export const __webpack_esm_id__=551;export const __webpack_esm_ids__=[551];export const __webpack_esm_modules__={424(e,t,r){r.d(t,{A:()=>p});var o=r(247),n=r(342);class a extends n.A{static config={className:"Neo.draggable.DragProxyComponent",ntype:"dragproxy",autoInitVnode:!0,autoMount:!0,baseCls:["neo-dragproxy"],moveInMainThread:!0};afterSetMounted(e,t){if(super.afterSetMounted(e,t),e&&this.moveInMainThread){let{appName:e,id:t,windowId:r}=this;Neo.main.addon.DragDrop.setDragProxyElement({appName:e,id:t,windowId:r})}}}const i=Neo.setupClass(a);var d=r(122);class l extends d.A{static config={className:"Neo.draggable.DragProxyContainer",ntype:"dragproxycontainer",autoInitVnode:!0,autoMount:!0,baseCls:["neo-dragproxy"],layout:"fit",moveInMainThread:!0};afterSetMounted(e,t){if(super.afterSetMounted(e,t),e&&this.moveInMainThread){let{appName:e,id:t,windowId:r}=this;Neo.main.addon.DragDrop.setDragProxyElement({appName:e,id:t,windowId:r})}}afterSetWindowId(e,t){super.afterSetWindowId(e,t),e&&Neo.currentWorker.insertThemeFiles(e,i.prototype)}destroy(...e){this.items=[],super.destroy(...e)}}const s=Neo.setupClass(l);var g=r(270),c=(r(691),r(825));class h extends o.A{static observable=!0;static config={className:"Neo.draggable.DragZone",ntype:"dragzone",addDragProxyCls:!0,allowOverdrag:!1,alwaysFireDragMove:!1,appName_:null,bodyCursorStyle:null,boundaryContainerId:null,boundaryContainerRect:null,data:null,dragElement:null,dragElementRect:null,dragProxy:null,dragProxyConfig_:null,dragProxyCls:"neo-dragproxy",dropZoneIdentifier:null,moveHorizontal:!0,moveInMainThread:!0,moveVertical:!0,offsetX:0,offsetY:0,owner:null,proxyParentId_:"document.body",scrollContainerId:null,scrollFactorLeft:1,scrollFactorTop:1,useProxyWrapper:!0,windowId_:null};construct(e){super.construct(e),Neo.main.addon.DragDrop||console.error("You can not use Neo.draggable.DragZone without adding Neo.main.addon.DragDrop to the main thread addons",this.id)}afterSetWindowId(e,t){e&&Neo.currentWorker.insertThemeFiles(e,this.__proto__)}beforeGetDragProxyConfig(e){return Neo.clone(e,!0,!0)}async createDragProxy(e,t=!0){let r,o,a=this,d=Neo.getComponent(a.getDragElementRoot().id)||a.owner,l=a.dragElementRect,h=a.dragProxyConfig||{},p=h.module===s,m=h.vdom,u=!p&&c.A.clone(m||a.dragElement);if(r={module:i,appName:a.appName,moveInMainThread:a.moveInMainThread,parentId:a.proxyParentId,windowId:a.windowId,...h},p?(r.height=`${e.height}px`,r.items=[],r.parentComponent=a.owner,r.width=`${e.width}px`,r.cls=r.cls||[],r.cls.push("neo-draggable")):(r.vdom=a.useProxyWrapper?{cn:[u]}:u,u.cls&&!a.useProxyWrapper&&(r.cls=r.cls||[],r.cls.push(...u.cls))),r.cls=r.cls||[],d&&r.cls.push(d.getTheme()),a.addDragProxyCls&&r.cls&&g.A.add(r.cls,a.dragProxyCls),r.style=r.style||{},Object.assign(r.style,{height:`${e.height}px`,left:`${a.moveHorizontal?e.x:l.x}px`,top:`${a.moveVertical?e.y:l.y}px`,width:`${e.width}px`}),t){if(p&&(r.autoInitVnode=!0,r.autoMount=!0),a.dragProxy=o=Neo.create(r),p){await o.mountedPromise,a.dragPlaceholder=Neo.create({module:n.A,flex:d.flex,style:{height:`${e.height}px`,visibility:"hidden",width:`${e.width}px`}}),d.minHeight&&(a.dragPlaceholder.minHeight=d.minHeight),d.minWidth&&(a.dragPlaceholder.minWidth=d.minWidth),a.dragStartIndex=a.owner.items.indexOf(d);const{vnode:t}=await Neo.vdom.Helper.create({vdom:a.dragPlaceholder.vdom});await Neo.applyDeltas(a.windowId,[{action:"insertNode",index:a.dragStartIndex,parentId:a.owner.getVdomItemsRoot().id,vnode:t},{action:"moveNode",id:d.id,index:0,parentId:o.id}]),a.dragPlaceholder.set({vnode:t,mounted:!0,vnodeInitialized:!0})}return o}return r}destroyDragProxy(){let e=this,t=e.dragProxy.id;e.timeout(e.moveInMainThread?0:30).then(()=>{Neo.applyDeltas(e.windowId,[{action:"removeNode",id:t}])}),e.dragProxy.destroy()}dragEnd(e){let t=this,{owner:r}=t,{cls:o}=r;g.A.remove(o,"neo-is-dragging"),r.cls=o,t.dragProxy&&(t.dragPlaceholder&&(t.dragPlaceholder.destroy(),t.dragPlaceholder=null),t.destroyDragProxy(),t.dragProxy=null),Object.assign(t,{dragElementRect:null,dragStartIndex:null,offsetX:0,offsetY:0,scrollContainerId:null}),t.fire("dragEnd",e),t.resetData()}dragMove(e,t=!1){let r,o=this;o.moveInMainThread&&!t||!o.dragProxy||(r=o.dragProxy.style,o.moveHorizontal&&(r.left=e.clientX-o.offsetX+"px"),o.moveVertical&&(r.top=e.clientY-o.offsetY+"px"),o.dragProxy.style=r),o.fire("dragMove",e)}async dragStart(e){let t,r,o,n=this,{appName:a,owner:i,windowId:d}=n,{cls:l}=i,s=n.getDragElementRect(e);n.setData(),t=await Neo.main.addon.DragDrop.setConfigs({appName:a,windowId:d,...n.getMainThreadConfigs()}),n.boundaryContainerRect=t.boundaryContainerRect,g.A.add(l,"neo-is-dragging"),i.cls=l,r=e.clientX-s.left,o=e.clientY-s.top,Object.assign(n,{dragElementRect:s,offsetX:r,offsetY:o}),await n.createDragProxy(s),n.fire("dragStart",{clientX:e.clientX,clientY:e.clientY,dragElementRect:s,eventData:e,id:n.id,offsetX:r,offsetY:o})}getDragElementRect(e){let t=this.getDragElementRoot().id;for(let r of e.path)if(r.id===t)return r.rect;for(let r of e.targetPath)if(r.id===t)return r.rect;return null}getDragElementRoot(){return this.dragElement}getMainThreadConfigs(){let e=this;return{allowOverdrag:e.allowOverdrag,alwaysFireDragMove:e.alwaysFireDragMove,bodyCursorStyle:e.bodyCursorStyle,boundaryContainerId:e.boundaryContainerId,dragElementRootId:e.getDragElementRoot().id,dragProxyCls:e.dragProxyCls,dragZoneId:e.id,dropZoneIdentifier:e.dropZoneIdentifier,moveHorizontal:e.moveHorizontal,moveVertical:e.moveVertical,scrollContainerId:e.scrollContainerId,scrollFactorLeft:e.scrollFactorLeft,scrollFactorTop:e.scrollFactorTop}}onDrop(e){this.fire("drop",e)}onDropEnter(e){this.fire("drop:enter",e)}onDropLeave(e){this.fire("drop:leave",e)}resetData(){this.timeout(50).then(()=>{this.data=null})}setData(e={}){let t=this;t.data={dragElement:t.getDragElementRoot(),dragZoneId:t.id,...e}}}const p=Neo.setupClass(h)},551(e,t,r){r.d(t,{default:()=>s}),r.r(t);var o=r(424),n=r(270),a=r(825);class i extends o.A{static config={className:"Neo.draggable.container.DragZone",ntype:"container-dragzone"};construct(e){super.construct(e);let t=this,{owner:r}=t,o={delegate:".neo-draggable",scope:t};r.addDomListeners([{"drag:end":t.onDragEnd,...o},{"drag:move":t.onDragMove,...o},{"drag:start":t.onDragStart,...o}]),r.on({insert:t.onItemInsert,itemsCreated:t.onItemsCreated,scope:t}),t.adjustItemCls(!0)}adjustItemCls(e){let t,{owner:r}=this;r.items.forEach(r=>{"string"!=typeof r&&(t=r.wrapperCls||[],n.A.toggle(t,"neo-draggable",e),r.wrapperCls=t)})}onDragEnd(e){if(this.owner.draggable){let e=this,t=e.dragProxy,r=t.cls||{},o=e.dragElementRect,a=t.wrapperStyle||{};n.A.add(r,"neo-animate"),t.cls=r,e.timeout(30).then(()=>{a.left=`${o.left}px`,a.top=`${o.top}px`,t.wrapperStyle=a,e.timeout(100).then(()=>{e.dragEnd()})})}}async onDragStart(e){let t=this;t.owner.draggable&&(t.dragElement=a.A.find(t.owner.vdom,e.path[0].id).vdom,await t.dragStart(e))}onItemInsert(e){let{item:t}=e,r=t.wrapperCls||[];n.A.add(r,"neo-draggable"),t.wrapperCls=r}onItemsCreated(e){this.adjustItemCls(!0)}}const d=Neo.setupClass(i);var l=r(406);const s=Neo.setupClass(class extends d{static config={className:"Neo.draggable.container.SortZone",ntype:"container-sortzone",adjustItemRectsToParent:!1,alwaysFireDragMove:!0,currentIndex:-1,detachThreshold:.8,dragHandleSelector:null,enableProxyToPopup:!1,indexMap:null,itemRects:null,itemStyles:null,lastIntersectionRatio:1,ownerRect:null,ownerStyle:null,reattachThreshold:.6,reversedLayoutDirection:!1,scrollLeft:0,scrollTop:0,sortDirection:"horizontal",startIndex:-1};isOverDragging=!1;isWindowDragging=!1;adjustItemCls(e){let t=this;if(t.dragHandleSelector){const r=t.dragHandleSelector.startsWith(".")?t.dragHandleSelector.substring(1):t.dragHandleSelector;t.owner.items.filter(e=>"string"!=typeof e&&a.A.find(e.vdom,{cls:r})).forEach(t=>{const r=t.wrapperCls||[];n.A.toggle(r,"neo-draggable",e),t.wrapperCls=r})}else super.adjustItemCls(e)}checkWindowBoundary(e){let t=this,{proxyRect:r}=e;if(r&&t.boundaryContainerRect){const o=t.boundaryContainerRect,n=l.A.getIntersection(r,o),a=r.width*r.height,i=n?n.width*n.height:0,d=a>0?i/a:0,s=d>t.lastIntersectionRatio,g=d<t.lastIntersectionRatio;if(t.lastIntersectionRatio=d,t.isWindowDragging){if(t.isWindowDragging)return s&&d>t.reattachThreshold?(t.dragPlaceholder.wrapperStyle={...t.dragPlaceholder.wrapperStyle,visibility:"visible"},t.itemRects.forEach((e,r)=>{let o=t.indexMap[r];if(-1!==o){let r=t.owner.items[o];r!==t.dragPlaceholder&&r!==t.dragComponent&&(r.wrapperStyle={...r.wrapperStyle,height:`${e.height}px`,left:`${e.left}px`,top:`${e.top}px`,width:`${e.width}px`})}}),t.fire("dragBoundaryEntry",{draggedItem:t.dragComponent,proxyRect:r,sortZone:t})):t.onWindowDragContinue(d,e),!0}else if(g&&d<t.detachThreshold)return t.isWindowDragging=!0,t.fire("dragBoundaryExit",{draggedItem:t.dragComponent,proxyRect:r,sortZone:t}),!0}return!1}getDragProxyConfig(){return{...this.dragProxyConfig,cls:[...this.owner.cls]}}moveTo(e,t){this.owner.moveTo(e,t)}async onDragEnd(e){let t,r=this,{itemStyles:o,owner:n}=r,a=n.style||{};if(await r.timeout(10),n.dragResortable){if(r.dragPlaceholder){const e=r.dragComponent,t=[],o=r.sortableItems.indexOf(r.dragPlaceholder);e&&o>-1&&(r.isWindowDragging||(!r.isRemoteDragging||r.isRemoteDragging&&!r.isWindowDragging)&&t.push({action:"moveNode",id:e.id,index:o,parentId:n.getVdomItemsRoot().id}),t.push({action:"removeNode",id:r.dragPlaceholder.id}),await Neo.applyDeltas(r.windowId,t))}if(a.height=r.ownerStyle.height||null,a.minWidth=r.ownerStyle.minWidth||null,a.width=r.ownerStyle.width||null,n.style=a,r.sortableItems?.forEach((e,n)=>{r.isWindowDragging&&e===r.dragComponent||(t=e.wrapperStyle||{},Object.assign(t,{height:o[n].height||null,left:null,margin:null,position:null,top:null,width:o[n].width||null}),n===r.startIndex&&(t.visibility=null),e.wrapperStyle=t)}),r.dragComponent){let e=r.dragComponent.wrapperStyle||{};e.visibility=null,r.dragComponent.wrapperStyle=e}if(!r.isWindowDragging&&!r.isRemoteDragging&&r.startIndex!==r.currentIndex){let e,t;if(r.dragPlaceholder){const o=r.dragComponent;e=r.owner.items.indexOf(o),t=r.owner.items.indexOf(r.sortableItems[r.currentIndex])}else e=r.owner.items.indexOf(r.sortableItems[r.startIndex]),t=r.owner.items.indexOf(r.sortableItems[r.currentIndex]);r.moveTo(e,t)}Object.assign(r,{currentIndex:-1,indexMap:null,isRemoteDragging:!1,isWindowDragging:!1,itemRects:null,itemStyles:null,ownerRect:null,startIndex:-1,sortableItems:null}),await r.timeout(30),r.dragEnd(e)}}async onDragMove(e){let t=this;if(!t.itemRects||t.isScrolling||!t.boundaryContainerRect)return;if(!t.isRemoteDragging&&t.dragProxy&&t.enableProxyToPopup&&t.checkWindowBoundary(e))return;let r,o,n,a,i,d,{clientX:l,clientY:s}=e,g=t.currentIndex,{itemRects:c}=t,h=c.length-1,p=t.adjustItemRectsToParent?t.ownerRect.x:0,m=t.adjustItemRectsToParent?t.ownerRect.y:0,u=t.reversedLayoutDirection;"horizontal"===t.sortDirection?(r=l-p+t.scrollLeft-t.offsetX-c[g].left,n=l>t.boundaryContainerRect.right,a=l<t.boundaryContainerRect.left,i="width"):(r=s-m+t.scrollTop-t.offsetY-c[g].top,n=s>t.boundaryContainerRect.bottom,a=s<t.boundaryContainerRect.top,i="height"),o=n||a,d=o?.02:.55,a?g>0&&(t.currentIndex--,await t.scrollToIndex(),t.switchItems(g,t.currentIndex)):n?g<h&&(t.currentIndex++,await t.scrollToIndex(),t.switchItems(g,t.currentIndex)):g>0&&(!u&&r<0||u&&r>0)?Math.abs(r)>c[g-1][i]*d&&(t.currentIndex--,t.switchItems(g,t.currentIndex)):g<h&&(!u&&r>0||u&&r<0)&&Math.abs(r)>c[g+1][i]*d&&(t.currentIndex++,t.switchItems(g,t.currentIndex)),t.isOverDragging=o&&0!==t.currentIndex&&t.currentIndex!==h,t.isOverDragging&&(await t.timeout(30),t.isOverDragging&&await t.onDragMove(e))}async onDragStart(e){let t,r,o,n,i,d,l=this,{adjustItemRectsToParent:s,dragHandleSelector:g,owner:c}=l,h=l.itemStyles=[],{layout:p}=c,m=c.style||{};if(c.dragResortable){if(g){const o=g.substring(1),n=e.path.find(e=>e.cls.includes(o));if(!n)return;for(let r=e.path.indexOf(n);r<e.path.length;r++){const o=e.path[r],n=Neo.getComponent(o.id);if(n&&c.items.includes(n)){t=n;break}}if(!t)return;if(d=c.items.filter(e=>a.A.find(e.vdom,{cls:g.startsWith(".")?g.substring(1):g})),r=d.indexOf(t),r<0)return}else t=Neo.getComponent(e.path[0].id),d=c.items,r=c.indexOf(t.id);o={},Object.assign(l,{currentIndex:r,dragElement:a.A.find(c.vdom,t.id).vdom,dragProxyConfig:l.getDragProxyConfig(),indexMap:o,lastIntersectionRatio:1,ownerStyle:{height:m.height,minWidth:m.minWidth,width:m.width},reversedLayoutDirection:"column-reverse"===p.direction||"row-reverse"===p.direction,sortableItems:d,sortDirection:p.direction?.includes("column")?"vertical":"horizontal",startIndex:r}),l.dragComponent=t,d.forEach((e,t)=>{o[t]=c.items.indexOf(e),h.push({height:e.height?`${e.height}px`:e.style?.height,width:e.width?`${e.width}px`:e.style?.width})});const u=await c.getDomRect([c.id].concat(d.map(e=>e.id)));if(l.ownerRect=u.shift(),u.length>0){const e=u[0],t=u[u.length-1];l.sortDirection,e.x>l.ownerRect.x&&(l.ownerRect.x=e.x),e.y>l.ownerRect.y&&(l.ownerRect.y=e.y),l.ownerRect.width=t.x+t.width-l.ownerRect.x,l.ownerRect.height=t.y+t.height-l.ownerRect.y}if(c.style={...m,height:`${l.ownerRect.height}px`,minWidth:`${l.ownerRect.width}px`,width:`${l.ownerRect.width}px`},s&&u.forEach(e=>{e.x-=l.ownerRect.x,e.y-=l.ownerRect.y}),l.itemRects=u,await l.dragStart(e),l.dragPlaceholder){const e=d.indexOf(t);e>-1&&(d[e]=l.dragPlaceholder),l.dragElement=l.dragPlaceholder.vdom}d.forEach((e,t)=>{n=e.wrapperStyle||{},i=l.itemRects[t],l.adjustProxyRectToParent?.(i,l.ownerRect),e.wrapperStyle=Object.assign(n,{height:`${i.height}px`,left:`${i.left}px`,margin:"0px",position:"absolute",top:`${i.top}px`,width:`${i.width}px`})}),await l.timeout(5),l.dragPlaceholder||(n=t.wrapperStyle||{},n.visibility="hidden",t.wrapperStyle=n)}}onWindowDragContinue(e,t){}async scrollToIndex(){let e=this;e.isScrolling=!0,await(e.owner.scrollToIndex?.(e.currentIndex,e.itemRects[e.currentIndex])),e.isScrolling=!1}switchItems(e,t){let r,o=this,n=o.reversedLayoutDirection;(!n&&t<e||n&&e<t)&&(r=e,e=t,t=r);let a=o.itemRects,i=o.indexMap,d=a[e],l=a[t],s=d.clone(),g=l.clone();if("horizontal"===o.sortDirection){const e=g.x-(s.x+s.width);d.width=g.width,l.x=s.x+g.width+e,l.width=s.width}else{const e=g.y-(s.y+s.height);d.height=g.height,l.height=s.height,l.y=s.y+g.height+e}r=i[e],i[e]=i[t],i[t]=r,o.updateItem(e,d),o.updateItem(t,l)}updateItem(e,t){let r,o=this,n=o.indexMap[e];if(-1===n){if(!o.dragPlaceholder)return;r=o.dragPlaceholder}else r=o.owner.items[n],o.dragPlaceholder&&r===o.dragComponent&&(r=o.dragPlaceholder);let{wrapperStyle:a}=r;a.left=`${t.left}px`,a.top=`${t.top}px`,r.wrapperStyle=a}})}};