"use strict";(self.webpackChunkneo_mjs=self.webpackChunkneo_mjs||[]).push([[96,666],{96:(e,s,t)=>{t.r(s),t.d(s,{default:()=>r});var a=t(583);class o extends a.A{static config={className:"Neo.main.addon.Base",isMainThreadAddon:!0,preloadFilesDelay:5e3};cache=[];get isLoading(){return!!this.#e&&!!this.#s}#e=null;#s=null;construct(e){super.construct(e);let s=this;if(s.#e=new Promise(e=>{s.#s=e}),!1===s.preloadFilesDelay)s.#s(),s.#s=null;else{const e=Neo.isNumber(s.preloadFilesDelay)?s.preloadFilesDelay:0;0===e?s.#t():s.timeout(e).then(()=>{s.#s&&s.#t()})}}async#t(){let e=this;if(e.#s){const s=e.#s;e.#s=null,await e.loadFiles(),s()}}async initAsync(){await super.initAsync(),await this.#e}afterSetIsReady(e,s){e&&this.#a()}cacheMethodCall(e){let s=this;return s.#s&&s.#t(),new Promise((t,a)=>{s.cache.push({...e,reject:a,resolve:t})})}async loadFiles(){}onInterceptRemotes(e){return this.cacheMethodCall({fn:e.remoteMethod,data:e.data})}async#a(){let e=this;for(const s of e.cache){let t;try{t=e[s.fn](s.data),Neo.isPromise(t)&&(t=await t),s.resolve(t)}catch(e){s.reject(e);break}}e.cache=[]}}const r=Neo.setupClass(o)},666:(e,s,t)=>{t.r(s),t.d(s,{default:()=>i});var a=t(96),o=t(160);class r extends a.default{static config={className:"Neo.main.addon.IntersectionObserver",remote:{app:["disconnect","observe","register"]}};map={};observeCache={};disconnect(e){this.map[e.id]?.disconnect()}findTopmostItem(e,s){let t,a,r,i,l=this;e.forEach(e=>{i=e.target,t=i.dataset&&{...i.dataset}||null,a=o.A.getPathFromElement(e.target).map(e=>o.A.getTargetData(e)),r=i.getBoundingClientRect(),r.y<200&&(e.isIntersecting,l.sendMessage({data:t,id:s.rootId,isIntersecting:!0,path:a,targetId:i.id}))})}isVisible(e,s){let t,a,r,i=this;e.forEach(e=>{r=e.target,t=r.dataset&&{...r.dataset}||null,a=o.A.getPathFromElement(e.target).map(e=>o.A.getTargetData(e)),e.isIntersecting&&i.sendMessage({data:t,id:s.rootId,isIntersecting:!0,path:a,targetId:r.id})})}observe(e){let s=!1,{id:t,observe:a}=e,{observeCache:o}=this,r=this.map[e.id],i=[];return Neo.isArray(a)||(a=[a]),a.forEach(e=>{i.push(...document.querySelectorAll(e))}),r?(e.disconnect&&r.disconnect(),i.forEach(e=>{r.observe(e)})):(s=!0,o[t]||(o[t]=[]),o[t].push(e)),{cached:s,countTargets:i.length}}register(e){let s,t=this,{observeCache:a}=t,{id:o,observe:r}=e,i=!0;return t.map[o]=s=new IntersectionObserver(t[e.callback].bind(t),{root:document.querySelector(e.root),rootMargin:e.rootMargin||"0px",threshold:e.threshold||0}),s.rootId=e.id,r&&(i=t.observe({id:o,observe:r})),a[o]&&(a[o].forEach(e=>t.observe(e)),delete a[o]),i}sendMessage(e){Neo.worker.Manager.sendMessage("app",{action:"domEvent",eventName:"intersect",data:e})}}const i=Neo.setupClass(r)}}]);