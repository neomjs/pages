"use strict";(self.webpackChunkneo_mjs=self.webpackChunkneo_mjs||[]).push([[7371],{1918:(e,n,o)=>{o.d(n,{pM:()=>C,UK:()=>b,_q:()=>E});var t=o(2583),s=o(293),i=o(6693),r=o(3799),c=o(6270),d=o(5691),l=o(9610);const a=Symbol.for("activeDomListeners"),m=Symbol.for("hookIndex"),p=Symbol.for("hooks"),u=Symbol.for("pendingDomEvents"),f=Symbol("vdomToApply");class h extends t.A{static config={className:"Neo.functional.component.Base",ntype:"functional-component",cls:null,mixins:[i.A,d.A,l.A],mounted_:!1,parentId_:null,vdom:{},windowId_:null};childComponents=null;isAwaitingMount=!1;#e=null;get mountedPromise(){let e=this;return e._mountedPromise||(e._mountedPromise=new Promise(n=>{e.mounted?n(e):e.mountedPromiseResolve=n})),e._mountedPromise}get parent(){let e=this;return e.parentComponent||("document.body"===e.parentId?null:Neo.getComponent(e.parentId))}construct(e){super.construct(e);let n=this,o={configurable:!0,enumerable:!1,writable:!0};Object.defineProperties(n,{[a]:{...o,value:[]},[m]:{...o,value:0},[p]:{...o,value:[]},[u]:{...o,value:[]},[f]:{...o,value:null}}),n.vdomEffect=new r.A({fn:()=>{n[m]=0,n[u]=[],n[f]=n.createVdom(n,n.data)},componentId:n.id,subscriber:{id:n.id,fn:n.onEffectRunStateChange,scope:n}})}afterSetId(e,n){super.afterSetId(e,n),n&&s.A.unregister(n),e&&s.A.register(this)}afterSetMounted(e,n){if(void 0!==n){const n=this;e?(n.initDomEvents(),n.applyPendingDomListeners(),n.mountedPromiseResolve?.(this),delete n.mountedPromiseResolve):delete n._mountedPromise}}afterSetWindowId(e,n){const o=this;e&&Neo.currentWorker.insertThemeFiles(e,o.__proto__),o.childComponents?.forEach(n=>{n.instance.windowId=e}),n&&(o.isVdomUpdating=!1)}applyPendingDomListeners(){const e=this,n=e[a],o=e[u];o.length>0&&(Neo.isEqual(n,o)||(n?.length>0&&e.removeDomListeners(e[a]),e.addDomListeners([...o]),e[a]=[...o]),e[u]=[])}createVdom(e,n){return{}}destroy(){const e=this;e.vdomEffect?.destroy(),e.childComponents?.forEach(e=>{e.instance.destroy()}),e.childComponents?.clear(),e.removeDomEvents(),e[u]=null,s.A.unregister(e),super.destroy()}diffAndSet(e,n,o){const t={};for(const s in n){const i=n[s],r=o[s];Neo.isEqual(i,r)||("Object"===Neo.typeOf(i)&&"NeoInstance"===Neo.typeOf(e[s])?this.diffAndSet(e[s],i,r||{}):t[s]=i)}Object.keys(t).length>0&&e.set(t)}onEffectRunStateChange(e,n){if(!1===e){const e=this,n=e[f];if(n){e.#e=new Map;const o=e.processVdomForComponents(n,e.id);e.childComponents?.size>0&&[...e.childComponents].forEach(([n,o])=>{e.#e.has(n)||(e.childComponents.delete(n),o.instance.destroy())});const t=e.childComponents?new Set(e.childComponents.keys()):new Set;let s=!1;for(const n of e.#e.keys())if(!t.has(n)){s=!0;break}s&&(e.updateDepth=-1),e.childComponents=e.#e;for(const n in e.vdom)delete e.vdom[n];Object.assign(e.vdom,o),e[f]=null;const i=e.getVdomRoot();e.cls&&(i.cls=c.A.union(e.cls,i.cls)),e.id&&(i.id=e.id),e.updateVdom(),e.mounted&&e.applyPendingDomListeners()}}}processVdomForComponents(e,n,o){if(!e)return e;if(e.componentId)return e;const t=this;if(e.className||e.module||e.ntype){const s=e.id;s||console.error(['Component definition in functional component VDOM is missing an "id". For stable reconciliation, ','especially in dynamic lists, provide a unique "id" property.'].join(""),e);let i,r=t.childComponents?.get(s),c={...e};return delete c.className,delete c.id,delete c.module,delete c.ntype,r?(i=r.instance,this.diffAndSet(i,c,r.lastConfig)):(t.childComponents??=new Map,i=Neo[e.className||e.module?"create":"ntype"]({...e,parentId:n,parentIndex:o,windowId:t.windowId})),t.#e.set(s,{instance:i,lastConfig:c}),i.createVdomReference()}return e.cn&&Array.isArray(e.cn)&&(e.cn=e.cn.map((e,o)=>t.processVdomForComponents(e,n,o))),e}set(e={},n=!1){let o=this;return o.silentVdomUpdate=!0,super.set(e),o.silentVdomUpdate=!1,n||!o.needsVdomUpdate?Promise.resolve():o.promiseUpdate()}}const y=Neo.setupClass(h),C=function(e){const n=e.config;if(delete e.config,!n?.className)throw new Error("defineComponent requires a config object with a className.");class o extends y{static config={...n}}return Object.entries(e).forEach(([e,n])=>{o.prototype[e]=n}),o=Neo.setupClass(o)};var g=o(9750),w=o(4304);const A=Symbol.for("hookIndex"),v=Symbol.for("hooks"),b=function(e){w.A.pause();const n=w.A.getActiveEffect(),o=n&&Neo.getComponent(n.componentId);if(!o)throw new Error("useConfig must be called from within a functional component's createVdom method.");const t=o[A];if(o[A]++,!o[v][t]){const n=new g.A(e),s=e=>{"function"==typeof e&&(e=e(n.get())),n.set(e)};o[v][t]=[n,s]}const[s,i]=o[v][t];return w.A.resume(),[s.get(),i]},N=Symbol.for("pendingDomEvents"),E=function(e,n,o){const t=w.A.getActiveEffect(),s=t?.componentId;if(!s)throw new Error("useEvent must be called from within a functional component's createVdom method.");w.A.pause();const i=Neo.getComponent(s);if(w.A.resume(),!i)throw new Error(`Component with id ${s} not found for useEvent hook.`);i[N]??=[],i[N].push({[e]:n,delegate:o,scope:i})}},2930:(e,n,o)=>{o.d(n,{A:()=>i});var t=o(3079);class s extends t.A{static config={className:"Neo.container.Viewport",ntype:"viewport",applyBodyCls:!0,autoMount:!0,baseCls:["neo-viewport"],monitorSize_:!1};afterSetMounted(e,n){super.afterSetMounted(e,n);let o=this;e&&o.monitorSize&&o.addDomListeners([{resize:o.onDomResize,scope:o}])}onConstructed(){super.onConstructed();let{appName:e,windowId:n}=this;this.applyBodyCls&&Neo.main.DomAccess.applyBodyCls({appName:e,cls:["neo-body-viewport"],windowId:n})}onDomResize(e){this.fire("resize",e)}}const i=Neo.setupClass(s)},3799:(e,n,o)=>{o.d(n,{A:()=>d});var t=o(9750),s=o(4304),i=o(3234),r=o(358);class c{componentId=null;dependencies=new Map;_fn=null;id=r.A.getId("effect");isDestroyed=!1;isRunning=null;get fn(){return this._fn}set fn(e){this._fn=e,this.run()}constructor(e,n={}){const o=this,{fn:s,componentId:i,lazy:r=!1,subscriber:c}="function"==typeof e?{...n,fn:e}:e||{};i&&(o.componentId=i),o.isRunning=new t.A(!1),c&&[].concat(c).forEach(e=>o.isRunning.subscribe(e)),r?o._fn=s:o.fn=s}destroy(){const e=this;e.dependencies.forEach(e=>e()),e.dependencies.clear(),e.isDestroyed=!0}run(){const e=this;if(s.A.pause(),e.isDestroyed||e.isRunning.get())s.A.resume();else if(i.A.isBatchActive())i.A.queueEffect(e);else{e.isRunning.set(!0),e.dependencies.forEach(e=>e()),e.dependencies.clear(),s.A.push(e),s.A.resume();try{e.fn()}finally{s.A.pop(),s.A.pause(),e.isRunning.set(!1),s.A.resume()}}}addDependency(e){const n=this;if(!n.dependencies.has(e)){const o=e.subscribe({id:n.id,fn:n.run.bind(n)});n.dependencies.set(e,o)}}}Neo.core??={},Neo.core.Effect||(Neo.core.Effect=c,Neo.effect=(e,n)=>new c(e,n));const d=Neo.core.Effect}}]);