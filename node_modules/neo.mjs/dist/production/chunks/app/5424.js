export const __webpack_esm_id__=5424;export const __webpack_esm_ids__=[5424];export const __webpack_esm_modules__={5424(e,t,s){s.d(t,{A:()=>r});var a=s(1741);class i extends a.A{static config={className:"Neo.component.MagicMoveText",ntype:"magic-move-text",autoCycle_:!0,autoCycleInterval_:2e3,baseCls:["neo-magic-move-text"],colorMove:null,colorFadeIn:null,colorFadeOut:null,cycleTexts:null,fontFamily_:"Helvetica Neue",transitionTime_:500,renderSeoList_:!1,_vdom:{style:{},cn:[{ariaHidden:!0,cn:[{cls:["neo-content"],cn:[]},{cls:["neo-measure-element-wrapper"],removeDom:!0,cn:[{cls:["neo-measure-element"],cn:[]}]}]}]}};chars=[];charsVdom=[];contentHeight=0;contentWidth=0;currentIndex=0;initialResizeEvent=!0;intervalId=null;isRetrying=!1;isTransitioning=!1;previousChars=[];get measureElement(){return this.measureWrapper.cn[0]}get measureWrapper(){return this.vdom.cn[0].cn[1]}get visualWrapper(){return this.vdom.cn[0].cn[0]}construct(e){super.construct(e);let t=this;t.addDomListeners({resize:t.onResize,scope:t}),t.app?.on("visibilitychange",t.onVisibilityChange,t)}async addResizeObserver(e){let{id:t,windowId:s}=this;(await Neo.currentWorker.getAddon("ResizeObserver",s))[e?"register":"unregister"]({id:t,windowId:s}),e&&(this.initialResizeEvent=!0)}afterSetAutoCycle(e,t){this.mounted&&this.startAutoCycle(e)}afterSetAutoCycleInterval(e,t){let s=this;t&&s.mounted&&(s.startAutoCycle(!1),s.startAutoCycle())}afterSetFontFamily(e,t){this.vdom.style.fontFamily=e,this.update()}afterSetMounted(e,t){super.afterSetMounted(e,t);let s=this;e?s.getDomRect().then(e=>{s.contentHeight=e.height,s.contentWidth=e.width}):s.previousChars=[],void 0!==t&&(s.addResizeObserver(e),s.autoCycle&&s.startAutoCycle(e))}async afterSetText(e,t){let s=this,{measureElement:a}=s;if(t&&(s.previousChars=s.chars),e){try{if(s.chars=[],a.cn=[],e?.split("").forEach(e=>{s.chars.push({name:e}),a.cn.push({tag:"span",text:e})}),s.mounted&&await s.measureChars(),s.isDestroyed)return;await s.updateChars()}catch(a){if(a===Neo.isDestroyed)return;s.isRetrying||(s.isRetrying=!0,s.previousChars=[],s.visualWrapper.cn.length=0,await s.afterSetText(e,t))}s.isRetrying=!1}}afterSetRenderSeoList(e,t){let s=this;e?s.vdom.cn[1]||(s.vdom.cn.push({tag:"ul",cls:["neo-seo-list"],cn:s.cycleTexts?.map(e=>({tag:"li",text:e}))||[]}),s.update()):s.vdom.cn[1]&&s.vdom.cn[1].cls.includes("neo-seo-list")&&(s.vdom.cn.pop(),s.update())}afterSetTransitionTime(e,t){this.vdom.style["--neo-transition-time"]=e+"ms",this.update()}createCharsVdom(e){let t,s=this,{chars:a}=s,i=[];return e.forEach((e,r)=>{null!==e&&(t=a[r],i.push({cls:["neo-char"],style:{color:s.colorFadeIn,left:t.left,opacity:0,top:t.top},text:t.name}))}),i}cycleText(){let e=this;e.text=e.cycleTexts[e.currentIndex],e.currentIndex=(e.currentIndex+1)%e.cycleTexts.length}async measureChars(){let e,t,s,a=this,{measureElement:i,measureWrapper:r}=a;if(r.style={height:a.contentHeight+"px",width:a.contentWidth+"px"},delete r.removeDom,await a.promiseUpdate(),!a.isDestroyed&&(await a.timeout(20),t=await a.getDomRect([a.id,r.id,...i.cn.map(e=>e.id)]),!a.isDestroyed)){if(s=t.shift(),e=t.shift(),s.width>0&&(Math.abs(s.width-a.contentWidth)>2||Math.abs(s.height-a.contentHeight)>2))return a.contentWidth=s.width,a.contentHeight=s.height,a.measureChars();t.length===a.chars.length&&(t.forEach((t,s)=>{a.chars[s].left=t.left-e.left+"px",a.chars[s].top=t.top-e.top+"px"}),await a.promiseUpdate())}}async onResize({rect:e}){let t=this;t.contentHeight=e.height,t.contentWidth=e.width,t.initialResizeEvent?t.initialResizeEvent=!1:t.isTransitioning||(await t.measureChars(),t.charsVdom=t.createCharsVdom(t.chars.map(e=>e.name)))}onVisibilityChange(e){let t=this;t.autoCycle&&(e.hidden?t.startAutoCycle(!1):(t.isRetrying=!1,t.previousChars=[],t.startAutoCycle()))}sortCharacters(e,t){let s=parseFloat(e.style.top)-parseFloat(t.style.top);return 0!==s?s:parseFloat(e.style.left)-parseFloat(t.style.left)}startAutoCycle(e=!0){let t=this;e?(t.intervalId=setInterval(t.cycleText.bind(t),t.autoCycleInterval),t.timeout(20).then(()=>{t.cycleText()})):clearInterval(t.intervalId)}async updateChars(){let e,t,s=this,{chars:a,previousChars:i}=s,r=s.visualWrapper,n=a.map(e=>e.name);if(s.isTransitioning=!0,!(s.charsVdom.length>1&&(r.cn=s.charsVdom,await s.promiseUpdate(),s.isDestroyed)||(i.forEach((i,o)=>{t=n.indexOf(i.name),t>-1?(e=r.cn[o],Object.assign(e.style,{color:s.colorMove,left:a[t].left,top:a[t].top}),n[t]=null):(e=r.cn[o],e.flag="remove")}),r.cn.push(...s.createCharsVdom(n)),await s.promiseUpdate(),s.isDestroyed||(r.cn.forEach(e=>{"remove"===e.flag?(e.style.color=s.colorFadeOut,e.style.opacity=0):delete e.style.opacity}),await s.promiseUpdate(),s.isDestroyed)))){for(await s.timeout(s.transitionTime),r.cn.sort(s.sortCharacters),t=r.cn.length-1;t>=0;t--)e=r.cn[t],delete e.flag,delete e.style.color,0===e.style.opacity&&r.cn.splice(t,1);await s.promiseUpdate(),s.isDestroyed||(await s.timeout(200),s.charsVdom=[...r.cn],s.isTransitioning=!1)}}}const r=Neo.setupClass(i)}};