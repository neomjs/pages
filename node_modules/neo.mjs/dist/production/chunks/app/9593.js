"use strict";(self.webpackChunkneo_mjs=self.webpackChunkneo_mjs||[]).push([[9593],{9593(e,s,t){t.r(s),t.d(s,{default:()=>i});var o=t(3572),n=t(5023),c=t(9932);t(4556);class r extends o.A{static observable=!0;static config={className:"Neo.data.connection.WebSocket",ntype:"socket-connection",socket_:null};channel=null;maxReconnectAttempts=5;messageCallbacks={};messageId=1;reconnectAttempts=0;serverAddress=null;construct(e){super.construct(e),this.createSocket()}attemptReconnect(e,s){let t=this;t.reconnectAttempts++,t.reconnectAttempts<t.maxReconnectAttempts&&(t.createSocket(),e&&t.on("open",{callback:e,scope:s||t,single:!0}))}beforeSend(e){let{channel:s}=this;return JSON.stringify(s?{channel:s,data:e}:e)}beforeSetSocket(e,s){if(e){let s=this;Object.assign(e,{onclose:s.onClose.bind(s),onerror:s.onError.bind(s),onmessage:s.onMessage.bind(s),onopen:s.onOpen.bind(s)}),(0,c.iI)(e,"send",s.beforeSend,s)}return e}close(e,s){this.socket.close(e,s)}createSocket(){this.socket=new WebSocket(this.serverAddress)}destroy(...e){this.close(),super.destroy(...e)}onClose(e,s,t){this.fire("close",{event:e,reason:s,wasClean:t})}onError(e){this.fire("error",{error:e})}onMessage(e){let s=this,t=JSON.parse(e.data);s.fire("message",{data:t}),t.mId&&(s.messageCallbacks[t.mId].resolve(t.data),delete s.messageCallbacks[t.mId])}onOpen(){this.fire("open",{scope:this})}promiseMessage(e){let s=this;return new Promise((t,o)=>{s.messageCallbacks[s.messageId]={reject:o,resolve:t},s.sendMessage({data:e,mId:s.messageId}),s.messageId++})}sendMessage(e){let s=this,{socket:t}=s,o=e;switch(t.readyState){case WebSocket.CLOSED:case WebSocket.CLOSING:s.attemptReconnect(function(){s.sendMessage(o)});break;case WebSocket.CONNECTING:s.on("open",function(){s.sendMessage(o)},s,{once:!0});break;case WebSocket.OPEN:t.send(e)}}}const a=Neo.setupClass(r);class l extends o.A{static config={className:"Neo.ai.Client",singleton:!0,socketConfig:null,url:"ws://localhost:8081"};isConnected=!1;socket=null;construct(e){super.construct(e),this.connect()}connect(){let e=this;e.socket=n.A.beforeSetInstance(e.socketConfig,a,{serverAddress:e.url,listeners:{close:e.onSocketClose,error:e.onSocketError,message:e.onSocketMessage,open:e.onSocketOpen,scope:e}})}async onSocketMessage({data:e}){try{if(e.method){const s=await this.handleRequest(e.method,e.params);this.sendResponse(e.id,s)}}catch(e){console.error("Neo.ai.Client: Failed to handle message",e)}}onSocketOpen(e){console.log("Neo.ai.Client: Connected to MCP Server"),this.isConnected=!0}onSocketClose(e){console.log("Neo.ai.Client: Disconnected"),this.isConnected=!1}onSocketError(e){console.error("Neo.ai.Client: WebSocket Error",e)}async handleRequest(e,s){switch(e){case"reload_page":return Neo.Main.reloadWindow(),{status:"reloading"};case"get_component_tree":return{root:"viewport"};case"get_component_property":return{value:null};case"set_component_property":return{success:!0};default:throw new Error(`Unknown method: ${e}`)}}sendResponse(e,s){this.isConnected&&this.socket.sendMessage(JSON.stringify({jsonrpc:"2.0",id:e,result:s}))}}const i=Neo.setupClass(l)}}]);