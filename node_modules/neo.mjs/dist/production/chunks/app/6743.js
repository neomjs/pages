"use strict";(self.webpackChunkneo_mjs=self.webpackChunkneo_mjs||[]).push([[6743],{6743:(t,e,i)=>{i.d(e,{A:()=>u});const n=Object.freeze([]),h=(t=0)=>{switch(Array.isArray(t)||(t=[t]),t.length){case 1:return t.length=4,t.fill(t[0],1,4);case 2:return[t[0],t[1],t[0],t[1]];case 3:return[t[0],t[1],t[2],t[1]]}return t},o=t=>{const e=s[t.ourEdge],i=s[t.theirEdge];return`${e}${t.ourEdgeOffset}${t.ourEdgeUnit}-${i}${t.theirEdgeOffset}${t.theirEdgeUnit}`},r=t=>{const e=t instanceof DOMRect?t:(1===t?.nodeType?t:"string"==typeof t?document.getElementById(t):null)?.getBoundingClientRect();return e&&new u(e.x,e.y,e.width,e.height)},s={t:"b",r:"l",b:"t",l:"r"},g={t:0,r:1,b:2,l:3},c=["top","right","bottom","left"],a=["t","r","b","l"],l=["width","height"],d=[0,0,0,0],m=/^([trblc])(\d*)(%|px)?-([trblc])(\d*)(%|px)?$/;class u extends DOMRect{static config={className:"Neo.util.Rectangle"};minHeight=null;minWidth=null;static excludes(t,e){return t.bottom<e.top||t.left>e.right||t.right<e.left||t.top>e.bottom}static getIntersection(t,e){let i=Math.max(t.x,e.x),n=Math.max(t.y,e.y),h=Math.min(t.right,e.right),o=Math.min(t.bottom,e.bottom),r=Math.max(0,h-i),s=Math.max(0,o-n);return s<1||r<1?null:new u(i,n,r,s)}static includes(t,e){return t.bottom>=e.bottom&&t.left<=e.left&&t.right>=e.right&&t.top<=e.top}static leavesSide(t,e,i){return!u.includes(t,e)&&("bottom"===i?t.bottom<e.bottom:"left"===i?t.left>e.left:"right"===i?t.right<e.right:"top"===i?t.top>e.top:void 0)}static moveBy(t,e=null,i=null){let n={...t};return Neo.isNumber(e)&&(n.left+=e,n.right+=e,n.x+=e),Neo.isNumber(i)&&(n.bottom+=i,n.top+=i,n.y+=i),n}static moveTo(t,e=null,i=null){let n={...t};return Neo.isNumber(e)&&(n.left=e,n.right=e+n.width,n.x=e),Neo.isNumber(i)&&(n.bottom=i+n.height,n.top=i,n.y=i),n}set bottom(t){this.height+=t-this.bottom}get bottom(){return super.bottom}set right(t){this.width+=t-this.right}get right(){return super.right}changeX(t){const e=this.x-t;this.x=t,this.width+=e}changeY(t){const e=this.y-t;this.y=t,this.height+=e}clone(){return u.clone(this)}static clone(t){const e=new u(t.x,t.y,t.width,t.height);return e.minWidth=t.minWidth,e.minHeight=t.minHeight,e}intersects(t){const e=this;if(t.height&&t.width){const i=Math.max(e.x,t.x),n=Math.max(e.y,t.y),h=Math.min(e.x+e.width,t.x+t.width),o=Math.min(e.y+e.height,t.y+t.height);return!(i>=h||n>=o)&&new u(i,n,h-i,o-n)}return t.x>=e.x&&t.y>=e.y&&t.right<=e.right&&t.bottom<=e.bottom}expand(t){return t=h(t),new this.constructor(this.x-t[3],this.y-t[0],this.width+t[1]+t[3],this.height+t[0]+t[2])}moveBy(t=0,e=0){const i=this.clone();return Array.isArray(t)&&(e=t[1],t=t[0]),i.x+=t,i.y+=e,i}contains(t){return u.includes(this,t)}constrainTo(t){const e=this,i=e.minWidth||e.width;if((e.minHeight||e.height)>t.height||i>t.width)return!1;const n=e.clone();return n.x=Math.max(e.x+Math.min(t.right-n.right,0),t.x),n.y=Math.max(e.y+Math.min(t.bottom-n.bottom,0),t.y),n.bottom=Math.min(n.bottom,t.bottom),n.right=Math.min(n.right,t.right),n}alignTo(t){const e=this,{constrainTo:i,target:n,edgeAlign:u,axisLock:b,offset:x,matchSize:f}=t,y=t.targetMargin?h(t.targetMargin):d,p=r(n),w=r(i),E=(t=>{const e=m.exec(t),i=g[e[1]],n=g[e[4]];return{ourEdge:e[1],ourEdgeOffset:parseInt(e[2]||50),ourEdgeUnit:e[3]||"%",ourEdgeZone:i,theirEdge:e[4],theirEdgeOffset:parseInt(e[5]||50),theirEdgeUnit:e[6]||"%",theirEdgeZone:n,edgeAligned:(1&i)==(1&n)&&i!==n}})(u),M=l[1&E.theirEdgeZone];let $=e.clone();f&&($[M]=p[M]);const A=$.getAnchorPoint(E.ourEdgeZone,E.ourEdgeOffset,E.ourEdgeUnit),k=p.getAnchorPoint(E.theirEdgeZone,E.theirEdgeOffset,E.theirEdgeUnit,y),z=[k[0]-A[0],k[1]-A[1]];if($=$.moveBy(z),$.zone=E.theirEdgeZone,$.position=c[$.zone],w&&!w.contains($)){if(p.intersects($))return $;let t=E.theirEdgeZone;const i=[{zone:t,edgeAlign:u}];if(b)i[1]={zone:t=(t+2)%4,edgeAlign:o(E)},i.push({zone:t=(E.theirEdgeZone+1)%4,edgeAlign:`${s[a[t]]}-${a[t]}`}),i.push({zone:t=(E.theirEdgeZone+3)%4,edgeAlign:`${s[a[t]]}-${a[t]}`});else for(let e=1;e<4;e++)i.push({zone:t=(t+1)%4,edgeAlign:`${s[a[t]]}-${a[t]}`});for(let t=0;t<i.length;t++){const e=w.clone();switch(i[t].zone){case 0:e.bottom=p.y-y[0];break;case 1:e.changeX(p.right+y[1]);break;case 2:e.changeY(p.bottom+y[2]);break;case 3:e.right=p.x-y[3]}i[t].constrainRect=e}for(let t=0;t<i.length;t++){const{zone:n,edgeAlign:h,constrainRect:o}=i[t],r=a[n];f&&($[M]=r===E.theirEdge||r==s[E.theirEdge]?p[M]:e[M]),$=$.alignTo({target:p,edgeAlign:h,targetMargin:y});let g=$.constrainTo(o);if(g)return g.zone=n,g.position=c[n],g}}return x&&$.moveBy(x),$}getAnchorPoint(t,e,i,h=n){const o=this;let r;switch(t){case 0:r=[o.x,o.y-(h[0]||0),o.width,0];break;case 1:r=[o.x+o.width+(h[1]||0),o.y,o.height,1];break;case 2:r=[o.x,o.y+o.height+(h[2]||0),o.width,0];break;case 3:r=[o.x-(h[3]||0),o.y,o.height,1]}return r[r[3]]+="%"===i?r[2]/100*e:e,r.length=2,r}equals(t){return t instanceof DOMRect&&t.x===this.x&&t.y===this.y&&t.height===this.height&&t.width===this.width}show(t="red"){const e=document.createElement("div");return e.style=`\n            position:absolute;\n            transform:translate3d(${this.x}px, ${this.y}px, 0);\n            height:${this.height}px;\n            width:${this.width}px;\n            background-color:${t}\n        `,document.body.appendChild(e),setTimeout(()=>e.remove(),3e4),e}toJSON(){const{bottom:t,height:e,left:i,minHeight:n,minWidth:h,right:o,top:r,width:s,x:g,y:c}=this;return{bottom:t,height:e,left:i,minHeight:n,minWidth:h,right:o,top:r,width:s,x:g,y:c}}}}}]);