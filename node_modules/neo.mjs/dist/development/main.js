/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/DefaultConfig.mjs":
/*!*******************************!*\
  !*** ./src/DefaultConfig.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const Neo = globalThis.Neo || {};

Neo.config = Neo.config || {};

/**
 * Config object for the neo.mjs framework which will get passed to all workers
 * You can change the configs, e.g. inside the index.html of your app
 * @memberOf module:Neo
 * @name config
 * @type Object
 */
const DefaultConfig = {
    /**
     * true will apply 'neo-body' to the document.body classList
     * @default true
     * @memberOf! module:Neo
     * @name config.applyBodyCls
     * @type Boolean
     */
    applyBodyCls: true,
    /**
     * true will apply 'position: fixed' to the html tag itself
     * See: https://github.com/neomjs/neo/issues/6429
     * @default true
     * @memberOf! module:Neo
     * @name config.applyFixedPositionToHtmlTag
     * @type Boolean
     */
    applyFixedPositionToHtmlTag: true,
    /**
     * Path to your app.mjs file. You can create multiple apps there if needed.
     * @default null
     * @memberOf! module:Neo
     * @name config.appPath
     * @type String|null
     */
    appPath: null,
    /**
     * Path to the neo.mjs directory
     * @default './'
     * @memberOf! module:Neo
     * @name config.basePath
     * @type String
     */
    basePath: './',
    /**
     * Pass a token in case you are using the CesiumJS main thread addon
     * See: https://github.com/neomjs/neo/blob/dev/src/main/addon/CesiumJS.mjs
     * @default undefined
     * @memberOf! module:Neo
     * @name config.cesiumJsToken
     * @type String|null
     */

    /**
     * Set this config to false to disable the component logging using Ctrl-Right-Click
     * @default true
     * @memberOf! module:Neo
     * @name config.enableComponentLogger
     * @type Boolean
     */
    enableComponentLogger: true,
    /**
     * Set this config to true to enable util.Logger (Neo.log()) based logs in production
     * @default false
     * @memberOf! module:Neo
     * @name config.enableLogsInProduction
     * @type Boolean
     */
    enableLogsInProduction: false,
    /**
     * The current environment. Valid values: 'development', 'dist/development', 'dist/production'
     * This config will get auto-generated
     * @default 'dist/production'
     * @memberOf! module:Neo
     * @name config.environment
     * @type String
     */
    environment: 'dist/production',
    /**
     * In case you are using the GoogleMaps main thread addon, you can pass the API key here.
     * @default undefined
     * @memberOf! module:Neo
     * @name config.googleMapsApiKey
     * @type String
     */

    /**
     * In case you are using the GoogleAnalytics main thread addon or useGoogleAnalytics: true,
     * you can change the gtag id here. Required for the online examples (gh pages)
     * @default undefined
     * @memberOf! module:Neo
     * @name config.gtagId
     * @type String
     */

    /**
     * Flag for running on https://neomjs.github.io/pages/
     * => to use local images paths instead of raw.githubusercontent.com
     * @default false
     * @memberOf! module:Neo
     * @name config.isGitHubPages
     * @type Boolean
     */
    isGitHubPages: true,
    /**
     * Flag for running the Neo main thread inside an iframe (Siesta Browser Harness)
     * @default false
     * @memberOf! module:Neo
     * @name config.isInsideSiesta
     * @type Boolean
     */
    isInsideSiesta: false,
    /**
     * delay in ms for the worker.Manager:loadApplication() call
     * @default 20
     * @memberOf! module:Neo
     * @name config.loadApplicationDelay
     * @type Number
     */
    loadApplicationDelay: 20,
    /**
     * Used by Intl.DateTimeFormat, for details take a look at:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @default 'default'
     * @memberOf! module:Neo
     * @name config.locale
     * @type String
     */
    locale: 'default',
    /**
     * true will log the delta updates inside the main thread(s) as well as the requestAnimation frames
     * @default false
     * @memberOf! module:Neo
     * @name config.logDeltaUpdates
     * @type Boolean
     */
    logDeltaUpdates: false,
    /**
     * true will log console warnings, in case a component tries to update() while a parent update is running.
     * A parent update results in a short delay, so you might want to resolve these collisions.
     * @default false
     * @memberOf! module:Neo
     * @name config.logVdomUpdateCollisions
     * @type Boolean
     */
    logVdomUpdateCollisions: false,
    /**
     * Add addons for the main thread
     * ./src/main/addon/ contains all framework related options.
     * You can also create your own addons within your workspace scope. Make sure to put them inside 'src/main/addon/'
     * and prefix them with 'WS/' inside your neo-config.json file.
     * Example: ['DragDrop', 'Stylesheet', 'WS/MyAddon']
     * @default ['DragDrop', 'Navigator', 'Stylesheet']
     * @memberOf! module:Neo
     * @name config.mainThreadAddons
     * @type String[]
     */
    mainThreadAddons: ['DragDrop', 'Navigator', 'Stylesheet'],
    /**
     * Pass the URL of a JSON-file, which contains the services and methods from your backend,
     * which you want to expose to the client.
     * See: https://github.com/neomjs/neo/projects/32
     * @default null
     * @memberOf! module:Neo
     * @name config.remotesApiUrl
     * @type String|null
     */
    remotesApiUrl: null,
    /**
     * You can visually show the amount of delta updates per second using this config.
     * It expects a dom node with the id "neo-delta-updates" as the rendering target.
     * @default false
     * @memberOf! module:Neo
     * @name config.renderCountDeltas
     * @type Boolean
     */
    renderCountDeltas: false,
    /**
     * Add themes you want to use here. The first theme will get applied.
     * @default ['neo-theme-light','neo-theme-dark','neo-theme-neo-light']
     * @memberOf! module:Neo
     * @name config.themes
     * @type String[]
     */
    themes: ['neo-theme-light', 'neo-theme-dark', 'neo-theme-neo-light'],
    /**
     * Flag for standalone Siesta module tests => prevent registerRemote worker messages
     * @default false
     * @memberOf! module:Neo
     * @name config.unitTestMode
     * @type Boolean
     */
    unitTestMode: false,
    /**
     * Experimental flag if an offscreen canvas worker should get created.
     * @default false
     * @memberOf! module:Neo
     * @name config.useCanvasWorker
     * @type Boolean
     */
    useCanvasWorker: false,
    /**
     * Flag if vdom ids should get mapped into DOM element ids.
     * false will convert them into a "data-neo-id" attribute.
     * @default true
     * @memberOf! module:Neo
     * @name config.useDomIds
     * @type Boolean
     */
    useDomIds: true,
    /**
     * True will automatically include the stylesheet
     * @default true
     * @memberOf! module:Neo
     * @name config.useFontAwesome
     * @type Boolean
     */
    useFontAwesome: true,
    /**
     * Intended for the online examples where we need an easy way to add GA to every generated app
     * @default false
     * @memberOf! module:Neo
     * @name config.useGoogleAnalytics
     * @type Boolean
     */
    useGoogleAnalytics: false,
    /**
     * True will add the ServiceWorker main thread addon to support caching of assets (PWA)
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
     *
     * You can also use a string to specify the target environment => 'dist/production'.
     * Using 'dist/production' will also use the service worker for 'dist/esm'
     * @default false
     * @memberOf! module:Neo
     * @name config.useServiceWorker
     * @type Boolean|String
     */
    useServiceWorker: false,
    /**
     * Creates App, Data & VDom as SharedWorkers.
     * Set this one to true in case you want to connect multiple main threads.
     * @default false
     * @memberOf! module:Neo
     * @name config.useSharedWorkers
     * @type Boolean
     */
    useSharedWorkers: false,
    /**
     * `true` will let the `vdom.Helper` create a String-based representation of the vnode tree.
     * Main will then use e.g.`parentNode.insertAdjacentHTML('beforeend', delta.outerHTML);`
     * This affects the initial painting of your apps, but also the creation of new component trees at run-time.
     * `false` will skip the creation of the String, and instead use DOM APIs to generate a fragment inside Main,
     * into which the vnode tree will get applied.
     * @default false
     * @memberOf! module:Neo
     * @name config.useStringBasedMounting
     * @type Boolean
     */
    useStringBasedMounting: false,
    /**
     * True will generate a new task worker, which can get filled with own expensive remote methods
     * @default false
     * @memberOf! module:Neo
     * @name config.useTaskWorker
     * @type Boolean
     */
    useTaskWorker: false,
    /**
     * False will create the vdom.Helper within the App worker (experimental!)
     * @default true
     * @memberOf! module:Neo
     * @name config.useVdomWorker
     * @type Boolean
     */
    useVdomWorker: true,
    /**
     * buildScripts/injectPackageVersion.mjs will update this value
     * @default '10.0.0-alpha.2'
     * @memberOf! module:Neo
     * @name config.version
     * @type String
     */
    version: '10.0.0-alpha.2'
};

Object.assign(DefaultConfig, {
    /**
     * Path to the top level neo.mjs resources folder
     * @default Neo.config.basePath + 'resources/'
     * @memberOf! module:Neo
     * @name config.resourcesPath
     * @type String
     */
    resourcesPath: `${Neo.config.basePath || DefaultConfig.basePath}resources/`,
    /**
     * The default base URL for web worker entry points (App, Data, Vdom)
     * @default Neo.config.basePath + 'src/worker/'
     * @memberOf! module:Neo
     * @name config.workerBasePath
     * @type String
     */
    workerBasePath: `${Neo.config.basePath || DefaultConfig.basePath}src/worker/`,
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DefaultConfig);


/***/ }),

/***/ "./src/Neo.mjs":
/*!*********************!*\
  !*** ./src/Neo.mjs ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultConfig.mjs */ "./src/DefaultConfig.mjs");


const
    camelRegex   = /-./g,
    configSymbol = Symbol.for('configSymbol'),
    getSetCache  = Symbol('getSetCache'),
    typeDetector = {
        function: item => {
            if (item.prototype?.constructor.isClass) {
                return 'NeoClass'
            }
        },
        object: item => {
            if (item.constructor.isClass && item instanceof Neo.core.Base) {
                return 'NeoInstance'
            }
        }
    };

/**
 * The base module to enhance classes, create instances and the Neo namespace
 * @module Neo
 * @singleton
 * @borrows Neo.core.Util.bindMethods       as bindMethods
 * @borrows Neo.core.Util.capitalize        as capitalize
 * @borrows Neo.core.Util.createStyleObject as createStyleObject
 * @borrows Neo.core.Util.createStyles      as createStyles
 * @borrows Neo.core.Util.decamel           as decamel
 * @borrows Neo.core.Util.isArray           as isArray
 * @borrows Neo.core.Util.isBoolean         as isBoolean
 * @borrows Neo.core.Util.isDefined         as isDefined
 * @borrows Neo.core.Compare.isEqual        as isEqual
 * @borrows Neo.core.Util.isNumber          as isNumber
 * @borrows Neo.core.Util.isObject          as isObject
 * @borrows Neo.core.Util.isString          as isString
 * @borrows Neo.core.Util.toArray           as toArray
 * @tutorial 01_Concept
 */
let Neo = globalThis.Neo || {};

Neo = globalThis.Neo = Object.assign({
    /**
     * A map containing ntypes as key and Neo classes or singletons as values
     * @memberOf! module:Neo
     * @protected
     * @type Object
     */
    ntypeMap: {},
    /**
     * Needed for Neo.create. False for the main thread, true for the App, Data & Vdom worker
     * @memberOf! module:Neo
     * @protected
     * @type Boolean
     */
    insideWorker: typeof DedicatedWorkerGlobalScope !== 'undefined' || typeof WorkerGlobalScope !== 'undefined',

    /**
     * Maps methods from one namespace to another one
     * @example
     * // aliases
     * Neo.applyFromNs(Neo, Util, {
     *     createStyleObject: 'createStyleObject',
     *     createStyles     : 'createStyles',
     *     capitalize       : 'capitalize'
     * }, true);
     *
     * // e.g. Neo.core.Util.isObject => Neo.isObject
     * @memberOf module:Neo
     * @param {Neo|Neo.core.Base} target    The target class or singleton Instance or Neo
     * @param {Neo.core.Base}     namespace The class containing the methods
     * @param {Object}            config
     * @param {Boolean}           [bind]    set this to true in case you want to bind methods to the "from" namespace
     * @returns {Object} target
     */
    applyFromNs(target, namespace, config, bind) {
        let fnName;

        if (target && Neo.typeOf(config) === 'Object') {
            Object.entries(config).forEach(([key, value]) => {
                fnName = namespace[value];
                target[key] = bind ? fnName.bind(namespace) : fnName
            })
        }

        return target
    },

    /**
     * Maps a class to the global Neo or App namespace.
     * Can get called for classes and singleton instances
     * @memberOf module:Neo
     * @param {Neo.core.Base} cls
     */
    applyToGlobalNs(cls) {
        let proto     = typeof cls === 'function' ? cls.prototype : cls,
            className = proto.isClass ? proto.config.className : proto.className,
            nsArray   = className.split('.'),
            key       = nsArray.pop(),
            ns        = Neo.ns(nsArray, true);

        ns[key] = cls
    },

    /**
     * Copies all keys of defaults into target, in case they don't already exist
     * @memberOf module:Neo
     * @param {Object} target   The target object
     * @param {Object} defaults The object containing the keys you want to copy
     * @returns {Object} target
     */
    assignDefaults(target, defaults) {
        if (target && Neo.typeOf(defaults) === 'Object') {
            Object.entries(defaults).forEach(([key, value]) => {
                if (!Object.hasOwn(target, key)) {
                    target[key] = value
                }
            })
        }

        return target
    },

    /**
     * Assigns a new value to a given nested objects path.
     * It will create the path structure or parts of it, in case it does not exist.
     * @example
     * Neo.assignToNs('annotations.selected', false, record)
     *
     * @memberOf module:Neo
     * @param {String[]|String} path             The path string containing dots or an Array of the string parts
     * @param {*}               value            The new value to assign to the leaf node
     * @param {Object}          scope=globalThis Set a different starting point as globalThis
     * @param {Boolean}         force=true       false will only assign default values (assign if old value === undefined)
     */
    assignToNs(path, value, scope=globalThis, force=true) {
        path = Array.isArray(path) ? path : path.split('.');

        let key;

        if (path.length > 1) {
            key   = path.pop();
            scope = Neo.ns(path, true, scope)
        } else {
            key = path
        }

        if (force || scope[key] === undefined) {
            scope[key] = value
        }
    },

    /**
     * Converts kebab-case strings into camel-case
     * @memberOf module:Neo
     * @param {String} value The target object
     * @returns {String}
     */
    camel(value) {
        return value.replace(camelRegex, match => match[1].toUpperCase())
    },

    /**
     * Makes the first character of a string uppercase
     * @memberOf module:Neo
     * @param {String} value
     * @returns {Boolean|String} Returns false for non string inputs
     */
    capitalize(value) {
        return value[0].toUpperCase() + value.slice(1)
    },

    /**
     * @memberOf module:Neo
     * @param {Object|Array|*} obj
     * @param {Boolean} deep=false               Set this to true in case you want to clone nested objects as well
     * @param {Boolean} ignoreNeoInstances=false returns existing instances if set to true
     * @returns {Object|Array|*} the cloned input
     */
    clone(obj, deep=false, ignoreNeoInstances=false) {
        let out;

        return {
            Array      : () => !deep ? [...obj] : [...obj.map(val => Neo.clone(val, deep, ignoreNeoInstances))],
            Date       : () => new Date(obj.valueOf()),
            Map        : () => new Map(obj), // shallow copy
            NeoInstance: () => ignoreNeoInstances ? obj : this.cloneNeoInstance(obj),
            Set        : () => new Set(obj),

            Object: () => {
                out = {};

                Object.entries(obj).forEach(([key, value]) => {
                    out[key] = !deep ? value : Neo.clone(value, deep, ignoreNeoInstances)
                });

                return out
            }
        }[Neo.typeOf(obj)]?.() || obj
    },

    /**
     * Creates a new instance using the originalConfig without the id
     * @memberOf module:Neo
     * @param {Neo.core.Base} instance
     * @returns {Neo.core.Base} the cloned instance
     */
    cloneNeoInstance(instance) {
        let config = {...instance.originalConfig};

        delete config._id;
        delete config.id;

        return Neo.create(instance.className, config)
    },

    /**
     * Use Neo.create() instead of "new" to create instances of all Neo classes
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create(Button, {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create({
     *     module : Button,
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create('Neo.button.Base' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create({
     *     className: 'Neo.button.Base',
     *     iconCls  : 'fa fa-home',
     *     text     : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object|Neo.core.Base} className
     * @param {Object}                      [config]
     * @returns {Neo.core.Base|null} The new class instance
     * @tutorial 02_ClassSystem
     */
    create(className, config) {
        let type = Neo.typeOf(className),
            cls, instance;

        if (type === 'NeoClass') {
            cls = className
        } else {
            if (type === 'Object') {
                config = className;

                if (!config.className && !config.module) {
                    // using console.error instead of throw to show the config object
                    console.error('Class created with object configuration missing className or module property', config);
                    return null
                }

                className = config.className || config.module.prototype.className;
            }

            if (!exists(className)) {
                throw new Error('Class ' + className + ' does not exist')
            }

            cls = Neo.ns(className)
        }

        instance = new cls();

        instance.construct(config);
        instance.onConstructed();
        instance.onAfterConstructed();
        instance.init();

        return instance
    },

    /**
     *
     */
    emptyFn() {},

    /**
     * Checks if there is a set method for a given property key inside the prototype chain
     * @memberOf module:Neo
     * @param {Neo.core.Base} proto The top level prototype of a class
     * @param {String}        key   The property key to test
     * @returns {Boolean}
     */
    hasPropertySetter(proto, key) {
        let descriptor;

        while (proto.__proto__) {
            descriptor = Object.getOwnPropertyDescriptor(proto, key);

            if (typeof descriptor === 'object' && typeof descriptor.set === 'function') {
                return true
            }

            proto = proto.__proto__
        }

        return false
    },

    /**
     * Deep-merges a source object into a target object
     * @memberOf module:Neo
     * @param {Object} target
     * @param {Object} source
     * @param {Object} defaults
     * @returns {Object} target
     */
    merge(target, source, defaults) {
        if (defaults) {
            return Neo.merge(Neo.merge(target, defaults), source)
        }

        for (const key in source) {
            const value = source[key];

            if (Neo.typeOf(value) === 'Object') {
                target[key] = Neo.merge(target[key] || {}, value)
            } else {
                target[key] = value
            }
        }

        return target
    },

    /**
     * Maps a className string into a given or global namespace
     * @example
     * Neo.ns('Neo.button.Base', true);
     * // =>
     * // globalThis.Neo             = globalThis.Neo             || {};
     * // globalThis.Neo.button      = globalThis.Neo.button      || {};
     * // globalThis.Neo.button.Base = globalThis.Neo.button.Base || {};
     * // return globalThis.Neo.button.Base;
     *
     * @memberOf module:Neo
     * @param {String[]|String} names        The class name string containing dots or an Array of the string parts
     * @param {Boolean}         create=false Set create to true to create empty objects for non-existing parts
     * @param {Object}          [scope]      Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    ns(names, create=false, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                prev[current] = {}
            }

            if (prev) {
                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Extended version of Neo.ns() which supports mapping into arrays.
     * @memberOf module:Neo
     * @param {Array|String} names        The class name string containing dots or an Array of the string parts
     * @param {Boolean}      create=false Set create to true to create empty objects for non-existing parts
     * @param {Object}       [scope]      Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    nsWithArrays(names, create=false, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                if (current.endsWith(']')) {
                    return createArrayNs(true, current, prev)
                }

                prev[current] = {}
            }

            if (prev) {
                if (current.endsWith(']')) {
                    return createArrayNs(false, current, prev)
                }

                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Creates instances of Neo classes using their ntype instead of the class name
     * @example
     * Neo.ntype('button' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.ntype({
     *     ntype  : 'button',
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object} ntype
     * @param {Object}        [config]
     * @returns {Neo.core.Base}
     * @see {@link module:Neo.create create}
     */
    ntype(ntype, config) {
        if (typeof ntype === 'object') {
            config = ntype;

            if (!config.ntype) {
                throw new Error('Class defined with object configuration missing ntype property. ' + config.ntype)
            }

            ntype = config.ntype
        }

        let className = Neo.ntypeMap[ntype];

        if (!className) {
            throw new Error('ntype ' + ntype + ' does not exist')
        }

        return Neo.create(className, config)
    },

    /**
     * Internally used at the end of each class / module definition
     * @memberOf module:Neo
     * @template T
     * @param {T} cls
     * @returns {T}
     */
    setupClass(cls) {
        let baseCfg    = null,
            ntypeChain = [],
            {ntypeMap} = Neo,
            proto      = cls.prototype || cls,
            ns         = Neo.ns(proto.constructor.config.className, false),
            protos     = [],
            cfg, config, ctor, ntype;

        /*
         * If the namespace already exists, directly return it.
         * This can happen when using different versions of neo.mjs
         * => Especially singletons (IdGenerator) must stay unique.
         *
         * This can also happen when using different environments of neo.mjs in parallel.
         * Example: code.LivePreview running inside a dist/production app.
         */
        if (ns) {
            return ns
        }

        while (proto.__proto__) {
            ctor = proto.constructor;

            if (Object.hasOwn(ctor, 'classConfigApplied')) {
                baseCfg    = Neo.clone(ctor.config, true);
                ntypeChain = [...ctor.ntypeChain];
                break
            }

            protos.unshift(proto);
            proto = proto.__proto__
        }

        config = baseCfg || {};

        protos.forEach(element => {
            let mixins;

            ctor = element.constructor;

            cfg = ctor.config || {};

            if (Neo.overwrites) {
                ctor.applyOverwrites?.(cfg)
            }

            Object.entries(cfg).forEach(([key, value]) => {
                if (key.slice(-1) === '_') {
                    delete cfg[key];
                    key = key.slice(0, -1);
                    cfg[key] = value;
                    autoGenerateGetSet(element, key)
                }

                    // only apply properties which have no setters inside the prototype chain
                // those will get applied on create (Neo.core.Base -> initConfig)
                else if (!Neo.hasPropertySetter(element, key)) {
                    Object.defineProperty(element, key, {
                        enumerable: true,
                        value,
                        writable  : true
                    })
                }
            });

            if (Object.hasOwn(cfg, 'ntype')) {
                ntype = cfg.ntype;

                ntypeChain.unshift(ntype);

                // Running the docs app inside a workspace can pull in the same classes from different roots,
                // so we want to check for different class names as well
                if (Object.hasOwn(ntypeMap, ntype) && cfg.className !== ntypeMap[ntype]) {
                    throw new Error(`ntype conflict for '${ntype}' inside the classes:\n${ntypeMap[ntype]}\n${cfg.className}`)
                }

                ntypeMap[ntype] = cfg.className
            }

            mixins = Object.hasOwn(config, 'mixins') && config.mixins || [];

            if (ctor.observable) {
                mixins.push('Neo.core.Observable')
            }

            if (Object.hasOwn(cfg, 'mixins') && Array.isArray(cfg.mixins) && cfg.mixins.length > 0) {
                mixins.push(...cfg.mixins)
            }

            if (mixins.length > 0) {
                applyMixins(ctor, mixins);

                if (Neo.ns('Neo.core.Observable', false, ctor.prototype.mixins)) {
                    ctor.observable = true
                }
            }

            delete cfg.mixins;
            delete config.mixins;

            Object.assign(config, cfg);

            Object.assign(ctor, {
                classConfigApplied: true,
                config            : Neo.clone(config, true),
                isClass           : true,
                ntypeChain
            });

            !config.singleton && this.applyToGlobalNs(cls)
        });

        proto = cls.prototype || cls;

        ntypeChain.forEach(ntype => {
            proto[`is${Neo.capitalize(Neo.camel(ntype))}`] = true
        });

        if (proto.singleton) {
            cls = Neo.create(cls);
            Neo.applyToGlobalNs(cls)
        }

        return cls
    },

    /**
     * @param {*} item
     * @returns {String|null}
     */
    typeOf(item) {
        if (item === null || item === undefined) {
            return null
        }

        return typeDetector[typeof item]?.(item) || item.constructor.name
    }
}, Neo);

/**
 * List of class properties which are not supposed to get mixed into other classes
 * @type {string[]}
 * @private
 */
const ignoreMixin = [
    '_name',
    'classConfigApplied',
    'className',
    'constructor',
    'isClass',
    'mixin',
    'ntype',
    'observable'
],

    charsRegex         = /\d+/g,
    extractArraysRegex = /^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;

/**
 * @param {Neo.core.Base} cls
 * @param {Array}         mixins
 * @private
 */
function applyMixins(cls, mixins) {
    if (!Array.isArray(mixins)) {
        mixins = [mixins];
    }

    let i            = 0,
        len          = mixins.length,
        mixinClasses = {},
        mixin, mixinCls, mixinProto;

    for (;i < len;i++) {
        mixin = mixins[i];

        if (mixin.isClass) {
            mixinProto = mixin.prototype;
            mixinCls   = Neo.ns(mixinProto.className)
        } else {
            if (!exists(mixin)) {
                throw new Error('Attempting to mixin an undefined class: ' + mixin + ', ' + cls.prototype.className)
            }

            mixinCls   = Neo.ns(mixin);
            mixinProto = mixinCls.prototype;
        }

        mixinProto.className.split('.').reduce(mixReduce(mixinCls), mixinClasses);

        Object.getOwnPropertyNames(mixinProto).forEach(mixinProperty(cls.prototype, mixinProto))
    }

    cls.prototype.mixins = mixinClasses // todo: we should do a deep merge
}

/**
 * Creates get / set methods for class configs ending with an underscore
 * @param {Neo.core.Base} proto
 * @param {String}        key
 * @private
 * @tutorial 02_ClassSystem
 */
function autoGenerateGetSet(proto, key) {
    if (Neo.hasPropertySetter(proto, key)) {
        throw('Config ' + key + '_ (' + proto.className + ') already has a set method, use beforeGet, beforeSet & afterSet instead')
    }

    if (!Neo[getSetCache]) {
        Neo[getSetCache] = {}
    }

    if (!Neo[getSetCache][key]) {
        Neo[getSetCache][key] = {
            get() {
                let me        = this,
                    beforeGet = `beforeGet${key[0].toUpperCase() + key.slice(1)}`,
                    hasNewKey = Object.hasOwn(me[configSymbol], key),
                    newKey    = me[configSymbol][key],
                    value     = hasNewKey ? newKey : me['_' + key];

                if (Array.isArray(value)) {
                    if (key !== 'items') {
                        value = [...value]
                    }
                } else if (value instanceof Date) {
                    value = new Date(value.valueOf())
                }

                if (hasNewKey) {
                    me[key] = value; // we do want to trigger the setter => beforeSet, afterSet
                    value = me['_' + key]; // return the value parsed by the setter
                    delete me[configSymbol][key]
                }

                if (typeof me[beforeGet] === 'function') {
                    value = me[beforeGet](value)
                }

                return value
            },

            set(value) {
                if (value === undefined) {
                    return
                }

                let me        = this,
                    _key      = '_' + key,
                    uKey      = key[0].toUpperCase() + key.slice(1),
                    beforeSet = 'beforeSet' + uKey,
                    afterSet  = 'afterSet'  + uKey,
                    oldValue  = me[_key];

                // every set call has to delete the matching symbol
                delete me[configSymbol][key];

                if (key !== 'items' && key !== 'vnode') {
                    value = Neo.clone(value, true, true)
                }

                // we do want to store the value before the beforeSet modification as well,
                // since it could get pulled by other beforeSet methods of different configs
                me[_key] = value;

                if (typeof me[beforeSet] === 'function') {
                    value = me[beforeSet](value, oldValue);

                    // If they don't return a value, that means no change
                    if (value === undefined) {
                        me[_key] = oldValue;
                        return
                    }

                    me[_key] = value;
                }

                if (
                    (key === 'vnode' && value !== oldValue) || // vnode trees can be huge, avoid a deep comparison
                    !Neo.isEqual(value, oldValue)
                ) {
                    me[afterSet]?.(value, oldValue);
                    me.afterSetConfig?.(key, value, oldValue)
                }
            }
        }
    }

    Object.defineProperty(proto, key, Neo[getSetCache][key])
}

/**
 * @param {Boolean} create
 * @param {Object}  current
 * @param {Object}  prev
 * @returns {Object|undefined}
 */
function createArrayNs(create, current, prev) {
    let arrDetails = parseArrayFromString(current),
        i          = 1,
        len        = arrDetails.length,
        arrItem, arrRoot;

    if (create) {
        prev[arrDetails[0]] = arrRoot = prev[arrDetails[0]] || []
    } else {
        arrRoot = prev[arrDetails[0]]
    }

    if (!arrRoot) {
        return
    }

    for (; i < len; i++) {
        arrItem = parseInt(arrDetails[i]);

        if (create) {
            arrRoot[arrItem] = arrRoot[arrItem] || {}
        }

        arrRoot = arrRoot[arrItem]
    }

    return arrRoot
}

/**
 * Checks if the class name exists inside the Neo or app namespace
 * @param {String} className
 * @returns {Boolean}
 * @private
 */
function exists(className) {
    try {
        return !!className.split('.').reduce((prev, current) => {
            return prev[current]
        }, globalThis)
    } catch(e) {
        return false
    }
}

/**
 * @param {Neo.core.Base} proto
 * @param {Neo.core.Base} mixinProto
 * @returns {Function}
 * @private
 */
function mixinProperty(proto, mixinProto) {
    return function(key) {
        if (~ignoreMixin.indexOf(key)) {
            return
        }

        if (proto[key]?._from) {
            if (mixinProto.className === proto[key]._from) {
                console.warn('Mixin set multiple times or already defined on a Base Class', proto.className, mixinProto.className, key);
                return
            }

            throw new Error(
                `${proto.className}: Multiple mixins defining same property (${mixinProto.className}, ${proto[key]._from}) => ${key}`
            )
        }

        proto[key] = mixinProto[key];

        Object.getOwnPropertyDescriptor(proto, key)._from = mixinProto.className;

        if (typeof proto[key] === 'function') {
            proto[key]._name = key
        }
    }
}

/**
 * @param mixinCls
 * @returns {Function}
 * @private
 */
function mixReduce(mixinCls) {
    return (prev, current, idx, arr) => {
        return prev[current] = idx !== arr.length -1 ? prev[current] || {} : mixinCls
    }
}

/**
 * @param {String} str
 * @returns {Function}
 * @private
 */
function parseArrayFromString(str) {
    return (extractArraysRegex.exec(str) || [null]).slice(1).reduce(
        (fun, args) => [fun].concat(args.match(charsRegex))
    )
}

Neo.config = Neo.config || {};

Neo.assignDefaults(Neo.config, _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo);


/***/ }),

/***/ "./src/core/Base.mjs":
/*!***************************!*\
  !*** ./src/core/Base.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");



const configSymbol       = Symbol.for('configSymbol'),
      forceAssignConfigs = Symbol('forceAssignConfigs'),
      isInstance         = Symbol('isInstance');

/**
 * The base class for (almost) all classes inside the Neo namespace
 * Exceptions are e.g. core.IdGenerator, vdom.VNode
 * @class Neo.core.Base
 */
class Base {
    /**
     * You can define methods which should get delayed.
     * Types are buffer, debounce & throttle.
     * @example
     *  delayable: {
     *      fireChangeEvent: {
     *          type : 'debounce',
     *          timer: 300
     *      }
     *  }
     * @member {Object} delayable={}
     * @protected
     * @static
     */
    static delayable = {}
    /**
     * Flag which will get set to true once manager.Instance got created
     * @member {Boolean} instanceManagerAvailable=false
     * @static
     */
    static instanceManagerAvailable = false
    /**
     * Regex to grab the MethodName from an error
     * which is a second generation function
     * @member {RegExp} methodNameRegex
     * @static
     */
    static methodNameRegex = /\n.*\n\s+at\s+.*\.(\w+)\s+.*/
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=false
     * @static
     */
    static observable = false
    /**
     * Keep the overwritten methods
     * @member {Object} overwrittenMethods={}
     * @protected
     * @static
     */
    static overwrittenMethods = {}
    /**
     * Configs will get merged throughout the class hierarchy
     * @returns {Object} config
     */
    static config = {
        /**
         * The class name which will get mapped into the Neo or app namespace
         * @member {String} className='Neo.core.Base'
         * @protected
         */
        className: 'Neo.core.Base',
        /**
         * The class shortcut-name to use for e.g. creating child components inside a JSON-format
         * @member {String} ntype='base'
         * @protected
         */
        ntype: 'base',
        /**
         * While it is recommended to change the static delayable configs on class level,
         * you can change it on instance level too. If not null, we will do a deep merge.
         * @member {Object} delayable=null
         */
        delayable: null,
        /**
         * The unique component id
         * @member {String|null} id_=null
         */
        id_: null,
        /**
         * Neo.create() will change this flag to true after the onConstructed() chain is done.
         * @member {Boolean} isConstructed=false
         * @protected
         */
        isConstructed: false,
        /**
         * Add mixins as an array of classNames, imported modules or a mixed version
         * @member {String[]|Neo.core.Base[]|null} mixins=null
         */
        mixins: null,
        /**
         * You can create a new instance by passing an imported class (JS module default export)
         * @member {Class} module=null
         * @protected
         */
        module: null
    }

    /**
     * Internal cache for all timeout ids when using this.timeout()
     * @member {Number[]} timeoutIds=[]
     * @private
     */
    #timeoutIds = []

    /**
     * Applies the observable mixin if needed, grants remote access if needed.
     * @param {Object} config={}
     */
    construct(config={}) {
        let me = this;

        Object.defineProperties(me, {
            [configSymbol]: {
                configurable: true,
                enumerable  : false,
                value       : {},
                writable    : true
            },
            [isInstance]: {
                enumerable: false,
                value     : true
            }
        });

        me.createId(config.id || me.id);
        delete config.id;

        if (me.constructor.config) {
            delete me.constructor.config.id
        }

        me.getStaticConfig('observable') && me.initObservable(config);

        // assign class field values prior to configs
        config = me.setFields(config);

        me.initConfig(config);

        Object.defineProperty(me, 'configsApplied', {
            enumerable: false,
            value     : true
        });

        me.applyDelayable();

        /*
         * We do not want to force devs to check for the `isDestroyed` flag in every possible class extension.
         * So, we are intercepting the top-most `destroy()` call to check for the flag there.
         * Rationale: `destroy()` must only get called once.
         */
        (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.intercept)(me, 'destroy', me.isDestroyedCheck, me);

        me.remote && setTimeout(me.initRemote.bind(me), 1)
    }

    /**
     * Triggered after the id config got changed.
     * You can dynamically change instance ids if needed. They need to stay unique at any given point.
     * Use case: e.g. component based lists, where you want to re-use item instances.
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me         = this,
            hasManager = Base.instanceManagerAvailable === true;

        if (oldValue) {
            if (hasManager) {
                Neo.manager.Instance.unregister(oldValue)
            } else {
                delete Neo.idMap[oldValue]
            }
        }

        if (value) {
            if (hasManager) {
                Neo.manager.Instance.register(me);
            } else {
                Neo.idMap = Neo.idMap || {};
                Neo.idMap[me.id] = me
            }
        }
    }

    /**
     * Adjusts all methods inside static delayable
     */
    applyDelayable() {
        let me            = this,
            ctorDelayable = me.constructor.delayable,
            delayable     = me.delayable ? Neo.merge({}, me.delayable, ctorDelayable) : ctorDelayable;

        Object.entries(delayable).forEach(([key, value]) => {
            if (value) {
                let map = {
                    buffer()   {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.buffer(me[key],   me, value.timer)},
                    debounce() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce(me[key], me, value.timer)},
                    throttle() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.throttle(me[key], me, value.timer)}
                };

                map[value.type]?.()
            }
        })
    }

    /**
     * Applying overwrites and adding overwrittenMethods to the class constructors
     * @param {Object} cfg
     * @protected
     */
    static applyOverwrites(cfg) {
        let overwrites = Neo.ns(cfg.className, false, Neo.overwrites),
            cls, item;

        if (overwrites) {
            // Apply all methods
            for (item in overwrites) {
                if (Neo.isFunction(overwrites[item])) {
                    // Already existing ones
                    cls = this.prototype;

                    if (cls[item]) {
                        // add to overwrittenMethods
                        cls.constructor.overwrittenMethods[item] = cls[item]
                    }
                }
            }

            // Apply configs to prototype
            Object.assign(cfg, overwrites)
        }
    }

    /**
     * Convenience method for beforeSet functions which test if a given value is inside a static array
     * @param {String|Number} value
     * @param {String|Number} oldValue
     * @param {String} name config name
     * @param {Array|String} [staticName=name + 's'] name of the static config array
     * @returns {String|Number} value or oldValue
     */
    beforeSetEnumValue(value, oldValue, name, staticName = name + 's') {
        let values = Array.isArray(staticName) ? staticName : this.getStaticConfig(staticName);

        if (!values.includes(value)) {
            console.error(`Supported values for ${name} are:`, ...values, this);
            return oldValue
        }

        return value
    }

    /**
     * @param {String} fn               The name of a function to find in the passed scope object.
     * @param {Object} originName       The name of the method inside the originScope.
     * @param {Object} scope            The scope to find the function in if it is specified as a string.
     * @param {Object} originScope=this The scope where the function is located.
     */
    bindCallback(fn, originName, scope=this, originScope=this) {
        if (fn && Neo.isString(fn)) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveCallback)(fn, scope);
            originScope[originName] = handler.fn.bind(handler.scope)
        }
    }

    /**
     * From within an overwrite, a method can call a parent method, by using callOverwritten.
     *
     * @example
     *    afterSetHeight(value, oldValue) {
     *        // do the standard
     *        this.callOverwritten(...arguments);
     *        // do you own stuff
     *    }
     *
     * We create an error to get the caller.name and then run that method on the constructor.
     * This is based on the following error structure, e.g. afterSetHeight.
     *
     *     Error
     *         at Base.callOverwritten (Base.mjs:176:21)
     *         at Base.afterSetHeight (Overrides.mjs:19:26)
     *
     * @param args
     */
    callOverwritten(...args) {
        let stack      = new Error().stack,
            methodName = stack.match(Base.methodNameRegex)[1];

        this.__proto__.constructor.overwrittenMethods[methodName].call(this, ...args)
    }

    /**
     * Uses the IdGenerator to create an id if a static one is not explicitly set.
     * Registers the instance to manager.Instance if this one is already created,
     * otherwise stores it inside a tmp map.
     * @param {String} id
     */
    createId(id) {
        this.id = id || _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getId(this.getIdKey())
    }

    /**
     * Unregisters this instance from Neo.manager.Instance
     * and removes all object entries from this instance
     */
    destroy() {
        let me = this;

        me.#timeoutIds.forEach(id => {
            clearTimeout(id)
        });

        if (Base.instanceManagerAvailable === true) {
            Neo.manager.Instance.unregister(me)
        } else if (Neo.idMap) {
            delete Neo.idMap[me.id]
        }

        Object.keys(me).forEach(key => {
            if (Object.getOwnPropertyDescriptor(me, key).writable) {
                // We must not delete the custom destroy() interceptor
                if (key !== 'destroy' && key !== '_id') {
                    delete me[key]
                }
            }
        });

        // We do want to prevent delayed event calls after an observable instance got destroyed.
        if (Neo.isFunction(me.fire)) {
            me.fire = Neo.emptyFn
        }

        me.isDestroyed = true
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * Override this method as needed.
     * @returns {String}
     */
    getIdKey() {
        return this.ntype
    }

    /**
     * Returns the value of a static config key or the staticConfig object itself in case no value is set
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @returns {*}
     */
    getStaticConfig(key) {
        return this.constructor[key]
    }

    /**
     * Check if a given ntype exists inside the proto chain, including the top level class
     * @param {String} ntype
     * @returns {Boolean}
     */
    hasNtype(ntype) {
        return this.constructor.ntypeChain.includes(ntype)
    }

    /**
     * Gets triggered after onConstructed() is done
     * @see {@link Neo.core.Base#onConstructed onConstructed}
     * @tutorial 02_ClassSystem
     */
    init() {}

    /**
     * Applies all class configs to this instance
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @protected
     */
    initConfig(config, preventOriginalConfig) {
        let me = this;

        me.isConfiguring = true;
        Object.assign(me[configSymbol], me.mergeConfig(config, preventOriginalConfig));
        me.processConfigs();
        me.isConfiguring = false;
    }

    /**
     * Does get triggered with a delay to ensure that Neo.workerId & Neo.worker.Manager are defined
     * Remote method access via promises
     * @protected
     */
    initRemote() {
        let me                  = this,
            {className, remote} = me,
            {currentWorker}     = Neo;

        if (!me.singleton && !me.isMainThreadAddon) {
            throw new Error('Remote method access is only functional for Singleton classes ' + className)
        }

        if (!Neo.config.unitTestMode && Neo.isObject(remote)) {
            if (Neo.workerId !== 'main' && currentWorker.isSharedWorker && !currentWorker.isConnected) {
                currentWorker.on('connected', () => {
                    Base.sendRemotes(className, remote)
                }, me, {once: true})
            } else {
                Base.sendRemotes(className, remote)
            }
        }
    }

    /**
     * Intercepts destroy() calls to ensure they will only get called once
     * @returns {Boolean}
     */
    isDestroyedCheck() {
        return !this.isDestroyed
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     * @protected
     */
    mergeConfig(config, preventOriginalConfig) {
        let me   = this,
            ctor = me.constructor;

        if (!ctor.config) {
            throw new Error('Neo.applyClassConfig has not been run on ' + me.className)
        }

        if (!preventOriginalConfig) {
            me.originalConfig = Neo.clone(config, true, true)
        }

        return {...ctor.config, ...config}
    }

    /**
     *
     */
    onAfterConstructed() {
        let me = this;

        me.isConstructed = true;

        // We can only fire the event in case the Observable mixin is included.
        me.getStaticConfig('observable') && me.fire('constructed', me)
    }

    /**
     * Gets triggered after all constructors are done
     * @tutorial 02_ClassSystem
     */
    onConstructed() {}

    /**
     * Helper method to replace string based values containing "@config:" with the matching config value
     * of this instance.
     * @param {Object|Object[]} items
     */
    parseItemConfigs(items) {
        let me = this,
            ns, nsArray, nsKey, symbolNs;

        if (items) {
            if (!Array.isArray(items)) {
                items = [items]
            }

            items.forEach(item => {
                item && Object.entries(item).forEach(([key, value]) => {
                    if (Array.isArray(value)) {
                        me.parseItemConfigs(value);
                    } else if (typeof value === 'string' && value.startsWith('@config:')) {
                        nsArray = value.substring(8).trim().split('.');
                        nsKey   = nsArray.pop();
                        ns      = Neo.ns(nsArray, false, me);

                        if (ns[nsKey] === undefined) {
                            console.error('The used @config does not exist:', nsKey, nsArray.join('.'))
                        } else {
                            symbolNs = Neo.ns(nsArray, false, me[configSymbol]);

                            // The config might not be processed yet, especially for configs
                            // not ending with an underscore, so we need to check the configSymbol first.
                            if (symbolNs && Object.hasOwn(symbolNs, nsKey)) {
                                item[key] = symbolNs[nsKey]
                            } else {
                                item[key] = ns[nsKey]
                            }
                        }
                    }
                })
            })
        }
    }

    /**
     * When using set(), configs without a trailing underscore can already be assigned,
     * so the hasOwnProperty() check will return true
     * @param {Boolean} [forceAssign=false]
     * @protected
     */
    processConfigs(forceAssign=false) {
        let me   = this,
            keys = Object.keys(me[configSymbol]);

        me[forceAssignConfigs] = forceAssign;

        // We do not want to iterate over the keys, since 1 config can remove more than 1 key (beforeSetX, afterSetX)
        if (keys.length > 0) {
            // The hasOwnProperty check is intended for configs without a trailing underscore
            // => they could already have been assigned inside an afterSet-method
            if (forceAssign || !me.hasOwnProperty(keys[0])) {
                me[keys[0]] = me[configSymbol][keys[0]]
            }

            // there is a delete-call inside the config getter as well (Neo.mjs => autoGenerateGetSet())
            // we need to keep this one for configs, which do not use getters (no trailing underscore)
            delete me[configSymbol][keys[0]];

            me.processConfigs(forceAssign)
        }
    }

    /**
     * @param {String} className
     * @param {Object} remote
     * @protected
     */
    static sendRemotes(className, remote) {
        let origin;

        Object.entries(remote).forEach(([worker, methods]) => {
            if (Neo.workerId !== worker) {
                origin = Neo.workerId === 'main' ? Neo.worker.Manager : Neo.currentWorker;

                origin.sendMessage(worker, {
                    action: 'registerRemote',
                    className,
                    methods
                })
            }
        })
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     */
    set(values={}) {
        let me = this;

        values = me.setFields(values);

        // If the initial config processing is still running,
        // finish this one first before dropping new values into the configSymbol.
        // see: https://github.com/neomjs/neo/issues/2201
        if (me[forceAssignConfigs] !== true && Object.keys(me[configSymbol]).length > 0) {
            me.processConfigs()
        }

        Object.assign(me[configSymbol], values);

        me.processConfigs(true)
    }

    /**
     * We want to assign class fields first and remove them from the config object,
     * so that afterSet(), beforeGet() and beforeSet() methods can get the new values right away
     * @param {Object} config
     * @returns {Object}
     * @protected
     */
    setFields(config) {
        let me          = this,
            configNames = me.constructor.config;

        Object.entries(config).forEach(([key, value]) => {
            if (!configNames.hasOwnProperty(key) && !Neo.hasPropertySetter(me, key)) {
                me[key] = value;
                delete config[key]
            }
        })

        return config
    }

    /**
     * Sets the value of a static config by a given key
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @param {*} value
     * @returns {Boolean} true in case the config exists and got changed
     */
    setStaticConfig(key, value) {
        let staticConfig = this.constructor.staticConfig;

        if (staticConfig.hasOwnProperty(key)) {
            staticConfig[key] = value;
            return true
        }

        return false
    }

    /**
     * Stores timeoutIds internally, so that destroy() can clear them if needed
     * @param {Number} time in milliseconds
     * @returns {Promise<any>}
     */
    timeout(time) {
        return new Promise(resolve => {
            let timeoutIds = this.#timeoutIds,
                timeoutId  = setTimeout(() => {timeoutIds.splice(timeoutIds.indexOf(timeoutId), 1); resolve()}, time);

            timeoutIds.push(timeoutId)
        })
    }

    /**
     * <p>Enhancing the toString() method, e.g.</p>
     * `Neo.create('Neo.button.Base').toString() => "[object Neo.button.Base (neo-button-1)]"`
     * @returns {String}
     */
    get [Symbol.toStringTag]() {
        return `${this.className} (id: ${this.id})`
    }

    /**
     * <p>Enhancing the instanceof method. Without this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => true`
     * <p>With this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => false`<br>
     * `Neo.create(Neo.collection.Base) instanceof Neo.core.Base => true`
     * @returns {Boolean}
     */
    static [Symbol.hasInstance](instance) {
        if (!instance) {
            return false
        }

        return instance[isInstance] === true ? super[Symbol.hasInstance](instance) : false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/core/Compare.mjs":
/*!******************************!*\
  !*** ./src/core/Compare.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.core.Compare
 * @extends Neo.core.Base
 */
class Compare extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.core.Compare'
         * @protected
         */
        className: 'Neo.core.Compare'
    }

    /**
     * Storing the comparison method names by data type
     * @member {Object} map
     */
    static map = {
        Array      : 'compareArrays',
        Date       : 'compareDates',
        Function   : 'compareFunctions',
        Map        : 'compareMaps',
        NeoInstance: 'compareNeoInstances',
        Object     : 'compareObjects',
        RegExp     : 'compareRegExps',
        Set        : 'compareSets'
    }

    /**
     * @param {Array} item1
     * @param {Array} item2
     * @returns {Boolean}
     */
    static compareArrays(item1, item2) {
        if (item1.length !== item2.length) {
            return false
        }

        for (const [i, v] of item1.entries()) {
            if (!Compare.isEqual(v, item2[i])) {
                return false
            }
        }

        return true
    }

    /**
     * @param {Date} item1
     * @param {Date} item2
     * @returns {Boolean}
     */
    static compareDates(item1, item2) {
        return item1.valueOf() === item2.valueOf()
    }

    /**
     * @param {Function} item1
     * @param {Function} item2
     * @returns {Boolean}
     */
    static compareFunctions(item1, item2) {
        if (item1.name !== item2.name) {
            return false
        }

        return item1.toString() === item2.toString()
    }

    /**
     * @param {Map} item1
     * @param {Map} item2
     * @returns {Boolean}
     */
    static compareMaps(item1, item2) {
        if (item1.size !== item2.size) {
            return false
        }

        let val2;

        for (const [key, val] of item1) {
            val2 = item2.get(key);

            if (val2 !== val || val2 === undefined && !item2.has(key)) {
                return false
            }
        }

        return true
    }

    /**
     * @param {Neo.core.Base} item1
     * @param {Neo.core.Base} item2
     * @returns {Boolean}
     */
    static compareNeoInstances(item1, item2) {
        return item1.id === item2.id
    }

    /**
     * @param {Object} item1
     * @param {Object} item2
     * @returns {Boolean}
     */
    static compareObjects(item1, item2) {
        if (Object.keys(item1).length !== Object.keys(item2).length) {
            return false
        }

        for (let key in item1) {
            if (!Compare.isEqual(item1[key], item2[key])) {
                return false
            }
        }

        return true
    }

    /**
     * @param {RegExp} item1
     * @param {RegExp} item2
     * @returns {Boolean}
     */
    static compareRegExps(item1, item2) {
        return item1.toString() === item2.toString()
    }

    /**
     * @param {Set} item1
     * @param {Set} item2
     * @returns {Boolean}
     */
    static compareSets(item1, item2) {
        if (item1.size !== item2.size) {
            return false
        }

        for (let key of item1) {
            if (!item2.has(key)) {
                return false
            }
        }

        return true
    }

    /**
     * @param {*} item1
     * @param {*} item2
     * @returns {Boolean}
     */
    static isEqual(item1, item2) {
        if (item1 === item2) {
            return true
        }

        let type1 = Neo.typeOf(item1),
            type2 = Neo.typeOf(item2);

        if (type1 !== type2) {
            return false
        }

        if (Compare.map[type1]) {
            return Compare[Compare.map[type1]](item1, item2)
        }

        // all other types
        return item1 === item2
    }
}

Compare = Neo.setupClass(Compare);

// alias
Neo.isEqual = Compare.isEqual;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Compare);


/***/ }),

/***/ "./src/core/IdGenerator.mjs":
/*!**********************************!*\
  !*** ./src/core/IdGenerator.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This class gets used by core.Base, so it can not extend it.
 * It could get simplified to just being an object (needs to manually get put into the Neo namespace in this case).
 * @class Neo.core.IdGenerator
 * @singleton
 */
class IdGenerator {
    static config = {
        /**
         * @member {String} className='Neo.core.IdGenerator'
         * @protected
         */
        className: 'Neo.core.IdGenerator',
        /**
         * @member {String} ntype='id-generator'
         * @protected
         */
        ntype: 'id-generator',
        /**
         * The default prefix for neo instance ids
         * @member {String} base='neo-'
         */
        base: 'neo-',
        /**
         * @member {Boolean} singleton='true
         * @protected
         */
        singleton: true
    }

    /**
     * @param config
     */
    construct(config) {
        let me = this;

        me.idCounter = {};

        // alias
        Neo.getId = me.getId.bind(me);
    }

    /**
     * @param name
     * @returns {string}
     */
    getId(name) {
        name = name || 'neo';

        let me      = this,
            counter = me.idCounter,
            count   = counter[name] || 0;

        counter[name] = ++count;

        return me.base + (name === 'neo' ? '' : name + '-') + count;
    }

    init() {}

    onAfterConstructed() {}

    onConstructed() {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(IdGenerator));


/***/ }),

/***/ "./src/core/Observable.mjs":
/*!*********************************!*\
  !*** ./src/core/Observable.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");




/**
 * @class Neo.core.Observable
 * @extends Neo.core.Base
 */
class Observable extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.core.Observable'
         * @protected
         */
        className: 'Neo.core.Observable',
        /**
         * @member {String} ntype='mixin-observable'
         * @protected
         */
        ntype: 'mixin-observable',
        /**
         * @member {Boolean} mixin=true
         * @protected
         */
        mixin: true
    }

    /**
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number|String} [order]
     * @returns {String|null} eventId null in case an object gets passed as the name (multiple ids)
     */
    addListener(name, opts, scope, eventId, data, order) {
        let me            = this,
            delay         = 0,
            eventIdObject = typeof eventId === 'object',
            nameObject    = typeof name    === 'object',
            once          = false,
            optsType      = typeof opts,
            listener, existing, eventConfig;

        /*
         * let us support the following format too:
         *
         * currentWorker.on('connected', () => {
         *     Base.sendRemotes(className, remote)
         * }, me, {once: true})
         */
        if (eventIdObject && optsType === 'function') {
            eventId.fn = opts;
            opts     = eventId;
            optsType = 'object';
            eventId  = null;
        }

        if (nameObject) {
            if (name.hasOwnProperty('delay')) {
                delay = name.delay;
                delete name.delay
            }

            if (name.hasOwnProperty('once')) {
                once = name.once;
                delete name.once
            }

            if (name.hasOwnProperty('order')) {
                order = name.order;
                delete name.order
            }

            if (name.hasOwnProperty('scope')) {
                scope = name.scope;
                delete name.scope
            }

            Object.entries(name).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    me.addListener(key, {delay, once, order, scope, ...value})
                } else {
                    me.addListener(key, {delay, fn: value, once, order, scope})
                }
            })
        } else if (optsType === 'object') {
            delay    = delay   || opts.delay;
            eventId  = eventId || opts.eventId;
            listener = opts.fn;
            once     = once    || opts.once;
            order    = order   || opts.order;
            scope    = scope   || opts.scope
        } else if (optsType === 'function') {
            listener = opts
        } else if (optsType === 'string') {
            listener = opts // VC hook, can get parsed after onConstructed in case the view uses the parent VC
        } else {
            throw new Error('Invalid addListener call: ' + name)
        }

        if (!nameObject) {
            eventConfig = {fn: listener, id: eventId || Neo.getId('event')};

            if (data)      {eventConfig.data   = data}
            if (delay > 0) {eventConfig.delay  = delay}
            if (once)      {eventConfig.once   = once}
            if (scope)     {eventConfig.scope  = scope}

            if (existing = me.listeners?.[name]) {
                existing.forEach(cfg => {
                    if (cfg.id === eventId || (cfg.fn === listener && cfg.scope === scope)) {
                        console.error('Duplicate event handler attached:', name, me)
                    }
                });

                if (typeof order === 'number') {
                    existing.splice(order, 0, eventConfig)
                } else if (order === 'before') {
                    existing.unshift(eventConfig)
                } else {
                    existing.push(eventConfig)
                }
            } else {
                me.listeners[name] = [eventConfig]
            }

            return eventConfig.id
        }

        return null
    }

    /**
     * Call the passed function, or a function by *name* which exists in the passed scope's
     * or this component's ownership chain.
     * @param {Function|String} fn A function, or the name of a function to find in the passed scope object.
     * @param {Object} scope       The scope to find the function in if it is specified as a string.
     * @param {Array} args         Arguments to pass to the callback.
     */
    callback(fn, scope=this, args) {
        if (fn) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveCallback)(fn, scope);
            handler.fn.apply(handler.scope, args)
        }
    }

    /**
     * Internal helper method for events which use the delay option
     * @param {Object} cb
     * @param {Array} args
     * @param {Number} delay
     */
    delayedCallback(cb, args, delay) {
        this.timeout(delay).then(() => {
            cb.fn.apply(cb.scope, args)
        })
    }

    /**
     * @param name
     */
    fire(name) {
        let me        = this,
            args      = [].slice.call(arguments, 1),
            listeners = me.listeners,
            delay, handler, handlers, i, len;

        if (listeners && listeners[name]) {
            handlers = [...listeners[name]];
            len      = handlers.length;

            for (i = 0; i < len; i++) {
                handler = handlers[i];
                delay   = handler.delay;

                // Resolve function name on the scope (or me), or, if it starts with 'up.'
                // look in the ownership hierarchy from me.
                const cb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveCallback)(handler.fn, handler.scope || me);

                // remove the listener if the scope no longer exists
                if (cb.scope && !cb.scope.id) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(listeners[name], handler)
                } else {
                    if (!me.suspendEvents) {
                        // Object event format. Inject firer reference in as 'source'
                        if (args.length === 1 && Neo.isObject(args[0])) {
                            args[0].source = me.id
                        }

                        // remove the listener if it has the once flag
                        handler.once && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(listeners[name], handler);

                        if (Neo.isNumber(delay) && delay > 0) {
                            me.delayedCallback(cb, handler.data ? args.concat(handler.data) : args, delay)
                        } else {
                            cb.fn.apply(cb.scope, handler.data ? args.concat(handler.data) : args)
                        }
                    }
                }
            }
        }
    }

    /**
     * @param {Object} config
     */
    initObservable(config) {
        let me = this,
            proto = me.__proto__,
            ctor  = proto.constructor,
            listeners;

        if (config.listeners) {
            me.listeners = config.listeners;
            delete config.listeners
        }

        listeners = me.listeners;

        me.listeners = {};

        if (listeners) {
            if (Neo.isObject(listeners)) {
                listeners = {...listeners}
            }

            me.addListener(listeners);
        }

        while (proto?.constructor.isClass) {
            ctor = proto.constructor;

            if (ctor.observable && !ctor.listeners) {
                Object.assign(ctor, {
                    addListener   : me.addListener,
                    fire          : me.fire,
                    listeners     : {},
                    on            : me.on,
                    removeListener: me.removeListener,
                    un            : me.un
                })
            }

            proto = proto.__proto__
        }
    }

    /**
     * Alias for addListener
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number} [order]
     * @returns {String} eventId
     */
    on(...args) {
        return this.addListener(...args)
    }

    /**
     * There are different syntax's how you can use this method.
     * Using the eventId:
     * ```
     * this.removeListener('change', 'neo-event-7');
     * ```
     * Passing the handler method:
     * ```
     * this.removeListener('change', this.onChange, this);
     * ```
     * Passing an object:
     * ```
     * me.field.un({
     *     change                    : me.onFieldChange,
     *     changeClearToOriginalValue: me.onFieldChange,
     *     scope                     : me
     * });
     * ```
     * @param {Object|String} name
     * @param {Function|String} [eventId]
     * @param {Neo.core.Base} [scope]
     */
    removeListener(name, eventId, scope) {
        let me = this,
            i, len, listener, listeners, match;

        if (Neo.isFunction(eventId)) {
            me.removeListener({[name]: eventId, scope});
            return
        }

        if (Neo.isObject(name)) {
            if (name.scope) {
                scope = name.scope;
                delete name.scope;
            }

            Object.entries(name).forEach(([key, value]) => {
                listeners = me.listeners[key] || [];
                i         = 0;
                len       = listeners.length;

                for (; i < len; i++) {
                    listener = listeners[i];

                    if (
                        listener.fn.name === (Neo.isString(value) ? value : value.name) &&
                        listener.scope   === scope
                    ) {
                        listeners.splice(i, 1);
                        break
                    }
                }
            });
        } else if (Neo.isString(eventId)) {
            listeners = me.listeners[name];
            match     = false;

            listeners.forEach((eventConfig, idx) => {
                if (eventConfig.id === eventId) {
                    return match = idx
                }
            });

            if (match !== false) {
                listeners.splice(match, 1)
            }
        }
    }

    // removeAllListeners: function(name) {

    // },

    // suspendListeners: function(queue) {

    // },

    // resumeListeners: function() {

    // }

    /**
     * Alias for removeListener
     * @param {Object|String} name
     * @param {String} [eventId]
     */
    un(...args) {
        this.removeListener(...args);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Observable));


/***/ }),

/***/ "./src/core/Util.mjs":
/*!***************************!*\
  !*** ./src/core/Util.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.core.Util
 * @extends Neo.core.Base
 */
class Util extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * A regex to remove camel case syntax
     * @member {RegExp} decamelRegEx=/([a-z])([A-Z])/g
     * @protected
     * @static
     */
    static decamelRegEx = /([a-z])([A-Z])/g

    static config = {
        /**
         * @member {String} className='Neo.core.Util'
         * @protected
         */
        className: 'Neo.core.Util',
        /**
         * @member {String} ntype='core-util'
         * @protected
         */
        ntype: 'core-util'
    }

    /**
     * @param {Object} scope
     * @param {String[]} values
     */
    static bindMethods(scope, values) {
        values.forEach(value => {
            scope[value] = scope[value].bind(scope)
        })
    }

    /**
     * Transforms a styles string into a styles object using camelcase syntax
     * @param {String} string The styles string to parse
     * @returns {Object} The camelcase styles object
     */
    static createStyleObject(string) {
        let parts;

        // split(';') does fetch semicolons inside brackets
        // -> background-image: "url('data:image/png;base64,...

        // TODO: Cache all regex
        return string.split(/;(?=[^\)]*(?:\(|$))/g).reduce((obj, el) => {
            // we have to split by the first colon only
            // -> background-image: url('http://example.com/image.png')
            parts = el.split((/:(.+)/)).map(function (x) {
                let num = parseFloat(x);

                return x == num ? num : x.trim()
            });

            if (parts[0] !== '') {
                parts[0] = parts[0].replace(/-([a-z])/g, (str, letter) => {
                    return letter.toUpperCase()
                });

                obj[parts[0]] = parts[1]
            }
            return obj
        }, {})
    }

    /**
     * Converts a styles object which can use camelcase syntax into a styles string
     * @param {Object} styles The styles object
     * @returns {String} The styles string (DOM ready)
     */
    static createStyles(styles) {
        let style = '';

        Object.entries(styles).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
                style += Util.decamel(key) + ':' + value + ';'
            }
        });

        return style
    }

    /**
     * Transforms all uppercase characters of a string into -lowercase.
     * Does not touch special characters.
     * @param {String} value The input containing uppercase characters
     * @returns {String} The lowercase output
     */
    static decamel(value) {
        return value.replace(Util.decamelRegEx, '$1-$2').toLowerCase()
    }

    /**
     * Returns true if the passed value is an array
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isArray(value) {
        return Array.isArray(value)
    }

    /**
     * Returns true if the passed value is a boolean
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isBoolean(value) {
        return typeof value === 'boolean'
    }

    /**
     * Returns true if the passed value is not undefined
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isDefined(value) {
        return typeof value !== 'undefined'
    }

    /**
     * Returns true if the passed value is an empty Array, Object or String
     * @param {Array|Object|String} value The value to test
     * @returns {Boolean}
     */
    static isEmpty(value) {
        if (value === null || value === undefined) {
            return true
        }

        if (Array.isArray(value)) {
            return value.length === 0
        }

        if (value instanceof Date) {
            return false
        }

        if (Util.isObject(value)) {
            return Object.keys(value).length === 0
        }

        if (Util.isString(value)) {
            return value === ''
        }

        return false
    }

    /**
     * Returns true if the passed value is a function
     * @param {Function} value The value to test
     * @returns {Boolean}
     */
    static isFunction(value) {
        return typeof value === 'function'
    }

    /**
     * Returns true if the passed value is a number. Returns false for non-finite numbers
     * @param {Number} value The value to test
     * @returns {Boolean}
     */
    static isNumber(value){
        return typeof value === 'number' && isFinite(value)
    }

    /**
     * Returns true if the passed value is an object
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isObject(value) {
        return value?.constructor?.name === 'Object' || false
    }

    /**
     * Returns true if the passed value is a neo data record
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isRecord(value) {
        return value?.constructor?.name === 'Record' || false
    }

    /**
     * Returns true if the passed value is a string
     * @param {String} value The value to test
     * @returns {Boolean}
     */
    static isString(value) {
        return typeof value === 'string'
    }

    /**
     * Converts any iterable (strings, numeric indices and a length property) into a true array
     * @param {Object|String} iterable
     * @param {Number} [start=0] start index
     * @param {Number} [end=iterable.length] end index
     * @returns {Array}
     */
    static toArray(iterable, start, end) {
        let len;

        if (!iterable || !(len = iterable.length)) {
            return []
        }

        if (typeof iterable === 'string') {
            return iterable.split('')
        }

        return Array.prototype.slice.call(iterable, start || 0, end || len)
    }
}

Util = Neo.setupClass(Util);

// aliases
Neo.applyFromNs(Neo, Util, {
    bindMethods      : 'bindMethods',
    createStyleObject: 'createStyleObject',
    createStyles     : 'createStyles',
    decamel          : 'decamel',
    isArray          : 'isArray',
    isBoolean        : 'isBoolean',
    isDefined        : 'isDefined',
    isEmpty          : 'isEmpty',
    isFunction       : 'isFunction',
    isNumber         : 'isNumber',
    isObject         : 'isObject',
    isRecord         : 'isRecord',
    isString         : 'isString',
    toArray          : 'toArray'
}, true);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Util);


/***/ }),

/***/ "./src/core/_export.mjs":
/*!******************************!*\
  !*** ./src/core/_export.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* reexport safe */ _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Compare: () => (/* reexport safe */ _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   IdGenerator: () => (/* reexport safe */ _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Observable: () => (/* reexport safe */ _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Util: () => (/* reexport safe */ _Util_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Compare.mjs */ "./src/core/Compare.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");
/* harmony import */ var _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Util_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Util.mjs */ "./src/core/Util.mjs");









/***/ }),

/***/ "./src/main/DeltaUpdates.mjs":
/*!***********************************!*\
  !*** ./src/main/DeltaUpdates.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DomAccess.mjs */ "./src/main/DomAccess.mjs");
/* harmony import */ var _vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vdom/domConstants.mjs */ "./src/vdom/domConstants.mjs");




const NeoConfig = Neo.config;

/**
 * Logic to apply the deltas generated by vdom.Helper to the real DOM
 * @class Neo.main.DeltaUpdates
 * @extends Neo.core.Base
 * @singleton
 */
class DeltaUpdates extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.DeltaUpdates'
         * @protected
         */
        className: 'Neo.main.DeltaUpdates',
        /**
         * @member {Number} countDeltas=0
         * @protected
         */
        countDeltas: 0,
        /**
         * @member {Number} countDeltasPer250ms=0
         * @protected
         */
        countDeltasPer250ms: 0,
        /**
         * @member {Number} countUpdates=0
         * @protected
         */
        countUpdates: 0,
        /**
         * @member {Boolean} renderCountDeltas_=false
         * @protected
         */
        renderCountDeltas_: false,
        /**
         * @member {Boolean} singleton=true
         */
        singleton: true
    }

    /**
     * @member {Number} logDeltasIntervalId=0
     * @protected
     */
    logDeltasIntervalId = 0
    /**
     * Private property to store the dynamically loaded renderer module.
     * @member {Neo.main.render.DomApiRenderer|Neo.main.render.DomApiRenderer|null} #renderer=null
     * @private
     */
    #renderer = null

    /**
     * Private property to signal that the renderer module has been loaded.
     * This will be a Promise that resolves when the module is ready.
     * @private
     * @member {Promise<void>|null} #_readyPromise
     */
    #_readyPromise = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (Neo.config.renderCountDeltas) {
            me.renderCountDeltas = true
        }

        // Initiate the asynchronous loading of the renderer here.
        me.#_readyPromise = (async () => {
            try {
                let module;

                if (NeoConfig.useStringBasedMounting) {
                    module = await __webpack_require__.e(/*! import() */ "src_main_render_StringBasedRenderer_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./render/StringBasedRenderer.mjs */ "./src/main/render/StringBasedRenderer.mjs"))
                } else {
                    module = await __webpack_require__.e(/*! import() */ "src_main_render_DomApiRenderer_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./render/DomApiRenderer.mjs */ "./src/main/render/DomApiRenderer.mjs"))
                }

                me.#renderer = module.default
            } catch (err) {
                console.error('DeltaUpdates: Failed to load renderer module:', err);
                throw err // Re-throw to propagate initialization failures
            }
        })()
    }

    /**
     * Triggered after the renderCountDeltas config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRenderCountDeltas(value, oldValue) {
        let me                    = this,
            {logDeltasIntervalId} = me,
            node;

        if (value) {
            if (logDeltasIntervalId === 0) {
                me.logDeltasIntervalId = setInterval(() => {
                    node = document.getElementById('neo-delta-updates');

                    if (node) {
                        node.innerHTML = String(me.countDeltasPer250ms * 4)
                    }

                    me.countDeltasPer250ms = 0
                }, 250)
            }
        } else {
            logDeltasIntervalId && clearInterval(logDeltasIntervalId);
            me.logDeltasInterval = 0
        }
    }

    /**
     * @param {HTMLElement} node
     * @param {String}      nodeName
     */
    changeNodeName(node, nodeName) {
        let {attributes} = node,
            clone        = document.createElement(nodeName),
            i            = 0,
            len          = attributes.length,
            attribute;

        if (node) {
            for (; i < len; i++) {
                attribute = attributes.item(i);
                clone.setAttribute(attribute.nodeName, attribute.nodeValue)
            }

            clone.innerHTML= node.innerHTML;

            node.parentNode.replaceChild(clone, node)
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.id
     */
    focusNode({id}) {
        _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(id)?.focus()
    }

    /**
     * Inserts a new node into the DOM tree based on delta updates.
     * This method handles both string-based (outerHTML) and direct DOM API (vnode) mounting.
     * It ensures the node is inserted at the correct index within the parent.
     *
     * Implementation Details & Considerations:
     * - `parentNode.children` contains only element nodes (tags).
     * - `parentNode.childNodes` contains all nodes, including text and comment nodes.
     * - Since every `vtype:'text'` is wrapped inside a comment block (as an ID),
     *   calculating a "realIndex" is necessary for string-based insertions to
     *   correctly account for non-element nodes.
     * - `insertAdjacentHTML()` is generally faster than creating a node via template,
     *   but it's only available for manipulating children (elements), not `childNodes` (all nodes).
     * - For performance, in cases where there are no comment nodes (i.e., no wrapped text nodes),
     *   the method prioritizes `insertAdjacentHTML()` when `useStringBasedMounting` is true.
     *
     * @param {Object}         delta
     * @param {Boolean}        delta.hasLeadingTextChildren Flag to honor leading comments, which require special treatment.
     * @param {Number}         delta.index                  The index at which to insert the new node within its parent.
     * @param {String}         [delta.outerHTML]            The string representation of the new node (for string-based mounting).
     * @param {String}         delta.parentId               The ID of the parent DOM node.
     * @param {Neo.vdom.VNode} [delta.vnode]                The VNode representation of the new node (for direct DOM API mounting).
     */
    insertNode({hasLeadingTextChildren, index, outerHTML, parentId, vnode}) {
        // This method is synchronous and *expects* the renderer to be loaded
        if (!this.#renderer) {
            console.error('DeltaUpdates renderer not ready during insertNode!');
            return
        }

        const parentNode = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElementOrBody(parentId);

        if (parentNode) {
            if (!NeoConfig.useStringBasedMounting) {
                this.#renderer.createDomTree({index, isRoot: true, parentNode, vnode})
            } else {
                this.#renderer.insertNodeAsString({hasLeadingTextChildren, index, outerHTML, parentNode})
            }
        }
    }

    /**
     * Moves an existing DOM node to a new position within its parent
     * or to a new parent.
     * This method directly manipulates the DOM using the pre-calculated physical index.
     *
     * @param {Object} delta
     * @param {String} delta.id       The ID of the DOM node to move.
     * @param {Number} delta.index    The physical index at which to insert the node
     * @param {String} delta.parentId The ID of the target parent DOM node.
     */
    moveNode({id, index, parentId}) {
        let node       = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(id),
            parentNode = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(parentId);

        if (node && parentNode) {
            // If the target index is at or beyond the end of the parent's current childNodes, append the node.
            if (index >= parentNode.childNodes.length) {
                parentNode.appendChild(node)
            } else {
                // Get the reference node at the target physical index.
                let referenceNode = parentNode.childNodes[index];

                // Only proceed if the node is not already at its target position.
                if (node !== referenceNode) {
                    // Perform a direct swap operation if immediate element siblings.
                    if (node.nodeType === 1 && node === referenceNode.nextElementSibling) {
                        node.replaceWith(referenceNode)
                    }

                    parentNode.insertBefore(node, referenceNode)
                }
            }
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.parentId
     */
    removeAll({parentId}) {
        let node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(parentId);

        if (node) {
            node.innerHTML = ''
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.id
     * @param {String} delta.parentId
     */
    removeNode({id, parentId}) {
        const node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(id);

        if (node) {
            node.remove();
        }
        // Potentially a vtype: 'text' node (wrapped between 2 comments)
        else if (parentId) {
            const
                parentNode = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElementOrBody(parentId),
                isComment  = Node.COMMENT_NODE;

            if (parentNode) {
                // Find the starting comment node using its id marker
                const startComment = Array.from(parentNode.childNodes).find(n =>
                    n.nodeType === isComment && n.nodeValue.includes(` ${id} `)
                );

                if (startComment) {
                    const
                        textNode = startComment.nextSibling,
                        // Ensure endComment is a comment node before attempting to remove
                        endComment = textNode?.nextSibling?.nodeType === isComment ? textNode.nextSibling : null;

                    // Remove the three parts: start comment, text node, end comment
                    startComment.remove();
                    textNode?.remove();
                    endComment?.remove()
                }
            }
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.fromId
     * @param {String} delta.parentId
     * @param {String} delta.toId
     */
    replaceChild({fromId, parentId, toId}) {
        let node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(parentId);

        node?.replaceChild(_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(toId), _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(fromId))
    }

    /**
     * @param {Object} delta
     * @param {String} [delta.id]
     * @param {String} [delta.value
     */
    setTextContent({id, value}) {
        let node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(id);

        if (node) {
            node.textContent = value
        }
    }

    /**
     * @param {Object} delta
     * @param {Object} [delta.attributes]
     * @param {String} [delta.cls]
     * @param {String} [delta.id]
     * @param {String} [delta.innerHTML]
     * @param {String} [delta.outerHTML]
     * @param {Object} [delta.style]
     */
    updateNode(delta) {
        let me   = this,
            node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElementOrBody(delta.id);

        if (!node) {
            console.log('node not found', delta.id);
        }

        if (node) {
            Object.entries(delta).forEach(([prop, value]) => {
                switch(prop) {
                    case 'attributes':
                        Object.entries(value).forEach(([key, val]) => {
                            if (_vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_2__.voidAttributes.has(key)) {
                                node[key] = val === 'true' // vnode attribute values get converted into strings
                            } else if (val === null || val === '') {
                                if (key === 'value') {
                                    node[key] = '' // input fields => pseudo attribute can not be removed
                                } else {
                                    node.removeAttribute(key)
                                }
                            } else if (key === 'id') {
                                node[NeoConfig.useDomIds ? 'id' : 'data-neo-id'] = val
                            } else if (key === 'spellcheck' && val === 'false') {
                                // see https://github.com/neomjs/neo/issues/1922
                                node[key] = false
                            } else {
                                if (key === 'value') {
                                    node[key] = val
                                } else {
                                    node.setAttribute(key, val)
                                }
                            }
                        });
                        break
                    case 'cls':
                        value.add    && node.classList.add(...value.add);
                        value.remove && node.classList.remove(...value.remove);
                        break
                    case 'innerHTML':
                        node.innerHTML = value || '';
                        break
                    case 'nodeName':
                        me.changeNodeName(node, value);
                        break
                    case 'outerHTML':
                        node.outerHTML = value || '';
                        break
                    case 'style':
                        if (Neo.isObject(value)) {
                            Object.entries(value).forEach(([key, val]) => {
                                let important;

                                if (Neo.isString(val) && val.includes('!important')) {
                                    val = val.replace('!important', '').trim();
                                    important = 'important'
                                }

                                node.style.setProperty(Neo.decamel(key), val, important)
                            })
                        }
                        break
                }
            })
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.id
     * @param {String} delta.parentId
     * @param {String} delta.value
     */
    updateVtext({id, parentId, value}) {
        let node      = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(parentId),
            innerHTML = node.innerHTML,
            startTag  = `<!-- ${id} -->`,
            reg       = new RegExp(startTag + '[\\s\\S]*?<!-- \/neo-vtext -->');

        node.innerHTML = innerHTML.replace(reg, value)
    }

    /**
     * @param {Object} data
     * @param {Object|Object[]} data.deltas
     * @param {String} data.id
     * @param {String} [data.origin='app']
     */
    update(data) {
        // This method is synchronous and *expects* the renderer to be loaded
        if (!this.#renderer) {
            console.error('DeltaUpdates renderer not ready during insertNode!');
            return
        }

        let me       = this,
            {deltas} = data,
            i        = 0,
            len;

        deltas = Array.isArray(deltas) ? deltas : [deltas];
        len    = deltas.length;

        if (NeoConfig.logDeltaUpdates && len > 0) {
            me.countDeltas += len;
            me.countUpdates++;
            console.log('update ' + me.countUpdates, 'total deltas ', me.countDeltas, Neo.clone(data, true))
        }

        if (NeoConfig.renderCountDeltas && len > 0) {
            me.countDeltasPer250ms += len
        }

        for (; i < len; i++) {
            me[deltas[i].action || 'updateNode'](deltas[i])
        }

        Neo.worker.Manager.sendMessage(data.origin || 'app', {
            action : 'reply',
            replyId: data.id,
            success: true
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DeltaUpdates));


/***/ }),

/***/ "./src/main/DomAccess.mjs":
/*!********************************!*\
  !*** ./src/main/DomAccess.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DomUtils.mjs */ "./src/main/DomUtils.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/String.mjs */ "./src/util/String.mjs");





const
    doPreventDefault = e => e.preventDefault(),
    filterTabbable   = e => !e.classList.contains('neo-focus-trap') && _DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isTabbable(e) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP,
    lengthRE         = /^\d+\w+$/,

    capturePassive = {
        capture: true,
        passive: true
    },

    fontSizeProps = [
        'font-family',
        'font-kerning',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-weight',
        'letter-spacing',
        'line-height',
        'text-decoration',
        'text-transform',
        'word-break'
    ],

    modifierKeys = {
        Shift   : 1,
        Alt     : 1,
        Meta    : 1,
        Control : 1
    };

/**
 * @class Neo.main.DomAccess
 * @extends Neo.core.Base
 * @singleton
 */
class DomAccess extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.main.DomAccess'
         * @protected
         */
        className: 'Neo.main.DomAccess',
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'addScript',
                'align',
                'applyBodyCls',
                'blur',
                'execCommand',
                'focus',
                'getAttributes',
                'getBoundingClientRect',
                'getScrollingDimensions',
                'measure',
                'monitorAutoGrow',
                'monitorAutoGrowHandler',
                'navigate',
                'navigateTo',
                'scrollBy',
                'scrollIntoView',
                'scrollTo',
                'scrollToTableRow',
                'selectNode',
                'setBodyCls',
                'setStyle',
                'syncModalMask',
                'trapFocus',
                'windowScrollTo'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @returns {HTMLElement}
     */
    get modalMask() {
        let me = this;

        if (!me._modalMask) {
            me._modalMask = document.createElement('div');
            me._modalMask.className = 'neo-dialog-modal-mask';
            me._modalMask.addEventListener('mousedown', doPreventDefault, {capture : true})
        }

        return me._modalMask
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.initGlobalListeners();

        // Set up our aligning callback which is called when things change which may
        // mean that alignments need to be updated.
        me.syncAligns = me.syncAligns.bind(me)
    }

    /**
     * @param {Object} alignSpec
     */
    addAligned(alignSpec) {
        const
            me                   = this,
            {id}                 = alignSpec,
            aligns               = me._aligns || (me._aligns = new Map()),
            resizeObserver       = me._alignResizeObserver || (me._alignResizeObserver = new ResizeObserver(me.syncAligns)),
            {constrainToElement} = alignSpec;

        // Set up listeners which monitor for changes
        if (!aligns.has(id)) {
            // Realign when target's layout-controlling element changes size
            resizeObserver.observe(alignSpec.offsetParent);

            // Realign when align to target changes size
            resizeObserver.observe(alignSpec.targetElement);

            // Realign when constraining element changes size
            if (constrainToElement) {
                resizeObserver.observe(constrainToElement)
            }
        }

        if (!me.hasDocumentScrollListener) {
            document.addEventListener('scroll', me.syncAligns, {
                capture: true,
                passive: true
            });

            me.hasDocumentScrollListener = true
        }

        if (!me.documentMutationObserver) {
            me.documentMutationObserver = new MutationObserver(me.onDocumentMutation.bind(me));

            me.documentMutationObserver.observe(document.body, {
                childList: true,
                subtree  : true
            })
        }

        aligns.set(id, alignSpec)
    }

    /**
     * @param {Object} data
     * @param {Boolean} data.async
     * @param {Boolean} [data.defer=false]
     * @param {String} [data.src=true]
     */
    addScript(data) {
        let script = document.createElement('script');

        if (!data.hasOwnProperty('async')) {
            data.async = true
        }

        Object.assign(script, data);

        document.head.appendChild(script)
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async align(data) {
        const
            me            = this,
            {constrainTo} = data,
            subject       = data.subject = me.getElement(data.id),
            {style}       = subject,
            align         = {...data},
            lastAlign     = me._aligns?.get(data.id);

        if (lastAlign) {
            subject.classList.remove(`neo-aligned-${lastAlign.result.position}`)
        }

        // Release any constrainTo or matchSize sizing which may have been imposed
        // by a previous align call.
        me.resetDimensions(align);

        // The Rectangle's align spec target and constrainTo must be Rectangles
        align.target = me.getClippedRect({id : data.targetElement = me.getElementOrBody(data.target)});

        if (!align.target) {
            // Set the Component with id data.id to hidden : true
            return Neo.worker.App.setConfigs({id: data.id, hidden: true})
        }

        data.offsetParent = data.targetElement.offsetParent;

        if (constrainTo) {
            align.constrainTo = me.getBoundingClientRect({id : data.constrainToElement = me.getElementOrBody(constrainTo)})
        }

        // Get an aligned clone of myRect aligned according to the align object
        const
            myRect = me.getBoundingClientRect(data),
            result = data.result = myRect.alignTo(align);

        Object.assign(style, {
            top       : 0,
            left      : 0,
            transform : `translate(${result.x}px,${result.y}px)`
        });

        if (result.width !== myRect.width) {
            style.width = `${result.width}px`
        }

        if (result.height !== myRect.height) {
            style.height = `${result.height}px`
        }

        // Place box shadow at correct edge
        subject.classList.add(`neo-aligned-${result.position}`);

        // Register an alignment to be kept in sync
        me.addAligned(data)
    }

    /**
     * @param {Object} data
     * @param {String[]} data.cls
     */
    applyBodyCls(data) {
        let cls = data.cls || [];
        document.body.classList.add(...cls)
    }

    /**
     * Calls blur() on a node for a given dom node id
     * @param {Object} data
     * @returns {Object} obj.id => the passed id
     */
    blur(data) {
        this.getElement(data.id)?.blur();
        return {id: data.id}
    }

    /**
     * @param {Object} data
     * @param {String} data.command
     * @returns {Object} data
     */
    execCommand(data) {
        document.execCommand(data.command);
        return data
    }

    /**
     * Calls focus() on a node for a given dom node id
     * @param {Object} data
     * @param {Boolean} data.children
     * @param {String} data.id
     * @returns {Object} obj.id => the passed id
     */
    focus({children, id}) {
        let node = this.getElement(id);

        if (node) {
            // The children property means focus inner elements if possible.
            if (!_DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFocusable(node) && children) {
                // query for the first focusable descendent
                node = _DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].query(node, _DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFocusable)
            }

            if (node) {
                node.focus();

                if (Neo.isNumber(node.selectionStart)) {
                    node.selectionStart = node.selectionEnd = node.value.length
                }
            }
        }

        return {id}
    }

    /**
     * Returns the attributes for a given dom node id
     * @param {Object}          data
     * @param {String|String[]} data.attributes either an attribute or an array of attributes
     * @param {String|String[]} data.id either an id or an array of ids
     * @returns {Array|Object} In case id is an array, an array of attribute objects is returned, otherwise an object
     */
    getAttributes({attributes, id}) {
        let returnData;

        if (Array.isArray(id)) {
            returnData = [];

            id.forEach(id => {
                returnData.push(this.getAttributes({attributes, id}))
            })
        } else {
            let node = this.getElementOrBody(id);

            returnData = {};

            if (node) {
                if (!Array.isArray(attributes)) {
                    attributes = [attributes]
                }

                attributes.forEach(attribute => {
                    returnData[attribute] = node[attribute]
                })
            }
        }

        return returnData
    }

    /**
     * Returns node.getBoundingClientRect() for a given dom node id
     * @param {Object} data
     * @param {Array|String} data.id either an id or an array of ids
     * @returns {DOMRect|DOMRect[]} In case id is an array, an array of DomRects is returned, otherwise an DomRect object
     */
    getBoundingClientRect(data) {
        let me = this,
            returnData;

        if (Array.isArray(data.id)) {
            return data.id.map(id => me.getBoundingClientRect({id}))
        } else {
            let node = me.getElementOrBody(data.nodeType ? data : data.id),
                rect = {},
                minWidth, minHeight, style;

            returnData = {};

            if (node) {
                rect      = node.getBoundingClientRect();
                style     = node.ownerDocument.defaultView.getComputedStyle(node);
                minWidth  = style.getPropertyValue('min-width');
                minHeight = style.getPropertyValue('min-height');

                // DomRect does not support spreading => {...DomRect} => {}
                returnData = _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].clone(rect);

                // Measure minWidth/minHeight in other units like em/rem etc
                // Note that 0px is what the DOM reports if no minWidth is specified
                // so we do not report a minimum in these cases.
                if (lengthRE.test(minWidth) && minWidth !== '0px') {
                    returnData.minWidth = me.measure({value: minWidth, id: node})
                }
                if (lengthRE.test(minHeight) && minHeight !== '0px') {
                    returnData.minHeight = me.measure({value: minHeight, id: node})
                }
            }
        }

        return returnData
    }

    /**
     * @param {Object|String} data
     * @returns {Neo.util.Rectangle}
     */
    getClippedRect(data) {
        let me            = this,
            node          = me.getElement(typeof data === 'object' ? data.id : data),
            {defaultView} = node.ownerDocument,
            rect          = me.getBoundingClientRect(node);

        for (let parentElement = node.offsetParent; parentElement && rect && parentElement !== document.documentElement; parentElement = parentElement.parentElement) {
            if (defaultView.getComputedStyle(parentElement).getPropertyValue('overflow') !== 'visible') {
                rect = rect.intersects(this.getBoundingClientRect(parentElement))
            }
        }

        return rect
    }

    /**
     * @param {String|HTMLElement} nodeId
     * @returns {HTMLElement|null}
     * @protected
     */
    getElement(nodeId) {
        let node = nodeId?.nodeType ?
            nodeId : Neo.config.useDomIds ?
                document.getElementById(nodeId) :
                document.querySelector(`[data-neo-id='${nodeId}']`);

        return node || null
    }

    /**
     * @param {String|HTMLElement} nodeId='document.body'
     * @returns {HTMLElement|null}
     * @protected
     */
    getElementOrBody(nodeId='document.body') {
        if (!nodeId) {
            return null
        }

        return nodeId.nodeType ? nodeId : (nodeId === 'body' || nodeId === 'document.body') ? document.body : this.getElement(nodeId)
    }

    /**
     * @param {HTMLElement|Object} data
     * @param {String|String[]} data.id
     * @returns {Object}
     */
    getScrollingDimensions(data) {
        let me = this;

        if (Array.isArray(data.id)) {
            return data.id.map(id => me.getScrollingDimensions({id}))
        } else {
            let node = data.nodeType ? data : me.getElementOrBody(data.id);

            return {
                clientHeight: node?.clientHeight,
                clientWidth : node?.clientWidth,
                scrollHeight: node?.scrollHeight,
                scrollWidth : node?.scrollWidth
            }
        }
    }

    /**
     *
     */
    initGlobalListeners() {
        let me = this;

        document.addEventListener('blur',      me.onDocumentBlur     .bind(me), capturePassive);
        document.addEventListener('keydown',   me.onDocumentKeyDown  .bind(me), capturePassive);
        document.addEventListener('keyup',     me.onDocumentKeyUp    .bind(me), capturePassive);
        document.addEventListener('mousedown', me.onDocumentMouseDown.bind(me), {capture : true})
    }

    /**
     * @param {HTMLElement} el
     * @returns {Boolean}
     */
    isAlignSubject(el) {
        return [...this._aligns?.values()].some(align => align.subject === el)
    }

    /**
     * Include a script into the document.head
     * You can add more attributes if needed. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script
     * @param {String} src
     * @param {Object} opts={defer:true}
     * @param {Boolean} [opts.async]
     * @param {Boolean} [opts.defer]
     * @returns {Promise<unknown>}
     */
    loadScript(src, opts={defer:true}) {
        let script;

        return new Promise((resolve, reject) => {
            script = document.createElement('script');

            Object.assign(script, {
                ...opts,
                onerror: reject,
                onload : resolve,
                src
            });

            document.head.appendChild(script)
        })
    }

    /**
     * Include a link into the document.head
     * @param {String} href
     * @param {Object} dataset=null
     * @returns {Promise<unknown>}
     */
    loadStylesheet(href, dataset=null) {
        let link;

        return new Promise((resolve, reject) => {
            link = document.createElement('link');

            Object.assign(link, {
                href,
                onerror: reject,
                onload : resolve,
                rel    : 'stylesheet',
                type   : 'text/css'
            });

            if (dataset) {
                Object.assign(link.dataset, dataset)
            }

            document.head.appendChild(link)
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Number|String} data.value
     * @returns {Number|String}
     */
    measure({ value, id }) {
        const node = id.nodeType === 1 ? id : this.getElement(id);

        if (value.endsWith('%')) {
            const fraction = parseFloat(value) / 100;

            return (node.offsetParent?.getBoundingClientRect().height || 0) * fraction
        }
        // If it's any other CSS unit than px, it needs to be measured using the DOM
        else if (isNaN(value) && !value.endsWith('px')) {
            const elStyle = node.ownerDocument.defaultView.getComputedStyle(node);

            let d = this._measuringDiv;

            if (!d) {
                d = this._measuringDiv = document.createElement('div');
                d.style = 'position:fixed;top:-10000px;left:-10000px'
            }

            // In case a DOM update cleared it out
            document.body.appendChild(d);

            // Set all the font-size, font-weight etc style properties so that
            // em/ex/rem etc units will match
            fontSizeProps.forEach(prop => {
                d.style[prop] = elStyle[prop];
            });
            d.className = node.className;
            d.style.width = value;

            // Read back the resulting computed pixel width
            value = elStyle.width;

        }
        // If it's a number, or ends with px, use the numeric value.
        else {
            value = parseFloat(value)
        }

        return value
    }

    /**
     * Checks the overflow status of a TextAreaField's &lt;textarea> element and updates the
     * height so that there is never a vertical scrollbar.
     * @param {Object} data
     */
    async monitorAutoGrow(data) {
        const
            me     = this,
            target = data.subject = me.getElement(data.id);

        // We need to update the height on every input event is autoGrow is truthy.
        target[data.autoGrow ? 'addEventListener' : 'removeEventListener']('input', me.monitorAutoGrowHandler);

        // Fix the height up immediately too
        data.autoGrow && me.monitorAutoGrowHandler({
            target
        })
    }

    /**
     *
     * @param {Event|Object} data
     * @param {String} [data.id]
     * @param {HTMLElement} [data.target]
     */
    monitorAutoGrowHandler(data) {
        const target = data.target || this.getElement(data.id);

        if (target) {
            const
                { style }              = target,
                { style : inputStyle } = target.closest('.neo-textarea');

            // Measure the scrollHeight when forced to overflow, then set height to encompass the scrollHeight
            style.height = style.minHeight = 0;
            inputStyle.setProperty('--textfield-input-height', `${target.scrollHeight + 5}px`);
            inputStyle.setProperty('height', '');
            style.height = style.minHeight = ''
        }
    }

    /**
     *
     */
    onDocumentBlur() {
        Neo.altKeyDown = Neo.controlKeyDown = Neo.metaKeyDown = Neo.shiftKeyDown = false
    }

    /**
     * @param {KeyboardEvent} keyEvent
     */
    onDocumentKeyDown(keyEvent) {
        if (modifierKeys[keyEvent.key]) {
            // e.g. Neo.isShiftKeyDown = true or Neo.isControlKeyDown = true.
            // Selection can consult this value
            Neo[`${_util_String_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].uncapitalize(keyEvent.key)}KeyDown`] = true
        }
    }

    /**
     * @param {KeyboardEvent} keyEvent
     */
    onDocumentKeyUp(keyEvent) {
        if (modifierKeys[keyEvent.key]) {
            Neo[`${_util_String_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].uncapitalize(keyEvent.key)}KeyDown`] = false
        }
    }

    /**
     * @param {Array} mutations
     */
    onDocumentMutation(mutations) {
        const me = this;

        // If the mutations are purely align subjects being added or removed, take no action.
        if (!mutations.every(({ type, addedNodes, removedNodes }) => {
            if (type === 'childList') {
                const nodes = [...Array.from(addedNodes), ...Array.from(removedNodes)];

                return nodes.every(a => me.isAlignSubject(a))
            }
        })) {
            me.syncAligns()
        }
    }

    /**
     * @param {MouseEvent} e
     */
    onDocumentMouseDown(e) {
        let focusController = e.target?.closest('[data-focus]');

        // data-focus on an element means reject mousedown gestures, and move focus
        // to the referenced element.
        if (focusController) {
            e.preventDefault();
            document.getElementById(focusController.dataset.focus)?.focus()
        }
    }

    /**
     *
     */
    onDomContentLoaded() {
        Neo.config.applyBodyCls && this.applyBodyCls({cls: ['neo-body']});
        Neo.config.applyFixedPositionToHtmlTag && document.documentElement.style.setProperty('position', 'fixed')
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.nodeId
     */
    onGetOffscreenCanvas(data) {
        let me        = this,
            node      = me.getElement(data.nodeId),
            offscreen = node.transferControlToOffscreen();

        data.offscreen = offscreen;

        Neo.worker.Manager.sendMessage(data.origin, {
            action : 'reply',
            data,
            replyId: data.id,
            success: true
        }, [offscreen])
    }

    /**
     * @param {Object} data
     * @param {String[]} data.attributes
     * @param {Array} data.functions An array containing strings and/or objects
     * @param {String[]} data.styles
     * @param {String} data.vnodeId
     * @protected
     */
    onReadDom(data) {
        let attributes    = data.attributes || [],
            functions     = data.functions  || [],
            styles        = data.styles     || [],
            {vnodeId}     = data,
            retAttributes = {},
            retFunctions  = {},
            retStyles     = {},
            element       = vnodeId ? this.getElement(vnodeId) : null,
            fnName, scope;

        attributes.forEach(key => {
            retAttributes[key] = element[key]
        });

        functions.forEach((key, index) => {
            if (Neo.isObject(key)) {
                key.params         = key.params         || [];
                key.paramIsDomNode = key.paramIsDomNode || [];

                scope = key.scope ? document[key.scope] : element;

                key.params.forEach((param, paramIndex) => {
                    if (key.paramIsDomNode[paramIndex] === true) {
                        key.params[paramIndex] = this.getElement(key.params[paramIndex])
                    }
                });

                fnName = key.returnFnName ? key.returnFnName : index;
                retFunctions[fnName] = scope[key.fn](...key.params);

                if (key.returnValue) {
                    retFunctions[fnName] = retFunctions[fnName][key.returnValue]
                }
            } else {
                retFunctions[key] = element[key]()
            }
        });

        styles.forEach(key => {
            retStyles[key] = element.style[key]
        });

        Object.assign(data, {
            attributes: retAttributes,
            functions : retFunctions,
            styles    : retStyles
        });

        Neo.worker.Manager.sendMessage(data.origin, {
            action : 'reply',
            data,
            replyId: data.id,
            success: true
        })
    }

    /**
     * @param data
     * @param data.target
     * @param data.relatedTarget
     */
    onTrappedFocusMovement({ target, relatedTarget }) {
        const backwards = relatedTarget && (target.compareDocumentPosition(relatedTarget) & 4);

        if (target.matches('.neo-focus-trap')) {
            const
                containingEement = target.parentElement,
                treeWalker       = containingEement.$treeWalker,
                topFocusTrap     = containingEement.$topFocusTrap,
                bottomFocusTrap  = containingEement.$bottomFocusTrap;

            treeWalker.currentNode = backwards ? bottomFocusTrap : topFocusTrap;
            treeWalker[backwards ? 'previousNode' : 'nextNode']();

            requestAnimationFrame(() => treeWalker.currentNode.focus())
        }
    }

    /**
     * @param {Object} data
     * @protected
     */
    read(data) {
        Neo.isFunction(data) && data()
    }

    /**
     * Resets any DOM sizing configs to the last externally configured value.
     *
     * This is used during aligning to release any constraints applied by a previous alignment.
     * @param {Object} align
     * @protected
     */
    resetDimensions(align) {
        Object.assign(this.getElement(align.id).style, {
            flex     : align.configuredFlex,
            height   : align.configuredHeight,
            maxHeight: align.configuredMaxHeight,
            maxWidth : align.configuredMaxWidth,
            minHeight: align.configuredMinHeight,
            minWidth : align.configuredMinWidth,
            width    : align.configuredWidth
        })
    }

    /**
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollBy
     * @param {Object} data
     * @param {String} data.behavior='auto' auto, instant, smooth
     * @param {String} data.direction='top' left, top
     * @param {String} data.id
     * @param {Number} data.value
     * @returns {Object} obj.id => the passed id
     */
    scrollBy({behavior='auto', direction='top', id, value}) {
        this.getElement(id)?.scrollBy({behavior, [direction]: value});
        return {id}
    }

    /**
     * You can either pass the id or a querySelector
     * @param {Object} data
     * @param {String} [data.id]
     * @param {String} data.behavior='smooth'
     * @param {String} data.block='start'
     * @param {Number} data.delay=500
     * @param {String} data.inline='nearest'
     * @param {String} [data.querySelector]
     * @returns {Promise<any>}
     */
    scrollIntoView({id, behavior='smooth', block='start', delay=500, inline='nearest', querySelector}) {
        let node = id ? this.getElement(id) : document.querySelector(querySelector),
            opts = {behavior, block, inline};

        if (behavior !== 'smooth') {
            node.scrollIntoView(opts)
        } else {
            // scrollIntoView() does not provide a callback yet.
            // See: https://github.com/w3c/csswg-drafts/issues/3744
            return new Promise(resolve => {
                if (node) {
                    let hasListener = 'scrollend' in window;

                    hasListener && document.addEventListener('scrollend', () => resolve(), {capture: true, once: true});

                    node.scrollIntoView(opts);

                    !hasListener && this.timeout(delay).then(() => {resolve()})
                } else {
                    resolve()
                }
            })
        }
    }

    /**
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo
     * @param {Object} data
     * @param {String} data.behavior='auto' auto, instant, smooth
     * @param {String} data.direction='top' left, top
     * @param {String} data.id
     * @param {Number} data.value
     * @returns {Object} obj.id => the passed id
     */
    scrollTo({behavior='auto', direction='top', id, value}) {
        this.getElement(id)?.scrollTo({behavior, [direction]: value});
        return {id}
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.behavior='smooth'
     * @param {Number} data.offset=34
     * @returns {Object} obj.id => the passed id
     */
    scrollToTableRow({id, behavior='smooth', offset=34}) {
        let node = this.getElement(id); // tr tag

        if (node) {
            let tableNode   = node.parentNode.parentNode,
                wrapperNode = tableNode.parentNode,
                tableTop    = tableNode.getBoundingClientRect().top,
                top         = node.getBoundingClientRect().top;

            wrapperNode.scrollTo({
                behavior,
                top: top - tableTop - offset
            })
        }

        return {id}
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Number} [data.start=0]
     * @param {Number} [data.end=99999]
     * @returns {Object} obj.id => the passed id
     */
    selectNode(data) {
        let node  = this.getElement(data.id),
            start = Neo.isNumber(data.start) ? data.start : 0,
            end   = Neo.isNumber(data.end)   ? data.end   : 99999;

        if (node) {
            node.select();
            node.setSelectionRange(start, end)
        }

        return {id: data.id}
    }

    /**
     * @param {Object} data
     * @param {String[]} data.add
     * @param {Object[]} data.remove
     */
    setBodyCls(data) {
        document.body.classList.remove(...data.remove || []);
        document.body.classList.add(...data.add || [])
    }

    /**
     * Not recommended to use => stick to vdom updates.
     * Can be handy for custom CSS based animations though.
     * @param {Object} data
     * @param {String} data.id A node id or 'document.body'
     * @param {Object} data.style
     * @returns {Object} obj.id => the passed id
     */
    setStyle(data) {
        let node = this.getElementOrBody(data.id);

        if (node) {
            Object.entries(data.style).forEach(([key, value]) => {
                if (Neo.isString(value) && value.includes('!important')) {
                    value = value.replace('!important', '').trim();
                    node.style.setProperty(Neo.decamel(key), value, 'important')
                } else {
                    node.style[Neo.decamel(key)] = value
                }
            })
        }

        return {id: data.id}
    }

    /**
     *
     */
    syncAligns() {
        const
            me        = this,
            {_aligns} = me;

        // Keep all registered aligns aligned on any detected change
        _aligns?.forEach(align => {
            const targetPresent = document.contains(align.targetElement);

            // Align subject and target still in the DOM - correct its alignment
            if (document.contains(align.subject) && targetPresent) {
                me.align(align)
            }
            // Align subject or target no longer in the DOM - remove it.
            else {
                // If target is no longer in the DOM, hide the subject component
                if (!targetPresent) {
                    Neo.worker.App.setConfigs({ id: align.id, hidden: true })
                }

                const
                    {_alignResizeObserver} = me,
                    {constrainToElement}   = align;

                // Stop observing the align elements
                _alignResizeObserver.unobserve(align.subject);
                _alignResizeObserver.unobserve(align.offsetParent);
                _alignResizeObserver.unobserve(align.targetElement);
                if (constrainToElement) {
                    _alignResizeObserver.unobserve(constrainToElement)
                }

                // Clear the last aligned class.
                align.subject.classList.remove(`neo-aligned-${align.result?.position}`);

                _aligns.delete(align.id)
            }
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Boolean} data.modal
     */
    syncModalMask({ id, modal }) {
        const el = id && this.getElement(id);

        // If we are visible and modal, the mask needs to be just below this element.
        if (el && modal && el.ownerDocument.contains(el) && el.ownerDocument.defaultView.getComputedStyle(el).getPropertyValue('display') !== 'none') {
            document.body.insertBefore(this.modalMask, el)
        }
        // Otherwise, the mask needs to be below the next topmost modal dialog if possible, or hidden
        else {
            const
                modals       = document.querySelectorAll('.neo-modal'),
                topmostModal = modals[modals.length - 1];

            // Move the mask under the next topmost modal now modal "id" is gone.
            if (topmostModal) {
                this.syncModalMask({ id: topmostModal.id, modal: true })
            } else {
                this._modalMask?.remove()
            }
        }
    }

    /**
     * Traps (or stops trapping) focus within a Component
     * @param {Object} data
     * @param {String} data.id The Component to trap focus within.
     * @param {Boolean} [data.trap=true] Pass `false` to stop trapping focus inside the Component.
     */
    async trapFocus(data) {
        const
            me                     = this,
            onTrappedFocusMovement = me.$boundOnTrappedFocusMovement || (me.$boundOnTrappedFocusMovement = me.onTrappedFocusMovement.bind(me)),
            subject                = data.subject = me.getElement(data.id),
            { trap = true }        = data;

        // Called before DOM has been created.
        if (!subject) {
            return
        }

        let topFocusTrap    = subject.$topFocusTrap,
            bottomFocusTrap = subject.$bottomFocusTrap;

        if (trap) {
            if (!subject.$treeWalker) {
                subject.$treeWalker = document.createTreeWalker(subject, NodeFilter.SHOW_ELEMENT, {
                    acceptNode: filterTabbable
                });
                topFocusTrap = subject.$topFocusTrap = document.createElement('div');
                bottomFocusTrap = subject.$bottomFocusTrap = document.createElement('div');

                // The two focus trapping elements must be invisible but tabbable.
                topFocusTrap.className = bottomFocusTrap.className = 'neo-focus-trap';
                topFocusTrap.setAttribute('tabIndex', 0);
                bottomFocusTrap.setAttribute('tabIndex', 0);

                // Listen for when they gain focus and wrap focus within the encapsulating element
                subject.addEventListener('focusin', onTrappedFocusMovement)
            }

            // Ensure content is encapsulated by the focus trap elements
            subject.insertBefore(topFocusTrap, subject.firstChild);
            subject.appendChild(bottomFocusTrap)
        } else {
            subject.removeEventListener('focusin', onTrappedFocusMovement)
        }
    }

    /**
     * @param {Object} data
     * @param {String} [data.behavior='smooth'] // auto or smooth
     * @param {String} [data.left=0]
     * @param {String} [data.top=0]
     */
    windowScrollTo(data) {
        window.scrollTo({
            behavior: data.behavior || 'smooth',
            left    : data.left     || 0,
            top     : data.top      || 0
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomAccess));


/***/ }),

/***/ "./src/main/DomEvents.mjs":
/*!********************************!*\
  !*** ./src/main/DomEvents.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _mixin_TouchDomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mixin/TouchDomEvents.mjs */ "./src/main/mixin/TouchDomEvents.mjs");





const globalDomEvents = [
    {name: 'change',      handler: 'onChange'},
    {name: 'click',       handler: 'onClick'},
    {name: 'contextmenu', handler: 'onContextMenu'},
    {name: 'dblclick',    handler: 'onDoubleClick'},
    {name: 'focusin',     handler: 'onFocusIn'},
    {name: 'focusout',    handler: 'onFocusOut'},
    {name: 'input',       handler: 'onChange'},
    {name: 'keydown',     handler: 'onKeyDown'},
    {name: 'keyup',       handler: 'onKeyUp'},
    {name: 'mousedown',   handler: 'onMouseDown'},
    {name: 'mouseenter',  handler: 'onMouseEnter', options: {capture: true}},
    {name: 'mouseleave',  handler: 'onMouseLeave', options: {capture: true}},
    {name: 'mouseup',     handler: 'onMouseUp'},
    {name: 'scroll',      handler: 'onScroll',     options: {capture: true}},
    {name: 'wheel',       handler: 'onWheel',      options: {passive: false}}
];

// Will get applied to the document.body in case Neo.config.hasTouchEvents === true
const touchEvents = [
    {name: 'touchcancel', handler: 'onTouchCancel'},
    {name: 'touchend',    handler: 'onTouchEnd'},
    {name: 'touchenter',  handler: 'onTouchEnter'},
    {name: 'touchleave',  handler: 'onTouchLeave'},
    {name: 'touchmove',   handler: 'onTouchMove', options: {passive: false}},
    {name: 'touchstart',  handler: 'onTouchStart'}
];

// wheel events fire very often, so we limit the targets to avoid unnecessary post messages from main to the app worker
const globalWheelTargets = [
    'neo-c-m-scrollcontainer',
    'neo-c-w-scrollcontainer',
    'neo-calendar-yearcomponent',
    'neo-circle-component',
    'neo-dateselector',
    'neo-gallery',
    'neo-helix'
];

// separated from globalWheelTargets => performance
// buffer in ms
const globalWheelTargetsBuffer = {
    'neo-c-m-scrollcontainer'   : 100,
    'neo-c-w-scrollcontainer'   : 100,
    'neo-calendar-yearcomponent': 300,
    'neo-dateselector'          : 300
};

// separated from globalWheelTargets => performance
const globalWheelTargetsKeepEvent = [
    'neo-c-m-scrollcontainer',
    'neo-c-w-scrollcontainer'
];

const lastWheelEvent = {
    date  : null,
    target: null
};

const
    disabledInputKeys         = {},
    preventClickTargets       = [],
    preventContextmenuTargets = [];

/**
 * @class Neo.main.DomEvents
 * @extends Neo.core.Base
 * @singleton
 */
class DomEvents extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.main.DomEvents'
         * @protected
         */
        className: 'Neo.main.DomEvents',
        /**
         * todo: conditional dynamic import once the build processes can handle it
         * @member {Array} mixins=[TouchDomEvents]
         */
        mixins: [_mixin_TouchDomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]],
        /**
         * @member {boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'addDomListener',
                'registerDisabledInputChars',
                'registerPreventDefaultTargets',
                'unregisterDisabledInputChars'
            ]
        }
    }

    /**
     *
     * @member {Object} touch
     */
    lastTouch = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        document.addEventListener('DOMContentLoaded',  me.onDomContentLoaded .bind(me));
        document.addEventListener('selectionchange',   me.onSelectionChange  .bind(me));
        window  .addEventListener('orientationchange', me.onOrientationChange.bind(me));
        window  .addEventListener('hashchange',        me.onHashChange       .bind(me));

        if (Neo.config.useSharedWorkers) {
            window.addEventListener('beforeunload', me.onBeforeUnload.bind(me))
        }
    }

    /**
     * @param {Object} data
     */
    addDomListener(data) {
        let me       = this,
            i        = 0,
            len      = data.events.length,
            failedId = null,
            event, id, targetNode;

        for (; i < len; i++) {
            event = data.events[i];

            if (!me[event.handler]) {
                me[event.handler] = Neo.emptyFn
            }

            id = event.vnodeId || data.vnodeId;

            if (id === 'document.body') {
                targetNode = document.body
            } else if (Neo.config.useDomIds) {
                targetNode = document.getElementById(id)
            } else {
                targetNode = document.querySelector(`[data-neo-id='${id}']`)
            }

            if (targetNode) {
                targetNode.addEventListener(event.name, me[event.handler].bind(me))
            } else {
                failedId = id
            }
        }

        if (failedId && Neo.config.environment === 'development') {
            console.warn('DomEvents:addDomListener() => target node not found:', failedId)
        }

        Neo.worker.Manager.sendMessage(data.origin, {
            action : 'reply',
            data,
            replyId: data.id,
            success: !failedId
        })
    }

    /**
     *
     */
    addGlobalDomListeners() {
        let me = this;

        [...globalDomEvents].concat(Neo.config.hasTouchEvents ? touchEvents : []).forEach(event => {
            document.body.addEventListener(event.name, me[event.handler].bind(me), event.options)
        });
    }

    /**
     * Local domEvent listener
     * @param {Event} event
     */
    domEventListener(event) {
        let me       = this,
            {target} = event,

            config = {
                action   : 'domEvent',
                eventName: event.type,

                data: {
                    ...me.getEventData(event),
                    id   : target.id,
                    value: target.value
                }
            };

        switch (event.type) {
            case 'mousemove':
                Object.assign(config.data, me.getMouseEventData(event));
                break
            default:
                event.preventDefault();
                break
        }

        Neo.worker.Manager.sendMessage('app', config)
    }

    /**
     *
     * @param {HTMLElement} node
     * @returns {Object}
     */
    geAriaAttributes(node) {
        let ariaAttributes = {},
            {attributes}   = node,
            i              = 0,
            len            = attributes?.length || 0,
            attribute;

        for (; i < len; i++) {
            attribute = attributes[i];

            if (attribute.name.startsWith('aria-')) {
                ariaAttributes[attribute.name.substring(5)] = attribute.value
            }
        }

        return ariaAttributes
    }

    /**
     * Returns the distance between two points
     * @param  {Number} x1 The X position of the first point
     * @param  {Number} y1 The Y position of the first point
     * @param  {Number} x2 The X position of the second point
     * @param  {Number} y2 The Y position of the second point
     * @returns {Number}
     */
    getDistance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
    }

    /**
     * @param {Event} event
     * @returns {Object}
     */
    getEventData(event) {
        let path = event.composedPath();

        if (path.length < 1) {
            // our draggable implementation will generate paths, so we do need to check for them
            path = event.path;
        }

        const result = {
            path     : path.map(e => this.getTargetData(e)),
            target   : this.getTargetData(event.target),
            timeStamp: event.timeStamp,
            type     : event.type,
            data     : {...event.target.dataset}
        };

        if (event.relatedTarget) {
            result.relatedTarget = this.getTargetData(event.relatedTarget)
        }

        return result
    }

    /**
     * @param {KeyboardEvent} event
     * @returns {Object}
     */
    getKeyboardEventData(event) {
        let {altKey, code, ctrlKey, key, keyCode, metaKey, shiftKey} = event;

        return {
            ...this.getEventData(event),
            altKey,
            code,
            ctrlKey,
            key,
            keyCode,
            metaKey,
            shiftKey
        }
    }

    /**
     * @param {MouseEvent} event
     * @returns {Object}
     */
    getMouseEventData(event) {
        let {altKey, clientX, clientY, ctrlKey, detail, metaKey, offsetX, offsetY, pageX, pageY, screenX, screenY, shiftKey} = event;

        return {
            ...this.getEventData(event),
            altKey,
            clientX,
            clientY,
            ctrlKey,
            detail,
            metaKey,
            offsetX,
            offsetY,
            pageX,
            pageY,
            screenX,
            screenY,
            shiftKey
        }
    }

    /**
     * @param {Element} element
     * @returns {Element[]}
     */
    getPathFromElement(element) {
        let path = [];

        if (element) {
            path.push(element);

            while (element.parentNode) {
                path.push(element.parentNode);
                element = element.parentNode
            }
        }

        return path
    }

    /**
     * @param {Object[]} path
     * @param {HTMLElement} target
     * @returns {Object[]}
     */
    getSelectionPath(path, target) {
        if (target.parentNode && target.id.split('__').length > 1) {
            path = this.getSelectionPath(path, target.parentNode);
        }

        path.push(this.getTargetData(target));

        return path
    }

    /**
     * @param {HTMLElement} node
     * @returns {Object}
     */
    getTargetData(node) {
        let r    = node.getBoundingClientRect?.(),
            rect = r && this.parseDomRect(r) || {};

        return {
            aria             : this.geAriaAttributes(node),
            checked          : node.checked,
            childElementCount: node.childElementCount,
            clientHeight     : node.clientHeight,
            clientLeft       : node.clientLeft,
            clientTop        : node.clientTop,
            clientWidth      : node.clientWidth,
            cls              : node.classList ? [...node.classList] : [],
            data             : {...node.dataset},
            draggable        : node.draggable,
            hidden           : node.hidden,
            id               : Neo.config.useDomIds ? node.id : node.dataset?.['neoId'],
            inert            : node.inert,
            isConnected      : node.isConnected,
            isContentEditable: node.isContentEditable,
            nodeType         : node.nodeType,
            offsetHeight     : node.offsetHeight,
            offsetLeft       : node.offsetLeft,
            offsetTop        : node.offsetTop,
            offsetWidth      : node.offsetWidth,
            rect,
            role             : node.role,
            scrollHeight     : node.scrollHeight,
            scrollLeft       : node.scrollLeft,
            scrollTop        : node.scrollTop,
            scrollWidth      : node.scrollWidth,
            style            : node.style?.cssText,
            tabIndex         : node.getAttribute?.('tabindex') ? node.tabIndex : null,
            tagName          : node.tagName?.toLowerCase()
        }
    }

    /**
     * Returns the first touch event found in touches or changedTouches of a TouchEvent
     * @param {TouchEvent} event
     * @returns {Touch}
     */
    getTouchCoords(event) {
        let {touches, changedTouches} = event;
        return touches?.[0] || changedTouches?.[0]
    }

    /**
     * Only in use if Neo.config.useSharedWorkers = true
     * @param {Object} event
     */
    onBeforeUnload(event) {
        let {Manager} = Neo.worker;

        Manager.appNames.forEach(appName => {
            Manager.broadcast({action: 'disconnect', appName, windowId: Manager.windowId})
        })
    }

    /**
     * @param {InputEvent} event
     */
    onChange(event) {
        let me       = this,
            {target} = event,

            data = {
                ...me.getEventData(event),
                valid: target.checkValidity?.(),
                value: target.value
            };

        // input and change events can pass a FileList for input type file
        if (target.files) {
            data.files = target.files
        }

        me.sendMessageToApp(data)
    }

    /**
     * @param {MouseEvent} event
     */
    onClick(event) {
        let me = this;

        me.sendMessageToApp(me.getMouseEventData(event));

        me.testPathInclusion(event, preventClickTargets) && event.preventDefault()
    }

    /**
     * @param {MouseEvent} event
     */
    onContextMenu(event) {
        let me = this;

        me.sendMessageToApp(me.getMouseEventData(event));

        if (event.ctrlKey || me.testPathInclusion(event, preventContextmenuTargets)) {
            event.preventDefault()
        }
    }

    /**
     *
     */
    onDomContentLoaded() {
        this.addGlobalDomListeners();
        this.fire('domContentLoaded')
    }

    /**
     * @param {MouseEvent} event
     */
    onDoubleClick(event) {
        let me = this;

        me.sendMessageToApp(me.getMouseEventData(event));

        me.testPathInclusion(event, preventClickTargets) && event.preventDefault()
    }

    /**
     * @param {FocusEvent} event
     */
    onFocusIn(event) {
        this.sendMessageToApp(this.getEventData(event))
    }

    /**
     * @param {FocusEvent} event
     */
    onFocusOut(event) {
        this.sendMessageToApp(this.getEventData(event))
    }

    /**
     *
     */
    onHashChange() {
        let {Manager}  = Neo.worker,
            hashString = location.hash.substring(1);

        Manager.sendMessage('app', {
            action: 'hashChange',
            data  : {
                appNames: Manager.appNames,
                hash    : this.parseHash(hashString),
                hashString,
                windowId: Manager.windowId
            }
        })
    }

    /**
     * @param {KeyboardEvent} event
     */
    onKeyDown(event) {
        let me        = this,
            {target}  = event,
            {tagName} = target,
            isInput   = tagName === 'INPUT' || tagName === 'TEXTAREA';

        if (isInput && disabledInputKeys[target.id]?.includes(event.key)) {
            event.preventDefault()
        } else {
            me.sendMessageToApp(me.getKeyboardEventData(event));

            if (
                isInput &&
                event.key === 'Tab' &&
                me.testPathInclusion(event, ['neo-grid-editor', 'neo-table-editor'], true)
            ) {
                event.preventDefault()
            }

            if (
                !isInput &&
                ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp'].includes(event.key) &&
                me.testPathInclusion(event, ['neo-selection'], true)
            ) {
                event.preventDefault()
            }
        }
    }

    /**
     * @param {KeyboardEvent} event
     */
    onKeyUp(event) {
        this.sendMessageToApp(this.getKeyboardEventData(event))
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseDown(event) {
        this.sendMessageToApp(this.getMouseEventData(event))
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseEnter(event) {
        let me       = this,
            appEvent = {...me.getMouseEventData(event), fromElementId: event.fromElement?.id || null, toElementId: event.toElement?.id || null};

        me.sendMessageToApp(appEvent);
        me.fire('mouseEnter', appEvent)
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseLeave(event) {
        let me       = this,
            appEvent = {...me.getMouseEventData(event), fromElementId: event.fromElement?.id || null, toElementId: event.toElement?.id || null};

        me.sendMessageToApp(appEvent);
        me.fire('mouseLeave', appEvent)
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseUp(event) {
        this.sendMessageToApp(this.getMouseEventData(event))
    }

    /**
     * @param {Event} event
     */
    onOrientationChange(event) {
        let {orientation} = screen,
            {angle, type} = orientation,
            layout        = angle === 0 || angle === 180 ? 'portrait' : 'landscape';

        Neo.worker.Manager.sendMessage('app', {
            action: 'orientationChange',
            data  : {angle, layout, type}
        })
    }

    /**
     * @param {Event} event
     */
    onScroll(event) {
        let me = this,
            {firstTouch, lastTouch} = me,
            {clientHeight, clientWidth, scrollLeft, scrollTop} = event.target,
            data;

        event.preventDefault();

        data = {
            ...me.getEventData(event),
            clientHeight,
            clientWidth,
            scrollLeft,
            scrollTop
        };

        if (firstTouch) {
            data.touches = {
                firstTouch: {clientX: firstTouch.clientX, clientY: firstTouch.clientY},
                lastTouch : {clientX: lastTouch .clientX, clientY: lastTouch .clientY}
            }
        }

        me.sendMessageToApp(data)
    }

    /**
     * @param {Event} event
     */
    onSelectionChange(event) {
        let me       = this,
            {target} = event,
            element  = target.type ? target : target.activeElement,
            path, targetData;

        if (target.tagName === 'BODY') {
            return
        }

        path       = me.getSelectionPath([], element);
        targetData = me.getTargetData(element);

        me.sendMessageToApp({
            path,
            selection: {direction: element.selectionDirection, end: element.selectionEnd, start: element.selectionStart},
            target   : targetData,
            timeStamp: event.timeStamp,
            type     : 'selectionchange'
        })
    }

    /**
     * @param {Event} event
     */
    onWheel(event) {
        let target        = this.testPathInclusion(event, globalWheelTargets),
            preventUpdate = false,
            targetCls;

        if (target) {
            targetCls = target.cls;

            if (globalWheelTargetsBuffer[target.cls]) {
                let date = new Date();

                if (lastWheelEvent.date && lastWheelEvent.target === targetCls && date - lastWheelEvent.date < globalWheelTargetsBuffer[targetCls]) {
                    preventUpdate = true
                } else {
                    Object.assign(lastWheelEvent, {
                        date,
                        target: targetCls
                    })
                }
            }

            if (!preventUpdate) {
                let {deltaX, deltaY, deltaZ} = event;

                this.sendMessageToApp({
                    ...this.getEventData(event),
                    clientHeight: target.node.clientHeight,
                    clientWidth : target.node.clientWidth,
                    deltaX,
                    deltaY,
                    deltaZ,
                    scrollLeft  : target.node.scrollLeft,
                    scrollTop   : target.node.scrollTop
                })
            }

            if (!globalWheelTargetsKeepEvent.includes(targetCls)) {
                event.preventDefault()
            }
        }
    }

    /**
     * DOMRects are not spreadable => {...DOMRect} => {}
     * @param {DOMRect} rect
     * @returns {Object}
     */
    parseDomRect(rect) {
        let {bottom, height, left, right, top, width, x, y} = rect;

        return {bottom, height, left, right, top, width, x, y}
    }

    /**
     * Example for Array values: "categories[]=test1&categories[]=test2"
     * @param {String} str
     * @returns {Object}
     */
    parseHash(str) {
        if (str === '') {
            return {}
        }

        let pieces = str.split('&'),
            data   = {},
            i, key, parts, value;

        for (i = 0; i < pieces.length; i++) {
            parts = pieces[i].split('=');

            if (parts.length < 2) {
                parts.push('')
            }

            key   = decodeURIComponent(parts[0]);
            value = decodeURIComponent(parts[1]);

            if (key.indexOf('[]') !== -1) {
                key = key.substring(0, key.indexOf('[]'));

                if (typeof data[key] === 'undefined') {
                    data[key] = [];
                }

                data[key].push(this.parseValue(value))
            } else {
                data[key] = this.parseValue(value)
            }
        }

        return data
    }

    /**
     * used by parseHash to convert tokens into boolean or number types if needed
     * @param {String} value
     * @returns {Boolean|Number|String}
     * @protected
     */
    parseValue(value) {
        if (value == parseInt(value)) {
            value = parseInt(value)
        } else if (value === 'false') {
            value = false
        } else if (value === 'true') {
            value = true
        }

        return value
    }

    /**
     * @param {Object} data
     * @param {String[]} data.chars
     * @param {String} data.id
     */
    registerDisabledInputChars(data) {
        disabledInputKeys[data.id] = data.chars
    }

    /**
     * @param {Object} data
     * @param {Array|String} data.cls
     * @param {String} data.name
     */
    registerPreventDefaultTargets(data) {
        let preventArray;

        if (!Array.isArray(data.cls)) {
            data.cls = [data.cls];
        }

        switch (data.name) {
            case 'click':
                preventArray = preventClickTargets;
                break;
            case 'contextmenu':
                preventArray = preventContextmenuTargets;
                break;
        }

        data.cls.forEach(cls => {
            !preventArray.includes(cls) && preventArray.push(cls)
        })
    }

    /**
     * Sends the parsed event data to the app worker
     * @param {Object} data
     * @protected
     */
    sendMessageToApp(data) {
        Neo.worker.Manager.sendMessage('app', {
            action   : 'domEvent',
            eventName: data.type,
            data
        })
    }

    /**
     * hello <foo>world thorsten! 3 < 4 and 5 > 3
     * @param {String} value
     * @returns {String}
     */
    stripHtml(value) {
        let doc = new DOMParser().parseFromString(value, 'text/html');

        return doc.body.textContent || ''
    }

    /**
     * @param {Object} event
     * @param {Object} targetArray
     * @param {Object} testSubstring=false
     * @returns {Object|Boolean} target cls & node if found, false otherwise
     */
    testPathInclusion(event, targetArray, testSubstring=false) {
        let countTargets = targetArray.length,
            path         = event.path || event.composedPath(),
            i            = 0,
            len          = path.length,
            j, node;

        for (; i < len; i++) {
            node = path[i];

            for (j = 0; j < countTargets; j++) {
                if (
                    testSubstring && node.classList?.value?.includes(targetArray[j]) ||
                    node.classList?.contains(targetArray[j])
                ) {
                    return {cls: targetArray[j], node}
                }
            }
        }

        return false
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     */
    unregisterDisabledInputChars(data) {
        delete disabledInputKeys[data.id]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvents));


/***/ }),

/***/ "./src/main/DomUtils.mjs":
/*!*******************************!*\
  !*** ./src/main/DomUtils.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


const focusableTags = {
    BODY    : 1,
    BUTTON  : 1,
    EMBED   : 1,
    IFRAME  : 1,
    INPUT   : 1,
    OBJECT  : 1,
    SELECT  : 1,
    TEXTAREA: 1
};

/**
 * @class Neo.main.DomUtils
 * @extends Neo.core.Base
 * @singleton
 */
class DomUtils extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.DomUtils'
         * @protected
         */
        className: 'Neo.main.DomUtils'
    }

    /**
     * Analogous to the `HTMLElement` `closest` method. Searches starting at the passed element for
     * an element for which the passed `filterFn` returns `true`
     * @param {HTMLElement} el The element to start from.
     * @param {Function} filterFn A function which returns `true` when the desired element is reached.
     * @param {HTMLElement} [limit] The element to stop at. This is *not* considered for matching.
     * @returns {HTMLElement}
     */
    static closest(el, filterFn, limit = document.body) {
        while (el?.nodeType === Node.ELEMENT_NODE && el !== limit) {
            if (filterFn(el)) {
                return el
            }

            el = el.parentNode
        }
    }

    static isFocusable(e) {
        // May be used as a scopeless callback, so use "DomUtils", not "this"
        return DomUtils.isTabbable(e) || Number(e.getAttribute('tabIndex')) < 0
    }

    static isTabbable(e) {
        const
            { nodeName } = e,
            style        = getComputedStyle(e),
            tabIndex     = e.getAttribute('tabIndex');

        // Hidden elements are not tabbable.
        // Negative tabIndex also means not tabbable (Though still focusable)
        if (!e.isConnected || !e.offsetParent || style.getPropertyValue('visibility') === 'hidden' || Number(tabIndex) < 0) {
            return false
        }

        return focusableTags[nodeName] ||
            ((nodeName === 'A' || nodeName === 'LINK') && !!e.href) ||
            (tabIndex != null && Number(tabIndex) >= 0) ||
            e.contentEditable === 'true'
    }

    /**
     * Analogous to the `HTMLElement` `querySelector` method. Searches the passed element
     * and all descendants for the first element for which the passed `filterFn` returns `true`.
     * @param {HTMLElement} el The element to start from.
     * @param {Function} filterFn A function which returns `true` when the desired element is reached.
     * @returns {HTMLElement} The first matching element
     */
    static query(el, filterFn) {
        return [el, ...el.querySelectorAll('*')].find(filterFn);
    }

    /**
     * Analogous to the `HTMLElement` `querySelectorAll` method. Searches the passed element
     * and all descendants for all elements for which the passed `filterFn` returns `true`.
     * @param {HTMLElement} el The element to start from.
     * @param {Function} filterFn A function which returns `true` when a desired element is reached.
     * @returns {HTMLElement[]} An array of matching elements
     */
    static queryAll(el, filterFn) {
        return [el, ...el.querySelectorAll('*')].filter(filterFn)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomUtils));


/***/ }),

/***/ "./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$":
/*!********************************************************************!*\
  !*** ./src/main/addon/ lazy ^\.\/.*\.mjs$ strict namespace object ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./AmCharts.mjs": [
		"./src/main/addon/AmCharts.mjs",
		"vendors-src_main_addon_AmCharts_mjs"
	],
	"./AnalyticsByGoogle.mjs": [
		"./src/main/addon/AnalyticsByGoogle.mjs",
		"src_main_addon_AnalyticsByGoogle_mjs"
	],
	"./Base.mjs": [
		"./src/main/addon/Base.mjs",
		"src_main_addon_Base_mjs"
	],
	"./CesiumJS.mjs": [
		"./src/main/addon/CesiumJS.mjs",
		"src_main_addon_CesiumJS_mjs"
	],
	"./CloneNode.mjs": [
		"./src/main/addon/CloneNode.mjs",
		"src_main_addon_CloneNode_mjs"
	],
	"./Cookie.mjs": [
		"./src/main/addon/Cookie.mjs",
		"src_main_addon_Cookie_mjs"
	],
	"./DragDrop.mjs": [
		"./src/main/addon/DragDrop.mjs",
		"vendors-src_main_addon_DragDrop_mjs"
	],
	"./FileSystemAccess.mjs": [
		"./src/main/addon/FileSystemAccess.mjs",
		"src_main_addon_FileSystemAccess_mjs"
	],
	"./GoogleMaps.mjs": [
		"./src/main/addon/GoogleMaps.mjs",
		"vendors-src_main_addon_GoogleMaps_mjs"
	],
	"./HighlightJS.mjs": [
		"./src/main/addon/HighlightJS.mjs",
		"src_main_addon_HighlightJS_mjs"
	],
	"./IntersectionObserver.mjs": [
		"./src/main/addon/IntersectionObserver.mjs",
		"src_main_addon_IntersectionObserver_mjs"
	],
	"./LocalStorage.mjs": [
		"./src/main/addon/LocalStorage.mjs",
		"src_main_addon_LocalStorage_mjs"
	],
	"./MapboxGL.mjs": [
		"./src/main/addon/MapboxGL.mjs",
		"vendors-src_main_addon_MapboxGL_mjs"
	],
	"./Markdown.mjs": [
		"./src/main/addon/Markdown.mjs",
		"src_main_addon_Markdown_mjs"
	],
	"./MonacoEditor.mjs": [
		"./src/main/addon/MonacoEditor.mjs",
		"src_main_addon_MonacoEditor_mjs"
	],
	"./Mwc.mjs": [
		"./src/main/addon/Mwc.mjs",
		"src_main_addon_Mwc_mjs"
	],
	"./Navigator.mjs": [
		"./src/main/addon/Navigator.mjs",
		"vendors-src_main_addon_Navigator_mjs"
	],
	"./Popover.mjs": [
		"./src/main/addon/Popover.mjs",
		"src_main_addon_Popover_mjs"
	],
	"./PrefixField.mjs": [
		"./src/main/addon/PrefixField.mjs",
		"src_main_addon_PrefixField_mjs"
	],
	"./ResizeObserver.mjs": [
		"./src/main/addon/ResizeObserver.mjs",
		"src_main_addon_ResizeObserver_mjs"
	],
	"./ScrollSync.mjs": [
		"./src/main/addon/ScrollSync.mjs",
		"src_main_addon_ScrollSync_mjs"
	],
	"./ServiceWorker.mjs": [
		"./src/main/addon/ServiceWorker.mjs",
		"src_main_addon_ServiceWorker_mjs"
	],
	"./Siesta.mjs": [
		"./src/main/addon/Siesta.mjs",
		"src_main_addon_Siesta_mjs"
	],
	"./Stylesheet.mjs": [
		"./src/main/addon/Stylesheet.mjs",
		"vendors-src_main_addon_Stylesheet_mjs"
	],
	"./WebComponent.mjs": [
		"./src/main/addon/WebComponent.mjs",
		"src_main_addon_WebComponent_mjs"
	],
	"./WindowPosition.mjs": [
		"./src/main/addon/WindowPosition.mjs",
		"vendors-src_main_addon_WindowPosition_mjs"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/main/mixin/TouchDomEvents.mjs":
/*!*******************************************!*\
  !*** ./src/main/mixin/TouchDomEvents.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Will get imported in case Neo.config.hasTouchEvents === true
 * @class Neo.main.mixin.TouchDomEvents
 * @extends Neo.core.Base
 * @singleton
 */
class TouchDomEvents extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.mixin.TouchDomEvents'
         * @protected
         */
        className: 'Neo.main.mixin.TouchDomEvents'
    }

    /**
     * @param {Object} event
     */
    onTouchCancel(event) {
        let me = this;

        me.sendMessageToApp(me.getEventData(event));
        me.firstTouch = null;
        me.lastTouch  = null
    }

    /**
     * @param {Object} event
     */
    onTouchEnd(event) {
        let me = this;

        me.sendMessageToApp(me.getEventData(event));
        me.firstTouch = null;
        me.lastTouch  = null
    }

    /**
     * @param {Object} event
     */
    onTouchEnter(event) {
        this.sendMessageToApp(this.getEventData(event))
    }

    /**
     * @param {Object} event
     */
    onTouchLeave(event) {
        this.sendMessageToApp(this.getEventData(event))
    }

    /**
     * @param {Object} event
     */
    onTouchMove(event) {
        let me          = this,
            data        = me.getEventData(event),
            touch       = event.touches[0],
            {lastTouch} = me;

        if (lastTouch) {
            Object.assign(data, {
                deltaX: touch.clientX - lastTouch.clientX,
                deltaY: touch.clientY - lastTouch.clientY
            })
        }

        me.sendMessageToApp(data);

        me.lastTouch = touch;

        if (me.testPathInclusion(event, ['neo-helix'])) {
            event.preventDefault()
        }
    }

    /**
     * @param {Object} event
     */
    onTouchStart(event) {
        let me = this;

        me.firstTouch = event.touches[0];
        me.lastTouch  = event.touches[0];

        me.sendMessageToApp(me.getEventData(event))
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TouchDomEvents));


/***/ }),

/***/ "./src/util/Array.mjs":
/*!****************************!*\
  !*** ./src/util/Array.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Array
 * @extends Neo.core.Base
 */
class NeoArray extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Array'
         * @protected
         */
        className: 'Neo.util.Array'
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     * @returns {Array}
     */
    static add(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.push(item);
            }
        });

        return arr
    }

    /**
     * Returns an array of items which are present in array1, but not in array2
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static difference(array1=[], array2=[]) {
        return array1.filter(item => !array2.includes(item))
    }

    /**
     * Checks if the item is included by reference inside the array
     * @param {Array} arr
     * @param {*} item
     */
    static hasItem(arr, item) {
        return arr.includes(item)
    }

    /**
     * Inserts an item or Array of items to an array in case it does not already exist.
     * Duplicates will only get matched by reference.
     * @param {Array} arr
     * @param {Number} index
     * @param {*} items
     * @returns {Array}
     */
    static insert(arr, index, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let len = items.length -1,
            i   = len,
            currentIndex, item;

        // Iterate backwards
        for (; i > -1; i--) {
            item = items[i];

            currentIndex = arr.indexOf(item);

            if (index !== currentIndex) {
                if (currentIndex > -1) {
                    this.move(arr, currentIndex, index)
                } else {
                    arr.splice(index, 0, item)
                }
            }
        }

        return arr
    }

    /**
     * Returns an array of items which are present in array1 and array2
     * Only supports primitive items
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static intersection(array1=[], array2=[]) {
        return array1.filter(item => array2.includes(item))
    }

    /**
     * Moves an item inside arr from fromIndex to toIndex
     * @param {Array} arr
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    static move(arr, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return arr
        }

        if (fromIndex >= arr.length) {
            fromIndex = arr.length - 1
        }

        arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);
        return arr
    }

    /**
     * Removes an item or array of items from an array. Only primitive items will get found
     * @param {Array} arr
     * @param {*} items
     */
    static remove(arr, items) {
        let index;

        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            index = arr.indexOf(item);

            index > -1 && arr.splice(index, 1)
        });

        return arr
    }

    /**
     * Convenience method to combine add & remove in one call.
     * You can pass single items or an array of items to add or to remove.
     * @param {Array} arr
     * @param {*} removeItems
     * @param {*} addItems
     */
    static removeAdd(arr, removeItems, addItems) {
        this.remove(arr, removeItems);
        return this.add(arr, addItems)
    }

    /**
     * Removes an item from an array in case it does exist, otherwise adds it
     * @param {Array} arr
     * @param {*} item
     * @param {Boolean} [add]
     */
    static toggle(arr, item, add = !this.hasItem(arr, item)) {
        return this[add ? 'add' : 'remove'](arr, item);
    }

    /**
     * Returns an array of items which are present in the passed arrays.
     * Multiple arrays may be passed.
     * Only supports primitive items
     * @returns {Array}
     */
    static union() {
        return [...new Set(Array.prototype.concat(...arguments))]
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static unshift(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.unshift(item)
            }
        });

        return arr
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(NeoArray));


/***/ }),

/***/ "./src/util/Function.mjs":
/*!*******************************!*\
  !*** ./src/util/Function.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bindAppend: () => (/* binding */ bindAppend),
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   createInterceptor: () => (/* binding */ createInterceptor),
/* harmony export */   createSequence: () => (/* binding */ createSequence),
/* harmony export */   debounce: () => (/* binding */ debounce),
/* harmony export */   intercept: () => (/* binding */ intercept),
/* harmony export */   resolveCallback: () => (/* binding */ resolveCallback),
/* harmony export */   throttle: () => (/* binding */ throttle)
/* harmony export */ });
/**
 * Append args instead of prepending them
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function bindAppend(fn, scope) {
    const args = [].slice.call(arguments).slice(2);

    return function() {
        return fn.apply(scope, [].slice.call(arguments).concat(args))
    }
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function buffer(callback, scope, delay=300) {
    let timeoutId;

    const wrapper = function(...args) {
        // callback invocation comes "delay" ms after the last call to wrapper
        // so cancel any pending invocation.
        clearTimeout(timeoutId);

        wrapper.isPending = true;

        timeoutId = setTimeout(() => {
            timeoutId = 0;
            wrapper.isPending = false;
            callback.apply(scope, args)
        }, delay)
    };

    wrapper.cancel = () => {
        wrapper.isPending = false;
        clearTimeout(timeoutId)
    };

    return wrapper
}

/**
 * Intended for functions with 1 param where the interceptor can change the value
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @returns {Function}
 */
function createInterceptor(target, targetMethodName, interceptFunction, scope) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function(value) {
        return targetMethod.call(target, interceptFunction.call(scope || target, value))
    })
}

/**
 * @param {Neo.core.Base} target
 * @param {String} methodName
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function createSequence(target, methodName, fn, scope) {
    let method = target[methodName] || Neo.emptyFn;

    return (target[methodName] = function() {
        method.apply(this, arguments);
        return fn.apply(scope || this, arguments)
    })
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function debounce(callback, scope, delay=300) {
    let debounceTimer;

    return function(...args) {
        // leading edge => trigger the first call right away
        if (!Neo.isNumber(debounceTimer)) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            // we still want to start a timer to delay the 2nd+ update
            debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
        } else {
            clearTimeout(debounceTimer);

            debounceTimer = setTimeout(() => {
                // we need to check if the scope (instance) did not get destroyed yet
                scope?.id && callback.apply(scope, args);
                debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
            },  delay)
        }
    }
}

/**
 * The interceptor can prevent the targetMethod from getting executed in case it returns false.
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @param {*} preventedReturnValue=null The value to return in case the interceptFunction returns false
 * @returns {Function}
 */
function intercept(target, targetMethodName, interceptFunction, scope, preventedReturnValue=null) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function() {
        return (interceptFunction.apply(scope || target, arguments) === false)
            ? preventedReturnValue
            : targetMethod.apply(target, arguments)
    })
}

/**
 * Locate a callable function by name in the passed scope.
 *
 * If the name starts with 'up.', the parent Component chain is searched.
 *
 * This is used by manager.DomEvents & core.Observable.fire and by 'handler' function calls to resolve
 * string function names in the Component's own hierarchy.
 * @param {Function|String} fn A function, or the name of a function to find in the passed scope object/
 * @param {Object} scope=this The scope to find the function in if it is specified as a string.
 * @returns {Object}
 */
function resolveCallback(fn, scope=this) {
    if (Neo.isString(fn)) {
        if (!scope[fn] && fn.startsWith('up.')) {
            fn = fn.slice(3);
            while (!scope[fn] && (scope = scope.parent));
        } else {
            scope = scope.getController?.()?.getHandlerScope(fn, null) || scope
        }

        fn = scope[fn]
    }

    return {fn, scope}
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function throttle(callback, scope, delay=300) {
    let lastRanDate, timeoutId;

    return function(...args) {
        if (!lastRanDate) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            lastRanDate = Date.now()
        } else {
            clearTimeout(timeoutId)

            timeoutId = setTimeout(function() {
                if ((Date.now() - lastRanDate) >= delay) {
                    // we need to check if the scope (instance) did not get destroyed yet
                    scope?.id && callback.apply(scope, args);

                    lastRanDate = Date.now()
                }
            }, delay - (Date.now() - lastRanDate))
        }
    }
}


/***/ }),

/***/ "./src/util/Rectangle.mjs":
/*!********************************!*\
  !*** ./src/util/Rectangle.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Rectangle)
/* harmony export */ });
/**
 * The class contains utility methods for working with DOMRect Objects
 * @class Neo.util.Rectangle
 * @extends DOMRect
 */

const
    emptyArray = Object.freeze([]),
    // Convert edge array values into the [T,R,B,L] form.
    parseEdgeValue = (e = 0) => {
        if (!Array.isArray(e)) {
            e = [e];
        }
        switch (e.length) {
            case 1:
                e.length = 4;
                return e.fill(e[0], 1, 4);
            case 2:// top&bottom, left&right
                return [e[0], e[1], e[0], e[1]];
            case 3:// top, left&right, bottom
                return [e[0], e[1], e[2], e[1]];
        }
        return e;
    },
    parseEdgeAlign = edgeAlign => {
        const
            edgeParts     = edgeAlignRE.exec(edgeAlign),
            ourEdgeZone   = edgeZone[edgeParts[1]],
            theirEdgeZone = edgeZone[edgeParts[4]];

        return {
            ourEdge         : edgeParts[1],
            ourEdgeOffset   : parseInt(edgeParts[2] || 50),
            ourEdgeUnit     : edgeParts[3] || '%',
            ourEdgeZone,
            theirEdge       : edgeParts[4],
            theirEdgeOffset : parseInt(edgeParts[5] || 50),
            theirEdgeUnit   : edgeParts[6] || '%',
            theirEdgeZone,

            // Aligned to an edge, *outside* of the target.
            // A normal align as a combo dropdown might request
            edgeAligned     : (ourEdgeZone & 1) === (theirEdgeZone & 1) && ourEdgeZone !== theirEdgeZone
        }
    },
    // The opposite of parseEdgeAlign, and it has to flip the edges
    createReversedEdgeAlign = edges => {
        const
            ourEdge   = oppositeEdge[edges.ourEdge],
            theirEdge = oppositeEdge[edges.theirEdge];

        // reconstitute a rule string with the edges flipped to the opposite sides
        return `${ourEdge}${edges.ourEdgeOffset}${edges.ourEdgeUnit}-${theirEdge}${edges.theirEdgeOffset}${edges.theirEdgeUnit}`

    },
    getElRect = el => {
        const r = el instanceof DOMRect ? el : (el?.nodeType === 1 ? el : typeof el === 'string' ? document.getElementById(el) : null)?.getBoundingClientRect();

        // Convert DOMRect into Rectangle
        return r && new Rectangle(r.x, r.y, r.width, r.height);
    },
    oppositeEdge = {
        t : 'b',
        r : 'l',
        b : 't',
        l : 'r'
    },
    edgeZone = {
        t : 0,
        r : 1,
        b : 2,
        l : 3
    },
    zoneNames = ['top', 'right', 'bottom', 'left'],
    zoneEdges = ['t', 'r', 'b', 'l'],
    zoneDimension = ['width', 'height'],
    zoneCoord = [0, 1, 0, 1],
    zeroMargins = [0, 0, 0, 0],
    edgeAlignRE = /^([trblc])(\d*)(%|px)?-([trblc])(\d*)(%|px)?$/;

class Rectangle extends DOMRect {
    static config = {
        /**
         * @member {String} className='Neo.util.Rectangle'
         * @protected
         */
        className: 'Neo.util.Rectangle'
    }

    /**
     * @member {Number|null} minHeight=null
     */
    minHeight = null
    /**
     * @member {Number|null} minWidth=null
     */
    minWidth = null

    /**
     * Checks if rect1 does not have an intersection with rect2
     * !includes() is true for intersections as well
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static excludes(rect1, rect2) {
        return rect1.bottom < rect2.top     // rect2 is below rect1
            || rect1.left   > rect2.right   // rect2 is left of rect1
            || rect1.right  < rect2.left    // rect2 is right of rect1
            || rect1.top    > rect2.bottom; // rect2 is above rect1
    }

    /**
     * Returns the overlapping area of rect1 & rect2 as a new Rectangle
     * @param {DOMRect|Neo.util.Rectangle} rect1
     * @param {DOMRect|Neo.util.Rectangle} rect2
     * @returns {Neo.util.Rectangle|null} The intersecting rect
     */
    static getIntersection(rect1, rect2) {
        let x      = Math.max(rect1.x,      rect2.x),
            y      = Math.max(rect1.y,      rect2.y),
            right  = Math.min(rect1.right,  rect2.right),
            bottom = Math.min(rect1.bottom, rect2.bottom),
            width  = Math.max(0, right  - x),
            height = Math.max(0, bottom - y);

        if (height < 1 || width < 1) {
            return null
        }

        return new Rectangle(x, y, width, height)
    }

    /**
     * Checks if rect2 is fully contained inside rect1
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static includes(rect1, rect2) {
        return rect1.bottom >= rect2.bottom
            && rect1.left   <= rect2.left
            && rect1.right  >= rect2.right
            && rect1.top    <= rect2.top;
    }

    /**
     * Checks if rect2 is not contained inside rect1.
     * This could be an intersection or being fully excluded.
     * @param {Object} rect1
     * @param {Object} rect2
     * @param {String} side bottom, left, right or top
     * @returns {Boolean}
     */
    static leavesSide(rect1, rect2, side) {
        if (Rectangle.includes(rect1, rect2)) {
            return false;
        }

        if (side === 'bottom') {
            return rect1.bottom < rect2.bottom;
        }

        if (side === 'left') {
            return rect1.left > rect2.left;
        }

        if (side === 'right') {
            return rect1.right < rect2.right;
        }

        if (side === 'top') {
            return rect1.top > rect2.top;
        }
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveBy(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  += x;
            movedRect.right += x;
            movedRect.x     += x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom += y;
            movedRect.top    += y;
            movedRect.y      += y;
        }

        return movedRect;
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveTo(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  = x;
            movedRect.right = x + movedRect.width;
            movedRect.x     = x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom = y + movedRect.height;
            movedRect.top    = y;
            movedRect.y      = y;
        }

        return movedRect;
    }

    set bottom(b) {
        this.height += b - this.bottom;
    }
    get bottom() {
        return super.bottom;
    }

    set right(r) {
        this.width += r - this.right;
    }
    get right() {
        return super.right;
    }

    // Change the x without moving the Rectangle. The left side moves and the right side doesn't
    changeX(x) {
        const widthDelta = this.x - x;

        this.x = x;
        this.width += widthDelta;
    }

    // Change the y without moving the Rectangle. The top side moves and the bottom side doesn't
    changeY(y) {
        const heightDelta = this.y - y;

        this.y = y;
        this.height += heightDelta;
    }

    clone() {
        return Rectangle.clone(this);
    }

    static clone(r) {
        const result = new Rectangle(r.x, r.y, r.width, r.height);

        result.minWidth = r.minWidth;
        result.minHeight = r.minHeight;

        return result;
    }

    intersects(other) {
        const me = this;

        if (other.height && other.width) {
            const
                left   = Math.max(me.x, other.x),
                top    = Math.max(me.y, other.y),
                right  = Math.min(me.x + me.width, other.x + other.width),
                bottom = Math.min(me.y + me.height, other.y + other.height);

            if (left >= right || top >= bottom) {
                return false;
            }

            return new Rectangle(left, top, right - left, bottom - top);
        }
        // We're dealing with a point here - zero dimensions
        else {
            return (other.x >= me.x && other.y >= me.y && other.right <= me.right && other.bottom <= me.bottom);
        }
    }

    /**
     * Checks if the other Rectangle is fully contained inside this Rectangle
     * @param {Object} other
     * @returns {Boolean}
     */
    contains(other) {
        return this.bottom >= other.bottom
            && this.left   <= other.left
            && this.right  >= other.right
            && this.top    <= other.top;
    }

    /**
     * Returns a clone of this Rectangle expanded according to the edges array.
     * @param {Number[]} edges
     * @returns {Rectangle}
     */
    expand(edges) {
        edges = parseEdgeValue(edges);

        return new this.constructor(this.x - edges[3], this.y - edges[0], this.width + edges[1] + edges[3], this.height + edges[0] + edges[2]);
    }

    moveBy(x = 0, y = 0) {
        const result = this.clone();

        if (Array.isArray(x)) {
            y = x[1];
            x = x[0];
        }
        result.x += x;
        result.y += y;
        return result;
    }

    /**
     * Returns `true` if this Rectangle completely contains the other Rectangle
     * @param {Rectangle} other
     */
    contains(other) {
        return this.constructor.includes(this, other);
    }

    /**
     * Returns a copy of this Rectangle constrained to fit within the passed Rectangle
     * @param {Rectangle} constrainTo
     * @returns {Rectangle|Boolean} A new Rectangle constrained to te passed Rectangle, or false if it could not be constrained.
     */
    constrainTo(constrainTo) {
        const
            me        = this,
            minWidth  = me.minWidth  || me.width,
            minHeight = me.minHeight || me.height;

        // Not possible, even when shrunk to minima
        if (minHeight > constrainTo.height || minWidth > constrainTo.width) {
            return false;
        }

        // We do not mutate this Rectangle, but return a constrained version
        const result = me.clone();

        // Translate result so that the top and left are visible
        result.x = Math.max(me.x + Math.min(constrainTo.right  - result.right,  0), constrainTo.x);
        result.y = Math.max(me.y + Math.min(constrainTo.bottom - result.bottom, 0), constrainTo.y);

        // Pull in any resulting overflow
        result.bottom = Math.min(result.bottom, constrainTo.bottom);
        result.right = Math.min(result.right, constrainTo.right);

        return result;
    }

    alignTo(align) {
        const
            me             = this,
            {
                constrainTo,    // Element or Rectangle result must fit into
                target,         // Element or Rectangle to align to
                edgeAlign,      // t50-b50 type string
                axisLock,       // true for flip, 'flexible' for flip, then try the other edges
                offset,         // Final [x, y] vector to move the result by.
                matchSize
            }              = align,
            targetMargin   = align.targetMargin ? parseEdgeValue(align.targetMargin) : zeroMargins,
            targetRect     = getElRect(target),
            constrainRect  = getElRect(constrainTo),
            edges          = parseEdgeAlign(edgeAlign),
            matchDimension = zoneDimension[edges.theirEdgeZone & 1];

        let result = me.clone();

        if (matchSize) {
            result[matchDimension] = targetRect[matchDimension];
        }

        // Must do the calculations after the aligned side has been matched in size if requested.
        const
            myPoint     = result.getAnchorPoint(edges.ourEdgeZone, edges.ourEdgeOffset, edges.ourEdgeUnit),
            targetPoint = targetRect.getAnchorPoint(edges.theirEdgeZone, edges.theirEdgeOffset, edges.theirEdgeUnit, targetMargin),
            vector      = [targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]];

        result = result.moveBy(vector);

        // A useful property in the resulting rectangle which specifies which zone of the target
        // It is being places in, T,R,B or L - 0, 1, 2, 3
        // Some code may want to treat DOM elements differently depending on the zone
        result.zone = edges.theirEdgeZone;
        result.position = zoneNames[result.zone];

        // Now we create the four Rectangles around the target, into which we may be constrained
        // Zones T,R,B,L 0 9, 1, 2, 3:
        // +-----------------------------------------------------------------------------------+
        // | +-------------------------+------------------------+----------------------------+ |
        // | |          ^              |                        |             ^              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+---------Zone 0---------+-------------+---------->   | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | +----------+--------------+------------------------+-------------+--------------+ |
        // | |          |              | +--------------------+ |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |       Zone 3            | |                    | |          Zone 1            | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | +--------------------+ |             |              | |
        // | ++---------+--------------+------------------------+-------------+--------------+ |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+--------Zone 2----------+-------------+------------> | |
        // | |          |              |                        |             |              | |
        // | |          v              |                        |             v              | |
        // | ++------------------------+------------------------+----------------------------+ |
        // +-----------------------------------------------------------------------------------+
        if (constrainRect && !constrainRect.contains(result)) {
            // They asked to overlap the target, for example t0-t0
            // In these cases, we just return the result
            if (targetRect.intersects(result)) {
                return result;
            }

            // This is the zone we try to fit into first, the one that was asked for
            let zone = edges.theirEdgeZone;

            // We create an array of four rectangles into which we try to fit with appropriate align specs.
            // We must start with the requested zone, whatever that is.
            const zonesToTry = [{
                zone,
                edgeAlign
            }];

            if (axisLock) {
                // Flip to the opposite side for the second try.
                // The alignment string has to be reversed
                // so r20-l30 has to become l20-r30.
                // The other two zones revert to centered so are easier
                zonesToTry[1] = {
                    zone      : zone = (zone + 2) % 4,
                    edgeAlign : createReversedEdgeAlign(edges)
                }

                // Fall back to the other two zones.
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 1) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 3) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
            }
            else {
                // go through the other zones in order
                for (let i = 1; i < 4; i++) {
                    zonesToTry.push({
                        zone      : zone = (zone + 1) % 4,
                        edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                    });
                }
            }

            // Calculate the constraint Rectangle for each zone
            for (let i = 0; i < zonesToTry.length; i++) {
                // We clone the outer constraining rectangle
                // and move it into position
                const c = constrainRect.clone();

                switch (zonesToTry[i].zone) {
                    case 0:
                        // The zone i2 above the target - zone 0/T
                        c.bottom = targetRect.y - targetMargin[0];
                        break;
                    case 1:
                        // The zone is to the right of the target - zone 1/R
                        c.changeX(targetRect.right + targetMargin[1]);
                        break;
                    case 2:
                        // The zone is below the target - zone 2/B
                        c.changeY(targetRect.bottom + targetMargin[2]);
                        break;
                    case 3:
                        // The zone is to the left of the target - zone 3/L
                        c.right = targetRect.x - targetMargin[3];
                        break;
                }
                zonesToTry[i].constrainRect = c;
            }

            // Now try to constrain our result into each zone's constraintZone
            for (let i = 0; i < zonesToTry.length; i++) {
                const
                    {
                        zone,
                        edgeAlign,
                        constrainRect
                    }    = zonesToTry[i],
                    edge = zoneEdges[zone];

                if (matchSize) {
                    // If we are aligning to the requested edge, or it's opposite edge then
                    // match that edge size, else revert it to our own size
                    result[matchDimension] = edge === edges.theirEdge || edge == oppositeEdge[edges.theirEdge] ? targetRect[matchDimension] : me[matchDimension];
                }

                // Do a simple align to the current edge
                result = result.alignTo({
                    target : targetRect,
                    edgeAlign,
                    targetMargin
                });

                let solution = result.constrainTo(constrainRect);

                // As soon as we find a zone into which the result is willing to be constrained. return it
                if (solution) {
                    solution.zone = zone;
                    solution.position = zoneNames[zone];
                    return solution;
                }
            }
        }

        // Add the configurable finishing touch.
        if (offset) {
            result.moveBy(offset);
        }

        return result;
    }

    getAnchorPoint(edgeZone, edgeOffset, edgeUnit, margin = emptyArray) {
        const me = this;

        let result;

        // Edge zones go top, right, bottom, left
        // Each one calculates the start point of that edge then moves along it by
        // the edgeOffset, then moves *away* from it by the margin for that edge if there's a margin.
        switch (edgeZone) {
            case 0:
                result = [me.x, me.y - (margin[0] || 0), me.width, 0];
                break;
            case 1:
                result = [me.x + me.width + (margin[1] || 0), me.y, me.height, 1];
                break;
            case 2:
                result = [me.x, me.y + me.height + (margin[2] || 0), me.width, 0];
                break;
            case 3:
                result = [me.x - (margin[3] || 0), me.y, me.height, 1];
        }
        result[result[3]] += edgeUnit === '%' ? result[2] / 100 * edgeOffset : edgeOffset;
        result.length = 2;
        return result;
    }

    equals(other) {
        return other instanceof DOMRect &&
            other.x === this.x &&
            other.y === this.y &&
            other.height === this.height &&
            other.width === this.width;
    }

    // For debugging purposes only
    show(color = 'red') {
        const div = document.createElement('div');

        div.style = `
            position:absolute;
            transform:translate3d(${this.x}px, ${this.y}px, 0);
            height:${this.height}px;
            width:${this.width}px;
            background-color:${color}
        `;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 30000);
        return div;
    }

    /**
     * When using JSON.stringify(this), we want to add minHeight & minWidth to the output.
     * @returns {Object}
     */
    toJSON() {
        const {bottom, height, left, minHeight, minWidth, right, top, width, x, y} = this;
        return {bottom, height, left, minHeight, minWidth, right, top, width, x, y}
    }
}


/***/ }),

/***/ "./src/util/String.mjs":
/*!*****************************!*\
  !*** ./src/util/String.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.String
 * @extends Neo.core.Base
 */
class StringUtil extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} charEntityMap
     * @static
     */
    static charEntityMap = {
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        '\'': '&apos;',
        '$' : '&dollar;',
        '\\': '&bsol;',
        '/' : '&sol;'
    }
    /**
     * @member {RegExp} charPattern
     * @static
     */
    static charPattern = /[&<>"'$\\]/g
    /**
     * @member {RegExp} entityPattern
     * @static
     */
    static entityPattern = /(&amp;)|(&lt;)|(&gt;)|(&quot;)|(&apos;)|(&dollar;)|(&bsol;)|(&sol;)/g

    static config = {
        /**
         * @member {String} className='Neo.util.String'
         * @protected
         */
        className: 'Neo.util.String'
    }

    /**
     * Escape HTML special characters
     * @param {String} value
     */
    static escapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.charPattern, me.getEntityFromChar.bind(me))
    }

    /**
     * Get char equivalent of a mapped entity
     * @param {String} entity
     */
    static getCharFromEntity(entity) {
        let mappedChar = Object.keys(this.charEntityMap).find(key => this.charEntityMap[key] === entity);
        return mappedChar || entity
    }

    /**
     * Get entity equivalent of a mapped char
     * @param {String} char
     */
    static getEntityFromChar(char) {
        return this.charEntityMap[char] || char
    }

    /**
     * Unescape HTML special characters
     * @param {String} value
     */
    static unescapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.entityPattern, me.getCharFromEntity.bind(me))
    }

    /**
     * Returns the passed string with the first letter uncapitalized.
     * @param {String} value
     * @returns  {String}
     */
    static uncapitalize(value) {
        return value && value[0].toLowerCase() + value.substring(1)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(StringUtil));


/***/ }),

/***/ "./src/vdom/domConstants.mjs":
/*!***********************************!*\
  !*** ./src/vdom/domConstants.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rawDimensionTags: () => (/* binding */ rawDimensionTags),
/* harmony export */   voidAttributes: () => (/* binding */ voidAttributes),
/* harmony export */   voidElements: () => (/* binding */ voidElements)
/* harmony export */ });
/**
 * The following top-level attributes will get converted into styles:
 * height, maxHeight, maxWidth, minHeight, minWidth, width
 *
 * Some tags must not do the transformation, so we add them here.
 * @member {Set} rawDimensionTags
 */
const rawDimensionTags = new Set([
    'circle',
    'clipPath',
    'ellipse',
    'filter',
    'foreignObject',
    'image',
    'marker',
    'mask',
    'pattern',
    'rect',
    'svg',
    'use'
]);

/**
 * Void attributes inside html tags
 * @member {Set} voidAttributes
 * @protected
 */
const voidAttributes = new Set([
    'checked',
    'defer',
    'disabled',
    'ismap',
    'multiple',
    'nohref',
    'noresize',
    'noshade',
    'nowrap',
    'open',
    'readonly',
    'required',
    'reversed',
    'selected'
]);

/**
 * Void html tags
 * @member {Set} voidElements
 * @protected
 */
const voidElements = new Set([
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
]);


/***/ }),

/***/ "./src/worker/Manager.mjs":
/*!********************************!*\
  !*** ./src/worker/Manager.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../main/DomAccess.mjs */ "./src/main/DomAccess.mjs");
/* harmony import */ var _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../main/DomEvents.mjs */ "./src/main/DomEvents.mjs");
/* harmony import */ var _Message_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Message.mjs */ "./src/worker/Message.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mixin/RemoteMethodAccess.mjs */ "./src/worker/mixin/RemoteMethodAccess.mjs");







const NeoConfig    = Neo.config,
      hasJsModules = NeoConfig.environment === 'development' || NeoConfig.environment === 'dist/esm';

// Using ?. since SWs do not exist for http (only https)
navigator.serviceWorker?.addEventListener('controllerchange', function() {
    window.location.reload()
}, {once: true});

/**
 * The worker manager lives inside the main thread and creates the App, Data & VDom worker.
 * Also, responsible for sending messages from the main thread to the different workers.
 * @class Neo.worker.Manager
 * @extends Neo.core.Base
 * @singleton
 */
class Manager extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.Manager'
         * @protected
         */
        className: 'Neo.worker.Manager',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Number} activeWorkers=0
         * @protected
         */
        activeWorkers: 0,
        /**
         * @member {String[]} appNames=[]
         * @protected
         */
        appNames: [],
        /**
         * @member {Number} constructedThreads=0
         * @protected
         */
        constructedThreads: 0,
        /**
         * @member {String[]|Neo.core.Base[]|null} mixins=[Observable, RemoteMethodAccess]
         */
        mixins: [_core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]],
        /**
         * True in case the current browser supports window.SharedWorker.
         * @member {Boolean} sharedWorkersEnabled=false
         * @protected
         */
        sharedWorkersEnabled: false,
        /**
         * Internal flag to stop the worker communication in case their creation fails
         * @member {Boolean} stopCommunication=false
         * @protected
         */
        stopCommunication: false,
        /**
         * True in case the current browser supports window.Worker.
         * The neo.mjs framework is not able to run without web workers.
         * @member {Boolean} sharedWorkersEnabled=false
         * @protected
         */
        webWorkersEnabled: false,
        /**
         * Using the current timestamp as an unique window identifier
         * @member {Number} windowId=new Date().getTime()
         * @protected
         */
        windowId: new Date().getTime(),
        /**
         * Contains the fileNames for the App, Data & Vdom workers
         * @member {Object} workers
         * @protected
         */
        workers: {
            app: {
                fileName: hasJsModules ? 'App.mjs'    : 'appworker.js'
            },
            canvas: {
                fileName: hasJsModules ? 'Canvas.mjs' : 'canvasworker.js'
            },
            data: {
                fileName: hasJsModules ? 'Data.mjs'   : 'dataworker.js'
            },
            task: {
                fileName: hasJsModules ? 'Task.mjs'   : 'taskworker.js'
            },
            vdom: {
                fileName: hasJsModules ? 'VDom.mjs'   : 'vdomworker.js'
            }
        }
    }

    /**
     * navigator.serviceWorker.controller can be null in case we load a page for the first time
     * or in case of a force refresh.
     * See: https://www.w3.org/TR/service-workers/#navigator-service-worker-controller
     * Only in this case main.addon.ServiceWorker will store the active registration once ready here.
     * @member {ServiceWorker|null} serviceWorker=null
     */
    serviceWorker = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.detectFeatures();

        !Neo.insideWorker && me.createWorkers();

        Neo.workerId = 'main';

        me.promises = {};

        me.on({
            'message:addDomListener'    : {fn: _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addDomListener,       scope: _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]},
            'message:getOffscreenCanvas': {fn: _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].onGetOffscreenCanvas, scope: _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]},
            'message:readDom'           : {fn: _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].onReadDom,            scope: _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]},
            'message:registerRemote'    : {fn: me.onRegisterRemote,            scope: me},
            'message:workerConstructed' : {fn: me.onWorkerConstructed,         scope: me}
        })
    }

    /**
     * Sends a message to each worker defined inside the this.workers config.
     * @param {Object} msg
     */
    broadcast(msg) {
        Object.keys(this.workers).forEach(name => {
            if (!(
                name === 'canvas' && !NeoConfig.useCanvasWorker ||
                name === 'task'   && !NeoConfig.useTaskWorker   ||
                name === 'vdom'   && !NeoConfig.useVdomWorker
            )) {
                this.sendMessage(name, msg)
            }
        });
    }

    /**
     * Creates a web worker using the passed options as well as adding error & message event listeners.
     * @param {Object} opts
     * @returns {SharedWorker|Worker}
     */
    createWorker(opts) {
        let me         = this,
            {fileName} = opts,
            filePath   = (opts.basePath || Neo.config.workerBasePath) + fileName,
            name       = `neomjs-${fileName.substring(0, fileName.indexOf('.')).toLowerCase()}-worker`,
            isShared   = me.sharedWorkersEnabled && NeoConfig.useSharedWorkers,
            cls        = isShared ? SharedWorker : Worker,
            worker     = hasJsModules
                ? new cls(filePath, {name, type: 'module'})
                : new cls(filePath, {name});

        (isShared ? worker.port : worker).onmessage = me.onWorkerMessage.bind(me);
        (isShared ? worker.port : worker).onerror   = me.onWorkerError  .bind(me);

        me.activeWorkers++;

        return worker
    }

    /**
     * Calls createWorker for each worker inside the this.workers config.
     */
    createWorkers() {
        let me                   = this,
            config               = Neo.clone(NeoConfig, true),
            {hash, href, search} = location,
            {windowId}           = me,
            key, value;

        // remove configs which are not relevant for the workers scope
        delete config.cesiumJsToken;

        // pass the initial hash value as Neo.configs
        if (hash) {
            config.hash = {
                hash      : _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].parseHash(hash.substring(1)),
                hashString: hash.substring(1),
                windowId
            }
        }

        config.url = {href, search};

        for ([key, value] of Object.entries(me.workers)) {
            if (key === 'canvas' && !config.useCanvasWorker ||
                key === 'task'   && !config.useTaskWorker   ||
                key === 'vdom'   && !config.useVdomWorker
            ) {
                continue
            }

            try {
                value.worker = me.createWorker(value)
            } catch (e) {
                document.body.innerHTML = e;
                me.stopCommunication = true;
                break
            }

            me.sendMessage(key, {
                action: 'registerNeoConfig',
                data  : {...config, windowId}
            })
        }
    }

    /**
     *
     */
    detectFeatures() {
        let me = this;

        NeoConfig.hasMouseEvents = matchMedia('(pointer:fine)').matches;
        NeoConfig.hasTouchEvents = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Useful for styling
        document.body.classList.add(NeoConfig.hasMouseEvents ? 'neo-mouse' : 'neo-no-mouse');

        if (window.Worker) {
            me.webWorkersEnabled = true
        } else {
            throw new Error('Your browser does not support Web Workers')
        }

        if (window.SharedWorker) {
            me.sharedWorkersEnabled = true
        }
    }

    /**
     * @param {String|Worker} name
     * @returns {Worker}
     */
    getWorker(name) {
        if (name === 'service') {
            return navigator.serviceWorker?.controller || this.serviceWorker
        }

        return name instanceof Worker ? name : this.workers[name].worker
    }

    /**
     * @param {String} path
     */
    loadApplication(path) {
        this.sendMessage('app', {
            action       : 'loadApplication',
            path,
            resourcesPath: NeoConfig.resourcesPath
        })
    }

    /**
     * @param {Object} data
     */
    onWorkerConstructed(data) {
        let me = this;

        me.constructedThreads++;

        if (me.constructedThreads === me.activeWorkers) {
            // better safe than sorry => all remotes need to be registered
            NeoConfig.appPath && me.timeout(NeoConfig.loadApplicationDelay).then(() => {
                me.loadApplication(NeoConfig.appPath)
            })
        }
    }

    /**
     * Handler method for worker error events
     * @param {Object} e
     */
    onWorkerError(e) {
        // starting a worker from a JS module will show JS errors in a correct way
        !hasJsModules && console.log('Worker Error:', e)
    }

    /**
     * Handler method for worker message events
     * @param {Object} event
     */
    onWorkerMessage(event) {
        let me       = this,
            {data}   = event,
            transfer = null,
            promise;

        const {action, destination: dest, replyId} = data;

        me.fire('message:'+action, data);

        if (action === 'reply') {
            promise = me.promises[replyId];

            if (!promise) {
                if (data.data) {
                    data.data.autoMount  && me.fire('automount',  data);
                    data.data.updateVdom && me.fire('updateVdom', data);

                    // We want to delay the message until the rendering queue has processed it
                    // See: https://github.com/neomjs/neo/issues/2864
                    me.promiseForwardMessage(data).then(msgData => {
                        me.sendMessage(msgData.destination, msgData)
                    })
                }
            } else {
                if (dest === 'main') {
                    data = data.data
                }

                promise[data.reject ? 'reject' : 'resolve'](data);
                delete me.promises[replyId]
            }
        }

        if (dest !== 'main' && action !== 'reply') {
            if (data.transfer) {
                transfer = [data.transfer]
            }

            me.promiseMessage(dest, data, transfer).then(response => {
                me.sendMessage(response.destination, response)
            }).catch(err => {
                me.sendMessage(data.origin, {
                    action : 'reply',
                    reject : true,
                    replyId: data.id,
                    error  : err.message
                })
            })
        }

        // only needed for SharedWorkers
        else if (dest === 'main' && action === 'registerAppName') {
            let {appName} = data;

            me.appNames.push(appName);

            me.broadcast({action: 'registerApp', appName})
        }

        else if (dest === 'main' && action === 'remoteMethod') {
            me.onRemoteMethod(data)
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.replyId
     * @returns {Promise<any>}
     */
    promiseForwardMessage(data) {
        return new Promise((resolve, reject) => {
            this.promises[data.replyId] = {data, reject, resolve}
        })
    }

    /**
     * @param {String} dest app, canvas, data or vdom
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Promise<any>}
     */
    promiseMessage(dest, opts, transfer) {
        let me = this;

        return new Promise((resolve, reject) => {
            let message = me.sendMessage(dest, opts, transfer),
                msgId   = message.id;

            me.promises[msgId] = {reject, resolve}
        })
    }

    /**
     * @param {String} replyId
     */
    resolveDomOperationPromise(replyId) {
        if (replyId) {
            let {promises} = this,
                promise    = promises[replyId];

            if (promise) {
                promise.resolve(promise.data);
                delete promises[replyId]
            }
        }
    }

    /**
     * @param {String} dest app, canvas, data or vdom
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Neo.worker.Message}
     * @protected
     */
    sendMessage(dest, opts, transfer) {
        let me = this,
            message, worker;

        if (!me.stopCommunication) {
            if (opts.channelPort) {
                worker = opts.channelPort;
                delete opts.channelPort
            } else {
                worker = me.getWorker(dest)
            }

            if (!worker) {
                throw new Error('Called sendMessage for a worker that does not exist: ' + dest)
            }

            opts.destination = dest;

            message = new _Message_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](opts);

            (worker.port ? worker.port : worker).postMessage(message, transfer);
            return message
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Manager));


/***/ }),

/***/ "./src/worker/Message.mjs":
/*!********************************!*\
  !*** ./src/worker/Message.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/IdGenerator.mjs */ "./src/core/IdGenerator.mjs");


/**
 * A wrapper for worker post messages sent between the App, Data, VDom worker & the main thread.
 * You can add optional params as needed.
 * @class Neo.worker.Message
 */
class Message {
    /**
     * @param {Object} config
     */
    constructor(config) {
        /**
         * @member {String} action
         */

        /**
         * @member {String} destination='main'
         */

        /**
         * @member {String} id=IdGenerator.getId(Neo.workerId)
         */

        /**
         * @member {String} origin=Neo.workerId
         */

        config.destination = config.destination || 'main';
        config.id          = config.id          || _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getId(Neo.workerId);
        config.origin      = config.origin      || Neo.workerId;

        Object.assign(this, config)
    }
}

const ns = Neo.ns('Neo.worker', true);
ns['Message'] = Message;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Message);


/***/ }),

/***/ "./src/worker/mixin/RemoteMethodAccess.mjs":
/*!*************************************************!*\
  !*** ./src/worker/mixin/RemoteMethodAccess.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.worker.mixin.RemoteMethodAccess
 * @extends Neo.core.Base
 */
class RemoteMethodAccess extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.mixin.RemoteMethodAccess'
         * @protected
         */
        className: 'Neo.worker.mixin.RemoteMethodAccess',
        /**
         * @member {Boolean} mixin=true
         * @protected
         */
        mixin: true
    }

    /**
     * @param {Object} source
     * @param {Object} target
     */
    assignPort(source, target) {
        if (source) {
            const {appName, port, windowId} = source;
            Object.assign(target, {appName, port, windowId})
        }
    }

    /**
     * @param {Object} remote
     * @param method
     * @returns {function(*=, *=): Promise<any>}
     */
    generateRemote(remote, method) {
        let me       = this,
            {origin} = remote;

        return function(data, buffer) {
            let opts = {
                action         : 'remoteMethod',
                data,
                destination    : origin,
                remoteClassName: remote.className,
                remoteMethod   : method
            };

            me.isSharedWorker && me.assignPort(data, opts);

            return me.promiseMessage(origin, opts, buffer)
        }
    }

    /**
     * @param {Object} remote
     */
    onRegisterRemote(remote) {
        if (remote.destination === Neo.workerId) {
            let me                   = this,
                {className, methods} = remote,
                pkg                  = Neo.ns(className, true);

            methods.forEach(method => {
                if (remote.origin !== 'main' && pkg[method]) {
                    throw new Error('Duplicate remote method definition ' + className + '.' + method)
                }

                pkg[method] ??= me.generateRemote(remote, method)
            })
        }
    }

    /**
     * @param {Object} msg
     */
    onRemoteMethod(msg) {
        let me  = this,
            pkg = Neo.ns(msg.remoteClassName),
            out, method;

        if (!pkg) {
            throw new Error('Invalid remote namespace "' + msg.remoteClassName + '"')
        }

        method = pkg[msg.remoteMethod];

        if (!method) {
            throw new Error('Invalid remote method name "' + msg.remoteMethod + '"')
        }

        if (Array.isArray(msg.data)) {
            out = method.call(pkg, ...msg.data)
        } else {
            out = method.call(pkg, msg.data)
        }

        if (out instanceof Promise) {
            out
                /*
                 * Intended logic:
                 * If the code of a remote method fails, it would not show any errors inside the console,
                 * so we want to manually log the error for debugging.
                 * Rejecting the Promise gives us the chance to recover.
                 *
                 * Example:
                 * Neo.vdom.Helper.update(opts).catch(err => {
                 *     me.isVdomUpdating = false;
                 *     reject?.()
                 * }).then(data => {...})
                 */
                .catch(err => {console.error(err); me.reject(msg, err)})
                .then(data => {me.resolve(msg, data)})
        } else {
            me.resolve(msg, out)
        }
    }

    /**
     * Gets called when promiseMessage gets rejected
     * @param {Object} msg
     * @param {Object} data
     */
    reject(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            reject : true,
            replyId: msg.id
        };

        me.isSharedWorker && me.assignPort(msg, opts);
        me.sendMessage(msg.origin, opts)
    }

    /**
     * Gets called when promiseMessage gets resolved
     * @param {Object} msg
     * @param {Object} data
     */
    resolve(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            replyId: msg.id
        };

        me.isSharedWorker && me.assignPort(msg, opts);
        me.sendMessage(msg.origin, opts)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RemoteMethodAccess));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "chunks/main/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "neo.mjs:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/Main.mjs ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Neo.mjs */ "./src/Neo.mjs");
/* harmony import */ var _core_export_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/_export.mjs */ "./src/core/_export.mjs");
/* harmony import */ var _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main/DomAccess.mjs */ "./src/main/DomAccess.mjs");
/* harmony import */ var _main_DeltaUpdates_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./main/DeltaUpdates.mjs */ "./src/main/DeltaUpdates.mjs");
/* harmony import */ var _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./main/DomEvents.mjs */ "./src/main/DomEvents.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./worker/Manager.mjs */ "./src/worker/Manager.mjs");


 // has to get imported before DeltaUpdates





/**
 * @class Neo.Main
 * @extends Neo.core.Base
 * @singleton
 */
class Main extends _core_export_mjs__WEBPACK_IMPORTED_MODULE_1__.Base {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.Main'
         * @protected
         */
        className: 'Neo.Main',
        /**
         * @member {String} mode='read'
         * @protected
         */
        mode: 'read',
        /**
         * @member {Object} openWindows={}
         * @protected
         */
        openWindows: {},
        /**
         * @member {Array} readQueue=[]
         * @protected
         */
        readQueue: [],
        /**
         * Remote method access for other workers
         * @member {Object} remote={app: [//...]}
         * @protected
         */
        remote: {
            app: [
                'alert',
                'editRoute',
                'getByPath',
                'getWindowData',
                'importAddon',
                'log',
                'redirectTo',
                'reloadWindow',
                'setNeoConfig',
                'setRoute',
                'windowClose',
                'windowCloseAll',
                'windowMoveTo',
                'windowOpen',
                'windowResizeTo'
            ]
        },
        /**
         * @member {Boolean} running=false
         * @protected
         */
        running: false,
        /**
         * @member {Boolean} showFps=false
         */
        showFps: false,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Number} timeLimit=15
         */
        timeLimit: 15,
        /**
         * should be dev only
         * @member {Number} totalFrameCount=0
         * @protected
         */
        totalFrameCount: 0,
        /**
         * @member {Array} updateQueue=[]
         * @protected
         */
        updateQueue: [],
        /**
         * @member {Array} writeQueue=[]
         * @protected
         */
        writeQueue: []
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].on({
            'automount'        : me.onRender,
            'message:mountDom' : me.onMountDom,
            'message:updateDom': me.onUpdateDom,
            'updateVdom'       : me.onUpdateVdom,
            scope              : me
        });

        _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].on('domContentLoaded', me.onDomContentLoaded, me);

        if (document.readyState !== 'loading') {
            _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].onDomContentLoaded()
        }
    }

    /**
     * Workers can not trigger alert(), so we need remote method access.
     * @param {Object} data
     * @param {String} data.message
     */
    alert(data) {
        alert(data.message)
    }

    /**
     * Edit the location.hash value
     * A value of null will remove the given key.
     * @param {Object} data
     */
    editRoute(data) {
        let hashObj = _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].parseHash(window.location.hash.substr(1)),
            hashArr = [];

        if (typeof data === 'string') {
            data = _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].parseHash(data)
        }

        Object.assign(hashObj, data);

        Object.entries(hashObj).forEach(([key, value]) => {
            if (value !== null) {
                hashArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(value))
            }
        });

        window.location.hash = hashArr.join('&')
    }

    /**
     * Request specific accessible window attributes by path into the app worker.
     * Keep in mind that this excludes anything DOM related or instances.
     * In case your path matches a method, you can also pass params for it.
     * @example:
     *     Neo.Main.getByPath({path: 'navigator.language'}).then(data => {})
     * @example:
     *     Neo.Main.getByPath({path: 'CSS.supports', params: ['display: flex']}).then(data => {})
     * @param {Object} data
     * @param {Array}  data.params=[]
     * @param {String} data.path
     * @returns {*}
     */
    getByPath({params=[], path}) {
        let target = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].nsWithArrays(path);
        return _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(target) ? target(...params) : target
    }

    /**
     * window.screen is not spreadable
     * @returns {Object}
     */
    getWindowData() {
        let win      = window,
            {screen} = win;

        return {
            innerHeight: win.innerHeight,
            innerWidth : win.innerWidth,
            outerHeight: win.outerHeight,
            outerWidth : win.outerWidth,
            screen: {
                availHeight: screen.availHeight,
                availLeft  : screen.availLeft,
                availTop   : screen.availTop,
                availWidth : screen.availWidth,
                colorDepth : screen.colorDepth,
                height     : screen.height,
                orientation: {angle: screen.orientation?.angle, type: screen.orientation?.type},
                pixelDepth : screen.pixelDepth,
                width      : screen.width
            },
            screenLeft: win.screenLeft,
            screenTop : win.screenTop
        }
    }

    /**
     * Import main thread addons at run-time from within the app worker
     * @param {Object} data
     * @param {String} data.name
     * @returns {Boolean}
     */
    async importAddon(data) {
        let {name} = data,
            module;

        if (name.startsWith('WS/')) {
            module = await __webpack_require__("./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$")(`./${name.substring(3)}.mjs`)
        } else {
            module = await __webpack_require__("./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$")(`./${name}.mjs`)
        }

        this.registerAddon(module.default);
        await this.timeout(20); // Wait until remotes are registered

        return true
    }

    /**
     * Remote console access to main threads.
     * You can use appName or windowId to target specific windows.
     * @param {Object} data
     * @param {String} [data.appName]
     * @param {String} data.value
     * @param {String} [data.method] defaults to 'log'
     * @param {Number} [data.windowId]
     * @returns {Boolean}
     */
    log(data) {
        console[data.method || 'log'](data.value);
        return true
    }

    /**
     *
     */
    async onDomContentLoaded() {
        let me       = this,
            {config} = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            imports  = [],
            {environment, mainThreadAddons, useServiceWorker} = config,
            modules;

        _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].onDomContentLoaded();

        // We need different publicPath values for the main thread inside the webpack based dist envs,
        // depending on the hierarchy level of the app entry point
        if (environment === 'dist/development' || environment === 'dist/production') {
            __webpack_require__.p = config.basePath.substring(6)
        }

        // Intended for the online examples where we need an easy way to add GA to every generated app
        if (config.useGoogleAnalytics && !mainThreadAddons.includes('AnalyticsByGoogle')) {
            mainThreadAddons.push('AnalyticsByGoogle')
        }

        if ((
                useServiceWorker === true ||
                useServiceWorker === environment ||
                (useServiceWorker === 'dist/production' && environment === 'dist/esm')
            ) &&
            !mainThreadAddons.includes('ServiceWorker')
        ) {
            mainThreadAddons.push('ServiceWorker')
        }

        mainThreadAddons.forEach(addon => {
            if (addon.startsWith('WS/')) {
                imports.push(__webpack_require__("./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$")(`./${addon.substring(3)}.mjs`))
            } else {
                imports.push(__webpack_require__("./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$")(`./${addon}.mjs`))
            }
        });

        modules = await Promise.all(imports);

        me.addon = {};

        modules.forEach(module => {
            me.registerAddon(module.default)
        });

        _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].onWorkerConstructed({
            origin: 'main'
        })
    }

    /**
     * @param {Object} data
     */
    onMountDom(data) {
        this.queueWrite(data);

        _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].sendMessage(data.origin || 'app', {
            action : 'reply',
            replyId: data.id,
            success: true
        })
    }

    /**
     * @param {Object} data
     */
    onRender(data) {
        data.data.replyId = data.replyId;
        this.queueWrite(data.data)
    }

    /**
     * @param {Object} data
     */
    onUpdateDom(data) {
        this.queueUpdate(data)
    }

    /**
     * @param {Object} data
     */
    onUpdateVdom(data) {
        data.data.replyId = data.replyId;
        this.queueUpdate(data.data)
    }

    /**
     * @param {Object[]} queue
     * @param {Date} start
     * @returns {Number}
     * @protected
     */
    processQueue(queue, start) {
        let me     = this,
            {mode} = me,
            limit  = me.timeLimit,
            operation;

        while (operation = queue.shift()) {
            if (new Date() - start > limit) {
                queue.unshift(operation);
                return requestAnimationFrame(me.renderFrame.bind(me))
            } else {
                if (mode === 'read') {
                    _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].read(operation)
                } else if (mode === 'write') {
                    _main_DeltaUpdates_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].insertNode(operation)
                } else {
                    _main_DeltaUpdates_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].update(operation)
                }

                _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].resolveDomOperationPromise(operation.replyId)
            }
        }
    }

    /**
     * @param {Object} data
     * @protected
     */
    queueRead(data) {
        let me = this;
        me.readQueue.push(data);

        if (!me.running) {
            me.running = true;
            requestAnimationFrame(me.renderFrame.bind(me))
        }
    }

    /**
     * @param {Object} data
     * @protected
     */
    queueUpdate(data) {
        let me = this;
        me.updateQueue.push(data);

        if (!me.running) {
            me.running = true;
            requestAnimationFrame(me.renderFrame.bind(me))
        }
    }

    /**
     * @param data
     * @protected
     */
    queueWrite(data) {
        let me = this;
        me.writeQueue.push(data);

        if (!me.running) {
            me.running = true;
            requestAnimationFrame(me.renderFrame.bind(me))
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.url
     */
    redirectTo(data) {
        window.location.href = data.url
    }

    /**
     * Helper method to register main thread addons
     * @param {Neo.core.Base} addon Can either be a neo class or instance
     */
    registerAddon(addon) {
        if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].typeOf(addon) === 'NeoClass') {
            // Addons could get imported multiple times. Ensure to only create an instance once.
            if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].typeOf(_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(addon.prototype.className)) !== 'NeoInstance') {
                addon = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].create(addon)
            }

            // Main thread addons need to get registered as singletons inside the neo namespace
            _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].applyToGlobalNs(addon)
        }

        this.addon[addon.constructor.name] = addon
    }

    /**
     * @param {Object} data
     */
    reloadWindow(data) {
        location.reload()
    }

    /**
     * Triggers the different DOM operation queues
     * @protected
     */
    renderFrame() {
        let me      = this,
            read    = me.readQueue,
            update  = me.updateQueue,
            write   = me.writeQueue,
            reading = me.mode === 'read',
            start   = new Date();

        if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config.logDeltaUpdates) {
            me.totalFrameCount++;
            console.log('Total Frames: ' + me.totalFrameCount)
        }

        if (reading || !write.length) {
            me.mode = 'read';
            if (me.processQueue(read, start)) {
                return
            }
        }

        if (update.length) {
            me.mode = 'update';
            if (me.processQueue(update, start)) {
                return
            }
        }

        if (write.length) {
            me.mode = 'write';
            if (me.processQueue(write, start)) {
                return
            }
        }

        me.running = false
    }

    /**
     * Change a Neo.config from the app worker
     * @param {Object} data
     * @param {String} data.key
     * @param {*} data.value
     */
    setNeoConfig(data) {
        let {key, value} = data;

        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config[key] = data.value;

        key === 'renderCountDeltas' && _main_DeltaUpdates_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].set({[key]: value})
    }

    /**
     * Change the location.hash value
     * @param {Object} data
     * @param {String} data.value
     */
    setRoute(data) {
        window.location.hash = data.value
    }

    /**
     * Closes popup windows
     * @param {Object} data
     * @param {String|String[]} data.names
     */
    windowClose(data) {
        if (!Array.isArray(data.names)) {
            data.names = [data.names]
        }

        data.names.forEach(name => {
            this.openWindows[name]?.close();
            delete this.openWindows[name]
        })
    }

    /**
     * Closes all popup windows
     * @param {Object} data
     */
    windowCloseAll(data) {
        Object.values(this.openWindows).forEach(value => {
            console.log(value);
            value.close()
        });

        this.openWindows = {}
    }

    /**
     * Move a popup window
     * @param {Object} data
     * @param {String} data.windowName
     * @param {String} data.x
     * @param {String} data.y
     */
    windowMoveTo(data) {
        this.openWindows[data.windowName]?.moveTo(data.x, data.y)
    }

    /**
     * Open a new popup window and return if successful
     * @param {Object} data
     * @param {String} data.url
     * @param {String} data.windowFeatures
     * @param {String} data.windowName
     * @return {Boolean}
     */
    windowOpen(data) {
        let openedWindow = window.open(data.url, data.windowName, data.windowFeatures),
            success      = !!openedWindow;

        if (success) {
            this.openWindows[data.windowName] = openedWindow
        }

        return success
    }

    /**
     * Move a popup window
     * @param {Object} data
     * @param {Number} [data.height]
     * @param {Number} [data.width]
     * @param {String} data.windowName
     */
    windowResizeTo(data) {
        let win    = this.openWindows[data.windowName],
            height = data.height || win.outerHeight,
            width  = data.width  || win.outerWidth;

        win.resizeTo(width, height)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].setupClass(Main));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhDQUE4QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBOEM7QUFDckUsQ0FBQzs7QUFFRCxpRUFBZSxhQUFhLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalRtQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGdEQUFHLGlCQUFpQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9EZWZhdWx0Q29uZmlnLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL05lby5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9Db21wYXJlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvSWRHZW5lcmF0b3IubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9PYnNlcnZhYmxlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvVXRpbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL19leHBvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9EZWx0YVVwZGF0ZXMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9Eb21BY2Nlc3MubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9Eb21FdmVudHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9Eb21VdGlscy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYWluL2FkZG9uLyBsYXp5IF5cXC5cXC8uKlxcLm1qcyQgc3RyaWN0IG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYWluL21peGluL1RvdWNoRG9tRXZlbnRzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvQXJyYXkubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9GdW5jdGlvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1JlY3RhbmdsZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1N0cmluZy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy92ZG9tL2RvbUNvbnN0YW50cy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvTWFuYWdlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvTWVzc2FnZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy93b3JrZXIvbWl4aW4vUmVtb3RlTWV0aG9kQWNjZXNzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2Vuc3VyZSBjaHVuayIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvbG9hZCBzY3JpcHQiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL01haW4ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE5lbyA9IGdsb2JhbFRoaXMuTmVvIHx8IHt9O1xuXG5OZW8uY29uZmlnID0gTmVvLmNvbmZpZyB8fCB7fTtcblxuLyoqXG4gKiBDb25maWcgb2JqZWN0IGZvciB0aGUgbmVvLm1qcyBmcmFtZXdvcmsgd2hpY2ggd2lsbCBnZXQgcGFzc2VkIHRvIGFsbCB3b3JrZXJzXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGUgY29uZmlncywgZS5nLiBpbnNpZGUgdGhlIGluZGV4Lmh0bWwgb2YgeW91ciBhcHBcbiAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gKiBAbmFtZSBjb25maWdcbiAqIEB0eXBlIE9iamVjdFxuICovXG5jb25zdCBEZWZhdWx0Q29uZmlnID0ge1xuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBhcHBseSAnbmVvLWJvZHknIHRvIHRoZSBkb2N1bWVudC5ib2R5IGNsYXNzTGlzdFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuYXBwbHlCb2R5Q2xzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiB0cnVlIHdpbGwgYXBwbHkgJ3Bvc2l0aW9uOiBmaXhlZCcgdG8gdGhlIGh0bWwgdGFnIGl0c2VsZlxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzY0MjlcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmFwcGx5Rml4ZWRQb3NpdGlvblRvSHRtbFRhZ1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBhcHBseUZpeGVkUG9zaXRpb25Ub0h0bWxUYWc6IHRydWUsXG4gICAgLyoqXG4gICAgICogUGF0aCB0byB5b3VyIGFwcC5tanMgZmlsZS4gWW91IGNhbiBjcmVhdGUgbXVsdGlwbGUgYXBwcyB0aGVyZSBpZiBuZWVkZWQuXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5hcHBQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBhcHBQYXRoOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFBhdGggdG8gdGhlIG5lby5tanMgZGlyZWN0b3J5XG4gICAgICogQGRlZmF1bHQgJy4vJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5iYXNlUGF0aFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGJhc2VQYXRoOiAnLi8nLFxuICAgIC8qKlxuICAgICAqIFBhc3MgYSB0b2tlbiBpbiBjYXNlIHlvdSBhcmUgdXNpbmcgdGhlIENlc2l1bUpTIG1haW4gdGhyZWFkIGFkZG9uXG4gICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9ibG9iL2Rldi9zcmMvbWFpbi9hZGRvbi9DZXNpdW1KUy5tanNcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuY2VzaXVtSnNUb2tlblxuICAgICAqIEB0eXBlIFN0cmluZ3xudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGUgY29tcG9uZW50IGxvZ2dpbmcgdXNpbmcgQ3RybC1SaWdodC1DbGlja1xuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZW5hYmxlQ29tcG9uZW50TG9nZ2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGVuYWJsZUNvbXBvbmVudExvZ2dlcjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gdHJ1ZSB0byBlbmFibGUgdXRpbC5Mb2dnZXIgKE5lby5sb2coKSkgYmFzZWQgbG9ncyBpbiBwcm9kdWN0aW9uXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZW5hYmxlTG9nc0luUHJvZHVjdGlvblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBlbmFibGVMb2dzSW5Qcm9kdWN0aW9uOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBlbnZpcm9ubWVudC4gVmFsaWQgdmFsdWVzOiAnZGV2ZWxvcG1lbnQnLCAnZGlzdC9kZXZlbG9wbWVudCcsICdkaXN0L3Byb2R1Y3Rpb24nXG4gICAgICogVGhpcyBjb25maWcgd2lsbCBnZXQgYXV0by1nZW5lcmF0ZWRcbiAgICAgKiBAZGVmYXVsdCAnZGlzdC9wcm9kdWN0aW9uJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5lbnZpcm9ubWVudFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGVudmlyb25tZW50OiAnZGlzdC9wcm9kdWN0aW9uJyxcbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHlvdSBhcmUgdXNpbmcgdGhlIEdvb2dsZU1hcHMgbWFpbiB0aHJlYWQgYWRkb24sIHlvdSBjYW4gcGFzcyB0aGUgQVBJIGtleSBoZXJlLlxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5nb29nbGVNYXBzQXBpS2V5XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHlvdSBhcmUgdXNpbmcgdGhlIEdvb2dsZUFuYWx5dGljcyBtYWluIHRocmVhZCBhZGRvbiBvciB1c2VHb29nbGVBbmFseXRpY3M6IHRydWUsXG4gICAgICogeW91IGNhbiBjaGFuZ2UgdGhlIGd0YWcgaWQgaGVyZS4gUmVxdWlyZWQgZm9yIHRoZSBvbmxpbmUgZXhhbXBsZXMgKGdoIHBhZ2VzKVxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5ndGFnSWRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHJ1bm5pbmcgb24gaHR0cHM6Ly9uZW9tanMuZ2l0aHViLmlvL3BhZ2VzL1xuICAgICAqID0+IHRvIHVzZSBsb2NhbCBpbWFnZXMgcGF0aHMgaW5zdGVhZCBvZiByYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuaXNHaXRIdWJQYWdlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0dpdEh1YlBhZ2VzOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHJ1bm5pbmcgdGhlIE5lbyBtYWluIHRocmVhZCBpbnNpZGUgYW4gaWZyYW1lIChTaWVzdGEgQnJvd3NlciBIYXJuZXNzKVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmlzSW5zaWRlU2llc3RhXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGlzSW5zaWRlU2llc3RhOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBkZWxheSBpbiBtcyBmb3IgdGhlIHdvcmtlci5NYW5hZ2VyOmxvYWRBcHBsaWNhdGlvbigpIGNhbGxcbiAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5sb2FkQXBwbGljYXRpb25EZWxheVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGxvYWRBcHBsaWNhdGlvbkRlbGF5OiAyMCxcbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IEludGwuRGF0ZVRpbWVGb3JtYXQsIGZvciBkZXRhaWxzIHRha2UgYSBsb29rIGF0OlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAgICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvY2FsZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGxvY2FsZTogJ2RlZmF1bHQnLFxuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBsb2cgdGhlIGRlbHRhIHVwZGF0ZXMgaW5zaWRlIHRoZSBtYWluIHRocmVhZChzKSBhcyB3ZWxsIGFzIHRoZSByZXF1ZXN0QW5pbWF0aW9uIGZyYW1lc1xuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvZ0RlbHRhVXBkYXRlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBsb2dEZWx0YVVwZGF0ZXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBsb2cgY29uc29sZSB3YXJuaW5ncywgaW4gY2FzZSBhIGNvbXBvbmVudCB0cmllcyB0byB1cGRhdGUoKSB3aGlsZSBhIHBhcmVudCB1cGRhdGUgaXMgcnVubmluZy5cbiAgICAgKiBBIHBhcmVudCB1cGRhdGUgcmVzdWx0cyBpbiBhIHNob3J0IGRlbGF5LCBzbyB5b3UgbWlnaHQgd2FudCB0byByZXNvbHZlIHRoZXNlIGNvbGxpc2lvbnMuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgbG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFkZCBhZGRvbnMgZm9yIHRoZSBtYWluIHRocmVhZFxuICAgICAqIC4vc3JjL21haW4vYWRkb24vIGNvbnRhaW5zIGFsbCBmcmFtZXdvcmsgcmVsYXRlZCBvcHRpb25zLlxuICAgICAqIFlvdSBjYW4gYWxzbyBjcmVhdGUgeW91ciBvd24gYWRkb25zIHdpdGhpbiB5b3VyIHdvcmtzcGFjZSBzY29wZS4gTWFrZSBzdXJlIHRvIHB1dCB0aGVtIGluc2lkZSAnc3JjL21haW4vYWRkb24vJ1xuICAgICAqIGFuZCBwcmVmaXggdGhlbSB3aXRoICdXUy8nIGluc2lkZSB5b3VyIG5lby1jb25maWcuanNvbiBmaWxlLlxuICAgICAqIEV4YW1wbGU6IFsnRHJhZ0Ryb3AnLCAnU3R5bGVzaGVldCcsICdXUy9NeUFkZG9uJ11cbiAgICAgKiBAZGVmYXVsdCBbJ0RyYWdEcm9wJywgJ05hdmlnYXRvcicsICdTdHlsZXNoZWV0J11cbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubWFpblRocmVhZEFkZG9uc1xuICAgICAqIEB0eXBlIFN0cmluZ1tdXG4gICAgICovXG4gICAgbWFpblRocmVhZEFkZG9uczogWydEcmFnRHJvcCcsICdOYXZpZ2F0b3InLCAnU3R5bGVzaGVldCddLFxuICAgIC8qKlxuICAgICAqIFBhc3MgdGhlIFVSTCBvZiBhIEpTT04tZmlsZSwgd2hpY2ggY29udGFpbnMgdGhlIHNlcnZpY2VzIGFuZCBtZXRob2RzIGZyb20geW91ciBiYWNrZW5kLFxuICAgICAqIHdoaWNoIHlvdSB3YW50IHRvIGV4cG9zZSB0byB0aGUgY2xpZW50LlxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vcHJvamVjdHMvMzJcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnJlbW90ZXNBcGlVcmxcbiAgICAgKiBAdHlwZSBTdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHJlbW90ZXNBcGlVcmw6IG51bGwsXG4gICAgLyoqXG4gICAgICogWW91IGNhbiB2aXN1YWxseSBzaG93IHRoZSBhbW91bnQgb2YgZGVsdGEgdXBkYXRlcyBwZXIgc2Vjb25kIHVzaW5nIHRoaXMgY29uZmlnLlxuICAgICAqIEl0IGV4cGVjdHMgYSBkb20gbm9kZSB3aXRoIHRoZSBpZCBcIm5lby1kZWx0YS11cGRhdGVzXCIgYXMgdGhlIHJlbmRlcmluZyB0YXJnZXQuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcucmVuZGVyQ291bnREZWx0YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgcmVuZGVyQ291bnREZWx0YXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFkZCB0aGVtZXMgeW91IHdhbnQgdG8gdXNlIGhlcmUuIFRoZSBmaXJzdCB0aGVtZSB3aWxsIGdldCBhcHBsaWVkLlxuICAgICAqIEBkZWZhdWx0IFsnbmVvLXRoZW1lLWxpZ2h0JywnbmVvLXRoZW1lLWRhcmsnLCduZW8tdGhlbWUtbmVvLWxpZ2h0J11cbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudGhlbWVzXG4gICAgICogQHR5cGUgU3RyaW5nW11cbiAgICAgKi9cbiAgICB0aGVtZXM6IFsnbmVvLXRoZW1lLWxpZ2h0JywgJ25lby10aGVtZS1kYXJrJywgJ25lby10aGVtZS1uZW8tbGlnaHQnXSxcbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBzdGFuZGFsb25lIFNpZXN0YSBtb2R1bGUgdGVzdHMgPT4gcHJldmVudCByZWdpc3RlclJlbW90ZSB3b3JrZXIgbWVzc2FnZXNcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51bml0VGVzdE1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdW5pdFRlc3RNb2RlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwgZmxhZyBpZiBhbiBvZmZzY3JlZW4gY2FudmFzIHdvcmtlciBzaG91bGQgZ2V0IGNyZWF0ZWQuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlQ2FudmFzV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZUNhbnZhc1dvcmtlcjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogRmxhZyBpZiB2ZG9tIGlkcyBzaG91bGQgZ2V0IG1hcHBlZCBpbnRvIERPTSBlbGVtZW50IGlkcy5cbiAgICAgKiBmYWxzZSB3aWxsIGNvbnZlcnQgdGhlbSBpbnRvIGEgXCJkYXRhLW5lby1pZFwiIGF0dHJpYnV0ZS5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZURvbUlkc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VEb21JZHM6IHRydWUsXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgaW5jbHVkZSB0aGUgc3R5bGVzaGVldFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlRm9udEF3ZXNvbWVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlRm9udEF3ZXNvbWU6IHRydWUsXG4gICAgLyoqXG4gICAgICogSW50ZW5kZWQgZm9yIHRoZSBvbmxpbmUgZXhhbXBsZXMgd2hlcmUgd2UgbmVlZCBhbiBlYXN5IHdheSB0byBhZGQgR0EgdG8gZXZlcnkgZ2VuZXJhdGVkIGFwcFxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZUdvb2dsZUFuYWx5dGljc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VHb29nbGVBbmFseXRpY3M6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFRydWUgd2lsbCBhZGQgdGhlIFNlcnZpY2VXb3JrZXIgbWFpbiB0aHJlYWQgYWRkb24gdG8gc3VwcG9ydCBjYWNoaW5nIG9mIGFzc2V0cyAoUFdBKVxuICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NlcnZpY2VfV29ya2VyX0FQSVxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIHVzZSBhIHN0cmluZyB0byBzcGVjaWZ5IHRoZSB0YXJnZXQgZW52aXJvbm1lbnQgPT4gJ2Rpc3QvcHJvZHVjdGlvbicuXG4gICAgICogVXNpbmcgJ2Rpc3QvcHJvZHVjdGlvbicgd2lsbCBhbHNvIHVzZSB0aGUgc2VydmljZSB3b3JrZXIgZm9yICdkaXN0L2VzbSdcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VTZXJ2aWNlV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhbnxTdHJpbmdcbiAgICAgKi9cbiAgICB1c2VTZXJ2aWNlV29ya2VyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIEFwcCwgRGF0YSAmIFZEb20gYXMgU2hhcmVkV29ya2Vycy5cbiAgICAgKiBTZXQgdGhpcyBvbmUgdG8gdHJ1ZSBpbiBjYXNlIHlvdSB3YW50IHRvIGNvbm5lY3QgbXVsdGlwbGUgbWFpbiB0aHJlYWRzLlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZVNoYXJlZFdvcmtlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlU2hhcmVkV29ya2VyczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogYHRydWVgIHdpbGwgbGV0IHRoZSBgdmRvbS5IZWxwZXJgIGNyZWF0ZSBhIFN0cmluZy1iYXNlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdm5vZGUgdHJlZS5cbiAgICAgKiBNYWluIHdpbGwgdGhlbiB1c2UgZS5nLmBwYXJlbnROb2RlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgZGVsdGEub3V0ZXJIVE1MKTtgXG4gICAgICogVGhpcyBhZmZlY3RzIHRoZSBpbml0aWFsIHBhaW50aW5nIG9mIHlvdXIgYXBwcywgYnV0IGFsc28gdGhlIGNyZWF0aW9uIG9mIG5ldyBjb21wb25lbnQgdHJlZXMgYXQgcnVuLXRpbWUuXG4gICAgICogYGZhbHNlYCB3aWxsIHNraXAgdGhlIGNyZWF0aW9uIG9mIHRoZSBTdHJpbmcsIGFuZCBpbnN0ZWFkIHVzZSBET00gQVBJcyB0byBnZW5lcmF0ZSBhIGZyYWdtZW50IGluc2lkZSBNYWluLFxuICAgICAqIGludG8gd2hpY2ggdGhlIHZub2RlIHRyZWUgd2lsbCBnZXQgYXBwbGllZC5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VTdHJpbmdCYXNlZE1vdW50aW5nXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZVN0cmluZ0Jhc2VkTW91bnRpbmc6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFRydWUgd2lsbCBnZW5lcmF0ZSBhIG5ldyB0YXNrIHdvcmtlciwgd2hpY2ggY2FuIGdldCBmaWxsZWQgd2l0aCBvd24gZXhwZW5zaXZlIHJlbW90ZSBtZXRob2RzXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlVGFza1dvcmtlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VUYXNrV29ya2VyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGYWxzZSB3aWxsIGNyZWF0ZSB0aGUgdmRvbS5IZWxwZXIgd2l0aGluIHRoZSBBcHAgd29ya2VyIChleHBlcmltZW50YWwhKVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlVmRvbVdvcmtlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VWZG9tV29ya2VyOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIGJ1aWxkU2NyaXB0cy9pbmplY3RQYWNrYWdlVmVyc2lvbi5tanMgd2lsbCB1cGRhdGUgdGhpcyB2YWx1ZVxuICAgICAqIEBkZWZhdWx0ICcxMC4wLjAtYWxwaGEuMidcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudmVyc2lvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHZlcnNpb246ICcxMC4wLjAtYWxwaGEuMidcbn07XG5cbk9iamVjdC5hc3NpZ24oRGVmYXVsdENvbmZpZywge1xuICAgIC8qKlxuICAgICAqIFBhdGggdG8gdGhlIHRvcCBsZXZlbCBuZW8ubWpzIHJlc291cmNlcyBmb2xkZXJcbiAgICAgKiBAZGVmYXVsdCBOZW8uY29uZmlnLmJhc2VQYXRoICsgJ3Jlc291cmNlcy8nXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnJlc291cmNlc1BhdGhcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICByZXNvdXJjZXNQYXRoOiBgJHtOZW8uY29uZmlnLmJhc2VQYXRoIHx8IERlZmF1bHRDb25maWcuYmFzZVBhdGh9cmVzb3VyY2VzL2AsXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgYmFzZSBVUkwgZm9yIHdlYiB3b3JrZXIgZW50cnkgcG9pbnRzIChBcHAsIERhdGEsIFZkb20pXG4gICAgICogQGRlZmF1bHQgTmVvLmNvbmZpZy5iYXNlUGF0aCArICdzcmMvd29ya2VyLydcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcud29ya2VyQmFzZVBhdGhcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB3b3JrZXJCYXNlUGF0aDogYCR7TmVvLmNvbmZpZy5iYXNlUGF0aCB8fCBEZWZhdWx0Q29uZmlnLmJhc2VQYXRofXNyYy93b3JrZXIvYCxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0Q29uZmlnO1xuIiwiaW1wb3J0IERlZmF1bHRDb25maWcgZnJvbSAnLi9EZWZhdWx0Q29uZmlnLm1qcyc7XG5cbmNvbnN0XG4gICAgY2FtZWxSZWdleCAgID0gLy0uL2csXG4gICAgY29uZmlnU3ltYm9sID0gU3ltYm9sLmZvcignY29uZmlnU3ltYm9sJyksXG4gICAgZ2V0U2V0Q2FjaGUgID0gU3ltYm9sKCdnZXRTZXRDYWNoZScpLFxuICAgIHR5cGVEZXRlY3RvciA9IHtcbiAgICAgICAgZnVuY3Rpb246IGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucHJvdG90eXBlPy5jb25zdHJ1Y3Rvci5pc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZW9DbGFzcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2JqZWN0OiBpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNvbnN0cnVjdG9yLmlzQ2xhc3MgJiYgaXRlbSBpbnN0YW5jZW9mIE5lby5jb3JlLkJhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05lb0luc3RhbmNlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuLyoqXG4gKiBUaGUgYmFzZSBtb2R1bGUgdG8gZW5oYW5jZSBjbGFzc2VzLCBjcmVhdGUgaW5zdGFuY2VzIGFuZCB0aGUgTmVvIG5hbWVzcGFjZVxuICogQG1vZHVsZSBOZW9cbiAqIEBzaW5nbGV0b25cbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuYmluZE1ldGhvZHMgICAgICAgYXMgYmluZE1ldGhvZHNcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuY2FwaXRhbGl6ZSAgICAgICAgYXMgY2FwaXRhbGl6ZVxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5jcmVhdGVTdHlsZU9iamVjdCBhcyBjcmVhdGVTdHlsZU9iamVjdFxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5jcmVhdGVTdHlsZXMgICAgICBhcyBjcmVhdGVTdHlsZXNcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuZGVjYW1lbCAgICAgICAgICAgYXMgZGVjYW1lbFxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5pc0FycmF5ICAgICAgICAgICBhcyBpc0FycmF5XG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmlzQm9vbGVhbiAgICAgICAgIGFzIGlzQm9vbGVhblxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5pc0RlZmluZWQgICAgICAgICBhcyBpc0RlZmluZWRcbiAqIEBib3Jyb3dzIE5lby5jb3JlLkNvbXBhcmUuaXNFcXVhbCAgICAgICAgYXMgaXNFcXVhbFxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5pc051bWJlciAgICAgICAgICBhcyBpc051bWJlclxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5pc09iamVjdCAgICAgICAgICBhcyBpc09iamVjdFxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5pc1N0cmluZyAgICAgICAgICBhcyBpc1N0cmluZ1xuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC50b0FycmF5ICAgICAgICAgICBhcyB0b0FycmF5XG4gKiBAdHV0b3JpYWwgMDFfQ29uY2VwdFxuICovXG5sZXQgTmVvID0gZ2xvYmFsVGhpcy5OZW8gfHwge307XG5cbk5lbyA9IGdsb2JhbFRoaXMuTmVvID0gT2JqZWN0LmFzc2lnbih7XG4gICAgLyoqXG4gICAgICogQSBtYXAgY29udGFpbmluZyBudHlwZXMgYXMga2V5IGFuZCBOZW8gY2xhc3NlcyBvciBzaW5nbGV0b25zIGFzIHZhbHVlc1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBudHlwZU1hcDoge30sXG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciBOZW8uY3JlYXRlLiBGYWxzZSBmb3IgdGhlIG1haW4gdGhyZWFkLCB0cnVlIGZvciB0aGUgQXBwLCBEYXRhICYgVmRvbSB3b3JrZXJcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIGluc2lkZVdvcmtlcjogdHlwZW9mIERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnLFxuXG4gICAgLyoqXG4gICAgICogTWFwcyBtZXRob2RzIGZyb20gb25lIG5hbWVzcGFjZSB0byBhbm90aGVyIG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gYWxpYXNlc1xuICAgICAqIE5lby5hcHBseUZyb21OcyhOZW8sIFV0aWwsIHtcbiAgICAgKiAgICAgY3JlYXRlU3R5bGVPYmplY3Q6ICdjcmVhdGVTdHlsZU9iamVjdCcsXG4gICAgICogICAgIGNyZWF0ZVN0eWxlcyAgICAgOiAnY3JlYXRlU3R5bGVzJyxcbiAgICAgKiAgICAgY2FwaXRhbGl6ZSAgICAgICA6ICdjYXBpdGFsaXplJ1xuICAgICAqIH0sIHRydWUpO1xuICAgICAqXG4gICAgICogLy8gZS5nLiBOZW8uY29yZS5VdGlsLmlzT2JqZWN0ID0+IE5lby5pc09iamVjdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtOZW98TmVvLmNvcmUuQmFzZX0gdGFyZ2V0ICAgIFRoZSB0YXJnZXQgY2xhc3Mgb3Igc2luZ2xldG9uIEluc3RhbmNlIG9yIE5lb1xuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gICAgIG5hbWVzcGFjZSBUaGUgY2xhc3MgY29udGFpbmluZyB0aGUgbWV0aG9kc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICAgIFtiaW5kXSAgICBzZXQgdGhpcyB0byB0cnVlIGluIGNhc2UgeW91IHdhbnQgdG8gYmluZCBtZXRob2RzIHRvIHRoZSBcImZyb21cIiBuYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBhcHBseUZyb21Ocyh0YXJnZXQsIG5hbWVzcGFjZSwgY29uZmlnLCBiaW5kKSB7XG4gICAgICAgIGxldCBmbk5hbWU7XG5cbiAgICAgICAgaWYgKHRhcmdldCAmJiBOZW8udHlwZU9mKGNvbmZpZykgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb25maWcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGZuTmFtZSA9IG5hbWVzcGFjZVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBiaW5kID8gZm5OYW1lLmJpbmQobmFtZXNwYWNlKSA6IGZuTmFtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhIGNsYXNzIHRvIHRoZSBnbG9iYWwgTmVvIG9yIEFwcCBuYW1lc3BhY2UuXG4gICAgICogQ2FuIGdldCBjYWxsZWQgZm9yIGNsYXNzZXMgYW5kIHNpbmdsZXRvbiBpbnN0YW5jZXNcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gY2xzXG4gICAgICovXG4gICAgYXBwbHlUb0dsb2JhbE5zKGNscykge1xuICAgICAgICBsZXQgcHJvdG8gICAgID0gdHlwZW9mIGNscyA9PT0gJ2Z1bmN0aW9uJyA/IGNscy5wcm90b3R5cGUgOiBjbHMsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcm90by5pc0NsYXNzID8gcHJvdG8uY29uZmlnLmNsYXNzTmFtZSA6IHByb3RvLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIG5zQXJyYXkgICA9IGNsYXNzTmFtZS5zcGxpdCgnLicpLFxuICAgICAgICAgICAga2V5ICAgICAgID0gbnNBcnJheS5wb3AoKSxcbiAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhuc0FycmF5LCB0cnVlKTtcblxuICAgICAgICBuc1trZXldID0gY2xzXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvcGllcyBhbGwga2V5cyBvZiBkZWZhdWx0cyBpbnRvIHRhcmdldCwgaW4gY2FzZSB0aGV5IGRvbid0IGFscmVhZHkgZXhpc3RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgICBUaGUgdGFyZ2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0cyBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleXMgeW91IHdhbnQgdG8gY29weVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIGFzc2lnbkRlZmF1bHRzKHRhcmdldCwgZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiBOZW8udHlwZU9mKGRlZmF1bHRzKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRlZmF1bHRzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGEgbmV3IHZhbHVlIHRvIGEgZ2l2ZW4gbmVzdGVkIG9iamVjdHMgcGF0aC5cbiAgICAgKiBJdCB3aWxsIGNyZWF0ZSB0aGUgcGF0aCBzdHJ1Y3R1cmUgb3IgcGFydHMgb2YgaXQsIGluIGNhc2UgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8uYXNzaWduVG9OcygnYW5ub3RhdGlvbnMuc2VsZWN0ZWQnLCBmYWxzZSwgcmVjb3JkKVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gcGF0aCAgICAgICAgICAgICBUaGUgcGF0aCBzdHJpbmcgY29udGFpbmluZyBkb3RzIG9yIGFuIEFycmF5IG9mIHRoZSBzdHJpbmcgcGFydHNcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICBUaGUgbmV3IHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgbGVhZiBub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIHNjb3BlPWdsb2JhbFRoaXMgU2V0IGEgZGlmZmVyZW50IHN0YXJ0aW5nIHBvaW50IGFzIGdsb2JhbFRoaXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgZm9yY2U9dHJ1ZSAgICAgICBmYWxzZSB3aWxsIG9ubHkgYXNzaWduIGRlZmF1bHQgdmFsdWVzIChhc3NpZ24gaWYgb2xkIHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICovXG4gICAgYXNzaWduVG9OcyhwYXRoLCB2YWx1ZSwgc2NvcGU9Z2xvYmFsVGhpcywgZm9yY2U9dHJ1ZSkge1xuICAgICAgICBwYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgbGV0IGtleTtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBrZXkgICA9IHBhdGgucG9wKCk7XG4gICAgICAgICAgICBzY29wZSA9IE5lby5ucyhwYXRoLCB0cnVlLCBzY29wZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IHBhdGhcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JjZSB8fCBzY29wZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNjb3BlW2tleV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGtlYmFiLWNhc2Ugc3RyaW5ncyBpbnRvIGNhbWVsLWNhc2VcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgdGFyZ2V0IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgY2FtZWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoY2FtZWxSZWdleCwgbWF0Y2ggPT4gbWF0Y2hbMV0udG9VcHBlckNhc2UoKSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB1cHBlcmNhc2VcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ30gUmV0dXJucyBmYWxzZSBmb3Igbm9uIHN0cmluZyBpbnB1dHNcbiAgICAgKi9cbiAgICBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVswXS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoMSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheXwqfSBvYmpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXA9ZmFsc2UgICAgICAgICAgICAgICBTZXQgdGhpcyB0byB0cnVlIGluIGNhc2UgeW91IHdhbnQgdG8gY2xvbmUgbmVzdGVkIG9iamVjdHMgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlTmVvSW5zdGFuY2VzPWZhbHNlIHJldHVybnMgZXhpc3RpbmcgaW5zdGFuY2VzIGlmIHNldCB0byB0cnVlXG4gICAgICogQHJldHVybnMge09iamVjdHxBcnJheXwqfSB0aGUgY2xvbmVkIGlucHV0XG4gICAgICovXG4gICAgY2xvbmUob2JqLCBkZWVwPWZhbHNlLCBpZ25vcmVOZW9JbnN0YW5jZXM9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG91dDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQXJyYXkgICAgICA6ICgpID0+ICFkZWVwID8gWy4uLm9ial0gOiBbLi4ub2JqLm1hcCh2YWwgPT4gTmVvLmNsb25lKHZhbCwgZGVlcCwgaWdub3JlTmVvSW5zdGFuY2VzKSldLFxuICAgICAgICAgICAgRGF0ZSAgICAgICA6ICgpID0+IG5ldyBEYXRlKG9iai52YWx1ZU9mKCkpLFxuICAgICAgICAgICAgTWFwICAgICAgICA6ICgpID0+IG5ldyBNYXAob2JqKSwgLy8gc2hhbGxvdyBjb3B5XG4gICAgICAgICAgICBOZW9JbnN0YW5jZTogKCkgPT4gaWdub3JlTmVvSW5zdGFuY2VzID8gb2JqIDogdGhpcy5jbG9uZU5lb0luc3RhbmNlKG9iaiksXG4gICAgICAgICAgICBTZXQgICAgICAgIDogKCkgPT4gbmV3IFNldChvYmopLFxuXG4gICAgICAgICAgICBPYmplY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBvdXQgPSB7fTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtrZXldID0gIWRlZXAgPyB2YWx1ZSA6IE5lby5jbG9uZSh2YWx1ZSwgZGVlcCwgaWdub3JlTmVvSW5zdGFuY2VzKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dFxuICAgICAgICAgICAgfVxuICAgICAgICB9W05lby50eXBlT2Yob2JqKV0/LigpIHx8IG9ialxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBvcmlnaW5hbENvbmZpZyB3aXRob3V0IHRoZSBpZFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfSB0aGUgY2xvbmVkIGluc3RhbmNlXG4gICAgICovXG4gICAgY2xvbmVOZW9JbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICBsZXQgY29uZmlnID0gey4uLmluc3RhbmNlLm9yaWdpbmFsQ29uZmlnfTtcblxuICAgICAgICBkZWxldGUgY29uZmlnLl9pZDtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5pZDtcblxuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZShpbnN0YW5jZS5jbGFzc05hbWUsIGNvbmZpZylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlIE5lby5jcmVhdGUoKSBpbnN0ZWFkIG9mIFwibmV3XCIgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiBhbGwgTmVvIGNsYXNzZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCBCdXR0b24gZnJvbSAnLi4vYnV0dG9uL0Jhc2UubWpzJztcbiAgICAgKlxuICAgICAqIE5lby5jcmVhdGUoQnV0dG9uLCB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG4gICAgICpcbiAgICAgKiBOZW8uY3JlYXRlKHtcbiAgICAgKiAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLmNyZWF0ZSgnTmVvLmJ1dHRvbi5CYXNlJyB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8uY3JlYXRlKHtcbiAgICAgKiAgICAgY2xhc3NOYW1lOiAnTmVvLmJ1dHRvbi5CYXNlJyxcbiAgICAgKiAgICAgaWNvbkNscyAgOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8TmVvLmNvcmUuQmFzZX0gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIFtjb25maWddXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V8bnVsbH0gVGhlIG5ldyBjbGFzcyBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICAgICAqL1xuICAgIGNyZWF0ZShjbGFzc05hbWUsIGNvbmZpZykge1xuICAgICAgICBsZXQgdHlwZSA9IE5lby50eXBlT2YoY2xhc3NOYW1lKSxcbiAgICAgICAgICAgIGNscywgaW5zdGFuY2U7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgIGNscyA9IGNsYXNzTmFtZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcuY2xhc3NOYW1lICYmICFjb25maWcubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIGNvbnNvbGUuZXJyb3IgaW5zdGVhZCBvZiB0aHJvdyB0byBzaG93IHRoZSBjb25maWcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NsYXNzIGNyZWF0ZWQgd2l0aCBvYmplY3QgY29uZmlndXJhdGlvbiBtaXNzaW5nIGNsYXNzTmFtZSBvciBtb2R1bGUgcHJvcGVydHknLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNvbmZpZy5jbGFzc05hbWUgfHwgY29uZmlnLm1vZHVsZS5wcm90b3R5cGUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4aXN0cyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyAnICsgY2xhc3NOYW1lICsgJyBkb2VzIG5vdCBleGlzdCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNscyA9IE5lby5ucyhjbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjbHMoKTtcblxuICAgICAgICBpbnN0YW5jZS5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgaW5zdGFuY2Uub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICBpbnN0YW5jZS5vbkFmdGVyQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgaW5zdGFuY2UuaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGVtcHR5Rm4oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGVyZSBpcyBhIHNldCBtZXRob2QgZm9yIGEgZ2l2ZW4gcHJvcGVydHkga2V5IGluc2lkZSB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHByb3RvIFRoZSB0b3AgbGV2ZWwgcHJvdG90eXBlIG9mIGEgY2xhc3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgIGtleSAgIFRoZSBwcm9wZXJ0eSBrZXkgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc1Byb3BlcnR5U2V0dGVyKHByb3RvLCBrZXkpIHtcbiAgICAgICAgbGV0IGRlc2NyaXB0b3I7XG5cbiAgICAgICAgd2hpbGUgKHByb3RvLl9fcHJvdG9fXykge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG8gPSBwcm90by5fX3Byb3RvX19cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWVwLW1lcmdlcyBhIHNvdXJjZSBvYmplY3QgaW50byBhIHRhcmdldCBvYmplY3RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cykge1xuICAgICAgICAgICAgcmV0dXJuIE5lby5tZXJnZShOZW8ubWVyZ2UodGFyZ2V0LCBkZWZhdWx0cyksIHNvdXJjZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gTmVvLm1lcmdlKHRhcmdldFtrZXldIHx8IHt9LCB2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgY2xhc3NOYW1lIHN0cmluZyBpbnRvIGEgZ2l2ZW4gb3IgZ2xvYmFsIG5hbWVzcGFjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLm5zKCdOZW8uYnV0dG9uLkJhc2UnLCB0cnVlKTtcbiAgICAgKiAvLyA9PlxuICAgICAqIC8vIGdsb2JhbFRoaXMuTmVvICAgICAgICAgICAgID0gZ2xvYmFsVGhpcy5OZW8gICAgICAgICAgICAgfHwge307XG4gICAgICogLy8gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uICAgICAgPSBnbG9iYWxUaGlzLk5lby5idXR0b24gICAgICB8fCB7fTtcbiAgICAgKiAvLyBnbG9iYWxUaGlzLk5lby5idXR0b24uQmFzZSA9IGdsb2JhbFRoaXMuTmVvLmJ1dHRvbi5CYXNlIHx8IHt9O1xuICAgICAqIC8vIHJldHVybiBnbG9iYWxUaGlzLk5lby5idXR0b24uQmFzZTtcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IG5hbWVzICAgICAgICBUaGUgY2xhc3MgbmFtZSBzdHJpbmcgY29udGFpbmluZyBkb3RzIG9yIGFuIEFycmF5IG9mIHRoZSBzdHJpbmcgcGFydHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgY3JlYXRlPWZhbHNlIFNldCBjcmVhdGUgdG8gdHJ1ZSB0byBjcmVhdGUgZW1wdHkgb2JqZWN0cyBmb3Igbm9uLWV4aXN0aW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIFtzY29wZV0gICAgICBTZXQgYSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9pbnQgYXMgZ2xvYmFsVGhpc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlZmVyZW5jZSB0byB0aGUgdG9wbGV2ZWwgbmFtZXNwYWNlXG4gICAgICovXG4gICAgbnMobmFtZXMsIGNyZWF0ZT1mYWxzZSwgc2NvcGUpIHtcbiAgICAgICAgbmFtZXMgPSBBcnJheS5pc0FycmF5KG5hbWVzKSA/IG5hbWVzIDogbmFtZXMuc3BsaXQoJy4nKTtcblxuICAgICAgICByZXR1cm4gbmFtZXMucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoY3JlYXRlICYmICFwcmV2W2N1cnJlbnRdKSB7XG4gICAgICAgICAgICAgICAgcHJldltjdXJyZW50XSA9IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZbY3VycmVudF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2NvcGUgfHwgZ2xvYmFsVGhpcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kZWQgdmVyc2lvbiBvZiBOZW8ubnMoKSB3aGljaCBzdXBwb3J0cyBtYXBwaW5nIGludG8gYXJyYXlzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IG5hbWVzICAgICAgICBUaGUgY2xhc3MgbmFtZSBzdHJpbmcgY29udGFpbmluZyBkb3RzIG9yIGFuIEFycmF5IG9mIHRoZSBzdHJpbmcgcGFydHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgY3JlYXRlPWZhbHNlIFNldCBjcmVhdGUgdG8gdHJ1ZSB0byBjcmVhdGUgZW1wdHkgb2JqZWN0cyBmb3Igbm9uLWV4aXN0aW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgIFtzY29wZV0gICAgICBTZXQgYSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9pbnQgYXMgZ2xvYmFsVGhpc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlZmVyZW5jZSB0byB0aGUgdG9wbGV2ZWwgbmFtZXNwYWNlXG4gICAgICovXG4gICAgbnNXaXRoQXJyYXlzKG5hbWVzLCBjcmVhdGU9ZmFsc2UsIHNjb3BlKSB7XG4gICAgICAgIG5hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZSAmJiAhcHJldltjdXJyZW50XSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5TnModHJ1ZSwgY3VycmVudCwgcHJldilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmV2W2N1cnJlbnRdID0ge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcnJheU5zKGZhbHNlLCBjdXJyZW50LCBwcmV2KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2W2N1cnJlbnRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNjb3BlIHx8IGdsb2JhbFRoaXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2VzIG9mIE5lbyBjbGFzc2VzIHVzaW5nIHRoZWlyIG50eXBlIGluc3RlYWQgb2YgdGhlIGNsYXNzIG5hbWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5udHlwZSgnYnV0dG9uJyB7XG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8ubnR5cGUoe1xuICAgICAqICAgICBudHlwZSAgOiAnYnV0dG9uJyxcbiAgICAgKiAgICAgaWNvbkNsczogJ2ZhIGZhLWhvbWUnLFxuICAgICAqICAgICB0ZXh0ICAgOiAnSG9tZSdcbiAgICAgKiB9KTtcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbnR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtjb25maWddXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V9XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOk5lby5jcmVhdGUgY3JlYXRlfVxuICAgICAqL1xuICAgIG50eXBlKG50eXBlLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IG50eXBlO1xuXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5udHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3MgZGVmaW5lZCB3aXRoIG9iamVjdCBjb25maWd1cmF0aW9uIG1pc3NpbmcgbnR5cGUgcHJvcGVydHkuICcgKyBjb25maWcubnR5cGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG50eXBlID0gY29uZmlnLm50eXBlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2xhc3NOYW1lID0gTmVvLm50eXBlTWFwW250eXBlXTtcblxuICAgICAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudHlwZSAnICsgbnR5cGUgKyAnIGRvZXMgbm90IGV4aXN0JylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZW8uY3JlYXRlKGNsYXNzTmFtZSwgY29uZmlnKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHVzZWQgYXQgdGhlIGVuZCBvZiBlYWNoIGNsYXNzIC8gbW9kdWxlIGRlZmluaXRpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHtUfSBjbHNcbiAgICAgKiBAcmV0dXJucyB7VH1cbiAgICAgKi9cbiAgICBzZXR1cENsYXNzKGNscykge1xuICAgICAgICBsZXQgYmFzZUNmZyAgICA9IG51bGwsXG4gICAgICAgICAgICBudHlwZUNoYWluID0gW10sXG4gICAgICAgICAgICB7bnR5cGVNYXB9ID0gTmVvLFxuICAgICAgICAgICAgcHJvdG8gICAgICA9IGNscy5wcm90b3R5cGUgfHwgY2xzLFxuICAgICAgICAgICAgbnMgICAgICAgICA9IE5lby5ucyhwcm90by5jb25zdHJ1Y3Rvci5jb25maWcuY2xhc3NOYW1lLCBmYWxzZSksXG4gICAgICAgICAgICBwcm90b3MgICAgID0gW10sXG4gICAgICAgICAgICBjZmcsIGNvbmZpZywgY3RvciwgbnR5cGU7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIG5hbWVzcGFjZSBhbHJlYWR5IGV4aXN0cywgZGlyZWN0bHkgcmV0dXJuIGl0LlxuICAgICAgICAgKiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB1c2luZyBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgbmVvLm1qc1xuICAgICAgICAgKiA9PiBFc3BlY2lhbGx5IHNpbmdsZXRvbnMgKElkR2VuZXJhdG9yKSBtdXN0IHN0YXkgdW5pcXVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGNhbiBhbHNvIGhhcHBlbiB3aGVuIHVzaW5nIGRpZmZlcmVudCBlbnZpcm9ubWVudHMgb2YgbmVvLm1qcyBpbiBwYXJhbGxlbC5cbiAgICAgICAgICogRXhhbXBsZTogY29kZS5MaXZlUHJldmlldyBydW5uaW5nIGluc2lkZSBhIGRpc3QvcHJvZHVjdGlvbiBhcHAuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuc1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHByb3RvLl9fcHJvdG9fXykge1xuICAgICAgICAgICAgY3RvciA9IHByb3RvLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihjdG9yLCAnY2xhc3NDb25maWdBcHBsaWVkJykpIHtcbiAgICAgICAgICAgICAgICBiYXNlQ2ZnICAgID0gTmVvLmNsb25lKGN0b3IuY29uZmlnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBudHlwZUNoYWluID0gWy4uLmN0b3IubnR5cGVDaGFpbl07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG9zLnVuc2hpZnQocHJvdG8pO1xuICAgICAgICAgICAgcHJvdG8gPSBwcm90by5fX3Byb3RvX19cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZyA9IGJhc2VDZmcgfHwge307XG5cbiAgICAgICAgcHJvdG9zLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBsZXQgbWl4aW5zO1xuXG4gICAgICAgICAgICBjdG9yID0gZWxlbWVudC5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAgICAgY2ZnID0gY3Rvci5jb25maWcgfHwge307XG5cbiAgICAgICAgICAgIGlmIChOZW8ub3ZlcndyaXRlcykge1xuICAgICAgICAgICAgICAgIGN0b3IuYXBwbHlPdmVyd3JpdGVzPy4oY2ZnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjZmcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc2xpY2UoLTEpID09PSAnXycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNmZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBjZmdba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhdXRvR2VuZXJhdGVHZXRTZXQoZWxlbWVudCwga2V5KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFwcGx5IHByb3BlcnRpZXMgd2hpY2ggaGF2ZSBubyBzZXR0ZXJzIGluc2lkZSB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAgICAgICAgICAgICAgLy8gdGhvc2Ugd2lsbCBnZXQgYXBwbGllZCBvbiBjcmVhdGUgKE5lby5jb3JlLkJhc2UgLT4gaW5pdENvbmZpZylcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghTmVvLmhhc1Byb3BlcnR5U2V0dGVyKGVsZW1lbnQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGUgIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihjZmcsICdudHlwZScpKSB7XG4gICAgICAgICAgICAgICAgbnR5cGUgPSBjZmcubnR5cGU7XG5cbiAgICAgICAgICAgICAgICBudHlwZUNoYWluLnVuc2hpZnQobnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVubmluZyB0aGUgZG9jcyBhcHAgaW5zaWRlIGEgd29ya3NwYWNlIGNhbiBwdWxsIGluIHRoZSBzYW1lIGNsYXNzZXMgZnJvbSBkaWZmZXJlbnQgcm9vdHMsXG4gICAgICAgICAgICAgICAgLy8gc28gd2Ugd2FudCB0byBjaGVjayBmb3IgZGlmZmVyZW50IGNsYXNzIG5hbWVzIGFzIHdlbGxcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihudHlwZU1hcCwgbnR5cGUpICYmIGNmZy5jbGFzc05hbWUgIT09IG50eXBlTWFwW250eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG50eXBlIGNvbmZsaWN0IGZvciAnJHtudHlwZX0nIGluc2lkZSB0aGUgY2xhc3NlczpcXG4ke250eXBlTWFwW250eXBlXX1cXG4ke2NmZy5jbGFzc05hbWV9YClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBudHlwZU1hcFtudHlwZV0gPSBjZmcuY2xhc3NOYW1lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1peGlucyA9IE9iamVjdC5oYXNPd24oY29uZmlnLCAnbWl4aW5zJykgJiYgY29uZmlnLm1peGlucyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKGN0b3Iub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgIG1peGlucy5wdXNoKCdOZW8uY29yZS5PYnNlcnZhYmxlJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oY2ZnLCAnbWl4aW5zJykgJiYgQXJyYXkuaXNBcnJheShjZmcubWl4aW5zKSAmJiBjZmcubWl4aW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtaXhpbnMucHVzaCguLi5jZmcubWl4aW5zKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWl4aW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhcHBseU1peGlucyhjdG9yLCBtaXhpbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKE5lby5ucygnTmVvLmNvcmUuT2JzZXJ2YWJsZScsIGZhbHNlLCBjdG9yLnByb3RvdHlwZS5taXhpbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0b3Iub2JzZXJ2YWJsZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjZmcubWl4aW5zO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5taXhpbnM7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBjZmcpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGN0b3IsIHtcbiAgICAgICAgICAgICAgICBjbGFzc0NvbmZpZ0FwcGxpZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlnICAgICAgICAgICAgOiBOZW8uY2xvbmUoY29uZmlnLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBpc0NsYXNzICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgbnR5cGVDaGFpblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICFjb25maWcuc2luZ2xldG9uICYmIHRoaXMuYXBwbHlUb0dsb2JhbE5zKGNscylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvdG8gPSBjbHMucHJvdG90eXBlIHx8IGNscztcblxuICAgICAgICBudHlwZUNoYWluLmZvckVhY2gobnR5cGUgPT4ge1xuICAgICAgICAgICAgcHJvdG9bYGlzJHtOZW8uY2FwaXRhbGl6ZShOZW8uY2FtZWwobnR5cGUpKX1gXSA9IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByb3RvLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgY2xzID0gTmVvLmNyZWF0ZShjbHMpO1xuICAgICAgICAgICAgTmVvLmFwcGx5VG9HbG9iYWxOcyhjbHMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xzXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0eXBlT2YoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZURldGVjdG9yW3R5cGVvZiBpdGVtXT8uKGl0ZW0pIHx8IGl0ZW0uY29uc3RydWN0b3IubmFtZVxuICAgIH1cbn0sIE5lbyk7XG5cbi8qKlxuICogTGlzdCBvZiBjbGFzcyBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBub3Qgc3VwcG9zZWQgdG8gZ2V0IG1peGVkIGludG8gb3RoZXIgY2xhc3Nlc1xuICogQHR5cGUge3N0cmluZ1tdfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaWdub3JlTWl4aW4gPSBbXG4gICAgJ19uYW1lJyxcbiAgICAnY2xhc3NDb25maWdBcHBsaWVkJyxcbiAgICAnY2xhc3NOYW1lJyxcbiAgICAnY29uc3RydWN0b3InLFxuICAgICdpc0NsYXNzJyxcbiAgICAnbWl4aW4nLFxuICAgICdudHlwZScsXG4gICAgJ29ic2VydmFibGUnXG5dLFxuXG4gICAgY2hhcnNSZWdleCAgICAgICAgID0gL1xcZCsvZyxcbiAgICBleHRyYWN0QXJyYXlzUmVnZXggPSAvXihcXHcrKVxccyooKD86XFxbXFxzKlxcZCtcXHMqXFxdXFxzKikqKSQvO1xuXG4vKipcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gY2xzXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgIG1peGluc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlNaXhpbnMoY2xzLCBtaXhpbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWl4aW5zKSkge1xuICAgICAgICBtaXhpbnMgPSBbbWl4aW5zXTtcbiAgICB9XG5cbiAgICBsZXQgaSAgICAgICAgICAgID0gMCxcbiAgICAgICAgbGVuICAgICAgICAgID0gbWl4aW5zLmxlbmd0aCxcbiAgICAgICAgbWl4aW5DbGFzc2VzID0ge30sXG4gICAgICAgIG1peGluLCBtaXhpbkNscywgbWl4aW5Qcm90bztcblxuICAgIGZvciAoO2kgPCBsZW47aSsrKSB7XG4gICAgICAgIG1peGluID0gbWl4aW5zW2ldO1xuXG4gICAgICAgIGlmIChtaXhpbi5pc0NsYXNzKSB7XG4gICAgICAgICAgICBtaXhpblByb3RvID0gbWl4aW4ucHJvdG90eXBlO1xuICAgICAgICAgICAgbWl4aW5DbHMgICA9IE5lby5ucyhtaXhpblByb3RvLmNsYXNzTmFtZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZXhpc3RzKG1peGluKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBtaXhpbiBhbiB1bmRlZmluZWQgY2xhc3M6ICcgKyBtaXhpbiArICcsICcgKyBjbHMucHJvdG90eXBlLmNsYXNzTmFtZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4aW5DbHMgICA9IE5lby5ucyhtaXhpbik7XG4gICAgICAgICAgICBtaXhpblByb3RvID0gbWl4aW5DbHMucHJvdG90eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWl4aW5Qcm90by5jbGFzc05hbWUuc3BsaXQoJy4nKS5yZWR1Y2UobWl4UmVkdWNlKG1peGluQ2xzKSwgbWl4aW5DbGFzc2VzKTtcblxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtaXhpblByb3RvKS5mb3JFYWNoKG1peGluUHJvcGVydHkoY2xzLnByb3RvdHlwZSwgbWl4aW5Qcm90bykpXG4gICAgfVxuXG4gICAgY2xzLnByb3RvdHlwZS5taXhpbnMgPSBtaXhpbkNsYXNzZXMgLy8gdG9kbzogd2Ugc2hvdWxkIGRvIGEgZGVlcCBtZXJnZVxufVxuXG4vKipcbiAqIENyZWF0ZXMgZ2V0IC8gc2V0IG1ldGhvZHMgZm9yIGNsYXNzIGNvbmZpZ3MgZW5kaW5nIHdpdGggYW4gdW5kZXJzY29yZVxuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBwcm90b1xuICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBrZXlcbiAqIEBwcml2YXRlXG4gKiBAdHV0b3JpYWwgMDJfQ2xhc3NTeXN0ZW1cbiAqL1xuZnVuY3Rpb24gYXV0b0dlbmVyYXRlR2V0U2V0KHByb3RvLCBrZXkpIHtcbiAgICBpZiAoTmVvLmhhc1Byb3BlcnR5U2V0dGVyKHByb3RvLCBrZXkpKSB7XG4gICAgICAgIHRocm93KCdDb25maWcgJyArIGtleSArICdfICgnICsgcHJvdG8uY2xhc3NOYW1lICsgJykgYWxyZWFkeSBoYXMgYSBzZXQgbWV0aG9kLCB1c2UgYmVmb3JlR2V0LCBiZWZvcmVTZXQgJiBhZnRlclNldCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoIU5lb1tnZXRTZXRDYWNoZV0pIHtcbiAgICAgICAgTmVvW2dldFNldENhY2hlXSA9IHt9XG4gICAgfVxuXG4gICAgaWYgKCFOZW9bZ2V0U2V0Q2FjaGVdW2tleV0pIHtcbiAgICAgICAgTmVvW2dldFNldENhY2hlXVtrZXldID0ge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVHZXQgPSBgYmVmb3JlR2V0JHtrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKX1gLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXdLZXkgPSBPYmplY3QuaGFzT3duKG1lW2NvbmZpZ1N5bWJvbF0sIGtleSksXG4gICAgICAgICAgICAgICAgICAgIG5ld0tleSAgICA9IG1lW2NvbmZpZ1N5bWJvbF1ba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgID0gaGFzTmV3S2V5ID8gbmV3S2V5IDogbWVbJ18nICsga2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnaXRlbXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFsuLi52YWx1ZV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVba2V5XSA9IHZhbHVlOyAvLyB3ZSBkbyB3YW50IHRvIHRyaWdnZXIgdGhlIHNldHRlciA9PiBiZWZvcmVTZXQsIGFmdGVyU2V0XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWVbJ18nICsga2V5XTsgLy8gcmV0dXJuIHRoZSB2YWx1ZSBwYXJzZWQgYnkgdGhlIHNldHRlclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWVbY29uZmlnU3ltYm9sXVtrZXldXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZVtiZWZvcmVHZXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWVbYmVmb3JlR2V0XSh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBfa2V5ICAgICAgPSAnXycgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIHVLZXkgICAgICA9IGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVTZXQgPSAnYmVmb3JlU2V0JyArIHVLZXksXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyU2V0ICA9ICdhZnRlclNldCcgICsgdUtleSxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgID0gbWVbX2tleV07XG5cbiAgICAgICAgICAgICAgICAvLyBldmVyeSBzZXQgY2FsbCBoYXMgdG8gZGVsZXRlIHRoZSBtYXRjaGluZyBzeW1ib2xcbiAgICAgICAgICAgICAgICBkZWxldGUgbWVbY29uZmlnU3ltYm9sXVtrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2l0ZW1zJyAmJiBrZXkgIT09ICd2bm9kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBOZW8uY2xvbmUodmFsdWUsIHRydWUsIHRydWUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2UgZG8gd2FudCB0byBzdG9yZSB0aGUgdmFsdWUgYmVmb3JlIHRoZSBiZWZvcmVTZXQgbW9kaWZpY2F0aW9uIGFzIHdlbGwsXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgY291bGQgZ2V0IHB1bGxlZCBieSBvdGhlciBiZWZvcmVTZXQgbWV0aG9kcyBvZiBkaWZmZXJlbnQgY29uZmlnc1xuICAgICAgICAgICAgICAgIG1lW19rZXldID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lW2JlZm9yZVNldF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtZVtiZWZvcmVTZXRdKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhleSBkb24ndCByZXR1cm4gYSB2YWx1ZSwgdGhhdCBtZWFucyBubyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lW19rZXldID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1lW19rZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoa2V5ID09PSAndm5vZGUnICYmIHZhbHVlICE9PSBvbGRWYWx1ZSkgfHwgLy8gdm5vZGUgdHJlZXMgY2FuIGJlIGh1Z2UsIGF2b2lkIGEgZGVlcCBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgICFOZW8uaXNFcXVhbCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lW2FmdGVyU2V0XT8uKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFmdGVyU2V0Q29uZmlnPy4oa2V5LCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBrZXksIE5lb1tnZXRTZXRDYWNoZV1ba2V5XSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9ICBjdXJyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gIHByZXZcbiAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheU5zKGNyZWF0ZSwgY3VycmVudCwgcHJldikge1xuICAgIGxldCBhcnJEZXRhaWxzID0gcGFyc2VBcnJheUZyb21TdHJpbmcoY3VycmVudCksXG4gICAgICAgIGkgICAgICAgICAgPSAxLFxuICAgICAgICBsZW4gICAgICAgID0gYXJyRGV0YWlscy5sZW5ndGgsXG4gICAgICAgIGFyckl0ZW0sIGFyclJvb3Q7XG5cbiAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgIHByZXZbYXJyRGV0YWlsc1swXV0gPSBhcnJSb290ID0gcHJldlthcnJEZXRhaWxzWzBdXSB8fCBbXVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGFyclJvb3QgPSBwcmV2W2FyckRldGFpbHNbMF1dXG4gICAgfVxuXG4gICAgaWYgKCFhcnJSb290KSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJySXRlbSA9IHBhcnNlSW50KGFyckRldGFpbHNbaV0pO1xuXG4gICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgIGFyclJvb3RbYXJySXRlbV0gPSBhcnJSb290W2Fyckl0ZW1dIHx8IHt9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJSb290ID0gYXJyUm9vdFthcnJJdGVtXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJSb290XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjbGFzcyBuYW1lIGV4aXN0cyBpbnNpZGUgdGhlIE5lbyBvciBhcHAgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4aXN0cyhjbGFzc05hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFjbGFzc05hbWUuc3BsaXQoJy4nKS5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2W2N1cnJlbnRdXG4gICAgICAgIH0sIGdsb2JhbFRoaXMpXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHByb3RvXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IG1peGluUHJvdG9cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1peGluUHJvcGVydHkocHJvdG8sIG1peGluUHJvdG8pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh+aWdub3JlTWl4aW4uaW5kZXhPZihrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm90b1trZXldPy5fZnJvbSkge1xuICAgICAgICAgICAgaWYgKG1peGluUHJvdG8uY2xhc3NOYW1lID09PSBwcm90b1trZXldLl9mcm9tKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXhpbiBzZXQgbXVsdGlwbGUgdGltZXMgb3IgYWxyZWFkeSBkZWZpbmVkIG9uIGEgQmFzZSBDbGFzcycsIHByb3RvLmNsYXNzTmFtZSwgbWl4aW5Qcm90by5jbGFzc05hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtwcm90by5jbGFzc05hbWV9OiBNdWx0aXBsZSBtaXhpbnMgZGVmaW5pbmcgc2FtZSBwcm9wZXJ0eSAoJHttaXhpblByb3RvLmNsYXNzTmFtZX0sICR7cHJvdG9ba2V5XS5fZnJvbX0pID0+ICR7a2V5fWBcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvW2tleV0gPSBtaXhpblByb3RvW2tleV07XG5cbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KS5fZnJvbSA9IG1peGluUHJvdG8uY2xhc3NOYW1lO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9ba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvdG9ba2V5XS5fbmFtZSA9IGtleVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBtaXhpbkNsc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWl4UmVkdWNlKG1peGluQ2xzKSB7XG4gICAgcmV0dXJuIChwcmV2LCBjdXJyZW50LCBpZHgsIGFycikgPT4ge1xuICAgICAgICByZXR1cm4gcHJldltjdXJyZW50XSA9IGlkeCAhPT0gYXJyLmxlbmd0aCAtMSA/IHByZXZbY3VycmVudF0gfHwge30gOiBtaXhpbkNsc1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5RnJvbVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gKGV4dHJhY3RBcnJheXNSZWdleC5leGVjKHN0cikgfHwgW251bGxdKS5zbGljZSgxKS5yZWR1Y2UoXG4gICAgICAgIChmdW4sIGFyZ3MpID0+IFtmdW5dLmNvbmNhdChhcmdzLm1hdGNoKGNoYXJzUmVnZXgpKVxuICAgIClcbn1cblxuTmVvLmNvbmZpZyA9IE5lby5jb25maWcgfHwge307XG5cbk5lby5hc3NpZ25EZWZhdWx0cyhOZW8uY29uZmlnLCBEZWZhdWx0Q29uZmlnKTtcblxuZXhwb3J0IGRlZmF1bHQgTmVvO1xuIiwiaW1wb3J0IHtidWZmZXIsIGRlYm91bmNlLCBpbnRlcmNlcHQsIHJlc29sdmVDYWxsYmFjaywgdGhyb3R0bGV9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcbmltcG9ydCBJZEdlbmVyYXRvciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuL0lkR2VuZXJhdG9yLm1qcydcblxuY29uc3QgY29uZmlnU3ltYm9sICAgICAgID0gU3ltYm9sLmZvcignY29uZmlnU3ltYm9sJyksXG4gICAgICBmb3JjZUFzc2lnbkNvbmZpZ3MgPSBTeW1ib2woJ2ZvcmNlQXNzaWduQ29uZmlncycpLFxuICAgICAgaXNJbnN0YW5jZSAgICAgICAgID0gU3ltYm9sKCdpc0luc3RhbmNlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIChhbG1vc3QpIGFsbCBjbGFzc2VzIGluc2lkZSB0aGUgTmVvIG5hbWVzcGFjZVxuICogRXhjZXB0aW9ucyBhcmUgZS5nLiBjb3JlLklkR2VuZXJhdG9yLCB2ZG9tLlZOb2RlXG4gKiBAY2xhc3MgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGRlZmluZSBtZXRob2RzIHdoaWNoIHNob3VsZCBnZXQgZGVsYXllZC5cbiAgICAgKiBUeXBlcyBhcmUgYnVmZmVyLCBkZWJvdW5jZSAmIHRocm90dGxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIGRlbGF5YWJsZToge1xuICAgICAqICAgICAgZmlyZUNoYW5nZUV2ZW50OiB7XG4gICAgICogICAgICAgICAgdHlwZSA6ICdkZWJvdW5jZScsXG4gICAgICogICAgICAgICAgdGltZXI6IDMwMFxuICAgICAqICAgICAgfVxuICAgICAqICB9XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGU9e31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7fVxuICAgIC8qKlxuICAgICAqIEZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgb25jZSBtYW5hZ2VyLkluc3RhbmNlIGdvdCBjcmVhdGVkXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaW5zdGFuY2VNYW5hZ2VyQXZhaWxhYmxlPWZhbHNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBpbnN0YW5jZU1hbmFnZXJBdmFpbGFibGUgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFJlZ2V4IHRvIGdyYWIgdGhlIE1ldGhvZE5hbWUgZnJvbSBhbiBlcnJvclxuICAgICAqIHdoaWNoIGlzIGEgc2Vjb25kIGdlbmVyYXRpb24gZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyIHtSZWdFeHB9IG1ldGhvZE5hbWVSZWdleFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgbWV0aG9kTmFtZVJlZ2V4ID0gL1xcbi4qXFxuXFxzK2F0XFxzKy4qXFwuKFxcdyspXFxzKy4qL1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPWZhbHNlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBLZWVwIHRoZSBvdmVyd3JpdHRlbiBtZXRob2RzXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBvdmVyd3JpdHRlbk1ldGhvZHM9e31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvdmVyd3JpdHRlbk1ldGhvZHMgPSB7fVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3Mgd2lsbCBnZXQgbWVyZ2VkIHRocm91Z2hvdXQgdGhlIGNsYXNzIGhpZXJhcmNoeVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSB3aGljaCB3aWxsIGdldCBtYXBwZWQgaW50byB0aGUgTmVvIG9yIGFwcCBuYW1lc3BhY2VcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb3JlLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb3JlLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsYXNzIHNob3J0Y3V0LW5hbWUgdG8gdXNlIGZvciBlLmcuIGNyZWF0aW5nIGNoaWxkIGNvbXBvbmVudHMgaW5zaWRlIGEgSlNPTi1mb3JtYXRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nYmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdiYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoaWxlIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoYW5nZSB0aGUgc3RhdGljIGRlbGF5YWJsZSBjb25maWdzIG9uIGNsYXNzIGxldmVsLFxuICAgICAgICAgKiB5b3UgY2FuIGNoYW5nZSBpdCBvbiBpbnN0YW5jZSBsZXZlbCB0b28uIElmIG5vdCBudWxsLCB3ZSB3aWxsIGRvIGEgZGVlcCBtZXJnZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXlhYmxlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuaXF1ZSBjb21wb25lbnQgaWRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGlkXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBpZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOZW8uY3JlYXRlKCkgd2lsbCBjaGFuZ2UgdGhpcyBmbGFnIHRvIHRydWUgYWZ0ZXIgdGhlIG9uQ29uc3RydWN0ZWQoKSBjaGFpbiBpcyBkb25lLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0NvbnN0cnVjdGVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzQ29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIG1peGlucyBhcyBhbiBhcnJheSBvZiBjbGFzc05hbWVzLCBpbXBvcnRlZCBtb2R1bGVzIG9yIGEgbWl4ZWQgdmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxOZW8uY29yZS5CYXNlW118bnVsbH0gbWl4aW5zPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1peGluczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gY3JlYXRlIGEgbmV3IGluc3RhbmNlIGJ5IHBhc3NpbmcgYW4gaW1wb3J0ZWQgY2xhc3MgKEpTIG1vZHVsZSBkZWZhdWx0IGV4cG9ydClcbiAgICAgICAgICogQG1lbWJlciB7Q2xhc3N9IG1vZHVsZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vZHVsZTogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNhY2hlIGZvciBhbGwgdGltZW91dCBpZHMgd2hlbiB1c2luZyB0aGlzLnRpbWVvdXQoKVxuICAgICAqIEBtZW1iZXIge051bWJlcltdfSB0aW1lb3V0SWRzPVtdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjdGltZW91dElkcyA9IFtdXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBvYnNlcnZhYmxlIG1peGluIGlmIG5lZWRlZCwgZ3JhbnRzIHJlbW90ZSBhY2Nlc3MgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWc9e31cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnPXt9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobWUsIHtcbiAgICAgICAgICAgIFtjb25maWdTeW1ib2xdOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGUgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgOiB7fSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZSAgICA6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbaXNJbnN0YW5jZV06IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmNyZWF0ZUlkKGNvbmZpZy5pZCB8fCBtZS5pZCk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuaWQ7XG5cbiAgICAgICAgaWYgKG1lLmNvbnN0cnVjdG9yLmNvbmZpZykge1xuICAgICAgICAgICAgZGVsZXRlIG1lLmNvbnN0cnVjdG9yLmNvbmZpZy5pZFxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0U3RhdGljQ29uZmlnKCdvYnNlcnZhYmxlJykgJiYgbWUuaW5pdE9ic2VydmFibGUoY29uZmlnKTtcblxuICAgICAgICAvLyBhc3NpZ24gY2xhc3MgZmllbGQgdmFsdWVzIHByaW9yIHRvIGNvbmZpZ3NcbiAgICAgICAgY29uZmlnID0gbWUuc2V0RmllbGRzKGNvbmZpZyk7XG5cbiAgICAgICAgbWUuaW5pdENvbmZpZyhjb25maWcpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2NvbmZpZ3NBcHBsaWVkJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAgICAgOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmFwcGx5RGVsYXlhYmxlKCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogV2UgZG8gbm90IHdhbnQgdG8gZm9yY2UgZGV2cyB0byBjaGVjayBmb3IgdGhlIGBpc0Rlc3Ryb3llZGAgZmxhZyBpbiBldmVyeSBwb3NzaWJsZSBjbGFzcyBleHRlbnNpb24uXG4gICAgICAgICAqIFNvLCB3ZSBhcmUgaW50ZXJjZXB0aW5nIHRoZSB0b3AtbW9zdCBgZGVzdHJveSgpYCBjYWxsIHRvIGNoZWNrIGZvciB0aGUgZmxhZyB0aGVyZS5cbiAgICAgICAgICogUmF0aW9uYWxlOiBgZGVzdHJveSgpYCBtdXN0IG9ubHkgZ2V0IGNhbGxlZCBvbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJjZXB0KG1lLCAnZGVzdHJveScsIG1lLmlzRGVzdHJveWVkQ2hlY2ssIG1lKTtcblxuICAgICAgICBtZS5yZW1vdGUgJiYgc2V0VGltZW91dChtZS5pbml0UmVtb3RlLmJpbmQobWUpLCAxKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkLlxuICAgICAqIFlvdSBjYW4gZHluYW1pY2FsbHkgY2hhbmdlIGluc3RhbmNlIGlkcyBpZiBuZWVkZWQuIFRoZXkgbmVlZCB0byBzdGF5IHVuaXF1ZSBhdCBhbnkgZ2l2ZW4gcG9pbnQuXG4gICAgICogVXNlIGNhc2U6IGUuZy4gY29tcG9uZW50IGJhc2VkIGxpc3RzLCB3aGVyZSB5b3Ugd2FudCB0byByZS11c2UgaXRlbSBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNNYW5hZ2VyID0gQmFzZS5pbnN0YW5jZU1hbmFnZXJBdmFpbGFibGUgPT09IHRydWU7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaGFzTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIE5lby5tYW5hZ2VyLkluc3RhbmNlLnVucmVnaXN0ZXIob2xkVmFsdWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBOZW8uaWRNYXBbb2xkVmFsdWVdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChoYXNNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgTmVvLm1hbmFnZXIuSW5zdGFuY2UucmVnaXN0ZXIobWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBOZW8uaWRNYXAgPSBOZW8uaWRNYXAgfHwge307XG4gICAgICAgICAgICAgICAgTmVvLmlkTWFwW21lLmlkXSA9IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGFsbCBtZXRob2RzIGluc2lkZSBzdGF0aWMgZGVsYXlhYmxlXG4gICAgICovXG4gICAgYXBwbHlEZWxheWFibGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGN0b3JEZWxheWFibGUgPSBtZS5jb25zdHJ1Y3Rvci5kZWxheWFibGUsXG4gICAgICAgICAgICBkZWxheWFibGUgICAgID0gbWUuZGVsYXlhYmxlID8gTmVvLm1lcmdlKHt9LCBtZS5kZWxheWFibGUsIGN0b3JEZWxheWFibGUpIDogY3RvckRlbGF5YWJsZTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhkZWxheWFibGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyKCkgICB7bWVba2V5XSA9IG5ldyBidWZmZXIobWVba2V5XSwgICBtZSwgdmFsdWUudGltZXIpfSxcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2UoKSB7bWVba2V5XSA9IG5ldyBkZWJvdW5jZShtZVtrZXldLCBtZSwgdmFsdWUudGltZXIpfSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKSB7bWVba2V5XSA9IG5ldyB0aHJvdHRsZShtZVtrZXldLCBtZSwgdmFsdWUudGltZXIpfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtYXBbdmFsdWUudHlwZV0/LigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHlpbmcgb3ZlcndyaXRlcyBhbmQgYWRkaW5nIG92ZXJ3cml0dGVuTWV0aG9kcyB0byB0aGUgY2xhc3MgY29uc3RydWN0b3JzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNmZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlPdmVyd3JpdGVzKGNmZykge1xuICAgICAgICBsZXQgb3ZlcndyaXRlcyA9IE5lby5ucyhjZmcuY2xhc3NOYW1lLCBmYWxzZSwgTmVvLm92ZXJ3cml0ZXMpLFxuICAgICAgICAgICAgY2xzLCBpdGVtO1xuXG4gICAgICAgIGlmIChvdmVyd3JpdGVzKSB7XG4gICAgICAgICAgICAvLyBBcHBseSBhbGwgbWV0aG9kc1xuICAgICAgICAgICAgZm9yIChpdGVtIGluIG92ZXJ3cml0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24ob3ZlcndyaXRlc1tpdGVtXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBleGlzdGluZyBvbmVzXG4gICAgICAgICAgICAgICAgICAgIGNscyA9IHRoaXMucHJvdG90eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHNbaXRlbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0byBvdmVyd3JpdHRlbk1ldGhvZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5jb25zdHJ1Y3Rvci5vdmVyd3JpdHRlbk1ldGhvZHNbaXRlbV0gPSBjbHNbaXRlbV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlncyB0byBwcm90b3R5cGVcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2ZnLCBvdmVyd3JpdGVzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBiZWZvcmVTZXQgZnVuY3Rpb25zIHdoaWNoIHRlc3QgaWYgYSBnaXZlbiB2YWx1ZSBpcyBpbnNpZGUgYSBzdGF0aWMgYXJyYXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGNvbmZpZyBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IFtzdGF0aWNOYW1lPW5hbWUgKyAncyddIG5hbWUgb2YgdGhlIHN0YXRpYyBjb25maWcgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcn0gdmFsdWUgb3Igb2xkVmFsdWVcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCBuYW1lLCBzdGF0aWNOYW1lID0gbmFtZSArICdzJykge1xuICAgICAgICBsZXQgdmFsdWVzID0gQXJyYXkuaXNBcnJheShzdGF0aWNOYW1lKSA/IHN0YXRpY05hbWUgOiB0aGlzLmdldFN0YXRpY0NvbmZpZyhzdGF0aWNOYW1lKTtcblxuICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN1cHBvcnRlZCB2YWx1ZXMgZm9yICR7bmFtZX0gYXJlOmAsIC4uLnZhbHVlcywgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbiAgICAgICAgICAgICAgIFRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdG8gZmluZCBpbiB0aGUgcGFzc2VkIHNjb3BlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luTmFtZSAgICAgICBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIGluc2lkZSB0aGUgb3JpZ2luU2NvcGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlICAgICAgICAgICAgVGhlIHNjb3BlIHRvIGZpbmQgdGhlIGZ1bmN0aW9uIGluIGlmIGl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luU2NvcGU9dGhpcyBUaGUgc2NvcGUgd2hlcmUgdGhlIGZ1bmN0aW9uIGlzIGxvY2F0ZWQuXG4gICAgICovXG4gICAgYmluZENhbGxiYWNrKGZuLCBvcmlnaW5OYW1lLCBzY29wZT10aGlzLCBvcmlnaW5TY29wZT10aGlzKSB7XG4gICAgICAgIGlmIChmbiAmJiBOZW8uaXNTdHJpbmcoZm4pKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gcmVzb2x2ZUNhbGxiYWNrKGZuLCBzY29wZSk7XG4gICAgICAgICAgICBvcmlnaW5TY29wZVtvcmlnaW5OYW1lXSA9IGhhbmRsZXIuZm4uYmluZChoYW5kbGVyLnNjb3BlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnJvbSB3aXRoaW4gYW4gb3ZlcndyaXRlLCBhIG1ldGhvZCBjYW4gY2FsbCBhIHBhcmVudCBtZXRob2QsIGJ5IHVzaW5nIGNhbGxPdmVyd3JpdHRlbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgYWZ0ZXJTZXRIZWlnaHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICogICAgICAgIC8vIGRvIHRoZSBzdGFuZGFyZFxuICAgICAqICAgICAgICB0aGlzLmNhbGxPdmVyd3JpdHRlbiguLi5hcmd1bWVudHMpO1xuICAgICAqICAgICAgICAvLyBkbyB5b3Ugb3duIHN0dWZmXG4gICAgICogICAgfVxuICAgICAqXG4gICAgICogV2UgY3JlYXRlIGFuIGVycm9yIHRvIGdldCB0aGUgY2FsbGVyLm5hbWUgYW5kIHRoZW4gcnVuIHRoYXQgbWV0aG9kIG9uIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgZXJyb3Igc3RydWN0dXJlLCBlLmcuIGFmdGVyU2V0SGVpZ2h0LlxuICAgICAqXG4gICAgICogICAgIEVycm9yXG4gICAgICogICAgICAgICBhdCBCYXNlLmNhbGxPdmVyd3JpdHRlbiAoQmFzZS5tanM6MTc2OjIxKVxuICAgICAqICAgICAgICAgYXQgQmFzZS5hZnRlclNldEhlaWdodCAoT3ZlcnJpZGVzLm1qczoxOToyNilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgY2FsbE92ZXJ3cml0dGVuKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHN0YWNrICAgICAgPSBuZXcgRXJyb3IoKS5zdGFjayxcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSBzdGFjay5tYXRjaChCYXNlLm1ldGhvZE5hbWVSZWdleClbMV07XG5cbiAgICAgICAgdGhpcy5fX3Byb3RvX18uY29uc3RydWN0b3Iub3ZlcndyaXR0ZW5NZXRob2RzW21ldGhvZE5hbWVdLmNhbGwodGhpcywgLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBJZEdlbmVyYXRvciB0byBjcmVhdGUgYW4gaWQgaWYgYSBzdGF0aWMgb25lIGlzIG5vdCBleHBsaWNpdGx5IHNldC5cbiAgICAgKiBSZWdpc3RlcnMgdGhlIGluc3RhbmNlIHRvIG1hbmFnZXIuSW5zdGFuY2UgaWYgdGhpcyBvbmUgaXMgYWxyZWFkeSBjcmVhdGVkLFxuICAgICAqIG90aGVyd2lzZSBzdG9yZXMgaXQgaW5zaWRlIGEgdG1wIG1hcC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKi9cbiAgICBjcmVhdGVJZChpZCkge1xuICAgICAgICB0aGlzLmlkID0gaWQgfHwgSWRHZW5lcmF0b3IuZ2V0SWQodGhpcy5nZXRJZEtleSgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIHRoaXMgaW5zdGFuY2UgZnJvbSBOZW8ubWFuYWdlci5JbnN0YW5jZVxuICAgICAqIGFuZCByZW1vdmVzIGFsbCBvYmplY3QgZW50cmllcyBmcm9tIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLiN0aW1lb3V0SWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoQmFzZS5pbnN0YW5jZU1hbmFnZXJBdmFpbGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIE5lby5tYW5hZ2VyLkluc3RhbmNlLnVucmVnaXN0ZXIobWUpXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlkTWFwKSB7XG4gICAgICAgICAgICBkZWxldGUgTmVvLmlkTWFwW21lLmlkXVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMobWUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1lLCBrZXkpLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBub3QgZGVsZXRlIHRoZSBjdXN0b20gZGVzdHJveSgpIGludGVyY2VwdG9yXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2Rlc3Ryb3knICYmIGtleSAhPT0gJ19pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lW2tleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIGRvIHdhbnQgdG8gcHJldmVudCBkZWxheWVkIGV2ZW50IGNhbGxzIGFmdGVyIGFuIG9ic2VydmFibGUgaW5zdGFuY2UgZ290IGRlc3Ryb3llZC5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKG1lLmZpcmUpKSB7XG4gICAgICAgICAgICBtZS5maXJlID0gTmVvLmVtcHR5Rm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgaW5zaWRlIGNyZWF0ZUlkKCkgYXMgdGhlIGRlZmF1bHQgdmFsdWUgcGFzc2VkIHRvIHRoZSBJZEdlbmVyYXRvci5cbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWQuXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnR5cGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHN0YXRpYyBjb25maWcga2V5IG9yIHRoZSBzdGF0aWNDb25maWcgb2JqZWN0IGl0c2VsZiBpbiBjYXNlIG5vIHZhbHVlIGlzIHNldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSBvZiBhIHN0YXRpY0NvbmZpZyBkZWZpbmVkIGluc2lkZSBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3RhdGljQ29uZmlnKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcltrZXldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBnaXZlbiBudHlwZSBleGlzdHMgaW5zaWRlIHRoZSBwcm90byBjaGFpbiwgaW5jbHVkaW5nIHRoZSB0b3AgbGV2ZWwgY2xhc3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbnR5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNOdHlwZShudHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5udHlwZUNoYWluLmluY2x1ZGVzKG50eXBlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGFmdGVyIG9uQ29uc3RydWN0ZWQoKSBpcyBkb25lXG4gICAgICogQHNlZSB7QGxpbmsgTmVvLmNvcmUuQmFzZSNvbkNvbnN0cnVjdGVkIG9uQ29uc3RydWN0ZWR9XG4gICAgICogQHR1dG9yaWFsIDAyX0NsYXNzU3lzdGVtXG4gICAgICovXG4gICAgaW5pdCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCBjbGFzcyBjb25maWdzIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdENvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzQ29uZmlndXJpbmcgPSB0cnVlO1xuICAgICAgICBPYmplY3QuYXNzaWduKG1lW2NvbmZpZ1N5bWJvbF0sIG1lLm1lcmdlQ29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKSk7XG4gICAgICAgIG1lLnByb2Nlc3NDb25maWdzKCk7XG4gICAgICAgIG1lLmlzQ29uZmlndXJpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIGdldCB0cmlnZ2VyZWQgd2l0aCBhIGRlbGF5IHRvIGVuc3VyZSB0aGF0IE5lby53b3JrZXJJZCAmIE5lby53b3JrZXIuTWFuYWdlciBhcmUgZGVmaW5lZFxuICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIHZpYSBwcm9taXNlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0UmVtb3RlKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xhc3NOYW1lLCByZW1vdGV9ID0gbWUsXG4gICAgICAgICAgICB7Y3VycmVudFdvcmtlcn0gICAgID0gTmVvO1xuXG4gICAgICAgIGlmICghbWUuc2luZ2xldG9uICYmICFtZS5pc01haW5UaHJlYWRBZGRvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdGUgbWV0aG9kIGFjY2VzcyBpcyBvbmx5IGZ1bmN0aW9uYWwgZm9yIFNpbmdsZXRvbiBjbGFzc2VzICcgKyBjbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIU5lby5jb25maWcudW5pdFRlc3RNb2RlICYmIE5lby5pc09iamVjdChyZW1vdGUpKSB7XG4gICAgICAgICAgICBpZiAoTmVvLndvcmtlcklkICE9PSAnbWFpbicgJiYgY3VycmVudFdvcmtlci5pc1NoYXJlZFdvcmtlciAmJiAhY3VycmVudFdvcmtlci5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIub24oJ2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgQmFzZS5zZW5kUmVtb3RlcyhjbGFzc05hbWUsIHJlbW90ZSlcbiAgICAgICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCYXNlLnNlbmRSZW1vdGVzKGNsYXNzTmFtZSwgcmVtb3RlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJjZXB0cyBkZXN0cm95KCkgY2FsbHMgdG8gZW5zdXJlIHRoZXkgd2lsbCBvbmx5IGdldCBjYWxsZWQgb25jZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRGVzdHJveWVkQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0Rlc3Ryb3llZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgb3JkZXIgY29uZmlncyBhcmUgYXBwbGllZCB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBjdG9yID0gbWUuY29uc3RydWN0b3I7XG5cbiAgICAgICAgaWYgKCFjdG9yLmNvbmZpZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZW8uYXBwbHlDbGFzc0NvbmZpZyBoYXMgbm90IGJlZW4gcnVuIG9uICcgKyBtZS5jbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICAgICAgbWUub3JpZ2luYWxDb25maWcgPSBOZW8uY2xvbmUoY29uZmlnLCB0cnVlLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi5jdG9yLmNvbmZpZywgLi4uY29uZmlnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25BZnRlckNvbnN0cnVjdGVkKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzQ29uc3RydWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGZpcmUgdGhlIGV2ZW50IGluIGNhc2UgdGhlIE9ic2VydmFibGUgbWl4aW4gaXMgaW5jbHVkZWQuXG4gICAgICAgIG1lLmdldFN0YXRpY0NvbmZpZygnb2JzZXJ2YWJsZScpICYmIG1lLmZpcmUoJ2NvbnN0cnVjdGVkJywgbWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIGNvbnN0cnVjdG9ycyBhcmUgZG9uZVxuICAgICAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byByZXBsYWNlIHN0cmluZyBiYXNlZCB2YWx1ZXMgY29udGFpbmluZyBcIkBjb25maWc6XCIgd2l0aCB0aGUgbWF0Y2hpbmcgY29uZmlnIHZhbHVlXG4gICAgICogb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBwYXJzZUl0ZW1Db25maWdzKGl0ZW1zKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBucywgbnNBcnJheSwgbnNLZXksIHN5bWJvbE5zO1xuXG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gW2l0ZW1zXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0gJiYgT2JqZWN0LmVudHJpZXMoaXRlbSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucGFyc2VJdGVtQ29uZmlncyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zdGFydHNXaXRoKCdAY29uZmlnOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuc0FycmF5ID0gdmFsdWUuc3Vic3RyaW5nKDgpLnRyaW0oKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnNLZXkgICA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBucyAgICAgID0gTmVvLm5zKG5zQXJyYXksIGZhbHNlLCBtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuc1tuc0tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSB1c2VkIEBjb25maWcgZG9lcyBub3QgZXhpc3Q6JywgbnNLZXksIG5zQXJyYXkuam9pbignLicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOcyA9IE5lby5ucyhuc0FycmF5LCBmYWxzZSwgbWVbY29uZmlnU3ltYm9sXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnIG1pZ2h0IG5vdCBiZSBwcm9jZXNzZWQgeWV0LCBlc3BlY2lhbGx5IGZvciBjb25maWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVuZGluZyB3aXRoIGFuIHVuZGVyc2NvcmUsIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGNvbmZpZ1N5bWJvbCBmaXJzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sTnMgJiYgT2JqZWN0Lmhhc093bihzeW1ib2xOcywgbnNLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1ba2V5XSA9IHN5bWJvbE5zW25zS2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1ba2V5XSA9IG5zW25zS2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyBzZXQoKSwgY29uZmlncyB3aXRob3V0IGEgdHJhaWxpbmcgdW5kZXJzY29yZSBjYW4gYWxyZWFkeSBiZSBhc3NpZ25lZCxcbiAgICAgKiBzbyB0aGUgaGFzT3duUHJvcGVydHkoKSBjaGVjayB3aWxsIHJldHVybiB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBc3NpZ249ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb2Nlc3NDb25maWdzKGZvcmNlQXNzaWduPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhtZVtjb25maWdTeW1ib2xdKTtcblxuICAgICAgICBtZVtmb3JjZUFzc2lnbkNvbmZpZ3NdID0gZm9yY2VBc3NpZ247XG5cbiAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBrZXlzLCBzaW5jZSAxIGNvbmZpZyBjYW4gcmVtb3ZlIG1vcmUgdGhhbiAxIGtleSAoYmVmb3JlU2V0WCwgYWZ0ZXJTZXRYKVxuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBUaGUgaGFzT3duUHJvcGVydHkgY2hlY2sgaXMgaW50ZW5kZWQgZm9yIGNvbmZpZ3Mgd2l0aG91dCBhIHRyYWlsaW5nIHVuZGVyc2NvcmVcbiAgICAgICAgICAgIC8vID0+IHRoZXkgY291bGQgYWxyZWFkeSBoYXZlIGJlZW4gYXNzaWduZWQgaW5zaWRlIGFuIGFmdGVyU2V0LW1ldGhvZFxuICAgICAgICAgICAgaWYgKGZvcmNlQXNzaWduIHx8ICFtZS5oYXNPd25Qcm9wZXJ0eShrZXlzWzBdKSkge1xuICAgICAgICAgICAgICAgIG1lW2tleXNbMF1dID0gbWVbY29uZmlnU3ltYm9sXVtrZXlzWzBdXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhIGRlbGV0ZS1jYWxsIGluc2lkZSB0aGUgY29uZmlnIGdldHRlciBhcyB3ZWxsIChOZW8ubWpzID0+IGF1dG9HZW5lcmF0ZUdldFNldCgpKVxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBrZWVwIHRoaXMgb25lIGZvciBjb25maWdzLCB3aGljaCBkbyBub3QgdXNlIGdldHRlcnMgKG5vIHRyYWlsaW5nIHVuZGVyc2NvcmUpXG4gICAgICAgICAgICBkZWxldGUgbWVbY29uZmlnU3ltYm9sXVtrZXlzWzBdXTtcblxuICAgICAgICAgICAgbWUucHJvY2Vzc0NvbmZpZ3MoZm9yY2VBc3NpZ24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlbW90ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VuZFJlbW90ZXMoY2xhc3NOYW1lLCByZW1vdGUpIHtcbiAgICAgICAgbGV0IG9yaWdpbjtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhyZW1vdGUpLmZvckVhY2goKFt3b3JrZXIsIG1ldGhvZHNdKSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLndvcmtlcklkICE9PSB3b3JrZXIpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBOZW8ud29ya2VySWQgPT09ICdtYWluJyA/IE5lby53b3JrZXIuTWFuYWdlciA6IE5lby5jdXJyZW50V29ya2VyO1xuXG4gICAgICAgICAgICAgICAgb3JpZ2luLnNlbmRNZXNzYWdlKHdvcmtlciwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdyZWdpc3RlclJlbW90ZScsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIG11bHRpcGxlIGNvbmZpZ3MgYXQgb25jZSwgZW5zdXJpbmcgdGhhdCBhbGwgYWZ0ZXJTZXQgbWV0aG9kcyBnZXQgYWxsIG5ldyBhc3NpZ25lZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICovXG4gICAgc2V0KHZhbHVlcz17fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHZhbHVlcyA9IG1lLnNldEZpZWxkcyh2YWx1ZXMpO1xuXG4gICAgICAgIC8vIElmIHRoZSBpbml0aWFsIGNvbmZpZyBwcm9jZXNzaW5nIGlzIHN0aWxsIHJ1bm5pbmcsXG4gICAgICAgIC8vIGZpbmlzaCB0aGlzIG9uZSBmaXJzdCBiZWZvcmUgZHJvcHBpbmcgbmV3IHZhbHVlcyBpbnRvIHRoZSBjb25maWdTeW1ib2wuXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIyMDFcbiAgICAgICAgaWYgKG1lW2ZvcmNlQXNzaWduQ29uZmlnc10gIT09IHRydWUgJiYgT2JqZWN0LmtleXMobWVbY29uZmlnU3ltYm9sXSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWUucHJvY2Vzc0NvbmZpZ3MoKVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZVtjb25maWdTeW1ib2xdLCB2YWx1ZXMpO1xuXG4gICAgICAgIG1lLnByb2Nlc3NDb25maWdzKHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byBhc3NpZ24gY2xhc3MgZmllbGRzIGZpcnN0IGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBjb25maWcgb2JqZWN0LFxuICAgICAqIHNvIHRoYXQgYWZ0ZXJTZXQoKSwgYmVmb3JlR2V0KCkgYW5kIGJlZm9yZVNldCgpIG1ldGhvZHMgY2FuIGdldCB0aGUgbmV3IHZhbHVlcyByaWdodCBhd2F5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldEZpZWxkcyhjb25maWcpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZ05hbWVzID0gbWUuY29uc3RydWN0b3IuY29uZmlnO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZ05hbWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgIU5lby5oYXNQcm9wZXJ0eVNldHRlcihtZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIG1lW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgY29uZmlnIGJ5IGEgZ2l2ZW4ga2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IG9mIGEgc3RhdGljQ29uZmlnIGRlZmluZWQgaW5zaWRlIHN0YXRpYyBnZXRTdGF0aWNDb25maWdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgY29uZmlnIGV4aXN0cyBhbmQgZ290IGNoYW5nZWRcbiAgICAgKi9cbiAgICBzZXRTdGF0aWNDb25maWcoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgc3RhdGljQ29uZmlnID0gdGhpcy5jb25zdHJ1Y3Rvci5zdGF0aWNDb25maWc7XG5cbiAgICAgICAgaWYgKHN0YXRpY0NvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBzdGF0aWNDb25maWdba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aW1lb3V0SWRzIGludGVybmFsbHksIHNvIHRoYXQgZGVzdHJveSgpIGNhbiBjbGVhciB0aGVtIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0SWRzID0gdGhpcy4jdGltZW91dElkcyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgID0gc2V0VGltZW91dCgoKSA9PiB7dGltZW91dElkcy5zcGxpY2UodGltZW91dElkcy5pbmRleE9mKHRpbWVvdXRJZCksIDEpOyByZXNvbHZlKCl9LCB0aW1lKTtcblxuICAgICAgICAgICAgdGltZW91dElkcy5wdXNoKHRpbWVvdXRJZClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmhhbmNpbmcgdGhlIHRvU3RyaW5nKCkgbWV0aG9kLCBlLmcuPC9wPlxuICAgICAqIGBOZW8uY3JlYXRlKCdOZW8uYnV0dG9uLkJhc2UnKS50b1N0cmluZygpID0+IFwiW29iamVjdCBOZW8uYnV0dG9uLkJhc2UgKG5lby1idXR0b24tMSldXCJgXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNsYXNzTmFtZX0gKGlkOiAke3RoaXMuaWR9KWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmhhbmNpbmcgdGhlIGluc3RhbmNlb2YgbWV0aG9kLiBXaXRob3V0IHRoaXMgY2hhbmdlOjwvcD5cbiAgICAgKiBgTmVvLmNvbGxlY3Rpb24uQmFzZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IHRydWVgXG4gICAgICogPHA+V2l0aCB0aGlzIGNoYW5nZTo8L3A+XG4gICAgICogYE5lby5jb2xsZWN0aW9uLkJhc2UucHJvdG90eXBlIGluc3RhbmNlb2YgTmVvLmNvcmUuQmFzZSA9PiBmYWxzZWA8YnI+XG4gICAgICogYE5lby5jcmVhdGUoTmVvLmNvbGxlY3Rpb24uQmFzZSkgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IHRydWVgXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlW2lzSW5zdGFuY2VdID09PSB0cnVlID8gc3VwZXJbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkgOiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvcmUuQ29tcGFyZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBDb21wYXJlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29yZS5Db21wYXJlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29yZS5Db21wYXJlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgdGhlIGNvbXBhcmlzb24gbWV0aG9kIG5hbWVzIGJ5IGRhdGEgdHlwZVxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWFwXG4gICAgICovXG4gICAgc3RhdGljIG1hcCA9IHtcbiAgICAgICAgQXJyYXkgICAgICA6ICdjb21wYXJlQXJyYXlzJyxcbiAgICAgICAgRGF0ZSAgICAgICA6ICdjb21wYXJlRGF0ZXMnLFxuICAgICAgICBGdW5jdGlvbiAgIDogJ2NvbXBhcmVGdW5jdGlvbnMnLFxuICAgICAgICBNYXAgICAgICAgIDogJ2NvbXBhcmVNYXBzJyxcbiAgICAgICAgTmVvSW5zdGFuY2U6ICdjb21wYXJlTmVvSW5zdGFuY2VzJyxcbiAgICAgICAgT2JqZWN0ICAgICA6ICdjb21wYXJlT2JqZWN0cycsXG4gICAgICAgIFJlZ0V4cCAgICAgOiAnY29tcGFyZVJlZ0V4cHMnLFxuICAgICAgICBTZXQgICAgICAgIDogJ2NvbXBhcmVTZXRzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlbTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZUFycmF5cyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgaWYgKGl0ZW0xLmxlbmd0aCAhPT0gaXRlbTIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2ksIHZdIG9mIGl0ZW0xLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKCFDb21wYXJlLmlzRXF1YWwodiwgaXRlbTJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVEYXRlcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0xLnZhbHVlT2YoKSA9PT0gaXRlbTIudmFsdWVPZigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlRnVuY3Rpb25zKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoaXRlbTEubmFtZSAhPT0gaXRlbTIubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbTEudG9TdHJpbmcoKSA9PT0gaXRlbTIudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWFwfSBpdGVtMVxuICAgICAqIEBwYXJhbSB7TWFwfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlTWFwcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgaWYgKGl0ZW0xLnNpemUgIT09IGl0ZW0yLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZhbDI7XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGl0ZW0xKSB7XG4gICAgICAgICAgICB2YWwyID0gaXRlbTIuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWwyICE9PSB2YWwgfHwgdmFsMiA9PT0gdW5kZWZpbmVkICYmICFpdGVtMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlTmVvSW5zdGFuY2VzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICByZXR1cm4gaXRlbTEuaWQgPT09IGl0ZW0yLmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVPYmplY3RzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaXRlbTEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoaXRlbTIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gaXRlbTEpIHtcbiAgICAgICAgICAgIGlmICghQ29tcGFyZS5pc0VxdWFsKGl0ZW0xW2tleV0sIGl0ZW0yW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBpdGVtMVxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlUmVnRXhwcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0xLnRvU3RyaW5nKCkgPT09IGl0ZW0yLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NldH0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge1NldH0gaXRlbTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVNldHMoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIGlmIChpdGVtMS5zaXplICE9PSBpdGVtMi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBpdGVtMSkge1xuICAgICAgICAgICAgaWYgKCFpdGVtMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0xXG4gICAgICogQHBhcmFtIHsqfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VxdWFsKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoaXRlbTEgPT09IGl0ZW0yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHR5cGUxID0gTmVvLnR5cGVPZihpdGVtMSksXG4gICAgICAgICAgICB0eXBlMiA9IE5lby50eXBlT2YoaXRlbTIpO1xuXG4gICAgICAgIGlmICh0eXBlMSAhPT0gdHlwZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbXBhcmUubWFwW3R5cGUxXSkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmVbQ29tcGFyZS5tYXBbdHlwZTFdXShpdGVtMSwgaXRlbTIpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGwgb3RoZXIgdHlwZXNcbiAgICAgICAgcmV0dXJuIGl0ZW0xID09PSBpdGVtMlxuICAgIH1cbn1cblxuQ29tcGFyZSA9IE5lby5zZXR1cENsYXNzKENvbXBhcmUpO1xuXG4vLyBhbGlhc1xuTmVvLmlzRXF1YWwgPSBDb21wYXJlLmlzRXF1YWw7XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBhcmU7XG4iLCIvKipcbiAqIFRoaXMgY2xhc3MgZ2V0cyB1c2VkIGJ5IGNvcmUuQmFzZSwgc28gaXQgY2FuIG5vdCBleHRlbmQgaXQuXG4gKiBJdCBjb3VsZCBnZXQgc2ltcGxpZmllZCB0byBqdXN0IGJlaW5nIGFuIG9iamVjdCAobmVlZHMgdG8gbWFudWFsbHkgZ2V0IHB1dCBpbnRvIHRoZSBOZW8gbmFtZXNwYWNlIGluIHRoaXMgY2FzZSkuXG4gKiBAY2xhc3MgTmVvLmNvcmUuSWRHZW5lcmF0b3JcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgSWRHZW5lcmF0b3Ige1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvcmUuSWRHZW5lcmF0b3InXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb3JlLklkR2VuZXJhdG9yJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2lkLWdlbmVyYXRvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdpZC1nZW5lcmF0b3InLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgcHJlZml4IGZvciBuZW8gaW5zdGFuY2UgaWRzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYmFzZT0nbmVvLSdcbiAgICAgICAgICovXG4gICAgICAgIGJhc2U6ICduZW8tJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj0ndHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlkQ291bnRlciA9IHt9O1xuXG4gICAgICAgIC8vIGFsaWFzXG4gICAgICAgIE5lby5nZXRJZCA9IG1lLmdldElkLmJpbmQobWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZChuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8ICduZW8nO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvdW50ZXIgPSBtZS5pZENvdW50ZXIsXG4gICAgICAgICAgICBjb3VudCAgID0gY291bnRlcltuYW1lXSB8fCAwO1xuXG4gICAgICAgIGNvdW50ZXJbbmFtZV0gPSArK2NvdW50O1xuXG4gICAgICAgIHJldHVybiBtZS5iYXNlICsgKG5hbWUgPT09ICduZW8nID8gJycgOiBuYW1lICsgJy0nKSArIGNvdW50O1xuICAgIH1cblxuICAgIGluaXQoKSB7fVxuXG4gICAgb25BZnRlckNvbnN0cnVjdGVkKCkge31cblxuICAgIG9uQ29uc3RydWN0ZWQoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhJZEdlbmVyYXRvcik7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IHtyZXNvbHZlQ2FsbGJhY2t9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBPYnNlcnZhYmxlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29yZS5PYnNlcnZhYmxlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29yZS5PYnNlcnZhYmxlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21peGluLW9ic2VydmFibGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbWl4aW4tb2JzZXJ2YWJsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtaXhpbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1peGluOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtldmVudElkXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcmRlcl1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IGV2ZW50SWQgbnVsbCBpbiBjYXNlIGFuIG9iamVjdCBnZXRzIHBhc3NlZCBhcyB0aGUgbmFtZSAobXVsdGlwbGUgaWRzKVxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyKG5hbWUsIG9wdHMsIHNjb3BlLCBldmVudElkLCBkYXRhLCBvcmRlcikge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkZWxheSAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGV2ZW50SWRPYmplY3QgPSB0eXBlb2YgZXZlbnRJZCA9PT0gJ29iamVjdCcsXG4gICAgICAgICAgICBuYW1lT2JqZWN0ICAgID0gdHlwZW9mIG5hbWUgICAgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgb25jZSAgICAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgb3B0c1R5cGUgICAgICA9IHR5cGVvZiBvcHRzLFxuICAgICAgICAgICAgbGlzdGVuZXIsIGV4aXN0aW5nLCBldmVudENvbmZpZztcblxuICAgICAgICAvKlxuICAgICAgICAgKiBsZXQgdXMgc3VwcG9ydCB0aGUgZm9sbG93aW5nIGZvcm1hdCB0b286XG4gICAgICAgICAqXG4gICAgICAgICAqIGN1cnJlbnRXb3JrZXIub24oJ2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICogICAgIEJhc2Uuc2VuZFJlbW90ZXMoY2xhc3NOYW1lLCByZW1vdGUpXG4gICAgICAgICAqIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZXZlbnRJZE9iamVjdCAmJiBvcHRzVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXZlbnRJZC5mbiA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzICAgICA9IGV2ZW50SWQ7XG4gICAgICAgICAgICBvcHRzVHlwZSA9ICdvYmplY3QnO1xuICAgICAgICAgICAgZXZlbnRJZCAgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdkZWxheScpKSB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSBuYW1lLmRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLmRlbGF5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdvbmNlJykpIHtcbiAgICAgICAgICAgICAgICBvbmNlID0gbmFtZS5vbmNlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLm9uY2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5hbWUuaGFzT3duUHJvcGVydHkoJ29yZGVyJykpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IG5hbWUub3JkZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5hbWUub3JkZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5hbWUuaGFzT3duUHJvcGVydHkoJ3Njb3BlJykpIHtcbiAgICAgICAgICAgICAgICBzY29wZSA9IG5hbWUuc2NvcGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5hbWUuc2NvcGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobmFtZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWRkTGlzdGVuZXIoa2V5LCB7ZGVsYXksIG9uY2UsIG9yZGVyLCBzY29wZSwgLi4udmFsdWV9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFkZExpc3RlbmVyKGtleSwge2RlbGF5LCBmbjogdmFsdWUsIG9uY2UsIG9yZGVyLCBzY29wZX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRlbGF5ICAgID0gZGVsYXkgICB8fCBvcHRzLmRlbGF5O1xuICAgICAgICAgICAgZXZlbnRJZCAgPSBldmVudElkIHx8IG9wdHMuZXZlbnRJZDtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gb3B0cy5mbjtcbiAgICAgICAgICAgIG9uY2UgICAgID0gb25jZSAgICB8fCBvcHRzLm9uY2U7XG4gICAgICAgICAgICBvcmRlciAgICA9IG9yZGVyICAgfHwgb3B0cy5vcmRlcjtcbiAgICAgICAgICAgIHNjb3BlICAgID0gc2NvcGUgICB8fCBvcHRzLnNjb3BlXG4gICAgICAgIH0gZWxzZSBpZiAob3B0c1R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gb3B0c1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHNUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBvcHRzIC8vIFZDIGhvb2ssIGNhbiBnZXQgcGFyc2VkIGFmdGVyIG9uQ29uc3RydWN0ZWQgaW4gY2FzZSB0aGUgdmlldyB1c2VzIHRoZSBwYXJlbnQgVkNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRMaXN0ZW5lciBjYWxsOiAnICsgbmFtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmFtZU9iamVjdCkge1xuICAgICAgICAgICAgZXZlbnRDb25maWcgPSB7Zm46IGxpc3RlbmVyLCBpZDogZXZlbnRJZCB8fCBOZW8uZ2V0SWQoJ2V2ZW50Jyl9O1xuXG4gICAgICAgICAgICBpZiAoZGF0YSkgICAgICB7ZXZlbnRDb25maWcuZGF0YSAgID0gZGF0YX1cbiAgICAgICAgICAgIGlmIChkZWxheSA+IDApIHtldmVudENvbmZpZy5kZWxheSAgPSBkZWxheX1cbiAgICAgICAgICAgIGlmIChvbmNlKSAgICAgIHtldmVudENvbmZpZy5vbmNlICAgPSBvbmNlfVxuICAgICAgICAgICAgaWYgKHNjb3BlKSAgICAge2V2ZW50Q29uZmlnLnNjb3BlICA9IHNjb3BlfVxuXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcgPSBtZS5saXN0ZW5lcnM/LltuYW1lXSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLmZvckVhY2goY2ZnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNmZy5pZCA9PT0gZXZlbnRJZCB8fCAoY2ZnLmZuID09PSBsaXN0ZW5lciAmJiBjZmcuc2NvcGUgPT09IHNjb3BlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRHVwbGljYXRlIGV2ZW50IGhhbmRsZXIgYXR0YWNoZWQ6JywgbmFtZSwgbWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnNwbGljZShvcmRlciwgMCwgZXZlbnRDb25maWcpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcudW5zaGlmdChldmVudENvbmZpZylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKGV2ZW50Q29uZmlnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUubGlzdGVuZXJzW25hbWVdID0gW2V2ZW50Q29uZmlnXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRDb25maWcuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgcGFzc2VkIGZ1bmN0aW9uLCBvciBhIGZ1bmN0aW9uIGJ5ICpuYW1lKiB3aGljaCBleGlzdHMgaW4gdGhlIHBhc3NlZCBzY29wZSdzXG4gICAgICogb3IgdGhpcyBjb21wb25lbnQncyBvd25lcnNoaXAgY2hhaW4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIEEgZnVuY3Rpb24sIG9yIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdG8gZmluZCBpbiB0aGUgcGFzc2VkIHNjb3BlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgICAgICAgVGhlIHNjb3BlIHRvIGZpbmQgdGhlIGZ1bmN0aW9uIGluIGlmIGl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzICAgICAgICAgQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGNhbGxiYWNrKGZuLCBzY29wZT10aGlzLCBhcmdzKSB7XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHJlc29sdmVDYWxsYmFjayhmbiwgc2NvcGUpO1xuICAgICAgICAgICAgaGFuZGxlci5mbi5hcHBseShoYW5kbGVyLnNjb3BlLCBhcmdzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCBmb3IgZXZlbnRzIHdoaWNoIHVzZSB0aGUgZGVsYXkgb3B0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNiXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICAgICAqL1xuICAgIGRlbGF5ZWRDYWxsYmFjayhjYiwgYXJncywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0KGRlbGF5KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNiLmZuLmFwcGx5KGNiLnNjb3BlLCBhcmdzKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICovXG4gICAgZmlyZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYXJncyAgICAgID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gbWUubGlzdGVuZXJzLFxuICAgICAgICAgICAgZGVsYXksIGhhbmRsZXIsIGhhbmRsZXJzLCBpLCBsZW47XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGhhbmRsZXJzID0gWy4uLmxpc3RlbmVyc1tuYW1lXV07XG4gICAgICAgICAgICBsZW4gICAgICA9IGhhbmRsZXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgIGRlbGF5ICAgPSBoYW5kbGVyLmRlbGF5O1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBmdW5jdGlvbiBuYW1lIG9uIHRoZSBzY29wZSAob3IgbWUpLCBvciwgaWYgaXQgc3RhcnRzIHdpdGggJ3VwLidcbiAgICAgICAgICAgICAgICAvLyBsb29rIGluIHRoZSBvd25lcnNoaXAgaGllcmFyY2h5IGZyb20gbWUuXG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSByZXNvbHZlQ2FsbGJhY2soaGFuZGxlci5mbiwgaGFuZGxlci5zY29wZSB8fCBtZSk7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGlmIHRoZSBzY29wZSBubyBsb25nZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKGNiLnNjb3BlICYmICFjYi5zY29wZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobGlzdGVuZXJzW25hbWVdLCBoYW5kbGVyKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IGV2ZW50IGZvcm1hdC4gSW5qZWN0IGZpcmVyIHJlZmVyZW5jZSBpbiBhcyAnc291cmNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIE5lby5pc09iamVjdChhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0uc291cmNlID0gbWUuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBpZiBpdCBoYXMgdGhlIG9uY2UgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vbmNlICYmIE5lb0FycmF5LnJlbW92ZShsaXN0ZW5lcnNbbmFtZV0sIGhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKGRlbGF5KSAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5kZWxheWVkQ2FsbGJhY2soY2IsIGhhbmRsZXIuZGF0YSA/IGFyZ3MuY29uY2F0KGhhbmRsZXIuZGF0YSkgOiBhcmdzLCBkZWxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IuZm4uYXBwbHkoY2Iuc2NvcGUsIGhhbmRsZXIuZGF0YSA/IGFyZ3MuY29uY2F0KGhhbmRsZXIuZGF0YSkgOiBhcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGluaXRPYnNlcnZhYmxlKGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcHJvdG8gPSBtZS5fX3Byb3RvX18sXG4gICAgICAgICAgICBjdG9yICA9IHByb3RvLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgbGlzdGVuZXJzO1xuXG4gICAgICAgIGlmIChjb25maWcubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBtZS5saXN0ZW5lcnMgPSBjb25maWcubGlzdGVuZXJzO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5saXN0ZW5lcnNcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycyA9IG1lLmxpc3RlbmVycztcblxuICAgICAgICBtZS5saXN0ZW5lcnMgPSB7fTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSB7Li4ubGlzdGVuZXJzfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5hZGRMaXN0ZW5lcihsaXN0ZW5lcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHByb3RvPy5jb25zdHJ1Y3Rvci5pc0NsYXNzKSB7XG4gICAgICAgICAgICBjdG9yID0gcHJvdG8uY29uc3RydWN0b3I7XG5cbiAgICAgICAgICAgIGlmIChjdG9yLm9ic2VydmFibGUgJiYgIWN0b3IubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyICAgOiBtZS5hZGRMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgZmlyZSAgICAgICAgICA6IG1lLmZpcmUsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgb24gICAgICAgICAgICA6IG1lLm9uLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcjogbWUucmVtb3ZlTGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIHVuICAgICAgICAgICAgOiBtZS51blxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3RvID0gcHJvdG8uX19wcm90b19fXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgYWRkTGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2V2ZW50SWRdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3JkZXJdXG4gICAgICogQHJldHVybnMge1N0cmluZ30gZXZlbnRJZFxuICAgICAqL1xuICAgIG9uKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBhcmUgZGlmZmVyZW50IHN5bnRheCdzIGhvdyB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgKiBVc2luZyB0aGUgZXZlbnRJZDpcbiAgICAgKiBgYGBcbiAgICAgKiB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCAnbmVvLWV2ZW50LTcnKTtcbiAgICAgKiBgYGBcbiAgICAgKiBQYXNzaW5nIHRoZSBoYW5kbGVyIG1ldGhvZDpcbiAgICAgKiBgYGBcbiAgICAgKiB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlLCB0aGlzKTtcbiAgICAgKiBgYGBcbiAgICAgKiBQYXNzaW5nIGFuIG9iamVjdDpcbiAgICAgKiBgYGBcbiAgICAgKiBtZS5maWVsZC51bih7XG4gICAgICogICAgIGNoYW5nZSAgICAgICAgICAgICAgICAgICAgOiBtZS5vbkZpZWxkQ2hhbmdlLFxuICAgICAqICAgICBjaGFuZ2VDbGVhclRvT3JpZ2luYWxWYWx1ZTogbWUub25GaWVsZENoYW5nZSxcbiAgICAgKiAgICAgc2NvcGUgICAgICAgICAgICAgICAgICAgICA6IG1lXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IFtldmVudElkXVxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gW3Njb3BlXVxuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50SWQsIHNjb3BlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpLCBsZW4sIGxpc3RlbmVyLCBsaXN0ZW5lcnMsIG1hdGNoO1xuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihldmVudElkKSkge1xuICAgICAgICAgICAgbWUucmVtb3ZlTGlzdGVuZXIoe1tuYW1lXTogZXZlbnRJZCwgc2NvcGV9KTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdChuYW1lKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUuc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBzY29wZSA9IG5hbWUuc2NvcGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5hbWUuc2NvcGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG5hbWUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IG1lLmxpc3RlbmVyc1trZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgIGkgICAgICAgICA9IDA7XG4gICAgICAgICAgICAgICAgbGVuICAgICAgID0gbGlzdGVuZXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZm4ubmFtZSA9PT0gKE5lby5pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZSA6IHZhbHVlLm5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5zY29wZSAgID09PSBzY29wZVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzU3RyaW5nKGV2ZW50SWQpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBtZS5saXN0ZW5lcnNbbmFtZV07XG4gICAgICAgICAgICBtYXRjaCAgICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGV2ZW50Q29uZmlnLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRDb25maWcuaWQgPT09IGV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID0gaWR4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKG1hdGNoLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAvLyB9LFxuXG4gICAgLy8gc3VzcGVuZExpc3RlbmVyczogZnVuY3Rpb24ocXVldWUpIHtcblxuICAgIC8vIH0sXG5cbiAgICAvLyByZXN1bWVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHJlbW92ZUxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtldmVudElkXVxuICAgICAqL1xuICAgIHVuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lciguLi5hcmdzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE9ic2VydmFibGUpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb3JlLlV0aWxcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgVXRpbCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEEgcmVnZXggdG8gcmVtb3ZlIGNhbWVsIGNhc2Ugc3ludGF4XG4gICAgICogQG1lbWJlciB7UmVnRXhwfSBkZWNhbWVsUmVnRXg9LyhbYS16XSkoW0EtWl0pL2dcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWNhbWVsUmVnRXggPSAvKFthLXpdKShbQS1aXSkvZ1xuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29yZS5VdGlsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29yZS5VdGlsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvcmUtdXRpbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb3JlLXV0aWwnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVzXG4gICAgICovXG4gICAgc3RhdGljIGJpbmRNZXRob2RzKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgc2NvcGVbdmFsdWVdID0gc2NvcGVbdmFsdWVdLmJpbmQoc2NvcGUpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIHN0eWxlcyBzdHJpbmcgaW50byBhIHN0eWxlcyBvYmplY3QgdXNpbmcgY2FtZWxjYXNlIHN5bnRheFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIHN0eWxlcyBzdHJpbmcgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY2FtZWxjYXNlIHN0eWxlcyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3R5bGVPYmplY3Qoc3RyaW5nKSB7XG4gICAgICAgIGxldCBwYXJ0cztcblxuICAgICAgICAvLyBzcGxpdCgnOycpIGRvZXMgZmV0Y2ggc2VtaWNvbG9ucyBpbnNpZGUgYnJhY2tldHNcbiAgICAgICAgLy8gLT4gYmFja2dyb3VuZC1pbWFnZTogXCJ1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwuLi5cblxuICAgICAgICAvLyBUT0RPOiBDYWNoZSBhbGwgcmVnZXhcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCgvOyg/PVteXFwpXSooPzpcXCh8JCkpL2cpLnJlZHVjZSgob2JqLCBlbCkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBzcGxpdCBieSB0aGUgZmlyc3QgY29sb24gb25seVxuICAgICAgICAgICAgLy8gLT4gYmFja2dyb3VuZC1pbWFnZTogdXJsKCdodHRwOi8vZXhhbXBsZS5jb20vaW1hZ2UucG5nJylcbiAgICAgICAgICAgIHBhcnRzID0gZWwuc3BsaXQoKC86KC4rKS8pKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnVtID0gcGFyc2VGbG9hdCh4KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB4ID09IG51bSA/IG51bSA6IHgudHJpbSgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhcnRzWzBdICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHBhcnRzWzBdID0gcGFydHNbMF0ucmVwbGFjZSgvLShbYS16XSkvZywgKHN0ciwgbGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgb2JqW3BhcnRzWzBdXSA9IHBhcnRzWzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH0sIHt9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3R5bGVzIG9iamVjdCB3aGljaCBjYW4gdXNlIGNhbWVsY2FzZSBzeW50YXggaW50byBhIHN0eWxlcyBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIFRoZSBzdHlsZXMgb2JqZWN0XG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0eWxlcyBzdHJpbmcgKERPTSByZWFkeSlcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3R5bGVzKHN0eWxlcykge1xuICAgICAgICBsZXQgc3R5bGUgPSAnJztcblxuICAgICAgICBPYmplY3QuZW50cmllcyhzdHlsZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSArPSBVdGlsLmRlY2FtZWwoa2V5KSArICc6JyArIHZhbHVlICsgJzsnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdHlsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYWxsIHVwcGVyY2FzZSBjaGFyYWN0ZXJzIG9mIGEgc3RyaW5nIGludG8gLWxvd2VyY2FzZS5cbiAgICAgKiBEb2VzIG5vdCB0b3VjaCBzcGVjaWFsIGNoYXJhY3RlcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBpbnB1dCBjb250YWluaW5nIHVwcGVyY2FzZSBjaGFyYWN0ZXJzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGxvd2VyY2FzZSBvdXRwdXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjYW1lbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShVdGlsLmRlY2FtZWxSZWdFeCwgJyQxLSQyJykudG9Mb3dlckNhc2UoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBib29sZWFuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGVtcHR5IEFycmF5LCBPYmplY3Qgb3IgU3RyaW5nXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChVdGlsLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChVdGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgbnVtYmVyLiBSZXR1cm5zIGZhbHNlIGZvciBub24tZmluaXRlIG51bWJlcnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNOdW1iZXIodmFsdWUpe1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlPy5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ09iamVjdCcgfHwgZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIG5lbyBkYXRhIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1JlY29yZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnUmVjb3JkJyB8fCBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW55IGl0ZXJhYmxlIChzdHJpbmdzLCBudW1lcmljIGluZGljZXMgYW5kIGEgbGVuZ3RoIHByb3BlcnR5KSBpbnRvIGEgdHJ1ZSBhcnJheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaXRlcmFibGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0PTBdIHN0YXJ0IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmQ9aXRlcmFibGUubGVuZ3RoXSBlbmQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIHRvQXJyYXkoaXRlcmFibGUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IGxlbjtcblxuICAgICAgICBpZiAoIWl0ZXJhYmxlIHx8ICEobGVuID0gaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlLnNwbGl0KCcnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGl0ZXJhYmxlLCBzdGFydCB8fCAwLCBlbmQgfHwgbGVuKVxuICAgIH1cbn1cblxuVXRpbCA9IE5lby5zZXR1cENsYXNzKFV0aWwpO1xuXG4vLyBhbGlhc2VzXG5OZW8uYXBwbHlGcm9tTnMoTmVvLCBVdGlsLCB7XG4gICAgYmluZE1ldGhvZHMgICAgICA6ICdiaW5kTWV0aG9kcycsXG4gICAgY3JlYXRlU3R5bGVPYmplY3Q6ICdjcmVhdGVTdHlsZU9iamVjdCcsXG4gICAgY3JlYXRlU3R5bGVzICAgICA6ICdjcmVhdGVTdHlsZXMnLFxuICAgIGRlY2FtZWwgICAgICAgICAgOiAnZGVjYW1lbCcsXG4gICAgaXNBcnJheSAgICAgICAgICA6ICdpc0FycmF5JyxcbiAgICBpc0Jvb2xlYW4gICAgICAgIDogJ2lzQm9vbGVhbicsXG4gICAgaXNEZWZpbmVkICAgICAgICA6ICdpc0RlZmluZWQnLFxuICAgIGlzRW1wdHkgICAgICAgICAgOiAnaXNFbXB0eScsXG4gICAgaXNGdW5jdGlvbiAgICAgICA6ICdpc0Z1bmN0aW9uJyxcbiAgICBpc051bWJlciAgICAgICAgIDogJ2lzTnVtYmVyJyxcbiAgICBpc09iamVjdCAgICAgICAgIDogJ2lzT2JqZWN0JyxcbiAgICBpc1JlY29yZCAgICAgICAgIDogJ2lzUmVjb3JkJyxcbiAgICBpc1N0cmluZyAgICAgICAgIDogJ2lzU3RyaW5nJyxcbiAgICB0b0FycmF5ICAgICAgICAgIDogJ3RvQXJyYXknXG59LCB0cnVlKTtcblxuZXhwb3J0IGRlZmF1bHQgVXRpbDtcbiIsImltcG9ydCBCYXNlICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBDb21wYXJlICAgICBmcm9tICcuL0NvbXBhcmUubWpzJztcbmltcG9ydCBJZEdlbmVyYXRvciBmcm9tICcuL0lkR2VuZXJhdG9yLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgZnJvbSAnLi9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgVXRpbCAgICAgICAgZnJvbSAnLi9VdGlsLm1qcyc7XG5cbmV4cG9ydCB7QmFzZSwgQ29tcGFyZSwgSWRHZW5lcmF0b3IsIE9ic2VydmFibGUsIFV0aWx9O1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgRG9tQWNjZXNzICAgICAgICBmcm9tICcuL0RvbUFjY2Vzcy5tanMnO1xuaW1wb3J0IHt2b2lkQXR0cmlidXRlc30gZnJvbSAnLi4vdmRvbS9kb21Db25zdGFudHMubWpzJztcblxuY29uc3QgTmVvQ29uZmlnID0gTmVvLmNvbmZpZztcblxuLyoqXG4gKiBMb2dpYyB0byBhcHBseSB0aGUgZGVsdGFzIGdlbmVyYXRlZCBieSB2ZG9tLkhlbHBlciB0byB0aGUgcmVhbCBET01cbiAqIEBjbGFzcyBOZW8ubWFpbi5EZWx0YVVwZGF0ZXNcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRGVsdGFVcGRhdGVzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5EZWx0YVVwZGF0ZXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLkRlbHRhVXBkYXRlcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvdW50RGVsdGFzPTBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY291bnREZWx0YXM6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvdW50RGVsdGFzUGVyMjUwbXM9MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb3VudERlbHRhc1BlcjI1MG1zOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb3VudFVwZGF0ZXM9MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb3VudFVwZGF0ZXM6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJDb3VudERlbHRhc189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyQ291bnREZWx0YXNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGxvZ0RlbHRhc0ludGVydmFsSWQ9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBsb2dEZWx0YXNJbnRlcnZhbElkID0gMFxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgcHJvcGVydHkgdG8gc3RvcmUgdGhlIGR5bmFtaWNhbGx5IGxvYWRlZCByZW5kZXJlciBtb2R1bGUuXG4gICAgICogQG1lbWJlciB7TmVvLm1haW4ucmVuZGVyLkRvbUFwaVJlbmRlcmVyfE5lby5tYWluLnJlbmRlci5Eb21BcGlSZW5kZXJlcnxudWxsfSAjcmVuZGVyZXI9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3JlbmRlcmVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBwcm9wZXJ0eSB0byBzaWduYWwgdGhhdCB0aGUgcmVuZGVyZXIgbW9kdWxlIGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgKiBUaGlzIHdpbGwgYmUgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbW9kdWxlIGlzIHJlYWR5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7UHJvbWlzZTx2b2lkPnxudWxsfSAjX3JlYWR5UHJvbWlzZVxuICAgICAqL1xuICAgICNfcmVhZHlQcm9taXNlID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoTmVvLmNvbmZpZy5yZW5kZXJDb3VudERlbHRhcykge1xuICAgICAgICAgICAgbWUucmVuZGVyQ291bnREZWx0YXMgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWF0ZSB0aGUgYXN5bmNocm9ub3VzIGxvYWRpbmcgb2YgdGhlIHJlbmRlcmVyIGhlcmUuXG4gICAgICAgIG1lLiNfcmVhZHlQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vZHVsZTtcblxuICAgICAgICAgICAgICAgIGlmIChOZW9Db25maWcudXNlU3RyaW5nQmFzZWRNb3VudGluZykge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4vcmVuZGVyL1N0cmluZ0Jhc2VkUmVuZGVyZXIubWpzJylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4vcmVuZGVyL0RvbUFwaVJlbmRlcmVyLm1qcycpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuI3JlbmRlcmVyID0gbW9kdWxlLmRlZmF1bHRcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RlbHRhVXBkYXRlczogRmFpbGVkIHRvIGxvYWQgcmVuZGVyZXIgbW9kdWxlOicsIGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyIC8vIFJlLXRocm93IHRvIHByb3BhZ2F0ZSBpbml0aWFsaXphdGlvbiBmYWlsdXJlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZW5kZXJDb3VudERlbHRhcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJlbmRlckNvdW50RGVsdGFzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtsb2dEZWx0YXNJbnRlcnZhbElkfSA9IG1lLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChsb2dEZWx0YXNJbnRlcnZhbElkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUubG9nRGVsdGFzSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZW8tZGVsdGEtdXBkYXRlcycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZyhtZS5jb3VudERlbHRhc1BlcjI1MG1zICogNClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1lLmNvdW50RGVsdGFzUGVyMjUwbXMgPSAwXG4gICAgICAgICAgICAgICAgfSwgMjUwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nRGVsdGFzSW50ZXJ2YWxJZCAmJiBjbGVhckludGVydmFsKGxvZ0RlbHRhc0ludGVydmFsSWQpO1xuICAgICAgICAgICAgbWUubG9nRGVsdGFzSW50ZXJ2YWwgPSAwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgbm9kZU5hbWVcbiAgICAgKi9cbiAgICBjaGFuZ2VOb2RlTmFtZShub2RlLCBub2RlTmFtZSkge1xuICAgICAgICBsZXQge2F0dHJpYnV0ZXN9ID0gbm9kZSxcbiAgICAgICAgICAgIGNsb25lICAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpLFxuICAgICAgICAgICAgaSAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICA9IGF0dHJpYnV0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgYXR0cmlidXRlO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlcy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgIGNsb25lLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUubm9kZU5hbWUsIGF0dHJpYnV0ZS5ub2RlVmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsb25lLmlubmVySFRNTD0gbm9kZS5pbm5lckhUTUw7XG5cbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmUsIG5vZGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEuaWRcbiAgICAgKi9cbiAgICBmb2N1c05vZGUoe2lkfSkge1xuICAgICAgICBEb21BY2Nlc3MuZ2V0RWxlbWVudChpZCk/LmZvY3VzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbmV3IG5vZGUgaW50byB0aGUgRE9NIHRyZWUgYmFzZWQgb24gZGVsdGEgdXBkYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBoYW5kbGVzIGJvdGggc3RyaW5nLWJhc2VkIChvdXRlckhUTUwpIGFuZCBkaXJlY3QgRE9NIEFQSSAodm5vZGUpIG1vdW50aW5nLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIG5vZGUgaXMgaW5zZXJ0ZWQgYXQgdGhlIGNvcnJlY3QgaW5kZXggd2l0aGluIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBEZXRhaWxzICYgQ29uc2lkZXJhdGlvbnM6XG4gICAgICogLSBgcGFyZW50Tm9kZS5jaGlsZHJlbmAgY29udGFpbnMgb25seSBlbGVtZW50IG5vZGVzICh0YWdzKS5cbiAgICAgKiAtIGBwYXJlbnROb2RlLmNoaWxkTm9kZXNgIGNvbnRhaW5zIGFsbCBub2RlcywgaW5jbHVkaW5nIHRleHQgYW5kIGNvbW1lbnQgbm9kZXMuXG4gICAgICogLSBTaW5jZSBldmVyeSBgdnR5cGU6J3RleHQnYCBpcyB3cmFwcGVkIGluc2lkZSBhIGNvbW1lbnQgYmxvY2sgKGFzIGFuIElEKSxcbiAgICAgKiAgIGNhbGN1bGF0aW5nIGEgXCJyZWFsSW5kZXhcIiBpcyBuZWNlc3NhcnkgZm9yIHN0cmluZy1iYXNlZCBpbnNlcnRpb25zIHRvXG4gICAgICogICBjb3JyZWN0bHkgYWNjb3VudCBmb3Igbm9uLWVsZW1lbnQgbm9kZXMuXG4gICAgICogLSBgaW5zZXJ0QWRqYWNlbnRIVE1MKClgIGlzIGdlbmVyYWxseSBmYXN0ZXIgdGhhbiBjcmVhdGluZyBhIG5vZGUgdmlhIHRlbXBsYXRlLFxuICAgICAqICAgYnV0IGl0J3Mgb25seSBhdmFpbGFibGUgZm9yIG1hbmlwdWxhdGluZyBjaGlsZHJlbiAoZWxlbWVudHMpLCBub3QgYGNoaWxkTm9kZXNgIChhbGwgbm9kZXMpLlxuICAgICAqIC0gRm9yIHBlcmZvcm1hbmNlLCBpbiBjYXNlcyB3aGVyZSB0aGVyZSBhcmUgbm8gY29tbWVudCBub2RlcyAoaS5lLiwgbm8gd3JhcHBlZCB0ZXh0IG5vZGVzKSxcbiAgICAgKiAgIHRoZSBtZXRob2QgcHJpb3JpdGl6ZXMgYGluc2VydEFkamFjZW50SFRNTCgpYCB3aGVuIGB1c2VTdHJpbmdCYXNlZE1vdW50aW5nYCBpcyB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGVsdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICBkZWx0YS5oYXNMZWFkaW5nVGV4dENoaWxkcmVuIEZsYWcgdG8gaG9ub3IgbGVhZGluZyBjb21tZW50cywgd2hpY2ggcmVxdWlyZSBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICBkZWx0YS5pbmRleCAgICAgICAgICAgICAgICAgIFRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIG5ldyBub2RlIHdpdGhpbiBpdHMgcGFyZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgIFtkZWx0YS5vdXRlckhUTUxdICAgICAgICAgICAgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbmV3IG5vZGUgKGZvciBzdHJpbmctYmFzZWQgbW91bnRpbmcpLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgIGRlbHRhLnBhcmVudElkICAgICAgICAgICAgICAgVGhlIElEIG9mIHRoZSBwYXJlbnQgRE9NIG5vZGUuXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gW2RlbHRhLnZub2RlXSAgICAgICAgICAgICAgICBUaGUgVk5vZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5ldyBub2RlIChmb3IgZGlyZWN0IERPTSBBUEkgbW91bnRpbmcpLlxuICAgICAqL1xuICAgIGluc2VydE5vZGUoe2hhc0xlYWRpbmdUZXh0Q2hpbGRyZW4sIGluZGV4LCBvdXRlckhUTUwsIHBhcmVudElkLCB2bm9kZX0pIHtcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgc3luY2hyb25vdXMgYW5kICpleHBlY3RzKiB0aGUgcmVuZGVyZXIgdG8gYmUgbG9hZGVkXG4gICAgICAgIGlmICghdGhpcy4jcmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RlbHRhVXBkYXRlcyByZW5kZXJlciBub3QgcmVhZHkgZHVyaW5nIGluc2VydE5vZGUhJyk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBEb21BY2Nlc3MuZ2V0RWxlbWVudE9yQm9keShwYXJlbnRJZCk7XG5cbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICghTmVvQ29uZmlnLnVzZVN0cmluZ0Jhc2VkTW91bnRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNyZW5kZXJlci5jcmVhdGVEb21UcmVlKHtpbmRleCwgaXNSb290OiB0cnVlLCBwYXJlbnROb2RlLCB2bm9kZX0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuI3JlbmRlcmVyLmluc2VydE5vZGVBc1N0cmluZyh7aGFzTGVhZGluZ1RleHRDaGlsZHJlbiwgaW5kZXgsIG91dGVySFRNTCwgcGFyZW50Tm9kZX0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBleGlzdGluZyBET00gbm9kZSB0byBhIG5ldyBwb3NpdGlvbiB3aXRoaW4gaXRzIHBhcmVudFxuICAgICAqIG9yIHRvIGEgbmV3IHBhcmVudC5cbiAgICAgKiBUaGlzIG1ldGhvZCBkaXJlY3RseSBtYW5pcHVsYXRlcyB0aGUgRE9NIHVzaW5nIHRoZSBwcmUtY2FsY3VsYXRlZCBwaHlzaWNhbCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWx0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWx0YS5pZCAgICAgICBUaGUgSUQgb2YgdGhlIERPTSBub2RlIHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhLmluZGV4ICAgIFRoZSBwaHlzaWNhbCBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEucGFyZW50SWQgVGhlIElEIG9mIHRoZSB0YXJnZXQgcGFyZW50IERPTSBub2RlLlxuICAgICAqL1xuICAgIG1vdmVOb2RlKHtpZCwgaW5kZXgsIHBhcmVudElkfSkge1xuICAgICAgICBsZXQgbm9kZSAgICAgICA9IERvbUFjY2Vzcy5nZXRFbGVtZW50KGlkKSxcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBEb21BY2Nlc3MuZ2V0RWxlbWVudChwYXJlbnRJZCk7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpbmRleCBpcyBhdCBvciBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgcGFyZW50J3MgY3VycmVudCBjaGlsZE5vZGVzLCBhcHBlbmQgdGhlIG5vZGUuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZWZlcmVuY2Ugbm9kZSBhdCB0aGUgdGFyZ2V0IHBoeXNpY2FsIGluZGV4LlxuICAgICAgICAgICAgICAgIGxldCByZWZlcmVuY2VOb2RlID0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VlZCBpZiB0aGUgbm9kZSBpcyBub3QgYWxyZWFkeSBhdCBpdHMgdGFyZ2V0IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSByZWZlcmVuY2VOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gYSBkaXJlY3Qgc3dhcCBvcGVyYXRpb24gaWYgaW1tZWRpYXRlIGVsZW1lbnQgc2libGluZ3MuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUgPT09IHJlZmVyZW5jZU5vZGUubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlcGxhY2VXaXRoKHJlZmVyZW5jZU5vZGUpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCByZWZlcmVuY2VOb2RlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWx0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWx0YS5wYXJlbnRJZFxuICAgICAqL1xuICAgIHJlbW92ZUFsbCh7cGFyZW50SWR9KSB7XG4gICAgICAgIGxldCBub2RlID0gRG9tQWNjZXNzLmdldEVsZW1lbnQocGFyZW50SWQpO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLmlubmVySFRNTCA9ICcnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEucGFyZW50SWRcbiAgICAgKi9cbiAgICByZW1vdmVOb2RlKHtpZCwgcGFyZW50SWR9KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBEb21BY2Nlc3MuZ2V0RWxlbWVudChpZCk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG90ZW50aWFsbHkgYSB2dHlwZTogJ3RleHQnIG5vZGUgKHdyYXBwZWQgYmV0d2VlbiAyIGNvbW1lbnRzKVxuICAgICAgICBlbHNlIGlmIChwYXJlbnRJZCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gRG9tQWNjZXNzLmdldEVsZW1lbnRPckJvZHkocGFyZW50SWQpLFxuICAgICAgICAgICAgICAgIGlzQ29tbWVudCAgPSBOb2RlLkNPTU1FTlRfTk9ERTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBzdGFydGluZyBjb21tZW50IG5vZGUgdXNpbmcgaXRzIGlkIG1hcmtlclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29tbWVudCA9IEFycmF5LmZyb20ocGFyZW50Tm9kZS5jaGlsZE5vZGVzKS5maW5kKG4gPT5cbiAgICAgICAgICAgICAgICAgICAgbi5ub2RlVHlwZSA9PT0gaXNDb21tZW50ICYmIG4ubm9kZVZhbHVlLmluY2x1ZGVzKGAgJHtpZH0gYClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUgPSBzdGFydENvbW1lbnQubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgZW5kQ29tbWVudCBpcyBhIGNvbW1lbnQgbm9kZSBiZWZvcmUgYXR0ZW1wdGluZyB0byByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENvbW1lbnQgPSB0ZXh0Tm9kZT8ubmV4dFNpYmxpbmc/Lm5vZGVUeXBlID09PSBpc0NvbW1lbnQgPyB0ZXh0Tm9kZS5uZXh0U2libGluZyA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0aHJlZSBwYXJ0czogc3RhcnQgY29tbWVudCwgdGV4dCBub2RlLCBlbmQgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlPy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29tbWVudD8ucmVtb3ZlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEuZnJvbUlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbHRhLnBhcmVudElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbHRhLnRvSWRcbiAgICAgKi9cbiAgICByZXBsYWNlQ2hpbGQoe2Zyb21JZCwgcGFyZW50SWQsIHRvSWR9KSB7XG4gICAgICAgIGxldCBub2RlID0gRG9tQWNjZXNzLmdldEVsZW1lbnQocGFyZW50SWQpO1xuXG4gICAgICAgIG5vZGU/LnJlcGxhY2VDaGlsZChEb21BY2Nlc3MuZ2V0RWxlbWVudCh0b0lkKSwgRG9tQWNjZXNzLmdldEVsZW1lbnQoZnJvbUlkKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlbHRhLmlkXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGVsdGEudmFsdWVcbiAgICAgKi9cbiAgICBzZXRUZXh0Q29udGVudCh7aWQsIHZhbHVlfSkge1xuICAgICAgICBsZXQgbm9kZSA9IERvbUFjY2Vzcy5nZXRFbGVtZW50KGlkKTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RlbHRhLmF0dHJpYnV0ZXNdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkZWx0YS5jbHNdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkZWx0YS5pZF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlbHRhLmlubmVySFRNTF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlbHRhLm91dGVySFRNTF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RlbHRhLnN0eWxlXVxuICAgICAqL1xuICAgIHVwZGF0ZU5vZGUoZGVsdGEpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSA9IERvbUFjY2Vzcy5nZXRFbGVtZW50T3JCb2R5KGRlbHRhLmlkKTtcblxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdub2RlIG5vdCBmb3VuZCcsIGRlbHRhLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkZWx0YSkuZm9yRWFjaCgoW3Byb3AsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZEF0dHJpYnV0ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtrZXldID0gdmFsID09PSAndHJ1ZScgLy8gdm5vZGUgYXR0cmlidXRlIHZhbHVlcyBnZXQgY29udmVydGVkIGludG8gc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtrZXldID0gJycgLy8gaW5wdXQgZmllbGRzID0+IHBzZXVkbyBhdHRyaWJ1dGUgY2FuIG5vdCBiZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlW05lb0NvbmZpZy51c2VEb21JZHMgPyAnaWQnIDogJ2RhdGEtbmVvLWlkJ10gPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NwZWxsY2hlY2snICYmIHZhbCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzE5MjJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtrZXldID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlW2tleV0gPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkICAgICYmIG5vZGUuY2xhc3NMaXN0LmFkZCguLi52YWx1ZS5hZGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVtb3ZlICYmIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSguLi52YWx1ZS5yZW1vdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5uZXJIVE1MJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gdmFsdWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdub2RlTmFtZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5jaGFuZ2VOb2RlTmFtZShub2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvdXRlckhUTUwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vdXRlckhUTUwgPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltcG9ydGFudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbCkgJiYgdmFsLmluY2x1ZGVzKCchaW1wb3J0YW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCchaW1wb3J0YW50JywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudCA9ICdpbXBvcnRhbnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KE5lby5kZWNhbWVsKGtleSksIHZhbCwgaW1wb3J0YW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEucGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEudmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGVWdGV4dCh7aWQsIHBhcmVudElkLCB2YWx1ZX0pIHtcbiAgICAgICAgbGV0IG5vZGUgICAgICA9IERvbUFjY2Vzcy5nZXRFbGVtZW50KHBhcmVudElkKSxcbiAgICAgICAgICAgIGlubmVySFRNTCA9IG5vZGUuaW5uZXJIVE1MLFxuICAgICAgICAgICAgc3RhcnRUYWcgID0gYDwhLS0gJHtpZH0gLS0+YCxcbiAgICAgICAgICAgIHJlZyAgICAgICA9IG5ldyBSZWdFeHAoc3RhcnRUYWcgKyAnW1xcXFxzXFxcXFNdKj88IS0tIFxcL25lby12dGV4dCAtLT4nKTtcblxuICAgICAgICBub2RlLmlubmVySFRNTCA9IGlubmVySFRNTC5yZXBsYWNlKHJlZywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gZGF0YS5kZWx0YXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5vcmlnaW49J2FwcCddXG4gICAgICovXG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgc3luY2hyb25vdXMgYW5kICpleHBlY3RzKiB0aGUgcmVuZGVyZXIgdG8gYmUgbG9hZGVkXG4gICAgICAgIGlmICghdGhpcy4jcmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RlbHRhVXBkYXRlcyByZW5kZXJlciBub3QgcmVhZHkgZHVyaW5nIGluc2VydE5vZGUhJyk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZGVsdGFzfSA9IGRhdGEsXG4gICAgICAgICAgICBpICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW47XG5cbiAgICAgICAgZGVsdGFzID0gQXJyYXkuaXNBcnJheShkZWx0YXMpID8gZGVsdGFzIDogW2RlbHRhc107XG4gICAgICAgIGxlbiAgICA9IGRlbHRhcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKE5lb0NvbmZpZy5sb2dEZWx0YVVwZGF0ZXMgJiYgbGVuID4gMCkge1xuICAgICAgICAgICAgbWUuY291bnREZWx0YXMgKz0gbGVuO1xuICAgICAgICAgICAgbWUuY291bnRVcGRhdGVzKys7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndXBkYXRlICcgKyBtZS5jb3VudFVwZGF0ZXMsICd0b3RhbCBkZWx0YXMgJywgbWUuY291bnREZWx0YXMsIE5lby5jbG9uZShkYXRhLCB0cnVlKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW9Db25maWcucmVuZGVyQ291bnREZWx0YXMgJiYgbGVuID4gMCkge1xuICAgICAgICAgICAgbWUuY291bnREZWx0YXNQZXIyNTBtcyArPSBsZW5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG1lW2RlbHRhc1tpXS5hY3Rpb24gfHwgJ3VwZGF0ZU5vZGUnXShkZWx0YXNbaV0pXG4gICAgICAgIH1cblxuICAgICAgICBOZW8ud29ya2VyLk1hbmFnZXIuc2VuZE1lc3NhZ2UoZGF0YS5vcmlnaW4gfHwgJ2FwcCcsIHtcbiAgICAgICAgICAgIGFjdGlvbiA6ICdyZXBseScsXG4gICAgICAgICAgICByZXBseUlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRGVsdGFVcGRhdGVzKTtcbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IERvbVV0aWxzICAgZnJvbSAnLi9Eb21VdGlscy5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSAgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcbmltcG9ydCBTdHJpbmdVdGlsIGZyb20gJy4uL3V0aWwvU3RyaW5nLm1qcyc7XG5cbmNvbnN0XG4gICAgZG9QcmV2ZW50RGVmYXVsdCA9IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICAgIGZpbHRlclRhYmJhYmxlICAgPSBlID0+ICFlLmNsYXNzTGlzdC5jb250YWlucygnbmVvLWZvY3VzLXRyYXAnKSAmJiBEb21VdGlscy5pc1RhYmJhYmxlKGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCxcbiAgICBsZW5ndGhSRSAgICAgICAgID0gL15cXGQrXFx3KyQvLFxuXG4gICAgY2FwdHVyZVBhc3NpdmUgPSB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9LFxuXG4gICAgZm9udFNpemVQcm9wcyA9IFtcbiAgICAgICAgJ2ZvbnQtZmFtaWx5JyxcbiAgICAgICAgJ2ZvbnQta2VybmluZycsXG4gICAgICAgICdmb250LXNpemUnLFxuICAgICAgICAnZm9udC1zaXplLWFkanVzdCcsXG4gICAgICAgICdmb250LXN0cmV0Y2gnLFxuICAgICAgICAnZm9udC1zdHlsZScsXG4gICAgICAgICdmb250LXdlaWdodCcsXG4gICAgICAgICdsZXR0ZXItc3BhY2luZycsXG4gICAgICAgICdsaW5lLWhlaWdodCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICAndGV4dC10cmFuc2Zvcm0nLFxuICAgICAgICAnd29yZC1icmVhaydcbiAgICBdLFxuXG4gICAgbW9kaWZpZXJLZXlzID0ge1xuICAgICAgICBTaGlmdCAgIDogMSxcbiAgICAgICAgQWx0ICAgICA6IDEsXG4gICAgICAgIE1ldGEgICAgOiAxLFxuICAgICAgICBDb250cm9sIDogMVxuICAgIH07XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYWluLkRvbUFjY2Vzc1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBEb21BY2Nlc3MgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5Eb21BY2Nlc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLkRvbUFjY2VzcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgd29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdhZGRTY3JpcHQnLFxuICAgICAgICAgICAgICAgICdhbGlnbicsXG4gICAgICAgICAgICAgICAgJ2FwcGx5Qm9keUNscycsXG4gICAgICAgICAgICAgICAgJ2JsdXInLFxuICAgICAgICAgICAgICAgICdleGVjQ29tbWFuZCcsXG4gICAgICAgICAgICAgICAgJ2ZvY3VzJyxcbiAgICAgICAgICAgICAgICAnZ2V0QXR0cmlidXRlcycsXG4gICAgICAgICAgICAgICAgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcsXG4gICAgICAgICAgICAgICAgJ2dldFNjcm9sbGluZ0RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICdtZWFzdXJlJyxcbiAgICAgICAgICAgICAgICAnbW9uaXRvckF1dG9Hcm93JyxcbiAgICAgICAgICAgICAgICAnbW9uaXRvckF1dG9Hcm93SGFuZGxlcicsXG4gICAgICAgICAgICAgICAgJ25hdmlnYXRlJyxcbiAgICAgICAgICAgICAgICAnbmF2aWdhdGVUbycsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbEJ5JyxcbiAgICAgICAgICAgICAgICAnc2Nyb2xsSW50b1ZpZXcnLFxuICAgICAgICAgICAgICAgICdzY3JvbGxUbycsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbFRvVGFibGVSb3cnLFxuICAgICAgICAgICAgICAgICdzZWxlY3ROb2RlJyxcbiAgICAgICAgICAgICAgICAnc2V0Qm9keUNscycsXG4gICAgICAgICAgICAgICAgJ3NldFN0eWxlJyxcbiAgICAgICAgICAgICAgICAnc3luY01vZGFsTWFzaycsXG4gICAgICAgICAgICAgICAgJ3RyYXBGb2N1cycsXG4gICAgICAgICAgICAgICAgJ3dpbmRvd1Njcm9sbFRvJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBtb2RhbE1hc2soKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5fbW9kYWxNYXNrKSB7XG4gICAgICAgICAgICBtZS5fbW9kYWxNYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBtZS5fbW9kYWxNYXNrLmNsYXNzTmFtZSA9ICduZW8tZGlhbG9nLW1vZGFsLW1hc2snO1xuICAgICAgICAgICAgbWUuX21vZGFsTWFzay5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBkb1ByZXZlbnREZWZhdWx0LCB7Y2FwdHVyZSA6IHRydWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLl9tb2RhbE1hc2tcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmluaXRHbG9iYWxMaXN0ZW5lcnMoKTtcblxuICAgICAgICAvLyBTZXQgdXAgb3VyIGFsaWduaW5nIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoaW5ncyBjaGFuZ2Ugd2hpY2ggbWF5XG4gICAgICAgIC8vIG1lYW4gdGhhdCBhbGlnbm1lbnRzIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgICAgICAgbWUuc3luY0FsaWducyA9IG1lLnN5bmNBbGlnbnMuYmluZChtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWxpZ25TcGVjXG4gICAgICovXG4gICAgYWRkQWxpZ25lZChhbGlnblNwZWMpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpZH0gICAgICAgICAgICAgICAgID0gYWxpZ25TcGVjLFxuICAgICAgICAgICAgYWxpZ25zICAgICAgICAgICAgICAgPSBtZS5fYWxpZ25zIHx8IChtZS5fYWxpZ25zID0gbmV3IE1hcCgpKSxcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyICAgICAgID0gbWUuX2FsaWduUmVzaXplT2JzZXJ2ZXIgfHwgKG1lLl9hbGlnblJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKG1lLnN5bmNBbGlnbnMpKSxcbiAgICAgICAgICAgIHtjb25zdHJhaW5Ub0VsZW1lbnR9ID0gYWxpZ25TcGVjO1xuXG4gICAgICAgIC8vIFNldCB1cCBsaXN0ZW5lcnMgd2hpY2ggbW9uaXRvciBmb3IgY2hhbmdlc1xuICAgICAgICBpZiAoIWFsaWducy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBSZWFsaWduIHdoZW4gdGFyZ2V0J3MgbGF5b3V0LWNvbnRyb2xsaW5nIGVsZW1lbnQgY2hhbmdlcyBzaXplXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGFsaWduU3BlYy5vZmZzZXRQYXJlbnQpO1xuXG4gICAgICAgICAgICAvLyBSZWFsaWduIHdoZW4gYWxpZ24gdG8gdGFyZ2V0IGNoYW5nZXMgc2l6ZVxuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShhbGlnblNwZWMudGFyZ2V0RWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIFJlYWxpZ24gd2hlbiBjb25zdHJhaW5pbmcgZWxlbWVudCBjaGFuZ2VzIHNpemVcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW5Ub0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGNvbnN0cmFpblRvRWxlbWVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUuaGFzRG9jdW1lbnRTY3JvbGxMaXN0ZW5lcikge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgbWUuc3luY0FsaWducywge1xuICAgICAgICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmhhc0RvY3VtZW50U2Nyb2xsTGlzdGVuZXIgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLmRvY3VtZW50TXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgbWUuZG9jdW1lbnRNdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobWUub25Eb2N1bWVudE11dGF0aW9uLmJpbmQobWUpKTtcblxuICAgICAgICAgICAgbWUuZG9jdW1lbnRNdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWJ0cmVlICA6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBhbGlnbnMuc2V0KGlkLCBhbGlnblNwZWMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuYXN5bmNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLmRlZmVyPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5zcmM9dHJ1ZV1cbiAgICAgKi9cbiAgICBhZGRTY3JpcHQoZGF0YSkge1xuICAgICAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KCdhc3luYycpKSB7XG4gICAgICAgICAgICBkYXRhLmFzeW5jID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzY3JpcHQsIGRhdGEpO1xuXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgYWxpZ24oZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29uc3RyYWluVG99ID0gZGF0YSxcbiAgICAgICAgICAgIHN1YmplY3QgICAgICAgPSBkYXRhLnN1YmplY3QgPSBtZS5nZXRFbGVtZW50KGRhdGEuaWQpLFxuICAgICAgICAgICAge3N0eWxlfSAgICAgICA9IHN1YmplY3QsXG4gICAgICAgICAgICBhbGlnbiAgICAgICAgID0gey4uLmRhdGF9LFxuICAgICAgICAgICAgbGFzdEFsaWduICAgICA9IG1lLl9hbGlnbnM/LmdldChkYXRhLmlkKTtcblxuICAgICAgICBpZiAobGFzdEFsaWduKSB7XG4gICAgICAgICAgICBzdWJqZWN0LmNsYXNzTGlzdC5yZW1vdmUoYG5lby1hbGlnbmVkLSR7bGFzdEFsaWduLnJlc3VsdC5wb3NpdGlvbn1gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVsZWFzZSBhbnkgY29uc3RyYWluVG8gb3IgbWF0Y2hTaXplIHNpemluZyB3aGljaCBtYXkgaGF2ZSBiZWVuIGltcG9zZWRcbiAgICAgICAgLy8gYnkgYSBwcmV2aW91cyBhbGlnbiBjYWxsLlxuICAgICAgICBtZS5yZXNldERpbWVuc2lvbnMoYWxpZ24pO1xuXG4gICAgICAgIC8vIFRoZSBSZWN0YW5nbGUncyBhbGlnbiBzcGVjIHRhcmdldCBhbmQgY29uc3RyYWluVG8gbXVzdCBiZSBSZWN0YW5nbGVzXG4gICAgICAgIGFsaWduLnRhcmdldCA9IG1lLmdldENsaXBwZWRSZWN0KHtpZCA6IGRhdGEudGFyZ2V0RWxlbWVudCA9IG1lLmdldEVsZW1lbnRPckJvZHkoZGF0YS50YXJnZXQpfSk7XG5cbiAgICAgICAgaWYgKCFhbGlnbi50YXJnZXQpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgQ29tcG9uZW50IHdpdGggaWQgZGF0YS5pZCB0byBoaWRkZW4gOiB0cnVlXG4gICAgICAgICAgICByZXR1cm4gTmVvLndvcmtlci5BcHAuc2V0Q29uZmlncyh7aWQ6IGRhdGEuaWQsIGhpZGRlbjogdHJ1ZX0pXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLm9mZnNldFBhcmVudCA9IGRhdGEudGFyZ2V0RWxlbWVudC5vZmZzZXRQYXJlbnQ7XG5cbiAgICAgICAgaWYgKGNvbnN0cmFpblRvKSB7XG4gICAgICAgICAgICBhbGlnbi5jb25zdHJhaW5UbyA9IG1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7aWQgOiBkYXRhLmNvbnN0cmFpblRvRWxlbWVudCA9IG1lLmdldEVsZW1lbnRPckJvZHkoY29uc3RyYWluVG8pfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBhbiBhbGlnbmVkIGNsb25lIG9mIG15UmVjdCBhbGlnbmVkIGFjY29yZGluZyB0byB0aGUgYWxpZ24gb2JqZWN0XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBteVJlY3QgPSBtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoZGF0YSksXG4gICAgICAgICAgICByZXN1bHQgPSBkYXRhLnJlc3VsdCA9IG15UmVjdC5hbGlnblRvKGFsaWduKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgICAgICB0b3AgICAgICAgOiAwLFxuICAgICAgICAgICAgbGVmdCAgICAgIDogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybSA6IGB0cmFuc2xhdGUoJHtyZXN1bHQueH1weCwke3Jlc3VsdC55fXB4KWBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC53aWR0aCAhPT0gbXlSZWN0LndpZHRoKSB7XG4gICAgICAgICAgICBzdHlsZS53aWR0aCA9IGAke3Jlc3VsdC53aWR0aH1weGBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuaGVpZ2h0ICE9PSBteVJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtyZXN1bHQuaGVpZ2h0fXB4YFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGxhY2UgYm94IHNoYWRvdyBhdCBjb3JyZWN0IGVkZ2VcbiAgICAgICAgc3ViamVjdC5jbGFzc0xpc3QuYWRkKGBuZW8tYWxpZ25lZC0ke3Jlc3VsdC5wb3NpdGlvbn1gKTtcblxuICAgICAgICAvLyBSZWdpc3RlciBhbiBhbGlnbm1lbnQgdG8gYmUga2VwdCBpbiBzeW5jXG4gICAgICAgIG1lLmFkZEFsaWduZWQoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGRhdGEuY2xzXG4gICAgICovXG4gICAgYXBwbHlCb2R5Q2xzKGRhdGEpIHtcbiAgICAgICAgbGV0IGNscyA9IGRhdGEuY2xzIHx8IFtdO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoLi4uY2xzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGJsdXIoKSBvbiBhIG5vZGUgZm9yIGEgZ2l2ZW4gZG9tIG5vZGUgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9iai5pZCA9PiB0aGUgcGFzc2VkIGlkXG4gICAgICovXG4gICAgYmx1cihkYXRhKSB7XG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudChkYXRhLmlkKT8uYmx1cigpO1xuICAgICAgICByZXR1cm4ge2lkOiBkYXRhLmlkfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuY29tbWFuZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBleGVjQ29tbWFuZChkYXRhKSB7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKGRhdGEuY29tbWFuZCk7XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgZm9jdXMoKSBvbiBhIG5vZGUgZm9yIGEgZ2l2ZW4gZG9tIG5vZGUgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5jaGlsZHJlblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHJldHVybnMge09iamVjdH0gb2JqLmlkID0+IHRoZSBwYXNzZWQgaWRcbiAgICAgKi9cbiAgICBmb2N1cyh7Y2hpbGRyZW4sIGlkfSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0RWxlbWVudChpZCk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjaGlsZHJlbiBwcm9wZXJ0eSBtZWFucyBmb2N1cyBpbm5lciBlbGVtZW50cyBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgIGlmICghRG9tVXRpbHMuaXNGb2N1c2FibGUobm9kZSkgJiYgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBxdWVyeSBmb3IgdGhlIGZpcnN0IGZvY3VzYWJsZSBkZXNjZW5kZW50XG4gICAgICAgICAgICAgICAgbm9kZSA9IERvbVV0aWxzLnF1ZXJ5KG5vZGUsIERvbVV0aWxzLmlzRm9jdXNhYmxlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZm9jdXMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNOdW1iZXIobm9kZS5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZWxlY3Rpb25TdGFydCA9IG5vZGUuc2VsZWN0aW9uRW5kID0gbm9kZS52YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge2lkfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF0dHJpYnV0ZXMgZm9yIGEgZ2l2ZW4gZG9tIG5vZGUgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBkYXRhLmF0dHJpYnV0ZXMgZWl0aGVyIGFuIGF0dHJpYnV0ZSBvciBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGRhdGEuaWQgZWl0aGVyIGFuIGlkIG9yIGFuIGFycmF5IG9mIGlkc1xuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IEluIGNhc2UgaWQgaXMgYW4gYXJyYXksIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBvYmplY3RzIGlzIHJldHVybmVkLCBvdGhlcndpc2UgYW4gb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlcyh7YXR0cmlidXRlcywgaWR9KSB7XG4gICAgICAgIGxldCByZXR1cm5EYXRhO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuRGF0YSA9IFtdO1xuXG4gICAgICAgICAgICBpZC5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm5EYXRhLnB1c2godGhpcy5nZXRBdHRyaWJ1dGVzKHthdHRyaWJ1dGVzLCBpZH0pKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5nZXRFbGVtZW50T3JCb2R5KGlkKTtcblxuICAgICAgICAgICAgcmV0dXJuRGF0YSA9IHt9O1xuXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gW2F0dHJpYnV0ZXNdXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGFbYXR0cmlidXRlXSA9IG5vZGVbYXR0cmlidXRlXVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuRGF0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBmb3IgYSBnaXZlbiBkb20gbm9kZSBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGRhdGEuaWQgZWl0aGVyIGFuIGlkIG9yIGFuIGFycmF5IG9mIGlkc1xuICAgICAqIEByZXR1cm5zIHtET01SZWN0fERPTVJlY3RbXX0gSW4gY2FzZSBpZCBpcyBhbiBhcnJheSwgYW4gYXJyYXkgb2YgRG9tUmVjdHMgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBhbiBEb21SZWN0IG9iamVjdFxuICAgICAqL1xuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICByZXR1cm5EYXRhO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5pZC5tYXAoaWQgPT4gbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHtpZH0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBtZS5nZXRFbGVtZW50T3JCb2R5KGRhdGEubm9kZVR5cGUgPyBkYXRhIDogZGF0YS5pZCksXG4gICAgICAgICAgICAgICAgcmVjdCA9IHt9LFxuICAgICAgICAgICAgICAgIG1pbldpZHRoLCBtaW5IZWlnaHQsIHN0eWxlO1xuXG4gICAgICAgICAgICByZXR1cm5EYXRhID0ge307XG5cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmVjdCAgICAgID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBzdHlsZSAgICAgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCAgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtaW4td2lkdGgnKTtcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtaW4taGVpZ2h0Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBEb21SZWN0IGRvZXMgbm90IHN1cHBvcnQgc3ByZWFkaW5nID0+IHsuLi5Eb21SZWN0fSA9PiB7fVxuICAgICAgICAgICAgICAgIHJldHVybkRhdGEgPSBSZWN0YW5nbGUuY2xvbmUocmVjdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBNZWFzdXJlIG1pbldpZHRoL21pbkhlaWdodCBpbiBvdGhlciB1bml0cyBsaWtlIGVtL3JlbSBldGNcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgMHB4IGlzIHdoYXQgdGhlIERPTSByZXBvcnRzIGlmIG5vIG1pbldpZHRoIGlzIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvIG5vdCByZXBvcnQgYSBtaW5pbXVtIGluIHRoZXNlIGNhc2VzLlxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhSRS50ZXN0KG1pbldpZHRoKSAmJiBtaW5XaWR0aCAhPT0gJzBweCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5taW5XaWR0aCA9IG1lLm1lYXN1cmUoe3ZhbHVlOiBtaW5XaWR0aCwgaWQ6IG5vZGV9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoUkUudGVzdChtaW5IZWlnaHQpICYmIG1pbkhlaWdodCAhPT0gJzBweCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5taW5IZWlnaHQgPSBtZS5tZWFzdXJlKHt2YWx1ZTogbWluSGVpZ2h0LCBpZDogbm9kZX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybkRhdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7TmVvLnV0aWwuUmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIGdldENsaXBwZWRSZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSAgICAgICAgICA9IG1lLmdldEVsZW1lbnQodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YS5pZCA6IGRhdGEpLFxuICAgICAgICAgICAge2RlZmF1bHRWaWV3fSA9IG5vZGUub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIHJlY3QgICAgICAgICAgPSBtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3Qobm9kZSk7XG5cbiAgICAgICAgZm9yIChsZXQgcGFyZW50RWxlbWVudCA9IG5vZGUub2Zmc2V0UGFyZW50OyBwYXJlbnRFbGVtZW50ICYmIHJlY3QgJiYgcGFyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyBwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdycpICE9PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgICAgICByZWN0ID0gcmVjdC5pbnRlcnNlY3RzKHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudEVsZW1lbnQpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3RcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gbm9kZUlkXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldEVsZW1lbnQobm9kZUlkKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZUlkPy5ub2RlVHlwZSA/XG4gICAgICAgICAgICBub2RlSWQgOiBOZW8uY29uZmlnLnVzZURvbUlkcyA/XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZUlkKSA6XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtbmVvLWlkPScke25vZGVJZH0nXWApO1xuXG4gICAgICAgIHJldHVybiBub2RlIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gbm9kZUlkPSdkb2N1bWVudC5ib2R5J1xuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXRFbGVtZW50T3JCb2R5KG5vZGVJZD0nZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZUlkLm5vZGVUeXBlID8gbm9kZUlkIDogKG5vZGVJZCA9PT0gJ2JvZHknIHx8IG5vZGVJZCA9PT0gJ2RvY3VtZW50LmJvZHknKSA/IGRvY3VtZW50LmJvZHkgOiB0aGlzLmdldEVsZW1lbnQobm9kZUlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGRhdGEuaWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFNjcm9sbGluZ0RpbWVuc2lvbnMoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5pZC5tYXAoaWQgPT4gbWUuZ2V0U2Nyb2xsaW5nRGltZW5zaW9ucyh7aWR9KSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gZGF0YS5ub2RlVHlwZSA/IGRhdGEgOiBtZS5nZXRFbGVtZW50T3JCb2R5KGRhdGEuaWQpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodDogbm9kZT8uY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNsaWVudFdpZHRoIDogbm9kZT8uY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0OiBub2RlPy5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsV2lkdGggOiBub2RlPy5zY3JvbGxXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0R2xvYmFsTGlzdGVuZXJzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAgICAgIG1lLm9uRG9jdW1lbnRCbHVyICAgICAuYmluZChtZSksIGNhcHR1cmVQYXNzaXZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsICAgbWUub25Eb2N1bWVudEtleURvd24gIC5iaW5kKG1lKSwgY2FwdHVyZVBhc3NpdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsICAgICBtZS5vbkRvY3VtZW50S2V5VXAgICAgLmJpbmQobWUpLCBjYXB0dXJlUGFzc2l2ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1lLm9uRG9jdW1lbnRNb3VzZURvd24uYmluZChtZSksIHtjYXB0dXJlIDogdHJ1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FsaWduU3ViamVjdChlbCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX2FsaWducz8udmFsdWVzKCldLnNvbWUoYWxpZ24gPT4gYWxpZ24uc3ViamVjdCA9PT0gZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5jbHVkZSBhIHNjcmlwdCBpbnRvIHRoZSBkb2N1bWVudC5oZWFkXG4gICAgICogWW91IGNhbiBhZGQgbW9yZSBhdHRyaWJ1dGVzIGlmIG5lZWRlZC4gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvc2NyaXB0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzPXtkZWZlcjp0cnVlfVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuYXN5bmNdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5kZWZlcl1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAgICAgKi9cbiAgICBsb2FkU2NyaXB0KHNyYywgb3B0cz17ZGVmZXI6dHJ1ZX0pIHtcbiAgICAgICAgbGV0IHNjcmlwdDtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2NyaXB0LCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICBvbmVycm9yOiByZWplY3QsXG4gICAgICAgICAgICAgICAgb25sb2FkIDogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNsdWRlIGEgbGluayBpbnRvIHRoZSBkb2N1bWVudC5oZWFkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhyZWZcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YXNldD1udWxsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gICAgICovXG4gICAgbG9hZFN0eWxlc2hlZXQoaHJlZiwgZGF0YXNldD1udWxsKSB7XG4gICAgICAgIGxldCBsaW5rO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGxpbmssIHtcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIG9uZXJyb3I6IHJlamVjdCxcbiAgICAgICAgICAgICAgICBvbmxvYWQgOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlbCAgICA6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICAgICAgICB0eXBlICAgOiAndGV4dC9jc3MnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGxpbmsuZGF0YXNldCwgZGF0YXNldClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGRhdGEudmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAgICAgKi9cbiAgICBtZWFzdXJlKHsgdmFsdWUsIGlkIH0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGlkLm5vZGVUeXBlID09PSAxID8gaWQgOiB0aGlzLmdldEVsZW1lbnQoaWQpO1xuXG4gICAgICAgIGlmICh2YWx1ZS5lbmRzV2l0aCgnJScpKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFjdGlvbiA9IHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwO1xuXG4gICAgICAgICAgICByZXR1cm4gKG5vZGUub2Zmc2V0UGFyZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgMCkgKiBmcmFjdGlvblxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGl0J3MgYW55IG90aGVyIENTUyB1bml0IHRoYW4gcHgsIGl0IG5lZWRzIHRvIGJlIG1lYXN1cmVkIHVzaW5nIHRoZSBET01cbiAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsdWUpICYmICF2YWx1ZS5lbmRzV2l0aCgncHgnKSkge1xuICAgICAgICAgICAgY29uc3QgZWxTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgICAgICAgICBsZXQgZCA9IHRoaXMuX21lYXN1cmluZ0RpdjtcblxuICAgICAgICAgICAgaWYgKCFkKSB7XG4gICAgICAgICAgICAgICAgZCA9IHRoaXMuX21lYXN1cmluZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGQuc3R5bGUgPSAncG9zaXRpb246Zml4ZWQ7dG9wOi0xMDAwMHB4O2xlZnQ6LTEwMDAwcHgnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBET00gdXBkYXRlIGNsZWFyZWQgaXQgb3V0XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGQpO1xuXG4gICAgICAgICAgICAvLyBTZXQgYWxsIHRoZSBmb250LXNpemUsIGZvbnQtd2VpZ2h0IGV0YyBzdHlsZSBwcm9wZXJ0aWVzIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIGVtL2V4L3JlbSBldGMgdW5pdHMgd2lsbCBtYXRjaFxuICAgICAgICAgICAgZm9udFNpemVQcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgICAgIGQuc3R5bGVbcHJvcF0gPSBlbFN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkLmNsYXNzTmFtZSA9IG5vZGUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgZC5zdHlsZS53aWR0aCA9IHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBSZWFkIGJhY2sgdGhlIHJlc3VsdGluZyBjb21wdXRlZCBwaXhlbCB3aWR0aFxuICAgICAgICAgICAgdmFsdWUgPSBlbFN0eWxlLndpZHRoO1xuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQncyBhIG51bWJlciwgb3IgZW5kcyB3aXRoIHB4LCB1c2UgdGhlIG51bWVyaWMgdmFsdWUuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBvdmVyZmxvdyBzdGF0dXMgb2YgYSBUZXh0QXJlYUZpZWxkJ3MgJmx0O3RleHRhcmVhPiBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZVxuICAgICAqIGhlaWdodCBzbyB0aGF0IHRoZXJlIGlzIG5ldmVyIGEgdmVydGljYWwgc2Nyb2xsYmFyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgbW9uaXRvckF1dG9Hcm93KGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXQgPSBkYXRhLnN1YmplY3QgPSBtZS5nZXRFbGVtZW50KGRhdGEuaWQpO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdXBkYXRlIHRoZSBoZWlnaHQgb24gZXZlcnkgaW5wdXQgZXZlbnQgaXMgYXV0b0dyb3cgaXMgdHJ1dGh5LlxuICAgICAgICB0YXJnZXRbZGF0YS5hdXRvR3JvdyA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJ10oJ2lucHV0JywgbWUubW9uaXRvckF1dG9Hcm93SGFuZGxlcik7XG5cbiAgICAgICAgLy8gRml4IHRoZSBoZWlnaHQgdXAgaW1tZWRpYXRlbHkgdG9vXG4gICAgICAgIGRhdGEuYXV0b0dyb3cgJiYgbWUubW9uaXRvckF1dG9Hcm93SGFuZGxlcih7XG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR8T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmlkXVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtkYXRhLnRhcmdldF1cbiAgICAgKi9cbiAgICBtb25pdG9yQXV0b0dyb3dIYW5kbGVyKGRhdGEpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZGF0YS50YXJnZXQgfHwgdGhpcy5nZXRFbGVtZW50KGRhdGEuaWQpO1xuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgeyBzdHlsZSB9ICAgICAgICAgICAgICA9IHRhcmdldCxcbiAgICAgICAgICAgICAgICB7IHN0eWxlIDogaW5wdXRTdHlsZSB9ID0gdGFyZ2V0LmNsb3Nlc3QoJy5uZW8tdGV4dGFyZWEnKTtcblxuICAgICAgICAgICAgLy8gTWVhc3VyZSB0aGUgc2Nyb2xsSGVpZ2h0IHdoZW4gZm9yY2VkIHRvIG92ZXJmbG93LCB0aGVuIHNldCBoZWlnaHQgdG8gZW5jb21wYXNzIHRoZSBzY3JvbGxIZWlnaHRcbiAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHN0eWxlLm1pbkhlaWdodCA9IDA7XG4gICAgICAgICAgICBpbnB1dFN0eWxlLnNldFByb3BlcnR5KCctLXRleHRmaWVsZC1pbnB1dC1oZWlnaHQnLCBgJHt0YXJnZXQuc2Nyb2xsSGVpZ2h0ICsgNX1weGApO1xuICAgICAgICAgICAgaW5wdXRTdHlsZS5zZXRQcm9wZXJ0eSgnaGVpZ2h0JywgJycpO1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUubWluSGVpZ2h0ID0gJydcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Eb2N1bWVudEJsdXIoKSB7XG4gICAgICAgIE5lby5hbHRLZXlEb3duID0gTmVvLmNvbnRyb2xLZXlEb3duID0gTmVvLm1ldGFLZXlEb3duID0gTmVvLnNoaWZ0S2V5RG93biA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBrZXlFdmVudFxuICAgICAqL1xuICAgIG9uRG9jdW1lbnRLZXlEb3duKGtleUV2ZW50KSB7XG4gICAgICAgIGlmIChtb2RpZmllcktleXNba2V5RXZlbnQua2V5XSkge1xuICAgICAgICAgICAgLy8gZS5nLiBOZW8uaXNTaGlmdEtleURvd24gPSB0cnVlIG9yIE5lby5pc0NvbnRyb2xLZXlEb3duID0gdHJ1ZS5cbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbiBjYW4gY29uc3VsdCB0aGlzIHZhbHVlXG4gICAgICAgICAgICBOZW9bYCR7U3RyaW5nVXRpbC51bmNhcGl0YWxpemUoa2V5RXZlbnQua2V5KX1LZXlEb3duYF0gPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGtleUV2ZW50XG4gICAgICovXG4gICAgb25Eb2N1bWVudEtleVVwKGtleUV2ZW50KSB7XG4gICAgICAgIGlmIChtb2RpZmllcktleXNba2V5RXZlbnQua2V5XSkge1xuICAgICAgICAgICAgTmVvW2Ake1N0cmluZ1V0aWwudW5jYXBpdGFsaXplKGtleUV2ZW50LmtleSl9S2V5RG93bmBdID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG11dGF0aW9uc1xuICAgICAqL1xuICAgIG9uRG9jdW1lbnRNdXRhdGlvbihtdXRhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIElmIHRoZSBtdXRhdGlvbnMgYXJlIHB1cmVseSBhbGlnbiBzdWJqZWN0cyBiZWluZyBhZGRlZCBvciByZW1vdmVkLCB0YWtlIG5vIGFjdGlvbi5cbiAgICAgICAgaWYgKCFtdXRhdGlvbnMuZXZlcnkoKHsgdHlwZSwgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gWy4uLkFycmF5LmZyb20oYWRkZWROb2RlcyksIC4uLkFycmF5LmZyb20ocmVtb3ZlZE5vZGVzKV07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXMuZXZlcnkoYSA9PiBtZS5pc0FsaWduU3ViamVjdChhKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIG1lLnN5bmNBbGlnbnMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAgICovXG4gICAgb25Eb2N1bWVudE1vdXNlRG93bihlKSB7XG4gICAgICAgIGxldCBmb2N1c0NvbnRyb2xsZXIgPSBlLnRhcmdldD8uY2xvc2VzdCgnW2RhdGEtZm9jdXNdJyk7XG5cbiAgICAgICAgLy8gZGF0YS1mb2N1cyBvbiBhbiBlbGVtZW50IG1lYW5zIHJlamVjdCBtb3VzZWRvd24gZ2VzdHVyZXMsIGFuZCBtb3ZlIGZvY3VzXG4gICAgICAgIC8vIHRvIHRoZSByZWZlcmVuY2VkIGVsZW1lbnQuXG4gICAgICAgIGlmIChmb2N1c0NvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZvY3VzQ29udHJvbGxlci5kYXRhc2V0LmZvY3VzKT8uZm9jdXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRvbUNvbnRlbnRMb2FkZWQoKSB7XG4gICAgICAgIE5lby5jb25maWcuYXBwbHlCb2R5Q2xzICYmIHRoaXMuYXBwbHlCb2R5Q2xzKHtjbHM6IFsnbmVvLWJvZHknXX0pO1xuICAgICAgICBOZW8uY29uZmlnLmFwcGx5Rml4ZWRQb3NpdGlvblRvSHRtbFRhZyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ3Bvc2l0aW9uJywgJ2ZpeGVkJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubm9kZUlkXG4gICAgICovXG4gICAgb25HZXRPZmZzY3JlZW5DYW52YXMoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgICAgICA9IG1lLmdldEVsZW1lbnQoZGF0YS5ub2RlSWQpLFxuICAgICAgICAgICAgb2Zmc2NyZWVuID0gbm9kZS50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpO1xuXG4gICAgICAgIGRhdGEub2Zmc2NyZWVuID0gb2Zmc2NyZWVuO1xuXG4gICAgICAgIE5lby53b3JrZXIuTWFuYWdlci5zZW5kTWVzc2FnZShkYXRhLm9yaWdpbiwge1xuICAgICAgICAgICAgYWN0aW9uIDogJ3JlcGx5JyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZXBseUlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICB9LCBbb2Zmc2NyZWVuXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGRhdGEuYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEuZnVuY3Rpb25zIEFuIGFycmF5IGNvbnRhaW5pbmcgc3RyaW5ncyBhbmQvb3Igb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGRhdGEuc3R5bGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudm5vZGVJZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblJlYWREb20oZGF0YSkge1xuICAgICAgICBsZXQgYXR0cmlidXRlcyAgICA9IGRhdGEuYXR0cmlidXRlcyB8fCBbXSxcbiAgICAgICAgICAgIGZ1bmN0aW9ucyAgICAgPSBkYXRhLmZ1bmN0aW9ucyAgfHwgW10sXG4gICAgICAgICAgICBzdHlsZXMgICAgICAgID0gZGF0YS5zdHlsZXMgICAgIHx8IFtdLFxuICAgICAgICAgICAge3Zub2RlSWR9ICAgICA9IGRhdGEsXG4gICAgICAgICAgICByZXRBdHRyaWJ1dGVzID0ge30sXG4gICAgICAgICAgICByZXRGdW5jdGlvbnMgID0ge30sXG4gICAgICAgICAgICByZXRTdHlsZXMgICAgID0ge30sXG4gICAgICAgICAgICBlbGVtZW50ICAgICAgID0gdm5vZGVJZCA/IHRoaXMuZ2V0RWxlbWVudCh2bm9kZUlkKSA6IG51bGwsXG4gICAgICAgICAgICBmbk5hbWUsIHNjb3BlO1xuXG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgcmV0QXR0cmlidXRlc1trZXldID0gZWxlbWVudFtrZXldXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9ucy5mb3JFYWNoKChrZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBrZXkucGFyYW1zICAgICAgICAgPSBrZXkucGFyYW1zICAgICAgICAgfHwgW107XG4gICAgICAgICAgICAgICAga2V5LnBhcmFtSXNEb21Ob2RlID0ga2V5LnBhcmFtSXNEb21Ob2RlIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUgPSBrZXkuc2NvcGUgPyBkb2N1bWVudFtrZXkuc2NvcGVdIDogZWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGtleS5wYXJhbXMuZm9yRWFjaCgocGFyYW0sIHBhcmFtSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5wYXJhbUlzRG9tTm9kZVtwYXJhbUluZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LnBhcmFtc1twYXJhbUluZGV4XSA9IHRoaXMuZ2V0RWxlbWVudChrZXkucGFyYW1zW3BhcmFtSW5kZXhdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBrZXkucmV0dXJuRm5OYW1lID8ga2V5LnJldHVybkZuTmFtZSA6IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldEZ1bmN0aW9uc1tmbk5hbWVdID0gc2NvcGVba2V5LmZuXSguLi5rZXkucGFyYW1zKTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkucmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0RnVuY3Rpb25zW2ZuTmFtZV0gPSByZXRGdW5jdGlvbnNbZm5OYW1lXVtrZXkucmV0dXJuVmFsdWVdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRGdW5jdGlvbnNba2V5XSA9IGVsZW1lbnRba2V5XSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICByZXRTdHlsZXNba2V5XSA9IGVsZW1lbnQuc3R5bGVba2V5XVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHJldEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBmdW5jdGlvbnMgOiByZXRGdW5jdGlvbnMsXG4gICAgICAgICAgICBzdHlsZXMgICAgOiByZXRTdHlsZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgTmVvLndvcmtlci5NYW5hZ2VyLnNlbmRNZXNzYWdlKGRhdGEub3JpZ2luLCB7XG4gICAgICAgICAgICBhY3Rpb24gOiAncmVwbHknLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJlcGx5SWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YS50YXJnZXRcbiAgICAgKiBAcGFyYW0gZGF0YS5yZWxhdGVkVGFyZ2V0XG4gICAgICovXG4gICAgb25UcmFwcGVkRm9jdXNNb3ZlbWVudCh7IHRhcmdldCwgcmVsYXRlZFRhcmdldCB9KSB7XG4gICAgICAgIGNvbnN0IGJhY2t3YXJkcyA9IHJlbGF0ZWRUYXJnZXQgJiYgKHRhcmdldC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihyZWxhdGVkVGFyZ2V0KSAmIDQpO1xuXG4gICAgICAgIGlmICh0YXJnZXQubWF0Y2hlcygnLm5lby1mb2N1cy10cmFwJykpIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgY29udGFpbmluZ0VlbWVudCA9IHRhcmdldC5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHRyZWVXYWxrZXIgICAgICAgPSBjb250YWluaW5nRWVtZW50LiR0cmVlV2Fsa2VyLFxuICAgICAgICAgICAgICAgIHRvcEZvY3VzVHJhcCAgICAgPSBjb250YWluaW5nRWVtZW50LiR0b3BGb2N1c1RyYXAsXG4gICAgICAgICAgICAgICAgYm90dG9tRm9jdXNUcmFwICA9IGNvbnRhaW5pbmdFZW1lbnQuJGJvdHRvbUZvY3VzVHJhcDtcblxuICAgICAgICAgICAgdHJlZVdhbGtlci5jdXJyZW50Tm9kZSA9IGJhY2t3YXJkcyA/IGJvdHRvbUZvY3VzVHJhcCA6IHRvcEZvY3VzVHJhcDtcbiAgICAgICAgICAgIHRyZWVXYWxrZXJbYmFja3dhcmRzID8gJ3ByZXZpb3VzTm9kZScgOiAnbmV4dE5vZGUnXSgpO1xuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdHJlZVdhbGtlci5jdXJyZW50Tm9kZS5mb2N1cygpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVhZChkYXRhKSB7XG4gICAgICAgIE5lby5pc0Z1bmN0aW9uKGRhdGEpICYmIGRhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbnkgRE9NIHNpemluZyBjb25maWdzIHRvIHRoZSBsYXN0IGV4dGVybmFsbHkgY29uZmlndXJlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZCBkdXJpbmcgYWxpZ25pbmcgdG8gcmVsZWFzZSBhbnkgY29uc3RyYWludHMgYXBwbGllZCBieSBhIHByZXZpb3VzIGFsaWdubWVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWxpZ25cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVzZXREaW1lbnNpb25zKGFsaWduKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5nZXRFbGVtZW50KGFsaWduLmlkKS5zdHlsZSwge1xuICAgICAgICAgICAgZmxleCAgICAgOiBhbGlnbi5jb25maWd1cmVkRmxleCxcbiAgICAgICAgICAgIGhlaWdodCAgIDogYWxpZ24uY29uZmlndXJlZEhlaWdodCxcbiAgICAgICAgICAgIG1heEhlaWdodDogYWxpZ24uY29uZmlndXJlZE1heEhlaWdodCxcbiAgICAgICAgICAgIG1heFdpZHRoIDogYWxpZ24uY29uZmlndXJlZE1heFdpZHRoLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiBhbGlnbi5jb25maWd1cmVkTWluSGVpZ2h0LFxuICAgICAgICAgICAgbWluV2lkdGggOiBhbGlnbi5jb25maWd1cmVkTWluV2lkdGgsXG4gICAgICAgICAgICB3aWR0aCAgICA6IGFsaWduLmNvbmZpZ3VyZWRXaWR0aFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2Nyb2xsQnlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmJlaGF2aW9yPSdhdXRvJyBhdXRvLCBpbnN0YW50LCBzbW9vdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5kaXJlY3Rpb249J3RvcCcgbGVmdCwgdG9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS52YWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9iai5pZCA9PiB0aGUgcGFzc2VkIGlkXG4gICAgICovXG4gICAgc2Nyb2xsQnkoe2JlaGF2aW9yPSdhdXRvJywgZGlyZWN0aW9uPSd0b3AnLCBpZCwgdmFsdWV9KSB7XG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudChpZCk/LnNjcm9sbEJ5KHtiZWhhdmlvciwgW2RpcmVjdGlvbl06IHZhbHVlfSk7XG4gICAgICAgIHJldHVybiB7aWR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBlaXRoZXIgcGFzcyB0aGUgaWQgb3IgYSBxdWVyeVNlbGVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEuaWRdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYmVoYXZpb3I9J3Ntb290aCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5ibG9jaz0nc3RhcnQnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuZGVsYXk9NTAwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaW5saW5lPSduZWFyZXN0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5xdWVyeVNlbGVjdG9yXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcoe2lkLCBiZWhhdmlvcj0nc21vb3RoJywgYmxvY2s9J3N0YXJ0JywgZGVsYXk9NTAwLCBpbmxpbmU9J25lYXJlc3QnLCBxdWVyeVNlbGVjdG9yfSkge1xuICAgICAgICBsZXQgbm9kZSA9IGlkID8gdGhpcy5nZXRFbGVtZW50KGlkKSA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnlTZWxlY3RvciksXG4gICAgICAgICAgICBvcHRzID0ge2JlaGF2aW9yLCBibG9jaywgaW5saW5lfTtcblxuICAgICAgICBpZiAoYmVoYXZpb3IgIT09ICdzbW9vdGgnKSB7XG4gICAgICAgICAgICBub2RlLnNjcm9sbEludG9WaWV3KG9wdHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzY3JvbGxJbnRvVmlldygpIGRvZXMgbm90IHByb3ZpZGUgYSBjYWxsYmFjayB5ZXQuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvY3Nzd2ctZHJhZnRzL2lzc3Vlcy8zNzQ0XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc0xpc3RlbmVyID0gJ3Njcm9sbGVuZCcgaW4gd2luZG93O1xuXG4gICAgICAgICAgICAgICAgICAgIGhhc0xpc3RlbmVyICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbGVuZCcsICgpID0+IHJlc29sdmUoKSwge2NhcHR1cmU6IHRydWUsIG9uY2U6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLnNjcm9sbEludG9WaWV3KG9wdHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICFoYXNMaXN0ZW5lciAmJiB0aGlzLnRpbWVvdXQoZGVsYXkpLnRoZW4oKCkgPT4ge3Jlc29sdmUoKX0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2Nyb2xsVG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmJlaGF2aW9yPSdhdXRvJyBhdXRvLCBpbnN0YW50LCBzbW9vdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5kaXJlY3Rpb249J3RvcCcgbGVmdCwgdG9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS52YWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9iai5pZCA9PiB0aGUgcGFzc2VkIGlkXG4gICAgICovXG4gICAgc2Nyb2xsVG8oe2JlaGF2aW9yPSdhdXRvJywgZGlyZWN0aW9uPSd0b3AnLCBpZCwgdmFsdWV9KSB7XG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudChpZCk/LnNjcm9sbFRvKHtiZWhhdmlvciwgW2RpcmVjdGlvbl06IHZhbHVlfSk7XG4gICAgICAgIHJldHVybiB7aWR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmJlaGF2aW9yPSdzbW9vdGgnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEub2Zmc2V0PTM0XG4gICAgICogQHJldHVybnMge09iamVjdH0gb2JqLmlkID0+IHRoZSBwYXNzZWQgaWRcbiAgICAgKi9cbiAgICBzY3JvbGxUb1RhYmxlUm93KHtpZCwgYmVoYXZpb3I9J3Ntb290aCcsIG9mZnNldD0zNH0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmdldEVsZW1lbnQoaWQpOyAvLyB0ciB0YWdcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbGV0IHRhYmxlTm9kZSAgID0gbm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgd3JhcHBlck5vZGUgPSB0YWJsZU5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICB0YWJsZVRvcCAgICA9IHRhYmxlTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AsXG4gICAgICAgICAgICAgICAgdG9wICAgICAgICAgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcblxuICAgICAgICAgICAgd3JhcHBlck5vZGUuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIHRvcDogdG9wIC0gdGFibGVUb3AgLSBvZmZzZXRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge2lkfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEuc3RhcnQ9MF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEuZW5kPTk5OTk5XVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9iai5pZCA9PiB0aGUgcGFzc2VkIGlkXG4gICAgICovXG4gICAgc2VsZWN0Tm9kZShkYXRhKSB7XG4gICAgICAgIGxldCBub2RlICA9IHRoaXMuZ2V0RWxlbWVudChkYXRhLmlkKSxcbiAgICAgICAgICAgIHN0YXJ0ID0gTmVvLmlzTnVtYmVyKGRhdGEuc3RhcnQpID8gZGF0YS5zdGFydCA6IDAsXG4gICAgICAgICAgICBlbmQgICA9IE5lby5pc051bWJlcihkYXRhLmVuZCkgICA/IGRhdGEuZW5kICAgOiA5OTk5OTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIG5vZGUuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7aWQ6IGRhdGEuaWR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBkYXRhLmFkZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucmVtb3ZlXG4gICAgICovXG4gICAgc2V0Qm9keUNscyhkYXRhKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSguLi5kYXRhLnJlbW92ZSB8fCBbXSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCguLi5kYXRhLmFkZCB8fCBbXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3QgcmVjb21tZW5kZWQgdG8gdXNlID0+IHN0aWNrIHRvIHZkb20gdXBkYXRlcy5cbiAgICAgKiBDYW4gYmUgaGFuZHkgZm9yIGN1c3RvbSBDU1MgYmFzZWQgYW5pbWF0aW9ucyB0aG91Z2guXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZCBBIG5vZGUgaWQgb3IgJ2RvY3VtZW50LmJvZHknXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEuc3R5bGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmouaWQgPT4gdGhlIHBhc3NlZCBpZFxuICAgICAqL1xuICAgIHNldFN0eWxlKGRhdGEpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmdldEVsZW1lbnRPckJvZHkoZGF0YS5pZCk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRhdGEuc3R5bGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLmluY2x1ZGVzKCchaW1wb3J0YW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCchaW1wb3J0YW50JywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShOZW8uZGVjYW1lbChrZXkpLCB2YWx1ZSwgJ2ltcG9ydGFudCcpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtOZW8uZGVjYW1lbChrZXkpXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7aWQ6IGRhdGEuaWR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBzeW5jQWxpZ25zKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtfYWxpZ25zfSA9IG1lO1xuXG4gICAgICAgIC8vIEtlZXAgYWxsIHJlZ2lzdGVyZWQgYWxpZ25zIGFsaWduZWQgb24gYW55IGRldGVjdGVkIGNoYW5nZVxuICAgICAgICBfYWxpZ25zPy5mb3JFYWNoKGFsaWduID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFByZXNlbnQgPSBkb2N1bWVudC5jb250YWlucyhhbGlnbi50YXJnZXRFbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gQWxpZ24gc3ViamVjdCBhbmQgdGFyZ2V0IHN0aWxsIGluIHRoZSBET00gLSBjb3JyZWN0IGl0cyBhbGlnbm1lbnRcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5jb250YWlucyhhbGlnbi5zdWJqZWN0KSAmJiB0YXJnZXRQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgbWUuYWxpZ24oYWxpZ24pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGlnbiBzdWJqZWN0IG9yIHRhcmdldCBubyBsb25nZXIgaW4gdGhlIERPTSAtIHJlbW92ZSBpdC5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRhcmdldCBpcyBubyBsb25nZXIgaW4gdGhlIERPTSwgaGlkZSB0aGUgc3ViamVjdCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvLndvcmtlci5BcHAuc2V0Q29uZmlncyh7IGlkOiBhbGlnbi5pZCwgaGlkZGVuOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAge19hbGlnblJlc2l6ZU9ic2VydmVyfSA9IG1lLFxuICAgICAgICAgICAgICAgICAgICB7Y29uc3RyYWluVG9FbGVtZW50fSAgID0gYWxpZ247XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9wIG9ic2VydmluZyB0aGUgYWxpZ24gZWxlbWVudHNcbiAgICAgICAgICAgICAgICBfYWxpZ25SZXNpemVPYnNlcnZlci51bm9ic2VydmUoYWxpZ24uc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgX2FsaWduUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGFsaWduLm9mZnNldFBhcmVudCk7XG4gICAgICAgICAgICAgICAgX2FsaWduUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGFsaWduLnRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW5Ub0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2FsaWduUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGNvbnN0cmFpblRvRWxlbWVudClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgbGFzdCBhbGlnbmVkIGNsYXNzLlxuICAgICAgICAgICAgICAgIGFsaWduLnN1YmplY3QuY2xhc3NMaXN0LnJlbW92ZShgbmVvLWFsaWduZWQtJHthbGlnbi5yZXN1bHQ/LnBvc2l0aW9ufWApO1xuXG4gICAgICAgICAgICAgICAgX2FsaWducy5kZWxldGUoYWxpZ24uaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5tb2RhbFxuICAgICAqL1xuICAgIHN5bmNNb2RhbE1hc2soeyBpZCwgbW9kYWwgfSkge1xuICAgICAgICBjb25zdCBlbCA9IGlkICYmIHRoaXMuZ2V0RWxlbWVudChpZCk7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIHZpc2libGUgYW5kIG1vZGFsLCB0aGUgbWFzayBuZWVkcyB0byBiZSBqdXN0IGJlbG93IHRoaXMgZWxlbWVudC5cbiAgICAgICAgaWYgKGVsICYmIG1vZGFsICYmIGVsLm93bmVyRG9jdW1lbnQuY29udGFpbnMoZWwpICYmIGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHRoaXMubW9kYWxNYXNrLCBlbClcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBtYXNrIG5lZWRzIHRvIGJlIGJlbG93IHRoZSBuZXh0IHRvcG1vc3QgbW9kYWwgZGlhbG9nIGlmIHBvc3NpYmxlLCBvciBoaWRkZW5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIG1vZGFscyAgICAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5uZW8tbW9kYWwnKSxcbiAgICAgICAgICAgICAgICB0b3Btb3N0TW9kYWwgPSBtb2RhbHNbbW9kYWxzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBtYXNrIHVuZGVyIHRoZSBuZXh0IHRvcG1vc3QgbW9kYWwgbm93IG1vZGFsIFwiaWRcIiBpcyBnb25lLlxuICAgICAgICAgICAgaWYgKHRvcG1vc3RNb2RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY01vZGFsTWFzayh7IGlkOiB0b3Btb3N0TW9kYWwuaWQsIG1vZGFsOiB0cnVlIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGFsTWFzaz8ucmVtb3ZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXBzIChvciBzdG9wcyB0cmFwcGluZykgZm9jdXMgd2l0aGluIGEgQ29tcG9uZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZCBUaGUgQ29tcG9uZW50IHRvIHRyYXAgZm9jdXMgd2l0aGluLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEudHJhcD10cnVlXSBQYXNzIGBmYWxzZWAgdG8gc3RvcCB0cmFwcGluZyBmb2N1cyBpbnNpZGUgdGhlIENvbXBvbmVudC5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFwRm9jdXMoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvblRyYXBwZWRGb2N1c01vdmVtZW50ID0gbWUuJGJvdW5kT25UcmFwcGVkRm9jdXNNb3ZlbWVudCB8fCAobWUuJGJvdW5kT25UcmFwcGVkRm9jdXNNb3ZlbWVudCA9IG1lLm9uVHJhcHBlZEZvY3VzTW92ZW1lbnQuYmluZChtZSkpLFxuICAgICAgICAgICAgc3ViamVjdCAgICAgICAgICAgICAgICA9IGRhdGEuc3ViamVjdCA9IG1lLmdldEVsZW1lbnQoZGF0YS5pZCksXG4gICAgICAgICAgICB7IHRyYXAgPSB0cnVlIH0gICAgICAgID0gZGF0YTtcblxuICAgICAgICAvLyBDYWxsZWQgYmVmb3JlIERPTSBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRvcEZvY3VzVHJhcCAgICA9IHN1YmplY3QuJHRvcEZvY3VzVHJhcCxcbiAgICAgICAgICAgIGJvdHRvbUZvY3VzVHJhcCA9IHN1YmplY3QuJGJvdHRvbUZvY3VzVHJhcDtcblxuICAgICAgICBpZiAodHJhcCkge1xuICAgICAgICAgICAgaWYgKCFzdWJqZWN0LiR0cmVlV2Fsa2VyKSB7XG4gICAgICAgICAgICAgICAgc3ViamVjdC4kdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoc3ViamVjdCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0Tm9kZTogZmlsdGVyVGFiYmFibGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0b3BGb2N1c1RyYXAgPSBzdWJqZWN0LiR0b3BGb2N1c1RyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBib3R0b21Gb2N1c1RyYXAgPSBzdWJqZWN0LiRib3R0b21Gb2N1c1RyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSB0d28gZm9jdXMgdHJhcHBpbmcgZWxlbWVudHMgbXVzdCBiZSBpbnZpc2libGUgYnV0IHRhYmJhYmxlLlxuICAgICAgICAgICAgICAgIHRvcEZvY3VzVHJhcC5jbGFzc05hbWUgPSBib3R0b21Gb2N1c1RyYXAuY2xhc3NOYW1lID0gJ25lby1mb2N1cy10cmFwJztcbiAgICAgICAgICAgICAgICB0b3BGb2N1c1RyYXAuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIDApO1xuICAgICAgICAgICAgICAgIGJvdHRvbUZvY3VzVHJhcC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIHdoZW4gdGhleSBnYWluIGZvY3VzIGFuZCB3cmFwIGZvY3VzIHdpdGhpbiB0aGUgZW5jYXBzdWxhdGluZyBlbGVtZW50XG4gICAgICAgICAgICAgICAgc3ViamVjdC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25UcmFwcGVkRm9jdXNNb3ZlbWVudClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRlbnQgaXMgZW5jYXBzdWxhdGVkIGJ5IHRoZSBmb2N1cyB0cmFwIGVsZW1lbnRzXG4gICAgICAgICAgICBzdWJqZWN0Lmluc2VydEJlZm9yZSh0b3BGb2N1c1RyYXAsIHN1YmplY3QuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICBzdWJqZWN0LmFwcGVuZENoaWxkKGJvdHRvbUZvY3VzVHJhcClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uVHJhcHBlZEZvY3VzTW92ZW1lbnQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5iZWhhdmlvcj0nc21vb3RoJ10gLy8gYXV0byBvciBzbW9vdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEubGVmdD0wXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS50b3A9MF1cbiAgICAgKi9cbiAgICB3aW5kb3dTY3JvbGxUbyhkYXRhKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh7XG4gICAgICAgICAgICBiZWhhdmlvcjogZGF0YS5iZWhhdmlvciB8fCAnc21vb3RoJyxcbiAgICAgICAgICAgIGxlZnQgICAgOiBkYXRhLmxlZnQgICAgIHx8IDAsXG4gICAgICAgICAgICB0b3AgICAgIDogZGF0YS50b3AgICAgICB8fCAwXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEb21BY2Nlc3MpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFN0cmluZ1V0aWwgICAgIGZyb20gJy4uL3V0aWwvU3RyaW5nLm1qcyc7XG5pbXBvcnQgVG91Y2hEb21FdmVudHMgZnJvbSAnLi9taXhpbi9Ub3VjaERvbUV2ZW50cy5tanMnO1xuXG5jb25zdCBnbG9iYWxEb21FdmVudHMgPSBbXG4gICAge25hbWU6ICdjaGFuZ2UnLCAgICAgIGhhbmRsZXI6ICdvbkNoYW5nZSd9LFxuICAgIHtuYW1lOiAnY2xpY2snLCAgICAgICBoYW5kbGVyOiAnb25DbGljayd9LFxuICAgIHtuYW1lOiAnY29udGV4dG1lbnUnLCBoYW5kbGVyOiAnb25Db250ZXh0TWVudSd9LFxuICAgIHtuYW1lOiAnZGJsY2xpY2snLCAgICBoYW5kbGVyOiAnb25Eb3VibGVDbGljayd9LFxuICAgIHtuYW1lOiAnZm9jdXNpbicsICAgICBoYW5kbGVyOiAnb25Gb2N1c0luJ30sXG4gICAge25hbWU6ICdmb2N1c291dCcsICAgIGhhbmRsZXI6ICdvbkZvY3VzT3V0J30sXG4gICAge25hbWU6ICdpbnB1dCcsICAgICAgIGhhbmRsZXI6ICdvbkNoYW5nZSd9LFxuICAgIHtuYW1lOiAna2V5ZG93bicsICAgICBoYW5kbGVyOiAnb25LZXlEb3duJ30sXG4gICAge25hbWU6ICdrZXl1cCcsICAgICAgIGhhbmRsZXI6ICdvbktleVVwJ30sXG4gICAge25hbWU6ICdtb3VzZWRvd24nLCAgIGhhbmRsZXI6ICdvbk1vdXNlRG93bid9LFxuICAgIHtuYW1lOiAnbW91c2VlbnRlcicsICBoYW5kbGVyOiAnb25Nb3VzZUVudGVyJywgb3B0aW9uczoge2NhcHR1cmU6IHRydWV9fSxcbiAgICB7bmFtZTogJ21vdXNlbGVhdmUnLCAgaGFuZGxlcjogJ29uTW91c2VMZWF2ZScsIG9wdGlvbnM6IHtjYXB0dXJlOiB0cnVlfX0sXG4gICAge25hbWU6ICdtb3VzZXVwJywgICAgIGhhbmRsZXI6ICdvbk1vdXNlVXAnfSxcbiAgICB7bmFtZTogJ3Njcm9sbCcsICAgICAgaGFuZGxlcjogJ29uU2Nyb2xsJywgICAgIG9wdGlvbnM6IHtjYXB0dXJlOiB0cnVlfX0sXG4gICAge25hbWU6ICd3aGVlbCcsICAgICAgIGhhbmRsZXI6ICdvbldoZWVsJywgICAgICBvcHRpb25zOiB7cGFzc2l2ZTogZmFsc2V9fVxuXTtcblxuLy8gV2lsbCBnZXQgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQuYm9keSBpbiBjYXNlIE5lby5jb25maWcuaGFzVG91Y2hFdmVudHMgPT09IHRydWVcbmNvbnN0IHRvdWNoRXZlbnRzID0gW1xuICAgIHtuYW1lOiAndG91Y2hjYW5jZWwnLCBoYW5kbGVyOiAnb25Ub3VjaENhbmNlbCd9LFxuICAgIHtuYW1lOiAndG91Y2hlbmQnLCAgICBoYW5kbGVyOiAnb25Ub3VjaEVuZCd9LFxuICAgIHtuYW1lOiAndG91Y2hlbnRlcicsICBoYW5kbGVyOiAnb25Ub3VjaEVudGVyJ30sXG4gICAge25hbWU6ICd0b3VjaGxlYXZlJywgIGhhbmRsZXI6ICdvblRvdWNoTGVhdmUnfSxcbiAgICB7bmFtZTogJ3RvdWNobW92ZScsICAgaGFuZGxlcjogJ29uVG91Y2hNb3ZlJywgb3B0aW9uczoge3Bhc3NpdmU6IGZhbHNlfX0sXG4gICAge25hbWU6ICd0b3VjaHN0YXJ0JywgIGhhbmRsZXI6ICdvblRvdWNoU3RhcnQnfVxuXTtcblxuLy8gd2hlZWwgZXZlbnRzIGZpcmUgdmVyeSBvZnRlbiwgc28gd2UgbGltaXQgdGhlIHRhcmdldHMgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcG9zdCBtZXNzYWdlcyBmcm9tIG1haW4gdG8gdGhlIGFwcCB3b3JrZXJcbmNvbnN0IGdsb2JhbFdoZWVsVGFyZ2V0cyA9IFtcbiAgICAnbmVvLWMtbS1zY3JvbGxjb250YWluZXInLFxuICAgICduZW8tYy13LXNjcm9sbGNvbnRhaW5lcicsXG4gICAgJ25lby1jYWxlbmRhci15ZWFyY29tcG9uZW50JyxcbiAgICAnbmVvLWNpcmNsZS1jb21wb25lbnQnLFxuICAgICduZW8tZGF0ZXNlbGVjdG9yJyxcbiAgICAnbmVvLWdhbGxlcnknLFxuICAgICduZW8taGVsaXgnXG5dO1xuXG4vLyBzZXBhcmF0ZWQgZnJvbSBnbG9iYWxXaGVlbFRhcmdldHMgPT4gcGVyZm9ybWFuY2Vcbi8vIGJ1ZmZlciBpbiBtc1xuY29uc3QgZ2xvYmFsV2hlZWxUYXJnZXRzQnVmZmVyID0ge1xuICAgICduZW8tYy1tLXNjcm9sbGNvbnRhaW5lcicgICA6IDEwMCxcbiAgICAnbmVvLWMtdy1zY3JvbGxjb250YWluZXInICAgOiAxMDAsXG4gICAgJ25lby1jYWxlbmRhci15ZWFyY29tcG9uZW50JzogMzAwLFxuICAgICduZW8tZGF0ZXNlbGVjdG9yJyAgICAgICAgICA6IDMwMFxufTtcblxuLy8gc2VwYXJhdGVkIGZyb20gZ2xvYmFsV2hlZWxUYXJnZXRzID0+IHBlcmZvcm1hbmNlXG5jb25zdCBnbG9iYWxXaGVlbFRhcmdldHNLZWVwRXZlbnQgPSBbXG4gICAgJ25lby1jLW0tc2Nyb2xsY29udGFpbmVyJyxcbiAgICAnbmVvLWMtdy1zY3JvbGxjb250YWluZXInXG5dO1xuXG5jb25zdCBsYXN0V2hlZWxFdmVudCA9IHtcbiAgICBkYXRlICA6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsXG59O1xuXG5jb25zdFxuICAgIGRpc2FibGVkSW5wdXRLZXlzICAgICAgICAgPSB7fSxcbiAgICBwcmV2ZW50Q2xpY2tUYXJnZXRzICAgICAgID0gW10sXG4gICAgcHJldmVudENvbnRleHRtZW51VGFyZ2V0cyA9IFtdO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFpbi5Eb21FdmVudHNcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRG9tRXZlbnRzIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uRG9tRXZlbnRzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFpbi5Eb21FdmVudHMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdG9kbzogY29uZGl0aW9uYWwgZHluYW1pYyBpbXBvcnQgb25jZSB0aGUgYnVpbGQgcHJvY2Vzc2VzIGNhbiBoYW5kbGUgaXRcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IG1peGlucz1bVG91Y2hEb21FdmVudHNdXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbnM6IFtUb3VjaERvbUV2ZW50c10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgd29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdhZGREb21MaXN0ZW5lcicsXG4gICAgICAgICAgICAgICAgJ3JlZ2lzdGVyRGlzYWJsZWRJbnB1dENoYXJzJyxcbiAgICAgICAgICAgICAgICAncmVnaXN0ZXJQcmV2ZW50RGVmYXVsdFRhcmdldHMnLFxuICAgICAgICAgICAgICAgICd1bnJlZ2lzdGVyRGlzYWJsZWRJbnB1dENoYXJzJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHRvdWNoXG4gICAgICovXG4gICAgbGFzdFRvdWNoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgIG1lLm9uRG9tQ29udGVudExvYWRlZCAuYmluZChtZSkpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCAgIG1lLm9uU2VsZWN0aW9uQ2hhbmdlICAuYmluZChtZSkpO1xuICAgICAgICB3aW5kb3cgIC5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG1lLm9uT3JpZW50YXRpb25DaGFuZ2UuYmluZChtZSkpO1xuICAgICAgICB3aW5kb3cgIC5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgICAgICAgIG1lLm9uSGFzaENoYW5nZSAgICAgICAuYmluZChtZSkpO1xuXG4gICAgICAgIGlmIChOZW8uY29uZmlnLnVzZVNoYXJlZFdvcmtlcnMpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBtZS5vbkJlZm9yZVVubG9hZC5iaW5kKG1lKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYWRkRG9tTGlzdGVuZXIoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgPSBkYXRhLmV2ZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBmYWlsZWRJZCA9IG51bGwsXG4gICAgICAgICAgICBldmVudCwgaWQsIHRhcmdldE5vZGU7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZXZlbnQgPSBkYXRhLmV2ZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKCFtZVtldmVudC5oYW5kbGVyXSkge1xuICAgICAgICAgICAgICAgIG1lW2V2ZW50LmhhbmRsZXJdID0gTmVvLmVtcHR5Rm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWQgPSBldmVudC52bm9kZUlkIHx8IGRhdGEudm5vZGVJZDtcblxuICAgICAgICAgICAgaWYgKGlkID09PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gZG9jdW1lbnQuYm9keVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uY29uZmlnLnVzZURvbUlkcykge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLW5lby1pZD0nJHtpZH0nXWApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50Lm5hbWUsIG1lW2V2ZW50LmhhbmRsZXJdLmJpbmQobWUpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWlsZWRJZCA9IGlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmFpbGVkSWQgJiYgTmVvLmNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEb21FdmVudHM6YWRkRG9tTGlzdGVuZXIoKSA9PiB0YXJnZXQgbm9kZSBub3QgZm91bmQ6JywgZmFpbGVkSWQpXG4gICAgICAgIH1cblxuICAgICAgICBOZW8ud29ya2VyLk1hbmFnZXIuc2VuZE1lc3NhZ2UoZGF0YS5vcmlnaW4sIHtcbiAgICAgICAgICAgIGFjdGlvbiA6ICdyZXBseScsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVwbHlJZDogZGF0YS5pZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6ICFmYWlsZWRJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkR2xvYmFsRG9tTGlzdGVuZXJzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIFsuLi5nbG9iYWxEb21FdmVudHNdLmNvbmNhdChOZW8uY29uZmlnLmhhc1RvdWNoRXZlbnRzID8gdG91Y2hFdmVudHMgOiBbXSkuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQubmFtZSwgbWVbZXZlbnQuaGFuZGxlcl0uYmluZChtZSksIGV2ZW50Lm9wdGlvbnMpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvY2FsIGRvbUV2ZW50IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBkb21FdmVudExpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dGFyZ2V0fSA9IGV2ZW50LFxuXG4gICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uICAgOiAnZG9tRXZlbnQnLFxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogZXZlbnQudHlwZSxcblxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZ2V0RXZlbnREYXRhKGV2ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IHRhcmdldC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLmRhdGEsIG1lLmdldE1vdXNlRXZlbnREYXRhKGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgTmVvLndvcmtlci5NYW5hZ2VyLnNlbmRNZXNzYWdlKCdhcHAnLCBjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZUFyaWFBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICAgICAgbGV0IGFyaWFBdHRyaWJ1dGVzID0ge30sXG4gICAgICAgICAgICB7YXR0cmlidXRlc30gICA9IG5vZGUsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgICA9IGF0dHJpYnV0ZXM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgYXR0cmlidXRlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUubmFtZS5zdGFydHNXaXRoKCdhcmlhLScpKSB7XG4gICAgICAgICAgICAgICAgYXJpYUF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWUuc3Vic3RyaW5nKDUpXSA9IGF0dHJpYnV0ZS52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyaWFBdHRyaWJ1dGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB4MSBUaGUgWCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkxIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludFxuICAgICAqIEBwYXJhbSAge051bWJlcn0geDIgVGhlIFggcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludFxuICAgICAqIEBwYXJhbSAge051bWJlcn0geTIgVGhlIFkgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiogMiArICh5MiAtIHkxKSAqKiAyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRFdmVudERhdGEoZXZlbnQpIHtcbiAgICAgICAgbGV0IHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAvLyBvdXIgZHJhZ2dhYmxlIGltcGxlbWVudGF0aW9uIHdpbGwgZ2VuZXJhdGUgcGF0aHMsIHNvIHdlIGRvIG5lZWQgdG8gY2hlY2sgZm9yIHRoZW1cbiAgICAgICAgICAgIHBhdGggPSBldmVudC5wYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgcGF0aCAgICAgOiBwYXRoLm1hcChlID0+IHRoaXMuZ2V0VGFyZ2V0RGF0YShlKSksXG4gICAgICAgICAgICB0YXJnZXQgICA6IHRoaXMuZ2V0VGFyZ2V0RGF0YShldmVudC50YXJnZXQpLFxuICAgICAgICAgICAgdGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAsXG4gICAgICAgICAgICB0eXBlICAgICA6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICBkYXRhICAgICA6IHsuLi5ldmVudC50YXJnZXQuZGF0YXNldH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbGF0ZWRUYXJnZXQgPSB0aGlzLmdldFRhcmdldERhdGEoZXZlbnQucmVsYXRlZFRhcmdldClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRLZXlib2FyZEV2ZW50RGF0YShldmVudCkge1xuICAgICAgICBsZXQge2FsdEtleSwgY29kZSwgY3RybEtleSwga2V5LCBrZXlDb2RlLCBtZXRhS2V5LCBzaGlmdEtleX0gPSBldmVudDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5nZXRFdmVudERhdGEoZXZlbnQpLFxuICAgICAgICAgICAgYWx0S2V5LFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIGN0cmxLZXksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBrZXlDb2RlLFxuICAgICAgICAgICAgbWV0YUtleSxcbiAgICAgICAgICAgIHNoaWZ0S2V5XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRNb3VzZUV2ZW50RGF0YShldmVudCkge1xuICAgICAgICBsZXQge2FsdEtleSwgY2xpZW50WCwgY2xpZW50WSwgY3RybEtleSwgZGV0YWlsLCBtZXRhS2V5LCBvZmZzZXRYLCBvZmZzZXRZLCBwYWdlWCwgcGFnZVksIHNjcmVlblgsIHNjcmVlblksIHNoaWZ0S2V5fSA9IGV2ZW50O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLmdldEV2ZW50RGF0YShldmVudCksXG4gICAgICAgICAgICBhbHRLZXksXG4gICAgICAgICAgICBjbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICAgIGN0cmxLZXksXG4gICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgICBtZXRhS2V5LFxuICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFksXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZLFxuICAgICAgICAgICAgc2NyZWVuWCxcbiAgICAgICAgICAgIHNjcmVlblksXG4gICAgICAgICAgICBzaGlmdEtleVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAgICAgKi9cbiAgICBnZXRQYXRoRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuXG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHBhdGhcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uUGF0aChwYXRoLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlICYmIHRhcmdldC5pZC5zcGxpdCgnX18nKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5nZXRTZWxlY3Rpb25QYXRoKHBhdGgsIHRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGgucHVzaCh0aGlzLmdldFRhcmdldERhdGEodGFyZ2V0KSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRUYXJnZXREYXRhKG5vZGUpIHtcbiAgICAgICAgbGV0IHIgICAgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdD8uKCksXG4gICAgICAgICAgICByZWN0ID0gciAmJiB0aGlzLnBhcnNlRG9tUmVjdChyKSB8fCB7fTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJpYSAgICAgICAgICAgICA6IHRoaXMuZ2VBcmlhQXR0cmlidXRlcyhub2RlKSxcbiAgICAgICAgICAgIGNoZWNrZWQgICAgICAgICAgOiBub2RlLmNoZWNrZWQsXG4gICAgICAgICAgICBjaGlsZEVsZW1lbnRDb3VudDogbm9kZS5jaGlsZEVsZW1lbnRDb3VudCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodCAgICAgOiBub2RlLmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgIGNsaWVudExlZnQgICAgICAgOiBub2RlLmNsaWVudExlZnQsXG4gICAgICAgICAgICBjbGllbnRUb3AgICAgICAgIDogbm9kZS5jbGllbnRUb3AsXG4gICAgICAgICAgICBjbGllbnRXaWR0aCAgICAgIDogbm9kZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgOiBub2RlLmNsYXNzTGlzdCA/IFsuLi5ub2RlLmNsYXNzTGlzdF0gOiBbXSxcbiAgICAgICAgICAgIGRhdGEgICAgICAgICAgICAgOiB7Li4ubm9kZS5kYXRhc2V0fSxcbiAgICAgICAgICAgIGRyYWdnYWJsZSAgICAgICAgOiBub2RlLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGhpZGRlbiAgICAgICAgICAgOiBub2RlLmhpZGRlbixcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgOiBOZW8uY29uZmlnLnVzZURvbUlkcyA/IG5vZGUuaWQgOiBub2RlLmRhdGFzZXQ/LlsnbmVvSWQnXSxcbiAgICAgICAgICAgIGluZXJ0ICAgICAgICAgICAgOiBub2RlLmluZXJ0LFxuICAgICAgICAgICAgaXNDb25uZWN0ZWQgICAgICA6IG5vZGUuaXNDb25uZWN0ZWQsXG4gICAgICAgICAgICBpc0NvbnRlbnRFZGl0YWJsZTogbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSxcbiAgICAgICAgICAgIG5vZGVUeXBlICAgICAgICAgOiBub2RlLm5vZGVUeXBlLFxuICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0ICAgICA6IG5vZGUub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0TGVmdCAgICAgICA6IG5vZGUub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgIG9mZnNldFRvcCAgICAgICAgOiBub2RlLm9mZnNldFRvcCxcbiAgICAgICAgICAgIG9mZnNldFdpZHRoICAgICAgOiBub2RlLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgcmVjdCxcbiAgICAgICAgICAgIHJvbGUgICAgICAgICAgICAgOiBub2RlLnJvbGUsXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgICAgIDogbm9kZS5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ICAgICAgIDogbm9kZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsVG9wICAgICAgICA6IG5vZGUuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgc2Nyb2xsV2lkdGggICAgICA6IG5vZGUuc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgICAgIDogbm9kZS5zdHlsZT8uY3NzVGV4dCxcbiAgICAgICAgICAgIHRhYkluZGV4ICAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZT8uKCd0YWJpbmRleCcpID8gbm9kZS50YWJJbmRleCA6IG51bGwsXG4gICAgICAgICAgICB0YWdOYW1lICAgICAgICAgIDogbm9kZS50YWdOYW1lPy50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB0b3VjaCBldmVudCBmb3VuZCBpbiB0b3VjaGVzIG9yIGNoYW5nZWRUb3VjaGVzIG9mIGEgVG91Y2hFdmVudFxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7VG91Y2h9XG4gICAgICovXG4gICAgZ2V0VG91Y2hDb29yZHMoZXZlbnQpIHtcbiAgICAgICAgbGV0IHt0b3VjaGVzLCBjaGFuZ2VkVG91Y2hlc30gPSBldmVudDtcbiAgICAgICAgcmV0dXJuIHRvdWNoZXM/LlswXSB8fCBjaGFuZ2VkVG91Y2hlcz8uWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSBpbiB1c2UgaWYgTmVvLmNvbmZpZy51c2VTaGFyZWRXb3JrZXJzID0gdHJ1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqL1xuICAgIG9uQmVmb3JlVW5sb2FkKGV2ZW50KSB7XG4gICAgICAgIGxldCB7TWFuYWdlcn0gPSBOZW8ud29ya2VyO1xuXG4gICAgICAgIE1hbmFnZXIuYXBwTmFtZXMuZm9yRWFjaChhcHBOYW1lID0+IHtcbiAgICAgICAgICAgIE1hbmFnZXIuYnJvYWRjYXN0KHthY3Rpb246ICdkaXNjb25uZWN0JywgYXBwTmFtZSwgd2luZG93SWQ6IE1hbmFnZXIud2luZG93SWR9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SW5wdXRFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkNoYW5nZShldmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3RhcmdldH0gPSBldmVudCxcblxuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZS5nZXRFdmVudERhdGEoZXZlbnQpLFxuICAgICAgICAgICAgICAgIHZhbGlkOiB0YXJnZXQuY2hlY2tWYWxpZGl0eT8uKCksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBpbnB1dCBhbmQgY2hhbmdlIGV2ZW50cyBjYW4gcGFzcyBhIEZpbGVMaXN0IGZvciBpbnB1dCB0eXBlIGZpbGVcbiAgICAgICAgaWYgKHRhcmdldC5maWxlcykge1xuICAgICAgICAgICAgZGF0YS5maWxlcyA9IHRhcmdldC5maWxlc1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcChtZS5nZXRNb3VzZUV2ZW50RGF0YShldmVudCkpO1xuXG4gICAgICAgIG1lLnRlc3RQYXRoSW5jbHVzaW9uKGV2ZW50LCBwcmV2ZW50Q2xpY2tUYXJnZXRzKSAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zZW5kTWVzc2FnZVRvQXBwKG1lLmdldE1vdXNlRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgbWUudGVzdFBhdGhJbmNsdXNpb24oZXZlbnQsIHByZXZlbnRDb250ZXh0bWVudVRhcmdldHMpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRG9tQ29udGVudExvYWRlZCgpIHtcbiAgICAgICAgdGhpcy5hZGRHbG9iYWxEb21MaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5maXJlKCdkb21Db250ZW50TG9hZGVkJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Eb3VibGVDbGljayhldmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAobWUuZ2V0TW91c2VFdmVudERhdGEoZXZlbnQpKTtcblxuICAgICAgICBtZS50ZXN0UGF0aEluY2x1c2lvbihldmVudCwgcHJldmVudENsaWNrVGFyZ2V0cykgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkZvY3VzSW4oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQXBwKHRoaXMuZ2V0RXZlbnREYXRhKGV2ZW50KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Gb2N1c091dChldmVudCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlVG9BcHAodGhpcy5nZXRFdmVudERhdGEoZXZlbnQpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25IYXNoQ2hhbmdlKCkge1xuICAgICAgICBsZXQge01hbmFnZXJ9ICA9IE5lby53b3JrZXIsXG4gICAgICAgICAgICBoYXNoU3RyaW5nID0gbG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSk7XG5cbiAgICAgICAgTWFuYWdlci5zZW5kTWVzc2FnZSgnYXBwJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnaGFzaENoYW5nZScsXG4gICAgICAgICAgICBkYXRhICA6IHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lczogTWFuYWdlci5hcHBOYW1lcyxcbiAgICAgICAgICAgICAgICBoYXNoICAgIDogdGhpcy5wYXJzZUhhc2goaGFzaFN0cmluZyksXG4gICAgICAgICAgICAgICAgaGFzaFN0cmluZyxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZDogTWFuYWdlci53aW5kb3dJZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dGFyZ2V0fSAgPSBldmVudCxcbiAgICAgICAgICAgIHt0YWdOYW1lfSA9IHRhcmdldCxcbiAgICAgICAgICAgIGlzSW5wdXQgICA9IHRhZ05hbWUgPT09ICdJTlBVVCcgfHwgdGFnTmFtZSA9PT0gJ1RFWFRBUkVBJztcblxuICAgICAgICBpZiAoaXNJbnB1dCAmJiBkaXNhYmxlZElucHV0S2V5c1t0YXJnZXQuaWRdPy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zZW5kTWVzc2FnZVRvQXBwKG1lLmdldEtleWJvYXJkRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc0lucHV0ICYmXG4gICAgICAgICAgICAgICAgZXZlbnQua2V5ID09PSAnVGFiJyAmJlxuICAgICAgICAgICAgICAgIG1lLnRlc3RQYXRoSW5jbHVzaW9uKGV2ZW50LCBbJ25lby1ncmlkLWVkaXRvcicsICduZW8tdGFibGUtZWRpdG9yJ10sIHRydWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgIFsnQXJyb3dEb3duJywgJ0Fycm93TGVmdCcsICdBcnJvd1JpZ2h0JywgJ0Fycm93VXAnXS5pbmNsdWRlcyhldmVudC5rZXkpICYmXG4gICAgICAgICAgICAgICAgbWUudGVzdFBhdGhJbmNsdXNpb24oZXZlbnQsIFsnbmVvLXNlbGVjdGlvbiddLCB0cnVlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQXBwKHRoaXMuZ2V0S2V5Ym9hcmRFdmVudERhdGEoZXZlbnQpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlVG9BcHAodGhpcy5nZXRNb3VzZUV2ZW50RGF0YShldmVudCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VFbnRlcihldmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYXBwRXZlbnQgPSB7Li4ubWUuZ2V0TW91c2VFdmVudERhdGEoZXZlbnQpLCBmcm9tRWxlbWVudElkOiBldmVudC5mcm9tRWxlbWVudD8uaWQgfHwgbnVsbCwgdG9FbGVtZW50SWQ6IGV2ZW50LnRvRWxlbWVudD8uaWQgfHwgbnVsbH07XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcChhcHBFdmVudCk7XG4gICAgICAgIG1lLmZpcmUoJ21vdXNlRW50ZXInLCBhcHBFdmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhcHBFdmVudCA9IHsuLi5tZS5nZXRNb3VzZUV2ZW50RGF0YShldmVudCksIGZyb21FbGVtZW50SWQ6IGV2ZW50LmZyb21FbGVtZW50Py5pZCB8fCBudWxsLCB0b0VsZW1lbnRJZDogZXZlbnQudG9FbGVtZW50Py5pZCB8fCBudWxsfTtcblxuICAgICAgICBtZS5zZW5kTWVzc2FnZVRvQXBwKGFwcEV2ZW50KTtcbiAgICAgICAgbWUuZmlyZSgnbW91c2VMZWF2ZScsIGFwcEV2ZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQXBwKHRoaXMuZ2V0TW91c2VFdmVudERhdGEoZXZlbnQpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25PcmllbnRhdGlvbkNoYW5nZShldmVudCkge1xuICAgICAgICBsZXQge29yaWVudGF0aW9ufSA9IHNjcmVlbixcbiAgICAgICAgICAgIHthbmdsZSwgdHlwZX0gPSBvcmllbnRhdGlvbixcbiAgICAgICAgICAgIGxheW91dCAgICAgICAgPSBhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnO1xuXG4gICAgICAgIE5lby53b3JrZXIuTWFuYWdlci5zZW5kTWVzc2FnZSgnYXBwJywge1xuICAgICAgICAgICAgYWN0aW9uOiAnb3JpZW50YXRpb25DaGFuZ2UnLFxuICAgICAgICAgICAgZGF0YSAgOiB7YW5nbGUsIGxheW91dCwgdHlwZX1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7Zmlyc3RUb3VjaCwgbGFzdFRvdWNofSA9IG1lLFxuICAgICAgICAgICAge2NsaWVudEhlaWdodCwgY2xpZW50V2lkdGgsIHNjcm9sbExlZnQsIHNjcm9sbFRvcH0gPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBkYXRhO1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLm1lLmdldEV2ZW50RGF0YShldmVudCksXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQsXG4gICAgICAgICAgICBjbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxUb3BcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZmlyc3RUb3VjaCkge1xuICAgICAgICAgICAgZGF0YS50b3VjaGVzID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0VG91Y2g6IHtjbGllbnRYOiBmaXJzdFRvdWNoLmNsaWVudFgsIGNsaWVudFk6IGZpcnN0VG91Y2guY2xpZW50WX0sXG4gICAgICAgICAgICAgICAgbGFzdFRvdWNoIDoge2NsaWVudFg6IGxhc3RUb3VjaCAuY2xpZW50WCwgY2xpZW50WTogbGFzdFRvdWNoIC5jbGllbnRZfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt0YXJnZXR9ID0gZXZlbnQsXG4gICAgICAgICAgICBlbGVtZW50ICA9IHRhcmdldC50eXBlID8gdGFyZ2V0IDogdGFyZ2V0LmFjdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICBwYXRoLCB0YXJnZXREYXRhO1xuXG4gICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggICAgICAgPSBtZS5nZXRTZWxlY3Rpb25QYXRoKFtdLCBlbGVtZW50KTtcbiAgICAgICAgdGFyZ2V0RGF0YSA9IG1lLmdldFRhcmdldERhdGEoZWxlbWVudCk7XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcCh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB7ZGlyZWN0aW9uOiBlbGVtZW50LnNlbGVjdGlvbkRpcmVjdGlvbiwgZW5kOiBlbGVtZW50LnNlbGVjdGlvbkVuZCwgc3RhcnQ6IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnR9LFxuICAgICAgICAgICAgdGFyZ2V0ICAgOiB0YXJnZXREYXRhLFxuICAgICAgICAgICAgdGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAsXG4gICAgICAgICAgICB0eXBlICAgICA6ICdzZWxlY3Rpb25jaGFuZ2UnXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbldoZWVsKGV2ZW50KSB7XG4gICAgICAgIGxldCB0YXJnZXQgICAgICAgID0gdGhpcy50ZXN0UGF0aEluY2x1c2lvbihldmVudCwgZ2xvYmFsV2hlZWxUYXJnZXRzKSxcbiAgICAgICAgICAgIHByZXZlbnRVcGRhdGUgPSBmYWxzZSxcbiAgICAgICAgICAgIHRhcmdldENscztcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXRDbHMgPSB0YXJnZXQuY2xzO1xuXG4gICAgICAgICAgICBpZiAoZ2xvYmFsV2hlZWxUYXJnZXRzQnVmZmVyW3RhcmdldC5jbHNdKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RXaGVlbEV2ZW50LmRhdGUgJiYgbGFzdFdoZWVsRXZlbnQudGFyZ2V0ID09PSB0YXJnZXRDbHMgJiYgZGF0ZSAtIGxhc3RXaGVlbEV2ZW50LmRhdGUgPCBnbG9iYWxXaGVlbFRhcmdldHNCdWZmZXJbdGFyZ2V0Q2xzXSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50VXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obGFzdFdoZWVsRXZlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldENsc1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFwcmV2ZW50VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHtkZWx0YVgsIGRlbHRhWSwgZGVsdGFafSA9IGV2ZW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQXBwKHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5nZXRFdmVudERhdGEoZXZlbnQpLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ6IHRhcmdldC5ub2RlLmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50V2lkdGggOiB0YXJnZXQubm9kZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWixcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCAgOiB0YXJnZXQubm9kZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgICA6IHRhcmdldC5ub2RlLnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ2xvYmFsV2hlZWxUYXJnZXRzS2VlcEV2ZW50LmluY2x1ZGVzKHRhcmdldENscykpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBET01SZWN0cyBhcmUgbm90IHNwcmVhZGFibGUgPT4gey4uLkRPTVJlY3R9ID0+IHt9XG4gICAgICogQHBhcmFtIHtET01SZWN0fSByZWN0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZURvbVJlY3QocmVjdCkge1xuICAgICAgICBsZXQge2JvdHRvbSwgaGVpZ2h0LCBsZWZ0LCByaWdodCwgdG9wLCB3aWR0aCwgeCwgeX0gPSByZWN0O1xuXG4gICAgICAgIHJldHVybiB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4YW1wbGUgZm9yIEFycmF5IHZhbHVlczogXCJjYXRlZ29yaWVzW109dGVzdDEmY2F0ZWdvcmllc1tdPXRlc3QyXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZUhhc2goc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwaWVjZXMgPSBzdHIuc3BsaXQoJyYnKSxcbiAgICAgICAgICAgIGRhdGEgICA9IHt9LFxuICAgICAgICAgICAgaSwga2V5LCBwYXJ0cywgdmFsdWU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFydHMgPSBwaWVjZXNbaV0uc3BsaXQoJz0nKTtcblxuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrZXkgICA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1swXSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1sxXSk7XG5cbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignW10nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDAsIGtleS5pbmRleE9mKCdbXScpKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhW2tleV0ucHVzaCh0aGlzLnBhcnNlVmFsdWUodmFsdWUpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSB0aGlzLnBhcnNlVmFsdWUodmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVzZWQgYnkgcGFyc2VIYXNoIHRvIGNvbnZlcnQgdG9rZW5zIGludG8gYm9vbGVhbiBvciBudW1iZXIgdHlwZXMgaWYgbmVlZGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58TnVtYmVyfFN0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcGFyc2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gcGFyc2VJbnQodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGRhdGEuY2hhcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqL1xuICAgIHJlZ2lzdGVyRGlzYWJsZWRJbnB1dENoYXJzKGRhdGEpIHtcbiAgICAgICAgZGlzYWJsZWRJbnB1dEtleXNbZGF0YS5pZF0gPSBkYXRhLmNoYXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gZGF0YS5jbHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5uYW1lXG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2ZW50RGVmYXVsdFRhcmdldHMoZGF0YSkge1xuICAgICAgICBsZXQgcHJldmVudEFycmF5O1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhLmNscykpIHtcbiAgICAgICAgICAgIGRhdGEuY2xzID0gW2RhdGEuY2xzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZGF0YS5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgcHJldmVudEFycmF5ID0gcHJldmVudENsaWNrVGFyZ2V0cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgICAgICAgICAgICBwcmV2ZW50QXJyYXkgPSBwcmV2ZW50Q29udGV4dG1lbnVUYXJnZXRzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5jbHMuZm9yRWFjaChjbHMgPT4ge1xuICAgICAgICAgICAgIXByZXZlbnRBcnJheS5pbmNsdWRlcyhjbHMpICYmIHByZXZlbnRBcnJheS5wdXNoKGNscylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgcGFyc2VkIGV2ZW50IGRhdGEgdG8gdGhlIGFwcCB3b3JrZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZVRvQXBwKGRhdGEpIHtcbiAgICAgICAgTmVvLndvcmtlci5NYW5hZ2VyLnNlbmRNZXNzYWdlKCdhcHAnLCB7XG4gICAgICAgICAgICBhY3Rpb24gICA6ICdkb21FdmVudCcsXG4gICAgICAgICAgICBldmVudE5hbWU6IGRhdGEudHlwZSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxsbyA8Zm9vPndvcmxkIHRob3JzdGVuISAzIDwgNCBhbmQgNSA+IDNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHN0cmlwSHRtbCh2YWx1ZSkge1xuICAgICAgICBsZXQgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh2YWx1ZSwgJ3RleHQvaHRtbCcpO1xuXG4gICAgICAgIHJldHVybiBkb2MuYm9keS50ZXh0Q29udGVudCB8fCAnJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRBcnJheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0U3Vic3RyaW5nPWZhbHNlXG4gICAgICogQHJldHVybnMge09iamVjdHxCb29sZWFufSB0YXJnZXQgY2xzICYgbm9kZSBpZiBmb3VuZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgdGVzdFBhdGhJbmNsdXNpb24oZXZlbnQsIHRhcmdldEFycmF5LCB0ZXN0U3Vic3RyaW5nPWZhbHNlKSB7XG4gICAgICAgIGxldCBjb3VudFRhcmdldHMgPSB0YXJnZXRBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICBwYXRoICAgICAgICAgPSBldmVudC5wYXRoIHx8IGV2ZW50LmNvbXBvc2VkUGF0aCgpLFxuICAgICAgICAgICAgaSAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgaiwgbm9kZTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gcGF0aFtpXTtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50VGFyZ2V0czsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0ZXN0U3Vic3RyaW5nICYmIG5vZGUuY2xhc3NMaXN0Py52YWx1ZT8uaW5jbHVkZXModGFyZ2V0QXJyYXlbal0pIHx8XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0Py5jb250YWlucyh0YXJnZXRBcnJheVtqXSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjbHM6IHRhcmdldEFycmF5W2pdLCBub2RlfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyRGlzYWJsZWRJbnB1dENoYXJzKGRhdGEpIHtcbiAgICAgICAgZGVsZXRlIGRpc2FibGVkSW5wdXRLZXlzW2RhdGEuaWRdXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEb21FdmVudHMpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbmNvbnN0IGZvY3VzYWJsZVRhZ3MgPSB7XG4gICAgQk9EWSAgICA6IDEsXG4gICAgQlVUVE9OICA6IDEsXG4gICAgRU1CRUQgICA6IDEsXG4gICAgSUZSQU1FICA6IDEsXG4gICAgSU5QVVQgICA6IDEsXG4gICAgT0JKRUNUICA6IDEsXG4gICAgU0VMRUNUICA6IDEsXG4gICAgVEVYVEFSRUE6IDFcbn07XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYWluLkRvbVV0aWxzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIERvbVV0aWxzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5Eb21VdGlscydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uRG9tVXRpbHMnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbG9nb3VzIHRvIHRoZSBgSFRNTEVsZW1lbnRgIGBjbG9zZXN0YCBtZXRob2QuIFNlYXJjaGVzIHN0YXJ0aW5nIGF0IHRoZSBwYXNzZWQgZWxlbWVudCBmb3JcbiAgICAgKiBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcGFzc2VkIGBmaWx0ZXJGbmAgcmV0dXJucyBgdHJ1ZWBcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0byBzdGFydCBmcm9tLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlckZuIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgZGVzaXJlZCBlbGVtZW50IGlzIHJlYWNoZWQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2xpbWl0XSBUaGUgZWxlbWVudCB0byBzdG9wIGF0LiBUaGlzIGlzICpub3QqIGNvbnNpZGVyZWQgZm9yIG1hdGNoaW5nLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xvc2VzdChlbCwgZmlsdGVyRm4sIGxpbWl0ID0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB3aGlsZSAoZWw/Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlbCAhPT0gbGltaXQpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJGbihlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaXNGb2N1c2FibGUoZSkge1xuICAgICAgICAvLyBNYXkgYmUgdXNlZCBhcyBhIHNjb3BlbGVzcyBjYWxsYmFjaywgc28gdXNlIFwiRG9tVXRpbHNcIiwgbm90IFwidGhpc1wiXG4gICAgICAgIHJldHVybiBEb21VdGlscy5pc1RhYmJhYmxlKGUpIHx8IE51bWJlcihlLmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKSkgPCAwXG4gICAgfVxuXG4gICAgc3RhdGljIGlzVGFiYmFibGUoZSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgeyBub2RlTmFtZSB9ID0gZSxcbiAgICAgICAgICAgIHN0eWxlICAgICAgICA9IGdldENvbXB1dGVkU3R5bGUoZSksXG4gICAgICAgICAgICB0YWJJbmRleCAgICAgPSBlLmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcblxuICAgICAgICAvLyBIaWRkZW4gZWxlbWVudHMgYXJlIG5vdCB0YWJiYWJsZS5cbiAgICAgICAgLy8gTmVnYXRpdmUgdGFiSW5kZXggYWxzbyBtZWFucyBub3QgdGFiYmFibGUgKFRob3VnaCBzdGlsbCBmb2N1c2FibGUpXG4gICAgICAgIGlmICghZS5pc0Nvbm5lY3RlZCB8fCAhZS5vZmZzZXRQYXJlbnQgfHwgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndmlzaWJpbGl0eScpID09PSAnaGlkZGVuJyB8fCBOdW1iZXIodGFiSW5kZXgpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9jdXNhYmxlVGFnc1tub2RlTmFtZV0gfHxcbiAgICAgICAgICAgICgobm9kZU5hbWUgPT09ICdBJyB8fCBub2RlTmFtZSA9PT0gJ0xJTksnKSAmJiAhIWUuaHJlZikgfHxcbiAgICAgICAgICAgICh0YWJJbmRleCAhPSBudWxsICYmIE51bWJlcih0YWJJbmRleCkgPj0gMCkgfHxcbiAgICAgICAgICAgIGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFsb2dvdXMgdG8gdGhlIGBIVE1MRWxlbWVudGAgYHF1ZXJ5U2VsZWN0b3JgIG1ldGhvZC4gU2VhcmNoZXMgdGhlIHBhc3NlZCBlbGVtZW50XG4gICAgICogYW5kIGFsbCBkZXNjZW5kYW50cyBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwYXNzZWQgYGZpbHRlckZuYCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0byBzdGFydCBmcm9tLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlckZuIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgZGVzaXJlZCBlbGVtZW50IGlzIHJlYWNoZWQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudFxuICAgICAqL1xuICAgIHN0YXRpYyBxdWVyeShlbCwgZmlsdGVyRm4pIHtcbiAgICAgICAgcmV0dXJuIFtlbCwgLi4uZWwucXVlcnlTZWxlY3RvckFsbCgnKicpXS5maW5kKGZpbHRlckZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFsb2dvdXMgdG8gdGhlIGBIVE1MRWxlbWVudGAgYHF1ZXJ5U2VsZWN0b3JBbGxgIG1ldGhvZC4gU2VhcmNoZXMgdGhlIHBhc3NlZCBlbGVtZW50XG4gICAgICogYW5kIGFsbCBkZXNjZW5kYW50cyBmb3IgYWxsIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcGFzc2VkIGBmaWx0ZXJGbmAgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJGbiBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYHRydWVgIHdoZW4gYSBkZXNpcmVkIGVsZW1lbnQgaXMgcmVhY2hlZC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX0gQW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHNcbiAgICAgKi9cbiAgICBzdGF0aWMgcXVlcnlBbGwoZWwsIGZpbHRlckZuKSB7XG4gICAgICAgIHJldHVybiBbZWwsIC4uLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKV0uZmlsdGVyKGZpbHRlckZuKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRG9tVXRpbHMpO1xuIiwidmFyIG1hcCA9IHtcblx0XCIuL0FtQ2hhcnRzLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0FtQ2hhcnRzLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9BbUNoYXJ0c19tanNcIlxuXHRdLFxuXHRcIi4vQW5hbHl0aWNzQnlHb29nbGUubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vQW5hbHl0aWNzQnlHb29nbGUubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9BbmFseXRpY3NCeUdvb2dsZV9tanNcIlxuXHRdLFxuXHRcIi4vQmFzZS5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9CYXNlLm1qc1wiLFxuXHRcdFwic3JjX21haW5fYWRkb25fQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vQ2VzaXVtSlMubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vQ2VzaXVtSlMubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9DZXNpdW1KU19tanNcIlxuXHRdLFxuXHRcIi4vQ2xvbmVOb2RlLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0Nsb25lTm9kZS5tanNcIixcblx0XHRcInNyY19tYWluX2FkZG9uX0Nsb25lTm9kZV9tanNcIlxuXHRdLFxuXHRcIi4vQ29va2llLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0Nvb2tpZS5tanNcIixcblx0XHRcInNyY19tYWluX2FkZG9uX0Nvb2tpZV9tanNcIlxuXHRdLFxuXHRcIi4vRHJhZ0Ryb3AubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vRHJhZ0Ryb3AubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX0RyYWdEcm9wX21qc1wiXG5cdF0sXG5cdFwiLi9GaWxlU3lzdGVtQWNjZXNzLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0ZpbGVTeXN0ZW1BY2Nlc3MubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9GaWxlU3lzdGVtQWNjZXNzX21qc1wiXG5cdF0sXG5cdFwiLi9Hb29nbGVNYXBzLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0dvb2dsZU1hcHMubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX0dvb2dsZU1hcHNfbWpzXCJcblx0XSxcblx0XCIuL0hpZ2hsaWdodEpTLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0hpZ2hsaWdodEpTLm1qc1wiLFxuXHRcdFwic3JjX21haW5fYWRkb25fSGlnaGxpZ2h0SlNfbWpzXCJcblx0XSxcblx0XCIuL0ludGVyc2VjdGlvbk9ic2VydmVyLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0ludGVyc2VjdGlvbk9ic2VydmVyLm1qc1wiLFxuXHRcdFwic3JjX21haW5fYWRkb25fSW50ZXJzZWN0aW9uT2JzZXJ2ZXJfbWpzXCJcblx0XSxcblx0XCIuL0xvY2FsU3RvcmFnZS5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9Mb2NhbFN0b3JhZ2UubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9Mb2NhbFN0b3JhZ2VfbWpzXCJcblx0XSxcblx0XCIuL01hcGJveEdMLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL01hcGJveEdMLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9NYXBib3hHTF9tanNcIlxuXHRdLFxuXHRcIi4vTWFya2Rvd24ubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vTWFya2Rvd24ubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9NYXJrZG93bl9tanNcIlxuXHRdLFxuXHRcIi4vTW9uYWNvRWRpdG9yLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL01vbmFjb0VkaXRvci5tanNcIixcblx0XHRcInNyY19tYWluX2FkZG9uX01vbmFjb0VkaXRvcl9tanNcIlxuXHRdLFxuXHRcIi4vTXdjLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL013Yy5tanNcIixcblx0XHRcInNyY19tYWluX2FkZG9uX013Y19tanNcIlxuXHRdLFxuXHRcIi4vTmF2aWdhdG9yLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL05hdmlnYXRvci5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fTmF2aWdhdG9yX21qc1wiXG5cdF0sXG5cdFwiLi9Qb3BvdmVyLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL1BvcG92ZXIubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9Qb3BvdmVyX21qc1wiXG5cdF0sXG5cdFwiLi9QcmVmaXhGaWVsZC5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9QcmVmaXhGaWVsZC5tanNcIixcblx0XHRcInNyY19tYWluX2FkZG9uX1ByZWZpeEZpZWxkX21qc1wiXG5cdF0sXG5cdFwiLi9SZXNpemVPYnNlcnZlci5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9SZXNpemVPYnNlcnZlci5tanNcIixcblx0XHRcInNyY19tYWluX2FkZG9uX1Jlc2l6ZU9ic2VydmVyX21qc1wiXG5cdF0sXG5cdFwiLi9TY3JvbGxTeW5jLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL1Njcm9sbFN5bmMubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9TY3JvbGxTeW5jX21qc1wiXG5cdF0sXG5cdFwiLi9TZXJ2aWNlV29ya2VyLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL1NlcnZpY2VXb3JrZXIubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9TZXJ2aWNlV29ya2VyX21qc1wiXG5cdF0sXG5cdFwiLi9TaWVzdGEubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vU2llc3RhLm1qc1wiLFxuXHRcdFwic3JjX21haW5fYWRkb25fU2llc3RhX21qc1wiXG5cdF0sXG5cdFwiLi9TdHlsZXNoZWV0Lm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL1N0eWxlc2hlZXQubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX1N0eWxlc2hlZXRfbWpzXCJcblx0XSxcblx0XCIuL1dlYkNvbXBvbmVudC5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9XZWJDb21wb25lbnQubWpzXCIsXG5cdFx0XCJzcmNfbWFpbl9hZGRvbl9XZWJDb21wb25lbnRfbWpzXCJcblx0XSxcblx0XCIuL1dpbmRvd1Bvc2l0aW9uLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL1dpbmRvd1Bvc2l0aW9uLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9XaW5kb3dQb3NpdGlvbl9tanNcIlxuXHRdXG59O1xuZnVuY3Rpb24gd2VicGFja0FzeW5jQ29udGV4dChyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH0pO1xuXHR9XG5cblx0dmFyIGlkcyA9IG1hcFtyZXFdLCBpZCA9IGlkc1swXTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShpZHNbMV0pLnRoZW4oKCkgPT4ge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcblx0fSk7XG59XG53ZWJwYWNrQXN5bmNDb250ZXh0LmtleXMgPSAoKSA9PiAoT2JqZWN0LmtleXMobWFwKSk7XG53ZWJwYWNrQXN5bmNDb250ZXh0LmlkID0gXCIuL3NyYy9tYWluL2FkZG9uIGxhenkgcmVjdXJzaXZlIF5cXFxcLlxcXFwvLipcXFxcLm1qcyRcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0FzeW5jQ29udGV4dDsiLCJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBXaWxsIGdldCBpbXBvcnRlZCBpbiBjYXNlIE5lby5jb25maWcuaGFzVG91Y2hFdmVudHMgPT09IHRydWVcbiAqIEBjbGFzcyBOZW8ubWFpbi5taXhpbi5Ub3VjaERvbUV2ZW50c1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBUb3VjaERvbUV2ZW50cyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4ubWl4aW4uVG91Y2hEb21FdmVudHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLm1peGluLlRvdWNoRG9tRXZlbnRzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqL1xuICAgIG9uVG91Y2hDYW5jZWwoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zZW5kTWVzc2FnZVRvQXBwKG1lLmdldEV2ZW50RGF0YShldmVudCkpO1xuICAgICAgICBtZS5maXJzdFRvdWNoID0gbnVsbDtcbiAgICAgICAgbWUubGFzdFRvdWNoICA9IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblRvdWNoRW5kKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcChtZS5nZXRFdmVudERhdGEoZXZlbnQpKTtcbiAgICAgICAgbWUuZmlyc3RUb3VjaCA9IG51bGw7XG4gICAgICAgIG1lLmxhc3RUb3VjaCAgPSBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgb25Ub3VjaEVudGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VUb0FwcCh0aGlzLmdldEV2ZW50RGF0YShldmVudCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgb25Ub3VjaExlYXZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VUb0FwcCh0aGlzLmdldEV2ZW50RGF0YShldmVudCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgICAgICAgID0gbWUuZ2V0RXZlbnREYXRhKGV2ZW50KSxcbiAgICAgICAgICAgIHRvdWNoICAgICAgID0gZXZlbnQudG91Y2hlc1swXSxcbiAgICAgICAgICAgIHtsYXN0VG91Y2h9ID0gbWU7XG5cbiAgICAgICAgaWYgKGxhc3RUb3VjaCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICAgICAgICAgICAgZGVsdGFYOiB0b3VjaC5jbGllbnRYIC0gbGFzdFRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgZGVsdGFZOiB0b3VjaC5jbGllbnRZIC0gbGFzdFRvdWNoLmNsaWVudFlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS5zZW5kTWVzc2FnZVRvQXBwKGRhdGEpO1xuXG4gICAgICAgIG1lLmxhc3RUb3VjaCA9IHRvdWNoO1xuXG4gICAgICAgIGlmIChtZS50ZXN0UGF0aEluY2x1c2lvbihldmVudCwgWyduZW8taGVsaXgnXSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqL1xuICAgIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmZpcnN0VG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICBtZS5sYXN0VG91Y2ggID0gZXZlbnQudG91Y2hlc1swXTtcblxuICAgICAgICBtZS5zZW5kTWVzc2FnZVRvQXBwKG1lLmdldEV2ZW50RGF0YShldmVudCkpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUb3VjaERvbUV2ZW50cyk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQXJyYXlcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgTmVvQXJyYXkgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkFycmF5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5BcnJheSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kIGFzIGR1cGxpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEsIGJ1dCBub3QgaW4gYXJyYXkyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxPVtdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyPVtdXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkaWZmZXJlbmNlKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gIWFycmF5Mi5pbmNsdWRlcyhpdGVtKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGl0ZW0gaXMgaW5jbHVkZWQgYnkgcmVmZXJlbmNlIGluc2lkZSB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzSXRlbShhcnIsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFyci5pbmNsdWRlcyhpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gaXRlbSBvciBBcnJheSBvZiBpdGVtcyB0byBhbiBhcnJheSBpbiBjYXNlIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICogRHVwbGljYXRlcyB3aWxsIG9ubHkgZ2V0IG1hdGNoZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydChhcnIsIGluZGV4LCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSBpdGVtcy5sZW5ndGggLTEsXG4gICAgICAgICAgICBpICAgPSBsZW4sXG4gICAgICAgICAgICBjdXJyZW50SW5kZXgsIGl0ZW07XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBiYWNrd2FyZHNcbiAgICAgICAgZm9yICg7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmUoYXJyLCBjdXJyZW50SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gYXJyYXkxIGFuZCBhcnJheTJcbiAgICAgKiBPbmx5IHN1cHBvcnRzIHByaW1pdGl2ZSBpdGVtc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MT1bXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5Mj1bXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJzZWN0aW9uKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gYXJyYXkyLmluY2x1ZGVzKGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGl0ZW0gaW5zaWRlIGFyciBmcm9tIGZyb21JbmRleCB0byB0b0luZGV4XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgc3RhdGljIG1vdmUoYXJyLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb21JbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tSW5kZXggPSBhcnIubGVuZ3RoIC0gMVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyLnNwbGljZSh0b0luZGV4LCAwLCBhcnIuc3BsaWNlKGZyb21JbmRleCwgMSlbMF0pO1xuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGZyb20gYW4gYXJyYXkuIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmUoYXJyLCBpdGVtcykge1xuICAgICAgICBsZXQgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgaW5kZXggPiAtMSAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNvbWJpbmUgYWRkICYgcmVtb3ZlIGluIG9uZSBjYWxsLlxuICAgICAqIFlvdSBjYW4gcGFzcyBzaW5nbGUgaXRlbXMgb3IgYW4gYXJyYXkgb2YgaXRlbXMgdG8gYWRkIG9yIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IHJlbW92ZUl0ZW1zXG4gICAgICogQHBhcmFtIHsqfSBhZGRJdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVBZGQoYXJyLCByZW1vdmVJdGVtcywgYWRkSXRlbXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoYXJyLCByZW1vdmVJdGVtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhcnIsIGFkZEl0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBleGlzdCwgb3RoZXJ3aXNlIGFkZHMgaXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthZGRdXG4gICAgICovXG4gICAgc3RhdGljIHRvZ2dsZShhcnIsIGl0ZW0sIGFkZCA9ICF0aGlzLmhhc0l0ZW0oYXJyLCBpdGVtKSkge1xuICAgICAgICByZXR1cm4gdGhpc1thZGQgPyAnYWRkJyA6ICdyZW1vdmUnXShhcnIsIGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gdGhlIHBhc3NlZCBhcnJheXMuXG4gICAgICogTXVsdGlwbGUgYXJyYXlzIG1heSBiZSBwYXNzZWQuXG4gICAgICogT25seSBzdXBwb3J0cyBwcmltaXRpdmUgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIHVuaW9uKCkge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5hcmd1bWVudHMpKV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kIGFzIGR1cGxpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICovXG4gICAgc3RhdGljIHVuc2hpZnQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFyci51bnNoaWZ0KGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcnJcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE5lb0FycmF5KTtcbiIsIi8qKlxuICogQXBwZW5kIGFyZ3MgaW5zdGVhZCBvZiBwcmVwZW5kaW5nIHRoZW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRBcHBlbmQoZm4sIHNjb3BlKSB7XG4gICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zbGljZSgyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KGFyZ3MpKVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBzY29wZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5PTMwMFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyKGNhbGxiYWNrLCBzY29wZSwgZGVsYXk9MzAwKSB7XG4gICAgbGV0IHRpbWVvdXRJZDtcblxuICAgIGNvbnN0IHdyYXBwZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIC8vIGNhbGxiYWNrIGludm9jYXRpb24gY29tZXMgXCJkZWxheVwiIG1zIGFmdGVyIHRoZSBsYXN0IGNhbGwgdG8gd3JhcHBlclxuICAgICAgICAvLyBzbyBjYW5jZWwgYW55IHBlbmRpbmcgaW52b2NhdGlvbi5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgd3JhcHBlci5pc1BlbmRpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZW91dElkID0gMDtcbiAgICAgICAgICAgIHdyYXBwZXIuaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncylcbiAgICAgICAgfSwgZGVsYXkpXG4gICAgfTtcblxuICAgIHdyYXBwZXIuY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICB3cmFwcGVyLmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgIH07XG5cbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG4vKipcbiAqIEludGVuZGVkIGZvciBmdW5jdGlvbnMgd2l0aCAxIHBhcmFtIHdoZXJlIHRoZSBpbnRlcmNlcHRvciBjYW4gY2hhbmdlIHRoZSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldE1ldGhvZE5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdEZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGFyZ2V0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnRlcmNlcHRvcih0YXJnZXQsIHRhcmdldE1ldGhvZE5hbWUsIGludGVyY2VwdEZ1bmN0aW9uLCBzY29wZSkge1xuICAgIGxldCB0YXJnZXRNZXRob2QgPSB0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV07XG5cbiAgICByZXR1cm4gKHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRNZXRob2QuY2FsbCh0YXJnZXQsIGludGVyY2VwdEZ1bmN0aW9uLmNhbGwoc2NvcGUgfHwgdGFyZ2V0LCB2YWx1ZSkpXG4gICAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlKHRhcmdldCwgbWV0aG9kTmFtZSwgZm4sIHNjb3BlKSB7XG4gICAgbGV0IG1ldGhvZCA9IHRhcmdldFttZXRob2ROYW1lXSB8fCBOZW8uZW1wdHlGbjtcblxuICAgIHJldHVybiAodGFyZ2V0W21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUgfHwgdGhpcywgYXJndW1lbnRzKVxuICAgIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gc2NvcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheT0zMDBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCBzY29wZSwgZGVsYXk9MzAwKSB7XG4gICAgbGV0IGRlYm91bmNlVGltZXI7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAvLyBsZWFkaW5nIGVkZ2UgPT4gdHJpZ2dlciB0aGUgZmlyc3QgY2FsbCByaWdodCBhd2F5XG4gICAgICAgIGlmICghTmVvLmlzTnVtYmVyKGRlYm91bmNlVGltZXIpKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBzY29wZSAoaW5zdGFuY2UpIGRpZCBub3QgZ2V0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgIHNjb3BlPy5pZCAmJiBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncyk7XG5cbiAgICAgICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gc3RhcnQgYSB0aW1lciB0byBkZWxheSB0aGUgMm5kKyB1cGRhdGVcbiAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtkZWJvdW5jZVRpbWVyID0gbnVsbH0sICBkZWxheSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKTtcblxuICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHNjb3BlIChpbnN0YW5jZSkgZGlkIG5vdCBnZXQgZGVzdHJveWVkIHlldFxuICAgICAgICAgICAgICAgIHNjb3BlPy5pZCAmJiBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge2RlYm91bmNlVGltZXIgPSBudWxsfSwgIGRlbGF5KVxuICAgICAgICAgICAgfSwgIGRlbGF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBpbnRlcmNlcHRvciBjYW4gcHJldmVudCB0aGUgdGFyZ2V0TWV0aG9kIGZyb20gZ2V0dGluZyBleGVjdXRlZCBpbiBjYXNlIGl0IHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0TWV0aG9kTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0RnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10YXJnZXRcbiAqIEBwYXJhbSB7Kn0gcHJldmVudGVkUmV0dXJuVmFsdWU9bnVsbCBUaGUgdmFsdWUgdG8gcmV0dXJuIGluIGNhc2UgdGhlIGludGVyY2VwdEZ1bmN0aW9uIHJldHVybnMgZmFsc2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyY2VwdCh0YXJnZXQsIHRhcmdldE1ldGhvZE5hbWUsIGludGVyY2VwdEZ1bmN0aW9uLCBzY29wZSwgcHJldmVudGVkUmV0dXJuVmFsdWU9bnVsbCkge1xuICAgIGxldCB0YXJnZXRNZXRob2QgPSB0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV07XG5cbiAgICByZXR1cm4gKHRhcmdldFt0YXJnZXRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKGludGVyY2VwdEZ1bmN0aW9uLmFwcGx5KHNjb3BlIHx8IHRhcmdldCwgYXJndW1lbnRzKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICA/IHByZXZlbnRlZFJldHVyblZhbHVlXG4gICAgICAgICAgICA6IHRhcmdldE1ldGhvZC5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cylcbiAgICB9KVxufVxuXG4vKipcbiAqIExvY2F0ZSBhIGNhbGxhYmxlIGZ1bmN0aW9uIGJ5IG5hbWUgaW4gdGhlIHBhc3NlZCBzY29wZS5cbiAqXG4gKiBJZiB0aGUgbmFtZSBzdGFydHMgd2l0aCAndXAuJywgdGhlIHBhcmVudCBDb21wb25lbnQgY2hhaW4gaXMgc2VhcmNoZWQuXG4gKlxuICogVGhpcyBpcyB1c2VkIGJ5IG1hbmFnZXIuRG9tRXZlbnRzICYgY29yZS5PYnNlcnZhYmxlLmZpcmUgYW5kIGJ5ICdoYW5kbGVyJyBmdW5jdGlvbiBjYWxscyB0byByZXNvbHZlXG4gKiBzdHJpbmcgZnVuY3Rpb24gbmFtZXMgaW4gdGhlIENvbXBvbmVudCdzIG93biBoaWVyYXJjaHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gQSBmdW5jdGlvbiwgb3IgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0byBmaW5kIGluIHRoZSBwYXNzZWQgc2NvcGUgb2JqZWN0L1xuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRoaXMgVGhlIHNjb3BlIHRvIGZpbmQgdGhlIGZ1bmN0aW9uIGluIGlmIGl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ2FsbGJhY2soZm4sIHNjb3BlPXRoaXMpIHtcbiAgICBpZiAoTmVvLmlzU3RyaW5nKGZuKSkge1xuICAgICAgICBpZiAoIXNjb3BlW2ZuXSAmJiBmbi5zdGFydHNXaXRoKCd1cC4nKSkge1xuICAgICAgICAgICAgZm4gPSBmbi5zbGljZSgzKTtcbiAgICAgICAgICAgIHdoaWxlICghc2NvcGVbZm5dICYmIChzY29wZSA9IHNjb3BlLnBhcmVudCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5nZXRDb250cm9sbGVyPy4oKT8uZ2V0SGFuZGxlclNjb3BlKGZuLCBudWxsKSB8fCBzY29wZVxuICAgICAgICB9XG5cbiAgICAgICAgZm4gPSBzY29wZVtmbl1cbiAgICB9XG5cbiAgICByZXR1cm4ge2ZuLCBzY29wZX1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBzY29wZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5PTMwMFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIHNjb3BlLCBkZWxheT0zMDApIHtcbiAgICBsZXQgbGFzdFJhbkRhdGUsIHRpbWVvdXRJZDtcblxuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGlmICghbGFzdFJhbkRhdGUpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHNjb3BlIChpbnN0YW5jZSkgZGlkIG5vdCBnZXQgZGVzdHJveWVkIHlldFxuICAgICAgICAgICAgc2NvcGU/LmlkICYmIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKTtcblxuICAgICAgICAgICAgbGFzdFJhbkRhdGUgPSBEYXRlLm5vdygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuXG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICgoRGF0ZS5ub3coKSAtIGxhc3RSYW5EYXRlKSA+PSBkZWxheSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBzY29wZSAoaW5zdGFuY2UpIGRpZCBub3QgZ2V0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU/LmlkICYmIGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICBsYXN0UmFuRGF0ZSA9IERhdGUubm93KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBkZWxheSAtIChEYXRlLm5vdygpIC0gbGFzdFJhbkRhdGUpKVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKiBUaGUgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciB3b3JraW5nIHdpdGggRE9NUmVjdCBPYmplY3RzXG4gKiBAY2xhc3MgTmVvLnV0aWwuUmVjdGFuZ2xlXG4gKiBAZXh0ZW5kcyBET01SZWN0XG4gKi9cblxuY29uc3RcbiAgICBlbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZShbXSksXG4gICAgLy8gQ29udmVydCBlZGdlIGFycmF5IHZhbHVlcyBpbnRvIHRoZSBbVCxSLEIsTF0gZm9ybS5cbiAgICBwYXJzZUVkZ2VWYWx1ZSA9IChlID0gMCkgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgIGUgPSBbZV07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGUubGVuZ3RoID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5maWxsKGVbMF0sIDEsIDQpO1xuICAgICAgICAgICAgY2FzZSAyOi8vIHRvcCZib3R0b20sIGxlZnQmcmlnaHRcbiAgICAgICAgICAgICAgICByZXR1cm4gW2VbMF0sIGVbMV0sIGVbMF0sIGVbMV1dO1xuICAgICAgICAgICAgY2FzZSAzOi8vIHRvcCwgbGVmdCZyaWdodCwgYm90dG9tXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlWzBdLCBlWzFdLCBlWzJdLCBlWzFdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9LFxuICAgIHBhcnNlRWRnZUFsaWduID0gZWRnZUFsaWduID0+IHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGVkZ2VQYXJ0cyAgICAgPSBlZGdlQWxpZ25SRS5leGVjKGVkZ2VBbGlnbiksXG4gICAgICAgICAgICBvdXJFZGdlWm9uZSAgID0gZWRnZVpvbmVbZWRnZVBhcnRzWzFdXSxcbiAgICAgICAgICAgIHRoZWlyRWRnZVpvbmUgPSBlZGdlWm9uZVtlZGdlUGFydHNbNF1dO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvdXJFZGdlICAgICAgICAgOiBlZGdlUGFydHNbMV0sXG4gICAgICAgICAgICBvdXJFZGdlT2Zmc2V0ICAgOiBwYXJzZUludChlZGdlUGFydHNbMl0gfHwgNTApLFxuICAgICAgICAgICAgb3VyRWRnZVVuaXQgICAgIDogZWRnZVBhcnRzWzNdIHx8ICclJyxcbiAgICAgICAgICAgIG91ckVkZ2Vab25lLFxuICAgICAgICAgICAgdGhlaXJFZGdlICAgICAgIDogZWRnZVBhcnRzWzRdLFxuICAgICAgICAgICAgdGhlaXJFZGdlT2Zmc2V0IDogcGFyc2VJbnQoZWRnZVBhcnRzWzVdIHx8IDUwKSxcbiAgICAgICAgICAgIHRoZWlyRWRnZVVuaXQgICA6IGVkZ2VQYXJ0c1s2XSB8fCAnJScsXG4gICAgICAgICAgICB0aGVpckVkZ2Vab25lLFxuXG4gICAgICAgICAgICAvLyBBbGlnbmVkIHRvIGFuIGVkZ2UsICpvdXRzaWRlKiBvZiB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgLy8gQSBub3JtYWwgYWxpZ24gYXMgYSBjb21ibyBkcm9wZG93biBtaWdodCByZXF1ZXN0XG4gICAgICAgICAgICBlZGdlQWxpZ25lZCAgICAgOiAob3VyRWRnZVpvbmUgJiAxKSA9PT0gKHRoZWlyRWRnZVpvbmUgJiAxKSAmJiBvdXJFZGdlWm9uZSAhPT0gdGhlaXJFZGdlWm9uZVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBUaGUgb3Bwb3NpdGUgb2YgcGFyc2VFZGdlQWxpZ24sIGFuZCBpdCBoYXMgdG8gZmxpcCB0aGUgZWRnZXNcbiAgICBjcmVhdGVSZXZlcnNlZEVkZ2VBbGlnbiA9IGVkZ2VzID0+IHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG91ckVkZ2UgICA9IG9wcG9zaXRlRWRnZVtlZGdlcy5vdXJFZGdlXSxcbiAgICAgICAgICAgIHRoZWlyRWRnZSA9IG9wcG9zaXRlRWRnZVtlZGdlcy50aGVpckVkZ2VdO1xuXG4gICAgICAgIC8vIHJlY29uc3RpdHV0ZSBhIHJ1bGUgc3RyaW5nIHdpdGggdGhlIGVkZ2VzIGZsaXBwZWQgdG8gdGhlIG9wcG9zaXRlIHNpZGVzXG4gICAgICAgIHJldHVybiBgJHtvdXJFZGdlfSR7ZWRnZXMub3VyRWRnZU9mZnNldH0ke2VkZ2VzLm91ckVkZ2VVbml0fS0ke3RoZWlyRWRnZX0ke2VkZ2VzLnRoZWlyRWRnZU9mZnNldH0ke2VkZ2VzLnRoZWlyRWRnZVVuaXR9YFxuXG4gICAgfSxcbiAgICBnZXRFbFJlY3QgPSBlbCA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSBlbCBpbnN0YW5jZW9mIERPTVJlY3QgPyBlbCA6IChlbD8ubm9kZVR5cGUgPT09IDEgPyBlbCA6IHR5cGVvZiBlbCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbCkgOiBudWxsKT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gQ29udmVydCBET01SZWN0IGludG8gUmVjdGFuZ2xlXG4gICAgICAgIHJldHVybiByICYmIG5ldyBSZWN0YW5nbGUoci54LCByLnksIHIud2lkdGgsIHIuaGVpZ2h0KTtcbiAgICB9LFxuICAgIG9wcG9zaXRlRWRnZSA9IHtcbiAgICAgICAgdCA6ICdiJyxcbiAgICAgICAgciA6ICdsJyxcbiAgICAgICAgYiA6ICd0JyxcbiAgICAgICAgbCA6ICdyJ1xuICAgIH0sXG4gICAgZWRnZVpvbmUgPSB7XG4gICAgICAgIHQgOiAwLFxuICAgICAgICByIDogMSxcbiAgICAgICAgYiA6IDIsXG4gICAgICAgIGwgOiAzXG4gICAgfSxcbiAgICB6b25lTmFtZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxuICAgIHpvbmVFZGdlcyA9IFsndCcsICdyJywgJ2InLCAnbCddLFxuICAgIHpvbmVEaW1lbnNpb24gPSBbJ3dpZHRoJywgJ2hlaWdodCddLFxuICAgIHpvbmVDb29yZCA9IFswLCAxLCAwLCAxXSxcbiAgICB6ZXJvTWFyZ2lucyA9IFswLCAwLCAwLCAwXSxcbiAgICBlZGdlQWxpZ25SRSA9IC9eKFt0cmJsY10pKFxcZCopKCV8cHgpPy0oW3RyYmxjXSkoXFxkKikoJXxweCk/JC87XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIERPTVJlY3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuUmVjdGFuZ2xlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5SZWN0YW5nbGUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG1pbkhlaWdodD1udWxsXG4gICAgICovXG4gICAgbWluSGVpZ2h0ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtaW5XaWR0aD1udWxsXG4gICAgICovXG4gICAgbWluV2lkdGggPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcmVjdDEgZG9lcyBub3QgaGF2ZSBhbiBpbnRlcnNlY3Rpb24gd2l0aCByZWN0MlxuICAgICAqICFpbmNsdWRlcygpIGlzIHRydWUgZm9yIGludGVyc2VjdGlvbnMgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBleGNsdWRlcyhyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QxLmJvdHRvbSA8IHJlY3QyLnRvcCAgICAgLy8gcmVjdDIgaXMgYmVsb3cgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLmxlZnQgICA+IHJlY3QyLnJpZ2h0ICAgLy8gcmVjdDIgaXMgbGVmdCBvZiByZWN0MVxuICAgICAgICAgICAgfHwgcmVjdDEucmlnaHQgIDwgcmVjdDIubGVmdCAgICAvLyByZWN0MiBpcyByaWdodCBvZiByZWN0MVxuICAgICAgICAgICAgfHwgcmVjdDEudG9wICAgID4gcmVjdDIuYm90dG9tOyAvLyByZWN0MiBpcyBhYm92ZSByZWN0MVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG92ZXJsYXBwaW5nIGFyZWEgb2YgcmVjdDEgJiByZWN0MiBhcyBhIG5ldyBSZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3R8TmVvLnV0aWwuUmVjdGFuZ2xlfSByZWN0MVxuICAgICAqIEBwYXJhbSB7RE9NUmVjdHxOZW8udXRpbC5SZWN0YW5nbGV9IHJlY3QyXG4gICAgICogQHJldHVybnMge05lby51dGlsLlJlY3RhbmdsZXxudWxsfSBUaGUgaW50ZXJzZWN0aW5nIHJlY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0SW50ZXJzZWN0aW9uKHJlY3QxLCByZWN0Mikge1xuICAgICAgICBsZXQgeCAgICAgID0gTWF0aC5tYXgocmVjdDEueCwgICAgICByZWN0Mi54KSxcbiAgICAgICAgICAgIHkgICAgICA9IE1hdGgubWF4KHJlY3QxLnksICAgICAgcmVjdDIueSksXG4gICAgICAgICAgICByaWdodCAgPSBNYXRoLm1pbihyZWN0MS5yaWdodCwgIHJlY3QyLnJpZ2h0KSxcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKSxcbiAgICAgICAgICAgIHdpZHRoICA9IE1hdGgubWF4KDAsIHJpZ2h0ICAtIHgpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYm90dG9tIC0geSk7XG5cbiAgICAgICAgaWYgKGhlaWdodCA8IDEgfHwgd2lkdGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcmVjdDIgaXMgZnVsbHkgY29udGFpbmVkIGluc2lkZSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbmNsdWRlcyhyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QxLmJvdHRvbSA+PSByZWN0Mi5ib3R0b21cbiAgICAgICAgICAgICYmIHJlY3QxLmxlZnQgICA8PSByZWN0Mi5sZWZ0XG4gICAgICAgICAgICAmJiByZWN0MS5yaWdodCAgPj0gcmVjdDIucmlnaHRcbiAgICAgICAgICAgICYmIHJlY3QxLnRvcCAgICA8PSByZWN0Mi50b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QyIGlzIG5vdCBjb250YWluZWQgaW5zaWRlIHJlY3QxLlxuICAgICAqIFRoaXMgY291bGQgYmUgYW4gaW50ZXJzZWN0aW9uIG9yIGJlaW5nIGZ1bGx5IGV4Y2x1ZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlIGJvdHRvbSwgbGVmdCwgcmlnaHQgb3IgdG9wXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGxlYXZlc1NpZGUocmVjdDEsIHJlY3QyLCBzaWRlKSB7XG4gICAgICAgIGlmIChSZWN0YW5nbGUuaW5jbHVkZXMocmVjdDEsIHJlY3QyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEuYm90dG9tIDwgcmVjdDIuYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLmxlZnQgPiByZWN0Mi5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0MS5yaWdodCA8IHJlY3QyLnJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEudG9wID4gcmVjdDIudG9wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIERPTVJlY3Qgb2JqZWN0IHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeD1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5PW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH0gbW92ZWRSZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1vdmVCeShyZWN0LCB4PW51bGwsIHk9bnVsbCkge1xuICAgICAgICBsZXQgbW92ZWRSZWN0ID0gey4uLnJlY3R9O1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5sZWZ0ICArPSB4O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnJpZ2h0ICs9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QueCAgICAgKz0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5ib3R0b20gKz0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC50b3AgICAgKz0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC55ICAgICAgKz0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3ZlZFJlY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIERPTVJlY3Qgb2JqZWN0IHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeD1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5PW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH0gbW92ZWRSZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1vdmVUbyhyZWN0LCB4PW51bGwsIHk9bnVsbCkge1xuICAgICAgICBsZXQgbW92ZWRSZWN0ID0gey4uLnJlY3R9O1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5sZWZ0ICA9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QucmlnaHQgPSB4ICsgbW92ZWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgbW92ZWRSZWN0LnggICAgID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5ib3R0b20gPSB5ICsgbW92ZWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC50b3AgICAgPSB5O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnkgICAgICA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWRSZWN0O1xuICAgIH1cblxuICAgIHNldCBib3R0b20oYikge1xuICAgICAgICB0aGlzLmhlaWdodCArPSBiIC0gdGhpcy5ib3R0b207XG4gICAgfVxuICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5ib3R0b207XG4gICAgfVxuXG4gICAgc2V0IHJpZ2h0KHIpIHtcbiAgICAgICAgdGhpcy53aWR0aCArPSByIC0gdGhpcy5yaWdodDtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gc3VwZXIucmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSB4IHdpdGhvdXQgbW92aW5nIHRoZSBSZWN0YW5nbGUuIFRoZSBsZWZ0IHNpZGUgbW92ZXMgYW5kIHRoZSByaWdodCBzaWRlIGRvZXNuJ3RcbiAgICBjaGFuZ2VYKHgpIHtcbiAgICAgICAgY29uc3Qgd2lkdGhEZWx0YSA9IHRoaXMueCAtIHg7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy53aWR0aCArPSB3aWR0aERlbHRhO1xuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgeSB3aXRob3V0IG1vdmluZyB0aGUgUmVjdGFuZ2xlLiBUaGUgdG9wIHNpZGUgbW92ZXMgYW5kIHRoZSBib3R0b20gc2lkZSBkb2Vzbid0XG4gICAgY2hhbmdlWSh5KSB7XG4gICAgICAgIGNvbnN0IGhlaWdodERlbHRhID0gdGhpcy55IC0geTtcblxuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHREZWx0YTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5jbG9uZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xvbmUocikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG5cbiAgICAgICAgcmVzdWx0Lm1pbldpZHRoID0gci5taW5XaWR0aDtcbiAgICAgICAgcmVzdWx0Lm1pbkhlaWdodCA9IHIubWluSGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0cyhvdGhlcikge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG90aGVyLmhlaWdodCAmJiBvdGhlci53aWR0aCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBsZWZ0ICAgPSBNYXRoLm1heChtZS54LCBvdGhlci54KSxcbiAgICAgICAgICAgICAgICB0b3AgICAgPSBNYXRoLm1heChtZS55LCBvdGhlci55KSxcbiAgICAgICAgICAgICAgICByaWdodCAgPSBNYXRoLm1pbihtZS54ICsgbWUud2lkdGgsIG90aGVyLnggKyBvdGhlci53aWR0aCksXG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4obWUueSArIG1lLmhlaWdodCwgb3RoZXIueSArIG90aGVyLmhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0ID49IHJpZ2h0IHx8IHRvcCA+PSBib3R0b20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBhIHBvaW50IGhlcmUgLSB6ZXJvIGRpbWVuc2lvbnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKG90aGVyLnggPj0gbWUueCAmJiBvdGhlci55ID49IG1lLnkgJiYgb3RoZXIucmlnaHQgPD0gbWUucmlnaHQgJiYgb3RoZXIuYm90dG9tIDw9IG1lLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG90aGVyIFJlY3RhbmdsZSBpcyBmdWxseSBjb250YWluZWQgaW5zaWRlIHRoaXMgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY29udGFpbnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tID49IG90aGVyLmJvdHRvbVxuICAgICAgICAgICAgJiYgdGhpcy5sZWZ0ICAgPD0gb3RoZXIubGVmdFxuICAgICAgICAgICAgJiYgdGhpcy5yaWdodCAgPj0gb3RoZXIucmlnaHRcbiAgICAgICAgICAgICYmIHRoaXMudG9wICAgIDw9IG90aGVyLnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGUgZXhwYW5kZWQgYWNjb3JkaW5nIHRvIHRoZSBlZGdlcyBhcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBlZGdlc1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9XG4gICAgICovXG4gICAgZXhwYW5kKGVkZ2VzKSB7XG4gICAgICAgIGVkZ2VzID0gcGFyc2VFZGdlVmFsdWUoZWRnZXMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnggLSBlZGdlc1szXSwgdGhpcy55IC0gZWRnZXNbMF0sIHRoaXMud2lkdGggKyBlZGdlc1sxXSArIGVkZ2VzWzNdLCB0aGlzLmhlaWdodCArIGVkZ2VzWzBdICsgZWRnZXNbMl0pO1xuICAgIH1cblxuICAgIG1vdmVCeSh4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgICAgICB5ID0geFsxXTtcbiAgICAgICAgICAgIHggPSB4WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC54ICs9IHg7XG4gICAgICAgIHJlc3VsdC55ICs9IHk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBSZWN0YW5nbGUgY29tcGxldGVseSBjb250YWlucyB0aGUgb3RoZXIgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IG90aGVyXG4gICAgICovXG4gICAgY29udGFpbnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuaW5jbHVkZXModGhpcywgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgUmVjdGFuZ2xlIGNvbnN0cmFpbmVkIHRvIGZpdCB3aXRoaW4gdGhlIHBhc3NlZCBSZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uc3RyYWluVG9cbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfEJvb2xlYW59IEEgbmV3IFJlY3RhbmdsZSBjb25zdHJhaW5lZCB0byB0ZSBwYXNzZWQgUmVjdGFuZ2xlLCBvciBmYWxzZSBpZiBpdCBjb3VsZCBub3QgYmUgY29uc3RyYWluZWQuXG4gICAgICovXG4gICAgY29uc3RyYWluVG8oY29uc3RyYWluVG8pIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtaW5XaWR0aCAgPSBtZS5taW5XaWR0aCAgfHwgbWUud2lkdGgsXG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBtZS5taW5IZWlnaHQgfHwgbWUuaGVpZ2h0O1xuXG4gICAgICAgIC8vIE5vdCBwb3NzaWJsZSwgZXZlbiB3aGVuIHNocnVuayB0byBtaW5pbWFcbiAgICAgICAgaWYgKG1pbkhlaWdodCA+IGNvbnN0cmFpblRvLmhlaWdodCB8fCBtaW5XaWR0aCA+IGNvbnN0cmFpblRvLndpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBkbyBub3QgbXV0YXRlIHRoaXMgUmVjdGFuZ2xlLCBidXQgcmV0dXJuIGEgY29uc3RyYWluZWQgdmVyc2lvblxuICAgICAgICBjb25zdCByZXN1bHQgPSBtZS5jbG9uZSgpO1xuXG4gICAgICAgIC8vIFRyYW5zbGF0ZSByZXN1bHQgc28gdGhhdCB0aGUgdG9wIGFuZCBsZWZ0IGFyZSB2aXNpYmxlXG4gICAgICAgIHJlc3VsdC54ID0gTWF0aC5tYXgobWUueCArIE1hdGgubWluKGNvbnN0cmFpblRvLnJpZ2h0ICAtIHJlc3VsdC5yaWdodCwgIDApLCBjb25zdHJhaW5Uby54KTtcbiAgICAgICAgcmVzdWx0LnkgPSBNYXRoLm1heChtZS55ICsgTWF0aC5taW4oY29uc3RyYWluVG8uYm90dG9tIC0gcmVzdWx0LmJvdHRvbSwgMCksIGNvbnN0cmFpblRvLnkpO1xuXG4gICAgICAgIC8vIFB1bGwgaW4gYW55IHJlc3VsdGluZyBvdmVyZmxvd1xuICAgICAgICByZXN1bHQuYm90dG9tID0gTWF0aC5taW4ocmVzdWx0LmJvdHRvbSwgY29uc3RyYWluVG8uYm90dG9tKTtcbiAgICAgICAgcmVzdWx0LnJpZ2h0ID0gTWF0aC5taW4ocmVzdWx0LnJpZ2h0LCBjb25zdHJhaW5Uby5yaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhbGlnblRvKGFsaWduKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWluVG8sICAgIC8vIEVsZW1lbnQgb3IgUmVjdGFuZ2xlIHJlc3VsdCBtdXN0IGZpdCBpbnRvXG4gICAgICAgICAgICAgICAgdGFyZ2V0LCAgICAgICAgIC8vIEVsZW1lbnQgb3IgUmVjdGFuZ2xlIHRvIGFsaWduIHRvXG4gICAgICAgICAgICAgICAgZWRnZUFsaWduLCAgICAgIC8vIHQ1MC1iNTAgdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICBheGlzTG9jaywgICAgICAgLy8gdHJ1ZSBmb3IgZmxpcCwgJ2ZsZXhpYmxlJyBmb3IgZmxpcCwgdGhlbiB0cnkgdGhlIG90aGVyIGVkZ2VzXG4gICAgICAgICAgICAgICAgb2Zmc2V0LCAgICAgICAgIC8vIEZpbmFsIFt4LCB5XSB2ZWN0b3IgdG8gbW92ZSB0aGUgcmVzdWx0IGJ5LlxuICAgICAgICAgICAgICAgIG1hdGNoU2l6ZVxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgPSBhbGlnbixcbiAgICAgICAgICAgIHRhcmdldE1hcmdpbiAgID0gYWxpZ24udGFyZ2V0TWFyZ2luID8gcGFyc2VFZGdlVmFsdWUoYWxpZ24udGFyZ2V0TWFyZ2luKSA6IHplcm9NYXJnaW5zLFxuICAgICAgICAgICAgdGFyZ2V0UmVjdCAgICAgPSBnZXRFbFJlY3QodGFyZ2V0KSxcbiAgICAgICAgICAgIGNvbnN0cmFpblJlY3QgID0gZ2V0RWxSZWN0KGNvbnN0cmFpblRvKSxcbiAgICAgICAgICAgIGVkZ2VzICAgICAgICAgID0gcGFyc2VFZGdlQWxpZ24oZWRnZUFsaWduKSxcbiAgICAgICAgICAgIG1hdGNoRGltZW5zaW9uID0gem9uZURpbWVuc2lvbltlZGdlcy50aGVpckVkZ2Vab25lICYgMV07XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IG1lLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoU2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0W21hdGNoRGltZW5zaW9uXSA9IHRhcmdldFJlY3RbbWF0Y2hEaW1lbnNpb25dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTXVzdCBkbyB0aGUgY2FsY3VsYXRpb25zIGFmdGVyIHRoZSBhbGlnbmVkIHNpZGUgaGFzIGJlZW4gbWF0Y2hlZCBpbiBzaXplIGlmIHJlcXVlc3RlZC5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG15UG9pbnQgICAgID0gcmVzdWx0LmdldEFuY2hvclBvaW50KGVkZ2VzLm91ckVkZ2Vab25lLCBlZGdlcy5vdXJFZGdlT2Zmc2V0LCBlZGdlcy5vdXJFZGdlVW5pdCksXG4gICAgICAgICAgICB0YXJnZXRQb2ludCA9IHRhcmdldFJlY3QuZ2V0QW5jaG9yUG9pbnQoZWRnZXMudGhlaXJFZGdlWm9uZSwgZWRnZXMudGhlaXJFZGdlT2Zmc2V0LCBlZGdlcy50aGVpckVkZ2VVbml0LCB0YXJnZXRNYXJnaW4pLFxuICAgICAgICAgICAgdmVjdG9yICAgICAgPSBbdGFyZ2V0UG9pbnRbMF0gLSBteVBvaW50WzBdLCB0YXJnZXRQb2ludFsxXSAtIG15UG9pbnRbMV1dO1xuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tb3ZlQnkodmVjdG9yKTtcblxuICAgICAgICAvLyBBIHVzZWZ1bCBwcm9wZXJ0eSBpbiB0aGUgcmVzdWx0aW5nIHJlY3RhbmdsZSB3aGljaCBzcGVjaWZpZXMgd2hpY2ggem9uZSBvZiB0aGUgdGFyZ2V0XG4gICAgICAgIC8vIEl0IGlzIGJlaW5nIHBsYWNlcyBpbiwgVCxSLEIgb3IgTCAtIDAsIDEsIDIsIDNcbiAgICAgICAgLy8gU29tZSBjb2RlIG1heSB3YW50IHRvIHRyZWF0IERPTSBlbGVtZW50cyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gdGhlIHpvbmVcbiAgICAgICAgcmVzdWx0LnpvbmUgPSBlZGdlcy50aGVpckVkZ2Vab25lO1xuICAgICAgICByZXN1bHQucG9zaXRpb24gPSB6b25lTmFtZXNbcmVzdWx0LnpvbmVdO1xuXG4gICAgICAgIC8vIE5vdyB3ZSBjcmVhdGUgdGhlIGZvdXIgUmVjdGFuZ2xlcyBhcm91bmQgdGhlIHRhcmdldCwgaW50byB3aGljaCB3ZSBtYXkgYmUgY29uc3RyYWluZWRcbiAgICAgICAgLy8gWm9uZXMgVCxSLEIsTCAwIDksIDEsIDIsIDM6XG4gICAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgLy8gfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgXiAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgXiAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICA8LS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS1ab25lIDAtLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tPiAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCArLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgWm9uZSAzICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgWm9uZSAxICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKystLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICA8LS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLVpvbmUgMi0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0+IHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB2ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB2ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCArKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgIGlmIChjb25zdHJhaW5SZWN0ICYmICFjb25zdHJhaW5SZWN0LmNvbnRhaW5zKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXkgYXNrZWQgdG8gb3ZlcmxhcCB0aGUgdGFyZ2V0LCBmb3IgZXhhbXBsZSB0MC10MFxuICAgICAgICAgICAgLy8gSW4gdGhlc2UgY2FzZXMsIHdlIGp1c3QgcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICh0YXJnZXRSZWN0LmludGVyc2VjdHMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHpvbmUgd2UgdHJ5IHRvIGZpdCBpbnRvIGZpcnN0LCB0aGUgb25lIHRoYXQgd2FzIGFza2VkIGZvclxuICAgICAgICAgICAgbGV0IHpvbmUgPSBlZGdlcy50aGVpckVkZ2Vab25lO1xuXG4gICAgICAgICAgICAvLyBXZSBjcmVhdGUgYW4gYXJyYXkgb2YgZm91ciByZWN0YW5nbGVzIGludG8gd2hpY2ggd2UgdHJ5IHRvIGZpdCB3aXRoIGFwcHJvcHJpYXRlIGFsaWduIHNwZWNzLlxuICAgICAgICAgICAgLy8gV2UgbXVzdCBzdGFydCB3aXRoIHRoZSByZXF1ZXN0ZWQgem9uZSwgd2hhdGV2ZXIgdGhhdCBpcy5cbiAgICAgICAgICAgIGNvbnN0IHpvbmVzVG9UcnkgPSBbe1xuICAgICAgICAgICAgICAgIHpvbmUsXG4gICAgICAgICAgICAgICAgZWRnZUFsaWduXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgaWYgKGF4aXNMb2NrKSB7XG4gICAgICAgICAgICAgICAgLy8gRmxpcCB0byB0aGUgb3Bwb3NpdGUgc2lkZSBmb3IgdGhlIHNlY29uZCB0cnkuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFsaWdubWVudCBzdHJpbmcgaGFzIHRvIGJlIHJldmVyc2VkXG4gICAgICAgICAgICAgICAgLy8gc28gcjIwLWwzMCBoYXMgdG8gYmVjb21lIGwyMC1yMzAuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG90aGVyIHR3byB6b25lcyByZXZlcnQgdG8gY2VudGVyZWQgc28gYXJlIGVhc2llclxuICAgICAgICAgICAgICAgIHpvbmVzVG9UcnlbMV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoem9uZSArIDIpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduIDogY3JlYXRlUmV2ZXJzZWRFZGdlQWxpZ24oZWRnZXMpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBvdGhlciB0d28gem9uZXMuXG4gICAgICAgICAgICAgICAgem9uZXNUb1RyeS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgem9uZSAgICAgIDogem9uZSA9IChlZGdlcy50aGVpckVkZ2Vab25lICsgMSkgJSA0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24gOiBgJHtvcHBvc2l0ZUVkZ2Vbem9uZUVkZ2VzW3pvbmVdXX0tJHt6b25lRWRnZXNbem9uZV19YFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoZWRnZXMudGhlaXJFZGdlWm9uZSArIDMpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduIDogYCR7b3Bwb3NpdGVFZGdlW3pvbmVFZGdlc1t6b25lXV19LSR7em9uZUVkZ2VzW3pvbmVdfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG90aGVyIHpvbmVzIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgem9uZXNUb1RyeS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoem9uZSArIDEpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGAke29wcG9zaXRlRWRnZVt6b25lRWRnZXNbem9uZV1dfS0ke3pvbmVFZGdlc1t6b25lXX1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb25zdHJhaW50IFJlY3RhbmdsZSBmb3IgZWFjaCB6b25lXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHpvbmVzVG9UcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjbG9uZSB0aGUgb3V0ZXIgY29uc3RyYWluaW5nIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIC8vIGFuZCBtb3ZlIGl0IGludG8gcG9zaXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBjID0gY29uc3RyYWluUmVjdC5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh6b25lc1RvVHJ5W2ldLnpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHpvbmUgaTIgYWJvdmUgdGhlIHRhcmdldCAtIHpvbmUgMC9UXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmJvdHRvbSA9IHRhcmdldFJlY3QueSAtIHRhcmdldE1hcmdpblswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgem9uZSBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIHRhcmdldCAtIHpvbmUgMS9SXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNoYW5nZVgodGFyZ2V0UmVjdC5yaWdodCArIHRhcmdldE1hcmdpblsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHpvbmUgaXMgYmVsb3cgdGhlIHRhcmdldCAtIHpvbmUgMi9CXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNoYW5nZVkodGFyZ2V0UmVjdC5ib3R0b20gKyB0YXJnZXRNYXJnaW5bMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSB0YXJnZXQgLSB6b25lIDMvTFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5yaWdodCA9IHRhcmdldFJlY3QueCAtIHRhcmdldE1hcmdpblszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5W2ldLmNvbnN0cmFpblJlY3QgPSBjO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3cgdHJ5IHRvIGNvbnN0cmFpbiBvdXIgcmVzdWx0IGludG8gZWFjaCB6b25lJ3MgY29uc3RyYWludFpvbmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgem9uZXNUb1RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW5SZWN0XG4gICAgICAgICAgICAgICAgICAgIH0gICAgPSB6b25lc1RvVHJ5W2ldLFxuICAgICAgICAgICAgICAgICAgICBlZGdlID0gem9uZUVkZ2VzW3pvbmVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYWxpZ25pbmcgdG8gdGhlIHJlcXVlc3RlZCBlZGdlLCBvciBpdCdzIG9wcG9zaXRlIGVkZ2UgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCB0aGF0IGVkZ2Ugc2l6ZSwgZWxzZSByZXZlcnQgaXQgdG8gb3VyIG93biBzaXplXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFttYXRjaERpbWVuc2lvbl0gPSBlZGdlID09PSBlZGdlcy50aGVpckVkZ2UgfHwgZWRnZSA9PSBvcHBvc2l0ZUVkZ2VbZWRnZXMudGhlaXJFZGdlXSA/IHRhcmdldFJlY3RbbWF0Y2hEaW1lbnNpb25dIDogbWVbbWF0Y2hEaW1lbnNpb25dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIGEgc2ltcGxlIGFsaWduIHRvIHRoZSBjdXJyZW50IGVkZ2VcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWxpZ25Ubyh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA6IHRhcmdldFJlY3QsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc29sdXRpb24gPSByZXN1bHQuY29uc3RyYWluVG8oY29uc3RyYWluUmVjdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcyBzb29uIGFzIHdlIGZpbmQgYSB6b25lIGludG8gd2hpY2ggdGhlIHJlc3VsdCBpcyB3aWxsaW5nIHRvIGJlIGNvbnN0cmFpbmVkLiByZXR1cm4gaXRcbiAgICAgICAgICAgICAgICBpZiAoc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24uem9uZSA9IHpvbmU7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLnBvc2l0aW9uID0gem9uZU5hbWVzW3pvbmVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSBjb25maWd1cmFibGUgZmluaXNoaW5nIHRvdWNoLlxuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXN1bHQubW92ZUJ5KG9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldEFuY2hvclBvaW50KGVkZ2Vab25lLCBlZGdlT2Zmc2V0LCBlZGdlVW5pdCwgbWFyZ2luID0gZW1wdHlBcnJheSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAvLyBFZGdlIHpvbmVzIGdvIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuICAgICAgICAvLyBFYWNoIG9uZSBjYWxjdWxhdGVzIHRoZSBzdGFydCBwb2ludCBvZiB0aGF0IGVkZ2UgdGhlbiBtb3ZlcyBhbG9uZyBpdCBieVxuICAgICAgICAvLyB0aGUgZWRnZU9mZnNldCwgdGhlbiBtb3ZlcyAqYXdheSogZnJvbSBpdCBieSB0aGUgbWFyZ2luIGZvciB0aGF0IGVkZ2UgaWYgdGhlcmUncyBhIG1hcmdpbi5cbiAgICAgICAgc3dpdGNoIChlZGdlWm9uZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFttZS54LCBtZS55IC0gKG1hcmdpblswXSB8fCAwKSwgbWUud2lkdGgsIDBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFttZS54ICsgbWUud2lkdGggKyAobWFyZ2luWzFdIHx8IDApLCBtZS55LCBtZS5oZWlnaHQsIDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFttZS54LCBtZS55ICsgbWUuaGVpZ2h0ICsgKG1hcmdpblsyXSB8fCAwKSwgbWUud2lkdGgsIDBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFttZS54IC0gKG1hcmdpblszXSB8fCAwKSwgbWUueSwgbWUuaGVpZ2h0LCAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzdWx0WzNdXSArPSBlZGdlVW5pdCA9PT0gJyUnID8gcmVzdWx0WzJdIC8gMTAwICogZWRnZU9mZnNldCA6IGVkZ2VPZmZzZXQ7XG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSAyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBET01SZWN0ICYmXG4gICAgICAgICAgICBvdGhlci54ID09PSB0aGlzLnggJiZcbiAgICAgICAgICAgIG90aGVyLnkgPT09IHRoaXMueSAmJlxuICAgICAgICAgICAgb3RoZXIuaGVpZ2h0ID09PSB0aGlzLmhlaWdodCAmJlxuICAgICAgICAgICAgb3RoZXIud2lkdGggPT09IHRoaXMud2lkdGg7XG4gICAgfVxuXG4gICAgLy8gRm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBvbmx5XG4gICAgc2hvdyhjb2xvciA9ICdyZWQnKSB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIGRpdi5zdHlsZSA9IGBcbiAgICAgICAgICAgIHBvc2l0aW9uOmFic29sdXRlO1xuICAgICAgICAgICAgdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKCR7dGhpcy54fXB4LCAke3RoaXMueX1weCwgMCk7XG4gICAgICAgICAgICBoZWlnaHQ6JHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgICAgIHdpZHRoOiR7dGhpcy53aWR0aH1weDtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6JHtjb2xvcn1cbiAgICAgICAgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGRpdi5yZW1vdmUoKSwgMzAwMDApO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgSlNPTi5zdHJpbmdpZnkodGhpcyksIHdlIHdhbnQgdG8gYWRkIG1pbkhlaWdodCAmIG1pbldpZHRoIHRvIHRoZSBvdXRwdXQuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHtib3R0b20sIGhlaWdodCwgbGVmdCwgbWluSGVpZ2h0LCBtaW5XaWR0aCwgcmlnaHQsIHRvcCwgd2lkdGgsIHgsIHl9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtib3R0b20sIGhlaWdodCwgbGVmdCwgbWluSGVpZ2h0LCBtaW5XaWR0aCwgcmlnaHQsIHRvcCwgd2lkdGgsIHgsIHl9XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlN0cmluZ1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTdHJpbmdVdGlsIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBjaGFyRW50aXR5TWFwXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBjaGFyRW50aXR5TWFwID0ge1xuICAgICAgICAnJicgOiAnJmFtcDsnLFxuICAgICAgICAnPCcgOiAnJmx0OycsXG4gICAgICAgICc+JyA6ICcmZ3Q7JyxcbiAgICAgICAgJ1wiJyA6ICcmcXVvdDsnLFxuICAgICAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgICAgICckJyA6ICcmZG9sbGFyOycsXG4gICAgICAgICdcXFxcJzogJyZic29sOycsXG4gICAgICAgICcvJyA6ICcmc29sOydcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7UmVnRXhwfSBjaGFyUGF0dGVyblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hhclBhdHRlcm4gPSAvWyY8PlwiJyRcXFxcXS9nXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7UmVnRXhwfSBlbnRpdHlQYXR0ZXJuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBlbnRpdHlQYXR0ZXJuID0gLygmYW1wOyl8KCZsdDspfCgmZ3Q7KXwoJnF1b3Q7KXwoJmFwb3M7KXwoJmRvbGxhcjspfCgmYnNvbDspfCgmc29sOykvZ1xuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5TdHJpbmcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlN0cmluZydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgSFRNTCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZXNjYXBlSHRtbCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzOyAvLyBpbnNpZGUgYSBzdGF0aWMgbWV0aG9kLCB3ZSBhcmUgcG9pbnRpbmcgdG8gdGhlIGNsYXNzIHByb3RvdHlwZVxuXG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShtZS5jaGFyUGF0dGVybiwgbWUuZ2V0RW50aXR5RnJvbUNoYXIuYmluZChtZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNoYXIgZXF1aXZhbGVudCBvZiBhIG1hcHBlZCBlbnRpdHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW50aXR5XG4gICAgICovXG4gICAgc3RhdGljIGdldENoYXJGcm9tRW50aXR5KGVudGl0eSkge1xuICAgICAgICBsZXQgbWFwcGVkQ2hhciA9IE9iamVjdC5rZXlzKHRoaXMuY2hhckVudGl0eU1hcCkuZmluZChrZXkgPT4gdGhpcy5jaGFyRW50aXR5TWFwW2tleV0gPT09IGVudGl0eSk7XG4gICAgICAgIHJldHVybiBtYXBwZWRDaGFyIHx8IGVudGl0eVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBlbnRpdHkgZXF1aXZhbGVudCBvZiBhIG1hcHBlZCBjaGFyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoYXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RW50aXR5RnJvbUNoYXIoY2hhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFyRW50aXR5TWFwW2NoYXJdIHx8IGNoYXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmVzY2FwZSBIVE1MIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmVzY2FwZUh0bWwodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpczsgLy8gaW5zaWRlIGEgc3RhdGljIG1ldGhvZCwgd2UgYXJlIHBvaW50aW5nIHRvIHRoZSBjbGFzcyBwcm90b3R5cGVcblxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobWUuZW50aXR5UGF0dGVybiwgbWUuZ2V0Q2hhckZyb21FbnRpdHkuYmluZChtZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFzc2VkIHN0cmluZyB3aXRoIHRoZSBmaXJzdCBsZXR0ZXIgdW5jYXBpdGFsaXplZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyAge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdW5jYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZVswXS50b0xvd2VyQ2FzZSgpICsgdmFsdWUuc3Vic3RyaW5nKDEpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdHJpbmdVdGlsKTtcbiIsIi8qKlxuICogVGhlIGZvbGxvd2luZyB0b3AtbGV2ZWwgYXR0cmlidXRlcyB3aWxsIGdldCBjb252ZXJ0ZWQgaW50byBzdHlsZXM6XG4gKiBoZWlnaHQsIG1heEhlaWdodCwgbWF4V2lkdGgsIG1pbkhlaWdodCwgbWluV2lkdGgsIHdpZHRoXG4gKlxuICogU29tZSB0YWdzIG11c3Qgbm90IGRvIHRoZSB0cmFuc2Zvcm1hdGlvbiwgc28gd2UgYWRkIHRoZW0gaGVyZS5cbiAqIEBtZW1iZXIge1NldH0gcmF3RGltZW5zaW9uVGFnc1xuICovXG5leHBvcnQgY29uc3QgcmF3RGltZW5zaW9uVGFncyA9IG5ldyBTZXQoW1xuICAgICdjaXJjbGUnLFxuICAgICdjbGlwUGF0aCcsXG4gICAgJ2VsbGlwc2UnLFxuICAgICdmaWx0ZXInLFxuICAgICdmb3JlaWduT2JqZWN0JyxcbiAgICAnaW1hZ2UnLFxuICAgICdtYXJrZXInLFxuICAgICdtYXNrJyxcbiAgICAncGF0dGVybicsXG4gICAgJ3JlY3QnLFxuICAgICdzdmcnLFxuICAgICd1c2UnXG5dKTtcblxuLyoqXG4gKiBWb2lkIGF0dHJpYnV0ZXMgaW5zaWRlIGh0bWwgdGFnc1xuICogQG1lbWJlciB7U2V0fSB2b2lkQXR0cmlidXRlc1xuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY29uc3Qgdm9pZEF0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdpc21hcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbm9ocmVmJyxcbiAgICAnbm9yZXNpemUnLFxuICAgICdub3NoYWRlJyxcbiAgICAnbm93cmFwJyxcbiAgICAnb3BlbicsXG4gICAgJ3JlYWRvbmx5JyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZXZlcnNlZCcsXG4gICAgJ3NlbGVjdGVkJ1xuXSk7XG5cbi8qKlxuICogVm9pZCBodG1sIHRhZ3NcbiAqIEBtZW1iZXIge1NldH0gdm9pZEVsZW1lbnRzXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmV4cG9ydCBjb25zdCB2b2lkRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICAnYXJlYScsXG4gICAgJ2Jhc2UnLFxuICAgICdicicsXG4gICAgJ2NvbCcsXG4gICAgJ2VtYmVkJyxcbiAgICAnaHInLFxuICAgICdpbWcnLFxuICAgICdpbnB1dCcsXG4gICAgJ2xpbmsnLFxuICAgICdtZXRhJyxcbiAgICAncGFyYW0nLFxuICAgICdzb3VyY2UnLFxuICAgICd0cmFjaycsXG4gICAgJ3dicidcbl0pO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBEb21BY2Nlc3MgICAgICAgICAgZnJvbSAnLi4vbWFpbi9Eb21BY2Nlc3MubWpzJztcbmltcG9ydCBEb21FdmVudHMgICAgICAgICAgZnJvbSAnLi4vbWFpbi9Eb21FdmVudHMubWpzJztcbmltcG9ydCBNZXNzYWdlICAgICAgICAgICAgZnJvbSAnLi9NZXNzYWdlLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFJlbW90ZU1ldGhvZEFjY2VzcyBmcm9tICcuL21peGluL1JlbW90ZU1ldGhvZEFjY2Vzcy5tanMnO1xuXG5jb25zdCBOZW9Db25maWcgICAgPSBOZW8uY29uZmlnLFxuICAgICAgaGFzSnNNb2R1bGVzID0gTmVvQ29uZmlnLmVudmlyb25tZW50ID09PSAnZGV2ZWxvcG1lbnQnIHx8IE5lb0NvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2Rpc3QvZXNtJztcblxuLy8gVXNpbmcgPy4gc2luY2UgU1dzIGRvIG5vdCBleGlzdCBmb3IgaHR0cCAob25seSBodHRwcylcbm5hdmlnYXRvci5zZXJ2aWNlV29ya2VyPy5hZGRFdmVudExpc3RlbmVyKCdjb250cm9sbGVyY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG59LCB7b25jZTogdHJ1ZX0pO1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgbWFuYWdlciBsaXZlcyBpbnNpZGUgdGhlIG1haW4gdGhyZWFkIGFuZCBjcmVhdGVzIHRoZSBBcHAsIERhdGEgJiBWRG9tIHdvcmtlci5cbiAqIEFsc28sIHJlc3BvbnNpYmxlIGZvciBzZW5kaW5nIG1lc3NhZ2VzIGZyb20gdGhlIG1haW4gdGhyZWFkIHRvIHRoZSBkaWZmZXJlbnQgd29ya2Vycy5cbiAqIEBjbGFzcyBOZW8ud29ya2VyLk1hbmFnZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgTWFuYWdlciBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLndvcmtlci5NYW5hZ2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ud29ya2VyLk1hbmFnZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhY3RpdmVXb3JrZXJzPTBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlV29ya2VyczogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhcHBOYW1lcz1bXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBhcHBOYW1lczogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbnN0cnVjdGVkVGhyZWFkcz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdGVkVGhyZWFkczogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfE5lby5jb3JlLkJhc2VbXXxudWxsfSBtaXhpbnM9W09ic2VydmFibGUsIFJlbW90ZU1ldGhvZEFjY2Vzc11cbiAgICAgICAgICovXG4gICAgICAgIG1peGluczogW09ic2VydmFibGUsIFJlbW90ZU1ldGhvZEFjY2Vzc10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluIGNhc2UgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyB3aW5kb3cuU2hhcmVkV29ya2VyLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaGFyZWRXb3JrZXJzRW5hYmxlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaGFyZWRXb3JrZXJzRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHN0b3AgdGhlIHdvcmtlciBjb21tdW5pY2F0aW9uIGluIGNhc2UgdGhlaXIgY3JlYXRpb24gZmFpbHNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc3RvcENvbW11bmljYXRpb249ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcENvbW11bmljYXRpb246IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpbiBjYXNlIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgd2luZG93Lldvcmtlci5cbiAgICAgICAgICogVGhlIG5lby5tanMgZnJhbWV3b3JrIGlzIG5vdCBhYmxlIHRvIHJ1biB3aXRob3V0IHdlYiB3b3JrZXJzLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaGFyZWRXb3JrZXJzRW5hYmxlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB3ZWJXb3JrZXJzRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2luZyB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gdW5pcXVlIHdpbmRvdyBpZGVudGlmaWVyXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gd2luZG93SWQ9bmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWQ6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbnMgdGhlIGZpbGVOYW1lcyBmb3IgdGhlIEFwcCwgRGF0YSAmIFZkb20gd29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHdvcmtlcnNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgd29ya2Vyczoge1xuICAgICAgICAgICAgYXBwOiB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGhhc0pzTW9kdWxlcyA/ICdBcHAubWpzJyAgICA6ICdhcHB3b3JrZXIuanMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FudmFzOiB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGhhc0pzTW9kdWxlcyA/ICdDYW52YXMubWpzJyA6ICdjYW52YXN3b3JrZXIuanMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBoYXNKc01vZHVsZXMgPyAnRGF0YS5tanMnICAgOiAnZGF0YXdvcmtlci5qcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YXNrOiB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGhhc0pzTW9kdWxlcyA/ICdUYXNrLm1qcycgICA6ICd0YXNrd29ya2VyLmpzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZkb206IHtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogaGFzSnNNb2R1bGVzID8gJ1ZEb20ubWpzJyAgIDogJ3Zkb213b3JrZXIuanMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyIGNhbiBiZSBudWxsIGluIGNhc2Ugd2UgbG9hZCBhIHBhZ2UgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICogb3IgaW4gY2FzZSBvZiBhIGZvcmNlIHJlZnJlc2guXG4gICAgICogU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvc2VydmljZS13b3JrZXJzLyNuYXZpZ2F0b3Itc2VydmljZS13b3JrZXItY29udHJvbGxlclxuICAgICAqIE9ubHkgaW4gdGhpcyBjYXNlIG1haW4uYWRkb24uU2VydmljZVdvcmtlciB3aWxsIHN0b3JlIHRoZSBhY3RpdmUgcmVnaXN0cmF0aW9uIG9uY2UgcmVhZHkgaGVyZS5cbiAgICAgKiBAbWVtYmVyIHtTZXJ2aWNlV29ya2VyfG51bGx9IHNlcnZpY2VXb3JrZXI9bnVsbFxuICAgICAqL1xuICAgIHNlcnZpY2VXb3JrZXIgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmRldGVjdEZlYXR1cmVzKCk7XG5cbiAgICAgICAgIU5lby5pbnNpZGVXb3JrZXIgJiYgbWUuY3JlYXRlV29ya2VycygpO1xuXG4gICAgICAgIE5lby53b3JrZXJJZCA9ICdtYWluJztcblxuICAgICAgICBtZS5wcm9taXNlcyA9IHt9O1xuXG4gICAgICAgIG1lLm9uKHtcbiAgICAgICAgICAgICdtZXNzYWdlOmFkZERvbUxpc3RlbmVyJyAgICA6IHtmbjogRG9tRXZlbnRzLmFkZERvbUxpc3RlbmVyLCAgICAgICBzY29wZTogRG9tRXZlbnRzfSxcbiAgICAgICAgICAgICdtZXNzYWdlOmdldE9mZnNjcmVlbkNhbnZhcyc6IHtmbjogRG9tQWNjZXNzLm9uR2V0T2Zmc2NyZWVuQ2FudmFzLCBzY29wZTogRG9tQWNjZXNzfSxcbiAgICAgICAgICAgICdtZXNzYWdlOnJlYWREb20nICAgICAgICAgICA6IHtmbjogRG9tQWNjZXNzLm9uUmVhZERvbSwgICAgICAgICAgICBzY29wZTogRG9tQWNjZXNzfSxcbiAgICAgICAgICAgICdtZXNzYWdlOnJlZ2lzdGVyUmVtb3RlJyAgICA6IHtmbjogbWUub25SZWdpc3RlclJlbW90ZSwgICAgICAgICAgICBzY29wZTogbWV9LFxuICAgICAgICAgICAgJ21lc3NhZ2U6d29ya2VyQ29uc3RydWN0ZWQnIDoge2ZuOiBtZS5vbldvcmtlckNvbnN0cnVjdGVkLCAgICAgICAgIHNjb3BlOiBtZX1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gZWFjaCB3b3JrZXIgZGVmaW5lZCBpbnNpZGUgdGhlIHRoaXMud29ya2VycyBjb25maWcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZ1xuICAgICAqL1xuICAgIGJyb2FkY2FzdChtc2cpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy53b3JrZXJzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgaWYgKCEoXG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2NhbnZhcycgJiYgIU5lb0NvbmZpZy51c2VDYW52YXNXb3JrZXIgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAndGFzaycgICAmJiAhTmVvQ29uZmlnLnVzZVRhc2tXb3JrZXIgICB8fFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICd2ZG9tJyAgICYmICFOZW9Db25maWcudXNlVmRvbVdvcmtlclxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobmFtZSwgbXNnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgd2ViIHdvcmtlciB1c2luZyB0aGUgcGFzc2VkIG9wdGlvbnMgYXMgd2VsbCBhcyBhZGRpbmcgZXJyb3IgJiBtZXNzYWdlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHtTaGFyZWRXb3JrZXJ8V29ya2VyfVxuICAgICAqL1xuICAgIGNyZWF0ZVdvcmtlcihvcHRzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmaWxlTmFtZX0gPSBvcHRzLFxuICAgICAgICAgICAgZmlsZVBhdGggICA9IChvcHRzLmJhc2VQYXRoIHx8IE5lby5jb25maWcud29ya2VyQmFzZVBhdGgpICsgZmlsZU5hbWUsXG4gICAgICAgICAgICBuYW1lICAgICAgID0gYG5lb21qcy0ke2ZpbGVOYW1lLnN1YnN0cmluZygwLCBmaWxlTmFtZS5pbmRleE9mKCcuJykpLnRvTG93ZXJDYXNlKCl9LXdvcmtlcmAsXG4gICAgICAgICAgICBpc1NoYXJlZCAgID0gbWUuc2hhcmVkV29ya2Vyc0VuYWJsZWQgJiYgTmVvQ29uZmlnLnVzZVNoYXJlZFdvcmtlcnMsXG4gICAgICAgICAgICBjbHMgICAgICAgID0gaXNTaGFyZWQgPyBTaGFyZWRXb3JrZXIgOiBXb3JrZXIsXG4gICAgICAgICAgICB3b3JrZXIgICAgID0gaGFzSnNNb2R1bGVzXG4gICAgICAgICAgICAgICAgPyBuZXcgY2xzKGZpbGVQYXRoLCB7bmFtZSwgdHlwZTogJ21vZHVsZSd9KVxuICAgICAgICAgICAgICAgIDogbmV3IGNscyhmaWxlUGF0aCwge25hbWV9KTtcblxuICAgICAgICAoaXNTaGFyZWQgPyB3b3JrZXIucG9ydCA6IHdvcmtlcikub25tZXNzYWdlID0gbWUub25Xb3JrZXJNZXNzYWdlLmJpbmQobWUpO1xuICAgICAgICAoaXNTaGFyZWQgPyB3b3JrZXIucG9ydCA6IHdvcmtlcikub25lcnJvciAgID0gbWUub25Xb3JrZXJFcnJvciAgLmJpbmQobWUpO1xuXG4gICAgICAgIG1lLmFjdGl2ZVdvcmtlcnMrKztcblxuICAgICAgICByZXR1cm4gd29ya2VyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgY3JlYXRlV29ya2VyIGZvciBlYWNoIHdvcmtlciBpbnNpZGUgdGhlIHRoaXMud29ya2VycyBjb25maWcuXG4gICAgICovXG4gICAgY3JlYXRlV29ya2VycygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgICAgICAgICAgICAgID0gTmVvLmNsb25lKE5lb0NvbmZpZywgdHJ1ZSksXG4gICAgICAgICAgICB7aGFzaCwgaHJlZiwgc2VhcmNofSA9IGxvY2F0aW9uLFxuICAgICAgICAgICAge3dpbmRvd0lkfSAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIGtleSwgdmFsdWU7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvbmZpZ3Mgd2hpY2ggYXJlIG5vdCByZWxldmFudCBmb3IgdGhlIHdvcmtlcnMgc2NvcGVcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5jZXNpdW1Kc1Rva2VuO1xuXG4gICAgICAgIC8vIHBhc3MgdGhlIGluaXRpYWwgaGFzaCB2YWx1ZSBhcyBOZW8uY29uZmlnc1xuICAgICAgICBpZiAoaGFzaCkge1xuICAgICAgICAgICAgY29uZmlnLmhhc2ggPSB7XG4gICAgICAgICAgICAgICAgaGFzaCAgICAgIDogRG9tRXZlbnRzLnBhcnNlSGFzaChoYXNoLnN1YnN0cmluZygxKSksXG4gICAgICAgICAgICAgICAgaGFzaFN0cmluZzogaGFzaC5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy51cmwgPSB7aHJlZiwgc2VhcmNofTtcblxuICAgICAgICBmb3IgKFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZS53b3JrZXJzKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NhbnZhcycgJiYgIWNvbmZpZy51c2VDYW52YXNXb3JrZXIgfHxcbiAgICAgICAgICAgICAgICBrZXkgPT09ICd0YXNrJyAgICYmICFjb25maWcudXNlVGFza1dvcmtlciAgIHx8XG4gICAgICAgICAgICAgICAga2V5ID09PSAndmRvbScgICAmJiAhY29uZmlnLnVzZVZkb21Xb3JrZXJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUud29ya2VyID0gbWUuY3JlYXRlV29ya2VyKHZhbHVlKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gZTtcbiAgICAgICAgICAgICAgICBtZS5zdG9wQ29tbXVuaWNhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2Uoa2V5LCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVnaXN0ZXJOZW9Db25maWcnLFxuICAgICAgICAgICAgICAgIGRhdGEgIDogey4uLmNvbmZpZywgd2luZG93SWR9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXRlY3RGZWF0dXJlcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBOZW9Db25maWcuaGFzTW91c2VFdmVudHMgPSBtYXRjaE1lZGlhKCcocG9pbnRlcjpmaW5lKScpLm1hdGNoZXM7XG4gICAgICAgIE5lb0NvbmZpZy5oYXNUb3VjaEV2ZW50cyA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IChuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKTtcblxuICAgICAgICAvLyBVc2VmdWwgZm9yIHN0eWxpbmdcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKE5lb0NvbmZpZy5oYXNNb3VzZUV2ZW50cyA/ICduZW8tbW91c2UnIDogJ25lby1uby1tb3VzZScpO1xuXG4gICAgICAgIGlmICh3aW5kb3cuV29ya2VyKSB7XG4gICAgICAgICAgICBtZS53ZWJXb3JrZXJzRW5hYmxlZCA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViIFdvcmtlcnMnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpbmRvdy5TaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgIG1lLnNoYXJlZFdvcmtlcnNFbmFibGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8V29ya2VyfSBuYW1lXG4gICAgICogQHJldHVybnMge1dvcmtlcn1cbiAgICAgKi9cbiAgICBnZXRXb3JrZXIobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3NlcnZpY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXI/LmNvbnRyb2xsZXIgfHwgdGhpcy5zZXJ2aWNlV29ya2VyXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZSBpbnN0YW5jZW9mIFdvcmtlciA/IG5hbWUgOiB0aGlzLndvcmtlcnNbbmFtZV0ud29ya2VyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKi9cbiAgICBsb2FkQXBwbGljYXRpb24ocGF0aCkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKCdhcHAnLCB7XG4gICAgICAgICAgICBhY3Rpb24gICAgICAgOiAnbG9hZEFwcGxpY2F0aW9uJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICByZXNvdXJjZXNQYXRoOiBOZW9Db25maWcucmVzb3VyY2VzUGF0aFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Xb3JrZXJDb25zdHJ1Y3RlZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY29uc3RydWN0ZWRUaHJlYWRzKys7XG5cbiAgICAgICAgaWYgKG1lLmNvbnN0cnVjdGVkVGhyZWFkcyA9PT0gbWUuYWN0aXZlV29ya2Vycykge1xuICAgICAgICAgICAgLy8gYmV0dGVyIHNhZmUgdGhhbiBzb3JyeSA9PiBhbGwgcmVtb3RlcyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIE5lb0NvbmZpZy5hcHBQYXRoICYmIG1lLnRpbWVvdXQoTmVvQ29uZmlnLmxvYWRBcHBsaWNhdGlvbkRlbGF5KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5sb2FkQXBwbGljYXRpb24oTmVvQ29uZmlnLmFwcFBhdGgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBtZXRob2QgZm9yIHdvcmtlciBlcnJvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgICAqL1xuICAgIG9uV29ya2VyRXJyb3IoZSkge1xuICAgICAgICAvLyBzdGFydGluZyBhIHdvcmtlciBmcm9tIGEgSlMgbW9kdWxlIHdpbGwgc2hvdyBKUyBlcnJvcnMgaW4gYSBjb3JyZWN0IHdheVxuICAgICAgICAhaGFzSnNNb2R1bGVzICYmIGNvbnNvbGUubG9nKCdXb3JrZXIgRXJyb3I6JywgZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIG1ldGhvZCBmb3Igd29ya2VyIG1lc3NhZ2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgb25Xb3JrZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZGF0YX0gICA9IGV2ZW50LFxuICAgICAgICAgICAgdHJhbnNmZXIgPSBudWxsLFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICBjb25zdCB7YWN0aW9uLCBkZXN0aW5hdGlvbjogZGVzdCwgcmVwbHlJZH0gPSBkYXRhO1xuXG4gICAgICAgIG1lLmZpcmUoJ21lc3NhZ2U6JythY3Rpb24sIGRhdGEpO1xuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXBseScpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBtZS5wcm9taXNlc1tyZXBseUlkXTtcblxuICAgICAgICAgICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGEuYXV0b01vdW50ICAmJiBtZS5maXJlKCdhdXRvbW91bnQnLCAgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YS51cGRhdGVWZG9tICYmIG1lLmZpcmUoJ3VwZGF0ZVZkb20nLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIGRlbGF5IHRoZSBtZXNzYWdlIHVudGlsIHRoZSByZW5kZXJpbmcgcXVldWUgaGFzIHByb2Nlc3NlZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yODY0XG4gICAgICAgICAgICAgICAgICAgIG1lLnByb21pc2VGb3J3YXJkTWVzc2FnZShkYXRhKS50aGVuKG1zZ0RhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UobXNnRGF0YS5kZXN0aW5hdGlvbiwgbXNnRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkZXN0ID09PSAnbWFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuZGF0YVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByb21pc2VbZGF0YS5yZWplY3QgPyAncmVqZWN0JyA6ICdyZXNvbHZlJ10oZGF0YSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lLnByb21pc2VzW3JlcGx5SWRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzdCAhPT0gJ21haW4nICYmIGFjdGlvbiAhPT0gJ3JlcGx5Jykge1xuICAgICAgICAgICAgaWYgKGRhdGEudHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2ZlciA9IFtkYXRhLnRyYW5zZmVyXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5wcm9taXNlTWVzc2FnZShkZXN0LCBkYXRhLCB0cmFuc2ZlcikudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UocmVzcG9uc2UuZGVzdGluYXRpb24sIHJlc3BvbnNlKVxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZShkYXRhLm9yaWdpbiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gOiAncmVwbHknLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZXBseUlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvciAgOiBlcnIubWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBuZWVkZWQgZm9yIFNoYXJlZFdvcmtlcnNcbiAgICAgICAgZWxzZSBpZiAoZGVzdCA9PT0gJ21haW4nICYmIGFjdGlvbiA9PT0gJ3JlZ2lzdGVyQXBwTmFtZScpIHtcbiAgICAgICAgICAgIGxldCB7YXBwTmFtZX0gPSBkYXRhO1xuXG4gICAgICAgICAgICBtZS5hcHBOYW1lcy5wdXNoKGFwcE5hbWUpO1xuXG4gICAgICAgICAgICBtZS5icm9hZGNhc3Qoe2FjdGlvbjogJ3JlZ2lzdGVyQXBwJywgYXBwTmFtZX0pXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChkZXN0ID09PSAnbWFpbicgJiYgYWN0aW9uID09PSAncmVtb3RlTWV0aG9kJykge1xuICAgICAgICAgICAgbWUub25SZW1vdGVNZXRob2QoZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEucmVwbHlJZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZUZvcndhcmRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvbWlzZXNbZGF0YS5yZXBseUlkXSA9IHtkYXRhLCByZWplY3QsIHJlc29sdmV9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc3QgYXBwLCBjYW52YXMsIGRhdGEgb3IgdmRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIGNvbmZpZ3MgZm9yIE5lby53b3JrZXIuTWVzc2FnZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2Zlcl0gQW4gb3B0aW9uYWwgYXJyYXkgb2YgVHJhbnNmZXJhYmxlIG9iamVjdHMgdG8gdHJhbnNmZXIgb3duZXJzaGlwIG9mLlxuICAgICAqIElmIHRoZSBvd25lcnNoaXAgb2YgYW4gb2JqZWN0IGlzIHRyYW5zZmVycmVkLCBpdCBiZWNvbWVzIHVudXNhYmxlIChuZXV0ZXJlZCkgaW4gdGhlIGNvbnRleHQgaXQgd2FzIHNlbnQgZnJvbVxuICAgICAqIGFuZCBiZWNvbWVzIGF2YWlsYWJsZSBvbmx5IHRvIHRoZSB3b3JrZXIgaXQgd2FzIHNlbnQgdG8uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9taXNlTWVzc2FnZShkZXN0LCBvcHRzLCB0cmFuc2Zlcikge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IG1lLnNlbmRNZXNzYWdlKGRlc3QsIG9wdHMsIHRyYW5zZmVyKSxcbiAgICAgICAgICAgICAgICBtc2dJZCAgID0gbWVzc2FnZS5pZDtcblxuICAgICAgICAgICAgbWUucHJvbWlzZXNbbXNnSWRdID0ge3JlamVjdCwgcmVzb2x2ZX1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVwbHlJZFxuICAgICAqL1xuICAgIHJlc29sdmVEb21PcGVyYXRpb25Qcm9taXNlKHJlcGx5SWQpIHtcbiAgICAgICAgaWYgKHJlcGx5SWQpIHtcbiAgICAgICAgICAgIGxldCB7cHJvbWlzZXN9ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwcm9taXNlICAgID0gcHJvbWlzZXNbcmVwbHlJZF07XG5cbiAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHByb21pc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb21pc2VzW3JlcGx5SWRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzdCBhcHAsIGNhbnZhcywgZGF0YSBvciB2ZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgY29uZmlncyBmb3IgTmVvLndvcmtlci5NZXNzYWdlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3RyYW5zZmVyXSBBbiBvcHRpb25hbCBhcnJheSBvZiBUcmFuc2ZlcmFibGUgb2JqZWN0cyB0byB0cmFuc2ZlciBvd25lcnNoaXAgb2YuXG4gICAgICogSWYgdGhlIG93bmVyc2hpcCBvZiBhbiBvYmplY3QgaXMgdHJhbnNmZXJyZWQsIGl0IGJlY29tZXMgdW51c2FibGUgKG5ldXRlcmVkKSBpbiB0aGUgY29udGV4dCBpdCB3YXMgc2VudCBmcm9tXG4gICAgICogYW5kIGJlY29tZXMgYXZhaWxhYmxlIG9ubHkgdG8gdGhlIHdvcmtlciBpdCB3YXMgc2VudCB0by5cbiAgICAgKiBAcmV0dXJucyB7TmVvLndvcmtlci5NZXNzYWdlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShkZXN0LCBvcHRzLCB0cmFuc2Zlcikge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbWVzc2FnZSwgd29ya2VyO1xuXG4gICAgICAgIGlmICghbWUuc3RvcENvbW11bmljYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmNoYW5uZWxQb3J0KSB7XG4gICAgICAgICAgICAgICAgd29ya2VyID0gb3B0cy5jaGFubmVsUG9ydDtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0cy5jaGFubmVsUG9ydFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIgPSBtZS5nZXRXb3JrZXIoZGVzdClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF3b3JrZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxlZCBzZW5kTWVzc2FnZSBmb3IgYSB3b3JrZXIgdGhhdCBkb2VzIG5vdCBleGlzdDogJyArIGRlc3QpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdHMuZGVzdGluYXRpb24gPSBkZXN0O1xuXG4gICAgICAgICAgICBtZXNzYWdlID0gbmV3IE1lc3NhZ2Uob3B0cyk7XG5cbiAgICAgICAgICAgICh3b3JrZXIucG9ydCA/IHdvcmtlci5wb3J0IDogd29ya2VyKS5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2Zlcik7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYW5hZ2VyKTtcbiIsImltcG9ydCBJZEdlbmVyYXRvciBmcm9tICcuLi9jb3JlL0lkR2VuZXJhdG9yLm1qcyc7XG5cbi8qKlxuICogQSB3cmFwcGVyIGZvciB3b3JrZXIgcG9zdCBtZXNzYWdlcyBzZW50IGJldHdlZW4gdGhlIEFwcCwgRGF0YSwgVkRvbSB3b3JrZXIgJiB0aGUgbWFpbiB0aHJlYWQuXG4gKiBZb3UgY2FuIGFkZCBvcHRpb25hbCBwYXJhbXMgYXMgbmVlZGVkLlxuICogQGNsYXNzIE5lby53b3JrZXIuTWVzc2FnZVxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGFjdGlvblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkZXN0aW5hdGlvbj0nbWFpbidcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaWQ9SWRHZW5lcmF0b3IuZ2V0SWQoTmVvLndvcmtlcklkKVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBvcmlnaW49TmVvLndvcmtlcklkXG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbmZpZy5kZXN0aW5hdGlvbiA9IGNvbmZpZy5kZXN0aW5hdGlvbiB8fCAnbWFpbic7XG4gICAgICAgIGNvbmZpZy5pZCAgICAgICAgICA9IGNvbmZpZy5pZCAgICAgICAgICB8fCBJZEdlbmVyYXRvci5nZXRJZChOZW8ud29ya2VySWQpO1xuICAgICAgICBjb25maWcub3JpZ2luICAgICAgPSBjb25maWcub3JpZ2luICAgICAgfHwgTmVvLndvcmtlcklkO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKVxuICAgIH1cbn1cblxuY29uc3QgbnMgPSBOZW8ubnMoJ05lby53b3JrZXInLCB0cnVlKTtcbm5zWydNZXNzYWdlJ10gPSBNZXNzYWdlO1xuXG5leHBvcnQgZGVmYXVsdCBNZXNzYWdlO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFJlbW90ZU1ldGhvZEFjY2VzcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLndvcmtlci5taXhpbi5SZW1vdGVNZXRob2RBY2Nlc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1peGluPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW46IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIGFzc2lnblBvcnQoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3Qge2FwcE5hbWUsIHBvcnQsIHdpbmRvd0lkfSA9IHNvdXJjZTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7YXBwTmFtZSwgcG9ydCwgd2luZG93SWR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlbW90ZVxuICAgICAqIEBwYXJhbSBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oKj0sICo9KTogUHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGdlbmVyYXRlUmVtb3RlKHJlbW90ZSwgbWV0aG9kKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3JpZ2lufSA9IHJlbW90ZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgYnVmZmVyKSB7XG4gICAgICAgICAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gICAgICAgICA6ICdyZW1vdGVNZXRob2QnLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gICAgOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgcmVtb3RlQ2xhc3NOYW1lOiByZW1vdGUuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHJlbW90ZU1ldGhvZCAgIDogbWV0aG9kXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBtZS5pc1NoYXJlZFdvcmtlciAmJiBtZS5hc3NpZ25Qb3J0KGRhdGEsIG9wdHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUucHJvbWlzZU1lc3NhZ2Uob3JpZ2luLCBvcHRzLCBidWZmZXIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVtb3RlXG4gICAgICovXG4gICAgb25SZWdpc3RlclJlbW90ZShyZW1vdGUpIHtcbiAgICAgICAgaWYgKHJlbW90ZS5kZXN0aW5hdGlvbiA9PT0gTmVvLndvcmtlcklkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtjbGFzc05hbWUsIG1ldGhvZHN9ID0gcmVtb3RlLFxuICAgICAgICAgICAgICAgIHBrZyAgICAgICAgICAgICAgICAgID0gTmVvLm5zKGNsYXNzTmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIG1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGUub3JpZ2luICE9PSAnbWFpbicgJiYgcGtnW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgcmVtb3RlIG1ldGhvZCBkZWZpbml0aW9uICcgKyBjbGFzc05hbWUgKyAnLicgKyBtZXRob2QpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGtnW21ldGhvZF0gPz89IG1lLmdlbmVyYXRlUmVtb3RlKHJlbW90ZSwgbWV0aG9kKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKi9cbiAgICBvblJlbW90ZU1ldGhvZChtc2cpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBwa2cgPSBOZW8ubnMobXNnLnJlbW90ZUNsYXNzTmFtZSksXG4gICAgICAgICAgICBvdXQsIG1ldGhvZDtcblxuICAgICAgICBpZiAoIXBrZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbW90ZSBuYW1lc3BhY2UgXCInICsgbXNnLnJlbW90ZUNsYXNzTmFtZSArICdcIicpXG4gICAgICAgIH1cblxuICAgICAgICBtZXRob2QgPSBwa2dbbXNnLnJlbW90ZU1ldGhvZF07XG5cbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZW1vdGUgbWV0aG9kIG5hbWUgXCInICsgbXNnLnJlbW90ZU1ldGhvZCArICdcIicpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtc2cuZGF0YSkpIHtcbiAgICAgICAgICAgIG91dCA9IG1ldGhvZC5jYWxsKHBrZywgLi4ubXNnLmRhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgPSBtZXRob2QuY2FsbChwa2csIG1zZy5kYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG91dFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogSW50ZW5kZWQgbG9naWM6XG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGNvZGUgb2YgYSByZW1vdGUgbWV0aG9kIGZhaWxzLCBpdCB3b3VsZCBub3Qgc2hvdyBhbnkgZXJyb3JzIGluc2lkZSB0aGUgY29uc29sZSxcbiAgICAgICAgICAgICAgICAgKiBzbyB3ZSB3YW50IHRvIG1hbnVhbGx5IGxvZyB0aGUgZXJyb3IgZm9yIGRlYnVnZ2luZy5cbiAgICAgICAgICAgICAgICAgKiBSZWplY3RpbmcgdGhlIFByb21pc2UgZ2l2ZXMgdXMgdGhlIGNoYW5jZSB0byByZWNvdmVyLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogRXhhbXBsZTpcbiAgICAgICAgICAgICAgICAgKiBOZW8udmRvbS5IZWxwZXIudXBkYXRlKG9wdHMpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICogICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICogICAgIHJlamVjdD8uKClcbiAgICAgICAgICAgICAgICAgKiB9KS50aGVuKGRhdGEgPT4gey4uLn0pXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7Y29uc29sZS5lcnJvcihlcnIpOyBtZS5yZWplY3QobXNnLCBlcnIpfSlcbiAgICAgICAgICAgICAgICAudGhlbihkYXRhID0+IHttZS5yZXNvbHZlKG1zZywgZGF0YSl9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUucmVzb2x2ZShtc2csIG91dClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gcHJvbWlzZU1lc3NhZ2UgZ2V0cyByZWplY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHJlamVjdChtc2csIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgYWN0aW9uIDogJ3JlcGx5JyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZWplY3QgOiB0cnVlLFxuICAgICAgICAgICAgcmVwbHlJZDogbXNnLmlkXG4gICAgICAgIH07XG5cbiAgICAgICAgbWUuaXNTaGFyZWRXb3JrZXIgJiYgbWUuYXNzaWduUG9ydChtc2csIG9wdHMpO1xuICAgICAgICBtZS5zZW5kTWVzc2FnZShtc2cub3JpZ2luLCBvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gcHJvbWlzZU1lc3NhZ2UgZ2V0cyByZXNvbHZlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHJlc29sdmUobXNnLCBkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG5cbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgIGFjdGlvbiA6ICdyZXBseScsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVwbHlJZDogbXNnLmlkXG4gICAgICAgIH07XG5cbiAgICAgICAgbWUuaXNTaGFyZWRXb3JrZXIgJiYgbWUuYXNzaWduUG9ydChtc2csIG9wdHMpO1xuICAgICAgICBtZS5zZW5kTWVzc2FnZShtc2cub3JpZ2luLCBvcHRzKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUmVtb3RlTWV0aG9kQWNjZXNzKTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5mID0ge307XG4vLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4vLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18uZSA9IChjaHVua0lkKSA9PiB7XG5cdHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmYpLnJlZHVjZSgocHJvbWlzZXMsIGtleSkgPT4ge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZltrZXldKGNodW5rSWQsIHByb21pc2VzKTtcblx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdH0sIFtdKSk7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy51ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcImNodW5rcy9tYWluL1wiICsgY2h1bmtJZCArIFwiLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJ2YXIgaW5Qcm9ncmVzcyA9IHt9O1xudmFyIGRhdGFXZWJwYWNrUHJlZml4ID0gXCJuZW8ubWpzOlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXG5cdFx0c2NyaXB0LnNyYyA9IHVybDtcblx0fVxuXHRpblByb2dyZXNzW3VybF0gPSBbZG9uZV07XG5cdHZhciBvblNjcmlwdENvbXBsZXRlID0gKHByZXYsIGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHZhciBkb25lRm5zID0gaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdGRlbGV0ZSBpblByb2dyZXNzW3VybF07XG5cdFx0c2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkb25lRm5zICYmIGRvbmVGbnMuZm9yRWFjaCgoZm4pID0+IChmbihldmVudCkpKTtcblx0XHRpZihwcmV2KSByZXR1cm4gcHJldihldmVudCk7XG5cdH1cblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjsiLCIvLyBubyBiYXNlVVJJXG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJtYWluXCI6IDBcbn07XG5cbl9fd2VicGFja19yZXF1aXJlX18uZi5qID0gKGNodW5rSWQsIHByb21pc2VzKSA9PiB7XG5cdFx0Ly8gSlNPTlAgY2h1bmsgbG9hZGluZyBmb3IgamF2YXNjcmlwdFxuXHRcdHZhciBpbnN0YWxsZWRDaHVua0RhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSA/IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA6IHVuZGVmaW5lZDtcblx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgIT09IDApIHsgLy8gMCBtZWFucyBcImFscmVhZHkgaW5zdGFsbGVkXCIuXG5cblx0XHRcdC8vIGEgUHJvbWlzZSBtZWFucyBcImN1cnJlbnRseSBsb2FkaW5nXCIuXG5cdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodHJ1ZSkgeyAvLyBhbGwgY2h1bmtzIGhhdmUgSlNcblx0XHRcdFx0XHQvLyBzZXR1cCBQcm9taXNlIGluIGNodW5rIGNhY2hlXG5cdFx0XHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiAoaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF0pKTtcblx0XHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSA9IHByb21pc2UpO1xuXG5cdFx0XHRcdFx0Ly8gc3RhcnQgY2h1bmsgbG9hZGluZ1xuXHRcdFx0XHRcdHZhciB1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLnUoY2h1bmtJZCk7XG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGVycm9yIGJlZm9yZSBzdGFjayB1bndvdW5kIHRvIGdldCB1c2VmdWwgc3RhY2t0cmFjZSBsYXRlclxuXHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcigpO1xuXHRcdFx0XHRcdHZhciBsb2FkaW5nRW5kZWQgPSAoZXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpKSB7XG5cdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdFx0XHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJlYWxTcmMgPSBldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LnNyYztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5tZXNzYWdlID0gJ0xvYWRpbmcgY2h1bmsgJyArIGNodW5rSWQgKyAnIGZhaWxlZC5cXG4oJyArIGVycm9yVHlwZSArICc6ICcgKyByZWFsU3JjICsgJyknO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlYWxTcmM7XG5cdFx0XHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtEYXRhWzFdKGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkLCBcImNodW5rLVwiICsgY2h1bmtJZCwgY2h1bmtJZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG59O1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xudmFyIHdlYnBhY2tKc29ucENhbGxiYWNrID0gKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uLCBkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMDtcblx0aWYoY2h1bmtJZHMuc29tZSgoaWQpID0+IChpbnN0YWxsZWRDaHVua3NbaWRdICE9PSAwKSkpIHtcblx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHJ1bnRpbWUpIHZhciByZXN1bHQgPSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR9XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0oKTtcblx0XHR9XG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0fVxuXG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rbmVvX21qc1wiXSA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtuZW9fbWpzXCJdIHx8IFtdO1xuY2h1bmtMb2FkaW5nR2xvYmFsLmZvckVhY2god2VicGFja0pzb25wQ2FsbGJhY2suYmluZChudWxsLCAwKSk7XG5jaHVua0xvYWRpbmdHbG9iYWwucHVzaCA9IHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2guYmluZChjaHVua0xvYWRpbmdHbG9iYWwpKTsiLCJpbXBvcnQgTmVvICAgICAgICAgICBmcm9tICcuL05lby5tanMnO1xuaW1wb3J0ICogYXMgY29yZSAgICAgZnJvbSAnLi9jb3JlL19leHBvcnQubWpzJztcbmltcG9ydCBEb21BY2Nlc3MgICAgIGZyb20gJy4vbWFpbi9Eb21BY2Nlc3MubWpzJzsgLy8gaGFzIHRvIGdldCBpbXBvcnRlZCBiZWZvcmUgRGVsdGFVcGRhdGVzXG5pbXBvcnQgRGVsdGFVcGRhdGVzICBmcm9tICcuL21haW4vRGVsdGFVcGRhdGVzLm1qcyc7XG5pbXBvcnQgRG9tRXZlbnRzICAgICBmcm9tICcuL21haW4vRG9tRXZlbnRzLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICBmcm9tICcuL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFdvcmtlck1hbmFnZXIgZnJvbSAnLi93b3JrZXIvTWFuYWdlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uTWFpblxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBNYWluIGV4dGVuZHMgY29yZS5CYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uTWFpbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLk1haW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBtb2RlPSdyZWFkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlOiAncmVhZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG9wZW5XaW5kb3dzPXt9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG9wZW5XaW5kb3dzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSByZWFkUXVldWU9W11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZFF1ZXVlOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIGZvciBvdGhlciB3b3JrZXJzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVtb3RlPXthcHA6IFsvLy4uLl19XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2FsZXJ0JyxcbiAgICAgICAgICAgICAgICAnZWRpdFJvdXRlJyxcbiAgICAgICAgICAgICAgICAnZ2V0QnlQYXRoJyxcbiAgICAgICAgICAgICAgICAnZ2V0V2luZG93RGF0YScsXG4gICAgICAgICAgICAgICAgJ2ltcG9ydEFkZG9uJyxcbiAgICAgICAgICAgICAgICAnbG9nJyxcbiAgICAgICAgICAgICAgICAncmVkaXJlY3RUbycsXG4gICAgICAgICAgICAgICAgJ3JlbG9hZFdpbmRvdycsXG4gICAgICAgICAgICAgICAgJ3NldE5lb0NvbmZpZycsXG4gICAgICAgICAgICAgICAgJ3NldFJvdXRlJyxcbiAgICAgICAgICAgICAgICAnd2luZG93Q2xvc2UnLFxuICAgICAgICAgICAgICAgICd3aW5kb3dDbG9zZUFsbCcsXG4gICAgICAgICAgICAgICAgJ3dpbmRvd01vdmVUbycsXG4gICAgICAgICAgICAgICAgJ3dpbmRvd09wZW4nLFxuICAgICAgICAgICAgICAgICd3aW5kb3dSZXNpemVUbydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJ1bm5pbmc9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93RnBzPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93RnBzOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdGltZUxpbWl0PTE1XG4gICAgICAgICAqL1xuICAgICAgICB0aW1lTGltaXQ6IDE1LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2hvdWxkIGJlIGRldiBvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdG90YWxGcmFtZUNvdW50PTBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdG90YWxGcmFtZUNvdW50OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IHVwZGF0ZVF1ZXVlPVtdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVF1ZXVlOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSB3cml0ZVF1ZXVlPVtdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlUXVldWU6IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBXb3JrZXJNYW5hZ2VyLm9uKHtcbiAgICAgICAgICAgICdhdXRvbW91bnQnICAgICAgICA6IG1lLm9uUmVuZGVyLFxuICAgICAgICAgICAgJ21lc3NhZ2U6bW91bnREb20nIDogbWUub25Nb3VudERvbSxcbiAgICAgICAgICAgICdtZXNzYWdlOnVwZGF0ZURvbSc6IG1lLm9uVXBkYXRlRG9tLFxuICAgICAgICAgICAgJ3VwZGF0ZVZkb20nICAgICAgIDogbWUub25VcGRhdGVWZG9tLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgICAgICAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgRG9tRXZlbnRzLm9uKCdkb21Db250ZW50TG9hZGVkJywgbWUub25Eb21Db250ZW50TG9hZGVkLCBtZSk7XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgRG9tRXZlbnRzLm9uRG9tQ29udGVudExvYWRlZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXb3JrZXJzIGNhbiBub3QgdHJpZ2dlciBhbGVydCgpLCBzbyB3ZSBuZWVkIHJlbW90ZSBtZXRob2QgYWNjZXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubWVzc2FnZVxuICAgICAqL1xuICAgIGFsZXJ0KGRhdGEpIHtcbiAgICAgICAgYWxlcnQoZGF0YS5tZXNzYWdlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVkaXQgdGhlIGxvY2F0aW9uLmhhc2ggdmFsdWVcbiAgICAgKiBBIHZhbHVlIG9mIG51bGwgd2lsbCByZW1vdmUgdGhlIGdpdmVuIGtleS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVkaXRSb3V0ZShkYXRhKSB7XG4gICAgICAgIGxldCBoYXNoT2JqID0gRG9tRXZlbnRzLnBhcnNlSGFzaCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpLFxuICAgICAgICAgICAgaGFzaEFyciA9IFtdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRhdGEgPSBEb21FdmVudHMucGFyc2VIYXNoKGRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKGhhc2hPYmosIGRhdGEpO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGhhc2hPYmopLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGFzaEFyci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoQXJyLmpvaW4oJyYnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3Qgc3BlY2lmaWMgYWNjZXNzaWJsZSB3aW5kb3cgYXR0cmlidXRlcyBieSBwYXRoIGludG8gdGhlIGFwcCB3b3JrZXIuXG4gICAgICogS2VlcCBpbiBtaW5kIHRoYXQgdGhpcyBleGNsdWRlcyBhbnl0aGluZyBET00gcmVsYXRlZCBvciBpbnN0YW5jZXMuXG4gICAgICogSW4gY2FzZSB5b3VyIHBhdGggbWF0Y2hlcyBhIG1ldGhvZCwgeW91IGNhbiBhbHNvIHBhc3MgcGFyYW1zIGZvciBpdC5cbiAgICAgKiBAZXhhbXBsZTpcbiAgICAgKiAgICAgTmVvLk1haW4uZ2V0QnlQYXRoKHtwYXRoOiAnbmF2aWdhdG9yLmxhbmd1YWdlJ30pLnRoZW4oZGF0YSA9PiB7fSlcbiAgICAgKiBAZXhhbXBsZTpcbiAgICAgKiAgICAgTmVvLk1haW4uZ2V0QnlQYXRoKHtwYXRoOiAnQ1NTLnN1cHBvcnRzJywgcGFyYW1zOiBbJ2Rpc3BsYXk6IGZsZXgnXX0pLnRoZW4oZGF0YSA9PiB7fSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBkYXRhLnBhcmFtcz1bXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnBhdGhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRCeVBhdGgoe3BhcmFtcz1bXSwgcGF0aH0pIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IE5lby5uc1dpdGhBcnJheXMocGF0aCk7XG4gICAgICAgIHJldHVybiBOZW8uaXNGdW5jdGlvbih0YXJnZXQpID8gdGFyZ2V0KC4uLnBhcmFtcykgOiB0YXJnZXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB3aW5kb3cuc2NyZWVuIGlzIG5vdCBzcHJlYWRhYmxlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRXaW5kb3dEYXRhKCkge1xuICAgICAgICBsZXQgd2luICAgICAgPSB3aW5kb3csXG4gICAgICAgICAgICB7c2NyZWVufSA9IHdpbjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5uZXJIZWlnaHQ6IHdpbi5pbm5lckhlaWdodCxcbiAgICAgICAgICAgIGlubmVyV2lkdGggOiB3aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIG91dGVySGVpZ2h0OiB3aW4ub3V0ZXJIZWlnaHQsXG4gICAgICAgICAgICBvdXRlcldpZHRoIDogd2luLm91dGVyV2lkdGgsXG4gICAgICAgICAgICBzY3JlZW46IHtcbiAgICAgICAgICAgICAgICBhdmFpbEhlaWdodDogc2NyZWVuLmF2YWlsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsTGVmdCAgOiBzY3JlZW4uYXZhaWxMZWZ0LFxuICAgICAgICAgICAgICAgIGF2YWlsVG9wICAgOiBzY3JlZW4uYXZhaWxUb3AsXG4gICAgICAgICAgICAgICAgYXZhaWxXaWR0aCA6IHNjcmVlbi5hdmFpbFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbG9yRGVwdGggOiBzY3JlZW4uY29sb3JEZXB0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgICAgIDogc2NyZWVuLmhlaWdodCxcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjoge2FuZ2xlOiBzY3JlZW4ub3JpZW50YXRpb24/LmFuZ2xlLCB0eXBlOiBzY3JlZW4ub3JpZW50YXRpb24/LnR5cGV9LFxuICAgICAgICAgICAgICAgIHBpeGVsRGVwdGggOiBzY3JlZW4ucGl4ZWxEZXB0aCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgIDogc2NyZWVuLndpZHRoXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NyZWVuTGVmdDogd2luLnNjcmVlbkxlZnQsXG4gICAgICAgICAgICBzY3JlZW5Ub3AgOiB3aW4uc2NyZWVuVG9wXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBvcnQgbWFpbiB0aHJlYWQgYWRkb25zIGF0IHJ1bi10aW1lIGZyb20gd2l0aGluIHRoZSBhcHAgd29ya2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5uYW1lXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgYXN5bmMgaW1wb3J0QWRkb24oZGF0YSkge1xuICAgICAgICBsZXQge25hbWV9ID0gZGF0YSxcbiAgICAgICAgICAgIG1vZHVsZTtcblxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdXUy8nKSkge1xuICAgICAgICAgICAgbW9kdWxlID0gYXdhaXQgaW1wb3J0KGAuLi8uLi8uLi9zcmMvbWFpbi9hZGRvbi8ke25hbWUuc3Vic3RyaW5nKDMpfS5tanNgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlID0gYXdhaXQgaW1wb3J0KGAuL21haW4vYWRkb24vJHtuYW1lfS5tanNgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckFkZG9uKG1vZHVsZS5kZWZhdWx0KTtcbiAgICAgICAgYXdhaXQgdGhpcy50aW1lb3V0KDIwKTsgLy8gV2FpdCB1bnRpbCByZW1vdGVzIGFyZSByZWdpc3RlcmVkXG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdGUgY29uc29sZSBhY2Nlc3MgdG8gbWFpbiB0aHJlYWRzLlxuICAgICAqIFlvdSBjYW4gdXNlIGFwcE5hbWUgb3Igd2luZG93SWQgdG8gdGFyZ2V0IHNwZWNpZmljIHdpbmRvd3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEuYXBwTmFtZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS52YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5tZXRob2RdIGRlZmF1bHRzIHRvICdsb2cnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLndpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGxvZyhkYXRhKSB7XG4gICAgICAgIGNvbnNvbGVbZGF0YS5tZXRob2QgfHwgJ2xvZyddKGRhdGEudmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgb25Eb21Db250ZW50TG9hZGVkKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbmZpZ30gPSBOZW8sXG4gICAgICAgICAgICBpbXBvcnRzICA9IFtdLFxuICAgICAgICAgICAge2Vudmlyb25tZW50LCBtYWluVGhyZWFkQWRkb25zLCB1c2VTZXJ2aWNlV29ya2VyfSA9IGNvbmZpZyxcbiAgICAgICAgICAgIG1vZHVsZXM7XG5cbiAgICAgICAgRG9tQWNjZXNzLm9uRG9tQ29udGVudExvYWRlZCgpO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgZGlmZmVyZW50IHB1YmxpY1BhdGggdmFsdWVzIGZvciB0aGUgbWFpbiB0aHJlYWQgaW5zaWRlIHRoZSB3ZWJwYWNrIGJhc2VkIGRpc3QgZW52cyxcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRoZSBoaWVyYXJjaHkgbGV2ZWwgb2YgdGhlIGFwcCBlbnRyeSBwb2ludFxuICAgICAgICBpZiAoZW52aXJvbm1lbnQgPT09ICdkaXN0L2RldmVsb3BtZW50JyB8fCBlbnZpcm9ubWVudCA9PT0gJ2Rpc3QvcHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IGNvbmZpZy5iYXNlUGF0aC5zdWJzdHJpbmcoNilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludGVuZGVkIGZvciB0aGUgb25saW5lIGV4YW1wbGVzIHdoZXJlIHdlIG5lZWQgYW4gZWFzeSB3YXkgdG8gYWRkIEdBIHRvIGV2ZXJ5IGdlbmVyYXRlZCBhcHBcbiAgICAgICAgaWYgKGNvbmZpZy51c2VHb29nbGVBbmFseXRpY3MgJiYgIW1haW5UaHJlYWRBZGRvbnMuaW5jbHVkZXMoJ0FuYWx5dGljc0J5R29vZ2xlJykpIHtcbiAgICAgICAgICAgIG1haW5UaHJlYWRBZGRvbnMucHVzaCgnQW5hbHl0aWNzQnlHb29nbGUnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChcbiAgICAgICAgICAgICAgICB1c2VTZXJ2aWNlV29ya2VyID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgdXNlU2VydmljZVdvcmtlciA9PT0gZW52aXJvbm1lbnQgfHxcbiAgICAgICAgICAgICAgICAodXNlU2VydmljZVdvcmtlciA9PT0gJ2Rpc3QvcHJvZHVjdGlvbicgJiYgZW52aXJvbm1lbnQgPT09ICdkaXN0L2VzbScpXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICAhbWFpblRocmVhZEFkZG9ucy5pbmNsdWRlcygnU2VydmljZVdvcmtlcicpXG4gICAgICAgICkge1xuICAgICAgICAgICAgbWFpblRocmVhZEFkZG9ucy5wdXNoKCdTZXJ2aWNlV29ya2VyJylcbiAgICAgICAgfVxuXG4gICAgICAgIG1haW5UaHJlYWRBZGRvbnMuZm9yRWFjaChhZGRvbiA9PiB7XG4gICAgICAgICAgICBpZiAoYWRkb24uc3RhcnRzV2l0aCgnV1MvJykpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRzLnB1c2goaW1wb3J0KGAuLi8uLi8uLi9zcmMvbWFpbi9hZGRvbi8ke2FkZG9uLnN1YnN0cmluZygzKX0ubWpzYCkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGltcG9ydHMucHVzaChpbXBvcnQoYC4vbWFpbi9hZGRvbi8ke2FkZG9ufS5tanNgKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kdWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKGltcG9ydHMpO1xuXG4gICAgICAgIG1lLmFkZG9uID0ge307XG5cbiAgICAgICAgbW9kdWxlcy5mb3JFYWNoKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBtZS5yZWdpc3RlckFkZG9uKG1vZHVsZS5kZWZhdWx0KVxuICAgICAgICB9KTtcblxuICAgICAgICBXb3JrZXJNYW5hZ2VyLm9uV29ya2VyQ29uc3RydWN0ZWQoe1xuICAgICAgICAgICAgb3JpZ2luOiAnbWFpbidcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91bnREb20oZGF0YSkge1xuICAgICAgICB0aGlzLnF1ZXVlV3JpdGUoZGF0YSk7XG5cbiAgICAgICAgV29ya2VyTWFuYWdlci5zZW5kTWVzc2FnZShkYXRhLm9yaWdpbiB8fCAnYXBwJywge1xuICAgICAgICAgICAgYWN0aW9uIDogJ3JlcGx5JyxcbiAgICAgICAgICAgIHJlcGx5SWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJlbmRlcihkYXRhKSB7XG4gICAgICAgIGRhdGEuZGF0YS5yZXBseUlkID0gZGF0YS5yZXBseUlkO1xuICAgICAgICB0aGlzLnF1ZXVlV3JpdGUoZGF0YS5kYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25VcGRhdGVEb20oZGF0YSkge1xuICAgICAgICB0aGlzLnF1ZXVlVXBkYXRlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblVwZGF0ZVZkb20oZGF0YSkge1xuICAgICAgICBkYXRhLmRhdGEucmVwbHlJZCA9IGRhdGEucmVwbHlJZDtcbiAgICAgICAgdGhpcy5xdWV1ZVVwZGF0ZShkYXRhLmRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcXVldWVcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvY2Vzc1F1ZXVlKHF1ZXVlLCBzdGFydCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttb2RlfSA9IG1lLFxuICAgICAgICAgICAgbGltaXQgID0gbWUudGltZUxpbWl0LFxuICAgICAgICAgICAgb3BlcmF0aW9uO1xuXG4gICAgICAgIHdoaWxlIChvcGVyYXRpb24gPSBxdWV1ZS5zaGlmdCgpKSB7XG4gICAgICAgICAgICBpZiAobmV3IERhdGUoKSAtIHN0YXJ0ID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS51bnNoaWZ0KG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShtZS5yZW5kZXJGcmFtZS5iaW5kKG1lKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkJykge1xuICAgICAgICAgICAgICAgICAgICBEb21BY2Nlc3MucmVhZChvcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnd3JpdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhVXBkYXRlcy5pbnNlcnROb2RlKG9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBEZWx0YVVwZGF0ZXMudXBkYXRlKG9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBXb3JrZXJNYW5hZ2VyLnJlc29sdmVEb21PcGVyYXRpb25Qcm9taXNlKG9wZXJhdGlvbi5yZXBseUlkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcXVldWVSZWFkKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUucmVhZFF1ZXVlLnB1c2goZGF0YSk7XG5cbiAgICAgICAgaWYgKCFtZS5ydW5uaW5nKSB7XG4gICAgICAgICAgICBtZS5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShtZS5yZW5kZXJGcmFtZS5iaW5kKG1lKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHF1ZXVlVXBkYXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgbWUudXBkYXRlUXVldWUucHVzaChkYXRhKTtcblxuICAgICAgICBpZiAoIW1lLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIG1lLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckZyYW1lLmJpbmQobWUpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcXVldWVXcml0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLndyaXRlUXVldWUucHVzaChkYXRhKTtcblxuICAgICAgICBpZiAoIW1lLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIG1lLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckZyYW1lLmJpbmQobWUpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS51cmxcbiAgICAgKi9cbiAgICByZWRpcmVjdFRvKGRhdGEpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkYXRhLnVybFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmVnaXN0ZXIgbWFpbiB0aHJlYWQgYWRkb25zXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBhZGRvbiBDYW4gZWl0aGVyIGJlIGEgbmVvIGNsYXNzIG9yIGluc3RhbmNlXG4gICAgICovXG4gICAgcmVnaXN0ZXJBZGRvbihhZGRvbikge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZihhZGRvbikgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgIC8vIEFkZG9ucyBjb3VsZCBnZXQgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMuIEVuc3VyZSB0byBvbmx5IGNyZWF0ZSBhbiBpbnN0YW5jZSBvbmNlLlxuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoTmVvLm5zKGFkZG9uLnByb3RvdHlwZS5jbGFzc05hbWUpKSAhPT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgICAgIGFkZG9uID0gTmVvLmNyZWF0ZShhZGRvbilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFpbiB0aHJlYWQgYWRkb25zIG5lZWQgdG8gZ2V0IHJlZ2lzdGVyZWQgYXMgc2luZ2xldG9ucyBpbnNpZGUgdGhlIG5lbyBuYW1lc3BhY2VcbiAgICAgICAgICAgIE5lby5hcHBseVRvR2xvYmFsTnMoYWRkb24pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZG9uW2FkZG9uLmNvbnN0cnVjdG9yLm5hbWVdID0gYWRkb25cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHJlbG9hZFdpbmRvdyhkYXRhKSB7XG4gICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgdGhlIGRpZmZlcmVudCBET00gb3BlcmF0aW9uIHF1ZXVlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW5kZXJGcmFtZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVhZCAgICA9IG1lLnJlYWRRdWV1ZSxcbiAgICAgICAgICAgIHVwZGF0ZSAgPSBtZS51cGRhdGVRdWV1ZSxcbiAgICAgICAgICAgIHdyaXRlICAgPSBtZS53cml0ZVF1ZXVlLFxuICAgICAgICAgICAgcmVhZGluZyA9IG1lLm1vZGUgPT09ICdyZWFkJyxcbiAgICAgICAgICAgIHN0YXJ0ICAgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIGlmIChOZW8uY29uZmlnLmxvZ0RlbHRhVXBkYXRlcykge1xuICAgICAgICAgICAgbWUudG90YWxGcmFtZUNvdW50Kys7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVG90YWwgRnJhbWVzOiAnICsgbWUudG90YWxGcmFtZUNvdW50KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlYWRpbmcgfHwgIXdyaXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgbWUubW9kZSA9ICdyZWFkJztcbiAgICAgICAgICAgIGlmIChtZS5wcm9jZXNzUXVldWUocmVhZCwgc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgbWUubW9kZSA9ICd1cGRhdGUnO1xuICAgICAgICAgICAgaWYgKG1lLnByb2Nlc3NRdWV1ZSh1cGRhdGUsIHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdyaXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgbWUubW9kZSA9ICd3cml0ZSc7XG4gICAgICAgICAgICBpZiAobWUucHJvY2Vzc1F1ZXVlKHdyaXRlLCBzdGFydCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnJ1bm5pbmcgPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBhIE5lby5jb25maWcgZnJvbSB0aGUgYXBwIHdvcmtlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEua2V5XG4gICAgICogQHBhcmFtIHsqfSBkYXRhLnZhbHVlXG4gICAgICovXG4gICAgc2V0TmVvQ29uZmlnKGRhdGEpIHtcbiAgICAgICAgbGV0IHtrZXksIHZhbHVlfSA9IGRhdGE7XG5cbiAgICAgICAgTmVvLmNvbmZpZ1trZXldID0gZGF0YS52YWx1ZTtcblxuICAgICAgICBrZXkgPT09ICdyZW5kZXJDb3VudERlbHRhcycgJiYgRGVsdGFVcGRhdGVzLnNldCh7W2tleV06IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGxvY2F0aW9uLmhhc2ggdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnZhbHVlXG4gICAgICovXG4gICAgc2V0Um91dGUoZGF0YSkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGRhdGEudmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgcG9wdXAgd2luZG93c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGRhdGEubmFtZXNcbiAgICAgKi9cbiAgICB3aW5kb3dDbG9zZShkYXRhKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhLm5hbWVzKSkge1xuICAgICAgICAgICAgZGF0YS5uYW1lcyA9IFtkYXRhLm5hbWVzXVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5uYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVuV2luZG93c1tuYW1lXT8uY2xvc2UoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wZW5XaW5kb3dzW25hbWVdXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBwb3B1cCB3aW5kb3dzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICB3aW5kb3dDbG9zZUFsbChkYXRhKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5vcGVuV2luZG93cykuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZS5jbG9zZSgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub3BlbldpbmRvd3MgPSB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgYSBwb3B1cCB3aW5kb3dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS54XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEueVxuICAgICAqL1xuICAgIHdpbmRvd01vdmVUbyhkYXRhKSB7XG4gICAgICAgIHRoaXMub3BlbldpbmRvd3NbZGF0YS53aW5kb3dOYW1lXT8ubW92ZVRvKGRhdGEueCwgZGF0YS55KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBuZXcgcG9wdXAgd2luZG93IGFuZCByZXR1cm4gaWYgc3VjY2Vzc2Z1bFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudXJsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93RmVhdHVyZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dOYW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aW5kb3dPcGVuKGRhdGEpIHtcbiAgICAgICAgbGV0IG9wZW5lZFdpbmRvdyA9IHdpbmRvdy5vcGVuKGRhdGEudXJsLCBkYXRhLndpbmRvd05hbWUsIGRhdGEud2luZG93RmVhdHVyZXMpLFxuICAgICAgICAgICAgc3VjY2VzcyAgICAgID0gISFvcGVuZWRXaW5kb3c7XG5cbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbldpbmRvd3NbZGF0YS53aW5kb3dOYW1lXSA9IG9wZW5lZFdpbmRvd1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3NcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgcG9wdXAgd2luZG93XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS53aWR0aF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dOYW1lXG4gICAgICovXG4gICAgd2luZG93UmVzaXplVG8oZGF0YSkge1xuICAgICAgICBsZXQgd2luICAgID0gdGhpcy5vcGVuV2luZG93c1tkYXRhLndpbmRvd05hbWVdLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgd2luLm91dGVySGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGggID0gZGF0YS53aWR0aCAgfHwgd2luLm91dGVyV2lkdGg7XG5cbiAgICAgICAgd2luLnJlc2l6ZVRvKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==