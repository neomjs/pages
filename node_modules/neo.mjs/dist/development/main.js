/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/DefaultConfig.mjs"
/*!*******************************!*\
  !*** ./src/DefaultConfig.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const Neo = globalThis.Neo || {};

Neo.config = Neo.config || {};

/**
 * Config object for the neo.mjs framework which will get passed to all workers
 * You can change the configs, e.g. inside the index.html of your app
 * @memberOf module:Neo
 * @name config
 * @type Object
 */
const DefaultConfig = {
    /**
     * true will apply 'neo-body' to the document.body classList
     * @default true
     * @memberOf! module:Neo
     * @name config.applyBodyCls
     * @type Boolean
     */
    applyBodyCls: true,
    /**
     * true will apply 'position: fixed' to the html tag itself
     * See: https://github.com/neomjs/neo/issues/6429
     * @default true
     * @memberOf! module:Neo
     * @name config.applyFixedPositionToHtmlTag
     * @type Boolean
     */
    applyFixedPositionToHtmlTag: true,
    /**
     * Path to your app.mjs file. You can create multiple apps there if needed.
     * @default null
     * @memberOf! module:Neo
     * @name config.appPath
     * @type String|null
     */
    appPath: null,
    /**
     * Path to the neo.mjs directory
     * @default './'
     * @memberOf! module:Neo
     * @name config.basePath
     * @type String
     */
    basePath: './',
    /**
     * Pass a token in case you are using the CesiumJS main thread addon
     * See: https://github.com/neomjs/neo/blob/dev/src/main/addon/CesiumJS.mjs
     * @default undefined
     * @memberOf! module:Neo
     * @name config.cesiumJsToken
     * @type String|null
     */

    /**
     * Set this config to false to disable the component logging using Ctrl-Right-Click
     * @default true
     * @memberOf! module:Neo
     * @name config.enableComponentLogger
     * @type Boolean
     */
    enableComponentLogger: true,
    /**
     * Set this config to true to enable util.Logger (Neo.log()) based logs in production
     * @default false
     * @memberOf! module:Neo
     * @name config.enableLogsInProduction
     * @type Boolean
     */
    enableLogsInProduction: false,
    /**
     * The current environment. Valid values: 'development', 'dist/development', 'dist/production'
     * This config will get auto-generated
     * @default 'dist/production'
     * @memberOf! module:Neo
     * @name config.environment
     * @type String
     */
    environment: 'dist/production',
    /**
     * In case you are using the GoogleMaps main thread addon, you can pass the API key here.
     * @default undefined
     * @memberOf! module:Neo
     * @name config.googleMapsApiKey
     * @type String
     */

    /**
     * In case you are using the GoogleAnalytics main thread addon or useGoogleAnalytics: true,
     * you can change the gtag id here. Required for the online examples (gh pages)
     * @default undefined
     * @memberOf! module:Neo
     * @name config.gtagId
     * @type String
     */

    /**
     * Flag for running on https://neomjs.github.io/pages/
     * => to use local images paths instead of raw.githubusercontent.com
     * @default false
     * @memberOf! module:Neo
     * @name config.isGitHubPages
     * @type Boolean
     */
    isGitHubPages: true,
    /**
     * Flag for running Neo.mjs inside the middleware Node.js process.
     * @default false
     * @memberOf! module:Neo
     * @name config.isMiddleware
     * @type Boolean
     */
    isMiddleware: false,
    /**
     * delay in ms for the worker.Manager:loadApplication() call
     * @default 20
     * @memberOf! module:Neo
     * @name config.loadApplicationDelay
     * @type Number
     */
    loadApplicationDelay: 20,
    /**
     * Used by Intl.DateTimeFormat, for details take a look at:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @default 'default'
     * @memberOf! module:Neo
     * @name config.locale
     * @type String
     */
    locale: 'default',
    /**
     * true will log the delta updates inside the main thread(s) as well as the requestAnimation frames
     * @default false
     * @memberOf! module:Neo
     * @name config.logDeltaUpdates
     * @type Boolean
     */
    logDeltaUpdates: false,
    /**
     * true will log console warnings, in case a component tries to update() while a parent update is running.
     * A parent update results in a short delay, so you might want to resolve these collisions.
     * @default false
     * @memberOf! module:Neo
     * @name config.logVdomUpdateCollisions
     * @type Boolean
     */
    logVdomUpdateCollisions: false,
    /**
     * Add addons for the main thread
     * ./src/main/addon/ contains all framework related options.
     * You can also create your own addons within your workspace scope. Make sure to put them inside 'src/main/addon/'
     * and prefix them with 'WS/' inside your neo-config.json file.
     * Example: ['DragDrop', 'Stylesheet', 'WS/MyAddon']
     * @default ['DragDrop', 'Navigator', 'Stylesheet']
     * @memberOf! module:Neo
     * @name config.mainThreadAddons
     * @type String[]
     */
    mainThreadAddons: ['DragDrop', 'Navigator', 'Stylesheet'],
    /**
     * The URL for the Neural Link WebSocket connection.
     * @default 'ws://127.0.0.1:8081'
     * @memberOf! module:Neo
     * @name config.neuralLinkUrl
     * @type String
     */

    /**
     * Pass the URL of a JSON-file, which contains the services and methods from your backend,
     * which you want to expose to the client.
     * See: https://github.com/neomjs/neo/projects/32
     * @default null
     * @memberOf! module:Neo
     * @name config.remotesApiUrl
     * @type String|null
     */
    remotesApiUrl: null,
    /**
     * You can visually show the amount of delta updates per second using this config.
     * It expects a dom node with the id "neo-delta-updates" as the rendering target.
     * @default false
     * @memberOf! module:Neo
     * @name config.renderCountDeltas
     * @type Boolean
     */
    renderCountDeltas: false,
    /**
     * Add themes you want to use here. The first theme will get applied.
     * @default ['neo-theme-light','neo-theme-dark','neo-theme-neo-light']
     * @memberOf! module:Neo
     * @name config.themes
     * @type String[]
     */
    themes: ['neo-theme-light', 'neo-theme-dark', 'neo-theme-neo-light'],
    /**
     * Flag for standalone Siesta module tests => prevent registerRemote worker messages
     * @default false
     * @memberOf! module:Neo
     * @name config.unitTestMode
     * @type Boolean
     */
    unitTestMode: false,
    /**
     * When unitTestMode is true, this flag can be enabled to allow VDOM-related
     * operations like initVnode() and update() to proceed. This is useful for integration-style
     * tests that need to verify component lifecycle and DOM output.
     * @default false
     * @memberOf! module:Neo
     * @name config.allowVdomUpdatesInTests
     * @type Boolean
     */
    allowVdomUpdatesInTests: false,
    /**
     * Set this to true to establish a WebSocket connection to the Neural Link MCP Server.
     * This enables bidirectional communication between the App Worker and external AI Agents.
     *
     * You can also use a string or array of strings to specify the target environment(s).
     * Example: 'development' or ['development', 'dist/production']
     * @default false
     * @memberOf! module:Neo
     * @name config.useAiClient
     * @type Boolean|String|String[]
     */
    useAiClient: false,
    /**
     * Experimental flag if an offscreen canvas worker should get created.
     * @default false
     * @memberOf! module:Neo
     * @name config.useCanvasWorker
     * @type Boolean
     */
    useCanvasWorker: false,
    /**
     * `true` will enable the advanced, secure, and performant direct DOM API rendering strategy (recommended).
     * In this mode, `Neo.vdom.Helper` will create and send structured VNode object graphs to the Main Thread.
     * `Neo.main.DeltaUpdates` will then use `Neo.main.render.DomApiRenderer` to directly manipulate the DOM.
     * Crucially, `Neo.main.render.DomApiRenderer` builds new **DOM subtrees** (from the received VNode object graphs)
     * as detached DocumentFragments or elements, entirely outside the live DOM tree.
     * These fully constructed fragments are then inserted into the live document in a **single, atomic operation**.
     * This approach inherently minimizes costly browser reflows/repaints, drastically reduces Cross-Site Scripting (XSS) risks,
     * and optimizes for surgical, atomic DOM updates for unparalleled performance.
     *
     * `false` will enable the legacy string-based rendering strategy.
     * In this mode, `Neo.vdom.Helper` will generate complete HTML strings (`outerHTML`) for VNode subtrees.
     * `Neo.main.DeltaUpdates` will then use `Neo.main.render.StringBasedRenderer` to insert these
     * strings into the DOM using methods like `parentNode.insertAdjacentHTML()`.
     * While performant for large insertions, this mode is generally less secure due to potential XSS vectors
     * and relies on browser HTML parsing, which can be less efficient for granular updates.
     *
     * This configuration affects both the initial painting of your applications and the creation
     * of new component trees at runtime.
     * @default true
     * @memberOf! module:Neo
     * @name config.useDomApiRenderer
     * @type Boolean
     */
    useDomApiRenderer: true,
    /**
     * Flag if vdom ids should get mapped into DOM element ids.
     * false will convert them into a "data-neo-id" attribute.
     * @default true
     * @memberOf! module:Neo
     * @name config.useDomIds
     * @type Boolean
     */
    useDomIds: true,
    /**
     * True will automatically include the stylesheet
     * @default true
     * @memberOf! module:Neo
     * @name config.useFontAwesome
     * @type Boolean
     */
    useFontAwesome: true,
    /**
     * Intended for the online examples where we need an easy way to add GA to every generated app
     * @default false
     * @memberOf! module:Neo
     * @name config.useGoogleAnalytics
     * @type Boolean
     */
    useGoogleAnalytics: false,
    /**
     * True will add the ServiceWorker main thread addon to support caching of assets (PWA)
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
     *
     * You can also use a string to specify the target environment => 'dist/production'.
     * Using 'dist/production' will also use the service worker for 'dist/esm'
     * @default false
     * @memberOf! module:Neo
     * @name config.useServiceWorker
     * @type Boolean|String
     */
    useServiceWorker: false,
    /**
     * Creates App, Data & VDom as SharedWorkers.
     * Set this one to true in case you want to connect multiple main threads.
     * @default false
     * @memberOf! module:Neo
     * @name config.useSharedWorkers
     * @type Boolean
     */
    useSharedWorkers: false,
    /**
     * True will generate a new task worker, which can get filled with own expensive remote methods
     * @default false
     * @memberOf! module:Neo
     * @name config.useTaskWorker
     * @type Boolean
     */
    useTaskWorker: false,
    /**
     * False will create the vdom.Helper within the App worker (experimental!)
     * @default true
     * @memberOf! module:Neo
     * @name config.useVdomWorker
     * @type Boolean
     */
    useVdomWorker: true,
    /**
     * buildScripts/injectPackageVersion.mjs will update this value
     * @default '11.18.0'
     * @memberOf! module:Neo
     * @name config.version
     * @type String
     */
    version: '11.18.0'
};

Object.assign(DefaultConfig, {
    /**
     * Path to the top level neo.mjs resources folder
     * @default Neo.config.basePath + 'resources/'
     * @memberOf! module:Neo
     * @name config.resourcesPath
     * @type String
     */
    resourcesPath: `${Neo.config.basePath || DefaultConfig.basePath}resources/`,
    /**
     * The default base URL for web worker entry points (App, Data, Vdom)
     * @default Neo.config.basePath + 'src/worker/'
     * @memberOf! module:Neo
     * @name config.workerBasePath
     * @type String
     */
    workerBasePath: `${Neo.config.basePath || DefaultConfig.basePath}src/worker/`,
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DefaultConfig);


/***/ },

/***/ "./src/Neo.mjs"
/*!*********************!*\
  !*** ./src/Neo.mjs ***!
  \*********************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultConfig.mjs */ "./src/DefaultConfig.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");



const
    camelRegex   = /-./g,
    configSymbol = Symbol.for('configSymbol'),
    getSetCache  = Symbol('getSetCache'),
    cloneMap = {
        Array(obj, deep, ignoreNeoInstances) {
            return !deep ? [...obj] : [...obj.map(val => Neo.clone(val, deep, ignoreNeoInstances))]
        },
        Date(obj) {
            return new Date(obj.valueOf())
        },
        Map(obj) {
            return new Map(obj) // shallow copy
        },
        NeoInstance(obj, ignoreNeoInstances) {
            return ignoreNeoInstances ? obj : Neo.cloneNeoInstance(obj)
        },
        Set(obj) {
            return new Set(obj)
        },
        Object(obj, deep, ignoreNeoInstances) {
            const out = {};

            // Use Reflect.ownKeys() to include symbol properties (e.g., for config descriptors)
            Reflect.ownKeys(obj).forEach(key => {
                const value = obj[key];
                out[key] = !deep ? value : Neo.clone(value, deep, ignoreNeoInstances)
            });

            return out
        }
    },
    typeDetector = {
        function: item => {
            if (item.prototype?.constructor?.isClass) {
                return 'NeoClass'
            }
        },
        object: item => {
            if (item.constructor?.isClass && item instanceof Neo.core.Base) {
                return 'NeoInstance'
            }
        }
    };

/**
 * The base module to enhance classes, create instances and the Neo namespace
 * @module Neo
 * @singleton
 * @borrows Neo.core.Util.bindMethods       as bindMethods
 * @borrows Neo.core.Util.createStyleObject as createStyleObject
 * @borrows Neo.core.Util.createStyles      as createStyles
 * @borrows Neo.core.Util.decamel           as decamel
 * @borrows Neo.core.Util.isArray           as isArray
 * @borrows Neo.core.Util.isBoolean         as isBoolean
 * @borrows Neo.core.Util.isDefined         as isDefined
 * @borrows Neo.core.Compare.isEqual        as isEqual
 * @borrows Neo.core.Util.isNumber          as isNumber
 * @borrows Neo.core.Util.isRecord          as isRecord
 * @borrows Neo.core.Util.isString          as isString
 * @borrows Neo.core.Util.snakeToCamel      as snakeToCamel
 * @borrows Neo.core.Util.toArray           as toArray
 * @tutorial 01_Concept
 */
let Neo = globalThis.Neo || {};

Neo = globalThis.Neo = Object.assign({
    /**
     * A map containing ntypes as key and Neo classes or singletons as values
     * @memberOf! module:Neo
     * @protected
     * @type Object
     */
    ntypeMap: {},
    /**
     * Needed for Neo.create. False for the main thread, true for the App, Data & Vdom worker
     * @memberOf! module:Neo
     * @protected
     * @type Boolean
     */
    insideWorker: typeof DedicatedWorkerGlobalScope !== 'undefined' || typeof WorkerGlobalScope !== 'undefined',

    /**
     * Maps methods from one namespace to another one
     * @example
     * // aliases
     * Neo.applyFromNs(Neo, Util, {
     *     createStyleObject: 'createStyleObject',
     *     createStyles     : 'createStyles',
     *     capitalize       : 'capitalize'
     * }, true);
     *
     * // e.g. Neo.core.Util.isObject => Neo.isObject
     * @memberOf module:Neo
     * @param {Neo|Neo.core.Base} target    The target class or singleton Instance or Neo
     * @param {Neo.core.Base}     namespace The class containing the methods
     * @param {Object}            config
     * @param {Boolean}           [bind]    set this to true in case you want to bind methods to the "from" namespace
     * @returns {Object} target
     */
    applyFromNs(target, namespace, config, bind) {
        let fnName;

        if (target && Neo.typeOf(config) === 'Object') {
            Object.entries(config).forEach(([key, value]) => {
                fnName = namespace[value];
                target[key] = bind ? fnName.bind(namespace) : fnName
            })
        }

        return target
    },

    /**
     * Maps a class to the global Neo or App namespace.
     * Can get called for classes and singleton instances
     * @memberOf module:Neo
     * @param {Neo.core.Base} cls
     */
    applyToGlobalNs(cls) {
        let proto     = typeof cls === 'function' ? cls.prototype : cls,
            className = proto.isClass ? proto.config.className : proto.className,
            nsArray   = className.split('.'),
            key       = nsArray.pop(),
            ns        = Neo.ns(nsArray, true);

        ns[key] = cls
    },

    /**
     * Copies all keys of defaults into target, in case they don't already exist
     * @memberOf module:Neo
     * @param {Object} target   The target object
     * @param {Object} defaults The object containing the keys you want to copy
     * @returns {Object} target
     */
    assignDefaults(target, defaults) {
        if (target && Neo.typeOf(defaults) === 'Object') {
            Object.entries(defaults).forEach(([key, value]) => {
                if (!Object.hasOwn(target, key)) {
                    target[key] = value
                }
            })
        }

        return target
    },

    /**
     * Assigns a new value to a given nested objects path.
     * It will create the path structure or parts of it, in case it does not exist.
     * @example
     * Neo.assignToNs('annotations.selected', false, record)
     *
     * @memberOf module:Neo
     * @param {String[]|String} path             The path string containing dots or an Array of the string parts
     * @param {*}               value            The new value to assign to the leaf node
     * @param {Object}          scope=globalThis Set a different starting point as globalThis
     * @param {Boolean}         force=true       false will only assign default values (assign if old value === undefined)
     */
    assignToNs(path, value, scope=globalThis, force=true) {
        path = Array.isArray(path) ? path : path.split('.');

        let key;

        if (path.length > 1) {
            key   = path.pop();
            scope = Neo.ns(path, true, scope)
        } else {
            key = path
        }

        if (force || scope[key] === undefined) {
            scope[key] = value
        }
    },

    /**
     * Converts kebab-case strings into camel-case
     * @memberOf module:Neo
     * @param {String} value The target object
     * @returns {String}
     */
    camel(value) {
        return value.replace(camelRegex, match => match[1].toUpperCase())
    },

    /**
     * Makes the first character of a string uppercase
     * @memberOf module:Neo
     * @param {String} value
     * @returns {Boolean|String} Returns false for non-string inputs
     */
    capitalize(value) {
        return value[0].toUpperCase() + value.slice(1)
    },

    /**
     * @memberOf module:Neo
     * @param {Object|Array|*} obj
     * @param {Boolean} deep=false               Set this to true in case you want to clone nested objects as well
     * @param {Boolean} ignoreNeoInstances=false returns existing instances if set to true
     * @returns {Object|Array|*} the cloned input
     */
    clone(obj, deep=false, ignoreNeoInstances=false) {
        return cloneMap[Neo.typeOf(obj)]?.(obj, deep, ignoreNeoInstances) || obj
    },

    /**
     * Creates a new instance using the originalConfig without the id
     * @memberOf module:Neo
     * @param {Neo.core.Base} instance
     * @returns {Neo.core.Base} the cloned instance
     */
    cloneNeoInstance(instance) {
        let config = {...instance.originalConfig};

        delete config._id;
        delete config.id;

        return Neo.create(instance.className, config)
    },

    /**
     * Use Neo.create() instead of "new" to create instances of all Neo classes
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create(Button, {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * import Button from '../button/Base.mjs';
     *
     * Neo.create({
     *     module : Button,
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create('Neo.button.Base' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.create({
     *     className: 'Neo.button.Base',
     *     iconCls  : 'fa fa-home',
     *     text     : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object|Neo.core.Base} className
     * @param {Object}                      [config]
     * @returns {Neo.core.Base|null} The new class instance
     */
    create(className, config) {
        let type = Neo.typeOf(className),
            cls, instance;

        if (type === 'NeoClass') {
            cls = className
        } else {
            if (type === 'Object') {
                config = className;

                if (!config.className && !config.module) {
                    // using console.error instead of throw to show the config object
                    console.error('Class created with object configuration missing className or module property', config);
                    return null
                }

                className = config.className || config.module.prototype.className
            }

            if (!exists(className)) {
                throw new Error('Class ' + className + ' does not exist')
            }

            cls = Neo.ns(className)
        }

        instance = new cls();

        instance.construct(config);
        instance.onConstructed();
        instance.onAfterConstructed();
        instance.init();

        return instance
    },

    /**
     * Defines a reactive configuration property on a target object (prototype or instance).
     * This method creates getters and setters that fully participate in Neo.mjs's reactive config system,
     * including lifecycle hooks.
     *
     * @param {Neo.core.Base}  target        - The instance or prototype on which to define the config.
     * @param {String}         key           - The name of the config property (without the '_' suffix).
     * @param {*}             [initialValue] - The initial value for the config.
     */
    createConfig(target, key, initialValue) {
        if (Neo.hasPropertySetter(target, key)) {
            throw(
`Invalid config in ${target.className}: '${key}_'. The config '${key}' is already defined as reactive by a parent class.
To override the default value, use '${key}' (without the underscore) in your static config.
If you intended to create custom logic, use the 'beforeGet${Neo.capitalize(key)}()', 'beforeSet${Neo.capitalize(key)}()',and 'afterSet${Neo.capitalize(key)}()' hooks instead of redefining the config.`
            )
        }

        const
            _key      = '_' + key,
            uKey      = key[0].toUpperCase() + key.slice(1),
            beforeGet = 'beforeGet' + uKey,
            beforeSet = 'beforeSet' + uKey,
            afterSet  = 'afterSet'  + uKey;

        Neo[getSetCache] ??= {};

        if (!Neo[getSetCache][key]) {
            // Public Descriptor
            Neo[getSetCache][key] = {
                get() {
                    let me        = this,
                        config    = me.getConfig(key),
                        hasNewKey = Object.hasOwn(me[configSymbol], key),
                        newKey    = me[configSymbol][key],
                        value     = hasNewKey ? newKey : me[_key];

                    if (value instanceof Date) {
                        value = new Date(value.valueOf())
                    }
                    // new, explicit opt-in path
                    else if (config.cloneOnGet) {
                        const {cloneOnGet} = config;

                        if (cloneOnGet === 'deep') {
                            value = Neo.clone(value, true, true)
                        } else if (cloneOnGet === 'shallow') {
                            const type = Neo.typeOf(value);

                            if (type === 'Array') {
                                value = [...value]
                            } else if (type === 'Object') {
                                value = {...value}
                            }
                        }
                    }
                    // legacy behavior
                    else if (Array.isArray(value)) {
                        value = [...value]
                    }

                    if (hasNewKey) {
                        me[key] = value;  // We do want to trigger the setter => beforeSet, afterSet
                        value = me[_key]; // Return the value parsed by the setter
                        delete me[configSymbol][key]
                    }

                    if (typeof me[beforeGet] === 'function') {
                        value = me[beforeGet](value)
                    }

                    return value
                },
                set(value) {
                    if (value === undefined) return;

                    const config = this.getConfig(key);
                    if (!config) return;

                    let me              = this,
                        oldValue        = config.get(), // Get the old value from the Config instance
                        {EffectManager} = Neo.core,
                        isNewBatch      = !EffectManager?.isPaused();

                    // If a config change is not triggered via `core.Base#set()`, honor changes inside hooks.
                    isNewBatch && EffectManager?.pause();

                    try {
                        // 1. Prevent infinite loops:
                        // Immediately remove the pending value from the configSymbol to prevent a getter from
                        // recursively re-triggering this setter.
                        delete me[configSymbol][key];

                        switch (config.clone) {
                            case 'deep':
                                value = Neo.clone(value, true, true);
                                break;
                            case 'shallow':
                                value = Neo.clone(value, false, true);
                                break;
                        }

                        // 2. Create a temporary state for beforeSet hooks:
                        // Set the new value directly on the private backing property. This allows any beforeSet
                        // hook to access the new value of this and other configs within the same `set()` call.
                        me[_key] = value;

                        if (typeof me[beforeSet] === 'function') {
                            value = me[beforeSet](value, oldValue);

                            // If they don't return a value, that means no change
                            if (value === undefined) {
                                // Restore the original value if the update is canceled.
                                me[_key] = oldValue;
                                return
                            }
                        }

                        // 3. Restore state for change detection:
                        // Revert the private backing property to its original value. This is crucial for the
                        // `config.set()` method to correctly detect if the value has actually changed.
                        me[_key] = oldValue;

                        // 4. Finalize the change:
                        // The config.set() method performs the final check and, if the value changed,
                        // triggers afterSet hooks and notifies subscribers.
                        if (config.set(value)) {
                            me[afterSet]?.(value, oldValue);
                            me.afterSetConfig?.(key, value, oldValue)
                        }
                    } finally {
                        // End the batch only if this setter started it.
                        isNewBatch && EffectManager?.resume()
                    }
                }
            };

            // Private Descriptor
            Neo[getSetCache][_key] = {
                get() {
                    return this.getConfig(key)?.get()
                },
                set(value) {
                    this.getConfig(key)?.setRaw(value)
                }
            }
        }

        Object.defineProperty(target, key,  Neo[getSetCache][key]);
        Object.defineProperty(target, _key, Neo[getSetCache][_key]);

        if (initialValue !== undefined) {
            target[key] = initialValue
        }
    },

    /**
     *
     */
    emptyFn() {},

    /**
     * Ensures a class is assigned to the Neo namespace only once, preventing duplicates.
     * This is a lightweight version of `Neo.setupClass` for simple classes
     * that do not extend `Neo.core.Base`.
     * It follows a "first one wins" strategy.
     *
     * @param {Function|Object} module    - The class constructor or singleton object to register.
     * @param {String}          classPath - The fully qualified name (e.g., 'Neo.core.Config').
     * @param {Function}       [onFirst]  - An optional callback that runs only the first time the class is registered.
     * @returns {Function|Object} The class or singleton from the Neo namespace (either the existing one or the newly set one).
     */
    gatekeep(module, classPath, onFirst) {
        const existingClass = Neo.ns(classPath, false);

        if (existingClass) {
            return existingClass
        }

        const
            nsArray   = classPath.split('.'),
            className = nsArray.pop(),
            parentNs  = Neo.ns(nsArray, true);

        parentNs[className] = module;

        onFirst?.(module);

        return parentNs[className]
    },

    /**
     * Checks if there is a set method for a given property key inside the prototype chain
     * @memberOf module:Neo
     * @param {Neo.core.Base} proto The top level prototype of a class
     * @param {String}        key   The property key to test
     * @returns {Boolean}
     */
    hasPropertySetter(proto, key) {
        let descriptor;

        while (proto.__proto__) {
            descriptor = Object.getOwnPropertyDescriptor(proto, key);

            if (typeof descriptor === 'object' && typeof descriptor.set === 'function') {
                return true
            }

            proto = proto.__proto__
        }

        return false
    },

    /**
     * Deep-merges a source object into a target object
     * @memberOf module:Neo
     * @param {Object} target
     * @param {Object} source
     * @param {Object} defaults
     * @returns {Object} target
     */
    merge(target, source, defaults) {
        if (defaults) {
            return Neo.merge(Neo.merge(target, defaults), source)
        }

        if (!target) {
            return source
        }

        for (const key in source) {
            const value = source[key];

            if (Neo.typeOf(value) === 'Object') {
                target[key] = Neo.merge(target[key] || {}, value)
            } else {
                target[key] = value
            }
        }

        return target
    },

    /**
     * Merges a new value into an existing config value based on a specified strategy.
     * This method is used during instance creation to apply merge strategies defined in config descriptors.
     * @param {any} defaultValue - The default value of the config (from static config).
     * @param {any} instanceValue - The value provided during instance creation.
     * @param {string|Function} strategy - The merge strategy: 'shallow', 'deep', 'replace', or a custom function.
     * @returns {any} The merged value.
     */
    mergeConfig(defaultValue, instanceValue, strategy) {
        const
            defaultValueType  = Neo.typeOf(defaultValue),
            instanceValueType = Neo.typeOf(instanceValue);

        if (strategy === 'shallow') {
            if (defaultValueType === 'Object' && instanceValueType === 'Object') {
                return {...defaultValue, ...instanceValue}
            }
        } else if (strategy === 'deep') {
            if (defaultValueType === 'Object' && instanceValueType === 'Object') {
                return Neo.merge(Neo.clone(defaultValue, true), instanceValue)
            }
        } else if (typeof strategy === 'function') {
            return strategy(defaultValue, instanceValue)
        }

        // Default to 'replace' or if strategy is not recognized
        return instanceValue
    },

    /**
     * Maps a className string into a given or global namespace
     * @example
     * Neo.ns('Neo.button.Base', true);
     * // =>
     * // globalThis.Neo             = globalThis.Neo             || {};
     * // globalThis.Neo.button      = globalThis.Neo.button      || {};
     * // globalThis.Neo.button.Base = globalThis.Neo.button.Base || {};
     * // return globalThis.Neo.button.Base;
     *
     * @memberOf module:Neo
     * @param {String[]|String} names        The class name string containing dots or an Array of the string parts
     * @param {Boolean}         create=false Set create to true to create empty objects for non-existing parts
     * @param {Object}          [scope]      Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    ns(names, create=false, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                prev[current] = {}
            }

            if (prev) {
                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Extended version of Neo.ns() which supports mapping into arrays.
     * @memberOf module:Neo
     * @param {Array|String} names        The class name string containing dots or an Array of the string parts
     * @param {Boolean}      create=false Set create to true to create empty objects for non-existing parts
     * @param {Object}       [scope]      Set a different starting point as globalThis
     * @returns {Object} reference to the toplevel namespace
     */
    nsWithArrays(names, create=false, scope) {
        names = Array.isArray(names) ? names : names.split('.');

        return names.reduce((prev, current) => {
            if (create && !prev[current]) {
                if (current.endsWith(']')) {
                    return createArrayNs(true, current, prev)
                }

                prev[current] = {}
            }

            if (prev) {
                if (current.endsWith(']')) {
                    return createArrayNs(false, current, prev)
                }

                return prev[current]
            }
        }, scope || globalThis)
    },

    /**
     * Creates instances of Neo classes using their ntype instead of the class name
     * @example
     * Neo.ntype('button' {
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @example
     * Neo.ntype({
     *     ntype  : 'button',
     *     iconCls: 'fa fa-home',
     *     text   : 'Home'
     * });
     * @memberOf module:Neo
     * @param {String|Object} ntype
     * @param {Object}        [config]
     * @returns {Neo.core.Base}
     * @see {@link module:Neo.create create}
     */
    ntype(ntype, config) {
        if (typeof ntype === 'object') {
            config = ntype;

            if (!config.ntype) {
                throw new Error('Class defined with object configuration missing ntype property. ' + config.ntype)
            }

            ntype = config.ntype
        }

        let className = Neo.ntypeMap[ntype];

        if (!className) {
            throw new Error('ntype ' + ntype + ' does not exist')
        }

        return Neo.create(className, config)
    },

    /**
     * This is the final and most critical step in the Neo.mjs class creation process.
     * It is called at the end of every class module definition.
     *
     * `setupClass` performs several key operations:
     * 1.  **Mixed-Environment Gatekeeper:** It first checks if the class's namespace already exists.
     *     If it does, it immediately returns the existing class. This is the crucial "first comes wins"
     *     strategy that enables Neo.mjs to safely combine environments. For example, a bundled
     *     `dist/production` app can dynamically load an unbundled module from `dist/esm` at runtime.
     *     If that module imports a class already present in the main bundle, this check ensures the
     *     original, bundled class is used, preventing conflicts and maintaining application integrity.
     * 2.  **Configuration Merging:** It traverses the prototype chain to merge `static config`
     *     objects from parent classes into the current class, creating a unified `config`.
     * 3.  **Applying Overwrites:** It calls the static `applyOverwrites()` method on the class,
     *     allowing the global `Neo.overwrites` object to modify the class's default prototype
     *     configs. This is a key mechanism for external theming and configuration.
     * 4.  **Reactive Getter/Setter Generation:** For any config ending with an underscore (e.g., `myConfig_`),
     *     it automatically generates the corresponding public getter and setter. This enables optional
     *     lifecycle hooks that are called automatically if implemented on the class:
     *     - `beforeGetMyConfig(value)`
     *     - `beforeSetMyConfig(newValue, oldValue)`
     *     - `afterSetMyConfig(newValue, oldValue)`
     * 5.  **Prototype-based Configs:** Non-reactive configs (without an underscore) are set
     *     directly on the prototype for memory efficiency.
     * 6.  **Mixin Application:** It processes the `mixins` config to blend in functionality from
     *     other classes.
     * 7.  **Namespace Registration:** It registers the class in the global `Neo` namespace.
     * 8.  **Singleton Instantiation:** If the class is configured as a singleton, it creates the
     *     single instance.
     *
     * @memberOf module:Neo
     * @template T
     * @param {T} cls The class constructor to process.
     * @returns {T} The processed and finalized class constructor or singleton instance.
     */
    setupClass(cls) {
        let baseConfig            = null,
            baseConfigDescriptors = null,
            ntypeChain            = [],
            {ntypeMap}            = Neo,
            proto                 = cls.prototype || cls,
            ns                    = Neo.ns(proto.constructor.config.className, false),
            protos                = [],
            cfg, config, configDescriptors, ctor, hierarchyInfo, ntype;

        /*
         * If the namespace already exists, directly return it.
         * This can happen when using different versions of Neo.mjs
         * => Especially singletons (IdGenerator) must stay unique.
         *
         * This can also happen when using different environments of neo.mjs in parallel.
         * Example: code.LivePreview running inside a dist/production app.
         */
        if (ns) {
            return ns
        }

        // Traverse the prototype chain to collect inherited configs and descriptors
        while (proto.__proto__) {
            ctor = proto.constructor;

            // If a class in the prototype chain has already had its config applied,
            // we can use its pre-processed config and descriptors as a base.
            if (Object.hasOwn(ctor, 'classConfigApplied')) {
                baseConfig            = Neo.clone(ctor.config, true);
                baseConfigDescriptors = Neo.clone(ctor.configDescriptors, true);
                ntypeChain            = [...ctor.ntypeChain];
                break
            }

            protos.unshift(proto);
            proto = proto.__proto__
        }

        // Initialize accumulated config and descriptors
        config            = baseConfig            || {};
        configDescriptors = baseConfigDescriptors || {};

        // Process each class in the prototype chain (from top to bottom)
        protos.forEach(element => {
            let currentConfigDescriptors = {},
                mixins;

            ctor = element.constructor;
            cfg  = ctor.config ? Neo.clone(ctor.config, true) : {};

            if (Neo.overwrites) {
                ctor.applyOverwrites?.(cfg)
            }

            // Process each config property defined in the current class's static config
            Object.entries(cfg).forEach(([key, value]) => {
                const
                    isReactive = key.slice(-1) === '_',
                    baseKey    = isReactive ? key.slice(0, -1) : key;

                // 1. Handle descriptors: If the value is a descriptor object, store it.
                //    The 'value' property of the descriptor is then used as the actual config value.
                if (Neo.isObject(value) && value[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__.isDescriptor] === true) {
                    currentConfigDescriptors[baseKey] = Neo.clone(value, true); // Deep clone to prevent mutation
                    value = value.value // Use the descriptor's value as the config value
                }

                // 2. Handle reactive vs. non-reactive configs: Generate getters/setters for reactive configs.
                if (isReactive) {
                    delete cfg[key];      // Remove original key with underscore
                    cfg[baseKey] = value; // Use the potentially modified value
                    Neo.createConfig(element, baseKey)
                }
                // This part handles non-reactive configs (including those that were descriptors)
                // If no property setter exists, define it directly on the prototype.
                else if (!Neo.hasPropertySetter(element, key)) {
                    Object.defineProperty(element, key, {enumerable: true, value, writable: true})
                }
            });

            // Merge configDescriptors: Apply "first-defined wins" strategy.
            // If a descriptor for a key already exists (from a parent class), it is not overwritten.
            if (Object.keys(currentConfigDescriptors).length > 0) {
                for (const key in currentConfigDescriptors) {
                    if (!Object.hasOwn(configDescriptors, key)) {
                        configDescriptors[key] = currentConfigDescriptors[key];
                    }
                }
            }

            // Process ntype and ntypeChain
            if (Object.hasOwn(cfg, 'ntype')) {
                ntype = cfg.ntype;

                ntypeChain.unshift(ntype);

                // Running the docs app inside a workspace can pull in the same classes from different roots,
                // so we want to check for different class names as well
                if (Object.hasOwn(ntypeMap, ntype) && cfg.className !== ntypeMap[ntype]) {
                    throw new Error(`ntype conflict for '${ntype}' inside the classes:\n${ntypeMap[ntype]}\n${cfg.className}`)
                }

                ntypeMap[ntype] = cfg.className
            }

            // Process mixins
            mixins = Object.hasOwn(config, 'mixins') && config.mixins || [];

            if (ctor.observable) {
                mixins.push('Neo.core.Observable')
            }

            if (Object.hasOwn(cfg, 'mixins') && Array.isArray(cfg.mixins) && cfg.mixins.length > 0) {
                mixins.push(...cfg.mixins)
            }

            if (mixins.length > 0) {
                applyMixins(ctor, mixins, cfg);

                if (Neo.ns('Neo.core.Observable', false, ctor.prototype.mixins)) {
                    ctor.observable = true
                }
            }

            delete cfg.mixins;
            delete config.mixins;

            // Hierarchical merging of static config values based on descriptors.
            // This ensures that values are merged (e.g., shallow/deep) instead of simply overwritten.
            Object.entries(cfg).forEach(([key, value]) => {
                const descriptor = configDescriptors[key];

                if (descriptor?.merge) {
                    config[key] = Neo.mergeConfig(config[key], value, descriptor.merge)
                } else {
                    config[key] = value
                }
            });

            // Assign final processed config and descriptors to the class constructor
            Object.assign(ctor, {
                classConfigApplied: true,
                config            : Neo.clone(config,            true), // Deep clone final config for immutability
                configDescriptors : Neo.clone(configDescriptors, true), // Deep clone final descriptors for immutability
                isClass           : true,
                ntypeChain
            });

            // Apply to global namespace if not a singleton
            !config.singleton && this.applyToGlobalNs(cls)
        });

        proto = cls.prototype || cls;

        // Add is<Ntype> flags to the prototype
        ntypeChain.forEach(ntype => {
            proto[`is${Neo.capitalize(Neo.camel(ntype))}`] = true
        });

        // If it's a singleton, create and apply the instance to the global namespace
        if (proto.singleton) {
            cls = Neo.create(cls);
            Neo.applyToGlobalNs(cls)
        }

        // Add class hierarchy information to the manager or a temporary map
        hierarchyInfo = {
            className      : proto.className,
            module         : cls,
            ntype          : Object.hasOwn(proto, 'ntype') ? proto.ntype : null,
            parentClassName: proto.__proto__?.className || null
        };

        if (Neo.manager?.ClassHierarchy) {
            Neo.manager.ClassHierarchy.add(hierarchyInfo)
        } else {
            Neo.classHierarchyMap ??= {};
            Neo.classHierarchyMap[proto.className] = hierarchyInfo
        }

        return cls
    },

    /**
     * @param {*} item
     * @returns {String|null}
     */
    typeOf(item) {
        // Return null for null or undefined
        if (item == null) return null;

        return typeDetector[typeof item]?.(item) || item.constructor?.name
    }
}, Neo);

/**
 * List of class properties which are not supposed to get mixed into other classes
 * @type {string[]}
 * @private
 */
const ignoreMixin = [
    '_name',
    'classConfigApplied',
    'className',
    'constructor',
    'id',
    'isClass',
    'mixin',
    'ntype',
    'observable',
    'toJSON'
],

    charsRegex         = /\d+/g,
    extractArraysRegex = /^(\w+)\s*((?:\[\s*\d+\s*\]\s*)*)$/;

/**
 * @param {Neo.core.Base} cls
 * @param {Array}         mixins
 * @param {Object}        classConfig
 * @private
 */
function applyMixins(cls, mixins, classConfig) {
    if (!Array.isArray(mixins)) {
        mixins = [mixins];
    }

    let i            = 0,
        len          = mixins.length,
        mixinClasses = {},
        mixin, mixinCls, mixinProto;

    for (;i < len;i++) {
        mixin = mixins[i];

        if (mixin.isClass) {
            mixinProto = mixin.prototype;
            mixinCls   = Neo.ns(mixinProto.className)
        } else {
            if (!exists(mixin)) {
                throw new Error('Attempting to mixin an undefined class: ' + mixin + ', ' + cls.prototype.className)
            }

            mixinCls   = Neo.ns(mixin);
            mixinProto = mixinCls.prototype
        }

        mixinProto.className.split('.').reduce(mixReduce(mixinCls), mixinClasses);

        Object.entries(Object.getOwnPropertyDescriptors(mixinProto)).forEach(mixinProperty(cls.prototype, mixinProto, classConfig))
    }

    cls.prototype.mixins = mixinClasses
}

/**
 * @param {Boolean} create
 * @param {Object}  current
 * @param {Object}  prev
 * @returns {Object|undefined}
 */
function createArrayNs(create, current, prev) {
    let arrDetails = parseArrayFromString(current),
        i          = 1,
        len        = arrDetails.length,
        arrItem, arrRoot;

    if (create) {
        prev[arrDetails[0]] = arrRoot = prev[arrDetails[0]] || []
    } else {
        arrRoot = prev[arrDetails[0]]
    }

    if (!arrRoot) return;

    for (; i < len; i++) {
        arrItem = parseInt(arrDetails[i]);

        if (create) {
            arrRoot[arrItem] = arrRoot[arrItem] || {}
        }

        arrRoot = arrRoot[arrItem]
    }

    return arrRoot
}

/**
 * Checks if the class name exists inside the Neo or app namespace
 * @param {String} className
 * @returns {Boolean}
 * @private
 */
function exists(className) {
    try {
        return !!className.split('.').reduce((prev, current) => {
            return prev[current]
        }, globalThis)
    } catch(e) {
        return false
    }
}

/**
 * @param {Neo.core.Base} proto
 * @param {Neo.core.Base} mixinProto
 * @param {Object}        classConfig
 * @returns {Function}
 * @private
 */
function mixinProperty(proto, mixinProto, classConfig) {
    return function([key, descriptor]) {
        if (ignoreMixin.includes(key)) return;

        // Mixins must not override existing class properties with a setter
        if (Neo.hasPropertySetter(proto, key)) return;

        // Reactive neo configs, or public class fields defined via get() AND set()
        if (descriptor.get && descriptor.set) {
            Neo.createConfig(proto, key);

            const mixinClassConfig = mixinProto.constructor.config;

            if (Object.hasOwn(mixinClassConfig, key)) {
                classConfig[key] = mixinClassConfig[key]
            }

            return
        }

        if (proto[key]?._from) {
            if (mixinProto.className === proto[key]._from) {
                console.warn('Mixin set multiple times or already defined on a Base Class', proto.className, mixinProto.className, key);
                return
            }

            throw new Error(
                `${proto.className}: Multiple mixins defining same property (${mixinProto.className}, ${proto[key]._from}) => ${key}`
            )
        }

        proto[key] = mixinProto[key];

        Object.getOwnPropertyDescriptor(proto, key)._from = mixinProto.className;

        if (typeof proto[key] === 'function') {
            proto[key]._name = key
        }
    }
}

/**
 * @param mixinCls
 * @returns {Function}
 * @private
 */
function mixReduce(mixinCls) {
    return (prev, current, idx, arr) => {
        return prev[current] = idx !== arr.length -1 ? prev[current] || {} : mixinCls
    }
}

/**
 * @param {String} str
 * @returns {Function}
 * @private
 */
function parseArrayFromString(str) {
    return (extractArraysRegex.exec(str) || [null]).slice(1).reduce(
        (fun, args) => [fun].concat(args.match(charsRegex))
    )
}

Neo.config ??= {};

Neo.assignDefaults(Neo.config, _DefaultConfig_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo);


/***/ },

/***/ "./src/collection/Base.mjs"
/*!*********************************!*\
  !*** ./src/collection/Base.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Filter.mjs */ "./src/collection/Filter.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Sorter_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Sorter.mjs */ "./src/collection/Sorter.mjs");







const
    countMutations     = Symbol('countMutations'),
    initialIndexSymbol = Symbol.for('initialIndex'),
    isFiltered         = Symbol('isFiltered'),
    isSorted           = Symbol('isSorted'),
    silentUpdateMode   = Symbol('silentUpdateMode'),
    toAddArray         = Symbol('toAddArray'),
    toRemoveArray      = Symbol('toRemoveArray'),
    updatingIndex      = Symbol('updatingIndex');

/**
 * @class Neo.collection.Base
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Collection extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.collection.Base'
         * @protected
         */
        className: 'Neo.collection.Base',
        /**
         * @member {String} ntype='collection'
         * @protected
         */
        ntype: 'collection',
        /**
         * When filtering the collection for the first time, allItems will become a new collection for the unfiltered
         * state, using this id as the sourceCollectionId
         * @member {Neo.collection.Base|null} allItems=null
         * @protected
         */
        allItems: null,
        /**
         * True to sort the collection items when adding / inserting new ones
         * @member {Boolean} autoSort=true
         */
        autoSort: true,
        /**
         * Stores the items.length of the items array in use
         * @member {Number} count_=0
         * @reactive
         */
        count_: 0,
        /**
         * Use 'primitive' for default filters, use 'advanced' for filters using a filterBy method
         * which need to iterate over other collection items
         * @member {String} filterMode='primitive'
         */
        filterMode: 'primitive',
        /**
         * An Array containing Neo.util.Filter config objects or instances
         * @member {Array} filters_=[]
         * @reactive
         */
        filters_: [],
        /**
         * @member {Object[]|null} items_=null
         * @reactive
         */
        items_: null,
        /**
         * The unique(!) key property of each collection item
         * @member {String} keyProperty='id'
         */
        keyProperty: 'id',
        /**
         * Adding new items without an id (keyProperty) will use a negative index, which will decrease by -1
         * for each new item
         * @member {Number} keyPropertyIndex=-1
         */
        keyPropertyIndex: -1,
        /**
         * A map containing the key & reference of each collection item for faster access
         * @member {Map} map_=null
         * @protected
         * @reactive
         */
        map_: null,
        /**
         * An internal Array of the sort directions for faster access
         * @member {Array} sortDirections=null
         * @protected
         */
        sortDirections: null,
        /**
         * An internal Array of the sort properties for faster access
         * @member {Array} sortProperties=null
         * @protected
         */
        sortProperties: null,
        /**
         * An Array containing Neo.util.Sorter config objects or instances
         * @member {Array} sorters_=[]
         * @reactive
         */
        sorters_: [],
        /**
         * The id of another collection instance to use as this data source
         * @member {String|null} sourceId_=null
         * @reactive
         */
        sourceId_: null
    }

    /**
     * @member {Number} initialIndexCounter=0
     */
    initialIndexCounter = 0

    /**
     * @param config
     */
    construct(config) {
        let me           = this,
            symbolConfig = {enumerable: false, writable: true};

        Object.defineProperties(me, {
            [countMutations]  : {...symbolConfig, value: false},
            [isFiltered]      : {...symbolConfig, value: false},
            [isSorted]        : {...symbolConfig, value: false},
            [silentUpdateMode]: {...symbolConfig, value: false},
            [toAddArray]      : {...symbolConfig, value: []},
            [toRemoveArray]   : {...symbolConfig, value: []},
            [updatingIndex]   : {...symbolConfig, value: 0}
        });

        super.construct(config);

        me.items = me.items || [];

        if (me.autoSort && me._sorters.length > 0) {
            me.doSort()
        }
    }

    /**
     * Adds one or more items to the end of the collection
     * @param {Array|Object} item The item(s) to add
     * @returns {Object[]} an array containing all added items
     */
    add(item) {
        return this.splice(null, null, item).addedItems
    }

    /**
     * Triggered after the filters config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        let me = this;

        value.forEach(filter => {
            if (filter.listenerApplied === false) {
                filter.on('change', me.onFilterChange, me);
                filter.listenerApplied = true
            }
        });

        oldValue && me.filter()
    }

    /**
     * Triggered after the items config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetItems(value, oldValue) {
        if (value) {
            let me            = this,
                {keyProperty} = me,
                i             = 0,
                len           = value.length,
                item;

            for (; i < len; i++) {
                item = value[i];
                me.map.set(item[keyProperty], item)
            }

            me.count = len
        }
    }

    /**
     * Triggered after the sorters config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        let me = this;

        me.applySorterConfigs();

        value.forEach(sorter => {
            if (sorter.listenerApplied === false) {
                sorter.on('change', me.onSorterChange, me);
                sorter.listenerApplied = true
            }
        });

        oldValue && me.autoSort && me.doSort()
    }

    /**
     * Triggered after the sourceId config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetSourceId(value, oldValue) {
        if (value) {
            let me     = this,
                source = Neo.get(value);

            me._items = [...source._items];
            me.map    = new Map(source.map); // creates a clone of the original map

            const listenersConfig = {
                mutate: me.onMutate,
                scope : me
            };

            source.on(listenersConfig);

            if (oldValue) {
                source = Neo.get(oldValue);
                source.un(listenersConfig)
            }
        }
    }

    /**
     * Saves the sort property & direction multiplier of each sorter inside 2 arrays for faster access when sorting
     * @protected
     */
    applySorterConfigs() {
        let me = this;

        me.sortDirections = [];
        me.sortProperties = [];

        me.sorters.forEach(sorter => {
            me.sortDirections.push(sorter.directionMultiplier);
            me.sortProperties.push(sorter.property)
        })
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetFilters(value, oldValue) {
        if (!Array.isArray(value)) {
            value = value ? [value] : []
        }

        let len = oldValue && oldValue.length || 0,
            hasMatch, i;

        value.forEach((key, index) => {
            if (oldValue) {
                hasMatch = false;
                i        = 0;

                for (; i < len; i++) {
                    if (oldValue[i] === key) {
                        oldValue[i].set({
                            operator: key.operator,
                            property: key.property,
                            value   : key.value
                        });

                        hasMatch = true;
                        break
                    } else if (
                        oldValue[i].operator === (key.operator || '===') &&
                        oldValue[i].property === key.property &&
                        oldValue[i].value    === key.value
                    ) {
                        hasMatch = true;
                        break
                    }
                }
            }

            if (!hasMatch) {
                value[index] = Neo.create(_Filter_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], key)
            } else {
                value[index] = oldValue[i];
                oldValue.splice(i, 1);
                len--
            }
        });

        if (Array.isArray(oldValue)) {
            oldValue.forEach(key => {
                key.destroy();
            })
        }

        return value
    }

    /**
     * @param {Map|null} value
     * @param {Map|null} oldValue
     * @protected
     */
    beforeSetMap(value, oldValue) {
        return !value ? new Map() : value
    }

    /**
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    beforeSetSorters(value, oldValue) {
        if (!Array.isArray(value)) {
            value = value ? [value] : []
        }

        let len = oldValue?.length || 0,
            hasMatch, i;

        value.forEach((key, index) => {
            if (oldValue) {
                hasMatch = false;
                i        = 0;

                let {direction, property} = key;

                for (; i < len; i++) {
                    if (oldValue[i] === key) {
                        oldValue[i].set({direction, property});

                        hasMatch = true;
                        break
                    } else if (oldValue[i].property === property && oldValue[i].direction === direction) {
                        hasMatch = true;
                        break
                    }
                }
            }

            if (!hasMatch) {
                value[index] = Neo.create(_Sorter_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], key)
            } else {
                value[index] = oldValue[i];
                oldValue.splice(i, 1);
                len--
            }
        });

        oldValue?.forEach(key => {
            key.destroy()
        });

        return value
    }

    /**
     * @param opts
     * @protected
     */
    cacheUpdate(opts) {
        // disabled for now
        // console.log('cacheUpdate', opts, this[toAddArray]);
        return;

        // removed by dead control flow


        // removed by dead control flow

    }

    /**
     * Removes all items and clears the map
     */
    clear() {
        this.splice(0, this.count);
        this.initialIndexCounter = 0
    }

    /**
     * Clears all current filters and optionally restores the original ones in case they existed.
     * @param {boolean} [restoreOriginalFilters=false]
     */
    clearFilters(restoreOriginalFilters) {
        this.filters = restoreOriginalFilters ? Neo.clone(this.originalConfig.filters, true, true) : null
    }

    /**
     * Removes all items and clears the map, without firing a mutate event
     */
    clearSilent() {
        let me = this;

        me._items.splice(0, me.count);
        me.map.clear()
    }

    /**
     * Clears all current sorters and optionally restores the original ones in case they existed.
     * Without restoreInitialState as true this will not affect the current sorting of this collection.
     * @param {boolean} [restoreOriginalSorters=false]
     */
    clearSorters(restoreOriginalSorters) {
        this.sorters = restoreOriginalSorters ? Neo.clone(this.originalConfig.sorters, true, true) : null
    }

    /**
     * @returns {Neo.collection.Base} The cloned collection
     */
    clone() {
        let me      = this,
            config  = Neo.clone(me.originalConfig, true),
            filters = me._filters || [],
            sorters = me._sorters || [];

        // Ensure the keyProperty does not get lost.
        config.keyProperty = me.keyProperty;

        delete config.id;
        delete config.filters;
        delete config.items;
        delete config.sorters;

        if (me._items.length > 0) {
            config.items  = [...me._items];
            config.count = config.items.length;
        }

        config.filters = [];
        config.sorters = [];

        // todo: filters & sorters should push their current state and not the original one

        filters.forEach(function(filter) {
            config.filters.push(filter.originalConfig)
        });

        sorters.forEach(function(sorter) {
            config.sorters.push(sorter.originalConfig)
        });

        return Neo.create(Collection, config)
    }

    /**
     * Clears the map & items array before the super call
     */
    destroy() {
        let me = this;

        me._items.splice(0, me._items.length);
        me.map.clear();

        super.destroy()
    }

    /**
     *
     * @param {Object[]} items=this._items
     * @param {Boolean} silent=false
     * @protected
     */
    doSort(items=this._items, silent=false) {
        let me                = this,
            previousItems     = [...items],
            {sorters, sortDirections, sortProperties} = me,
            countSorters      = sortProperties.length || 0,
            hasSortByMethod   = false,
            hasTransformValue = false,
            i, mappedItems, obj, sorter, sortProperty, sortValue;

        if (countSorters > 0) {
            sorters.forEach(key => {
                if (key.sortBy) {
                    hasSortByMethod = true
                }

                if (key.useTransformValue) {
                    hasTransformValue = true
                }
            });

            if (hasSortByMethod) {
                me._items.sort((a, b) => {
                    i = 0;

                    for (; i < countSorters; i++) {
                        sorter    = sorters[i];
                        sortValue = sorter[sorter.sortBy ? 'sortBy' : 'defaultSortBy'](a, b);

                        if (sortValue !== 0) {
                            return sortValue
                        }
                    }

                    return 0
                })
            } else {
                if (hasTransformValue) {
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Sorting_with_map
                    mappedItems = items.map((item, index) => {
                        obj = {index};
                        i   = 0;

                        for (; i < countSorters; i++) {
                            if (sorters[i].useTransformValue) {
                                obj[sortProperties[i]] = sorters[i].transformValue(item[sortProperties[i]])
                            } else {
                                obj[sortProperties[i]] = item[sortProperties[i]]
                            }
                        }

                        return obj
                    });
                } else {
                    mappedItems = items
                }

                mappedItems.sort((a, b) => {
                    i = 0;

                    for (; i < countSorters; i++) {
                        sortProperty = sortProperties[i];

                        if (a[sortProperty] > b[sortProperty]) {
                            return 1 * sortDirections[i]
                        }

                        if (a[sortProperty] < b[sortProperty]) {
                            return -1 * sortDirections[i]
                        }
                    }

                    return 0
                });

                if (hasTransformValue) {
                    me._items = mappedItems.map(el => {
                        return items[el.index]
                    })
                }
            }
        }

        me[isSorted] = countSorters > 0;

        if (!silent && me[updatingIndex] === 0) {
            me.fire('sort', {
                items: me._items,
                previousItems,
                scope: me
            })
        }
    }

    /**
     * Resumes the collection events.
     * If you started an update using the startSilentUpdateMode flag,
     * you must use the endSilentUpdateMode param for this call.
     * Using the endSilentUpdateMode param will not fire a mutation event.
     * @param {Boolean} [endSilentUpdateMode]
     * @see {@link Neo.collection.Base#startUpdate startUpdate}
     */
    endUpdate(endSilentUpdateMode) {
        const me = this;

        if (me[updatingIndex] > 0) {
            me[updatingIndex]--
        }

        if (endSilentUpdateMode) {
            me[silentUpdateMode] = false
        } else {
            me.fire('mutate', {
                addedItems  : me[toAddArray],
                removedItems: me[toRemoveArray]
            });

            me[toAddArray]   .splice(0, me[toAddArray]   .length);
            me[toRemoveArray].splice(0, me[toRemoveArray].length)
        }
    }

    /**
     * Needed for remote filtering
     * @returns {Object[]}
     */
    exportFilters() {
        let me      = this,
            filters = [],
            filter;

        me.filters?.forEach(key => {
            filter = key.export();

            filter && filters.push(filter)
        });

        return filters
    }

    /**
     * Needed for remote sorting
     * @returns {Object[]}
     */
    exportSorters() {
        let me      = this,
            sorters = [],
            sorter;

        me.sorters?.forEach(key => {
            sorter = key.export();

            sorter && sorters.push(sorter)
        });

        return sorters
    }

    /**
     * @protected
     */
    filter() {
        let me              = this,
            filters         = me._filters,
            countAllFilters = filters.length,
            countFilters    = 0,
            items           = me.allItems?._items || me._items,
            i               = 0,
            countItems      = items.length,
            filteredItems   = [],
            needsSorting    = false,
            oldItems        = [...me._items],
            config, isIncluded, item, j, tmpItems;

        for (; i < countAllFilters; i++) {
            if (!filters[i].disabled) {
                countFilters++
            }
        }

        if (countFilters === 0 && me.allItems) {
            if (me.sorters.length > 0) {
                needsSorting = true
            }

            me.clearSilent();

            me.items = [...me.allItems._items]
        } else {
            if (!me.allItems) {
                config = {...me.originalConfig};

                delete config.filters;
                delete config.items;
                delete config.sorters;

                // When a collection is filtered, it clones itself to create an `allItems` collection
                // which stores the unfiltered data. It is crucial to use `me.constructor` here.
                // If we hardcode `Collection`, subclasses like `data.Store` would lose their specific
                // functionalities (e.g., lazy record instantiation on `get()`) for the `allItems` collection.
                me.allItems = Neo.create(me.constructor, {
                    ...Neo.clone(config, true, true),
                    id         : me.id + '-all',
                    items      : [...me._items], // Initialize with a shallow copy of current items
                    keyProperty: me.keyProperty,
                    sourceId   : me.id
                })
            }

            me.map.clear();

            if (me.filterMode === 'primitive') {
                // using for loops on purpose -> performance
                for (i = 0; i < countItems; i++) {
                    isIncluded = true;
                    item       = items[i];
                    j          = 0;

                    for (; j < countAllFilters; j++) {
                        if (filters[j].isFiltered(item, items, items)) {
                            isIncluded = false;
                            break
                        }
                    }

                    if (isIncluded) {
                        filteredItems.push(item);
                        me.map.set(item[me.keyProperty], item)
                    }
                }

                me._items = filteredItems // silent update, the map is already in place
            } else {
                filteredItems = [...items];

                for (j=0; j < countAllFilters; j++) {
                    tmpItems = [];

                    for (i = 0; i < countItems; i++) {
                        if (!filters[j].isFiltered(filteredItems[i], filteredItems, items)) {
                            tmpItems.push(filteredItems[i])
                        }
                    }

                    filteredItems = [...tmpItems];
                    countItems    = filteredItems.length
                }

                me.items = filteredItems // update the map
            }
        }

        me[isFiltered] = countFilters !== 0;

        if (needsSorting) {
            me.doSort(me.items, true)
        }

        me.count = me.items.length;

        me.fire('filter', {
            isFiltered: me[isFiltered],
            items     : me.items,
            oldItems,
            scope     : me
        })
    }

    /**
     * Returns items which match the property and value.
     * Properties can contain dots for namespaces => find('vdom.id', 'neo-vnode-1')
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]}
     *     returnFirstMatch=false: Returns an empty Array in case no items are found
     *     returnFirstMatch=true:  Returns the first found item or null
     */
    find(property, value, returnFirstMatch=false) {
        let me               = this,
            items            = [],
            isObjectProperty = me.isItem(property),
            item, matchArray, propertiesArray, propertiesLength;

        if (isObjectProperty) {
            propertiesArray  = Object.entries(property);
            propertiesLength = propertiesArray.length;
        }

        for (item of me.items) {
            if (isObjectProperty) {
                matchArray = [];

                propertiesArray.forEach(([key, value]) => {
                    if (Neo.ns(key, false, item) === value) {
                        matchArray.push(true)
                    }
                });

                if (matchArray.length === propertiesLength) {
                    if (returnFirstMatch) {
                        return item
                    }

                    items.push(item)
                }
            } else if (Neo.ns(property, false, item) === value) {
                if (returnFirstMatch) {
                    return item
                }

                items.push(item)
            }
        }

        return returnFirstMatch ? null : items
    }

    /**
     * Returns all items in the collection for which the passed function returns true
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} fn.item The current collection item
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.count The end index (up to, last value excluded)
     * @returns {Array} Returns an empty Array in case no items are found
     */
    findBy(fn, scope=this, start=0, end=this.count) {
        let me    = this,
            items = [],
            i     = start;

        for (; i < end; i++) {
            if (fn.call(scope, me.items[i])) {
                items.push(me.items[i])
            }
        }

        return items
    }

    /**
     * Returns the first item which matches the property and value
     * @param {Object|String} property
     * @param {Number|String} [value] Only required in case the first param is a string
     * @returns {Object} Returns the first found item or null
     */
    findFirst(property, value) {
        return this.find(property, value, true)
    }

    /**
     * Returns the first item inside the collection
     * @returns {Object}
     */
    first() {
        return this.getAt(0)
    }

    /**
     * Returns the object associated to the key, or null if there is none.
     * @param {Number|String} key
     * @returns {Object|null}
     */
    get(key) {
        return this.map.get(key) || null
    }

    /**
     * Returns the item for a given index
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        return this._items[index]
    }

    /**
     * Returns the config value of this.count
     * @returns {Number}
     * @deprecated Use `this.count` directly instead.
     */
    getCount() {
        return this._count || 0 // skipping beforeGetCount() on purpose
    }

    /**
     * @returns {Number}
     */
    getCountMutations() {
        return this[countMutations]
    }

    /**
     * Returns the first matching filter for the given property config
     * @param {String} property
     * @returns {Neo.collection.Filter|null}
     */
    getFilter(property) {
        let filters = this.filters || [],
            i       = 0,
            len     = filters.length;

        for (; i < len; i++) {
            if (filters[i].property === property) {
                return filters[i]
            }
        }

        return null
    }

    /**
     * Returns the key for a given index
     * @param {Number} index
     * @returns {Number|String|undefined}
     */
    getKeyAt(index) {
        let item = this._items[index];
        return item?.[this.keyProperty]
    }

    /**
     * Returns a shallow copy of a portion of the items array
     * @param {Number} [start] Zero-based index at which to begin extraction.
     * @param {Number} [end] Zero-based index before which to end extraction (extracts up to but not including end).
     * @returns {Array}
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
     */
    getRange(start, end) {
        return this._items.slice(start, end)
    }

    /**
     * Returns the Source Collection in case the sourceCollectionId config was set
     * @returns {Neo.collection.Base|undefined}
     */
    getSource() {
        return this.sourceId && Neo.get(this.sourceId)
    }

    /**
     * Returns a boolean asserting whether a value has been associated to the key in the Collection or not
     * @param {Number|String} key
     * @returns {Boolean}
     */
    has(key) {
        return this.map.has(key)
    }

    /**
     * Returns a boolean asserting whether an item exists in the Collection or not
     * @param {Object} item
     * @returns {Boolean}
     */
    hasItem(item) {
        return this.map.has(item[this.keyProperty])
    }

    /**
     * Returns the index for a given key or item
     * @param {Number|String|Object} key
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOf(key) {
        let me = this;
        return me._items.indexOf(me.isItem(key) ? key : me.map.get(key))
    }

    /**
     * Returns the index for a given item
     * @param {Object} item
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOfItem(item) {
        return this._items.indexOf(item)
    }

    /**
     * Returns the index for a given key
     * @param {Number|String} key
     * @returns {Number} index (-1 in case no match is found)
     */
    indexOfKey(key) {
        return this._items.indexOf(this.map.get(key))
    }

    /**
     * Inserts an item or an array of items at the specified index
     * @param {Number} index
     * @param {Array|Object} item
     * @returns {Object[]} an array containing all added items
     */
    insert(index, item) {
        return this.splice(index, 0, item).addedItems
    }

    /**
     * @returns {Boolean} true in case the collection is filtered
     */
    isFiltered() {
        return this[isFiltered]
    }

    /**
     * @param {Object} item
     * @returns {boolean}
     * @protected
     */
    isFilteredItem(item) {
        let me         = this,
            filters    = me._filters,
            i          = 0,
            len        = filters.length,
            isFiltered = false;

        for (; i < len; i++) {
            if (filters[i].isFiltered(item)) {
                isFiltered = true;
                break
            }
        }

        return isFiltered
    }

    /**
     * Helper method to check if a given input is either object-like or a key
     * @param {*} value
     * @returns {Boolean} returns true for object-like values
     */
    isItem(value) {
        // We can not use Neo.isObject() || Neo.isRecord(), since collections can store neo instances too.
        return typeof value === 'object'
    }

    /**
     * @returns {Boolean} true in case the collection is sorted
     */
    isSorted() {
        return this[isSorted]
    }

    /**
     * Returns the last item inside the collection
     * @returns {Object}
     */
    last() {
        return this.getAt(this.count -1)
    }

    /**
     * Moves an item from fromIndex to toIndex
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    move(fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return;
        }

        let items = this._items;

        if (fromIndex >= items.length) {
            fromIndex = items.length - 1
        }

        // The splice operations are intentionally separated.
        // Using the common one-liner `items.splice(toIndex, 0, items.splice(fromIndex, 1)[0])`
        // can lead to unpredictable side effects, as the inner splice can alter the array
        // before the outer splice's index is resolved. This two-step approach is safer.
        const item = items.splice(fromIndex, 1)[0];
        items.splice(toIndex, 0, item)
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        this.filter()
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onMutate(opts) {
        let me = this;

        // todo: inspect the bubbling chain
        /*if (opts.preventBubbleUp) {
            me.preventBubbleUp = true
        }*/

        me.preventBubbleUp = true;

        me.splice(null, opts.removedItems, opts.addedItems)
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onSorterChange(opts) {
        this.applySorterConfigs();
        this.doSort()
    }

    /**
     * Removes the last element from the items array and returns this element.
     * @returns {Object} The removed element from the collection; undefined if the collection is empty.
     */
    pop() {
        let mutation = this.splice(this.count -1, 1);
        return mutation.removedItems[0]
    }

    /**
     * Adds one or more items to the end of the collection and returns the new items count
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    push(item) {
        return this.add(item)
    }

    /**
     * Removes a given key, item or Array containing keys|items
     * @param {Number|String|Object|Array} key
     * @returns {Number} the collection count
     */
    remove(key) {
        this.splice(0, Array.isArray(key) ? key : [key]);
        return this.count
    }

    /**
     * Removes the item at the given index
     * @param {Number} index
     * @returns {Number} the collection count
     */
    removeAt(index) {
        this.splice(index, 1);
        return this.count
    }

    /**
     * Reverses the items array in place.
     * Intended for collections without sorters.
     * @returns {Array} items
     */
    reverse() {
        return this._items.reverse()
    }

    /**
     * Removes the first element from the items array and returns this element.
     * @returns {Object} The removed element from the collection; undefined if the collection is empty.
     */
    shift() {
        let mutation = this.splice(0, 1);
        return mutation.addedItems[0]
    }

    /**
     * @param {function} callback Function to test for each item, taking three parameters:
     * @param {Object}   callback.item The current collection item being processed
     * @param {Number}  [callback.index] The index of the current item being processed
     * @param {Array}   [callback.items] The items array of the collection
     *
     * @param {Object} [scope] Value to use as "this" when executing the callback
     * @returns {boolean} true if the callback function returns a truthy value for any collection item, otherwise false
     */
    some(...args) {
        return this._items.some(...args)
    }

    /**
     * Executes a provided function once for each array element.
     * @param {Function} fn The function to execute for each element.
     * @param {Object} [scope] Value to use as `this` when executing `fn`.
     */
    forEach(fn, scope) {
        this._items.forEach(fn, scope);
    }

    /**
     * Removes items from and/or adds items to this collection
     * If the toRemoveArray is used, then the index is not used for removing, the entries are found by key and removed from where they are.
     * If index is not passed, toAddArray is appended to the Collection.
     * @param {Number|null} index
     * @param {Number|Object[]} [removeCountOrToRemoveArray]
     * @param {Object|Object[]} [toAddArray]
     * @returns {Object} An object containing the addedItems & removedItems arrays
     */
    splice(index, removeCountOrToRemoveArray, toAddArray) {
        let me                 = this,
            {keyProperty, map} = me,
            source             = me.getSource(),
            addedItems         = [],
            items              = me._items,
            removedItems       = [],
            removeCountAtIndex = Neo.isNumber(removeCountOrToRemoveArray) ? removeCountOrToRemoveArray : null,
            toRemoveArray      = Array.isArray(removeCountOrToRemoveArray) ? removeCountOrToRemoveArray : null,
            i, item, key, len, toAddMap;

        if (!Neo.isNumber(index) && removeCountAtIndex) {
            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].error(me.id + ': If index is not passed, removeCountAtIndex cannot be used')
        }

        toAddArray = toAddArray && !Array.isArray(toAddArray) ? [toAddArray] : toAddArray;

        if (toRemoveArray && (len = toRemoveArray.length) > 0) {
            if (toAddArray && toAddArray.length > 0) {
                toAddMap = toAddArray.map(e => e[keyProperty])
            }

            for (i=0; i < len; i++) {
                item = toRemoveArray[i];
                key  = me.isItem(item) ? item[keyProperty] : item;

                if (map.has(key)) {
                    if (!toAddMap || (toAddMap && toAddMap.indexOf(key) < 0)) {
                        removedItems.push(items.splice(me.indexOfKey(key), 1)[0]);
                        map.delete(key)
                    }
                }
            }
        } else if (removeCountAtIndex && removeCountAtIndex > 0) {
            // Optimization: If this is a full clear operation, use map.clear()
            if (index === 0 && removeCountAtIndex === me.count) {
                removedItems = items;
                me._items = [];
                map.clear()
            } else {
                removedItems = items.splice(index, removeCountAtIndex);

                // For partial removals, iterate and delete individual items from the map
                removedItems.forEach(e => {
                    map.delete(e[keyProperty])
                })
            }
        }

        if (toAddArray && (len = toAddArray.length) > 0) {
            for (i=0; i < len; i++) {
                item = toAddArray[i];
                key  = item[keyProperty];

                if (!key) {
                    item[keyProperty] = key = me.keyPropertyIndex;
                    me.keyPropertyIndex--
                }

                // Check if the item has the symbol defined (e.g., initialized to null via RecordFactory).
                // We only want to assign the counter to items that opt-in to this feature to support
                // restoring the original insertion order (e.g., Store.sort() with no args).
                // This prevents polluting plain objects in standard Collections.
                if (Object.hasOwn(item, initialIndexSymbol)) {
                    item[initialIndexSymbol] = me.initialIndexCounter++
                }

                if (!map.has(key) && !me.isFilteredItem(item)) {
                    addedItems.push(item);
                    map.set(key, item)
                }
            }

            if (addedItems.length > 0) {
                if (!items || items.length === 0) {
                    // Performance improvement for Safari, see: https://github.com/neomjs/neo/issues/6228
                    me._items = addedItems
                } else {
                    const finalIndex = Neo.isNumber(index) ? index : items.length;

                    if (addedItems.length > 5000) {
                        // Manually splice for large arrays to avoid a stack overflow
                        const beginning = items.slice(0, finalIndex);
                        const end       = items.slice(finalIndex);
                        me._items       = beginning.concat(addedItems, end);
                    } else {
                        items.splice(finalIndex, 0, ...addedItems)
                    }
                }

                if (me.autoSort && me._sorters.length > 0) {
                    me.doSort(undefined, true)
                }
            }
        }

        if (source) {
            if (!source.getSource()) {
                source.preventBubbleUp = true
            }

            if (!me.preventBubbleUp) {
                // console.log('source splice', source.id, 'added:', ...toAddArray, 'removed:', ...removedItems);
                me.startUpdate(true);
                source.splice(null, toRemoveArray || removedItems, toAddArray);
                me.endUpdate(true)
            }

            delete source.preventBubbleUp
        }

        if (addedItems.length > 0 || removedItems.length > 0) {
            me[countMutations]++
        }

        if (me[updatingIndex] === 0) {
            me.count = me._items.length;

            me.fire('mutate', {
                addedItems     : toAddArray,
                preventBubbleUp: me.preventBubbleUp,
                removedItems   : toRemoveArray || removedItems
            })
        } else if (!me[silentUpdateMode]) {
            me.cacheUpdate({
                addedItems,
                removedItems
            })
        }

        if (me[updatingIndex] === 0) {
            delete me.preventBubbleUp
        }

        return {addedItems, removedItems}
    }

    /**
     * Prevents the collection from firing events until endUpdate gets called.
     * If you start an update using the startSilentUpdateMode param,
     * the mutation event will not fire after using endUpdate()
     * (you must use the endSilentUpdateMode param for the endUpdate call in case you used
     * startSilentUpdateMode here)
     * @param {Boolean} [startSilentUpdateMode]
     * @see {@link Neo.collection.Base#endUpdate endUpdate}
     */
    startUpdate(startSilentUpdateMode) {
        if (startSilentUpdateMode) {
            this[silentUpdateMode] = true
        }

        this[updatingIndex]++
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            count      : me.count,
            filters    : me.filters.map(filter => filter.toJSON()),
            keyProperty: me.keyProperty,
            sorters    : me.sorters.map(sorter => sorter.toJSON()),
            sourceId   : me.sourceId
        }
    }

    /**
     * Adds one or more elements to the beginning of the collection and returns the new items count
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    unshift(item) {
        this.splice(0, 0, item);
        return this.count
    }
}

/**
 * The mutate event fires after every splice call (invoked by all methods which change the content of the items array).
 * @event mutate
 * @param {Object[]} addedItems
 * @param {Boolean} preventBubbleUp private
 * @param {Object[]} removedItems
 * @returns {Object}
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Collection));


/***/ },

/***/ "./src/collection/Filter.mjs"
/*!***********************************!*\
  !*** ./src/collection/Filter.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.collection.Filter
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Filter extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true
    /**
     * Valid values for the operator config:<br>
     * ['==','===','!=','!==','<','<=','>','>=','endsWith','excluded','included','isDefined','isUndefined','like','startsWith']
     * @member {String[]} operators
     * @protected
     * @static
     */
    static operators = [
        '==', '===', '!=', '!==', '<', '<=', '>', '>=', 'doesNotStartWith', 'endsWith', 'excluded',
        'included', 'isDefined', 'isUndefined', 'like', 'startsWith'
    ]

    static config = {
        /**
         * @member {String} className='Neo.collection.Filter'
         * @protected
         */
        className: 'Neo.collection.Filter',
        /**
         * @member {String} ntype='filter'
         * @protected
         */
        ntype: 'filter',
        /**
         * Setting disabled to true will exclude this filter from the collection filtering logic
         * @member {Boolean} disabled_=false
         * @reactive
         */
        disabled_: false,
        /**
         * Provide a custom filtering function which has a higher priority than property, operator & value
         * @member {Function|null} filterBy_=null
         * @reactive
         */
        filterBy_: null,
        /**
         * True means not filtering out items in case the value is '', null, [] or {}
         * @member {Boolean} includeEmptyValues=true
         */
        includeEmptyValues: true,
        /**
         * Set this flag to true before starting bulk updates (e.g. changing property & value)
         * to prevent multiple change events
         * @member {Boolean} isUpdating_=false
         * @reactive
         */
        isUpdating_: false,
        /**
         * The owner util.Collection needs to apply an onChange listener once
         * @member {Boolean} listenerApplied=false
         * @protected
         */
        listenerApplied: false,
        /**
         * The operator to filter by (use the combination of property, operator & value)
         * Valid values:
         *
         * == (not recommended)
         * ===
         * != (not recommended)
         * !==
         * <
         * >=
         * >
         * >=
         * like (collectionValue.toLowerCase().indexOf(filterValue.toLowerCase()) > -1)
         * included (expects value to be an array)
         * excluded (expects value to be an array)
         * @member {String} operator='==='
         */
        operator_: '===',
        /**
         * The property to filter by (use the combination of property, operator & value)
         * @member {String} property_='id'
         * @reactive
         */
        property_: 'id',
        /**
         * The scope to use for the filterBy method, in case it is provided. Defaults to this instance.
         * @member {Object|null} scope=null
         */
        scope: null,
        /**
         * The value to filter by (use the combination of property, operator & value)
         * @member {String} value_=null
         * @reactive
         */
        value_: null
    }

    afterSetDisabled(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetFilterBy(value, oldValue) {
        // todo
    }

    afterSetIsUpdating(value, oldValue) {
        value === false && this.fireChangeEvent(value, oldValue)
    }

    afterSetOperator(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetProperty(...args) {
        this.fireChangeEvent(...args)
    }

    afterSetValue(...args) {
        this.fireChangeEvent(...args)
    }

    beforeSetFilterBy(value, oldValue) {
        if (value && typeof value !== 'function') {
            Neo.logError('filterBy has to be a function', this);
            return oldValue
        }

        return value
    }

    /**
     * Triggered before the operator config gets changed.
     * @param {String|null} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetOperator(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'operator')
    }

    /**
     * Needed for remote filtering
     * @returns {Object|null}
     */
    export() {
        let me                          = this,
            {operator, property, value} = me;

        if (!me.filterBy) {
            return {operator, property, value}
        }

        return null
    }

    /**
     * @param value
     * @param oldValue
     */
    fireChangeEvent(value, oldValue) {
        let me = this;

        if (oldValue !== undefined && me.isUpdating !== true) {
            let {operator, property, value} = me;
            me.fire('change', {operator, property, value})
        }
    }

    /**
     * Checks if a collection item matches this filter
     * @param {Object} item The current collection item
     * @param {Array} filteredItems If the collection filterMode is not primitive contains the items which passed
     * the previous filters, otherwise all collection items
     * @param {Array} allItems all collection items
     * @returns {Boolean}
     */
    isFiltered(item, filteredItems, allItems) {
        let me = this,
            filterValue, recordValue;

        if (me._disabled) {
            return false
        }

        if (me._filterBy) {
            return me.filterBy.call(me.scope || me, {
                allItems,
                filteredItems,
                item,
                value: me._value
            })
        }

        if (me.includeEmptyValues && (me._value === null || Neo.isEmpty(me._value))) {
            return false
        }

        filterValue = me._value;
        recordValue = item[me._property];

        if (filterValue instanceof Date && recordValue instanceof Date) {
            filterValue = filterValue.valueOf();
            recordValue = recordValue.valueOf()
        }

        return !Filter[me._operator](recordValue, filterValue)
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            disabled: me.disabled,
            operator: me.operator,
            property: me.property,
            value   : me.value
        }
    }

    static ['=='] (a, b) {return a == b}
    static ['==='](a, b) {return a === b}
    static ['!='] (a, b) {return a != b}
    static ['!=='](a, b) {return a !== b}
    static ['<']  (a, b) {return a < b}
    static ['<='] (a, b) {return a <= b}
    static ['>']  (a, b) {return a > b}
    static ['>='] (a, b) {return a >= b}

    static ['doesNotStartWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return !a?.toLowerCase().startsWith(b?.toLowerCase())
    }

    static ['endsWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().endsWith(b?.toLowerCase()) || false
    }

    static ['excluded'](a, b) {
        return b.indexOf(a) < 0
    }

    static ['included'](a, b) {
        return b.indexOf(a) > -1
    }

    static ['isDefined'](a, b) {
        return a !== undefined
    }

    static ['isUndefined'](a, b) {
        return a === undefined
    }

    static ['like'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().includes(b?.toLowerCase()) || false
    }

    static ['startsWith'](a, b) {
        if (!Neo.isString(a)) {a = String(a)}
        if (!Neo.isString(b)) {b = String(b)}

        return a?.toLowerCase().startsWith(b?.toLowerCase()) || false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Filter));


/***/ },

/***/ "./src/collection/Sorter.mjs"
/*!***********************************!*\
  !*** ./src/collection/Sorter.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");



/**
 * @class Neo.collection.Sorter
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Sorter extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.collection.Sorter'
         * @protected
         */
        className: 'Neo.collection.Sorter',
        /**
         * @member {String} ntype='sorter'
         * @protected
         */
        ntype: 'sorter',
        /**
         * Internal config which maps the direction ASC to 1, -1 otherwise
         * @member {Number} directionMultiplier=1
         * @protected
         */
        directionMultiplier: 1,
        /**
         * The sort direction when using a property.
         * @member {String} direction_='ASC'
         * @reactive
         */
        direction_: 'ASC',
        /**
         * The owner util.Collection needs to apply an onChange listener once
         * @member {boolean} listenerApplied=false
         * @protected
         */
        listenerApplied: false,
        /**
         * The property to sort by.
         * @member {String} property_='id'
         * @reactive
         */
        property_: 'id',
        /**
         * Provide a custom sorting function, has a higher priority than property & direction
         * @member {Function|null} sortBy=null
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        sortBy: null,
        /**
         * True to use the transformValue method for each item (the method can get overridden)
         * @member {Boolean} useTransformValue=true
         * @protected
         */
        useTransformValue: true
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetDirection(value, oldValue) {
        let me = this;

        me.directionMultiplier = value === 'ASC' ? 1 : -1;

        if (oldValue) {
            me.fire('change', {
                direction: me.direction,
                property : me.property
            });
        }
    }

    /**
     * @param {String} value
     * @param {String} oldValue
     */
    afterSetProperty(value, oldValue) {
        let me = this;

        if (oldValue) {
            me.fire('change', {
                direction: me.direction,
                property : me.property
            });
        }
    }

    /**
     * Default sorter function which gets used by collections in case at least one sorter has a real sortBy method
     * @param a
     * @param b
     */
    defaultSortBy(a, b) {
        let me = this;

        a = a[me.property];
        b = b[me.property];

        if (me.useTransformValue) {
            a = me.transformValue(a);
            b = me.transformValue(b);
        }

        if (a > b) {
            return 1 * me.directionMultiplier;
        }

        if (a < b) {
            return -1 * me.directionMultiplier;
        }

        return 0;
    }

    /**
     * Needed for remote sorting
     * @returns {Object|null}
     */
    export() {
        let me                    = this,
            {direction, property} = me;

        if (!me.sortBy && direction && property) {
            return {direction, property}
        }

        return null
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            direction: this.direction,
            property : this.property
        }
    }

    /**
     * @param {*} value
     * @returns {*} value
     */
    transformValue(value) {
        if (typeof value === 'string') {
            value = value.toLowerCase()
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Sorter));


/***/ },

/***/ "./src/core/Base.mjs"
/*!***************************!*\
  !*** ./src/core/Base.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Compare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Compare.mjs */ "./src/core/Compare.mjs");
/* harmony import */ var _core_Util_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Util.mjs */ "./src/core/Util.mjs");
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");








const configSymbol       = Symbol.for('configSymbol'),
      forceAssignConfigs = Symbol('forceAssignConfigs'),
      isInstance         = Symbol('isInstance');

/**
 * The base class for (almost) all classes inside the Neo namespace
 * Exceptions are e.g. core.IdGenerator, vdom.VNode
 * @class Neo.core.Base
 */
class Base {
    /**
     * You can define methods which should get delayed.
     * Types are buffer, debounce & throttle.
     * @example
     *  delayable: {
     *      fireChangeEvent: {
     *          type : 'debounce',
     *          timer: 300
     *      }
     *  }
     * @member {Object} delayable={}
     * @protected
     * @static
     */
    static delayable = {}
    /**
     * Flag which will get set to true once manager.Instance got created
     * @member {Boolean} instanceManagerAvailable=false
     * @static
     */
    static instanceManagerAvailable = false
    /**
     * Regex to grab the MethodName from an error
     * which is a second generation function
     * @member {RegExp} methodNameRegex
     * @static
     */
    static methodNameRegex = /\n.*\n\s+at\s+.*\.(\w+)\s+.*/
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=false
     * @static
     */
    static observable = false
    /**
     * Keep the overwritten methods
     * @member {Object} overwrittenMethods={}
     * @protected
     * @static
     */
    static overwrittenMethods = {}
    /**
     * Defines the default configuration properties for the class. These configurations are
     * merged throughout the class hierarchy and can be overridden at the instance level.
     *
     * There are two main types of configs:
     *
     * 1.  **Reactive Configs:** Property names ending with a trailing underscore (e.g., `myConfig_`).
     *     The framework automatically generates a public getter and setter, removing the underscore
     *     from the property name (e.g., `this.myConfig`). This system enables powerful, optional
     *     lifecycle hooks that are called automatically if they are implemented on the class:
     *     - `beforeGetMyConfig(value)`: Executed before the getter returns. Can be used to dynamically modify the returned value.
     *     - `beforeSetMyConfig(newValue, oldValue)`: Executed before a new value is set. Can be used for validation or transformation. Returning `undefined` from this hook will cancel the update.
     *     - `afterSetMyConfig(newValue, oldValue)`: Executed after a new value has been successfully set. Ideal for triggering side effects.
     *
     * 2.  **Non-Reactive (Prototype-based) Configs:** Property names without a trailing underscore.
     *     These are applied directly to the class's **prototype** during the `Neo.setupClass`
     *     process. This is highly memory-efficient as the value is shared across all instances.
     *     It also allows for powerful, application-wide modifications of default behaviors
     *     by using the `Neo.overwrites` mechanism, which modifies these prototype values at
     *     load time.
     *
     *     **vs. Class Fields:**
     *     Use a non-reactive config when you want the property to be eligible for the `Neo.overwrites`
     *     mechanism. This allows external code (like themes or application-level overrides) to change
     *     the default value for the class, which then propagates to all subclasses and instances
     *     globally. Use standard class fields for internal state that should not be globally reconfigured.
     *
     * @returns {Object} config
     */
    static config = {
        /**
         * The class name which will get mapped into the Neo or app namespace
         * @member {String} className='Neo.core.Base'
         * @protected
         */
        className: 'Neo.core.Base',
        /**
         * The class shortcut-name to use for e.g. creating child components inside a JSON-format
         * @member {String} ntype='base'
         * @protected
         */
        ntype: 'base',
        /**
         * While it is recommended to change the static delayable configs on class level,
         * you can change it on instance level too. If not null, we will do a deep merge.
         * @member {Object} delayable=null
         */
        delayable: null,
        /**
         * The unique component id
         * @member {String|null} id_=null
         * @reactive
         */
        id_: null,
        /**
         * An array of remote method names that should be intercepted.
         * Names used here must be present inside the `remote_` config.
         * If a remote call for one of these methods arrives, `onInterceptRemotes()` will be called.
         * @member {String[]|null} interceptRemotes=null
         * @protected
         */
        interceptRemotes: null,
        /**
         * Neo.create() will change this flag to true after the onConstructed() chain is done.
         * @member {Boolean} isConstructed=false
         * @protected
         */
        isConstructed: false,
        /**
         * This config will be set to `true` as the very first action within the `destroy()` method.
         * Effects can observe this config to clean themselves up.
         * @member {Boolean} isDestroying_=false
         * @protected
         * @reactive
         */
        isDestroying_: false,
        /**
         * The config will get set to `true` once the Promise of `async initAsync()` is resolved.
         * You can use `afterSetIsReady()` to get notified once the ready state is reached.
         * For observable classes, this will also fire a `ready` event.
         * @member {Boolean} isReady_=false
         * @reactive
         */
        isReady_: false,
        /**
         * Add mixins as an array of classNames, imported modules or a mixed version
         * @member {String[]|Neo.core.Base[]|null} mixins=null
         */
        mixins: null,
        /**
         * You can create a new instance by passing an imported class (JS module default export)
         * @member {Class} module=null
         * @protected
         */
        module: null,
        /**
         * Remote method access for other threads. Example use case:
         * remote: {app: ['myRemoteMethod']}
         *
         * ONLY supported for singletons.
         *
         * @member {Object|null} remote_=null
         * @protected
         * @reactive
         */
        remote_: null
    }

    /**
     * A private field to store the Config controller instances.
     * @member {Object} #configs={}
     * @private
     */
    #configs = {};
    /**
     * Internal cache for all config subscription cleanup functions.
     * @member {Function[]} #configSubscriptionCleanups=[]
     * @private
     */
    #configSubscriptionCleanups = []
    /**
     * A promise that resolves when the instance is fully initialized (after initAsync() completes).
     * @member {Promise<void>|null} #readyPromise
     * @private
     */
    #readyPromise = null;
    /**
     * A resolver function for the ready promise.
     * @member {Function|null} #readyResolver
     * @private
     */
    #readyResolver = null;
    /**
     * A promise that resolves when the remote methods are registered.
     * @member {Promise<void>|null} #remotesReadyPromise
     * @private
     */
    #remotesReadyPromise = null;
    /**
     * A resolver function for the remotesReady promise.
     * @member {Function|null} #remotesReadyResolver
     * @private
     */
    #remotesReadyResolver = null;
    /**
     * Internal cache for all timeout ids when using this.timeout()
     * @member {Number[]} timeoutIds=[]
     * @private
     */
    #timeoutIds = []

    /**
     * The main initializer for all Neo.mjs classes, invoked by `Neo.create()`.
     * NOTE: This is not the native `constructor()`, which is called without arguments by `Neo.create()` first.
     *
     * This method orchestrates the entire instance initialization process, including
     * the setup of the powerful and flexible config system.
     *
     * The `config` parameter is a single object that can contain different types of properties,
     * which are processed in a specific order to ensure consistency and predictability:
     *
     * 1.  **Public Class Fields & Other Properties:** Any key in the `config` object that is NOT
     *     defined in the class's `static config` hierarchy is considered a public field or a
     *     dynamic property. These are assigned directly to the instance (`this.myField = value`)
     *     at the very beginning. This is crucial so that subsequent config hooks (like `afterSet*`)
     *     can access their latest values.
     *
     * 2.  **Reactive Configs:** A property is considered reactive if it is defined with a trailing
     *     underscore (e.g., `myValue_`) in the `static config` of **any class in the inheritance
     *     chain**. Subclasses can provide new default values for these configs without the
     *     underscore, and they will still be reactive. Their values are applied via generated
     *     setters, triggering `beforeSet*` and `afterSet*` hooks, and they are wrapped in a
     *     `Neo.core.Config` instance to enable subscription-based reactivity.
     *
     * 3.  **Non-Reactive Configs:** Properties defined in `static config` without a trailing
     *     underscore in their entire inheritance chain. Their default values are applied directly
     *     to the class **prototype**, making them shared across all instances and allowing for
     *     run-time modifications (prototypal inheritance). When a new value is passed to this
     *     method, it creates an instance-specific property that shadows the prototype value.
     *
     * This method also initializes the observable mixin (if applicable) and schedules asynchronous
     * logic like `initAsync()` (which handles remote method access) to run after the synchronous
     * construction chain is complete.
     *
     * @param {Object} config={} The initial configuration object for the instance.
     */
    construct(config={}) {
        let me = this;

        Object.defineProperties(me, {
            [configSymbol]: {
                configurable: true,
                enumerable  : false,
                value       : {},
                writable    : true
            },
            [isInstance]: {
                enumerable: false,
                value     : true
            }
        });

        me.id = config.id || me.constructor.config.id || _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getId(this.getIdKey());
        delete config.id;

        // Assign class field values prior to configs
        config = me.setFields(config);

        me.initConfig(config);

        Object.defineProperty(me, 'configsApplied', {
            enumerable: false,
            value     : true
        });

        me.applyDelayable();

        /*
         * We do not want to force devs to check for the `isDestroyed` flag in every possible class extension.
         * So, we are intercepting the top-most `destroy()` call to check for the flag there.
         * Rationale: `destroy()` must only get called once.
         */
        (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.intercept)(me, 'destroy', me.#preDestroyHook, me);

        // Storing a resolver to execute inside `afterSetIsReady`.
        me.#readyPromise = new Promise(resolve => {
            me.#readyResolver = resolve
        });

        me.#remotesReadyPromise = new Promise(resolve => {
            me.#remotesReadyResolver = resolve
        });

        // Triggers async logic after the construction chain is done.
        Promise.resolve().then(async () => {
            await me.initAsync();
            me.isReady = true
        })
    }

    /**
     * Triggered after the id config got changed.
     * You can dynamically change instance ids if needed. They need to stay unique at any given point.
     * Use case: e.g. component based lists, where you want to re-use item instances.
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        let me         = this,
            hasManager = Base.instanceManagerAvailable === true;

        if (oldValue) {
            if (hasManager) {
                Neo.manager.Instance.unregister(oldValue)
            } else if (Neo.idMap) {
                delete Neo.idMap[oldValue]
            }
        }

        if (value) {
            if (hasManager) {
                Neo.manager.Instance.register(me)
            } else {
                Neo.idMap ??= {};
                Neo.idMap[value] = me
            }
        }
    }

    /**
     * Triggered after the isReady config gets changed.
     * Resolves the ready() promise and fires the ready event for observable classes.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        if (value) {
            let me = this;

            me.#readyResolver?.();

            // We can only fire the event in case the Observable mixin is included.
            me.getStaticConfig('observable') && me.fire('ready')
        }
    }

    /**
     * Adjusts all methods inside static delayable
     */
    applyDelayable() {
        let me            = this,
            ctorDelayable = me.constructor.delayable,
            delayable     = me.delayable ? Neo.merge({}, me.delayable, ctorDelayable) : ctorDelayable;

        Object.entries(delayable).forEach(([key, value]) => {
            if (value) {
                let map = {
                    buffer()   {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.buffer(me[key],   me, value.timer)},
                    debounce() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce(me[key], me, value.timer)},
                    throttle() {me[key] = new _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.throttle(me[key], me, value.timer)}
                };

                map[value.type]?.()
            }
        })
    }

    /**
     * This static method is called by `Neo.setupClass()` during the class creation process.
     * It allows for modifying a class's default prototype-based configs from outside the
     * class hierarchy, which is a powerful way to avoid boilerplate code.
     *
     * It looks for a matching entry in the global `Neo.overwrites` object based on the
     * class's `className`. If found, it merges the properties from the overwrite object
     * into the class's static `config`. This provides a powerful mechanism for theming
     * or applying application-wide customizations to framework or library classes without
     * needing to extend them.
     *
     * @example
     * // Imagine you have hundreds of buttons in your app, and you want all of them
     * // to have `labelPosition: 'top'` instead of the default `'left'`.
     * // Instead of configuring each instance, you can define an overwrite.
     *
     * // inside an Overwrites.mjs file loaded by your app:
     * Neo.overwrites = {
     *     Neo: {
     *         button: {
     *             Base: {
     *                 labelPosition: 'top'
     *             }
     *         }
     *     }
     * };
     *
     * // Now, every `Neo.button.Base` (and any class that extends it) will have this
     * // new default value on its prototype.
     *
     * @param {Object} cfg The static `config` object of the class being processed.
     * @protected
     * @static
     */
    static applyOverwrites(cfg) {
        let overwrites = Neo.ns(cfg.className, false, Neo.overwrites),
            cls, item;

        if (overwrites) {
            // Apply all methods
            for (item in overwrites) {
                if (Neo.isFunction(overwrites[item])) {
                    // Already existing ones
                    cls = this.prototype;

                    if (cls[item]) {
                        // Add to overwrittenMethods
                        cls.constructor.overwrittenMethods[item] = cls[item]
                    }
                }
            }

            // Apply configs to prototype
            Object.assign(cfg, overwrites)
        }
    }

    /**
     * Convenience method for beforeSet functions which test if a given value is inside a static array
     * @param {String|Number} value
     * @param {String|Number} oldValue
     * @param {String} name config name
     * @param {Array|String} [staticName=name + 's'] name of the static config array
     * @returns {String|Number} value or oldValue
     */
    beforeSetEnumValue(value, oldValue, name, staticName = name + 's') {
        let values = Array.isArray(staticName) ? staticName : this.getStaticConfig(staticName);

        if (!values.includes(value)) {
            console.error(`Supported values for ${name} are:`, ...values, this);
            return oldValue
        }

        return value
    }

    /**
     * Triggered before the remote config gets changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetRemote(value, oldValue) {
        let me = this;

        // Only allow remote access for singletons or main thread addons
        if (value && !me.singleton && !me.isMainThreadAddon) {
            throw new Error('Remote method access is only functional for Singleton classes ' + me.className)
        }

        return value
    }

    /**
     * @param {String} fn               The name of a function to find in the passed scope object.
     * @param {Object} originName       The name of the method inside the originScope.
     * @param {Object} scope            The scope to find the function in if it is specified as a string.
     * @param {Object} originScope=this The scope where the function is located.
     */
    bindCallback(fn, originName, scope=this, originScope=this) {
        if (fn && Neo.isString(fn)) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveCallback)(fn, scope);
            originScope[originName] = handler.fn.bind(handler.scope)
        }
    }

    /**
     * From within an overwrite, a method can call a parent method, by using callOverwritten.
     *
     * @example
     *    afterSetHeight(value, oldValue) {
     *        // do the standard
     *        this.callOverwritten(...arguments);
     *        // do you own stuff
     *    }
     *
     * We create an error to get the caller.name and then run that method on the constructor.
     * This is based on the following error structure, e.g. afterSetHeight.
     *
     *     Error
     *         at Base.callOverwritten (Base.mjs:176:21)
     *         at Base.afterSetHeight (Overrides.mjs:19:26)
     *
     * @param args
     */
    callOverwritten(...args) {
        let stack      = new Error().stack,
            methodName = stack.match(Base.methodNameRegex)[1];

        this.__proto__.constructor.overwrittenMethods[methodName].call(this, ...args)
    }

    /**
     * Unregisters this instance from Neo.manager.Instance
     * and removes all object entries from this instance
     */
    destroy() {
        let me = this;

        me.#timeoutIds.forEach(id => {
            clearTimeout(id)
        });

        me.#configSubscriptionCleanups.forEach(cleanup => {
            cleanup()
        });

        if (Base.instanceManagerAvailable === true) {
            Neo.manager.Instance.unregister(me)
        } else if (Neo.idMap) {
            delete Neo.idMap[me.id]
        }

        Object.keys(me).forEach(key => {
            if (Object.getOwnPropertyDescriptor(me, key).writable) {
                // We must not delete the custom destroy() interceptor
                if (key !== 'destroy' && key !== '_id') {
                    delete me[key]
                }
            }
        });

        // We do want to prevent delayed event calls after an observable instance got destroyed.
        if (Neo.isFunction(me.fire)) {
            me.fire = Neo.emptyFn
        }

        me.isDestroyed = true
    }

    /**
     * A public method to access the underlying Config controller.
     * This enables advanced interactions like subscriptions.
     * @param {String} key The name of the config property (e.g., 'items').
     * @returns {Config|undefined} The Config instance, or undefined if not found.
     */
    getConfig(key) {
        let me = this;

        if (!me.#configs[key] && me.isConfig(key)) {
            me.#configs[key] = new _Config_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](me.constructor.configDescriptors?.[key])
        }

        return me.#configs[key]
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * Override this method as needed.
     * @returns {String}
     */
    getIdKey() {
        return this.ntype
    }

    /**
     * Returns the value of a static config key or the staticConfig object itself in case no value is set
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @returns {*}
     */
    getStaticConfig(key) {
        return this.constructor[key]
    }

    /**
     * Check if a given ntype exists inside the proto chain, including the top level class
     * @param {String} ntype
     * @returns {Boolean}
     */
    hasNtype(ntype) {
        return this.constructor.ntypeChain.includes(ntype)
    }

    /**
     * Gets triggered after onConstructed() is done
     */
    init() {}

    /**
     * You can use this method in subclasses to perform asynchronous initialization logic.
     * Make sure to use the parent call `await super.initAsync()` at the beginning of their implementations,
     * or the registration of remote methods will get delayed.
     *
     * A common use case is requiring conditional or optional dynamic imports or fetching initial data.
     *
     * Once the promise returned by this method is fulfilled, the `isReady` config will be set to `true`.
     * @returns {Promise<void>} A promise that resolves when the asynchronous initialization is complete.
     */
    async initAsync() {
        if (this.remote) {
            await this.initRemote()
        }

        this.#remotesReadyResolver()
    }

    /**
     * Applies all class configs to this instance
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @protected
     */
    initConfig(config, preventOriginalConfig) {
        let me = this;

        me.isConfiguring = true;
        Object.assign(me[configSymbol], me.mergeConfig(config, preventOriginalConfig));
        delete me[configSymbol].id;
        me.processConfigs();
        me.isConfiguring = false
    }

    /**
     * Does get triggered with a delay to ensure that Neo.workerId & Neo.worker.Manager are defined
     * Remote method access via promises
     * @protected
     */
    async initRemote() {
        let {className, remote} = this,
            {currentWorker}     = Neo;

        if (!Neo.config.isMiddleware && !Neo.config.unitTestMode) {
            if (Neo.workerId !== 'main' && currentWorker.isSharedWorker) {
                if (remote.main) {
                    currentWorker.remotesToRegister.push({className, methods: remote.main})
                }

                if (!currentWorker.isConnected) {
                    await new Promise(resolve => {
                        currentWorker.on('connected', () => resolve(), this, {once: true})
                    })
                }
            }

            await Base.promiseRemotes(className, remote)
        }
    }

    /**
     * @param {String} key
     * @returns {Boolean}
     */
    isConfig(key) {
        let me = this;
        // If a `core.Config` controller is already created, return true (fastest possible check).
        // If not, a config is considered "reactive" if it has a generated property setter
        // AND it is present as a defined config in the merged static config hierarchy.
        // Neo.setupClass() removes the underscore from the static config keys.
        return me.#configs[key] || (Neo.hasPropertySetter(me, key) && (key in me.constructor.config))
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     * @protected
     */
    mergeConfig(config, preventOriginalConfig) {
        let me   = this,
            ctor = me.constructor,
            configDescriptors, staticConfig;

        if (!ctor.config) {
            throw new Error('Neo.applyClassConfig has not been run on ' + me.className)
        }

        if (!preventOriginalConfig) {
            me.originalConfig = Neo.clone(config, true, true)
        }

        configDescriptors = ctor.configDescriptors;
        staticConfig      = ctor.config;

        if (configDescriptors) {
            Object.entries(config).forEach(([key, instanceValue]) => {
                const descriptor = configDescriptors[key];

                if (descriptor?.merge) {
                    config[key] = Neo.mergeConfig(staticConfig[key], instanceValue, descriptor.merge)
                }
            })
        }

        return {...staticConfig, ...config}
    }

    /**
     * Subscribes *this* instance (the subscriber) to changes of a specific config property on another instance (the publisher).
     * Ensures automatic cleanup when *this* instance (the subscriber) is destroyed.
     *
     * @param {String|Neo.core.Base} publisher  - The ID of the publisher instance or the instance reference itself.
     * @param {String}               configName - The name of the config property on the publisher to subscribe to (e.g., 'myConfig').
     * @param {Function}             fn         - The callback function to execute when the config changes.
     * @returns {Function} A cleanup function to manually unsubscribe if needed before this instance's destruction.
     *
     * @example
     * // Subscribing to a config on another instance
     * this.observeConfig(someOtherInstance, 'myConfig', (newValue, oldValue) => {
     *     console.log('myConfig changed:', newValue);
     * });
     *
     * // Discouraged: Self-observation. Use afterSet<ConfigName>() hooks instead.
     * this.observeConfig(this, 'myOwnConfig', (newValue, oldValue) => {
     *     console.log('myOwnConfig changed:', newValue);
     * });
     */
    observeConfig(publisher, configName, fn) {
        let publisherInstance = publisher;

        if (Neo.isString(publisher)) {
            publisherInstance = Neo.get(publisher);
            if (!publisherInstance) {
                console.warn(`Publisher instance with ID '${publisher}' not found. Cannot subscribe.`);
                return Neo.emptyFn
            }
        }

        if (!(publisherInstance instanceof Neo.core.Base)) {
            console.warn(`Invalid publisher provided. Must be a Neo.core.Base instance or its ID.`);
            return Neo.emptyFn
        }

        const configController = publisherInstance.getConfig(configName);

        if (!configController) {
            console.warn(`Config '${configName}' not found on publisher instance ${publisherInstance.id}. Cannot subscribe.`);
            return Neo.emptyFn
        }

        const cleanup = configController.subscribe({id: this.id, fn});

        this.#configSubscriptionCleanups.push(cleanup);

        return cleanup
    }

    /**
     *
     */
    onAfterConstructed() {
        let me = this;

        me.isConstructed = true;

        // We can only fire the event in case the Observable mixin is included.
        me.getStaticConfig('observable') && me.fire('constructed', me)
    }

    /**
     * Gets triggered after all constructors are done
     */
    onConstructed() {}

    /**
     * Placeholder method for intercepting remote calls.
     * Subclasses can override this method to implement custom interception logic.
     * @param {Object} msg The remote message object.
     */
    onInterceptRemotes(msg) {
        // No-op in base class
    }

    /**
     * Helper method to replace string-based values containing "@config:" with the matching config value
     * of this instance.
     * @param {Object|Object[]} items
     */
    parseItemConfigs(items) {
        let me = this,
            ns, nsArray, nsKey, symbolNs;

        if (items) {
            if (!Array.isArray(items)) {
                items = [items]
            }

            items.forEach(item => {
                item && Object.entries(item).forEach(([key, value]) => {
                    if (Array.isArray(value)) {
                        me.parseItemConfigs(value);
                    } else if (typeof value === 'string' && value.startsWith('@config:')) {
                        nsArray = value.substring(8).trim().split('.');
                        nsKey   = nsArray.pop();
                        ns      = Neo.ns(nsArray, false, me);

                        if (ns[nsKey] === undefined) {
                            console.error('The used @config does not exist:', nsKey, nsArray.join('.'))
                        } else {
                            symbolNs = Neo.ns(nsArray, false, me[configSymbol]);

                            // The config might not be processed yet, especially for configs
                            // not ending with an underscore, so we need to check the configSymbol first.
                            if (symbolNs && Object.hasOwn(symbolNs, nsKey)) {
                                item[key] = symbolNs[nsKey]
                            } else {
                                item[key] = ns[nsKey]
                            }
                        }
                    }
                })
            })
        }
    }

    /**
     * Intercepts destroy() calls to ensure they will only get called once
     * @returns {Boolean}
     * @private
     */
    #preDestroyHook() {
        this.isDestroying = true;
        return !this.isDestroyed
    }

    /**
     * When using set(), configs without a trailing underscore can already be assigned,
     * so the hasOwnProperty() check will return true
     * @param {Boolean} [forceAssign=false]
     * @protected
     */
    processConfigs(forceAssign=false) {
        let me   = this,
            keys = Object.keys(me[configSymbol]);

        me[forceAssignConfigs] = forceAssign;

        // We do not want to iterate over the keys, since 1 config can remove more than 1 key (beforeSetX, afterSetX)
        if (keys.length > 0) {
            // The hasOwnProperty check is intended for configs without a trailing underscore
            // => they could already have been assigned inside an afterSet-method
            if (forceAssign || !me.hasOwnProperty(keys[0])) {
                me[keys[0]] = me[configSymbol][keys[0]]
            }

            // there is a delete-call inside the config getter as well (Neo.mjs => autoGenerateGetSet())
            // we need to keep this one for configs, which do not use getters (no trailing underscore)
            delete me[configSymbol][keys[0]];

            me.processConfigs(forceAssign)
        }
    }

    /**
     * Returns a promise that resolves when the instance is fully initialized (after initAsync).
     * Use case: alternative way to subscribe to the ready state, especially for classes which are not observable.
     * @example: await ChromaManager.ready();
     * @returns {Promise<void>}
     */
    ready() {
        return this.#readyPromise;
    }

    /**
     * Returns a promise that resolves when the remote methods are registered.
     * @returns {Promise<void>}
     */
    remotesReady() {
        return this.#remotesReadyPromise
    }

    /**
     * Sends remote method registration messages to other threads (workers or main-threads).
     * This method is crucial for enabling cross-worker communication and remote method invocation
     * for singleton instances. It ensures that methods defined in the `remote` config
     * are properly registered in the target realm.
     * @param {String} className - The class name of the instance sending the remote messages.
     * @param {Object} remote    - The remote config object, specifying target threads and methods.
     * @protected
     * @static
     */
    static async promiseRemotes(className, remote) {
        let origin, promises = [];

        Object.entries(remote).forEach(([worker, methods]) => {
            if (Neo.workerId !== worker) {
                origin = Neo.workerId === 'main' ? Neo.worker.Manager : Neo.currentWorker;

                if (origin.hasWorker(worker)) {
                    promises.push(origin.promiseMessage(worker, {action: 'registerRemote', className, methods}))
                }
            }
        });

        await Promise.all(promises)
    }

    /**
     * Serializes a config object/array to be JSON-compatible.
     * Use this method when a config might contain references to Neo classes (constructors)
     * which need to be converted to their className strings for serialization.
     * @param {Array|Object} config
     * @returns {Array|Object}
     */
    serializeConfig(config) {
        let me   = this,
            type = Neo.typeOf(config);

        if (type === 'Array') {
            return config.map(item => me.serializeConfig(item))
        }

        if (type === 'NeoInstance') {
            return {
                className: config.className,
                id       : config.id
            }
        }

        if (type !== 'Object') {
            return type === 'NeoClass' ? config.prototype.className : config
        }

        let out = {};

        Object.entries(config).forEach(([key, value]) => {
            type = Neo.typeOf(value);

            if (type === 'NeoClass') {
                if (key === 'module') {
                    out.className = value.prototype.className
                } else {
                    out[key] = value.prototype.className
                }
            } else if (type === 'NeoInstance') {
                out[key] = {
                    className: value.className,
                    id       : value.id
                }
            } else if (type === 'Object' || type === 'Array') {
                out[key] = me.serializeConfig(value)
            } else if (type !== 'Function') {
                out[key] = value
            } else {
                out[key] = '[Function]'
            }
        });

        return out
    }

    /**
     * set() accepts the following input as keys:
     * 1. Non-reactive configs
     * 2. Reactive configs
     * 3. Class fields defined via value
     * 4. Class fields defined via get() & set()
     * 5. "Anything else" will get directly get assigned to the instance
     *
     * The logic resolves circular dependencies as good as possible and ensures that config related hooks:
     * - beforeGet<Config>
     * - beforeSet<Config>
     * - afterSet<Config>
     * can access all new values from the batch operation.
     * @param {Object} values={}
     */
    set(values={}) {
        let me                = this,
            classFieldsViaSet = {};

        // Prevent Effects from running for bulk changes
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].pause();

        try {
            values = me.setFields(values);

            // If the initial config processing is still running,
            // finish this one first before dropping new values into the configSymbol.
            // See: https://github.com/neomjs/neo/issues/2201
            if (me[forceAssignConfigs] !== true && Object.keys(me[configSymbol]).length > 0) {
                me.processConfigs()
            }

            // Store class fields which are defined via get() & set() and ensure they won't get added to the config symbol.
            Object.entries(values).forEach(([key, value]) => {
                if (!me.isConfig(key)) {
                    classFieldsViaSet[key] = value;
                    delete values[key]
                }
            })

            // Add reactive configs to the configSymbol
            Object.assign(me[configSymbol], values);

            // Process class fields which are defined via get() & set() => now they can access the latest values
            // for reactive and non-reactive configs, as well as class fields defined with values.
            Object.entries(classFieldsViaSet).forEach(([key, value]) => {
                me[key] = value
            })

            // Process reactive configs
            me.processConfigs(true);
        } finally {
            // Trigger the skipped Effect, if needed
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].resume()
        }
    }

    /**
     * We want to assign class fields first and remove them from the config object,
     * so that afterSet(), beforeGet() and beforeSet() methods can get the new values right away
     * @param {Object} config
     * @returns {Object}
     * @protected
     */
    setFields(config) {
        let me = this;

        Object.entries(config).forEach(([key, value]) => {
            if (!me.isConfig(key) && !Neo.hasPropertySetter(me, key)) {
                me[key] = value;
                delete config[key]
            }
        });

        return config
    }

    /**
     * Sets the value of a static config by a given key
     * @param {String} key The key of a staticConfig defined inside static getStaticConfig
     * @param {*} value
     * @returns {Boolean} true in case the config exists and got changed
     */
    setStaticConfig(key, value) {
        let staticConfig = this.constructor.staticConfig;

        if (staticConfig.hasOwnProperty(key)) {
            staticConfig[key] = value;
            return true
        }

        return false
    }

    /**
     * Stores timeoutIds internally, so that destroy() can clear them if needed
     * @param {Number} time in milliseconds
     * @returns {Promise<any>}
     */
    timeout(time) {
        return new Promise(resolve => {
            let timeoutIds = this.#timeoutIds,
                timeoutId  = setTimeout(() => {timeoutIds.splice(timeoutIds.indexOf(timeoutId), 1); resolve()}, time);

            timeoutIds.push(timeoutId)
        })
    }

    /**
     * Recursive helper to extract all mixin classes from the mixins object
     * @param {Object} [obj=this.mixins]
     * @param {Array} [res=[]]
     * @returns {Array}
     * @protected
     */
    getMixins(obj=this.mixins, res=[]) {
        if (obj) {
            Object.values(obj).forEach(value => {
                if (value && value.prototype) {
                    res.push(value)
                } else if (Neo.isObject(value)) {
                    this.getMixins(value, res)
                }
            })
        }

        return res
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * Subclasses should override this to include their specific relevant state.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        // Recursion guard: If a mixin calls super.toJSON(), it hits this method again.
        // We return the base object to break the loop.
        if (me.__inToJSON) {
            return {
                className  : me.className,
                id         : me.id,
                isDestroyed: me.isDestroyed,
                ntype      : me.ntype,
                remote     : me.remote
            }
        }

        me.__inToJSON = true;

        try {
            let out = {
                className  : me.className,
                id         : me.id,
                isDestroyed: me.isDestroyed,
                ntype      : me.ntype,
                remote     : me.remote
            };

            me.getMixins().forEach(mixin => {
                if (mixin.prototype.toJSON) {
                    Object.assign(out, mixin.prototype.toJSON.call(me))
                }
            });

            return out
        } finally {
            delete me.__inToJSON
        }
    }

    /**
     * <p>Enhancing the toString() method, e.g.</p>
     * `Neo.create('Neo.button.Base').toString() => "[object Neo.button.Base]"`
     * @returns {String}
     */
    get [Symbol.toStringTag]() {
        return this.className
    }

    /**
     * <p>Enhancing the instanceof method. Without this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => true`
     * <p>With this change:</p>
     * `Neo.collection.Base.prototype instanceof Neo.core.Base => false`<br>
     * `Neo.create(Neo.collection.Base) instanceof Neo.core.Base => true`
     * @returns {Boolean}
     */
    static [Symbol.hasInstance](instance) {
        if (!instance) {
            return false
        }

        return instance[isInstance] === true ? super[Symbol.hasInstance](instance) : false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ },

/***/ "./src/core/Compare.mjs"
/*!******************************!*\
  !*** ./src/core/Compare.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class Neo.core.Compare
 */
class Compare {
    /**
     * Storing the comparison method names by data type
     * @member {Object} map
     */
    static map = {
        Array      : 'compareArrays',
        Date       : 'compareDates',
        Function   : 'compareFunctions',
        Map        : 'compareMaps',
        NeoInstance: 'compareNeoInstances',
        Object     : 'compareObjects',
        RegExp     : 'compareRegExps',
        Set        : 'compareSets'
    }

    /**
     * @param {Array} item1
     * @param {Array} item2
     * @returns {Boolean}
     */
    static compareArrays(item1, item2) {
        if (item1.length !== item2.length) {
            return false
        }

        for (const [i, v] of item1.entries()) {
            if (!Compare.isEqual(v, item2[i])) {
                return false
            }
        }

        return true
    }

    /**
     * @param {Date} item1
     * @param {Date} item2
     * @returns {Boolean}
     */
    static compareDates(item1, item2) {
        return item1.valueOf() === item2.valueOf()
    }

    /**
     * @param {Function} item1
     * @param {Function} item2
     * @returns {Boolean}
     */
    static compareFunctions(item1, item2) {
        if (item1.name !== item2.name) {
            return false
        }

        return item1.toString() === item2.toString()
    }

    /**
     * @param {Map} item1
     * @param {Map} item2
     * @returns {Boolean}
     */
    static compareMaps(item1, item2) {
        if (item1.size !== item2.size) {
            return false
        }

        let val2;

        for (const [key, val] of item1) {
            val2 = item2.get(key);

            if (val2 !== val || val2 === undefined && !item2.has(key)) {
                return false
            }
        }

        return true
    }

    /**
     * @param {Neo.core.Base} item1
     * @param {Neo.core.Base} item2
     * @returns {Boolean}
     */
    static compareNeoInstances(item1, item2) {
        return item1.id === item2.id
    }

    /**
     * @param {Object} item1
     * @param {Object} item2
     * @returns {Boolean}
     */
    static compareObjects(item1, item2) {
        if (Object.keys(item1).length !== Object.keys(item2).length) {
            return false
        }

        for (let key in item1) {
            if (!Compare.isEqual(item1[key], item2[key])) {
                return false
            }
        }

        return true
    }

    /**
     * @param {RegExp} item1
     * @param {RegExp} item2
     * @returns {Boolean}
     */
    static compareRegExps(item1, item2) {
        return item1.toString() === item2.toString()
    }

    /**
     * @param {Set} item1
     * @param {Set} item2
     * @returns {Boolean}
     */
    static compareSets(item1, item2) {
        if (item1.size !== item2.size) {
            return false
        }

        for (let key of item1) {
            if (!item2.has(key)) {
                return false
            }
        }

        return true
    }

    /**
     * @param {*} item1
     * @param {*} item2
     * @returns {Boolean}
     */
    static isEqual(item1, item2) {
        if (item1 === item2) {
            return true
        }

        let type1 = Neo.typeOf(item1),
            type2 = Neo.typeOf(item2);

        if (type1 !== type2) {
            return false
        }

        if (Compare.map[type1]) {
            return Compare[Compare.map[type1]](item1, item2)
        }

        // all other types
        return item1 === item2
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Compare, 'Neo.core.Compare', () => {
    // alias
    Neo.isEqual = Compare.isEqual
}));


/***/ },

/***/ "./src/core/Config.mjs"
/*!*****************************!*\
  !*** ./src/core/Config.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");



/**
 * Represents an observable container for a config property.
 * This class manages the value of a config, its subscribers, and custom behaviors
 * like merge strategies and equality checks defined via a descriptor object.
 *
 * The primary purpose of this class is to enable fine-grained reactivity and
 * decoupled cross-instance state sharing within the Neo.mjs framework.
 * @class Neo.core.Config
 * @private
 * @internal
 */
class Config {
    /**
     * Stores all subscriptions for this Config instance.
     * The data structure is a Map where:
     * - The key is the ID of the subscription owner (e.g., a component's `id`).
     * - The value is another Map (the subscriberMap).
     *
     * The nested subscriberMap is structured as:
     * - The key is the callback function (`fn`).
     * - The value is a Set of scopes (`scopeSet`).
     *
     * This nested structure `Map<string, Map<function, Set<scope>>>` is intentionally chosen
     * to robustly handle the edge case where the same function is subscribed multiple times
     * with different scopes, all under the same owner ID. It ensures that each
     * `fn`-`scope` combination is unique and that cleanup is precise.
     * @member {Object} #subscribers={}
     * @private
     */
    #subscribers = {}
    /**
     * The internal value of the config property.
     * @member {*} #value
     * @private
     */
    #value
    /**
     * The cloning strategy to use when setting a new value.
     * Supported values: 'deep', 'shallow', 'none'.
     * @member {String} clone='deep'
     */

    /**
     * The cloning strategy to use when getting a value.
     * Supported values: 'deep', 'shallow', 'none'.
     * @member {String} cloneOnGet=null
     */

    /**
     * The function used to compare new and old values for equality.
     * Defaults to `Neo.isEqual`. Can be overridden via a descriptor.
     * @member {Function} isEqual=Neo.isEqual
     */

    /**
     * The strategy to use when merging new values into this config.
     * Defaults to 'replace'. Can be overridden via a descriptor merge property.
     * @member {Function|String} mergeStrategy='replace'
     */

    /**
     * Creates an instance of Config.
     * @param {any|Object} configObject - The initial value for the config.
     */
    constructor(configObject) {
        if (Neo.isObject(configObject) && configObject[_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_1__.isDescriptor] === true) {
            this.initDescriptor(configObject)
        } else {
            this.#value = configObject
        }
    }

    /**
     * Gets the current value of the config property.
     * @returns {any} The current value.
     */
    get() {
        // Registers this Config instance as a dependency with the currently active Effect,
        // enabling automatic re-execution when this Config's value changes.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].addDependency(this);
        return this.#value
    }

    /**
     * Initializes the `Config` instance using a descriptor object.
     * Extracts `clone`, `mergeStrategy` and `isEqual` from the descriptor.
     * The internal `#value` is NOT set by this method.
     * @param {Object}    descriptor                      - The descriptor object for the config.
     * @param {string}   [descriptor.clone='deep']        - The clone strategy for set.
     * @param {string}   [descriptor.cloneOnGet]          - The clone strategy for get. Defaults to 'shallow' if clone is 'deep' or 'shallow', and 'none' if clone is 'none'.
     * @param {Function} [descriptor.isEqual=Neo.isEqual] - The equality comparison function.
     * @param {string}   [descriptor.merge='deep']        - The merge strategy.
     * @param {any}       descriptor.value                - The default value for the config (not set by this method).
     */
    initDescriptor({clone, cloneOnGet, isEqual, merge}) {
        let me = this;

        if (clone && clone !== me.clone) {
            Object.defineProperty(me, 'clone', {
                configurable: true, enumerable: true, value: clone, writable: true
            })
        }

        if (cloneOnGet && cloneOnGet !== me.cloneOnGet) {
            Object.defineProperty(me, 'cloneOnGet', {
                configurable: true, enumerable: true, value: cloneOnGet, writable: true
            })
        }

        if (isEqual && isEqual !== me.isEqual) {
            Object.defineProperty(me, 'isEqual', {
                configurable: true, enumerable: true, value: isEqual, writable: true
            })
        }

        if (merge && merge !== me.mergeStrategy) {
            Object.defineProperty(me, 'mergeStrategy', {
                configurable: true, enumerable: true, value: merge, writable: true
            })
        }
    }

    /**
     * Notifies all subscribed callbacks about a change in the config's value.
     * It iterates through the nested subscriber structure to ensure each callback
     * is executed with its intended scope.
     * @param {any} newValue - The new value of the config.
     * @param {any} oldValue - The old value of the config.
     */
    notify(newValue, oldValue) {
        for (const id in this.#subscribers) {
            if (this.#subscribers.hasOwnProperty(id)) {
                const subscriberMap = this.#subscribers[id];
                for (const [fn, scopeSet] of subscriberMap) {
                    for (const scope of scopeSet) {
                        fn.call(scope || null, newValue, oldValue)
                    }
                }
            }
        }
    }

    /**
     * Sets a new value for the config property.
     * This method performs an equality check using `this.isEqual` before updating the value.
     * If the value has changed, it updates `#value` and notifies all subscribers.
     * @param {any} newValue - The new value to set.
     * @returns {Boolean} True if the value changed, false otherwise.
     */
    set(newValue) {
        if (newValue === undefined) return false; // Preserve original behavior for undefined

        const
            me       = this,
            oldValue = me.#value;

        // The setter automatically uses the configured equality check
        if (!me.isEqual(newValue, oldValue)) {
            me.#value = newValue;
            me.notify(newValue, oldValue);
            return true
        }

        return false
    }

    /**
     * Sets the internal value of the config property directly, without performing
     * an equality check or notifying subscribers.
     * This method is intended for internal framework use where direct assignment
     * is necessary (e.g., during initial setup or specific internal optimizations).
     * @param {any} newValue - The new value to set directly.
     */
    setRaw(newValue) {
        this.#value = newValue
    }

    /**
     * Subscribes a callback function to changes in this config's value.
     * The callback will be invoked with `(newValue, oldValue)` whenever the config changes.
     * @param {Object}   options        - An object containing the subscription details.
     * @param {String}   options.id     - The ID of the subscription owner (e.g., a Neo.core.Base instance's id).
     * @param {Function} options.fn     - The callback function.
     * @param {Object}  [options.scope] - The scope to execute the callback in.
     * @returns {Function} A cleanup function to unsubscribe the callback.
     */
    subscribe({id, fn, scope}) {
        if (typeof id !== 'string' || id.length === 0 || typeof fn !== 'function') {
            throw new Error([
                'Config.subscribe: options must be an object with a non-empty string `id` ',
                '(the subscription owner\'s id), and a callback function `fn`.'
            ].join(''))
        }

        const me = this;

        // Get or create the top-level Map for the subscription owner.
        if (!me.#subscribers[id]) {
            me.#subscribers[id] = new Map()
        }

        const subscriberMap = me.#subscribers[id];

        // Get or create the Set of scopes for the specific callback function.
        if (!subscriberMap.has(fn)) {
            subscriberMap.set(fn, new Set())
        }

        const scopeSet = subscriberMap.get(fn);
        scopeSet.add(scope);

        // The returned cleanup function is precise. It removes only the specific
        // scope for the function, and cleans up the parent data structures
        // (the Set and the Maps) only if they become empty.
        return () => {
            const currentSubscriberMap = me.#subscribers[id];
            if (currentSubscriberMap) {
                const currentScopeSet = currentSubscriberMap.get(fn);
                if (currentScopeSet) {
                    currentScopeSet.delete(scope);
                    if (currentScopeSet.size === 0) {
                        currentSubscriberMap.delete(fn);
                        if (currentSubscriberMap.size === 0) {
                            delete me.#subscribers[id]
                        }
                    }
                }
            }
        }
    }
}

Object.defineProperties(Config.prototype, {
    clone        : {configurable: true, enumerable: false, value: 'deep',      writable: false},
    cloneOnGet   : {configurable: true, enumerable: false, value: null,        writable: false},
    isEqual      : {configurable: true, enumerable: false, value: Neo.isEqual, writable: false},
    mergeStrategy: {configurable: true, enumerable: false, value: 'replace',   writable: false}
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Config, 'Neo.core.Config'));


/***/ },

/***/ "./src/core/ConfigSymbols.mjs"
/*!************************************!*\
  !*** ./src/core/ConfigSymbols.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isDescriptor: () => (/* binding */ isDescriptor)
/* harmony export */ });
const isDescriptor = Symbol.for('Neo.Config.isDescriptor');


/***/ },

/***/ "./src/core/EffectManager.mjs"
/*!************************************!*\
  !*** ./src/core/EffectManager.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A singleton manager to track the currently running effect and control global effect execution.
 * It provides a centralized mechanism for pausing, resuming, and batching effect runs.
 * @class Neo.core.EffectManager
 * @singleton
 */
const EffectManager = {
    /**
     * A stack to keep track of the currently active effect and its predecessors.
     * @member {Neo.core.Effect[]} effectStack=[]
     * @protected
     */
    effectStack: [],
    /**
     * A flag to temporarily disable dependency tracking for the active effect.
     * This is used internally to prevent effects from depending on their own state, like `isRunning`.
     * @member {Boolean} isTrackingPaused=false
     * @protected
     */
    isTrackingPaused: false,
    /**
     * A counter to manage nested calls to pause() and resume(). Effect execution is
     * paused or batched while this counter is greater than 0.
     * @member {Number} pauseCounter=0
     * @protected
     */
    pauseCounter: 0,
    /**
     * A Set to store unique effects that are triggered while the manager is paused.
     * These effects will be run when resume() is called and the pauseCounter returns to 0.
     * @member {Set<Neo.core.Effect>} queuedEffects=new Set()
     * @protected
     */
    queuedEffects: new Set(),

    /**
     * Adds a `Neo.core.Config` instance as a dependency for the currently active effect,
     * unless dependency tracking is explicitly paused.
     * @param {Neo.core.Config} config The config instance to add as a dependency.
     */
    addDependency(config) {
        if (!this.isTrackingPaused) {
            this.getActiveEffect()?.addDependency(config)
        }
    },

    /**
     * Returns the effect currently at the top of the stack (i.e., the one currently running).
     * @returns {Neo.core.Effect|null}
     */
    getActiveEffect() {
        return this.effectStack[this.effectStack.length - 1]
    },

    /**
     * Checks if effect execution is currently paused or batched.
     * @returns {Boolean} True if the pauseCounter is greater than 0.
     */
    isPaused() {
        return this.pauseCounter > 0
    },

    /**
     * Pauses effect execution and begins batching.
     * Each call to pause() increments a counter, allowing for nested control.
     */
    pause() {
        this.pauseCounter++
    },

    /**
     * Disables dependency tracking for the currently active effect.
     * @protected
     */
    pauseTracking() {
        this.isTrackingPaused = true
    },

    /**
     * Pops the current effect from the stack.
     * @returns {Neo.core.Effect|null}
     */
    pop() {
        return this.effectStack.pop()
    },

    /**
     * Pushes an effect onto the stack.
     * @param {Neo.core.Effect} effect The effect to push.
     */
    push(effect) {
        this.effectStack.push(effect)
    },

    /**
     * Queues a unique effect to be run later.
     * @param {Neo.core.Effect} effect The effect to queue.
     * @protected
     */
    queue(effect) {
        this.queuedEffects.add(effect)
    },

    /**
     * Resumes effect execution. If the pause counter returns to zero and effects
     * have been queued, they will all be executed synchronously.
     */
    resume() {
        let me = this;

        if (me.pauseCounter > 0) {
            me.pauseCounter--;

            if (me.pauseCounter === 0 && me.queuedEffects.size > 0) {
                const effectsToRun = [...me.queuedEffects];
                me.queuedEffects.clear();
                effectsToRun.forEach(effect => effect.run())
            }
        }
    },

    /**
     * Re-enables dependency tracking for the currently active effect.
     * @protected
     */
    resumeTracking() {
        this.isTrackingPaused = false
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(EffectManager, 'Neo.core.EffectManager', () => {
    /**
     * Wraps a function in a batch operation, ensuring that all effects triggered
     * within it are run only once after the function completes.
     * @function Neo.batch
     * @param {Function} fn The function to execute.
     */
    Neo.batch = function(fn) {
        EffectManager.pause();
        try {
            fn()
        } finally {
            // The public resume() method handles running queued effects.
            EffectManager.resume()
        }
    }
}));


/***/ },

/***/ "./src/core/IdGenerator.mjs"
/*!**********************************!*\
  !*** ./src/core/IdGenerator.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Provides a singleton utility for generating unique IDs.
 * @namespace Neo.core.IdGenerator
 */
const IdGenerator = {
    /**
     * The default prefix for neo instance ids
     * @member {String} base='neo-'
     */
    base: 'neo-',
    /**
     * @member {Object} idCounter={}
     */
    idCounter: {},

    /**
     * @param name
     * @returns {String}
     */
    getId(name) {
        name = name || 'neo';

        let me      = this,
            counter = me.idCounter,
            count   = counter[name] || 0;

        counter[name] = ++count;

        return me.base + (name === 'neo' ? '' : name + '-') + count
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(IdGenerator, 'Neo.core.IdGenerator', () => {
    Neo.getId = IdGenerator.getId.bind(IdGenerator)
}));


/***/ },

/***/ "./src/core/Observable.mjs"
/*!*********************************!*\
  !*** ./src/core/Observable.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");





/**
 * A unique, non-enumerable key for the internal event map.
 * Using a Symbol prevents property name collisions on the consuming class instance,
 * providing a robust way to manage private state within a mixin.
 * @type {Symbol}
 */
const eventMapSymbol = Symbol('eventMap');

/**
 * @class Neo.core.Observable
 * @extends Neo.core.Base
 */
class Observable extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.core.Observable'
         * @protected
         */
        className: 'Neo.core.Observable',
        /**
         * @member {String} ntype='mixin-observable'
         * @protected
         */
        ntype: 'mixin-observable',
        /**
         * A declarative way to assign event listeners to an instance upon creation.
         * The framework processes this config and calls `on()` to populate the
         * internal event registry. This config should not be manipulated directly after
         * instantiation; use `on()` and `un()` instead.
         * @member {Object|null} listeners_
         * @example
         * listeners: {
         *     myEvent: 'onMyEvent',
         *     otherEvent: {
         *         fn: 'onOtherEvent',
         *         delay: 100,
         *         once: true
         *     },
         *     scope: this
         * }
         * @reactive
         */
        listeners_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__.isDescriptor]: true,
            merge         : 'deep',
            value         : {}
        }
    }

    /**
     * @member {Object} [eventMapSymbol]
     * @private
     */

    /**
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number|String} [order]
     * @returns {String|null} eventId null in case an object gets passed as the name (multiple ids)
     */
    addListener(name, opts, scope, eventId, data, order) {
        let me            = this,
            delay         = 0,
            eventIdObject = typeof eventId === 'object',
            nameObject    = typeof name    === 'object',
            once          = false,
            optsType      = typeof opts,
            listener, existing, eventConfig;

        /*
         * let us support the following format too:
         *
         * currentWorker.on('connected', () => {
         *     Base.sendRemotes(className, remote)
         * }, me, {once: true})
         */
        if (eventIdObject && optsType === 'function') {
            eventId.fn = opts;
            opts     = eventId;
            optsType = 'object';
            eventId  = null;
        }

        if (nameObject) {
            if (name.hasOwnProperty('delay')) {
                delay = name.delay;
                delete name.delay
            }

            if (name.hasOwnProperty('once')) {
                once = name.once;
                delete name.once
            }

            if (name.hasOwnProperty('order')) {
                order = name.order;
                delete name.order
            }

            if (name.hasOwnProperty('scope')) {
                scope = name.scope;
                delete name.scope
            }

            Object.entries(name).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    me.addListener(key, {delay, once, order, scope, ...value})
                } else {
                    me.addListener(key, {delay, fn: value, once, order, scope})
                }
            })
        } else if (optsType === 'object') {
            delay    = delay   || opts.delay;
            eventId  = eventId || opts.eventId;
            listener = opts.fn;
            once     = once    || opts.once;
            order    = order   || opts.order;
            scope    = scope   || opts.scope
        } else if (optsType === 'function') {
            listener = opts
        } else if (optsType === 'string') {
            listener = opts // VC hook, can get parsed after onConstructed in case the view uses the parent VC
        } else {
            throw new Error('Invalid addListener call: ' + name)
        }

        if (!nameObject) {
            // LAZY INITIALIZATION: The key to a robust mixin.
            // This ensures the private internal listener store exists on the instance.
            // `eventMapSymbol` is the *actual* registry of handler arrays, and is
            // intentionally separate from the public `listeners_` config.
            me[eventMapSymbol] ??= {};

            eventConfig = {fn: listener, id: eventId || Neo.getId('event')};

            if (data)      {eventConfig.data   = data}
            if (delay > 0) {eventConfig.delay  = delay}
            if (once)      {eventConfig.once   = once}
            if (scope)     {eventConfig.scope  = scope}

            if ((existing = me[eventMapSymbol][name])) {
                existing.forEach(cfg => {
                    if (cfg.id === eventId || (cfg.fn === listener && cfg.scope === scope)) {
                        console.error('Duplicate event handler attached:', name, me)
                    }
                });

                if (typeof order === 'number') {
                    existing.splice(order, 0, eventConfig)
                } else if (order === 'before') {
                    existing.unshift(eventConfig)
                } else {
                    existing.push(eventConfig)
                }
            } else {
                me[eventMapSymbol][name] = [eventConfig] // Use the private eventMapSymbol registry
            }

            return eventConfig.id
        }

        return null
    }

    /**
     * This hook is the bridge between the declarative `listeners_` config and the
     * imperative `on()`/`un()` methods. It's called automatically by the framework
     * whenever the `listeners` config property is changed.
     * @param {Object} value The new listeners object
     * @param {Object} oldValue The old listeners object
     * @protected
     */
    afterSetListeners(value, oldValue) {
        // Unregister any listeners from the old config object
        if (oldValue && Object.keys(oldValue).length > 0) {
            this.un(oldValue)
        }
        // Register all listeners from the new config object
        if (value && Object.keys(value).length > 0) {
            this.on(value)
        }
    }

    /**
     * Call the passed function, or a function by *name* which exists in the passed scope's
     * or this component's ownership chain.
     * @param {Function|String} fn A function, or the name of a function to find in the passed scope object.
     * @param {Object} scope       The scope to find the function in if it is specified as a string.
     * @param {Array} args         Arguments to pass to the callback.
     */
    callback(fn, scope=this, args) {
        if (fn) {
            const handler = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCallback)(fn, scope);
            handler.fn.apply(handler.scope, args)
        }
    }

    /**
     * Internal helper method for events which use the delay option
     * @param {Object} cb
     * @param {Array} args
     * @param {Number} delay
     */
    delayedCallback(cb, args, delay) {
        this.timeout(delay).then(() => {
            cb.fn.apply(cb.scope, args)
        })
    }

    /**
     * @param name
     */
    fire(name) {
        let me        = this,
            args      = [].slice.call(arguments, 1),
            listeners = me[eventMapSymbol], // Always use the private, structured registry for firing events.
            delay, handler, handlers, i, len;

        if (listeners && listeners[name]) {
            handlers = [...listeners[name]];
            len      = handlers.length;

            for (i = 0; i < len; i++) {
                handler = handlers[i];
                delay   = handler.delay;

                // Resolve function name on the scope (or me), or, if it starts with 'up.'
                // look in the ownership hierarchy from me.
                const cb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCallback)(handler.fn, handler.scope || me);

                // remove the listener if the scope no longer exists
                if (cb.scope && !cb.scope.id) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(listeners[name], handler)
                } else {
                    if (!me.suspendEvents) {
                        // Object event format. Inject firer reference in as 'source'
                        if (args.length === 1 && Neo.isObject(args[0])) {
                            args[0].source = me.id
                        }

                        // remove the listener if it has the once flag
                        handler.once && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(listeners[name], handler);

                        if (Neo.isNumber(delay) && delay > 0) {
                            me.delayedCallback(cb, handler.data ? args.concat(handler.data) : args, delay)
                        } else {
                            cb.fn.apply(cb.scope, handler.data ? args.concat(handler.data) : args)
                        }
                    }
                }
            }
        }
    }

    /**
     * Alias for addListener
     * @param {Object|String} name
     * @param {Object} [opts]
     * @param {Object} [scope]
     * @param {String} [eventId]
     * @param {Object} [data]
     * @param {Number} [order]
     * @returns {String} eventId
     */
    on(...args) {
        return this.addListener(...args)
    }

    /**
     * There are different syntax's how you can use this method.
     * Using the eventId:
     * ```
     * this.removeListener('change', 'neo-event-7');
     * ```
     * Passing the handler method:
     * ```
     * this.removeListener('change', this.onChange, this);
     * ```
     * Passing an object:
     * ```
     * me.field.un({
     *     change                    : me.onFieldChange,
     *     changeClearToOriginalValue: me.onFieldChange,
     *     scope                     : me
     * });
     * ```
     * @param {Object|String} name
     * @param {Function|String} [eventId]
     * @param {Neo.core.Base} [scope]
     */
    removeListener(name, eventId, scope) {
        let me = this,
            i, len, listener, listeners, match;

        // LAZY INITIALIZATION: Ensure the internal listener store exists.
        me[eventMapSymbol] ??= {};

        if (Neo.isFunction(eventId)) {
            me.removeListener({[name]: eventId, scope});
            return
        }

        if (Neo.isObject(name)) {
            if (name.scope) {
                scope = name.scope;
                delete name.scope;
            }

            Object.entries(name).forEach(([key, value]) => {
                listeners = me[eventMapSymbol][key] || [];
                i         = 0;
                len       = listeners.length;

                for (; i < len; i++) {
                    listener = listeners[i];

                    if (
                        listener.fn.name === (Neo.isString(value) ? value : value.name) &&
                        listener.scope   === scope
                    ) {
                        listeners.splice(i, 1);
                        break
                    }
                }
            })
        } else if (Neo.isString(eventId)) {
            listeners = me[eventMapSymbol][name];
            match     = false;

            listeners.forEach((eventConfig, idx) => {
                if (eventConfig.id === eventId) {
                    return match = idx
                }
            });

            if (match !== false) {
                listeners.splice(match, 1)
            }
        }
    }

    /**
     * Alias for removeListener
     * @param {Object|String} name
     * @param {String} [eventId]
     */
    un(...args) {
        this.removeListener(...args);
    }

    /**
     * Serializes the observable state into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me        = this,
            listeners = {},
            eventMap  = me[eventMapSymbol];

        if (eventMap) {
            Object.entries(eventMap).forEach(([eventName, handlers]) => {
                if (handlers.length > 0) {
                    listeners[eventName] = handlers.map(handler => me.serializeConfig(handler))
                }
            })
        }

        return {
            ...super.toJSON(),
            listeners
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Observable));


/***/ },

/***/ "./src/core/Util.mjs"
/*!***************************!*\
  !*** ./src/core/Util.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @class Neo.core.Util
 */
class Util {
    /**
     * A regex to remove camel case syntax
     * @member {RegExp} decamelRegEx=/([a-z])([A-Z])/g
     * @protected
     * @static
     */
    static decamelRegEx = /([a-z])([A-Z])/g

    /**
     * @param {Object} scope
     * @param {String[]} values
     */
    static bindMethods(scope, values) {
        values.forEach(value => {
            scope[value] = scope[value].bind(scope)
        })
    }

    /**
     * Transforms a styles string into a styles object using camelcase syntax
     * @param {String} string The styles string to parse
     * @returns {Object} The camelcase styles object
     */
    static createStyleObject(string) {
        let parts;

        // split(';') does fetch semicolons inside brackets
        // -> background-image: "url('data:image/png;base64,...

        // TODO: Cache all regex
        return string.split(/;(?=[^\)]*(?:\(|$))/g).reduce((obj, el) => {
            // we have to split by the first colon only
            // -> background-image: url('http://example.com/image.png')
            parts = el.split((/:(.+)/)).map(function (x) {
                let num = parseFloat(x);

                return x == num ? num : x.trim()
            });

            if (parts[0] !== '') {
                parts[0] = parts[0].replace(/-([a-z])/g, (str, letter) => {
                    return letter.toUpperCase()
                });

                obj[parts[0]] = parts[1]
            }
            return obj
        }, {})
    }

    /**
     * Converts a styles object which can use camelcase syntax into a styles string
     * @param {Object} styles The styles object
     * @returns {String} The styles string (DOM ready)
     */
    static createStyles(styles) {
        let style = '';

        Object.entries(styles).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
                style += Util.decamel(key) + ':' + value + ';'
            }
        });

        return style
    }

    /**
     * Transforms all uppercase characters of a string into -lowercase.
     * Does not touch special characters.
     * @param {String} value The input containing uppercase characters
     * @returns {String} The lowercase output
     */
    static decamel(value) {
        return value.replace(Util.decamelRegEx, '$1-$2').toLowerCase()
    }

    /**
     * Returns true if the passed value is an array
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isArray(value) {
        return Array.isArray(value)
    }

    /**
     * Returns true if the passed value is a boolean
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isBoolean(value) {
        return typeof value === 'boolean'
    }

    /**
     * Returns true if the passed value is not undefined
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isDefined(value) {
        return typeof value !== 'undefined'
    }

    /**
     * Returns true if the passed value is an empty Array, Object or String
     * @param {Array|Object|String} value The value to test
     * @returns {Boolean}
     */
    static isEmpty(value) {
        if (value === null || value === undefined) {
            return true
        }

        if (Array.isArray(value)) {
            return value.length === 0
        }

        if (value instanceof Date) {
            return false
        }

        if (Util.isObject(value)) {
            return Object.keys(value).length === 0
        }

        if (Util.isString(value)) {
            return value === ''
        }

        return false
    }

    /**
     * Returns true if the passed value is a function
     * @param {Function} value The value to test
     * @returns {Boolean}
     */
    static isFunction(value) {
        return typeof value === 'function'
    }

    /**
     * Returns true if the passed value is a number. Returns false for non-finite numbers
     * @param {Number} value The value to test
     * @returns {Boolean}
     */
    static isNumber(value){
        return typeof value === 'number' && isFinite(value)
    }

    /**
     * Returns true if the passed value is an object
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isObject(value) {
        return value?.constructor?.name === 'Object'
    }

    /**
     * Returns true if the passed value is a promise.
     * We are intentionally not checking for `value instanceof Promise`,
     * to support any "thenable" objects for flexibility.
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isPromise(value) {
        return typeof value?.then === 'function'
    }

    /**
     * Returns true if the passed value is a neo data record
     * @param {Object} value The value to test
     * @returns {Boolean}
     */
    static isRecord(value) {
        return value?.constructor?.name === 'Record'
    }

    /**
     * Returns true if the passed value is a string
     * @param {String} value The value to test
     * @returns {Boolean}
     */
    static isString(value) {
        return typeof value === 'string'
    }

    /**
     * Converts a snake_case string into camelCase.
     * @param {String} value The snake_case string.
     * @returns {String} The camelCase string.
     */
    static snakeToCamel(value) {
        return value.replace(/(_\w)/g, m => m[1].toUpperCase());
    }

    /**
     * Converts any iterable (strings, numeric indices and a length property) into a true array
     * @param {Object|String} iterable
     * @param {Number} [start=0] start index
     * @param {Number} [end=iterable.length] end index
     * @returns {Array}
     */
    static toArray(iterable, start, end) {
        let len;

        if (!iterable || !(len = iterable.length)) {
            return []
        }

        if (typeof iterable === 'string') {
            return iterable.split('')
        }

        return Array.prototype.slice.call(iterable, start || 0, end || len)
    }
}

const ns = Neo.ns('Neo.core', true);
ns.Util = Util;

// aliases
Neo.applyFromNs(Neo, Util, {
    bindMethods      : 'bindMethods',
    createStyleObject: 'createStyleObject',
    createStyles     : 'createStyles',
    decamel          : 'decamel',
    isArray          : 'isArray',
    isBoolean        : 'isBoolean',
    isDefined        : 'isDefined',
    isEmpty          : 'isEmpty',
    isFunction       : 'isFunction',
    isNumber         : 'isNumber',
    isObject         : 'isObject',
    isPromise        : 'isPromise',
    isRecord         : 'isRecord',
    isString         : 'isString',
    snakeToCamel     : 'snakeToCamel',
    toArray          : 'toArray'
}, true);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Util);


/***/ },

/***/ "./src/core/_export.mjs"
/*!******************************!*\
  !*** ./src/core/_export.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* reexport safe */ _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Compare: () => (/* reexport safe */ _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   IdGenerator: () => (/* reexport safe */ _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   Observable: () => (/* reexport safe */ _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   Util: () => (/* reexport safe */ _Util_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Compare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Compare.mjs */ "./src/core/Compare.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");
/* harmony import */ var _Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _Util_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Util.mjs */ "./src/core/Util.mjs");









/***/ },

/***/ "./src/main/DeltaUpdates.mjs"
/*!***********************************!*\
  !*** ./src/main/DeltaUpdates.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DomAccess.mjs */ "./src/main/DomAccess.mjs");
/* harmony import */ var _vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vdom/domConstants.mjs */ "./src/vdom/domConstants.mjs");




const NeoConfig = Neo.config;

/**
 * Manages and applies the Virtual DOM (VDom) delta updates generated by `Neo.vdom.Helper` to the real browser DOM.
 * This class acts as the bridge between the VDom worker's calculated changes and the actual rendering on the main thread.
 * It orchestrates various DOM manipulation operations such as node insertions, removals, moves, attribute updates,
 * and handles dynamic renderer switching based on `Neo.config.useDomApiRenderer`.
 *
 * As a singleton per browser window, it provides a centralized and efficient mechanism for synchronized DOM updates,
 * ensuring the UI accurately reflects the application state.
 * @class Neo.main.DeltaUpdates
 * @extends Neo.core.Base
 * @singleton
 */
class DeltaUpdates extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.DeltaUpdates'
         * @protected
         */
        className: 'Neo.main.DeltaUpdates',
        /**
         * @member {Number} countDeltas=0
         * @protected
         */
        countDeltas: 0,
        /**
         * @member {Number} countDeltasPer250ms=0
         * @protected
         */
        countDeltasPer250ms: 0,
        /**
         * @member {Number} countUpdates=0
         * @protected
         */
        countUpdates: 0,
        /**
         * @member {Boolean} renderCountDeltas_=false
         * @protected
         * @reactive
         */
        renderCountDeltas_: false,
        /**
         * @member {Boolean} singleton=true
         */
        singleton: true
    }

    /**
     * @member {Number} logDeltasIntervalId=0
     * @protected
     */
    logDeltasIntervalId = 0

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let {environment} = NeoConfig;

        if (NeoConfig.renderCountDeltas) {
            this.renderCountDeltas = true
        }

        // We need different publicPath values for the main thread inside the webpack based dist envs,
        // depending on the hierarchy level of the app entry point
        if (environment === 'dist/development' || environment === 'dist/production') {
            __webpack_require__.p = NeoConfig.basePath.substring(6)
        }
    }

    /**
     * Triggered after the renderCountDeltas config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRenderCountDeltas(value, oldValue) {
        let me                    = this,
            {logDeltasIntervalId} = me,
            node;

        if (value) {
            if (logDeltasIntervalId === 0) {
                me.logDeltasIntervalId = setInterval(() => {
                    node = document.getElementById('neo-delta-updates');

                    if (node) {
                        node.innerHTML = String(me.countDeltasPer250ms * 4)
                    }

                    me.countDeltasPer250ms = 0
                }, 250)
            }
        } else {
            logDeltasIntervalId && clearInterval(logDeltasIntervalId);
            me.logDeltasInterval = 0
        }
    }

    /**
     * Changes the tag name (nodeName) of an existing HTMLElement in the DOM.
     * This operation is performed by creating a new HTML element with the desired `nodeName`,
     * meticulously copying all attributes and the `innerHTML` from the original `node` to the new one,
     * and then seamlessly replacing the original `node` with the newly created element within its parent.
     *
     * @param {HTMLElement} node     The existing DOM HTMLElement whose tag name needs to be changed.
     * @param {String}      nodeName The new tag name (e.g., 'div', 'span', 'p') for the element.
     */
    changeNodeName(node, nodeName) {
        let {attributes} = node,
            clone        = document.createElement(nodeName),
            i            = 0,
            len          = attributes.length,
            attribute;

        if (node) {
            for (; i < len; i++) {
                attribute = attributes.item(i);
                clone.setAttribute(attribute.nodeName, attribute.nodeValue)
            }

            clone.innerHTML= node.innerHTML;

            node.parentNode.replaceChild(clone, node)
        }
    }

    /**
     *
     */
    checkRendererAvailability() {
        const {render} = Neo.main;

        if (NeoConfig.useDomApiRenderer) {
            if (!render?.DomApiRenderer) {
                throw new Error('Neo.main.DeltaUpdates: DomApiRenderer is not loaded yet!')
            }
        } else {
            if (!render?.StringBasedRenderer) {
                throw new Error('Neo.main.DeltaUpdates: StringBasedRenderer is not loaded yet!')
            }
        }
    }

    /**
     * @param {Object} delta
     * @param {String} delta.id
     */
    focusNode({id}) {
        _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(id)?.focus()
    }

    /**
     * Imports either (if not already imported):
     * `Neo.main.render.DomApiRenderer`      if Neo.config.useDomApiRenderer === true
     * `Neo.main.render.StringBasedRenderer` if Neo.config.useDomApiRenderer === false
     * @returns {Promise<void>}
     * @protected
     */
    async importRenderer() {
        const {render} = Neo.main;

        if (NeoConfig.useDomApiRenderer) {
            if (!render?.DomApiRenderer) {
                await __webpack_require__.e(/*! import() */ "src_main_render_DomApiRenderer_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./render/DomApiRenderer.mjs */ "./src/main/render/DomApiRenderer.mjs"))
            }
        } else {
            if (!render?.StringBasedRenderer) {
                await __webpack_require__.e(/*! import() */ "src_main_render_StringBasedRenderer_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./render/StringBasedRenderer.mjs */ "./src/main/render/StringBasedRenderer.mjs"))
            }
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        super.initAsync();

        let me = this;

        // Subscribe to global Neo.config changes for dynamic renderer switching.
        Neo.worker.Manager.on({
            neoConfigChange: me.onNeoConfigChange,
            scope          : me
        });

        await me.importRenderer()
    }

    /**
     * Inserts a new node into the DOM tree based on delta updates.
     * This method handles both string-based (outerHTML) and direct DOM API (vnode) mounting.
     * It ensures the node is inserted at the correct index within the parent.
     * This method is synchronous and *expects* the appropriate renderer (DomApiRenderer or StringBasedRenderer) to be already loaded.
     *
     * @param {Object}         delta
     * @param {Boolean}        delta.hasLeadingTextChildren Flag to honor leading comments, which require special treatment.
     * @param {Number}         delta.index                  The index at which to insert the new node within its parent.
     * @param {String}         [delta.outerHTML]            The string representation of the new node (for string-based mounting).
     * @param {String}         delta.parentId               The ID of the parent DOM node.
     * @param {Object[]}       [delta.postMountUpdates]     Array of post-mount updates (e.g. scroll state).
     * @param {Neo.vdom.VNode} [delta.vnode]                The VNode representation of the new node (for direct DOM API mounting).
     */
    insertNode({hasLeadingTextChildren, index, outerHTML, parentId, postMountUpdates, vnode}) {
        this.checkRendererAvailability();

        let {render}   = Neo.main,
            parentNode = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElementOrBody(parentId);

        if (parentNode) {
            if (NeoConfig.useDomApiRenderer) {
                render.DomApiRenderer.createDomTree({index, isRoot: true, parentNode, vnode})
            } else {
                render.StringBasedRenderer.insertNodeAsString({hasLeadingTextChildren, index, outerHTML, parentNode, postMountUpdates})
            }
        }
    }

    /**
     * Moves an existing DOM node to a new position within its parent or to a new parent.
     * This method directly manipulates the DOM using the pre-calculated physical index,
     * accounting for potential text nodes wrapped in comments.
     * It performs a direct sibling swap when an element is immediately followed by its target position,
     * which is necessary to prevent attempting to replace a node with itself.
     *
     * @param {Object} delta
     * @param {String} delta.id       The ID of the DOM node to move.
     * @param {Number} delta.index    The physical index at which to insert the node within the target parent's childNodes.
     * @param {String} delta.parentId The ID of the target parent DOM node.
     */
    moveNode({id, index, parentId}) {
        let node       = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(id),
            parentNode = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(parentId);

        if (node && parentNode) {
            // If the target index is at or beyond the end of the parent's current childNodes, append the node.
            if (index >= parentNode.childNodes.length) {
                parentNode.appendChild(node)
            } else {
                // Get the reference node at the target physical index.
                let referenceNode = parentNode.childNodes[index];

                // Only proceed if the node is not already at its target position.
                if (node !== referenceNode) {
                    // Perform a direct swap operation if immediate element siblings.
                    if (node.nodeType === 1 && node === referenceNode.nextElementSibling) {
                        node.replaceWith(referenceNode)
                    }

                    parentNode.insertBefore(node, referenceNode)
                }
            }
        }
    }

    /**
     * Handler for global Neo.config changes.
     * If the `Neo.config.useDomApiRenderer` value changes, this method dynamically loads the renderer.
     * @param {Object} config
     * @return {Promise<void>}
     */
    async onNeoConfigChange(config) {
        if (Object.hasOwn(config, 'useDomApiRenderer')) {
            await this.importRenderer()
        }
    }

    /**
     * Clears all child nodes of a given parent DOM node.
     * This is achieved by setting its `innerHTML` property to an empty string,
     * which is generally considered the fastest and most efficient way to remove
     * all children from a DOM element in modern browsers.
     *
     * @param {Object} delta
     * @param {String} delta.parentId The ID of the parent DOM node whose children will be removed.
     */
    removeAll({parentId}) {
        let node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(parentId);

        if (node) {
            node.innerHTML = ''
        }
    }

    /**
     * Removes a DOM node from its parent.
     * This method handles both standard HTML elements and virtual text nodes,
     * which are typically wrapped within comment nodes in the DOM.
     *
     * @param {Object} delta
     * @param {String} delta.id       The ID of the DOM node to remove.
     * @param {String} delta.parentId The ID of the parent DOM node (required for text node removal).
     */
    removeNode({id, parentId}) {
        const node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(id);

        if (node) {
            node.remove();
        }
        // Potentially a vtype: 'text' node (wrapped between 2 comments)
        else if (parentId) {
            const
                parentNode = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElementOrBody(parentId),
                isComment  = Node.COMMENT_NODE;

            if (parentNode) {
                // Find the starting comment node using its id marker
                const startComment = Array.from(parentNode.childNodes).find(n =>
                    n.nodeType === isComment && n.nodeValue.includes(` ${id} `)
                );

                if (startComment) {
                    const
                        textNode = startComment.nextSibling,
                        // Ensure endComment is a comment node before attempting to remove
                        endComment = textNode?.nextSibling?.nodeType === isComment ? textNode.nextSibling : null;

                    // Remove the three parts: start comment, text node, end comment
                    startComment.remove();
                    textNode?.remove();
                    endComment?.remove()
                }
            }
        }
    }

    /**
     * Replaces an existing child DOM node (`fromId`) with a new DOM node (`toId`)
     * within a specified parent DOM node (`parentId`).
     * This operation directly invokes the native `Node.replaceChild()` API,
     * performing an atomic swap of the elements in the DOM tree.
     * It is typically used when a specific DOM element needs to be completely
     * exchanged for a different one at the same position.
     *
     * @param {Object} delta
     * @param {String} delta.fromId   The ID of the existing child DOM node to be replaced.
     * @param {String} delta.parentId The ID of the parent DOM node containing the child to be replaced.
     * @param {String} delta.toId     The ID of the new DOM node that will replace the old one.
     */
    replaceChild({fromId, parentId, toId}) {
        let node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(parentId);

        node?.replaceChild(_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(toId), _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(fromId))
    }

    /**
     * Updates various properties of an existing DOM node based on the provided delta.
     * This includes updating attributes, class names, inner HTML, node name, and inline styles.
     * It handles specific cases for attribute types (e.g., boolean attributes, 'value')
     * and style properties (e.g., '!important').
     *
     * @param {Object} delta
     * @param {String} delta.id            The ID of the DOM node to update.
     * @param {Object} [delta.attributes]  An object containing attribute key-value pairs to update or remove (if value is null/empty).
     * @param {Object} [delta.cls]         An object containing 'add' and/or 'remove' arrays for CSS classes.
     * @param {String} [delta.innerHTML]   The new inner HTML content for the node.
     * @param {String} [delta.nodeName]    The new tag name for the node (will trigger a node replacement).
     * @param {String} [delta.outerHTML]   The new outer HTML content for the node (will trigger a node replacement).
     * @param {Object} [delta.style]       An object containing CSS style properties to update. Values can include '!important'.
     * @param {String} [delta.textContent] The new text content for the node (replaces innerHTML if present).
     */
    updateNode(delta) {
        let me   = this,
            node = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElementOrBody(delta.id);

        if (node) {
            Object.entries(delta).forEach(([prop, value]) => {
                switch (prop) {
                    case 'attributes':
                        Object.entries(value).forEach(([key, val]) => {
                            if (_vdom_domConstants_mjs__WEBPACK_IMPORTED_MODULE_2__.voidAttributes.has(key)) {
                                node[key] = val === 'true' // vnode attribute values get converted into strings
                            } else if (val === null || val === '') {
                                if (key === 'value') {
                                    node[key] = '' // input fields => pseudo attribute can not be removed
                                } else {
                                    node.removeAttribute(key)
                                }
                            } else if (key === 'id') {
                                node[NeoConfig.useDomIds ? 'id' : 'data-neo-id'] = val
                            } else if (key === 'spellcheck' && val === 'false') {
                                // see https://github.com/neomjs/neo/issues/1922
                                node[key] = false
                            } else {
                                if (key === 'value') {
                                    node[key] = val
                                } else {
                                    node.setAttribute(key, val)
                                }
                            }
                        });
                        break
                    case 'cls':
                        value.add    && node.classList.add(...value.add);
                        value.remove && node.classList.remove(...value.remove);
                        break
                    case 'innerHTML':
                        node.innerHTML = value || '';
                        break
                    case 'nodeName':
                        me.changeNodeName(node, value);
                        break
                    case 'outerHTML':
                        node.outerHTML = value || '';
                        break
                    case 'scrollLeft':
                    case 'scrollTop':
                        node[prop] = value;
                        break
                    case 'style':
                        if (Neo.isObject(value)) {
                            Object.entries(value).forEach(([key, val]) => {
                                let important;

                                if (Neo.isString(val) && val.includes('!important')) {
                                    val = val.replace('!important', '').trim();
                                    important = 'important'
                                }

                                node.style.setProperty(Neo.decamel(key), val, important)
                            })
                        }
                        break
                    case 'textContent':
                        node.textContent = value;
                        break
                }
            })
        }
    }

    /**
     * Updates the text content of a virtual text node within the DOM.
     * Virtual text nodes are rendered within the DOM as a pair of HTML comments,
     * with their content embedded between them. This method locates the specific
     * text node by its ID (embedded in the start comment tag) within its parent's
     * innerHTML and replaces its content using a regular expression.
     *
     * @param {Object} delta
     * @param {String} delta.id       The unique ID of the virtual text node, which is embedded in its opening comment tag.
     * @param {String} delta.parentId The ID of the parent DOM node whose `innerHTML` contains the virtual text node.
     * @param {String} delta.value    The new text content to be applied to the virtual text node.
     */
    updateVtext({id, parentId, value}) {
        let node      = _DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getElement(parentId),
            innerHTML = node.innerHTML,
            startTag  = `<!-- ${id} -->`,
            reg       = new RegExp(startTag + '[\\s\\S]*?<!-- \/neo-vtext -->');

        node.innerHTML = innerHTML.replace(reg, value)
    }

    /**
     * Applies a set of VDom delta updates to the real DOM.
     * This method is the core entry point for rendering changes initiated from the VDom worker.
     * It iterates through the provided deltas and dispatches them to specific DOM manipulation
     * methods (e.g., insertNode, removeNode, updateNode) based on their `action` property.
     * This method expects the appropriate renderer (DomApiRenderer or StringBasedRenderer)
     * to be loaded based on `Neo.config.useDomApiRenderer`.
     *
     * @param {Object} data
     * @param {Object|Object[]} data.deltas An array of delta objects, or a single delta object,
     * representing changes to be applied to the DOM.
     * Each delta object contains an `action` property
     * (e.g., 'insertNode', 'removeNode', 'updateNode', 'moveNode')
     * and additional properties relevant to the specific action.
     * @param {String} data.id             The unique ID of the request, used for sending a reply back to the origin.
     * @param {String} [data.origin='app'] The origin of the message (e.g., 'app'), used for sending replies.
     */
    update(data) {
        this.checkRendererAvailability();

        let me       = this,
            {deltas} = data,
            i        = 0,
            len;

        deltas = Array.isArray(deltas) ? deltas : [deltas];
        len    = deltas.length;

        if (NeoConfig.logDeltaUpdates && len > 0) {
            me.countDeltas += len;
            me.countUpdates++;
            console.log('update ' + me.countUpdates, 'total deltas ', me.countDeltas, Neo.clone(data, true))
        }

        if (NeoConfig.renderCountDeltas && len > 0) {
            me.countDeltasPer250ms += len
        }

        for (; i < len; i++) {
            me[deltas[i].action || 'updateNode'](deltas[i])
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DeltaUpdates));


/***/ },

/***/ "./src/main/DomAccess.mjs"
/*!********************************!*\
  !*** ./src/main/DomAccess.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DomUtils.mjs */ "./src/main/DomUtils.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/String.mjs */ "./src/util/String.mjs");





const
    doPreventDefault = e => e.preventDefault(),
    filterTabbable   = e => !e.classList.contains('neo-focus-trap') && _DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isTabbable(e) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP,
    lengthRE         = /^\d+\w+$/,

    capturePassive = {
        capture: true,
        passive: true
    },

    fontSizeProps = [
        'font-family',
        'font-kerning',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-weight',
        'letter-spacing',
        'line-height',
        'text-decoration',
        'text-transform',
        'word-break'
    ],

    modifierKeys = {
        Shift   : 1,
        Alt     : 1,
        Meta    : 1,
        Control : 1
    };

/**
 * @class Neo.main.DomAccess
 * @extends Neo.core.Base
 * @singleton
 */
class DomAccess extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.main.DomAccess'
         * @protected
         */
        className: 'Neo.main.DomAccess',
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'addScript',
                'align',
                'applyBodyCls',
                'blur',
                'execCommand',
                'focus',
                'getAttributes',
                'getBoundingClientRect',
                'getComputedStyle',
                'getOffscreenCanvas',
                'getScrollingDimensions',
                'measure',
                'monitorAutoGrow',
                'monitorAutoGrowHandler',
                'scrollBy',
                'scrollIntoView',
                'scrollTo',
                'scrollToTableRow',
                'selectNode',
                'setBodyCls',
                'setStyle',
                'syncModalMask',
                'trapFocus',
                'windowScrollTo'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @returns {HTMLElement}
     */
    get modalMask() {
        let me = this;

        if (!me._modalMask) {
            me._modalMask = document.createElement('div');
            me._modalMask.className = 'neo-dialog-modal-mask';
            me._modalMask.addEventListener('mousedown', doPreventDefault, {capture : true})
        }

        return me._modalMask
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.initGlobalListeners();

        // Set up our aligning callback which is called when things change which may
        // mean that alignments need to be updated.
        me.syncAligns = me.syncAligns.bind(me)
    }

    /**
     * @param {Object} alignSpec
     */
    addAligned(alignSpec) {
        const
            me                   = this,
            {id}                 = alignSpec,
            aligns               = me._aligns || (me._aligns = new Map()),
            resizeObserver       = me._alignResizeObserver || (me._alignResizeObserver = new ResizeObserver(me.syncAligns)),
            {constrainToElement} = alignSpec;

        // Set up listeners which monitor for changes
        if (!aligns.has(id)) {
            // Realign when target's layout-controlling element changes size
            resizeObserver.observe(alignSpec.offsetParent);

            // Realign when align to target changes size
            resizeObserver.observe(alignSpec.targetElement);

            // Realign when constraining element changes size
            if (constrainToElement) {
                resizeObserver.observe(constrainToElement)
            }
        }

        if (!me.hasDocumentScrollListener) {
            document.addEventListener('scroll', me.syncAligns, {
                capture: true,
                passive: true
            });

            me.hasDocumentScrollListener = true
        }

        if (!me.documentMutationObserver) {
            me.documentMutationObserver = new MutationObserver(me.onDocumentMutation.bind(me));

            me.documentMutationObserver.observe(document.body, {
                childList: true,
                subtree  : true
            })
        }

        aligns.set(id, alignSpec)
    }

    /**
     * @param {Object} data
     * @param {Boolean} data.async
     * @param {Boolean} [data.defer=false]
     * @param {String} [data.src=true]
     */
    addScript(data) {
        let script = document.createElement('script');

        if (!data.hasOwnProperty('async')) {
            data.async = true
        }

        Object.assign(script, data);

        document.head.appendChild(script)
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async align(data) {
        const
            me            = this,
            {constrainTo} = data,
            subject       = data.subject = me.getElement(data.id),
            {style}       = subject,
            align         = {...data},
            lastAlign     = me._aligns?.get(data.id);

        if (lastAlign) {
            subject.classList.remove(`neo-aligned-${lastAlign.result.position}`)
        }

        // Release any constrainTo or matchSize sizing which may have been imposed
        // by a previous align call.
        me.resetDimensions(align);

        // The Rectangle's align spec target and constrainTo must be Rectangles
        align.target = me.getClippedRect({id : data.targetElement = me.getElementOrBody(data.target)});

        if (!align.target) {
            // Set the Component with id data.id to hidden : true
            return Neo.worker.App.setConfigs({id: data.id, hidden: true})
        }

        data.offsetParent = data.targetElement.offsetParent;

        if (constrainTo) {
            align.constrainTo = me.getBoundingClientRect({id : data.constrainToElement = me.getElementOrBody(constrainTo)})
        }

        // Get an aligned clone of myRect aligned according to the align object
        const
            myRect = me.getBoundingClientRect(data),
            result = data.result = myRect.alignTo(align);

        Object.assign(style, {
            top       : 0,
            left      : 0,
            transform : `translate(${result.x}px,${result.y}px)`
        });

        if (result.width !== myRect.width) {
            style.width = `${result.width}px`
        }

        if (result.height !== myRect.height) {
            style.height = `${result.height}px`
        }

        // Place box shadow at correct edge
        subject.classList.add(`neo-aligned-${result.position}`);

        // Register an alignment to be kept in sync
        me.addAligned(data)
    }

    /**
     * @param {Object} data
     * @param {String[]} data.cls
     */
    applyBodyCls(data) {
        let cls = data.cls || [];
        document.body.classList.add(...cls)
    }

    /**
     * Calls blur() on a node for a given dom node id
     * @param {Object} data
     * @returns {Object} obj.id => the passed id
     */
    blur(data) {
        this.getElement(data.id)?.blur();
        return {id: data.id}
    }

    /**
     * @param {Object} data
     * @param {String} data.command
     * @returns {Object} data
     */
    execCommand(data) {
        document.execCommand(data.command);
        return data
    }

    /**
     * Calls focus() on a node for a given dom node id
     * @param {Object} data
     * @param {Boolean} data.children
     * @param {String} data.id
     * @returns {Object} obj.id => the passed id
     */
    focus({children, id}) {
        let node = this.getElement(id);

        if (node) {
            // The children property means focus inner elements if possible.
            if (!_DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFocusable(node) && children) {
                // query for the first focusable descendent
                node = _DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].query(node, _DomUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFocusable)
            }

            if (node) {
                node.focus();

                if (Neo.isNumber(node.selectionStart)) {
                    node.selectionStart = node.selectionEnd = node.value.length
                }
            }
        }

        return {id}
    }

    /**
     * Returns the attributes for a given dom node id
     * @param {Object}          data
     * @param {String|String[]} data.attributes either an attribute or an array of attributes
     * @param {String|String[]} data.id either an id or an array of ids
     * @returns {Array|Object} In case id is an array, an array of attribute objects is returned, otherwise an object
     */
    getAttributes({attributes, id}) {
        let returnData;

        if (Array.isArray(id)) {
            returnData = [];

            id.forEach(id => {
                returnData.push(this.getAttributes({attributes, id}))
            })
        } else {
            let node = this.getElementOrBody(id);

            returnData = {};

            if (node) {
                if (!Array.isArray(attributes)) {
                    attributes = [attributes]
                }

                attributes.forEach(attribute => {
                    returnData[attribute] = node[attribute]
                })
            }
        }

        return returnData
    }

    /**
     * Returns node.getBoundingClientRect() for a given dom node id
     * @param {Object} data
     * @param {Array|String} data.id either an id or an array of ids
     * @returns {DOMRect|DOMRect[]} In case id is an array, an array of DomRects is returned, otherwise an DomRect object
     */
    getBoundingClientRect(data) {
        let me = this,
            returnData;

        if (Array.isArray(data.id)) {
            return data.id.map(id => me.getBoundingClientRect({id}))
        } else {
            let node = me.getElementOrBody(data.nodeType ? data : data.id),
                rect = {},
                minWidth, minHeight, style;

            returnData = {};

            if (node) {
                rect      = node.getBoundingClientRect();
                style     = node.ownerDocument.defaultView.getComputedStyle(node);
                minWidth  = style.getPropertyValue('min-width');
                minHeight = style.getPropertyValue('min-height');

                // DomRect does not support spreading => {...DomRect} => {}
                returnData = _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].clone(rect);

                // Measure minWidth/minHeight in other units like em/rem etc
                // Note that 0px is what the DOM reports if no minWidth is specified
                // so we do not report a minimum in these cases.
                if (lengthRE.test(minWidth) && minWidth !== '0px') {
                    returnData.minWidth = me.measure({value: minWidth, id: node})
                }
                if (lengthRE.test(minHeight) && minHeight !== '0px') {
                    returnData.minHeight = me.measure({value: minHeight, id: node})
                }
            }
        }

        return returnData
    }

    /**
     * @param {Object|String} data
     * @returns {Neo.util.Rectangle}
     */
    getClippedRect(data) {
        let me            = this,
            node          = me.getElement(typeof data === 'object' ? data.id : data),
            {defaultView} = node.ownerDocument,
            rect          = me.getBoundingClientRect(node);

        for (let parentElement = node.offsetParent; parentElement && rect && parentElement !== document.documentElement; parentElement = parentElement.parentElement) {
            if (defaultView.getComputedStyle(parentElement).getPropertyValue('overflow') !== 'visible') {
                rect = rect.intersects(this.getBoundingClientRect(parentElement))
            }
        }

        return rect
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String|String[]} data.style
     * @returns {Object}
     */
    getComputedStyle({id, style}) {
        let node   = this.getElement(id),
            styles = {};

        if (node) {
            let computedStyle = window.getComputedStyle(node);

            if (!Array.isArray(style)) {
                style = [style]
            }

            style.forEach(prop => {
                styles[prop] = computedStyle.getPropertyValue(prop)
            })
        }

        return styles
    }

    /**
     * @param {String|HTMLElement|Window|Document} nodeId
     * @returns {HTMLElement|Window|Document|null}
     * @protected
     */
    getElement(nodeId) {
        if (nodeId === 'window') {
            return globalThis
        }

        if (nodeId === 'document') {
            return document
        }

        if (nodeId === 'document.body' || nodeId === 'body') {
            return document.body
        }

        let node = nodeId?.nodeType ?
            nodeId : Neo.config.useDomIds ?
                document.getElementById(nodeId) :
                document.querySelector(`[data-neo-id='${nodeId}']`);

        return node || null
    }

    /**
     * @param {String|HTMLElement} nodeId='document.body'
     * @returns {HTMLElement|null}
     * @protected
     */
    getElementOrBody(nodeId='document.body') {
        if (!nodeId) {
            return null
        }

        return this.getElement(nodeId)
    }

    /**
     * @param {HTMLElement|Object} data
     * @param {String|String[]} data.id
     * @returns {Object}
     */
    getScrollingDimensions(data) {
        let me = this;

        if (Array.isArray(data.id)) {
            return data.id.map(id => me.getScrollingDimensions({id}))
        } else {
            let node = data.nodeType ? data : me.getElementOrBody(data.id);

            return {
                clientHeight: node?.clientHeight,
                clientWidth : node?.clientWidth,
                scrollHeight: node?.scrollHeight,
                scrollWidth : node?.scrollWidth
            }
        }
    }

    /**
     *
     */
    initGlobalListeners() {
        let me = this;

        document.addEventListener('blur',      me.onDocumentBlur     .bind(me), capturePassive);
        document.addEventListener('keydown',   me.onDocumentKeyDown  .bind(me), capturePassive);
        document.addEventListener('keyup',     me.onDocumentKeyUp    .bind(me), capturePassive);
        document.addEventListener('mousedown', me.onDocumentMouseDown.bind(me), {capture : true})
    }

    /**
     * @param {HTMLElement} el
     * @returns {Boolean}
     */
    isAlignSubject(el) {
        return [...this._aligns?.values()].some(align => align.subject === el)
    }

    /**
     * Include a script into the document.head
     * You can add more attributes if needed. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script
     * @param {String} src
     * @param {Object} opts={defer:true}
     * @param {Boolean} [opts.async]
     * @param {Boolean} [opts.defer]
     * @returns {Promise<unknown>}
     */
    loadScript(src, opts={defer:true}) {
        let script;

        return new Promise((resolve, reject) => {
            script = document.createElement('script');

            Object.assign(script, {
                ...opts,
                onerror: reject,
                onload : resolve,
                src
            });

            document.head.appendChild(script)
        })
    }

    /**
     * Include a link into the document.head
     * @param {String} href
     * @param {Object} dataset=null
     * @returns {Promise<unknown>}
     */
    loadStylesheet(href, dataset=null) {
        let link;

        return new Promise((resolve, reject) => {
            link = document.createElement('link');

            Object.assign(link, {
                href,
                onerror: reject,
                onload : resolve,
                rel    : 'stylesheet',
                type   : 'text/css'
            });

            if (dataset) {
                Object.assign(link.dataset, dataset)
            }

            document.head.appendChild(link)
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Number|String} data.value
     * @returns {Number|String}
     */
    measure({ value, id }) {
        const node = id.nodeType === 1 ? id : this.getElement(id);

        if (value.endsWith('%')) {
            const fraction = parseFloat(value) / 100;

            return (node.offsetParent?.getBoundingClientRect().height || 0) * fraction
        }
        // If it's any other CSS unit than px, it needs to be measured using the DOM
        else if (isNaN(value) && !value.endsWith('px')) {
            const elStyle = node.ownerDocument.defaultView.getComputedStyle(node);

            let d = this._measuringDiv;

            if (!d) {
                d = this._measuringDiv = document.createElement('div');
                d.style = 'position:fixed;top:-10000px;left:-10000px'
            }

            // In case a DOM update cleared it out
            document.body.appendChild(d);

            // Set all the font-size, font-weight etc style properties so that
            // em/ex/rem etc units will match
            fontSizeProps.forEach(prop => {
                d.style[prop] = elStyle[prop];
            });
            d.className = node.className;
            d.style.width = value;

            // Read back the resulting computed pixel width
            value = elStyle.width;

        }
        // If it's a number, or ends with px, use the numeric value.
        else {
            value = parseFloat(value)
        }

        return value
    }

    /**
     * Checks the overflow status of a TextAreaField's &lt;textarea> element and updates the
     * height so that there is never a vertical scrollbar.
     * @param {Object} data
     */
    async monitorAutoGrow(data) {
        const
            me     = this,
            target = data.subject = me.getElement(data.id);

        // We need to update the height on every input event is autoGrow is truthy.
        target[data.autoGrow ? 'addEventListener' : 'removeEventListener']('input', me.monitorAutoGrowHandler);

        // Fix the height up immediately too
        data.autoGrow && me.monitorAutoGrowHandler({
            target
        })
    }

    /**
     *
     * @param {Event|Object} data
     * @param {String} [data.id]
     * @param {HTMLElement} [data.target]
     */
    monitorAutoGrowHandler(data) {
        const target = data.target || this.getElement(data.id);

        if (target) {
            const
                { style }              = target,
                { style : inputStyle } = target.closest('.neo-textarea');

            // Measure the scrollHeight when forced to overflow, then set height to encompass the scrollHeight
            style.height = style.minHeight = 0;
            inputStyle.setProperty('--textfield-input-height', `${target.scrollHeight + 5}px`);
            inputStyle.setProperty('height', '');
            style.height = style.minHeight = ''
        }
    }

    /**
     *
     */
    onDocumentBlur() {
        Neo.altKeyDown = Neo.controlKeyDown = Neo.metaKeyDown = Neo.shiftKeyDown = false
    }

    /**
     * @param {KeyboardEvent} keyEvent
     */
    onDocumentKeyDown(keyEvent) {
        if (modifierKeys[keyEvent.key]) {
            // e.g. Neo.isShiftKeyDown = true or Neo.isControlKeyDown = true.
            // Selection can consult this value
            Neo[`${_util_String_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].uncapitalize(keyEvent.key)}KeyDown`] = true
        }
    }

    /**
     * @param {KeyboardEvent} keyEvent
     */
    onDocumentKeyUp(keyEvent) {
        if (modifierKeys[keyEvent.key]) {
            Neo[`${_util_String_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].uncapitalize(keyEvent.key)}KeyDown`] = false
        }
    }

    /**
     * @param {Array} mutations
     */
    onDocumentMutation(mutations) {
        const me = this;

        // If the mutations are purely align subjects being added or removed, take no action.
        if (!mutations.every(({ type, addedNodes, removedNodes }) => {
            if (type === 'childList') {
                const nodes = [...Array.from(addedNodes), ...Array.from(removedNodes)];

                return nodes.every(a => me.isAlignSubject(a))
            }
        })) {
            me.syncAligns()
        }
    }

    /**
     * @param {MouseEvent} e
     */
    onDocumentMouseDown(e) {
        let focusController = e.target?.closest('[data-focus]');

        // data-focus on an element means reject mousedown gestures, and move focus
        // to the referenced element.
        if (focusController) {
            e.preventDefault();
            document.getElementById(focusController.dataset.focus)?.focus()
        }
    }

    /**
     *
     */
    onDomContentLoaded() {
        Neo.config.applyBodyCls && this.applyBodyCls({cls: ['neo-body']});
        Neo.config.applyFixedPositionToHtmlTag && document.documentElement.style.setProperty('position', 'fixed')
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.nodeId
     */
    getOffscreenCanvas(data) {
        let me        = this,
            node      = me.getElement(data.nodeId),
            offscreen;

        if (!node) {
            return {
                result: {success: false}
            }
        }

        try {
            offscreen = node.transferControlToOffscreen();

            return {
                result  : {offscreen},
                transfer: [offscreen]
            }
        } catch (e) {
            return {transferred: true}
        }
    }

    /**
     * @param {Object} data
     * @param {String[]} data.attributes
     * @param {Array} data.functions An array containing strings and/or objects
     * @param {String[]} data.styles
     * @param {String} data.vnodeId
     * @protected
     */
    onReadDom(data) {
        let attributes    = data.attributes || [],
            functions     = data.functions  || [],
            styles        = data.styles     || [],
            {vnodeId}     = data,
            retAttributes = {},
            retFunctions  = {},
            retStyles     = {},
            element       = vnodeId ? this.getElement(vnodeId) : null,
            fnName, scope;

        attributes.forEach(key => {
            retAttributes[key] = element[key]
        });

        functions.forEach((key, index) => {
            if (Neo.isObject(key)) {
                key.params         = key.params         || [];
                key.paramIsDomNode = key.paramIsDomNode || [];

                scope = key.scope ? document[key.scope] : element;

                key.params.forEach((param, paramIndex) => {
                    if (key.paramIsDomNode[paramIndex] === true) {
                        key.params[paramIndex] = this.getElement(key.params[paramIndex])
                    }
                });

                fnName = key.returnFnName ? key.returnFnName : index;
                retFunctions[fnName] = scope[key.fn](...key.params);

                if (key.returnValue) {
                    retFunctions[fnName] = retFunctions[fnName][key.returnValue]
                }
            } else {
                retFunctions[key] = element[key]()
            }
        });

        styles.forEach(key => {
            retStyles[key] = element.style[key]
        });

        Object.assign(data, {
            attributes: retAttributes,
            functions : retFunctions,
            styles    : retStyles
        });

        Neo.worker.Manager.sendMessage(data.origin, {
            action : 'reply',
            data,
            replyId: data.id,
            success: true
        })
    }

    /**
     * @param data
     * @param data.target
     * @param data.relatedTarget
     */
    onTrappedFocusMovement({ target, relatedTarget }) {
        const backwards = relatedTarget && (target.compareDocumentPosition(relatedTarget) & 4);

        if (target.matches('.neo-focus-trap')) {
            const
                containingEement = target.parentElement,
                treeWalker       = containingEement.$treeWalker,
                topFocusTrap     = containingEement.$topFocusTrap,
                bottomFocusTrap  = containingEement.$bottomFocusTrap;

            treeWalker.currentNode = backwards ? bottomFocusTrap : topFocusTrap;
            treeWalker[backwards ? 'previousNode' : 'nextNode']();

            requestAnimationFrame(() => treeWalker.currentNode.focus())
        }
    }

    /**
     * @param {Object} data
     * @protected
     */
    read(data) {
        Neo.isFunction(data) && data()
    }

    /**
     * Resets any DOM sizing configs to the last externally configured value.
     *
     * This is used during aligning to release any constraints applied by a previous alignment.
     * @param {Object} align
     * @protected
     */
    resetDimensions(align) {
        Object.assign(this.getElement(align.id).style, {
            flex     : align.configuredFlex,
            height   : align.configuredHeight,
            maxHeight: align.configuredMaxHeight,
            maxWidth : align.configuredMaxWidth,
            minHeight: align.configuredMinHeight,
            minWidth : align.configuredMinWidth,
            width    : align.configuredWidth
        })
    }

    /**
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollBy
     * @param {Object} data
     * @param {String} data.behavior='auto' auto, instant, smooth
     * @param {String} data.direction='top' left, top
     * @param {String} data.id
     * @param {Number} data.value
     * @returns {Object} obj.id => the passed id
     */
    scrollBy({behavior='auto', direction='top', id, value}) {
        this.getElement(id)?.scrollBy({behavior, [direction]: value});
        return {id}
    }

    /**
     * You can either pass the id or a querySelector
     * @param {Object} data
     * @param {String} [data.id]
     * @param {String} data.behavior='smooth'
     * @param {String} data.block='start'
     * @param {Number} data.delay=500
     * @param {String} data.inline='nearest'
     * @param {String} [data.querySelector]
     * @returns {Promise<any>}
     */
    scrollIntoView({id, behavior='smooth', block='start', delay=500, inline='nearest', querySelector}) {
        let node = id ? this.getElement(id) : document.querySelector(querySelector),
            opts = {behavior, block, inline};

        if (behavior !== 'smooth') {
            node.scrollIntoView(opts)
        } else {
            // scrollIntoView() does not provide a callback yet.
            // See: https://github.com/w3c/csswg-drafts/issues/3744
            return new Promise(resolve => {
                if (node) {
                    let hasListener = 'scrollend' in window;

                    hasListener && document.addEventListener('scrollend', () => resolve(), {capture: true, once: true});

                    node.scrollIntoView(opts);

                    !hasListener && this.timeout(delay).then(() => {resolve()})
                } else {
                    resolve()
                }
            })
        }
    }

    /**
     * See: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo
     * @param {Object} data
     * @param {String} data.behavior='auto' auto, instant, smooth
     * @param {String} data.direction='top' left, top
     * @param {String} data.id
     * @param {Number} data.value
     * @returns {Object} obj.id => the passed id
     */
    scrollTo({behavior='auto', direction='top', id, value}) {
        this.getElement(id)?.scrollTo({behavior, [direction]: value});
        return {id}
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {String} data.behavior='smooth'
     * @param {Number} data.offset=34
     * @returns {Object} obj.id => the passed id
     */
    scrollToTableRow({id, behavior='smooth', offset=34}) {
        let node = this.getElement(id); // tr tag

        if (node) {
            let tableNode   = node.parentNode.parentNode,
                wrapperNode = tableNode.parentNode,
                tableTop    = tableNode.getBoundingClientRect().top,
                top         = node.getBoundingClientRect().top;

            wrapperNode.scrollTo({
                behavior,
                top: top - tableTop - offset
            })
        }

        return {id}
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Number} [data.start=0]
     * @param {Number} [data.end=99999]
     * @returns {Object} obj.id => the passed id
     */
    selectNode(data) {
        let node  = this.getElement(data.id),
            start = Neo.isNumber(data.start) ? data.start : 0,
            end   = Neo.isNumber(data.end)   ? data.end   : 99999;

        if (node) {
            node.select();
            node.setSelectionRange(start, end)
        }

        return {id: data.id}
    }

    /**
     * @param {Object} data
     * @param {String[]} data.add
     * @param {Object[]} data.remove
     */
    setBodyCls(data) {
        document.body.classList.remove(...data.remove || []);
        document.body.classList.add(...data.add || [])
    }

    /**
     * Not recommended to use => stick to vdom updates.
     * Can be handy for custom CSS based animations though.
     * @param {Object} data
     * @param {String} data.id A node id or 'document.body'
     * @param {Object} data.style
     * @returns {Object} obj.id => the passed id
     */
    setStyle(data) {
        let node = this.getElementOrBody(data.id);

        if (node) {
            Object.entries(data.style).forEach(([key, value]) => {
                if (Neo.isString(value) && value.includes('!important')) {
                    value = value.replace('!important', '').trim();
                    node.style.setProperty(Neo.decamel(key), value, 'important')
                } else {
                    node.style[Neo.decamel(key)] = value
                }
            })
        }

        return {id: data.id}
    }

    /**
     *
     */
    syncAligns() {
        const
            me        = this,
            {_aligns} = me;

        // Keep all registered aligns aligned on any detected change
        _aligns?.forEach(align => {
            const targetPresent = document.contains(align.targetElement);

            // Align subject and target still in the DOM - correct its alignment
            if (document.contains(align.subject) && targetPresent) {
                me.align(align)
            }
            // Align subject or target no longer in the DOM - remove it.
            else {
                // If target is no longer in the DOM, hide the subject component
                if (!targetPresent) {
                    Neo.worker.App.setConfigs({ id: align.id, hidden: true })
                }

                const
                    {_alignResizeObserver} = me,
                    {constrainToElement}   = align;

                // Stop observing the align elements
                _alignResizeObserver.unobserve(align.subject);
                _alignResizeObserver.unobserve(align.offsetParent);
                _alignResizeObserver.unobserve(align.targetElement);
                if (constrainToElement) {
                    _alignResizeObserver.unobserve(constrainToElement)
                }

                // Clear the last aligned class.
                align.subject.classList.remove(`neo-aligned-${align.result?.position}`);

                _aligns.delete(align.id)
            }
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Boolean} data.modal
     */
    syncModalMask({ id, modal }) {
        const el = id && this.getElement(id);

        // If we are visible and modal, the mask needs to be just below this element.
        if (el && modal && el.ownerDocument.contains(el) && el.ownerDocument.defaultView.getComputedStyle(el).getPropertyValue('display') !== 'none') {
            document.body.insertBefore(this.modalMask, el)
        }
        // Otherwise, the mask needs to be below the next topmost modal dialog if possible, or hidden
        else {
            const
                modals       = document.querySelectorAll('.neo-modal'),
                topmostModal = modals[modals.length - 1];

            // Move the mask under the next topmost modal now modal "id" is gone.
            if (topmostModal) {
                this.syncModalMask({ id: topmostModal.id, modal: true })
            } else {
                this._modalMask?.remove()
            }
        }
    }

    /**
     * Traps (or stops trapping) focus within a Component
     * @param {Object} data
     * @param {String} data.id The Component to trap focus within.
     * @param {Boolean} [data.trap=true] Pass `false` to stop trapping focus inside the Component.
     */
    async trapFocus(data) {
        const
            me                     = this,
            onTrappedFocusMovement = me.$boundOnTrappedFocusMovement || (me.$boundOnTrappedFocusMovement = me.onTrappedFocusMovement.bind(me)),
            subject                = data.subject = me.getElement(data.id),
            { trap = true }        = data;

        // Called before DOM has been created.
        if (!subject) {
            return
        }

        let topFocusTrap    = subject.$topFocusTrap,
            bottomFocusTrap = subject.$bottomFocusTrap;

        if (trap) {
            if (!subject.$treeWalker) {
                subject.$treeWalker = document.createTreeWalker(subject, NodeFilter.SHOW_ELEMENT, {
                    acceptNode: filterTabbable
                });
                topFocusTrap = subject.$topFocusTrap = document.createElement('div');
                bottomFocusTrap = subject.$bottomFocusTrap = document.createElement('div');

                // The two focus trapping elements must be invisible but tabbable.
                topFocusTrap.className = bottomFocusTrap.className = 'neo-focus-trap';
                topFocusTrap.setAttribute('tabIndex', 0);
                bottomFocusTrap.setAttribute('tabIndex', 0);

                // Listen for when they gain focus and wrap focus within the encapsulating element
                subject.addEventListener('focusin', onTrappedFocusMovement)
            }

            // Ensure content is encapsulated by the focus trap elements
            subject.insertBefore(topFocusTrap, subject.firstChild);
            subject.appendChild(bottomFocusTrap)
        } else {
            subject.removeEventListener('focusin', onTrappedFocusMovement)
        }
    }

    /**
     * @param {Object} data
     * @param {String} [data.behavior='smooth'] // auto or smooth
     * @param {String} [data.left=0]
     * @param {String} [data.top=0]
     */
    windowScrollTo(data) {
        window.scrollTo({
            behavior: data.behavior || 'smooth',
            left    : data.left     || 0,
            top     : data.top      || 0
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomAccess));


/***/ },

/***/ "./src/main/DomEvents.mjs"
/*!********************************!*\
  !*** ./src/main/DomEvents.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _mixin_TouchDomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mixin/TouchDomEvents.mjs */ "./src/main/mixin/TouchDomEvents.mjs");





const globalDomEvents = [
    {name: 'change',      handler: 'onChange'},
    {name: 'click',       handler: 'onClick'},
    {name: 'contextmenu', handler: 'onContextMenu'},
    {name: 'dblclick',    handler: 'onDoubleClick'},
    {name: 'focusin',     handler: 'onFocusIn'},
    {name: 'focusout',    handler: 'onFocusOut'},
    {name: 'input',       handler: 'onChange'},
    {name: 'keydown',     handler: 'onKeyDown'},
    {name: 'keyup',       handler: 'onKeyUp'},
    {name: 'mousedown',   handler: 'onMouseDown'},
    {name: 'mouseenter',  handler: 'onMouseEnter', options: {capture: true}},
    {name: 'mouseleave',  handler: 'onMouseLeave', options: {capture: true}},
    {name: 'mouseup',     handler: 'onMouseUp'},
    {name: 'scroll',      handler: 'onScroll',     options: {capture: true}},
    {name: 'wheel',       handler: 'onWheel',      options: {passive: false}}
];

// Will get applied to the document.body in case Neo.config.hasTouchEvents === true
const touchEvents = [
    {name: 'touchcancel', handler: 'onTouchCancel'},
    {name: 'touchend',    handler: 'onTouchEnd'},
    {name: 'touchenter',  handler: 'onTouchEnter'},
    {name: 'touchleave',  handler: 'onTouchLeave'},
    {name: 'touchmove',   handler: 'onTouchMove', options: {passive: false}},
    {name: 'touchstart',  handler: 'onTouchStart'}
];

// wheel events fire very often, so we limit the targets to avoid unnecessary post messages from main to the app worker
const globalWheelTargets = [
    'neo-c-m-scrollcontainer',
    'neo-c-w-scrollcontainer',
    'neo-calendar-yearcomponent',
    'neo-circle-component',
    'neo-dateselector',
    'neo-gallery',
    'neo-helix'
];

// separated from globalWheelTargets => performance
// buffer in ms
const globalWheelTargetsBuffer = {
    'neo-c-m-scrollcontainer'   : 100,
    'neo-c-w-scrollcontainer'   : 100,
    'neo-calendar-yearcomponent': 300,
    'neo-dateselector'          : 300
};

// separated from globalWheelTargets => performance
const globalWheelTargetsKeepEvent = [
    'neo-c-m-scrollcontainer',
    'neo-c-w-scrollcontainer'
];

const lastWheelEvent = {
    date  : null,
    target: null
};

const
    disabledInputKeys         = {},
    preventClickTargets       = [],
    preventContextmenuTargets = [];

/**
 * @class Neo.main.DomEvents
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 * @mixes Neo.main.mixin.TouchDomEvents
 * @singleton
 */
class DomEvents extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.main.DomEvents'
         * @protected
         */
        className: 'Neo.main.DomEvents',
        /**
         * todo: conditional dynamic import once the build processes can handle it
         * @member {Array} mixins=[TouchDomEvents]
         */
        mixins: [_mixin_TouchDomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]],
        /**
         * @member {boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'addDomListener',
                'registerDisabledInputChars',
                'registerPreventDefaultTargets',
                'unregisterDisabledInputChars'
            ]
        }
    }

    /**
     *
     * @member {Object} touch
     */
    lastTouch = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        document.addEventListener('DOMContentLoaded',  me.onDomContentLoaded .bind(me));
        document.addEventListener('selectionchange',   me.onSelectionChange  .bind(me));
        document.addEventListener('visibilitychange',  me.onVisibilitychange .bind(me));
        window  .addEventListener('orientationchange', me.onOrientationChange.bind(me));
        window  .addEventListener('hashchange',        me.onHashChange       .bind(me));

        if (Neo.config.useSharedWorkers) {
            window.addEventListener('beforeunload', me.onBeforeUnload.bind(me))
        }
    }

    /**
     * @param {Object} data
     */
    addDomListener(data) {
        let me       = this,
            i        = 0,
            len      = data.events.length,
            failedId = null,
            event, id, targetNode;

        for (; i < len; i++) {
            event = data.events[i];

            if (!me[event.handler]) {
                me[event.handler] = Neo.emptyFn
            }

            id = event.vnodeId || data.vnodeId;

            if (id === 'document.body') {
                targetNode = document.body
            } else if (Neo.config.useDomIds) {
                targetNode = document.getElementById(id)
            } else {
                targetNode = document.querySelector(`[data-neo-id='${id}']`)
            }

            if (targetNode) {
                targetNode.addEventListener(event.name, me[event.handler].bind(me))
            } else {
                failedId = id
            }
        }

        if (failedId && Neo.config.environment === 'development') {
            console.warn('DomEvents:addDomListener() => target node not found:', failedId)
        }

        Neo.worker.Manager.sendMessage(data.origin, {
            action : 'reply',
            data,
            replyId: data.id,
            success: !failedId
        })
    }

    /**
     *
     */
    addGlobalDomListeners() {
        let me = this;

        [...globalDomEvents].concat(Neo.config.hasTouchEvents ? touchEvents : []).forEach(event => {
            document.body.addEventListener(event.name, me[event.handler].bind(me), event.options)
        });
    }

    /**
     * Local domEvent listener
     * @param {Event} event
     */
    domEventListener(event) {
        let me       = this,
            {target} = event,

            config = {
                action   : 'domEvent',
                eventName: event.type,

                data: {
                    ...me.getEventData(event),
                    id   : target.id,
                    value: target.value
                }
            };

        switch (event.type) {
            case 'mousemove':
                Object.assign(config.data, me.getMouseEventData(event));
                break
            default:
                event.preventDefault();
                break
        }

        Neo.worker.Manager.sendMessage('app', config)
    }

    /**
     *
     * @param {HTMLElement} node
     * @returns {Object}
     */
    geAriaAttributes(node) {
        let ariaAttributes = {},
            {attributes}   = node,
            i              = 0,
            len            = attributes?.length || 0,
            attribute;

        for (; i < len; i++) {
            attribute = attributes[i];

            if (attribute.name.startsWith('aria-')) {
                ariaAttributes[attribute.name.substring(5)] = attribute.value
            }
        }

        return ariaAttributes
    }

    /**
     * Returns the distance between two points
     * @param  {Number} x1 The X position of the first point
     * @param  {Number} y1 The Y position of the first point
     * @param  {Number} x2 The X position of the second point
     * @param  {Number} y2 The Y position of the second point
     * @returns {Number}
     */
    getDistance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
    }

    /**
     * @param {Event} event
     * @returns {Object}
     */
    getEventData(event) {
        let path = event.composedPath();

        if (path.length < 1) {
            // our draggable implementation will generate paths, so we do need to check for them
            path = event.path;
        }

        const result = {
            path     : path.map(e => this.getTargetData(e)),
            target   : this.getTargetData(event.target),
            timeStamp: event.timeStamp,
            type     : event.type,
            data     : {...event.target.dataset}
        };

        if (event.relatedTarget) {
            result.relatedTarget = this.getTargetData(event.relatedTarget)
        }

        return result
    }

    /**
     * @param {KeyboardEvent} event
     * @returns {Object}
     */
    getKeyboardEventData(event) {
        let {altKey, code, ctrlKey, key, keyCode, metaKey, shiftKey} = event;

        return {
            ...this.getEventData(event),
            altKey,
            code,
            ctrlKey,
            key,
            keyCode,
            metaKey,
            shiftKey
        }
    }

    /**
     * @param {MouseEvent} event
     * @returns {Object}
     */
    getMouseEventData(event) {
        let {altKey, clientX, clientY, ctrlKey, detail, metaKey, offsetX, offsetY, pageX, pageY, screenX, screenY, shiftKey} = event;

        return {
            ...this.getEventData(event),
            altKey,
            clientX,
            clientY,
            ctrlKey,
            detail,
            metaKey,
            offsetX,
            offsetY,
            pageX,
            pageY,
            screenX,
            screenY,
            shiftKey
        }
    }

    /**
     * @param {Element} element
     * @returns {Element[]}
     */
    getPathFromElement(element) {
        let path = [];

        if (element) {
            path.push(element);

            while (element.parentNode) {
                path.push(element.parentNode);
                element = element.parentNode
            }
        }

        return path
    }

    /**
     * @param {Object[]} path
     * @param {HTMLElement} target
     * @returns {Object[]}
     */
    getSelectionPath(path, target) {
        if (target.parentNode && target.id.split('__').length > 1) {
            path = this.getSelectionPath(path, target.parentNode);
        }

        path.push(this.getTargetData(target));

        return path
    }

    /**
     * @param {HTMLElement} node
     * @returns {Object}
     */
    getTargetData(node) {
        let r    = node.getBoundingClientRect?.(),
            rect = r && this.parseDomRect(r) || {};

        return {
            aria             : this.geAriaAttributes(node),
            checked          : node.checked,
            childElementCount: node.childElementCount,
            clientHeight     : node.clientHeight,
            clientLeft       : node.clientLeft,
            clientTop        : node.clientTop,
            clientWidth      : node.clientWidth,
            cls              : node.classList ? [...node.classList] : [],
            data             : {...node.dataset},
            draggable        : node.draggable,
            hidden           : node.hidden,
            id               : Neo.config.useDomIds ? node.id : node.dataset?.['neoId'],
            inert            : node.inert,
            isConnected      : node.isConnected,
            isContentEditable: node.isContentEditable,
            nodeType         : node.nodeType,
            offsetHeight     : node.offsetHeight,
            offsetLeft       : node.offsetLeft,
            offsetTop        : node.offsetTop,
            offsetWidth      : node.offsetWidth,
            rect,
            role             : node.role,
            scrollHeight     : node.scrollHeight,
            scrollLeft       : node.scrollLeft,
            scrollTop        : node.scrollTop,
            scrollWidth      : node.scrollWidth,
            style            : node.style?.cssText,
            tabIndex         : node.getAttribute?.('tabindex') ? node.tabIndex : null,
            tagName          : node.tagName?.toLowerCase()
        }
    }

    /**
     * Returns the first touch event found in touches or changedTouches of a TouchEvent
     * @param {TouchEvent} event
     * @returns {Touch}
     */
    getTouchCoords(event) {
        let {touches, changedTouches} = event;
        return touches?.[0] || changedTouches?.[0]
    }

    /**
     * Only in use if Neo.config.useSharedWorkers = true
     * @param {Object} event
     */
    onBeforeUnload(event) {
        let {Manager} = Neo.worker;

        Manager.appNames.forEach(appName => {
            Manager.broadcast({action: 'disconnect', appName, windowId: Manager.windowId})
        })
    }

    /**
     * @param {InputEvent} event
     */
    onChange(event) {
        let me       = this,
            {target} = event,

            data = {
                ...me.getEventData(event),
                valid: target.checkValidity?.(),
                value: target.value
            };

        // input and change events can pass a FileList for input type file
        if (target.files) {
            data.files = target.files
        }

        me.sendMessageToApp(data)
    }

    /**
     * @param {MouseEvent} event
     */
    onClick(event) {
        let me = this;

        me.sendMessageToApp(me.getMouseEventData(event));

        me.testPathInclusion(event, preventClickTargets) && event.preventDefault()
    }

    /**
     * @param {MouseEvent} event
     */
    onContextMenu(event) {
        let me = this;

        me.sendMessageToApp(me.getMouseEventData(event));

        if (event.ctrlKey || me.testPathInclusion(event, preventContextmenuTargets)) {
            event.preventDefault()
        }
    }

    /**
     *
     */
    onDomContentLoaded() {
        this.addGlobalDomListeners();
        this.fire('domContentLoaded')
    }

    /**
     * @param {MouseEvent} event
     */
    onDoubleClick(event) {
        let me = this;

        me.sendMessageToApp(me.getMouseEventData(event));

        me.testPathInclusion(event, preventClickTargets) && event.preventDefault()
    }

    /**
     * @param {FocusEvent} event
     */
    onFocusIn(event) {
        this.sendMessageToApp(this.getEventData(event))
    }

    /**
     * @param {FocusEvent} event
     */
    onFocusOut(event) {
        this.sendMessageToApp(this.getEventData(event))
    }

    /**
     *
     */
    onHashChange() {
        let {Manager}  = Neo.worker,
            hashString = location.hash.substring(1);

        Manager.sendMessage('app', {
            action: 'hashChange',
            data  : {
                appNames: Manager.appNames,
                hash    : this.parseHash(hashString),
                hashString,
                windowId: Manager.windowId
            }
        })
    }

    /**
     * @param {KeyboardEvent} event
     */
    onKeyDown(event) {
        let me        = this,
            {target}  = event,
            {tagName} = target,
            isInput   = tagName === 'INPUT' || tagName === 'TEXTAREA';

        if (isInput && disabledInputKeys[target.id]?.includes(event.key)) {
            event.preventDefault()
        } else {
            me.sendMessageToApp(me.getKeyboardEventData(event));

            if (
                isInput &&
                event.key === 'Tab' &&
                me.testPathInclusion(event, ['neo-grid-editor', 'neo-table-editor'], true)
            ) {
                event.preventDefault()
            }

            if (
                !isInput &&
                ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp'].includes(event.key) &&
                me.testPathInclusion(event, ['neo-selection'], true)
            ) {
                event.preventDefault()
            }
        }
    }

    /**
     * @param {KeyboardEvent} event
     */
    onKeyUp(event) {
        this.sendMessageToApp(this.getKeyboardEventData(event))
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseDown(event) {
        this.sendMessageToApp(this.getMouseEventData(event))
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseEnter(event) {
        let me       = this,
            appEvent = {...me.getMouseEventData(event), fromElementId: event.fromElement?.id || null, toElementId: event.toElement?.id || null};

        me.sendMessageToApp(appEvent);
        me.fire('mouseEnter', appEvent)
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseLeave(event) {
        let me       = this,
            appEvent = {...me.getMouseEventData(event), fromElementId: event.fromElement?.id || null, toElementId: event.toElement?.id || null};

        me.sendMessageToApp(appEvent);
        me.fire('mouseLeave', appEvent)
    }

    /**
     * @param {MouseEvent} event
     */
    onMouseUp(event) {
        this.sendMessageToApp(this.getMouseEventData(event))
    }

    /**
     * @param {Event} event
     */
    onOrientationChange(event) {
        let {orientation} = screen,
            {angle, type} = orientation,
            layout        = angle === 0 || angle === 180 ? 'portrait' : 'landscape';

        Neo.worker.Manager.sendMessage('app', {
            action: 'orientationChange',
            data  : {angle, layout, type}
        })
    }

    /**
     * @param {Event} event
     */
    onScroll(event) {
        let me = this,
            {firstTouch, lastTouch} = me,
            {clientHeight, clientWidth, scrollLeft, scrollTop} = event.target,
            data;

        event.preventDefault();

        data = {
            ...me.getEventData(event),
            clientHeight,
            clientWidth,
            scrollLeft,
            scrollTop
        };

        if (firstTouch) {
            data.touches = {
                firstTouch: {clientX: firstTouch.clientX, clientY: firstTouch.clientY},
                lastTouch : {clientX: lastTouch .clientX, clientY: lastTouch .clientY}
            }
        }

        me.sendMessageToApp(data)
    }

    /**
     * @param {Event} event
     */
    onSelectionChange(event) {
        let me       = this,
            {target} = event,
            element  = target.type ? target : target.activeElement,
            path, targetData;

        if (target.tagName === 'BODY') {
            return
        }

        path       = me.getSelectionPath([], element);
        targetData = me.getTargetData(element);

        me.sendMessageToApp({
            path,
            selection: {direction: element.selectionDirection, end: element.selectionEnd, start: element.selectionStart},
            target   : targetData,
            timeStamp: event.timeStamp,
            type     : 'selectionchange'
        })
    }

    /**
     * @param {Event} event
     */
    onVisibilitychange(event) {
        Neo.worker.Manager.sendMessage('app', {
            action: 'visibilityChange',
            data  : {
                hidden         : document.hidden,
                visibilityState: document.visibilityState,
                windowId       : Neo.worker.Manager.windowId
            }
        })
    }

    /**
     * @param {Event} event
     */
    onWheel(event) {
        let target        = this.testPathInclusion(event, globalWheelTargets),
            preventUpdate = false,
            targetCls;

        if (target) {
            targetCls = target.cls;

            if (globalWheelTargetsBuffer[target.cls]) {
                let date = new Date();

                if (lastWheelEvent.date && lastWheelEvent.target === targetCls && date - lastWheelEvent.date < globalWheelTargetsBuffer[targetCls]) {
                    preventUpdate = true
                } else {
                    Object.assign(lastWheelEvent, {
                        date,
                        target: targetCls
                    })
                }
            }

            if (!preventUpdate) {
                let {deltaX, deltaY, deltaZ} = event;

                this.sendMessageToApp({
                    ...this.getEventData(event),
                    clientHeight: target.node.clientHeight,
                    clientWidth : target.node.clientWidth,
                    deltaX,
                    deltaY,
                    deltaZ,
                    scrollLeft  : target.node.scrollLeft,
                    scrollTop   : target.node.scrollTop
                })
            }

            if (!globalWheelTargetsKeepEvent.includes(targetCls)) {
                event.preventDefault()
            }
        }
    }

    /**
     * DOMRects are not spreadable => {...DOMRect} => {}
     * @param {DOMRect} rect
     * @returns {Object}
     */
    parseDomRect(rect) {
        let {bottom, height, left, right, top, width, x, y} = rect;

        return {bottom, height, left, right, top, width, x, y}
    }

    /**
     * Example for Array values: "categories[]=test1&categories[]=test2"
     * @param {String} str
     * @returns {Object}
     */
    parseHash(str) {
        if (str === '') {
            return {}
        }

        let pieces = str.split('&'),
            data   = {},
            i, key, parts, value;

        for (i = 0; i < pieces.length; i++) {
            parts = pieces[i].split('=');

            if (parts.length < 2) {
                parts.push('')
            }

            key   = decodeURIComponent(parts[0]);
            value = decodeURIComponent(parts[1]);

            if (key.indexOf('[]') !== -1) {
                key = key.substring(0, key.indexOf('[]'));

                if (typeof data[key] === 'undefined') {
                    data[key] = [];
                }

                data[key].push(this.parseValue(value))
            } else {
                data[key] = this.parseValue(value)
            }
        }

        return data
    }

    /**
     * used by parseHash to convert tokens into boolean or number types if needed
     * @param {String} value
     * @returns {Boolean|Number|String}
     * @protected
     */
    parseValue(value) {
        if (value == parseInt(value)) {
            value = parseInt(value)
        } else if (value === 'false') {
            value = false
        } else if (value === 'true') {
            value = true
        }

        return value
    }

    /**
     * @param {Object} data
     * @param {String[]} data.chars
     * @param {String} data.id
     */
    registerDisabledInputChars(data) {
        disabledInputKeys[data.id] = data.chars
    }

    /**
     * @param {Object} data
     * @param {Array|String} data.cls
     * @param {String} data.name
     */
    registerPreventDefaultTargets(data) {
        let preventArray;

        if (!Array.isArray(data.cls)) {
            data.cls = [data.cls];
        }

        switch (data.name) {
            case 'click':
                preventArray = preventClickTargets;
                break;
            case 'contextmenu':
                preventArray = preventContextmenuTargets;
                break;
        }

        data.cls.forEach(cls => {
            !preventArray.includes(cls) && preventArray.push(cls)
        })
    }

    /**
     * Sends the parsed event data to the app worker
     * @param {Object} data
     * @protected
     */
    sendMessageToApp(data) {
        Neo.worker.Manager.sendMessage('app', {
            action   : 'domEvent',
            eventName: data.type,
            data
        })
    }

    /**
     * hello <foo>world thorsten! 3 < 4 and 5 > 3
     * @param {String} value
     * @returns {String}
     */
    stripHtml(value) {
        let doc = new DOMParser().parseFromString(value, 'text/html');

        return doc.body.textContent || ''
    }

    /**
     * @param {Object} event
     * @param {Object} targetArray
     * @param {Object} testSubstring=false
     * @returns {Object|Boolean} target cls & node if found, false otherwise
     */
    testPathInclusion(event, targetArray, testSubstring=false) {
        let countTargets = targetArray.length,
            path         = event.path || event.composedPath(),
            i            = 0,
            len          = path.length,
            j, node;

        for (; i < len; i++) {
            node = path[i];

            for (j = 0; j < countTargets; j++) {
                if (
                    testSubstring && node.classList?.value?.includes(targetArray[j]) ||
                    node.classList?.contains(targetArray[j])
                ) {
                    return {cls: targetArray[j], node}
                }
            }
        }

        return false
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     */
    unregisterDisabledInputChars(data) {
        delete disabledInputKeys[data.id]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvents));


/***/ },

/***/ "./src/main/DomUtils.mjs"
/*!*******************************!*\
  !*** ./src/main/DomUtils.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


const focusableTags = {
    BODY    : 1,
    BUTTON  : 1,
    EMBED   : 1,
    IFRAME  : 1,
    INPUT   : 1,
    OBJECT  : 1,
    SELECT  : 1,
    TEXTAREA: 1
};

/**
 * @class Neo.main.DomUtils
 * @extends Neo.core.Base
 * @singleton
 */
class DomUtils extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.DomUtils'
         * @protected
         */
        className: 'Neo.main.DomUtils'
    }

    /**
     * Analogous to the `HTMLElement` `closest` method. Searches starting at the passed element for
     * an element for which the passed `filterFn` returns `true`
     * @param {HTMLElement} el The element to start from.
     * @param {Function} filterFn A function which returns `true` when the desired element is reached.
     * @param {HTMLElement} [limit] The element to stop at. This is *not* considered for matching.
     * @returns {HTMLElement}
     */
    static closest(el, filterFn, limit = document.body) {
        while (el?.nodeType === Node.ELEMENT_NODE && el !== limit) {
            if (filterFn(el)) {
                return el
            }

            el = el.parentNode
        }
    }

    static isFocusable(e) {
        // May be used as a scopeless callback, so use "DomUtils", not "this"
        return DomUtils.isTabbable(e) || Number(e.getAttribute('tabIndex')) < 0
    }

    static isTabbable(e) {
        const
            { nodeName } = e,
            style        = getComputedStyle(e),
            tabIndex     = e.getAttribute('tabIndex');

        // Hidden elements are not tabbable.
        // Negative tabIndex also means not tabbable (Though still focusable)
        if (!e.isConnected || !e.offsetParent || style.getPropertyValue('visibility') === 'hidden' || Number(tabIndex) < 0) {
            return false
        }

        return focusableTags[nodeName] ||
            ((nodeName === 'A' || nodeName === 'LINK') && !!e.href) ||
            (tabIndex != null && Number(tabIndex) >= 0) ||
            e.contentEditable === 'true'
    }

    /**
     * Analogous to the `HTMLElement` `querySelector` method. Searches the passed element
     * and all descendants for the first element for which the passed `filterFn` returns `true`.
     * @param {HTMLElement} el The element to start from.
     * @param {Function} filterFn A function which returns `true` when the desired element is reached.
     * @returns {HTMLElement} The first matching element
     */
    static query(el, filterFn) {
        return [el, ...el.querySelectorAll('*')].find(filterFn);
    }

    /**
     * Analogous to the `HTMLElement` `querySelectorAll` method. Searches the passed element
     * and all descendants for all elements for which the passed `filterFn` returns `true`.
     * @param {HTMLElement} el The element to start from.
     * @param {Function} filterFn A function which returns `true` when a desired element is reached.
     * @returns {HTMLElement[]} An array of matching elements
     */
    static queryAll(el, filterFn) {
        return [el, ...el.querySelectorAll('*')].filter(filterFn)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomUtils));


/***/ },

/***/ "./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$"
/*!********************************************************************!*\
  !*** ./src/main/addon/ lazy ^\.\/.*\.mjs$ strict namespace object ***!
  \********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./AmCharts.mjs": [
		"./src/main/addon/AmCharts.mjs",
		"vendors-src_main_addon_AmCharts_mjs"
	],
	"./AnalyticsByGoogle.mjs": [
		"./src/main/addon/AnalyticsByGoogle.mjs",
		"vendors-src_main_addon_AnalyticsByGoogle_mjs"
	],
	"./Base.mjs": [
		"./src/main/addon/Base.mjs",
		"src_main_addon_Base_mjs"
	],
	"./CesiumJS.mjs": [
		"./src/main/addon/CesiumJS.mjs",
		"vendors-src_main_addon_CesiumJS_mjs"
	],
	"./CloneNode.mjs": [
		"./src/main/addon/CloneNode.mjs",
		"vendors-src_main_addon_CloneNode_mjs"
	],
	"./Cookie.mjs": [
		"./src/main/addon/Cookie.mjs",
		"vendors-src_main_addon_Cookie_mjs"
	],
	"./DocumentHead.mjs": [
		"./src/main/addon/DocumentHead.mjs",
		"vendors-src_main_addon_DocumentHead_mjs"
	],
	"./DragDrop.mjs": [
		"./src/main/addon/DragDrop.mjs",
		"vendors-src_main_addon_DragDrop_mjs"
	],
	"./EventSimulator.mjs": [
		"./src/main/addon/EventSimulator.mjs",
		"vendors-src_main_addon_EventSimulator_mjs"
	],
	"./FileSystemAccess.mjs": [
		"./src/main/addon/FileSystemAccess.mjs",
		"vendors-src_main_addon_FileSystemAccess_mjs"
	],
	"./GoogleMaps.mjs": [
		"./src/main/addon/GoogleMaps.mjs",
		"vendors-src_main_addon_GoogleMaps_mjs"
	],
	"./HighlightJS.mjs": [
		"./src/main/addon/HighlightJS.mjs",
		"vendors-src_main_addon_HighlightJS_mjs"
	],
	"./IntersectionObserver.mjs": [
		"./src/main/addon/IntersectionObserver.mjs",
		"vendors-src_main_addon_IntersectionObserver_mjs"
	],
	"./LocalStorage.mjs": [
		"./src/main/addon/LocalStorage.mjs",
		"vendors-src_main_addon_LocalStorage_mjs"
	],
	"./MapboxGL.mjs": [
		"./src/main/addon/MapboxGL.mjs",
		"vendors-src_main_addon_MapboxGL_mjs"
	],
	"./Markdown.mjs": [
		"./src/main/addon/Markdown.mjs",
		"vendors-src_main_addon_Markdown_mjs"
	],
	"./MonacoEditor.mjs": [
		"./src/main/addon/MonacoEditor.mjs",
		"vendors-src_main_addon_MonacoEditor_mjs"
	],
	"./Mwc.mjs": [
		"./src/main/addon/Mwc.mjs",
		"vendors-src_main_addon_Mwc_mjs"
	],
	"./Navigator.mjs": [
		"./src/main/addon/Navigator.mjs",
		"vendors-src_main_addon_Navigator_mjs"
	],
	"./OpenStreetMaps.mjs": [
		"./src/main/addon/OpenStreetMaps.mjs",
		"vendors-src_main_addon_OpenStreetMaps_mjs"
	],
	"./Popover.mjs": [
		"./src/main/addon/Popover.mjs",
		"vendors-src_main_addon_Popover_mjs"
	],
	"./PrefixField.mjs": [
		"./src/main/addon/PrefixField.mjs",
		"vendors-src_main_addon_PrefixField_mjs"
	],
	"./ResizeObserver.mjs": [
		"./src/main/addon/ResizeObserver.mjs",
		"vendors-src_main_addon_ResizeObserver_mjs"
	],
	"./ScrollSync.mjs": [
		"./src/main/addon/ScrollSync.mjs",
		"vendors-src_main_addon_ScrollSync_mjs"
	],
	"./ServerSideRendering.mjs": [
		"./src/main/addon/ServerSideRendering.mjs",
		"src_main_addon_ServerSideRendering_mjs"
	],
	"./ServiceWorker.mjs": [
		"./src/main/addon/ServiceWorker.mjs",
		"vendors-src_main_addon_ServiceWorker_mjs"
	],
	"./Stylesheet.mjs": [
		"./src/main/addon/Stylesheet.mjs",
		"vendors-src_main_addon_Stylesheet_mjs"
	],
	"./WebComponent.mjs": [
		"./src/main/addon/WebComponent.mjs",
		"vendors-src_main_addon_WebComponent_mjs"
	],
	"./WindowPosition.mjs": [
		"./src/main/addon/WindowPosition.mjs",
		"vendors-src_main_addon_WindowPosition_mjs"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$";
module.exports = webpackAsyncContext;

/***/ },

/***/ "./src/main/mixin/TouchDomEvents.mjs"
/*!*******************************************!*\
  !*** ./src/main/mixin/TouchDomEvents.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Will get imported in case Neo.config.hasTouchEvents === true
 * @class Neo.main.mixin.TouchDomEvents
 * @extends Neo.core.Base
 * @singleton
 */
class TouchDomEvents extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.main.mixin.TouchDomEvents'
         * @protected
         */
        className: 'Neo.main.mixin.TouchDomEvents'
    }

    /**
     * @param {Object} event
     */
    onTouchCancel(event) {
        let me = this;

        me.sendMessageToApp(me.getEventData(event));
        me.firstTouch = null;
        me.lastTouch  = null
    }

    /**
     * @param {Object} event
     */
    onTouchEnd(event) {
        let me = this;

        me.sendMessageToApp(me.getEventData(event));
        me.firstTouch = null;
        me.lastTouch  = null
    }

    /**
     * @param {Object} event
     */
    onTouchEnter(event) {
        this.sendMessageToApp(this.getEventData(event))
    }

    /**
     * @param {Object} event
     */
    onTouchLeave(event) {
        this.sendMessageToApp(this.getEventData(event))
    }

    /**
     * @param {Object} event
     */
    onTouchMove(event) {
        let me          = this,
            data        = me.getEventData(event),
            touch       = event.touches[0],
            {lastTouch} = me;

        if (lastTouch) {
            Object.assign(data, {
                deltaX: touch.clientX - lastTouch.clientX,
                deltaY: touch.clientY - lastTouch.clientY
            })
        }

        me.sendMessageToApp(data);

        me.lastTouch = touch;

        if (me.testPathInclusion(event, ['neo-helix'])) {
            event.preventDefault()
        }
    }

    /**
     * @param {Object} event
     */
    onTouchStart(event) {
        let me = this;

        me.firstTouch = event.touches[0];
        me.lastTouch  = event.touches[0];

        me.sendMessageToApp(me.getEventData(event))
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TouchDomEvents));


/***/ },

/***/ "./src/manager/Base.mjs"
/*!******************************!*\
  !*** ./src/manager/Base.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");


/**
 * Abstract base class for the other manager classes
 * @class Neo.manager.Base
 * @extends Neo.collection.Base
 */
class Manager extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]{
    static config = {
        /**
         * @member {String} className='Neo.manager.Base'
         * @protected
         */
        className: 'Neo.manager.Base'
    }

    /**
     * @param {Number|String} id
     * @returns {Object}
     */
    getById(id) {
        return id && this.get(id) || null
    }

    /**
     * @param {Object} item
     */
    register(item) {
        let me = this;

        if (me.get(item.id)) {
            Neo.logError('Trying to create an item with an already existing id', item, me.get(item.id))
        } else {
            me.push(item)
        }
    }

    /**
     * Removes a collection item passed by reference or key
     * @param {Object|String} item
     */
    unregister(item) {
        this.remove(item)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Manager));


/***/ },

/***/ "./src/manager/ClassHierarchy.mjs"
/*!****************************************!*\
  !*** ./src/manager/ClassHierarchy.mjs ***!
  \****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.ClassHierarchy
 * @extends Neo.manager.Base
 * @singleton
 *
 * This manager maintains a registry of all classes defined within the Neo.mjs framework's current realm (main or worker),
 * including their inheritance relationships and key metadata.
 * Each registered item (value in the manager's store) has the following structure:
 * @typedef {Object} ClassHierarchyInfo
 * @property {String} className - The full Neo.mjs class name (e.g., 'Neo.component.Base').
 * @property {Function|Object} module - The direct reference to the class constructor function itself (for non-singletons)
 * or the instantiated singleton object (for singletons).
 * @property {String|null} ntype - The ntype of the class if defined (e.g., 'button', 'container'), otherwise `null`.
 * @property {String|null} parentClassName - The full class name of its direct parent class,
 * or `null` if it's a top-level class (e.g., 'Neo.core.Base').
 */
class ClassHierarchy extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.ClassHierarchy'
         * @protected
         */
        className: 'Neo.manager.ClassHierarchy',
        /**
         * @member {String} keyProperty='className'
         * @protected
         */
        keyProperty: 'className',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Memoizes the return values of isA() calls
     * @member {Map} isAQueryMap=new Map()
     * @protected
     */
    isAQueryMap = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.consumeTempMap()
    }

    /**
     * Register all classes that got applied to the Neo namespace before this instance got created
     * @protected
     */
    consumeTempMap() {
        if (Neo.classHierarchyMap) {
            this.add(Object.values(Neo.classHierarchyMap));
            delete Neo.classHierarchyMap
        }
    }

    /**
     * Both params represent classNames.
     *
     * Example use cases:
     * - isA('Neo.button.Menu',    'Neo.button.Base')    => true
     * - isA('Neo.button.Base',    'Neo.button.Menu')    => false
     * - isA('Neo.button.Base',    'Neo.component.Base') => true
     * - isA('Neo.component.Base', 'Neo.core.Base')      => true
     * @param {String} descendant
     * @param {String} ancestor
     * @returns {Boolean}
     */
    isA(descendant, ancestor) {
        if (descendant === ancestor) {
            return true
        }

        let parent        = descendant,
            {isAQueryMap} = this,
            queryName     = `${descendant},${ancestor}`,
            returnValue   = false;

        if (isAQueryMap.has(queryName)) {
            return isAQueryMap.get(queryName)
        }

        while (parent = this.get(parent)?.parentClassName) {
            if (parent === ancestor) {
                returnValue = true;
                break
            }

            // Assumption: component.Base directly extends core.Base
            if (parent === 'Neo.component.Base' && ancestor !== 'Neo.core.Base') {
                returnValue = false;
                break
            }

            if (parent === 'Neo.core.Base') {
                returnValue = false;
                break
            }
        }

        isAQueryMap.set(queryName, returnValue);

        return returnValue
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ClassHierarchy));


/***/ },

/***/ "./src/util/Array.mjs"
/*!****************************!*\
  !*** ./src/util/Array.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Array
 * @extends Neo.core.Base
 */
class NeoArray extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Array'
         * @protected
         */
        className: 'Neo.util.Array'
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     * @returns {Array}
     */
    static add(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.push(item);
            }
        });

        return arr
    }

    /**
     * Returns an array of items which are present in array1, but not in array2
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static difference(array1=[], array2=[]) {
        return array1.filter(item => !array2.includes(item))
    }

    /**
     * Checks if the item is included by reference inside the array
     * @param {Array} arr
     * @param {*} item
     */
    static hasItem(arr, item) {
        return arr.includes(item)
    }

    /**
     * Inserts an item or Array of items to an array in case it does not already exist.
     * Duplicates will only get matched by reference.
     * @param {Array} arr
     * @param {Number} index
     * @param {*} items
     * @returns {Array}
     */
    static insert(arr, index, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let len = items.length -1,
            i   = len,
            currentIndex, item;

        // Iterate backwards
        for (; i > -1; i--) {
            item = items[i];

            currentIndex = arr.indexOf(item);

            if (index !== currentIndex) {
                if (currentIndex > -1) {
                    this.move(arr, currentIndex, index)
                } else {
                    arr.splice(index, 0, item)
                }
            }
        }

        return arr
    }

    /**
     * Returns an array of items which are present in array1 and array2
     * Only supports primitive items
     * @param {Array} array1=[]
     * @param {Array} array2=[]
     * @returns {Array}
     */
    static intersection(array1=[], array2=[]) {
        return array1.filter(item => array2.includes(item))
    }

    /**
     * Moves an item inside arr from fromIndex to toIndex
     * @param {Array} arr
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    static move(arr, fromIndex, toIndex) {
        if (fromIndex === toIndex) {
            return arr
        }

        if (fromIndex >= arr.length) {
            fromIndex = arr.length - 1
        }

        arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);
        return arr
    }

    /**
     * Removes an item or array of items from an array. Only primitive items will get found
     * @param {Array} arr
     * @param {*} items
     */
    static remove(arr, items) {
        let index;

        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            index = arr.indexOf(item);

            index > -1 && arr.splice(index, 1)
        });

        return arr
    }

    /**
     * Convenience method to combine add & remove in one call.
     * You can pass single items or an array of items to add or to remove.
     * @param {Array} arr
     * @param {*} removeItems
     * @param {*} addItems
     */
    static removeAdd(arr, removeItems, addItems) {
        this.remove(arr, removeItems);
        return this.add(arr, addItems)
    }

    /**
     * Removes an item from an array in case it does exist, otherwise adds it
     * @param {Array} arr
     * @param {*} item
     * @param {Boolean} [add]
     */
    static toggle(arr, item, add = !this.hasItem(arr, item)) {
        return this[add ? 'add' : 'remove'](arr, item);
    }

    /**
     * Returns an array of items which are present in the passed arrays.
     * Multiple arrays may be passed.
     * Only supports primitive items
     * @returns {Array}
     */
    static union() {
        return [...new Set(Array.prototype.concat(...arguments))]
    }

    /**
     * Adds an item or Array of items to an array in case it does not already exist.
     * Only primitive items will get found as duplicates
     * @param {Array} arr
     * @param {*} items
     */
    static unshift(arr, items) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        items.forEach(item => {
            if (!arr.includes(item)) {
                arr.unshift(item)
            }
        });

        return arr
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(NeoArray));


/***/ },

/***/ "./src/util/Function.mjs"
/*!*******************************!*\
  !*** ./src/util/Function.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bindAppend: () => (/* binding */ bindAppend),
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   createInterceptor: () => (/* binding */ createInterceptor),
/* harmony export */   createSequence: () => (/* binding */ createSequence),
/* harmony export */   debounce: () => (/* binding */ debounce),
/* harmony export */   intercept: () => (/* binding */ intercept),
/* harmony export */   resolveCallback: () => (/* binding */ resolveCallback),
/* harmony export */   throttle: () => (/* binding */ throttle),
/* harmony export */   unSequence: () => (/* binding */ unSequence)
/* harmony export */ });
const originalMethodSymbol = Symbol('originalMethod');
const sequencedFnsSymbol   = Symbol('sequencedFns');

/**
 * Append args instead of prepending them
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function bindAppend(fn, scope) {
    const args = [].slice.call(arguments).slice(2);

    return function() {
        return fn.apply(scope, [].slice.call(arguments).concat(args))
    }
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function buffer(callback, scope, delay=300) {
    let timeoutId;

    const wrapper = function(...args) {
        // callback invocation comes "delay" ms after the last call to wrapper
        // so cancel any pending invocation.
        clearTimeout(timeoutId);

        wrapper.isPending = true;

        timeoutId = setTimeout(() => {
            timeoutId = 0;
            wrapper.isPending = false;
            callback.apply(scope, args)
        }, delay)
    };

    wrapper.cancel = () => {
        wrapper.isPending = false;
        clearTimeout(timeoutId)
    };

    return wrapper
}

/**
 * Intended for functions with 1 param where the interceptor can change the value
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @returns {Function}
 */
function createInterceptor(target, targetMethodName, interceptFunction, scope) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function(value) {
        return targetMethod.call(target, interceptFunction.call(scope || target, value))
    })
}

/**
 * @param {Neo.core.Base} target
 * @param {String} methodName
 * @param {Function} fn
 * @param {Object} scope
 * @returns {Function}
 */
function createSequence(target, methodName, fn, scope) {
    let currentMethod = target[methodName],
        wrapper;

    if (currentMethod && currentMethod[sequencedFnsSymbol]) {
        // Already a sequenced method, add to its list
        wrapper = currentMethod;
        wrapper[sequencedFnsSymbol].push({fn, scope})
    } else {
        // First time sequencing this method
        let originalMethod = currentMethod || Neo.emptyFn;

        wrapper = function() {
            originalMethod.apply(this, arguments); // Call the original method

            // Call all sequenced functions
            wrapper[sequencedFnsSymbol].forEach(seqFn => {
                seqFn.fn.apply(seqFn.scope || this, arguments);
            });
        };
        wrapper[sequencedFnsSymbol] = [{fn, scope}];
        wrapper[originalMethodSymbol] = originalMethod; // Store original method
    }

    return (target[methodName] = wrapper);
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function debounce(callback, scope, delay=300) {
    let debounceTimer;

    return function(...args) {
        // leading edge => trigger the first call right away
        if (!Neo.isNumber(debounceTimer)) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            // we still want to start a timer to delay the 2nd+ update
            debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
        } else {
            clearTimeout(debounceTimer);

            debounceTimer = setTimeout(() => {
                // we need to check if the scope (instance) did not get destroyed yet
                scope?.id && callback.apply(scope, args);
                debounceTimer = setTimeout(() => {debounceTimer = null},  delay)
            },  delay)
        }
    }
}

/**
 * The interceptor can prevent the targetMethod from getting executed in case it returns false.
 * @param {Object} target
 * @param {String} targetMethodName
 * @param {Function} interceptFunction
 * @param {Object} scope=target
 * @param {*} preventedReturnValue=null The value to return in case the interceptFunction returns false
 * @returns {Function}
 */
function intercept(target, targetMethodName, interceptFunction, scope, preventedReturnValue=null) {
    let targetMethod = target[targetMethodName];

    return (target[targetMethodName] = function() {
        return (interceptFunction.apply(scope || target, arguments) === false)
            ? preventedReturnValue
            : targetMethod.apply(target, arguments)
    })
}

/**
 * Locate a callable function by name in the passed scope.
 *
 * If the name starts with 'up.', the parent Component chain is searched.
 *
 * This is used by manager.DomEvents & core.Observable.fire and by 'handler' function calls to resolve
 * string function names in the Component's own hierarchy.
 * @param {Function|String} fn A function, or the name of a function to find in the passed scope object/
 * @param {Object} scope=this The scope to find the function in if it is specified as a string.
 * @returns {Object}
 */
function resolveCallback(fn, scope=this) {
    if (Neo.isString(fn)) {
        if (!scope[fn] && fn.startsWith('up.')) {
            fn = fn.slice(3);
            while (!scope[fn] && (scope = scope.parent));
        } else {
            scope = scope.getController?.()?.getHandlerScope(fn, null) || scope
        }

        fn = scope[fn]
    }

    return {fn, scope}
}

/**
 * @param {Function} callback
 * @param {Neo.core.Base} scope
 * @param {Number} delay=300
 * @returns {Function}
 */
function throttle(callback, scope, delay=300) {
    let lastRanDate, timeoutId;

    return function(...args) {
        if (!lastRanDate) {
            // we need to check if the scope (instance) did not get destroyed yet
            scope?.id && callback.apply(scope, args);

            lastRanDate = Date.now()
        } else {
            clearTimeout(timeoutId)

            timeoutId = setTimeout(function() {
                if ((Date.now() - lastRanDate) >= delay) {
                    // we need to check if the scope (instance) did not get destroyed yet
                    scope?.id && callback.apply(scope, args);

                    lastRanDate = Date.now()
                }
            }, delay - (Date.now() - lastRanDate))
        }
    }
}

/**
 * @param {Neo.core.Base} target
 * @param {String} methodName
 * @param {Function} fn
 * @param {Object} scope
 */
function unSequence(target, methodName, fn, scope) {
    let currentMethod = target[methodName];

    if (!currentMethod || !currentMethod[sequencedFnsSymbol]) {
        return // Not a sequenced method
    }

    const sequencedFunctions = currentMethod[sequencedFnsSymbol];

    // Filter out the function to unsequence
    currentMethod[sequencedFnsSymbol] = sequencedFunctions.filter(seqFn =>
        !(seqFn.fn === fn && seqFn.scope === scope)
    );

    if (currentMethod[sequencedFnsSymbol].length === 0) {
        // If no functions left, restore the original method
        target[methodName] = currentMethod[originalMethodSymbol]
    }
}


/***/ },

/***/ "./src/util/Logger.mjs"
/*!*****************************!*\
  !*** ./src/util/Logger.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Logger
 * @extends Neo.core.Base
 * @singleton
 */
class Logger extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Logger'
         * @protected
         */
        className: 'Neo.util.Logger',
        /**
         * Set the minimum level, which you want to output.
         * Change this at any time using a value of logLevels: ['info', 'log', 'warn', 'error']
         *
         *     Neo.util.Logger.level = 'error'
         *
         * @member {String} level='info'
         * @protected
         */
        level_: 'info',
        /**
         * @member {Boolean} enableLogs=true
         * @protected
         */
        singleton: true
    }

    /**
     * @member {Object} logChar
     */
    logChars  = {
        error: 'E',
        info : 'I',
        log  : 'L',
        warn : 'W'
    }
    /**
     * @member {Object} colors
     */
    logColors = {
        error: 'indianred',
        info : '#acacac',
        log  : '#448888',
        warn : '#6d6d00'
    }
    /**
     * LogLevels
     * @member {String[]} logLevels
     */
    logLevels = ['info', 'log', 'warn', 'error']

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // aliases
        Neo.applyFromNs(Neo, me, {
            error   : 'error',
            info    : 'info',
            log     : 'log',
            logError: 'logError',
            warn    : 'warn'
        }, true);

        me.timeout(50).then(() => {
            if (!Neo.config.enableLogsInProduction && Neo.config.environment === 'dist/production') {
                me.write = Neo.emptyFn
            }
        })
    }

    /**
     * Set level to number based on position in logLevels
     * @param {String} value
     * @param {String|Number} oldValue
     * @returns {Number}
     */
    beforeSetLevel(value, oldValue) {
        return this.logLevels.indexOf(value)
    }

    /**
     * @param {String} value
     */
    error(value) {
        throw new Error(value)
    }

    /**
     * internal helper to catch caller
     * no known native way in modern JS to know what file that triggered the current method
     * therefore we use Error, we can get the caller file from the stack trace string.
     * @protected
     * @returns {String}
     */
    getCaller() {
        let caller_path = undefined,
            err         = new Error(),
            stack_lines = err.stack.split('\n'),
            found_this  = false,
            i, line;

        for (i in stack_lines) {
            line = stack_lines[i];

            if (!found_this && /Logger\.mjs/.test(line)) {
                found_this = true
            } else if (found_this) {
                if (!/Logger\.mjs/.test(line)) {
                    // remove the closing )
                    line        = line.replace(')', '');
                    // get the part after the last /
                    caller_path = line.match(/([^\/]+)$/)[1].match(/([^ ]+)$/)[1];

                    break
                }
            }
        }

        return caller_path
    }

    /**
     * @param args
     */
    info(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'info')
    }

    /**
     * @param args
     */
    log(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'log')
    }

    /**
     * @param args
     */
    logError(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'error')
    }

    /**
     * @param {Object} data
     */
    onContextMenu(data) {
        let {config} = Neo;

        if (config.enableComponentLogger && !(config.env === 'dist/production' && config.enableLogsInProduction)) {
            let isGroupSet = false,
                component;

            data.path.forEach(item => {
                component = Neo.getComponent(item.id, false);

                if (component) {
                    if (!isGroupSet) {
                        isGroupSet = true;
                        console.group(item.id)
                    }

                    console.log(component)
                }
            });

            isGroupSet && console.groupEnd()
        }
    }

    /**
     * Internal helper for args
     * @param {Array} args
     * @returns {Object}
     * @protected
     */
    resolveArgs(...args) {
        let identifier = args[0],
            argsObject = {};

        if (args.length === 1) {
            if (Neo.isString(identifier)) {
                argsObject.msg = args[0]
            } else if (Neo.isObject(identifier)) {
                argsObject = identifier
            }
        } else if (args.length > 2) {
            argsObject.msg  = args[0];
            argsObject.data = args.slice(1)
        }

        return argsObject
    }

    /**
     * @param args
     */
    warn(...args) {
        args = this.resolveArgs(...args);
        this.write(args, 'warn')
    }

    /**
     * Output method
     * @param {Object} args
     * @param {String} level
     * @protected
     */
    write(args, level) {
        let me = this;

        if (me.beforeSetLevel(level) < me.level) {
            return
        }

        console.log('#', args.msg, level);

        let logColor = me.logColors[level],
            logChar  = me.logChars[level],
            bg       = `background-color:${logColor}; color: white; font-weight: 900;`,
            color    = `color:${logColor};`,
            msg      = `[${me.getCaller()}] ${args.msg}`;

        if (args.data) {
            console.groupCollapsed(`%c ${logChar} %c ${msg}`, bg, color)
            console.log(args.data);
            console.groupEnd()
        } else {
            console.log(`%c ${logChar} %c ${msg}`, bg, color)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Logger));


/***/ },

/***/ "./src/util/Rectangle.mjs"
/*!********************************!*\
  !*** ./src/util/Rectangle.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Rectangle)
/* harmony export */ });
/**
 * The class contains utility methods for working with DOMRect Objects
 * @class Neo.util.Rectangle
 * @extends DOMRect
 */

const
    emptyArray = Object.freeze([]),
    // Convert edge array values into the [T,R,B,L] form.
    parseEdgeValue = (e = 0) => {
        if (!Array.isArray(e)) {
            e = [e];
        }
        switch (e.length) {
            case 1:
                e.length = 4;
                return e.fill(e[0], 1, 4);
            case 2:// top&bottom, left&right
                return [e[0], e[1], e[0], e[1]];
            case 3:// top, left&right, bottom
                return [e[0], e[1], e[2], e[1]];
        }
        return e;
    },
    parseEdgeAlign = edgeAlign => {
        const
            edgeParts     = edgeAlignRE.exec(edgeAlign),
            ourEdgeZone   = edgeZone[edgeParts[1]],
            theirEdgeZone = edgeZone[edgeParts[4]];

        return {
            ourEdge         : edgeParts[1],
            ourEdgeOffset   : parseInt(edgeParts[2] || 50),
            ourEdgeUnit     : edgeParts[3] || '%',
            ourEdgeZone,
            theirEdge       : edgeParts[4],
            theirEdgeOffset : parseInt(edgeParts[5] || 50),
            theirEdgeUnit   : edgeParts[6] || '%',
            theirEdgeZone,

            // Aligned to an edge, *outside* of the target.
            // A normal align as a combo dropdown might request
            edgeAligned     : (ourEdgeZone & 1) === (theirEdgeZone & 1) && ourEdgeZone !== theirEdgeZone
        }
    },
    // The opposite of parseEdgeAlign, and it has to flip the edges
    createReversedEdgeAlign = edges => {
        const
            ourEdge   = oppositeEdge[edges.ourEdge],
            theirEdge = oppositeEdge[edges.theirEdge];

        // reconstitute a rule string with the edges flipped to the opposite sides
        return `${ourEdge}${edges.ourEdgeOffset}${edges.ourEdgeUnit}-${theirEdge}${edges.theirEdgeOffset}${edges.theirEdgeUnit}`

    },
    getElRect = el => {
        const r = el instanceof DOMRect ? el : (el?.nodeType === 1 ? el : typeof el === 'string' ? document.getElementById(el) : null)?.getBoundingClientRect();

        // Convert DOMRect into Rectangle
        return r && new Rectangle(r.x, r.y, r.width, r.height);
    },
    oppositeEdge = {
        t : 'b',
        r : 'l',
        b : 't',
        l : 'r'
    },
    edgeZone = {
        t : 0,
        r : 1,
        b : 2,
        l : 3
    },
    zoneNames = ['top', 'right', 'bottom', 'left'],
    zoneEdges = ['t', 'r', 'b', 'l'],
    zoneDimension = ['width', 'height'],
    zoneCoord = [0, 1, 0, 1],
    zeroMargins = [0, 0, 0, 0],
    edgeAlignRE = /^([trblc])(\d*)(%|px)?-([trblc])(\d*)(%|px)?$/;

class Rectangle extends DOMRect {
    static config = {
        /**
         * @member {String} className='Neo.util.Rectangle'
         * @protected
         */
        className: 'Neo.util.Rectangle'
    }

    /**
     * @member {Number|null} minHeight=null
     */
    minHeight = null
    /**
     * @member {Number|null} minWidth=null
     */
    minWidth = null

    /**
     * Checks if rect1 does not have an intersection with rect2
     * !includes() is true for intersections as well
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static excludes(rect1, rect2) {
        return rect1.bottom < rect2.top     // rect2 is below rect1
            || rect1.left   > rect2.right   // rect2 is left of rect1
            || rect1.right  < rect2.left    // rect2 is right of rect1
            || rect1.top    > rect2.bottom; // rect2 is above rect1
    }

    /**
     * Returns the overlapping area of rect1 & rect2 as a new Rectangle
     * @param {DOMRect|Neo.util.Rectangle} rect1
     * @param {DOMRect|Neo.util.Rectangle} rect2
     * @returns {Neo.util.Rectangle|null} The intersecting rect
     */
    static getIntersection(rect1, rect2) {
        let x      = Math.max(rect1.x,      rect2.x),
            y      = Math.max(rect1.y,      rect2.y),
            right  = Math.min(rect1.right,  rect2.right),
            bottom = Math.min(rect1.bottom, rect2.bottom),
            width  = Math.max(0, right  - x),
            height = Math.max(0, bottom - y);

        if (height < 1 || width < 1) {
            return null
        }

        return new Rectangle(x, y, width, height)
    }

    /**
     * Checks if rect2 is fully contained inside rect1
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static includes(rect1, rect2) {
        return rect1.bottom >= rect2.bottom
            && rect1.left   <= rect2.left
            && rect1.right  >= rect2.right
            && rect1.top    <= rect2.top;
    }

    /**
     * Checks if rect2 is not contained inside rect1.
     * This could be an intersection or being fully excluded.
     * @param {Object} rect1
     * @param {Object} rect2
     * @param {String} side bottom, left, right or top
     * @returns {Boolean}
     */
    static leavesSide(rect1, rect2, side) {
        if (Rectangle.includes(rect1, rect2)) {
            return false;
        }

        if (side === 'bottom') {
            return rect1.bottom < rect2.bottom;
        }

        if (side === 'left') {
            return rect1.left > rect2.left;
        }

        if (side === 'right') {
            return rect1.right < rect2.right;
        }

        if (side === 'top') {
            return rect1.top > rect2.top;
        }
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveBy(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  += x;
            movedRect.right += x;
            movedRect.x     += x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom += y;
            movedRect.top    += y;
            movedRect.y      += y;
        }

        return movedRect;
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveTo(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  = x;
            movedRect.right = x + movedRect.width;
            movedRect.x     = x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom = y + movedRect.height;
            movedRect.top    = y;
            movedRect.y      = y;
        }

        return movedRect;
    }

    set bottom(b) {
        this.height += b - this.bottom;
    }
    get bottom() {
        return super.bottom;
    }

    set right(r) {
        this.width += r - this.right;
    }
    get right() {
        return super.right;
    }

    // Change the x without moving the Rectangle. The left side moves and the right side doesn't
    changeX(x) {
        const widthDelta = this.x - x;

        this.x = x;
        this.width += widthDelta;
    }

    // Change the y without moving the Rectangle. The top side moves and the bottom side doesn't
    changeY(y) {
        const heightDelta = this.y - y;

        this.y = y;
        this.height += heightDelta;
    }

    clone() {
        return Rectangle.clone(this);
    }

    static clone(r) {
        const result = new Rectangle(r.x, r.y, r.width, r.height);

        result.minWidth = r.minWidth;
        result.minHeight = r.minHeight;

        return result;
    }

    intersects(other) {
        const me = this;

        if (other.height && other.width) {
            const
                left   = Math.max(me.x, other.x),
                top    = Math.max(me.y, other.y),
                right  = Math.min(me.x + me.width, other.x + other.width),
                bottom = Math.min(me.y + me.height, other.y + other.height);

            if (left >= right || top >= bottom) {
                return false;
            }

            return new Rectangle(left, top, right - left, bottom - top);
        }
        // We're dealing with a point here - zero dimensions
        else {
            return (other.x >= me.x && other.y >= me.y && other.right <= me.right && other.bottom <= me.bottom);
        }
    }


    /**
     * Returns a clone of this Rectangle expanded according to the edges array.
     * @param {Number[]} edges
     * @returns {Rectangle}
     */
    expand(edges) {
        edges = parseEdgeValue(edges);

        return new this.constructor(this.x - edges[3], this.y - edges[0], this.width + edges[1] + edges[3], this.height + edges[0] + edges[2]);
    }

    moveBy(x = 0, y = 0) {
        const result = this.clone();

        if (Array.isArray(x)) {
            y = x[1];
            x = x[0];
        }
        result.x += x;
        result.y += y;
        return result;
    }

    /**
     * Returns `true` if this Rectangle completely contains the other Rectangle
     * @param {Rectangle} other
     */
    contains(other) {
        return Rectangle.includes(this, other)
    }

    /**
     * Returns a copy of this Rectangle constrained to fit within the passed Rectangle
     * @param {Rectangle} constrainTo
     * @returns {Rectangle|Boolean} A new Rectangle constrained to te passed Rectangle, or false if it could not be constrained.
     */
    constrainTo(constrainTo) {
        const
            me        = this,
            minWidth  = me.minWidth  || me.width,
            minHeight = me.minHeight || me.height;

        // Not possible, even when shrunk to minima
        if (minHeight > constrainTo.height || minWidth > constrainTo.width) {
            return false;
        }

        // We do not mutate this Rectangle, but return a constrained version
        const result = me.clone();

        // Translate result so that the top and left are visible
        result.x = Math.max(me.x + Math.min(constrainTo.right  - result.right,  0), constrainTo.x);
        result.y = Math.max(me.y + Math.min(constrainTo.bottom - result.bottom, 0), constrainTo.y);

        // Pull in any resulting overflow
        result.bottom = Math.min(result.bottom, constrainTo.bottom);
        result.right = Math.min(result.right, constrainTo.right);

        return result;
    }

    alignTo(align) {
        const
            me             = this,
            {
                constrainTo,    // Element or Rectangle result must fit into
                target,         // Element or Rectangle to align to
                edgeAlign,      // t50-b50 type string
                axisLock,       // true for flip, 'flexible' for flip, then try the other edges
                offset,         // Final [x, y] vector to move the result by.
                matchSize
            }              = align,
            targetMargin   = align.targetMargin ? parseEdgeValue(align.targetMargin) : zeroMargins,
            targetRect     = getElRect(target),
            constrainRect  = getElRect(constrainTo),
            edges          = parseEdgeAlign(edgeAlign),
            matchDimension = zoneDimension[edges.theirEdgeZone & 1];

        let result = me.clone();

        if (matchSize) {
            result[matchDimension] = targetRect[matchDimension];
        }

        // Must do the calculations after the aligned side has been matched in size if requested.
        const
            myPoint     = result.getAnchorPoint(edges.ourEdgeZone, edges.ourEdgeOffset, edges.ourEdgeUnit),
            targetPoint = targetRect.getAnchorPoint(edges.theirEdgeZone, edges.theirEdgeOffset, edges.theirEdgeUnit, targetMargin),
            vector      = [targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]];

        result = result.moveBy(vector);

        // A useful property in the resulting rectangle which specifies which zone of the target
        // It is being places in, T,R,B or L - 0, 1, 2, 3
        // Some code may want to treat DOM elements differently depending on the zone
        result.zone = edges.theirEdgeZone;
        result.position = zoneNames[result.zone];

        // Now we create the four Rectangles around the target, into which we may be constrained
        // Zones T,R,B,L 0 9, 1, 2, 3:
        // +-----------------------------------------------------------------------------------+
        // | +-------------------------+------------------------+----------------------------+ |
        // | |          ^              |                        |             ^              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+---------Zone 0---------+-------------+---------->   | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | +----------+--------------+------------------------+-------------+--------------+ |
        // | |          |              | +--------------------+ |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |       Zone 3            | |                    | |          Zone 1            | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | +--------------------+ |             |              | |
        // | ++---------+--------------+------------------------+-------------+--------------+ |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+--------Zone 2----------+-------------+------------> | |
        // | |          |              |                        |             |              | |
        // | |          v              |                        |             v              | |
        // | ++------------------------+------------------------+----------------------------+ |
        // +-----------------------------------------------------------------------------------+
        if (constrainRect && !constrainRect.contains(result)) {
            // They asked to overlap the target, for example t0-t0
            // In these cases, we just return the result
            if (targetRect.intersects(result)) {
                return result;
            }

            // This is the zone we try to fit into first, the one that was asked for
            let zone = edges.theirEdgeZone;

            // We create an array of four rectangles into which we try to fit with appropriate align specs.
            // We must start with the requested zone, whatever that is.
            const zonesToTry = [{
                zone,
                edgeAlign
            }];

            if (axisLock) {
                // Flip to the opposite side for the second try.
                // The alignment string has to be reversed
                // so r20-l30 has to become l20-r30.
                // The other two zones revert to centered so are easier
                zonesToTry[1] = {
                    zone      : zone = (zone + 2) % 4,
                    edgeAlign : createReversedEdgeAlign(edges)
                }

                // Fall back to the other two zones.
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 1) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 3) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
            }
            else {
                // go through the other zones in order
                for (let i = 1; i < 4; i++) {
                    zonesToTry.push({
                        zone      : zone = (zone + 1) % 4,
                        edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                    });
                }
            }

            // Calculate the constraint Rectangle for each zone
            for (let i = 0; i < zonesToTry.length; i++) {
                // We clone the outer constraining rectangle
                // and move it into position
                const c = constrainRect.clone();

                switch (zonesToTry[i].zone) {
                    case 0:
                        // The zone i2 above the target - zone 0/T
                        c.bottom = targetRect.y - targetMargin[0];
                        break;
                    case 1:
                        // The zone is to the right of the target - zone 1/R
                        c.changeX(targetRect.right + targetMargin[1]);
                        break;
                    case 2:
                        // The zone is below the target - zone 2/B
                        c.changeY(targetRect.bottom + targetMargin[2]);
                        break;
                    case 3:
                        // The zone is to the left of the target - zone 3/L
                        c.right = targetRect.x - targetMargin[3];
                        break;
                }
                zonesToTry[i].constrainRect = c;
            }

            // Now try to constrain our result into each zone's constraintZone
            for (let i = 0; i < zonesToTry.length; i++) {
                const
                    {
                        zone,
                        edgeAlign,
                        constrainRect
                    }    = zonesToTry[i],
                    edge = zoneEdges[zone];

                if (matchSize) {
                    // If we are aligning to the requested edge, or it's opposite edge then
                    // match that edge size, else revert it to our own size
                    result[matchDimension] = edge === edges.theirEdge || edge == oppositeEdge[edges.theirEdge] ? targetRect[matchDimension] : me[matchDimension];
                }

                // Do a simple align to the current edge
                result = result.alignTo({
                    target : targetRect,
                    edgeAlign,
                    targetMargin
                });

                let solution = result.constrainTo(constrainRect);

                // As soon as we find a zone into which the result is willing to be constrained. return it
                if (solution) {
                    solution.zone = zone;
                    solution.position = zoneNames[zone];
                    return solution;
                }
            }
        }

        // Add the configurable finishing touch.
        if (offset) {
            result.moveBy(offset);
        }

        return result;
    }

    getAnchorPoint(edgeZone, edgeOffset, edgeUnit, margin = emptyArray) {
        const me = this;

        let result;

        // Edge zones go top, right, bottom, left
        // Each one calculates the start point of that edge then moves along it by
        // the edgeOffset, then moves *away* from it by the margin for that edge if there's a margin.
        switch (edgeZone) {
            case 0:
                result = [me.x, me.y - (margin[0] || 0), me.width, 0];
                break;
            case 1:
                result = [me.x + me.width + (margin[1] || 0), me.y, me.height, 1];
                break;
            case 2:
                result = [me.x, me.y + me.height + (margin[2] || 0), me.width, 0];
                break;
            case 3:
                result = [me.x - (margin[3] || 0), me.y, me.height, 1];
        }
        result[result[3]] += edgeUnit === '%' ? result[2] / 100 * edgeOffset : edgeOffset;
        result.length = 2;
        return result;
    }

    equals(other) {
        return other instanceof DOMRect &&
            other.x === this.x &&
            other.y === this.y &&
            other.height === this.height &&
            other.width === this.width;
    }

    // For debugging purposes only
    show(color = 'red') {
        const div = document.createElement('div');

        div.style = `
            position:absolute;
            transform:translate3d(${this.x}px, ${this.y}px, 0);
            height:${this.height}px;
            width:${this.width}px;
            background-color:${color}
        `;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 30000);
        return div;
    }

    /**
     * When using JSON.stringify(this), we want to add minHeight & minWidth to the output.
     * @returns {Object}
     */
    toJSON() {
        const {bottom, height, left, minHeight, minWidth, right, top, width, x, y} = this;
        return {bottom, height, left, minHeight, minWidth, right, top, width, x, y}
    }
}


/***/ },

/***/ "./src/util/String.mjs"
/*!*****************************!*\
  !*** ./src/util/String.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.String
 * @extends Neo.core.Base
 */
class StringUtil extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} charEntityMap
     * @static
     */
    static charEntityMap = {
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        '\'': '&apos;',
        '$' : '&dollar;',
        '\\': '&bsol;',
        '/' : '&sol;'
    }
    /**
     * @member {RegExp} charPattern
     * @static
     */
    static charPattern = /[&<>"'$\\]/g
    /**
     * @member {RegExp} entityPattern
     * @static
     */
    static entityPattern = /(&amp;)|(&lt;)|(&gt;)|(&quot;)|(&apos;)|(&dollar;)|(&bsol;)|(&sol;)/g

    static config = {
        /**
         * @member {String} className='Neo.util.String'
         * @protected
         */
        className: 'Neo.util.String'
    }

    /**
     * Escape HTML special characters
     * @param {String} value
     */
    static escapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.charPattern, me.getEntityFromChar.bind(me))
    }

    /**
     * Get char equivalent of a mapped entity
     * @param {String} entity
     */
    static getCharFromEntity(entity) {
        let mappedChar = Object.keys(this.charEntityMap).find(key => this.charEntityMap[key] === entity);
        return mappedChar || entity
    }

    /**
     * Get entity equivalent of a mapped char
     * @param {String} char
     */
    static getEntityFromChar(char) {
        return this.charEntityMap[char] || char
    }

    /**
     * Unescape HTML special characters
     * @param {String} value
     */
    static unescapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.entityPattern, me.getCharFromEntity.bind(me))
    }

    /**
     * Returns the passed string with the first letter uncapitalized.
     * @param {String} value
     * @returns  {String}
     */
    static uncapitalize(value) {
        return value && value[0].toLowerCase() + value.substring(1)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(StringUtil));


/***/ },

/***/ "./src/vdom/domConstants.mjs"
/*!***********************************!*\
  !*** ./src/vdom/domConstants.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rawDimensionTags: () => (/* binding */ rawDimensionTags),
/* harmony export */   voidAttributes: () => (/* binding */ voidAttributes),
/* harmony export */   voidElements: () => (/* binding */ voidElements)
/* harmony export */ });
/**
 * The following top-level attributes will get converted into styles:
 * height, maxHeight, maxWidth, minHeight, minWidth, width
 *
 * Some tags must not do the transformation, so we add them here.
 * @member {Set} rawDimensionTags
 */
const rawDimensionTags = new Set([
    'circle',
    'clipPath',
    'ellipse',
    'filter',
    'foreignObject',
    'image',
    'marker',
    'mask',
    'pattern',
    'rect',
    'svg',
    'use'
]);

/**
 * Void attributes inside html tags
 * @member {Set} voidAttributes
 * @protected
 */
const voidAttributes = new Set([
    'checked',
    'defer',
    'disabled',
    'ismap',
    'multiple',
    'nohref',
    'noresize',
    'noshade',
    'nowrap',
    'open',
    'readonly',
    'required',
    'reversed',
    'selected'
]);

/**
 * Void html tags
 * @member {Set} voidElements
 * @protected
 */
const voidElements = new Set([
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
]);


/***/ },

/***/ "./src/worker/Manager.mjs"
/*!********************************!*\
  !*** ./src/worker/Manager.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../main/DomAccess.mjs */ "./src/main/DomAccess.mjs");
/* harmony import */ var _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../main/DomEvents.mjs */ "./src/main/DomEvents.mjs");
/* harmony import */ var _Message_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Message.mjs */ "./src/worker/Message.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mixin/RemoteMethodAccess.mjs */ "./src/worker/mixin/RemoteMethodAccess.mjs");







const NeoConfig    = Neo.config,
      hasJsModules = NeoConfig.environment === 'development' || NeoConfig.environment === 'dist/esm';

// Using ?. since SWs do not exist for http (only https)
navigator.serviceWorker?.addEventListener('controllerchange', function() {
    window.location.reload()
}, {once: true});

/**
 * @summary Orchestrates the multi-threaded worker environment and handles message routing.
 *
 * This class is the central nervous system of the Neo.mjs runtime in the main thread. It is responsible for:
 * 1.  **Worker Creation:** Instantiating the App, Data, VDom, and other workers based on configuration.
 * 2.  **Message Routing:** Acting as the hub for inter-worker communication. While standard messages are routed
 *     via the main thread, this manager also facilitates the initial handshake to establish direct
 *     **MessageChannel** connections between workers (e.g., App <-> Canvas) for high-performance,
 *     bi-directional communication. The VDOM update process is a notable exception, using a triangular
 *     flow (App -> VDom -> Main -> App) by design.
 * 3.  **DOM Update Coordination:** intercepting VDOM update requests and synchronizing them with the
 *     browser's animation frame to ensure smooth rendering. This involves a complex promise-based
 *     mechanism to delay worker replies until the DOM changes are actually painted.
 * 4.  **Configuration Management:** synchronizing `Neo.config` changes across all threads.
 *
 * @class Neo.worker.Manager
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 * @mixes Neo.worker.mixin.RemoteMethodAccess
 * @singleton
 */
class Manager extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.Manager'
         * @protected
         */
        className: 'Neo.worker.Manager',
        /**
         * @member {Number} activeWorkers=0
         * @protected
         */
        activeWorkers: 0,
        /**
         * @member {String[]} appNames=[]
         * @protected
         */
        appNames: [],
        /**
         * @member {Number} constructedThreads=0
         * @protected
         */
        constructedThreads: 0,
        /**
         * @member {String[]|Neo.core.Base[]|null} mixins=[Observable, RemoteMethodAccess]
         */
        mixins: [_core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], _mixin_RemoteMethodAccess_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]],
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app   : ['setNeoConfig'],
            canvas: ['setNeoConfig'],
            data  : ['setNeoConfig'],
            task  : ['setNeoConfig'],
            vdom  : ['setNeoConfig']
        },
        /**
         * True in case the current browser supports window.SharedWorker.
         * @member {Boolean} sharedWorkersEnabled=false
         * @protected
         */
        sharedWorkersEnabled: false,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * Internal flag to stop the worker communication in case their creation fails
         * @member {Boolean} stopCommunication=false
         * @protected
         */
        stopCommunication: false,
        /**
         * True in case the current browser supports window.Worker.
         * The neo.mjs framework is not able to run without web workers.
         * @member {Boolean} sharedWorkersEnabled=false
         * @protected
         */
        webWorkersEnabled: false,
        /**
         * Using crypto.randomUUID() as a unique window identifier
         * @member {String} windowId=window.__NEO_SSR__?.windowId||crypto.randomUUID()
         * @protected
         */
        windowId: window.__NEO_SSR__?.windowId || crypto.randomUUID(),
        /**
         * Contains the fileNames for the App, Data & Vdom workers
         * @member {Object} workers
         * @protected
         */
        workers: {
            app: {
                fileName: hasJsModules ? 'App.mjs'    : 'appworker.js'
            },
            canvas: {
                fileName: hasJsModules ? 'Canvas.mjs' : 'canvasworker.js'
            },
            data: {
                fileName: hasJsModules ? 'Data.mjs'   : 'dataworker.js'
            },
            task: {
                fileName: hasJsModules ? 'Task.mjs'   : 'taskworker.js'
            },
            vdom: {
                fileName: hasJsModules ? 'VDom.mjs'   : 'vdomworker.js'
            }
        }
    }

    /**
     * navigator.serviceWorker.controller can be null in case we load a page for the first time
     * or in case of a force refresh.
     * See: https://www.w3.org/TR/service-workers/#navigator-service-worker-controller
     * Only in this case main.addon.ServiceWorker will store the active registration once ready here.
     * @member {ServiceWorker|null} serviceWorker=null
     */
    serviceWorker = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.detectFeatures();

        !Neo.insideWorker && me.createWorkers();

        Neo.setGlobalConfig = me.setGlobalConfig.bind(me);
        Neo.workerId        = 'main';

        me.promises = {};

        me.on({
            'message:addDomListener'    : {fn: _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addDomListener,       scope: _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]},
            'message:getOffscreenCanvas': {fn: _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].onGetOffscreenCanvas, scope: _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]},
            'message:readDom'           : {fn: _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].onReadDom,            scope: _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]},
            'message:registerRemote'    : {fn: me.onRegisterRemote,            scope: me},
            'message:workerConstructed' : {fn: me.onWorkerConstructed,         scope: me}
        })
    }

    /**
     * Sends a message to each worker defined inside the this.workers config.
     * Only sends to workers that are currently active and available.
     * @param {Object} msg             The message payload to broadcast.
     * @param {Object} [excludeOrigin] Optionally pass the origin realm name to exclude from the broadcast.
     */
    broadcast(msg, excludeOrigin) {
        let me = this;

        Object.keys(me.workers).forEach(name => {
            if (name !== excludeOrigin && me.getWorker(name)) {
                me.sendMessage(name, msg)
            }
        })
    }

    /**
     * Creates a web worker using the passed options as well as adding error & message event listeners.
     * @param {Object} opts
     * @returns {SharedWorker|Worker}
     */
    createWorker(opts) {
        let me         = this,
            {fileName} = opts,
            filePath   = (opts.basePath || Neo.config.workerBasePath) + fileName,
            name       = `neomjs-${fileName.substring(0, fileName.indexOf('.')).toLowerCase()}-worker`,
            isShared   = me.sharedWorkersEnabled && NeoConfig.useSharedWorkers,
            cls        = isShared ? SharedWorker : Worker,
            worker     = hasJsModules
                ? new cls(filePath, {name, type: 'module'})
                : new cls(filePath, {name});

        (isShared ? worker.port : worker).onmessage = me.onWorkerMessage.bind(me);
        (isShared ? worker.port : worker).onerror   = me.onWorkerError  .bind(me);

        me.activeWorkers++;

        return worker
    }

    /**
     * @summary Instantiates the configured worker threads.
     *
     * This method reads the `Neo.config` to determine which workers to create (App, Data, VDom, etc.)
     * and whether to use `Worker` or `SharedWorker`. It injects the initial configuration and environment
     * data (like window ID) into each worker upon creation.
     */
    createWorkers() {
        let me                   = this,
            config               = Neo.clone(NeoConfig, true),
            {hash, href, search} = location,
            {windowId}           = me,
            ssrData              = window.__NEO_SSR__,
            key, value;

        // remove configs which are not relevant for the workers scope
        delete config.cesiumJsToken;

        // pass the initial hash value as Neo.configs
        if (hash) {
            config.hash = {
                hash      : _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].parseHash(hash.substring(1)),
                hashString: hash.substring(1),
                windowId
            }
        }

        config.url = {href, search};

        for ([key, value] of Object.entries(me.workers)) {
            if (key === 'canvas' && !config.useCanvasWorker ||
                key === 'task'   && !config.useTaskWorker   ||
                key === 'vdom'   && !config.useVdomWorker
            ) {
                continue
            }

            try {
                value.worker = me.createWorker(value)
            } catch (e) {
                document.body.innerHTML = e;
                me.stopCommunication = true;
                break
            }

            let workerConfig = {...config, windowId};

            if (ssrData && key === 'app') {
                Object.assign(workerConfig, {
                    cssMap : ssrData.cssMap,
                    useSSR: true,
                    vnode : ssrData.vnode
                });

                if (ssrData.hash) {
                    workerConfig.hash = ssrData.hash;
                }
            }

            me.sendMessage(key, {
                action: 'registerNeoConfig',
                data  : workerConfig
            })
        }
    }

    /**
     *
     */
    detectFeatures() {
        let me = this;

        NeoConfig.hasMouseEvents = matchMedia('(pointer:fine)').matches;
        NeoConfig.hasTouchEvents = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Useful for styling
        document.body.classList.add(NeoConfig.hasMouseEvents ? 'neo-mouse' : 'neo-no-mouse');

        if (window.Worker) {
            me.webWorkersEnabled = true
        } else {
            throw new Error('Your browser does not support Web Workers')
        }

        if (window.SharedWorker) {
            me.sharedWorkersEnabled = true
        }
    }

    /**
     * @param {String|Worker} name
     * @returns {Worker}
     */
    getWorker(name) {
        if (name === 'service') {
            return navigator.serviceWorker?.controller || this.serviceWorker
        }

        return name instanceof Worker ? name : this.workers[name].worker
    }

    /**
     * @param {String} name
     * @returns {Boolean}
     */
    hasWorker(name) {
        return !!this.getWorker(name)
    }

    /**
     * @summary Handles the queuing and processing of DOM update operations.
     *
     * This helper method centralizes the logic for both standard VDOM updates and direct `App.applyDeltas` calls.
     * Its primary purpose is to enforce the **"delayed reply"** pattern:
     * - If the update contains visual changes (deltas), it registers a promise and queues the update for the next animation frame.
     *   The reply to the worker is sent only *after* the main thread has processed the queue, ensuring the DOM is updated.
     * - If the update is a no-op (zero deltas), it sends an immediate reply to avoid unnecessary latency.
     *
     * This method also handles the firing of the `updateVdom` event, which triggers the actual processing in `Main.mjs`.
     *
     * @param {Object} data The message payload from the worker.
     * @param {Object[]} deltas The array of DOM deltas to process.
     * @param {String} replyDest The destination for the reply message (e.g., 'app').
     * @param {Boolean} [forward=false] If true, forwards the original message as the reply (VDOM worker path).
     *                                  If false, constructs a new success reply (App worker path).
     */
    handleDomUpdate(data, deltas, replyDest, forward=false) {
        let me = this;

        if (deltas?.length > 0) {
            me.promiseForwardMessage(data).then(msgData => {
                me.sendMessage(replyDest, forward ? msgData : {action: 'reply', replyId: msgData.id, success: true})
            });

            me.fire('updateVdom', forward ? data : {data, replyId: data.id});
            return
        }

        me.sendMessage(replyDest, forward ? data : {action: 'reply', replyId: data.id, success: true})
    }

    /**
     *
     */
    loadApplication() {
        this.sendMessage('app', {action: 'loadApplication' })
    }

    /**
     * @param {Object} data
     */
    onWorkerConstructed(data) {
        let me = this;

        me.constructedThreads++;

        // To include the main thread as ready, we must wait for activeWorkers + 1
        if (me.constructedThreads === me.activeWorkers + 1) {
            // better safe than sorry => all remotes need to be registered
            NeoConfig.appPath && me.timeout(NeoConfig.loadApplicationDelay).then(() => {
                me.loadApplication()
            })
        }
    }

    /**
     * Handler method for worker error events
     * @param {Object} e
     */
    onWorkerError(e) {
        // starting a worker from a JS module will show JS errors in a correct way
        !hasJsModules && console.log('Worker Error:', e)
    }

    /**
     * Handler method for worker message events.
     *
     * @summary Intercepts and routes messages from workers.
     *
     * This method contains critical routing logic:
     * 1.  **DOM Update Interception:** It catches `updateVdom` actions (from App) and `reply` messages (from VDom)
     *     that contain DOM updates. It normalizes `autoMount` operations into `insertNode` deltas and delegates
     *     them to `handleDomUpdate`.
     * 2.  **Promise Resolution:** It resolves pending promises for `reply` messages (e.g., remote method calls).
     * 3.  **Message Forwarding:** It routes messages between workers (e.g., App -> Data).
     *
     * @param {Object} event
     */
    onWorkerMessage(event) {
        let me       = this,
            {data}   = event,
            transfer = null,
            promise;

        const {action, destination: dest, replyId} = data;

        me.fire('message:'+action, data);

        if (action === 'updateVdom') {
            data.replyId = data.id;
            me.handleDomUpdate(data, data.deltas, data.origin, false);
            return
        }

        if (action === 'reply') {
            promise = me.promises[replyId];

            if (!promise) {
                let payload = data.data;

                if (payload) {
                    if (payload.autoMount || payload.updateVdom) {
                        let deltas = payload.deltas;

                        if (payload.autoMount) {
                            deltas = [{
                                action   : 'insertNode',
                                index    : payload.parentIndex,
                                outerHTML: payload.outerHTML,
                                parentId : payload.parentId,
                                vnode    : payload.vnode
                            }];

                            payload.deltas = deltas
                        }

                        me.handleDomUpdate(data, deltas, dest, true)
                    } else {
                        me.sendMessage(dest, data)
                    }
                }
            } else {
                if (dest === 'main') {
                    data = data.data
                }

                if (data) {
                    promise[data.reject ? 'reject' : 'resolve'](data);
                    delete me.promises[replyId]
                }
            }
        }

        if (dest !== 'main' && dest !== me.windowId && action !== 'reply') {
            if (data.transfer) {
                transfer = [data.transfer]
            }

            me.promiseMessage(dest, data, transfer).then(response => {
                me.sendMessage(response.destination, response)
            }).catch(err => {
                me.sendMessage(data.origin, {
                    action : 'reply',
                    reject : true,
                    replyId: data.id,
                    error  : err.message
                })
            })
        }

        // only needed for SharedWorkers
        else if ((dest === 'main' || dest === me.windowId) && action === 'registerAppName') {
            let {appName} = data;

            me.appNames.push(appName);

            me.broadcast({action: 'registerApp', appName})
        }

        else if ((dest === 'main' || dest === me.windowId) && action === 'remoteMethod') {
            me.onRemoteMethod(data)
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.replyId
     * @returns {Promise<any>}
     */
    promiseForwardMessage(data) {
        return new Promise((resolve, reject) => {
            this.promises[data.replyId] = {data, reject, resolve}
        })
    }

    /**
     * @param {String} dest app, canvas, data or vdom
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Promise<any>}
     */
    promiseMessage(dest, opts, transfer) {
        let me = this;

        return new Promise((resolve, reject) => {
            let message = me.sendMessage(dest, opts, transfer),
                msgId;

            if (!message) {
                reject(new Error(me.stopCommunication ? 'Communication is stopped.' : `Target worker '${dest}' does not exist.`));
                return
            }

            msgId = message.id;

            me.promises[msgId] = {reject, resolve}
        })
    }

    /**
     * @param {String} replyId
     */
    resolveDomOperationPromise(replyId) {
        if (replyId) {
            let {promises} = this,
                promise    = promises[replyId];

            if (promise) {
                promise.resolve(promise.data);
                delete promises[replyId]
            }
        }
    }

    /**
     * @param {String} dest app, canvas, data or vdom
     * @param {Object} opts configs for Neo.worker.Message
     * @param {Array} [transfer] An optional array of Transferable objects to transfer ownership of.
     * If the ownership of an object is transferred, it becomes unusable (neutered) in the context it was sent from
     * and becomes available only to the worker it was sent to.
     * @returns {Neo.worker.Message|null}
     * @protected
     */
    sendMessage(dest, opts, transfer) {
        let me = this,
            message, worker;

        if (!me.stopCommunication) {
            if (opts.channelPort) {
                worker = opts.channelPort;
                delete opts.channelPort
            } else {
                worker = me.getWorker(dest)
            }

            if (worker) {
                opts.destination = dest;
                opts.windowId ??= me.windowId;

                message = new _Message_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](opts);

                (worker.port ? worker.port : worker).postMessage(message, transfer);
                return message
            }
        }

        return null
    }

    /**
     * Initiates a global Neo.config change from the Main Thread.
     *
     * This method acts as a proxy, routing the config change request to the App Worker.
     * This design centralizes the complex multi-threaded and multi-window synchronization
     * logic within the App Worker's `setGlobalConfig` method.
     *
     * Developers should typically use `Neo.setGlobalConfig(config)` directly,
     * which will correctly resolve to this proxy when called from the Main Thread.
     *
     * @param {Object} config The partial or full Neo.config object with changes to apply.
     */
    setGlobalConfig(config) {
        // Remotely calls the App Worker's setGlobalConfig method.
        // This ensures all global config changes are processed through the App Worker
        // which contains the centralized multi-window synchronization logic.
        Neo.worker.App.setGlobalConfig(config)
    }

    /**
     * Change Neo.config globally from a worker
     * @param {Object}  data
     * @param {Boolean} data.broadcast
     * @param {Object}  data.config
     * @param {String}  [data.excludeOrigin]
     */
    setNeoConfig({broadcast, config, excludeOrigin}) {
        let me = this;

        Neo.merge(Neo.config, config);

        me.fire('neoConfigChange', config);

        broadcast && me.broadcast({action: 'setNeoConfig', config}, excludeOrigin)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Manager));


/***/ },

/***/ "./src/worker/Message.mjs"
/*!********************************!*\
  !*** ./src/worker/Message.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/IdGenerator.mjs */ "./src/core/IdGenerator.mjs");


/**
 * A wrapper for worker post messages sent between the App, Data, VDom worker & the main thread.
 * You can add optional params as needed.
 * @class Neo.worker.Message
 */
class Message {
    /**
     * @param {Object} config
     */
    constructor(config) {
        /**
         * @member {String} action
         */

        /**
         * @member {String} destination='main'
         */

        /**
         * @member {String} id=IdGenerator.getId(Neo.workerId)
         */

        /**
         * @member {String} origin=Neo.workerId
         */

        config.destination = config.destination || 'main';
        config.id          = config.id          || _core_IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getId(Neo.workerId);
        config.origin      = config.origin      || Neo.workerId;

        Object.assign(this, config)
    }
}

const ns = Neo.ns('Neo.worker', true);
ns['Message'] = Message;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Message);


/***/ },

/***/ "./src/worker/mixin/RemoteMethodAccess.mjs"
/*!*************************************************!*\
  !*** ./src/worker/mixin/RemoteMethodAccess.mjs ***!
  \*************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Mixin to enable and handle remote method access across threads (Workers and Main Threads).
 *
 * **What is Remote Method Access?**
 * This pattern allows code running in one thread (e.g., an App Worker) to execute a method located in another thread
 * (e.g., the Main Thread) as if it were a local function call. Since the threads are isolated, the execution is asynchronous:
 * the caller invokes the method and awaits a `Promise` that resolves with the return value from the other thread.
 *
 * **Crucial Constraints:**
 * - **Serialization:** All arguments passed to the method and the return value sent back MUST be **JSON-serializable**.
 *   This means you cannot pass DOM nodes, DOM Events, or complex class instances directly.
 * - **Transferables:** `ArrayBuffer`, `MessagePort` and `OffscreenCanvas` can be transferred (zero-copy) if explicitly handled.
 *
 * This mixin is the core mechanism for cross-thread communication in Neo.mjs. It is consumed by:
 * - `Neo.worker.Base` (App, Data, VDom, Task, Canvas workers)
 * - `Neo.worker.ServiceBase` (Service Worker)
 * - `Neo.worker.Manager` (Main Thread)
 *
 * This broad usage ensures that **all** connected realms can communicate with each other. This includes
 * Worker-to-Worker, Worker-to-Main, and even Main-to-Worker method calls.
 *
 * **Key Responsibilities:**
 * 1. **Registration:** Registers methods defined in the `remote` config as callable endpoints.
 * 2. **Proxy Generation:** Creates local proxy functions that send messages to the target thread when called.
 * 3. **Routing:** Ensures messages are sent to the correct `windowId` in a multi-window environment.
 * 4. **Interception:** Supports the `interceptRemotes` config to intercept calls before they are executed.
 *    This is particularly critical for Main Thread Addons (Singletons). Calls arriving before an addon is
 *    `isReady` (e.g., waiting for external libraries like Monaco Editor or Google Maps to load) can be
 *    intercepted and queued, ensuring they execute only once the singleton is fully functional.
 *
 * **Synchronous vs. Asynchronous:**
 * - **Definition:** Remote methods can be defined as synchronous or asynchronous functions in their origin class.
 * - **Execution:** When called from a different thread, the execution is **ALWAYS asynchronous**. The proxy
 *   function returns a `Promise` that resolves with the return value of the remote method. This is true even if
 *   the original method is synchronous.
 *
 * **Namespace-Driven Access:**
 * Remote access is resolved via namespaces. The calling thread must know the full class name (e.g., `Neo.main.addon.LocalStorage`)
 * to invoke the method.
 *
 * **Architectural Note:**
 * To support the distributed multi-window architecture where one App Worker serves multiple connected Main Threads,
 * **the first parameter of any remote method MUST be an object containing `windowId`**.
 * This allows the sender to attach the `windowId` (and other metadata) to the payload, ensuring the message
 * is routed to the correct browser window context. Calls passing arrays or primitive values as the first argument
 * cannot be reliably routed in a shared-worker environment.
 *
 * @example
 * // 1. Usage in Neo.component.wrapper.MonacoEditor
 * // Calls the remote method 'setTheme' on the Main Thread addon 'Neo.main.addon.MonacoEditor'
 * Neo.main.addon.MonacoEditor.setTheme({
 *     id      : me.id,
 *     value   : 'vs-dark',
 *     windowId: me.windowId // Critical for routing!
 * }).then(() => {
 *     console.log('Theme updated');
 * });
 *
 * @example
 * // 2. Usage in a Controller accessing LocalStorage
 * // Calls 'readLocalStorageItem' on the Main Thread addon 'Neo.main.addon.LocalStorage'
 * const value = await Neo.main.addon.LocalStorage.readLocalStorageItem({
 *     key     : 'mySettings',
 *     windowId: this.windowId
 * });
 *
 * @class Neo.worker.mixin.RemoteMethodAccess
 * @extends Neo.core.Base
 * @see Neo.worker.Base
 * @see Neo.worker.ServiceBase
 * @see Neo.worker.Manager
 * @see Neo.main.addon.Base
 * @see Neo.main.addon.MonacoEditor
 * @see Neo.main.addon.LocalStorage
 */
class RemoteMethodAccess extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.worker.mixin.RemoteMethodAccess'
         * @protected
         */
        className: 'Neo.worker.mixin.RemoteMethodAccess'
    }

    /**
     * Helper method to copy routing information (appName, port, windowId) from a source message to a target message.
     * This is crucial in SharedWorker environments to maintain the context of the original sender when formulating a reply or forwarding a message.
     *
     * @param {Object} source The source message object containing routing metadata.
     * @param {Object} target The target message object to populate with routing metadata.
     */
    assignPort(source, target) {
        if (source) {
            const {appName, port, windowId} = source;
            Object.assign(target, {appName, port, windowId})
        }
    }

    /**
     * Generates a proxy function for a remote method.
     * When this proxy is called, it sends a message to the target thread to execute the real method.
     *
     * It handles:
     * 1. Constructing the message payload with `action: 'remoteMethod'`.
     * 2. determining the correct destination (e.g., using `windowId` from the data if targeting 'main').
     * 3. Preserving routing context in SharedWorker environments.
     * 4. Returning a Promise that resolves with the remote method's result.
     *
     * @param {Object} remote The remote configuration object.
     * @param {String} method The name of the method to generate a proxy for.
     * @returns {function(*=, *=): Promise<any>} The proxy function.
     */
    generateRemote(remote, method) {
        let me       = this,
            {origin} = remote;

        return function(data, buffer) {
            let opts = {
                action         : 'remoteMethod',
                data,
                destination    : origin,
                remoteClassName: remote.className,
                remoteMethod   : method
            };

            if (origin === 'main' && data?.windowId) {
                opts.destination = data.windowId
            }

            me.isSharedWorker && me.assignPort(data, opts);

            return me.promiseMessage(opts.destination, opts, buffer)
        }
    }

    /**
     * Handles the 'registerRemote' message action.
     * It iterates over the list of methods provided in the remote config and generates local proxy functions
     * for them in the appropriate namespace. This makes the remote methods available to be called as if they were local.
     *
     * @param {Object} remote The remote configuration object containing className and methods list.
     */
    onRegisterRemote(remote) {
        if (remote.destination === Neo.workerId) {
            let me                   = this,
                {className, methods} = remote,
                pkg                  = Neo.ns(className, true);

            methods.forEach(method => {
                if (remote.origin !== 'main' && pkg[method]) {
                    throw new Error('Duplicate remote method definition ' + className + '.' + method)
                }

                pkg[method] ??= me.generateRemote(remote, method)
            });

            if (remote.id) {
                me.resolve(remote, true)
            }
        }
    }

    /**
     * Handles the execution of a requested remote method.
     * Triggered when a worker receives a message with `action: 'remoteMethod'`.
     *
     * This method:
     * 1. Resolves the target class and method from the namespace.
     * 2. Checks if the call should be intercepted (e.g., if the target singleton is not ready).
     * 3. Executes the method (handling both sync and async results).
     * 4. Catches errors and sends a rejection reply.
     * 5. Resolves success and sends a reply with the result.
     *
     * @param {Object} msg The message payload containing remoteClassName, remoteMethod, and data.
     */
    onRemoteMethod(msg) {
        let me  = this,
            pkg = Neo.ns(msg.remoteClassName),
            out, method;

        if (!pkg) {
            throw new Error('Invalid remote namespace "' + msg.remoteClassName + '"')
        }

        method = pkg[msg.remoteMethod];

        if (!method) {
            throw new Error('Invalid remote method name "' + msg.remoteMethod + '" in namespace "' + msg.remoteClassName + '"')
        }

        // Check for interception
        if (!pkg.isReady && pkg.interceptRemotes?.includes(msg.remoteMethod)) {
            out = pkg.onInterceptRemotes(msg);
        } else if (Array.isArray(msg.data)) {
            out = method.call(pkg, ...msg.data)
        } else {
            out = method.call(pkg, msg.data)
        }

        if (Neo.isPromise(out)) {
            out
                /*
                 * Intended logic:
                 * If the code of a remote method fails, it would not show any errors inside the console,
                 * so we want to manually log the error for debugging.
                 * Rejecting the Promise gives us the chance to recover.
                 *
                 * Example:
                 * Neo.vdom.Helper.update(opts).catch(err => {
                 *     me.isVdomUpdating = false;
                 *     reject?.()
                 * }).then(data => {...})
                 */
                .catch(err => {console.error(err); me.reject(msg, err)})
                .then(data => {me.resolve(msg, data)})
        } else {
            me.resolve(msg, out)
        }
    }

    /**
     * Sends a rejection reply back to the caller of a remote method.
     * Used when the execution of the remote method fails or throws an error.
     * It ensures the reply is routed back to the correct origin (windowId or worker).
     *
     * @param {Object} msg The original message object.
     * @param {Object} data The error data to send back.
     */
    reject(msg, data) {
        let me = this,

        opts = {
            action : 'reply',
            data,
            reject : true,
            replyId: msg.id
        };

        if (me.isSharedWorker) {
            me.assignPort(msg, opts);

            if (msg.origin === 'main' && opts.windowId) {
                msg.origin = opts.windowId
            }
        }

        me.sendMessage(msg.origin, opts)
    }

    /**
     * Sends a success reply back to the caller of a remote method.
     * Used when the remote method executes successfully.
     * It handles the transfer of transferable objects (like ArrayBuffers) and ensures correct routing.
     *
     * @param {Object} msg The original message object.
     * @param {Object} data The result data to send back.
     */
    resolve(msg, data) {
        let me       = this,
            transfer = null,
            opts;

        if (Neo.isObject(data) && Array.isArray(data.transfer)) {
            transfer = data.transfer;
            data     = data.result || data
        }

        opts = {
            action : 'reply',
            data,
            replyId: msg.id
        };

        if (me.isSharedWorker) {
            me.assignPort(msg, opts);

            if (msg.origin === 'main' && opts.windowId) {
                msg.origin = opts.windowId
            }
        }

        me.sendMessage(msg.origin, opts, transfer)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RemoteMethodAccess));


/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "chunks/main/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "neo.mjs:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/Main.mjs ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Neo.mjs */ "./src/Neo.mjs");
/* harmony import */ var _core_export_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/_export.mjs */ "./src/core/_export.mjs");
/* harmony import */ var _manager_ClassHierarchy_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./manager/ClassHierarchy.mjs */ "./src/manager/ClassHierarchy.mjs");
/* harmony import */ var _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./main/DomAccess.mjs */ "./src/main/DomAccess.mjs");
/* harmony import */ var _main_DeltaUpdates_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./main/DeltaUpdates.mjs */ "./src/main/DeltaUpdates.mjs");
/* harmony import */ var _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./main/DomEvents.mjs */ "./src/main/DomEvents.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./worker/Manager.mjs */ "./src/worker/Manager.mjs");



 // has to get imported before DeltaUpdates





/**
 * @class Neo.Main
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 * @singleton
 */
class Main extends _core_export_mjs__WEBPACK_IMPORTED_MODULE_1__.Base {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.Main'
         * @protected
         */
        className: 'Neo.Main',
        /**
         * @member {String} mode='read'
         * @protected
         */
        mode: 'read',
        /**
         * @member {Object} openWindows={}
         * @protected
         */
        openWindows: {},
        /**
         * @member {Array} readQueue=[]
         * @protected
         */
        readQueue: [],
        /**
         * Remote method access for other workers
         * @member {Object} remote
         * @protected
         */
        remote: {
            app: [
                'alert',
                'editRoute',
                'getByPath',
                'getWindowData',
                'importAddon',
                'log',
                'redirectTo',
                'reloadWindow',
                'setNeoConfig',
                'setRoute',
                'windowClose',
                'windowCloseAll',
                'windowMoveTo',
                'windowOpen',
                'windowResizeTo'
            ]
        },
        /**
         * @member {Boolean} running=false
         * @protected
         */
        running: false,
        /**
         * @member {Boolean} showFps=false
         */
        showFps: false,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Number} timeLimit=15
         */
        timeLimit: 15,
        /**
         * should be dev only
         * @member {Number} totalFrameCount=0
         * @protected
         */
        totalFrameCount: 0,
        /**
         * @member {Array} writeQueue=[]
         * @protected
         */
        writeQueue: []
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].on({
            'automount' : me.onRender,
            'updateVdom': me.onUpdateVdom,
            scope       : me
        });

        _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].on('domContentLoaded', me.onDomContentLoaded, me);

        if (document.readyState !== 'loading') {
            _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].onDomContentLoaded()
        }
    }

    /**
     * Workers can not trigger alert(), so we need remote method access.
     * @param {Object} data
     * @param {String} data.message
     */
    alert(data) {
        alert(data.message)
    }

    /**
     * Edit the location.hash value
     * A value of null will remove the given key.
     * @param {Object} data
     */
    editRoute(data) {
        let hashObj = _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].parseHash(window.location.hash.substr(1)),
            hashArr = [];

        if (typeof data === 'string') {
            data = _main_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].parseHash(data)
        }

        Object.assign(hashObj, data);

        Object.entries(hashObj).forEach(([key, value]) => {
            if (value !== null) {
                hashArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(value))
            }
        });

        window.location.hash = hashArr.join('&')
    }

    /**
     * Request specific accessible window attributes by path into the app worker.
     * Keep in mind that this excludes anything DOM related or instances.
     * In case your path matches a method, you can also pass params for it.
     * @example:
     *     Neo.Main.getByPath({path: 'navigator.language', windowId}).then(data => {})
     * @example:
     *     Neo.Main.getByPath({path: 'CSS.supports', params: ['display: flex'], windowId}).then(data => {})
     * @param {Object} data
     * @param {Array}  data.params=[]
     * @param {String} data.path
     * @returns {*}
     */
    getByPath({params=[], path}) {
        let target = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].nsWithArrays(path);
        return _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(target) ? target(...params) : target
    }

    /**
     * window.screen is not spreadable
     * @returns {Object}
     */
    getWindowData() {
        let win      = window,
            {screen} = win;

        return {
            innerHeight    : win.innerHeight,
            innerWidth     : win.innerWidth,
            mozInnerScreenX: win.mozInnerScreenX, // Firefox specific
            mozInnerScreenY: win.mozInnerScreenY, // Firefox specific
            outerHeight    : win.outerHeight,
            outerWidth     : win.outerWidth,
            screen: {
                availHeight: screen.availHeight,
                availLeft  : screen.availLeft,
                availTop   : screen.availTop,
                availWidth : screen.availWidth,
                colorDepth : screen.colorDepth,
                height     : screen.height,
                orientation: {angle: screen.orientation?.angle, type: screen.orientation?.type},
                pixelDepth : screen.pixelDepth,
                width      : screen.width
            },
            screenLeft: win.screenLeft,
            screenTop : win.screenTop
        }
    }

    /**
     * Import main thread addons at run-time from within the app worker
     * @param {Object} data
     * @param {String} data.name
     * @returns {Boolean}
     */
    async importAddon(data) {
        let {name} = data,
            module;

        if (name.startsWith('WS/')) {
            module = await __webpack_require__("./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$")(`./${name.substring(3)}.mjs`)
        } else {
            module = await __webpack_require__("./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$")(`./${name}.mjs`)
        }

        this.registerAddon(module.default);
        await this.timeout(20); // Wait until remotes are registered

        return true
    }

    /**
     * Remote console access to main threads.
     * You can use appName or windowId to target specific windows.
     * @param {Object} data
     * @param {String} [data.appName]
     * @param {String} data.value
     * @param {String} [data.method] defaults to 'log'
     * @param {Number} [data.windowId]
     * @returns {Boolean}
     */
    log(data) {
        console[data.method || 'log'](data.value);
        return true
    }

    /**
     *
     */
    async onDomContentLoaded() {
        let me       = this,
            {config} = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            imports  = [],
            {environment, mainThreadAddons, useServiceWorker} = config,
            modules;

        me.addon = {};

        if (window.__NEO_SSR__) {
            config.useSSR = true;
            let module = await __webpack_require__.e(/*! import() */ "src_main_addon_ServerSideRendering_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./main/addon/ServerSideRendering.mjs */ "./src/main/addon/ServerSideRendering.mjs"));
            me.registerAddon(module.default)
        }

        _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].onDomContentLoaded();

        // Intended for the online examples where we need an easy way to add GA to every generated app
        if (config.useGoogleAnalytics && !mainThreadAddons.includes('AnalyticsByGoogle')) {
            mainThreadAddons.push('AnalyticsByGoogle')
        }

        if ((
                useServiceWorker === true ||
                useServiceWorker === environment ||
                (useServiceWorker === 'dist/production' && environment === 'dist/esm')
            ) &&
            !mainThreadAddons.includes('ServiceWorker')
        ) {
            mainThreadAddons.push('ServiceWorker')
        }

        mainThreadAddons.forEach(addon => {
            if (addon.startsWith('WS/')) {
                imports.push(__webpack_require__("./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$")(`./${addon.substring(3)}.mjs`))
            } else {
                imports.push(__webpack_require__("./src/main/addon lazy recursive ^\\.\\/.*\\.mjs$")(`./${addon}.mjs`))
            }
        });

        modules = await Promise.all(imports);

        const instances = modules.map(module => me.registerAddon(module.default));

        await Promise.all(instances.map(instance => instance.remotesReady()));

        await me.remotesReady();

        _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].onWorkerConstructed({
            origin: 'main'
        })
    }

    /**
     * @param {Object} data
     */
    onRender(data) {
        data.data.replyId = data.replyId;
        this.queueWrite(data.data)
    }

    /**
     * @param {Object} data
     */
    onUpdateVdom(data) {
        data.data.replyId = data.replyId;
        this.queueWrite(data.data)
    }

    /**
     * @param {Object[]} queue
     * @param {Date} start
     * @returns {Number}
     * @protected
     */
    processQueue(queue, start) {
        let me     = this,
            {mode} = me,
            limit  = me.timeLimit,
            operation;

        while (operation = queue.shift()) {
            if (new Date() - start > limit) {
                queue.unshift(operation);
                return requestAnimationFrame(me.renderFrame.bind(me))
            } else {
                if (mode === 'read') {
                    _main_DomAccess_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].read(operation)
                } else {
                    _main_DeltaUpdates_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].update(operation)
                }

                _worker_Manager_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].resolveDomOperationPromise(operation.replyId)
            }
        }
    }

    /**
     * @param {Object} data
     * @protected
     */
    queueRead(data) {
        let me = this;
        me.readQueue.push(data);

        if (!me.running) {
            me.running = true;
            requestAnimationFrame(me.renderFrame.bind(me))
        }
    }

    /**
     * @param data
     * @protected
     */
    queueWrite(data) {
        let me = this;
        me.writeQueue.push(data);

        if (!me.running) {
            me.running = true;
            requestAnimationFrame(me.renderFrame.bind(me))
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.url
     */
    redirectTo(data) {
        window.location.href = data.url
    }

    /**
     * Helper method to register main thread addons
     * @param {Neo.core.Base} addon Can either be a neo class or instance
     * @returns {Neo.core.Base} The addon instance
     */
    registerAddon(addon) {
        if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].typeOf(addon) === 'NeoClass') {
            // Addons could get imported multiple times. Ensure to only create an instance once.
            if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].typeOf(_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].ns(addon.prototype.className)) !== 'NeoInstance') {
                addon = _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].create(addon);

                // Main thread addons need to get registered as singletons inside the neo namespace
                _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].applyToGlobalNs(addon)
            }
        }

        this.addon[addon.constructor.name] = addon;

        return addon
    }

    /**
     * @param {Object} data
     */
    reloadWindow(data) {
        location.reload()
    }

    /**
     * Triggers the different DOM operation queues
     * @protected
     */
    renderFrame() {
        let me      = this,
            read    = me.readQueue,
            write   = me.writeQueue,
            reading = me.mode === 'read',
            start   = new Date();

        if (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config.logDeltaUpdates) {
            me.totalFrameCount++;
            console.log('Total Frames: ' + me.totalFrameCount)
        }

        if (reading || !write.length) {
            me.mode = 'read';
            if (me.processQueue(read, start)) {
                return
            }
        }

        if (write.length) {
            me.mode = 'write';
            if (me.processQueue(write, start)) {
                return
            }
        }

        me.running = false
    }

    /**
     * Change a Neo.config from the app worker
     * @param {Object} data
     * @param {String} data.key
     * @param {*} data.value
     */
    setNeoConfig(data) {
        let {key, value} = data;

        _Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].config[key] = data.value;

        key === 'renderCountDeltas' && _main_DeltaUpdates_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].set({[key]: value})
    }

    /**
     * Change the location.hash value
     * @param {Object} data
     * @param {String} data.value
     */
    setRoute(data) {
        window.location.hash = data.value
    }

    /**
     * Closes popup windows
     * @param {Object} data
     * @param {String|String[]} data.names
     */
    windowClose(data) {
        if (!Array.isArray(data.names)) {
            data.names = [data.names]
        }

        data.names.forEach(name => {
            this.openWindows[name]?.win.close();
            delete this.openWindows[name]
        })
    }

    /**
     * Closes all popup windows
     * @param {Object} data
     */
    windowCloseAll(data) {
        Object.values(this.openWindows).forEach(obj => {
            obj.win.close()
        });

        this.openWindows = {}
    }

    /**
     * Move a popup window
     * @param {Object} data
     * @param {String} data.windowName
     * @param {String} data.x
     * @param {String} data.y
     */
    windowMoveTo(data) {
        this.openWindows[data.windowName]?.win.moveTo(data.x, data.y)
    }

    /**
     * Open a new popup window and return true if successful
     * @param {Object}  data
     * @param {String}  data.url
     * @param {Boolean} [data.useTotalHeight=true] Using this flag will set outerHeight to innerHeight, ignoring header tools
     * @param {String}  data.windowFeatures
     * @param {String}  data.windowName
     * @return {Boolean}
     */
    windowOpen({url, useTotalHeight=true, windowFeatures, windowName}) {
        let existingWin  = this.openWindows[windowName],
            targetName;

        if (existingWin && !existingWin.win.closed) {
            targetName = existingWin.targetName
        } else {
            targetName = crypto.randomUUID()
        }

        let openedWindow = window.open(url, targetName, windowFeatures),
            success      = !!openedWindow;

        if (success) {
            if (useTotalHeight) {
                openedWindow.resizeTo(openedWindow.outerWidth, openedWindow.innerHeight)
            }

            this.openWindows[windowName] = {targetName, win: openedWindow}
        }

        return success
    }

    /**
     * Move a popup window
     * @param {Object} data
     * @param {Number} [data.height]
     * @param {Number} [data.width]
     * @param {String} data.windowName
     */
    windowResizeTo(data) {
        let win    = this.openWindows[data.windowName]?.win,
            height = data.height || win.outerHeight,
            width  = data.width  || win.outerWidth;

        win.resizeTo(width, height)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Neo_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].setupClass(Main));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOENBQThDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUE4QztBQUNyRSxDQUFDOztB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QUFRO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxnREFBRyxpQkFBaUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvRGVmYXVsdENvbmZpZy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9OZW8ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29sbGVjdGlvbi9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbGxlY3Rpb24vRmlsdGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbGxlY3Rpb24vU29ydGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0NvbXBhcmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9Db25maWcubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9Db25maWdTeW1ib2xzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvRWZmZWN0TWFuYWdlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0lkR2VuZXJhdG9yLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvT2JzZXJ2YWJsZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL1V0aWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9fZXhwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vRGVsdGFVcGRhdGVzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vRG9tQWNjZXNzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vRG9tRXZlbnRzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21haW4vRG9tVXRpbHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9hZGRvbi8gbGF6eSBeXFwuXFwvLipcXC5tanMkIHN0cmljdCBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFpbi9taXhpbi9Ub3VjaERvbUV2ZW50cy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9DbGFzc0hpZXJhcmNoeS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0FycmF5Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvRnVuY3Rpb24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9Mb2dnZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9SZWN0YW5nbGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9TdHJpbmcubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdmRvbS9kb21Db25zdGFudHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvd29ya2VyL01hbmFnZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvd29ya2VyL01lc3NhZ2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvd29ya2VyL21peGluL1JlbW90ZU1ldGhvZEFjY2Vzcy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvZ2V0IGphdmFzY3JpcHQgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vbmVvLm1qcy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2xvYWQgc2NyaXB0Iiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9uZW8ubWpzL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL25lby5tanMvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9NYWluLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBOZW8gPSBnbG9iYWxUaGlzLk5lbyB8fCB7fTtcblxuTmVvLmNvbmZpZyA9IE5lby5jb25maWcgfHwge307XG5cbi8qKlxuICogQ29uZmlnIG9iamVjdCBmb3IgdGhlIG5lby5tanMgZnJhbWV3b3JrIHdoaWNoIHdpbGwgZ2V0IHBhc3NlZCB0byBhbGwgd29ya2Vyc1xuICogWW91IGNhbiBjaGFuZ2UgdGhlIGNvbmZpZ3MsIGUuZy4gaW5zaWRlIHRoZSBpbmRleC5odG1sIG9mIHlvdXIgYXBwXG4gKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICogQG5hbWUgY29uZmlnXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xuY29uc3QgRGVmYXVsdENvbmZpZyA9IHtcbiAgICAvKipcbiAgICAgKiB0cnVlIHdpbGwgYXBwbHkgJ25lby1ib2R5JyB0byB0aGUgZG9jdW1lbnQuYm9keSBjbGFzc0xpc3RcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmFwcGx5Qm9keUNsc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgLyoqXG4gICAgICogdHJ1ZSB3aWxsIGFwcGx5ICdwb3NpdGlvbjogZml4ZWQnIHRvIHRoZSBodG1sIHRhZyBpdHNlbGZcbiAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy82NDI5XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5hcHBseUZpeGVkUG9zaXRpb25Ub0h0bWxUYWdcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgYXBwbHlGaXhlZFBvc2l0aW9uVG9IdG1sVGFnOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhdGggdG8geW91ciBhcHAubWpzIGZpbGUuIFlvdSBjYW4gY3JlYXRlIG11bHRpcGxlIGFwcHMgdGhlcmUgaWYgbmVlZGVkLlxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuYXBwUGF0aFxuICAgICAqIEB0eXBlIFN0cmluZ3xudWxsXG4gICAgICovXG4gICAgYXBwUGF0aDogbnVsbCxcbiAgICAvKipcbiAgICAgKiBQYXRoIHRvIHRoZSBuZW8ubWpzIGRpcmVjdG9yeVxuICAgICAqIEBkZWZhdWx0ICcuLydcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuYmFzZVBhdGhcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBiYXNlUGF0aDogJy4vJyxcbiAgICAvKipcbiAgICAgKiBQYXNzIGEgdG9rZW4gaW4gY2FzZSB5b3UgYXJlIHVzaW5nIHRoZSBDZXNpdW1KUyBtYWluIHRocmVhZCBhZGRvblxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vYmxvYi9kZXYvc3JjL21haW4vYWRkb24vQ2VzaXVtSlMubWpzXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmNlc2l1bUpzVG9rZW5cbiAgICAgKiBAdHlwZSBTdHJpbmd8bnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgY29uZmlnIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhlIGNvbXBvbmVudCBsb2dnaW5nIHVzaW5nIEN0cmwtUmlnaHQtQ2xpY2tcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmVuYWJsZUNvbXBvbmVudExvZ2dlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBlbmFibGVDb21wb25lbnRMb2dnZXI6IHRydWUsXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgdG8gZW5hYmxlIHV0aWwuTG9nZ2VyIChOZW8ubG9nKCkpIGJhc2VkIGxvZ3MgaW4gcHJvZHVjdGlvblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmVuYWJsZUxvZ3NJblByb2R1Y3Rpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgZW5hYmxlTG9nc0luUHJvZHVjdGlvbjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFZhbGlkIHZhbHVlczogJ2RldmVsb3BtZW50JywgJ2Rpc3QvZGV2ZWxvcG1lbnQnLCAnZGlzdC9wcm9kdWN0aW9uJ1xuICAgICAqIFRoaXMgY29uZmlnIHdpbGwgZ2V0IGF1dG8tZ2VuZXJhdGVkXG4gICAgICogQGRlZmF1bHQgJ2Rpc3QvcHJvZHVjdGlvbidcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZW52aXJvbm1lbnRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBlbnZpcm9ubWVudDogJ2Rpc3QvcHJvZHVjdGlvbicsXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3UgYXJlIHVzaW5nIHRoZSBHb29nbGVNYXBzIG1haW4gdGhyZWFkIGFkZG9uLCB5b3UgY2FuIHBhc3MgdGhlIEFQSSBrZXkgaGVyZS5cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZ29vZ2xlTWFwc0FwaUtleVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3UgYXJlIHVzaW5nIHRoZSBHb29nbGVBbmFseXRpY3MgbWFpbiB0aHJlYWQgYWRkb24gb3IgdXNlR29vZ2xlQW5hbHl0aWNzOiB0cnVlLFxuICAgICAqIHlvdSBjYW4gY2hhbmdlIHRoZSBndGFnIGlkIGhlcmUuIFJlcXVpcmVkIGZvciB0aGUgb25saW5lIGV4YW1wbGVzIChnaCBwYWdlcylcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcuZ3RhZ0lkXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBydW5uaW5nIG9uIGh0dHBzOi8vbmVvbWpzLmdpdGh1Yi5pby9wYWdlcy9cbiAgICAgKiA9PiB0byB1c2UgbG9jYWwgaW1hZ2VzIHBhdGhzIGluc3RlYWQgb2YgcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmlzR2l0SHViUGFnZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgaXNHaXRIdWJQYWdlczogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBGbGFnIGZvciBydW5uaW5nIE5lby5tanMgaW5zaWRlIHRoZSBtaWRkbGV3YXJlIE5vZGUuanMgcHJvY2Vzcy5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5pc01pZGRsZXdhcmVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgaXNNaWRkbGV3YXJlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBkZWxheSBpbiBtcyBmb3IgdGhlIHdvcmtlci5NYW5hZ2VyOmxvYWRBcHBsaWNhdGlvbigpIGNhbGxcbiAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5sb2FkQXBwbGljYXRpb25EZWxheVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGxvYWRBcHBsaWNhdGlvbkRlbGF5OiAyMCxcbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IEludGwuRGF0ZVRpbWVGb3JtYXQsIGZvciBkZXRhaWxzIHRha2UgYSBsb29rIGF0OlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAgICogQGRlZmF1bHQgJ2RlZmF1bHQnXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvY2FsZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGxvY2FsZTogJ2RlZmF1bHQnLFxuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBsb2cgdGhlIGRlbHRhIHVwZGF0ZXMgaW5zaWRlIHRoZSBtYWluIHRocmVhZChzKSBhcyB3ZWxsIGFzIHRoZSByZXF1ZXN0QW5pbWF0aW9uIGZyYW1lc1xuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLmxvZ0RlbHRhVXBkYXRlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBsb2dEZWx0YVVwZGF0ZXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIHRydWUgd2lsbCBsb2cgY29uc29sZSB3YXJuaW5ncywgaW4gY2FzZSBhIGNvbXBvbmVudCB0cmllcyB0byB1cGRhdGUoKSB3aGlsZSBhIHBhcmVudCB1cGRhdGUgaXMgcnVubmluZy5cbiAgICAgKiBBIHBhcmVudCB1cGRhdGUgcmVzdWx0cyBpbiBhIHNob3J0IGRlbGF5LCBzbyB5b3UgbWlnaHQgd2FudCB0byByZXNvbHZlIHRoZXNlIGNvbGxpc2lvbnMuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgbG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFkZCBhZGRvbnMgZm9yIHRoZSBtYWluIHRocmVhZFxuICAgICAqIC4vc3JjL21haW4vYWRkb24vIGNvbnRhaW5zIGFsbCBmcmFtZXdvcmsgcmVsYXRlZCBvcHRpb25zLlxuICAgICAqIFlvdSBjYW4gYWxzbyBjcmVhdGUgeW91ciBvd24gYWRkb25zIHdpdGhpbiB5b3VyIHdvcmtzcGFjZSBzY29wZS4gTWFrZSBzdXJlIHRvIHB1dCB0aGVtIGluc2lkZSAnc3JjL21haW4vYWRkb24vJ1xuICAgICAqIGFuZCBwcmVmaXggdGhlbSB3aXRoICdXUy8nIGluc2lkZSB5b3VyIG5lby1jb25maWcuanNvbiBmaWxlLlxuICAgICAqIEV4YW1wbGU6IFsnRHJhZ0Ryb3AnLCAnU3R5bGVzaGVldCcsICdXUy9NeUFkZG9uJ11cbiAgICAgKiBAZGVmYXVsdCBbJ0RyYWdEcm9wJywgJ05hdmlnYXRvcicsICdTdHlsZXNoZWV0J11cbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubWFpblRocmVhZEFkZG9uc1xuICAgICAqIEB0eXBlIFN0cmluZ1tdXG4gICAgICovXG4gICAgbWFpblRocmVhZEFkZG9uczogWydEcmFnRHJvcCcsICdOYXZpZ2F0b3InLCAnU3R5bGVzaGVldCddLFxuICAgIC8qKlxuICAgICAqIFRoZSBVUkwgZm9yIHRoZSBOZXVyYWwgTGluayBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgKiBAZGVmYXVsdCAnd3M6Ly8xMjcuMC4wLjE6ODA4MSdcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcubmV1cmFsTGlua1VybFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUGFzcyB0aGUgVVJMIG9mIGEgSlNPTi1maWxlLCB3aGljaCBjb250YWlucyB0aGUgc2VydmljZXMgYW5kIG1ldGhvZHMgZnJvbSB5b3VyIGJhY2tlbmQsXG4gICAgICogd2hpY2ggeW91IHdhbnQgdG8gZXhwb3NlIHRvIHRoZSBjbGllbnQuXG4gICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9wcm9qZWN0cy8zMlxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcucmVtb3Rlc0FwaVVybFxuICAgICAqIEB0eXBlIFN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcmVtb3Rlc0FwaVVybDogbnVsbCxcbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIHZpc3VhbGx5IHNob3cgdGhlIGFtb3VudCBvZiBkZWx0YSB1cGRhdGVzIHBlciBzZWNvbmQgdXNpbmcgdGhpcyBjb25maWcuXG4gICAgICogSXQgZXhwZWN0cyBhIGRvbSBub2RlIHdpdGggdGhlIGlkIFwibmVvLWRlbHRhLXVwZGF0ZXNcIiBhcyB0aGUgcmVuZGVyaW5nIHRhcmdldC5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5yZW5kZXJDb3VudERlbHRhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICByZW5kZXJDb3VudERlbHRhczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWRkIHRoZW1lcyB5b3Ugd2FudCB0byB1c2UgaGVyZS4gVGhlIGZpcnN0IHRoZW1lIHdpbGwgZ2V0IGFwcGxpZWQuXG4gICAgICogQGRlZmF1bHQgWyduZW8tdGhlbWUtbGlnaHQnLCduZW8tdGhlbWUtZGFyaycsJ25lby10aGVtZS1uZW8tbGlnaHQnXVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy50aGVtZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdbXVxuICAgICAqL1xuICAgIHRoZW1lczogWyduZW8tdGhlbWUtbGlnaHQnLCAnbmVvLXRoZW1lLWRhcmsnLCAnbmVvLXRoZW1lLW5lby1saWdodCddLFxuICAgIC8qKlxuICAgICAqIEZsYWcgZm9yIHN0YW5kYWxvbmUgU2llc3RhIG1vZHVsZSB0ZXN0cyA9PiBwcmV2ZW50IHJlZ2lzdGVyUmVtb3RlIHdvcmtlciBtZXNzYWdlc1xuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVuaXRUZXN0TW9kZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1bml0VGVzdE1vZGU6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFdoZW4gdW5pdFRlc3RNb2RlIGlzIHRydWUsIHRoaXMgZmxhZyBjYW4gYmUgZW5hYmxlZCB0byBhbGxvdyBWRE9NLXJlbGF0ZWRcbiAgICAgKiBvcGVyYXRpb25zIGxpa2UgaW5pdFZub2RlKCkgYW5kIHVwZGF0ZSgpIHRvIHByb2NlZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBpbnRlZ3JhdGlvbi1zdHlsZVxuICAgICAqIHRlc3RzIHRoYXQgbmVlZCB0byB2ZXJpZnkgY29tcG9uZW50IGxpZmVjeWNsZSBhbmQgRE9NIG91dHB1dC5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5hbGxvd1Zkb21VcGRhdGVzSW5UZXN0c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBhbGxvd1Zkb21VcGRhdGVzSW5UZXN0czogZmFsc2UsXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgdG8gdHJ1ZSB0byBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTmV1cmFsIExpbmsgTUNQIFNlcnZlci5cbiAgICAgKiBUaGlzIGVuYWJsZXMgYmlkaXJlY3Rpb25hbCBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIEFwcCBXb3JrZXIgYW5kIGV4dGVybmFsIEFJIEFnZW50cy5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyB1c2UgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyB0byBzcGVjaWZ5IHRoZSB0YXJnZXQgZW52aXJvbm1lbnQocykuXG4gICAgICogRXhhbXBsZTogJ2RldmVsb3BtZW50JyBvciBbJ2RldmVsb3BtZW50JywgJ2Rpc3QvcHJvZHVjdGlvbiddXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlQWlDbGllbnRcbiAgICAgKiBAdHlwZSBCb29sZWFufFN0cmluZ3xTdHJpbmdbXVxuICAgICAqL1xuICAgIHVzZUFpQ2xpZW50OiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwgZmxhZyBpZiBhbiBvZmZzY3JlZW4gY2FudmFzIHdvcmtlciBzaG91bGQgZ2V0IGNyZWF0ZWQuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlQ2FudmFzV29ya2VyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZUNhbnZhc1dvcmtlcjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogYHRydWVgIHdpbGwgZW5hYmxlIHRoZSBhZHZhbmNlZCwgc2VjdXJlLCBhbmQgcGVyZm9ybWFudCBkaXJlY3QgRE9NIEFQSSByZW5kZXJpbmcgc3RyYXRlZ3kgKHJlY29tbWVuZGVkKS5cbiAgICAgKiBJbiB0aGlzIG1vZGUsIGBOZW8udmRvbS5IZWxwZXJgIHdpbGwgY3JlYXRlIGFuZCBzZW5kIHN0cnVjdHVyZWQgVk5vZGUgb2JqZWN0IGdyYXBocyB0byB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICogYE5lby5tYWluLkRlbHRhVXBkYXRlc2Agd2lsbCB0aGVuIHVzZSBgTmVvLm1haW4ucmVuZGVyLkRvbUFwaVJlbmRlcmVyYCB0byBkaXJlY3RseSBtYW5pcHVsYXRlIHRoZSBET00uXG4gICAgICogQ3J1Y2lhbGx5LCBgTmVvLm1haW4ucmVuZGVyLkRvbUFwaVJlbmRlcmVyYCBidWlsZHMgbmV3ICoqRE9NIHN1YnRyZWVzKiogKGZyb20gdGhlIHJlY2VpdmVkIFZOb2RlIG9iamVjdCBncmFwaHMpXG4gICAgICogYXMgZGV0YWNoZWQgRG9jdW1lbnRGcmFnbWVudHMgb3IgZWxlbWVudHMsIGVudGlyZWx5IG91dHNpZGUgdGhlIGxpdmUgRE9NIHRyZWUuXG4gICAgICogVGhlc2UgZnVsbHkgY29uc3RydWN0ZWQgZnJhZ21lbnRzIGFyZSB0aGVuIGluc2VydGVkIGludG8gdGhlIGxpdmUgZG9jdW1lbnQgaW4gYSAqKnNpbmdsZSwgYXRvbWljIG9wZXJhdGlvbioqLlxuICAgICAqIFRoaXMgYXBwcm9hY2ggaW5oZXJlbnRseSBtaW5pbWl6ZXMgY29zdGx5IGJyb3dzZXIgcmVmbG93cy9yZXBhaW50cywgZHJhc3RpY2FsbHkgcmVkdWNlcyBDcm9zcy1TaXRlIFNjcmlwdGluZyAoWFNTKSByaXNrcyxcbiAgICAgKiBhbmQgb3B0aW1pemVzIGZvciBzdXJnaWNhbCwgYXRvbWljIERPTSB1cGRhdGVzIGZvciB1bnBhcmFsbGVsZWQgcGVyZm9ybWFuY2UuXG4gICAgICpcbiAgICAgKiBgZmFsc2VgIHdpbGwgZW5hYmxlIHRoZSBsZWdhY3kgc3RyaW5nLWJhc2VkIHJlbmRlcmluZyBzdHJhdGVneS5cbiAgICAgKiBJbiB0aGlzIG1vZGUsIGBOZW8udmRvbS5IZWxwZXJgIHdpbGwgZ2VuZXJhdGUgY29tcGxldGUgSFRNTCBzdHJpbmdzIChgb3V0ZXJIVE1MYCkgZm9yIFZOb2RlIHN1YnRyZWVzLlxuICAgICAqIGBOZW8ubWFpbi5EZWx0YVVwZGF0ZXNgIHdpbGwgdGhlbiB1c2UgYE5lby5tYWluLnJlbmRlci5TdHJpbmdCYXNlZFJlbmRlcmVyYCB0byBpbnNlcnQgdGhlc2VcbiAgICAgKiBzdHJpbmdzIGludG8gdGhlIERPTSB1c2luZyBtZXRob2RzIGxpa2UgYHBhcmVudE5vZGUuaW5zZXJ0QWRqYWNlbnRIVE1MKClgLlxuICAgICAqIFdoaWxlIHBlcmZvcm1hbnQgZm9yIGxhcmdlIGluc2VydGlvbnMsIHRoaXMgbW9kZSBpcyBnZW5lcmFsbHkgbGVzcyBzZWN1cmUgZHVlIHRvIHBvdGVudGlhbCBYU1MgdmVjdG9yc1xuICAgICAqIGFuZCByZWxpZXMgb24gYnJvd3NlciBIVE1MIHBhcnNpbmcsIHdoaWNoIGNhbiBiZSBsZXNzIGVmZmljaWVudCBmb3IgZ3JhbnVsYXIgdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgY29uZmlndXJhdGlvbiBhZmZlY3RzIGJvdGggdGhlIGluaXRpYWwgcGFpbnRpbmcgb2YgeW91ciBhcHBsaWNhdGlvbnMgYW5kIHRoZSBjcmVhdGlvblxuICAgICAqIG9mIG5ldyBjb21wb25lbnQgdHJlZXMgYXQgcnVudGltZS5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZURvbUFwaVJlbmRlcmVyXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZURvbUFwaVJlbmRlcmVyOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEZsYWcgaWYgdmRvbSBpZHMgc2hvdWxkIGdldCBtYXBwZWQgaW50byBET00gZWxlbWVudCBpZHMuXG4gICAgICogZmFsc2Ugd2lsbCBjb252ZXJ0IHRoZW0gaW50byBhIFwiZGF0YS1uZW8taWRcIiBhdHRyaWJ1dGUuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VEb21JZHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlRG9tSWRzOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFRydWUgd2lsbCBhdXRvbWF0aWNhbGx5IGluY2x1ZGUgdGhlIHN0eWxlc2hlZXRcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLnVzZUZvbnRBd2Vzb21lXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZUZvbnRBd2Vzb21lOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEludGVuZGVkIGZvciB0aGUgb25saW5lIGV4YW1wbGVzIHdoZXJlIHdlIG5lZWQgYW4gZWFzeSB3YXkgdG8gYWRkIEdBIHRvIGV2ZXJ5IGdlbmVyYXRlZCBhcHBcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VHb29nbGVBbmFseXRpY3NcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdXNlR29vZ2xlQW5hbHl0aWNzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBUcnVlIHdpbGwgYWRkIHRoZSBTZXJ2aWNlV29ya2VyIG1haW4gdGhyZWFkIGFkZG9uIHRvIHN1cHBvcnQgY2FjaGluZyBvZiBhc3NldHMgKFBXQSlcbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TZXJ2aWNlX1dvcmtlcl9BUElcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyB1c2UgYSBzdHJpbmcgdG8gc3BlY2lmeSB0aGUgdGFyZ2V0IGVudmlyb25tZW50ID0+ICdkaXN0L3Byb2R1Y3Rpb24nLlxuICAgICAqIFVzaW5nICdkaXN0L3Byb2R1Y3Rpb24nIHdpbGwgYWxzbyB1c2UgdGhlIHNlcnZpY2Ugd29ya2VyIGZvciAnZGlzdC9lc20nXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlU2VydmljZVdvcmtlclxuICAgICAqIEB0eXBlIEJvb2xlYW58U3RyaW5nXG4gICAgICovXG4gICAgdXNlU2VydmljZVdvcmtlcjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBBcHAsIERhdGEgJiBWRG9tIGFzIFNoYXJlZFdvcmtlcnMuXG4gICAgICogU2V0IHRoaXMgb25lIHRvIHRydWUgaW4gY2FzZSB5b3Ugd2FudCB0byBjb25uZWN0IG11bHRpcGxlIG1haW4gdGhyZWFkcy5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy51c2VTaGFyZWRXb3JrZXJzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHVzZVNoYXJlZFdvcmtlcnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFRydWUgd2lsbCBnZW5lcmF0ZSBhIG5ldyB0YXNrIHdvcmtlciwgd2hpY2ggY2FuIGdldCBmaWxsZWQgd2l0aCBvd24gZXhwZW5zaXZlIHJlbW90ZSBtZXRob2RzXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlVGFza1dvcmtlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VUYXNrV29ya2VyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGYWxzZSB3aWxsIGNyZWF0ZSB0aGUgdmRvbS5IZWxwZXIgd2l0aGluIHRoZSBBcHAgd29ya2VyIChleHBlcmltZW50YWwhKVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyT2YhIG1vZHVsZTpOZW9cbiAgICAgKiBAbmFtZSBjb25maWcudXNlVmRvbVdvcmtlclxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB1c2VWZG9tV29ya2VyOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIGJ1aWxkU2NyaXB0cy9pbmplY3RQYWNrYWdlVmVyc2lvbi5tanMgd2lsbCB1cGRhdGUgdGhpcyB2YWx1ZVxuICAgICAqIEBkZWZhdWx0ICcxMS4xOC4wJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy52ZXJzaW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgdmVyc2lvbjogJzExLjE4LjAnXG59O1xuXG5PYmplY3QuYXNzaWduKERlZmF1bHRDb25maWcsIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIHRvIHRoZSB0b3AgbGV2ZWwgbmVvLm1qcyByZXNvdXJjZXMgZm9sZGVyXG4gICAgICogQGRlZmF1bHQgTmVvLmNvbmZpZy5iYXNlUGF0aCArICdyZXNvdXJjZXMvJ1xuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBuYW1lIGNvbmZpZy5yZXNvdXJjZXNQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgcmVzb3VyY2VzUGF0aDogYCR7TmVvLmNvbmZpZy5iYXNlUGF0aCB8fCBEZWZhdWx0Q29uZmlnLmJhc2VQYXRofXJlc291cmNlcy9gLFxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB3ZWIgd29ya2VyIGVudHJ5IHBvaW50cyAoQXBwLCBEYXRhLCBWZG9tKVxuICAgICAqIEBkZWZhdWx0IE5lby5jb25maWcuYmFzZVBhdGggKyAnc3JjL3dvcmtlci8nXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQG5hbWUgY29uZmlnLndvcmtlckJhc2VQYXRoXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgd29ya2VyQmFzZVBhdGg6IGAke05lby5jb25maWcuYmFzZVBhdGggfHwgRGVmYXVsdENvbmZpZy5iYXNlUGF0aH1zcmMvd29ya2VyL2AsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdENvbmZpZztcbiIsImltcG9ydCBEZWZhdWx0Q29uZmlnICBmcm9tICcuL0RlZmF1bHRDb25maWcubWpzJztcbmltcG9ydCB7aXNEZXNjcmlwdG9yfSBmcm9tICcuL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG5jb25zdFxuICAgIGNhbWVsUmVnZXggICA9IC8tLi9nLFxuICAgIGNvbmZpZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ2NvbmZpZ1N5bWJvbCcpLFxuICAgIGdldFNldENhY2hlICA9IFN5bWJvbCgnZ2V0U2V0Q2FjaGUnKSxcbiAgICBjbG9uZU1hcCA9IHtcbiAgICAgICAgQXJyYXkob2JqLCBkZWVwLCBpZ25vcmVOZW9JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAhZGVlcCA/IFsuLi5vYmpdIDogWy4uLm9iai5tYXAodmFsID0+IE5lby5jbG9uZSh2YWwsIGRlZXAsIGlnbm9yZU5lb0luc3RhbmNlcykpXVxuICAgICAgICB9LFxuICAgICAgICBEYXRlKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iai52YWx1ZU9mKCkpXG4gICAgICAgIH0sXG4gICAgICAgIE1hcChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKG9iaikgLy8gc2hhbGxvdyBjb3B5XG4gICAgICAgIH0sXG4gICAgICAgIE5lb0luc3RhbmNlKG9iaiwgaWdub3JlTmVvSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gaWdub3JlTmVvSW5zdGFuY2VzID8gb2JqIDogTmVvLmNsb25lTmVvSW5zdGFuY2Uob2JqKVxuICAgICAgICB9LFxuICAgICAgICBTZXQob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldChvYmopXG4gICAgICAgIH0sXG4gICAgICAgIE9iamVjdChvYmosIGRlZXAsIGlnbm9yZU5lb0luc3RhbmNlcykge1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0ge307XG5cbiAgICAgICAgICAgIC8vIFVzZSBSZWZsZWN0Lm93bktleXMoKSB0byBpbmNsdWRlIHN5bWJvbCBwcm9wZXJ0aWVzIChlLmcuLCBmb3IgY29uZmlnIGRlc2NyaXB0b3JzKVxuICAgICAgICAgICAgUmVmbGVjdC5vd25LZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSAhZGVlcCA/IHZhbHVlIDogTmVvLmNsb25lKHZhbHVlLCBkZWVwLCBpZ25vcmVOZW9JbnN0YW5jZXMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dFxuICAgICAgICB9XG4gICAgfSxcbiAgICB0eXBlRGV0ZWN0b3IgPSB7XG4gICAgICAgIGZ1bmN0aW9uOiBpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnByb3RvdHlwZT8uY29uc3RydWN0b3I/LmlzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05lb0NsYXNzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvYmplY3Q6IGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29uc3RydWN0b3I/LmlzQ2xhc3MgJiYgaXRlbSBpbnN0YW5jZW9mIE5lby5jb3JlLkJhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05lb0luc3RhbmNlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuLyoqXG4gKiBUaGUgYmFzZSBtb2R1bGUgdG8gZW5oYW5jZSBjbGFzc2VzLCBjcmVhdGUgaW5zdGFuY2VzIGFuZCB0aGUgTmVvIG5hbWVzcGFjZVxuICogQG1vZHVsZSBOZW9cbiAqIEBzaW5nbGV0b25cbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuYmluZE1ldGhvZHMgICAgICAgYXMgYmluZE1ldGhvZHNcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuY3JlYXRlU3R5bGVPYmplY3QgYXMgY3JlYXRlU3R5bGVPYmplY3RcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuY3JlYXRlU3R5bGVzICAgICAgYXMgY3JlYXRlU3R5bGVzXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLmRlY2FtZWwgICAgICAgICAgIGFzIGRlY2FtZWxcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNBcnJheSAgICAgICAgICAgYXMgaXNBcnJheVxuICogQGJvcnJvd3MgTmVvLmNvcmUuVXRpbC5pc0Jvb2xlYW4gICAgICAgICBhcyBpc0Jvb2xlYW5cbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNEZWZpbmVkICAgICAgICAgYXMgaXNEZWZpbmVkXG4gKiBAYm9ycm93cyBOZW8uY29yZS5Db21wYXJlLmlzRXF1YWwgICAgICAgIGFzIGlzRXF1YWxcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNOdW1iZXIgICAgICAgICAgYXMgaXNOdW1iZXJcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNSZWNvcmQgICAgICAgICAgYXMgaXNSZWNvcmRcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuaXNTdHJpbmcgICAgICAgICAgYXMgaXNTdHJpbmdcbiAqIEBib3Jyb3dzIE5lby5jb3JlLlV0aWwuc25ha2VUb0NhbWVsICAgICAgYXMgc25ha2VUb0NhbWVsXG4gKiBAYm9ycm93cyBOZW8uY29yZS5VdGlsLnRvQXJyYXkgICAgICAgICAgIGFzIHRvQXJyYXlcbiAqIEB0dXRvcmlhbCAwMV9Db25jZXB0XG4gKi9cbmxldCBOZW8gPSBnbG9iYWxUaGlzLk5lbyB8fCB7fTtcblxuTmVvID0gZ2xvYmFsVGhpcy5OZW8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBjb250YWluaW5nIG50eXBlcyBhcyBrZXkgYW5kIE5lbyBjbGFzc2VzIG9yIHNpbmdsZXRvbnMgYXMgdmFsdWVzXG4gICAgICogQG1lbWJlck9mISBtb2R1bGU6TmVvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIG50eXBlTWFwOiB7fSxcbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIE5lby5jcmVhdGUuIEZhbHNlIGZvciB0aGUgbWFpbiB0aHJlYWQsIHRydWUgZm9yIHRoZSBBcHAsIERhdGEgJiBWZG9tIHdvcmtlclxuICAgICAqIEBtZW1iZXJPZiEgbW9kdWxlOk5lb1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgaW5zaWRlV29ya2VyOiB0eXBlb2YgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIG1ldGhvZHMgZnJvbSBvbmUgbmFtZXNwYWNlIHRvIGFub3RoZXIgb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBhbGlhc2VzXG4gICAgICogTmVvLmFwcGx5RnJvbU5zKE5lbywgVXRpbCwge1xuICAgICAqICAgICBjcmVhdGVTdHlsZU9iamVjdDogJ2NyZWF0ZVN0eWxlT2JqZWN0JyxcbiAgICAgKiAgICAgY3JlYXRlU3R5bGVzICAgICA6ICdjcmVhdGVTdHlsZXMnLFxuICAgICAqICAgICBjYXBpdGFsaXplICAgICAgIDogJ2NhcGl0YWxpemUnXG4gICAgICogfSwgdHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBlLmcuIE5lby5jb3JlLlV0aWwuaXNPYmplY3QgPT4gTmVvLmlzT2JqZWN0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge05lb3xOZW8uY29yZS5CYXNlfSB0YXJnZXQgICAgVGhlIHRhcmdldCBjbGFzcyBvciBzaW5nbGV0b24gSW5zdGFuY2Ugb3IgTmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSAgICAgbmFtZXNwYWNlIFRoZSBjbGFzcyBjb250YWluaW5nIHRoZSBtZXRob2RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgICAgW2JpbmRdICAgIHNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSB5b3Ugd2FudCB0byBiaW5kIG1ldGhvZHMgdG8gdGhlIFwiZnJvbVwiIG5hbWVzcGFjZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIGFwcGx5RnJvbU5zKHRhcmdldCwgbmFtZXNwYWNlLCBjb25maWcsIGJpbmQpIHtcbiAgICAgICAgbGV0IGZuTmFtZTtcblxuICAgICAgICBpZiAodGFyZ2V0ICYmIE5lby50eXBlT2YoY29uZmlnKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gbmFtZXNwYWNlW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGJpbmQgPyBmbk5hbWUuYmluZChuYW1lc3BhY2UpIDogZm5OYW1lXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgY2xhc3MgdG8gdGhlIGdsb2JhbCBOZW8gb3IgQXBwIG5hbWVzcGFjZS5cbiAgICAgKiBDYW4gZ2V0IGNhbGxlZCBmb3IgY2xhc3NlcyBhbmQgc2luZ2xldG9uIGluc3RhbmNlc1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBjbHNcbiAgICAgKi9cbiAgICBhcHBseVRvR2xvYmFsTnMoY2xzKSB7XG4gICAgICAgIGxldCBwcm90byAgICAgPSB0eXBlb2YgY2xzID09PSAnZnVuY3Rpb24nID8gY2xzLnByb3RvdHlwZSA6IGNscyxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByb3RvLmlzQ2xhc3MgPyBwcm90by5jb25maWcuY2xhc3NOYW1lIDogcHJvdG8uY2xhc3NOYW1lLFxuICAgICAgICAgICAgbnNBcnJheSAgID0gY2xhc3NOYW1lLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBrZXkgICAgICAgPSBuc0FycmF5LnBvcCgpLFxuICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKG5zQXJyYXksIHRydWUpO1xuXG4gICAgICAgIG5zW2tleV0gPSBjbHNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGFsbCBrZXlzIG9mIGRlZmF1bHRzIGludG8gdGFyZ2V0LCBpbiBjYXNlIHRoZXkgZG9uJ3QgYWxyZWFkeSBleGlzdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgIFRoZSB0YXJnZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRzIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUga2V5cyB5b3Ugd2FudCB0byBjb3B5XG4gICAgICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgYXNzaWduRGVmYXVsdHModGFyZ2V0LCBkZWZhdWx0cykge1xuICAgICAgICBpZiAodGFyZ2V0ICYmIE5lby50eXBlT2YoZGVmYXVsdHMpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGVmYXVsdHMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYSBuZXcgdmFsdWUgdG8gYSBnaXZlbiBuZXN0ZWQgb2JqZWN0cyBwYXRoLlxuICAgICAqIEl0IHdpbGwgY3JlYXRlIHRoZSBwYXRoIHN0cnVjdHVyZSBvciBwYXJ0cyBvZiBpdCwgaW4gY2FzZSBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5hc3NpZ25Ub05zKCdhbm5vdGF0aW9ucy5zZWxlY3RlZCcsIGZhbHNlLCByZWNvcmQpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBwYXRoICAgICAgICAgICAgIFRoZSBwYXRoIHN0cmluZyBjb250YWluaW5nIGRvdHMgb3IgYW4gQXJyYXkgb2YgdGhlIHN0cmluZyBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgICAgIFRoZSBuZXcgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgc2NvcGU9Z2xvYmFsVGhpcyBTZXQgYSBkaWZmZXJlbnQgc3RhcnRpbmcgcG9pbnQgYXMgZ2xvYmFsVGhpc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICBmb3JjZT10cnVlICAgICAgIGZhbHNlIHdpbGwgb25seSBhc3NpZ24gZGVmYXVsdCB2YWx1ZXMgKGFzc2lnbiBpZiBvbGQgdmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgKi9cbiAgICBhc3NpZ25Ub05zKHBhdGgsIHZhbHVlLCBzY29wZT1nbG9iYWxUaGlzLCBmb3JjZT10cnVlKSB7XG4gICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcblxuICAgICAgICBsZXQga2V5O1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGtleSAgID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIHNjb3BlID0gTmVvLm5zKHBhdGgsIHRydWUsIHNjb3BlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gcGF0aFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlIHx8IHNjb3BlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NvcGVba2V5XSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMga2ViYWItY2FzZSBzdHJpbmdzIGludG8gY2FtZWwtY2FzZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB0YXJnZXQgb2JqZWN0XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBjYW1lbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShjYW1lbFJlZ2V4LCBtYXRjaCA9PiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHVwcGVyY2FzZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58U3RyaW5nfSBSZXR1cm5zIGZhbHNlIGZvciBub24tc3RyaW5nIGlucHV0c1xuICAgICAqL1xuICAgIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fCp9IG9ialxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVlcD1mYWxzZSAgICAgICAgICAgICAgIFNldCB0aGlzIHRvIHRydWUgaW4gY2FzZSB5b3Ugd2FudCB0byBjbG9uZSBuZXN0ZWQgb2JqZWN0cyBhcyB3ZWxsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVOZW9JbnN0YW5jZXM9ZmFsc2UgcmV0dXJucyBleGlzdGluZyBpbnN0YW5jZXMgaWYgc2V0IHRvIHRydWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fEFycmF5fCp9IHRoZSBjbG9uZWQgaW5wdXRcbiAgICAgKi9cbiAgICBjbG9uZShvYmosIGRlZXA9ZmFsc2UsIGlnbm9yZU5lb0luc3RhbmNlcz1mYWxzZSkge1xuICAgICAgICByZXR1cm4gY2xvbmVNYXBbTmVvLnR5cGVPZihvYmopXT8uKG9iaiwgZGVlcCwgaWdub3JlTmVvSW5zdGFuY2VzKSB8fCBvYmpcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB1c2luZyB0aGUgb3JpZ2luYWxDb25maWcgd2l0aG91dCB0aGUgaWRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuQmFzZX0gdGhlIGNsb25lZCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNsb25lTmVvSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHsuLi5pbnN0YW5jZS5vcmlnaW5hbENvbmZpZ307XG5cbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faWQ7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuaWQ7XG5cbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoaW5zdGFuY2UuY2xhc3NOYW1lLCBjb25maWcpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZSBOZW8uY3JlYXRlKCkgaW5zdGVhZCBvZiBcIm5ld1wiIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYWxsIE5lbyBjbGFzc2VzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgQnV0dG9uIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG4gICAgICpcbiAgICAgKiBOZW8uY3JlYXRlKEJ1dHRvbiwge1xuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuICAgICAqXG4gICAgICogTmVvLmNyZWF0ZSh7XG4gICAgICogICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgKiAgICAgaWNvbkNsczogJ2ZhIGZhLWhvbWUnLFxuICAgICAqICAgICB0ZXh0ICAgOiAnSG9tZSdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5jcmVhdGUoJ05lby5idXR0b24uQmFzZScge1xuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLmNyZWF0ZSh7XG4gICAgICogICAgIGNsYXNzTmFtZTogJ05lby5idXR0b24uQmFzZScsXG4gICAgICogICAgIGljb25DbHMgIDogJ2ZhIGZhLWhvbWUnLFxuICAgICAqICAgICB0ZXh0ICAgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fE5lby5jb3JlLkJhc2V9IGNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICBbY29uZmlnXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfG51bGx9IFRoZSBuZXcgY2xhc3MgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjcmVhdGUoY2xhc3NOYW1lLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBOZW8udHlwZU9mKGNsYXNzTmFtZSksXG4gICAgICAgICAgICBjbHMsIGluc3RhbmNlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnTmVvQ2xhc3MnKSB7XG4gICAgICAgICAgICBjbHMgPSBjbGFzc05hbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmNsYXNzTmFtZSAmJiAhY29uZmlnLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBjb25zb2xlLmVycm9yIGluc3RlYWQgb2YgdGhyb3cgdG8gc2hvdyB0aGUgY29uZmlnIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDbGFzcyBjcmVhdGVkIHdpdGggb2JqZWN0IGNvbmZpZ3VyYXRpb24gbWlzc2luZyBjbGFzc05hbWUgb3IgbW9kdWxlIHByb3BlcnR5JywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjb25maWcuY2xhc3NOYW1lIHx8IGNvbmZpZy5tb2R1bGUucHJvdG90eXBlLmNsYXNzTmFtZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4aXN0cyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyAnICsgY2xhc3NOYW1lICsgJyBkb2VzIG5vdCBleGlzdCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNscyA9IE5lby5ucyhjbGFzc05hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjbHMoKTtcblxuICAgICAgICBpbnN0YW5jZS5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgaW5zdGFuY2Uub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICBpbnN0YW5jZS5vbkFmdGVyQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgaW5zdGFuY2UuaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgcmVhY3RpdmUgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBvbiBhIHRhcmdldCBvYmplY3QgKHByb3RvdHlwZSBvciBpbnN0YW5jZSkuXG4gICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgZnVsbHkgcGFydGljaXBhdGUgaW4gTmVvLm1qcydzIHJlYWN0aXZlIGNvbmZpZyBzeXN0ZW0sXG4gICAgICogaW5jbHVkaW5nIGxpZmVjeWNsZSBob29rcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gIHRhcmdldCAgICAgICAgLSBUaGUgaW5zdGFuY2Ugb3IgcHJvdG90eXBlIG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgIGtleSAgICAgICAgICAgLSBUaGUgbmFtZSBvZiB0aGUgY29uZmlnIHByb3BlcnR5ICh3aXRob3V0IHRoZSAnXycgc3VmZml4KS5cbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgIFtpbml0aWFsVmFsdWVdIC0gVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBjb25maWcuXG4gICAgICovXG4gICAgY3JlYXRlQ29uZmlnKHRhcmdldCwga2V5LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5oYXNQcm9wZXJ0eVNldHRlcih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICAgIHRocm93KFxuYEludmFsaWQgY29uZmlnIGluICR7dGFyZ2V0LmNsYXNzTmFtZX06ICcke2tleX1fJy4gVGhlIGNvbmZpZyAnJHtrZXl9JyBpcyBhbHJlYWR5IGRlZmluZWQgYXMgcmVhY3RpdmUgYnkgYSBwYXJlbnQgY2xhc3MuXG5UbyBvdmVycmlkZSB0aGUgZGVmYXVsdCB2YWx1ZSwgdXNlICcke2tleX0nICh3aXRob3V0IHRoZSB1bmRlcnNjb3JlKSBpbiB5b3VyIHN0YXRpYyBjb25maWcuXG5JZiB5b3UgaW50ZW5kZWQgdG8gY3JlYXRlIGN1c3RvbSBsb2dpYywgdXNlIHRoZSAnYmVmb3JlR2V0JHtOZW8uY2FwaXRhbGl6ZShrZXkpfSgpJywgJ2JlZm9yZVNldCR7TmVvLmNhcGl0YWxpemUoa2V5KX0oKScsYW5kICdhZnRlclNldCR7TmVvLmNhcGl0YWxpemUoa2V5KX0oKScgaG9va3MgaW5zdGVhZCBvZiByZWRlZmluaW5nIHRoZSBjb25maWcuYFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIF9rZXkgICAgICA9ICdfJyArIGtleSxcbiAgICAgICAgICAgIHVLZXkgICAgICA9IGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpLFxuICAgICAgICAgICAgYmVmb3JlR2V0ID0gJ2JlZm9yZUdldCcgKyB1S2V5LFxuICAgICAgICAgICAgYmVmb3JlU2V0ID0gJ2JlZm9yZVNldCcgKyB1S2V5LFxuICAgICAgICAgICAgYWZ0ZXJTZXQgID0gJ2FmdGVyU2V0JyAgKyB1S2V5O1xuXG4gICAgICAgIE5lb1tnZXRTZXRDYWNoZV0gPz89IHt9O1xuXG4gICAgICAgIGlmICghTmVvW2dldFNldENhY2hlXVtrZXldKSB7XG4gICAgICAgICAgICAvLyBQdWJsaWMgRGVzY3JpcHRvclxuICAgICAgICAgICAgTmVvW2dldFNldENhY2hlXVtrZXldID0ge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgICAgPSBtZS5nZXRDb25maWcoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc05ld0tleSA9IE9iamVjdC5oYXNPd24obWVbY29uZmlnU3ltYm9sXSwga2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0tleSAgICA9IG1lW2NvbmZpZ1N5bWJvbF1ba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICA9IGhhc05ld0tleSA/IG5ld0tleSA6IG1lW19rZXldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldywgZXhwbGljaXQgb3B0LWluIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLmNsb25lT25HZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHtjbG9uZU9uR2V0fSA9IGNvbmZpZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb25lT25HZXQgPT09ICdkZWVwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLmNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbG9uZU9uR2V0ID09PSAnc2hhbGxvdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gTmVvLnR5cGVPZih2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFsuLi52YWx1ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gey4uLnZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBsZWdhY3kgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gWy4uLnZhbHVlXVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc05ld0tleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVba2V5XSA9IHZhbHVlOyAgLy8gV2UgZG8gd2FudCB0byB0cmlnZ2VyIHRoZSBzZXR0ZXIgPT4gYmVmb3JlU2V0LCBhZnRlclNldFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtZVtfa2V5XTsgLy8gUmV0dXJuIHRoZSB2YWx1ZSBwYXJzZWQgYnkgdGhlIHNldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lW2NvbmZpZ1N5bWJvbF1ba2V5XVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZVtiZWZvcmVHZXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lW2JlZm9yZUdldF0odmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSAgICAgICAgPSBjb25maWcuZ2V0KCksIC8vIEdldCB0aGUgb2xkIHZhbHVlIGZyb20gdGhlIENvbmZpZyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAge0VmZmVjdE1hbmFnZXJ9ID0gTmVvLmNvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05ld0JhdGNoICAgICAgPSAhRWZmZWN0TWFuYWdlcj8uaXNQYXVzZWQoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGNvbmZpZyBjaGFuZ2UgaXMgbm90IHRyaWdnZXJlZCB2aWEgYGNvcmUuQmFzZSNzZXQoKWAsIGhvbm9yIGNoYW5nZXMgaW5zaWRlIGhvb2tzLlxuICAgICAgICAgICAgICAgICAgICBpc05ld0JhdGNoICYmIEVmZmVjdE1hbmFnZXI/LnBhdXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIFByZXZlbnQgaW5maW5pdGUgbG9vcHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbW1lZGlhdGVseSByZW1vdmUgdGhlIHBlbmRpbmcgdmFsdWUgZnJvbSB0aGUgY29uZmlnU3ltYm9sIHRvIHByZXZlbnQgYSBnZXR0ZXIgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgcmUtdHJpZ2dlcmluZyB0aGlzIHNldHRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdW2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29uZmlnLmNsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVlcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLmNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2hhbGxvdyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLmNsb25lKHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBDcmVhdGUgYSB0ZW1wb3Jhcnkgc3RhdGUgZm9yIGJlZm9yZVNldCBob29rczpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgbmV3IHZhbHVlIGRpcmVjdGx5IG9uIHRoZSBwcml2YXRlIGJhY2tpbmcgcHJvcGVydHkuIFRoaXMgYWxsb3dzIGFueSBiZWZvcmVTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhvb2sgdG8gYWNjZXNzIHRoZSBuZXcgdmFsdWUgb2YgdGhpcyBhbmQgb3RoZXIgY29uZmlncyB3aXRoaW4gdGhlIHNhbWUgYHNldCgpYCBjYWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVbX2tleV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZVtiZWZvcmVTZXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtZVtiZWZvcmVTZXRdKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGRvbid0IHJldHVybiBhIHZhbHVlLCB0aGF0IG1lYW5zIG5vIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlIGlmIHRoZSB1cGRhdGUgaXMgY2FuY2VsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW19rZXldID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMy4gUmVzdG9yZSBzdGF0ZSBmb3IgY2hhbmdlIGRldGVjdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgcHJpdmF0ZSBiYWNraW5nIHByb3BlcnR5IHRvIGl0cyBvcmlnaW5hbCB2YWx1ZS4gVGhpcyBpcyBjcnVjaWFsIGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBjb25maWcuc2V0KClgIG1ldGhvZCB0byBjb3JyZWN0bHkgZGV0ZWN0IGlmIHRoZSB2YWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lW19rZXldID0gb2xkVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQuIEZpbmFsaXplIHRoZSBjaGFuZ2U6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnLnNldCgpIG1ldGhvZCBwZXJmb3JtcyB0aGUgZmluYWwgY2hlY2sgYW5kLCBpZiB0aGUgdmFsdWUgY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJzIGFmdGVyU2V0IGhvb2tzIGFuZCBub3RpZmllcyBzdWJzY3JpYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2V0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW2FmdGVyU2V0XT8uKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuYWZ0ZXJTZXRDb25maWc/LihrZXksIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCB0aGUgYmF0Y2ggb25seSBpZiB0aGlzIHNldHRlciBzdGFydGVkIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXdCYXRjaCAmJiBFZmZlY3RNYW5hZ2VyPy5yZXN1bWUoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUHJpdmF0ZSBEZXNjcmlwdG9yXG4gICAgICAgICAgICBOZW9bZ2V0U2V0Q2FjaGVdW19rZXldID0ge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnKGtleSk/LmdldCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDb25maWcoa2V5KT8uc2V0UmF3KHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgIE5lb1tnZXRTZXRDYWNoZV1ba2V5XSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF9rZXksIE5lb1tnZXRTZXRDYWNoZV1bX2tleV0pO1xuXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBpbml0aWFsVmFsdWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGVtcHR5Rm4oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYSBjbGFzcyBpcyBhc3NpZ25lZCB0byB0aGUgTmVvIG5hbWVzcGFjZSBvbmx5IG9uY2UsIHByZXZlbnRpbmcgZHVwbGljYXRlcy5cbiAgICAgKiBUaGlzIGlzIGEgbGlnaHR3ZWlnaHQgdmVyc2lvbiBvZiBgTmVvLnNldHVwQ2xhc3NgIGZvciBzaW1wbGUgY2xhc3Nlc1xuICAgICAqIHRoYXQgZG8gbm90IGV4dGVuZCBgTmVvLmNvcmUuQmFzZWAuXG4gICAgICogSXQgZm9sbG93cyBhIFwiZmlyc3Qgb25lIHdpbnNcIiBzdHJhdGVneS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBtb2R1bGUgICAgLSBUaGUgY2xhc3MgY29uc3RydWN0b3Igb3Igc2luZ2xldG9uIG9iamVjdCB0byByZWdpc3Rlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgY2xhc3NQYXRoIC0gVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIChlLmcuLCAnTmVvLmNvcmUuQ29uZmlnJykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgW29uRmlyc3RdICAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgcnVucyBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBjbGFzcyBpcyByZWdpc3RlcmVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBjbGFzcyBvciBzaW5nbGV0b24gZnJvbSB0aGUgTmVvIG5hbWVzcGFjZSAoZWl0aGVyIHRoZSBleGlzdGluZyBvbmUgb3IgdGhlIG5ld2x5IHNldCBvbmUpLlxuICAgICAqL1xuICAgIGdhdGVrZWVwKG1vZHVsZSwgY2xhc3NQYXRoLCBvbkZpcnN0KSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhc3MgPSBOZW8ubnMoY2xhc3NQYXRoLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGV4aXN0aW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0NsYXNzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbnNBcnJheSAgID0gY2xhc3NQYXRoLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBuc0FycmF5LnBvcCgpLFxuICAgICAgICAgICAgcGFyZW50TnMgID0gTmVvLm5zKG5zQXJyYXksIHRydWUpO1xuXG4gICAgICAgIHBhcmVudE5zW2NsYXNzTmFtZV0gPSBtb2R1bGU7XG5cbiAgICAgICAgb25GaXJzdD8uKG1vZHVsZSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudE5zW2NsYXNzTmFtZV1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlIGlzIGEgc2V0IG1ldGhvZCBmb3IgYSBnaXZlbiBwcm9wZXJ0eSBrZXkgaW5zaWRlIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gcHJvdG8gVGhlIHRvcCBsZXZlbCBwcm90b3R5cGUgb2YgYSBjbGFzc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAga2V5ICAgVGhlIHByb3BlcnR5IGtleSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUHJvcGVydHlTZXR0ZXIocHJvdG8sIGtleSkge1xuICAgICAgICBsZXQgZGVzY3JpcHRvcjtcblxuICAgICAgICB3aGlsZSAocHJvdG8uX19wcm90b19fKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVzY3JpcHRvci5zZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm90byA9IHByb3RvLl9fcHJvdG9fX1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZXAtbWVyZ2VzIGEgc291cmNlIG9iamVjdCBpbnRvIGEgdGFyZ2V0IG9iamVjdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6TmVvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLm1lcmdlKE5lby5tZXJnZSh0YXJnZXQsIGRlZmF1bHRzKSwgc291cmNlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gTmVvLm1lcmdlKHRhcmdldFtrZXldIHx8IHt9LCB2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBuZXcgdmFsdWUgaW50byBhbiBleGlzdGluZyBjb25maWcgdmFsdWUgYmFzZWQgb24gYSBzcGVjaWZpZWQgc3RyYXRlZ3kuXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBkdXJpbmcgaW5zdGFuY2UgY3JlYXRpb24gdG8gYXBwbHkgbWVyZ2Ugc3RyYXRlZ2llcyBkZWZpbmVkIGluIGNvbmZpZyBkZXNjcmlwdG9ycy5cbiAgICAgKiBAcGFyYW0ge2FueX0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGNvbmZpZyAoZnJvbSBzdGF0aWMgY29uZmlnKS5cbiAgICAgKiBAcGFyYW0ge2FueX0gaW5zdGFuY2VWYWx1ZSAtIFRoZSB2YWx1ZSBwcm92aWRlZCBkdXJpbmcgaW5zdGFuY2UgY3JlYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHN0cmF0ZWd5IC0gVGhlIG1lcmdlIHN0cmF0ZWd5OiAnc2hhbGxvdycsICdkZWVwJywgJ3JlcGxhY2UnLCBvciBhIGN1c3RvbSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBUaGUgbWVyZ2VkIHZhbHVlLlxuICAgICAqL1xuICAgIG1lcmdlQ29uZmlnKGRlZmF1bHRWYWx1ZSwgaW5zdGFuY2VWYWx1ZSwgc3RyYXRlZ3kpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVR5cGUgID0gTmVvLnR5cGVPZihkZWZhdWx0VmFsdWUpLFxuICAgICAgICAgICAgaW5zdGFuY2VWYWx1ZVR5cGUgPSBOZW8udHlwZU9mKGluc3RhbmNlVmFsdWUpO1xuXG4gICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ3NoYWxsb3cnKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlVHlwZSA9PT0gJ09iamVjdCcgJiYgaW5zdGFuY2VWYWx1ZVR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsuLi5kZWZhdWx0VmFsdWUsIC4uLmluc3RhbmNlVmFsdWV9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdkZWVwJykge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUgPT09ICdPYmplY3QnICYmIGluc3RhbmNlVmFsdWVUeXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBOZW8ubWVyZ2UoTmVvLmNsb25lKGRlZmF1bHRWYWx1ZSwgdHJ1ZSksIGluc3RhbmNlVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koZGVmYXVsdFZhbHVlLCBpbnN0YW5jZVZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byAncmVwbGFjZScgb3IgaWYgc3RyYXRlZ3kgaXMgbm90IHJlY29nbml6ZWRcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlVmFsdWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhIGNsYXNzTmFtZSBzdHJpbmcgaW50byBhIGdpdmVuIG9yIGdsb2JhbCBuYW1lc3BhY2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIE5lby5ucygnTmVvLmJ1dHRvbi5CYXNlJywgdHJ1ZSk7XG4gICAgICogLy8gPT5cbiAgICAgKiAvLyBnbG9iYWxUaGlzLk5lbyAgICAgICAgICAgICA9IGdsb2JhbFRoaXMuTmVvICAgICAgICAgICAgIHx8IHt9O1xuICAgICAqIC8vIGdsb2JhbFRoaXMuTmVvLmJ1dHRvbiAgICAgID0gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uICAgICAgfHwge307XG4gICAgICogLy8gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uLkJhc2UgPSBnbG9iYWxUaGlzLk5lby5idXR0b24uQmFzZSB8fCB7fTtcbiAgICAgKiAvLyByZXR1cm4gZ2xvYmFsVGhpcy5OZW8uYnV0dG9uLkJhc2U7XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBuYW1lcyAgICAgICAgVGhlIGNsYXNzIG5hbWUgc3RyaW5nIGNvbnRhaW5pbmcgZG90cyBvciBhbiBBcnJheSBvZiB0aGUgc3RyaW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgIGNyZWF0ZT1mYWxzZSBTZXQgY3JlYXRlIHRvIHRydWUgdG8gY3JlYXRlIGVtcHR5IG9iamVjdHMgZm9yIG5vbi1leGlzdGluZyBwYXJ0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBbc2NvcGVdICAgICAgU2V0IGEgZGlmZmVyZW50IHN0YXJ0aW5nIHBvaW50IGFzIGdsb2JhbFRoaXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWZlcmVuY2UgdG8gdGhlIHRvcGxldmVsIG5hbWVzcGFjZVxuICAgICAqL1xuICAgIG5zKG5hbWVzLCBjcmVhdGU9ZmFsc2UsIHNjb3BlKSB7XG4gICAgICAgIG5hbWVzID0gQXJyYXkuaXNBcnJheShuYW1lcykgPyBuYW1lcyA6IG5hbWVzLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIG5hbWVzLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZSAmJiAhcHJldltjdXJyZW50XSkge1xuICAgICAgICAgICAgICAgIHByZXZbY3VycmVudF0gPSB7fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2W2N1cnJlbnRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNjb3BlIHx8IGdsb2JhbFRoaXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZGVkIHZlcnNpb24gb2YgTmVvLm5zKCkgd2hpY2ggc3VwcG9ydHMgbWFwcGluZyBpbnRvIGFycmF5cy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBuYW1lcyAgICAgICAgVGhlIGNsYXNzIG5hbWUgc3RyaW5nIGNvbnRhaW5pbmcgZG90cyBvciBhbiBBcnJheSBvZiB0aGUgc3RyaW5nIHBhcnRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgIGNyZWF0ZT1mYWxzZSBTZXQgY3JlYXRlIHRvIHRydWUgdG8gY3JlYXRlIGVtcHR5IG9iamVjdHMgZm9yIG5vbi1leGlzdGluZyBwYXJ0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICBbc2NvcGVdICAgICAgU2V0IGEgZGlmZmVyZW50IHN0YXJ0aW5nIHBvaW50IGFzIGdsb2JhbFRoaXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWZlcmVuY2UgdG8gdGhlIHRvcGxldmVsIG5hbWVzcGFjZVxuICAgICAqL1xuICAgIG5zV2l0aEFycmF5cyhuYW1lcywgY3JlYXRlPWZhbHNlLCBzY29wZSkge1xuICAgICAgICBuYW1lcyA9IEFycmF5LmlzQXJyYXkobmFtZXMpID8gbmFtZXMgOiBuYW1lcy5zcGxpdCgnLicpO1xuXG4gICAgICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChjcmVhdGUgJiYgIXByZXZbY3VycmVudF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcnJheU5zKHRydWUsIGN1cnJlbnQsIHByZXYpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJldltjdXJyZW50XSA9IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlOcyhmYWxzZSwgY3VycmVudCwgcHJldilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldltjdXJyZW50XVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzY29wZSB8fCBnbG9iYWxUaGlzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGluc3RhbmNlcyBvZiBOZW8gY2xhc3NlcyB1c2luZyB0aGVpciBudHlwZSBpbnN0ZWFkIG9mIHRoZSBjbGFzcyBuYW1lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBOZW8ubnR5cGUoJ2J1dHRvbicge1xuICAgICAqICAgICBpY29uQ2xzOiAnZmEgZmEtaG9tZScsXG4gICAgICogICAgIHRleHQgICA6ICdIb21lJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogTmVvLm50eXBlKHtcbiAgICAgKiAgICAgbnR5cGUgIDogJ2J1dHRvbicsXG4gICAgICogICAgIGljb25DbHM6ICdmYSBmYS1ob21lJyxcbiAgICAgKiAgICAgdGV4dCAgIDogJ0hvbWUnXG4gICAgICogfSk7XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpOZW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG50eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbY29uZmlnXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpOZW8uY3JlYXRlIGNyZWF0ZX1cbiAgICAgKi9cbiAgICBudHlwZShudHlwZSwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWcgPSBudHlwZTtcblxuICAgICAgICAgICAgaWYgKCFjb25maWcubnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIGRlZmluZWQgd2l0aCBvYmplY3QgY29uZmlndXJhdGlvbiBtaXNzaW5nIG50eXBlIHByb3BlcnR5LiAnICsgY29uZmlnLm50eXBlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBudHlwZSA9IGNvbmZpZy5udHlwZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IE5lby5udHlwZU1hcFtudHlwZV07XG5cbiAgICAgICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbnR5cGUgJyArIG50eXBlICsgJyBkb2VzIG5vdCBleGlzdCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZShjbGFzc05hbWUsIGNvbmZpZylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgZmluYWwgYW5kIG1vc3QgY3JpdGljYWwgc3RlcCBpbiB0aGUgTmVvLm1qcyBjbGFzcyBjcmVhdGlvbiBwcm9jZXNzLlxuICAgICAqIEl0IGlzIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGNsYXNzIG1vZHVsZSBkZWZpbml0aW9uLlxuICAgICAqXG4gICAgICogYHNldHVwQ2xhc3NgIHBlcmZvcm1zIHNldmVyYWwga2V5IG9wZXJhdGlvbnM6XG4gICAgICogMS4gICoqTWl4ZWQtRW52aXJvbm1lbnQgR2F0ZWtlZXBlcjoqKiBJdCBmaXJzdCBjaGVja3MgaWYgdGhlIGNsYXNzJ3MgbmFtZXNwYWNlIGFscmVhZHkgZXhpc3RzLlxuICAgICAqICAgICBJZiBpdCBkb2VzLCBpdCBpbW1lZGlhdGVseSByZXR1cm5zIHRoZSBleGlzdGluZyBjbGFzcy4gVGhpcyBpcyB0aGUgY3J1Y2lhbCBcImZpcnN0IGNvbWVzIHdpbnNcIlxuICAgICAqICAgICBzdHJhdGVneSB0aGF0IGVuYWJsZXMgTmVvLm1qcyB0byBzYWZlbHkgY29tYmluZSBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBhIGJ1bmRsZWRcbiAgICAgKiAgICAgYGRpc3QvcHJvZHVjdGlvbmAgYXBwIGNhbiBkeW5hbWljYWxseSBsb2FkIGFuIHVuYnVuZGxlZCBtb2R1bGUgZnJvbSBgZGlzdC9lc21gIGF0IHJ1bnRpbWUuXG4gICAgICogICAgIElmIHRoYXQgbW9kdWxlIGltcG9ydHMgYSBjbGFzcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIG1haW4gYnVuZGxlLCB0aGlzIGNoZWNrIGVuc3VyZXMgdGhlXG4gICAgICogICAgIG9yaWdpbmFsLCBidW5kbGVkIGNsYXNzIGlzIHVzZWQsIHByZXZlbnRpbmcgY29uZmxpY3RzIGFuZCBtYWludGFpbmluZyBhcHBsaWNhdGlvbiBpbnRlZ3JpdHkuXG4gICAgICogMi4gICoqQ29uZmlndXJhdGlvbiBNZXJnaW5nOioqIEl0IHRyYXZlcnNlcyB0aGUgcHJvdG90eXBlIGNoYWluIHRvIG1lcmdlIGBzdGF0aWMgY29uZmlnYFxuICAgICAqICAgICBvYmplY3RzIGZyb20gcGFyZW50IGNsYXNzZXMgaW50byB0aGUgY3VycmVudCBjbGFzcywgY3JlYXRpbmcgYSB1bmlmaWVkIGBjb25maWdgLlxuICAgICAqIDMuICAqKkFwcGx5aW5nIE92ZXJ3cml0ZXM6KiogSXQgY2FsbHMgdGhlIHN0YXRpYyBgYXBwbHlPdmVyd3JpdGVzKClgIG1ldGhvZCBvbiB0aGUgY2xhc3MsXG4gICAgICogICAgIGFsbG93aW5nIHRoZSBnbG9iYWwgYE5lby5vdmVyd3JpdGVzYCBvYmplY3QgdG8gbW9kaWZ5IHRoZSBjbGFzcydzIGRlZmF1bHQgcHJvdG90eXBlXG4gICAgICogICAgIGNvbmZpZ3MuIFRoaXMgaXMgYSBrZXkgbWVjaGFuaXNtIGZvciBleHRlcm5hbCB0aGVtaW5nIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIDQuICAqKlJlYWN0aXZlIEdldHRlci9TZXR0ZXIgR2VuZXJhdGlvbjoqKiBGb3IgYW55IGNvbmZpZyBlbmRpbmcgd2l0aCBhbiB1bmRlcnNjb3JlIChlLmcuLCBgbXlDb25maWdfYCksXG4gICAgICogICAgIGl0IGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIHRoZSBjb3JyZXNwb25kaW5nIHB1YmxpYyBnZXR0ZXIgYW5kIHNldHRlci4gVGhpcyBlbmFibGVzIG9wdGlvbmFsXG4gICAgICogICAgIGxpZmVjeWNsZSBob29rcyB0aGF0IGFyZSBjYWxsZWQgYXV0b21hdGljYWxseSBpZiBpbXBsZW1lbnRlZCBvbiB0aGUgY2xhc3M6XG4gICAgICogICAgIC0gYGJlZm9yZUdldE15Q29uZmlnKHZhbHVlKWBcbiAgICAgKiAgICAgLSBgYmVmb3JlU2V0TXlDb25maWcobmV3VmFsdWUsIG9sZFZhbHVlKWBcbiAgICAgKiAgICAgLSBgYWZ0ZXJTZXRNeUNvbmZpZyhuZXdWYWx1ZSwgb2xkVmFsdWUpYFxuICAgICAqIDUuICAqKlByb3RvdHlwZS1iYXNlZCBDb25maWdzOioqIE5vbi1yZWFjdGl2ZSBjb25maWdzICh3aXRob3V0IGFuIHVuZGVyc2NvcmUpIGFyZSBzZXRcbiAgICAgKiAgICAgZGlyZWN0bHkgb24gdGhlIHByb3RvdHlwZSBmb3IgbWVtb3J5IGVmZmljaWVuY3kuXG4gICAgICogNi4gICoqTWl4aW4gQXBwbGljYXRpb246KiogSXQgcHJvY2Vzc2VzIHRoZSBgbWl4aW5zYCBjb25maWcgdG8gYmxlbmQgaW4gZnVuY3Rpb25hbGl0eSBmcm9tXG4gICAgICogICAgIG90aGVyIGNsYXNzZXMuXG4gICAgICogNy4gICoqTmFtZXNwYWNlIFJlZ2lzdHJhdGlvbjoqKiBJdCByZWdpc3RlcnMgdGhlIGNsYXNzIGluIHRoZSBnbG9iYWwgYE5lb2AgbmFtZXNwYWNlLlxuICAgICAqIDguICAqKlNpbmdsZXRvbiBJbnN0YW50aWF0aW9uOioqIElmIHRoZSBjbGFzcyBpcyBjb25maWd1cmVkIGFzIGEgc2luZ2xldG9uLCBpdCBjcmVhdGVzIHRoZVxuICAgICAqICAgICBzaW5nbGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOk5lb1xuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHtUfSBjbHMgVGhlIGNsYXNzIGNvbnN0cnVjdG9yIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge1R9IFRoZSBwcm9jZXNzZWQgYW5kIGZpbmFsaXplZCBjbGFzcyBjb25zdHJ1Y3RvciBvciBzaW5nbGV0b24gaW5zdGFuY2UuXG4gICAgICovXG4gICAgc2V0dXBDbGFzcyhjbHMpIHtcbiAgICAgICAgbGV0IGJhc2VDb25maWcgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBiYXNlQ29uZmlnRGVzY3JpcHRvcnMgPSBudWxsLFxuICAgICAgICAgICAgbnR5cGVDaGFpbiAgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICB7bnR5cGVNYXB9ICAgICAgICAgICAgPSBOZW8sXG4gICAgICAgICAgICBwcm90byAgICAgICAgICAgICAgICAgPSBjbHMucHJvdG90eXBlIHx8IGNscyxcbiAgICAgICAgICAgIG5zICAgICAgICAgICAgICAgICAgICA9IE5lby5ucyhwcm90by5jb25zdHJ1Y3Rvci5jb25maWcuY2xhc3NOYW1lLCBmYWxzZSksXG4gICAgICAgICAgICBwcm90b3MgICAgICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGNmZywgY29uZmlnLCBjb25maWdEZXNjcmlwdG9ycywgY3RvciwgaGllcmFyY2h5SW5mbywgbnR5cGU7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIG5hbWVzcGFjZSBhbHJlYWR5IGV4aXN0cywgZGlyZWN0bHkgcmV0dXJuIGl0LlxuICAgICAgICAgKiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB1c2luZyBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgTmVvLm1qc1xuICAgICAgICAgKiA9PiBFc3BlY2lhbGx5IHNpbmdsZXRvbnMgKElkR2VuZXJhdG9yKSBtdXN0IHN0YXkgdW5pcXVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGNhbiBhbHNvIGhhcHBlbiB3aGVuIHVzaW5nIGRpZmZlcmVudCBlbnZpcm9ubWVudHMgb2YgbmVvLm1qcyBpbiBwYXJhbGxlbC5cbiAgICAgICAgICogRXhhbXBsZTogY29kZS5MaXZlUHJldmlldyBydW5uaW5nIGluc2lkZSBhIGRpc3QvcHJvZHVjdGlvbiBhcHAuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBjb2xsZWN0IGluaGVyaXRlZCBjb25maWdzIGFuZCBkZXNjcmlwdG9yc1xuICAgICAgICB3aGlsZSAocHJvdG8uX19wcm90b19fKSB7XG4gICAgICAgICAgICBjdG9yID0gcHJvdG8uY29uc3RydWN0b3I7XG5cbiAgICAgICAgICAgIC8vIElmIGEgY2xhc3MgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBoYXMgYWxyZWFkeSBoYWQgaXRzIGNvbmZpZyBhcHBsaWVkLFxuICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSBpdHMgcHJlLXByb2Nlc3NlZCBjb25maWcgYW5kIGRlc2NyaXB0b3JzIGFzIGEgYmFzZS5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGN0b3IsICdjbGFzc0NvbmZpZ0FwcGxpZWQnKSkge1xuICAgICAgICAgICAgICAgIGJhc2VDb25maWcgICAgICAgICAgICA9IE5lby5jbG9uZShjdG9yLmNvbmZpZywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYmFzZUNvbmZpZ0Rlc2NyaXB0b3JzID0gTmVvLmNsb25lKGN0b3IuY29uZmlnRGVzY3JpcHRvcnMsIHRydWUpO1xuICAgICAgICAgICAgICAgIG50eXBlQ2hhaW4gICAgICAgICAgICA9IFsuLi5jdG9yLm50eXBlQ2hhaW5dO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb3Rvcy51bnNoaWZ0KHByb3RvKTtcbiAgICAgICAgICAgIHByb3RvID0gcHJvdG8uX19wcm90b19fXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIGFjY3VtdWxhdGVkIGNvbmZpZyBhbmQgZGVzY3JpcHRvcnNcbiAgICAgICAgY29uZmlnICAgICAgICAgICAgPSBiYXNlQ29uZmlnICAgICAgICAgICAgfHwge307XG4gICAgICAgIGNvbmZpZ0Rlc2NyaXB0b3JzID0gYmFzZUNvbmZpZ0Rlc2NyaXB0b3JzIHx8IHt9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBjbGFzcyBpbiB0aGUgcHJvdG90eXBlIGNoYWluIChmcm9tIHRvcCB0byBib3R0b20pXG4gICAgICAgIHByb3Rvcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRDb25maWdEZXNjcmlwdG9ycyA9IHt9LFxuICAgICAgICAgICAgICAgIG1peGlucztcblxuICAgICAgICAgICAgY3RvciA9IGVsZW1lbnQuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBjZmcgID0gY3Rvci5jb25maWcgPyBOZW8uY2xvbmUoY3Rvci5jb25maWcsIHRydWUpIDoge307XG5cbiAgICAgICAgICAgIGlmIChOZW8ub3ZlcndyaXRlcykge1xuICAgICAgICAgICAgICAgIGN0b3IuYXBwbHlPdmVyd3JpdGVzPy4oY2ZnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggY29uZmlnIHByb3BlcnR5IGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgY2xhc3MncyBzdGF0aWMgY29uZmlnXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjZmcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGlzUmVhY3RpdmUgPSBrZXkuc2xpY2UoLTEpID09PSAnXycsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VLZXkgICAgPSBpc1JlYWN0aXZlID8ga2V5LnNsaWNlKDAsIC0xKSA6IGtleTtcblxuICAgICAgICAgICAgICAgIC8vIDEuIEhhbmRsZSBkZXNjcmlwdG9yczogSWYgdGhlIHZhbHVlIGlzIGEgZGVzY3JpcHRvciBvYmplY3QsIHN0b3JlIGl0LlxuICAgICAgICAgICAgICAgIC8vICAgIFRoZSAndmFsdWUnIHByb3BlcnR5IG9mIHRoZSBkZXNjcmlwdG9yIGlzIHRoZW4gdXNlZCBhcyB0aGUgYWN0dWFsIGNvbmZpZyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZVtpc0Rlc2NyaXB0b3JdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWdEZXNjcmlwdG9yc1tiYXNlS2V5XSA9IE5lby5jbG9uZSh2YWx1ZSwgdHJ1ZSk7IC8vIERlZXAgY2xvbmUgdG8gcHJldmVudCBtdXRhdGlvblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlIC8vIFVzZSB0aGUgZGVzY3JpcHRvcidzIHZhbHVlIGFzIHRoZSBjb25maWcgdmFsdWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAyLiBIYW5kbGUgcmVhY3RpdmUgdnMuIG5vbi1yZWFjdGl2ZSBjb25maWdzOiBHZW5lcmF0ZSBnZXR0ZXJzL3NldHRlcnMgZm9yIHJlYWN0aXZlIGNvbmZpZ3MuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNmZ1trZXldOyAgICAgIC8vIFJlbW92ZSBvcmlnaW5hbCBrZXkgd2l0aCB1bmRlcnNjb3JlXG4gICAgICAgICAgICAgICAgICAgIGNmZ1tiYXNlS2V5XSA9IHZhbHVlOyAvLyBVc2UgdGhlIHBvdGVudGlhbGx5IG1vZGlmaWVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIE5lby5jcmVhdGVDb25maWcoZWxlbWVudCwgYmFzZUtleSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBwYXJ0IGhhbmRsZXMgbm9uLXJlYWN0aXZlIGNvbmZpZ3MgKGluY2x1ZGluZyB0aG9zZSB0aGF0IHdlcmUgZGVzY3JpcHRvcnMpXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gcHJvcGVydHkgc2V0dGVyIGV4aXN0cywgZGVmaW5lIGl0IGRpcmVjdGx5IG9uIHRoZSBwcm90b3R5cGUuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIU5lby5oYXNQcm9wZXJ0eVNldHRlcihlbGVtZW50LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCBrZXksIHtlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZSwgd3JpdGFibGU6IHRydWV9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBNZXJnZSBjb25maWdEZXNjcmlwdG9yczogQXBwbHkgXCJmaXJzdC1kZWZpbmVkIHdpbnNcIiBzdHJhdGVneS5cbiAgICAgICAgICAgIC8vIElmIGEgZGVzY3JpcHRvciBmb3IgYSBrZXkgYWxyZWFkeSBleGlzdHMgKGZyb20gYSBwYXJlbnQgY2xhc3MpLCBpdCBpcyBub3Qgb3ZlcndyaXR0ZW4uXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY3VycmVudENvbmZpZ0Rlc2NyaXB0b3JzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudENvbmZpZ0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihjb25maWdEZXNjcmlwdG9ycywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRGVzY3JpcHRvcnNba2V5XSA9IGN1cnJlbnRDb25maWdEZXNjcmlwdG9yc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIG50eXBlIGFuZCBudHlwZUNoYWluXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihjZmcsICdudHlwZScpKSB7XG4gICAgICAgICAgICAgICAgbnR5cGUgPSBjZmcubnR5cGU7XG5cbiAgICAgICAgICAgICAgICBudHlwZUNoYWluLnVuc2hpZnQobnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gUnVubmluZyB0aGUgZG9jcyBhcHAgaW5zaWRlIGEgd29ya3NwYWNlIGNhbiBwdWxsIGluIHRoZSBzYW1lIGNsYXNzZXMgZnJvbSBkaWZmZXJlbnQgcm9vdHMsXG4gICAgICAgICAgICAgICAgLy8gc28gd2Ugd2FudCB0byBjaGVjayBmb3IgZGlmZmVyZW50IGNsYXNzIG5hbWVzIGFzIHdlbGxcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihudHlwZU1hcCwgbnR5cGUpICYmIGNmZy5jbGFzc05hbWUgIT09IG50eXBlTWFwW250eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG50eXBlIGNvbmZsaWN0IGZvciAnJHtudHlwZX0nIGluc2lkZSB0aGUgY2xhc3NlczpcXG4ke250eXBlTWFwW250eXBlXX1cXG4ke2NmZy5jbGFzc05hbWV9YClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBudHlwZU1hcFtudHlwZV0gPSBjZmcuY2xhc3NOYW1lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgbWl4aW5zXG4gICAgICAgICAgICBtaXhpbnMgPSBPYmplY3QuaGFzT3duKGNvbmZpZywgJ21peGlucycpICYmIGNvbmZpZy5taXhpbnMgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChjdG9yLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICBtaXhpbnMucHVzaCgnTmVvLmNvcmUuT2JzZXJ2YWJsZScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGNmZywgJ21peGlucycpICYmIEFycmF5LmlzQXJyYXkoY2ZnLm1peGlucykgJiYgY2ZnLm1peGlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWl4aW5zLnB1c2goLi4uY2ZnLm1peGlucylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1peGlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlNaXhpbnMoY3RvciwgbWl4aW5zLCBjZmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKE5lby5ucygnTmVvLmNvcmUuT2JzZXJ2YWJsZScsIGZhbHNlLCBjdG9yLnByb3RvdHlwZS5taXhpbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0b3Iub2JzZXJ2YWJsZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjZmcubWl4aW5zO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5taXhpbnM7XG5cbiAgICAgICAgICAgIC8vIEhpZXJhcmNoaWNhbCBtZXJnaW5nIG9mIHN0YXRpYyBjb25maWcgdmFsdWVzIGJhc2VkIG9uIGRlc2NyaXB0b3JzLlxuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdmFsdWVzIGFyZSBtZXJnZWQgKGUuZy4sIHNoYWxsb3cvZGVlcCkgaW5zdGVhZCBvZiBzaW1wbHkgb3ZlcndyaXR0ZW4uXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjZmcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBjb25maWdEZXNjcmlwdG9yc1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3I/Lm1lcmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1trZXldID0gTmVvLm1lcmdlQ29uZmlnKGNvbmZpZ1trZXldLCB2YWx1ZSwgZGVzY3JpcHRvci5tZXJnZSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFzc2lnbiBmaW5hbCBwcm9jZXNzZWQgY29uZmlnIGFuZCBkZXNjcmlwdG9ycyB0byB0aGUgY2xhc3MgY29uc3RydWN0b3JcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY3Rvciwge1xuICAgICAgICAgICAgICAgIGNsYXNzQ29uZmlnQXBwbGllZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWcgICAgICAgICAgICA6IE5lby5jbG9uZShjb25maWcsICAgICAgICAgICAgdHJ1ZSksIC8vIERlZXAgY2xvbmUgZmluYWwgY29uZmlnIGZvciBpbW11dGFiaWxpdHlcbiAgICAgICAgICAgICAgICBjb25maWdEZXNjcmlwdG9ycyA6IE5lby5jbG9uZShjb25maWdEZXNjcmlwdG9ycywgdHJ1ZSksIC8vIERlZXAgY2xvbmUgZmluYWwgZGVzY3JpcHRvcnMgZm9yIGltbXV0YWJpbGl0eVxuICAgICAgICAgICAgICAgIGlzQ2xhc3MgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBudHlwZUNoYWluXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgdG8gZ2xvYmFsIG5hbWVzcGFjZSBpZiBub3QgYSBzaW5nbGV0b25cbiAgICAgICAgICAgICFjb25maWcuc2luZ2xldG9uICYmIHRoaXMuYXBwbHlUb0dsb2JhbE5zKGNscylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvdG8gPSBjbHMucHJvdG90eXBlIHx8IGNscztcblxuICAgICAgICAvLyBBZGQgaXM8TnR5cGU+IGZsYWdzIHRvIHRoZSBwcm90b3R5cGVcbiAgICAgICAgbnR5cGVDaGFpbi5mb3JFYWNoKG50eXBlID0+IHtcbiAgICAgICAgICAgIHByb3RvW2BpcyR7TmVvLmNhcGl0YWxpemUoTmVvLmNhbWVsKG50eXBlKSl9YF0gPSB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIGl0J3MgYSBzaW5nbGV0b24sIGNyZWF0ZSBhbmQgYXBwbHkgdGhlIGluc3RhbmNlIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlXG4gICAgICAgIGlmIChwcm90by5zaW5nbGV0b24pIHtcbiAgICAgICAgICAgIGNscyA9IE5lby5jcmVhdGUoY2xzKTtcbiAgICAgICAgICAgIE5lby5hcHBseVRvR2xvYmFsTnMoY2xzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGNsYXNzIGhpZXJhcmNoeSBpbmZvcm1hdGlvbiB0byB0aGUgbWFuYWdlciBvciBhIHRlbXBvcmFyeSBtYXBcbiAgICAgICAgaGllcmFyY2h5SW5mbyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSAgICAgIDogcHJvdG8uY2xhc3NOYW1lLFxuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBjbHMsXG4gICAgICAgICAgICBudHlwZSAgICAgICAgICA6IE9iamVjdC5oYXNPd24ocHJvdG8sICdudHlwZScpID8gcHJvdG8ubnR5cGUgOiBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q2xhc3NOYW1lOiBwcm90by5fX3Byb3RvX18/LmNsYXNzTmFtZSB8fCBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKE5lby5tYW5hZ2VyPy5DbGFzc0hpZXJhcmNoeSkge1xuICAgICAgICAgICAgTmVvLm1hbmFnZXIuQ2xhc3NIaWVyYXJjaHkuYWRkKGhpZXJhcmNoeUluZm8pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBOZW8uY2xhc3NIaWVyYXJjaHlNYXAgPz89IHt9O1xuICAgICAgICAgICAgTmVvLmNsYXNzSGllcmFyY2h5TWFwW3Byb3RvLmNsYXNzTmFtZV0gPSBoaWVyYXJjaHlJbmZvXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xzXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0eXBlT2YoaXRlbSkge1xuICAgICAgICAvLyBSZXR1cm4gbnVsbCBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVEZXRlY3Rvclt0eXBlb2YgaXRlbV0/LihpdGVtKSB8fCBpdGVtLmNvbnN0cnVjdG9yPy5uYW1lXG4gICAgfVxufSwgTmVvKTtcblxuLyoqXG4gKiBMaXN0IG9mIGNsYXNzIHByb3BlcnRpZXMgd2hpY2ggYXJlIG5vdCBzdXBwb3NlZCB0byBnZXQgbWl4ZWQgaW50byBvdGhlciBjbGFzc2VzXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpZ25vcmVNaXhpbiA9IFtcbiAgICAnX25hbWUnLFxuICAgICdjbGFzc0NvbmZpZ0FwcGxpZWQnLFxuICAgICdjbGFzc05hbWUnLFxuICAgICdjb25zdHJ1Y3RvcicsXG4gICAgJ2lkJyxcbiAgICAnaXNDbGFzcycsXG4gICAgJ21peGluJyxcbiAgICAnbnR5cGUnLFxuICAgICdvYnNlcnZhYmxlJyxcbiAgICAndG9KU09OJ1xuXSxcblxuICAgIGNoYXJzUmVnZXggICAgICAgICA9IC9cXGQrL2csXG4gICAgZXh0cmFjdEFycmF5c1JlZ2V4ID0gL14oXFx3KylcXHMqKCg/OlxcW1xccypcXGQrXFxzKlxcXVxccyopKikkLztcblxuLyoqXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGNsc1xuICogQHBhcmFtIHtBcnJheX0gICAgICAgICBtaXhpbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgY2xhc3NDb25maWdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWl4aW5zKGNscywgbWl4aW5zLCBjbGFzc0NvbmZpZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtaXhpbnMpKSB7XG4gICAgICAgIG1peGlucyA9IFttaXhpbnNdO1xuICAgIH1cblxuICAgIGxldCBpICAgICAgICAgICAgPSAwLFxuICAgICAgICBsZW4gICAgICAgICAgPSBtaXhpbnMubGVuZ3RoLFxuICAgICAgICBtaXhpbkNsYXNzZXMgPSB7fSxcbiAgICAgICAgbWl4aW4sIG1peGluQ2xzLCBtaXhpblByb3RvO1xuXG4gICAgZm9yICg7aSA8IGxlbjtpKyspIHtcbiAgICAgICAgbWl4aW4gPSBtaXhpbnNbaV07XG5cbiAgICAgICAgaWYgKG1peGluLmlzQ2xhc3MpIHtcbiAgICAgICAgICAgIG1peGluUHJvdG8gPSBtaXhpbi5wcm90b3R5cGU7XG4gICAgICAgICAgICBtaXhpbkNscyAgID0gTmVvLm5zKG1peGluUHJvdG8uY2xhc3NOYW1lKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFleGlzdHMobWl4aW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIG1peGluIGFuIHVuZGVmaW5lZCBjbGFzczogJyArIG1peGluICsgJywgJyArIGNscy5wcm90b3R5cGUuY2xhc3NOYW1lKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaXhpbkNscyAgID0gTmVvLm5zKG1peGluKTtcbiAgICAgICAgICAgIG1peGluUHJvdG8gPSBtaXhpbkNscy5wcm90b3R5cGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1peGluUHJvdG8uY2xhc3NOYW1lLnNwbGl0KCcuJykucmVkdWNlKG1peFJlZHVjZShtaXhpbkNscyksIG1peGluQ2xhc3Nlcyk7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobWl4aW5Qcm90bykpLmZvckVhY2gobWl4aW5Qcm9wZXJ0eShjbHMucHJvdG90eXBlLCBtaXhpblByb3RvLCBjbGFzc0NvbmZpZykpXG4gICAgfVxuXG4gICAgY2xzLnByb3RvdHlwZS5taXhpbnMgPSBtaXhpbkNsYXNzZXNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9ICBjdXJyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gIHByZXZcbiAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheU5zKGNyZWF0ZSwgY3VycmVudCwgcHJldikge1xuICAgIGxldCBhcnJEZXRhaWxzID0gcGFyc2VBcnJheUZyb21TdHJpbmcoY3VycmVudCksXG4gICAgICAgIGkgICAgICAgICAgPSAxLFxuICAgICAgICBsZW4gICAgICAgID0gYXJyRGV0YWlscy5sZW5ndGgsXG4gICAgICAgIGFyckl0ZW0sIGFyclJvb3Q7XG5cbiAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgIHByZXZbYXJyRGV0YWlsc1swXV0gPSBhcnJSb290ID0gcHJldlthcnJEZXRhaWxzWzBdXSB8fCBbXVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGFyclJvb3QgPSBwcmV2W2FyckRldGFpbHNbMF1dXG4gICAgfVxuXG4gICAgaWYgKCFhcnJSb290KSByZXR1cm47XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFyckl0ZW0gPSBwYXJzZUludChhcnJEZXRhaWxzW2ldKTtcblxuICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICBhcnJSb290W2Fyckl0ZW1dID0gYXJyUm9vdFthcnJJdGVtXSB8fCB7fVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyUm9vdCA9IGFyclJvb3RbYXJySXRlbV1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyUm9vdFxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgY2xhc3MgbmFtZSBleGlzdHMgaW5zaWRlIHRoZSBOZW8gb3IgYXBwIG5hbWVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleGlzdHMoY2xhc3NOYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhY2xhc3NOYW1lLnNwbGl0KCcuJykucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJldltjdXJyZW50XVxuICAgICAgICB9LCBnbG9iYWxUaGlzKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBwcm90b1xuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBtaXhpblByb3RvXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGNsYXNzQ29uZmlnXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtaXhpblByb3BlcnR5KHByb3RvLCBtaXhpblByb3RvLCBjbGFzc0NvbmZpZykge1xuICAgIHJldHVybiBmdW5jdGlvbihba2V5LCBkZXNjcmlwdG9yXSkge1xuICAgICAgICBpZiAoaWdub3JlTWl4aW4uaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIE1peGlucyBtdXN0IG5vdCBvdmVycmlkZSBleGlzdGluZyBjbGFzcyBwcm9wZXJ0aWVzIHdpdGggYSBzZXR0ZXJcbiAgICAgICAgaWYgKE5lby5oYXNQcm9wZXJ0eVNldHRlcihwcm90bywga2V5KSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFJlYWN0aXZlIG5lbyBjb25maWdzLCBvciBwdWJsaWMgY2xhc3MgZmllbGRzIGRlZmluZWQgdmlhIGdldCgpIEFORCBzZXQoKVxuICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgJiYgZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICAgIE5lby5jcmVhdGVDb25maWcocHJvdG8sIGtleSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1peGluQ2xhc3NDb25maWcgPSBtaXhpblByb3RvLmNvbnN0cnVjdG9yLmNvbmZpZztcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24obWl4aW5DbGFzc0NvbmZpZywga2V5KSkge1xuICAgICAgICAgICAgICAgIGNsYXNzQ29uZmlnW2tleV0gPSBtaXhpbkNsYXNzQ29uZmlnW2tleV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvdG9ba2V5XT8uX2Zyb20pIHtcbiAgICAgICAgICAgIGlmIChtaXhpblByb3RvLmNsYXNzTmFtZSA9PT0gcHJvdG9ba2V5XS5fZnJvbSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWl4aW4gc2V0IG11bHRpcGxlIHRpbWVzIG9yIGFscmVhZHkgZGVmaW5lZCBvbiBhIEJhc2UgQ2xhc3MnLCBwcm90by5jbGFzc05hbWUsIG1peGluUHJvdG8uY2xhc3NOYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYCR7cHJvdG8uY2xhc3NOYW1lfTogTXVsdGlwbGUgbWl4aW5zIGRlZmluaW5nIHNhbWUgcHJvcGVydHkgKCR7bWl4aW5Qcm90by5jbGFzc05hbWV9LCAke3Byb3RvW2tleV0uX2Zyb219KSA9PiAke2tleX1gXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBwcm90b1trZXldID0gbWl4aW5Qcm90b1trZXldO1xuXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSkuX2Zyb20gPSBtaXhpblByb3RvLmNsYXNzTmFtZTtcblxuICAgICAgICBpZiAodHlwZW9mIHByb3RvW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb3RvW2tleV0uX25hbWUgPSBrZXlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gbWl4aW5DbHNcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1peFJlZHVjZShtaXhpbkNscykge1xuICAgIHJldHVybiAocHJldiwgY3VycmVudCwgaWR4LCBhcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXZbY3VycmVudF0gPSBpZHggIT09IGFyci5sZW5ndGggLTEgPyBwcmV2W2N1cnJlbnRdIHx8IHt9IDogbWl4aW5DbHNcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcnJheUZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIChleHRyYWN0QXJyYXlzUmVnZXguZXhlYyhzdHIpIHx8IFtudWxsXSkuc2xpY2UoMSkucmVkdWNlKFxuICAgICAgICAoZnVuLCBhcmdzKSA9PiBbZnVuXS5jb25jYXQoYXJncy5tYXRjaChjaGFyc1JlZ2V4KSlcbiAgICApXG59XG5cbk5lby5jb25maWcgPz89IHt9O1xuXG5OZW8uYXNzaWduRGVmYXVsdHMoTmVvLmNvbmZpZywgRGVmYXVsdENvbmZpZyk7XG5cbmV4cG9ydCBkZWZhdWx0IE5lbztcbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IEZpbHRlciAgICAgZnJvbSAnLi9GaWx0ZXIubWpzJztcbmltcG9ydCBMb2dnZXIgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBTb3J0ZXIgICAgIGZyb20gJy4vU29ydGVyLm1qcyc7XG5cbmNvbnN0XG4gICAgY291bnRNdXRhdGlvbnMgICAgID0gU3ltYm9sKCdjb3VudE11dGF0aW9ucycpLFxuICAgIGluaXRpYWxJbmRleFN5bWJvbCA9IFN5bWJvbC5mb3IoJ2luaXRpYWxJbmRleCcpLFxuICAgIGlzRmlsdGVyZWQgICAgICAgICA9IFN5bWJvbCgnaXNGaWx0ZXJlZCcpLFxuICAgIGlzU29ydGVkICAgICAgICAgICA9IFN5bWJvbCgnaXNTb3J0ZWQnKSxcbiAgICBzaWxlbnRVcGRhdGVNb2RlICAgPSBTeW1ib2woJ3NpbGVudFVwZGF0ZU1vZGUnKSxcbiAgICB0b0FkZEFycmF5ICAgICAgICAgPSBTeW1ib2woJ3RvQWRkQXJyYXknKSxcbiAgICB0b1JlbW92ZUFycmF5ICAgICAgPSBTeW1ib2woJ3RvUmVtb3ZlQXJyYXknKSxcbiAgICB1cGRhdGluZ0luZGV4ICAgICAgPSBTeW1ib2woJ3VwZGF0aW5nSW5kZXgnKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbGxlY3Rpb24uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqL1xuY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb2xsZWN0aW9uLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb2xsZWN0aW9uLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29sbGVjdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb2xsZWN0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gZmlsdGVyaW5nIHRoZSBjb2xsZWN0aW9uIGZvciB0aGUgZmlyc3QgdGltZSwgYWxsSXRlbXMgd2lsbCBiZWNvbWUgYSBuZXcgY29sbGVjdGlvbiBmb3IgdGhlIHVuZmlsdGVyZWRcbiAgICAgICAgICogc3RhdGUsIHVzaW5nIHRoaXMgaWQgYXMgdGhlIHNvdXJjZUNvbGxlY3Rpb25JZFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IGFsbEl0ZW1zPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYWxsSXRlbXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHNvcnQgdGhlIGNvbGxlY3Rpb24gaXRlbXMgd2hlbiBhZGRpbmcgLyBpbnNlcnRpbmcgbmV3IG9uZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b1NvcnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1NvcnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGl0ZW1zLmxlbmd0aCBvZiB0aGUgaXRlbXMgYXJyYXkgaW4gdXNlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY291bnRfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb3VudF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgJ3ByaW1pdGl2ZScgZm9yIGRlZmF1bHQgZmlsdGVycywgdXNlICdhZHZhbmNlZCcgZm9yIGZpbHRlcnMgdXNpbmcgYSBmaWx0ZXJCeSBtZXRob2RcbiAgICAgICAgICogd2hpY2ggbmVlZCB0byBpdGVyYXRlIG92ZXIgb3RoZXIgY29sbGVjdGlvbiBpdGVtc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGZpbHRlck1vZGU9J3ByaW1pdGl2ZSdcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlck1vZGU6ICdwcmltaXRpdmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gQXJyYXkgY29udGFpbmluZyBOZW8udXRpbC5GaWx0ZXIgY29uZmlnIG9iamVjdHMgb3IgaW5zdGFuY2VzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBmaWx0ZXJzXz1bXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlcnNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfG51bGx9IGl0ZW1zXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuaXF1ZSghKSBrZXkgcHJvcGVydHkgb2YgZWFjaCBjb2xsZWN0aW9uIGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBrZXlQcm9wZXJ0eT0naWQnXG4gICAgICAgICAqL1xuICAgICAgICBrZXlQcm9wZXJ0eTogJ2lkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGluZyBuZXcgaXRlbXMgd2l0aG91dCBhbiBpZCAoa2V5UHJvcGVydHkpIHdpbGwgdXNlIGEgbmVnYXRpdmUgaW5kZXgsIHdoaWNoIHdpbGwgZGVjcmVhc2UgYnkgLTFcbiAgICAgICAgICogZm9yIGVhY2ggbmV3IGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBrZXlQcm9wZXJ0eUluZGV4PS0xXG4gICAgICAgICAqL1xuICAgICAgICBrZXlQcm9wZXJ0eUluZGV4OiAtMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIGNvbnRhaW5pbmcgdGhlIGtleSAmIHJlZmVyZW5jZSBvZiBlYWNoIGNvbGxlY3Rpb24gaXRlbSBmb3IgZmFzdGVyIGFjY2Vzc1xuICAgICAgICAgKiBAbWVtYmVyIHtNYXB9IG1hcF89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWFwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIEFycmF5IG9mIHRoZSBzb3J0IGRpcmVjdGlvbnMgZm9yIGZhc3RlciBhY2Nlc3NcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IHNvcnREaXJlY3Rpb25zPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydERpcmVjdGlvbnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlcm5hbCBBcnJheSBvZiB0aGUgc29ydCBwcm9wZXJ0aWVzIGZvciBmYXN0ZXIgYWNjZXNzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBzb3J0UHJvcGVydGllcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRQcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gQXJyYXkgY29udGFpbmluZyBOZW8udXRpbC5Tb3J0ZXIgY29uZmlnIG9iamVjdHMgb3IgaW5zdGFuY2VzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBzb3J0ZXJzXz1bXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRlcnNfOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiBhbm90aGVyIGNvbGxlY3Rpb24gaW5zdGFuY2UgdG8gdXNlIGFzIHRoaXMgZGF0YSBzb3VyY2VcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNvdXJjZUlkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc291cmNlSWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBpbml0aWFsSW5kZXhDb3VudGVyPTBcbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXhDb3VudGVyID0gMFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzeW1ib2xDb25maWcgPSB7ZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlfTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZSwge1xuICAgICAgICAgICAgW2NvdW50TXV0YXRpb25zXSAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW2lzRmlsdGVyZWRdICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW2lzU29ydGVkXSAgICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW3NpbGVudFVwZGF0ZU1vZGVdOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgW3RvQWRkQXJyYXldICAgICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW3RvUmVtb3ZlQXJyYXldICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW3VwZGF0aW5nSW5kZXhdICAgOiB7Li4uc3ltYm9sQ29uZmlnLCB2YWx1ZTogMH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBtZS5pdGVtcyB8fCBbXTtcblxuICAgICAgICBpZiAobWUuYXV0b1NvcnQgJiYgbWUuX3NvcnRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWUuZG9Tb3J0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgaXRlbXMgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX0gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgYWRkZWQgaXRlbXNcbiAgICAgKi9cbiAgICBhZGQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UobnVsbCwgbnVsbCwgaXRlbSkuYWRkZWRJdGVtc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZmlsdGVycyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZpbHRlciA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmxpc3RlbmVyQXBwbGllZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIub24oJ2NoYW5nZScsIG1lLm9uRmlsdGVyQ2hhbmdlLCBtZSk7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmxpc3RlbmVyQXBwbGllZCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2xkVmFsdWUgJiYgbWUuZmlsdGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGl0ZW1zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJdGVtcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2tleVByb3BlcnR5fSA9IG1lLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgICAgICAgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICBtZS5tYXAuc2V0KGl0ZW1ba2V5UHJvcGVydHldLCBpdGVtKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5jb3VudCA9IGxlblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0ZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFwcGx5U29ydGVyQ29uZmlncygpO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goc29ydGVyID0+IHtcbiAgICAgICAgICAgIGlmIChzb3J0ZXIubGlzdGVuZXJBcHBsaWVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHNvcnRlci5vbignY2hhbmdlJywgbWUub25Tb3J0ZXJDaGFuZ2UsIG1lKTtcbiAgICAgICAgICAgICAgICBzb3J0ZXIubGlzdGVuZXJBcHBsaWVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5hdXRvU29ydCAmJiBtZS5kb1NvcnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc291cmNlSWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3VyY2VJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBOZW8uZ2V0KHZhbHVlKTtcblxuICAgICAgICAgICAgbWUuX2l0ZW1zID0gWy4uLnNvdXJjZS5faXRlbXNdO1xuICAgICAgICAgICAgbWUubWFwICAgID0gbmV3IE1hcChzb3VyY2UubWFwKTsgLy8gY3JlYXRlcyBhIGNsb25lIG9mIHRoZSBvcmlnaW5hbCBtYXBcblxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG11dGF0ZTogbWUub25NdXRhdGUsXG4gICAgICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc291cmNlLm9uKGxpc3RlbmVyc0NvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IE5lby5nZXQob2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIHNvdXJjZS51bihsaXN0ZW5lcnNDb25maWcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyB0aGUgc29ydCBwcm9wZXJ0eSAmIGRpcmVjdGlvbiBtdWx0aXBsaWVyIG9mIGVhY2ggc29ydGVyIGluc2lkZSAyIGFycmF5cyBmb3IgZmFzdGVyIGFjY2VzcyB3aGVuIHNvcnRpbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXBwbHlTb3J0ZXJDb25maWdzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNvcnREaXJlY3Rpb25zID0gW107XG4gICAgICAgIG1lLnNvcnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICAgICAgbWUuc29ydGVycy5mb3JFYWNoKHNvcnRlciA9PiB7XG4gICAgICAgICAgICBtZS5zb3J0RGlyZWN0aW9ucy5wdXNoKHNvcnRlci5kaXJlY3Rpb25NdWx0aXBsaWVyKTtcbiAgICAgICAgICAgIG1lLnNvcnRQcm9wZXJ0aWVzLnB1c2goc29ydGVyLnByb3BlcnR5KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IFt2YWx1ZV0gOiBbXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxlbiA9IG9sZFZhbHVlICYmIG9sZFZhbHVlLmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgaGFzTWF0Y2gsIGk7XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpICAgICAgICA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZVtpXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVtpXS5zZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBrZXkub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGtleS5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgIDoga2V5LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldLm9wZXJhdG9yID09PSAoa2V5Lm9wZXJhdG9yIHx8ICc9PT0nKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVbaV0ucHJvcGVydHkgPT09IGtleS5wcm9wZXJ0eSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVbaV0udmFsdWUgICAgPT09IGtleS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBOZW8uY3JlYXRlKEZpbHRlciwga2V5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBvbGRWYWx1ZVtpXTtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgbGVuLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAga2V5LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01hcHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TWFwfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldE1hcCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZSA/IG5ldyBNYXAoKSA6IHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gW3ZhbHVlXSA6IFtdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuID0gb2xkVmFsdWU/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgaGFzTWF0Y2gsIGk7XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpICAgICAgICA9IDA7XG5cbiAgICAgICAgICAgICAgICBsZXQge2RpcmVjdGlvbiwgcHJvcGVydHl9ID0ga2V5O1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWVbaV0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVbaV0uc2V0KHtkaXJlY3Rpb24sIHByb3BlcnR5fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWVbaV0ucHJvcGVydHkgPT09IHByb3BlcnR5ICYmIG9sZFZhbHVlW2ldLmRpcmVjdGlvbiA9PT0gZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gTmVvLmNyZWF0ZShTb3J0ZXIsIGtleSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gb2xkVmFsdWVbaV07XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGxlbi0tXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9sZFZhbHVlPy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBrZXkuZGVzdHJveSgpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhY2hlVXBkYXRlKG9wdHMpIHtcbiAgICAgICAgLy8gZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnY2FjaGVVcGRhdGUnLCBvcHRzLCB0aGlzW3RvQWRkQXJyYXldKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtrZXlQcm9wZXJ0eX0gPSBtZSxcbiAgICAgICAgICAgIGluZGV4LCB0b0FkZE1hcCwgdG9SZW1vdmVNYXA7XG5cbiAgICAgICAgaWYgKCFtZVtzaWxlbnRVcGRhdGVNb2RlXSkge1xuICAgICAgICAgICAgdG9BZGRNYXAgICAgPSBtZVt0b0FkZEFycmF5XSAgIC5tYXAoZSA9PiBlW2tleVByb3BlcnR5XSk7XG4gICAgICAgICAgICB0b1JlbW92ZU1hcCA9IG1lW3RvUmVtb3ZlQXJyYXldLm1hcChlID0+IGVba2V5UHJvcGVydHldKTtcblxuICAgICAgICAgICAgb3B0cy5hZGRlZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID0gdG9SZW1vdmVNYXAuaW5kZXhPZihpdGVtW2tleVByb3BlcnR5XSkgPiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVbdG9SZW1vdmVBcnJheV0uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9BZGRNYXAuaW5kZXhPZihpdGVtW2tleVByb3BlcnR5XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lW3RvQWRkQXJyYXldLnB1c2goaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3B0cy5yZW1vdmVkSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPSB0b0FkZE1hcC5pbmRleE9mKGl0ZW1ba2V5UHJvcGVydHldKSA+IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtZVt0b0FkZEFycmF5XS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b1JlbW92ZU1hcC5pbmRleE9mKGl0ZW1ba2V5UHJvcGVydHldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVbdG9SZW1vdmVBcnJheV0ucHVzaChpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBpdGVtcyBhbmQgY2xlYXJzIHRoZSBtYXBcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoMCwgdGhpcy5jb3VudCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbEluZGV4Q291bnRlciA9IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGN1cnJlbnQgZmlsdGVycyBhbmQgb3B0aW9uYWxseSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgb25lcyBpbiBjYXNlIHRoZXkgZXhpc3RlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXN0b3JlT3JpZ2luYWxGaWx0ZXJzPWZhbHNlXVxuICAgICAqL1xuICAgIGNsZWFyRmlsdGVycyhyZXN0b3JlT3JpZ2luYWxGaWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHJlc3RvcmVPcmlnaW5hbEZpbHRlcnMgPyBOZW8uY2xvbmUodGhpcy5vcmlnaW5hbENvbmZpZy5maWx0ZXJzLCB0cnVlLCB0cnVlKSA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBpdGVtcyBhbmQgY2xlYXJzIHRoZSBtYXAsIHdpdGhvdXQgZmlyaW5nIGEgbXV0YXRlIGV2ZW50XG4gICAgICovXG4gICAgY2xlYXJTaWxlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuX2l0ZW1zLnNwbGljZSgwLCBtZS5jb3VudCk7XG4gICAgICAgIG1lLm1hcC5jbGVhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjdXJyZW50IHNvcnRlcnMgYW5kIG9wdGlvbmFsbHkgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIG9uZXMgaW4gY2FzZSB0aGV5IGV4aXN0ZWQuXG4gICAgICogV2l0aG91dCByZXN0b3JlSW5pdGlhbFN0YXRlIGFzIHRydWUgdGhpcyB3aWxsIG5vdCBhZmZlY3QgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVzdG9yZU9yaWdpbmFsU29ydGVycz1mYWxzZV1cbiAgICAgKi9cbiAgICBjbGVhclNvcnRlcnMocmVzdG9yZU9yaWdpbmFsU29ydGVycykge1xuICAgICAgICB0aGlzLnNvcnRlcnMgPSByZXN0b3JlT3JpZ2luYWxTb3J0ZXJzID8gTmVvLmNsb25lKHRoaXMub3JpZ2luYWxDb25maWcuc29ydGVycywgdHJ1ZSwgdHJ1ZSkgOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5jb2xsZWN0aW9uLkJhc2V9IFRoZSBjbG9uZWQgY29sbGVjdGlvblxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgID0gTmVvLmNsb25lKG1lLm9yaWdpbmFsQ29uZmlnLCB0cnVlKSxcbiAgICAgICAgICAgIGZpbHRlcnMgPSBtZS5fZmlsdGVycyB8fCBbXSxcbiAgICAgICAgICAgIHNvcnRlcnMgPSBtZS5fc29ydGVycyB8fCBbXTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhlIGtleVByb3BlcnR5IGRvZXMgbm90IGdldCBsb3N0LlxuICAgICAgICBjb25maWcua2V5UHJvcGVydHkgPSBtZS5rZXlQcm9wZXJ0eTtcblxuICAgICAgICBkZWxldGUgY29uZmlnLmlkO1xuICAgICAgICBkZWxldGUgY29uZmlnLmZpbHRlcnM7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuaXRlbXM7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuc29ydGVycztcblxuICAgICAgICBpZiAobWUuX2l0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5pdGVtcyAgPSBbLi4ubWUuX2l0ZW1zXTtcbiAgICAgICAgICAgIGNvbmZpZy5jb3VudCA9IGNvbmZpZy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuZmlsdGVycyA9IFtdO1xuICAgICAgICBjb25maWcuc29ydGVycyA9IFtdO1xuXG4gICAgICAgIC8vIHRvZG86IGZpbHRlcnMgJiBzb3J0ZXJzIHNob3VsZCBwdXNoIHRoZWlyIGN1cnJlbnQgc3RhdGUgYW5kIG5vdCB0aGUgb3JpZ2luYWwgb25lXG5cbiAgICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgICAgY29uZmlnLmZpbHRlcnMucHVzaChmaWx0ZXIub3JpZ2luYWxDb25maWcpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvcnRlcnMuZm9yRWFjaChmdW5jdGlvbihzb3J0ZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zb3J0ZXJzLnB1c2goc29ydGVyLm9yaWdpbmFsQ29uZmlnKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gTmVvLmNyZWF0ZShDb2xsZWN0aW9uLCBjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBtYXAgJiBpdGVtcyBhcnJheSBiZWZvcmUgdGhlIHN1cGVyIGNhbGxcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9pdGVtcy5zcGxpY2UoMCwgbWUuX2l0ZW1zLmxlbmd0aCk7XG4gICAgICAgIG1lLm1hcC5jbGVhcigpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXM9dGhpcy5faXRlbXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkb1NvcnQoaXRlbXM9dGhpcy5faXRlbXMsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcHJldmlvdXNJdGVtcyAgICAgPSBbLi4uaXRlbXNdLFxuICAgICAgICAgICAge3NvcnRlcnMsIHNvcnREaXJlY3Rpb25zLCBzb3J0UHJvcGVydGllc30gPSBtZSxcbiAgICAgICAgICAgIGNvdW50U29ydGVycyAgICAgID0gc29ydFByb3BlcnRpZXMubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBoYXNTb3J0QnlNZXRob2QgICA9IGZhbHNlLFxuICAgICAgICAgICAgaGFzVHJhbnNmb3JtVmFsdWUgPSBmYWxzZSxcbiAgICAgICAgICAgIGksIG1hcHBlZEl0ZW1zLCBvYmosIHNvcnRlciwgc29ydFByb3BlcnR5LCBzb3J0VmFsdWU7XG5cbiAgICAgICAgaWYgKGNvdW50U29ydGVycyA+IDApIHtcbiAgICAgICAgICAgIHNvcnRlcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc29ydEJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NvcnRCeU1ldGhvZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnVzZVRyYW5zZm9ybVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1RyYW5zZm9ybVZhbHVlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaGFzU29ydEJ5TWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWUuX2l0ZW1zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBjb3VudFNvcnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVyICAgID0gc29ydGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRWYWx1ZSA9IHNvcnRlcltzb3J0ZXIuc29ydEJ5ID8gJ3NvcnRCeScgOiAnZGVmYXVsdFNvcnRCeSddKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydFZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNTb3J0aW5nX3dpdGhfbWFwXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZEl0ZW1zID0gaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0ge2luZGV4fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgICA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY291bnRTb3J0ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGVyc1tpXS51c2VUcmFuc2Zvcm1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbc29ydFByb3BlcnRpZXNbaV1dID0gc29ydGVyc1tpXS50cmFuc2Zvcm1WYWx1ZShpdGVtW3NvcnRQcm9wZXJ0aWVzW2ldXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbc29ydFByb3BlcnRpZXNbaV1dID0gaXRlbVtzb3J0UHJvcGVydGllc1tpXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVkSXRlbXMgPSBpdGVtc1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hcHBlZEl0ZW1zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBjb3VudFNvcnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydFByb3BlcnR5ID0gc29ydFByb3BlcnRpZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW3NvcnRQcm9wZXJ0eV0gPiBiW3NvcnRQcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAqIHNvcnREaXJlY3Rpb25zW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW3NvcnRQcm9wZXJ0eV0gPCBiW3NvcnRQcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBzb3J0RGlyZWN0aW9uc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNUcmFuc2Zvcm1WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5faXRlbXMgPSBtYXBwZWRJdGVtcy5tYXAoZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zW2VsLmluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lW2lzU29ydGVkXSA9IGNvdW50U29ydGVycyA+IDA7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQgJiYgbWVbdXBkYXRpbmdJbmRleF0gPT09IDApIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3NvcnQnLCB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG1lLl9pdGVtcyxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0l0ZW1zLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgdGhlIGNvbGxlY3Rpb24gZXZlbnRzLlxuICAgICAqIElmIHlvdSBzdGFydGVkIGFuIHVwZGF0ZSB1c2luZyB0aGUgc3RhcnRTaWxlbnRVcGRhdGVNb2RlIGZsYWcsXG4gICAgICogeW91IG11c3QgdXNlIHRoZSBlbmRTaWxlbnRVcGRhdGVNb2RlIHBhcmFtIGZvciB0aGlzIGNhbGwuXG4gICAgICogVXNpbmcgdGhlIGVuZFNpbGVudFVwZGF0ZU1vZGUgcGFyYW0gd2lsbCBub3QgZmlyZSBhIG11dGF0aW9uIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VuZFNpbGVudFVwZGF0ZU1vZGVdXG4gICAgICogQHNlZSB7QGxpbmsgTmVvLmNvbGxlY3Rpb24uQmFzZSNzdGFydFVwZGF0ZSBzdGFydFVwZGF0ZX1cbiAgICAgKi9cbiAgICBlbmRVcGRhdGUoZW5kU2lsZW50VXBkYXRlTW9kZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lW3VwZGF0aW5nSW5kZXhdID4gMCkge1xuICAgICAgICAgICAgbWVbdXBkYXRpbmdJbmRleF0tLVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZFNpbGVudFVwZGF0ZU1vZGUpIHtcbiAgICAgICAgICAgIG1lW3NpbGVudFVwZGF0ZU1vZGVdID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ211dGF0ZScsIHtcbiAgICAgICAgICAgICAgICBhZGRlZEl0ZW1zICA6IG1lW3RvQWRkQXJyYXldLFxuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtczogbWVbdG9SZW1vdmVBcnJheV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZVt0b0FkZEFycmF5XSAgIC5zcGxpY2UoMCwgbWVbdG9BZGRBcnJheV0gICAubGVuZ3RoKTtcbiAgICAgICAgICAgIG1lW3RvUmVtb3ZlQXJyYXldLnNwbGljZSgwLCBtZVt0b1JlbW92ZUFycmF5XS5sZW5ndGgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWVkZWQgZm9yIHJlbW90ZSBmaWx0ZXJpbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgZXhwb3J0RmlsdGVycygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmlsdGVycyA9IFtdLFxuICAgICAgICAgICAgZmlsdGVyO1xuXG4gICAgICAgIG1lLmZpbHRlcnM/LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGZpbHRlciA9IGtleS5leHBvcnQoKTtcblxuICAgICAgICAgICAgZmlsdGVyICYmIGZpbHRlcnMucHVzaChmaWx0ZXIpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciByZW1vdGUgc29ydGluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBleHBvcnRTb3J0ZXJzKCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzb3J0ZXJzID0gW10sXG4gICAgICAgICAgICBzb3J0ZXI7XG5cbiAgICAgICAgbWUuc29ydGVycz8uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgc29ydGVyID0ga2V5LmV4cG9ydCgpO1xuXG4gICAgICAgICAgICBzb3J0ZXIgJiYgc29ydGVycy5wdXNoKHNvcnRlcilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNvcnRlcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZmlsdGVyKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpbHRlcnMgICAgICAgICA9IG1lLl9maWx0ZXJzLFxuICAgICAgICAgICAgY291bnRBbGxGaWx0ZXJzID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICAgICAgICBjb3VudEZpbHRlcnMgICAgPSAwLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICAgID0gbWUuYWxsSXRlbXM/Ll9pdGVtcyB8fCBtZS5faXRlbXMsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgY291bnRJdGVtcyAgICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcyAgID0gW10sXG4gICAgICAgICAgICBuZWVkc1NvcnRpbmcgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG9sZEl0ZW1zICAgICAgICA9IFsuLi5tZS5faXRlbXNdLFxuICAgICAgICAgICAgY29uZmlnLCBpc0luY2x1ZGVkLCBpdGVtLCBqLCB0bXBJdGVtcztcblxuICAgICAgICBmb3IgKDsgaSA8IGNvdW50QWxsRmlsdGVyczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcnNbaV0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjb3VudEZpbHRlcnMrK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvdW50RmlsdGVycyA9PT0gMCAmJiBtZS5hbGxJdGVtcykge1xuICAgICAgICAgICAgaWYgKG1lLnNvcnRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG5lZWRzU29ydGluZyA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuY2xlYXJTaWxlbnQoKTtcblxuICAgICAgICAgICAgbWUuaXRlbXMgPSBbLi4ubWUuYWxsSXRlbXMuX2l0ZW1zXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtZS5hbGxJdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHsuLi5tZS5vcmlnaW5hbENvbmZpZ307XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLmZpbHRlcnM7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5pdGVtcztcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLnNvcnRlcnM7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIGEgY29sbGVjdGlvbiBpcyBmaWx0ZXJlZCwgaXQgY2xvbmVzIGl0c2VsZiB0byBjcmVhdGUgYW4gYGFsbEl0ZW1zYCBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggc3RvcmVzIHRoZSB1bmZpbHRlcmVkIGRhdGEuIEl0IGlzIGNydWNpYWwgdG8gdXNlIGBtZS5jb25zdHJ1Y3RvcmAgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXJkY29kZSBgQ29sbGVjdGlvbmAsIHN1YmNsYXNzZXMgbGlrZSBgZGF0YS5TdG9yZWAgd291bGQgbG9zZSB0aGVpciBzcGVjaWZpY1xuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxpdGllcyAoZS5nLiwgbGF6eSByZWNvcmQgaW5zdGFudGlhdGlvbiBvbiBgZ2V0KClgKSBmb3IgdGhlIGBhbGxJdGVtc2AgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcyA9IE5lby5jcmVhdGUobWUuY29uc3RydWN0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uTmVvLmNsb25lKGNvbmZpZywgdHJ1ZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICAgOiBtZS5pZCArICctYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgICAgICA6IFsuLi5tZS5faXRlbXNdLCAvLyBJbml0aWFsaXplIHdpdGggYSBzaGFsbG93IGNvcHkgb2YgY3VycmVudCBpdGVtc1xuICAgICAgICAgICAgICAgICAgICBrZXlQcm9wZXJ0eTogbWUua2V5UHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkICAgOiBtZS5pZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLm1hcC5jbGVhcigpO1xuXG4gICAgICAgICAgICBpZiAobWUuZmlsdGVyTW9kZSA9PT0gJ3ByaW1pdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBmb3IgbG9vcHMgb24gcHVycG9zZSAtPiBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudEl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gICAgICAgPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaiAgICAgICAgICA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGogPCBjb3VudEFsbEZpbHRlcnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcnNbal0uaXNGaWx0ZXJlZChpdGVtLCBpdGVtcywgaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbmNsdWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUubWFwLnNldChpdGVtW21lLmtleVByb3BlcnR5XSwgaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLl9pdGVtcyA9IGZpbHRlcmVkSXRlbXMgLy8gc2lsZW50IHVwZGF0ZSwgdGhlIG1hcCBpcyBhbHJlYWR5IGluIHBsYWNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMgPSBbLi4uaXRlbXNdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqPTA7IGogPCBjb3VudEFsbEZpbHRlcnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0bXBJdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudEl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyc1tqXS5pc0ZpbHRlcmVkKGZpbHRlcmVkSXRlbXNbaV0sIGZpbHRlcmVkSXRlbXMsIGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEl0ZW1zLnB1c2goZmlsdGVyZWRJdGVtc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMgPSBbLi4udG1wSXRlbXNdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudEl0ZW1zICAgID0gZmlsdGVyZWRJdGVtcy5sZW5ndGhcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5pdGVtcyA9IGZpbHRlcmVkSXRlbXMgLy8gdXBkYXRlIHRoZSBtYXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lW2lzRmlsdGVyZWRdID0gY291bnRGaWx0ZXJzICE9PSAwO1xuXG4gICAgICAgIGlmIChuZWVkc1NvcnRpbmcpIHtcbiAgICAgICAgICAgIG1lLmRvU29ydChtZS5pdGVtcywgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNvdW50ID0gbWUuaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIG1lLmZpcmUoJ2ZpbHRlcicsIHtcbiAgICAgICAgICAgIGlzRmlsdGVyZWQ6IG1lW2lzRmlsdGVyZWRdLFxuICAgICAgICAgICAgaXRlbXMgICAgIDogbWUuaXRlbXMsXG4gICAgICAgICAgICBvbGRJdGVtcyxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtcyB3aGljaCBtYXRjaCB0aGUgcHJvcGVydHkgYW5kIHZhbHVlLlxuICAgICAqIFByb3BlcnRpZXMgY2FuIGNvbnRhaW4gZG90cyBmb3IgbmFtZXNwYWNlcyA9PiBmaW5kKCd2ZG9tLmlkJywgJ25lby12bm9kZS0xJylcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbdmFsdWVdIE9ubHkgcmVxdWlyZWQgaW4gY2FzZSB0aGUgZmlyc3QgcGFyYW0gaXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfVxuICAgICAqICAgICByZXR1cm5GaXJzdE1hdGNoPWZhbHNlOiBSZXR1cm5zIGFuIGVtcHR5IEFycmF5IGluIGNhc2Ugbm8gaXRlbXMgYXJlIGZvdW5kXG4gICAgICogICAgIHJldHVybkZpcnN0TWF0Y2g9dHJ1ZTogIFJldHVybnMgdGhlIGZpcnN0IGZvdW5kIGl0ZW0gb3IgbnVsbFxuICAgICAqL1xuICAgIGZpbmQocHJvcGVydHksIHZhbHVlLCByZXR1cm5GaXJzdE1hdGNoPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGlzT2JqZWN0UHJvcGVydHkgPSBtZS5pc0l0ZW0ocHJvcGVydHkpLFxuICAgICAgICAgICAgaXRlbSwgbWF0Y2hBcnJheSwgcHJvcGVydGllc0FycmF5LCBwcm9wZXJ0aWVzTGVuZ3RoO1xuXG4gICAgICAgIGlmIChpc09iamVjdFByb3BlcnR5KSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzQXJyYXkgID0gT2JqZWN0LmVudHJpZXMocHJvcGVydHkpO1xuICAgICAgICAgICAgcHJvcGVydGllc0xlbmd0aCA9IHByb3BlcnRpZXNBcnJheS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZW0gb2YgbWUuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hBcnJheSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgcHJvcGVydGllc0FycmF5LmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLm5zKGtleSwgZmFsc2UsIGl0ZW0pID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBcnJheS5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaEFycmF5Lmxlbmd0aCA9PT0gcHJvcGVydGllc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuRmlyc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5ucyhwcm9wZXJ0eSwgZmFsc2UsIGl0ZW0pID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybkZpcnN0TWF0Y2ggPyBudWxsIDogaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiBmb3Igd2hpY2ggdGhlIHBhc3NlZCBmdW5jdGlvbiByZXR1cm5zIHRydWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcnVuIGZvciBlYWNoIGl0ZW0gaW5zaWRlIHRoZSBzdGFydC1lbmQgcmFuZ2UuIFJldHVybiB0cnVlIGZvciBhIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmbi5pdGVtIFRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10aGlzIFRoZSBzY29wZSBpbiB3aGljaCB0aGUgcGFzc2VkIGZ1bmN0aW9uIGdldHMgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQ9MCBUaGUgc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kPXRoaXMuY291bnQgVGhlIGVuZCBpbmRleCAodXAgdG8sIGxhc3QgdmFsdWUgZXhjbHVkZWQpXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGVtcHR5IEFycmF5IGluIGNhc2Ugbm8gaXRlbXMgYXJlIGZvdW5kXG4gICAgICovXG4gICAgZmluZEJ5KGZuLCBzY29wZT10aGlzLCBzdGFydD0wLCBlbmQ9dGhpcy5jb3VudCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgICAgIGkgICAgID0gc3RhcnQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZuLmNhbGwoc2NvcGUsIG1lLml0ZW1zW2ldKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobWUuaXRlbXNbaV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIHdoaWNoIG1hdGNoZXMgdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFt2YWx1ZV0gT25seSByZXF1aXJlZCBpbiBjYXNlIHRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGZpcnN0IGZvdW5kIGl0ZW0gb3IgbnVsbFxuICAgICAqL1xuICAgIGZpbmRGaXJzdChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZChwcm9wZXJ0eSwgdmFsdWUsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSBpbnNpZGUgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdCgwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9iamVjdCBhc3NvY2lhdGVkIHRvIHRoZSBrZXksIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXQoa2V5KSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBmb3IgYSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldEF0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tpbmRleF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25maWcgdmFsdWUgb2YgdGhpcy5jb3VudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGB0aGlzLmNvdW50YCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGdldENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY291bnQgfHwgMCAvLyBza2lwcGluZyBiZWZvcmVHZXRDb3VudCgpIG9uIHB1cnBvc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvdW50TXV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tjb3VudE11dGF0aW9uc11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBtYXRjaGluZyBmaWx0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbGxlY3Rpb24uRmlsdGVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0RmlsdGVyKHByb3BlcnR5KSB7XG4gICAgICAgIGxldCBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzIHx8IFtdLFxuICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgID0gZmlsdGVycy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0ucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcnNbaV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUga2V5IGZvciBhIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge051bWJlcnxTdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldEtleUF0KGluZGV4KSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuICAgICAgICByZXR1cm4gaXRlbT8uW3RoaXMua2V5UHJvcGVydHldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNoYWxsb3cgY29weSBvZiBhIHBvcnRpb24gb2YgdGhlIGl0ZW1zIGFycmF5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBiZWdpbiBleHRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kXSBaZXJvLWJhc2VkIGluZGV4IGJlZm9yZSB3aGljaCB0byBlbmQgZXh0cmFjdGlvbiAoZXh0cmFjdHMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kKS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2VcbiAgICAgKi9cbiAgICBnZXRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5zbGljZShzdGFydCwgZW5kKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNvdXJjZSBDb2xsZWN0aW9uIGluIGNhc2UgdGhlIHNvdXJjZUNvbGxlY3Rpb25JZCBjb25maWcgd2FzIHNldFxuICAgICAqIEByZXR1cm5zIHtOZW8uY29sbGVjdGlvbi5CYXNlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRTb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUlkICYmIE5lby5nZXQodGhpcy5zb3VyY2VJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBhc3NlcnRpbmcgd2hldGhlciBhIHZhbHVlIGhhcyBiZWVuIGFzc29jaWF0ZWQgdG8gdGhlIGtleSBpbiB0aGUgQ29sbGVjdGlvbiBvciBub3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyhrZXkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gYXNzZXJ0aW5nIHdoZXRoZXIgYW4gaXRlbSBleGlzdHMgaW4gdGhlIENvbGxlY3Rpb24gb3Igbm90XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNJdGVtKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyhpdGVtW3RoaXMua2V5UHJvcGVydHldKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IGZvciBhIGdpdmVuIGtleSBvciBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE9iamVjdH0ga2V5XG4gICAgICogQHJldHVybnMge051bWJlcn0gaW5kZXggKC0xIGluIGNhc2Ugbm8gbWF0Y2ggaXMgZm91bmQpXG4gICAgICovXG4gICAgaW5kZXhPZihrZXkpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1lLl9pdGVtcy5pbmRleE9mKG1lLmlzSXRlbShrZXkpID8ga2V5IDogbWUubWFwLmdldChrZXkpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IGZvciBhIGdpdmVuIGl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGluZGV4ICgtMSBpbiBjYXNlIG5vIG1hdGNoIGlzIGZvdW5kKVxuICAgICAqL1xuICAgIGluZGV4T2ZJdGVtKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGluZGV4ICgtMSBpbiBjYXNlIG5vIG1hdGNoIGlzIGZvdW5kKVxuICAgICAqL1xuICAgIGluZGV4T2ZLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5pbmRleE9mKHRoaXMubWFwLmdldChrZXkpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gaXRlbSBvciBhbiBhcnJheSBvZiBpdGVtcyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119IGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGFkZGVkIGl0ZW1zXG4gICAgICovXG4gICAgaW5zZXJ0KGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgaXRlbSkuYWRkZWRJdGVtc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIGNvbGxlY3Rpb24gaXMgZmlsdGVyZWRcbiAgICAgKi9cbiAgICBpc0ZpbHRlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tpc0ZpbHRlcmVkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzRmlsdGVyZWRJdGVtKGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmlsdGVycyAgICA9IG1lLl9maWx0ZXJzLFxuICAgICAgICAgICAgaSAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICAgICAgICBpc0ZpbHRlcmVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0uaXNGaWx0ZXJlZChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlzRmlsdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNGaWx0ZXJlZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY2hlY2sgaWYgYSBnaXZlbiBpbnB1dCBpcyBlaXRoZXIgb2JqZWN0LWxpa2Ugb3IgYSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJldHVybnMgdHJ1ZSBmb3Igb2JqZWN0LWxpa2UgdmFsdWVzXG4gICAgICovXG4gICAgaXNJdGVtKHZhbHVlKSB7XG4gICAgICAgIC8vIFdlIGNhbiBub3QgdXNlIE5lby5pc09iamVjdCgpIHx8IE5lby5pc1JlY29yZCgpLCBzaW5jZSBjb2xsZWN0aW9ucyBjYW4gc3RvcmUgbmVvIGluc3RhbmNlcyB0b28uXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaW4gY2FzZSB0aGUgY29sbGVjdGlvbiBpcyBzb3J0ZWRcbiAgICAgKi9cbiAgICBpc1NvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbaXNTb3J0ZWRdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIGluc2lkZSB0aGUgY29sbGVjdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXQodGhpcy5jb3VudCAtMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBpdGVtIGZyb20gZnJvbUluZGV4IHRvIHRvSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXhcbiAgICAgKi9cbiAgICBtb3ZlKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICBpZiAoZnJvbUluZGV4ID09PSB0b0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLl9pdGVtcztcblxuICAgICAgICBpZiAoZnJvbUluZGV4ID49IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbUluZGV4ID0gaXRlbXMubGVuZ3RoIC0gMVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHNwbGljZSBvcGVyYXRpb25zIGFyZSBpbnRlbnRpb25hbGx5IHNlcGFyYXRlZC5cbiAgICAgICAgLy8gVXNpbmcgdGhlIGNvbW1vbiBvbmUtbGluZXIgYGl0ZW1zLnNwbGljZSh0b0luZGV4LCAwLCBpdGVtcy5zcGxpY2UoZnJvbUluZGV4LCAxKVswXSlgXG4gICAgICAgIC8vIGNhbiBsZWFkIHRvIHVucHJlZGljdGFibGUgc2lkZSBlZmZlY3RzLCBhcyB0aGUgaW5uZXIgc3BsaWNlIGNhbiBhbHRlciB0aGUgYXJyYXlcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBvdXRlciBzcGxpY2UncyBpbmRleCBpcyByZXNvbHZlZC4gVGhpcyB0d28tc3RlcCBhcHByb2FjaCBpcyBzYWZlci5cbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zLnNwbGljZShmcm9tSW5kZXgsIDEpWzBdO1xuICAgICAgICBpdGVtcy5zcGxpY2UodG9JbmRleCwgMCwgaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZpbHRlckNoYW5nZShvcHRzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbk11dGF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gdG9kbzogaW5zcGVjdCB0aGUgYnViYmxpbmcgY2hhaW5cbiAgICAgICAgLyppZiAob3B0cy5wcmV2ZW50QnViYmxlVXApIHtcbiAgICAgICAgICAgIG1lLnByZXZlbnRCdWJibGVVcCA9IHRydWVcbiAgICAgICAgfSovXG5cbiAgICAgICAgbWUucHJldmVudEJ1YmJsZVVwID0gdHJ1ZTtcblxuICAgICAgICBtZS5zcGxpY2UobnVsbCwgb3B0cy5yZW1vdmVkSXRlbXMsIG9wdHMuYWRkZWRJdGVtcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNvcnRlckNoYW5nZShvcHRzKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTb3J0ZXJDb25maWdzKCk7XG4gICAgICAgIHRoaXMuZG9Tb3J0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgaXRlbXMgYXJyYXkgYW5kIHJldHVybnMgdGhpcyBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZW1vdmVkIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbjsgdW5kZWZpbmVkIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIHBvcCgpIHtcbiAgICAgICAgbGV0IG11dGF0aW9uID0gdGhpcy5zcGxpY2UodGhpcy5jb3VudCAtMSwgMSk7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi5yZW1vdmVkSXRlbXNbMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIGl0ZW1zIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24gYW5kIHJldHVybnMgdGhlIG5ldyBpdGVtcyBjb3VudFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgcHVzaChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBnaXZlbiBrZXksIGl0ZW0gb3IgQXJyYXkgY29udGFpbmluZyBrZXlzfGl0ZW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE9iamVjdHxBcnJheX0ga2V5XG4gICAgICogQHJldHVybnMge051bWJlcn0gdGhlIGNvbGxlY3Rpb24gY291bnRcbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKDAsIEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IFtrZXldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgcmVtb3ZlQXQoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBpdGVtcyBhcnJheSBpbiBwbGFjZS5cbiAgICAgKiBJbnRlbmRlZCBmb3IgY29sbGVjdGlvbnMgd2l0aG91dCBzb3J0ZXJzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gaXRlbXNcbiAgICAgKi9cbiAgICByZXZlcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMucmV2ZXJzZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBpdGVtcyBhcnJheSBhbmQgcmV0dXJucyB0aGlzIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJlbW92ZWQgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uOyB1bmRlZmluZWQgaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuXG4gICAgICovXG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGxldCBtdXRhdGlvbiA9IHRoaXMuc3BsaWNlKDAsIDEpO1xuICAgICAgICByZXR1cm4gbXV0YXRpb24uYWRkZWRJdGVtc1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggaXRlbSwgdGFraW5nIHRocmVlIHBhcmFtZXRlcnM6XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgY2FsbGJhY2suaXRlbSBUaGUgY3VycmVudCBjb2xsZWN0aW9uIGl0ZW0gYmVpbmcgcHJvY2Vzc2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBbY2FsbGJhY2suaW5kZXhdIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBpdGVtIGJlaW5nIHByb2Nlc3NlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgW2NhbGxiYWNrLml0ZW1zXSBUaGUgaXRlbXMgYXJyYXkgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFZhbHVlIHRvIHVzZSBhcyBcInRoaXNcIiB3aGVuIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgYW55IGNvbGxlY3Rpb24gaXRlbSwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgc29tZSguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5zb21lKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBmbmAuXG4gICAgICovXG4gICAgZm9yRWFjaChmbiwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5faXRlbXMuZm9yRWFjaChmbiwgc2NvcGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgaXRlbXMgZnJvbSBhbmQvb3IgYWRkcyBpdGVtcyB0byB0aGlzIGNvbGxlY3Rpb25cbiAgICAgKiBJZiB0aGUgdG9SZW1vdmVBcnJheSBpcyB1c2VkLCB0aGVuIHRoZSBpbmRleCBpcyBub3QgdXNlZCBmb3IgcmVtb3ZpbmcsIHRoZSBlbnRyaWVzIGFyZSBmb3VuZCBieSBrZXkgYW5kIHJlbW92ZWQgZnJvbSB3aGVyZSB0aGV5IGFyZS5cbiAgICAgKiBJZiBpbmRleCBpcyBub3QgcGFzc2VkLCB0b0FkZEFycmF5IGlzIGFwcGVuZGVkIHRvIHRoZSBDb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0W119IFtyZW1vdmVDb3VudE9yVG9SZW1vdmVBcnJheV1cbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gW3RvQWRkQXJyYXldXG4gICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGFkZGVkSXRlbXMgJiByZW1vdmVkSXRlbXMgYXJyYXlzXG4gICAgICovXG4gICAgc3BsaWNlKGluZGV4LCByZW1vdmVDb3VudE9yVG9SZW1vdmVBcnJheSwgdG9BZGRBcnJheSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtrZXlQcm9wZXJ0eSwgbWFwfSA9IG1lLFxuICAgICAgICAgICAgc291cmNlICAgICAgICAgICAgID0gbWUuZ2V0U291cmNlKCksXG4gICAgICAgICAgICBhZGRlZEl0ZW1zICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgICAgICAgICA9IG1lLl9pdGVtcyxcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcyAgICAgICA9IFtdLFxuICAgICAgICAgICAgcmVtb3ZlQ291bnRBdEluZGV4ID0gTmVvLmlzTnVtYmVyKHJlbW92ZUNvdW50T3JUb1JlbW92ZUFycmF5KSA/IHJlbW92ZUNvdW50T3JUb1JlbW92ZUFycmF5IDogbnVsbCxcbiAgICAgICAgICAgIHRvUmVtb3ZlQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXkocmVtb3ZlQ291bnRPclRvUmVtb3ZlQXJyYXkpID8gcmVtb3ZlQ291bnRPclRvUmVtb3ZlQXJyYXkgOiBudWxsLFxuICAgICAgICAgICAgaSwgaXRlbSwga2V5LCBsZW4sIHRvQWRkTWFwO1xuXG4gICAgICAgIGlmICghTmVvLmlzTnVtYmVyKGluZGV4KSAmJiByZW1vdmVDb3VudEF0SW5kZXgpIHtcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihtZS5pZCArICc6IElmIGluZGV4IGlzIG5vdCBwYXNzZWQsIHJlbW92ZUNvdW50QXRJbmRleCBjYW5ub3QgYmUgdXNlZCcpXG4gICAgICAgIH1cblxuICAgICAgICB0b0FkZEFycmF5ID0gdG9BZGRBcnJheSAmJiAhQXJyYXkuaXNBcnJheSh0b0FkZEFycmF5KSA/IFt0b0FkZEFycmF5XSA6IHRvQWRkQXJyYXk7XG5cbiAgICAgICAgaWYgKHRvUmVtb3ZlQXJyYXkgJiYgKGxlbiA9IHRvUmVtb3ZlQXJyYXkubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgICAgIGlmICh0b0FkZEFycmF5ICYmIHRvQWRkQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRvQWRkTWFwID0gdG9BZGRBcnJheS5tYXAoZSA9PiBlW2tleVByb3BlcnR5XSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpPTA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b1JlbW92ZUFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGtleSAgPSBtZS5pc0l0ZW0oaXRlbSkgPyBpdGVtW2tleVByb3BlcnR5XSA6IGl0ZW07XG5cbiAgICAgICAgICAgICAgICBpZiAobWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdG9BZGRNYXAgfHwgKHRvQWRkTWFwICYmIHRvQWRkTWFwLmluZGV4T2Yoa2V5KSA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXMucHVzaChpdGVtcy5zcGxpY2UobWUuaW5kZXhPZktleShrZXkpLCAxKVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZW1vdmVDb3VudEF0SW5kZXggJiYgcmVtb3ZlQ291bnRBdEluZGV4ID4gMCkge1xuICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBJZiB0aGlzIGlzIGEgZnVsbCBjbGVhciBvcGVyYXRpb24sIHVzZSBtYXAuY2xlYXIoKVxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIHJlbW92ZUNvdW50QXRJbmRleCA9PT0gbWUuY291bnQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXMgPSBpdGVtcztcbiAgICAgICAgICAgICAgICBtZS5faXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBtYXAuY2xlYXIoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXMgPSBpdGVtcy5zcGxpY2UoaW5kZXgsIHJlbW92ZUNvdW50QXRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgcGFydGlhbCByZW1vdmFscywgaXRlcmF0ZSBhbmQgZGVsZXRlIGluZGl2aWR1YWwgaXRlbXMgZnJvbSB0aGUgbWFwXG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5kZWxldGUoZVtrZXlQcm9wZXJ0eV0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b0FkZEFycmF5ICYmIChsZW4gPSB0b0FkZEFycmF5Lmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRvQWRkQXJyYXlbaV07XG4gICAgICAgICAgICAgICAga2V5ICA9IGl0ZW1ba2V5UHJvcGVydHldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtrZXlQcm9wZXJ0eV0gPSBrZXkgPSBtZS5rZXlQcm9wZXJ0eUluZGV4O1xuICAgICAgICAgICAgICAgICAgICBtZS5rZXlQcm9wZXJ0eUluZGV4LS1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgaXRlbSBoYXMgdGhlIHN5bWJvbCBkZWZpbmVkIChlLmcuLCBpbml0aWFsaXplZCB0byBudWxsIHZpYSBSZWNvcmRGYWN0b3J5KS5cbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gYXNzaWduIHRoZSBjb3VudGVyIHRvIGl0ZW1zIHRoYXQgb3B0LWluIHRvIHRoaXMgZmVhdHVyZSB0byBzdXBwb3J0XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBpbnNlcnRpb24gb3JkZXIgKGUuZy4sIFN0b3JlLnNvcnQoKSB3aXRoIG5vIGFyZ3MpLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgcG9sbHV0aW5nIHBsYWluIG9iamVjdHMgaW4gc3RhbmRhcmQgQ29sbGVjdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaXRlbSwgaW5pdGlhbEluZGV4U3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW2luaXRpYWxJbmRleFN5bWJvbF0gPSBtZS5pbml0aWFsSW5kZXhDb3VudGVyKytcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hcC5oYXMoa2V5KSAmJiAhbWUuaXNGaWx0ZXJlZEl0ZW0oaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KGtleSwgaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhZGRlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zIHx8IGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtYW5jZSBpbXByb3ZlbWVudCBmb3IgU2FmYXJpLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy82MjI4XG4gICAgICAgICAgICAgICAgICAgIG1lLl9pdGVtcyA9IGFkZGVkSXRlbXNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbEluZGV4ID0gTmVvLmlzTnVtYmVyKGluZGV4KSA/IGluZGV4IDogaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRlZEl0ZW1zLmxlbmd0aCA+IDUwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNwbGljZSBmb3IgbGFyZ2UgYXJyYXlzIHRvIGF2b2lkIGEgc3RhY2sgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJlZ2lubmluZyA9IGl0ZW1zLnNsaWNlKDAsIGZpbmFsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kICAgICAgID0gaXRlbXMuc2xpY2UoZmluYWxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5faXRlbXMgICAgICAgPSBiZWdpbm5pbmcuY29uY2F0KGFkZGVkSXRlbXMsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoZmluYWxJbmRleCwgMCwgLi4uYWRkZWRJdGVtcylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtZS5hdXRvU29ydCAmJiBtZS5fc29ydGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRvU29ydCh1bmRlZmluZWQsIHRydWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuZ2V0U291cmNlKCkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UucHJldmVudEJ1YmJsZVVwID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1lLnByZXZlbnRCdWJibGVVcCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzb3VyY2Ugc3BsaWNlJywgc291cmNlLmlkLCAnYWRkZWQ6JywgLi4udG9BZGRBcnJheSwgJ3JlbW92ZWQ6JywgLi4ucmVtb3ZlZEl0ZW1zKTtcbiAgICAgICAgICAgICAgICBtZS5zdGFydFVwZGF0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc3BsaWNlKG51bGwsIHRvUmVtb3ZlQXJyYXkgfHwgcmVtb3ZlZEl0ZW1zLCB0b0FkZEFycmF5KTtcbiAgICAgICAgICAgICAgICBtZS5lbmRVcGRhdGUodHJ1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZS5wcmV2ZW50QnViYmxlVXBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRlZEl0ZW1zLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1lW2NvdW50TXV0YXRpb25zXSsrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVbdXBkYXRpbmdJbmRleF0gPT09IDApIHtcbiAgICAgICAgICAgIG1lLmNvdW50ID0gbWUuX2l0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgbWUuZmlyZSgnbXV0YXRlJywge1xuICAgICAgICAgICAgICAgIGFkZGVkSXRlbXMgICAgIDogdG9BZGRBcnJheSxcbiAgICAgICAgICAgICAgICBwcmV2ZW50QnViYmxlVXA6IG1lLnByZXZlbnRCdWJibGVVcCxcbiAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXMgICA6IHRvUmVtb3ZlQXJyYXkgfHwgcmVtb3ZlZEl0ZW1zXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKCFtZVtzaWxlbnRVcGRhdGVNb2RlXSkge1xuICAgICAgICAgICAgbWUuY2FjaGVVcGRhdGUoe1xuICAgICAgICAgICAgICAgIGFkZGVkSXRlbXMsXG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lW3VwZGF0aW5nSW5kZXhdID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbWUucHJldmVudEJ1YmJsZVVwXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge2FkZGVkSXRlbXMsIHJlbW92ZWRJdGVtc31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgY29sbGVjdGlvbiBmcm9tIGZpcmluZyBldmVudHMgdW50aWwgZW5kVXBkYXRlIGdldHMgY2FsbGVkLlxuICAgICAqIElmIHlvdSBzdGFydCBhbiB1cGRhdGUgdXNpbmcgdGhlIHN0YXJ0U2lsZW50VXBkYXRlTW9kZSBwYXJhbSxcbiAgICAgKiB0aGUgbXV0YXRpb24gZXZlbnQgd2lsbCBub3QgZmlyZSBhZnRlciB1c2luZyBlbmRVcGRhdGUoKVxuICAgICAqICh5b3UgbXVzdCB1c2UgdGhlIGVuZFNpbGVudFVwZGF0ZU1vZGUgcGFyYW0gZm9yIHRoZSBlbmRVcGRhdGUgY2FsbCBpbiBjYXNlIHlvdSB1c2VkXG4gICAgICogc3RhcnRTaWxlbnRVcGRhdGVNb2RlIGhlcmUpXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc3RhcnRTaWxlbnRVcGRhdGVNb2RlXVxuICAgICAqIEBzZWUge0BsaW5rIE5lby5jb2xsZWN0aW9uLkJhc2UjZW5kVXBkYXRlIGVuZFVwZGF0ZX1cbiAgICAgKi9cbiAgICBzdGFydFVwZGF0ZShzdGFydFNpbGVudFVwZGF0ZU1vZGUpIHtcbiAgICAgICAgaWYgKHN0YXJ0U2lsZW50VXBkYXRlTW9kZSkge1xuICAgICAgICAgICAgdGhpc1tzaWxlbnRVcGRhdGVNb2RlXSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbdXBkYXRpbmdJbmRleF0rK1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgY291bnQgICAgICA6IG1lLmNvdW50LFxuICAgICAgICAgICAgZmlsdGVycyAgICA6IG1lLmZpbHRlcnMubWFwKGZpbHRlciA9PiBmaWx0ZXIudG9KU09OKCkpLFxuICAgICAgICAgICAga2V5UHJvcGVydHk6IG1lLmtleVByb3BlcnR5LFxuICAgICAgICAgICAgc29ydGVycyAgICA6IG1lLnNvcnRlcnMubWFwKHNvcnRlciA9PiBzb3J0ZXIudG9KU09OKCkpLFxuICAgICAgICAgICAgc291cmNlSWQgICA6IG1lLnNvdXJjZUlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIGVsZW1lbnRzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24gYW5kIHJldHVybnMgdGhlIG5ldyBpdGVtcyBjb3VudFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgdW5zaGlmdChpdGVtKSB7XG4gICAgICAgIHRoaXMuc3BsaWNlKDAsIDAsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudFxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbXV0YXRlIGV2ZW50IGZpcmVzIGFmdGVyIGV2ZXJ5IHNwbGljZSBjYWxsIChpbnZva2VkIGJ5IGFsbCBtZXRob2RzIHdoaWNoIGNoYW5nZSB0aGUgY29udGVudCBvZiB0aGUgaXRlbXMgYXJyYXkpLlxuICogQGV2ZW50IG11dGF0ZVxuICogQHBhcmFtIHtPYmplY3RbXX0gYWRkZWRJdGVtc1xuICogQHBhcmFtIHtCb29sZWFufSBwcmV2ZW50QnViYmxlVXAgcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3RbXX0gcmVtb3ZlZEl0ZW1zXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbGxlY3Rpb24pO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbGxlY3Rpb24uRmlsdGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBGaWx0ZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgdGhlIG9wZXJhdG9yIGNvbmZpZzo8YnI+XG4gICAgICogWyc9PScsJz09PScsJyE9JywnIT09JywnPCcsJzw9JywnPicsJz49JywnZW5kc1dpdGgnLCdleGNsdWRlZCcsJ2luY2x1ZGVkJywnaXNEZWZpbmVkJywnaXNVbmRlZmluZWQnLCdsaWtlJywnc3RhcnRzV2l0aCddXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IG9wZXJhdG9yc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9wZXJhdG9ycyA9IFtcbiAgICAgICAgJz09JywgJz09PScsICchPScsICchPT0nLCAnPCcsICc8PScsICc+JywgJz49JywgJ2RvZXNOb3RTdGFydFdpdGgnLCAnZW5kc1dpdGgnLCAnZXhjbHVkZWQnLFxuICAgICAgICAnaW5jbHVkZWQnLCAnaXNEZWZpbmVkJywgJ2lzVW5kZWZpbmVkJywgJ2xpa2UnLCAnc3RhcnRzV2l0aCdcbiAgICBdXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb2xsZWN0aW9uLkZpbHRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbGxlY3Rpb24uRmlsdGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2ZpbHRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdmaWx0ZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dGluZyBkaXNhYmxlZCB0byB0cnVlIHdpbGwgZXhjbHVkZSB0aGlzIGZpbHRlciBmcm9tIHRoZSBjb2xsZWN0aW9uIGZpbHRlcmluZyBsb2dpY1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZSBhIGN1c3RvbSBmaWx0ZXJpbmcgZnVuY3Rpb24gd2hpY2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoYW4gcHJvcGVydHksIG9wZXJhdG9yICYgdmFsdWVcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb258bnVsbH0gZmlsdGVyQnlfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJCeV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIG1lYW5zIG5vdCBmaWx0ZXJpbmcgb3V0IGl0ZW1zIGluIGNhc2UgdGhlIHZhbHVlIGlzICcnLCBudWxsLCBbXSBvciB7fVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbmNsdWRlRW1wdHlWYWx1ZXM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5jbHVkZUVtcHR5VmFsdWVzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgZmxhZyB0byB0cnVlIGJlZm9yZSBzdGFydGluZyBidWxrIHVwZGF0ZXMgKGUuZy4gY2hhbmdpbmcgcHJvcGVydHkgJiB2YWx1ZSlcbiAgICAgICAgICogdG8gcHJldmVudCBtdWx0aXBsZSBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVXBkYXRpbmdfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNVcGRhdGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG93bmVyIHV0aWwuQ29sbGVjdGlvbiBuZWVkcyB0byBhcHBseSBhbiBvbkNoYW5nZSBsaXN0ZW5lciBvbmNlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGxpc3RlbmVyQXBwbGllZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0ZW5lckFwcGxpZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wZXJhdG9yIHRvIGZpbHRlciBieSAodXNlIHRoZSBjb21iaW5hdGlvbiBvZiBwcm9wZXJ0eSwgb3BlcmF0b3IgJiB2YWx1ZSlcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOlxuICAgICAgICAgKlxuICAgICAgICAgKiA9PSAobm90IHJlY29tbWVuZGVkKVxuICAgICAgICAgKiA9PT1cbiAgICAgICAgICogIT0gKG5vdCByZWNvbW1lbmRlZClcbiAgICAgICAgICogIT09XG4gICAgICAgICAqIDxcbiAgICAgICAgICogPj1cbiAgICAgICAgICogPlxuICAgICAgICAgKiA+PVxuICAgICAgICAgKiBsaWtlIChjb2xsZWN0aW9uVmFsdWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKGZpbHRlclZhbHVlLnRvTG93ZXJDYXNlKCkpID4gLTEpXG4gICAgICAgICAqIGluY2x1ZGVkIChleHBlY3RzIHZhbHVlIHRvIGJlIGFuIGFycmF5KVxuICAgICAgICAgKiBleGNsdWRlZCAoZXhwZWN0cyB2YWx1ZSB0byBiZSBhbiBhcnJheSlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBvcGVyYXRvcj0nPT09J1xuICAgICAgICAgKi9cbiAgICAgICAgb3BlcmF0b3JfOiAnPT09JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBmaWx0ZXIgYnkgKHVzZSB0aGUgY29tYmluYXRpb24gb2YgcHJvcGVydHksIG9wZXJhdG9yICYgdmFsdWUpXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcHJvcGVydHlfPSdpZCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwcm9wZXJ0eV86ICdpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NvcGUgdG8gdXNlIGZvciB0aGUgZmlsdGVyQnkgbWV0aG9kLCBpbiBjYXNlIGl0IGlzIHByb3ZpZGVkLiBEZWZhdWx0cyB0byB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc2NvcGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFsdWUgdG8gZmlsdGVyIGJ5ICh1c2UgdGhlIGNvbWJpbmF0aW9uIG9mIHByb3BlcnR5LCBvcGVyYXRvciAmIHZhbHVlKVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHZhbHVlXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVfOiBudWxsXG4gICAgfVxuXG4gICAgYWZ0ZXJTZXREaXNhYmxlZCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgYWZ0ZXJTZXRGaWx0ZXJCeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gdG9kb1xuICAgIH1cblxuICAgIGFmdGVyU2V0SXNVcGRhdGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPT09IGZhbHNlICYmIHRoaXMuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICBhZnRlclNldE9wZXJhdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoLi4uYXJncylcbiAgICB9XG5cbiAgICBhZnRlclNldFByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoLi4uYXJncylcbiAgICB9XG5cbiAgICBhZnRlclNldFZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoLi4uYXJncylcbiAgICB9XG5cbiAgICBiZWZvcmVTZXRGaWx0ZXJCeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKCdmaWx0ZXJCeSBoYXMgdG8gYmUgYSBmdW5jdGlvbicsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBvcGVyYXRvciBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0T3BlcmF0b3IodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdvcGVyYXRvcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciByZW1vdGUgZmlsdGVyaW5nXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGV4cG9ydCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3BlcmF0b3IsIHByb3BlcnR5LCB2YWx1ZX0gPSBtZTtcblxuICAgICAgICBpZiAoIW1lLmZpbHRlckJ5KSB7XG4gICAgICAgICAgICByZXR1cm4ge29wZXJhdG9yLCBwcm9wZXJ0eSwgdmFsdWV9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtZS5pc1VwZGF0aW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBsZXQge29wZXJhdG9yLCBwcm9wZXJ0eSwgdmFsdWV9ID0gbWU7XG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7b3BlcmF0b3IsIHByb3BlcnR5LCB2YWx1ZX0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjb2xsZWN0aW9uIGl0ZW0gbWF0Y2hlcyB0aGlzIGZpbHRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaXRlbVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmVkSXRlbXMgSWYgdGhlIGNvbGxlY3Rpb24gZmlsdGVyTW9kZSBpcyBub3QgcHJpbWl0aXZlIGNvbnRhaW5zIHRoZSBpdGVtcyB3aGljaCBwYXNzZWRcbiAgICAgKiB0aGUgcHJldmlvdXMgZmlsdGVycywgb3RoZXJ3aXNlIGFsbCBjb2xsZWN0aW9uIGl0ZW1zXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWxsSXRlbXMgYWxsIGNvbGxlY3Rpb24gaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0ZpbHRlcmVkKGl0ZW0sIGZpbHRlcmVkSXRlbXMsIGFsbEl0ZW1zKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBmaWx0ZXJWYWx1ZSwgcmVjb3JkVmFsdWU7XG5cbiAgICAgICAgaWYgKG1lLl9kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuX2ZpbHRlckJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuZmlsdGVyQnkuY2FsbChtZS5zY29wZSB8fCBtZSwge1xuICAgICAgICAgICAgICAgIGFsbEl0ZW1zLFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWUuX3ZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmluY2x1ZGVFbXB0eVZhbHVlcyAmJiAobWUuX3ZhbHVlID09PSBudWxsIHx8IE5lby5pc0VtcHR5KG1lLl92YWx1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlclZhbHVlID0gbWUuX3ZhbHVlO1xuICAgICAgICByZWNvcmRWYWx1ZSA9IGl0ZW1bbWUuX3Byb3BlcnR5XTtcblxuICAgICAgICBpZiAoZmlsdGVyVmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIHJlY29yZFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWx0ZXJWYWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICByZWNvcmRWYWx1ZSA9IHJlY29yZFZhbHVlLnZhbHVlT2YoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFGaWx0ZXJbbWUuX29wZXJhdG9yXShyZWNvcmRWYWx1ZSwgZmlsdGVyVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBkaXNhYmxlZDogbWUuZGlzYWJsZWQsXG4gICAgICAgICAgICBvcGVyYXRvcjogbWUub3BlcmF0b3IsXG4gICAgICAgICAgICBwcm9wZXJ0eTogbWUucHJvcGVydHksXG4gICAgICAgICAgICB2YWx1ZSAgIDogbWUudmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBbJz09J10gKGEsIGIpIHtyZXR1cm4gYSA9PSBifVxuICAgIHN0YXRpYyBbJz09PSddKGEsIGIpIHtyZXR1cm4gYSA9PT0gYn1cbiAgICBzdGF0aWMgWychPSddIChhLCBiKSB7cmV0dXJuIGEgIT0gYn1cbiAgICBzdGF0aWMgWychPT0nXShhLCBiKSB7cmV0dXJuIGEgIT09IGJ9XG4gICAgc3RhdGljIFsnPCddICAoYSwgYikge3JldHVybiBhIDwgYn1cbiAgICBzdGF0aWMgWyc8PSddIChhLCBiKSB7cmV0dXJuIGEgPD0gYn1cbiAgICBzdGF0aWMgWyc+J10gIChhLCBiKSB7cmV0dXJuIGEgPiBifVxuICAgIHN0YXRpYyBbJz49J10gKGEsIGIpIHtyZXR1cm4gYSA+PSBifVxuXG4gICAgc3RhdGljIFsnZG9lc05vdFN0YXJ0V2l0aCddKGEsIGIpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYSkpIHthID0gU3RyaW5nKGEpfVxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhiKSkge2IgPSBTdHJpbmcoYil9XG5cbiAgICAgICAgcmV0dXJuICFhPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYj8udG9Mb3dlckNhc2UoKSlcbiAgICB9XG5cbiAgICBzdGF0aWMgWydlbmRzV2l0aCddKGEsIGIpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYSkpIHthID0gU3RyaW5nKGEpfVxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhiKSkge2IgPSBTdHJpbmcoYil9XG5cbiAgICAgICAgcmV0dXJuIGE/LnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoYj8udG9Mb3dlckNhc2UoKSkgfHwgZmFsc2VcbiAgICB9XG5cbiAgICBzdGF0aWMgWydleGNsdWRlZCddKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSA8IDBcbiAgICB9XG5cbiAgICBzdGF0aWMgWydpbmNsdWRlZCddKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSA+IC0xXG4gICAgfVxuXG4gICAgc3RhdGljIFsnaXNEZWZpbmVkJ10oYSwgYikge1xuICAgICAgICByZXR1cm4gYSAhPT0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgc3RhdGljIFsnaXNVbmRlZmluZWQnXShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBzdGF0aWMgWydsaWtlJ10oYSwgYikge1xuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhhKSkge2EgPSBTdHJpbmcoYSl9XG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGIpKSB7YiA9IFN0cmluZyhiKX1cblxuICAgICAgICByZXR1cm4gYT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhiPy50b0xvd2VyQ2FzZSgpKSB8fCBmYWxzZVxuICAgIH1cblxuICAgIHN0YXRpYyBbJ3N0YXJ0c1dpdGgnXShhLCBiKSB7XG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGEpKSB7YSA9IFN0cmluZyhhKX1cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoYikpIHtiID0gU3RyaW5nKGIpfVxuXG4gICAgICAgIHJldHVybiBhPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYj8udG9Mb3dlckNhc2UoKSkgfHwgZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZpbHRlcik7XG4iLCJpbXBvcnQgQmFzZSAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29sbGVjdGlvbi5Tb3J0ZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKi9cbmNsYXNzIFNvcnRlciBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb2xsZWN0aW9uLlNvcnRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbGxlY3Rpb24uU29ydGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NvcnRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzb3J0ZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgY29uZmlnIHdoaWNoIG1hcHMgdGhlIGRpcmVjdGlvbiBBU0MgdG8gMSwgLTEgb3RoZXJ3aXNlXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZGlyZWN0aW9uTXVsdGlwbGllcj0xXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbk11bHRpcGxpZXI6IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc29ydCBkaXJlY3Rpb24gd2hlbiB1c2luZyBhIHByb3BlcnR5LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRpcmVjdGlvbl89J0FTQydcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXJlY3Rpb25fOiAnQVNDJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvd25lciB1dGlsLkNvbGxlY3Rpb24gbmVlZHMgdG8gYXBwbHkgYW4gb25DaGFuZ2UgbGlzdGVuZXIgb25jZVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBsaXN0ZW5lckFwcGxpZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdGVuZXJBcHBsaWVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBzb3J0IGJ5LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHByb3BlcnR5Xz0naWQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvcGVydHlfOiAnaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZSBhIGN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uLCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhhbiBwcm9wZXJ0eSAmIGRpcmVjdGlvblxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSBzb3J0Qnk9bnVsbFxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0NvbGxhdG9yXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Qnk6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIHVzZSB0aGUgdHJhbnNmb3JtVmFsdWUgbWV0aG9kIGZvciBlYWNoIGl0ZW0gKHRoZSBtZXRob2QgY2FuIGdldCBvdmVycmlkZGVuKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VUcmFuc2Zvcm1WYWx1ZT10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVzZVRyYW5zZm9ybVZhbHVlOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXREaXJlY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZGlyZWN0aW9uTXVsdGlwbGllciA9IHZhbHVlID09PSAnQVNDJyA/IDEgOiAtMTtcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IG1lLmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA6IG1lLnByb3BlcnR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0UHJvcGVydHkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBtZS5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgOiBtZS5wcm9wZXJ0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHNvcnRlciBmdW5jdGlvbiB3aGljaCBnZXRzIHVzZWQgYnkgY29sbGVjdGlvbnMgaW4gY2FzZSBhdCBsZWFzdCBvbmUgc29ydGVyIGhhcyBhIHJlYWwgc29ydEJ5IG1ldGhvZFxuICAgICAqIEBwYXJhbSBhXG4gICAgICogQHBhcmFtIGJcbiAgICAgKi9cbiAgICBkZWZhdWx0U29ydEJ5KGEsIGIpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBhID0gYVttZS5wcm9wZXJ0eV07XG4gICAgICAgIGIgPSBiW21lLnByb3BlcnR5XTtcblxuICAgICAgICBpZiAobWUudXNlVHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgICAgIGEgPSBtZS50cmFuc2Zvcm1WYWx1ZShhKTtcbiAgICAgICAgICAgIGIgPSBtZS50cmFuc2Zvcm1WYWx1ZShiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDEgKiBtZS5kaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTEgKiBtZS5kaXJlY3Rpb25NdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciByZW1vdGUgc29ydGluZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBleHBvcnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RpcmVjdGlvbiwgcHJvcGVydHl9ID0gbWU7XG5cbiAgICAgICAgaWYgKCFtZS5zb3J0QnkgJiYgZGlyZWN0aW9uICYmIHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge2RpcmVjdGlvbiwgcHJvcGVydHl9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXG4gICAgICAgICAgICBwcm9wZXJ0eSA6IHRoaXMucHJvcGVydHlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNvcnRlcik7XG4iLCJpbXBvcnQge2J1ZmZlciwgZGVib3VuY2UsIGludGVyY2VwdCwgcmVzb2x2ZUNhbGxiYWNrLCB0aHJvdHRsZX0gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuaW1wb3J0IENvbXBhcmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQ29tcGFyZS5tanMnO1xuaW1wb3J0IFV0aWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvVXRpbC5tanMnO1xuaW1wb3J0IENvbmZpZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4vQ29uZmlnLm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi9Db25maWdTeW1ib2xzLm1qcyc7XG5pbXBvcnQgSWRHZW5lcmF0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi9JZEdlbmVyYXRvci5tanMnO1xuaW1wb3J0IEVmZmVjdE1hbmFnZXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4vRWZmZWN0TWFuYWdlci5tanMnO1xuXG5jb25zdCBjb25maWdTeW1ib2wgICAgICAgPSBTeW1ib2wuZm9yKCdjb25maWdTeW1ib2wnKSxcbiAgICAgIGZvcmNlQXNzaWduQ29uZmlncyA9IFN5bWJvbCgnZm9yY2VBc3NpZ25Db25maWdzJyksXG4gICAgICBpc0luc3RhbmNlICAgICAgICAgPSBTeW1ib2woJ2lzSW5zdGFuY2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgKGFsbW9zdCkgYWxsIGNsYXNzZXMgaW5zaWRlIHRoZSBOZW8gbmFtZXNwYWNlXG4gKiBFeGNlcHRpb25zIGFyZSBlLmcuIGNvcmUuSWRHZW5lcmF0b3IsIHZkb20uVk5vZGVcbiAqIEBjbGFzcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gZGVmaW5lIG1ldGhvZHMgd2hpY2ggc2hvdWxkIGdldCBkZWxheWVkLlxuICAgICAqIFR5cGVzIGFyZSBidWZmZXIsIGRlYm91bmNlICYgdGhyb3R0bGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgZGVsYXlhYmxlOiB7XG4gICAgICogICAgICBmaXJlQ2hhbmdlRXZlbnQ6IHtcbiAgICAgKiAgICAgICAgICB0eXBlIDogJ2RlYm91bmNlJyxcbiAgICAgKiAgICAgICAgICB0aW1lcjogMzAwXG4gICAgICogICAgICB9XG4gICAgICogIH1cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlbGF5YWJsZT17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRlbGF5YWJsZSA9IHt9XG4gICAgLyoqXG4gICAgICogRmxhZyB3aGljaCB3aWxsIGdldCBzZXQgdG8gdHJ1ZSBvbmNlIG1hbmFnZXIuSW5zdGFuY2UgZ290IGNyZWF0ZWRcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbnN0YW5jZU1hbmFnZXJBdmFpbGFibGU9ZmFsc2VcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGluc3RhbmNlTWFuYWdlckF2YWlsYWJsZSA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogUmVnZXggdG8gZ3JhYiB0aGUgTWV0aG9kTmFtZSBmcm9tIGFuIGVycm9yXG4gICAgICogd2hpY2ggaXMgYSBzZWNvbmQgZ2VuZXJhdGlvbiBmdW5jdGlvblxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gbWV0aG9kTmFtZVJlZ2V4XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBtZXRob2ROYW1lUmVnZXggPSAvXFxuLipcXG5cXHMrYXRcXHMrLipcXC4oXFx3KylcXHMrLiovXG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9ZmFsc2VcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEtlZXAgdGhlIG92ZXJ3cml0dGVuIG1ldGhvZHNcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG92ZXJ3cml0dGVuTWV0aG9kcz17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG92ZXJ3cml0dGVuTWV0aG9kcyA9IHt9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgZm9yIHRoZSBjbGFzcy4gVGhlc2UgY29uZmlndXJhdGlvbnMgYXJlXG4gICAgICogbWVyZ2VkIHRocm91Z2hvdXQgdGhlIGNsYXNzIGhpZXJhcmNoeSBhbmQgY2FuIGJlIG92ZXJyaWRkZW4gYXQgdGhlIGluc3RhbmNlIGxldmVsLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHR3byBtYWluIHR5cGVzIG9mIGNvbmZpZ3M6XG4gICAgICpcbiAgICAgKiAxLiAgKipSZWFjdGl2ZSBDb25maWdzOioqIFByb3BlcnR5IG5hbWVzIGVuZGluZyB3aXRoIGEgdHJhaWxpbmcgdW5kZXJzY29yZSAoZS5nLiwgYG15Q29uZmlnX2ApLlxuICAgICAqICAgICBUaGUgZnJhbWV3b3JrIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIGEgcHVibGljIGdldHRlciBhbmQgc2V0dGVyLCByZW1vdmluZyB0aGUgdW5kZXJzY29yZVxuICAgICAqICAgICBmcm9tIHRoZSBwcm9wZXJ0eSBuYW1lIChlLmcuLCBgdGhpcy5teUNvbmZpZ2ApLiBUaGlzIHN5c3RlbSBlbmFibGVzIHBvd2VyZnVsLCBvcHRpb25hbFxuICAgICAqICAgICBsaWZlY3ljbGUgaG9va3MgdGhhdCBhcmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgaWYgdGhleSBhcmUgaW1wbGVtZW50ZWQgb24gdGhlIGNsYXNzOlxuICAgICAqICAgICAtIGBiZWZvcmVHZXRNeUNvbmZpZyh2YWx1ZSlgOiBFeGVjdXRlZCBiZWZvcmUgdGhlIGdldHRlciByZXR1cm5zLiBDYW4gYmUgdXNlZCB0byBkeW5hbWljYWxseSBtb2RpZnkgdGhlIHJldHVybmVkIHZhbHVlLlxuICAgICAqICAgICAtIGBiZWZvcmVTZXRNeUNvbmZpZyhuZXdWYWx1ZSwgb2xkVmFsdWUpYDogRXhlY3V0ZWQgYmVmb3JlIGEgbmV3IHZhbHVlIGlzIHNldC4gQ2FuIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24gb3IgdHJhbnNmb3JtYXRpb24uIFJldHVybmluZyBgdW5kZWZpbmVkYCBmcm9tIHRoaXMgaG9vayB3aWxsIGNhbmNlbCB0aGUgdXBkYXRlLlxuICAgICAqICAgICAtIGBhZnRlclNldE15Q29uZmlnKG5ld1ZhbHVlLCBvbGRWYWx1ZSlgOiBFeGVjdXRlZCBhZnRlciBhIG5ldyB2YWx1ZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2V0LiBJZGVhbCBmb3IgdHJpZ2dlcmluZyBzaWRlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiAyLiAgKipOb24tUmVhY3RpdmUgKFByb3RvdHlwZS1iYXNlZCkgQ29uZmlnczoqKiBQcm9wZXJ0eSBuYW1lcyB3aXRob3V0IGEgdHJhaWxpbmcgdW5kZXJzY29yZS5cbiAgICAgKiAgICAgVGhlc2UgYXJlIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIGNsYXNzJ3MgKipwcm90b3R5cGUqKiBkdXJpbmcgdGhlIGBOZW8uc2V0dXBDbGFzc2BcbiAgICAgKiAgICAgcHJvY2Vzcy4gVGhpcyBpcyBoaWdobHkgbWVtb3J5LWVmZmljaWVudCBhcyB0aGUgdmFsdWUgaXMgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzLlxuICAgICAqICAgICBJdCBhbHNvIGFsbG93cyBmb3IgcG93ZXJmdWwsIGFwcGxpY2F0aW9uLXdpZGUgbW9kaWZpY2F0aW9ucyBvZiBkZWZhdWx0IGJlaGF2aW9yc1xuICAgICAqICAgICBieSB1c2luZyB0aGUgYE5lby5vdmVyd3JpdGVzYCBtZWNoYW5pc20sIHdoaWNoIG1vZGlmaWVzIHRoZXNlIHByb3RvdHlwZSB2YWx1ZXMgYXRcbiAgICAgKiAgICAgbG9hZCB0aW1lLlxuICAgICAqXG4gICAgICogICAgICoqdnMuIENsYXNzIEZpZWxkczoqKlxuICAgICAqICAgICBVc2UgYSBub24tcmVhY3RpdmUgY29uZmlnIHdoZW4geW91IHdhbnQgdGhlIHByb3BlcnR5IHRvIGJlIGVsaWdpYmxlIGZvciB0aGUgYE5lby5vdmVyd3JpdGVzYFxuICAgICAqICAgICBtZWNoYW5pc20uIFRoaXMgYWxsb3dzIGV4dGVybmFsIGNvZGUgKGxpa2UgdGhlbWVzIG9yIGFwcGxpY2F0aW9uLWxldmVsIG92ZXJyaWRlcykgdG8gY2hhbmdlXG4gICAgICogICAgIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgY2xhc3MsIHdoaWNoIHRoZW4gcHJvcGFnYXRlcyB0byBhbGwgc3ViY2xhc3NlcyBhbmQgaW5zdGFuY2VzXG4gICAgICogICAgIGdsb2JhbGx5LiBVc2Ugc3RhbmRhcmQgY2xhc3MgZmllbGRzIGZvciBpbnRlcm5hbCBzdGF0ZSB0aGF0IHNob3VsZCBub3QgYmUgZ2xvYmFsbHkgcmVjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIHdoaWNoIHdpbGwgZ2V0IG1hcHBlZCBpbnRvIHRoZSBOZW8gb3IgYXBwIG5hbWVzcGFjZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvcmUuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvcmUuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2xhc3Mgc2hvcnRjdXQtbmFtZSB0byB1c2UgZm9yIGUuZy4gY3JlYXRpbmcgY2hpbGQgY29tcG9uZW50cyBpbnNpZGUgYSBKU09OLWZvcm1hdFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdiYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Jhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpbGUgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2hhbmdlIHRoZSBzdGF0aWMgZGVsYXlhYmxlIGNvbmZpZ3Mgb24gY2xhc3MgbGV2ZWwsXG4gICAgICAgICAqIHlvdSBjYW4gY2hhbmdlIGl0IG9uIGluc3RhbmNlIGxldmVsIHRvby4gSWYgbm90IG51bGwsIHdlIHdpbGwgZG8gYSBkZWVwIG1lcmdlLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlbGF5YWJsZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxheWFibGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIGNvbXBvbmVudCBpZFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaWRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiByZW1vdGUgbWV0aG9kIG5hbWVzIHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkLlxuICAgICAgICAgKiBOYW1lcyB1c2VkIGhlcmUgbXVzdCBiZSBwcmVzZW50IGluc2lkZSB0aGUgYHJlbW90ZV9gIGNvbmZpZy5cbiAgICAgICAgICogSWYgYSByZW1vdGUgY2FsbCBmb3Igb25lIG9mIHRoZXNlIG1ldGhvZHMgYXJyaXZlcywgYG9uSW50ZXJjZXB0UmVtb3RlcygpYCB3aWxsIGJlIGNhbGxlZC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118bnVsbH0gaW50ZXJjZXB0UmVtb3Rlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGludGVyY2VwdFJlbW90ZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOZW8uY3JlYXRlKCkgd2lsbCBjaGFuZ2UgdGhpcyBmbGFnIHRvIHRydWUgYWZ0ZXIgdGhlIG9uQ29uc3RydWN0ZWQoKSBjaGFpbiBpcyBkb25lLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0NvbnN0cnVjdGVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzQ29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjb25maWcgd2lsbCBiZSBzZXQgdG8gYHRydWVgIGFzIHRoZSB2ZXJ5IGZpcnN0IGFjdGlvbiB3aXRoaW4gdGhlIGBkZXN0cm95KClgIG1ldGhvZC5cbiAgICAgICAgICogRWZmZWN0cyBjYW4gb2JzZXJ2ZSB0aGlzIGNvbmZpZyB0byBjbGVhbiB0aGVtc2VsdmVzIHVwLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0Rlc3Ryb3lpbmdfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpc0Rlc3Ryb3lpbmdfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb25maWcgd2lsbCBnZXQgc2V0IHRvIGB0cnVlYCBvbmNlIHRoZSBQcm9taXNlIG9mIGBhc3luYyBpbml0QXN5bmMoKWAgaXMgcmVzb2x2ZWQuXG4gICAgICAgICAqIFlvdSBjYW4gdXNlIGBhZnRlclNldElzUmVhZHkoKWAgdG8gZ2V0IG5vdGlmaWVkIG9uY2UgdGhlIHJlYWR5IHN0YXRlIGlzIHJlYWNoZWQuXG4gICAgICAgICAqIEZvciBvYnNlcnZhYmxlIGNsYXNzZXMsIHRoaXMgd2lsbCBhbHNvIGZpcmUgYSBgcmVhZHlgIGV2ZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1JlYWR5Xz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlzUmVhZHlfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBtaXhpbnMgYXMgYW4gYXJyYXkgb2YgY2xhc3NOYW1lcywgaW1wb3J0ZWQgbW9kdWxlcyBvciBhIG1peGVkIHZlcnNpb25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118TmVvLmNvcmUuQmFzZVtdfG51bGx9IG1peGlucz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgY2FuIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBieSBwYXNzaW5nIGFuIGltcG9ydGVkIGNsYXNzIChKUyBtb2R1bGUgZGVmYXVsdCBleHBvcnQpXG4gICAgICAgICAqIEBtZW1iZXIge0NsYXNzfSBtb2R1bGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgdGhyZWFkcy4gRXhhbXBsZSB1c2UgY2FzZTpcbiAgICAgICAgICogcmVtb3RlOiB7YXBwOiBbJ215UmVtb3RlTWV0aG9kJ119XG4gICAgICAgICAqXG4gICAgICAgICAqIE9OTFkgc3VwcG9ydGVkIGZvciBzaW5nbGV0b25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gcmVtb3RlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGVfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBwcml2YXRlIGZpZWxkIHRvIHN0b3JlIHRoZSBDb25maWcgY29udHJvbGxlciBpbnN0YW5jZXMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSAjY29uZmlncz17fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2NvbmZpZ3MgPSB7fTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjYWNoZSBmb3IgYWxsIGNvbmZpZyBzdWJzY3JpcHRpb24gY2xlYW51cCBmdW5jdGlvbnMuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb25bXX0gI2NvbmZpZ1N1YnNjcmlwdGlvbkNsZWFudXBzPVtdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjY29uZmlnU3Vic2NyaXB0aW9uQ2xlYW51cHMgPSBbXVxuICAgIC8qKlxuICAgICAqIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGluc3RhbmNlIGlzIGZ1bGx5IGluaXRpYWxpemVkIChhZnRlciBpbml0QXN5bmMoKSBjb21wbGV0ZXMpLlxuICAgICAqIEBtZW1iZXIge1Byb21pc2U8dm9pZD58bnVsbH0gI3JlYWR5UHJvbWlzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3JlYWR5UHJvbWlzZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQSByZXNvbHZlciBmdW5jdGlvbiBmb3IgdGhlIHJlYWR5IHByb21pc2UuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb258bnVsbH0gI3JlYWR5UmVzb2x2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNyZWFkeVJlc29sdmVyID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSByZW1vdGUgbWV0aG9kcyBhcmUgcmVnaXN0ZXJlZC5cbiAgICAgKiBAbWVtYmVyIHtQcm9taXNlPHZvaWQ+fG51bGx9ICNyZW1vdGVzUmVhZHlQcm9taXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjcmVtb3Rlc1JlYWR5UHJvbWlzZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQSByZXNvbHZlciBmdW5jdGlvbiBmb3IgdGhlIHJlbW90ZXNSZWFkeSBwcm9taXNlLlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufG51bGx9ICNyZW1vdGVzUmVhZHlSZXNvbHZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3JlbW90ZXNSZWFkeVJlc29sdmVyID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjYWNoZSBmb3IgYWxsIHRpbWVvdXQgaWRzIHdoZW4gdXNpbmcgdGhpcy50aW1lb3V0KClcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX0gdGltZW91dElkcz1bXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3RpbWVvdXRJZHMgPSBbXVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gaW5pdGlhbGl6ZXIgZm9yIGFsbCBOZW8ubWpzIGNsYXNzZXMsIGludm9rZWQgYnkgYE5lby5jcmVhdGUoKWAuXG4gICAgICogTk9URTogVGhpcyBpcyBub3QgdGhlIG5hdGl2ZSBgY29uc3RydWN0b3IoKWAsIHdoaWNoIGlzIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cyBieSBgTmVvLmNyZWF0ZSgpYCBmaXJzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG9yY2hlc3RyYXRlcyB0aGUgZW50aXJlIGluc3RhbmNlIGluaXRpYWxpemF0aW9uIHByb2Nlc3MsIGluY2x1ZGluZ1xuICAgICAqIHRoZSBzZXR1cCBvZiB0aGUgcG93ZXJmdWwgYW5kIGZsZXhpYmxlIGNvbmZpZyBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBUaGUgYGNvbmZpZ2AgcGFyYW1ldGVyIGlzIGEgc2luZ2xlIG9iamVjdCB0aGF0IGNhbiBjb250YWluIGRpZmZlcmVudCB0eXBlcyBvZiBwcm9wZXJ0aWVzLFxuICAgICAqIHdoaWNoIGFyZSBwcm9jZXNzZWQgaW4gYSBzcGVjaWZpYyBvcmRlciB0byBlbnN1cmUgY29uc2lzdGVuY3kgYW5kIHByZWRpY3RhYmlsaXR5OlxuICAgICAqXG4gICAgICogMS4gICoqUHVibGljIENsYXNzIEZpZWxkcyAmIE90aGVyIFByb3BlcnRpZXM6KiogQW55IGtleSBpbiB0aGUgYGNvbmZpZ2Agb2JqZWN0IHRoYXQgaXMgTk9UXG4gICAgICogICAgIGRlZmluZWQgaW4gdGhlIGNsYXNzJ3MgYHN0YXRpYyBjb25maWdgIGhpZXJhcmNoeSBpcyBjb25zaWRlcmVkIGEgcHVibGljIGZpZWxkIG9yIGFcbiAgICAgKiAgICAgZHluYW1pYyBwcm9wZXJ0eS4gVGhlc2UgYXJlIGFzc2lnbmVkIGRpcmVjdGx5IHRvIHRoZSBpbnN0YW5jZSAoYHRoaXMubXlGaWVsZCA9IHZhbHVlYClcbiAgICAgKiAgICAgYXQgdGhlIHZlcnkgYmVnaW5uaW5nLiBUaGlzIGlzIGNydWNpYWwgc28gdGhhdCBzdWJzZXF1ZW50IGNvbmZpZyBob29rcyAobGlrZSBgYWZ0ZXJTZXQqYClcbiAgICAgKiAgICAgY2FuIGFjY2VzcyB0aGVpciBsYXRlc3QgdmFsdWVzLlxuICAgICAqXG4gICAgICogMi4gICoqUmVhY3RpdmUgQ29uZmlnczoqKiBBIHByb3BlcnR5IGlzIGNvbnNpZGVyZWQgcmVhY3RpdmUgaWYgaXQgaXMgZGVmaW5lZCB3aXRoIGEgdHJhaWxpbmdcbiAgICAgKiAgICAgdW5kZXJzY29yZSAoZS5nLiwgYG15VmFsdWVfYCkgaW4gdGhlIGBzdGF0aWMgY29uZmlnYCBvZiAqKmFueSBjbGFzcyBpbiB0aGUgaW5oZXJpdGFuY2VcbiAgICAgKiAgICAgY2hhaW4qKi4gU3ViY2xhc3NlcyBjYW4gcHJvdmlkZSBuZXcgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZXNlIGNvbmZpZ3Mgd2l0aG91dCB0aGVcbiAgICAgKiAgICAgdW5kZXJzY29yZSwgYW5kIHRoZXkgd2lsbCBzdGlsbCBiZSByZWFjdGl2ZS4gVGhlaXIgdmFsdWVzIGFyZSBhcHBsaWVkIHZpYSBnZW5lcmF0ZWRcbiAgICAgKiAgICAgc2V0dGVycywgdHJpZ2dlcmluZyBgYmVmb3JlU2V0KmAgYW5kIGBhZnRlclNldCpgIGhvb2tzLCBhbmQgdGhleSBhcmUgd3JhcHBlZCBpbiBhXG4gICAgICogICAgIGBOZW8uY29yZS5Db25maWdgIGluc3RhbmNlIHRvIGVuYWJsZSBzdWJzY3JpcHRpb24tYmFzZWQgcmVhY3Rpdml0eS5cbiAgICAgKlxuICAgICAqIDMuICAqKk5vbi1SZWFjdGl2ZSBDb25maWdzOioqIFByb3BlcnRpZXMgZGVmaW5lZCBpbiBgc3RhdGljIGNvbmZpZ2Agd2l0aG91dCBhIHRyYWlsaW5nXG4gICAgICogICAgIHVuZGVyc2NvcmUgaW4gdGhlaXIgZW50aXJlIGluaGVyaXRhbmNlIGNoYWluLiBUaGVpciBkZWZhdWx0IHZhbHVlcyBhcmUgYXBwbGllZCBkaXJlY3RseVxuICAgICAqICAgICB0byB0aGUgY2xhc3MgKipwcm90b3R5cGUqKiwgbWFraW5nIHRoZW0gc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIGFuZCBhbGxvd2luZyBmb3JcbiAgICAgKiAgICAgcnVuLXRpbWUgbW9kaWZpY2F0aW9ucyAocHJvdG90eXBhbCBpbmhlcml0YW5jZSkuIFdoZW4gYSBuZXcgdmFsdWUgaXMgcGFzc2VkIHRvIHRoaXNcbiAgICAgKiAgICAgbWV0aG9kLCBpdCBjcmVhdGVzIGFuIGluc3RhbmNlLXNwZWNpZmljIHByb3BlcnR5IHRoYXQgc2hhZG93cyB0aGUgcHJvdG90eXBlIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyBpbml0aWFsaXplcyB0aGUgb2JzZXJ2YWJsZSBtaXhpbiAoaWYgYXBwbGljYWJsZSkgYW5kIHNjaGVkdWxlcyBhc3luY2hyb25vdXNcbiAgICAgKiBsb2dpYyBsaWtlIGBpbml0QXN5bmMoKWAgKHdoaWNoIGhhbmRsZXMgcmVtb3RlIG1ldGhvZCBhY2Nlc3MpIHRvIHJ1biBhZnRlciB0aGUgc3luY2hyb25vdXNcbiAgICAgKiBjb25zdHJ1Y3Rpb24gY2hhaW4gaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnPXt9IFRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZz17fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG1lLCB7XG4gICAgICAgICAgICBbY29uZmlnU3ltYm9sXToge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgIDoge30sXG4gICAgICAgICAgICAgICAgd3JpdGFibGUgICAgOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW2lzSW5zdGFuY2VdOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgIDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5pZCA9IGNvbmZpZy5pZCB8fCBtZS5jb25zdHJ1Y3Rvci5jb25maWcuaWQgfHwgSWRHZW5lcmF0b3IuZ2V0SWQodGhpcy5nZXRJZEtleSgpKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5pZDtcblxuICAgICAgICAvLyBBc3NpZ24gY2xhc3MgZmllbGQgdmFsdWVzIHByaW9yIHRvIGNvbmZpZ3NcbiAgICAgICAgY29uZmlnID0gbWUuc2V0RmllbGRzKGNvbmZpZyk7XG5cbiAgICAgICAgbWUuaW5pdENvbmZpZyhjb25maWcpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ2NvbmZpZ3NBcHBsaWVkJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAgICAgOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmFwcGx5RGVsYXlhYmxlKCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogV2UgZG8gbm90IHdhbnQgdG8gZm9yY2UgZGV2cyB0byBjaGVjayBmb3IgdGhlIGBpc0Rlc3Ryb3llZGAgZmxhZyBpbiBldmVyeSBwb3NzaWJsZSBjbGFzcyBleHRlbnNpb24uXG4gICAgICAgICAqIFNvLCB3ZSBhcmUgaW50ZXJjZXB0aW5nIHRoZSB0b3AtbW9zdCBgZGVzdHJveSgpYCBjYWxsIHRvIGNoZWNrIGZvciB0aGUgZmxhZyB0aGVyZS5cbiAgICAgICAgICogUmF0aW9uYWxlOiBgZGVzdHJveSgpYCBtdXN0IG9ubHkgZ2V0IGNhbGxlZCBvbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJjZXB0KG1lLCAnZGVzdHJveScsIG1lLiNwcmVEZXN0cm95SG9vaywgbWUpO1xuXG4gICAgICAgIC8vIFN0b3JpbmcgYSByZXNvbHZlciB0byBleGVjdXRlIGluc2lkZSBgYWZ0ZXJTZXRJc1JlYWR5YC5cbiAgICAgICAgbWUuI3JlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgbWUuI3JlYWR5UmVzb2x2ZXIgPSByZXNvbHZlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLiNyZW1vdGVzUmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBtZS4jcmVtb3Rlc1JlYWR5UmVzb2x2ZXIgPSByZXNvbHZlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRyaWdnZXJzIGFzeW5jIGxvZ2ljIGFmdGVyIHRoZSBjb25zdHJ1Y3Rpb24gY2hhaW4gaXMgZG9uZS5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBtZS5pbml0QXN5bmMoKTtcbiAgICAgICAgICAgIG1lLmlzUmVhZHkgPSB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpZCBjb25maWcgZ290IGNoYW5nZWQuXG4gICAgICogWW91IGNhbiBkeW5hbWljYWxseSBjaGFuZ2UgaW5zdGFuY2UgaWRzIGlmIG5lZWRlZC4gVGhleSBuZWVkIHRvIHN0YXkgdW5pcXVlIGF0IGFueSBnaXZlbiBwb2ludC5cbiAgICAgKiBVc2UgY2FzZTogZS5nLiBjb21wb25lbnQgYmFzZWQgbGlzdHMsIHdoZXJlIHlvdSB3YW50IHRvIHJlLXVzZSBpdGVtIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc01hbmFnZXIgPSBCYXNlLmluc3RhbmNlTWFuYWdlckF2YWlsYWJsZSA9PT0gdHJ1ZTtcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChoYXNNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgTmVvLm1hbmFnZXIuSW5zdGFuY2UudW5yZWdpc3RlcihvbGRWYWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlkTWFwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIE5lby5pZE1hcFtvbGRWYWx1ZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGhhc01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBOZW8ubWFuYWdlci5JbnN0YW5jZS5yZWdpc3RlcihtZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTmVvLmlkTWFwID8/PSB7fTtcbiAgICAgICAgICAgICAgICBOZW8uaWRNYXBbdmFsdWVdID0gbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNSZWFkeSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIFJlc29sdmVzIHRoZSByZWFkeSgpIHByb21pc2UgYW5kIGZpcmVzIHRoZSByZWFkeSBldmVudCBmb3Igb2JzZXJ2YWJsZSBjbGFzc2VzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNSZWFkeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS4jcmVhZHlSZXNvbHZlcj8uKCk7XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IGZpcmUgdGhlIGV2ZW50IGluIGNhc2UgdGhlIE9ic2VydmFibGUgbWl4aW4gaXMgaW5jbHVkZWQuXG4gICAgICAgICAgICBtZS5nZXRTdGF0aWNDb25maWcoJ29ic2VydmFibGUnKSAmJiBtZS5maXJlKCdyZWFkeScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGFsbCBtZXRob2RzIGluc2lkZSBzdGF0aWMgZGVsYXlhYmxlXG4gICAgICovXG4gICAgYXBwbHlEZWxheWFibGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGN0b3JEZWxheWFibGUgPSBtZS5jb25zdHJ1Y3Rvci5kZWxheWFibGUsXG4gICAgICAgICAgICBkZWxheWFibGUgICAgID0gbWUuZGVsYXlhYmxlID8gTmVvLm1lcmdlKHt9LCBtZS5kZWxheWFibGUsIGN0b3JEZWxheWFibGUpIDogY3RvckRlbGF5YWJsZTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhkZWxheWFibGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyKCkgICB7bWVba2V5XSA9IG5ldyBidWZmZXIobWVba2V5XSwgICBtZSwgdmFsdWUudGltZXIpfSxcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2UoKSB7bWVba2V5XSA9IG5ldyBkZWJvdW5jZShtZVtrZXldLCBtZSwgdmFsdWUudGltZXIpfSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKSB7bWVba2V5XSA9IG5ldyB0aHJvdHRsZShtZVtrZXldLCBtZSwgdmFsdWUudGltZXIpfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtYXBbdmFsdWUudHlwZV0/LigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBzdGF0aWMgbWV0aG9kIGlzIGNhbGxlZCBieSBgTmVvLnNldHVwQ2xhc3MoKWAgZHVyaW5nIHRoZSBjbGFzcyBjcmVhdGlvbiBwcm9jZXNzLlxuICAgICAqIEl0IGFsbG93cyBmb3IgbW9kaWZ5aW5nIGEgY2xhc3MncyBkZWZhdWx0IHByb3RvdHlwZS1iYXNlZCBjb25maWdzIGZyb20gb3V0c2lkZSB0aGVcbiAgICAgKiBjbGFzcyBoaWVyYXJjaHksIHdoaWNoIGlzIGEgcG93ZXJmdWwgd2F5IHRvIGF2b2lkIGJvaWxlcnBsYXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBJdCBsb29rcyBmb3IgYSBtYXRjaGluZyBlbnRyeSBpbiB0aGUgZ2xvYmFsIGBOZW8ub3ZlcndyaXRlc2Agb2JqZWN0IGJhc2VkIG9uIHRoZVxuICAgICAqIGNsYXNzJ3MgYGNsYXNzTmFtZWAuIElmIGZvdW5kLCBpdCBtZXJnZXMgdGhlIHByb3BlcnRpZXMgZnJvbSB0aGUgb3ZlcndyaXRlIG9iamVjdFxuICAgICAqIGludG8gdGhlIGNsYXNzJ3Mgc3RhdGljIGBjb25maWdgLiBUaGlzIHByb3ZpZGVzIGEgcG93ZXJmdWwgbWVjaGFuaXNtIGZvciB0aGVtaW5nXG4gICAgICogb3IgYXBwbHlpbmcgYXBwbGljYXRpb24td2lkZSBjdXN0b21pemF0aW9ucyB0byBmcmFtZXdvcmsgb3IgbGlicmFyeSBjbGFzc2VzIHdpdGhvdXRcbiAgICAgKiBuZWVkaW5nIHRvIGV4dGVuZCB0aGVtLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBJbWFnaW5lIHlvdSBoYXZlIGh1bmRyZWRzIG9mIGJ1dHRvbnMgaW4geW91ciBhcHAsIGFuZCB5b3Ugd2FudCBhbGwgb2YgdGhlbVxuICAgICAqIC8vIHRvIGhhdmUgYGxhYmVsUG9zaXRpb246ICd0b3AnYCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGAnbGVmdCdgLlxuICAgICAqIC8vIEluc3RlYWQgb2YgY29uZmlndXJpbmcgZWFjaCBpbnN0YW5jZSwgeW91IGNhbiBkZWZpbmUgYW4gb3ZlcndyaXRlLlxuICAgICAqXG4gICAgICogLy8gaW5zaWRlIGFuIE92ZXJ3cml0ZXMubWpzIGZpbGUgbG9hZGVkIGJ5IHlvdXIgYXBwOlxuICAgICAqIE5lby5vdmVyd3JpdGVzID0ge1xuICAgICAqICAgICBOZW86IHtcbiAgICAgKiAgICAgICAgIGJ1dHRvbjoge1xuICAgICAqICAgICAgICAgICAgIEJhc2U6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogJ3RvcCdcbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gTm93LCBldmVyeSBgTmVvLmJ1dHRvbi5CYXNlYCAoYW5kIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgaXQpIHdpbGwgaGF2ZSB0aGlzXG4gICAgICogLy8gbmV3IGRlZmF1bHQgdmFsdWUgb24gaXRzIHByb3RvdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgVGhlIHN0YXRpYyBgY29uZmlnYCBvYmplY3Qgb2YgdGhlIGNsYXNzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseU92ZXJ3cml0ZXMoY2ZnKSB7XG4gICAgICAgIGxldCBvdmVyd3JpdGVzID0gTmVvLm5zKGNmZy5jbGFzc05hbWUsIGZhbHNlLCBOZW8ub3ZlcndyaXRlcyksXG4gICAgICAgICAgICBjbHMsIGl0ZW07XG5cbiAgICAgICAgaWYgKG92ZXJ3cml0ZXMpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IGFsbCBtZXRob2RzXG4gICAgICAgICAgICBmb3IgKGl0ZW0gaW4gb3ZlcndyaXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihvdmVyd3JpdGVzW2l0ZW1dKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGV4aXN0aW5nIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgY2xzID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsc1tpdGVtXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIG92ZXJ3cml0dGVuTWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzLmNvbnN0cnVjdG9yLm92ZXJ3cml0dGVuTWV0aG9kc1tpdGVtXSA9IGNsc1tpdGVtXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWdzIHRvIHByb3RvdHlwZVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjZmcsIG92ZXJ3cml0ZXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGJlZm9yZVNldCBmdW5jdGlvbnMgd2hpY2ggdGVzdCBpZiBhIGdpdmVuIHZhbHVlIGlzIGluc2lkZSBhIHN0YXRpYyBhcnJheVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgY29uZmlnIG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gW3N0YXRpY05hbWU9bmFtZSArICdzJ10gbmFtZSBvZiB0aGUgc3RhdGljIGNvbmZpZyBhcnJheVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZSBvciBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIG5hbWUsIHN0YXRpY05hbWUgPSBuYW1lICsgJ3MnKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHN0YXRpY05hbWUpID8gc3RhdGljTmFtZSA6IHRoaXMuZ2V0U3RhdGljQ29uZmlnKHN0YXRpY05hbWUpO1xuXG4gICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgU3VwcG9ydGVkIHZhbHVlcyBmb3IgJHtuYW1lfSBhcmU6YCwgLi4udmFsdWVzLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcmVtb3RlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRSZW1vdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gT25seSBhbGxvdyByZW1vdGUgYWNjZXNzIGZvciBzaW5nbGV0b25zIG9yIG1haW4gdGhyZWFkIGFkZG9uc1xuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLnNpbmdsZXRvbiAmJiAhbWUuaXNNYWluVGhyZWFkQWRkb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3RlIG1ldGhvZCBhY2Nlc3MgaXMgb25seSBmdW5jdGlvbmFsIGZvciBTaW5nbGV0b24gY2xhc3NlcyAnICsgbWUuY2xhc3NOYW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZuICAgICAgICAgICAgICAgVGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0byBmaW5kIGluIHRoZSBwYXNzZWQgc2NvcGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5OYW1lICAgICAgIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgaW5zaWRlIHRoZSBvcmlnaW5TY29wZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgICAgICAgICAgICBUaGUgc2NvcGUgdG8gZmluZCB0aGUgZnVuY3Rpb24gaW4gaWYgaXQgaXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5TY29wZT10aGlzIFRoZSBzY29wZSB3aGVyZSB0aGUgZnVuY3Rpb24gaXMgbG9jYXRlZC5cbiAgICAgKi9cbiAgICBiaW5kQ2FsbGJhY2soZm4sIG9yaWdpbk5hbWUsIHNjb3BlPXRoaXMsIG9yaWdpblNjb3BlPXRoaXMpIHtcbiAgICAgICAgaWYgKGZuICYmIE5lby5pc1N0cmluZyhmbikpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSByZXNvbHZlQ2FsbGJhY2soZm4sIHNjb3BlKTtcbiAgICAgICAgICAgIG9yaWdpblNjb3BlW29yaWdpbk5hbWVdID0gaGFuZGxlci5mbi5iaW5kKGhhbmRsZXIuc2NvcGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcm9tIHdpdGhpbiBhbiBvdmVyd3JpdGUsIGEgbWV0aG9kIGNhbiBjYWxsIGEgcGFyZW50IG1ldGhvZCwgYnkgdXNpbmcgY2FsbE92ZXJ3cml0dGVuLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBhZnRlclNldEhlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgKiAgICAgICAgLy8gZG8gdGhlIHN0YW5kYXJkXG4gICAgICogICAgICAgIHRoaXMuY2FsbE92ZXJ3cml0dGVuKC4uLmFyZ3VtZW50cyk7XG4gICAgICogICAgICAgIC8vIGRvIHlvdSBvd24gc3R1ZmZcbiAgICAgKiAgICB9XG4gICAgICpcbiAgICAgKiBXZSBjcmVhdGUgYW4gZXJyb3IgdG8gZ2V0IHRoZSBjYWxsZXIubmFtZSBhbmQgdGhlbiBydW4gdGhhdCBtZXRob2Qgb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBlcnJvciBzdHJ1Y3R1cmUsIGUuZy4gYWZ0ZXJTZXRIZWlnaHQuXG4gICAgICpcbiAgICAgKiAgICAgRXJyb3JcbiAgICAgKiAgICAgICAgIGF0IEJhc2UuY2FsbE92ZXJ3cml0dGVuIChCYXNlLm1qczoxNzY6MjEpXG4gICAgICogICAgICAgICBhdCBCYXNlLmFmdGVyU2V0SGVpZ2h0IChPdmVycmlkZXMubWpzOjE5OjI2KVxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBjYWxsT3ZlcndyaXR0ZW4oLi4uYXJncykge1xuICAgICAgICBsZXQgc3RhY2sgICAgICA9IG5ldyBFcnJvcigpLnN0YWNrLFxuICAgICAgICAgICAgbWV0aG9kTmFtZSA9IHN0YWNrLm1hdGNoKEJhc2UubWV0aG9kTmFtZVJlZ2V4KVsxXTtcblxuICAgICAgICB0aGlzLl9fcHJvdG9fXy5jb25zdHJ1Y3Rvci5vdmVyd3JpdHRlbk1ldGhvZHNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIHRoaXMgaW5zdGFuY2UgZnJvbSBOZW8ubWFuYWdlci5JbnN0YW5jZVxuICAgICAqIGFuZCByZW1vdmVzIGFsbCBvYmplY3QgZW50cmllcyBmcm9tIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLiN0aW1lb3V0SWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS4jY29uZmlnU3Vic2NyaXB0aW9uQ2xlYW51cHMuZm9yRWFjaChjbGVhbnVwID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoQmFzZS5pbnN0YW5jZU1hbmFnZXJBdmFpbGFibGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIE5lby5tYW5hZ2VyLkluc3RhbmNlLnVucmVnaXN0ZXIobWUpXG4gICAgICAgIH0gZWxzZSBpZiAoTmVvLmlkTWFwKSB7XG4gICAgICAgICAgICBkZWxldGUgTmVvLmlkTWFwW21lLmlkXVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMobWUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1lLCBrZXkpLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBub3QgZGVsZXRlIHRoZSBjdXN0b20gZGVzdHJveSgpIGludGVyY2VwdG9yXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2Rlc3Ryb3knICYmIGtleSAhPT0gJ19pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lW2tleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIGRvIHdhbnQgdG8gcHJldmVudCBkZWxheWVkIGV2ZW50IGNhbGxzIGFmdGVyIGFuIG9ic2VydmFibGUgaW5zdGFuY2UgZ290IGRlc3Ryb3llZC5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKG1lLmZpcmUpKSB7XG4gICAgICAgICAgICBtZS5maXJlID0gTmVvLmVtcHR5Rm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcHVibGljIG1ldGhvZCB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgQ29uZmlnIGNvbnRyb2xsZXIuXG4gICAgICogVGhpcyBlbmFibGVzIGFkdmFuY2VkIGludGVyYWN0aW9ucyBsaWtlIHN1YnNjcmlwdGlvbnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgY29uZmlnIHByb3BlcnR5IChlLmcuLCAnaXRlbXMnKS5cbiAgICAgKiBAcmV0dXJucyB7Q29uZmlnfHVuZGVmaW5lZH0gVGhlIENvbmZpZyBpbnN0YW5jZSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXRDb25maWcoa2V5KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS4jY29uZmlnc1trZXldICYmIG1lLmlzQ29uZmlnKGtleSkpIHtcbiAgICAgICAgICAgIG1lLiNjb25maWdzW2tleV0gPSBuZXcgQ29uZmlnKG1lLmNvbnN0cnVjdG9yLmNvbmZpZ0Rlc2NyaXB0b3JzPy5ba2V5XSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS4jY29uZmlnc1trZXldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBpbnNpZGUgY3JlYXRlSWQoKSBhcyB0aGUgZGVmYXVsdCB2YWx1ZSBwYXNzZWQgdG8gdGhlIElkR2VuZXJhdG9yLlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElkS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udHlwZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc3RhdGljIGNvbmZpZyBrZXkgb3IgdGhlIHN0YXRpY0NvbmZpZyBvYmplY3QgaXRzZWxmIGluIGNhc2Ugbm8gdmFsdWUgaXMgc2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IG9mIGEgc3RhdGljQ29uZmlnIGRlZmluZWQgaW5zaWRlIHN0YXRpYyBnZXRTdGF0aWNDb25maWdcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTdGF0aWNDb25maWcoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yW2tleV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGdpdmVuIG50eXBlIGV4aXN0cyBpbnNpZGUgdGhlIHByb3RvIGNoYWluLCBpbmNsdWRpbmcgdGhlIHRvcCBsZXZlbCBjbGFzc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBudHlwZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc050eXBlKG50eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm50eXBlQ2hhaW4uaW5jbHVkZXMobnR5cGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgb25Db25zdHJ1Y3RlZCgpIGlzIGRvbmVcbiAgICAgKi9cbiAgICBpbml0KCkge31cblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIGluIHN1YmNsYXNzZXMgdG8gcGVyZm9ybSBhc3luY2hyb25vdXMgaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSB0aGUgcGFyZW50IGNhbGwgYGF3YWl0IHN1cGVyLmluaXRBc3luYygpYCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZWlyIGltcGxlbWVudGF0aW9ucyxcbiAgICAgKiBvciB0aGUgcmVnaXN0cmF0aW9uIG9mIHJlbW90ZSBtZXRob2RzIHdpbGwgZ2V0IGRlbGF5ZWQuXG4gICAgICpcbiAgICAgKiBBIGNvbW1vbiB1c2UgY2FzZSBpcyByZXF1aXJpbmcgY29uZGl0aW9uYWwgb3Igb3B0aW9uYWwgZHluYW1pYyBpbXBvcnRzIG9yIGZldGNoaW5nIGluaXRpYWwgZGF0YS5cbiAgICAgKlxuICAgICAqIE9uY2UgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QgaXMgZnVsZmlsbGVkLCB0aGUgYGlzUmVhZHlgIGNvbmZpZyB3aWxsIGJlIHNldCB0byBgdHJ1ZWAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBpbml0aWFsaXphdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0QXN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW90ZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0UmVtb3RlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI3JlbW90ZXNSZWFkeVJlc29sdmVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCBjbGFzcyBjb25maWdzIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdENvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzQ29uZmlndXJpbmcgPSB0cnVlO1xuICAgICAgICBPYmplY3QuYXNzaWduKG1lW2NvbmZpZ1N5bWJvbF0sIG1lLm1lcmdlQ29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKSk7XG4gICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdLmlkO1xuICAgICAgICBtZS5wcm9jZXNzQ29uZmlncygpO1xuICAgICAgICBtZS5pc0NvbmZpZ3VyaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIGdldCB0cmlnZ2VyZWQgd2l0aCBhIGRlbGF5IHRvIGVuc3VyZSB0aGF0IE5lby53b3JrZXJJZCAmIE5lby53b3JrZXIuTWFuYWdlciBhcmUgZGVmaW5lZFxuICAgICAqIFJlbW90ZSBtZXRob2QgYWNjZXNzIHZpYSBwcm9taXNlc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBpbml0UmVtb3RlKCkge1xuICAgICAgICBsZXQge2NsYXNzTmFtZSwgcmVtb3RlfSA9IHRoaXMsXG4gICAgICAgICAgICB7Y3VycmVudFdvcmtlcn0gICAgID0gTmVvO1xuXG4gICAgICAgIGlmICghTmVvLmNvbmZpZy5pc01pZGRsZXdhcmUgJiYgIU5lby5jb25maWcudW5pdFRlc3RNb2RlKSB7XG4gICAgICAgICAgICBpZiAoTmVvLndvcmtlcklkICE9PSAnbWFpbicgJiYgY3VycmVudFdvcmtlci5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGUubWFpbikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29ya2VyLnJlbW90ZXNUb1JlZ2lzdGVyLnB1c2goe2NsYXNzTmFtZSwgbWV0aG9kczogcmVtb3RlLm1haW59KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFdvcmtlci5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIub24oJ2Nvbm5lY3RlZCcsICgpID0+IHJlc29sdmUoKSwgdGhpcywge29uY2U6IHRydWV9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgQmFzZS5wcm9taXNlUmVtb3RlcyhjbGFzc05hbWUsIHJlbW90ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0NvbmZpZyhrZXkpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgLy8gSWYgYSBgY29yZS5Db25maWdgIGNvbnRyb2xsZXIgaXMgYWxyZWFkeSBjcmVhdGVkLCByZXR1cm4gdHJ1ZSAoZmFzdGVzdCBwb3NzaWJsZSBjaGVjaykuXG4gICAgICAgIC8vIElmIG5vdCwgYSBjb25maWcgaXMgY29uc2lkZXJlZCBcInJlYWN0aXZlXCIgaWYgaXQgaGFzIGEgZ2VuZXJhdGVkIHByb3BlcnR5IHNldHRlclxuICAgICAgICAvLyBBTkQgaXQgaXMgcHJlc2VudCBhcyBhIGRlZmluZWQgY29uZmlnIGluIHRoZSBtZXJnZWQgc3RhdGljIGNvbmZpZyBoaWVyYXJjaHkuXG4gICAgICAgIC8vIE5lby5zZXR1cENsYXNzKCkgcmVtb3ZlcyB0aGUgdW5kZXJzY29yZSBmcm9tIHRoZSBzdGF0aWMgY29uZmlnIGtleXMuXG4gICAgICAgIHJldHVybiBtZS4jY29uZmlnc1trZXldIHx8IChOZW8uaGFzUHJvcGVydHlTZXR0ZXIobWUsIGtleSkgJiYgKGtleSBpbiBtZS5jb25zdHJ1Y3Rvci5jb25maWcpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgb3JkZXIgY29uZmlncyBhcmUgYXBwbGllZCB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBjdG9yID0gbWUuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBjb25maWdEZXNjcmlwdG9ycywgc3RhdGljQ29uZmlnO1xuXG4gICAgICAgIGlmICghY3Rvci5jb25maWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVvLmFwcGx5Q2xhc3NDb25maWcgaGFzIG5vdCBiZWVuIHJ1biBvbiAnICsgbWUuY2xhc3NOYW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcmV2ZW50T3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgICAgIG1lLm9yaWdpbmFsQ29uZmlnID0gTmVvLmNsb25lKGNvbmZpZywgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Rlc2NyaXB0b3JzID0gY3Rvci5jb25maWdEZXNjcmlwdG9ycztcbiAgICAgICAgc3RhdGljQ29uZmlnICAgICAgPSBjdG9yLmNvbmZpZztcblxuICAgICAgICBpZiAoY29uZmlnRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW2tleSwgaW5zdGFuY2VWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gY29uZmlnRGVzY3JpcHRvcnNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yPy5tZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdba2V5XSA9IE5lby5tZXJnZUNvbmZpZyhzdGF0aWNDb25maWdba2V5XSwgaW5zdGFuY2VWYWx1ZSwgZGVzY3JpcHRvci5tZXJnZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsuLi5zdGF0aWNDb25maWcsIC4uLmNvbmZpZ31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzICp0aGlzKiBpbnN0YW5jZSAodGhlIHN1YnNjcmliZXIpIHRvIGNoYW5nZXMgb2YgYSBzcGVjaWZpYyBjb25maWcgcHJvcGVydHkgb24gYW5vdGhlciBpbnN0YW5jZSAodGhlIHB1Ymxpc2hlcikuXG4gICAgICogRW5zdXJlcyBhdXRvbWF0aWMgY2xlYW51cCB3aGVuICp0aGlzKiBpbnN0YW5jZSAodGhlIHN1YnNjcmliZXIpIGlzIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE5lby5jb3JlLkJhc2V9IHB1Ymxpc2hlciAgLSBUaGUgSUQgb2YgdGhlIHB1Ymxpc2hlciBpbnN0YW5jZSBvciB0aGUgaW5zdGFuY2UgcmVmZXJlbmNlIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBjb25maWdOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbmZpZyBwcm9wZXJ0eSBvbiB0aGUgcHVibGlzaGVyIHRvIHN1YnNjcmliZSB0byAoZS5nLiwgJ215Q29uZmlnJykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgICAgICAgZm4gICAgICAgICAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBjbGVhbnVwIGZ1bmN0aW9uIHRvIG1hbnVhbGx5IHVuc3Vic2NyaWJlIGlmIG5lZWRlZCBiZWZvcmUgdGhpcyBpbnN0YW5jZSdzIGRlc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTdWJzY3JpYmluZyB0byBhIGNvbmZpZyBvbiBhbm90aGVyIGluc3RhbmNlXG4gICAgICogdGhpcy5vYnNlcnZlQ29uZmlnKHNvbWVPdGhlckluc3RhbmNlLCAnbXlDb25maWcnLCAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdteUNvbmZpZyBjaGFuZ2VkOicsIG5ld1ZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIERpc2NvdXJhZ2VkOiBTZWxmLW9ic2VydmF0aW9uLiBVc2UgYWZ0ZXJTZXQ8Q29uZmlnTmFtZT4oKSBob29rcyBpbnN0ZWFkLlxuICAgICAqIHRoaXMub2JzZXJ2ZUNvbmZpZyh0aGlzLCAnbXlPd25Db25maWcnLCAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdteU93bkNvbmZpZyBjaGFuZ2VkOicsIG5ld1ZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBvYnNlcnZlQ29uZmlnKHB1Ymxpc2hlciwgY29uZmlnTmFtZSwgZm4pIHtcbiAgICAgICAgbGV0IHB1Ymxpc2hlckluc3RhbmNlID0gcHVibGlzaGVyO1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcocHVibGlzaGVyKSkge1xuICAgICAgICAgICAgcHVibGlzaGVySW5zdGFuY2UgPSBOZW8uZ2V0KHB1Ymxpc2hlcik7XG4gICAgICAgICAgICBpZiAoIXB1Ymxpc2hlckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBQdWJsaXNoZXIgaW5zdGFuY2Ugd2l0aCBJRCAnJHtwdWJsaXNoZXJ9JyBub3QgZm91bmQuIENhbm5vdCBzdWJzY3JpYmUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5lby5lbXB0eUZuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShwdWJsaXNoZXJJbnN0YW5jZSBpbnN0YW5jZW9mIE5lby5jb3JlLkJhc2UpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcHVibGlzaGVyIHByb3ZpZGVkLiBNdXN0IGJlIGEgTmVvLmNvcmUuQmFzZSBpbnN0YW5jZSBvciBpdHMgSUQuYCk7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmVtcHR5Rm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZ0NvbnRyb2xsZXIgPSBwdWJsaXNoZXJJbnN0YW5jZS5nZXRDb25maWcoY29uZmlnTmFtZSk7XG5cbiAgICAgICAgaWYgKCFjb25maWdDb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvbmZpZyAnJHtjb25maWdOYW1lfScgbm90IGZvdW5kIG9uIHB1Ymxpc2hlciBpbnN0YW5jZSAke3B1Ymxpc2hlckluc3RhbmNlLmlkfS4gQ2Fubm90IHN1YnNjcmliZS5gKTtcbiAgICAgICAgICAgIHJldHVybiBOZW8uZW1wdHlGblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNvbmZpZ0NvbnRyb2xsZXIuc3Vic2NyaWJlKHtpZDogdGhpcy5pZCwgZm59KTtcblxuICAgICAgICB0aGlzLiNjb25maWdTdWJzY3JpcHRpb25DbGVhbnVwcy5wdXNoKGNsZWFudXApO1xuXG4gICAgICAgIHJldHVybiBjbGVhbnVwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkFmdGVyQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaXNDb25zdHJ1Y3RlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgZmlyZSB0aGUgZXZlbnQgaW4gY2FzZSB0aGUgT2JzZXJ2YWJsZSBtaXhpbiBpcyBpbmNsdWRlZC5cbiAgICAgICAgbWUuZ2V0U3RhdGljQ29uZmlnKCdvYnNlcnZhYmxlJykgJiYgbWUuZmlyZSgnY29uc3RydWN0ZWQnLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBhbGwgY29uc3RydWN0b3JzIGFyZSBkb25lXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgZm9yIGludGVyY2VwdGluZyByZW1vdGUgY2FsbHMuXG4gICAgICogU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW1wbGVtZW50IGN1c3RvbSBpbnRlcmNlcHRpb24gbG9naWMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBUaGUgcmVtb3RlIG1lc3NhZ2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIG9uSW50ZXJjZXB0UmVtb3Rlcyhtc2cpIHtcbiAgICAgICAgLy8gTm8tb3AgaW4gYmFzZSBjbGFzc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmVwbGFjZSBzdHJpbmctYmFzZWQgdmFsdWVzIGNvbnRhaW5pbmcgXCJAY29uZmlnOlwiIHdpdGggdGhlIG1hdGNoaW5nIGNvbmZpZyB2YWx1ZVxuICAgICAqIG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IGl0ZW1zXG4gICAgICovXG4gICAgcGFyc2VJdGVtQ29uZmlncyhpdGVtcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbnMsIG5zQXJyYXksIG5zS2V5LCBzeW1ib2xOcztcblxuICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtICYmIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnBhcnNlSXRlbUNvbmZpZ3ModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuc3RhcnRzV2l0aCgnQGNvbmZpZzonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnNBcnJheSA9IHZhbHVlLnN1YnN0cmluZyg4KS50cmltKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5zS2V5ICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnMgICAgICA9IE5lby5ucyhuc0FycmF5LCBmYWxzZSwgbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnNbbnNLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgdXNlZCBAY29uZmlnIGRvZXMgbm90IGV4aXN0OicsIG5zS2V5LCBuc0FycmF5LmpvaW4oJy4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sTnMgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW2NvbmZpZ1N5bWJvbF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbmZpZyBtaWdodCBub3QgYmUgcHJvY2Vzc2VkIHlldCwgZXNwZWNpYWxseSBmb3IgY29uZmlnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbmRpbmcgd2l0aCBhbiB1bmRlcnNjb3JlLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBjb25maWdTeW1ib2wgZmlyc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bWJvbE5zICYmIE9iamVjdC5oYXNPd24oc3ltYm9sTnMsIG5zS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtW2tleV0gPSBzeW1ib2xOc1tuc0tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtW2tleV0gPSBuc1tuc0tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVyY2VwdHMgZGVzdHJveSgpIGNhbGxzIHRvIGVuc3VyZSB0aGV5IHdpbGwgb25seSBnZXQgY2FsbGVkIG9uY2VcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNwcmVEZXN0cm95SG9vaygpIHtcbiAgICAgICAgdGhpcy5pc0Rlc3Ryb3lpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEZXN0cm95ZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIHNldCgpLCBjb25maWdzIHdpdGhvdXQgYSB0cmFpbGluZyB1bmRlcnNjb3JlIGNhbiBhbHJlYWR5IGJlIGFzc2lnbmVkLFxuICAgICAqIHNvIHRoZSBoYXNPd25Qcm9wZXJ0eSgpIGNoZWNrIHdpbGwgcmV0dXJuIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZUFzc2lnbj1mYWxzZV1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvY2Vzc0NvbmZpZ3MoZm9yY2VBc3NpZ249ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG1lW2NvbmZpZ1N5bWJvbF0pO1xuXG4gICAgICAgIG1lW2ZvcmNlQXNzaWduQ29uZmlnc10gPSBmb3JjZUFzc2lnbjtcblxuICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBpdGVyYXRlIG92ZXIgdGhlIGtleXMsIHNpbmNlIDEgY29uZmlnIGNhbiByZW1vdmUgbW9yZSB0aGFuIDEga2V5IChiZWZvcmVTZXRYLCBhZnRlclNldFgpXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBoYXNPd25Qcm9wZXJ0eSBjaGVjayBpcyBpbnRlbmRlZCBmb3IgY29uZmlncyB3aXRob3V0IGEgdHJhaWxpbmcgdW5kZXJzY29yZVxuICAgICAgICAgICAgLy8gPT4gdGhleSBjb3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhc3NpZ25lZCBpbnNpZGUgYW4gYWZ0ZXJTZXQtbWV0aG9kXG4gICAgICAgICAgICBpZiAoZm9yY2VBc3NpZ24gfHwgIW1lLmhhc093blByb3BlcnR5KGtleXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgbWVba2V5c1swXV0gPSBtZVtjb25maWdTeW1ib2xdW2tleXNbMF1dXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgZGVsZXRlLWNhbGwgaW5zaWRlIHRoZSBjb25maWcgZ2V0dGVyIGFzIHdlbGwgKE5lby5tanMgPT4gYXV0b0dlbmVyYXRlR2V0U2V0KCkpXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgdGhpcyBvbmUgZm9yIGNvbmZpZ3MsIHdoaWNoIGRvIG5vdCB1c2UgZ2V0dGVycyAobm8gdHJhaWxpbmcgdW5kZXJzY29yZSlcbiAgICAgICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdW2tleXNbMF1dO1xuXG4gICAgICAgICAgICBtZS5wcm9jZXNzQ29uZmlncyhmb3JjZUFzc2lnbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgaW5zdGFuY2UgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgKGFmdGVyIGluaXRBc3luYykuXG4gICAgICogVXNlIGNhc2U6IGFsdGVybmF0aXZlIHdheSB0byBzdWJzY3JpYmUgdG8gdGhlIHJlYWR5IHN0YXRlLCBlc3BlY2lhbGx5IGZvciBjbGFzc2VzIHdoaWNoIGFyZSBub3Qgb2JzZXJ2YWJsZS5cbiAgICAgKiBAZXhhbXBsZTogYXdhaXQgQ2hyb21hTWFuYWdlci5yZWFkeSgpO1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVhZHlQcm9taXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgcmVtb3RlIG1ldGhvZHMgYXJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgcmVtb3Rlc1JlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVtb3Rlc1JlYWR5UHJvbWlzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIHJlbW90ZSBtZXRob2QgcmVnaXN0cmF0aW9uIG1lc3NhZ2VzIHRvIG90aGVyIHRocmVhZHMgKHdvcmtlcnMgb3IgbWFpbi10aHJlYWRzKS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjcnVjaWFsIGZvciBlbmFibGluZyBjcm9zcy13b3JrZXIgY29tbXVuaWNhdGlvbiBhbmQgcmVtb3RlIG1ldGhvZCBpbnZvY2F0aW9uXG4gICAgICogZm9yIHNpbmdsZXRvbiBpbnN0YW5jZXMuIEl0IGVuc3VyZXMgdGhhdCBtZXRob2RzIGRlZmluZWQgaW4gdGhlIGByZW1vdGVgIGNvbmZpZ1xuICAgICAqIGFyZSBwcm9wZXJseSByZWdpc3RlcmVkIGluIHRoZSB0YXJnZXQgcmVhbG0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBpbnN0YW5jZSBzZW5kaW5nIHRoZSByZW1vdGUgbWVzc2FnZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlbW90ZSAgICAtIFRoZSByZW1vdGUgY29uZmlnIG9iamVjdCwgc3BlY2lmeWluZyB0YXJnZXQgdGhyZWFkcyBhbmQgbWV0aG9kcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBwcm9taXNlUmVtb3RlcyhjbGFzc05hbWUsIHJlbW90ZSkge1xuICAgICAgICBsZXQgb3JpZ2luLCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJlbW90ZSkuZm9yRWFjaCgoW3dvcmtlciwgbWV0aG9kc10pID0+IHtcbiAgICAgICAgICAgIGlmIChOZW8ud29ya2VySWQgIT09IHdvcmtlcikge1xuICAgICAgICAgICAgICAgIG9yaWdpbiA9IE5lby53b3JrZXJJZCA9PT0gJ21haW4nID8gTmVvLndvcmtlci5NYW5hZ2VyIDogTmVvLmN1cnJlbnRXb3JrZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLmhhc1dvcmtlcih3b3JrZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gob3JpZ2luLnByb21pc2VNZXNzYWdlKHdvcmtlciwge2FjdGlvbjogJ3JlZ2lzdGVyUmVtb3RlJywgY2xhc3NOYW1lLCBtZXRob2RzfSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGEgY29uZmlnIG9iamVjdC9hcnJheSB0byBiZSBKU09OLWNvbXBhdGlibGUuXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4gYSBjb25maWcgbWlnaHQgY29udGFpbiByZWZlcmVuY2VzIHRvIE5lbyBjbGFzc2VzIChjb25zdHJ1Y3RvcnMpXG4gICAgICogd2hpY2ggbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gdGhlaXIgY2xhc3NOYW1lIHN0cmluZ3MgZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9XG4gICAgICovXG4gICAgc2VyaWFsaXplQ29uZmlnKGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICB0eXBlID0gTmVvLnR5cGVPZihjb25maWcpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLm1hcChpdGVtID0+IG1lLnNlcmlhbGl6ZUNvbmZpZyhpdGVtKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY29uZmlnLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IGNvbmZpZy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ05lb0NsYXNzJyA/IGNvbmZpZy5wcm90b3R5cGUuY2xhc3NOYW1lIDogY29uZmlnXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0ID0ge307XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHR5cGUgPSBOZW8udHlwZU9mKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgICAgICBvdXQuY2xhc3NOYW1lID0gdmFsdWUucHJvdG90eXBlLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtrZXldID0gdmFsdWUucHJvdG90eXBlLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgICAgIG91dFtrZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHZhbHVlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiB2YWx1ZS5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ09iamVjdCcgfHwgdHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgICAgIG91dFtrZXldID0gbWUuc2VyaWFsaXplQ29uZmlnKHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnRnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRba2V5XSA9ICdbRnVuY3Rpb25dJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0KCkgYWNjZXB0cyB0aGUgZm9sbG93aW5nIGlucHV0IGFzIGtleXM6XG4gICAgICogMS4gTm9uLXJlYWN0aXZlIGNvbmZpZ3NcbiAgICAgKiAyLiBSZWFjdGl2ZSBjb25maWdzXG4gICAgICogMy4gQ2xhc3MgZmllbGRzIGRlZmluZWQgdmlhIHZhbHVlXG4gICAgICogNC4gQ2xhc3MgZmllbGRzIGRlZmluZWQgdmlhIGdldCgpICYgc2V0KClcbiAgICAgKiA1LiBcIkFueXRoaW5nIGVsc2VcIiB3aWxsIGdldCBkaXJlY3RseSBnZXQgYXNzaWduZWQgdG8gdGhlIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBUaGUgbG9naWMgcmVzb2x2ZXMgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFzIGdvb2QgYXMgcG9zc2libGUgYW5kIGVuc3VyZXMgdGhhdCBjb25maWcgcmVsYXRlZCBob29rczpcbiAgICAgKiAtIGJlZm9yZUdldDxDb25maWc+XG4gICAgICogLSBiZWZvcmVTZXQ8Q29uZmlnPlxuICAgICAqIC0gYWZ0ZXJTZXQ8Q29uZmlnPlxuICAgICAqIGNhbiBhY2Nlc3MgYWxsIG5ldyB2YWx1ZXMgZnJvbSB0aGUgYmF0Y2ggb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKi9cbiAgICBzZXQodmFsdWVzPXt9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjbGFzc0ZpZWxkc1ZpYVNldCA9IHt9O1xuXG4gICAgICAgIC8vIFByZXZlbnQgRWZmZWN0cyBmcm9tIHJ1bm5pbmcgZm9yIGJ1bGsgY2hhbmdlc1xuICAgICAgICBFZmZlY3RNYW5hZ2VyLnBhdXNlKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG1lLnNldEZpZWxkcyh2YWx1ZXMpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBjb25maWcgcHJvY2Vzc2luZyBpcyBzdGlsbCBydW5uaW5nLFxuICAgICAgICAgICAgLy8gZmluaXNoIHRoaXMgb25lIGZpcnN0IGJlZm9yZSBkcm9wcGluZyBuZXcgdmFsdWVzIGludG8gdGhlIGNvbmZpZ1N5bWJvbC5cbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIyMDFcbiAgICAgICAgICAgIGlmIChtZVtmb3JjZUFzc2lnbkNvbmZpZ3NdICE9PSB0cnVlICYmIE9iamVjdC5rZXlzKG1lW2NvbmZpZ1N5bWJvbF0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5wcm9jZXNzQ29uZmlncygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIGNsYXNzIGZpZWxkcyB3aGljaCBhcmUgZGVmaW5lZCB2aWEgZ2V0KCkgJiBzZXQoKSBhbmQgZW5zdXJlIHRoZXkgd29uJ3QgZ2V0IGFkZGVkIHRvIHRoZSBjb25maWcgc3ltYm9sLlxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLmlzQ29uZmlnKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NGaWVsZHNWaWFTZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVzW2tleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBBZGQgcmVhY3RpdmUgY29uZmlncyB0byB0aGUgY29uZmlnU3ltYm9sXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lW2NvbmZpZ1N5bWJvbF0sIHZhbHVlcyk7XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgY2xhc3MgZmllbGRzIHdoaWNoIGFyZSBkZWZpbmVkIHZpYSBnZXQoKSAmIHNldCgpID0+IG5vdyB0aGV5IGNhbiBhY2Nlc3MgdGhlIGxhdGVzdCB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGZvciByZWFjdGl2ZSBhbmQgbm9uLXJlYWN0aXZlIGNvbmZpZ3MsIGFzIHdlbGwgYXMgY2xhc3MgZmllbGRzIGRlZmluZWQgd2l0aCB2YWx1ZXMuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjbGFzc0ZpZWxkc1ZpYVNldCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbWVba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHJlYWN0aXZlIGNvbmZpZ3NcbiAgICAgICAgICAgIG1lLnByb2Nlc3NDb25maWdzKHRydWUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgc2tpcHBlZCBFZmZlY3QsIGlmIG5lZWRlZFxuICAgICAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byBhc3NpZ24gY2xhc3MgZmllbGRzIGZpcnN0IGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBjb25maWcgb2JqZWN0LFxuICAgICAqIHNvIHRoYXQgYWZ0ZXJTZXQoKSwgYmVmb3JlR2V0KCkgYW5kIGJlZm9yZVNldCgpIG1ldGhvZHMgY2FuIGdldCB0aGUgbmV3IHZhbHVlcyByaWdodCBhd2F5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldEZpZWxkcyhjb25maWcpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBPYmplY3QuZW50cmllcyhjb25maWcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtZS5pc0NvbmZpZyhrZXkpICYmICFOZW8uaGFzUHJvcGVydHlTZXR0ZXIobWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBtZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZ1trZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHN0YXRpYyBjb25maWcgYnkgYSBnaXZlbiBrZXlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgb2YgYSBzdGF0aWNDb25maWcgZGVmaW5lZCBpbnNpZGUgc3RhdGljIGdldFN0YXRpY0NvbmZpZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBjb25maWcgZXhpc3RzIGFuZCBnb3QgY2hhbmdlZFxuICAgICAqL1xuICAgIHNldFN0YXRpY0NvbmZpZyhrZXksIHZhbHVlKSB7XG4gICAgICAgIGxldCBzdGF0aWNDb25maWcgPSB0aGlzLmNvbnN0cnVjdG9yLnN0YXRpY0NvbmZpZztcblxuICAgICAgICBpZiAoc3RhdGljQ29uZmlnLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHN0YXRpY0NvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRpbWVvdXRJZHMgaW50ZXJuYWxseSwgc28gdGhhdCBkZXN0cm95KCkgY2FuIGNsZWFyIHRoZW0gaWYgbmVlZGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRJZHMgPSB0aGlzLiN0aW1lb3V0SWRzLFxuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCAgPSBzZXRUaW1lb3V0KCgpID0+IHt0aW1lb3V0SWRzLnNwbGljZSh0aW1lb3V0SWRzLmluZGV4T2YodGltZW91dElkKSwgMSk7IHJlc29sdmUoKX0sIHRpbWUpO1xuXG4gICAgICAgICAgICB0aW1lb3V0SWRzLnB1c2godGltZW91dElkKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZSBoZWxwZXIgdG8gZXh0cmFjdCBhbGwgbWl4aW4gY2xhc3NlcyBmcm9tIHRoZSBtaXhpbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmo9dGhpcy5taXhpbnNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlcz1bXV1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldE1peGlucyhvYmo9dGhpcy5taXhpbnMsIHJlcz1bXSkge1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKG9iaikuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRNaXhpbnModmFsdWUsIHJlcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyB0byBpbmNsdWRlIHRoZWlyIHNwZWNpZmljIHJlbGV2YW50IHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIFJlY3Vyc2lvbiBndWFyZDogSWYgYSBtaXhpbiBjYWxscyBzdXBlci50b0pTT04oKSwgaXQgaGl0cyB0aGlzIG1ldGhvZCBhZ2Fpbi5cbiAgICAgICAgLy8gV2UgcmV0dXJuIHRoZSBiYXNlIG9iamVjdCB0byBicmVhayB0aGUgbG9vcC5cbiAgICAgICAgaWYgKG1lLl9faW5Ub0pTT04pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICA6IG1lLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgaXNEZXN0cm95ZWQ6IG1lLmlzRGVzdHJveWVkLFxuICAgICAgICAgICAgICAgIG50eXBlICAgICAgOiBtZS5udHlwZSxcbiAgICAgICAgICAgICAgICByZW1vdGUgICAgIDogbWUucmVtb3RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5fX2luVG9KU09OID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IG91dCA9IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgIDogbWUuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBpc0Rlc3Ryb3llZDogbWUuaXNEZXN0cm95ZWQsXG4gICAgICAgICAgICAgICAgbnR5cGUgICAgICA6IG1lLm50eXBlLFxuICAgICAgICAgICAgICAgIHJlbW90ZSAgICAgOiBtZS5yZW1vdGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1lLmdldE1peGlucygpLmZvckVhY2gobWl4aW4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtaXhpbi5wcm90b3R5cGUudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0LCBtaXhpbi5wcm90b3R5cGUudG9KU09OLmNhbGwobWUpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkZWxldGUgbWUuX19pblRvSlNPTlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+RW5oYW5jaW5nIHRoZSB0b1N0cmluZygpIG1ldGhvZCwgZS5nLjwvcD5cbiAgICAgKiBgTmVvLmNyZWF0ZSgnTmVvLmJ1dHRvbi5CYXNlJykudG9TdHJpbmcoKSA9PiBcIltvYmplY3QgTmVvLmJ1dHRvbi5CYXNlXVwiYFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc05hbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmhhbmNpbmcgdGhlIGluc3RhbmNlb2YgbWV0aG9kLiBXaXRob3V0IHRoaXMgY2hhbmdlOjwvcD5cbiAgICAgKiBgTmVvLmNvbGxlY3Rpb24uQmFzZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IHRydWVgXG4gICAgICogPHA+V2l0aCB0aGlzIGNoYW5nZTo8L3A+XG4gICAgICogYE5lby5jb2xsZWN0aW9uLkJhc2UucHJvdG90eXBlIGluc3RhbmNlb2YgTmVvLmNvcmUuQmFzZSA9PiBmYWxzZWA8YnI+XG4gICAgICogYE5lby5jcmVhdGUoTmVvLmNvbGxlY3Rpb24uQmFzZSkgaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlID0+IHRydWVgXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlW2lzSW5zdGFuY2VdID09PSB0cnVlID8gc3VwZXJbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkgOiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCIvKipcbiAqIEBjbGFzcyBOZW8uY29yZS5Db21wYXJlXG4gKi9cbmNsYXNzIENvbXBhcmUge1xuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgdGhlIGNvbXBhcmlzb24gbWV0aG9kIG5hbWVzIGJ5IGRhdGEgdHlwZVxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWFwXG4gICAgICovXG4gICAgc3RhdGljIG1hcCA9IHtcbiAgICAgICAgQXJyYXkgICAgICA6ICdjb21wYXJlQXJyYXlzJyxcbiAgICAgICAgRGF0ZSAgICAgICA6ICdjb21wYXJlRGF0ZXMnLFxuICAgICAgICBGdW5jdGlvbiAgIDogJ2NvbXBhcmVGdW5jdGlvbnMnLFxuICAgICAgICBNYXAgICAgICAgIDogJ2NvbXBhcmVNYXBzJyxcbiAgICAgICAgTmVvSW5zdGFuY2U6ICdjb21wYXJlTmVvSW5zdGFuY2VzJyxcbiAgICAgICAgT2JqZWN0ICAgICA6ICdjb21wYXJlT2JqZWN0cycsXG4gICAgICAgIFJlZ0V4cCAgICAgOiAnY29tcGFyZVJlZ0V4cHMnLFxuICAgICAgICBTZXQgICAgICAgIDogJ2NvbXBhcmVTZXRzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlbTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZUFycmF5cyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgaWYgKGl0ZW0xLmxlbmd0aCAhPT0gaXRlbTIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2ksIHZdIG9mIGl0ZW0xLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKCFDb21wYXJlLmlzRXF1YWwodiwgaXRlbTJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVEYXRlcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0xLnZhbHVlT2YoKSA9PT0gaXRlbTIudmFsdWVPZigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlRnVuY3Rpb25zKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoaXRlbTEubmFtZSAhPT0gaXRlbTIubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbTEudG9TdHJpbmcoKSA9PT0gaXRlbTIudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWFwfSBpdGVtMVxuICAgICAqIEBwYXJhbSB7TWFwfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlTWFwcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgaWYgKGl0ZW0xLnNpemUgIT09IGl0ZW0yLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZhbDI7XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGl0ZW0xKSB7XG4gICAgICAgICAgICB2YWwyID0gaXRlbTIuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWwyICE9PSB2YWwgfHwgdmFsMiA9PT0gdW5kZWZpbmVkICYmICFpdGVtMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlTmVvSW5zdGFuY2VzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICByZXR1cm4gaXRlbTEuaWQgPT09IGl0ZW0yLmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0xXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0yXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmVPYmplY3RzKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaXRlbTEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoaXRlbTIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gaXRlbTEpIHtcbiAgICAgICAgICAgIGlmICghQ29tcGFyZS5pc0VxdWFsKGl0ZW0xW2tleV0sIGl0ZW0yW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBpdGVtMVxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlUmVnRXhwcyhpdGVtMSwgaXRlbTIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0xLnRvU3RyaW5nKCkgPT09IGl0ZW0yLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NldH0gaXRlbTFcbiAgICAgKiBAcGFyYW0ge1NldH0gaXRlbTJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVNldHMoaXRlbTEsIGl0ZW0yKSB7XG4gICAgICAgIGlmIChpdGVtMS5zaXplICE9PSBpdGVtMi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBpdGVtMSkge1xuICAgICAgICAgICAgaWYgKCFpdGVtMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0xXG4gICAgICogQHBhcmFtIHsqfSBpdGVtMlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VxdWFsKGl0ZW0xLCBpdGVtMikge1xuICAgICAgICBpZiAoaXRlbTEgPT09IGl0ZW0yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHR5cGUxID0gTmVvLnR5cGVPZihpdGVtMSksXG4gICAgICAgICAgICB0eXBlMiA9IE5lby50eXBlT2YoaXRlbTIpO1xuXG4gICAgICAgIGlmICh0eXBlMSAhPT0gdHlwZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbXBhcmUubWFwW3R5cGUxXSkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBhcmVbQ29tcGFyZS5tYXBbdHlwZTFdXShpdGVtMSwgaXRlbTIpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGwgb3RoZXIgdHlwZXNcbiAgICAgICAgcmV0dXJuIGl0ZW0xID09PSBpdGVtMlxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLmdhdGVrZWVwKENvbXBhcmUsICdOZW8uY29yZS5Db21wYXJlJywgKCkgPT4ge1xuICAgIC8vIGFsaWFzXG4gICAgTmVvLmlzRXF1YWwgPSBDb21wYXJlLmlzRXF1YWxcbn0pO1xuIiwiaW1wb3J0IEVmZmVjdE1hbmFnZXIgIGZyb20gJy4vRWZmZWN0TWFuYWdlci5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9IGZyb20gJy4vQ29uZmlnU3ltYm9scy5tanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb2JzZXJ2YWJsZSBjb250YWluZXIgZm9yIGEgY29uZmlnIHByb3BlcnR5LlxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIHRoZSB2YWx1ZSBvZiBhIGNvbmZpZywgaXRzIHN1YnNjcmliZXJzLCBhbmQgY3VzdG9tIGJlaGF2aW9yc1xuICogbGlrZSBtZXJnZSBzdHJhdGVnaWVzIGFuZCBlcXVhbGl0eSBjaGVja3MgZGVmaW5lZCB2aWEgYSBkZXNjcmlwdG9yIG9iamVjdC5cbiAqXG4gKiBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgY2xhc3MgaXMgdG8gZW5hYmxlIGZpbmUtZ3JhaW5lZCByZWFjdGl2aXR5IGFuZFxuICogZGVjb3VwbGVkIGNyb3NzLWluc3RhbmNlIHN0YXRlIHNoYXJpbmcgd2l0aGluIHRoZSBOZW8ubWpzIGZyYW1ld29yay5cbiAqIEBjbGFzcyBOZW8uY29yZS5Db25maWdcbiAqIEBwcml2YXRlXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ29uZmlnIHtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgYWxsIHN1YnNjcmlwdGlvbnMgZm9yIHRoaXMgQ29uZmlnIGluc3RhbmNlLlxuICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBpcyBhIE1hcCB3aGVyZTpcbiAgICAgKiAtIFRoZSBrZXkgaXMgdGhlIElEIG9mIHRoZSBzdWJzY3JpcHRpb24gb3duZXIgKGUuZy4sIGEgY29tcG9uZW50J3MgYGlkYCkuXG4gICAgICogLSBUaGUgdmFsdWUgaXMgYW5vdGhlciBNYXAgKHRoZSBzdWJzY3JpYmVyTWFwKS5cbiAgICAgKlxuICAgICAqIFRoZSBuZXN0ZWQgc3Vic2NyaWJlck1hcCBpcyBzdHJ1Y3R1cmVkIGFzOlxuICAgICAqIC0gVGhlIGtleSBpcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKGBmbmApLlxuICAgICAqIC0gVGhlIHZhbHVlIGlzIGEgU2V0IG9mIHNjb3BlcyAoYHNjb3BlU2V0YCkuXG4gICAgICpcbiAgICAgKiBUaGlzIG5lc3RlZCBzdHJ1Y3R1cmUgYE1hcDxzdHJpbmcsIE1hcDxmdW5jdGlvbiwgU2V0PHNjb3BlPj4+YCBpcyBpbnRlbnRpb25hbGx5IGNob3NlblxuICAgICAqIHRvIHJvYnVzdGx5IGhhbmRsZSB0aGUgZWRnZSBjYXNlIHdoZXJlIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHN1YnNjcmliZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgKiB3aXRoIGRpZmZlcmVudCBzY29wZXMsIGFsbCB1bmRlciB0aGUgc2FtZSBvd25lciBJRC4gSXQgZW5zdXJlcyB0aGF0IGVhY2hcbiAgICAgKiBgZm5gLWBzY29wZWAgY29tYmluYXRpb24gaXMgdW5pcXVlIGFuZCB0aGF0IGNsZWFudXAgaXMgcHJlY2lzZS5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9ICNzdWJzY3JpYmVycz17fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3N1YnNjcmliZXJzID0ge31cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgdmFsdWUgb2YgdGhlIGNvbmZpZyBwcm9wZXJ0eS5cbiAgICAgKiBAbWVtYmVyIHsqfSAjdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICN2YWx1ZVxuICAgIC8qKlxuICAgICAqIFRoZSBjbG9uaW5nIHN0cmF0ZWd5IHRvIHVzZSB3aGVuIHNldHRpbmcgYSBuZXcgdmFsdWUuXG4gICAgICogU3VwcG9ydGVkIHZhbHVlczogJ2RlZXAnLCAnc2hhbGxvdycsICdub25lJy5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsb25lPSdkZWVwJ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNsb25pbmcgc3RyYXRlZ3kgdG8gdXNlIHdoZW4gZ2V0dGluZyBhIHZhbHVlLlxuICAgICAqIFN1cHBvcnRlZCB2YWx1ZXM6ICdkZWVwJywgJ3NoYWxsb3cnLCAnbm9uZScuXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBjbG9uZU9uR2V0PW51bGxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbXBhcmUgbmV3IGFuZCBvbGQgdmFsdWVzIGZvciBlcXVhbGl0eS5cbiAgICAgKiBEZWZhdWx0cyB0byBgTmVvLmlzRXF1YWxgLiBDYW4gYmUgb3ZlcnJpZGRlbiB2aWEgYSBkZXNjcmlwdG9yLlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBpc0VxdWFsPU5lby5pc0VxdWFsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyYXRlZ3kgdG8gdXNlIHdoZW4gbWVyZ2luZyBuZXcgdmFsdWVzIGludG8gdGhpcyBjb25maWcuXG4gICAgICogRGVmYXVsdHMgdG8gJ3JlcGxhY2UnLiBDYW4gYmUgb3ZlcnJpZGRlbiB2aWEgYSBkZXNjcmlwdG9yIG1lcmdlIHByb3BlcnR5LlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufFN0cmluZ30gbWVyZ2VTdHJhdGVneT0ncmVwbGFjZSdcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ29uZmlnLlxuICAgICAqIEBwYXJhbSB7YW55fE9iamVjdH0gY29uZmlnT2JqZWN0IC0gVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBjb25maWcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnT2JqZWN0KSB7XG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QoY29uZmlnT2JqZWN0KSAmJiBjb25maWdPYmplY3RbaXNEZXNjcmlwdG9yXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RGVzY3JpcHRvcihjb25maWdPYmplY3QpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiN2YWx1ZSA9IGNvbmZpZ09iamVjdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY29uZmlnIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXJzIHRoaXMgQ29uZmlnIGluc3RhbmNlIGFzIGEgZGVwZW5kZW5jeSB3aXRoIHRoZSBjdXJyZW50bHkgYWN0aXZlIEVmZmVjdCxcbiAgICAgICAgLy8gZW5hYmxpbmcgYXV0b21hdGljIHJlLWV4ZWN1dGlvbiB3aGVuIHRoaXMgQ29uZmlnJ3MgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgRWZmZWN0TWFuYWdlci5hZGREZXBlbmRlbmN5KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy4jdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYENvbmZpZ2AgaW5zdGFuY2UgdXNpbmcgYSBkZXNjcmlwdG9yIG9iamVjdC5cbiAgICAgKiBFeHRyYWN0cyBgY2xvbmVgLCBgbWVyZ2VTdHJhdGVneWAgYW5kIGBpc0VxdWFsYCBmcm9tIHRoZSBkZXNjcmlwdG9yLlxuICAgICAqIFRoZSBpbnRlcm5hbCBgI3ZhbHVlYCBpcyBOT1Qgc2V0IGJ5IHRoaXMgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICBkZXNjcmlwdG9yICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGRlc2NyaXB0b3Igb2JqZWN0IGZvciB0aGUgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgIFtkZXNjcmlwdG9yLmNsb25lPSdkZWVwJ10gICAgICAgIC0gVGhlIGNsb25lIHN0cmF0ZWd5IGZvciBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgW2Rlc2NyaXB0b3IuY2xvbmVPbkdldF0gICAgICAgICAgLSBUaGUgY2xvbmUgc3RyYXRlZ3kgZm9yIGdldC4gRGVmYXVsdHMgdG8gJ3NoYWxsb3cnIGlmIGNsb25lIGlzICdkZWVwJyBvciAnc2hhbGxvdycsIGFuZCAnbm9uZScgaWYgY2xvbmUgaXMgJ25vbmUnLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkZXNjcmlwdG9yLmlzRXF1YWw9TmVvLmlzRXF1YWxdIC0gVGhlIGVxdWFsaXR5IGNvbXBhcmlzb24gZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgW2Rlc2NyaXB0b3IubWVyZ2U9J2RlZXAnXSAgICAgICAgLSBUaGUgbWVyZ2Ugc3RyYXRlZ3kuXG4gICAgICogQHBhcmFtIHthbnl9ICAgICAgIGRlc2NyaXB0b3IudmFsdWUgICAgICAgICAgICAgICAgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbmZpZyAobm90IHNldCBieSB0aGlzIG1ldGhvZCkuXG4gICAgICovXG4gICAgaW5pdERlc2NyaXB0b3Ioe2Nsb25lLCBjbG9uZU9uR2V0LCBpc0VxdWFsLCBtZXJnZX0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoY2xvbmUgJiYgY2xvbmUgIT09IG1lLmNsb25lKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdjbG9uZScsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBjbG9uZSwgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvbmVPbkdldCAmJiBjbG9uZU9uR2V0ICE9PSBtZS5jbG9uZU9uR2V0KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdjbG9uZU9uR2V0Jywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IGNsb25lT25HZXQsIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXF1YWwgJiYgaXNFcXVhbCAhPT0gbWUuaXNFcXVhbCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnaXNFcXVhbCcsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBpc0VxdWFsLCB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZSAmJiBtZXJnZSAhPT0gbWUubWVyZ2VTdHJhdGVneSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnbWVyZ2VTdHJhdGVneScsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBtZXJnZSwgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBjYWxsYmFja3MgYWJvdXQgYSBjaGFuZ2UgaW4gdGhlIGNvbmZpZydzIHZhbHVlLlxuICAgICAqIEl0IGl0ZXJhdGVzIHRocm91Z2ggdGhlIG5lc3RlZCBzdWJzY3JpYmVyIHN0cnVjdHVyZSB0byBlbnN1cmUgZWFjaCBjYWxsYmFja1xuICAgICAqIGlzIGV4ZWN1dGVkIHdpdGggaXRzIGludGVuZGVkIHNjb3BlLlxuICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgLSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBjb25maWcuXG4gICAgICovXG4gICAgbm90aWZ5KG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuI3N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jc3Vic2NyaWJlcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlck1hcCA9IHRoaXMuI3N1YnNjcmliZXJzW2lkXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmbiwgc2NvcGVTZXRdIG9mIHN1YnNjcmliZXJNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZVNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChzY29wZSB8fCBudWxsLCBuZXdWYWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IHZhbHVlIGZvciB0aGUgY29uZmlnIHByb3BlcnR5LlxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGFuIGVxdWFsaXR5IGNoZWNrIHVzaW5nIGB0aGlzLmlzRXF1YWxgIGJlZm9yZSB1cGRhdGluZyB0aGUgdmFsdWUuXG4gICAgICogSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBpdCB1cGRhdGVzIGAjdmFsdWVgIGFuZCBub3RpZmllcyBhbGwgc3Vic2NyaWJlcnMuXG4gICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIC0gVGhlIG5ldyB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTsgLy8gUHJlc2VydmUgb3JpZ2luYWwgYmVoYXZpb3IgZm9yIHVuZGVmaW5lZFxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IG1lLiN2YWx1ZTtcblxuICAgICAgICAvLyBUaGUgc2V0dGVyIGF1dG9tYXRpY2FsbHkgdXNlcyB0aGUgY29uZmlndXJlZCBlcXVhbGl0eSBjaGVja1xuICAgICAgICBpZiAoIW1lLmlzRXF1YWwobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgbWUuI3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBtZS5ub3RpZnkobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbnRlcm5hbCB2YWx1ZSBvZiB0aGUgY29uZmlnIHByb3BlcnR5IGRpcmVjdGx5LCB3aXRob3V0IHBlcmZvcm1pbmdcbiAgICAgKiBhbiBlcXVhbGl0eSBjaGVjayBvciBub3RpZnlpbmcgc3Vic2NyaWJlcnMuXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGludGVybmFsIGZyYW1ld29yayB1c2Ugd2hlcmUgZGlyZWN0IGFzc2lnbm1lbnRcbiAgICAgKiBpcyBuZWNlc3NhcnkgKGUuZy4sIGR1cmluZyBpbml0aWFsIHNldHVwIG9yIHNwZWNpZmljIGludGVybmFsIG9wdGltaXphdGlvbnMpLlxuICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUgdG8gc2V0IGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHNldFJhdyhuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLiN2YWx1ZSA9IG5ld1ZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNoYW5nZXMgaW4gdGhpcyBjb25maWcncyB2YWx1ZS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdpdGggYChuZXdWYWx1ZSwgb2xkVmFsdWUpYCB3aGVuZXZlciB0aGUgY29uZmlnIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucyAgICAgICAgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3Vic2NyaXB0aW9uIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5pZCAgICAgLSBUaGUgSUQgb2YgdGhlIHN1YnNjcmlwdGlvbiBvd25lciAoZS5nLiwgYSBOZW8uY29yZS5CYXNlIGluc3RhbmNlJ3MgaWQpLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuZm4gICAgIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnMuc2NvcGVdIC0gVGhlIHNjb3BlIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIGluLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBjbGVhbnVwIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoe2lkLCBmbiwgc2NvcGV9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnIHx8IGlkLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICAgICAgJ0NvbmZpZy5zdWJzY3JpYmU6IG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBhIG5vbi1lbXB0eSBzdHJpbmcgYGlkYCAnLFxuICAgICAgICAgICAgICAgICcodGhlIHN1YnNjcmlwdGlvbiBvd25lclxcJ3MgaWQpLCBhbmQgYSBjYWxsYmFjayBmdW5jdGlvbiBgZm5gLidcbiAgICAgICAgICAgIF0uam9pbignJykpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgdG9wLWxldmVsIE1hcCBmb3IgdGhlIHN1YnNjcmlwdGlvbiBvd25lci5cbiAgICAgICAgaWYgKCFtZS4jc3Vic2NyaWJlcnNbaWRdKSB7XG4gICAgICAgICAgICBtZS4jc3Vic2NyaWJlcnNbaWRdID0gbmV3IE1hcCgpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdWJzY3JpYmVyTWFwID0gbWUuI3N1YnNjcmliZXJzW2lkXTtcblxuICAgICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBTZXQgb2Ygc2NvcGVzIGZvciB0aGUgc3BlY2lmaWMgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgIGlmICghc3Vic2NyaWJlck1hcC5oYXMoZm4pKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyTWFwLnNldChmbiwgbmV3IFNldCgpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NvcGVTZXQgPSBzdWJzY3JpYmVyTWFwLmdldChmbik7XG4gICAgICAgIHNjb3BlU2V0LmFkZChzY29wZSk7XG5cbiAgICAgICAgLy8gVGhlIHJldHVybmVkIGNsZWFudXAgZnVuY3Rpb24gaXMgcHJlY2lzZS4gSXQgcmVtb3ZlcyBvbmx5IHRoZSBzcGVjaWZpY1xuICAgICAgICAvLyBzY29wZSBmb3IgdGhlIGZ1bmN0aW9uLCBhbmQgY2xlYW5zIHVwIHRoZSBwYXJlbnQgZGF0YSBzdHJ1Y3R1cmVzXG4gICAgICAgIC8vICh0aGUgU2V0IGFuZCB0aGUgTWFwcykgb25seSBpZiB0aGV5IGJlY29tZSBlbXB0eS5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdWJzY3JpYmVyTWFwID0gbWUuI3N1YnNjcmliZXJzW2lkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3Vic2NyaWJlck1hcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTY29wZVNldCA9IGN1cnJlbnRTdWJzY3JpYmVyTWFwLmdldChmbik7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZVNldCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGVTZXQuZGVsZXRlKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZVNldC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3Vic2NyaWJlck1hcC5kZWxldGUoZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdWJzY3JpYmVyTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUuI3N1YnNjcmliZXJzW2lkXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25maWcucHJvdG90eXBlLCB7XG4gICAgY2xvbmUgICAgICAgIDoge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiAnZGVlcCcsICAgICAgd3JpdGFibGU6IGZhbHNlfSxcbiAgICBjbG9uZU9uR2V0ICAgOiB7Y29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG51bGwsICAgICAgICB3cml0YWJsZTogZmFsc2V9LFxuICAgIGlzRXF1YWwgICAgICA6IHtjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogTmVvLmlzRXF1YWwsIHdyaXRhYmxlOiBmYWxzZX0sXG4gICAgbWVyZ2VTdHJhdGVneToge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiAncmVwbGFjZScsICAgd3JpdGFibGU6IGZhbHNlfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5nYXRla2VlcChDb25maWcsICdOZW8uY29yZS5Db25maWcnKTtcbiIsImV4cG9ydCBjb25zdCBpc0Rlc2NyaXB0b3IgPSBTeW1ib2wuZm9yKCdOZW8uQ29uZmlnLmlzRGVzY3JpcHRvcicpO1xuIiwiLyoqXG4gKiBBIHNpbmdsZXRvbiBtYW5hZ2VyIHRvIHRyYWNrIHRoZSBjdXJyZW50bHkgcnVubmluZyBlZmZlY3QgYW5kIGNvbnRyb2wgZ2xvYmFsIGVmZmVjdCBleGVjdXRpb24uXG4gKiBJdCBwcm92aWRlcyBhIGNlbnRyYWxpemVkIG1lY2hhbmlzbSBmb3IgcGF1c2luZywgcmVzdW1pbmcsIGFuZCBiYXRjaGluZyBlZmZlY3QgcnVucy5cbiAqIEBjbGFzcyBOZW8uY29yZS5FZmZlY3RNYW5hZ2VyXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNvbnN0IEVmZmVjdE1hbmFnZXIgPSB7XG4gICAgLyoqXG4gICAgICogQSBzdGFjayB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVmZmVjdCBhbmQgaXRzIHByZWRlY2Vzc29ycy5cbiAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5FZmZlY3RbXX0gZWZmZWN0U3RhY2s9W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZWZmZWN0U3RhY2s6IFtdLFxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byB0ZW1wb3JhcmlseSBkaXNhYmxlIGRlcGVuZGVuY3kgdHJhY2tpbmcgZm9yIHRoZSBhY3RpdmUgZWZmZWN0LlxuICAgICAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIHByZXZlbnQgZWZmZWN0cyBmcm9tIGRlcGVuZGluZyBvbiB0aGVpciBvd24gc3RhdGUsIGxpa2UgYGlzUnVubmluZ2AuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNUcmFja2luZ1BhdXNlZD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc1RyYWNraW5nUGF1c2VkOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBBIGNvdW50ZXIgdG8gbWFuYWdlIG5lc3RlZCBjYWxscyB0byBwYXVzZSgpIGFuZCByZXN1bWUoKS4gRWZmZWN0IGV4ZWN1dGlvbiBpc1xuICAgICAqIHBhdXNlZCBvciBiYXRjaGVkIHdoaWxlIHRoaXMgY291bnRlciBpcyBncmVhdGVyIHRoYW4gMC5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHBhdXNlQ291bnRlcj0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHBhdXNlQ291bnRlcjogMCxcbiAgICAvKipcbiAgICAgKiBBIFNldCB0byBzdG9yZSB1bmlxdWUgZWZmZWN0cyB0aGF0IGFyZSB0cmlnZ2VyZWQgd2hpbGUgdGhlIG1hbmFnZXIgaXMgcGF1c2VkLlxuICAgICAqIFRoZXNlIGVmZmVjdHMgd2lsbCBiZSBydW4gd2hlbiByZXN1bWUoKSBpcyBjYWxsZWQgYW5kIHRoZSBwYXVzZUNvdW50ZXIgcmV0dXJucyB0byAwLlxuICAgICAqIEBtZW1iZXIge1NldDxOZW8uY29yZS5FZmZlY3Q+fSBxdWV1ZWRFZmZlY3RzPW5ldyBTZXQoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBxdWV1ZWRFZmZlY3RzOiBuZXcgU2V0KCksXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYE5lby5jb3JlLkNvbmZpZ2AgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZmZlY3QsXG4gICAgICogdW5sZXNzIGRlcGVuZGVuY3kgdHJhY2tpbmcgaXMgZXhwbGljaXRseSBwYXVzZWQuXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5Db25maWd9IGNvbmZpZyBUaGUgY29uZmlnIGluc3RhbmNlIHRvIGFkZCBhcyBhIGRlcGVuZGVuY3kuXG4gICAgICovXG4gICAgYWRkRGVwZW5kZW5jeShjb25maWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhY2tpbmdQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QWN0aXZlRWZmZWN0KCk/LmFkZERlcGVuZGVuY3koY29uZmlnKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVmZmVjdCBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2sgKGkuZS4sIHRoZSBvbmUgY3VycmVudGx5IHJ1bm5pbmcpLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5FZmZlY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVFZmZlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVmZmVjdFN0YWNrW3RoaXMuZWZmZWN0U3RhY2subGVuZ3RoIC0gMV1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVmZmVjdCBleGVjdXRpb24gaXMgY3VycmVudGx5IHBhdXNlZCBvciBiYXRjaGVkLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwYXVzZUNvdW50ZXIgaXMgZ3JlYXRlciB0aGFuIDAuXG4gICAgICovXG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlQ291bnRlciA+IDBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIGVmZmVjdCBleGVjdXRpb24gYW5kIGJlZ2lucyBiYXRjaGluZy5cbiAgICAgKiBFYWNoIGNhbGwgdG8gcGF1c2UoKSBpbmNyZW1lbnRzIGEgY291bnRlciwgYWxsb3dpbmcgZm9yIG5lc3RlZCBjb250cm9sLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnBhdXNlQ291bnRlcisrXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGRlcGVuZGVuY3kgdHJhY2tpbmcgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcGF1c2VUcmFja2luZygpIHtcbiAgICAgICAgdGhpcy5pc1RyYWNraW5nUGF1c2VkID0gdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQb3BzIHRoZSBjdXJyZW50IGVmZmVjdCBmcm9tIHRoZSBzdGFjay5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuRWZmZWN0fG51bGx9XG4gICAgICovXG4gICAgcG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3RTdGFjay5wb3AoKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYW4gZWZmZWN0IG9udG8gdGhlIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuRWZmZWN0fSBlZmZlY3QgVGhlIGVmZmVjdCB0byBwdXNoLlxuICAgICAqL1xuICAgIHB1c2goZWZmZWN0KSB7XG4gICAgICAgIHRoaXMuZWZmZWN0U3RhY2sucHVzaChlZmZlY3QpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyBhIHVuaXF1ZSBlZmZlY3QgdG8gYmUgcnVuIGxhdGVyLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuRWZmZWN0fSBlZmZlY3QgVGhlIGVmZmVjdCB0byBxdWV1ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcXVldWUoZWZmZWN0KSB7XG4gICAgICAgIHRoaXMucXVldWVkRWZmZWN0cy5hZGQoZWZmZWN0KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIGVmZmVjdCBleGVjdXRpb24uIElmIHRoZSBwYXVzZSBjb3VudGVyIHJldHVybnMgdG8gemVybyBhbmQgZWZmZWN0c1xuICAgICAqIGhhdmUgYmVlbiBxdWV1ZWQsIHRoZXkgd2lsbCBhbGwgYmUgZXhlY3V0ZWQgc3luY2hyb25vdXNseS5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnBhdXNlQ291bnRlciA+IDApIHtcbiAgICAgICAgICAgIG1lLnBhdXNlQ291bnRlci0tO1xuXG4gICAgICAgICAgICBpZiAobWUucGF1c2VDb3VudGVyID09PSAwICYmIG1lLnF1ZXVlZEVmZmVjdHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZmZlY3RzVG9SdW4gPSBbLi4ubWUucXVldWVkRWZmZWN0c107XG4gICAgICAgICAgICAgICAgbWUucXVldWVkRWZmZWN0cy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIGVmZmVjdHNUb1J1bi5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QucnVuKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmUtZW5hYmxlcyBkZXBlbmRlbmN5IHRyYWNraW5nIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlc3VtZVRyYWNraW5nKCkge1xuICAgICAgICB0aGlzLmlzVHJhY2tpbmdQYXVzZWQgPSBmYWxzZVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5nYXRla2VlcChFZmZlY3RNYW5hZ2VyLCAnTmVvLmNvcmUuRWZmZWN0TWFuYWdlcicsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGZ1bmN0aW9uIGluIGEgYmF0Y2ggb3BlcmF0aW9uLCBlbnN1cmluZyB0aGF0IGFsbCBlZmZlY3RzIHRyaWdnZXJlZFxuICAgICAqIHdpdGhpbiBpdCBhcmUgcnVuIG9ubHkgb25jZSBhZnRlciB0aGUgZnVuY3Rpb24gY29tcGxldGVzLlxuICAgICAqIEBmdW5jdGlvbiBOZW8uYmF0Y2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICAgKi9cbiAgICBOZW8uYmF0Y2ggPSBmdW5jdGlvbihmbikge1xuICAgICAgICBFZmZlY3RNYW5hZ2VyLnBhdXNlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbigpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyBUaGUgcHVibGljIHJlc3VtZSgpIG1ldGhvZCBoYW5kbGVzIHJ1bm5pbmcgcXVldWVkIGVmZmVjdHMuXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8qKlxuICogUHJvdmlkZXMgYSBzaW5nbGV0b24gdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgSURzLlxuICogQG5hbWVzcGFjZSBOZW8uY29yZS5JZEdlbmVyYXRvclxuICovXG5jb25zdCBJZEdlbmVyYXRvciA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBwcmVmaXggZm9yIG5lbyBpbnN0YW5jZSBpZHNcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGJhc2U9J25lby0nXG4gICAgICovXG4gICAgYmFzZTogJ25lby0nLFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gaWRDb3VudGVyPXt9XG4gICAgICovXG4gICAgaWRDb3VudGVyOiB7fSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZChuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8ICduZW8nO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvdW50ZXIgPSBtZS5pZENvdW50ZXIsXG4gICAgICAgICAgICBjb3VudCAgID0gY291bnRlcltuYW1lXSB8fCAwO1xuXG4gICAgICAgIGNvdW50ZXJbbmFtZV0gPSArK2NvdW50O1xuXG4gICAgICAgIHJldHVybiBtZS5iYXNlICsgKG5hbWUgPT09ICduZW8nID8gJycgOiBuYW1lICsgJy0nKSArIGNvdW50XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uZ2F0ZWtlZXAoSWRHZW5lcmF0b3IsICdOZW8uY29yZS5JZEdlbmVyYXRvcicsICgpID0+IHtcbiAgICBOZW8uZ2V0SWQgPSBJZEdlbmVyYXRvci5nZXRJZC5iaW5kKElkR2VuZXJhdG9yKVxufSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgIGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuaW1wb3J0IHtyZXNvbHZlQ2FsbGJhY2t9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcblxuLyoqXG4gKiBBIHVuaXF1ZSwgbm9uLWVudW1lcmFibGUga2V5IGZvciB0aGUgaW50ZXJuYWwgZXZlbnQgbWFwLlxuICogVXNpbmcgYSBTeW1ib2wgcHJldmVudHMgcHJvcGVydHkgbmFtZSBjb2xsaXNpb25zIG9uIHRoZSBjb25zdW1pbmcgY2xhc3MgaW5zdGFuY2UsXG4gKiBwcm92aWRpbmcgYSByb2J1c3Qgd2F5IHRvIG1hbmFnZSBwcml2YXRlIHN0YXRlIHdpdGhpbiBhIG1peGluLlxuICogQHR5cGUge1N5bWJvbH1cbiAqL1xuY29uc3QgZXZlbnRNYXBTeW1ib2wgPSBTeW1ib2woJ2V2ZW50TWFwJyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvcmUuT2JzZXJ2YWJsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvcmUuT2JzZXJ2YWJsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdtaXhpbi1vYnNlcnZhYmxlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21peGluLW9ic2VydmFibGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBkZWNsYXJhdGl2ZSB3YXkgdG8gYXNzaWduIGV2ZW50IGxpc3RlbmVycyB0byBhbiBpbnN0YW5jZSB1cG9uIGNyZWF0aW9uLlxuICAgICAgICAgKiBUaGUgZnJhbWV3b3JrIHByb2Nlc3NlcyB0aGlzIGNvbmZpZyBhbmQgY2FsbHMgYG9uKClgIHRvIHBvcHVsYXRlIHRoZVxuICAgICAgICAgKiBpbnRlcm5hbCBldmVudCByZWdpc3RyeS4gVGhpcyBjb25maWcgc2hvdWxkIG5vdCBiZSBtYW5pcHVsYXRlZCBkaXJlY3RseSBhZnRlclxuICAgICAgICAgKiBpbnN0YW50aWF0aW9uOyB1c2UgYG9uKClgIGFuZCBgdW4oKWAgaW5zdGVhZC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxpc3RlbmVyc19cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbGlzdGVuZXJzOiB7XG4gICAgICAgICAqICAgICBteUV2ZW50OiAnb25NeUV2ZW50JyxcbiAgICAgICAgICogICAgIG90aGVyRXZlbnQ6IHtcbiAgICAgICAgICogICAgICAgICBmbjogJ29uT3RoZXJFdmVudCcsXG4gICAgICAgICAqICAgICAgICAgZGVsYXk6IDEwMCxcbiAgICAgICAgICogICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAqICAgICB9LFxuICAgICAgICAgKiAgICAgc2NvcGU6IHRoaXNcbiAgICAgICAgICogfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RlbmVyc186IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdkZWVwJyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiB7fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBbZXZlbnRNYXBTeW1ib2xdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3JkZXJdXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBldmVudElkIG51bGwgaW4gY2FzZSBhbiBvYmplY3QgZ2V0cyBwYXNzZWQgYXMgdGhlIG5hbWUgKG11bHRpcGxlIGlkcylcbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihuYW1lLCBvcHRzLCBzY29wZSwgZXZlbnRJZCwgZGF0YSwgb3JkZXIpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGVsYXkgICAgICAgICA9IDAsXG4gICAgICAgICAgICBldmVudElkT2JqZWN0ID0gdHlwZW9mIGV2ZW50SWQgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgbmFtZU9iamVjdCAgICA9IHR5cGVvZiBuYW1lICAgID09PSAnb2JqZWN0JyxcbiAgICAgICAgICAgIG9uY2UgICAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG9wdHNUeXBlICAgICAgPSB0eXBlb2Ygb3B0cyxcbiAgICAgICAgICAgIGxpc3RlbmVyLCBleGlzdGluZywgZXZlbnRDb25maWc7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogbGV0IHVzIHN1cHBvcnQgdGhlIGZvbGxvd2luZyBmb3JtYXQgdG9vOlxuICAgICAgICAgKlxuICAgICAgICAgKiBjdXJyZW50V29ya2VyLm9uKCdjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAqICAgICBCYXNlLnNlbmRSZW1vdGVzKGNsYXNzTmFtZSwgcmVtb3RlKVxuICAgICAgICAgKiB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGV2ZW50SWRPYmplY3QgJiYgb3B0c1R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGV2ZW50SWQuZm4gPSBvcHRzO1xuICAgICAgICAgICAgb3B0cyAgICAgPSBldmVudElkO1xuICAgICAgICAgICAgb3B0c1R5cGUgPSAnb2JqZWN0JztcbiAgICAgICAgICAgIGV2ZW50SWQgID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eSgnZGVsYXknKSkge1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gbmFtZS5kZWxheTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5kZWxheVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eSgnb25jZScpKSB7XG4gICAgICAgICAgICAgICAgb25jZSA9IG5hbWUub25jZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5vbmNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdvcmRlcicpKSB7XG4gICAgICAgICAgICAgICAgb3JkZXIgPSBuYW1lLm9yZGVyO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLm9yZGVyXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KCdzY29wZScpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBuYW1lLnNjb3BlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lLnNjb3BlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG5hbWUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFkZExpc3RlbmVyKGtleSwge2RlbGF5LCBvbmNlLCBvcmRlciwgc2NvcGUsIC4uLnZhbHVlfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5hZGRMaXN0ZW5lcihrZXksIHtkZWxheSwgZm46IHZhbHVlLCBvbmNlLCBvcmRlciwgc2NvcGV9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAob3B0c1R5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkZWxheSAgICA9IGRlbGF5ICAgfHwgb3B0cy5kZWxheTtcbiAgICAgICAgICAgIGV2ZW50SWQgID0gZXZlbnRJZCB8fCBvcHRzLmV2ZW50SWQ7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IG9wdHMuZm47XG4gICAgICAgICAgICBvbmNlICAgICA9IG9uY2UgICAgfHwgb3B0cy5vbmNlO1xuICAgICAgICAgICAgb3JkZXIgICAgPSBvcmRlciAgIHx8IG9wdHMub3JkZXI7XG4gICAgICAgICAgICBzY29wZSAgICA9IHNjb3BlICAgfHwgb3B0cy5zY29wZVxuICAgICAgICB9IGVsc2UgaWYgKG9wdHNUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IG9wdHNcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gb3B0cyAvLyBWQyBob29rLCBjYW4gZ2V0IHBhcnNlZCBhZnRlciBvbkNvbnN0cnVjdGVkIGluIGNhc2UgdGhlIHZpZXcgdXNlcyB0aGUgcGFyZW50IFZDXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkTGlzdGVuZXIgY2FsbDogJyArIG5hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5hbWVPYmplY3QpIHtcbiAgICAgICAgICAgIC8vIExBWlkgSU5JVElBTElaQVRJT046IFRoZSBrZXkgdG8gYSByb2J1c3QgbWl4aW4uXG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIHByaXZhdGUgaW50ZXJuYWwgbGlzdGVuZXIgc3RvcmUgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIGBldmVudE1hcFN5bWJvbGAgaXMgdGhlICphY3R1YWwqIHJlZ2lzdHJ5IG9mIGhhbmRsZXIgYXJyYXlzLCBhbmQgaXNcbiAgICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgc2VwYXJhdGUgZnJvbSB0aGUgcHVibGljIGBsaXN0ZW5lcnNfYCBjb25maWcuXG4gICAgICAgICAgICBtZVtldmVudE1hcFN5bWJvbF0gPz89IHt9O1xuXG4gICAgICAgICAgICBldmVudENvbmZpZyA9IHtmbjogbGlzdGVuZXIsIGlkOiBldmVudElkIHx8IE5lby5nZXRJZCgnZXZlbnQnKX07XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSAgICAgIHtldmVudENvbmZpZy5kYXRhICAgPSBkYXRhfVxuICAgICAgICAgICAgaWYgKGRlbGF5ID4gMCkge2V2ZW50Q29uZmlnLmRlbGF5ICA9IGRlbGF5fVxuICAgICAgICAgICAgaWYgKG9uY2UpICAgICAge2V2ZW50Q29uZmlnLm9uY2UgICA9IG9uY2V9XG4gICAgICAgICAgICBpZiAoc2NvcGUpICAgICB7ZXZlbnRDb25maWcuc2NvcGUgID0gc2NvcGV9XG5cbiAgICAgICAgICAgIGlmICgoZXhpc3RpbmcgPSBtZVtldmVudE1hcFN5bWJvbF1bbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmcuZm9yRWFjaChjZmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ZnLmlkID09PSBldmVudElkIHx8IChjZmcuZm4gPT09IGxpc3RlbmVyICYmIGNmZy5zY29wZSA9PT0gc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdEdXBsaWNhdGUgZXZlbnQgaGFuZGxlciBhdHRhY2hlZDonLCBuYW1lLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcuc3BsaWNlKG9yZGVyLCAwLCBldmVudENvbmZpZylcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnYmVmb3JlJykge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy51bnNoaWZ0KGV2ZW50Q29uZmlnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2goZXZlbnRDb25maWcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZVtldmVudE1hcFN5bWJvbF1bbmFtZV0gPSBbZXZlbnRDb25maWddIC8vIFVzZSB0aGUgcHJpdmF0ZSBldmVudE1hcFN5bWJvbCByZWdpc3RyeVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRDb25maWcuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBob29rIGlzIHRoZSBicmlkZ2UgYmV0d2VlbiB0aGUgZGVjbGFyYXRpdmUgYGxpc3RlbmVyc19gIGNvbmZpZyBhbmQgdGhlXG4gICAgICogaW1wZXJhdGl2ZSBgb24oKWAvYHVuKClgIG1ldGhvZHMuIEl0J3MgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGZyYW1ld29ya1xuICAgICAqIHdoZW5ldmVyIHRoZSBgbGlzdGVuZXJzYCBjb25maWcgcHJvcGVydHkgaXMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIG5ldyBsaXN0ZW5lcnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlIFRoZSBvbGQgbGlzdGVuZXJzIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExpc3RlbmVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gVW5yZWdpc3RlciBhbnkgbGlzdGVuZXJzIGZyb20gdGhlIG9sZCBjb25maWcgb2JqZWN0XG4gICAgICAgIGlmIChvbGRWYWx1ZSAmJiBPYmplY3Qua2V5cyhvbGRWYWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy51bihvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpc3RlciBhbGwgbGlzdGVuZXJzIGZyb20gdGhlIG5ldyBjb25maWcgb2JqZWN0XG4gICAgICAgIGlmICh2YWx1ZSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5vbih2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIHBhc3NlZCBmdW5jdGlvbiwgb3IgYSBmdW5jdGlvbiBieSAqbmFtZSogd2hpY2ggZXhpc3RzIGluIHRoZSBwYXNzZWQgc2NvcGUnc1xuICAgICAqIG9yIHRoaXMgY29tcG9uZW50J3Mgb3duZXJzaGlwIGNoYWluLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBBIGZ1bmN0aW9uLCBvciB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRvIGZpbmQgaW4gdGhlIHBhc3NlZCBzY29wZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlICAgICAgIFRoZSBzY29wZSB0byBmaW5kIHRoZSBmdW5jdGlvbiBpbiBpZiBpdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAgICAgICAgIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBjYWxsYmFjayhmbiwgc2NvcGU9dGhpcywgYXJncykge1xuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSByZXNvbHZlQ2FsbGJhY2soZm4sIHNjb3BlKTtcbiAgICAgICAgICAgIGhhbmRsZXIuZm4uYXBwbHkoaGFuZGxlci5zY29wZSwgYXJncylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGhlbHBlciBtZXRob2QgZm9yIGV2ZW50cyB3aGljaCB1c2UgdGhlIGRlbGF5IG9wdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAgICAgKi9cbiAgICBkZWxheWVkQ2FsbGJhY2soY2IsIGFyZ3MsIGRlbGF5KSB7XG4gICAgICAgIHRoaXMudGltZW91dChkZWxheSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjYi5mbi5hcHBseShjYi5zY29wZSwgYXJncylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqL1xuICAgIGZpcmUobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFyZ3MgICAgICA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IG1lW2V2ZW50TWFwU3ltYm9sXSwgLy8gQWx3YXlzIHVzZSB0aGUgcHJpdmF0ZSwgc3RydWN0dXJlZCByZWdpc3RyeSBmb3IgZmlyaW5nIGV2ZW50cy5cbiAgICAgICAgICAgIGRlbGF5LCBoYW5kbGVyLCBoYW5kbGVycywgaSwgbGVuO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICBoYW5kbGVycyA9IFsuLi5saXN0ZW5lcnNbbmFtZV1dO1xuICAgICAgICAgICAgbGVuICAgICAgPSBoYW5kbGVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyc1tpXTtcbiAgICAgICAgICAgICAgICBkZWxheSAgID0gaGFuZGxlci5kZWxheTtcblxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgZnVuY3Rpb24gbmFtZSBvbiB0aGUgc2NvcGUgKG9yIG1lKSwgb3IsIGlmIGl0IHN0YXJ0cyB3aXRoICd1cC4nXG4gICAgICAgICAgICAgICAgLy8gbG9vayBpbiB0aGUgb3duZXJzaGlwIGhpZXJhcmNoeSBmcm9tIG1lLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gcmVzb2x2ZUNhbGxiYWNrKGhhbmRsZXIuZm4sIGhhbmRsZXIuc2NvcGUgfHwgbWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBpZiB0aGUgc2NvcGUgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChjYi5zY29wZSAmJiAhY2Iuc2NvcGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGxpc3RlbmVyc1tuYW1lXSwgaGFuZGxlcilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCBldmVudCBmb3JtYXQuIEluamVjdCBmaXJlciByZWZlcmVuY2UgaW4gYXMgJ3NvdXJjZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBOZW8uaXNPYmplY3QoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzBdLnNvdXJjZSA9IG1lLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGlzdGVuZXIgaWYgaXQgaGFzIHRoZSBvbmNlIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub25jZSAmJiBOZW9BcnJheS5yZW1vdmUobGlzdGVuZXJzW25hbWVdLCBoYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc051bWJlcihkZWxheSkgJiYgZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuZGVsYXllZENhbGxiYWNrKGNiLCBoYW5kbGVyLmRhdGEgPyBhcmdzLmNvbmNhdChoYW5kbGVyLmRhdGEpIDogYXJncywgZGVsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiLmZuLmFwcGx5KGNiLnNjb3BlLCBoYW5kbGVyLmRhdGEgPyBhcmdzLmNvbmNhdChoYW5kbGVyLmRhdGEpIDogYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBhZGRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcl1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBldmVudElkXG4gICAgICovXG4gICAgb24oLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lciguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGFyZSBkaWZmZXJlbnQgc3ludGF4J3MgaG93IHlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kLlxuICAgICAqIFVzaW5nIHRoZSBldmVudElkOlxuICAgICAqIGBgYFxuICAgICAqIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsICduZW8tZXZlbnQtNycpO1xuICAgICAqIGBgYFxuICAgICAqIFBhc3NpbmcgdGhlIGhhbmRsZXIgbWV0aG9kOlxuICAgICAqIGBgYFxuICAgICAqIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UsIHRoaXMpO1xuICAgICAqIGBgYFxuICAgICAqIFBhc3NpbmcgYW4gb2JqZWN0OlxuICAgICAqIGBgYFxuICAgICAqIG1lLmZpZWxkLnVuKHtcbiAgICAgKiAgICAgY2hhbmdlICAgICAgICAgICAgICAgICAgICA6IG1lLm9uRmllbGRDaGFuZ2UsXG4gICAgICogICAgIGNoYW5nZUNsZWFyVG9PcmlnaW5hbFZhbHVlOiBtZS5vbkZpZWxkQ2hhbmdlLFxuICAgICAqICAgICBzY29wZSAgICAgICAgICAgICAgICAgICAgIDogbWVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gW2V2ZW50SWRdXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBbc2NvcGVdXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRJZCwgc2NvcGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGksIGxlbiwgbGlzdGVuZXIsIGxpc3RlbmVycywgbWF0Y2g7XG5cbiAgICAgICAgLy8gTEFaWSBJTklUSUFMSVpBVElPTjogRW5zdXJlIHRoZSBpbnRlcm5hbCBsaXN0ZW5lciBzdG9yZSBleGlzdHMuXG4gICAgICAgIG1lW2V2ZW50TWFwU3ltYm9sXSA/Pz0ge307XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKGV2ZW50SWQpKSB7XG4gICAgICAgICAgICBtZS5yZW1vdmVMaXN0ZW5lcih7W25hbWVdOiBldmVudElkLCBzY29wZX0pO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5zY29wZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gbmFtZS5zY29wZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZS5zY29wZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobmFtZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbWVbZXZlbnRNYXBTeW1ib2xdW2tleV0gfHwgW107XG4gICAgICAgICAgICAgICAgaSAgICAgICAgID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gICAgICAgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5mbi5uYW1lID09PSAoTmVvLmlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlIDogdmFsdWUubmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLnNjb3BlICAgPT09IHNjb3BlXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKE5lby5pc1N0cmluZyhldmVudElkKSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gbWVbZXZlbnRNYXBTeW1ib2xdW25hbWVdO1xuICAgICAgICAgICAgbWF0Y2ggICAgID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChldmVudENvbmZpZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Q29uZmlnLmlkID09PSBldmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCA9IGlkeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2ggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShtYXRjaCwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciByZW1vdmVMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZXZlbnRJZF1cbiAgICAgKi9cbiAgICB1biguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoLi4uYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgb2JzZXJ2YWJsZSBzdGF0ZSBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSB7fSxcbiAgICAgICAgICAgIGV2ZW50TWFwICA9IG1lW2V2ZW50TWFwU3ltYm9sXTtcblxuICAgICAgICBpZiAoZXZlbnRNYXApIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGV2ZW50TWFwKS5mb3JFYWNoKChbZXZlbnROYW1lLCBoYW5kbGVyc10pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnROYW1lXSA9IGhhbmRsZXJzLm1hcChoYW5kbGVyID0+IG1lLnNlcmlhbGl6ZUNvbmZpZyhoYW5kbGVyKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgbGlzdGVuZXJzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE9ic2VydmFibGUpO1xuIiwiLyoqXG4gKiBAY2xhc3MgTmVvLmNvcmUuVXRpbFxuICovXG5jbGFzcyBVdGlsIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZ2V4IHRvIHJlbW92ZSBjYW1lbCBjYXNlIHN5bnRheFxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gZGVjYW1lbFJlZ0V4PS8oW2Etel0pKFtBLVpdKS9nXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjYW1lbFJlZ0V4ID0gLyhbYS16XSkoW0EtWl0pL2dcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlc1xuICAgICAqL1xuICAgIHN0YXRpYyBiaW5kTWV0aG9kcyhzY29wZSwgdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNjb3BlW3ZhbHVlXSA9IHNjb3BlW3ZhbHVlXS5iaW5kKHNjb3BlKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBzdHlsZXMgc3RyaW5nIGludG8gYSBzdHlsZXMgb2JqZWN0IHVzaW5nIGNhbWVsY2FzZSBzeW50YXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBzdHlsZXMgc3RyaW5nIHRvIHBhcnNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGNhbWVsY2FzZSBzdHlsZXMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0eWxlT2JqZWN0KHN0cmluZykge1xuICAgICAgICBsZXQgcGFydHM7XG5cbiAgICAgICAgLy8gc3BsaXQoJzsnKSBkb2VzIGZldGNoIHNlbWljb2xvbnMgaW5zaWRlIGJyYWNrZXRzXG4gICAgICAgIC8vIC0+IGJhY2tncm91bmQtaW1hZ2U6IFwidXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsLi4uXG5cbiAgICAgICAgLy8gVE9ETzogQ2FjaGUgYWxsIHJlZ2V4XG4gICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoLzsoPz1bXlxcKV0qKD86XFwofCQpKS9nKS5yZWR1Y2UoKG9iaiwgZWwpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gc3BsaXQgYnkgdGhlIGZpcnN0IGNvbG9uIG9ubHlcbiAgICAgICAgICAgIC8vIC0+IGJhY2tncm91bmQtaW1hZ2U6IHVybCgnaHR0cDovL2V4YW1wbGUuY29tL2ltYWdlLnBuZycpXG4gICAgICAgICAgICBwYXJ0cyA9IGVsLnNwbGl0KCgvOiguKykvKSkubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bSA9IHBhcnNlRmxvYXQoeCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geCA9PSBudW0gPyBudW0gOiB4LnRyaW0oKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0c1swXSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnJlcGxhY2UoLy0oW2Etel0pL2csIChzdHIsIGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG9ialtwYXJ0c1swXV0gPSBwYXJ0c1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9LCB7fSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0eWxlcyBvYmplY3Qgd2hpY2ggY2FuIHVzZSBjYW1lbGNhc2Ugc3ludGF4IGludG8gYSBzdHlsZXMgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBUaGUgc3R5bGVzIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHlsZXMgc3RyaW5nIChET00gcmVhZHkpXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gJyc7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3R5bGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgKz0gVXRpbC5kZWNhbWVsKGtleSkgKyAnOicgKyB2YWx1ZSArICc7J1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3R5bGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFsbCB1cHBlcmNhc2UgY2hhcmFjdGVycyBvZiBhIHN0cmluZyBpbnRvIC1sb3dlcmNhc2UuXG4gICAgICogRG9lcyBub3QgdG91Y2ggc3BlY2lhbCBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgaW5wdXQgY29udGFpbmluZyB1cHBlcmNhc2UgY2hhcmFjdGVyc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBsb3dlcmNhc2Ugb3V0cHV0XG4gICAgICovXG4gICAgc3RhdGljIGRlY2FtZWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoVXRpbC5kZWNhbWVsUmVnRXgsICckMS0kMicpLnRvTG93ZXJDYXNlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgYm9vbGVhblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0RlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBlbXB0eSBBcnJheSwgT2JqZWN0IG9yIFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVXRpbC5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIG51bWJlci4gUmV0dXJucyBmYWxzZSBmb3Igbm9uLWZpbml0ZSBudW1iZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzTnVtYmVyKHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdPYmplY3QnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBwcm9taXNlLlxuICAgICAqIFdlIGFyZSBpbnRlbnRpb25hbGx5IG5vdCBjaGVja2luZyBmb3IgYHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZWAsXG4gICAgICogdG8gc3VwcG9ydCBhbnkgXCJ0aGVuYWJsZVwiIG9iamVjdHMgZm9yIGZsZXhpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1Byb21pc2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZT8udGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgbmVvIGRhdGEgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzUmVjb3JkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdSZWNvcmQnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHNuYWtlX2Nhc2Ugc3RyaW5nIGludG8gY2FtZWxDYXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgc25ha2VfY2FzZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGNhbWVsQ2FzZSBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHNuYWtlVG9DYW1lbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKF9cXHcpL2csIG0gPT4gbVsxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbnkgaXRlcmFibGUgKHN0cmluZ3MsIG51bWVyaWMgaW5kaWNlcyBhbmQgYSBsZW5ndGggcHJvcGVydHkpIGludG8gYSB0cnVlIGFycmF5XG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpdGVyYWJsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZD1pdGVyYWJsZS5sZW5ndGhdIGVuZCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgdG9BcnJheShpdGVyYWJsZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBsZXQgbGVuO1xuXG4gICAgICAgIGlmICghaXRlcmFibGUgfHwgIShsZW4gPSBpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmFibGUuc3BsaXQoJycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXRlcmFibGUsIHN0YXJ0IHx8IDAsIGVuZCB8fCBsZW4pXG4gICAgfVxufVxuXG5jb25zdCBucyA9IE5lby5ucygnTmVvLmNvcmUnLCB0cnVlKTtcbm5zLlV0aWwgPSBVdGlsO1xuXG4vLyBhbGlhc2VzXG5OZW8uYXBwbHlGcm9tTnMoTmVvLCBVdGlsLCB7XG4gICAgYmluZE1ldGhvZHMgICAgICA6ICdiaW5kTWV0aG9kcycsXG4gICAgY3JlYXRlU3R5bGVPYmplY3Q6ICdjcmVhdGVTdHlsZU9iamVjdCcsXG4gICAgY3JlYXRlU3R5bGVzICAgICA6ICdjcmVhdGVTdHlsZXMnLFxuICAgIGRlY2FtZWwgICAgICAgICAgOiAnZGVjYW1lbCcsXG4gICAgaXNBcnJheSAgICAgICAgICA6ICdpc0FycmF5JyxcbiAgICBpc0Jvb2xlYW4gICAgICAgIDogJ2lzQm9vbGVhbicsXG4gICAgaXNEZWZpbmVkICAgICAgICA6ICdpc0RlZmluZWQnLFxuICAgIGlzRW1wdHkgICAgICAgICAgOiAnaXNFbXB0eScsXG4gICAgaXNGdW5jdGlvbiAgICAgICA6ICdpc0Z1bmN0aW9uJyxcbiAgICBpc051bWJlciAgICAgICAgIDogJ2lzTnVtYmVyJyxcbiAgICBpc09iamVjdCAgICAgICAgIDogJ2lzT2JqZWN0JyxcbiAgICBpc1Byb21pc2UgICAgICAgIDogJ2lzUHJvbWlzZScsXG4gICAgaXNSZWNvcmQgICAgICAgICA6ICdpc1JlY29yZCcsXG4gICAgaXNTdHJpbmcgICAgICAgICA6ICdpc1N0cmluZycsXG4gICAgc25ha2VUb0NhbWVsICAgICA6ICdzbmFrZVRvQ2FtZWwnLFxuICAgIHRvQXJyYXkgICAgICAgICAgOiAndG9BcnJheSdcbn0sIHRydWUpO1xuXG5leHBvcnQgZGVmYXVsdCBVdGlsO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBhcmUgICAgIGZyb20gJy4vQ29tcGFyZS5tanMnO1xuaW1wb3J0IElkR2VuZXJhdG9yIGZyb20gJy4vSWRHZW5lcmF0b3IubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICBmcm9tICcuL09ic2VydmFibGUubWpzJztcbmltcG9ydCBVdGlsICAgICAgICBmcm9tICcuL1V0aWwubWpzJztcblxuZXhwb3J0IHtCYXNlLCBDb21wYXJlLCBJZEdlbmVyYXRvciwgT2JzZXJ2YWJsZSwgVXRpbH07XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBEb21BY2Nlc3MgICAgICAgIGZyb20gJy4vRG9tQWNjZXNzLm1qcyc7XG5pbXBvcnQge3ZvaWRBdHRyaWJ1dGVzfSBmcm9tICcuLi92ZG9tL2RvbUNvbnN0YW50cy5tanMnO1xuXG5jb25zdCBOZW9Db25maWcgPSBOZW8uY29uZmlnO1xuXG4vKipcbiAqIE1hbmFnZXMgYW5kIGFwcGxpZXMgdGhlIFZpcnR1YWwgRE9NIChWRG9tKSBkZWx0YSB1cGRhdGVzIGdlbmVyYXRlZCBieSBgTmVvLnZkb20uSGVscGVyYCB0byB0aGUgcmVhbCBicm93c2VyIERPTS5cbiAqIFRoaXMgY2xhc3MgYWN0cyBhcyB0aGUgYnJpZGdlIGJldHdlZW4gdGhlIFZEb20gd29ya2VyJ3MgY2FsY3VsYXRlZCBjaGFuZ2VzIGFuZCB0aGUgYWN0dWFsIHJlbmRlcmluZyBvbiB0aGUgbWFpbiB0aHJlYWQuXG4gKiBJdCBvcmNoZXN0cmF0ZXMgdmFyaW91cyBET00gbWFuaXB1bGF0aW9uIG9wZXJhdGlvbnMgc3VjaCBhcyBub2RlIGluc2VydGlvbnMsIHJlbW92YWxzLCBtb3ZlcywgYXR0cmlidXRlIHVwZGF0ZXMsXG4gKiBhbmQgaGFuZGxlcyBkeW5hbWljIHJlbmRlcmVyIHN3aXRjaGluZyBiYXNlZCBvbiBgTmVvLmNvbmZpZy51c2VEb21BcGlSZW5kZXJlcmAuXG4gKlxuICogQXMgYSBzaW5nbGV0b24gcGVyIGJyb3dzZXIgd2luZG93LCBpdCBwcm92aWRlcyBhIGNlbnRyYWxpemVkIGFuZCBlZmZpY2llbnQgbWVjaGFuaXNtIGZvciBzeW5jaHJvbml6ZWQgRE9NIHVwZGF0ZXMsXG4gKiBlbnN1cmluZyB0aGUgVUkgYWNjdXJhdGVseSByZWZsZWN0cyB0aGUgYXBwbGljYXRpb24gc3RhdGUuXG4gKiBAY2xhc3MgTmVvLm1haW4uRGVsdGFVcGRhdGVzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIERlbHRhVXBkYXRlcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uRGVsdGFVcGRhdGVzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFpbi5EZWx0YVVwZGF0ZXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb3VudERlbHRhcz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvdW50RGVsdGFzOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb3VudERlbHRhc1BlcjI1MG1zPTBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY291bnREZWx0YXNQZXIyNTBtczogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY291bnRVcGRhdGVzPTBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY291bnRVcGRhdGVzOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyQ291bnREZWx0YXNfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJDb3VudERlbHRhc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbG9nRGVsdGFzSW50ZXJ2YWxJZD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGxvZ0RlbHRhc0ludGVydmFsSWQgPSAwXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQge2Vudmlyb25tZW50fSA9IE5lb0NvbmZpZztcblxuICAgICAgICBpZiAoTmVvQ29uZmlnLnJlbmRlckNvdW50RGVsdGFzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvdW50RGVsdGFzID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgbmVlZCBkaWZmZXJlbnQgcHVibGljUGF0aCB2YWx1ZXMgZm9yIHRoZSBtYWluIHRocmVhZCBpbnNpZGUgdGhlIHdlYnBhY2sgYmFzZWQgZGlzdCBlbnZzLFxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIGhpZXJhcmNoeSBsZXZlbCBvZiB0aGUgYXBwIGVudHJ5IHBvaW50XG4gICAgICAgIGlmIChlbnZpcm9ubWVudCA9PT0gJ2Rpc3QvZGV2ZWxvcG1lbnQnIHx8IGVudmlyb25tZW50ID09PSAnZGlzdC9wcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gTmVvQ29uZmlnLmJhc2VQYXRoLnN1YnN0cmluZyg2KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZW5kZXJDb3VudERlbHRhcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJlbmRlckNvdW50RGVsdGFzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtsb2dEZWx0YXNJbnRlcnZhbElkfSA9IG1lLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChsb2dEZWx0YXNJbnRlcnZhbElkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUubG9nRGVsdGFzSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZW8tZGVsdGEtdXBkYXRlcycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZyhtZS5jb3VudERlbHRhc1BlcjI1MG1zICogNClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1lLmNvdW50RGVsdGFzUGVyMjUwbXMgPSAwXG4gICAgICAgICAgICAgICAgfSwgMjUwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nRGVsdGFzSW50ZXJ2YWxJZCAmJiBjbGVhckludGVydmFsKGxvZ0RlbHRhc0ludGVydmFsSWQpO1xuICAgICAgICAgICAgbWUubG9nRGVsdGFzSW50ZXJ2YWwgPSAwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB0YWcgbmFtZSAobm9kZU5hbWUpIG9mIGFuIGV4aXN0aW5nIEhUTUxFbGVtZW50IGluIHRoZSBET00uXG4gICAgICogVGhpcyBvcGVyYXRpb24gaXMgcGVyZm9ybWVkIGJ5IGNyZWF0aW5nIGEgbmV3IEhUTUwgZWxlbWVudCB3aXRoIHRoZSBkZXNpcmVkIGBub2RlTmFtZWAsXG4gICAgICogbWV0aWN1bG91c2x5IGNvcHlpbmcgYWxsIGF0dHJpYnV0ZXMgYW5kIHRoZSBgaW5uZXJIVE1MYCBmcm9tIHRoZSBvcmlnaW5hbCBgbm9kZWAgdG8gdGhlIG5ldyBvbmUsXG4gICAgICogYW5kIHRoZW4gc2VhbWxlc3NseSByZXBsYWNpbmcgdGhlIG9yaWdpbmFsIGBub2RlYCB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlICAgICBUaGUgZXhpc3RpbmcgRE9NIEhUTUxFbGVtZW50IHdob3NlIHRhZyBuYW1lIG5lZWRzIHRvIGJlIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgbm9kZU5hbWUgVGhlIG5ldyB0YWcgbmFtZSAoZS5nLiwgJ2RpdicsICdzcGFuJywgJ3AnKSBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgY2hhbmdlTm9kZU5hbWUobm9kZSwgbm9kZU5hbWUpIHtcbiAgICAgICAgbGV0IHthdHRyaWJ1dGVzfSA9IG5vZGUsXG4gICAgICAgICAgICBjbG9uZSAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgPSBhdHRyaWJ1dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLm5vZGVOYW1lLCBhdHRyaWJ1dGUubm9kZVZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbG9uZS5pbm5lckhUTUw9IG5vZGUuaW5uZXJIVE1MO1xuXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNsb25lLCBub2RlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjaGVja1JlbmRlcmVyQXZhaWxhYmlsaXR5KCkge1xuICAgICAgICBjb25zdCB7cmVuZGVyfSA9IE5lby5tYWluO1xuXG4gICAgICAgIGlmIChOZW9Db25maWcudXNlRG9tQXBpUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGlmICghcmVuZGVyPy5Eb21BcGlSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVvLm1haW4uRGVsdGFVcGRhdGVzOiBEb21BcGlSZW5kZXJlciBpcyBub3QgbG9hZGVkIHlldCEnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyZW5kZXI/LlN0cmluZ0Jhc2VkUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lby5tYWluLkRlbHRhVXBkYXRlczogU3RyaW5nQmFzZWRSZW5kZXJlciBpcyBub3QgbG9hZGVkIHlldCEnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlbHRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbHRhLmlkXG4gICAgICovXG4gICAgZm9jdXNOb2RlKHtpZH0pIHtcbiAgICAgICAgRG9tQWNjZXNzLmdldEVsZW1lbnQoaWQpPy5mb2N1cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wb3J0cyBlaXRoZXIgKGlmIG5vdCBhbHJlYWR5IGltcG9ydGVkKTpcbiAgICAgKiBgTmVvLm1haW4ucmVuZGVyLkRvbUFwaVJlbmRlcmVyYCAgICAgIGlmIE5lby5jb25maWcudXNlRG9tQXBpUmVuZGVyZXIgPT09IHRydWVcbiAgICAgKiBgTmVvLm1haW4ucmVuZGVyLlN0cmluZ0Jhc2VkUmVuZGVyZXJgIGlmIE5lby5jb25maWcudXNlRG9tQXBpUmVuZGVyZXIgPT09IGZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGltcG9ydFJlbmRlcmVyKCkge1xuICAgICAgICBjb25zdCB7cmVuZGVyfSA9IE5lby5tYWluO1xuXG4gICAgICAgIGlmIChOZW9Db25maWcudXNlRG9tQXBpUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGlmICghcmVuZGVyPy5Eb21BcGlSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IGltcG9ydCgnLi9yZW5kZXIvRG9tQXBpUmVuZGVyZXIubWpzJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcmVuZGVyPy5TdHJpbmdCYXNlZFJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaW1wb3J0KCcuL3JlbmRlci9TdHJpbmdCYXNlZFJlbmRlcmVyLm1qcycpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBpbml0QXN5bmMoKSB7XG4gICAgICAgIHN1cGVyLmluaXRBc3luYygpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGdsb2JhbCBOZW8uY29uZmlnIGNoYW5nZXMgZm9yIGR5bmFtaWMgcmVuZGVyZXIgc3dpdGNoaW5nLlxuICAgICAgICBOZW8ud29ya2VyLk1hbmFnZXIub24oe1xuICAgICAgICAgICAgbmVvQ29uZmlnQ2hhbmdlOiBtZS5vbk5lb0NvbmZpZ0NoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUuaW1wb3J0UmVuZGVyZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBuZXcgbm9kZSBpbnRvIHRoZSBET00gdHJlZSBiYXNlZCBvbiBkZWx0YSB1cGRhdGVzLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgYm90aCBzdHJpbmctYmFzZWQgKG91dGVySFRNTCkgYW5kIGRpcmVjdCBET00gQVBJICh2bm9kZSkgbW91bnRpbmcuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgbm9kZSBpcyBpbnNlcnRlZCBhdCB0aGUgY29ycmVjdCBpbmRleCB3aXRoaW4gdGhlIHBhcmVudC5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzeW5jaHJvbm91cyBhbmQgKmV4cGVjdHMqIHRoZSBhcHByb3ByaWF0ZSByZW5kZXJlciAoRG9tQXBpUmVuZGVyZXIgb3IgU3RyaW5nQmFzZWRSZW5kZXJlcikgdG8gYmUgYWxyZWFkeSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkZWx0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRlbHRhLmhhc0xlYWRpbmdUZXh0Q2hpbGRyZW4gRmxhZyB0byBob25vciBsZWFkaW5nIGNvbW1lbnRzLCB3aGljaCByZXF1aXJlIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgIGRlbHRhLmluZGV4ICAgICAgICAgICAgICAgICAgVGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgbmV3IG5vZGUgd2l0aGluIGl0cyBwYXJlbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgW2RlbHRhLm91dGVySFRNTF0gICAgICAgICAgICBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBuZXcgbm9kZSAoZm9yIHN0cmluZy1iYXNlZCBtb3VudGluZykuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgZGVsdGEucGFyZW50SWQgICAgICAgICAgICAgICBUaGUgSUQgb2YgdGhlIHBhcmVudCBET00gbm9kZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSAgICAgICBbZGVsdGEucG9zdE1vdW50VXBkYXRlc10gICAgIEFycmF5IG9mIHBvc3QtbW91bnQgdXBkYXRlcyAoZS5nLiBzY3JvbGwgc3RhdGUpLlxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IFtkZWx0YS52bm9kZV0gICAgICAgICAgICAgICAgVGhlIFZOb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBuZXcgbm9kZSAoZm9yIGRpcmVjdCBET00gQVBJIG1vdW50aW5nKS5cbiAgICAgKi9cbiAgICBpbnNlcnROb2RlKHtoYXNMZWFkaW5nVGV4dENoaWxkcmVuLCBpbmRleCwgb3V0ZXJIVE1MLCBwYXJlbnRJZCwgcG9zdE1vdW50VXBkYXRlcywgdm5vZGV9KSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZW5kZXJlckF2YWlsYWJpbGl0eSgpO1xuXG4gICAgICAgIGxldCB7cmVuZGVyfSAgID0gTmVvLm1haW4sXG4gICAgICAgICAgICBwYXJlbnROb2RlID0gRG9tQWNjZXNzLmdldEVsZW1lbnRPckJvZHkocGFyZW50SWQpO1xuXG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAoTmVvQ29uZmlnLnVzZURvbUFwaVJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyLkRvbUFwaVJlbmRlcmVyLmNyZWF0ZURvbVRyZWUoe2luZGV4LCBpc1Jvb3Q6IHRydWUsIHBhcmVudE5vZGUsIHZub2RlfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyLlN0cmluZ0Jhc2VkUmVuZGVyZXIuaW5zZXJ0Tm9kZUFzU3RyaW5nKHtoYXNMZWFkaW5nVGV4dENoaWxkcmVuLCBpbmRleCwgb3V0ZXJIVE1MLCBwYXJlbnROb2RlLCBwb3N0TW91bnRVcGRhdGVzfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGV4aXN0aW5nIERPTSBub2RlIHRvIGEgbmV3IHBvc2l0aW9uIHdpdGhpbiBpdHMgcGFyZW50IG9yIHRvIGEgbmV3IHBhcmVudC5cbiAgICAgKiBUaGlzIG1ldGhvZCBkaXJlY3RseSBtYW5pcHVsYXRlcyB0aGUgRE9NIHVzaW5nIHRoZSBwcmUtY2FsY3VsYXRlZCBwaHlzaWNhbCBpbmRleCxcbiAgICAgKiBhY2NvdW50aW5nIGZvciBwb3RlbnRpYWwgdGV4dCBub2RlcyB3cmFwcGVkIGluIGNvbW1lbnRzLlxuICAgICAqIEl0IHBlcmZvcm1zIGEgZGlyZWN0IHNpYmxpbmcgc3dhcCB3aGVuIGFuIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgaXRzIHRhcmdldCBwb3NpdGlvbixcbiAgICAgKiB3aGljaCBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCBhdHRlbXB0aW5nIHRvIHJlcGxhY2UgYSBub2RlIHdpdGggaXRzZWxmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlbHRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbHRhLmlkICAgICAgIFRoZSBJRCBvZiB0aGUgRE9NIG5vZGUgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEuaW5kZXggICAgVGhlIHBoeXNpY2FsIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgbm9kZSB3aXRoaW4gdGhlIHRhcmdldCBwYXJlbnQncyBjaGlsZE5vZGVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWx0YS5wYXJlbnRJZCBUaGUgSUQgb2YgdGhlIHRhcmdldCBwYXJlbnQgRE9NIG5vZGUuXG4gICAgICovXG4gICAgbW92ZU5vZGUoe2lkLCBpbmRleCwgcGFyZW50SWR9KSB7XG4gICAgICAgIGxldCBub2RlICAgICAgID0gRG9tQWNjZXNzLmdldEVsZW1lbnQoaWQpLFxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IERvbUFjY2Vzcy5nZXRFbGVtZW50KHBhcmVudElkKTtcblxuICAgICAgICBpZiAobm9kZSAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGluZGV4IGlzIGF0IG9yIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQncyBjdXJyZW50IGNoaWxkTm9kZXMsIGFwcGVuZCB0aGUgbm9kZS5cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBwYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlZmVyZW5jZSBub2RlIGF0IHRoZSB0YXJnZXQgcGh5c2ljYWwgaW5kZXguXG4gICAgICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSBwYXJlbnROb2RlLmNoaWxkTm9kZXNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBwcm9jZWVkIGlmIHRoZSBub2RlIGlzIG5vdCBhbHJlYWR5IGF0IGl0cyB0YXJnZXQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHJlZmVyZW5jZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGRpcmVjdCBzd2FwIG9wZXJhdGlvbiBpZiBpbW1lZGlhdGUgZWxlbWVudCBzaWJsaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZSA9PT0gcmVmZXJlbmNlTm9kZS5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVwbGFjZVdpdGgocmVmZXJlbmNlTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZmVyZW5jZU5vZGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgZ2xvYmFsIE5lby5jb25maWcgY2hhbmdlcy5cbiAgICAgKiBJZiB0aGUgYE5lby5jb25maWcudXNlRG9tQXBpUmVuZGVyZXJgIHZhbHVlIGNoYW5nZXMsIHRoaXMgbWV0aG9kIGR5bmFtaWNhbGx5IGxvYWRzIHRoZSByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvbk5lb0NvbmZpZ0NoYW5nZShjb25maWcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oY29uZmlnLCAndXNlRG9tQXBpUmVuZGVyZXInKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbXBvcnRSZW5kZXJlcigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNoaWxkIG5vZGVzIG9mIGEgZ2l2ZW4gcGFyZW50IERPTSBub2RlLlxuICAgICAqIFRoaXMgaXMgYWNoaWV2ZWQgYnkgc2V0dGluZyBpdHMgYGlubmVySFRNTGAgcHJvcGVydHkgdG8gYW4gZW1wdHkgc3RyaW5nLFxuICAgICAqIHdoaWNoIGlzIGdlbmVyYWxseSBjb25zaWRlcmVkIHRoZSBmYXN0ZXN0IGFuZCBtb3N0IGVmZmljaWVudCB3YXkgdG8gcmVtb3ZlXG4gICAgICogYWxsIGNoaWxkcmVuIGZyb20gYSBET00gZWxlbWVudCBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEucGFyZW50SWQgVGhlIElEIG9mIHRoZSBwYXJlbnQgRE9NIG5vZGUgd2hvc2UgY2hpbGRyZW4gd2lsbCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbCh7cGFyZW50SWR9KSB7XG4gICAgICAgIGxldCBub2RlID0gRG9tQWNjZXNzLmdldEVsZW1lbnQocGFyZW50SWQpO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLmlubmVySFRNTCA9ICcnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgRE9NIG5vZGUgZnJvbSBpdHMgcGFyZW50LlxuICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgYm90aCBzdGFuZGFyZCBIVE1MIGVsZW1lbnRzIGFuZCB2aXJ0dWFsIHRleHQgbm9kZXMsXG4gICAgICogd2hpY2ggYXJlIHR5cGljYWxseSB3cmFwcGVkIHdpdGhpbiBjb21tZW50IG5vZGVzIGluIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEuaWQgICAgICAgVGhlIElEIG9mIHRoZSBET00gbm9kZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbHRhLnBhcmVudElkIFRoZSBJRCBvZiB0aGUgcGFyZW50IERPTSBub2RlIChyZXF1aXJlZCBmb3IgdGV4dCBub2RlIHJlbW92YWwpLlxuICAgICAqL1xuICAgIHJlbW92ZU5vZGUoe2lkLCBwYXJlbnRJZH0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IERvbUFjY2Vzcy5nZXRFbGVtZW50KGlkKTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3RlbnRpYWxseSBhIHZ0eXBlOiAndGV4dCcgbm9kZSAod3JhcHBlZCBiZXR3ZWVuIDIgY29tbWVudHMpXG4gICAgICAgIGVsc2UgaWYgKHBhcmVudElkKSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBEb21BY2Nlc3MuZ2V0RWxlbWVudE9yQm9keShwYXJlbnRJZCksXG4gICAgICAgICAgICAgICAgaXNDb21tZW50ICA9IE5vZGUuQ09NTUVOVF9OT0RFO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0YXJ0aW5nIGNvbW1lbnQgbm9kZSB1c2luZyBpdHMgaWQgbWFya2VyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRDb21tZW50ID0gQXJyYXkuZnJvbShwYXJlbnROb2RlLmNoaWxkTm9kZXMpLmZpbmQobiA9PlxuICAgICAgICAgICAgICAgICAgICBuLm5vZGVUeXBlID09PSBpc0NvbW1lbnQgJiYgbi5ub2RlVmFsdWUuaW5jbHVkZXMoYCAke2lkfSBgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZSA9IHN0YXJ0Q29tbWVudC5uZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBlbmRDb21tZW50IGlzIGEgY29tbWVudCBub2RlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29tbWVudCA9IHRleHROb2RlPy5uZXh0U2libGluZz8ubm9kZVR5cGUgPT09IGlzQ29tbWVudCA/IHRleHROb2RlLm5leHRTaWJsaW5nIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRocmVlIHBhcnRzOiBzdGFydCBjb21tZW50LCB0ZXh0IG5vZGUsIGVuZCBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29tbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGU/LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbmRDb21tZW50Py5yZW1vdmUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFuIGV4aXN0aW5nIGNoaWxkIERPTSBub2RlIChgZnJvbUlkYCkgd2l0aCBhIG5ldyBET00gbm9kZSAoYHRvSWRgKVxuICAgICAqIHdpdGhpbiBhIHNwZWNpZmllZCBwYXJlbnQgRE9NIG5vZGUgKGBwYXJlbnRJZGApLlxuICAgICAqIFRoaXMgb3BlcmF0aW9uIGRpcmVjdGx5IGludm9rZXMgdGhlIG5hdGl2ZSBgTm9kZS5yZXBsYWNlQ2hpbGQoKWAgQVBJLFxuICAgICAqIHBlcmZvcm1pbmcgYW4gYXRvbWljIHN3YXAgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBET00gdHJlZS5cbiAgICAgKiBJdCBpcyB0eXBpY2FsbHkgdXNlZCB3aGVuIGEgc3BlY2lmaWMgRE9NIGVsZW1lbnQgbmVlZHMgdG8gYmUgY29tcGxldGVseVxuICAgICAqIGV4Y2hhbmdlZCBmb3IgYSBkaWZmZXJlbnQgb25lIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlbHRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbHRhLmZyb21JZCAgIFRoZSBJRCBvZiB0aGUgZXhpc3RpbmcgY2hpbGQgRE9NIG5vZGUgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbHRhLnBhcmVudElkIFRoZSBJRCBvZiB0aGUgcGFyZW50IERPTSBub2RlIGNvbnRhaW5pbmcgdGhlIGNoaWxkIHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWx0YS50b0lkICAgICBUaGUgSUQgb2YgdGhlIG5ldyBET00gbm9kZSB0aGF0IHdpbGwgcmVwbGFjZSB0aGUgb2xkIG9uZS5cbiAgICAgKi9cbiAgICByZXBsYWNlQ2hpbGQoe2Zyb21JZCwgcGFyZW50SWQsIHRvSWR9KSB7XG4gICAgICAgIGxldCBub2RlID0gRG9tQWNjZXNzLmdldEVsZW1lbnQocGFyZW50SWQpO1xuXG4gICAgICAgIG5vZGU/LnJlcGxhY2VDaGlsZChEb21BY2Nlc3MuZ2V0RWxlbWVudCh0b0lkKSwgRG9tQWNjZXNzLmdldEVsZW1lbnQoZnJvbUlkKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHZhcmlvdXMgcHJvcGVydGllcyBvZiBhbiBleGlzdGluZyBET00gbm9kZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGVsdGEuXG4gICAgICogVGhpcyBpbmNsdWRlcyB1cGRhdGluZyBhdHRyaWJ1dGVzLCBjbGFzcyBuYW1lcywgaW5uZXIgSFRNTCwgbm9kZSBuYW1lLCBhbmQgaW5saW5lIHN0eWxlcy5cbiAgICAgKiBJdCBoYW5kbGVzIHNwZWNpZmljIGNhc2VzIGZvciBhdHRyaWJ1dGUgdHlwZXMgKGUuZy4sIGJvb2xlYW4gYXR0cmlidXRlcywgJ3ZhbHVlJylcbiAgICAgKiBhbmQgc3R5bGUgcHJvcGVydGllcyAoZS5nLiwgJyFpbXBvcnRhbnQnKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWx0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWx0YS5pZCAgICAgICAgICAgIFRoZSBJRCBvZiB0aGUgRE9NIG5vZGUgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVsdGEuYXR0cmlidXRlc10gIEFuIG9iamVjdCBjb250YWluaW5nIGF0dHJpYnV0ZSBrZXktdmFsdWUgcGFpcnMgdG8gdXBkYXRlIG9yIHJlbW92ZSAoaWYgdmFsdWUgaXMgbnVsbC9lbXB0eSkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkZWx0YS5jbHNdICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgJ2FkZCcgYW5kL29yICdyZW1vdmUnIGFycmF5cyBmb3IgQ1NTIGNsYXNzZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkZWx0YS5pbm5lckhUTUxdICAgVGhlIG5ldyBpbm5lciBIVE1MIGNvbnRlbnQgZm9yIHRoZSBub2RlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGVsdGEubm9kZU5hbWVdICAgIFRoZSBuZXcgdGFnIG5hbWUgZm9yIHRoZSBub2RlICh3aWxsIHRyaWdnZXIgYSBub2RlIHJlcGxhY2VtZW50KS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlbHRhLm91dGVySFRNTF0gICBUaGUgbmV3IG91dGVyIEhUTUwgY29udGVudCBmb3IgdGhlIG5vZGUgKHdpbGwgdHJpZ2dlciBhIG5vZGUgcmVwbGFjZW1lbnQpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVsdGEuc3R5bGVdICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIENTUyBzdHlsZSBwcm9wZXJ0aWVzIHRvIHVwZGF0ZS4gVmFsdWVzIGNhbiBpbmNsdWRlICchaW1wb3J0YW50Jy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlbHRhLnRleHRDb250ZW50XSBUaGUgbmV3IHRleHQgY29udGVudCBmb3IgdGhlIG5vZGUgKHJlcGxhY2VzIGlubmVySFRNTCBpZiBwcmVzZW50KS5cbiAgICAgKi9cbiAgICB1cGRhdGVOb2RlKGRlbHRhKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBEb21BY2Nlc3MuZ2V0RWxlbWVudE9yQm9keShkZWx0YS5pZCk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRlbHRhKS5mb3JFYWNoKChbcHJvcCwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodm9pZEF0dHJpYnV0ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtrZXldID0gdmFsID09PSAndHJ1ZScgLy8gdm5vZGUgYXR0cmlidXRlIHZhbHVlcyBnZXQgY29udmVydGVkIGludG8gc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtrZXldID0gJycgLy8gaW5wdXQgZmllbGRzID0+IHBzZXVkbyBhdHRyaWJ1dGUgY2FuIG5vdCBiZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlW05lb0NvbmZpZy51c2VEb21JZHMgPyAnaWQnIDogJ2RhdGEtbmVvLWlkJ10gPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NwZWxsY2hlY2snICYmIHZhbCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzE5MjJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtrZXldID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlW2tleV0gPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkICAgICYmIG5vZGUuY2xhc3NMaXN0LmFkZCguLi52YWx1ZS5hZGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVtb3ZlICYmIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSguLi52YWx1ZS5yZW1vdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5uZXJIVE1MJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gdmFsdWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdub2RlTmFtZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5jaGFuZ2VOb2RlTmFtZShub2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvdXRlckhUTUwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vdXRlckhUTUwgPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Njcm9sbExlZnQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzY3JvbGxUb3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1wb3J0YW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsKSAmJiB2YWwuaW5jbHVkZXMoJyFpbXBvcnRhbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoJyFpbXBvcnRhbnQnLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0YW50ID0gJ2ltcG9ydGFudCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoTmVvLmRlY2FtZWwoa2V5KSwgdmFsLCBpbXBvcnRhbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRDb250ZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRleHQgY29udGVudCBvZiBhIHZpcnR1YWwgdGV4dCBub2RlIHdpdGhpbiB0aGUgRE9NLlxuICAgICAqIFZpcnR1YWwgdGV4dCBub2RlcyBhcmUgcmVuZGVyZWQgd2l0aGluIHRoZSBET00gYXMgYSBwYWlyIG9mIEhUTUwgY29tbWVudHMsXG4gICAgICogd2l0aCB0aGVpciBjb250ZW50IGVtYmVkZGVkIGJldHdlZW4gdGhlbS4gVGhpcyBtZXRob2QgbG9jYXRlcyB0aGUgc3BlY2lmaWNcbiAgICAgKiB0ZXh0IG5vZGUgYnkgaXRzIElEIChlbWJlZGRlZCBpbiB0aGUgc3RhcnQgY29tbWVudCB0YWcpIHdpdGhpbiBpdHMgcGFyZW50J3NcbiAgICAgKiBpbm5lckhUTUwgYW5kIHJlcGxhY2VzIGl0cyBjb250ZW50IHVzaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlbHRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlbHRhLmlkICAgICAgIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHZpcnR1YWwgdGV4dCBub2RlLCB3aGljaCBpcyBlbWJlZGRlZCBpbiBpdHMgb3BlbmluZyBjb21tZW50IHRhZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsdGEucGFyZW50SWQgVGhlIElEIG9mIHRoZSBwYXJlbnQgRE9NIG5vZGUgd2hvc2UgYGlubmVySFRNTGAgY29udGFpbnMgdGhlIHZpcnR1YWwgdGV4dCBub2RlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWx0YS52YWx1ZSAgICBUaGUgbmV3IHRleHQgY29udGVudCB0byBiZSBhcHBsaWVkIHRvIHRoZSB2aXJ0dWFsIHRleHQgbm9kZS5cbiAgICAgKi9cbiAgICB1cGRhdGVWdGV4dCh7aWQsIHBhcmVudElkLCB2YWx1ZX0pIHtcbiAgICAgICAgbGV0IG5vZGUgICAgICA9IERvbUFjY2Vzcy5nZXRFbGVtZW50KHBhcmVudElkKSxcbiAgICAgICAgICAgIGlubmVySFRNTCA9IG5vZGUuaW5uZXJIVE1MLFxuICAgICAgICAgICAgc3RhcnRUYWcgID0gYDwhLS0gJHtpZH0gLS0+YCxcbiAgICAgICAgICAgIHJlZyAgICAgICA9IG5ldyBSZWdFeHAoc3RhcnRUYWcgKyAnW1xcXFxzXFxcXFNdKj88IS0tIFxcL25lby12dGV4dCAtLT4nKTtcblxuICAgICAgICBub2RlLmlubmVySFRNTCA9IGlubmVySFRNTC5yZXBsYWNlKHJlZywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIHNldCBvZiBWRG9tIGRlbHRhIHVwZGF0ZXMgdG8gdGhlIHJlYWwgRE9NLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSBjb3JlIGVudHJ5IHBvaW50IGZvciByZW5kZXJpbmcgY2hhbmdlcyBpbml0aWF0ZWQgZnJvbSB0aGUgVkRvbSB3b3JrZXIuXG4gICAgICogSXQgaXRlcmF0ZXMgdGhyb3VnaCB0aGUgcHJvdmlkZWQgZGVsdGFzIGFuZCBkaXNwYXRjaGVzIHRoZW0gdG8gc3BlY2lmaWMgRE9NIG1hbmlwdWxhdGlvblxuICAgICAqIG1ldGhvZHMgKGUuZy4sIGluc2VydE5vZGUsIHJlbW92ZU5vZGUsIHVwZGF0ZU5vZGUpIGJhc2VkIG9uIHRoZWlyIGBhY3Rpb25gIHByb3BlcnR5LlxuICAgICAqIFRoaXMgbWV0aG9kIGV4cGVjdHMgdGhlIGFwcHJvcHJpYXRlIHJlbmRlcmVyIChEb21BcGlSZW5kZXJlciBvciBTdHJpbmdCYXNlZFJlbmRlcmVyKVxuICAgICAqIHRvIGJlIGxvYWRlZCBiYXNlZCBvbiBgTmVvLmNvbmZpZy51c2VEb21BcGlSZW5kZXJlcmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSBkYXRhLmRlbHRhcyBBbiBhcnJheSBvZiBkZWx0YSBvYmplY3RzLCBvciBhIHNpbmdsZSBkZWx0YSBvYmplY3QsXG4gICAgICogcmVwcmVzZW50aW5nIGNoYW5nZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgRE9NLlxuICAgICAqIEVhY2ggZGVsdGEgb2JqZWN0IGNvbnRhaW5zIGFuIGBhY3Rpb25gIHByb3BlcnR5XG4gICAgICogKGUuZy4sICdpbnNlcnROb2RlJywgJ3JlbW92ZU5vZGUnLCAndXBkYXRlTm9kZScsICdtb3ZlTm9kZScpXG4gICAgICogYW5kIGFkZGl0aW9uYWwgcHJvcGVydGllcyByZWxldmFudCB0byB0aGUgc3BlY2lmaWMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkICAgICAgICAgICAgIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHJlcXVlc3QsIHVzZWQgZm9yIHNlbmRpbmcgYSByZXBseSBiYWNrIHRvIHRoZSBvcmlnaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLm9yaWdpbj0nYXBwJ10gVGhlIG9yaWdpbiBvZiB0aGUgbWVzc2FnZSAoZS5nLiwgJ2FwcCcpLCB1c2VkIGZvciBzZW5kaW5nIHJlcGxpZXMuXG4gICAgICovXG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlbmRlcmVyQXZhaWxhYmlsaXR5KCk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkZWx0YXN9ID0gZGF0YSxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbjtcblxuICAgICAgICBkZWx0YXMgPSBBcnJheS5pc0FycmF5KGRlbHRhcykgPyBkZWx0YXMgOiBbZGVsdGFzXTtcbiAgICAgICAgbGVuICAgID0gZGVsdGFzLmxlbmd0aDtcblxuICAgICAgICBpZiAoTmVvQ29uZmlnLmxvZ0RlbHRhVXBkYXRlcyAmJiBsZW4gPiAwKSB7XG4gICAgICAgICAgICBtZS5jb3VudERlbHRhcyArPSBsZW47XG4gICAgICAgICAgICBtZS5jb3VudFVwZGF0ZXMrKztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1cGRhdGUgJyArIG1lLmNvdW50VXBkYXRlcywgJ3RvdGFsIGRlbHRhcyAnLCBtZS5jb3VudERlbHRhcywgTmVvLmNsb25lKGRhdGEsIHRydWUpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lb0NvbmZpZy5yZW5kZXJDb3VudERlbHRhcyAmJiBsZW4gPiAwKSB7XG4gICAgICAgICAgICBtZS5jb3VudERlbHRhc1BlcjI1MG1zICs9IGxlblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbWVbZGVsdGFzW2ldLmFjdGlvbiB8fCAndXBkYXRlTm9kZSddKGRlbHRhc1tpXSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRGVsdGFVcGRhdGVzKTtcbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IERvbVV0aWxzICAgZnJvbSAnLi9Eb21VdGlscy5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSAgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcbmltcG9ydCBTdHJpbmdVdGlsIGZyb20gJy4uL3V0aWwvU3RyaW5nLm1qcyc7XG5cbmNvbnN0XG4gICAgZG9QcmV2ZW50RGVmYXVsdCA9IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICAgIGZpbHRlclRhYmJhYmxlICAgPSBlID0+ICFlLmNsYXNzTGlzdC5jb250YWlucygnbmVvLWZvY3VzLXRyYXAnKSAmJiBEb21VdGlscy5pc1RhYmJhYmxlKGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCxcbiAgICBsZW5ndGhSRSAgICAgICAgID0gL15cXGQrXFx3KyQvLFxuXG4gICAgY2FwdHVyZVBhc3NpdmUgPSB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9LFxuXG4gICAgZm9udFNpemVQcm9wcyA9IFtcbiAgICAgICAgJ2ZvbnQtZmFtaWx5JyxcbiAgICAgICAgJ2ZvbnQta2VybmluZycsXG4gICAgICAgICdmb250LXNpemUnLFxuICAgICAgICAnZm9udC1zaXplLWFkanVzdCcsXG4gICAgICAgICdmb250LXN0cmV0Y2gnLFxuICAgICAgICAnZm9udC1zdHlsZScsXG4gICAgICAgICdmb250LXdlaWdodCcsXG4gICAgICAgICdsZXR0ZXItc3BhY2luZycsXG4gICAgICAgICdsaW5lLWhlaWdodCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICAndGV4dC10cmFuc2Zvcm0nLFxuICAgICAgICAnd29yZC1icmVhaydcbiAgICBdLFxuXG4gICAgbW9kaWZpZXJLZXlzID0ge1xuICAgICAgICBTaGlmdCAgIDogMSxcbiAgICAgICAgQWx0ICAgICA6IDEsXG4gICAgICAgIE1ldGEgICAgOiAxLFxuICAgICAgICBDb250cm9sIDogMVxuICAgIH07XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYWluLkRvbUFjY2Vzc1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBEb21BY2Nlc3MgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5Eb21BY2Nlc3MnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLkRvbUFjY2VzcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgd29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgIGFwcDogW1xuICAgICAgICAgICAgICAgICdhZGRTY3JpcHQnLFxuICAgICAgICAgICAgICAgICdhbGlnbicsXG4gICAgICAgICAgICAgICAgJ2FwcGx5Qm9keUNscycsXG4gICAgICAgICAgICAgICAgJ2JsdXInLFxuICAgICAgICAgICAgICAgICdleGVjQ29tbWFuZCcsXG4gICAgICAgICAgICAgICAgJ2ZvY3VzJyxcbiAgICAgICAgICAgICAgICAnZ2V0QXR0cmlidXRlcycsXG4gICAgICAgICAgICAgICAgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCcsXG4gICAgICAgICAgICAgICAgJ2dldENvbXB1dGVkU3R5bGUnLFxuICAgICAgICAgICAgICAgICdnZXRPZmZzY3JlZW5DYW52YXMnLFxuICAgICAgICAgICAgICAgICdnZXRTY3JvbGxpbmdEaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAnbWVhc3VyZScsXG4gICAgICAgICAgICAgICAgJ21vbml0b3JBdXRvR3JvdycsXG4gICAgICAgICAgICAgICAgJ21vbml0b3JBdXRvR3Jvd0hhbmRsZXInLFxuICAgICAgICAgICAgICAgICdzY3JvbGxCeScsXG4gICAgICAgICAgICAgICAgJ3Njcm9sbEludG9WaWV3JyxcbiAgICAgICAgICAgICAgICAnc2Nyb2xsVG8nLFxuICAgICAgICAgICAgICAgICdzY3JvbGxUb1RhYmxlUm93JyxcbiAgICAgICAgICAgICAgICAnc2VsZWN0Tm9kZScsXG4gICAgICAgICAgICAgICAgJ3NldEJvZHlDbHMnLFxuICAgICAgICAgICAgICAgICdzZXRTdHlsZScsXG4gICAgICAgICAgICAgICAgJ3N5bmNNb2RhbE1hc2snLFxuICAgICAgICAgICAgICAgICd0cmFwRm9jdXMnLFxuICAgICAgICAgICAgICAgICd3aW5kb3dTY3JvbGxUbydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgbW9kYWxNYXNrKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuX21vZGFsTWFzaykge1xuICAgICAgICAgICAgbWUuX21vZGFsTWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWUuX21vZGFsTWFzay5jbGFzc05hbWUgPSAnbmVvLWRpYWxvZy1tb2RhbC1tYXNrJztcbiAgICAgICAgICAgIG1lLl9tb2RhbE1hc2suYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZG9QcmV2ZW50RGVmYXVsdCwge2NhcHR1cmUgOiB0cnVlfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5fbW9kYWxNYXNrXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pbml0R2xvYmFsTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgLy8gU2V0IHVwIG91ciBhbGlnbmluZyBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGluZ3MgY2hhbmdlIHdoaWNoIG1heVxuICAgICAgICAvLyBtZWFuIHRoYXQgYWxpZ25tZW50cyBuZWVkIHRvIGJlIHVwZGF0ZWQuXG4gICAgICAgIG1lLnN5bmNBbGlnbnMgPSBtZS5zeW5jQWxpZ25zLmJpbmQobWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFsaWduU3BlY1xuICAgICAqL1xuICAgIGFkZEFsaWduZWQoYWxpZ25TcGVjKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aWR9ICAgICAgICAgICAgICAgICA9IGFsaWduU3BlYyxcbiAgICAgICAgICAgIGFsaWducyAgICAgICAgICAgICAgID0gbWUuX2FsaWducyB8fCAobWUuX2FsaWducyA9IG5ldyBNYXAoKSksXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlciAgICAgICA9IG1lLl9hbGlnblJlc2l6ZU9ic2VydmVyIHx8IChtZS5fYWxpZ25SZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihtZS5zeW5jQWxpZ25zKSksXG4gICAgICAgICAgICB7Y29uc3RyYWluVG9FbGVtZW50fSA9IGFsaWduU3BlYztcblxuICAgICAgICAvLyBTZXQgdXAgbGlzdGVuZXJzIHdoaWNoIG1vbml0b3IgZm9yIGNoYW5nZXNcbiAgICAgICAgaWYgKCFhbGlnbnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgLy8gUmVhbGlnbiB3aGVuIHRhcmdldCdzIGxheW91dC1jb250cm9sbGluZyBlbGVtZW50IGNoYW5nZXMgc2l6ZVxuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShhbGlnblNwZWMub2Zmc2V0UGFyZW50KTtcblxuICAgICAgICAgICAgLy8gUmVhbGlnbiB3aGVuIGFsaWduIHRvIHRhcmdldCBjaGFuZ2VzIHNpemVcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoYWxpZ25TcGVjLnRhcmdldEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBSZWFsaWduIHdoZW4gY29uc3RyYWluaW5nIGVsZW1lbnQgY2hhbmdlcyBzaXplXG4gICAgICAgICAgICBpZiAoY29uc3RyYWluVG9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb25zdHJhaW5Ub0VsZW1lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLmhhc0RvY3VtZW50U2Nyb2xsTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG1lLnN5bmNBbGlnbnMsIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5oYXNEb2N1bWVudFNjcm9sbExpc3RlbmVyID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5kb2N1bWVudE11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIG1lLmRvY3VtZW50TXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG1lLm9uRG9jdW1lbnRNdXRhdGlvbi5iaW5kKG1lKSk7XG5cbiAgICAgICAgICAgIG1lLmRvY3VtZW50TXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHtcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VidHJlZSAgOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgYWxpZ25zLnNldChpZCwgYWxpZ25TcGVjKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLmFzeW5jXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS5kZWZlcj1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEuc3JjPXRydWVdXG4gICAgICovXG4gICAgYWRkU2NyaXB0KGRhdGEpIHtcbiAgICAgICAgbGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eSgnYXN5bmMnKSkge1xuICAgICAgICAgICAgZGF0YS5hc3luYyA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2NyaXB0LCBkYXRhKTtcblxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGFsaWduKGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbnN0cmFpblRvfSA9IGRhdGEsXG4gICAgICAgICAgICBzdWJqZWN0ICAgICAgID0gZGF0YS5zdWJqZWN0ID0gbWUuZ2V0RWxlbWVudChkYXRhLmlkKSxcbiAgICAgICAgICAgIHtzdHlsZX0gICAgICAgPSBzdWJqZWN0LFxuICAgICAgICAgICAgYWxpZ24gICAgICAgICA9IHsuLi5kYXRhfSxcbiAgICAgICAgICAgIGxhc3RBbGlnbiAgICAgPSBtZS5fYWxpZ25zPy5nZXQoZGF0YS5pZCk7XG5cbiAgICAgICAgaWYgKGxhc3RBbGlnbikge1xuICAgICAgICAgICAgc3ViamVjdC5jbGFzc0xpc3QucmVtb3ZlKGBuZW8tYWxpZ25lZC0ke2xhc3RBbGlnbi5yZXN1bHQucG9zaXRpb259YClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbGVhc2UgYW55IGNvbnN0cmFpblRvIG9yIG1hdGNoU2l6ZSBzaXppbmcgd2hpY2ggbWF5IGhhdmUgYmVlbiBpbXBvc2VkXG4gICAgICAgIC8vIGJ5IGEgcHJldmlvdXMgYWxpZ24gY2FsbC5cbiAgICAgICAgbWUucmVzZXREaW1lbnNpb25zKGFsaWduKTtcblxuICAgICAgICAvLyBUaGUgUmVjdGFuZ2xlJ3MgYWxpZ24gc3BlYyB0YXJnZXQgYW5kIGNvbnN0cmFpblRvIG11c3QgYmUgUmVjdGFuZ2xlc1xuICAgICAgICBhbGlnbi50YXJnZXQgPSBtZS5nZXRDbGlwcGVkUmVjdCh7aWQgOiBkYXRhLnRhcmdldEVsZW1lbnQgPSBtZS5nZXRFbGVtZW50T3JCb2R5KGRhdGEudGFyZ2V0KX0pO1xuXG4gICAgICAgIGlmICghYWxpZ24udGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIENvbXBvbmVudCB3aXRoIGlkIGRhdGEuaWQgdG8gaGlkZGVuIDogdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIE5lby53b3JrZXIuQXBwLnNldENvbmZpZ3Moe2lkOiBkYXRhLmlkLCBoaWRkZW46IHRydWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5vZmZzZXRQYXJlbnQgPSBkYXRhLnRhcmdldEVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gICAgICAgIGlmIChjb25zdHJhaW5Ubykge1xuICAgICAgICAgICAgYWxpZ24uY29uc3RyYWluVG8gPSBtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3Qoe2lkIDogZGF0YS5jb25zdHJhaW5Ub0VsZW1lbnQgPSBtZS5nZXRFbGVtZW50T3JCb2R5KGNvbnN0cmFpblRvKX0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYW4gYWxpZ25lZCBjbG9uZSBvZiBteVJlY3QgYWxpZ25lZCBhY2NvcmRpbmcgdG8gdGhlIGFsaWduIG9iamVjdFxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbXlSZWN0ID0gbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGRhdGEpLFxuICAgICAgICAgICAgcmVzdWx0ID0gZGF0YS5yZXN1bHQgPSBteVJlY3QuYWxpZ25UbyhhbGlnbik7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgICAgdG9wICAgICAgIDogMCxcbiAgICAgICAgICAgIGxlZnQgICAgICA6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm0gOiBgdHJhbnNsYXRlKCR7cmVzdWx0Lnh9cHgsJHtyZXN1bHQueX1weClgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQud2lkdGggIT09IG15UmVjdC53aWR0aCkge1xuICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHtyZXN1bHQud2lkdGh9cHhgXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmhlaWdodCAhPT0gbXlSZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7cmVzdWx0LmhlaWdodH1weGBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBsYWNlIGJveCBzaGFkb3cgYXQgY29ycmVjdCBlZGdlXG4gICAgICAgIHN1YmplY3QuY2xhc3NMaXN0LmFkZChgbmVvLWFsaWduZWQtJHtyZXN1bHQucG9zaXRpb259YCk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgYW4gYWxpZ25tZW50IHRvIGJlIGtlcHQgaW4gc3luY1xuICAgICAgICBtZS5hZGRBbGlnbmVkKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBkYXRhLmNsc1xuICAgICAqL1xuICAgIGFwcGx5Qm9keUNscyhkYXRhKSB7XG4gICAgICAgIGxldCBjbHMgPSBkYXRhLmNscyB8fCBbXTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKC4uLmNscylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBibHVyKCkgb24gYSBub2RlIGZvciBhIGdpdmVuIGRvbSBub2RlIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmouaWQgPT4gdGhlIHBhc3NlZCBpZFxuICAgICAqL1xuICAgIGJsdXIoZGF0YSkge1xuICAgICAgICB0aGlzLmdldEVsZW1lbnQoZGF0YS5pZCk/LmJsdXIoKTtcbiAgICAgICAgcmV0dXJuIHtpZDogZGF0YS5pZH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmNvbW1hbmRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZXhlY0NvbW1hbmQoZGF0YSkge1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZChkYXRhLmNvbW1hbmQpO1xuICAgICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGZvY3VzKCkgb24gYSBub2RlIGZvciBhIGdpdmVuIGRvbSBub2RlIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuY2hpbGRyZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9iai5pZCA9PiB0aGUgcGFzc2VkIGlkXG4gICAgICovXG4gICAgZm9jdXMoe2NoaWxkcmVuLCBpZH0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmdldEVsZW1lbnQoaWQpO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAvLyBUaGUgY2hpbGRyZW4gcHJvcGVydHkgbWVhbnMgZm9jdXMgaW5uZXIgZWxlbWVudHMgaWYgcG9zc2libGUuXG4gICAgICAgICAgICBpZiAoIURvbVV0aWxzLmlzRm9jdXNhYmxlKG5vZGUpICYmIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gcXVlcnkgZm9yIHRoZSBmaXJzdCBmb2N1c2FibGUgZGVzY2VuZGVudFxuICAgICAgICAgICAgICAgIG5vZGUgPSBEb21VdGlscy5xdWVyeShub2RlLCBEb21VdGlscy5pc0ZvY3VzYWJsZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmZvY3VzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKG5vZGUuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2VsZWN0aW9uU3RhcnQgPSBub2RlLnNlbGVjdGlvbkVuZCA9IG5vZGUudmFsdWUubGVuZ3RoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtpZH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIGZvciBhIGdpdmVuIGRvbSBub2RlIGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gZGF0YS5hdHRyaWJ1dGVzIGVpdGhlciBhbiBhdHRyaWJ1dGUgb3IgYW4gYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBkYXRhLmlkIGVpdGhlciBhbiBpZCBvciBhbiBhcnJheSBvZiBpZHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBJbiBjYXNlIGlkIGlzIGFuIGFycmF5LCBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgb2JqZWN0cyBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIGFuIG9iamVjdFxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZXMoe2F0dHJpYnV0ZXMsIGlkfSkge1xuICAgICAgICBsZXQgcmV0dXJuRGF0YTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgICAgICAgIHJldHVybkRhdGEgPSBbXTtcblxuICAgICAgICAgICAgaWQuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuRGF0YS5wdXNoKHRoaXMuZ2V0QXR0cmlidXRlcyh7YXR0cmlidXRlcywgaWR9KSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0RWxlbWVudE9yQm9keShpZCk7XG5cbiAgICAgICAgICAgIHJldHVybkRhdGEgPSB7fTtcblxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IFthdHRyaWJ1dGVzXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5EYXRhW2F0dHJpYnV0ZV0gPSBub2RlW2F0dHJpYnV0ZV1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVybkRhdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgZm9yIGEgZ2l2ZW4gZG9tIG5vZGUgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBkYXRhLmlkIGVpdGhlciBhbiBpZCBvciBhbiBhcnJheSBvZiBpZHNcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdHxET01SZWN0W119IEluIGNhc2UgaWQgaXMgYW4gYXJyYXksIGFuIGFycmF5IG9mIERvbVJlY3RzIGlzIHJldHVybmVkLCBvdGhlcndpc2UgYW4gRG9tUmVjdCBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmV0dXJuRGF0YTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuaWQubWFwKGlkID0+IG1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7aWR9KSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gbWUuZ2V0RWxlbWVudE9yQm9keShkYXRhLm5vZGVUeXBlID8gZGF0YSA6IGRhdGEuaWQpLFxuICAgICAgICAgICAgICAgIHJlY3QgPSB7fSxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCwgbWluSGVpZ2h0LCBzdHlsZTtcblxuICAgICAgICAgICAgcmV0dXJuRGF0YSA9IHt9O1xuXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJlY3QgICAgICA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgc3R5bGUgICAgID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWluLXdpZHRoJyk7XG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWluLWhlaWdodCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9tUmVjdCBkb2VzIG5vdCBzdXBwb3J0IHNwcmVhZGluZyA9PiB7Li4uRG9tUmVjdH0gPT4ge31cbiAgICAgICAgICAgICAgICByZXR1cm5EYXRhID0gUmVjdGFuZ2xlLmNsb25lKHJlY3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWVhc3VyZSBtaW5XaWR0aC9taW5IZWlnaHQgaW4gb3RoZXIgdW5pdHMgbGlrZSBlbS9yZW0gZXRjXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IDBweCBpcyB3aGF0IHRoZSBET00gcmVwb3J0cyBpZiBubyBtaW5XaWR0aCBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkbyBub3QgcmVwb3J0IGEgbWluaW11bSBpbiB0aGVzZSBjYXNlcy5cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoUkUudGVzdChtaW5XaWR0aCkgJiYgbWluV2lkdGggIT09ICcwcHgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEubWluV2lkdGggPSBtZS5tZWFzdXJlKHt2YWx1ZTogbWluV2lkdGgsIGlkOiBub2RlfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aFJFLnRlc3QobWluSGVpZ2h0KSAmJiBtaW5IZWlnaHQgIT09ICcwcHgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkRhdGEubWluSGVpZ2h0ID0gbWUubWVhc3VyZSh7dmFsdWU6IG1pbkhlaWdodCwgaWQ6IG5vZGV9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5EYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhXG4gICAgICogQHJldHVybnMge05lby51dGlsLlJlY3RhbmdsZX1cbiAgICAgKi9cbiAgICBnZXRDbGlwcGVkUmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgICAgICAgICAgPSBtZS5nZXRFbGVtZW50KHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEuaWQgOiBkYXRhKSxcbiAgICAgICAgICAgIHtkZWZhdWx0Vmlld30gPSBub2RlLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICByZWN0ICAgICAgICAgID0gbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG5vZGUpO1xuXG4gICAgICAgIGZvciAobGV0IHBhcmVudEVsZW1lbnQgPSBub2RlLm9mZnNldFBhcmVudDsgcGFyZW50RWxlbWVudCAmJiByZWN0ICYmIHBhcmVudEVsZW1lbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsgcGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocGFyZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QuaW50ZXJzZWN0cyh0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnRFbGVtZW50KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBkYXRhLnN0eWxlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFN0eWxlKHtpZCwgc3R5bGV9KSB7XG4gICAgICAgIGxldCBub2RlICAgPSB0aGlzLmdldEVsZW1lbnQoaWQpLFxuICAgICAgICAgICAgc3R5bGVzID0ge307XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IFtzdHlsZV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGUuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgICAgICBzdHlsZXNbcHJvcF0gPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8V2luZG93fERvY3VtZW50fSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8V2luZG93fERvY3VtZW50fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldEVsZW1lbnQobm9kZUlkKSB7XG4gICAgICAgIGlmIChub2RlSWQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGVJZCA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZUlkID09PSAnZG9jdW1lbnQuYm9keScgfHwgbm9kZUlkID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZSA9IG5vZGVJZD8ubm9kZVR5cGUgP1xuICAgICAgICAgICAgbm9kZUlkIDogTmVvLmNvbmZpZy51c2VEb21JZHMgP1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGVJZCkgOlxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLW5lby1pZD0nJHtub2RlSWR9J11gKTtcblxuICAgICAgICByZXR1cm4gbm9kZSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IG5vZGVJZD0nZG9jdW1lbnQuYm9keSdcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0RWxlbWVudE9yQm9keShub2RlSWQ9J2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudChub2RlSWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gZGF0YS5pZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0U2Nyb2xsaW5nRGltZW5zaW9ucyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS5pZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmlkLm1hcChpZCA9PiBtZS5nZXRTY3JvbGxpbmdEaW1lbnNpb25zKHtpZH0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBkYXRhLm5vZGVUeXBlID8gZGF0YSA6IG1lLmdldEVsZW1lbnRPckJvZHkoZGF0YS5pZCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBub2RlPy5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgY2xpZW50V2lkdGggOiBub2RlPy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQ6IG5vZGU/LnNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgICBzY3JvbGxXaWR0aCA6IG5vZGU/LnNjcm9sbFdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRHbG9iYWxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICAgICAgbWUub25Eb2N1bWVudEJsdXIgICAgIC5iaW5kKG1lKSwgY2FwdHVyZVBhc3NpdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgICBtZS5vbkRvY3VtZW50S2V5RG93biAgLmJpbmQobWUpLCBjYXB0dXJlUGFzc2l2ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgICAgIG1lLm9uRG9jdW1lbnRLZXlVcCAgICAuYmluZChtZSksIGNhcHR1cmVQYXNzaXZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbWUub25Eb2N1bWVudE1vdXNlRG93bi5iaW5kKG1lKSwge2NhcHR1cmUgOiB0cnVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzQWxpZ25TdWJqZWN0KGVsKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fYWxpZ25zPy52YWx1ZXMoKV0uc29tZShhbGlnbiA9PiBhbGlnbi5zdWJqZWN0ID09PSBlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNsdWRlIGEgc2NyaXB0IGludG8gdGhlIGRvY3VtZW50LmhlYWRcbiAgICAgKiBZb3UgY2FuIGFkZCBtb3JlIGF0dHJpYnV0ZXMgaWYgbmVlZGVkLiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e2RlZmVyOnRydWV9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5hc3luY11cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRzLmRlZmVyXVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd24+fVxuICAgICAqL1xuICAgIGxvYWRTY3JpcHQoc3JjLCBvcHRzPXtkZWZlcjp0cnVlfSkge1xuICAgICAgICBsZXQgc2NyaXB0O1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY3JpcHQsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgICAgIG9uZXJyb3I6IHJlamVjdCxcbiAgICAgICAgICAgICAgICBvbmxvYWQgOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluY2x1ZGUgYSBsaW5rIGludG8gdGhlIGRvY3VtZW50LmhlYWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHJlZlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhc2V0PW51bGxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAgICAgKi9cbiAgICBsb2FkU3R5bGVzaGVldChocmVmLCBkYXRhc2V0PW51bGwpIHtcbiAgICAgICAgbGV0IGxpbms7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obGluaywge1xuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgb25lcnJvcjogcmVqZWN0LFxuICAgICAgICAgICAgICAgIG9ubG9hZCA6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVsICAgIDogJ3N0eWxlc2hlZXQnLFxuICAgICAgICAgICAgICAgIHR5cGUgICA6ICd0ZXh0L2NzcydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZGF0YXNldCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obGluay5kYXRhc2V0LCBkYXRhc2V0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZGF0YS52YWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICAgICAqL1xuICAgIG1lYXN1cmUoeyB2YWx1ZSwgaWQgfSkge1xuICAgICAgICBjb25zdCBub2RlID0gaWQubm9kZVR5cGUgPT09IDEgPyBpZCA6IHRoaXMuZ2V0RWxlbWVudChpZCk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uID0gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDA7XG5cbiAgICAgICAgICAgIHJldHVybiAobm9kZS5vZmZzZXRQYXJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCB8fCAwKSAqIGZyYWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQncyBhbnkgb3RoZXIgQ1NTIHVuaXQgdGhhbiBweCwgaXQgbmVlZHMgdG8gYmUgbWVhc3VyZWQgdXNpbmcgdGhlIERPTVxuICAgICAgICBlbHNlIGlmIChpc05hTih2YWx1ZSkgJiYgIXZhbHVlLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgICAgICBjb25zdCBlbFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICAgICAgICAgIGxldCBkID0gdGhpcy5fbWVhc3VyaW5nRGl2O1xuXG4gICAgICAgICAgICBpZiAoIWQpIHtcbiAgICAgICAgICAgICAgICBkID0gdGhpcy5fbWVhc3VyaW5nRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZC5zdHlsZSA9ICdwb3NpdGlvbjpmaXhlZDt0b3A6LTEwMDAwcHg7bGVmdDotMTAwMDBweCdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW4gY2FzZSBhIERPTSB1cGRhdGUgY2xlYXJlZCBpdCBvdXRcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBhbGwgdGhlIGZvbnQtc2l6ZSwgZm9udC13ZWlnaHQgZXRjIHN0eWxlIHByb3BlcnRpZXMgc28gdGhhdFxuICAgICAgICAgICAgLy8gZW0vZXgvcmVtIGV0YyB1bml0cyB3aWxsIG1hdGNoXG4gICAgICAgICAgICBmb250U2l6ZVByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICAgICAgZC5zdHlsZVtwcm9wXSA9IGVsU3R5bGVbcHJvcF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQuY2xhc3NOYW1lID0gbm9kZS5jbGFzc05hbWU7XG4gICAgICAgICAgICBkLnN0eWxlLndpZHRoID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgYmFjayB0aGUgcmVzdWx0aW5nIGNvbXB1dGVkIHBpeGVsIHdpZHRoXG4gICAgICAgICAgICB2YWx1ZSA9IGVsU3R5bGUud2lkdGg7XG5cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpdCdzIGEgbnVtYmVyLCBvciBlbmRzIHdpdGggcHgsIHVzZSB0aGUgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIG92ZXJmbG93IHN0YXR1cyBvZiBhIFRleHRBcmVhRmllbGQncyAmbHQ7dGV4dGFyZWE+IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlXG4gICAgICogaGVpZ2h0IHNvIHRoYXQgdGhlcmUgaXMgbmV2ZXIgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBtb25pdG9yQXV0b0dyb3coZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRhcmdldCA9IGRhdGEuc3ViamVjdCA9IG1lLmdldEVsZW1lbnQoZGF0YS5pZCk7XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byB1cGRhdGUgdGhlIGhlaWdodCBvbiBldmVyeSBpbnB1dCBldmVudCBpcyBhdXRvR3JvdyBpcyB0cnV0aHkuXG4gICAgICAgIHRhcmdldFtkYXRhLmF1dG9Hcm93ID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInXSgnaW5wdXQnLCBtZS5tb25pdG9yQXV0b0dyb3dIYW5kbGVyKTtcblxuICAgICAgICAvLyBGaXggdGhlIGhlaWdodCB1cCBpbW1lZGlhdGVseSB0b29cbiAgICAgICAgZGF0YS5hdXRvR3JvdyAmJiBtZS5tb25pdG9yQXV0b0dyb3dIYW5kbGVyKHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudHxPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEuaWRdXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2RhdGEudGFyZ2V0XVxuICAgICAqL1xuICAgIG1vbml0b3JBdXRvR3Jvd0hhbmRsZXIoZGF0YSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBkYXRhLnRhcmdldCB8fCB0aGlzLmdldEVsZW1lbnQoZGF0YS5pZCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICB7IHN0eWxlIH0gICAgICAgICAgICAgID0gdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHsgc3R5bGUgOiBpbnB1dFN0eWxlIH0gPSB0YXJnZXQuY2xvc2VzdCgnLm5lby10ZXh0YXJlYScpO1xuXG4gICAgICAgICAgICAvLyBNZWFzdXJlIHRoZSBzY3JvbGxIZWlnaHQgd2hlbiBmb3JjZWQgdG8gb3ZlcmZsb3csIHRoZW4gc2V0IGhlaWdodCB0byBlbmNvbXBhc3MgdGhlIHNjcm9sbEhlaWdodFxuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUubWluSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGlucHV0U3R5bGUuc2V0UHJvcGVydHkoJy0tdGV4dGZpZWxkLWlucHV0LWhlaWdodCcsIGAke3RhcmdldC5zY3JvbGxIZWlnaHQgKyA1fXB4YCk7XG4gICAgICAgICAgICBpbnB1dFN0eWxlLnNldFByb3BlcnR5KCdoZWlnaHQnLCAnJyk7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5taW5IZWlnaHQgPSAnJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRvY3VtZW50Qmx1cigpIHtcbiAgICAgICAgTmVvLmFsdEtleURvd24gPSBOZW8uY29udHJvbEtleURvd24gPSBOZW8ubWV0YUtleURvd24gPSBOZW8uc2hpZnRLZXlEb3duID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGtleUV2ZW50XG4gICAgICovXG4gICAgb25Eb2N1bWVudEtleURvd24oa2V5RXZlbnQpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVyS2V5c1trZXlFdmVudC5rZXldKSB7XG4gICAgICAgICAgICAvLyBlLmcuIE5lby5pc1NoaWZ0S2V5RG93biA9IHRydWUgb3IgTmVvLmlzQ29udHJvbEtleURvd24gPSB0cnVlLlxuICAgICAgICAgICAgLy8gU2VsZWN0aW9uIGNhbiBjb25zdWx0IHRoaXMgdmFsdWVcbiAgICAgICAgICAgIE5lb1tgJHtTdHJpbmdVdGlsLnVuY2FwaXRhbGl6ZShrZXlFdmVudC5rZXkpfUtleURvd25gXSA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0ga2V5RXZlbnRcbiAgICAgKi9cbiAgICBvbkRvY3VtZW50S2V5VXAoa2V5RXZlbnQpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVyS2V5c1trZXlFdmVudC5rZXldKSB7XG4gICAgICAgICAgICBOZW9bYCR7U3RyaW5nVXRpbC51bmNhcGl0YWxpemUoa2V5RXZlbnQua2V5KX1LZXlEb3duYF0gPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbXV0YXRpb25zXG4gICAgICovXG4gICAgb25Eb2N1bWVudE11dGF0aW9uKG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gSWYgdGhlIG11dGF0aW9ucyBhcmUgcHVyZWx5IGFsaWduIHN1YmplY3RzIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWQsIHRha2Ugbm8gYWN0aW9uLlxuICAgICAgICBpZiAoIW11dGF0aW9ucy5ldmVyeSgoeyB0eXBlLCBhZGRlZE5vZGVzLCByZW1vdmVkTm9kZXMgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBbLi4uQXJyYXkuZnJvbShhZGRlZE5vZGVzKSwgLi4uQXJyYXkuZnJvbShyZW1vdmVkTm9kZXMpXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBub2Rlcy5ldmVyeShhID0+IG1lLmlzQWxpZ25TdWJqZWN0KGEpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgbWUuc3luY0FsaWducygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICAgKi9cbiAgICBvbkRvY3VtZW50TW91c2VEb3duKGUpIHtcbiAgICAgICAgbGV0IGZvY3VzQ29udHJvbGxlciA9IGUudGFyZ2V0Py5jbG9zZXN0KCdbZGF0YS1mb2N1c10nKTtcblxuICAgICAgICAvLyBkYXRhLWZvY3VzIG9uIGFuIGVsZW1lbnQgbWVhbnMgcmVqZWN0IG1vdXNlZG93biBnZXN0dXJlcywgYW5kIG1vdmUgZm9jdXNcbiAgICAgICAgLy8gdG8gdGhlIHJlZmVyZW5jZWQgZWxlbWVudC5cbiAgICAgICAgaWYgKGZvY3VzQ29udHJvbGxlcikge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9jdXNDb250cm9sbGVyLmRhdGFzZXQuZm9jdXMpPy5mb2N1cygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRG9tQ29udGVudExvYWRlZCgpIHtcbiAgICAgICAgTmVvLmNvbmZpZy5hcHBseUJvZHlDbHMgJiYgdGhpcy5hcHBseUJvZHlDbHMoe2NsczogWyduZW8tYm9keSddfSk7XG4gICAgICAgIE5lby5jb25maWcuYXBwbHlGaXhlZFBvc2l0aW9uVG9IdG1sVGFnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCAnZml4ZWQnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5ub2RlSWRcbiAgICAgKi9cbiAgICBnZXRPZmZzY3JlZW5DYW52YXMoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgICAgICA9IG1lLmdldEVsZW1lbnQoZGF0YS5ub2RlSWQpLFxuICAgICAgICAgICAgb2Zmc2NyZWVuO1xuXG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHtzdWNjZXNzOiBmYWxzZX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvZmZzY3JlZW4gPSBub2RlLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICA6IHtvZmZzY3JlZW59LFxuICAgICAgICAgICAgICAgIHRyYW5zZmVyOiBbb2Zmc2NyZWVuXVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3RyYW5zZmVycmVkOiB0cnVlfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBkYXRhLmF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhLmZ1bmN0aW9ucyBBbiBhcnJheSBjb250YWluaW5nIHN0cmluZ3MgYW5kL29yIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBkYXRhLnN0eWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnZub2RlSWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25SZWFkRG9tKGRhdGEpIHtcbiAgICAgICAgbGV0IGF0dHJpYnV0ZXMgICAgPSBkYXRhLmF0dHJpYnV0ZXMgfHwgW10sXG4gICAgICAgICAgICBmdW5jdGlvbnMgICAgID0gZGF0YS5mdW5jdGlvbnMgIHx8IFtdLFxuICAgICAgICAgICAgc3R5bGVzICAgICAgICA9IGRhdGEuc3R5bGVzICAgICB8fCBbXSxcbiAgICAgICAgICAgIHt2bm9kZUlkfSAgICAgPSBkYXRhLFxuICAgICAgICAgICAgcmV0QXR0cmlidXRlcyA9IHt9LFxuICAgICAgICAgICAgcmV0RnVuY3Rpb25zICA9IHt9LFxuICAgICAgICAgICAgcmV0U3R5bGVzICAgICA9IHt9LFxuICAgICAgICAgICAgZWxlbWVudCAgICAgICA9IHZub2RlSWQgPyB0aGlzLmdldEVsZW1lbnQodm5vZGVJZCkgOiBudWxsLFxuICAgICAgICAgICAgZm5OYW1lLCBzY29wZTtcblxuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHJldEF0dHJpYnV0ZXNba2V5XSA9IGVsZW1lbnRba2V5XVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbnMuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICAgICAga2V5LnBhcmFtcyAgICAgICAgID0ga2V5LnBhcmFtcyAgICAgICAgIHx8IFtdO1xuICAgICAgICAgICAgICAgIGtleS5wYXJhbUlzRG9tTm9kZSA9IGtleS5wYXJhbUlzRG9tTm9kZSB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHNjb3BlID0ga2V5LnNjb3BlID8gZG9jdW1lbnRba2V5LnNjb3BlXSA6IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBrZXkucGFyYW1zLmZvckVhY2goKHBhcmFtLCBwYXJhbUluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkucGFyYW1Jc0RvbU5vZGVbcGFyYW1JbmRleF0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5wYXJhbXNbcGFyYW1JbmRleF0gPSB0aGlzLmdldEVsZW1lbnQoa2V5LnBhcmFtc1twYXJhbUluZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZm5OYW1lID0ga2V5LnJldHVybkZuTmFtZSA/IGtleS5yZXR1cm5Gbk5hbWUgOiBpbmRleDtcbiAgICAgICAgICAgICAgICByZXRGdW5jdGlvbnNbZm5OYW1lXSA9IHNjb3BlW2tleS5mbl0oLi4ua2V5LnBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldEZ1bmN0aW9uc1tmbk5hbWVdID0gcmV0RnVuY3Rpb25zW2ZuTmFtZV1ba2V5LnJldHVyblZhbHVlXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0RnVuY3Rpb25zW2tleV0gPSBlbGVtZW50W2tleV0oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdHlsZXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgcmV0U3R5bGVzW2tleV0gPSBlbGVtZW50LnN0eWxlW2tleV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiByZXRBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZnVuY3Rpb25zIDogcmV0RnVuY3Rpb25zLFxuICAgICAgICAgICAgc3R5bGVzICAgIDogcmV0U3R5bGVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE5lby53b3JrZXIuTWFuYWdlci5zZW5kTWVzc2FnZShkYXRhLm9yaWdpbiwge1xuICAgICAgICAgICAgYWN0aW9uIDogJ3JlcGx5JyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZXBseUlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHBhcmFtIGRhdGEudGFyZ2V0XG4gICAgICogQHBhcmFtIGRhdGEucmVsYXRlZFRhcmdldFxuICAgICAqL1xuICAgIG9uVHJhcHBlZEZvY3VzTW92ZW1lbnQoeyB0YXJnZXQsIHJlbGF0ZWRUYXJnZXQgfSkge1xuICAgICAgICBjb25zdCBiYWNrd2FyZHMgPSByZWxhdGVkVGFyZ2V0ICYmICh0YXJnZXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24ocmVsYXRlZFRhcmdldCkgJiA0KTtcblxuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoJy5uZW8tZm9jdXMtdHJhcCcpKSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdFZW1lbnQgPSB0YXJnZXQucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICB0cmVlV2Fsa2VyICAgICAgID0gY29udGFpbmluZ0VlbWVudC4kdHJlZVdhbGtlcixcbiAgICAgICAgICAgICAgICB0b3BGb2N1c1RyYXAgICAgID0gY29udGFpbmluZ0VlbWVudC4kdG9wRm9jdXNUcmFwLFxuICAgICAgICAgICAgICAgIGJvdHRvbUZvY3VzVHJhcCAgPSBjb250YWluaW5nRWVtZW50LiRib3R0b21Gb2N1c1RyYXA7XG5cbiAgICAgICAgICAgIHRyZWVXYWxrZXIuY3VycmVudE5vZGUgPSBiYWNrd2FyZHMgPyBib3R0b21Gb2N1c1RyYXAgOiB0b3BGb2N1c1RyYXA7XG4gICAgICAgICAgICB0cmVlV2Fsa2VyW2JhY2t3YXJkcyA/ICdwcmV2aW91c05vZGUnIDogJ25leHROb2RlJ10oKTtcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRyZWVXYWxrZXIuY3VycmVudE5vZGUuZm9jdXMoKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlYWQoZGF0YSkge1xuICAgICAgICBOZW8uaXNGdW5jdGlvbihkYXRhKSAmJiBkYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYW55IERPTSBzaXppbmcgY29uZmlncyB0byB0aGUgbGFzdCBleHRlcm5hbGx5IGNvbmZpZ3VyZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgZHVyaW5nIGFsaWduaW5nIHRvIHJlbGVhc2UgYW55IGNvbnN0cmFpbnRzIGFwcGxpZWQgYnkgYSBwcmV2aW91cyBhbGlnbm1lbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFsaWduXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlc2V0RGltZW5zaW9ucyhhbGlnbikge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZ2V0RWxlbWVudChhbGlnbi5pZCkuc3R5bGUsIHtcbiAgICAgICAgICAgIGZsZXggICAgIDogYWxpZ24uY29uZmlndXJlZEZsZXgsXG4gICAgICAgICAgICBoZWlnaHQgICA6IGFsaWduLmNvbmZpZ3VyZWRIZWlnaHQsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IGFsaWduLmNvbmZpZ3VyZWRNYXhIZWlnaHQsXG4gICAgICAgICAgICBtYXhXaWR0aCA6IGFsaWduLmNvbmZpZ3VyZWRNYXhXaWR0aCxcbiAgICAgICAgICAgIG1pbkhlaWdodDogYWxpZ24uY29uZmlndXJlZE1pbkhlaWdodCxcbiAgICAgICAgICAgIG1pbldpZHRoIDogYWxpZ24uY29uZmlndXJlZE1pbldpZHRoLFxuICAgICAgICAgICAgd2lkdGggICAgOiBhbGlnbi5jb25maWd1cmVkV2lkdGhcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3Njcm9sbEJ5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5iZWhhdmlvcj0nYXV0bycgYXV0bywgaW5zdGFudCwgc21vb3RoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuZGlyZWN0aW9uPSd0b3AnIGxlZnQsIHRvcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmouaWQgPT4gdGhlIHBhc3NlZCBpZFxuICAgICAqL1xuICAgIHNjcm9sbEJ5KHtiZWhhdmlvcj0nYXV0bycsIGRpcmVjdGlvbj0ndG9wJywgaWQsIHZhbHVlfSkge1xuICAgICAgICB0aGlzLmdldEVsZW1lbnQoaWQpPy5zY3JvbGxCeSh7YmVoYXZpb3IsIFtkaXJlY3Rpb25dOiB2YWx1ZX0pO1xuICAgICAgICByZXR1cm4ge2lkfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gZWl0aGVyIHBhc3MgdGhlIGlkIG9yIGEgcXVlcnlTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmlkXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmJlaGF2aW9yPSdzbW9vdGgnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYmxvY2s9J3N0YXJ0J1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmRlbGF5PTUwMFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlubGluZT0nbmVhcmVzdCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEucXVlcnlTZWxlY3Rvcl1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KHtpZCwgYmVoYXZpb3I9J3Ntb290aCcsIGJsb2NrPSdzdGFydCcsIGRlbGF5PTUwMCwgaW5saW5lPSduZWFyZXN0JywgcXVlcnlTZWxlY3Rvcn0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpZCA/IHRoaXMuZ2V0RWxlbWVudChpZCkgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5U2VsZWN0b3IpLFxuICAgICAgICAgICAgb3B0cyA9IHtiZWhhdmlvciwgYmxvY2ssIGlubGluZX07XG5cbiAgICAgICAgaWYgKGJlaGF2aW9yICE9PSAnc21vb3RoJykge1xuICAgICAgICAgICAgbm9kZS5zY3JvbGxJbnRvVmlldyhvcHRzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2Nyb2xsSW50b1ZpZXcoKSBkb2VzIG5vdCBwcm92aWRlIGEgY2FsbGJhY2sgeWV0LlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL2Nzc3dnLWRyYWZ0cy9pc3N1ZXMvMzc0NFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNMaXN0ZW5lciA9ICdzY3JvbGxlbmQnIGluIHdpbmRvdztcblxuICAgICAgICAgICAgICAgICAgICBoYXNMaXN0ZW5lciAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxlbmQnLCAoKSA9PiByZXNvbHZlKCksIHtjYXB0dXJlOiB0cnVlLCBvbmNlOiB0cnVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zY3JvbGxJbnRvVmlldyhvcHRzKTtcblxuICAgICAgICAgICAgICAgICAgICAhaGFzTGlzdGVuZXIgJiYgdGhpcy50aW1lb3V0KGRlbGF5KS50aGVuKCgpID0+IHtyZXNvbHZlKCl9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3Njcm9sbFRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5iZWhhdmlvcj0nYXV0bycgYXV0bywgaW5zdGFudCwgc21vb3RoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuZGlyZWN0aW9uPSd0b3AnIGxlZnQsIHRvcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmouaWQgPT4gdGhlIHBhc3NlZCBpZFxuICAgICAqL1xuICAgIHNjcm9sbFRvKHtiZWhhdmlvcj0nYXV0bycsIGRpcmVjdGlvbj0ndG9wJywgaWQsIHZhbHVlfSkge1xuICAgICAgICB0aGlzLmdldEVsZW1lbnQoaWQpPy5zY3JvbGxUbyh7YmVoYXZpb3IsIFtkaXJlY3Rpb25dOiB2YWx1ZX0pO1xuICAgICAgICByZXR1cm4ge2lkfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5iZWhhdmlvcj0nc21vb3RoJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm9mZnNldD0zNFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9iai5pZCA9PiB0aGUgcGFzc2VkIGlkXG4gICAgICovXG4gICAgc2Nyb2xsVG9UYWJsZVJvdyh7aWQsIGJlaGF2aW9yPSdzbW9vdGgnLCBvZmZzZXQ9MzR9KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5nZXRFbGVtZW50KGlkKTsgLy8gdHIgdGFnXG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCB0YWJsZU5vZGUgICA9IG5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIHdyYXBwZXJOb2RlID0gdGFibGVOb2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgdGFibGVUb3AgICAgPSB0YWJsZU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgICAgID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG5cbiAgICAgICAgICAgIHdyYXBwZXJOb2RlLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBiZWhhdmlvcixcbiAgICAgICAgICAgICAgICB0b3A6IHRvcCAtIHRhYmxlVG9wIC0gb2Zmc2V0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtpZH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLnN0YXJ0PTBdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLmVuZD05OTk5OV1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmouaWQgPT4gdGhlIHBhc3NlZCBpZFxuICAgICAqL1xuICAgIHNlbGVjdE5vZGUoZGF0YSkge1xuICAgICAgICBsZXQgbm9kZSAgPSB0aGlzLmdldEVsZW1lbnQoZGF0YS5pZCksXG4gICAgICAgICAgICBzdGFydCA9IE5lby5pc051bWJlcihkYXRhLnN0YXJ0KSA/IGRhdGEuc3RhcnQgOiAwLFxuICAgICAgICAgICAgZW5kICAgPSBOZW8uaXNOdW1iZXIoZGF0YS5lbmQpICAgPyBkYXRhLmVuZCAgIDogOTk5OTk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuc2VsZWN0KCk7XG4gICAgICAgICAgICBub2RlLnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge2lkOiBkYXRhLmlkfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZGF0YS5hZGRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnJlbW92ZVxuICAgICAqL1xuICAgIHNldEJvZHlDbHMoZGF0YSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoLi4uZGF0YS5yZW1vdmUgfHwgW10pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoLi4uZGF0YS5hZGQgfHwgW10pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90IHJlY29tbWVuZGVkIHRvIHVzZSA9PiBzdGljayB0byB2ZG9tIHVwZGF0ZXMuXG4gICAgICogQ2FuIGJlIGhhbmR5IGZvciBjdXN0b20gQ1NTIGJhc2VkIGFuaW1hdGlvbnMgdGhvdWdoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWQgQSBub2RlIGlkIG9yICdkb2N1bWVudC5ib2R5J1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnN0eWxlXG4gICAgICogQHJldHVybnMge09iamVjdH0gb2JqLmlkID0+IHRoZSBwYXNzZWQgaWRcbiAgICAgKi9cbiAgICBzZXRTdHlsZShkYXRhKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5nZXRFbGVtZW50T3JCb2R5KGRhdGEuaWQpO1xuXG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhLnN0eWxlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5pbmNsdWRlcygnIWltcG9ydGFudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnIWltcG9ydGFudCcsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoTmVvLmRlY2FtZWwoa2V5KSwgdmFsdWUsICdpbXBvcnRhbnQnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbTmVvLmRlY2FtZWwoa2V5KV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge2lkOiBkYXRhLmlkfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgc3luY0FsaWducygpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7X2FsaWduc30gPSBtZTtcblxuICAgICAgICAvLyBLZWVwIGFsbCByZWdpc3RlcmVkIGFsaWducyBhbGlnbmVkIG9uIGFueSBkZXRlY3RlZCBjaGFuZ2VcbiAgICAgICAgX2FsaWducz8uZm9yRWFjaChhbGlnbiA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQcmVzZW50ID0gZG9jdW1lbnQuY29udGFpbnMoYWxpZ24udGFyZ2V0RWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIEFsaWduIHN1YmplY3QgYW5kIHRhcmdldCBzdGlsbCBpbiB0aGUgRE9NIC0gY29ycmVjdCBpdHMgYWxpZ25tZW50XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuY29udGFpbnMoYWxpZ24uc3ViamVjdCkgJiYgdGFyZ2V0UHJlc2VudCkge1xuICAgICAgICAgICAgICAgIG1lLmFsaWduKGFsaWduKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxpZ24gc3ViamVjdCBvciB0YXJnZXQgbm8gbG9uZ2VyIGluIHRoZSBET00gLSByZW1vdmUgaXQuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0YXJnZXQgaXMgbm8gbG9uZ2VyIGluIHRoZSBET00sIGhpZGUgdGhlIHN1YmplY3QgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIE5lby53b3JrZXIuQXBwLnNldENvbmZpZ3MoeyBpZDogYWxpZ24uaWQsIGhpZGRlbjogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHtfYWxpZ25SZXNpemVPYnNlcnZlcn0gPSBtZSxcbiAgICAgICAgICAgICAgICAgICAge2NvbnN0cmFpblRvRWxlbWVudH0gICA9IGFsaWduO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RvcCBvYnNlcnZpbmcgdGhlIGFsaWduIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgX2FsaWduUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGFsaWduLnN1YmplY3QpO1xuICAgICAgICAgICAgICAgIF9hbGlnblJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShhbGlnbi5vZmZzZXRQYXJlbnQpO1xuICAgICAgICAgICAgICAgIF9hbGlnblJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShhbGlnbi50YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWluVG9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9hbGlnblJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShjb25zdHJhaW5Ub0VsZW1lbnQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGxhc3QgYWxpZ25lZCBjbGFzcy5cbiAgICAgICAgICAgICAgICBhbGlnbi5zdWJqZWN0LmNsYXNzTGlzdC5yZW1vdmUoYG5lby1hbGlnbmVkLSR7YWxpZ24ucmVzdWx0Py5wb3NpdGlvbn1gKTtcblxuICAgICAgICAgICAgICAgIF9hbGlnbnMuZGVsZXRlKGFsaWduLmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEubW9kYWxcbiAgICAgKi9cbiAgICBzeW5jTW9kYWxNYXNrKHsgaWQsIG1vZGFsIH0pIHtcbiAgICAgICAgY29uc3QgZWwgPSBpZCAmJiB0aGlzLmdldEVsZW1lbnQoaWQpO1xuXG4gICAgICAgIC8vIElmIHdlIGFyZSB2aXNpYmxlIGFuZCBtb2RhbCwgdGhlIG1hc2sgbmVlZHMgdG8gYmUganVzdCBiZWxvdyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIGlmIChlbCAmJiBtb2RhbCAmJiBlbC5vd25lckRvY3VtZW50LmNvbnRhaW5zKGVsKSAmJiBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZSh0aGlzLm1vZGFsTWFzaywgZWwpXG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgbWFzayBuZWVkcyB0byBiZSBiZWxvdyB0aGUgbmV4dCB0b3Btb3N0IG1vZGFsIGRpYWxvZyBpZiBwb3NzaWJsZSwgb3IgaGlkZGVuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBtb2RhbHMgICAgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmVvLW1vZGFsJyksXG4gICAgICAgICAgICAgICAgdG9wbW9zdE1vZGFsID0gbW9kYWxzW21vZGFscy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgLy8gTW92ZSB0aGUgbWFzayB1bmRlciB0aGUgbmV4dCB0b3Btb3N0IG1vZGFsIG5vdyBtb2RhbCBcImlkXCIgaXMgZ29uZS5cbiAgICAgICAgICAgIGlmICh0b3Btb3N0TW9kYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNNb2RhbE1hc2soeyBpZDogdG9wbW9zdE1vZGFsLmlkLCBtb2RhbDogdHJ1ZSB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RhbE1hc2s/LnJlbW92ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFwcyAob3Igc3RvcHMgdHJhcHBpbmcpIGZvY3VzIHdpdGhpbiBhIENvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWQgVGhlIENvbXBvbmVudCB0byB0cmFwIGZvY3VzIHdpdGhpbi5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLnRyYXA9dHJ1ZV0gUGFzcyBgZmFsc2VgIHRvIHN0b3AgdHJhcHBpbmcgZm9jdXMgaW5zaWRlIHRoZSBDb21wb25lbnQuXG4gICAgICovXG4gICAgYXN5bmMgdHJhcEZvY3VzKGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgb25UcmFwcGVkRm9jdXNNb3ZlbWVudCA9IG1lLiRib3VuZE9uVHJhcHBlZEZvY3VzTW92ZW1lbnQgfHwgKG1lLiRib3VuZE9uVHJhcHBlZEZvY3VzTW92ZW1lbnQgPSBtZS5vblRyYXBwZWRGb2N1c01vdmVtZW50LmJpbmQobWUpKSxcbiAgICAgICAgICAgIHN1YmplY3QgICAgICAgICAgICAgICAgPSBkYXRhLnN1YmplY3QgPSBtZS5nZXRFbGVtZW50KGRhdGEuaWQpLFxuICAgICAgICAgICAgeyB0cmFwID0gdHJ1ZSB9ICAgICAgICA9IGRhdGE7XG5cbiAgICAgICAgLy8gQ2FsbGVkIGJlZm9yZSBET00gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b3BGb2N1c1RyYXAgICAgPSBzdWJqZWN0LiR0b3BGb2N1c1RyYXAsXG4gICAgICAgICAgICBib3R0b21Gb2N1c1RyYXAgPSBzdWJqZWN0LiRib3R0b21Gb2N1c1RyYXA7XG5cbiAgICAgICAgaWYgKHRyYXApIHtcbiAgICAgICAgICAgIGlmICghc3ViamVjdC4kdHJlZVdhbGtlcikge1xuICAgICAgICAgICAgICAgIHN1YmplY3QuJHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHN1YmplY3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdE5vZGU6IGZpbHRlclRhYmJhYmxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdG9wRm9jdXNUcmFwID0gc3ViamVjdC4kdG9wRm9jdXNUcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgYm90dG9tRm9jdXNUcmFwID0gc3ViamVjdC4kYm90dG9tRm9jdXNUcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgdHdvIGZvY3VzIHRyYXBwaW5nIGVsZW1lbnRzIG11c3QgYmUgaW52aXNpYmxlIGJ1dCB0YWJiYWJsZS5cbiAgICAgICAgICAgICAgICB0b3BGb2N1c1RyYXAuY2xhc3NOYW1lID0gYm90dG9tRm9jdXNUcmFwLmNsYXNzTmFtZSA9ICduZW8tZm9jdXMtdHJhcCc7XG4gICAgICAgICAgICAgICAgdG9wRm9jdXNUcmFwLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAwKTtcbiAgICAgICAgICAgICAgICBib3R0b21Gb2N1c1RyYXAuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIDApO1xuXG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciB3aGVuIHRoZXkgZ2FpbiBmb2N1cyBhbmQgd3JhcCBmb2N1cyB3aXRoaW4gdGhlIGVuY2Fwc3VsYXRpbmcgZWxlbWVudFxuICAgICAgICAgICAgICAgIHN1YmplY3QuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uVHJhcHBlZEZvY3VzTW92ZW1lbnQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBjb250ZW50IGlzIGVuY2Fwc3VsYXRlZCBieSB0aGUgZm9jdXMgdHJhcCBlbGVtZW50c1xuICAgICAgICAgICAgc3ViamVjdC5pbnNlcnRCZWZvcmUodG9wRm9jdXNUcmFwLCBzdWJqZWN0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgc3ViamVjdC5hcHBlbmRDaGlsZChib3R0b21Gb2N1c1RyYXApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvblRyYXBwZWRGb2N1c01vdmVtZW50KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEuYmVoYXZpb3I9J3Ntb290aCddIC8vIGF1dG8gb3Igc21vb3RoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmxlZnQ9MF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEudG9wPTBdXG4gICAgICovXG4gICAgd2luZG93U2Nyb2xsVG8oZGF0YSkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgYmVoYXZpb3I6IGRhdGEuYmVoYXZpb3IgfHwgJ3Ntb290aCcsXG4gICAgICAgICAgICBsZWZ0ICAgIDogZGF0YS5sZWZ0ICAgICB8fCAwLFxuICAgICAgICAgICAgdG9wICAgICA6IGRhdGEudG9wICAgICAgfHwgMFxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRG9tQWNjZXNzKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBTdHJpbmdVdGlsICAgICBmcm9tICcuLi91dGlsL1N0cmluZy5tanMnO1xuaW1wb3J0IFRvdWNoRG9tRXZlbnRzIGZyb20gJy4vbWl4aW4vVG91Y2hEb21FdmVudHMubWpzJztcblxuY29uc3QgZ2xvYmFsRG9tRXZlbnRzID0gW1xuICAgIHtuYW1lOiAnY2hhbmdlJywgICAgICBoYW5kbGVyOiAnb25DaGFuZ2UnfSxcbiAgICB7bmFtZTogJ2NsaWNrJywgICAgICAgaGFuZGxlcjogJ29uQ2xpY2snfSxcbiAgICB7bmFtZTogJ2NvbnRleHRtZW51JywgaGFuZGxlcjogJ29uQ29udGV4dE1lbnUnfSxcbiAgICB7bmFtZTogJ2RibGNsaWNrJywgICAgaGFuZGxlcjogJ29uRG91YmxlQ2xpY2snfSxcbiAgICB7bmFtZTogJ2ZvY3VzaW4nLCAgICAgaGFuZGxlcjogJ29uRm9jdXNJbid9LFxuICAgIHtuYW1lOiAnZm9jdXNvdXQnLCAgICBoYW5kbGVyOiAnb25Gb2N1c091dCd9LFxuICAgIHtuYW1lOiAnaW5wdXQnLCAgICAgICBoYW5kbGVyOiAnb25DaGFuZ2UnfSxcbiAgICB7bmFtZTogJ2tleWRvd24nLCAgICAgaGFuZGxlcjogJ29uS2V5RG93bid9LFxuICAgIHtuYW1lOiAna2V5dXAnLCAgICAgICBoYW5kbGVyOiAnb25LZXlVcCd9LFxuICAgIHtuYW1lOiAnbW91c2Vkb3duJywgICBoYW5kbGVyOiAnb25Nb3VzZURvd24nfSxcbiAgICB7bmFtZTogJ21vdXNlZW50ZXInLCAgaGFuZGxlcjogJ29uTW91c2VFbnRlcicsIG9wdGlvbnM6IHtjYXB0dXJlOiB0cnVlfX0sXG4gICAge25hbWU6ICdtb3VzZWxlYXZlJywgIGhhbmRsZXI6ICdvbk1vdXNlTGVhdmUnLCBvcHRpb25zOiB7Y2FwdHVyZTogdHJ1ZX19LFxuICAgIHtuYW1lOiAnbW91c2V1cCcsICAgICBoYW5kbGVyOiAnb25Nb3VzZVVwJ30sXG4gICAge25hbWU6ICdzY3JvbGwnLCAgICAgIGhhbmRsZXI6ICdvblNjcm9sbCcsICAgICBvcHRpb25zOiB7Y2FwdHVyZTogdHJ1ZX19LFxuICAgIHtuYW1lOiAnd2hlZWwnLCAgICAgICBoYW5kbGVyOiAnb25XaGVlbCcsICAgICAgb3B0aW9uczoge3Bhc3NpdmU6IGZhbHNlfX1cbl07XG5cbi8vIFdpbGwgZ2V0IGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50LmJvZHkgaW4gY2FzZSBOZW8uY29uZmlnLmhhc1RvdWNoRXZlbnRzID09PSB0cnVlXG5jb25zdCB0b3VjaEV2ZW50cyA9IFtcbiAgICB7bmFtZTogJ3RvdWNoY2FuY2VsJywgaGFuZGxlcjogJ29uVG91Y2hDYW5jZWwnfSxcbiAgICB7bmFtZTogJ3RvdWNoZW5kJywgICAgaGFuZGxlcjogJ29uVG91Y2hFbmQnfSxcbiAgICB7bmFtZTogJ3RvdWNoZW50ZXInLCAgaGFuZGxlcjogJ29uVG91Y2hFbnRlcid9LFxuICAgIHtuYW1lOiAndG91Y2hsZWF2ZScsICBoYW5kbGVyOiAnb25Ub3VjaExlYXZlJ30sXG4gICAge25hbWU6ICd0b3VjaG1vdmUnLCAgIGhhbmRsZXI6ICdvblRvdWNoTW92ZScsIG9wdGlvbnM6IHtwYXNzaXZlOiBmYWxzZX19LFxuICAgIHtuYW1lOiAndG91Y2hzdGFydCcsICBoYW5kbGVyOiAnb25Ub3VjaFN0YXJ0J31cbl07XG5cbi8vIHdoZWVsIGV2ZW50cyBmaXJlIHZlcnkgb2Z0ZW4sIHNvIHdlIGxpbWl0IHRoZSB0YXJnZXRzIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHBvc3QgbWVzc2FnZXMgZnJvbSBtYWluIHRvIHRoZSBhcHAgd29ya2VyXG5jb25zdCBnbG9iYWxXaGVlbFRhcmdldHMgPSBbXG4gICAgJ25lby1jLW0tc2Nyb2xsY29udGFpbmVyJyxcbiAgICAnbmVvLWMtdy1zY3JvbGxjb250YWluZXInLFxuICAgICduZW8tY2FsZW5kYXIteWVhcmNvbXBvbmVudCcsXG4gICAgJ25lby1jaXJjbGUtY29tcG9uZW50JyxcbiAgICAnbmVvLWRhdGVzZWxlY3RvcicsXG4gICAgJ25lby1nYWxsZXJ5JyxcbiAgICAnbmVvLWhlbGl4J1xuXTtcblxuLy8gc2VwYXJhdGVkIGZyb20gZ2xvYmFsV2hlZWxUYXJnZXRzID0+IHBlcmZvcm1hbmNlXG4vLyBidWZmZXIgaW4gbXNcbmNvbnN0IGdsb2JhbFdoZWVsVGFyZ2V0c0J1ZmZlciA9IHtcbiAgICAnbmVvLWMtbS1zY3JvbGxjb250YWluZXInICAgOiAxMDAsXG4gICAgJ25lby1jLXctc2Nyb2xsY29udGFpbmVyJyAgIDogMTAwLFxuICAgICduZW8tY2FsZW5kYXIteWVhcmNvbXBvbmVudCc6IDMwMCxcbiAgICAnbmVvLWRhdGVzZWxlY3RvcicgICAgICAgICAgOiAzMDBcbn07XG5cbi8vIHNlcGFyYXRlZCBmcm9tIGdsb2JhbFdoZWVsVGFyZ2V0cyA9PiBwZXJmb3JtYW5jZVxuY29uc3QgZ2xvYmFsV2hlZWxUYXJnZXRzS2VlcEV2ZW50ID0gW1xuICAgICduZW8tYy1tLXNjcm9sbGNvbnRhaW5lcicsXG4gICAgJ25lby1jLXctc2Nyb2xsY29udGFpbmVyJ1xuXTtcblxuY29uc3QgbGFzdFdoZWVsRXZlbnQgPSB7XG4gICAgZGF0ZSAgOiBudWxsLFxuICAgIHRhcmdldDogbnVsbFxufTtcblxuY29uc3RcbiAgICBkaXNhYmxlZElucHV0S2V5cyAgICAgICAgID0ge30sXG4gICAgcHJldmVudENsaWNrVGFyZ2V0cyAgICAgICA9IFtdLFxuICAgIHByZXZlbnRDb250ZXh0bWVudVRhcmdldHMgPSBbXTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1haW4uRG9tRXZlbnRzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICogQG1peGVzIE5lby5tYWluLm1peGluLlRvdWNoRG9tRXZlbnRzXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIERvbUV2ZW50cyBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYWluLkRvbUV2ZW50cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4uRG9tRXZlbnRzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvZG86IGNvbmRpdGlvbmFsIGR5bmFtaWMgaW1wb3J0IG9uY2UgdGhlIGJ1aWxkIHByb2Nlc3NlcyBjYW4gaGFuZGxlIGl0XG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBtaXhpbnM9W1RvdWNoRG9tRXZlbnRzXVxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW5zOiBbVG91Y2hEb21FdmVudHNdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnYWRkRG9tTGlzdGVuZXInLFxuICAgICAgICAgICAgICAgICdyZWdpc3RlckRpc2FibGVkSW5wdXRDaGFycycsXG4gICAgICAgICAgICAgICAgJ3JlZ2lzdGVyUHJldmVudERlZmF1bHRUYXJnZXRzJyxcbiAgICAgICAgICAgICAgICAndW5yZWdpc3RlckRpc2FibGVkSW5wdXRDaGFycydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB0b3VjaFxuICAgICAqL1xuICAgIGxhc3RUb3VjaCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICBtZS5vbkRvbUNvbnRlbnRMb2FkZWQgLmJpbmQobWUpKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgICBtZS5vblNlbGVjdGlvbkNoYW5nZSAgLmJpbmQobWUpKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICBtZS5vblZpc2liaWxpdHljaGFuZ2UgLmJpbmQobWUpKTtcbiAgICAgICAgd2luZG93ICAuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBtZS5vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQobWUpKTtcbiAgICAgICAgd2luZG93ICAuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsICAgICAgICBtZS5vbkhhc2hDaGFuZ2UgICAgICAgLmJpbmQobWUpKTtcblxuICAgICAgICBpZiAoTmVvLmNvbmZpZy51c2VTaGFyZWRXb3JrZXJzKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgbWUub25CZWZvcmVVbmxvYWQuYmluZChtZSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGkgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgID0gZGF0YS5ldmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgZmFpbGVkSWQgPSBudWxsLFxuICAgICAgICAgICAgZXZlbnQsIGlkLCB0YXJnZXROb2RlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZGF0YS5ldmVudHNbaV07XG5cbiAgICAgICAgICAgIGlmICghbWVbZXZlbnQuaGFuZGxlcl0pIHtcbiAgICAgICAgICAgICAgICBtZVtldmVudC5oYW5kbGVyXSA9IE5lby5lbXB0eUZuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlkID0gZXZlbnQudm5vZGVJZCB8fCBkYXRhLnZub2RlSWQ7XG5cbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGRvY3VtZW50LmJvZHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmNvbmZpZy51c2VEb21JZHMpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1uZW8taWQ9JyR7aWR9J11gKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudC5uYW1lLCBtZVtldmVudC5oYW5kbGVyXS5iaW5kKG1lKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFpbGVkSWQgPSBpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZhaWxlZElkICYmIE5lby5jb25maWcuZW52aXJvbm1lbnQgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRG9tRXZlbnRzOmFkZERvbUxpc3RlbmVyKCkgPT4gdGFyZ2V0IG5vZGUgbm90IGZvdW5kOicsIGZhaWxlZElkKVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvLndvcmtlci5NYW5hZ2VyLnNlbmRNZXNzYWdlKGRhdGEub3JpZ2luLCB7XG4gICAgICAgICAgICBhY3Rpb24gOiAncmVwbHknLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJlcGx5SWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBzdWNjZXNzOiAhZmFpbGVkSWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEdsb2JhbERvbUxpc3RlbmVycygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBbLi4uZ2xvYmFsRG9tRXZlbnRzXS5jb25jYXQoTmVvLmNvbmZpZy5oYXNUb3VjaEV2ZW50cyA/IHRvdWNoRXZlbnRzIDogW10pLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2ZW50Lm5hbWUsIG1lW2V2ZW50LmhhbmRsZXJdLmJpbmQobWUpLCBldmVudC5vcHRpb25zKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBkb21FdmVudCBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgZG9tRXZlbnRMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3RhcmdldH0gPSBldmVudCxcblxuICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGFjdGlvbiAgIDogJ2RvbUV2ZW50JyxcbiAgICAgICAgICAgICAgICBldmVudE5hbWU6IGV2ZW50LnR5cGUsXG5cbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmdldEV2ZW50RGF0YShldmVudCksXG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiB0YXJnZXQuaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZy5kYXRhLCBtZS5nZXRNb3VzZUV2ZW50RGF0YShldmVudCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIE5lby53b3JrZXIuTWFuYWdlci5zZW5kTWVzc2FnZSgnYXBwJywgY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2VBcmlhQXR0cmlidXRlcyhub2RlKSB7XG4gICAgICAgIGxldCBhcmlhQXR0cmlidXRlcyA9IHt9LFxuICAgICAgICAgICAge2F0dHJpYnV0ZXN9ICAgPSBub2RlLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICAgPSBhdHRyaWJ1dGVzPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLm5hbWUuc3RhcnRzV2l0aCgnYXJpYS0nKSkge1xuICAgICAgICAgICAgICAgIGFyaWFBdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lLnN1YnN0cmluZyg1KV0gPSBhdHRyaWJ1dGUudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmlhQXR0cmlidXRlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAqIEBwYXJhbSAge051bWJlcn0geDEgVGhlIFggcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB5MSBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHgyIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkyIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICoqIDIgKyAoeTIgLSB5MSkgKiogMilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RXZlbnREYXRhKGV2ZW50KSB7XG4gICAgICAgIGxldCBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgLy8gb3VyIGRyYWdnYWJsZSBpbXBsZW1lbnRhdGlvbiB3aWxsIGdlbmVyYXRlIHBhdGhzLCBzbyB3ZSBkbyBuZWVkIHRvIGNoZWNrIGZvciB0aGVtXG4gICAgICAgICAgICBwYXRoID0gZXZlbnQucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHBhdGggICAgIDogcGF0aC5tYXAoZSA9PiB0aGlzLmdldFRhcmdldERhdGEoZSkpLFxuICAgICAgICAgICAgdGFyZ2V0ICAgOiB0aGlzLmdldFRhcmdldERhdGEoZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wLFxuICAgICAgICAgICAgdHlwZSAgICAgOiBldmVudC50eXBlLFxuICAgICAgICAgICAgZGF0YSAgICAgOiB7Li4uZXZlbnQudGFyZ2V0LmRhdGFzZXR9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWxhdGVkVGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXREYXRhKGV2ZW50LnJlbGF0ZWRUYXJnZXQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0S2V5Ym9hcmRFdmVudERhdGEoZXZlbnQpIHtcbiAgICAgICAgbGV0IHthbHRLZXksIGNvZGUsIGN0cmxLZXksIGtleSwga2V5Q29kZSwgbWV0YUtleSwgc2hpZnRLZXl9ID0gZXZlbnQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0RXZlbnREYXRhKGV2ZW50KSxcbiAgICAgICAgICAgIGFsdEtleSxcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICBjdHJsS2V5LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAga2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGFLZXksXG4gICAgICAgICAgICBzaGlmdEtleVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TW91c2VFdmVudERhdGEoZXZlbnQpIHtcbiAgICAgICAgbGV0IHthbHRLZXksIGNsaWVudFgsIGNsaWVudFksIGN0cmxLZXksIGRldGFpbCwgbWV0YUtleSwgb2Zmc2V0WCwgb2Zmc2V0WSwgcGFnZVgsIHBhZ2VZLCBzY3JlZW5YLCBzY3JlZW5ZLCBzaGlmdEtleX0gPSBldmVudDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5nZXRFdmVudERhdGEoZXZlbnQpLFxuICAgICAgICAgICAgYWx0S2V5LFxuICAgICAgICAgICAgY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFksXG4gICAgICAgICAgICBjdHJsS2V5LFxuICAgICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgICAgbWV0YUtleSxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZLFxuICAgICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgICBwYWdlWSxcbiAgICAgICAgICAgIHNjcmVlblgsXG4gICAgICAgICAgICBzY3JlZW5ZLFxuICAgICAgICAgICAgc2hpZnRLZXlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0UGF0aEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcblxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGVsZW1lbnQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwYXRoXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvblBhdGgocGF0aCwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSAmJiB0YXJnZXQuaWQuc3BsaXQoJ19fJykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcGF0aCA9IHRoaXMuZ2V0U2VsZWN0aW9uUGF0aChwYXRoLCB0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLnB1c2godGhpcy5nZXRUYXJnZXREYXRhKHRhcmdldCkpO1xuXG4gICAgICAgIHJldHVybiBwYXRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VGFyZ2V0RGF0YShub2RlKSB7XG4gICAgICAgIGxldCByICAgID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3Q/LigpLFxuICAgICAgICAgICAgcmVjdCA9IHIgJiYgdGhpcy5wYXJzZURvbVJlY3QocikgfHwge307XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyaWEgICAgICAgICAgICAgOiB0aGlzLmdlQXJpYUF0dHJpYnV0ZXMobm9kZSksXG4gICAgICAgICAgICBjaGVja2VkICAgICAgICAgIDogbm9kZS5jaGVja2VkLFxuICAgICAgICAgICAgY2hpbGRFbGVtZW50Q291bnQ6IG5vZGUuY2hpbGRFbGVtZW50Q291bnQsXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQgICAgIDogbm9kZS5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICBjbGllbnRMZWZ0ICAgICAgIDogbm9kZS5jbGllbnRMZWZ0LFxuICAgICAgICAgICAgY2xpZW50VG9wICAgICAgICA6IG5vZGUuY2xpZW50VG9wLFxuICAgICAgICAgICAgY2xpZW50V2lkdGggICAgICA6IG5vZGUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgIDogbm9kZS5jbGFzc0xpc3QgPyBbLi4ubm9kZS5jbGFzc0xpc3RdIDogW10sXG4gICAgICAgICAgICBkYXRhICAgICAgICAgICAgIDogey4uLm5vZGUuZGF0YXNldH0sXG4gICAgICAgICAgICBkcmFnZ2FibGUgICAgICAgIDogbm9kZS5kcmFnZ2FibGUsXG4gICAgICAgICAgICBoaWRkZW4gICAgICAgICAgIDogbm9kZS5oaWRkZW4sXG4gICAgICAgICAgICBpZCAgICAgICAgICAgICAgIDogTmVvLmNvbmZpZy51c2VEb21JZHMgPyBub2RlLmlkIDogbm9kZS5kYXRhc2V0Py5bJ25lb0lkJ10sXG4gICAgICAgICAgICBpbmVydCAgICAgICAgICAgIDogbm9kZS5pbmVydCxcbiAgICAgICAgICAgIGlzQ29ubmVjdGVkICAgICAgOiBub2RlLmlzQ29ubmVjdGVkLFxuICAgICAgICAgICAgaXNDb250ZW50RWRpdGFibGU6IG5vZGUuaXNDb250ZW50RWRpdGFibGUsXG4gICAgICAgICAgICBub2RlVHlwZSAgICAgICAgIDogbm9kZS5ub2RlVHlwZSxcbiAgICAgICAgICAgIG9mZnNldEhlaWdodCAgICAgOiBub2RlLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldExlZnQgICAgICAgOiBub2RlLm9mZnNldExlZnQsXG4gICAgICAgICAgICBvZmZzZXRUb3AgICAgICAgIDogbm9kZS5vZmZzZXRUb3AsXG4gICAgICAgICAgICBvZmZzZXRXaWR0aCAgICAgIDogbm9kZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgICByb2xlICAgICAgICAgICAgIDogbm9kZS5yb2xlLFxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ICAgICA6IG5vZGUuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCAgICAgICA6IG5vZGUuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFRvcCAgICAgICAgOiBub2RlLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNjcm9sbFdpZHRoICAgICAgOiBub2RlLnNjcm9sbFdpZHRoLFxuICAgICAgICAgICAgc3R5bGUgICAgICAgICAgICA6IG5vZGUuc3R5bGU/LmNzc1RleHQsXG4gICAgICAgICAgICB0YWJJbmRleCAgICAgICAgIDogbm9kZS5nZXRBdHRyaWJ1dGU/LigndGFiaW5kZXgnKSA/IG5vZGUudGFiSW5kZXggOiBudWxsLFxuICAgICAgICAgICAgdGFnTmFtZSAgICAgICAgICA6IG5vZGUudGFnTmFtZT8udG9Mb3dlckNhc2UoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdG91Y2ggZXZlbnQgZm91bmQgaW4gdG91Y2hlcyBvciBjaGFuZ2VkVG91Y2hlcyBvZiBhIFRvdWNoRXZlbnRcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge1RvdWNofVxuICAgICAqL1xuICAgIGdldFRvdWNoQ29vcmRzKGV2ZW50KSB7XG4gICAgICAgIGxldCB7dG91Y2hlcywgY2hhbmdlZFRvdWNoZXN9ID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiB0b3VjaGVzPy5bMF0gfHwgY2hhbmdlZFRvdWNoZXM/LlswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ubHkgaW4gdXNlIGlmIE5lby5jb25maWcudXNlU2hhcmVkV29ya2VycyA9IHRydWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkJlZm9yZVVubG9hZChldmVudCkge1xuICAgICAgICBsZXQge01hbmFnZXJ9ID0gTmVvLndvcmtlcjtcblxuICAgICAgICBNYW5hZ2VyLmFwcE5hbWVzLmZvckVhY2goYXBwTmFtZSA9PiB7XG4gICAgICAgICAgICBNYW5hZ2VyLmJyb2FkY2FzdCh7YWN0aW9uOiAnZGlzY29ubmVjdCcsIGFwcE5hbWUsIHdpbmRvd0lkOiBNYW5hZ2VyLndpbmRvd0lkfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0lucHV0RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt0YXJnZXR9ID0gZXZlbnQsXG5cbiAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgLi4ubWUuZ2V0RXZlbnREYXRhKGV2ZW50KSxcbiAgICAgICAgICAgICAgICB2YWxpZDogdGFyZ2V0LmNoZWNrVmFsaWRpdHk/LigpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gaW5wdXQgYW5kIGNoYW5nZSBldmVudHMgY2FuIHBhc3MgYSBGaWxlTGlzdCBmb3IgaW5wdXQgdHlwZSBmaWxlXG4gICAgICAgIGlmICh0YXJnZXQuZmlsZXMpIHtcbiAgICAgICAgICAgIGRhdGEuZmlsZXMgPSB0YXJnZXQuZmlsZXNcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAobWUuZ2V0TW91c2VFdmVudERhdGEoZXZlbnQpKTtcblxuICAgICAgICBtZS50ZXN0UGF0aEluY2x1c2lvbihldmVudCwgcHJldmVudENsaWNrVGFyZ2V0cykgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcChtZS5nZXRNb3VzZUV2ZW50RGF0YShldmVudCkpO1xuXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IG1lLnRlc3RQYXRoSW5jbHVzaW9uKGV2ZW50LCBwcmV2ZW50Q29udGV4dG1lbnVUYXJnZXRzKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRvbUNvbnRlbnRMb2FkZWQoKSB7XG4gICAgICAgIHRoaXMuYWRkR2xvYmFsRG9tTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuZmlyZSgnZG9tQ29udGVudExvYWRlZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uRG91YmxlQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zZW5kTWVzc2FnZVRvQXBwKG1lLmdldE1vdXNlRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgICAgbWUudGVzdFBhdGhJbmNsdXNpb24oZXZlbnQsIHByZXZlbnRDbGlja1RhcmdldHMpICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Gb2N1c0luKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VUb0FwcCh0aGlzLmdldEV2ZW50RGF0YShldmVudCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGb2N1c0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uRm9jdXNPdXQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQXBwKHRoaXMuZ2V0RXZlbnREYXRhKGV2ZW50KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uSGFzaENoYW5nZSgpIHtcbiAgICAgICAgbGV0IHtNYW5hZ2VyfSAgPSBOZW8ud29ya2VyLFxuICAgICAgICAgICAgaGFzaFN0cmluZyA9IGxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpO1xuXG4gICAgICAgIE1hbmFnZXIuc2VuZE1lc3NhZ2UoJ2FwcCcsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2hhc2hDaGFuZ2UnLFxuICAgICAgICAgICAgZGF0YSAgOiB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZXM6IE1hbmFnZXIuYXBwTmFtZXMsXG4gICAgICAgICAgICAgICAgaGFzaCAgICA6IHRoaXMucGFyc2VIYXNoKGhhc2hTdHJpbmcpLFxuICAgICAgICAgICAgICAgIGhhc2hTdHJpbmcsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IE1hbmFnZXIud2luZG93SWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3RhcmdldH0gID0gZXZlbnQsXG4gICAgICAgICAgICB7dGFnTmFtZX0gPSB0YXJnZXQsXG4gICAgICAgICAgICBpc0lucHV0ICAgPSB0YWdOYW1lID09PSAnSU5QVVQnIHx8IHRhZ05hbWUgPT09ICdURVhUQVJFQSc7XG5cbiAgICAgICAgaWYgKGlzSW5wdXQgJiYgZGlzYWJsZWRJbnB1dEtleXNbdGFyZ2V0LmlkXT8uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcChtZS5nZXRLZXlib2FyZEV2ZW50RGF0YShldmVudCkpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmtleSA9PT0gJ1RhYicgJiZcbiAgICAgICAgICAgICAgICBtZS50ZXN0UGF0aEluY2x1c2lvbihldmVudCwgWyduZW8tZ3JpZC1lZGl0b3InLCAnbmVvLXRhYmxlLWVkaXRvciddLCB0cnVlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWlzSW5wdXQgJiZcbiAgICAgICAgICAgICAgICBbJ0Fycm93RG93bicsICdBcnJvd0xlZnQnLCAnQXJyb3dSaWdodCcsICdBcnJvd1VwJ10uaW5jbHVkZXMoZXZlbnQua2V5KSAmJlxuICAgICAgICAgICAgICAgIG1lLnRlc3RQYXRoSW5jbHVzaW9uKGV2ZW50LCBbJ25lby1zZWxlY3Rpb24nXSwgdHJ1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbktleVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VUb0FwcCh0aGlzLmdldEtleWJvYXJkRXZlbnREYXRhKGV2ZW50KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQXBwKHRoaXMuZ2V0TW91c2VFdmVudERhdGEoZXZlbnQpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1vdXNlRW50ZXIoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFwcEV2ZW50ID0gey4uLm1lLmdldE1vdXNlRXZlbnREYXRhKGV2ZW50KSwgZnJvbUVsZW1lbnRJZDogZXZlbnQuZnJvbUVsZW1lbnQ/LmlkIHx8IG51bGwsIHRvRWxlbWVudElkOiBldmVudC50b0VsZW1lbnQ/LmlkIHx8IG51bGx9O1xuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAoYXBwRXZlbnQpO1xuICAgICAgICBtZS5maXJlKCdtb3VzZUVudGVyJywgYXBwRXZlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYXBwRXZlbnQgPSB7Li4ubWUuZ2V0TW91c2VFdmVudERhdGEoZXZlbnQpLCBmcm9tRWxlbWVudElkOiBldmVudC5mcm9tRWxlbWVudD8uaWQgfHwgbnVsbCwgdG9FbGVtZW50SWQ6IGV2ZW50LnRvRWxlbWVudD8uaWQgfHwgbnVsbH07XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2VUb0FwcChhcHBFdmVudCk7XG4gICAgICAgIG1lLmZpcmUoJ21vdXNlTGVhdmUnLCBhcHBFdmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Nb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VUb0FwcCh0aGlzLmdldE1vdXNlRXZlbnREYXRhKGV2ZW50KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uT3JpZW50YXRpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHtvcmllbnRhdGlvbn0gPSBzY3JlZW4sXG4gICAgICAgICAgICB7YW5nbGUsIHR5cGV9ID0gb3JpZW50YXRpb24sXG4gICAgICAgICAgICBsYXlvdXQgICAgICAgID0gYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJztcblxuICAgICAgICBOZW8ud29ya2VyLk1hbmFnZXIuc2VuZE1lc3NhZ2UoJ2FwcCcsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ29yaWVudGF0aW9uQ2hhbmdlJyxcbiAgICAgICAgICAgIGRhdGEgIDoge2FuZ2xlLCBsYXlvdXQsIHR5cGV9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNjcm9sbChldmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2ZpcnN0VG91Y2gsIGxhc3RUb3VjaH0gPSBtZSxcbiAgICAgICAgICAgIHtjbGllbnRIZWlnaHQsIGNsaWVudFdpZHRoLCBzY3JvbGxMZWZ0LCBzY3JvbGxUb3B9ID0gZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAuLi5tZS5nZXRFdmVudERhdGEoZXZlbnQpLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsVG9wXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZpcnN0VG91Y2gpIHtcbiAgICAgICAgICAgIGRhdGEudG91Y2hlcyA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdFRvdWNoOiB7Y2xpZW50WDogZmlyc3RUb3VjaC5jbGllbnRYLCBjbGllbnRZOiBmaXJzdFRvdWNoLmNsaWVudFl9LFxuICAgICAgICAgICAgICAgIGxhc3RUb3VjaCA6IHtjbGllbnRYOiBsYXN0VG91Y2ggLmNsaWVudFgsIGNsaWVudFk6IGxhc3RUb3VjaCAuY2xpZW50WX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dGFyZ2V0fSA9IGV2ZW50LFxuICAgICAgICAgICAgZWxlbWVudCAgPSB0YXJnZXQudHlwZSA/IHRhcmdldCA6IHRhcmdldC5hY3RpdmVFbGVtZW50LFxuICAgICAgICAgICAgcGF0aCwgdGFyZ2V0RGF0YTtcblxuICAgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBwYXRoICAgICAgID0gbWUuZ2V0U2VsZWN0aW9uUGF0aChbXSwgZWxlbWVudCk7XG4gICAgICAgIHRhcmdldERhdGEgPSBtZS5nZXRUYXJnZXREYXRhKGVsZW1lbnQpO1xuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHNlbGVjdGlvbjoge2RpcmVjdGlvbjogZWxlbWVudC5zZWxlY3Rpb25EaXJlY3Rpb24sIGVuZDogZWxlbWVudC5zZWxlY3Rpb25FbmQsIHN0YXJ0OiBlbGVtZW50LnNlbGVjdGlvblN0YXJ0fSxcbiAgICAgICAgICAgIHRhcmdldCAgIDogdGFyZ2V0RGF0YSxcbiAgICAgICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wLFxuICAgICAgICAgICAgdHlwZSAgICAgOiAnc2VsZWN0aW9uY2hhbmdlJ1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25WaXNpYmlsaXR5Y2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIE5lby53b3JrZXIuTWFuYWdlci5zZW5kTWVzc2FnZSgnYXBwJywge1xuICAgICAgICAgICAgYWN0aW9uOiAndmlzaWJpbGl0eUNoYW5nZScsXG4gICAgICAgICAgICBkYXRhICA6IHtcbiAgICAgICAgICAgICAgICBoaWRkZW4gICAgICAgICA6IGRvY3VtZW50LmhpZGRlbixcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5U3RhdGU6IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCAgICAgICA6IE5lby53b3JrZXIuTWFuYWdlci53aW5kb3dJZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25XaGVlbChldmVudCkge1xuICAgICAgICBsZXQgdGFyZ2V0ICAgICAgICA9IHRoaXMudGVzdFBhdGhJbmNsdXNpb24oZXZlbnQsIGdsb2JhbFdoZWVsVGFyZ2V0cyksXG4gICAgICAgICAgICBwcmV2ZW50VXBkYXRlID0gZmFsc2UsXG4gICAgICAgICAgICB0YXJnZXRDbHM7XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0Q2xzID0gdGFyZ2V0LmNscztcblxuICAgICAgICAgICAgaWYgKGdsb2JhbFdoZWVsVGFyZ2V0c0J1ZmZlclt0YXJnZXQuY2xzXSkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChsYXN0V2hlZWxFdmVudC5kYXRlICYmIGxhc3RXaGVlbEV2ZW50LnRhcmdldCA9PT0gdGFyZ2V0Q2xzICYmIGRhdGUgLSBsYXN0V2hlZWxFdmVudC5kYXRlIDwgZ2xvYmFsV2hlZWxUYXJnZXRzQnVmZmVyW3RhcmdldENsc10pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudFVwZGF0ZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGxhc3RXaGVlbEV2ZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRDbHNcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcHJldmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCB7ZGVsdGFYLCBkZWx0YVksIGRlbHRhWn0gPSBldmVudDtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VUb0FwcCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0RXZlbnREYXRhKGV2ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiB0YXJnZXQubm9kZS5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFdpZHRoIDogdGFyZ2V0Lm5vZGUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVosXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgIDogdGFyZ2V0Lm5vZGUuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wICAgOiB0YXJnZXQubm9kZS5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdsb2JhbFdoZWVsVGFyZ2V0c0tlZXBFdmVudC5pbmNsdWRlcyh0YXJnZXRDbHMpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRE9NUmVjdHMgYXJlIG5vdCBzcHJlYWRhYmxlID0+IHsuLi5ET01SZWN0fSA9PiB7fVxuICAgICAqIEBwYXJhbSB7RE9NUmVjdH0gcmVjdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgcGFyc2VEb21SZWN0KHJlY3QpIHtcbiAgICAgICAgbGV0IHtib3R0b20sIGhlaWdodCwgbGVmdCwgcmlnaHQsIHRvcCwgd2lkdGgsIHgsIHl9ID0gcmVjdDtcblxuICAgICAgICByZXR1cm4ge2JvdHRvbSwgaGVpZ2h0LCBsZWZ0LCByaWdodCwgdG9wLCB3aWR0aCwgeCwgeX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGFtcGxlIGZvciBBcnJheSB2YWx1ZXM6IFwiY2F0ZWdvcmllc1tdPXRlc3QxJmNhdGVnb3JpZXNbXT10ZXN0MlwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgcGFyc2VIYXNoKHN0cikge1xuICAgICAgICBpZiAoc3RyID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGllY2VzID0gc3RyLnNwbGl0KCcmJyksXG4gICAgICAgICAgICBkYXRhICAgPSB7fSxcbiAgICAgICAgICAgIGksIGtleSwgcGFydHMsIHZhbHVlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnRzID0gcGllY2VzW2ldLnNwbGl0KCc9Jyk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCgnJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2V5ICAgPSBkZWNvZGVVUklDb21wb25lbnQocGFydHNbMF0pO1xuICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQocGFydHNbMV0pO1xuXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ1tdJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygwLCBrZXkuaW5kZXhPZignW10nKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YVtrZXldLnB1c2godGhpcy5wYXJzZVZhbHVlKHZhbHVlKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gdGhpcy5wYXJzZVZhbHVlKHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IHBhcnNlSGFzaCB0byBjb252ZXJ0IHRva2VucyBpbnRvIGJvb2xlYW4gb3IgbnVtYmVyIHR5cGVzIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufE51bWJlcnxTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHBhcnNlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IHBhcnNlSW50KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBkYXRhLmNoYXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKi9cbiAgICByZWdpc3RlckRpc2FibGVkSW5wdXRDaGFycyhkYXRhKSB7XG4gICAgICAgIGRpc2FibGVkSW5wdXRLZXlzW2RhdGEuaWRdID0gZGF0YS5jaGFyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGRhdGEuY2xzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubmFtZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJldmVudERlZmF1bHRUYXJnZXRzKGRhdGEpIHtcbiAgICAgICAgbGV0IHByZXZlbnRBcnJheTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5jbHMpKSB7XG4gICAgICAgICAgICBkYXRhLmNscyA9IFtkYXRhLmNsc107XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGRhdGEubmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICAgICAgICAgIHByZXZlbnRBcnJheSA9IHByZXZlbnRDbGlja1RhcmdldHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICAgICAgICAgICAgcHJldmVudEFycmF5ID0gcHJldmVudENvbnRleHRtZW51VGFyZ2V0cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuY2xzLmZvckVhY2goY2xzID0+IHtcbiAgICAgICAgICAgICFwcmV2ZW50QXJyYXkuaW5jbHVkZXMoY2xzKSAmJiBwcmV2ZW50QXJyYXkucHVzaChjbHMpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIHBhcnNlZCBldmVudCBkYXRhIHRvIHRoZSBhcHAgd29ya2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2VUb0FwcChkYXRhKSB7XG4gICAgICAgIE5lby53b3JrZXIuTWFuYWdlci5zZW5kTWVzc2FnZSgnYXBwJywge1xuICAgICAgICAgICAgYWN0aW9uICAgOiAnZG9tRXZlbnQnLFxuICAgICAgICAgICAgZXZlbnROYW1lOiBkYXRhLnR5cGUsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVsbG8gPGZvbz53b3JsZCB0aG9yc3RlbiEgMyA8IDQgYW5kIDUgPiAzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdHJpcEh0bWwodmFsdWUpIHtcbiAgICAgICAgbGV0IGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcodmFsdWUsICd0ZXh0L2h0bWwnKTtcblxuICAgICAgICByZXR1cm4gZG9jLmJvZHkudGV4dENvbnRlbnQgfHwgJydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0QXJyYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVzdFN1YnN0cmluZz1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8Qm9vbGVhbn0gdGFyZ2V0IGNscyAmIG5vZGUgaWYgZm91bmQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHRlc3RQYXRoSW5jbHVzaW9uKGV2ZW50LCB0YXJnZXRBcnJheSwgdGVzdFN1YnN0cmluZz1mYWxzZSkge1xuICAgICAgICBsZXQgY291bnRUYXJnZXRzID0gdGFyZ2V0QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgcGF0aCAgICAgICAgID0gZXZlbnQucGF0aCB8fCBldmVudC5jb21wb3NlZFBhdGgoKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIGosIG5vZGU7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbm9kZSA9IHBhdGhbaV07XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudFRhcmdldHM7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGVzdFN1YnN0cmluZyAmJiBub2RlLmNsYXNzTGlzdD8udmFsdWU/LmluY2x1ZGVzKHRhcmdldEFycmF5W2pdKSB8fFxuICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdD8uY29udGFpbnModGFyZ2V0QXJyYXlbal0pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y2xzOiB0YXJnZXRBcnJheVtqXSwgbm9kZX1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICovXG4gICAgdW5yZWdpc3RlckRpc2FibGVkSW5wdXRDaGFycyhkYXRhKSB7XG4gICAgICAgIGRlbGV0ZSBkaXNhYmxlZElucHV0S2V5c1tkYXRhLmlkXVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRG9tRXZlbnRzKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG5jb25zdCBmb2N1c2FibGVUYWdzID0ge1xuICAgIEJPRFkgICAgOiAxLFxuICAgIEJVVFRPTiAgOiAxLFxuICAgIEVNQkVEICAgOiAxLFxuICAgIElGUkFNRSAgOiAxLFxuICAgIElOUFVUICAgOiAxLFxuICAgIE9CSkVDVCAgOiAxLFxuICAgIFNFTEVDVCAgOiAxLFxuICAgIFRFWFRBUkVBOiAxXG59O1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFpbi5Eb21VdGlsc1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBEb21VdGlscyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1haW4uRG9tVXRpbHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYWluLkRvbVV0aWxzJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWxvZ291cyB0byB0aGUgYEhUTUxFbGVtZW50YCBgY2xvc2VzdGAgbWV0aG9kLiBTZWFyY2hlcyBzdGFydGluZyBhdCB0aGUgcGFzc2VkIGVsZW1lbnQgZm9yXG4gICAgICogYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHBhc3NlZCBgZmlsdGVyRm5gIHJldHVybnMgYHRydWVgXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJGbiBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYHRydWVgIHdoZW4gdGhlIGRlc2lyZWQgZWxlbWVudCBpcyByZWFjaGVkLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtsaW1pdF0gVGhlIGVsZW1lbnQgdG8gc3RvcCBhdC4gVGhpcyBpcyAqbm90KiBjb25zaWRlcmVkIGZvciBtYXRjaGluZy5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgc3RhdGljIGNsb3Nlc3QoZWwsIGZpbHRlckZuLCBsaW1pdCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgd2hpbGUgKGVsPy5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWwgIT09IGxpbWl0KSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyRm4oZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50Tm9kZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGlzRm9jdXNhYmxlKGUpIHtcbiAgICAgICAgLy8gTWF5IGJlIHVzZWQgYXMgYSBzY29wZWxlc3MgY2FsbGJhY2ssIHNvIHVzZSBcIkRvbVV0aWxzXCIsIG5vdCBcInRoaXNcIlxuICAgICAgICByZXR1cm4gRG9tVXRpbHMuaXNUYWJiYWJsZShlKSB8fCBOdW1iZXIoZS5nZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JykpIDwgMFxuICAgIH1cblxuICAgIHN0YXRpYyBpc1RhYmJhYmxlKGUpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHsgbm9kZU5hbWUgfSA9IGUsXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgPSBnZXRDb21wdXRlZFN0eWxlKGUpLFxuICAgICAgICAgICAgdGFiSW5kZXggICAgID0gZS5nZXRBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG5cbiAgICAgICAgLy8gSGlkZGVuIGVsZW1lbnRzIGFyZSBub3QgdGFiYmFibGUuXG4gICAgICAgIC8vIE5lZ2F0aXZlIHRhYkluZGV4IGFsc28gbWVhbnMgbm90IHRhYmJhYmxlIChUaG91Z2ggc3RpbGwgZm9jdXNhYmxlKVxuICAgICAgICBpZiAoIWUuaXNDb25uZWN0ZWQgfHwgIWUub2Zmc2V0UGFyZW50IHx8IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ2hpZGRlbicgfHwgTnVtYmVyKHRhYkluZGV4KSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvY3VzYWJsZVRhZ3Nbbm9kZU5hbWVdIHx8XG4gICAgICAgICAgICAoKG5vZGVOYW1lID09PSAnQScgfHwgbm9kZU5hbWUgPT09ICdMSU5LJykgJiYgISFlLmhyZWYpIHx8XG4gICAgICAgICAgICAodGFiSW5kZXggIT0gbnVsbCAmJiBOdW1iZXIodGFiSW5kZXgpID49IDApIHx8XG4gICAgICAgICAgICBlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbG9nb3VzIHRvIHRoZSBgSFRNTEVsZW1lbnRgIGBxdWVyeVNlbGVjdG9yYCBtZXRob2QuIFNlYXJjaGVzIHRoZSBwYXNzZWQgZWxlbWVudFxuICAgICAqIGFuZCBhbGwgZGVzY2VuZGFudHMgZm9yIHRoZSBmaXJzdCBlbGVtZW50IGZvciB3aGljaCB0aGUgcGFzc2VkIGBmaWx0ZXJGbmAgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGVsZW1lbnQgdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJGbiBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYHRydWVgIHdoZW4gdGhlIGRlc2lyZWQgZWxlbWVudCBpcyByZWFjaGVkLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgcXVlcnkoZWwsIGZpbHRlckZuKSB7XG4gICAgICAgIHJldHVybiBbZWwsIC4uLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKV0uZmluZChmaWx0ZXJGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbG9nb3VzIHRvIHRoZSBgSFRNTEVsZW1lbnRgIGBxdWVyeVNlbGVjdG9yQWxsYCBtZXRob2QuIFNlYXJjaGVzIHRoZSBwYXNzZWQgZWxlbWVudFxuICAgICAqIGFuZCBhbGwgZGVzY2VuZGFudHMgZm9yIGFsbCBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHBhc3NlZCBgZmlsdGVyRm5gIHJldHVybnMgYHRydWVgLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIFRoZSBlbGVtZW50IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyRm4gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGB0cnVlYCB3aGVuIGEgZGVzaXJlZCBlbGVtZW50IGlzIHJlYWNoZWQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119IEFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzXG4gICAgICovXG4gICAgc3RhdGljIHF1ZXJ5QWxsKGVsLCBmaWx0ZXJGbikge1xuICAgICAgICByZXR1cm4gW2VsLCAuLi5lbC5xdWVyeVNlbGVjdG9yQWxsKCcqJyldLmZpbHRlcihmaWx0ZXJGbilcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERvbVV0aWxzKTtcbiIsInZhciBtYXAgPSB7XG5cdFwiLi9BbUNoYXJ0cy5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9BbUNoYXJ0cy5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fQW1DaGFydHNfbWpzXCJcblx0XSxcblx0XCIuL0FuYWx5dGljc0J5R29vZ2xlLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0FuYWx5dGljc0J5R29vZ2xlLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9BbmFseXRpY3NCeUdvb2dsZV9tanNcIlxuXHRdLFxuXHRcIi4vQmFzZS5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9CYXNlLm1qc1wiLFxuXHRcdFwic3JjX21haW5fYWRkb25fQmFzZV9tanNcIlxuXHRdLFxuXHRcIi4vQ2VzaXVtSlMubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vQ2VzaXVtSlMubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX0Nlc2l1bUpTX21qc1wiXG5cdF0sXG5cdFwiLi9DbG9uZU5vZGUubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vQ2xvbmVOb2RlLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9DbG9uZU5vZGVfbWpzXCJcblx0XSxcblx0XCIuL0Nvb2tpZS5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9Db29raWUubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX0Nvb2tpZV9tanNcIlxuXHRdLFxuXHRcIi4vRG9jdW1lbnRIZWFkLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0RvY3VtZW50SGVhZC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fRG9jdW1lbnRIZWFkX21qc1wiXG5cdF0sXG5cdFwiLi9EcmFnRHJvcC5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9EcmFnRHJvcC5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fRHJhZ0Ryb3BfbWpzXCJcblx0XSxcblx0XCIuL0V2ZW50U2ltdWxhdG9yLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0V2ZW50U2ltdWxhdG9yLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9FdmVudFNpbXVsYXRvcl9tanNcIlxuXHRdLFxuXHRcIi4vRmlsZVN5c3RlbUFjY2Vzcy5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9GaWxlU3lzdGVtQWNjZXNzLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9GaWxlU3lzdGVtQWNjZXNzX21qc1wiXG5cdF0sXG5cdFwiLi9Hb29nbGVNYXBzLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0dvb2dsZU1hcHMubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX0dvb2dsZU1hcHNfbWpzXCJcblx0XSxcblx0XCIuL0hpZ2hsaWdodEpTLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL0hpZ2hsaWdodEpTLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9IaWdobGlnaHRKU19tanNcIlxuXHRdLFxuXHRcIi4vSW50ZXJzZWN0aW9uT2JzZXJ2ZXIubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vSW50ZXJzZWN0aW9uT2JzZXJ2ZXIubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX0ludGVyc2VjdGlvbk9ic2VydmVyX21qc1wiXG5cdF0sXG5cdFwiLi9Mb2NhbFN0b3JhZ2UubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vTG9jYWxTdG9yYWdlLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9Mb2NhbFN0b3JhZ2VfbWpzXCJcblx0XSxcblx0XCIuL01hcGJveEdMLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL01hcGJveEdMLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9NYXBib3hHTF9tanNcIlxuXHRdLFxuXHRcIi4vTWFya2Rvd24ubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vTWFya2Rvd24ubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX01hcmtkb3duX21qc1wiXG5cdF0sXG5cdFwiLi9Nb25hY29FZGl0b3IubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vTW9uYWNvRWRpdG9yLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9Nb25hY29FZGl0b3JfbWpzXCJcblx0XSxcblx0XCIuL013Yy5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9Nd2MubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX013Y19tanNcIlxuXHRdLFxuXHRcIi4vTmF2aWdhdG9yLm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL05hdmlnYXRvci5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fTmF2aWdhdG9yX21qc1wiXG5cdF0sXG5cdFwiLi9PcGVuU3RyZWV0TWFwcy5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9PcGVuU3RyZWV0TWFwcy5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fT3BlblN0cmVldE1hcHNfbWpzXCJcblx0XSxcblx0XCIuL1BvcG92ZXIubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vUG9wb3Zlci5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fUG9wb3Zlcl9tanNcIlxuXHRdLFxuXHRcIi4vUHJlZml4RmllbGQubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vUHJlZml4RmllbGQubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX1ByZWZpeEZpZWxkX21qc1wiXG5cdF0sXG5cdFwiLi9SZXNpemVPYnNlcnZlci5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9SZXNpemVPYnNlcnZlci5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fUmVzaXplT2JzZXJ2ZXJfbWpzXCJcblx0XSxcblx0XCIuL1Njcm9sbFN5bmMubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vU2Nyb2xsU3luYy5tanNcIixcblx0XHRcInZlbmRvcnMtc3JjX21haW5fYWRkb25fU2Nyb2xsU3luY19tanNcIlxuXHRdLFxuXHRcIi4vU2VydmVyU2lkZVJlbmRlcmluZy5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9TZXJ2ZXJTaWRlUmVuZGVyaW5nLm1qc1wiLFxuXHRcdFwic3JjX21haW5fYWRkb25fU2VydmVyU2lkZVJlbmRlcmluZ19tanNcIlxuXHRdLFxuXHRcIi4vU2VydmljZVdvcmtlci5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9TZXJ2aWNlV29ya2VyLm1qc1wiLFxuXHRcdFwidmVuZG9ycy1zcmNfbWFpbl9hZGRvbl9TZXJ2aWNlV29ya2VyX21qc1wiXG5cdF0sXG5cdFwiLi9TdHlsZXNoZWV0Lm1qc1wiOiBbXG5cdFx0XCIuL3NyYy9tYWluL2FkZG9uL1N0eWxlc2hlZXQubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX1N0eWxlc2hlZXRfbWpzXCJcblx0XSxcblx0XCIuL1dlYkNvbXBvbmVudC5tanNcIjogW1xuXHRcdFwiLi9zcmMvbWFpbi9hZGRvbi9XZWJDb21wb25lbnQubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX1dlYkNvbXBvbmVudF9tanNcIlxuXHRdLFxuXHRcIi4vV2luZG93UG9zaXRpb24ubWpzXCI6IFtcblx0XHRcIi4vc3JjL21haW4vYWRkb24vV2luZG93UG9zaXRpb24ubWpzXCIsXG5cdFx0XCJ2ZW5kb3JzLXNyY19tYWluX2FkZG9uX1dpbmRvd1Bvc2l0aW9uX21qc1wiXG5cdF1cbn07XG5mdW5jdGlvbiB3ZWJwYWNrQXN5bmNDb250ZXh0KHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHRcdHRocm93IGU7XG5cdFx0fSk7XG5cdH1cblxuXHR2YXIgaWRzID0gbWFwW3JlcV0sIGlkID0gaWRzWzBdO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5lKGlkc1sxXSkudGhlbigoKSA9PiB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xuXHR9KTtcbn1cbndlYnBhY2tBc3luY0NvbnRleHQua2V5cyA9ICgpID0+IChPYmplY3Qua2V5cyhtYXApKTtcbndlYnBhY2tBc3luY0NvbnRleHQuaWQgPSBcIi4vc3JjL21haW4vYWRkb24gbGF6eSByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKlxcXFwubWpzJFwiO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQXN5bmNDb250ZXh0OyIsImltcG9ydCBCYXNlIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIFdpbGwgZ2V0IGltcG9ydGVkIGluIGNhc2UgTmVvLmNvbmZpZy5oYXNUb3VjaEV2ZW50cyA9PT0gdHJ1ZVxuICogQGNsYXNzIE5lby5tYWluLm1peGluLlRvdWNoRG9tRXZlbnRzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFRvdWNoRG9tRXZlbnRzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFpbi5taXhpbi5Ub3VjaERvbUV2ZW50cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1haW4ubWl4aW4uVG91Y2hEb21FdmVudHMnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgb25Ub3VjaENhbmNlbChldmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAobWUuZ2V0RXZlbnREYXRhKGV2ZW50KSk7XG4gICAgICAgIG1lLmZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgICBtZS5sYXN0VG91Y2ggID0gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqL1xuICAgIG9uVG91Y2hFbmQoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zZW5kTWVzc2FnZVRvQXBwKG1lLmdldEV2ZW50RGF0YShldmVudCkpO1xuICAgICAgICBtZS5maXJzdFRvdWNoID0gbnVsbDtcbiAgICAgICAgbWUubGFzdFRvdWNoICA9IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblRvdWNoRW50ZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQXBwKHRoaXMuZ2V0RXZlbnREYXRhKGV2ZW50KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblRvdWNoTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVRvQXBwKHRoaXMuZ2V0RXZlbnREYXRhKGV2ZW50KSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblRvdWNoTW92ZShldmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSAgICAgICAgPSBtZS5nZXRFdmVudERhdGEoZXZlbnQpLFxuICAgICAgICAgICAgdG91Y2ggICAgICAgPSBldmVudC50b3VjaGVzWzBdLFxuICAgICAgICAgICAge2xhc3RUb3VjaH0gPSBtZTtcblxuICAgICAgICBpZiAobGFzdFRvdWNoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgICAgICAgICAgICBkZWx0YVg6IHRvdWNoLmNsaWVudFggLSBsYXN0VG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgICAgICBkZWx0YVk6IHRvdWNoLmNsaWVudFkgLSBsYXN0VG91Y2guY2xpZW50WVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAoZGF0YSk7XG5cbiAgICAgICAgbWUubGFzdFRvdWNoID0gdG91Y2g7XG5cbiAgICAgICAgaWYgKG1lLnRlc3RQYXRoSW5jbHVzaW9uKGV2ZW50LCBbJ25lby1oZWxpeCddKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZmlyc3RUb3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgIG1lLmxhc3RUb3VjaCAgPSBldmVudC50b3VjaGVzWzBdO1xuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlVG9BcHAobWUuZ2V0RXZlbnREYXRhKGV2ZW50KSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvdWNoRG9tRXZlbnRzKTtcbiIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL2NvbGxlY3Rpb24vQmFzZS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRoZSBvdGhlciBtYW5hZ2VyIGNsYXNzZXNcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29sbGVjdGlvbi5CYXNlXG4gKi9cbmNsYXNzIE1hbmFnZXIgZXh0ZW5kcyBDb2xsZWN0aW9ue1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuQmFzZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRCeUlkKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCAmJiB0aGlzLmdldChpZCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICovXG4gICAgcmVnaXN0ZXIoaXRlbSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5nZXQoaXRlbS5pZCkpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcignVHJ5aW5nIHRvIGNyZWF0ZSBhbiBpdGVtIHdpdGggYW4gYWxyZWFkeSBleGlzdGluZyBpZCcsIGl0ZW0sIG1lLmdldChpdGVtLmlkKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnB1c2goaXRlbSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aW9uIGl0ZW0gcGFzc2VkIGJ5IHJlZmVyZW5jZSBvciBrZXlcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGl0ZW1cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1hbmFnZXIpO1xuIiwiaW1wb3J0IEJhc2VNYW5hZ2VyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5DbGFzc0hpZXJhcmNoeVxuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICpcbiAqIFRoaXMgbWFuYWdlciBtYWludGFpbnMgYSByZWdpc3RyeSBvZiBhbGwgY2xhc3NlcyBkZWZpbmVkIHdpdGhpbiB0aGUgTmVvLm1qcyBmcmFtZXdvcmsncyBjdXJyZW50IHJlYWxtIChtYWluIG9yIHdvcmtlciksXG4gKiBpbmNsdWRpbmcgdGhlaXIgaW5oZXJpdGFuY2UgcmVsYXRpb25zaGlwcyBhbmQga2V5IG1ldGFkYXRhLlxuICogRWFjaCByZWdpc3RlcmVkIGl0ZW0gKHZhbHVlIGluIHRoZSBtYW5hZ2VyJ3Mgc3RvcmUpIGhhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENsYXNzSGllcmFyY2h5SW5mb1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGNsYXNzTmFtZSAtIFRoZSBmdWxsIE5lby5tanMgY2xhc3MgbmFtZSAoZS5nLiwgJ05lby5jb21wb25lbnQuQmFzZScpLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxPYmplY3R9IG1vZHVsZSAtIFRoZSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYgKGZvciBub24tc2luZ2xldG9ucylcbiAqIG9yIHRoZSBpbnN0YW50aWF0ZWQgc2luZ2xldG9uIG9iamVjdCAoZm9yIHNpbmdsZXRvbnMpLlxuICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gbnR5cGUgLSBUaGUgbnR5cGUgb2YgdGhlIGNsYXNzIGlmIGRlZmluZWQgKGUuZy4sICdidXR0b24nLCAnY29udGFpbmVyJyksIG90aGVyd2lzZSBgbnVsbGAuXG4gKiBAcHJvcGVydHkge1N0cmluZ3xudWxsfSBwYXJlbnRDbGFzc05hbWUgLSBUaGUgZnVsbCBjbGFzcyBuYW1lIG9mIGl0cyBkaXJlY3QgcGFyZW50IGNsYXNzLFxuICogb3IgYG51bGxgIGlmIGl0J3MgYSB0b3AtbGV2ZWwgY2xhc3MgKGUuZy4sICdOZW8uY29yZS5CYXNlJykuXG4gKi9cbmNsYXNzIENsYXNzSGllcmFyY2h5IGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuQ2xhc3NIaWVyYXJjaHknXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkNsYXNzSGllcmFyY2h5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHk9J2NsYXNzTmFtZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHk6ICdjbGFzc05hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZXMgb2YgaXNBKCkgY2FsbHNcbiAgICAgKiBAbWVtYmVyIHtNYXB9IGlzQVF1ZXJ5TWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0FRdWVyeU1hcCA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY29uc3VtZVRlbXBNYXAoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFsbCBjbGFzc2VzIHRoYXQgZ290IGFwcGxpZWQgdG8gdGhlIE5lbyBuYW1lc3BhY2UgYmVmb3JlIHRoaXMgaW5zdGFuY2UgZ290IGNyZWF0ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29uc3VtZVRlbXBNYXAoKSB7XG4gICAgICAgIGlmIChOZW8uY2xhc3NIaWVyYXJjaHlNYXApIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKE9iamVjdC52YWx1ZXMoTmVvLmNsYXNzSGllcmFyY2h5TWFwKSk7XG4gICAgICAgICAgICBkZWxldGUgTmVvLmNsYXNzSGllcmFyY2h5TWFwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCb3RoIHBhcmFtcyByZXByZXNlbnQgY2xhc3NOYW1lcy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgdXNlIGNhc2VzOlxuICAgICAqIC0gaXNBKCdOZW8uYnV0dG9uLk1lbnUnLCAgICAnTmVvLmJ1dHRvbi5CYXNlJykgICAgPT4gdHJ1ZVxuICAgICAqIC0gaXNBKCdOZW8uYnV0dG9uLkJhc2UnLCAgICAnTmVvLmJ1dHRvbi5NZW51JykgICAgPT4gZmFsc2VcbiAgICAgKiAtIGlzQSgnTmVvLmJ1dHRvbi5CYXNlJywgICAgJ05lby5jb21wb25lbnQuQmFzZScpID0+IHRydWVcbiAgICAgKiAtIGlzQSgnTmVvLmNvbXBvbmVudC5CYXNlJywgJ05lby5jb3JlLkJhc2UnKSAgICAgID0+IHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVzY2VuZGFudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbmNlc3RvclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzQShkZXNjZW5kYW50LCBhbmNlc3Rvcikge1xuICAgICAgICBpZiAoZGVzY2VuZGFudCA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyZW50ICAgICAgICA9IGRlc2NlbmRhbnQsXG4gICAgICAgICAgICB7aXNBUXVlcnlNYXB9ID0gdGhpcyxcbiAgICAgICAgICAgIHF1ZXJ5TmFtZSAgICAgPSBgJHtkZXNjZW5kYW50fSwke2FuY2VzdG9yfWAsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSAgID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzQVF1ZXJ5TWFwLmhhcyhxdWVyeU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBUXVlcnlNYXAuZ2V0KHF1ZXJ5TmFtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgPSB0aGlzLmdldChwYXJlbnQpPy5wYXJlbnRDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IGNvbXBvbmVudC5CYXNlIGRpcmVjdGx5IGV4dGVuZHMgY29yZS5CYXNlXG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSAnTmVvLmNvbXBvbmVudC5CYXNlJyAmJiBhbmNlc3RvciAhPT0gJ05lby5jb3JlLkJhc2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSAnTmVvLmNvcmUuQmFzZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpc0FRdWVyeU1hcC5zZXQocXVlcnlOYW1lLCByZXR1cm5WYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDbGFzc0hpZXJhcmNoeSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQXJyYXlcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgTmVvQXJyYXkgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkFycmF5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5BcnJheSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kIGFzIGR1cGxpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBpdGVtcyB3aGljaCBhcmUgcHJlc2VudCBpbiBhcnJheTEsIGJ1dCBub3QgaW4gYXJyYXkyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkxPVtdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkyPVtdXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBkaWZmZXJlbmNlKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gIWFycmF5Mi5pbmNsdWRlcyhpdGVtKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGl0ZW0gaXMgaW5jbHVkZWQgYnkgcmVmZXJlbmNlIGluc2lkZSB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzSXRlbShhcnIsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFyci5pbmNsdWRlcyhpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gaXRlbSBvciBBcnJheSBvZiBpdGVtcyB0byBhbiBhcnJheSBpbiBjYXNlIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICogRHVwbGljYXRlcyB3aWxsIG9ubHkgZ2V0IG1hdGNoZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIGluc2VydChhcnIsIGluZGV4LCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSBpdGVtcy5sZW5ndGggLTEsXG4gICAgICAgICAgICBpICAgPSBsZW4sXG4gICAgICAgICAgICBjdXJyZW50SW5kZXgsIGl0ZW07XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBiYWNrd2FyZHNcbiAgICAgICAgZm9yICg7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmUoYXJyLCBjdXJyZW50SW5kZXgsIGluZGV4KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gYXJyYXkxIGFuZCBhcnJheTJcbiAgICAgKiBPbmx5IHN1cHBvcnRzIHByaW1pdGl2ZSBpdGVtc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5MT1bXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5Mj1bXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJzZWN0aW9uKGFycmF5MT1bXSwgYXJyYXkyPVtdKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuZmlsdGVyKGl0ZW0gPT4gYXJyYXkyLmluY2x1ZGVzKGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGl0ZW0gaW5zaWRlIGFyciBmcm9tIGZyb21JbmRleCB0byB0b0luZGV4XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgc3RhdGljIG1vdmUoYXJyLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb21JbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tSW5kZXggPSBhcnIubGVuZ3RoIC0gMVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyLnNwbGljZSh0b0luZGV4LCAwLCBhcnIuc3BsaWNlKGZyb21JbmRleCwgMSlbMF0pO1xuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGZyb20gYW4gYXJyYXkuIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHsqfSBpdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmUoYXJyLCBpdGVtcykge1xuICAgICAgICBsZXQgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgaW5kZXggPiAtMSAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNvbWJpbmUgYWRkICYgcmVtb3ZlIGluIG9uZSBjYWxsLlxuICAgICAqIFlvdSBjYW4gcGFzcyBzaW5nbGUgaXRlbXMgb3IgYW4gYXJyYXkgb2YgaXRlbXMgdG8gYWRkIG9yIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IHJlbW92ZUl0ZW1zXG4gICAgICogQHBhcmFtIHsqfSBhZGRJdGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVBZGQoYXJyLCByZW1vdmVJdGVtcywgYWRkSXRlbXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoYXJyLCByZW1vdmVJdGVtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhcnIsIGFkZEl0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5IGluIGNhc2UgaXQgZG9lcyBleGlzdCwgb3RoZXJ3aXNlIGFkZHMgaXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthZGRdXG4gICAgICovXG4gICAgc3RhdGljIHRvZ2dsZShhcnIsIGl0ZW0sIGFkZCA9ICF0aGlzLmhhc0l0ZW0oYXJyLCBpdGVtKSkge1xuICAgICAgICByZXR1cm4gdGhpc1thZGQgPyAnYWRkJyA6ICdyZW1vdmUnXShhcnIsIGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgaXRlbXMgd2hpY2ggYXJlIHByZXNlbnQgaW4gdGhlIHBhc3NlZCBhcnJheXMuXG4gICAgICogTXVsdGlwbGUgYXJyYXlzIG1heSBiZSBwYXNzZWQuXG4gICAgICogT25seSBzdXBwb3J0cyBwcmltaXRpdmUgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgc3RhdGljIHVuaW9uKCkge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoQXJyYXkucHJvdG90eXBlLmNvbmNhdCguLi5hcmd1bWVudHMpKV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gb3IgQXJyYXkgb2YgaXRlbXMgdG8gYW4gYXJyYXkgaW4gY2FzZSBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqIE9ubHkgcHJpbWl0aXZlIGl0ZW1zIHdpbGwgZ2V0IGZvdW5kIGFzIGR1cGxpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1zXG4gICAgICovXG4gICAgc3RhdGljIHVuc2hpZnQoYXJyLCBpdGVtcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtpdGVtc11cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGFyci51bnNoaWZ0KGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcnJcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE5lb0FycmF5KTtcbiIsImNvbnN0IG9yaWdpbmFsTWV0aG9kU3ltYm9sID0gU3ltYm9sKCdvcmlnaW5hbE1ldGhvZCcpO1xuY29uc3Qgc2VxdWVuY2VkRm5zU3ltYm9sICAgPSBTeW1ib2woJ3NlcXVlbmNlZEZucycpO1xuXG4vKipcbiAqIEFwcGVuZCBhcmdzIGluc3RlYWQgb2YgcHJlcGVuZGluZyB0aGVtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kQXBwZW5kKGZuLCBzY29wZSkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuc2xpY2UoMik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShzY29wZSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmNvbmNhdChhcmdzKSlcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gc2NvcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheT0zMDBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihjYWxsYmFjaywgc2NvcGUsIGRlbGF5PTMwMCkge1xuICAgIGxldCB0aW1lb3V0SWQ7XG5cbiAgICBjb25zdCB3cmFwcGVyID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAvLyBjYWxsYmFjayBpbnZvY2F0aW9uIGNvbWVzIFwiZGVsYXlcIiBtcyBhZnRlciB0aGUgbGFzdCBjYWxsIHRvIHdyYXBwZXJcbiAgICAgICAgLy8gc28gY2FuY2VsIGFueSBwZW5kaW5nIGludm9jYXRpb24uXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICAgIHdyYXBwZXIuaXNQZW5kaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICB3cmFwcGVyLmlzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpXG4gICAgICAgIH0sIGRlbGF5KVxuICAgIH07XG5cbiAgICB3cmFwcGVyLmNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgd3JhcHBlci5pc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICB9O1xuXG4gICAgcmV0dXJuIHdyYXBwZXJcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCBmb3IgZnVuY3Rpb25zIHdpdGggMSBwYXJhbSB3aGVyZSB0aGUgaW50ZXJjZXB0b3IgY2FuIGNoYW5nZSB0aGUgdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRNZXRob2ROYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRGdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRhcmdldFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW50ZXJjZXB0b3IodGFyZ2V0LCB0YXJnZXRNZXRob2ROYW1lLCBpbnRlcmNlcHRGdW5jdGlvbiwgc2NvcGUpIHtcbiAgICBsZXQgdGFyZ2V0TWV0aG9kID0gdGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdO1xuXG4gICAgcmV0dXJuICh0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0TWV0aG9kLmNhbGwodGFyZ2V0LCBpbnRlcmNlcHRGdW5jdGlvbi5jYWxsKHNjb3BlIHx8IHRhcmdldCwgdmFsdWUpKVxuICAgIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZSh0YXJnZXQsIG1ldGhvZE5hbWUsIGZuLCBzY29wZSkge1xuICAgIGxldCBjdXJyZW50TWV0aG9kID0gdGFyZ2V0W21ldGhvZE5hbWVdLFxuICAgICAgICB3cmFwcGVyO1xuXG4gICAgaWYgKGN1cnJlbnRNZXRob2QgJiYgY3VycmVudE1ldGhvZFtzZXF1ZW5jZWRGbnNTeW1ib2xdKSB7XG4gICAgICAgIC8vIEFscmVhZHkgYSBzZXF1ZW5jZWQgbWV0aG9kLCBhZGQgdG8gaXRzIGxpc3RcbiAgICAgICAgd3JhcHBlciA9IGN1cnJlbnRNZXRob2Q7XG4gICAgICAgIHdyYXBwZXJbc2VxdWVuY2VkRm5zU3ltYm9sXS5wdXNoKHtmbiwgc2NvcGV9KVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgc2VxdWVuY2luZyB0aGlzIG1ldGhvZFxuICAgICAgICBsZXQgb3JpZ2luYWxNZXRob2QgPSBjdXJyZW50TWV0aG9kIHx8IE5lby5lbXB0eUZuO1xuXG4gICAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIENhbGwgdGhlIG9yaWdpbmFsIG1ldGhvZFxuXG4gICAgICAgICAgICAvLyBDYWxsIGFsbCBzZXF1ZW5jZWQgZnVuY3Rpb25zXG4gICAgICAgICAgICB3cmFwcGVyW3NlcXVlbmNlZEZuc1N5bWJvbF0uZm9yRWFjaChzZXFGbiA9PiB7XG4gICAgICAgICAgICAgICAgc2VxRm4uZm4uYXBwbHkoc2VxRm4uc2NvcGUgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB3cmFwcGVyW3NlcXVlbmNlZEZuc1N5bWJvbF0gPSBbe2ZuLCBzY29wZX1dO1xuICAgICAgICB3cmFwcGVyW29yaWdpbmFsTWV0aG9kU3ltYm9sXSA9IG9yaWdpbmFsTWV0aG9kOyAvLyBTdG9yZSBvcmlnaW5hbCBtZXRob2RcbiAgICB9XG5cbiAgICByZXR1cm4gKHRhcmdldFttZXRob2ROYW1lXSA9IHdyYXBwZXIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHNjb3BlXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXk9MzAwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgc2NvcGUsIGRlbGF5PTMwMCkge1xuICAgIGxldCBkZWJvdW5jZVRpbWVyO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gbGVhZGluZyBlZGdlID0+IHRyaWdnZXIgdGhlIGZpcnN0IGNhbGwgcmlnaHQgYXdheVxuICAgICAgICBpZiAoIU5lby5pc051bWJlcihkZWJvdW5jZVRpbWVyKSkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgc2NvcGUgKGluc3RhbmNlKSBkaWQgbm90IGdldCBkZXN0cm95ZWQgeWV0XG4gICAgICAgICAgICBzY29wZT8uaWQgJiYgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xuXG4gICAgICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIHN0YXJ0IGEgdGltZXIgdG8gZGVsYXkgdGhlIDJuZCsgdXBkYXRlXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7ZGVib3VuY2VUaW1lciA9IG51bGx9LCAgZGVsYXkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lcik7XG5cbiAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBzY29wZSAoaW5zdGFuY2UpIGRpZCBub3QgZ2V0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgICAgICBzY29wZT8uaWQgJiYgY2FsbGJhY2suYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtkZWJvdW5jZVRpbWVyID0gbnVsbH0sICBkZWxheSlcbiAgICAgICAgICAgIH0sICBkZWxheSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJjZXB0b3IgY2FuIHByZXZlbnQgdGhlIHRhcmdldE1ldGhvZCBmcm9tIGdldHRpbmcgZXhlY3V0ZWQgaW4gY2FzZSBpdCByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldE1ldGhvZE5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdEZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGFyZ2V0XG4gKiBAcGFyYW0geyp9IHByZXZlbnRlZFJldHVyblZhbHVlPW51bGwgVGhlIHZhbHVlIHRvIHJldHVybiBpbiBjYXNlIHRoZSBpbnRlcmNlcHRGdW5jdGlvbiByZXR1cm5zIGZhbHNlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcmNlcHQodGFyZ2V0LCB0YXJnZXRNZXRob2ROYW1lLCBpbnRlcmNlcHRGdW5jdGlvbiwgc2NvcGUsIHByZXZlbnRlZFJldHVyblZhbHVlPW51bGwpIHtcbiAgICBsZXQgdGFyZ2V0TWV0aG9kID0gdGFyZ2V0W3RhcmdldE1ldGhvZE5hbWVdO1xuXG4gICAgcmV0dXJuICh0YXJnZXRbdGFyZ2V0TWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChpbnRlcmNlcHRGdW5jdGlvbi5hcHBseShzY29wZSB8fCB0YXJnZXQsIGFyZ3VtZW50cykgPT09IGZhbHNlKVxuICAgICAgICAgICAgPyBwcmV2ZW50ZWRSZXR1cm5WYWx1ZVxuICAgICAgICAgICAgOiB0YXJnZXRNZXRob2QuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpXG4gICAgfSlcbn1cblxuLyoqXG4gKiBMb2NhdGUgYSBjYWxsYWJsZSBmdW5jdGlvbiBieSBuYW1lIGluIHRoZSBwYXNzZWQgc2NvcGUuXG4gKlxuICogSWYgdGhlIG5hbWUgc3RhcnRzIHdpdGggJ3VwLicsIHRoZSBwYXJlbnQgQ29tcG9uZW50IGNoYWluIGlzIHNlYXJjaGVkLlxuICpcbiAqIFRoaXMgaXMgdXNlZCBieSBtYW5hZ2VyLkRvbUV2ZW50cyAmIGNvcmUuT2JzZXJ2YWJsZS5maXJlIGFuZCBieSAnaGFuZGxlcicgZnVuY3Rpb24gY2FsbHMgdG8gcmVzb2x2ZVxuICogc3RyaW5nIGZ1bmN0aW9uIG5hbWVzIGluIHRoZSBDb21wb25lbnQncyBvd24gaGllcmFyY2h5LlxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIEEgZnVuY3Rpb24sIG9yIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdG8gZmluZCBpbiB0aGUgcGFzc2VkIHNjb3BlIG9iamVjdC9cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10aGlzIFRoZSBzY29wZSB0byBmaW5kIHRoZSBmdW5jdGlvbiBpbiBpZiBpdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNhbGxiYWNrKGZuLCBzY29wZT10aGlzKSB7XG4gICAgaWYgKE5lby5pc1N0cmluZyhmbikpIHtcbiAgICAgICAgaWYgKCFzY29wZVtmbl0gJiYgZm4uc3RhcnRzV2l0aCgndXAuJykpIHtcbiAgICAgICAgICAgIGZuID0gZm4uc2xpY2UoMyk7XG4gICAgICAgICAgICB3aGlsZSAoIXNjb3BlW2ZuXSAmJiAoc2NvcGUgPSBzY29wZS5wYXJlbnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjb3BlID0gc2NvcGUuZ2V0Q29udHJvbGxlcj8uKCk/LmdldEhhbmRsZXJTY29wZShmbiwgbnVsbCkgfHwgc2NvcGVcbiAgICAgICAgfVxuXG4gICAgICAgIGZuID0gc2NvcGVbZm5dXG4gICAgfVxuXG4gICAgcmV0dXJuIHtmbiwgc2NvcGV9XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gc2NvcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheT0zMDBcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBzY29wZSwgZGVsYXk9MzAwKSB7XG4gICAgbGV0IGxhc3RSYW5EYXRlLCB0aW1lb3V0SWQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBpZiAoIWxhc3RSYW5EYXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBzY29wZSAoaW5zdGFuY2UpIGRpZCBub3QgZ2V0IGRlc3Ryb3llZCB5ZXRcbiAgICAgICAgICAgIHNjb3BlPy5pZCAmJiBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncyk7XG5cbiAgICAgICAgICAgIGxhc3RSYW5EYXRlID0gRGF0ZS5ub3coKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcblxuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoKERhdGUubm93KCkgLSBsYXN0UmFuRGF0ZSkgPj0gZGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgc2NvcGUgKGluc3RhbmNlKSBkaWQgbm90IGdldCBkZXN0cm95ZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlPy5pZCAmJiBjYWxsYmFjay5hcHBseShzY29wZSwgYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdFJhbkRhdGUgPSBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZGVsYXkgLSAoRGF0ZS5ub3coKSAtIGxhc3RSYW5EYXRlKSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuU2VxdWVuY2UodGFyZ2V0LCBtZXRob2ROYW1lLCBmbiwgc2NvcGUpIHtcbiAgICBsZXQgY3VycmVudE1ldGhvZCA9IHRhcmdldFttZXRob2ROYW1lXTtcblxuICAgIGlmICghY3VycmVudE1ldGhvZCB8fCAhY3VycmVudE1ldGhvZFtzZXF1ZW5jZWRGbnNTeW1ib2xdKSB7XG4gICAgICAgIHJldHVybiAvLyBOb3QgYSBzZXF1ZW5jZWQgbWV0aG9kXG4gICAgfVxuXG4gICAgY29uc3Qgc2VxdWVuY2VkRnVuY3Rpb25zID0gY3VycmVudE1ldGhvZFtzZXF1ZW5jZWRGbnNTeW1ib2xdO1xuXG4gICAgLy8gRmlsdGVyIG91dCB0aGUgZnVuY3Rpb24gdG8gdW5zZXF1ZW5jZVxuICAgIGN1cnJlbnRNZXRob2Rbc2VxdWVuY2VkRm5zU3ltYm9sXSA9IHNlcXVlbmNlZEZ1bmN0aW9ucy5maWx0ZXIoc2VxRm4gPT5cbiAgICAgICAgIShzZXFGbi5mbiA9PT0gZm4gJiYgc2VxRm4uc2NvcGUgPT09IHNjb3BlKVxuICAgICk7XG5cbiAgICBpZiAoY3VycmVudE1ldGhvZFtzZXF1ZW5jZWRGbnNTeW1ib2xdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBubyBmdW5jdGlvbnMgbGVmdCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgbWV0aG9kXG4gICAgICAgIHRhcmdldFttZXRob2ROYW1lXSA9IGN1cnJlbnRNZXRob2Rbb3JpZ2luYWxNZXRob2RTeW1ib2xdXG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLkxvZ2dlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBMb2dnZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLkxvZ2dlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuTG9nZ2VyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgbWluaW11bSBsZXZlbCwgd2hpY2ggeW91IHdhbnQgdG8gb3V0cHV0LlxuICAgICAgICAgKiBDaGFuZ2UgdGhpcyBhdCBhbnkgdGltZSB1c2luZyBhIHZhbHVlIG9mIGxvZ0xldmVsczogWydpbmZvJywgJ2xvZycsICd3YXJuJywgJ2Vycm9yJ11cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIE5lby51dGlsLkxvZ2dlci5sZXZlbCA9ICdlcnJvcidcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsZXZlbD0naW5mbydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbGV2ZWxfOiAnaW5mbycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVMb2dzPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBsb2dDaGFyXG4gICAgICovXG4gICAgbG9nQ2hhcnMgID0ge1xuICAgICAgICBlcnJvcjogJ0UnLFxuICAgICAgICBpbmZvIDogJ0knLFxuICAgICAgICBsb2cgIDogJ0wnLFxuICAgICAgICB3YXJuIDogJ1cnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gY29sb3JzXG4gICAgICovXG4gICAgbG9nQ29sb3JzID0ge1xuICAgICAgICBlcnJvcjogJ2luZGlhbnJlZCcsXG4gICAgICAgIGluZm8gOiAnI2FjYWNhYycsXG4gICAgICAgIGxvZyAgOiAnIzQ0ODg4OCcsXG4gICAgICAgIHdhcm4gOiAnIzZkNmQwMCdcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nTGV2ZWxzXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGxvZ0xldmVsc1xuICAgICAqL1xuICAgIGxvZ0xldmVscyA9IFsnaW5mbycsICdsb2cnLCAnd2FybicsICdlcnJvciddXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIGFsaWFzZXNcbiAgICAgICAgTmVvLmFwcGx5RnJvbU5zKE5lbywgbWUsIHtcbiAgICAgICAgICAgIGVycm9yICAgOiAnZXJyb3InLFxuICAgICAgICAgICAgaW5mbyAgICA6ICdpbmZvJyxcbiAgICAgICAgICAgIGxvZyAgICAgOiAnbG9nJyxcbiAgICAgICAgICAgIGxvZ0Vycm9yOiAnbG9nRXJyb3InLFxuICAgICAgICAgICAgd2FybiAgICA6ICd3YXJuJ1xuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghTmVvLmNvbmZpZy5lbmFibGVMb2dzSW5Qcm9kdWN0aW9uICYmIE5lby5jb25maWcuZW52aXJvbm1lbnQgPT09ICdkaXN0L3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbWUud3JpdGUgPSBOZW8uZW1wdHlGblxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBsZXZlbCB0byBudW1iZXIgYmFzZWQgb24gcG9zaXRpb24gaW4gbG9nTGV2ZWxzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgYmVmb3JlU2V0TGV2ZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0xldmVscy5pbmRleE9mKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGVycm9yKHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBoZWxwZXIgdG8gY2F0Y2ggY2FsbGVyXG4gICAgICogbm8ga25vd24gbmF0aXZlIHdheSBpbiBtb2Rlcm4gSlMgdG8ga25vdyB3aGF0IGZpbGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGN1cnJlbnQgbWV0aG9kXG4gICAgICogdGhlcmVmb3JlIHdlIHVzZSBFcnJvciwgd2UgY2FuIGdldCB0aGUgY2FsbGVyIGZpbGUgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugc3RyaW5nLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENhbGxlcigpIHtcbiAgICAgICAgbGV0IGNhbGxlcl9wYXRoID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXJyICAgICAgICAgPSBuZXcgRXJyb3IoKSxcbiAgICAgICAgICAgIHN0YWNrX2xpbmVzID0gZXJyLnN0YWNrLnNwbGl0KCdcXG4nKSxcbiAgICAgICAgICAgIGZvdW5kX3RoaXMgID0gZmFsc2UsXG4gICAgICAgICAgICBpLCBsaW5lO1xuXG4gICAgICAgIGZvciAoaSBpbiBzdGFja19saW5lcykge1xuICAgICAgICAgICAgbGluZSA9IHN0YWNrX2xpbmVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWZvdW5kX3RoaXMgJiYgL0xvZ2dlclxcLm1qcy8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kX3RoaXMgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvdW5kX3RoaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9Mb2dnZXJcXC5tanMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjbG9zaW5nIClcbiAgICAgICAgICAgICAgICAgICAgbGluZSAgICAgICAgPSBsaW5lLnJlcGxhY2UoJyknLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcGFydCBhZnRlciB0aGUgbGFzdCAvXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlcl9wYXRoID0gbGluZS5tYXRjaCgvKFteXFwvXSspJC8pWzFdLm1hdGNoKC8oW14gXSspJC8pWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxlcl9wYXRoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncyA9IHRoaXMucmVzb2x2ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIHRoaXMud3JpdGUoYXJncywgJ2luZm8nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncyA9IHRoaXMucmVzb2x2ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIHRoaXMud3JpdGUoYXJncywgJ2xvZycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBsb2dFcnJvciguLi5hcmdzKSB7XG4gICAgICAgIGFyZ3MgPSB0aGlzLnJlc29sdmVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLndyaXRlKGFyZ3MsICdlcnJvcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbnRleHRNZW51KGRhdGEpIHtcbiAgICAgICAgbGV0IHtjb25maWd9ID0gTmVvO1xuXG4gICAgICAgIGlmIChjb25maWcuZW5hYmxlQ29tcG9uZW50TG9nZ2VyICYmICEoY29uZmlnLmVudiA9PT0gJ2Rpc3QvcHJvZHVjdGlvbicgJiYgY29uZmlnLmVuYWJsZUxvZ3NJblByb2R1Y3Rpb24pKSB7XG4gICAgICAgICAgICBsZXQgaXNHcm91cFNldCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDtcblxuICAgICAgICAgICAgZGF0YS5wYXRoLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChpdGVtLmlkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNHcm91cFNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNHcm91cFNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwKGl0ZW0uaWQpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlzR3JvdXBTZXQgJiYgY29uc29sZS5ncm91cEVuZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZm9yIGFyZ3NcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVzb2x2ZUFyZ3MoLi4uYXJncykge1xuICAgICAgICBsZXQgaWRlbnRpZmllciA9IGFyZ3NbMF0sXG4gICAgICAgICAgICBhcmdzT2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKGlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgYXJnc09iamVjdC5tc2cgPSBhcmdzWzBdXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdChpZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIGFyZ3NPYmplY3QgPSBpZGVudGlmaWVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBhcmdzT2JqZWN0Lm1zZyAgPSBhcmdzWzBdO1xuICAgICAgICAgICAgYXJnc09iamVjdC5kYXRhID0gYXJncy5zbGljZSgxKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3NPYmplY3RcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICBhcmdzID0gdGhpcy5yZXNvbHZlQXJncyguLi5hcmdzKTtcbiAgICAgICAgdGhpcy53cml0ZShhcmdzLCAnd2FybicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3V0cHV0IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxldmVsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHdyaXRlKGFyZ3MsIGxldmVsKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmJlZm9yZVNldExldmVsKGxldmVsKSA8IG1lLmxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCcjJywgYXJncy5tc2csIGxldmVsKTtcblxuICAgICAgICBsZXQgbG9nQ29sb3IgPSBtZS5sb2dDb2xvcnNbbGV2ZWxdLFxuICAgICAgICAgICAgbG9nQ2hhciAgPSBtZS5sb2dDaGFyc1tsZXZlbF0sXG4gICAgICAgICAgICBiZyAgICAgICA9IGBiYWNrZ3JvdW5kLWNvbG9yOiR7bG9nQ29sb3J9OyBjb2xvcjogd2hpdGU7IGZvbnQtd2VpZ2h0OiA5MDA7YCxcbiAgICAgICAgICAgIGNvbG9yICAgID0gYGNvbG9yOiR7bG9nQ29sb3J9O2AsXG4gICAgICAgICAgICBtc2cgICAgICA9IGBbJHttZS5nZXRDYWxsZXIoKX1dICR7YXJncy5tc2d9YDtcblxuICAgICAgICBpZiAoYXJncy5kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKGAlYyAke2xvZ0NoYXJ9ICVjICR7bXNnfWAsIGJnLCBjb2xvcilcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3MuZGF0YSk7XG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAlYyAke2xvZ0NoYXJ9ICVjICR7bXNnfWAsIGJnLCBjb2xvcilcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTG9nZ2VyKTtcbiIsIi8qKlxuICogVGhlIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIERPTVJlY3QgT2JqZWN0c1xuICogQGNsYXNzIE5lby51dGlsLlJlY3RhbmdsZVxuICogQGV4dGVuZHMgRE9NUmVjdFxuICovXG5cbmNvbnN0XG4gICAgZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUoW10pLFxuICAgIC8vIENvbnZlcnQgZWRnZSBhcnJheSB2YWx1ZXMgaW50byB0aGUgW1QsUixCLExdIGZvcm0uXG4gICAgcGFyc2VFZGdlVmFsdWUgPSAoZSA9IDApID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICBlID0gW2VdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBlLmxlbmd0aCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZmlsbChlWzBdLCAxLCA0KTtcbiAgICAgICAgICAgIGNhc2UgMjovLyB0b3AmYm90dG9tLCBsZWZ0JnJpZ2h0XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlWzBdLCBlWzFdLCBlWzBdLCBlWzFdXTtcbiAgICAgICAgICAgIGNhc2UgMzovLyB0b3AsIGxlZnQmcmlnaHQsIGJvdHRvbVxuICAgICAgICAgICAgICAgIHJldHVybiBbZVswXSwgZVsxXSwgZVsyXSwgZVsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfSxcbiAgICBwYXJzZUVkZ2VBbGlnbiA9IGVkZ2VBbGlnbiA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBlZGdlUGFydHMgICAgID0gZWRnZUFsaWduUkUuZXhlYyhlZGdlQWxpZ24pLFxuICAgICAgICAgICAgb3VyRWRnZVpvbmUgICA9IGVkZ2Vab25lW2VkZ2VQYXJ0c1sxXV0sXG4gICAgICAgICAgICB0aGVpckVkZ2Vab25lID0gZWRnZVpvbmVbZWRnZVBhcnRzWzRdXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3VyRWRnZSAgICAgICAgIDogZWRnZVBhcnRzWzFdLFxuICAgICAgICAgICAgb3VyRWRnZU9mZnNldCAgIDogcGFyc2VJbnQoZWRnZVBhcnRzWzJdIHx8IDUwKSxcbiAgICAgICAgICAgIG91ckVkZ2VVbml0ICAgICA6IGVkZ2VQYXJ0c1szXSB8fCAnJScsXG4gICAgICAgICAgICBvdXJFZGdlWm9uZSxcbiAgICAgICAgICAgIHRoZWlyRWRnZSAgICAgICA6IGVkZ2VQYXJ0c1s0XSxcbiAgICAgICAgICAgIHRoZWlyRWRnZU9mZnNldCA6IHBhcnNlSW50KGVkZ2VQYXJ0c1s1XSB8fCA1MCksXG4gICAgICAgICAgICB0aGVpckVkZ2VVbml0ICAgOiBlZGdlUGFydHNbNl0gfHwgJyUnLFxuICAgICAgICAgICAgdGhlaXJFZGdlWm9uZSxcblxuICAgICAgICAgICAgLy8gQWxpZ25lZCB0byBhbiBlZGdlLCAqb3V0c2lkZSogb2YgdGhlIHRhcmdldC5cbiAgICAgICAgICAgIC8vIEEgbm9ybWFsIGFsaWduIGFzIGEgY29tYm8gZHJvcGRvd24gbWlnaHQgcmVxdWVzdFxuICAgICAgICAgICAgZWRnZUFsaWduZWQgICAgIDogKG91ckVkZ2Vab25lICYgMSkgPT09ICh0aGVpckVkZ2Vab25lICYgMSkgJiYgb3VyRWRnZVpvbmUgIT09IHRoZWlyRWRnZVpvbmVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gVGhlIG9wcG9zaXRlIG9mIHBhcnNlRWRnZUFsaWduLCBhbmQgaXQgaGFzIHRvIGZsaXAgdGhlIGVkZ2VzXG4gICAgY3JlYXRlUmV2ZXJzZWRFZGdlQWxpZ24gPSBlZGdlcyA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBvdXJFZGdlICAgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMub3VyRWRnZV0sXG4gICAgICAgICAgICB0aGVpckVkZ2UgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMudGhlaXJFZGdlXTtcblxuICAgICAgICAvLyByZWNvbnN0aXR1dGUgYSBydWxlIHN0cmluZyB3aXRoIHRoZSBlZGdlcyBmbGlwcGVkIHRvIHRoZSBvcHBvc2l0ZSBzaWRlc1xuICAgICAgICByZXR1cm4gYCR7b3VyRWRnZX0ke2VkZ2VzLm91ckVkZ2VPZmZzZXR9JHtlZGdlcy5vdXJFZGdlVW5pdH0tJHt0aGVpckVkZ2V9JHtlZGdlcy50aGVpckVkZ2VPZmZzZXR9JHtlZGdlcy50aGVpckVkZ2VVbml0fWBcblxuICAgIH0sXG4gICAgZ2V0RWxSZWN0ID0gZWwgPT4ge1xuICAgICAgICBjb25zdCByID0gZWwgaW5zdGFuY2VvZiBET01SZWN0ID8gZWwgOiAoZWw/Lm5vZGVUeXBlID09PSAxID8gZWwgOiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpIDogbnVsbCk/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgRE9NUmVjdCBpbnRvIFJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gciAmJiBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG4gICAgfSxcbiAgICBvcHBvc2l0ZUVkZ2UgPSB7XG4gICAgICAgIHQgOiAnYicsXG4gICAgICAgIHIgOiAnbCcsXG4gICAgICAgIGIgOiAndCcsXG4gICAgICAgIGwgOiAncidcbiAgICB9LFxuICAgIGVkZ2Vab25lID0ge1xuICAgICAgICB0IDogMCxcbiAgICAgICAgciA6IDEsXG4gICAgICAgIGIgOiAyLFxuICAgICAgICBsIDogM1xuICAgIH0sXG4gICAgem9uZU5hbWVzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgICB6b25lRWRnZXMgPSBbJ3QnLCAncicsICdiJywgJ2wnXSxcbiAgICB6b25lRGltZW5zaW9uID0gWyd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICB6b25lQ29vcmQgPSBbMCwgMSwgMCwgMV0sXG4gICAgemVyb01hcmdpbnMgPSBbMCwgMCwgMCwgMF0sXG4gICAgZWRnZUFsaWduUkUgPSAvXihbdHJibGNdKShcXGQqKSglfHB4KT8tKFt0cmJsY10pKFxcZCopKCV8cHgpPyQvO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBET01SZWN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLlJlY3RhbmdsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuUmVjdGFuZ2xlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtaW5IZWlnaHQ9bnVsbFxuICAgICAqL1xuICAgIG1pbkhlaWdodCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbWluV2lkdGg9bnVsbFxuICAgICAqL1xuICAgIG1pbldpZHRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QxIGRvZXMgbm90IGhhdmUgYW4gaW50ZXJzZWN0aW9uIHdpdGggcmVjdDJcbiAgICAgKiAhaW5jbHVkZXMoKSBpcyB0cnVlIGZvciBpbnRlcnNlY3Rpb25zIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhjbHVkZXMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIHJldHVybiByZWN0MS5ib3R0b20gPCByZWN0Mi50b3AgICAgIC8vIHJlY3QyIGlzIGJlbG93IHJlY3QxXG4gICAgICAgICAgICB8fCByZWN0MS5sZWZ0ICAgPiByZWN0Mi5yaWdodCAgIC8vIHJlY3QyIGlzIGxlZnQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnJpZ2h0ICA8IHJlY3QyLmxlZnQgICAgLy8gcmVjdDIgaXMgcmlnaHQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnRvcCAgICA+IHJlY3QyLmJvdHRvbTsgLy8gcmVjdDIgaXMgYWJvdmUgcmVjdDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGFwcGluZyBhcmVhIG9mIHJlY3QxICYgcmVjdDIgYXMgYSBuZXcgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtET01SZWN0fE5lby51dGlsLlJlY3RhbmdsZX0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3R8TmVvLnV0aWwuUmVjdGFuZ2xlfSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtOZW8udXRpbC5SZWN0YW5nbGV8bnVsbH0gVGhlIGludGVyc2VjdGluZyByZWN0XG4gICAgICovXG4gICAgc3RhdGljIGdldEludGVyc2VjdGlvbihyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgbGV0IHggICAgICA9IE1hdGgubWF4KHJlY3QxLngsICAgICAgcmVjdDIueCksXG4gICAgICAgICAgICB5ICAgICAgPSBNYXRoLm1heChyZWN0MS55LCAgICAgIHJlY3QyLnkpLFxuICAgICAgICAgICAgcmlnaHQgID0gTWF0aC5taW4ocmVjdDEucmlnaHQsICByZWN0Mi5yaWdodCksXG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgICAgICAgICB3aWR0aCAgPSBNYXRoLm1heCgwLCByaWdodCAgLSB4KSxcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDAsIGJvdHRvbSAtIHkpO1xuXG4gICAgICAgIGlmIChoZWlnaHQgPCAxIHx8IHdpZHRoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QyIGlzIGZ1bGx5IGNvbnRhaW5lZCBpbnNpZGUgcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5jbHVkZXMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIHJldHVybiByZWN0MS5ib3R0b20gPj0gcmVjdDIuYm90dG9tXG4gICAgICAgICAgICAmJiByZWN0MS5sZWZ0ICAgPD0gcmVjdDIubGVmdFxuICAgICAgICAgICAgJiYgcmVjdDEucmlnaHQgID49IHJlY3QyLnJpZ2h0XG4gICAgICAgICAgICAmJiByZWN0MS50b3AgICAgPD0gcmVjdDIudG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiByZWN0MiBpcyBub3QgY29udGFpbmVkIGluc2lkZSByZWN0MS5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFuIGludGVyc2VjdGlvbiBvciBiZWluZyBmdWxseSBleGNsdWRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZSBib3R0b20sIGxlZnQsIHJpZ2h0IG9yIHRvcFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBsZWF2ZXNTaWRlKHJlY3QxLCByZWN0Miwgc2lkZSkge1xuICAgICAgICBpZiAoUmVjdGFuZ2xlLmluY2x1ZGVzKHJlY3QxLCByZWN0MikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLmJvdHRvbSA8IHJlY3QyLmJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0MS5sZWZ0ID4gcmVjdDIubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEucmlnaHQgPCByZWN0Mi5yaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWRlID09PSAndG9wJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLnRvcCA+IHJlY3QyLnRvcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgYSBET01SZWN0IG9iamVjdCB0byBhIG5ldyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gW3g9bnVsbF1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeT1udWxsXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG1vdmVkUmVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlQnkocmVjdCwgeD1udWxsLCB5PW51bGwpIHtcbiAgICAgICAgbGV0IG1vdmVkUmVjdCA9IHsuLi5yZWN0fTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHgpKSB7XG4gICAgICAgICAgICBtb3ZlZFJlY3QubGVmdCAgKz0geDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5yaWdodCArPSB4O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnggICAgICs9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBtb3ZlZFJlY3QuYm90dG9tICs9IHk7XG4gICAgICAgICAgICBtb3ZlZFJlY3QudG9wICAgICs9IHk7XG4gICAgICAgICAgICBtb3ZlZFJlY3QueSAgICAgICs9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWRSZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgYSBET01SZWN0IG9iamVjdCB0byBhIG5ldyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gW3g9bnVsbF1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeT1udWxsXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG1vdmVkUmVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlVG8ocmVjdCwgeD1udWxsLCB5PW51bGwpIHtcbiAgICAgICAgbGV0IG1vdmVkUmVjdCA9IHsuLi5yZWN0fTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHgpKSB7XG4gICAgICAgICAgICBtb3ZlZFJlY3QubGVmdCAgPSB4O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnJpZ2h0ID0geCArIG1vdmVkUmVjdC53aWR0aDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC54ICAgICA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBtb3ZlZFJlY3QuYm90dG9tID0geSArIG1vdmVkUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICBtb3ZlZFJlY3QudG9wICAgID0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC55ICAgICAgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVkUmVjdDtcbiAgICB9XG5cbiAgICBzZXQgYm90dG9tKGIpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gYiAtIHRoaXMuYm90dG9tO1xuICAgIH1cbiAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuYm90dG9tO1xuICAgIH1cblxuICAgIHNldCByaWdodChyKSB7XG4gICAgICAgIHRoaXMud2lkdGggKz0gciAtIHRoaXMucmlnaHQ7XG4gICAgfVxuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJpZ2h0O1xuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgeCB3aXRob3V0IG1vdmluZyB0aGUgUmVjdGFuZ2xlLiBUaGUgbGVmdCBzaWRlIG1vdmVzIGFuZCB0aGUgcmlnaHQgc2lkZSBkb2Vzbid0XG4gICAgY2hhbmdlWCh4KSB7XG4gICAgICAgIGNvbnN0IHdpZHRoRGVsdGEgPSB0aGlzLnggLSB4O1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMud2lkdGggKz0gd2lkdGhEZWx0YTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdGhlIHkgd2l0aG91dCBtb3ZpbmcgdGhlIFJlY3RhbmdsZS4gVGhlIHRvcCBzaWRlIG1vdmVzIGFuZCB0aGUgYm90dG9tIHNpZGUgZG9lc24ndFxuICAgIGNoYW5nZVkoeSkge1xuICAgICAgICBjb25zdCBoZWlnaHREZWx0YSA9IHRoaXMueSAtIHk7XG5cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0RGVsdGE7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBSZWN0YW5nbGUuY2xvbmUodGhpcyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNsb25lKHIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZShyLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQpO1xuXG4gICAgICAgIHJlc3VsdC5taW5XaWR0aCA9IHIubWluV2lkdGg7XG4gICAgICAgIHJlc3VsdC5taW5IZWlnaHQgPSByLm1pbkhlaWdodDtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGludGVyc2VjdHMob3RoZXIpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvdGhlci5oZWlnaHQgJiYgb3RoZXIud2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgbGVmdCAgID0gTWF0aC5tYXgobWUueCwgb3RoZXIueCksXG4gICAgICAgICAgICAgICAgdG9wICAgID0gTWF0aC5tYXgobWUueSwgb3RoZXIueSksXG4gICAgICAgICAgICAgICAgcmlnaHQgID0gTWF0aC5taW4obWUueCArIG1lLndpZHRoLCBvdGhlci54ICsgb3RoZXIud2lkdGgpLFxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKG1lLnkgKyBtZS5oZWlnaHQsIG90aGVyLnkgKyBvdGhlci5oZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAobGVmdCA+PSByaWdodCB8fCB0b3AgPj0gYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBkZWFsaW5nIHdpdGggYSBwb2ludCBoZXJlIC0gemVybyBkaW1lbnNpb25zXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChvdGhlci54ID49IG1lLnggJiYgb3RoZXIueSA+PSBtZS55ICYmIG90aGVyLnJpZ2h0IDw9IG1lLnJpZ2h0ICYmIG90aGVyLmJvdHRvbSA8PSBtZS5ib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGUgZXhwYW5kZWQgYWNjb3JkaW5nIHRvIHRoZSBlZGdlcyBhcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBlZGdlc1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9XG4gICAgICovXG4gICAgZXhwYW5kKGVkZ2VzKSB7XG4gICAgICAgIGVkZ2VzID0gcGFyc2VFZGdlVmFsdWUoZWRnZXMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnggLSBlZGdlc1szXSwgdGhpcy55IC0gZWRnZXNbMF0sIHRoaXMud2lkdGggKyBlZGdlc1sxXSArIGVkZ2VzWzNdLCB0aGlzLmhlaWdodCArIGVkZ2VzWzBdICsgZWRnZXNbMl0pO1xuICAgIH1cblxuICAgIG1vdmVCeSh4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgICAgICB5ID0geFsxXTtcbiAgICAgICAgICAgIHggPSB4WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC54ICs9IHg7XG4gICAgICAgIHJlc3VsdC55ICs9IHk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBSZWN0YW5nbGUgY29tcGxldGVseSBjb250YWlucyB0aGUgb3RoZXIgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IG90aGVyXG4gICAgICovXG4gICAgY29udGFpbnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5pbmNsdWRlcyh0aGlzLCBvdGhlcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIFJlY3RhbmdsZSBjb25zdHJhaW5lZCB0byBmaXQgd2l0aGluIHRoZSBwYXNzZWQgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbnN0cmFpblRvXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZXxCb29sZWFufSBBIG5ldyBSZWN0YW5nbGUgY29uc3RyYWluZWQgdG8gdGUgcGFzc2VkIFJlY3RhbmdsZSwgb3IgZmFsc2UgaWYgaXQgY291bGQgbm90IGJlIGNvbnN0cmFpbmVkLlxuICAgICAqL1xuICAgIGNvbnN0cmFpblRvKGNvbnN0cmFpblRvKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbWluV2lkdGggID0gbWUubWluV2lkdGggIHx8IG1lLndpZHRoLFxuICAgICAgICAgICAgbWluSGVpZ2h0ID0gbWUubWluSGVpZ2h0IHx8IG1lLmhlaWdodDtcblxuICAgICAgICAvLyBOb3QgcG9zc2libGUsIGV2ZW4gd2hlbiBzaHJ1bmsgdG8gbWluaW1hXG4gICAgICAgIGlmIChtaW5IZWlnaHQgPiBjb25zdHJhaW5Uby5oZWlnaHQgfHwgbWluV2lkdGggPiBjb25zdHJhaW5Uby53aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZG8gbm90IG11dGF0ZSB0aGlzIFJlY3RhbmdsZSwgYnV0IHJldHVybiBhIGNvbnN0cmFpbmVkIHZlcnNpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbWUuY2xvbmUoKTtcblxuICAgICAgICAvLyBUcmFuc2xhdGUgcmVzdWx0IHNvIHRoYXQgdGhlIHRvcCBhbmQgbGVmdCBhcmUgdmlzaWJsZVxuICAgICAgICByZXN1bHQueCA9IE1hdGgubWF4KG1lLnggKyBNYXRoLm1pbihjb25zdHJhaW5Uby5yaWdodCAgLSByZXN1bHQucmlnaHQsICAwKSwgY29uc3RyYWluVG8ueCk7XG4gICAgICAgIHJlc3VsdC55ID0gTWF0aC5tYXgobWUueSArIE1hdGgubWluKGNvbnN0cmFpblRvLmJvdHRvbSAtIHJlc3VsdC5ib3R0b20sIDApLCBjb25zdHJhaW5Uby55KTtcblxuICAgICAgICAvLyBQdWxsIGluIGFueSByZXN1bHRpbmcgb3ZlcmZsb3dcbiAgICAgICAgcmVzdWx0LmJvdHRvbSA9IE1hdGgubWluKHJlc3VsdC5ib3R0b20sIGNvbnN0cmFpblRvLmJvdHRvbSk7XG4gICAgICAgIHJlc3VsdC5yaWdodCA9IE1hdGgubWluKHJlc3VsdC5yaWdodCwgY29uc3RyYWluVG8ucmlnaHQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYWxpZ25UbyhhbGlnbikge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpblRvLCAgICAvLyBFbGVtZW50IG9yIFJlY3RhbmdsZSByZXN1bHQgbXVzdCBmaXQgaW50b1xuICAgICAgICAgICAgICAgIHRhcmdldCwgICAgICAgICAvLyBFbGVtZW50IG9yIFJlY3RhbmdsZSB0byBhbGlnbiB0b1xuICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiwgICAgICAvLyB0NTAtYjUwIHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgYXhpc0xvY2ssICAgICAgIC8vIHRydWUgZm9yIGZsaXAsICdmbGV4aWJsZScgZm9yIGZsaXAsIHRoZW4gdHJ5IHRoZSBvdGhlciBlZGdlc1xuICAgICAgICAgICAgICAgIG9mZnNldCwgICAgICAgICAvLyBGaW5hbCBbeCwgeV0gdmVjdG9yIHRvIG1vdmUgdGhlIHJlc3VsdCBieS5cbiAgICAgICAgICAgICAgICBtYXRjaFNpemVcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgID0gYWxpZ24sXG4gICAgICAgICAgICB0YXJnZXRNYXJnaW4gICA9IGFsaWduLnRhcmdldE1hcmdpbiA/IHBhcnNlRWRnZVZhbHVlKGFsaWduLnRhcmdldE1hcmdpbikgOiB6ZXJvTWFyZ2lucyxcbiAgICAgICAgICAgIHRhcmdldFJlY3QgICAgID0gZ2V0RWxSZWN0KHRhcmdldCksXG4gICAgICAgICAgICBjb25zdHJhaW5SZWN0ICA9IGdldEVsUmVjdChjb25zdHJhaW5UbyksXG4gICAgICAgICAgICBlZGdlcyAgICAgICAgICA9IHBhcnNlRWRnZUFsaWduKGVkZ2VBbGlnbiksXG4gICAgICAgICAgICBtYXRjaERpbWVuc2lvbiA9IHpvbmVEaW1lbnNpb25bZWRnZXMudGhlaXJFZGdlWm9uZSAmIDFdO1xuXG4gICAgICAgIGxldCByZXN1bHQgPSBtZS5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdFttYXRjaERpbWVuc2lvbl0gPSB0YXJnZXRSZWN0W21hdGNoRGltZW5zaW9uXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE11c3QgZG8gdGhlIGNhbGN1bGF0aW9ucyBhZnRlciB0aGUgYWxpZ25lZCBzaWRlIGhhcyBiZWVuIG1hdGNoZWQgaW4gc2l6ZSBpZiByZXF1ZXN0ZWQuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBteVBvaW50ICAgICA9IHJlc3VsdC5nZXRBbmNob3JQb2ludChlZGdlcy5vdXJFZGdlWm9uZSwgZWRnZXMub3VyRWRnZU9mZnNldCwgZWRnZXMub3VyRWRnZVVuaXQpLFxuICAgICAgICAgICAgdGFyZ2V0UG9pbnQgPSB0YXJnZXRSZWN0LmdldEFuY2hvclBvaW50KGVkZ2VzLnRoZWlyRWRnZVpvbmUsIGVkZ2VzLnRoZWlyRWRnZU9mZnNldCwgZWRnZXMudGhlaXJFZGdlVW5pdCwgdGFyZ2V0TWFyZ2luKSxcbiAgICAgICAgICAgIHZlY3RvciAgICAgID0gW3RhcmdldFBvaW50WzBdIC0gbXlQb2ludFswXSwgdGFyZ2V0UG9pbnRbMV0gLSBteVBvaW50WzFdXTtcblxuICAgICAgICByZXN1bHQgPSByZXN1bHQubW92ZUJ5KHZlY3Rvcik7XG5cbiAgICAgICAgLy8gQSB1c2VmdWwgcHJvcGVydHkgaW4gdGhlIHJlc3VsdGluZyByZWN0YW5nbGUgd2hpY2ggc3BlY2lmaWVzIHdoaWNoIHpvbmUgb2YgdGhlIHRhcmdldFxuICAgICAgICAvLyBJdCBpcyBiZWluZyBwbGFjZXMgaW4sIFQsUixCIG9yIEwgLSAwLCAxLCAyLCAzXG4gICAgICAgIC8vIFNvbWUgY29kZSBtYXkgd2FudCB0byB0cmVhdCBET00gZWxlbWVudHMgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHRoZSB6b25lXG4gICAgICAgIHJlc3VsdC56b25lID0gZWRnZXMudGhlaXJFZGdlWm9uZTtcbiAgICAgICAgcmVzdWx0LnBvc2l0aW9uID0gem9uZU5hbWVzW3Jlc3VsdC56b25lXTtcblxuICAgICAgICAvLyBOb3cgd2UgY3JlYXRlIHRoZSBmb3VyIFJlY3RhbmdsZXMgYXJvdW5kIHRoZSB0YXJnZXQsIGludG8gd2hpY2ggd2UgbWF5IGJlIGNvbnN0cmFpbmVkXG4gICAgICAgIC8vIFpvbmVzIFQsUixCLEwgMCA5LCAxLCAyLCAzOlxuICAgICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgIC8vIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIF4gICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIF4gICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgPC0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tWm9uZSAwLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLT4gICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKy0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgIFpvbmUgMyAgICAgICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgIFpvbmUgMSAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8ICsrLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgPC0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS1ab25lIDItLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tPiB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgdiAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgdiAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKystLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICBpZiAoY29uc3RyYWluUmVjdCAmJiAhY29uc3RyYWluUmVjdC5jb250YWlucyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAvLyBUaGV5IGFza2VkIHRvIG92ZXJsYXAgdGhlIHRhcmdldCwgZm9yIGV4YW1wbGUgdDAtdDBcbiAgICAgICAgICAgIC8vIEluIHRoZXNlIGNhc2VzLCB3ZSBqdXN0IHJldHVybiB0aGUgcmVzdWx0XG4gICAgICAgICAgICBpZiAodGFyZ2V0UmVjdC5pbnRlcnNlY3RzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSB6b25lIHdlIHRyeSB0byBmaXQgaW50byBmaXJzdCwgdGhlIG9uZSB0aGF0IHdhcyBhc2tlZCBmb3JcbiAgICAgICAgICAgIGxldCB6b25lID0gZWRnZXMudGhlaXJFZGdlWm9uZTtcblxuICAgICAgICAgICAgLy8gV2UgY3JlYXRlIGFuIGFycmF5IG9mIGZvdXIgcmVjdGFuZ2xlcyBpbnRvIHdoaWNoIHdlIHRyeSB0byBmaXQgd2l0aCBhcHByb3ByaWF0ZSBhbGlnbiBzcGVjcy5cbiAgICAgICAgICAgIC8vIFdlIG11c3Qgc3RhcnQgd2l0aCB0aGUgcmVxdWVzdGVkIHpvbmUsIHdoYXRldmVyIHRoYXQgaXMuXG4gICAgICAgICAgICBjb25zdCB6b25lc1RvVHJ5ID0gW3tcbiAgICAgICAgICAgICAgICB6b25lLFxuICAgICAgICAgICAgICAgIGVkZ2VBbGlnblxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGlmIChheGlzTG9jaykge1xuICAgICAgICAgICAgICAgIC8vIEZsaXAgdG8gdGhlIG9wcG9zaXRlIHNpZGUgZm9yIHRoZSBzZWNvbmQgdHJ5LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBhbGlnbm1lbnQgc3RyaW5nIGhhcyB0byBiZSByZXZlcnNlZFxuICAgICAgICAgICAgICAgIC8vIHNvIHIyMC1sMzAgaGFzIHRvIGJlY29tZSBsMjAtcjMwLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBvdGhlciB0d28gem9uZXMgcmV2ZXJ0IHRvIGNlbnRlcmVkIHNvIGFyZSBlYXNpZXJcbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5WzFdID0ge1xuICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKHpvbmUgKyAyKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGNyZWF0ZVJldmVyc2VkRWRnZUFsaWduKGVkZ2VzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgb3RoZXIgdHdvIHpvbmVzLlxuICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoZWRnZXMudGhlaXJFZGdlWm9uZSArIDEpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduIDogYCR7b3Bwb3NpdGVFZGdlW3pvbmVFZGdlc1t6b25lXV19LSR7em9uZUVkZ2VzW3pvbmVdfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKGVkZ2VzLnRoZWlyRWRnZVpvbmUgKyAzKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGAke29wcG9zaXRlRWRnZVt6b25lRWRnZXNbem9uZV1dfS0ke3pvbmVFZGdlc1t6b25lXX1gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBvdGhlciB6b25lcyBpbiBvcmRlclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKHpvbmUgKyAxKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24gOiBgJHtvcHBvc2l0ZUVkZ2Vbem9uZUVkZ2VzW3pvbmVdXX0tJHt6b25lRWRnZXNbem9uZV19YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29uc3RyYWludCBSZWN0YW5nbGUgZm9yIGVhY2ggem9uZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6b25lc1RvVHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2xvbmUgdGhlIG91dGVyIGNvbnN0cmFpbmluZyByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAvLyBhbmQgbW92ZSBpdCBpbnRvIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNvbnN0cmFpblJlY3QuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoem9uZXNUb1RyeVtpXS56b25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGkyIGFib3ZlIHRoZSB0YXJnZXQgLSB6b25lIDAvVFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5ib3R0b20gPSB0YXJnZXRSZWN0LnkgLSB0YXJnZXRNYXJnaW5bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHpvbmUgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSB0YXJnZXQgLSB6b25lIDEvUlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFuZ2VYKHRhcmdldFJlY3QucmlnaHQgKyB0YXJnZXRNYXJnaW5bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGlzIGJlbG93IHRoZSB0YXJnZXQgLSB6b25lIDIvQlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFuZ2VZKHRhcmdldFJlY3QuYm90dG9tICsgdGFyZ2V0TWFyZ2luWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgem9uZSBpcyB0byB0aGUgbGVmdCBvZiB0aGUgdGFyZ2V0IC0gem9uZSAzL0xcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSB0YXJnZXRSZWN0LnggLSB0YXJnZXRNYXJnaW5bM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgem9uZXNUb1RyeVtpXS5jb25zdHJhaW5SZWN0ID0gYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHRyeSB0byBjb25zdHJhaW4gb3VyIHJlc3VsdCBpbnRvIGVhY2ggem9uZSdzIGNvbnN0cmFpbnRab25lXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHpvbmVzVG9UcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWluUmVjdFxuICAgICAgICAgICAgICAgICAgICB9ICAgID0gem9uZXNUb1RyeVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZSA9IHpvbmVFZGdlc1t6b25lXTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGFsaWduaW5nIHRvIHRoZSByZXF1ZXN0ZWQgZWRnZSwgb3IgaXQncyBvcHBvc2l0ZSBlZGdlIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhhdCBlZGdlIHNpemUsIGVsc2UgcmV2ZXJ0IGl0IHRvIG91ciBvd24gc2l6ZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbWF0Y2hEaW1lbnNpb25dID0gZWRnZSA9PT0gZWRnZXMudGhlaXJFZGdlIHx8IGVkZ2UgPT0gb3Bwb3NpdGVFZGdlW2VkZ2VzLnRoZWlyRWRnZV0gPyB0YXJnZXRSZWN0W21hdGNoRGltZW5zaW9uXSA6IG1lW21hdGNoRGltZW5zaW9uXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBhIHNpbXBsZSBhbGlnbiB0byB0aGUgY3VycmVudCBlZGdlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFsaWduVG8oe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgOiB0YXJnZXRSZWN0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNvbHV0aW9uID0gcmVzdWx0LmNvbnN0cmFpblRvKGNvbnN0cmFpblJlY3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXMgc29vbiBhcyB3ZSBmaW5kIGEgem9uZSBpbnRvIHdoaWNoIHRoZSByZXN1bHQgaXMgd2lsbGluZyB0byBiZSBjb25zdHJhaW5lZC4gcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLnpvbmUgPSB6b25lO1xuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbi5wb3NpdGlvbiA9IHpvbmVOYW1lc1t6b25lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgY29uZmlndXJhYmxlIGZpbmlzaGluZyB0b3VjaC5cbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1vdmVCeShvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXRBbmNob3JQb2ludChlZGdlWm9uZSwgZWRnZU9mZnNldCwgZWRnZVVuaXQsIG1hcmdpbiA9IGVtcHR5QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgLy8gRWRnZSB6b25lcyBnbyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgICAgLy8gRWFjaCBvbmUgY2FsY3VsYXRlcyB0aGUgc3RhcnQgcG9pbnQgb2YgdGhhdCBlZGdlIHRoZW4gbW92ZXMgYWxvbmcgaXQgYnlcbiAgICAgICAgLy8gdGhlIGVkZ2VPZmZzZXQsIHRoZW4gbW92ZXMgKmF3YXkqIGZyb20gaXQgYnkgdGhlIG1hcmdpbiBmb3IgdGhhdCBlZGdlIGlmIHRoZXJlJ3MgYSBtYXJnaW4uXG4gICAgICAgIHN3aXRjaCAoZWRnZVpvbmUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCwgbWUueSAtIChtYXJnaW5bMF0gfHwgMCksIG1lLndpZHRoLCAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCArIG1lLndpZHRoICsgKG1hcmdpblsxXSB8fCAwKSwgbWUueSwgbWUuaGVpZ2h0LCAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCwgbWUueSArIG1lLmhlaWdodCArIChtYXJnaW5bMl0gfHwgMCksIG1lLndpZHRoLCAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCAtIChtYXJnaW5bM10gfHwgMCksIG1lLnksIG1lLmhlaWdodCwgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc3VsdFszXV0gKz0gZWRnZVVuaXQgPT09ICclJyA/IHJlc3VsdFsyXSAvIDEwMCAqIGVkZ2VPZmZzZXQgOiBlZGdlT2Zmc2V0O1xuICAgICAgICByZXN1bHQubGVuZ3RoID0gMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgRE9NUmVjdCAmJlxuICAgICAgICAgICAgb3RoZXIueCA9PT0gdGhpcy54ICYmXG4gICAgICAgICAgICBvdGhlci55ID09PSB0aGlzLnkgJiZcbiAgICAgICAgICAgIG90aGVyLmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgICAgICAgIG90aGVyLndpZHRoID09PSB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgb25seVxuICAgIHNob3coY29sb3IgPSAncmVkJykge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBkaXYuc3R5bGUgPSBgXG4gICAgICAgICAgICBwb3NpdGlvbjphYnNvbHV0ZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTp0cmFuc2xhdGUzZCgke3RoaXMueH1weCwgJHt0aGlzLnl9cHgsIDApO1xuICAgICAgICAgICAgaGVpZ2h0OiR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICB3aWR0aDoke3RoaXMud2lkdGh9cHg7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiR7Y29sb3J9XG4gICAgICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBkaXYucmVtb3ZlKCksIDMwMDAwKTtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIEpTT04uc3RyaW5naWZ5KHRoaXMpLCB3ZSB3YW50IHRvIGFkZCBtaW5IZWlnaHQgJiBtaW5XaWR0aCB0byB0aGUgb3V0cHV0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIG1pbkhlaWdodCwgbWluV2lkdGgsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIG1pbkhlaWdodCwgbWluV2lkdGgsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fVxuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5TdHJpbmdcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgU3RyaW5nVXRpbCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gY2hhckVudGl0eU1hcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hhckVudGl0eU1hcCA9IHtcbiAgICAgICAgJyYnIDogJyZhbXA7JyxcbiAgICAgICAgJzwnIDogJyZsdDsnLFxuICAgICAgICAnPicgOiAnJmd0OycsXG4gICAgICAgICdcIicgOiAnJnF1b3Q7JyxcbiAgICAgICAgJ1xcJyc6ICcmYXBvczsnLFxuICAgICAgICAnJCcgOiAnJmRvbGxhcjsnLFxuICAgICAgICAnXFxcXCc6ICcmYnNvbDsnLFxuICAgICAgICAnLycgOiAnJnNvbDsnXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gY2hhclBhdHRlcm5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNoYXJQYXR0ZXJuID0gL1smPD5cIickXFxcXF0vZ1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gZW50aXR5UGF0dGVyblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZW50aXR5UGF0dGVybiA9IC8oJmFtcDspfCgmbHQ7KXwoJmd0Oyl8KCZxdW90Oyl8KCZhcG9zOyl8KCZkb2xsYXI7KXwoJmJzb2w7KXwoJnNvbDspL2dcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuU3RyaW5nJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5TdHJpbmcnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlIEhUTUwgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGVzY2FwZUh0bWwodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpczsgLy8gaW5zaWRlIGEgc3RhdGljIG1ldGhvZCwgd2UgYXJlIHBvaW50aW5nIHRvIHRoZSBjbGFzcyBwcm90b3R5cGVcblxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobWUuY2hhclBhdHRlcm4sIG1lLmdldEVudGl0eUZyb21DaGFyLmJpbmQobWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjaGFyIGVxdWl2YWxlbnQgb2YgYSBtYXBwZWQgZW50aXR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVudGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFyRnJvbUVudGl0eShlbnRpdHkpIHtcbiAgICAgICAgbGV0IG1hcHBlZENoYXIgPSBPYmplY3Qua2V5cyh0aGlzLmNoYXJFbnRpdHlNYXApLmZpbmQoa2V5ID0+IHRoaXMuY2hhckVudGl0eU1hcFtrZXldID09PSBlbnRpdHkpO1xuICAgICAgICByZXR1cm4gbWFwcGVkQ2hhciB8fCBlbnRpdHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZW50aXR5IGVxdWl2YWxlbnQgb2YgYSBtYXBwZWQgY2hhclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyXG4gICAgICovXG4gICAgc3RhdGljIGdldEVudGl0eUZyb21DaGFyKGNoYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVudGl0eU1hcFtjaGFyXSB8fCBjaGFyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5lc2NhcGUgSFRNTCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgdW5lc2NhcGVIdG1sKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7IC8vIGluc2lkZSBhIHN0YXRpYyBtZXRob2QsIHdlIGFyZSBwb2ludGluZyB0byB0aGUgY2xhc3MgcHJvdG90eXBlXG5cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG1lLmVudGl0eVBhdHRlcm4sIG1lLmdldENoYXJGcm9tRW50aXR5LmJpbmQobWUpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhc3NlZCBzdHJpbmcgd2l0aCB0aGUgZmlyc3QgbGV0dGVyIHVuY2FwaXRhbGl6ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMgIHtTdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHVuY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbMF0udG9Mb3dlckNhc2UoKSArIHZhbHVlLnN1YnN0cmluZygxKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3RyaW5nVXRpbCk7XG4iLCIvKipcbiAqIFRoZSBmb2xsb3dpbmcgdG9wLWxldmVsIGF0dHJpYnV0ZXMgd2lsbCBnZXQgY29udmVydGVkIGludG8gc3R5bGVzOlxuICogaGVpZ2h0LCBtYXhIZWlnaHQsIG1heFdpZHRoLCBtaW5IZWlnaHQsIG1pbldpZHRoLCB3aWR0aFxuICpcbiAqIFNvbWUgdGFncyBtdXN0IG5vdCBkbyB0aGUgdHJhbnNmb3JtYXRpb24sIHNvIHdlIGFkZCB0aGVtIGhlcmUuXG4gKiBAbWVtYmVyIHtTZXR9IHJhd0RpbWVuc2lvblRhZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHJhd0RpbWVuc2lvblRhZ3MgPSBuZXcgU2V0KFtcbiAgICAnY2lyY2xlJyxcbiAgICAnY2xpcFBhdGgnLFxuICAgICdlbGxpcHNlJyxcbiAgICAnZmlsdGVyJyxcbiAgICAnZm9yZWlnbk9iamVjdCcsXG4gICAgJ2ltYWdlJyxcbiAgICAnbWFya2VyJyxcbiAgICAnbWFzaycsXG4gICAgJ3BhdHRlcm4nLFxuICAgICdyZWN0JyxcbiAgICAnc3ZnJyxcbiAgICAndXNlJ1xuXSk7XG5cbi8qKlxuICogVm9pZCBhdHRyaWJ1dGVzIGluc2lkZSBodG1sIHRhZ3NcbiAqIEBtZW1iZXIge1NldH0gdm9pZEF0dHJpYnV0ZXNcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHZvaWRBdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgJ2NoZWNrZWQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnaXNtYXAnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ25vaHJlZicsXG4gICAgJ25vcmVzaXplJyxcbiAgICAnbm9zaGFkZScsXG4gICAgJ25vd3JhcCcsXG4gICAgJ29wZW4nLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl0pO1xuXG4vKipcbiAqIFZvaWQgaHRtbCB0YWdzXG4gKiBAbWVtYmVyIHtTZXR9IHZvaWRFbGVtZW50c1xuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY29uc3Qgdm9pZEVsZW1lbnRzID0gbmV3IFNldChbXG4gICAgJ2FyZWEnLFxuICAgICdiYXNlJyxcbiAgICAnYnInLFxuICAgICdjb2wnLFxuICAgICdlbWJlZCcsXG4gICAgJ2hyJyxcbiAgICAnaW1nJyxcbiAgICAnaW5wdXQnLFxuICAgICdsaW5rJyxcbiAgICAnbWV0YScsXG4gICAgJ3BhcmFtJyxcbiAgICAnc291cmNlJyxcbiAgICAndHJhY2snLFxuICAgICd3YnInXG5dKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgRG9tQWNjZXNzICAgICAgICAgIGZyb20gJy4uL21haW4vRG9tQWNjZXNzLm1qcyc7XG5pbXBvcnQgRG9tRXZlbnRzICAgICAgICAgIGZyb20gJy4uL21haW4vRG9tRXZlbnRzLm1qcyc7XG5pbXBvcnQgTWVzc2FnZSAgICAgICAgICAgIGZyb20gJy4vTWVzc2FnZS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBSZW1vdGVNZXRob2RBY2Nlc3MgZnJvbSAnLi9taXhpbi9SZW1vdGVNZXRob2RBY2Nlc3MubWpzJztcblxuY29uc3QgTmVvQ29uZmlnICAgID0gTmVvLmNvbmZpZyxcbiAgICAgIGhhc0pzTW9kdWxlcyA9IE5lb0NvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2RldmVsb3BtZW50JyB8fCBOZW9Db25maWcuZW52aXJvbm1lbnQgPT09ICdkaXN0L2VzbSc7XG5cbi8vIFVzaW5nID8uIHNpbmNlIFNXcyBkbyBub3QgZXhpc3QgZm9yIGh0dHAgKG9ubHkgaHR0cHMpXG5uYXZpZ2F0b3Iuc2VydmljZVdvcmtlcj8uYWRkRXZlbnRMaXN0ZW5lcignY29udHJvbGxlcmNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxufSwge29uY2U6IHRydWV9KTtcblxuLyoqXG4gKiBAc3VtbWFyeSBPcmNoZXN0cmF0ZXMgdGhlIG11bHRpLXRocmVhZGVkIHdvcmtlciBlbnZpcm9ubWVudCBhbmQgaGFuZGxlcyBtZXNzYWdlIHJvdXRpbmcuXG4gKlxuICogVGhpcyBjbGFzcyBpcyB0aGUgY2VudHJhbCBuZXJ2b3VzIHN5c3RlbSBvZiB0aGUgTmVvLm1qcyBydW50aW1lIGluIHRoZSBtYWluIHRocmVhZC4gSXQgaXMgcmVzcG9uc2libGUgZm9yOlxuICogMS4gICoqV29ya2VyIENyZWF0aW9uOioqIEluc3RhbnRpYXRpbmcgdGhlIEFwcCwgRGF0YSwgVkRvbSwgYW5kIG90aGVyIHdvcmtlcnMgYmFzZWQgb24gY29uZmlndXJhdGlvbi5cbiAqIDIuICAqKk1lc3NhZ2UgUm91dGluZzoqKiBBY3RpbmcgYXMgdGhlIGh1YiBmb3IgaW50ZXItd29ya2VyIGNvbW11bmljYXRpb24uIFdoaWxlIHN0YW5kYXJkIG1lc3NhZ2VzIGFyZSByb3V0ZWRcbiAqICAgICB2aWEgdGhlIG1haW4gdGhyZWFkLCB0aGlzIG1hbmFnZXIgYWxzbyBmYWNpbGl0YXRlcyB0aGUgaW5pdGlhbCBoYW5kc2hha2UgdG8gZXN0YWJsaXNoIGRpcmVjdFxuICogICAgICoqTWVzc2FnZUNoYW5uZWwqKiBjb25uZWN0aW9ucyBiZXR3ZWVuIHdvcmtlcnMgKGUuZy4sIEFwcCA8LT4gQ2FudmFzKSBmb3IgaGlnaC1wZXJmb3JtYW5jZSxcbiAqICAgICBiaS1kaXJlY3Rpb25hbCBjb21tdW5pY2F0aW9uLiBUaGUgVkRPTSB1cGRhdGUgcHJvY2VzcyBpcyBhIG5vdGFibGUgZXhjZXB0aW9uLCB1c2luZyBhIHRyaWFuZ3VsYXJcbiAqICAgICBmbG93IChBcHAgLT4gVkRvbSAtPiBNYWluIC0+IEFwcCkgYnkgZGVzaWduLlxuICogMy4gICoqRE9NIFVwZGF0ZSBDb29yZGluYXRpb246KiogaW50ZXJjZXB0aW5nIFZET00gdXBkYXRlIHJlcXVlc3RzIGFuZCBzeW5jaHJvbml6aW5nIHRoZW0gd2l0aCB0aGVcbiAqICAgICBicm93c2VyJ3MgYW5pbWF0aW9uIGZyYW1lIHRvIGVuc3VyZSBzbW9vdGggcmVuZGVyaW5nLiBUaGlzIGludm9sdmVzIGEgY29tcGxleCBwcm9taXNlLWJhc2VkXG4gKiAgICAgbWVjaGFuaXNtIHRvIGRlbGF5IHdvcmtlciByZXBsaWVzIHVudGlsIHRoZSBET00gY2hhbmdlcyBhcmUgYWN0dWFsbHkgcGFpbnRlZC5cbiAqIDQuICAqKkNvbmZpZ3VyYXRpb24gTWFuYWdlbWVudDoqKiBzeW5jaHJvbml6aW5nIGBOZW8uY29uZmlnYCBjaGFuZ2VzIGFjcm9zcyBhbGwgdGhyZWFkcy5cbiAqXG4gKiBAY2xhc3MgTmVvLndvcmtlci5NYW5hZ2VyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICogQG1peGVzIE5lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIE1hbmFnZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby53b3JrZXIuTWFuYWdlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLndvcmtlci5NYW5hZ2VyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYWN0aXZlV29ya2Vycz0wXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZVdvcmtlcnM6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYXBwTmFtZXM9W11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwTmFtZXM6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb25zdHJ1Y3RlZFRocmVhZHM9MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RlZFRocmVhZHM6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxOZW8uY29yZS5CYXNlW118bnVsbH0gbWl4aW5zPVtPYnNlcnZhYmxlLCBSZW1vdGVNZXRob2RBY2Nlc3NdXG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbnM6IFtPYnNlcnZhYmxlLCBSZW1vdGVNZXRob2RBY2Nlc3NdLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHAgICA6IFsnc2V0TmVvQ29uZmlnJ10sXG4gICAgICAgICAgICBjYW52YXM6IFsnc2V0TmVvQ29uZmlnJ10sXG4gICAgICAgICAgICBkYXRhICA6IFsnc2V0TmVvQ29uZmlnJ10sXG4gICAgICAgICAgICB0YXNrICA6IFsnc2V0TmVvQ29uZmlnJ10sXG4gICAgICAgICAgICB2ZG9tICA6IFsnc2V0TmVvQ29uZmlnJ11cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaW4gY2FzZSB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHdpbmRvdy5TaGFyZWRXb3JrZXIuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNoYXJlZFdvcmtlcnNFbmFibGVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNoYXJlZFdvcmtlcnNFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcCB0aGUgd29ya2VyIGNvbW11bmljYXRpb24gaW4gY2FzZSB0aGVpciBjcmVhdGlvbiBmYWlsc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzdG9wQ29tbXVuaWNhdGlvbj1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wQ29tbXVuaWNhdGlvbjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluIGNhc2UgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyB3aW5kb3cuV29ya2VyLlxuICAgICAgICAgKiBUaGUgbmVvLm1qcyBmcmFtZXdvcmsgaXMgbm90IGFibGUgdG8gcnVuIHdpdGhvdXQgd2ViIHdvcmtlcnMuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNoYXJlZFdvcmtlcnNFbmFibGVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHdlYldvcmtlcnNFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzaW5nIGNyeXB0by5yYW5kb21VVUlEKCkgYXMgYSB1bmlxdWUgd2luZG93IGlkZW50aWZpZXJcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB3aW5kb3dJZD13aW5kb3cuX19ORU9fU1NSX18/LndpbmRvd0lkfHxjcnlwdG8ucmFuZG9tVVVJRCgpXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkOiB3aW5kb3cuX19ORU9fU1NSX18/LndpbmRvd0lkIHx8IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250YWlucyB0aGUgZmlsZU5hbWVzIGZvciB0aGUgQXBwLCBEYXRhICYgVmRvbSB3b3JrZXJzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gd29ya2Vyc1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB3b3JrZXJzOiB7XG4gICAgICAgICAgICBhcHA6IHtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogaGFzSnNNb2R1bGVzID8gJ0FwcC5tanMnICAgIDogJ2FwcHdvcmtlci5qcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW52YXM6IHtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogaGFzSnNNb2R1bGVzID8gJ0NhbnZhcy5tanMnIDogJ2NhbnZhc3dvcmtlci5qcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGhhc0pzTW9kdWxlcyA/ICdEYXRhLm1qcycgICA6ICdkYXRhd29ya2VyLmpzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhc2s6IHtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogaGFzSnNNb2R1bGVzID8gJ1Rhc2subWpzJyAgIDogJ3Rhc2t3b3JrZXIuanMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmRvbToge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBoYXNKc01vZHVsZXMgPyAnVkRvbS5tanMnICAgOiAndmRvbXdvcmtlci5qcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIgY2FuIGJlIG51bGwgaW4gY2FzZSB3ZSBsb2FkIGEgcGFnZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgKiBvciBpbiBjYXNlIG9mIGEgZm9yY2UgcmVmcmVzaC5cbiAgICAgKiBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZXJ2aWNlLXdvcmtlcnMvI25hdmlnYXRvci1zZXJ2aWNlLXdvcmtlci1jb250cm9sbGVyXG4gICAgICogT25seSBpbiB0aGlzIGNhc2UgbWFpbi5hZGRvbi5TZXJ2aWNlV29ya2VyIHdpbGwgc3RvcmUgdGhlIGFjdGl2ZSByZWdpc3RyYXRpb24gb25jZSByZWFkeSBoZXJlLlxuICAgICAqIEBtZW1iZXIge1NlcnZpY2VXb3JrZXJ8bnVsbH0gc2VydmljZVdvcmtlcj1udWxsXG4gICAgICovXG4gICAgc2VydmljZVdvcmtlciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZGV0ZWN0RmVhdHVyZXMoKTtcblxuICAgICAgICAhTmVvLmluc2lkZVdvcmtlciAmJiBtZS5jcmVhdGVXb3JrZXJzKCk7XG5cbiAgICAgICAgTmVvLnNldEdsb2JhbENvbmZpZyA9IG1lLnNldEdsb2JhbENvbmZpZy5iaW5kKG1lKTtcbiAgICAgICAgTmVvLndvcmtlcklkICAgICAgICA9ICdtYWluJztcblxuICAgICAgICBtZS5wcm9taXNlcyA9IHt9O1xuXG4gICAgICAgIG1lLm9uKHtcbiAgICAgICAgICAgICdtZXNzYWdlOmFkZERvbUxpc3RlbmVyJyAgICA6IHtmbjogRG9tRXZlbnRzLmFkZERvbUxpc3RlbmVyLCAgICAgICBzY29wZTogRG9tRXZlbnRzfSxcbiAgICAgICAgICAgICdtZXNzYWdlOmdldE9mZnNjcmVlbkNhbnZhcyc6IHtmbjogRG9tQWNjZXNzLm9uR2V0T2Zmc2NyZWVuQ2FudmFzLCBzY29wZTogRG9tQWNjZXNzfSxcbiAgICAgICAgICAgICdtZXNzYWdlOnJlYWREb20nICAgICAgICAgICA6IHtmbjogRG9tQWNjZXNzLm9uUmVhZERvbSwgICAgICAgICAgICBzY29wZTogRG9tQWNjZXNzfSxcbiAgICAgICAgICAgICdtZXNzYWdlOnJlZ2lzdGVyUmVtb3RlJyAgICA6IHtmbjogbWUub25SZWdpc3RlclJlbW90ZSwgICAgICAgICAgICBzY29wZTogbWV9LFxuICAgICAgICAgICAgJ21lc3NhZ2U6d29ya2VyQ29uc3RydWN0ZWQnIDoge2ZuOiBtZS5vbldvcmtlckNvbnN0cnVjdGVkLCAgICAgICAgIHNjb3BlOiBtZX1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gZWFjaCB3b3JrZXIgZGVmaW5lZCBpbnNpZGUgdGhlIHRoaXMud29ya2VycyBjb25maWcuXG4gICAgICogT25seSBzZW5kcyB0byB3b3JrZXJzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUgYW5kIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnICAgICAgICAgICAgIFRoZSBtZXNzYWdlIHBheWxvYWQgdG8gYnJvYWRjYXN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXhjbHVkZU9yaWdpbl0gT3B0aW9uYWxseSBwYXNzIHRoZSBvcmlnaW4gcmVhbG0gbmFtZSB0byBleGNsdWRlIGZyb20gdGhlIGJyb2FkY2FzdC5cbiAgICAgKi9cbiAgICBicm9hZGNhc3QobXNnLCBleGNsdWRlT3JpZ2luKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgT2JqZWN0LmtleXMobWUud29ya2VycykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBleGNsdWRlT3JpZ2luICYmIG1lLmdldFdvcmtlcihuYW1lKSkge1xuICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKG5hbWUsIG1zZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgd2ViIHdvcmtlciB1c2luZyB0aGUgcGFzc2VkIG9wdGlvbnMgYXMgd2VsbCBhcyBhZGRpbmcgZXJyb3IgJiBtZXNzYWdlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEByZXR1cm5zIHtTaGFyZWRXb3JrZXJ8V29ya2VyfVxuICAgICAqL1xuICAgIGNyZWF0ZVdvcmtlcihvcHRzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmaWxlTmFtZX0gPSBvcHRzLFxuICAgICAgICAgICAgZmlsZVBhdGggICA9IChvcHRzLmJhc2VQYXRoIHx8IE5lby5jb25maWcud29ya2VyQmFzZVBhdGgpICsgZmlsZU5hbWUsXG4gICAgICAgICAgICBuYW1lICAgICAgID0gYG5lb21qcy0ke2ZpbGVOYW1lLnN1YnN0cmluZygwLCBmaWxlTmFtZS5pbmRleE9mKCcuJykpLnRvTG93ZXJDYXNlKCl9LXdvcmtlcmAsXG4gICAgICAgICAgICBpc1NoYXJlZCAgID0gbWUuc2hhcmVkV29ya2Vyc0VuYWJsZWQgJiYgTmVvQ29uZmlnLnVzZVNoYXJlZFdvcmtlcnMsXG4gICAgICAgICAgICBjbHMgICAgICAgID0gaXNTaGFyZWQgPyBTaGFyZWRXb3JrZXIgOiBXb3JrZXIsXG4gICAgICAgICAgICB3b3JrZXIgICAgID0gaGFzSnNNb2R1bGVzXG4gICAgICAgICAgICAgICAgPyBuZXcgY2xzKGZpbGVQYXRoLCB7bmFtZSwgdHlwZTogJ21vZHVsZSd9KVxuICAgICAgICAgICAgICAgIDogbmV3IGNscyhmaWxlUGF0aCwge25hbWV9KTtcblxuICAgICAgICAoaXNTaGFyZWQgPyB3b3JrZXIucG9ydCA6IHdvcmtlcikub25tZXNzYWdlID0gbWUub25Xb3JrZXJNZXNzYWdlLmJpbmQobWUpO1xuICAgICAgICAoaXNTaGFyZWQgPyB3b3JrZXIucG9ydCA6IHdvcmtlcikub25lcnJvciAgID0gbWUub25Xb3JrZXJFcnJvciAgLmJpbmQobWUpO1xuXG4gICAgICAgIG1lLmFjdGl2ZVdvcmtlcnMrKztcblxuICAgICAgICByZXR1cm4gd29ya2VyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSW5zdGFudGlhdGVzIHRoZSBjb25maWd1cmVkIHdvcmtlciB0aHJlYWRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmVhZHMgdGhlIGBOZW8uY29uZmlnYCB0byBkZXRlcm1pbmUgd2hpY2ggd29ya2VycyB0byBjcmVhdGUgKEFwcCwgRGF0YSwgVkRvbSwgZXRjLilcbiAgICAgKiBhbmQgd2hldGhlciB0byB1c2UgYFdvcmtlcmAgb3IgYFNoYXJlZFdvcmtlcmAuIEl0IGluamVjdHMgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBhbmQgZW52aXJvbm1lbnRcbiAgICAgKiBkYXRhIChsaWtlIHdpbmRvdyBJRCkgaW50byBlYWNoIHdvcmtlciB1cG9uIGNyZWF0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZVdvcmtlcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgICAgICAgICAgICAgICA9IE5lby5jbG9uZShOZW9Db25maWcsIHRydWUpLFxuICAgICAgICAgICAge2hhc2gsIGhyZWYsIHNlYXJjaH0gPSBsb2NhdGlvbixcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICBzc3JEYXRhICAgICAgICAgICAgICA9IHdpbmRvdy5fX05FT19TU1JfXyxcbiAgICAgICAgICAgIGtleSwgdmFsdWU7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvbmZpZ3Mgd2hpY2ggYXJlIG5vdCByZWxldmFudCBmb3IgdGhlIHdvcmtlcnMgc2NvcGVcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5jZXNpdW1Kc1Rva2VuO1xuXG4gICAgICAgIC8vIHBhc3MgdGhlIGluaXRpYWwgaGFzaCB2YWx1ZSBhcyBOZW8uY29uZmlnc1xuICAgICAgICBpZiAoaGFzaCkge1xuICAgICAgICAgICAgY29uZmlnLmhhc2ggPSB7XG4gICAgICAgICAgICAgICAgaGFzaCAgICAgIDogRG9tRXZlbnRzLnBhcnNlSGFzaChoYXNoLnN1YnN0cmluZygxKSksXG4gICAgICAgICAgICAgICAgaGFzaFN0cmluZzogaGFzaC5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy51cmwgPSB7aHJlZiwgc2VhcmNofTtcblxuICAgICAgICBmb3IgKFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZS53b3JrZXJzKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NhbnZhcycgJiYgIWNvbmZpZy51c2VDYW52YXNXb3JrZXIgfHxcbiAgICAgICAgICAgICAgICBrZXkgPT09ICd0YXNrJyAgICYmICFjb25maWcudXNlVGFza1dvcmtlciAgIHx8XG4gICAgICAgICAgICAgICAga2V5ID09PSAndmRvbScgICAmJiAhY29uZmlnLnVzZVZkb21Xb3JrZXJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUud29ya2VyID0gbWUuY3JlYXRlV29ya2VyKHZhbHVlKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gZTtcbiAgICAgICAgICAgICAgICBtZS5zdG9wQ29tbXVuaWNhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHdvcmtlckNvbmZpZyA9IHsuLi5jb25maWcsIHdpbmRvd0lkfTtcblxuICAgICAgICAgICAgaWYgKHNzckRhdGEgJiYga2V5ID09PSAnYXBwJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24od29ya2VyQ29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNzc01hcCA6IHNzckRhdGEuY3NzTWFwLFxuICAgICAgICAgICAgICAgICAgICB1c2VTU1I6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZub2RlIDogc3NyRGF0YS52bm9kZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNzckRhdGEuaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJDb25maWcuaGFzaCA9IHNzckRhdGEuaGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKGtleSwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3JlZ2lzdGVyTmVvQ29uZmlnJyxcbiAgICAgICAgICAgICAgICBkYXRhICA6IHdvcmtlckNvbmZpZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGV0ZWN0RmVhdHVyZXMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvQ29uZmlnLmhhc01vdXNlRXZlbnRzID0gbWF0Y2hNZWRpYSgnKHBvaW50ZXI6ZmluZSknKS5tYXRjaGVzO1xuICAgICAgICBOZW9Db25maWcuaGFzVG91Y2hFdmVudHMgPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCAobmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCk7XG5cbiAgICAgICAgLy8gVXNlZnVsIGZvciBzdHlsaW5nXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChOZW9Db25maWcuaGFzTW91c2VFdmVudHMgPyAnbmVvLW1vdXNlJyA6ICduZW8tbm8tbW91c2UnKTtcblxuICAgICAgICBpZiAod2luZG93Lldvcmtlcikge1xuICAgICAgICAgICAgbWUud2ViV29ya2Vyc0VuYWJsZWQgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYiBXb3JrZXJzJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cuU2hhcmVkV29ya2VyKSB7XG4gICAgICAgICAgICBtZS5zaGFyZWRXb3JrZXJzRW5hYmxlZCA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFdvcmtlcn0gbmFtZVxuICAgICAqIEByZXR1cm5zIHtXb3JrZXJ9XG4gICAgICovXG4gICAgZ2V0V29ya2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzZXJ2aWNlJykge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyPy5jb250cm9sbGVyIHx8IHRoaXMuc2VydmljZVdvcmtlclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWUgaW5zdGFuY2VvZiBXb3JrZXIgPyBuYW1lIDogdGhpcy53b3JrZXJzW25hbWVdLndvcmtlclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzV29ya2VyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRXb3JrZXIobmFtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRoZSBxdWV1aW5nIGFuZCBwcm9jZXNzaW5nIG9mIERPTSB1cGRhdGUgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCBjZW50cmFsaXplcyB0aGUgbG9naWMgZm9yIGJvdGggc3RhbmRhcmQgVkRPTSB1cGRhdGVzIGFuZCBkaXJlY3QgYEFwcC5hcHBseURlbHRhc2AgY2FsbHMuXG4gICAgICogSXRzIHByaW1hcnkgcHVycG9zZSBpcyB0byBlbmZvcmNlIHRoZSAqKlwiZGVsYXllZCByZXBseVwiKiogcGF0dGVybjpcbiAgICAgKiAtIElmIHRoZSB1cGRhdGUgY29udGFpbnMgdmlzdWFsIGNoYW5nZXMgKGRlbHRhcyksIGl0IHJlZ2lzdGVycyBhIHByb21pc2UgYW5kIHF1ZXVlcyB0aGUgdXBkYXRlIGZvciB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAgICogICBUaGUgcmVwbHkgdG8gdGhlIHdvcmtlciBpcyBzZW50IG9ubHkgKmFmdGVyKiB0aGUgbWFpbiB0aHJlYWQgaGFzIHByb2Nlc3NlZCB0aGUgcXVldWUsIGVuc3VyaW5nIHRoZSBET00gaXMgdXBkYXRlZC5cbiAgICAgKiAtIElmIHRoZSB1cGRhdGUgaXMgYSBuby1vcCAoemVybyBkZWx0YXMpLCBpdCBzZW5kcyBhbiBpbW1lZGlhdGUgcmVwbHkgdG8gYXZvaWQgdW5uZWNlc3NhcnkgbGF0ZW5jeS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsc28gaGFuZGxlcyB0aGUgZmlyaW5nIG9mIHRoZSBgdXBkYXRlVmRvbWAgZXZlbnQsIHdoaWNoIHRyaWdnZXJzIHRoZSBhY3R1YWwgcHJvY2Vzc2luZyBpbiBgTWFpbi5tanNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIG1lc3NhZ2UgcGF5bG9hZCBmcm9tIHRoZSB3b3JrZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGVsdGFzIFRoZSBhcnJheSBvZiBET00gZGVsdGFzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGx5RGVzdCBUaGUgZGVzdGluYXRpb24gZm9yIHRoZSByZXBseSBtZXNzYWdlIChlLmcuLCAnYXBwJykuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yd2FyZD1mYWxzZV0gSWYgdHJ1ZSwgZm9yd2FyZHMgdGhlIG9yaWdpbmFsIG1lc3NhZ2UgYXMgdGhlIHJlcGx5IChWRE9NIHdvcmtlciBwYXRoKS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBmYWxzZSwgY29uc3RydWN0cyBhIG5ldyBzdWNjZXNzIHJlcGx5IChBcHAgd29ya2VyIHBhdGgpLlxuICAgICAqL1xuICAgIGhhbmRsZURvbVVwZGF0ZShkYXRhLCBkZWx0YXMsIHJlcGx5RGVzdCwgZm9yd2FyZD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkZWx0YXM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1lLnByb21pc2VGb3J3YXJkTWVzc2FnZShkYXRhKS50aGVuKG1zZ0RhdGEgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKHJlcGx5RGVzdCwgZm9yd2FyZCA/IG1zZ0RhdGEgOiB7YWN0aW9uOiAncmVwbHknLCByZXBseUlkOiBtc2dEYXRhLmlkLCBzdWNjZXNzOiB0cnVlfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5maXJlKCd1cGRhdGVWZG9tJywgZm9yd2FyZCA/IGRhdGEgOiB7ZGF0YSwgcmVwbHlJZDogZGF0YS5pZH0pO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5zZW5kTWVzc2FnZShyZXBseURlc3QsIGZvcndhcmQgPyBkYXRhIDoge2FjdGlvbjogJ3JlcGx5JywgcmVwbHlJZDogZGF0YS5pZCwgc3VjY2VzczogdHJ1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBsb2FkQXBwbGljYXRpb24oKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ2FwcCcsIHthY3Rpb246ICdsb2FkQXBwbGljYXRpb24nIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbldvcmtlckNvbnN0cnVjdGVkKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jb25zdHJ1Y3RlZFRocmVhZHMrKztcblxuICAgICAgICAvLyBUbyBpbmNsdWRlIHRoZSBtYWluIHRocmVhZCBhcyByZWFkeSwgd2UgbXVzdCB3YWl0IGZvciBhY3RpdmVXb3JrZXJzICsgMVxuICAgICAgICBpZiAobWUuY29uc3RydWN0ZWRUaHJlYWRzID09PSBtZS5hY3RpdmVXb3JrZXJzICsgMSkge1xuICAgICAgICAgICAgLy8gYmV0dGVyIHNhZmUgdGhhbiBzb3JyeSA9PiBhbGwgcmVtb3RlcyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIE5lb0NvbmZpZy5hcHBQYXRoICYmIG1lLnRpbWVvdXQoTmVvQ29uZmlnLmxvYWRBcHBsaWNhdGlvbkRlbGF5KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5sb2FkQXBwbGljYXRpb24oKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgbWV0aG9kIGZvciB3b3JrZXIgZXJyb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICAgKi9cbiAgICBvbldvcmtlckVycm9yKGUpIHtcbiAgICAgICAgLy8gc3RhcnRpbmcgYSB3b3JrZXIgZnJvbSBhIEpTIG1vZHVsZSB3aWxsIHNob3cgSlMgZXJyb3JzIGluIGEgY29ycmVjdCB3YXlcbiAgICAgICAgIWhhc0pzTW9kdWxlcyAmJiBjb25zb2xlLmxvZygnV29ya2VyIEVycm9yOicsIGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBtZXRob2QgZm9yIHdvcmtlciBtZXNzYWdlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEludGVyY2VwdHMgYW5kIHJvdXRlcyBtZXNzYWdlcyBmcm9tIHdvcmtlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjb250YWlucyBjcml0aWNhbCByb3V0aW5nIGxvZ2ljOlxuICAgICAqIDEuICAqKkRPTSBVcGRhdGUgSW50ZXJjZXB0aW9uOioqIEl0IGNhdGNoZXMgYHVwZGF0ZVZkb21gIGFjdGlvbnMgKGZyb20gQXBwKSBhbmQgYHJlcGx5YCBtZXNzYWdlcyAoZnJvbSBWRG9tKVxuICAgICAqICAgICB0aGF0IGNvbnRhaW4gRE9NIHVwZGF0ZXMuIEl0IG5vcm1hbGl6ZXMgYGF1dG9Nb3VudGAgb3BlcmF0aW9ucyBpbnRvIGBpbnNlcnROb2RlYCBkZWx0YXMgYW5kIGRlbGVnYXRlc1xuICAgICAqICAgICB0aGVtIHRvIGBoYW5kbGVEb21VcGRhdGVgLlxuICAgICAqIDIuICAqKlByb21pc2UgUmVzb2x1dGlvbjoqKiBJdCByZXNvbHZlcyBwZW5kaW5nIHByb21pc2VzIGZvciBgcmVwbHlgIG1lc3NhZ2VzIChlLmcuLCByZW1vdGUgbWV0aG9kIGNhbGxzKS5cbiAgICAgKiAzLiAgKipNZXNzYWdlIEZvcndhcmRpbmc6KiogSXQgcm91dGVzIG1lc3NhZ2VzIGJldHdlZW4gd29ya2VycyAoZS5nLiwgQXBwIC0+IERhdGEpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgb25Xb3JrZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZGF0YX0gICA9IGV2ZW50LFxuICAgICAgICAgICAgdHJhbnNmZXIgPSBudWxsLFxuICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICBjb25zdCB7YWN0aW9uLCBkZXN0aW5hdGlvbjogZGVzdCwgcmVwbHlJZH0gPSBkYXRhO1xuXG4gICAgICAgIG1lLmZpcmUoJ21lc3NhZ2U6JythY3Rpb24sIGRhdGEpO1xuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICd1cGRhdGVWZG9tJykge1xuICAgICAgICAgICAgZGF0YS5yZXBseUlkID0gZGF0YS5pZDtcbiAgICAgICAgICAgIG1lLmhhbmRsZURvbVVwZGF0ZShkYXRhLCBkYXRhLmRlbHRhcywgZGF0YS5vcmlnaW4sIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JlcGx5Jykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG1lLnByb21pc2VzW3JlcGx5SWRdO1xuXG4gICAgICAgICAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF5bG9hZCA9IGRhdGEuZGF0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmF1dG9Nb3VudCB8fCBwYXlsb2FkLnVwZGF0ZVZkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YXMgPSBwYXlsb2FkLmRlbHRhcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuYXV0b01vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uICAgOiAnaW5zZXJ0Tm9kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICAgIDogcGF5bG9hZC5wYXJlbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJIVE1MOiBwYXlsb2FkLm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgOiBwYXlsb2FkLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZSAgICA6IHBheWxvYWQudm5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZGVsdGFzID0gZGVsdGFzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmhhbmRsZURvbVVwZGF0ZShkYXRhLCBkZWx0YXMsIGRlc3QsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZShkZXN0LCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdCA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmRhdGFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlW2RhdGEucmVqZWN0ID8gJ3JlamVjdCcgOiAncmVzb2x2ZSddKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUucHJvbWlzZXNbcmVwbHlJZF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzdCAhPT0gJ21haW4nICYmIGRlc3QgIT09IG1lLndpbmRvd0lkICYmIGFjdGlvbiAhPT0gJ3JlcGx5Jykge1xuICAgICAgICAgICAgaWYgKGRhdGEudHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2ZlciA9IFtkYXRhLnRyYW5zZmVyXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5wcm9taXNlTWVzc2FnZShkZXN0LCBkYXRhLCB0cmFuc2ZlcikudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UocmVzcG9uc2UuZGVzdGluYXRpb24sIHJlc3BvbnNlKVxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZShkYXRhLm9yaWdpbiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gOiAncmVwbHknLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZXBseUlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvciAgOiBlcnIubWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBuZWVkZWQgZm9yIFNoYXJlZFdvcmtlcnNcbiAgICAgICAgZWxzZSBpZiAoKGRlc3QgPT09ICdtYWluJyB8fCBkZXN0ID09PSBtZS53aW5kb3dJZCkgJiYgYWN0aW9uID09PSAncmVnaXN0ZXJBcHBOYW1lJykge1xuICAgICAgICAgICAgbGV0IHthcHBOYW1lfSA9IGRhdGE7XG5cbiAgICAgICAgICAgIG1lLmFwcE5hbWVzLnB1c2goYXBwTmFtZSk7XG5cbiAgICAgICAgICAgIG1lLmJyb2FkY2FzdCh7YWN0aW9uOiAncmVnaXN0ZXJBcHAnLCBhcHBOYW1lfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKChkZXN0ID09PSAnbWFpbicgfHwgZGVzdCA9PT0gbWUud2luZG93SWQpICYmIGFjdGlvbiA9PT0gJ3JlbW90ZU1ldGhvZCcpIHtcbiAgICAgICAgICAgIG1lLm9uUmVtb3RlTWV0aG9kKGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnJlcGx5SWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHByb21pc2VGb3J3YXJkTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb21pc2VzW2RhdGEucmVwbHlJZF0gPSB7ZGF0YSwgcmVqZWN0LCByZXNvbHZlfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0IGFwcCwgY2FudmFzLCBkYXRhIG9yIHZkb21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBjb25maWdzIGZvciBOZW8ud29ya2VyLk1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmZXJdIEFuIG9wdGlvbmFsIGFycmF5IG9mIFRyYW5zZmVyYWJsZSBvYmplY3RzIHRvIHRyYW5zZmVyIG93bmVyc2hpcCBvZi5cbiAgICAgKiBJZiB0aGUgb3duZXJzaGlwIG9mIGFuIG9iamVjdCBpcyB0cmFuc2ZlcnJlZCwgaXQgYmVjb21lcyB1bnVzYWJsZSAobmV1dGVyZWQpIGluIHRoZSBjb250ZXh0IGl0IHdhcyBzZW50IGZyb21cbiAgICAgKiBhbmQgYmVjb21lcyBhdmFpbGFibGUgb25seSB0byB0aGUgd29ya2VyIGl0IHdhcyBzZW50IHRvLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZU1lc3NhZ2UoZGVzdCwgb3B0cywgdHJhbnNmZXIpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBtZS5zZW5kTWVzc2FnZShkZXN0LCBvcHRzLCB0cmFuc2ZlciksXG4gICAgICAgICAgICAgICAgbXNnSWQ7XG5cbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IobWUuc3RvcENvbW11bmljYXRpb24gPyAnQ29tbXVuaWNhdGlvbiBpcyBzdG9wcGVkLicgOiBgVGFyZ2V0IHdvcmtlciAnJHtkZXN0fScgZG9lcyBub3QgZXhpc3QuYCkpO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtc2dJZCA9IG1lc3NhZ2UuaWQ7XG5cbiAgICAgICAgICAgIG1lLnByb21pc2VzW21zZ0lkXSA9IHtyZWplY3QsIHJlc29sdmV9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGx5SWRcbiAgICAgKi9cbiAgICByZXNvbHZlRG9tT3BlcmF0aW9uUHJvbWlzZShyZXBseUlkKSB7XG4gICAgICAgIGlmIChyZXBseUlkKSB7XG4gICAgICAgICAgICBsZXQge3Byb21pc2VzfSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJvbWlzZSAgICA9IHByb21pc2VzW3JlcGx5SWRdO1xuXG4gICAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShwcm9taXNlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9taXNlc1tyZXBseUlkXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlc3QgYXBwLCBjYW52YXMsIGRhdGEgb3IgdmRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIGNvbmZpZ3MgZm9yIE5lby53b3JrZXIuTWVzc2FnZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2Zlcl0gQW4gb3B0aW9uYWwgYXJyYXkgb2YgVHJhbnNmZXJhYmxlIG9iamVjdHMgdG8gdHJhbnNmZXIgb3duZXJzaGlwIG9mLlxuICAgICAqIElmIHRoZSBvd25lcnNoaXAgb2YgYW4gb2JqZWN0IGlzIHRyYW5zZmVycmVkLCBpdCBiZWNvbWVzIHVudXNhYmxlIChuZXV0ZXJlZCkgaW4gdGhlIGNvbnRleHQgaXQgd2FzIHNlbnQgZnJvbVxuICAgICAqIGFuZCBiZWNvbWVzIGF2YWlsYWJsZSBvbmx5IHRvIHRoZSB3b3JrZXIgaXQgd2FzIHNlbnQgdG8uXG4gICAgICogQHJldHVybnMge05lby53b3JrZXIuTWVzc2FnZXxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShkZXN0LCBvcHRzLCB0cmFuc2Zlcikge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbWVzc2FnZSwgd29ya2VyO1xuXG4gICAgICAgIGlmICghbWUuc3RvcENvbW11bmljYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmNoYW5uZWxQb3J0KSB7XG4gICAgICAgICAgICAgICAgd29ya2VyID0gb3B0cy5jaGFubmVsUG9ydDtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0cy5jaGFubmVsUG9ydFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIgPSBtZS5nZXRXb3JrZXIoZGVzdClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgICAgICAgIG9wdHMuZGVzdGluYXRpb24gPSBkZXN0O1xuICAgICAgICAgICAgICAgIG9wdHMud2luZG93SWQgPz89IG1lLndpbmRvd0lkO1xuXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKG9wdHMpO1xuXG4gICAgICAgICAgICAgICAgKHdvcmtlci5wb3J0ID8gd29ya2VyLnBvcnQgOiB3b3JrZXIpLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBnbG9iYWwgTmVvLmNvbmZpZyBjaGFuZ2UgZnJvbSB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhY3RzIGFzIGEgcHJveHksIHJvdXRpbmcgdGhlIGNvbmZpZyBjaGFuZ2UgcmVxdWVzdCB0byB0aGUgQXBwIFdvcmtlci5cbiAgICAgKiBUaGlzIGRlc2lnbiBjZW50cmFsaXplcyB0aGUgY29tcGxleCBtdWx0aS10aHJlYWRlZCBhbmQgbXVsdGktd2luZG93IHN5bmNocm9uaXphdGlvblxuICAgICAqIGxvZ2ljIHdpdGhpbiB0aGUgQXBwIFdvcmtlcidzIGBzZXRHbG9iYWxDb25maWdgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIERldmVsb3BlcnMgc2hvdWxkIHR5cGljYWxseSB1c2UgYE5lby5zZXRHbG9iYWxDb25maWcoY29uZmlnKWAgZGlyZWN0bHksXG4gICAgICogd2hpY2ggd2lsbCBjb3JyZWN0bHkgcmVzb2x2ZSB0byB0aGlzIHByb3h5IHdoZW4gY2FsbGVkIGZyb20gdGhlIE1haW4gVGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgcGFydGlhbCBvciBmdWxsIE5lby5jb25maWcgb2JqZWN0IHdpdGggY2hhbmdlcyB0byBhcHBseS5cbiAgICAgKi9cbiAgICBzZXRHbG9iYWxDb25maWcoY29uZmlnKSB7XG4gICAgICAgIC8vIFJlbW90ZWx5IGNhbGxzIHRoZSBBcHAgV29ya2VyJ3Mgc2V0R2xvYmFsQ29uZmlnIG1ldGhvZC5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGFsbCBnbG9iYWwgY29uZmlnIGNoYW5nZXMgYXJlIHByb2Nlc3NlZCB0aHJvdWdoIHRoZSBBcHAgV29ya2VyXG4gICAgICAgIC8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjZW50cmFsaXplZCBtdWx0aS13aW5kb3cgc3luY2hyb25pemF0aW9uIGxvZ2ljLlxuICAgICAgICBOZW8ud29ya2VyLkFwcC5zZXRHbG9iYWxDb25maWcoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBOZW8uY29uZmlnIGdsb2JhbGx5IGZyb20gYSB3b3JrZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuYnJvYWRjYXN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhLmNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgW2RhdGEuZXhjbHVkZU9yaWdpbl1cbiAgICAgKi9cbiAgICBzZXROZW9Db25maWcoe2Jyb2FkY2FzdCwgY29uZmlnLCBleGNsdWRlT3JpZ2lufSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5tZXJnZShOZW8uY29uZmlnLCBjb25maWcpO1xuXG4gICAgICAgIG1lLmZpcmUoJ25lb0NvbmZpZ0NoYW5nZScsIGNvbmZpZyk7XG5cbiAgICAgICAgYnJvYWRjYXN0ICYmIG1lLmJyb2FkY2FzdCh7YWN0aW9uOiAnc2V0TmVvQ29uZmlnJywgY29uZmlnfSwgZXhjbHVkZU9yaWdpbilcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1hbmFnZXIpO1xuIiwiaW1wb3J0IElkR2VuZXJhdG9yIGZyb20gJy4uL2NvcmUvSWRHZW5lcmF0b3IubWpzJztcblxuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIHdvcmtlciBwb3N0IG1lc3NhZ2VzIHNlbnQgYmV0d2VlbiB0aGUgQXBwLCBEYXRhLCBWRG9tIHdvcmtlciAmIHRoZSBtYWluIHRocmVhZC5cbiAqIFlvdSBjYW4gYWRkIG9wdGlvbmFsIHBhcmFtcyBhcyBuZWVkZWQuXG4gKiBAY2xhc3MgTmVvLndvcmtlci5NZXNzYWdlXG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYWN0aW9uXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRlc3RpbmF0aW9uPSdtYWluJ1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpZD1JZEdlbmVyYXRvci5nZXRJZChOZW8ud29ya2VySWQpXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG9yaWdpbj1OZW8ud29ya2VySWRcbiAgICAgICAgICovXG5cbiAgICAgICAgY29uZmlnLmRlc3RpbmF0aW9uID0gY29uZmlnLmRlc3RpbmF0aW9uIHx8ICdtYWluJztcbiAgICAgICAgY29uZmlnLmlkICAgICAgICAgID0gY29uZmlnLmlkICAgICAgICAgIHx8IElkR2VuZXJhdG9yLmdldElkKE5lby53b3JrZXJJZCk7XG4gICAgICAgIGNvbmZpZy5vcmlnaW4gICAgICA9IGNvbmZpZy5vcmlnaW4gICAgICB8fCBOZW8ud29ya2VySWQ7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcpXG4gICAgfVxufVxuXG5jb25zdCBucyA9IE5lby5ucygnTmVvLndvcmtlcicsIHRydWUpO1xubnNbJ01lc3NhZ2UnXSA9IE1lc3NhZ2U7XG5cbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2U7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBNaXhpbiB0byBlbmFibGUgYW5kIGhhbmRsZSByZW1vdGUgbWV0aG9kIGFjY2VzcyBhY3Jvc3MgdGhyZWFkcyAoV29ya2VycyBhbmQgTWFpbiBUaHJlYWRzKS5cbiAqXG4gKiAqKldoYXQgaXMgUmVtb3RlIE1ldGhvZCBBY2Nlc3M/KipcbiAqIFRoaXMgcGF0dGVybiBhbGxvd3MgY29kZSBydW5uaW5nIGluIG9uZSB0aHJlYWQgKGUuZy4sIGFuIEFwcCBXb3JrZXIpIHRvIGV4ZWN1dGUgYSBtZXRob2QgbG9jYXRlZCBpbiBhbm90aGVyIHRocmVhZFxuICogKGUuZy4sIHRoZSBNYWluIFRocmVhZCkgYXMgaWYgaXQgd2VyZSBhIGxvY2FsIGZ1bmN0aW9uIGNhbGwuIFNpbmNlIHRoZSB0aHJlYWRzIGFyZSBpc29sYXRlZCwgdGhlIGV4ZWN1dGlvbiBpcyBhc3luY2hyb25vdXM6XG4gKiB0aGUgY2FsbGVyIGludm9rZXMgdGhlIG1ldGhvZCBhbmQgYXdhaXRzIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIG90aGVyIHRocmVhZC5cbiAqXG4gKiAqKkNydWNpYWwgQ29uc3RyYWludHM6KipcbiAqIC0gKipTZXJpYWxpemF0aW9uOioqIEFsbCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBtZXRob2QgYW5kIHRoZSByZXR1cm4gdmFsdWUgc2VudCBiYWNrIE1VU1QgYmUgKipKU09OLXNlcmlhbGl6YWJsZSoqLlxuICogICBUaGlzIG1lYW5zIHlvdSBjYW5ub3QgcGFzcyBET00gbm9kZXMsIERPTSBFdmVudHMsIG9yIGNvbXBsZXggY2xhc3MgaW5zdGFuY2VzIGRpcmVjdGx5LlxuICogLSAqKlRyYW5zZmVyYWJsZXM6KiogYEFycmF5QnVmZmVyYCwgYE1lc3NhZ2VQb3J0YCBhbmQgYE9mZnNjcmVlbkNhbnZhc2AgY2FuIGJlIHRyYW5zZmVycmVkICh6ZXJvLWNvcHkpIGlmIGV4cGxpY2l0bHkgaGFuZGxlZC5cbiAqXG4gKiBUaGlzIG1peGluIGlzIHRoZSBjb3JlIG1lY2hhbmlzbSBmb3IgY3Jvc3MtdGhyZWFkIGNvbW11bmljYXRpb24gaW4gTmVvLm1qcy4gSXQgaXMgY29uc3VtZWQgYnk6XG4gKiAtIGBOZW8ud29ya2VyLkJhc2VgIChBcHAsIERhdGEsIFZEb20sIFRhc2ssIENhbnZhcyB3b3JrZXJzKVxuICogLSBgTmVvLndvcmtlci5TZXJ2aWNlQmFzZWAgKFNlcnZpY2UgV29ya2VyKVxuICogLSBgTmVvLndvcmtlci5NYW5hZ2VyYCAoTWFpbiBUaHJlYWQpXG4gKlxuICogVGhpcyBicm9hZCB1c2FnZSBlbnN1cmVzIHRoYXQgKiphbGwqKiBjb25uZWN0ZWQgcmVhbG1zIGNhbiBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuIFRoaXMgaW5jbHVkZXNcbiAqIFdvcmtlci10by1Xb3JrZXIsIFdvcmtlci10by1NYWluLCBhbmQgZXZlbiBNYWluLXRvLVdvcmtlciBtZXRob2QgY2FsbHMuXG4gKlxuICogKipLZXkgUmVzcG9uc2liaWxpdGllczoqKlxuICogMS4gKipSZWdpc3RyYXRpb246KiogUmVnaXN0ZXJzIG1ldGhvZHMgZGVmaW5lZCBpbiB0aGUgYHJlbW90ZWAgY29uZmlnIGFzIGNhbGxhYmxlIGVuZHBvaW50cy5cbiAqIDIuICoqUHJveHkgR2VuZXJhdGlvbjoqKiBDcmVhdGVzIGxvY2FsIHByb3h5IGZ1bmN0aW9ucyB0aGF0IHNlbmQgbWVzc2FnZXMgdG8gdGhlIHRhcmdldCB0aHJlYWQgd2hlbiBjYWxsZWQuXG4gKiAzLiAqKlJvdXRpbmc6KiogRW5zdXJlcyBtZXNzYWdlcyBhcmUgc2VudCB0byB0aGUgY29ycmVjdCBgd2luZG93SWRgIGluIGEgbXVsdGktd2luZG93IGVudmlyb25tZW50LlxuICogNC4gKipJbnRlcmNlcHRpb246KiogU3VwcG9ydHMgdGhlIGBpbnRlcmNlcHRSZW1vdGVzYCBjb25maWcgdG8gaW50ZXJjZXB0IGNhbGxzIGJlZm9yZSB0aGV5IGFyZSBleGVjdXRlZC5cbiAqICAgIFRoaXMgaXMgcGFydGljdWxhcmx5IGNyaXRpY2FsIGZvciBNYWluIFRocmVhZCBBZGRvbnMgKFNpbmdsZXRvbnMpLiBDYWxscyBhcnJpdmluZyBiZWZvcmUgYW4gYWRkb24gaXNcbiAqICAgIGBpc1JlYWR5YCAoZS5nLiwgd2FpdGluZyBmb3IgZXh0ZXJuYWwgbGlicmFyaWVzIGxpa2UgTW9uYWNvIEVkaXRvciBvciBHb29nbGUgTWFwcyB0byBsb2FkKSBjYW4gYmVcbiAqICAgIGludGVyY2VwdGVkIGFuZCBxdWV1ZWQsIGVuc3VyaW5nIHRoZXkgZXhlY3V0ZSBvbmx5IG9uY2UgdGhlIHNpbmdsZXRvbiBpcyBmdWxseSBmdW5jdGlvbmFsLlxuICpcbiAqICoqU3luY2hyb25vdXMgdnMuIEFzeW5jaHJvbm91czoqKlxuICogLSAqKkRlZmluaXRpb246KiogUmVtb3RlIG1ldGhvZHMgY2FuIGJlIGRlZmluZWQgYXMgc3luY2hyb25vdXMgb3IgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyBpbiB0aGVpciBvcmlnaW4gY2xhc3MuXG4gKiAtICoqRXhlY3V0aW9uOioqIFdoZW4gY2FsbGVkIGZyb20gYSBkaWZmZXJlbnQgdGhyZWFkLCB0aGUgZXhlY3V0aW9uIGlzICoqQUxXQVlTIGFzeW5jaHJvbm91cyoqLiBUaGUgcHJveHlcbiAqICAgZnVuY3Rpb24gcmV0dXJucyBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcmVtb3RlIG1ldGhvZC4gVGhpcyBpcyB0cnVlIGV2ZW4gaWZcbiAqICAgdGhlIG9yaWdpbmFsIG1ldGhvZCBpcyBzeW5jaHJvbm91cy5cbiAqXG4gKiAqKk5hbWVzcGFjZS1Ecml2ZW4gQWNjZXNzOioqXG4gKiBSZW1vdGUgYWNjZXNzIGlzIHJlc29sdmVkIHZpYSBuYW1lc3BhY2VzLiBUaGUgY2FsbGluZyB0aHJlYWQgbXVzdCBrbm93IHRoZSBmdWxsIGNsYXNzIG5hbWUgKGUuZy4sIGBOZW8ubWFpbi5hZGRvbi5Mb2NhbFN0b3JhZ2VgKVxuICogdG8gaW52b2tlIHRoZSBtZXRob2QuXG4gKlxuICogKipBcmNoaXRlY3R1cmFsIE5vdGU6KipcbiAqIFRvIHN1cHBvcnQgdGhlIGRpc3RyaWJ1dGVkIG11bHRpLXdpbmRvdyBhcmNoaXRlY3R1cmUgd2hlcmUgb25lIEFwcCBXb3JrZXIgc2VydmVzIG11bHRpcGxlIGNvbm5lY3RlZCBNYWluIFRocmVhZHMsXG4gKiAqKnRoZSBmaXJzdCBwYXJhbWV0ZXIgb2YgYW55IHJlbW90ZSBtZXRob2QgTVVTVCBiZSBhbiBvYmplY3QgY29udGFpbmluZyBgd2luZG93SWRgKiouXG4gKiBUaGlzIGFsbG93cyB0aGUgc2VuZGVyIHRvIGF0dGFjaCB0aGUgYHdpbmRvd0lkYCAoYW5kIG90aGVyIG1ldGFkYXRhKSB0byB0aGUgcGF5bG9hZCwgZW5zdXJpbmcgdGhlIG1lc3NhZ2VcbiAqIGlzIHJvdXRlZCB0byB0aGUgY29ycmVjdCBicm93c2VyIHdpbmRvdyBjb250ZXh0LiBDYWxscyBwYXNzaW5nIGFycmF5cyBvciBwcmltaXRpdmUgdmFsdWVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICogY2Fubm90IGJlIHJlbGlhYmx5IHJvdXRlZCBpbiBhIHNoYXJlZC13b3JrZXIgZW52aXJvbm1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIDEuIFVzYWdlIGluIE5lby5jb21wb25lbnQud3JhcHBlci5Nb25hY29FZGl0b3JcbiAqIC8vIENhbGxzIHRoZSByZW1vdGUgbWV0aG9kICdzZXRUaGVtZScgb24gdGhlIE1haW4gVGhyZWFkIGFkZG9uICdOZW8ubWFpbi5hZGRvbi5Nb25hY29FZGl0b3InXG4gKiBOZW8ubWFpbi5hZGRvbi5Nb25hY29FZGl0b3Iuc2V0VGhlbWUoe1xuICogICAgIGlkICAgICAgOiBtZS5pZCxcbiAqICAgICB2YWx1ZSAgIDogJ3ZzLWRhcmsnLFxuICogICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZCAvLyBDcml0aWNhbCBmb3Igcm91dGluZyFcbiAqIH0pLnRoZW4oKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdUaGVtZSB1cGRhdGVkJyk7XG4gKiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gMi4gVXNhZ2UgaW4gYSBDb250cm9sbGVyIGFjY2Vzc2luZyBMb2NhbFN0b3JhZ2VcbiAqIC8vIENhbGxzICdyZWFkTG9jYWxTdG9yYWdlSXRlbScgb24gdGhlIE1haW4gVGhyZWFkIGFkZG9uICdOZW8ubWFpbi5hZGRvbi5Mb2NhbFN0b3JhZ2UnXG4gKiBjb25zdCB2YWx1ZSA9IGF3YWl0IE5lby5tYWluLmFkZG9uLkxvY2FsU3RvcmFnZS5yZWFkTG9jYWxTdG9yYWdlSXRlbSh7XG4gKiAgICAga2V5ICAgICA6ICdteVNldHRpbmdzJyxcbiAqICAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICogfSk7XG4gKlxuICogQGNsYXNzIE5lby53b3JrZXIubWl4aW4uUmVtb3RlTWV0aG9kQWNjZXNzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2VlIE5lby53b3JrZXIuQmFzZVxuICogQHNlZSBOZW8ud29ya2VyLlNlcnZpY2VCYXNlXG4gKiBAc2VlIE5lby53b3JrZXIuTWFuYWdlclxuICogQHNlZSBOZW8ubWFpbi5hZGRvbi5CYXNlXG4gKiBAc2VlIE5lby5tYWluLmFkZG9uLk1vbmFjb0VkaXRvclxuICogQHNlZSBOZW8ubWFpbi5hZGRvbi5Mb2NhbFN0b3JhZ2VcbiAqL1xuY2xhc3MgUmVtb3RlTWV0aG9kQWNjZXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ud29ya2VyLm1peGluLlJlbW90ZU1ldGhvZEFjY2VzcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLndvcmtlci5taXhpbi5SZW1vdGVNZXRob2RBY2Nlc3MnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjb3B5IHJvdXRpbmcgaW5mb3JtYXRpb24gKGFwcE5hbWUsIHBvcnQsIHdpbmRvd0lkKSBmcm9tIGEgc291cmNlIG1lc3NhZ2UgdG8gYSB0YXJnZXQgbWVzc2FnZS5cbiAgICAgKiBUaGlzIGlzIGNydWNpYWwgaW4gU2hhcmVkV29ya2VyIGVudmlyb25tZW50cyB0byBtYWludGFpbiB0aGUgY29udGV4dCBvZiB0aGUgb3JpZ2luYWwgc2VuZGVyIHdoZW4gZm9ybXVsYXRpbmcgYSByZXBseSBvciBmb3J3YXJkaW5nIGEgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXNzYWdlIG9iamVjdCBjb250YWluaW5nIHJvdXRpbmcgbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG1lc3NhZ2Ugb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggcm91dGluZyBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBhc3NpZ25Qb3J0KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHthcHBOYW1lLCBwb3J0LCB3aW5kb3dJZH0gPSBzb3VyY2U7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwge2FwcE5hbWUsIHBvcnQsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHByb3h5IGZ1bmN0aW9uIGZvciBhIHJlbW90ZSBtZXRob2QuXG4gICAgICogV2hlbiB0aGlzIHByb3h5IGlzIGNhbGxlZCwgaXQgc2VuZHMgYSBtZXNzYWdlIHRvIHRoZSB0YXJnZXQgdGhyZWFkIHRvIGV4ZWN1dGUgdGhlIHJlYWwgbWV0aG9kLlxuICAgICAqXG4gICAgICogSXQgaGFuZGxlczpcbiAgICAgKiAxLiBDb25zdHJ1Y3RpbmcgdGhlIG1lc3NhZ2UgcGF5bG9hZCB3aXRoIGBhY3Rpb246ICdyZW1vdGVNZXRob2QnYC5cbiAgICAgKiAyLiBkZXRlcm1pbmluZyB0aGUgY29ycmVjdCBkZXN0aW5hdGlvbiAoZS5nLiwgdXNpbmcgYHdpbmRvd0lkYCBmcm9tIHRoZSBkYXRhIGlmIHRhcmdldGluZyAnbWFpbicpLlxuICAgICAqIDMuIFByZXNlcnZpbmcgcm91dGluZyBjb250ZXh0IGluIFNoYXJlZFdvcmtlciBlbnZpcm9ubWVudHMuXG4gICAgICogNC4gUmV0dXJuaW5nIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlbW90ZSBtZXRob2QncyByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVtb3RlIFRoZSByZW1vdGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGdlbmVyYXRlIGEgcHJveHkgZm9yLlxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigqPSwgKj0pOiBQcm9taXNlPGFueT59IFRoZSBwcm94eSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZVJlbW90ZShyZW1vdGUsIG1ldGhvZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge29yaWdpbn0gPSByZW1vdGU7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGJ1ZmZlcikge1xuICAgICAgICAgICAgbGV0IG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uICAgICAgICAgOiAncmVtb3RlTWV0aG9kJyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uICAgIDogb3JpZ2luLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNsYXNzTmFtZTogcmVtb3RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICByZW1vdGVNZXRob2QgICA6IG1ldGhvZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ21haW4nICYmIGRhdGE/LndpbmRvd0lkKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5kZXN0aW5hdGlvbiA9IGRhdGEud2luZG93SWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuaXNTaGFyZWRXb3JrZXIgJiYgbWUuYXNzaWduUG9ydChkYXRhLCBvcHRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIG1lLnByb21pc2VNZXNzYWdlKG9wdHMuZGVzdGluYXRpb24sIG9wdHMsIGJ1ZmZlcilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlICdyZWdpc3RlclJlbW90ZScgbWVzc2FnZSBhY3Rpb24uXG4gICAgICogSXQgaXRlcmF0ZXMgb3ZlciB0aGUgbGlzdCBvZiBtZXRob2RzIHByb3ZpZGVkIGluIHRoZSByZW1vdGUgY29uZmlnIGFuZCBnZW5lcmF0ZXMgbG9jYWwgcHJveHkgZnVuY3Rpb25zXG4gICAgICogZm9yIHRoZW0gaW4gdGhlIGFwcHJvcHJpYXRlIG5hbWVzcGFjZS4gVGhpcyBtYWtlcyB0aGUgcmVtb3RlIG1ldGhvZHMgYXZhaWxhYmxlIHRvIGJlIGNhbGxlZCBhcyBpZiB0aGV5IHdlcmUgbG9jYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVtb3RlIFRoZSByZW1vdGUgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyBjbGFzc05hbWUgYW5kIG1ldGhvZHMgbGlzdC5cbiAgICAgKi9cbiAgICBvblJlZ2lzdGVyUmVtb3RlKHJlbW90ZSkge1xuICAgICAgICBpZiAocmVtb3RlLmRlc3RpbmF0aW9uID09PSBOZW8ud29ya2VySWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2NsYXNzTmFtZSwgbWV0aG9kc30gPSByZW1vdGUsXG4gICAgICAgICAgICAgICAgcGtnICAgICAgICAgICAgICAgICAgPSBOZW8ubnMoY2xhc3NOYW1lLCB0cnVlKTtcblxuICAgICAgICAgICAgbWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZS5vcmlnaW4gIT09ICdtYWluJyAmJiBwa2dbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSByZW1vdGUgbWV0aG9kIGRlZmluaXRpb24gJyArIGNsYXNzTmFtZSArICcuJyArIG1ldGhvZClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwa2dbbWV0aG9kXSA/Pz0gbWUuZ2VuZXJhdGVSZW1vdGUocmVtb3RlLCBtZXRob2QpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHJlbW90ZS5pZCkge1xuICAgICAgICAgICAgICAgIG1lLnJlc29sdmUocmVtb3RlLCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgZXhlY3V0aW9uIG9mIGEgcmVxdWVzdGVkIHJlbW90ZSBtZXRob2QuXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSB3b3JrZXIgcmVjZWl2ZXMgYSBtZXNzYWdlIHdpdGggYGFjdGlvbjogJ3JlbW90ZU1ldGhvZCdgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Q6XG4gICAgICogMS4gUmVzb2x2ZXMgdGhlIHRhcmdldCBjbGFzcyBhbmQgbWV0aG9kIGZyb20gdGhlIG5hbWVzcGFjZS5cbiAgICAgKiAyLiBDaGVja3MgaWYgdGhlIGNhbGwgc2hvdWxkIGJlIGludGVyY2VwdGVkIChlLmcuLCBpZiB0aGUgdGFyZ2V0IHNpbmdsZXRvbiBpcyBub3QgcmVhZHkpLlxuICAgICAqIDMuIEV4ZWN1dGVzIHRoZSBtZXRob2QgKGhhbmRsaW5nIGJvdGggc3luYyBhbmQgYXN5bmMgcmVzdWx0cykuXG4gICAgICogNC4gQ2F0Y2hlcyBlcnJvcnMgYW5kIHNlbmRzIGEgcmVqZWN0aW9uIHJlcGx5LlxuICAgICAqIDUuIFJlc29sdmVzIHN1Y2Nlc3MgYW5kIHNlbmRzIGEgcmVwbHkgd2l0aCB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBUaGUgbWVzc2FnZSBwYXlsb2FkIGNvbnRhaW5pbmcgcmVtb3RlQ2xhc3NOYW1lLCByZW1vdGVNZXRob2QsIGFuZCBkYXRhLlxuICAgICAqL1xuICAgIG9uUmVtb3RlTWV0aG9kKG1zZykge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIHBrZyA9IE5lby5ucyhtc2cucmVtb3RlQ2xhc3NOYW1lKSxcbiAgICAgICAgICAgIG91dCwgbWV0aG9kO1xuXG4gICAgICAgIGlmICghcGtnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVtb3RlIG5hbWVzcGFjZSBcIicgKyBtc2cucmVtb3RlQ2xhc3NOYW1lICsgJ1wiJylcbiAgICAgICAgfVxuXG4gICAgICAgIG1ldGhvZCA9IHBrZ1ttc2cucmVtb3RlTWV0aG9kXTtcblxuICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbW90ZSBtZXRob2QgbmFtZSBcIicgKyBtc2cucmVtb3RlTWV0aG9kICsgJ1wiIGluIG5hbWVzcGFjZSBcIicgKyBtc2cucmVtb3RlQ2xhc3NOYW1lICsgJ1wiJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBpbnRlcmNlcHRpb25cbiAgICAgICAgaWYgKCFwa2cuaXNSZWFkeSAmJiBwa2cuaW50ZXJjZXB0UmVtb3Rlcz8uaW5jbHVkZXMobXNnLnJlbW90ZU1ldGhvZCkpIHtcbiAgICAgICAgICAgIG91dCA9IHBrZy5vbkludGVyY2VwdFJlbW90ZXMobXNnKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1zZy5kYXRhKSkge1xuICAgICAgICAgICAgb3V0ID0gbWV0aG9kLmNhbGwocGtnLCAuLi5tc2cuZGF0YSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCA9IG1ldGhvZC5jYWxsKHBrZywgbXNnLmRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTmVvLmlzUHJvbWlzZShvdXQpKSB7XG4gICAgICAgICAgICBvdXRcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEludGVuZGVkIGxvZ2ljOlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBjb2RlIG9mIGEgcmVtb3RlIG1ldGhvZCBmYWlscywgaXQgd291bGQgbm90IHNob3cgYW55IGVycm9ycyBpbnNpZGUgdGhlIGNvbnNvbGUsXG4gICAgICAgICAgICAgICAgICogc28gd2Ugd2FudCB0byBtYW51YWxseSBsb2cgdGhlIGVycm9yIGZvciBkZWJ1Z2dpbmcuXG4gICAgICAgICAgICAgICAgICogUmVqZWN0aW5nIHRoZSBQcm9taXNlIGdpdmVzIHVzIHRoZSBjaGFuY2UgdG8gcmVjb3Zlci5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAgICAgICAgICogTmVvLnZkb20uSGVscGVyLnVwZGF0ZShvcHRzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAqICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAqICAgICByZWplY3Q/LigpXG4gICAgICAgICAgICAgICAgICogfSkudGhlbihkYXRhID0+IHsuLi59KVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge2NvbnNvbGUuZXJyb3IoZXJyKTsgbWUucmVqZWN0KG1zZywgZXJyKX0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7bWUucmVzb2x2ZShtc2csIGRhdGEpfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlc29sdmUobXNnLCBvdXQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHJlamVjdGlvbiByZXBseSBiYWNrIHRvIHRoZSBjYWxsZXIgb2YgYSByZW1vdGUgbWV0aG9kLlxuICAgICAqIFVzZWQgd2hlbiB0aGUgZXhlY3V0aW9uIG9mIHRoZSByZW1vdGUgbWV0aG9kIGZhaWxzIG9yIHRocm93cyBhbiBlcnJvci5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXBseSBpcyByb3V0ZWQgYmFjayB0byB0aGUgY29ycmVjdCBvcmlnaW4gKHdpbmRvd0lkIG9yIHdvcmtlcikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbXNnIFRoZSBvcmlnaW5hbCBtZXNzYWdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXJyb3IgZGF0YSB0byBzZW5kIGJhY2suXG4gICAgICovXG4gICAgcmVqZWN0KG1zZywgZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICBhY3Rpb24gOiAncmVwbHknLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJlamVjdCA6IHRydWUsXG4gICAgICAgICAgICByZXBseUlkOiBtc2cuaWRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWUuaXNTaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgIG1lLmFzc2lnblBvcnQobXNnLCBvcHRzKTtcblxuICAgICAgICAgICAgaWYgKG1zZy5vcmlnaW4gPT09ICdtYWluJyAmJiBvcHRzLndpbmRvd0lkKSB7XG4gICAgICAgICAgICAgICAgbXNnLm9yaWdpbiA9IG9wdHMud2luZG93SWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNlbmRNZXNzYWdlKG1zZy5vcmlnaW4sIG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBzdWNjZXNzIHJlcGx5IGJhY2sgdG8gdGhlIGNhbGxlciBvZiBhIHJlbW90ZSBtZXRob2QuXG4gICAgICogVXNlZCB3aGVuIHRoZSByZW1vdGUgbWV0aG9kIGV4ZWN1dGVzIHN1Y2Nlc3NmdWxseS5cbiAgICAgKiBJdCBoYW5kbGVzIHRoZSB0cmFuc2ZlciBvZiB0cmFuc2ZlcmFibGUgb2JqZWN0cyAobGlrZSBBcnJheUJ1ZmZlcnMpIGFuZCBlbnN1cmVzIGNvcnJlY3Qgcm91dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgVGhlIG9yaWdpbmFsIG1lc3NhZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSByZXN1bHQgZGF0YSB0byBzZW5kIGJhY2suXG4gICAgICovXG4gICAgcmVzb2x2ZShtc2csIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRyYW5zZmVyID0gbnVsbCxcbiAgICAgICAgICAgIG9wdHM7XG5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdChkYXRhKSAmJiBBcnJheS5pc0FycmF5KGRhdGEudHJhbnNmZXIpKSB7XG4gICAgICAgICAgICB0cmFuc2ZlciA9IGRhdGEudHJhbnNmZXI7XG4gICAgICAgICAgICBkYXRhICAgICA9IGRhdGEucmVzdWx0IHx8IGRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICBhY3Rpb24gOiAncmVwbHknLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJlcGx5SWQ6IG1zZy5pZFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtZS5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgbWUuYXNzaWduUG9ydChtc2csIG9wdHMpO1xuXG4gICAgICAgICAgICBpZiAobXNnLm9yaWdpbiA9PT0gJ21haW4nICYmIG9wdHMud2luZG93SWQpIHtcbiAgICAgICAgICAgICAgICBtc2cub3JpZ2luID0gb3B0cy53aW5kb3dJZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuc2VuZE1lc3NhZ2UobXNnLm9yaWdpbiwgb3B0cywgdHJhbnNmZXIpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhSZW1vdGVNZXRob2RBY2Nlc3MpO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDaGVjayBpZiBtb2R1bGUgZXhpc3RzIChkZXZlbG9wbWVudCBvbmx5KVxuXHRpZiAoX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIG1vZHVsZUlkICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbl9fd2VicGFja19yZXF1aXJlX18ubSA9IF9fd2VicGFja19tb2R1bGVzX187XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZiA9IHt9O1xuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIG9ubHkgdGhlIGVudHJ5IGNodW5rLlxuLy8gVGhlIGNodW5rIGxvYWRpbmcgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmUgPSAoY2h1bmtJZCkgPT4ge1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5mKS5yZWR1Y2UoKHByb21pc2VzLCBrZXkpID0+IHtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZba2V5XShjaHVua0lkLCBwcm9taXNlcyk7XG5cdFx0cmV0dXJuIHByb21pc2VzO1xuXHR9LCBbXSkpO1xufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhc3luYyBjaHVua3Ncbl9fd2VicGFja19yZXF1aXJlX18udSA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJjaHVua3MvbWFpbi9cIiArIGNodW5rSWQgKyBcIi5qc1wiO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwidmFyIGluUHJvZ3Jlc3MgPSB7fTtcbnZhciBkYXRhV2VicGFja1ByZWZpeCA9IFwibmVvLm1qczpcIjtcbi8vIGxvYWRTY3JpcHQgZnVuY3Rpb24gdG8gbG9hZCBhIHNjcmlwdCB2aWEgc2NyaXB0IHRhZ1xuX193ZWJwYWNrX3JlcXVpcmVfXy5sID0gKHVybCwgZG9uZSwga2V5LCBjaHVua0lkKSA9PiB7XG5cdGlmKGluUHJvZ3Jlc3NbdXJsXSkgeyBpblByb2dyZXNzW3VybF0ucHVzaChkb25lKTsgcmV0dXJuOyB9XG5cdHZhciBzY3JpcHQsIG5lZWRBdHRhY2g7XG5cdGlmKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHMgPSBzY3JpcHRzW2ldO1xuXHRcdFx0aWYocy5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgPT0gdXJsIHx8IHMuZ2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIpID09IGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KSB7IHNjcmlwdCA9IHM7IGJyZWFrOyB9XG5cdFx0fVxuXHR9XG5cdGlmKCFzY3JpcHQpIHtcblx0XHRuZWVkQXR0YWNoID0gdHJ1ZTtcblx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ3V0Zi04Jztcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuXHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIF9fd2VicGFja19yZXF1aXJlX18ubmMpO1xuXHRcdH1cblx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS13ZWJwYWNrXCIsIGRhdGFXZWJwYWNrUHJlZml4ICsga2V5KTtcblxuXHRcdHNjcmlwdC5zcmMgPSB1cmw7XG5cdH1cblx0aW5Qcm9ncmVzc1t1cmxdID0gW2RvbmVdO1xuXHR2YXIgb25TY3JpcHRDb21wbGV0ZSA9IChwcmV2LCBldmVudCkgPT4ge1xuXHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cblx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR2YXIgZG9uZUZucyA9IGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRkZWxldGUgaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdHNjcmlwdC5wYXJlbnROb2RlICYmIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZG9uZUZucyAmJiBkb25lRm5zLmZvckVhY2goKGZuKSA9PiAoZm4oZXZlbnQpKSk7XG5cdFx0aWYocHJldikgcmV0dXJuIHByZXYoZXZlbnQpO1xuXHR9XG5cdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgdW5kZWZpbmVkLCB7IHR5cGU6ICd0aW1lb3V0JywgdGFyZ2V0OiBzY3JpcHQgfSksIDEyMDAwMCk7XG5cdHNjcmlwdC5vbmVycm9yID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmVycm9yKTtcblx0c2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25sb2FkKTtcblx0bmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG59OyIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwibWFpblwiOiAwXG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYuaiA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHRcdC8vIEpTT05QIGNodW5rIGxvYWRpbmcgZm9yIGphdmFzY3JpcHRcblx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgPyBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gOiB1bmRlZmluZWQ7XG5cdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSB7IC8vIDAgbWVhbnMgXCJhbHJlYWR5IGluc3RhbGxlZFwiLlxuXG5cdFx0XHQvLyBhIFByb21pc2UgbWVhbnMgXCJjdXJyZW50bHkgbG9hZGluZ1wiLlxuXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG5cdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRydWUpIHsgLy8gYWxsIGNodW5rcyBoYXZlIEpTXG5cdFx0XHRcdFx0Ly8gc2V0dXAgUHJvbWlzZSBpbiBjaHVuayBjYWNoZVxuXHRcdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gKGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IFtyZXNvbHZlLCByZWplY3RdKSk7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKTtcblxuXHRcdFx0XHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcblx0XHRcdFx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpO1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHRcdFx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSkge1xuXHRcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXJyb3JUeXBlID0gZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyA/ICdtaXNzaW5nJyA6IGV2ZW50LnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IubWVzc2FnZSA9ICdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5uYW1lID0gJ0NodW5rTG9hZEVycm9yJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YVsxXShlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubCh1cmwsIGxvYWRpbmdFbmRlZCwgXCJjaHVuay1cIiArIGNodW5rSWQsIGNodW5rSWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxufTtcblxuLy8gbm8gcHJlZmV0Y2hpbmdcblxuLy8gbm8gcHJlbG9hZGVkXG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3RcblxuLy8gbm8gb24gY2h1bmtzIGxvYWRlZFxuXG4vLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcbnZhciB3ZWJwYWNrSnNvbnBDYWxsYmFjayA9IChwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbiwgZGF0YSkgPT4ge1xuXHR2YXIgW2NodW5rSWRzLCBtb3JlTW9kdWxlcywgcnVudGltZV0gPSBkYXRhO1xuXHQvLyBhZGQgXCJtb3JlTW9kdWxlc1wiIHRvIHRoZSBtb2R1bGVzIG9iamVjdCxcblx0Ly8gdGhlbiBmbGFnIGFsbCBcImNodW5rSWRzXCIgYXMgbG9hZGVkIGFuZCBmaXJlIGNhbGxiYWNrXG5cdHZhciBtb2R1bGVJZCwgY2h1bmtJZCwgaSA9IDA7XG5cdGlmKGNodW5rSWRzLnNvbWUoKGlkKSA9PiAoaW5zdGFsbGVkQ2h1bmtzW2lkXSAhPT0gMCkpKSB7XG5cdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG5cdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihydW50aW1lKSB2YXIgcmVzdWx0ID0gcnVudGltZShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0fVxuXHRpZihwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbikgcGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24oZGF0YSk7XG5cdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2h1bmtJZCA9IGNodW5rSWRzW2ldO1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKCk7XG5cdFx0fVxuXHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG5cdH1cblxufVxuXG52YXIgY2h1bmtMb2FkaW5nR2xvYmFsID0gc2VsZltcIndlYnBhY2tDaHVua25lb19tanNcIl0gPSBzZWxmW1wid2VicGFja0NodW5rbmVvX21qc1wiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiaW1wb3J0IE5lbyAgICAgICAgICAgICAgICAgICBmcm9tICcuL05lby5tanMnO1xuaW1wb3J0ICogYXMgY29yZSAgICAgICAgICAgICBmcm9tICcuL2NvcmUvX2V4cG9ydC5tanMnO1xuaW1wb3J0IENsYXNzSGllcmFyY2h5TWFuYWdlciBmcm9tICcuL21hbmFnZXIvQ2xhc3NIaWVyYXJjaHkubWpzJztcbmltcG9ydCBEb21BY2Nlc3MgICAgICAgICAgICAgZnJvbSAnLi9tYWluL0RvbUFjY2Vzcy5tanMnOyAvLyBoYXMgdG8gZ2V0IGltcG9ydGVkIGJlZm9yZSBEZWx0YVVwZGF0ZXNcbmltcG9ydCBEZWx0YVVwZGF0ZXMgICAgICAgICAgZnJvbSAnLi9tYWluL0RlbHRhVXBkYXRlcy5tanMnO1xuaW1wb3J0IERvbUV2ZW50cyAgICAgICAgICAgICBmcm9tICcuL21haW4vRG9tRXZlbnRzLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgICAgICAgIGZyb20gJy4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgV29ya2VyTWFuYWdlciAgICAgICAgIGZyb20gJy4vd29ya2VyL01hbmFnZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLk1haW5cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIE1haW4gZXh0ZW5kcyBjb3JlLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5NYWluJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uTWFpbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG1vZGU9J3JlYWQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vZGU6ICdyZWFkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gb3BlbldpbmRvd3M9e31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbldpbmRvd3M6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IHJlYWRRdWV1ZT1bXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZWFkUXVldWU6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3RlIG1ldGhvZCBhY2Nlc3MgZm9yIG90aGVyIHdvcmtlcnNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZW1vdGVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBhcHA6IFtcbiAgICAgICAgICAgICAgICAnYWxlcnQnLFxuICAgICAgICAgICAgICAgICdlZGl0Um91dGUnLFxuICAgICAgICAgICAgICAgICdnZXRCeVBhdGgnLFxuICAgICAgICAgICAgICAgICdnZXRXaW5kb3dEYXRhJyxcbiAgICAgICAgICAgICAgICAnaW1wb3J0QWRkb24nLFxuICAgICAgICAgICAgICAgICdsb2cnLFxuICAgICAgICAgICAgICAgICdyZWRpcmVjdFRvJyxcbiAgICAgICAgICAgICAgICAncmVsb2FkV2luZG93JyxcbiAgICAgICAgICAgICAgICAnc2V0TmVvQ29uZmlnJyxcbiAgICAgICAgICAgICAgICAnc2V0Um91dGUnLFxuICAgICAgICAgICAgICAgICd3aW5kb3dDbG9zZScsXG4gICAgICAgICAgICAgICAgJ3dpbmRvd0Nsb3NlQWxsJyxcbiAgICAgICAgICAgICAgICAnd2luZG93TW92ZVRvJyxcbiAgICAgICAgICAgICAgICAnd2luZG93T3BlbicsXG4gICAgICAgICAgICAgICAgJ3dpbmRvd1Jlc2l6ZVRvJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcnVubmluZz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dGcHM9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNob3dGcHM6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0aW1lTGltaXQ9MTVcbiAgICAgICAgICovXG4gICAgICAgIHRpbWVMaW1pdDogMTUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzaG91bGQgYmUgZGV2IG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0b3RhbEZyYW1lQ291bnQ9MFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbEZyYW1lQ291bnQ6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gd3JpdGVRdWV1ZT1bXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZVF1ZXVlOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgV29ya2VyTWFuYWdlci5vbih7XG4gICAgICAgICAgICAnYXV0b21vdW50JyA6IG1lLm9uUmVuZGVyLFxuICAgICAgICAgICAgJ3VwZGF0ZVZkb20nOiBtZS5vblVwZGF0ZVZkb20sXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIERvbUV2ZW50cy5vbignZG9tQ29udGVudExvYWRlZCcsIG1lLm9uRG9tQ29udGVudExvYWRlZCwgbWUpO1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIERvbUV2ZW50cy5vbkRvbUNvbnRlbnRMb2FkZWQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV29ya2VycyBjYW4gbm90IHRyaWdnZXIgYWxlcnQoKSwgc28gd2UgbmVlZCByZW1vdGUgbWV0aG9kIGFjY2Vzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLm1lc3NhZ2VcbiAgICAgKi9cbiAgICBhbGVydChkYXRhKSB7XG4gICAgICAgIGFsZXJ0KGRhdGEubWVzc2FnZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZGl0IHRoZSBsb2NhdGlvbi5oYXNoIHZhbHVlXG4gICAgICogQSB2YWx1ZSBvZiBudWxsIHdpbGwgcmVtb3ZlIHRoZSBnaXZlbiBrZXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBlZGl0Um91dGUoZGF0YSkge1xuICAgICAgICBsZXQgaGFzaE9iaiA9IERvbUV2ZW50cy5wYXJzZUhhc2god2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKSxcbiAgICAgICAgICAgIGhhc2hBcnIgPSBbXTtcblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhID0gRG9tRXZlbnRzLnBhcnNlSGFzaChkYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihoYXNoT2JqLCBkYXRhKTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhoYXNoT2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhhc2hBcnIucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaEFyci5qb2luKCcmJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHNwZWNpZmljIGFjY2Vzc2libGUgd2luZG93IGF0dHJpYnV0ZXMgYnkgcGF0aCBpbnRvIHRoZSBhcHAgd29ya2VyLlxuICAgICAqIEtlZXAgaW4gbWluZCB0aGF0IHRoaXMgZXhjbHVkZXMgYW55dGhpbmcgRE9NIHJlbGF0ZWQgb3IgaW5zdGFuY2VzLlxuICAgICAqIEluIGNhc2UgeW91ciBwYXRoIG1hdGNoZXMgYSBtZXRob2QsIHlvdSBjYW4gYWxzbyBwYXNzIHBhcmFtcyBmb3IgaXQuXG4gICAgICogQGV4YW1wbGU6XG4gICAgICogICAgIE5lby5NYWluLmdldEJ5UGF0aCh7cGF0aDogJ25hdmlnYXRvci5sYW5ndWFnZScsIHdpbmRvd0lkfSkudGhlbihkYXRhID0+IHt9KVxuICAgICAqIEBleGFtcGxlOlxuICAgICAqICAgICBOZW8uTWFpbi5nZXRCeVBhdGgoe3BhdGg6ICdDU1Muc3VwcG9ydHMnLCBwYXJhbXM6IFsnZGlzcGxheTogZmxleCddLCB3aW5kb3dJZH0pLnRoZW4oZGF0YSA9PiB7fSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBkYXRhLnBhcmFtcz1bXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnBhdGhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRCeVBhdGgoe3BhcmFtcz1bXSwgcGF0aH0pIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IE5lby5uc1dpdGhBcnJheXMocGF0aCk7XG4gICAgICAgIHJldHVybiBOZW8uaXNGdW5jdGlvbih0YXJnZXQpID8gdGFyZ2V0KC4uLnBhcmFtcykgOiB0YXJnZXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB3aW5kb3cuc2NyZWVuIGlzIG5vdCBzcHJlYWRhYmxlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRXaW5kb3dEYXRhKCkge1xuICAgICAgICBsZXQgd2luICAgICAgPSB3aW5kb3csXG4gICAgICAgICAgICB7c2NyZWVufSA9IHdpbjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5uZXJIZWlnaHQgICAgOiB3aW4uaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICBpbm5lcldpZHRoICAgICA6IHdpbi5pbm5lcldpZHRoLFxuICAgICAgICAgICAgbW96SW5uZXJTY3JlZW5YOiB3aW4ubW96SW5uZXJTY3JlZW5YLCAvLyBGaXJlZm94IHNwZWNpZmljXG4gICAgICAgICAgICBtb3pJbm5lclNjcmVlblk6IHdpbi5tb3pJbm5lclNjcmVlblksIC8vIEZpcmVmb3ggc3BlY2lmaWNcbiAgICAgICAgICAgIG91dGVySGVpZ2h0ICAgIDogd2luLm91dGVySGVpZ2h0LFxuICAgICAgICAgICAgb3V0ZXJXaWR0aCAgICAgOiB3aW4ub3V0ZXJXaWR0aCxcbiAgICAgICAgICAgIHNjcmVlbjoge1xuICAgICAgICAgICAgICAgIGF2YWlsSGVpZ2h0OiBzY3JlZW4uYXZhaWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxMZWZ0ICA6IHNjcmVlbi5hdmFpbExlZnQsXG4gICAgICAgICAgICAgICAgYXZhaWxUb3AgICA6IHNjcmVlbi5hdmFpbFRvcCxcbiAgICAgICAgICAgICAgICBhdmFpbFdpZHRoIDogc2NyZWVuLmF2YWlsV2lkdGgsXG4gICAgICAgICAgICAgICAgY29sb3JEZXB0aCA6IHNjcmVlbi5jb2xvckRlcHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCAgICAgOiBzY3JlZW4uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiB7YW5nbGU6IHNjcmVlbi5vcmllbnRhdGlvbj8uYW5nbGUsIHR5cGU6IHNjcmVlbi5vcmllbnRhdGlvbj8udHlwZX0sXG4gICAgICAgICAgICAgICAgcGl4ZWxEZXB0aCA6IHNjcmVlbi5waXhlbERlcHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgOiBzY3JlZW4ud2lkdGhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY3JlZW5MZWZ0OiB3aW4uc2NyZWVuTGVmdCxcbiAgICAgICAgICAgIHNjcmVlblRvcCA6IHdpbi5zY3JlZW5Ub3BcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcG9ydCBtYWluIHRocmVhZCBhZGRvbnMgYXQgcnVuLXRpbWUgZnJvbSB3aXRoaW4gdGhlIGFwcCB3b3JrZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLm5hbWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBhc3luYyBpbXBvcnRBZGRvbihkYXRhKSB7XG4gICAgICAgIGxldCB7bmFtZX0gPSBkYXRhLFxuICAgICAgICAgICAgbW9kdWxlO1xuXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ1dTLycpKSB7XG4gICAgICAgICAgICBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoYC4uLy4uLy4uL3NyYy9tYWluL2FkZG9uLyR7bmFtZS5zdWJzdHJpbmcoMyl9Lm1qc2ApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoYC4vbWFpbi9hZGRvbi8ke25hbWV9Lm1qc2ApXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZ2lzdGVyQWRkb24obW9kdWxlLmRlZmF1bHQpO1xuICAgICAgICBhd2FpdCB0aGlzLnRpbWVvdXQoMjApOyAvLyBXYWl0IHVudGlsIHJlbW90ZXMgYXJlIHJlZ2lzdGVyZWRcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW90ZSBjb25zb2xlIGFjY2VzcyB0byBtYWluIHRocmVhZHMuXG4gICAgICogWW91IGNhbiB1c2UgYXBwTmFtZSBvciB3aW5kb3dJZCB0byB0YXJnZXQgc3BlY2lmaWMgd2luZG93cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS5hcHBOYW1lXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLm1ldGhvZF0gZGVmYXVsdHMgdG8gJ2xvZydcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RhdGEud2luZG93SWRdXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgbG9nKGRhdGEpIHtcbiAgICAgICAgY29uc29sZVtkYXRhLm1ldGhvZCB8fCAnbG9nJ10oZGF0YS52YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBvbkRvbUNvbnRlbnRMb2FkZWQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29uZmlnfSA9IE5lbyxcbiAgICAgICAgICAgIGltcG9ydHMgID0gW10sXG4gICAgICAgICAgICB7ZW52aXJvbm1lbnQsIG1haW5UaHJlYWRBZGRvbnMsIHVzZVNlcnZpY2VXb3JrZXJ9ID0gY29uZmlnLFxuICAgICAgICAgICAgbW9kdWxlcztcblxuICAgICAgICBtZS5hZGRvbiA9IHt9O1xuXG4gICAgICAgIGlmICh3aW5kb3cuX19ORU9fU1NSX18pIHtcbiAgICAgICAgICAgIGNvbmZpZy51c2VTU1IgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IG1vZHVsZSA9IGF3YWl0IGltcG9ydCgnLi9tYWluL2FkZG9uL1NlcnZlclNpZGVSZW5kZXJpbmcubWpzJyk7XG4gICAgICAgICAgICBtZS5yZWdpc3RlckFkZG9uKG1vZHVsZS5kZWZhdWx0KVxuICAgICAgICB9XG5cbiAgICAgICAgRG9tQWNjZXNzLm9uRG9tQ29udGVudExvYWRlZCgpO1xuXG4gICAgICAgIC8vIEludGVuZGVkIGZvciB0aGUgb25saW5lIGV4YW1wbGVzIHdoZXJlIHdlIG5lZWQgYW4gZWFzeSB3YXkgdG8gYWRkIEdBIHRvIGV2ZXJ5IGdlbmVyYXRlZCBhcHBcbiAgICAgICAgaWYgKGNvbmZpZy51c2VHb29nbGVBbmFseXRpY3MgJiYgIW1haW5UaHJlYWRBZGRvbnMuaW5jbHVkZXMoJ0FuYWx5dGljc0J5R29vZ2xlJykpIHtcbiAgICAgICAgICAgIG1haW5UaHJlYWRBZGRvbnMucHVzaCgnQW5hbHl0aWNzQnlHb29nbGUnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChcbiAgICAgICAgICAgICAgICB1c2VTZXJ2aWNlV29ya2VyID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgdXNlU2VydmljZVdvcmtlciA9PT0gZW52aXJvbm1lbnQgfHxcbiAgICAgICAgICAgICAgICAodXNlU2VydmljZVdvcmtlciA9PT0gJ2Rpc3QvcHJvZHVjdGlvbicgJiYgZW52aXJvbm1lbnQgPT09ICdkaXN0L2VzbScpXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICAhbWFpblRocmVhZEFkZG9ucy5pbmNsdWRlcygnU2VydmljZVdvcmtlcicpXG4gICAgICAgICkge1xuICAgICAgICAgICAgbWFpblRocmVhZEFkZG9ucy5wdXNoKCdTZXJ2aWNlV29ya2VyJylcbiAgICAgICAgfVxuXG4gICAgICAgIG1haW5UaHJlYWRBZGRvbnMuZm9yRWFjaChhZGRvbiA9PiB7XG4gICAgICAgICAgICBpZiAoYWRkb24uc3RhcnRzV2l0aCgnV1MvJykpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRzLnB1c2goaW1wb3J0KGAuLi8uLi8uLi9zcmMvbWFpbi9hZGRvbi8ke2FkZG9uLnN1YnN0cmluZygzKX0ubWpzYCkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGltcG9ydHMucHVzaChpbXBvcnQoYC4vbWFpbi9hZGRvbi8ke2FkZG9ufS5tanNgKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kdWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKGltcG9ydHMpO1xuXG4gICAgICAgIGNvbnN0IGluc3RhbmNlcyA9IG1vZHVsZXMubWFwKG1vZHVsZSA9PiBtZS5yZWdpc3RlckFkZG9uKG1vZHVsZS5kZWZhdWx0KSk7XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiBpbnN0YW5jZS5yZW1vdGVzUmVhZHkoKSkpO1xuXG4gICAgICAgIGF3YWl0IG1lLnJlbW90ZXNSZWFkeSgpO1xuXG4gICAgICAgIFdvcmtlck1hbmFnZXIub25Xb3JrZXJDb25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICBvcmlnaW46ICdtYWluJ1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25SZW5kZXIoZGF0YSkge1xuICAgICAgICBkYXRhLmRhdGEucmVwbHlJZCA9IGRhdGEucmVwbHlJZDtcbiAgICAgICAgdGhpcy5xdWV1ZVdyaXRlKGRhdGEuZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uVXBkYXRlVmRvbShkYXRhKSB7XG4gICAgICAgIGRhdGEuZGF0YS5yZXBseUlkID0gZGF0YS5yZXBseUlkO1xuICAgICAgICB0aGlzLnF1ZXVlV3JpdGUoZGF0YS5kYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHF1ZXVlXG4gICAgICogQHBhcmFtIHtEYXRlfSBzdGFydFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb2Nlc3NRdWV1ZShxdWV1ZSwgc3RhcnQpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW9kZX0gPSBtZSxcbiAgICAgICAgICAgIGxpbWl0ICA9IG1lLnRpbWVMaW1pdCxcbiAgICAgICAgICAgIG9wZXJhdGlvbjtcblxuICAgICAgICB3aGlsZSAob3BlcmF0aW9uID0gcXVldWUuc2hpZnQoKSkge1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkgLSBzdGFydCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcXVldWUudW5zaGlmdChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWUucmVuZGVyRnJhbWUuYmluZChtZSkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgRG9tQWNjZXNzLnJlYWQob3BlcmF0aW9uKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIERlbHRhVXBkYXRlcy51cGRhdGUob3BlcmF0aW9uKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFdvcmtlck1hbmFnZXIucmVzb2x2ZURvbU9wZXJhdGlvblByb21pc2Uob3BlcmF0aW9uLnJlcGx5SWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBxdWV1ZVJlYWQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICBtZS5yZWFkUXVldWUucHVzaChkYXRhKTtcblxuICAgICAgICBpZiAoIW1lLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIG1lLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckZyYW1lLmJpbmQobWUpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcXVldWVXcml0ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLndyaXRlUXVldWUucHVzaChkYXRhKTtcblxuICAgICAgICBpZiAoIW1lLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIG1lLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1lLnJlbmRlckZyYW1lLmJpbmQobWUpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS51cmxcbiAgICAgKi9cbiAgICByZWRpcmVjdFRvKGRhdGEpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkYXRhLnVybFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmVnaXN0ZXIgbWFpbiB0aHJlYWQgYWRkb25zXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBhZGRvbiBDYW4gZWl0aGVyIGJlIGEgbmVvIGNsYXNzIG9yIGluc3RhbmNlXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V9IFRoZSBhZGRvbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWRkb24oYWRkb24pIHtcbiAgICAgICAgaWYgKE5lby50eXBlT2YoYWRkb24pID09PSAnTmVvQ2xhc3MnKSB7XG4gICAgICAgICAgICAvLyBBZGRvbnMgY291bGQgZ2V0IGltcG9ydGVkIG11bHRpcGxlIHRpbWVzLiBFbnN1cmUgdG8gb25seSBjcmVhdGUgYW4gaW5zdGFuY2Ugb25jZS5cbiAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKE5lby5ucyhhZGRvbi5wcm90b3R5cGUuY2xhc3NOYW1lKSkgIT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICBhZGRvbiA9IE5lby5jcmVhdGUoYWRkb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFpbiB0aHJlYWQgYWRkb25zIG5lZWQgdG8gZ2V0IHJlZ2lzdGVyZWQgYXMgc2luZ2xldG9ucyBpbnNpZGUgdGhlIG5lbyBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICBOZW8uYXBwbHlUb0dsb2JhbE5zKGFkZG9uKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRvblthZGRvbi5jb25zdHJ1Y3Rvci5uYW1lXSA9IGFkZG9uO1xuXG4gICAgICAgIHJldHVybiBhZGRvblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgcmVsb2FkV2luZG93KGRhdGEpIHtcbiAgICAgICAgbG9jYXRpb24ucmVsb2FkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZGlmZmVyZW50IERPTSBvcGVyYXRpb24gcXVldWVzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbmRlckZyYW1lKCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWFkICAgID0gbWUucmVhZFF1ZXVlLFxuICAgICAgICAgICAgd3JpdGUgICA9IG1lLndyaXRlUXVldWUsXG4gICAgICAgICAgICByZWFkaW5nID0gbWUubW9kZSA9PT0gJ3JlYWQnLFxuICAgICAgICAgICAgc3RhcnQgICA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgaWYgKE5lby5jb25maWcubG9nRGVsdGFVcGRhdGVzKSB7XG4gICAgICAgICAgICBtZS50b3RhbEZyYW1lQ291bnQrKztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUb3RhbCBGcmFtZXM6ICcgKyBtZS50b3RhbEZyYW1lQ291bnQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVhZGluZyB8fCAhd3JpdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZS5tb2RlID0gJ3JlYWQnO1xuICAgICAgICAgICAgaWYgKG1lLnByb2Nlc3NRdWV1ZShyZWFkLCBzdGFydCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3cml0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lLm1vZGUgPSAnd3JpdGUnO1xuICAgICAgICAgICAgaWYgKG1lLnByb2Nlc3NRdWV1ZSh3cml0ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5ydW5uaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgYSBOZW8uY29uZmlnIGZyb20gdGhlIGFwcCB3b3JrZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmtleVxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIHNldE5lb0NvbmZpZyhkYXRhKSB7XG4gICAgICAgIGxldCB7a2V5LCB2YWx1ZX0gPSBkYXRhO1xuXG4gICAgICAgIE5lby5jb25maWdba2V5XSA9IGRhdGEudmFsdWU7XG5cbiAgICAgICAga2V5ID09PSAncmVuZGVyQ291bnREZWx0YXMnICYmIERlbHRhVXBkYXRlcy5zZXQoe1trZXldOiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBsb2NhdGlvbi5oYXNoIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIHNldFJvdXRlKGRhdGEpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBkYXRhLnZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHBvcHVwIHdpbmRvd3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBkYXRhLm5hbWVzXG4gICAgICovXG4gICAgd2luZG93Q2xvc2UoZGF0YSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5uYW1lcykpIHtcbiAgICAgICAgICAgIGRhdGEubmFtZXMgPSBbZGF0YS5uYW1lc11cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEubmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgIHRoaXMub3BlbldpbmRvd3NbbmFtZV0/Lndpbi5jbG9zZSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3BlbldpbmRvd3NbbmFtZV1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIHBvcHVwIHdpbmRvd3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHdpbmRvd0Nsb3NlQWxsKGRhdGEpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm9wZW5XaW5kb3dzKS5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgICAgICBvYmoud2luLmNsb3NlKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vcGVuV2luZG93cyA9IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBhIHBvcHVwIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93TmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS55XG4gICAgICovXG4gICAgd2luZG93TW92ZVRvKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vcGVuV2luZG93c1tkYXRhLndpbmRvd05hbWVdPy53aW4ubW92ZVRvKGRhdGEueCwgZGF0YS55KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBuZXcgcG9wdXAgd2luZG93IGFuZCByZXR1cm4gdHJ1ZSBpZiBzdWNjZXNzZnVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBkYXRhLnVybFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEudXNlVG90YWxIZWlnaHQ9dHJ1ZV0gVXNpbmcgdGhpcyBmbGFnIHdpbGwgc2V0IG91dGVySGVpZ2h0IHRvIGlubmVySGVpZ2h0LCBpZ25vcmluZyBoZWFkZXIgdG9vbHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEud2luZG93RmVhdHVyZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEud2luZG93TmFtZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgd2luZG93T3Blbih7dXJsLCB1c2VUb3RhbEhlaWdodD10cnVlLCB3aW5kb3dGZWF0dXJlcywgd2luZG93TmFtZX0pIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nV2luICA9IHRoaXMub3BlbldpbmRvd3Nbd2luZG93TmFtZV0sXG4gICAgICAgICAgICB0YXJnZXROYW1lO1xuXG4gICAgICAgIGlmIChleGlzdGluZ1dpbiAmJiAhZXhpc3RpbmdXaW4ud2luLmNsb3NlZCkge1xuICAgICAgICAgICAgdGFyZ2V0TmFtZSA9IGV4aXN0aW5nV2luLnRhcmdldE5hbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE5hbWUgPSBjcnlwdG8ucmFuZG9tVVVJRCgpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3BlbmVkV2luZG93ID0gd2luZG93Lm9wZW4odXJsLCB0YXJnZXROYW1lLCB3aW5kb3dGZWF0dXJlcyksXG4gICAgICAgICAgICBzdWNjZXNzICAgICAgPSAhIW9wZW5lZFdpbmRvdztcblxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgaWYgKHVzZVRvdGFsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgb3BlbmVkV2luZG93LnJlc2l6ZVRvKG9wZW5lZFdpbmRvdy5vdXRlcldpZHRoLCBvcGVuZWRXaW5kb3cuaW5uZXJIZWlnaHQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3BlbldpbmRvd3Nbd2luZG93TmFtZV0gPSB7dGFyZ2V0TmFtZSwgd2luOiBvcGVuZWRXaW5kb3d9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VjY2Vzc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgYSBwb3B1cCB3aW5kb3dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YS5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkYXRhLndpZHRoXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd05hbWVcbiAgICAgKi9cbiAgICB3aW5kb3dSZXNpemVUbyhkYXRhKSB7XG4gICAgICAgIGxldCB3aW4gICAgPSB0aGlzLm9wZW5XaW5kb3dzW2RhdGEud2luZG93TmFtZV0/LndpbixcbiAgICAgICAgICAgIGhlaWdodCA9IGRhdGEuaGVpZ2h0IHx8IHdpbi5vdXRlckhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoICA9IGRhdGEud2lkdGggIHx8IHdpbi5vdXRlcldpZHRoO1xuXG4gICAgICAgIHdpbi5yZXNpemVUbyh3aWR0aCwgaGVpZ2h0KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9