"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_component_timer_app_mjs"],{

/***/ "./examples/component/timer/MainContainer.mjs"
/*!****************************************************!*\
  !*** ./examples/component/timer/MainContainer.mjs ***!
  \****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/form/field/Color.mjs */ "./src/form/field/Color.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _src_component_Timer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/component/Timer.mjs */ "./src/component/Timer.mjs");






/**
 * @class Neo.examples.component.timer.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className: 'Neo.examples.component.timer.MainContainer',
    }

    createConfigurationComponents() {
        let me = this;

        return [{
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            labelText: 'dimensions',
            listeners: {change: me.onConfigChange.bind(me, 'dimensions')},
            value    : '8rem'
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: false,
            labelText: 'colorStart',
            listeners: {change: me.onConfigChange.bind(me, 'colorStart')},
            value    : '#8a9b0f'
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: false,
            labelText: 'colorEnd',
            listeners: {change: me.onConfigChange.bind(me, 'colorEnd')},
            value    : '#940a3d'
        }]
    }

    createExampleComponent() {
        return Neo.create({
            module: _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            style : {
                overflow : 'auto',
                maxHeight: '100%'
            },
            items : [{
                html: '<h1>Configurable</h1>',
                style: {textAlign: 'center'}
            }, {
                module    : _src_component_Timer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                duration  : '20s',
                flag      : 'timer-component',
                dimensions: '8rem'
            }]
        })
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        const timer = this.down({flag: 'timer-component'});

        timer[config] = opts.value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./examples/component/timer/app.mjs"
/*!******************************************!*\
  !*** ./examples/component/timer/app.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/timer/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.timer'
});



/***/ },

/***/ "./src/component/Timer.mjs"
/*!*********************************!*\
  !*** ./src/component/Timer.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.component.Timer
 * @extends Neo.component.Base
 */
class Timer extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Timer'
         * @protected
         */
        className: 'Neo.component.Timer',
        /**
         * @member {String} ntype='timer'
         * @protected
         */
        ntype: 'timer',
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=['timer']
         */
        baseCls: ['neo-timer'],
        /**
         * End color of the circle. If not set, it uses the css default
         * @member {Number|String} colorEnd_=null
         * @reactive
         */
        colorEnd_: null,
        /**
         * Start color of the circle. If not set, it uses the css default
         * @member {Number|String} colorStart_=null
         * @reactive
         */
        colorStart_: null,
        /**
         * Start time. This might be '5m', '30s' or milliseconds as number
         * @member {Number|String} duration_='5m'
         * @reactive
         */
        duration_: '10m',
        /**
         * Defines height and min-width. This can be a number in px or a string.
         * @member {Number|String} dimensions_='6rem'
         * @reactive
         */
        dimensions_: '8em',
        /**
         * Helper to keep running smooth at minimum cost
         * @member {Object}      timer={}
         * @member {Number|null} timer.currentSecond =null // run only once per second
         * @member {Number|null} timer.intervalId    =null // setInterval id
         * @member {Boolean}     timer.running       =false// keeps track if timer/entry is up
         * @member {Number|null} timer.startTime     =null // calc the current progress
         */
        timer: {
            currentSecond: null,
            intervalId   : null,
            running      : false,
            startTime    : null
        },
        /**
         * The vdom markup for this component.
         * @member {Object} vdom={}
         */
        vdom:
        {cn: [
            {cls: 'countdown', cn: [
                {tag: 'svg', cls: 'clock', viewBox: '-50 -50 100 100', strokeWidth: '10', cn: [
                    {tag: 'circle', r: 45},
                    {tag: 'circle', r: 45, pathLength: 1}
                ]},
                {cls: ['flip-card'], cn : [
                    {cls: 'flip-card-inner enter-mask', cn : [
                        {cls: 'flip-card-front', cn : [
                            {tag: 'input', cls: 'enter-time'},
                            {tag: 'button',cls: 'fa fa-play'}
                        ]},
                        {cls: 'flip-card-back', cn : [
                            {cls: 'runner', text: '00:00'}
                        ]}
                    ]}
                ]}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click   : me.onTimerClick,   delegate: 'flip-card-back'},
            {click   : me.onTimerClick,   delegate: 'fa fa-play'},
            {input   : me.onTimerInput,   delegate: 'enter-time'},
            {focusout: me.onTimerInput,   delegate: 'enter-time'},
            {keydown : me.onFieldKeyDown, delegate: 'enter-time'}
        ])
    }

    /**
     * Triggered after the dimensions config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetDimensions(value, oldValue) {
        if (typeof value === 'number') {
            value = value + 'px'
        }

        this.updateProperties({dimensions: value})
    }

    /**
     * Triggered after the colorStart config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetColorStart(value, oldValue) {
        value && this.updateProperties({colorStart: value})
    }

    /**
     * Triggered after the colorEnd config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetColorEnd(value, oldValue) {
        value && this.updateProperties({colorEnd: value})
    }

    /**
     * Triggered before the duration config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetDuration(value, oldValue) {
        let me = this,
            durationType;

        me.updateInputField(value)

        if (Neo.isString(value)) {
            durationType = value.at(-1);

            if (durationType === 'm') {
                value = value.split('m')[0] * 60 * 1000
            } else if (durationType === 's') {
                value = value.split('s')[0] * 1000
            }
        }

        me.updateProperties({full: value});

        return value
    }

    /**
     * Check if Enter was pressed
     * @param {Object} data
     */
    onFieldKeyDown(data) {
        let me = this;

        if (data.key === 'Enter') {
            me.duration = me.timer.entry;
            me.onTimerClick()
        }
    }

    /**
     * Click on Play or Timer
     */
    onTimerClick() {
        let me = this;

        // If the timer is running, stop and clear it
        if (me.timer.intervalId) {
            me.toggleTimer(false);
            me.resetTimer()
        } else {
            // prepare
            me.timer.startTime = new Date().getTime();

            me.timer.intervalId = setInterval(function () {
                const startTime = me.timer.startTime,
                      curTime   = new Date().getTime(),
                      totalTime = me.duration,
                      endTime   = startTime + totalTime;

                if (curTime > endTime) {
                    me.toggleTimer(false);
                    me.resetTimer()
                } else {
                    const milliseconds = endTime - curTime,
                          secondsLeft  = Math.floor(milliseconds / 1000);
                    let secondsNow = secondsLeft % 60,
                        minutesNow = Math.floor(secondsLeft / 60)

                    // Ensure this does not run 10 times a second
                    if (secondsNow !== me.timer.currentSecond) {
                        me.timer.currentSecond = secondsNow;

                        secondsNow = secondsNow.toString().padStart(2, '0');
                        minutesNow = minutesNow.toString().padStart(2, '0');

                        me.updateTimer(`${minutesNow}:${secondsNow}`);
                        me.updateProperties({current: milliseconds});
                        me.toggleTimer(true)
                    }
                }
            }, 100)
        }
    }

    /**
     * On change event of the textfield
     * @param {Object} data
     */
    onTimerInput(data) {
        let me = this;

        if (data.value) {
            me.timer.entry = data.value
        } else {
            me.duration = me.timer.entry
        }
    }

    /**
     * Reset the properties, timer and remove Interval
     */
    resetTimer() {
        let me = this;

        me.updateProperties({current: ''});
        me.updateTimer('00:00');

        clearInterval(me.timer.intervalId);
        delete me.timer.intervalId
    }

    /**
     * Flip over the timer face
     * @param {Boolean} doShow
     */
    toggleTimer(doShow) {
        if(this.running === doShow) return;

        let me       = this,
            flipCard = me.vdom.cn[0].cn[1];

        me.running = doShow;

        flipCard.cls = flipCard.cls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][doShow ? 'add' : 'remove'](flipCard.cls, 'turn');
        me.update()
    }

    /**
     * Write to the input field
     * @param {String} value
     */
    updateInputField(value) {
        let me         = this,
            inputField = me.vdom.cn[0].cn[1].cn[0].cn[0].cn[0];

        inputField.value = value;
    }

    /**
     * Update the timer, typically once per second
     * @param {String} value
     */
    updateTimer(value) {
        let me    = this,
            timer = me.vdom.cn[0].cn[1].cn[0].cn[1].cn[0];

        timer.text = value;
        me.update()
    }

    /**
     * Update the css properties
     * - current amount of seconds left
     * - full amount of time
     * - size of the timer
     * @param {Object} properties
     */
    updateProperties(properties) {
        let {style} = this;

        if (properties.current !== undefined) {
            style['--neo-timer-current'] = `${properties.current}!important`
        }
        if (properties.full !== undefined) {
            style['--neo-timer-full'] = `${properties.full}!important`
        }
        if (properties.colorEnd !== undefined) {
            style['--timer-color-end'] = `${properties.colorEnd}!important`
        }
        if (properties.colorStart !== undefined) {
            style['--timer-color-start'] = `${properties.colorStart}!important`
        }
        if (properties.dimensions !== undefined) {
            style['--timer-dimension'] = `${properties.dimensions}!important`
        }

        this.style = style
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Timer));


/***/ },

/***/ "./src/form/field/Color.mjs"
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.ComboBox
 */
class Color extends _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-combobox','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-combobox', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.vdom, me.getInputWrapperId());

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.vdom, me.getColorIndicatorId())?.vdom,
            {list, record} = me,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor()
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]))
        } else {
            selectionModel?.deselectAll(true)
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter)
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me                  = this,
            {inputValue, value} = me;

        return value ? me.colorFormatter(me, value) : me.forceSelection ? null : inputValue
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let {list} = this,
            index  = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem()
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let {list} = this;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90aW1lcl9hcHBfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNBO0FBQ0U7QUFDRDtBQUNBOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBcUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZ0VBQVM7QUFDaEM7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFO0FBQ0EsU0FBUztBQUNULHVCQUF1QixpRUFBVTtBQUNqQztBQUNBO0FBQ0Esd0JBQXdCLGlEQUFpRDtBQUN6RTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsaUVBQVU7QUFDakM7QUFDQTtBQUNBLHdCQUF3QiwrQ0FBK0M7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwrREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2IsNEJBQTRCLGdFQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRUc7O0FBRXpDO0FBQ1AsY0FBYywwREFBYTtBQUMzQjtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xrQztBQUNPOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBUztBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFD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QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NvbXBvbmVudC90aW1lci9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY29tcG9uZW50L3RpbWVyL2FwcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvVGltZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9Db2xvci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbmZpZ3VyYXRpb25WaWV3cG9ydCBmcm9tICcuLi8uLi9Db25maWd1cmF0aW9uVmlld3BvcnQubWpzJztcbmltcG9ydCBDb250YWluZXIgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ29sb3JGaWVsZCAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NvbG9yLm1qcyc7XG5pbXBvcnQgVGV4dEZpZWxkICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL1RleHQubWpzJztcbmltcG9ydCBUaW1lciAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBvbmVudC9UaW1lci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY29tcG9uZW50LnRpbWVyLk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5leGFtcGxlcy5Db25maWd1cmF0aW9uVmlld3BvcnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIENvbmZpZ3VyYXRpb25WaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmV4YW1wbGVzLmNvbXBvbmVudC50aW1lci5NYWluQ29udGFpbmVyJyxcbiAgICB9XG5cbiAgICBjcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50cygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdkaW1lbnNpb25zJyl9LFxuICAgICAgICAgICAgdmFsdWUgICAgOiAnOHJlbSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDb2xvckZpZWxkLFxuICAgICAgICAgICAgY2xlYXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ2NvbG9yU3RhcnQnLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnY29sb3JTdGFydCcpfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogJyM4YTliMGYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogQ29sb3JGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdjb2xvckVuZCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdjb2xvckVuZCcpfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogJyM5NDBhM2QnXG4gICAgICAgIH1dXG4gICAgfVxuXG4gICAgY3JlYXRlRXhhbXBsZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlOiBDb250YWluZXIsXG4gICAgICAgICAgICBzdHlsZSA6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6ICcxMDAlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZW1zIDogW3tcbiAgICAgICAgICAgICAgICBodG1sOiAnPGgxPkNvbmZpZ3VyYWJsZTwvaDE+JyxcbiAgICAgICAgICAgICAgICBzdHlsZToge3RleHRBbGlnbjogJ2NlbnRlcid9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgIDogVGltZXIsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gIDogJzIwcycsXG4gICAgICAgICAgICAgICAgZmxhZyAgICAgIDogJ3RpbWVyLWNvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogJzhyZW0nXG4gICAgICAgICAgICB9XVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIG9uQ29uZmlnQ2hhbmdlKGNvbmZpZywgb3B0cykge1xuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuZG93bih7ZmxhZzogJ3RpbWVyLWNvbXBvbmVudCd9KTtcblxuICAgICAgICB0aW1lcltjb25maWddID0gb3B0cy52YWx1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL01haW5Db250YWluZXIubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogTWFpbkNvbnRhaW5lcixcbiAgICBuYW1lICAgIDogJ05lby5leGFtcGxlcy5jb21wb25lbnQudGltZXInXG59KTtcblxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LlRpbWVyXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgVGltZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5UaW1lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5UaW1lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0aW1lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0aW1lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDU1Mgc2VsZWN0b3JzIHRvIGFwcGx5IHRvIHRoZSByb290IGxldmVsIG5vZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9Wyd0aW1lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10aW1lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5kIGNvbG9yIG9mIHRoZSBjaXJjbGUuIElmIG5vdCBzZXQsIGl0IHVzZXMgdGhlIGNzcyBkZWZhdWx0XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IGNvbG9yRW5kXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JFbmRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgY29sb3Igb2YgdGhlIGNpcmNsZS4gSWYgbm90IHNldCwgaXQgdXNlcyB0aGUgY3NzIGRlZmF1bHRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ30gY29sb3JTdGFydF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yU3RhcnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgdGltZS4gVGhpcyBtaWdodCBiZSAnNW0nLCAnMzBzJyBvciBtaWxsaXNlY29uZHMgYXMgbnVtYmVyXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IGR1cmF0aW9uXz0nNW0nXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHVyYXRpb25fOiAnMTBtJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgaGVpZ2h0IGFuZCBtaW4td2lkdGguIFRoaXMgY2FuIGJlIGEgbnVtYmVyIGluIHB4IG9yIGEgc3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBkaW1lbnNpb25zXz0nNnJlbSdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaW1lbnNpb25zXzogJzhlbScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgdG8ga2VlcCBydW5uaW5nIHNtb290aCBhdCBtaW5pbXVtIGNvc3RcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSAgICAgIHRpbWVyPXt9XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB0aW1lci5jdXJyZW50U2Vjb25kID1udWxsIC8vIHJ1biBvbmx5IG9uY2UgcGVyIHNlY29uZFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gdGltZXIuaW50ZXJ2YWxJZCAgICA9bnVsbCAvLyBzZXRJbnRlcnZhbCBpZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSAgICAgdGltZXIucnVubmluZyAgICAgICA9ZmFsc2UvLyBrZWVwcyB0cmFjayBpZiB0aW1lci9lbnRyeSBpcyB1cFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gdGltZXIuc3RhcnRUaW1lICAgICA9bnVsbCAvLyBjYWxjIHRoZSBjdXJyZW50IHByb2dyZXNzXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lcjoge1xuICAgICAgICAgICAgY3VycmVudFNlY29uZDogbnVsbCxcbiAgICAgICAgICAgIGludGVydmFsSWQgICA6IG51bGwsXG4gICAgICAgICAgICBydW5uaW5nICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0VGltZSAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZG9tIG1hcmt1cCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmRvbT17fVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiAnY291bnRkb3duJywgY246IFtcbiAgICAgICAgICAgICAgICB7dGFnOiAnc3ZnJywgY2xzOiAnY2xvY2snLCB2aWV3Qm94OiAnLTUwIC01MCAxMDAgMTAwJywgc3Ryb2tlV2lkdGg6ICcxMCcsIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHt0YWc6ICdjaXJjbGUnLCByOiA0NX0sXG4gICAgICAgICAgICAgICAgICAgIHt0YWc6ICdjaXJjbGUnLCByOiA0NSwgcGF0aExlbmd0aDogMX1cbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ2ZsaXAtY2FyZCddLCBjbiA6IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogJ2ZsaXAtY2FyZC1pbm5lciBlbnRlci1tYXNrJywgY24gOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiAnZmxpcC1jYXJkLWZyb250JywgY24gOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RhZzogJ2lucHV0JywgY2xzOiAnZW50ZXItdGltZSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0YWc6ICdidXR0b24nLGNsczogJ2ZhIGZhLXBsYXknfVxuICAgICAgICAgICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiAnZmxpcC1jYXJkLWJhY2snLCBjbiA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xzOiAncnVubmVyJywgdGV4dDogJzAwOjAwJ31cbiAgICAgICAgICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAge2NsaWNrICAgOiBtZS5vblRpbWVyQ2xpY2ssICAgZGVsZWdhdGU6ICdmbGlwLWNhcmQtYmFjayd9LFxuICAgICAgICAgICAge2NsaWNrICAgOiBtZS5vblRpbWVyQ2xpY2ssICAgZGVsZWdhdGU6ICdmYSBmYS1wbGF5J30sXG4gICAgICAgICAgICB7aW5wdXQgICA6IG1lLm9uVGltZXJJbnB1dCwgICBkZWxlZ2F0ZTogJ2VudGVyLXRpbWUnfSxcbiAgICAgICAgICAgIHtmb2N1c291dDogbWUub25UaW1lcklucHV0LCAgIGRlbGVnYXRlOiAnZW50ZXItdGltZSd9LFxuICAgICAgICAgICAge2tleWRvd24gOiBtZS5vbkZpZWxkS2V5RG93biwgZGVsZWdhdGU6ICdlbnRlci10aW1lJ31cbiAgICAgICAgXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpbWVuc2lvbnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREaW1lbnNpb25zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICdweCdcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyh7ZGltZW5zaW9uczogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29sb3JTdGFydCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29sb3JTdGFydCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHtjb2xvclN0YXJ0OiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjb2xvckVuZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29sb3JFbmQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMudXBkYXRlUHJvcGVydGllcyh7Y29sb3JFbmQ6IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBkdXJhdGlvbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldER1cmF0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZHVyYXRpb25UeXBlO1xuXG4gICAgICAgIG1lLnVwZGF0ZUlucHV0RmllbGQodmFsdWUpXG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uVHlwZSA9IHZhbHVlLmF0KC0xKTtcblxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uVHlwZSA9PT0gJ20nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnbScpWzBdICogNjAgKiAxMDAwXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uVHlwZSA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgncycpWzBdICogMTAwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlUHJvcGVydGllcyh7ZnVsbDogdmFsdWV9KTtcblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBFbnRlciB3YXMgcHJlc3NlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25GaWVsZEtleURvd24oZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgbWUuZHVyYXRpb24gPSBtZS50aW1lci5lbnRyeTtcbiAgICAgICAgICAgIG1lLm9uVGltZXJDbGljaygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGljayBvbiBQbGF5IG9yIFRpbWVyXG4gICAgICovXG4gICAgb25UaW1lckNsaWNrKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIElmIHRoZSB0aW1lciBpcyBydW5uaW5nLCBzdG9wIGFuZCBjbGVhciBpdFxuICAgICAgICBpZiAobWUudGltZXIuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgbWUudG9nZ2xlVGltZXIoZmFsc2UpO1xuICAgICAgICAgICAgbWUucmVzZXRUaW1lcigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwcmVwYXJlXG4gICAgICAgICAgICBtZS50aW1lci5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICAgICAgbWUudGltZXIuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBtZS50aW1lci5zdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgY3VyVGltZSAgID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxUaW1lID0gbWUuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSAgID0gc3RhcnRUaW1lICsgdG90YWxUaW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1clRpbWUgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRvZ2dsZVRpbWVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVzZXRUaW1lcigpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlsbGlzZWNvbmRzID0gZW5kVGltZSAtIGN1clRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHNMZWZ0ICA9IE1hdGguZmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWNvbmRzTm93ID0gc2Vjb25kc0xlZnQgJSA2MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXNOb3cgPSBNYXRoLmZsb29yKHNlY29uZHNMZWZ0IC8gNjApXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgZG9lcyBub3QgcnVuIDEwIHRpbWVzIGEgc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWNvbmRzTm93ICE9PSBtZS50aW1lci5jdXJyZW50U2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS50aW1lci5jdXJyZW50U2Vjb25kID0gc2Vjb25kc05vdztcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kc05vdyA9IHNlY29uZHNOb3cudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlc05vdyA9IG1pbnV0ZXNOb3cudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVUaW1lcihgJHttaW51dGVzTm93fToke3NlY29uZHNOb3d9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVQcm9wZXJ0aWVzKHtjdXJyZW50OiBtaWxsaXNlY29uZHN9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRvZ2dsZVRpbWVyKHRydWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2UgZXZlbnQgb2YgdGhlIHRleHRmaWVsZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25UaW1lcklucHV0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgbWUudGltZXIuZW50cnkgPSBkYXRhLnZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5kdXJhdGlvbiA9IG1lLnRpbWVyLmVudHJ5XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcHJvcGVydGllcywgdGltZXIgYW5kIHJlbW92ZSBJbnRlcnZhbFxuICAgICAqL1xuICAgIHJlc2V0VGltZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudXBkYXRlUHJvcGVydGllcyh7Y3VycmVudDogJyd9KTtcbiAgICAgICAgbWUudXBkYXRlVGltZXIoJzAwOjAwJyk7XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbChtZS50aW1lci5pbnRlcnZhbElkKTtcbiAgICAgICAgZGVsZXRlIG1lLnRpbWVyLmludGVydmFsSWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGlwIG92ZXIgdGhlIHRpbWVyIGZhY2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRvU2hvd1xuICAgICAqL1xuICAgIHRvZ2dsZVRpbWVyKGRvU2hvdykge1xuICAgICAgICBpZih0aGlzLnJ1bm5pbmcgPT09IGRvU2hvdykgcmV0dXJuO1xuXG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBmbGlwQ2FyZCA9IG1lLnZkb20uY25bMF0uY25bMV07XG5cbiAgICAgICAgbWUucnVubmluZyA9IGRvU2hvdztcblxuICAgICAgICBmbGlwQ2FyZC5jbHMgPSBmbGlwQ2FyZC5jbHMgfHwgW107XG5cbiAgICAgICAgTmVvQXJyYXlbZG9TaG93ID8gJ2FkZCcgOiAncmVtb3ZlJ10oZmxpcENhcmQuY2xzLCAndHVybicpO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyaXRlIHRvIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZUlucHV0RmllbGQodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5wdXRGaWVsZCA9IG1lLnZkb20uY25bMF0uY25bMV0uY25bMF0uY25bMF0uY25bMF07XG5cbiAgICAgICAgaW5wdXRGaWVsZC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdGltZXIsIHR5cGljYWxseSBvbmNlIHBlciBzZWNvbmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGVUaW1lcih2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgdGltZXIgPSBtZS52ZG9tLmNuWzBdLmNuWzFdLmNuWzBdLmNuWzFdLmNuWzBdO1xuXG4gICAgICAgIHRpbWVyLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgICogLSBjdXJyZW50IGFtb3VudCBvZiBzZWNvbmRzIGxlZnRcbiAgICAgKiAtIGZ1bGwgYW1vdW50IG9mIHRpbWVcbiAgICAgKiAtIHNpemUgb2YgdGhlIHRpbWVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHtzdHlsZX0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVbJy0tbmVvLXRpbWVyLWN1cnJlbnQnXSA9IGAke3Byb3BlcnRpZXMuY3VycmVudH0haW1wb3J0YW50YFxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmZ1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVbJy0tbmVvLXRpbWVyLWZ1bGwnXSA9IGAke3Byb3BlcnRpZXMuZnVsbH0haW1wb3J0YW50YFxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNvbG9yRW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLXRpbWVyLWNvbG9yLWVuZCddID0gYCR7cHJvcGVydGllcy5jb2xvckVuZH0haW1wb3J0YW50YFxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNvbG9yU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVbJy0tdGltZXItY29sb3Itc3RhcnQnXSA9IGAke3Byb3BlcnRpZXMuY29sb3JTdGFydH0haW1wb3J0YW50YFxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmRpbWVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVbJy0tdGltZXItZGltZW5zaW9uJ10gPSBgJHtwcm9wZXJ0aWVzLmRpbWVuc2lvbnN9IWltcG9ydGFudGBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGltZXIpO1xuIiwiaW1wb3J0IENvbG9yTGlzdCBmcm9tICcuLi8uLi9saXN0L0NvbG9yLm1qcydcbmltcG9ydCBDb21ib0JveCAgZnJvbSAnLi9Db21ib0JveC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLkNvbWJvQm94XG4gKi9cbmNsYXNzIENvbG9yIGV4dGVuZHMgQ29tYm9Cb3gge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQ29sb3InXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLkNvbG9yJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbG9yZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29sb3JmaWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jb2xvcmZpZWxkJywnbmVvLWNvbWJvYm94JywnbmVvLXBpY2tlcmZpZWxkJywnbmVvLXRleHRmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb2xvcmZpZWxkJywgJ25lby1jb21ib2JveCcsICduZW8tcGlja2VyZmllbGQnLCAnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEuTW9kZWwgZmllbGQgd2hpY2ggY29udGFpbnMgdGhlIGNvbG9yIHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY29sb3JGaWVsZD0nbmFtZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmllbGQ6ICduYW1lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIHRoZSBmb3JtYXR0ZXIgdG8gYXBwbHkgYSBjdXN0b20gYmFja2dyb3VuZC1jb2xvciBzdHlsaW5nLlxuICAgICAgICAgKiBFLmcuIHVzaW5nIENTUyB2YXJzIGZvciBkaWZmZXJlbnQgdGhlbWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBjb2xvckZpZWxkPShzY29wZSxkYXRhKT0+ZGF0YVtzY29wZS5jb2xvckZpZWxkXVxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGb3JtYXR0ZXI6IChzY29wZSxkYXRhKSA9PiBkYXRhW3Njb3BlLmNvbG9yRmllbGRdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxpc3RDb25maWdcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb25maWc6IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgIDogQ29sb3JMaXN0LFxuICAgICAgICAgICAgY29sb3JGaWVsZCAgICAgICAgOiAnQGNvbmZpZzpjb2xvckZpZWxkJyxcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0dGVyICAgIDogJ0Bjb25maWc6Y29sb3JGb3JtYXR0ZXInLFxuICAgICAgICAgICAgc2lsZW50U2VsZWN0VXBkYXRlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0V3JhcHBlciA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbWUuZ2V0SW5wdXRXcmFwcGVySWQoKSk7XG5cbiAgICAgICAgaW5wdXRXcmFwcGVyLnZkb20uY24udW5zaGlmdCh7XG4gICAgICAgICAgICBjbHMgIDogJ25lby1jb2xvcicsXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0Q29sb3JJbmRpY2F0b3JJZCgpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG1lLmdldENvbG9yKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRGaWx0ZXI9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBwcmV2ZW50RmlsdGVyPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb2xvckluZGljYXRvciA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbWUuZ2V0Q29sb3JJbmRpY2F0b3JJZCgpKT8udmRvbSxcbiAgICAgICAgICAgIHtsaXN0LCByZWNvcmR9ID0gbWUsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbCA9IG1lLmxpc3Q/LnNlbGVjdGlvbk1vZGVsO1xuXG4gICAgICAgIGlmIChjb2xvckluZGljYXRvcikge1xuICAgICAgICAgICAgY29sb3JJbmRpY2F0b3Iuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbWUuZ2V0Q29sb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LnNlbGVjdChsaXN0LmdldEl0ZW1JZChyZWNvcmRbbWUuc3RvcmUua2V5UHJvcGVydHldKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCh0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHN1cGVyIGNhbGwgd2lsbCB0cmlnZ2VyIHRoZSB2ZG9tIHVwZGF0ZVxuICAgICAgICBzdXBlci5hZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgcHJldmVudEZpbHRlcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbG9yKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aW5wdXRWYWx1ZSwgdmFsdWV9ID0gbWU7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gbWUuY29sb3JGb3JtYXR0ZXIobWUsIHZhbHVlKSA6IG1lLmZvcmNlU2VsZWN0aW9uID8gbnVsbCA6IGlucHV0VmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbG9ySW5kaWNhdG9ySWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fY29sb3ItaW5kaWNhdG9yYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNlbGVjdFBvc3RMYXN0SXRlbSgpIHtcbiAgICAgICAgbGV0IHtsaXN0fSA9IHRoaXMsXG4gICAgICAgICAgICBpbmRleCAgPSBsaXN0LnN0b3JlLmdldENvdW50KCkgLSAxO1xuXG4gICAgICAgIGxpc3QudmRvbS5jbltpbmRleF0gPSBsaXN0LmNyZWF0ZUl0ZW0obGlzdC5zdG9yZS5nZXRBdChpbmRleCksIGluZGV4KTtcblxuICAgICAgICBzdXBlci5vblNlbGVjdFBvc3RMYXN0SXRlbSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UHJlRmlyc3RJdGVtKCkge1xuICAgICAgICBsZXQge2xpc3R9ID0gdGhpcztcblxuICAgICAgICBsaXN0LnZkb20uY25bMF0gPSBsaXN0LmNyZWF0ZUl0ZW0obGlzdC5zdG9yZS5nZXRBdCgwKSwgMCk7XG5cbiAgICAgICAgc3VwZXIub25TZWxlY3RQcmVGaXJzdEl0ZW0oKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29sb3IpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==