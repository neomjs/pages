export const __webpack_esm_id__ = "vendors-examples_component_timer_app_mjs";
export const __webpack_esm_ids__ = ["vendors-examples_component_timer_app_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./examples/component/timer/MainContainer.mjs"
/*!****************************************************!*\
  !*** ./examples/component/timer/MainContainer.mjs ***!
  \****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/form/field/Color.mjs */ "./src/form/field/Color.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _src_component_Timer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/component/Timer.mjs */ "./src/component/Timer.mjs");






/**
 * @class Neo.examples.component.timer.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className: 'Neo.examples.component.timer.MainContainer',
    }

    createConfigurationComponents() {
        let me = this;

        return [{
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            labelText: 'dimensions',
            listeners: {change: me.onConfigChange.bind(me, 'dimensions')},
            value    : '8rem'
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: false,
            labelText: 'colorStart',
            listeners: {change: me.onConfigChange.bind(me, 'colorStart')},
            value    : '#8a9b0f'
        }, {
            module   : _src_form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            clearable: false,
            labelText: 'colorEnd',
            listeners: {change: me.onConfigChange.bind(me, 'colorEnd')},
            value    : '#940a3d'
        }]
    }

    createExampleComponent() {
        return Neo.create({
            module: _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            style : {
                overflow : 'auto',
                maxHeight: '100%'
            },
            items : [{
                html: '<h1>Configurable</h1>',
                style: {textAlign: 'center'}
            }, {
                module    : _src_component_Timer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                duration  : '20s',
                flag      : 'timer-component',
                dimensions: '8rem'
            }]
        })
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        const timer = this.down({flag: 'timer-component'});

        timer[config] = opts.value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./examples/component/timer/app.mjs"
/*!******************************************!*\
  !*** ./examples/component/timer/app.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/timer/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.timer'
});



/***/ },

/***/ "./src/component/Timer.mjs"
/*!*********************************!*\
  !*** ./src/component/Timer.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.component.Timer
 * @extends Neo.component.Base
 */
class Timer extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Timer'
         * @protected
         */
        className: 'Neo.component.Timer',
        /**
         * @member {String} ntype='timer'
         * @protected
         */
        ntype: 'timer',
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=['timer']
         */
        baseCls: ['neo-timer'],
        /**
         * End color of the circle. If not set, it uses the css default
         * @member {Number|String} colorEnd_=null
         * @reactive
         */
        colorEnd_: null,
        /**
         * Start color of the circle. If not set, it uses the css default
         * @member {Number|String} colorStart_=null
         * @reactive
         */
        colorStart_: null,
        /**
         * Start time. This might be '5m', '30s' or milliseconds as number
         * @member {Number|String} duration_='5m'
         * @reactive
         */
        duration_: '10m',
        /**
         * Defines height and min-width. This can be a number in px or a string.
         * @member {Number|String} dimensions_='6rem'
         * @reactive
         */
        dimensions_: '8em',
        /**
         * Helper to keep running smooth at minimum cost
         * @member {Object}      timer={}
         * @member {Number|null} timer.currentSecond =null // run only once per second
         * @member {Number|null} timer.intervalId    =null // setInterval id
         * @member {Boolean}     timer.running       =false// keeps track if timer/entry is up
         * @member {Number|null} timer.startTime     =null // calc the current progress
         */
        timer: {
            currentSecond: null,
            intervalId   : null,
            running      : false,
            startTime    : null
        },
        /**
         * The vdom markup for this component.
         * @member {Object} vdom={}
         */
        vdom:
        {cn: [
            {cls: 'countdown', cn: [
                {tag: 'svg', cls: 'clock', viewBox: '-50 -50 100 100', strokeWidth: '10', cn: [
                    {tag: 'circle', r: 45},
                    {tag: 'circle', r: 45, pathLength: 1}
                ]},
                {cls: ['flip-card'], cn : [
                    {cls: 'flip-card-inner enter-mask', cn : [
                        {cls: 'flip-card-front', cn : [
                            {tag: 'input', cls: 'enter-time'},
                            {tag: 'button',cls: 'fa fa-play'}
                        ]},
                        {cls: 'flip-card-back', cn : [
                            {cls: 'runner', text: '00:00'}
                        ]}
                    ]}
                ]}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click   : me.onTimerClick,   delegate: 'flip-card-back'},
            {click   : me.onTimerClick,   delegate: 'fa fa-play'},
            {input   : me.onTimerInput,   delegate: 'enter-time'},
            {focusout: me.onTimerInput,   delegate: 'enter-time'},
            {keydown : me.onFieldKeyDown, delegate: 'enter-time'}
        ])
    }

    /**
     * Triggered after the dimensions config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @protected
     */
    afterSetDimensions(value, oldValue) {
        if (typeof value === 'number') {
            value = value + 'px'
        }

        this.updateProperties({dimensions: value})
    }

    /**
     * Triggered after the colorStart config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetColorStart(value, oldValue) {
        value && this.updateProperties({colorStart: value})
    }

    /**
     * Triggered after the colorEnd config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetColorEnd(value, oldValue) {
        value && this.updateProperties({colorEnd: value})
    }

    /**
     * Triggered before the duration config got changed
     * @param {Number|String} value
     * @param {Number|String} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetDuration(value, oldValue) {
        let me = this,
            durationType;

        me.updateInputField(value)

        if (Neo.isString(value)) {
            durationType = value.at(-1);

            if (durationType === 'm') {
                value = value.split('m')[0] * 60 * 1000
            } else if (durationType === 's') {
                value = value.split('s')[0] * 1000
            }
        }

        me.updateProperties({full: value});

        return value
    }

    /**
     * Check if Enter was pressed
     * @param {Object} data
     */
    onFieldKeyDown(data) {
        let me = this;

        if (data.key === 'Enter') {
            me.duration = me.timer.entry;
            me.onTimerClick()
        }
    }

    /**
     * Click on Play or Timer
     */
    onTimerClick() {
        let me = this;

        // If the timer is running, stop and clear it
        if (me.timer.intervalId) {
            me.toggleTimer(false);
            me.resetTimer()
        } else {
            // prepare
            me.timer.startTime = new Date().getTime();

            me.timer.intervalId = setInterval(function () {
                const startTime = me.timer.startTime,
                      curTime   = new Date().getTime(),
                      totalTime = me.duration,
                      endTime   = startTime + totalTime;

                if (curTime > endTime) {
                    me.toggleTimer(false);
                    me.resetTimer()
                } else {
                    const milliseconds = endTime - curTime,
                          secondsLeft  = Math.floor(milliseconds / 1000);
                    let secondsNow = secondsLeft % 60,
                        minutesNow = Math.floor(secondsLeft / 60)

                    // Ensure this does not run 10 times a second
                    if (secondsNow !== me.timer.currentSecond) {
                        me.timer.currentSecond = secondsNow;

                        secondsNow = secondsNow.toString().padStart(2, '0');
                        minutesNow = minutesNow.toString().padStart(2, '0');

                        me.updateTimer(`${minutesNow}:${secondsNow}`);
                        me.updateProperties({current: milliseconds});
                        me.toggleTimer(true)
                    }
                }
            }, 100)
        }
    }

    /**
     * On change event of the textfield
     * @param {Object} data
     */
    onTimerInput(data) {
        let me = this;

        if (data.value) {
            me.timer.entry = data.value
        } else {
            me.duration = me.timer.entry
        }
    }

    /**
     * Reset the properties, timer and remove Interval
     */
    resetTimer() {
        let me = this;

        me.updateProperties({current: ''});
        me.updateTimer('00:00');

        clearInterval(me.timer.intervalId);
        delete me.timer.intervalId
    }

    /**
     * Flip over the timer face
     * @param {Boolean} doShow
     */
    toggleTimer(doShow) {
        if(this.running === doShow) return;

        let me       = this,
            flipCard = me.vdom.cn[0].cn[1];

        me.running = doShow;

        flipCard.cls = flipCard.cls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][doShow ? 'add' : 'remove'](flipCard.cls, 'turn');
        me.update()
    }

    /**
     * Write to the input field
     * @param {String} value
     */
    updateInputField(value) {
        let me         = this,
            inputField = me.vdom.cn[0].cn[1].cn[0].cn[0].cn[0];

        inputField.value = value;
    }

    /**
     * Update the timer, typically once per second
     * @param {String} value
     */
    updateTimer(value) {
        let me    = this,
            timer = me.vdom.cn[0].cn[1].cn[0].cn[1].cn[0];

        timer.text = value;
        me.update()
    }

    /**
     * Update the css properties
     * - current amount of seconds left
     * - full amount of time
     * - size of the timer
     * @param {Object} properties
     */
    updateProperties(properties) {
        let {style} = this;

        if (properties.current !== undefined) {
            style['--neo-timer-current'] = `${properties.current}!important`
        }
        if (properties.full !== undefined) {
            style['--neo-timer-full'] = `${properties.full}!important`
        }
        if (properties.colorEnd !== undefined) {
            style['--timer-color-end'] = `${properties.colorEnd}!important`
        }
        if (properties.colorStart !== undefined) {
            style['--timer-color-start'] = `${properties.colorStart}!important`
        }
        if (properties.dimensions !== undefined) {
            style['--timer-dimension'] = `${properties.dimensions}!important`
        }

        this.style = style
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Timer));


/***/ },

/***/ "./src/form/field/Color.mjs"
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.ComboBox
 */
class Color extends _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-combobox','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-combobox', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.vdom, me.getInputWrapperId());

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.vdom, me.getColorIndicatorId())?.vdom,
            {list, record} = me,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor()
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]))
        } else {
            selectionModel?.deselectAll(true)
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter)
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me                  = this,
            {inputValue, value} = me;

        return value ? me.colorFormatter(me, value) : me.forceSelection ? null : inputValue
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let {list} = this,
            index  = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem()
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let {list} = this;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF90aW1lcl9hcHBfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDQTtBQUNFO0FBQ0Q7QUFDQTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQXFCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGdFQUFTO0FBQ2hDO0FBQ0Esd0JBQXdCLGlEQUFpRDtBQUN6RTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsaUVBQVU7QUFDakM7QUFDQTtBQUNBLHdCQUF3QixpREFBaUQ7QUFDekU7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLGlFQUFVO0FBQ2pDO0FBQ0E7QUFDQSx3QkFBd0IsK0NBQStDO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiLDRCQUE0QixnRUFBSztBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsaUNBQWlDLHdCQUF3Qjs7QUFFekQ7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDcEVHOztBQUV6QztBQUNQLGNBQWMsMERBQWE7QUFDM0I7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMa0M7QUFDTzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVM7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLG9CQUFvQixhQUFhO0FBQ2pDLG9CQUFvQixhQUFhO0FBQ2pDLG9CQUFvQixhQUFhO0FBQ2pDLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLHFCQUFxQixxQkFBcUI7QUFDMUMscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6Qiw2QkFBNkIsZ0NBQWdDO0FBQzdELDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSx3REFBd0Q7QUFDckUsYUFBYSxvREFBb0Q7QUFDakUsYUFBYSxvREFBb0Q7QUFDakUsYUFBYSxvREFBb0Q7QUFDakUsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixrQkFBa0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFlBQVk7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLFdBQVcsR0FBRyxXQUFXO0FBQ25FLDZDQUE2QyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsWUFBWTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDblVPO0FBQ0w7QUFDSzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVE7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHNEQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBUTtBQUNyQyxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07O0FBRW5COztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvdGltZXIvTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NvbXBvbmVudC90aW1lci9hcHAubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L1RpbWVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvQ29sb3IubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb25maWd1cmF0aW9uVmlld3BvcnQgZnJvbSAnLi4vLi4vQ29uZmlndXJhdGlvblZpZXdwb3J0Lm1qcyc7XG5pbXBvcnQgQ29udGFpbmVyICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IENvbG9yRmllbGQgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9Db2xvci5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5pbXBvcnQgVGltZXIgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvVGltZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmV4YW1wbGVzLmNvbXBvbmVudC50aW1lci5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZXhhbXBsZXMuQ29uZmlndXJhdGlvblZpZXdwb3J0XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBDb25maWd1cmF0aW9uVmlld3BvcnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5leGFtcGxlcy5jb21wb25lbnQudGltZXIuTWFpbkNvbnRhaW5lcicsXG4gICAgfVxuXG4gICAgY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudHMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnZGltZW5zaW9ucycpfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogJzhyZW0nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogQ29sb3JGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdjb2xvclN0YXJ0JyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2NvbG9yU3RhcnQnKX0sXG4gICAgICAgICAgICB2YWx1ZSAgICA6ICcjOGE5YjBmJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IENvbG9yRmllbGQsXG4gICAgICAgICAgICBjbGVhcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnY29sb3JFbmQnLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnY29sb3JFbmQnKX0sXG4gICAgICAgICAgICB2YWx1ZSAgICA6ICcjOTQwYTNkJ1xuICAgICAgICB9XVxuICAgIH1cblxuICAgIGNyZWF0ZUV4YW1wbGVDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgIG1vZHVsZTogQ29udGFpbmVyLFxuICAgICAgICAgICAgc3R5bGUgOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtcyA6IFt7XG4gICAgICAgICAgICAgICAgaHRtbDogJzxoMT5Db25maWd1cmFibGU8L2gxPicsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHt0ZXh0QWxpZ246ICdjZW50ZXInfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICA6IFRpbWVyLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uICA6ICcyMHMnLFxuICAgICAgICAgICAgICAgIGZsYWcgICAgICA6ICd0aW1lci1jb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6ICc4cmVtJ1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkNvbmZpZ0NoYW5nZShjb25maWcsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLmRvd24oe2ZsYWc6ICd0aW1lci1jb21wb25lbnQnfSk7XG5cbiAgICAgICAgdGltZXJbY29uZmlnXSA9IG9wdHMudmFsdWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXIpO1xuIiwiaW1wb3J0IE1haW5Db250YWluZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvblN0YXJ0ID0gKCkgPT4gTmVvLmFwcCh7XG4gICAgbWFpblZpZXc6IE1haW5Db250YWluZXIsXG4gICAgbmFtZSAgICA6ICdOZW8uZXhhbXBsZXMuY29tcG9uZW50LnRpbWVyJ1xufSk7XG5cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5UaW1lclxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIFRpbWVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuVGltZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuVGltZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndGltZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGltZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIHNlbGVjdG9ycyB0byBhcHBseSB0byB0aGUgcm9vdCBsZXZlbCBub2RlIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsndGltZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdGltZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuZCBjb2xvciBvZiB0aGUgY2lyY2xlLiBJZiBub3Qgc2V0LCBpdCB1c2VzIHRoZSBjc3MgZGVmYXVsdFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBjb2xvckVuZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRW5kXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IGNvbG9yIG9mIHRoZSBjaXJjbGUuIElmIG5vdCBzZXQsIGl0IHVzZXMgdGhlIGNzcyBkZWZhdWx0XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IGNvbG9yU3RhcnRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvclN0YXJ0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IHRpbWUuIFRoaXMgbWlnaHQgYmUgJzVtJywgJzMwcycgb3IgbWlsbGlzZWNvbmRzIGFzIG51bWJlclxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfSBkdXJhdGlvbl89JzVtJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGR1cmF0aW9uXzogJzEwbScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGhlaWdodCBhbmQgbWluLXdpZHRoLiBUaGlzIGNhbiBiZSBhIG51bWJlciBpbiBweCBvciBhIHN0cmluZy5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ30gZGltZW5zaW9uc189JzZyZW0nXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGltZW5zaW9uc186ICc4ZW0nLFxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHRvIGtlZXAgcnVubmluZyBzbW9vdGggYXQgbWluaW11bSBjb3N0XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gICAgICB0aW1lcj17fVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gdGltZXIuY3VycmVudFNlY29uZCA9bnVsbCAvLyBydW4gb25seSBvbmNlIHBlciBzZWNvbmRcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRpbWVyLmludGVydmFsSWQgICAgPW51bGwgLy8gc2V0SW50ZXJ2YWwgaWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gICAgIHRpbWVyLnJ1bm5pbmcgICAgICAgPWZhbHNlLy8ga2VlcHMgdHJhY2sgaWYgdGltZXIvZW50cnkgaXMgdXBcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRpbWVyLnN0YXJ0VGltZSAgICAgPW51bGwgLy8gY2FsYyB0aGUgY3VycmVudCBwcm9ncmVzc1xuICAgICAgICAgKi9cbiAgICAgICAgdGltZXI6IHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWNvbmQ6IG51bGwsXG4gICAgICAgICAgICBpbnRlcnZhbElkICAgOiBudWxsLFxuICAgICAgICAgICAgcnVubmluZyAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBzdGFydFRpbWUgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmRvbSBtYXJrdXAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209e31cbiAgICAgICAgICovXG4gICAgICAgIHZkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge2NsczogJ2NvdW50ZG93bicsIGNuOiBbXG4gICAgICAgICAgICAgICAge3RhZzogJ3N2ZycsIGNsczogJ2Nsb2NrJywgdmlld0JveDogJy01MCAtNTAgMTAwIDEwMCcsIHN0cm9rZVdpZHRoOiAnMTAnLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7dGFnOiAnY2lyY2xlJywgcjogNDV9LFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiAnY2lyY2xlJywgcjogNDUsIHBhdGhMZW5ndGg6IDF9XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NsczogWydmbGlwLWNhcmQnXSwgY24gOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6ICdmbGlwLWNhcmQtaW5uZXIgZW50ZXItbWFzaycsIGNuIDogW1xuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogJ2ZsaXAtY2FyZC1mcm9udCcsIGNuIDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0YWc6ICdpbnB1dCcsIGNsczogJ2VudGVyLXRpbWUnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGFnOiAnYnV0dG9uJyxjbHM6ICdmYSBmYS1wbGF5J31cbiAgICAgICAgICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogJ2ZsaXAtY2FyZC1iYWNrJywgY24gOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsczogJ3J1bm5lcicsIHRleHQ6ICcwMDowMCd9XG4gICAgICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgIHtjbGljayAgIDogbWUub25UaW1lckNsaWNrLCAgIGRlbGVnYXRlOiAnZmxpcC1jYXJkLWJhY2snfSxcbiAgICAgICAgICAgIHtjbGljayAgIDogbWUub25UaW1lckNsaWNrLCAgIGRlbGVnYXRlOiAnZmEgZmEtcGxheSd9LFxuICAgICAgICAgICAge2lucHV0ICAgOiBtZS5vblRpbWVySW5wdXQsICAgZGVsZWdhdGU6ICdlbnRlci10aW1lJ30sXG4gICAgICAgICAgICB7Zm9jdXNvdXQ6IG1lLm9uVGltZXJJbnB1dCwgICBkZWxlZ2F0ZTogJ2VudGVyLXRpbWUnfSxcbiAgICAgICAgICAgIHtrZXlkb3duIDogbWUub25GaWVsZEtleURvd24sIGRlbGVnYXRlOiAnZW50ZXItdGltZSd9XG4gICAgICAgIF0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkaW1lbnNpb25zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGltZW5zaW9ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAncHgnXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoe2RpbWVuc2lvbnM6IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbG9yU3RhcnQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbG9yU3RhcnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMudXBkYXRlUHJvcGVydGllcyh7Y29sb3JTdGFydDogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29sb3JFbmQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbG9yRW5kKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoe2NvbG9yRW5kOiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZHVyYXRpb24gY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREdXJhdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGR1cmF0aW9uVHlwZTtcblxuICAgICAgICBtZS51cGRhdGVJbnB1dEZpZWxkKHZhbHVlKVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBkdXJhdGlvblR5cGUgPSB2YWx1ZS5hdCgtMSk7XG5cbiAgICAgICAgICAgIGlmIChkdXJhdGlvblR5cGUgPT09ICdtJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJ20nKVswXSAqIDYwICogMTAwMFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvblR5cGUgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJ3MnKVswXSAqIDEwMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZVByb3BlcnRpZXMoe2Z1bGw6IHZhbHVlfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgRW50ZXIgd2FzIHByZXNzZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRmllbGRLZXlEb3duKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgIG1lLmR1cmF0aW9uID0gbWUudGltZXIuZW50cnk7XG4gICAgICAgICAgICBtZS5vblRpbWVyQ2xpY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xpY2sgb24gUGxheSBvciBUaW1lclxuICAgICAqL1xuICAgIG9uVGltZXJDbGljaygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBJZiB0aGUgdGltZXIgaXMgcnVubmluZywgc3RvcCBhbmQgY2xlYXIgaXRcbiAgICAgICAgaWYgKG1lLnRpbWVyLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIG1lLnRvZ2dsZVRpbWVyKGZhbHNlKTtcbiAgICAgICAgICAgIG1lLnJlc2V0VGltZXIoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcHJlcGFyZVxuICAgICAgICAgICAgbWUudGltZXIuc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgIG1lLnRpbWVyLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbWUudGltZXIuc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGN1clRpbWUgICA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVGltZSA9IG1lLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIGVuZFRpbWUgICA9IHN0YXJ0VGltZSArIHRvdGFsVGltZTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJUaW1lID4gZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS50b2dnbGVUaW1lcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlc2V0VGltZXIoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IGVuZFRpbWUgLSBjdXJUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRzTGVmdCAgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Vjb25kc05vdyA9IHNlY29uZHNMZWZ0ICUgNjAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzTm93ID0gTWF0aC5mbG9vcihzZWNvbmRzTGVmdCAvIDYwKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGRvZXMgbm90IHJ1biAxMCB0aW1lcyBhIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kc05vdyAhPT0gbWUudGltZXIuY3VycmVudFNlY29uZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudGltZXIuY3VycmVudFNlY29uZCA9IHNlY29uZHNOb3c7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZHNOb3cgPSBzZWNvbmRzTm93LnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXNOb3cgPSBtaW51dGVzTm93LnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlVGltZXIoYCR7bWludXRlc05vd306JHtzZWNvbmRzTm93fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlUHJvcGVydGllcyh7Y3VycmVudDogbWlsbGlzZWNvbmRzfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS50b2dnbGVUaW1lcih0cnVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT24gY2hhbmdlIGV2ZW50IG9mIHRoZSB0ZXh0ZmllbGRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uVGltZXJJbnB1dChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEudmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnRpbWVyLmVudHJ5ID0gZGF0YS52YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuZHVyYXRpb24gPSBtZS50aW1lci5lbnRyeVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHByb3BlcnRpZXMsIHRpbWVyIGFuZCByZW1vdmUgSW50ZXJ2YWxcbiAgICAgKi9cbiAgICByZXNldFRpbWVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnVwZGF0ZVByb3BlcnRpZXMoe2N1cnJlbnQ6ICcnfSk7XG4gICAgICAgIG1lLnVwZGF0ZVRpbWVyKCcwMDowMCcpO1xuXG4gICAgICAgIGNsZWFySW50ZXJ2YWwobWUudGltZXIuaW50ZXJ2YWxJZCk7XG4gICAgICAgIGRlbGV0ZSBtZS50aW1lci5pbnRlcnZhbElkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxpcCBvdmVyIHRoZSB0aW1lciBmYWNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkb1Nob3dcbiAgICAgKi9cbiAgICB0b2dnbGVUaW1lcihkb1Nob3cpIHtcbiAgICAgICAgaWYodGhpcy5ydW5uaW5nID09PSBkb1Nob3cpIHJldHVybjtcblxuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmxpcENhcmQgPSBtZS52ZG9tLmNuWzBdLmNuWzFdO1xuXG4gICAgICAgIG1lLnJ1bm5pbmcgPSBkb1Nob3c7XG5cbiAgICAgICAgZmxpcENhcmQuY2xzID0gZmxpcENhcmQuY2xzIHx8IFtdO1xuXG4gICAgICAgIE5lb0FycmF5W2RvU2hvdyA/ICdhZGQnIDogJ3JlbW92ZSddKGZsaXBDYXJkLmNscywgJ3R1cm4nKTtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0byB0aGUgaW5wdXQgZmllbGRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGVJbnB1dEZpZWxkKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0RmllbGQgPSBtZS52ZG9tLmNuWzBdLmNuWzFdLmNuWzBdLmNuWzBdLmNuWzBdO1xuXG4gICAgICAgIGlucHV0RmllbGQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHRpbWVyLCB0eXBpY2FsbHkgb25jZSBwZXIgc2Vjb25kXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlVGltZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRpbWVyID0gbWUudmRvbS5jblswXS5jblsxXS5jblswXS5jblsxXS5jblswXTtcblxuICAgICAgICB0aW1lci50ZXh0ID0gdmFsdWU7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBjc3MgcHJvcGVydGllc1xuICAgICAqIC0gY3VycmVudCBhbW91bnQgb2Ygc2Vjb25kcyBsZWZ0XG4gICAgICogLSBmdWxsIGFtb3VudCBvZiB0aW1lXG4gICAgICogLSBzaXplIG9mIHRoZSB0aW1lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgdXBkYXRlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGxldCB7c3R5bGV9ID0gdGhpcztcblxuICAgICAgICBpZiAocHJvcGVydGllcy5jdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLW5lby10aW1lci1jdXJyZW50J10gPSBgJHtwcm9wZXJ0aWVzLmN1cnJlbnR9IWltcG9ydGFudGBcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5mdWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLW5lby10aW1lci1mdWxsJ10gPSBgJHtwcm9wZXJ0aWVzLmZ1bGx9IWltcG9ydGFudGBcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5jb2xvckVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHlsZVsnLS10aW1lci1jb2xvci1lbmQnXSA9IGAke3Byb3BlcnRpZXMuY29sb3JFbmR9IWltcG9ydGFudGBcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5jb2xvclN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLXRpbWVyLWNvbG9yLXN0YXJ0J10gPSBgJHtwcm9wZXJ0aWVzLmNvbG9yU3RhcnR9IWltcG9ydGFudGBcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcy5kaW1lbnNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlWyctLXRpbWVyLWRpbWVuc2lvbiddID0gYCR7cHJvcGVydGllcy5kaW1lbnNpb25zfSFpbXBvcnRhbnRgXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpbWVyKTtcbiIsImltcG9ydCBDb2xvckxpc3QgZnJvbSAnLi4vLi4vbGlzdC9Db2xvci5tanMnXG5pbXBvcnQgQ29tYm9Cb3ggIGZyb20gJy4vQ29tYm9Cb3gubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLkNvbG9yXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5Db21ib0JveFxuICovXG5jbGFzcyBDb2xvciBleHRlbmRzIENvbWJvQm94IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLmZpZWxkLkNvbG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5Db2xvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb2xvcmZpZWxkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbG9yZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY29sb3JmaWVsZCcsJ25lby1jb21ib2JveCcsJ25lby1waWNrZXJmaWVsZCcsJ25lby10ZXh0ZmllbGQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY29sb3JmaWVsZCcsICduZW8tY29tYm9ib3gnLCAnbmVvLXBpY2tlcmZpZWxkJywgJ25lby10ZXh0ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhLk1vZGVsIGZpZWxkIHdoaWNoIGNvbnRhaW5zIHRoZSBjb2xvciB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbG9yRmllbGQ9J25hbWUnXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZpZWxkOiAnbmFtZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSB0aGUgZm9ybWF0dGVyIHRvIGFwcGx5IGEgY3VzdG9tIGJhY2tncm91bmQtY29sb3Igc3R5bGluZy5cbiAgICAgICAgICogRS5nLiB1c2luZyBDU1MgdmFycyBmb3IgZGlmZmVyZW50IHRoZW1lc1xuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gY29sb3JGaWVsZD0oc2NvcGUsZGF0YSk9PmRhdGFbc2NvcGUuY29sb3JGaWVsZF1cbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRm9ybWF0dGVyOiAoc2NvcGUsZGF0YSkgPT4gZGF0YVtzY29wZS5jb2xvckZpZWxkXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBsaXN0Q29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0Q29uZmlnOiB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICA6IENvbG9yTGlzdCxcbiAgICAgICAgICAgIGNvbG9yRmllbGQgICAgICAgIDogJ0Bjb25maWc6Y29sb3JGaWVsZCcsXG4gICAgICAgICAgICBjb2xvckZvcm1hdHRlciAgICA6ICdAY29uZmlnOmNvbG9yRm9ybWF0dGVyJyxcbiAgICAgICAgICAgIHNpbGVudFNlbGVjdFVwZGF0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnB1dFdyYXBwZXIgPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIG1lLmdldElucHV0V3JhcHBlcklkKCkpO1xuXG4gICAgICAgIGlucHV0V3JhcHBlci52ZG9tLmNuLnVuc2hpZnQoe1xuICAgICAgICAgICAgY2xzICA6ICduZW8tY29sb3InLFxuICAgICAgICAgICAgaWQgICA6IG1lLmdldENvbG9ySW5kaWNhdG9ySWQoKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBtZS5nZXRDb2xvcigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50RmlsdGVyPWZhbHNlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgcHJldmVudEZpbHRlcj1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29sb3JJbmRpY2F0b3IgPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIG1lLmdldENvbG9ySW5kaWNhdG9ySWQoKSk/LnZkb20sXG4gICAgICAgICAgICB7bGlzdCwgcmVjb3JkfSA9IG1lLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwgPSBtZS5saXN0Py5zZWxlY3Rpb25Nb2RlbDtcblxuICAgICAgICBpZiAoY29sb3JJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGNvbG9ySW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1lLmdldENvbG9yKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5zZWxlY3QobGlzdC5nZXRJdGVtSWQocmVjb3JkW21lLnN0b3JlLmtleVByb3BlcnR5XSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uZGVzZWxlY3RBbGwodHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBzdXBlciBjYWxsIHdpbGwgdHJpZ2dlciB0aGUgdmRvbSB1cGRhdGVcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHByZXZlbnRGaWx0ZXIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2xvcigpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2lucHV0VmFsdWUsIHZhbHVlfSA9IG1lO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZSA/IG1lLmNvbG9yRm9ybWF0dGVyKG1lLCB2YWx1ZSkgOiBtZS5mb3JjZVNlbGVjdGlvbiA/IG51bGwgOiBpbnB1dFZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2xvckluZGljYXRvcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX2NvbG9yLWluZGljYXRvcmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TZWxlY3RQb3N0TGFzdEl0ZW0oKSB7XG4gICAgICAgIGxldCB7bGlzdH0gPSB0aGlzLFxuICAgICAgICAgICAgaW5kZXggID0gbGlzdC5zdG9yZS5nZXRDb3VudCgpIC0gMTtcblxuICAgICAgICBsaXN0LnZkb20uY25baW5kZXhdID0gbGlzdC5jcmVhdGVJdGVtKGxpc3Quc3RvcmUuZ2V0QXQoaW5kZXgpLCBpbmRleCk7XG5cbiAgICAgICAgc3VwZXIub25TZWxlY3RQb3N0TGFzdEl0ZW0oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNlbGVjdFByZUZpcnN0SXRlbSgpIHtcbiAgICAgICAgbGV0IHtsaXN0fSA9IHRoaXM7XG5cbiAgICAgICAgbGlzdC52ZG9tLmNuWzBdID0gbGlzdC5jcmVhdGVJdGVtKGxpc3Quc3RvcmUuZ2V0QXQoMCksIDApO1xuXG4gICAgICAgIHN1cGVyLm9uU2VsZWN0UHJlRmlyc3RJdGVtKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbG9yKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=