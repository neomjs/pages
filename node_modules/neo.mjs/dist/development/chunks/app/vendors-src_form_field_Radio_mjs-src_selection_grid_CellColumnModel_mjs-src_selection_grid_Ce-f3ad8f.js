"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_field_Radio_mjs-src_selection_grid_CellColumnModel_mjs-src_selection_grid_Ce-f3ad8f"],{

/***/ "./src/form/field/Radio.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Radio.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.form.field.Radio
 * @extends Neo.form.field.CheckBox
 */
class Radio extends _CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Radio'
         * @protected
         */
        className: 'Neo.form.field.Radio',
        /**
         * @member {String} ntype='radiofield'
         * @protected
         */
        ntype: 'radiofield',
        /**
         * @member {String[]} baseCls=['neo-radiofield','neo-checkboxfield']
         */
        baseCls: ['neo-radiofield', 'neo-checkboxfield'],
        /**
         * @member {String[]} iconCls=['far','fa-circle']
         */
        iconCls: ['far', 'fa-circle'],
        /**
         * @member {String} inputType='radio'
         */
        inputType: 'radio'
    }

    /**
     * Triggered after the checked config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetChecked(value, oldValue) {
        super.afterSetChecked(value, oldValue);

        // update radios with the same name to be unchecked
        value && this.uncheckGroupItems()
    }

    /**
     * Radios should only fire change & fieldChange events if checked.
     * If there was just 1 radio, you can not uncheck it.
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.checked && super.fireChangeEvent(value, oldValue)
    }

    /**
     * @returns {String[]}
     */
    getGroupValue() {
        let value = super.getGroupValue();

        return value.length > 0 ? value[0] : []
    }

    /**
     * Radios do not fire a change event for "uncheck", so we need to iterate over other radios with the same name.
     */
    uncheckGroupItems() {
        let me = this,
            radios;

        // discuss: we could limit this to radios inside the same form, IF a top level form is used
        radios = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find({
            ntype: 'radiofield',
            name : me.name
        });

        radios.forEach(item => {
            if (item.id !== me.id && item._checked) {
                item.checked = false
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Radio));


/***/ }),

/***/ "./src/selection/grid/CellColumnModel.mjs":
/*!************************************************!*\
  !*** ./src/selection/grid/CellColumnModel.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CellModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellModel.mjs */ "./src/selection/grid/CellModel.mjs");


/**
 * @class Neo.selection.grid.CellColumnModel
 * @extends Neo.selection.grid.CellModel
 */
class CellColumnModel extends _CellModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.CellColumnModel'
         * @protected
         */
        className: 'Neo.selection.grid.CellColumnModel',
        /**
         * @member {String} ntype='selection-grid-cellcolumnmodel'
         * @protected
         */
        ntype: 'selection-grid-cellcolumnmodel',
        /**
         * @member {String} cls='neo-selection-cellcolumnmodel'
         * @protected
         */
        cls: 'neo-selection-cellcolumnmodel',
        /**
         * @member {String} selectedColumnCellCls='selected-column-cell'
         * @protected
         */
        selectedColumnCellCls: 'selected-column-cell',
        /**
         * Storing the column dataFields
         * @member {String[]} selectedColumns=[]
         */
        selectedColumns: []
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        let me     = this,
            {view} = me,
            cellId = data.data.currentTarget;

        if (cellId) {
            me.selectedColumns = [view.getDataField(cellId)];
            view.createViewData(true)
        }

        super.onCellClick(data)
    }

    /**
     * @param {Number} step
     */
    onNavKeyColumn(step) {
        let me                 = this,
            {dataFields, view} = me,
            currentColumn, index;

        if (me.hasSelection()) {
            currentColumn = me.selectedColumns[0]
        } else {
            currentColumn = dataFields[0]
        }

        index = (dataFields.indexOf(currentColumn) + step) % dataFields.length;

        while (index < 0) {
            index += dataFields.length
        }

        me.selectedColumns = [dataFields[index]];

        view.createViewData(true);

        super.onNavKeyColumn(step)
    }

    /**
     *
     */
    unregister() {
        this.selectedColumns = [];
        this.view.createViewData();

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CellColumnModel));


/***/ }),

/***/ "./src/selection/grid/CellColumnRowModel.mjs":
/*!***************************************************!*\
  !*** ./src/selection/grid/CellColumnRowModel.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CellRowModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellRowModel.mjs */ "./src/selection/grid/CellRowModel.mjs");


/**
 * @class Neo.selection.grid.CellColumnRowModel
 * @extends Neo.selection.grid.CellRowModel
 */
class CellColumnRowModel extends _CellRowModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.CellColumnRowModel'
         * @protected
         */
        className: 'Neo.selection.grid.CellColumnRowModel',
        /**
         * @member {String} ntype='selection-grid-cellcolumnrowmodel'
         * @protected
         */
        ntype: 'selection-grid-cellcolumnrowmodel',
        /**
         * @member {String} cls='neo-selection-cellcolumnrowmodel'
         * @protected
         */
        cls: 'neo-selection-cellcolumnrowmodel',
        /**
         * @member {String} selectedColumnCellCls='selected-column-cell'
         * @protected
         */
        selectedColumnCellCls: 'selected-column-cell',
        /**
         * Storing the column dataFields
         * @member {String[]} selectedColumns=[]
         */
        selectedColumns: []
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        let me     = this,
            {view} = me,
            cellId = data.data.currentTarget;

        if (cellId) {
            me.selectedColumns = [view.getDataField(cellId)];
            view.createViewData(true)
        }

        super.onCellClick(data)
    }

    /**
     * @param {Number} step
     */
    onNavKeyColumn(step) {
        let me                 = this,
            {dataFields, view} = me,
            currentColumn, index;

        if (me.hasSelection()) {
            currentColumn = me.selectedColumns[0]
        } else {
            currentColumn = dataFields[0]
        }

        index = (dataFields.indexOf(currentColumn) + step) % dataFields.length;

        while (index < 0) {
            index += dataFields.length
        }

        me.selectedColumns = [dataFields[index]];

        view.createViewData(true);

        super.onNavKeyColumn(step)
    }

    /**
     *
     */
    unregister() {
        this.selectedColumns = [];
        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CellColumnRowModel));


/***/ }),

/***/ "./src/selection/grid/CellModel.mjs":
/*!******************************************!*\
  !*** ./src/selection/grid/CellModel.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseModel.mjs */ "./src/selection/grid/BaseModel.mjs");


/**
 * @class Neo.selection.grid.CellModel
 * @extends Neo.selection.grid.BaseModel
 */
class CellModel extends _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.CellModel'
         * @protected
         */
        className: 'Neo.selection.grid.CellModel',
        /**
         * @member {String} ntype='selection-grid-cellmodel'
         * @protected
         */
        ntype: 'selection-grid-cellmodel',
        /**
         * @member {String} cls='neo-selection-cellmodel'
         * @protected
         */
        cls: 'neo-selection-cellmodel'
    }

    /**
     *
     */
    addDomListener() {
        let me = this;

        me.view.parent.on('cellClick', me.onCellClick, me)
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.view.parent.un('cellClick', me.onCellClick, me);

        super.destroy(...args)
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        this.toggleSelection(data.data.currentTarget)
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        !this.hasEditorFocus(data) && this.onNavKeyRow(1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        !this.hasEditorFocus(data) && this.onNavKeyColumn(-1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownRight(data) {
        !this.hasEditorFocus(data) && this.onNavKeyColumn(1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        !this.hasEditorFocus(data) && this.onNavKeyRow(-1)
    }

    /**
     * @param {Number} step
     */
    onNavKeyColumn(step) {
        let me                 = this,
            {dataFields, view} = me,
            {store}            = view,
            currentColumn, currentIndex, newIndex, record;

        if (me.hasSelection()) {
            currentColumn = view.getDataField(me.items[0]);
            record        = view.getRecord(me.items[0])
        } else {
            currentColumn = dataFields[0];
            record        = store.getAt(0)
        }

        currentIndex = dataFields.indexOf(currentColumn);
        newIndex     = (currentIndex + step) % dataFields.length;

        while (newIndex < 0) {
            newIndex += dataFields.length
        }

        me.select(view.getCellId(record, dataFields[newIndex]));

        view.parent.scrollByColumns(currentIndex, step)
    }

    /**
     * @param {Number} step
     */
    onNavKeyRow(step) {
        let me           = this,
            {view}       = me,
            {store}      = view,
            currentIndex = 0,
            dataField, newIndex;

        if (me.hasSelection()) {
            currentIndex = store.indexOf(view.getRecord(me.items[0]));
            dataField    = view.getDataField(me.items[0])
        } else {
            dataField = me.dataFields[0]
        }

        newIndex = (currentIndex + step) % store.getCount();

        while (newIndex < 0) {
            newIndex += store.getCount()
        }

        me.select(view.getCellId(store.getAt(newIndex), dataField));
        view.scrollByRows(currentIndex, step)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me         = this,
            {id, view} = me,
            scope      = id;

        view.keys?._keys.push(
            {fn: 'onKeyDownDown'  ,key: 'Down'  ,scope},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope},
            {fn: 'onKeyDownUp'    ,key: 'Up'    ,scope}
        )
    }

    /**
     *
     */
    unregister() {
        let me         = this,
            {id, view} = me,
            scope      = id;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown'  ,key: 'Down'  ,scope},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope},
            {fn: 'onKeyDownUp'    ,key: 'Up'    ,scope}
        ]);

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CellModel));


/***/ }),

/***/ "./src/selection/grid/CellRowModel.mjs":
/*!*********************************************!*\
  !*** ./src/selection/grid/CellRowModel.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CellModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellModel.mjs */ "./src/selection/grid/CellModel.mjs");


/**
 * @class Neo.selection.grid.CellRowModel
 * @extends Neo.selection.grid.CellModel
 */
class CellRowModel extends _CellModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.grid.CellRowModel'
         * @protected
         */
        className: 'Neo.selection.grid.CellRowModel',
        /**
         * @member {String} ntype='selection-grid-cellrowmodel'
         * @protected
         */
        ntype: 'selection-grid-cellrowmodel',
        /**
         * @member {String} cls='neo-selection-cellrowmodel'
         * @protected
         */
        cls: 'neo-selection-cellrowmodel',
        /**
         * Storing the node ids
         * @member {String[]} selectedRows=[]
         * @protected
         */
        selectedRows: []
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        let me     = this,
            {view} = me,
            record = view.getRecord(data.data.currentTarget),
            rowId  = view.getRowId(record);

        if (rowId) {
            me.selectedRows = [rowId];
            view.createViewData(true)
        }

        super.onCellClick(data)
    }

    /**
     * @param {Number} step
     */
    onNavKeyRow(step) {
        let me           = this,
            {view}       = me,
            {store}      = view,
            countRecords = store.getCount(),
            rowId        = me.selectedRows[0] || view.getRowId(store.getAt(0)),
            record       = view.getRecord(rowId),
            index        = store.indexOf(record),
            newIndex     = (index + step) % countRecords,
            id;

        while (newIndex < 0) {
            newIndex += countRecords
        }

        id = view.getRowId(store.getAt(newIndex));

        if (id) {
            me.selectedRows = [id];
            view.createViewData(true)
        }

        super.onNavKeyRow(step)
    }

    /**
     *
     */
    unregister() {
        this.selectedRows = [];
        this.view.createViewData();

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CellRowModel));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX1JhZGlvX21qcy1zcmNfc2VsZWN0aW9uX2dyaWRfQ2VsbENvbHVtbk1vZGVsX21qcy1zcmNfc2VsZWN0aW9uX2dyaWRfQ2UtZjNhZDhmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNhOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBUTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsOERBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUscUJBQXFCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Rkc7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFTO0FBQ3ZDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7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QUN2Qjs7QUFFQTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsMENBQTBDO0FBQ3ZELGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQSxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhLDBDQUEwQztBQUN2RCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHlCQUF5QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDN0tEOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzREFBUztBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNEJBQTRCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvUmFkaW8ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL2dyaWQvQ2VsbENvbHVtbk1vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9ncmlkL0NlbGxDb2x1bW5Sb3dNb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vZ3JpZC9DZWxsTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL2dyaWQvQ2VsbFJvd01vZGVsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hlY2tCb3ggICAgICAgICBmcm9tICcuL0NoZWNrQm94Lm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZm9ybS5maWVsZC5SYWRpb1xuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuQ2hlY2tCb3hcbiAqL1xuY2xhc3MgUmFkaW8gZXh0ZW5kcyBDaGVja0JveCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5SYWRpbydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuUmFkaW8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncmFkaW9maWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdyYWRpb2ZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXJhZGlvZmllbGQnLCduZW8tY2hlY2tib3hmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1yYWRpb2ZpZWxkJywgJ25lby1jaGVja2JveGZpZWxkJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaWNvbkNscz1bJ2ZhcicsJ2ZhLWNpcmNsZSddXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiBbJ2ZhcicsICdmYS1jaXJjbGUnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaW5wdXRUeXBlPSdyYWRpbydcbiAgICAgICAgICovXG4gICAgICAgIGlucHV0VHlwZTogJ3JhZGlvJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2hlY2tlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENoZWNrZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0Q2hlY2tlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSByYWRpb3Mgd2l0aCB0aGUgc2FtZSBuYW1lIHRvIGJlIHVuY2hlY2tlZFxuICAgICAgICB2YWx1ZSAmJiB0aGlzLnVuY2hlY2tHcm91cEl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSYWRpb3Mgc2hvdWxkIG9ubHkgZmlyZSBjaGFuZ2UgJiBmaWVsZENoYW5nZSBldmVudHMgaWYgY2hlY2tlZC5cbiAgICAgKiBJZiB0aGVyZSB3YXMganVzdCAxIHJhZGlvLCB5b3UgY2FuIG5vdCB1bmNoZWNrIGl0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgJiYgc3VwZXIuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0R3JvdXBWYWx1ZSgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gc3VwZXIuZ2V0R3JvdXBWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwID8gdmFsdWVbMF0gOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJhZGlvcyBkbyBub3QgZmlyZSBhIGNoYW5nZSBldmVudCBmb3IgXCJ1bmNoZWNrXCIsIHNvIHdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIG90aGVyIHJhZGlvcyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gICAgICovXG4gICAgdW5jaGVja0dyb3VwSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICByYWRpb3M7XG5cbiAgICAgICAgLy8gZGlzY3Vzczogd2UgY291bGQgbGltaXQgdGhpcyB0byByYWRpb3MgaW5zaWRlIHRoZSBzYW1lIGZvcm0sIElGIGEgdG9wIGxldmVsIGZvcm0gaXMgdXNlZFxuICAgICAgICByYWRpb3MgPSBDb21wb25lbnRNYW5hZ2VyLmZpbmQoe1xuICAgICAgICAgICAgbnR5cGU6ICdyYWRpb2ZpZWxkJyxcbiAgICAgICAgICAgIG5hbWUgOiBtZS5uYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJhZGlvcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG1lLmlkICYmIGl0ZW0uX2NoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNoZWNrZWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUmFkaW8pO1xuIiwiaW1wb3J0IENlbGxNb2RlbCBmcm9tICcuL0NlbGxNb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLmdyaWQuQ2VsbENvbHVtbk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uc2VsZWN0aW9uLmdyaWQuQ2VsbE1vZGVsXG4gKi9cbmNsYXNzIENlbGxDb2x1bW5Nb2RlbCBleHRlbmRzIENlbGxNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLmdyaWQuQ2VsbENvbHVtbk1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLmdyaWQuQ2VsbENvbHVtbk1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi1ncmlkLWNlbGxjb2x1bW5tb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tZ3JpZC1jZWxsY29sdW1ubW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbHM9J25lby1zZWxlY3Rpb24tY2VsbGNvbHVtbm1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6ICduZW8tc2VsZWN0aW9uLWNlbGxjb2x1bW5tb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNlbGVjdGVkQ29sdW1uQ2VsbENscz0nc2VsZWN0ZWQtY29sdW1uLWNlbGwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkQ29sdW1uQ2VsbENsczogJ3NlbGVjdGVkLWNvbHVtbi1jZWxsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JpbmcgdGhlIGNvbHVtbiBkYXRhRmllbGRzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBzZWxlY3RlZENvbHVtbnM9W11cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkQ29sdW1uczogW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2VsbENsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gPSBtZSxcbiAgICAgICAgICAgIGNlbGxJZCA9IGRhdGEuZGF0YS5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICAgIGlmIChjZWxsSWQpIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkQ29sdW1ucyA9IFt2aWV3LmdldERhdGFGaWVsZChjZWxsSWQpXTtcbiAgICAgICAgICAgIHZpZXcuY3JlYXRlVmlld0RhdGEodHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLm9uQ2VsbENsaWNrKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBvbk5hdktleUNvbHVtbihzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RhdGFGaWVsZHMsIHZpZXd9ID0gbWUsXG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uLCBpbmRleDtcblxuICAgICAgICBpZiAobWUuaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW4gPSBtZS5zZWxlY3RlZENvbHVtbnNbMF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW4gPSBkYXRhRmllbGRzWzBdXG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IChkYXRhRmllbGRzLmluZGV4T2YoY3VycmVudENvbHVtbikgKyBzdGVwKSAlIGRhdGFGaWVsZHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IGRhdGFGaWVsZHMubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBtZS5zZWxlY3RlZENvbHVtbnMgPSBbZGF0YUZpZWxkc1tpbmRleF1dO1xuXG4gICAgICAgIHZpZXcuY3JlYXRlVmlld0RhdGEodHJ1ZSk7XG5cbiAgICAgICAgc3VwZXIub25OYXZLZXlDb2x1bW4oc3RlcClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMudmlldy5jcmVhdGVWaWV3RGF0YSgpO1xuXG4gICAgICAgIHN1cGVyLnVucmVnaXN0ZXIoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2VsbENvbHVtbk1vZGVsKTtcbiIsImltcG9ydCBDZWxsUm93TW9kZWwgZnJvbSAnLi9DZWxsUm93TW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5ncmlkLkNlbGxDb2x1bW5Sb3dNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5ncmlkLkNlbGxSb3dNb2RlbFxuICovXG5jbGFzcyBDZWxsQ29sdW1uUm93TW9kZWwgZXh0ZW5kcyBDZWxsUm93TW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5ncmlkLkNlbGxDb2x1bW5Sb3dNb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5ncmlkLkNlbGxDb2x1bW5Sb3dNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tZ3JpZC1jZWxsY29sdW1ucm93bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLWdyaWQtY2VsbGNvbHVtbnJvd21vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xzPSduZW8tc2VsZWN0aW9uLWNlbGxjb2x1bW5yb3dtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiAnbmVvLXNlbGVjdGlvbi1jZWxsY29sdW1ucm93bW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzZWxlY3RlZENvbHVtbkNlbGxDbHM9J3NlbGVjdGVkLWNvbHVtbi1jZWxsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZENvbHVtbkNlbGxDbHM6ICdzZWxlY3RlZC1jb2x1bW4tY2VsbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yaW5nIHRoZSBjb2x1bW4gZGF0YUZpZWxkc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gc2VsZWN0ZWRDb2x1bW5zPVtdXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZENvbHVtbnM6IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNlbGxDbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICBjZWxsSWQgPSBkYXRhLmRhdGEuY3VycmVudFRhcmdldDtcblxuICAgICAgICBpZiAoY2VsbElkKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3RlZENvbHVtbnMgPSBbdmlldy5nZXREYXRhRmllbGQoY2VsbElkKV07XG4gICAgICAgICAgICB2aWV3LmNyZWF0ZVZpZXdEYXRhKHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5vbkNlbGxDbGljayhkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgb25OYXZLZXlDb2x1bW4oc3RlcCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkYXRhRmllbGRzLCB2aWV3fSA9IG1lLFxuICAgICAgICAgICAgY3VycmVudENvbHVtbiwgaW5kZXg7XG5cbiAgICAgICAgaWYgKG1lLmhhc1NlbGVjdGlvbigpKSB7XG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uID0gbWUuc2VsZWN0ZWRDb2x1bW5zWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uID0gZGF0YUZpZWxkc1swXVxuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSAoZGF0YUZpZWxkcy5pbmRleE9mKGN1cnJlbnRDb2x1bW4pICsgc3RlcCkgJSBkYXRhRmllbGRzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpbmRleCArPSBkYXRhRmllbGRzLmxlbmd0aFxuICAgICAgICB9XG5cbiAgICAgICAgbWUuc2VsZWN0ZWRDb2x1bW5zID0gW2RhdGFGaWVsZHNbaW5kZXhdXTtcblxuICAgICAgICB2aWV3LmNyZWF0ZVZpZXdEYXRhKHRydWUpO1xuXG4gICAgICAgIHN1cGVyLm9uTmF2S2V5Q29sdW1uKHN0ZXApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29sdW1ucyA9IFtdO1xuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENlbGxDb2x1bW5Sb3dNb2RlbCk7XG4iLCJpbXBvcnQgQmFzZU1vZGVsIGZyb20gJy4vQmFzZU1vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uZ3JpZC5DZWxsTW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uZ3JpZC5CYXNlTW9kZWxcbiAqL1xuY2xhc3MgQ2VsbE1vZGVsIGV4dGVuZHMgQmFzZU1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uZ3JpZC5DZWxsTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uZ3JpZC5DZWxsTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLWdyaWQtY2VsbG1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi1ncmlkLWNlbGxtb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNscz0nbmVvLXNlbGVjdGlvbi1jZWxsbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsczogJ25lby1zZWxlY3Rpb24tY2VsbG1vZGVsJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkRG9tTGlzdGVuZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmlldy5wYXJlbnQub24oJ2NlbGxDbGljaycsIG1lLm9uQ2VsbENsaWNrLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZpZXcucGFyZW50LnVuKCdjZWxsQ2xpY2snLCBtZS5vbkNlbGxDbGljaywgbWUpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2VsbENsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy50b2dnbGVTZWxlY3Rpb24oZGF0YS5kYXRhLmN1cnJlbnRUYXJnZXQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25Eb3duKGRhdGEpIHtcbiAgICAgICAgIXRoaXMuaGFzRWRpdG9yRm9jdXMoZGF0YSkgJiYgdGhpcy5vbk5hdktleVJvdygxKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duTGVmdChkYXRhKSB7XG4gICAgICAgICF0aGlzLmhhc0VkaXRvckZvY3VzKGRhdGEpICYmIHRoaXMub25OYXZLZXlDb2x1bW4oLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25SaWdodChkYXRhKSB7XG4gICAgICAgICF0aGlzLmhhc0VkaXRvckZvY3VzKGRhdGEpICYmIHRoaXMub25OYXZLZXlDb2x1bW4oMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blVwKGRhdGEpIHtcbiAgICAgICAgIXRoaXMuaGFzRWRpdG9yRm9jdXMoZGF0YSkgJiYgdGhpcy5vbk5hdktleVJvdygtMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIG9uTmF2S2V5Q29sdW1uKHN0ZXApIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZGF0YUZpZWxkcywgdmlld30gPSBtZSxcbiAgICAgICAgICAgIHtzdG9yZX0gICAgICAgICAgICA9IHZpZXcsXG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uLCBjdXJyZW50SW5kZXgsIG5ld0luZGV4LCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKG1lLmhhc1NlbGVjdGlvbigpKSB7XG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uID0gdmlldy5nZXREYXRhRmllbGQobWUuaXRlbXNbMF0pO1xuICAgICAgICAgICAgcmVjb3JkICAgICAgICA9IHZpZXcuZ2V0UmVjb3JkKG1lLml0ZW1zWzBdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudENvbHVtbiA9IGRhdGFGaWVsZHNbMF07XG4gICAgICAgICAgICByZWNvcmQgICAgICAgID0gc3RvcmUuZ2V0QXQoMClcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGRhdGFGaWVsZHMuaW5kZXhPZihjdXJyZW50Q29sdW1uKTtcbiAgICAgICAgbmV3SW5kZXggICAgID0gKGN1cnJlbnRJbmRleCArIHN0ZXApICUgZGF0YUZpZWxkcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgbmV3SW5kZXggKz0gZGF0YUZpZWxkcy5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNlbGVjdCh2aWV3LmdldENlbGxJZChyZWNvcmQsIGRhdGFGaWVsZHNbbmV3SW5kZXhdKSk7XG5cbiAgICAgICAgdmlldy5wYXJlbnQuc2Nyb2xsQnlDb2x1bW5zKGN1cnJlbnRJbmRleCwgc3RlcClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIG9uTmF2S2V5Um93KHN0ZXApIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gICAgICAgPSBtZSxcbiAgICAgICAgICAgIHtzdG9yZX0gICAgICA9IHZpZXcsXG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSAwLFxuICAgICAgICAgICAgZGF0YUZpZWxkLCBuZXdJbmRleDtcblxuICAgICAgICBpZiAobWUuaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IHN0b3JlLmluZGV4T2Yodmlldy5nZXRSZWNvcmQobWUuaXRlbXNbMF0pKTtcbiAgICAgICAgICAgIGRhdGFGaWVsZCAgICA9IHZpZXcuZ2V0RGF0YUZpZWxkKG1lLml0ZW1zWzBdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUZpZWxkID0gbWUuZGF0YUZpZWxkc1swXVxuICAgICAgICB9XG5cbiAgICAgICAgbmV3SW5kZXggPSAoY3VycmVudEluZGV4ICsgc3RlcCkgJSBzdG9yZS5nZXRDb3VudCgpO1xuXG4gICAgICAgIHdoaWxlIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIG5ld0luZGV4ICs9IHN0b3JlLmdldENvdW50KClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNlbGVjdCh2aWV3LmdldENlbGxJZChzdG9yZS5nZXRBdChuZXdJbmRleCksIGRhdGFGaWVsZCkpO1xuICAgICAgICB2aWV3LnNjcm9sbEJ5Um93cyhjdXJyZW50SW5kZXgsIHN0ZXApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBzdXBlci5yZWdpc3Rlcihjb21wb25lbnQpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpZCwgdmlld30gPSBtZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgPSBpZDtcblxuICAgICAgICB2aWV3LmtleXM/Ll9rZXlzLnB1c2goXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25Eb3duJyAgLGtleTogJ0Rvd24nICAsc2NvcGV9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICxrZXk6ICdMZWZ0JyAgLHNjb3BlfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAsa2V5OiAnUmlnaHQnICxzY29wZX0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25VcCcgICAgLGtleTogJ1VwJyAgICAsc2NvcGV9XG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpZCwgdmlld30gPSBtZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgPSBpZDtcblxuICAgICAgICB2aWV3LmtleXM/LnJlbW92ZUtleXMoW1xuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicgICxrZXk6ICdEb3duJyAgLHNjb3BlfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkxlZnQnICAsa2V5OiAnTGVmdCcgICxzY29wZX0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgLGtleTogJ1JpZ2h0JyAsc2NvcGV9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnICAgICxrZXk6ICdVcCcgICAgLHNjb3BlfVxuICAgICAgICBdKTtcblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENlbGxNb2RlbCk7XG4iLCJpbXBvcnQgQ2VsbE1vZGVsIGZyb20gJy4vQ2VsbE1vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uZ3JpZC5DZWxsUm93TW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uZ3JpZC5DZWxsTW9kZWxcbiAqL1xuY2xhc3MgQ2VsbFJvd01vZGVsIGV4dGVuZHMgQ2VsbE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uZ3JpZC5DZWxsUm93TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uZ3JpZC5DZWxsUm93TW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLWdyaWQtY2VsbHJvd21vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi1ncmlkLWNlbGxyb3dtb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNscz0nbmVvLXNlbGVjdGlvbi1jZWxscm93bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsczogJ25lby1zZWxlY3Rpb24tY2VsbHJvd21vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JpbmcgdGhlIG5vZGUgaWRzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBzZWxlY3RlZFJvd3M9W11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRSb3dzOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DZWxsQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lLFxuICAgICAgICAgICAgcmVjb3JkID0gdmlldy5nZXRSZWNvcmQoZGF0YS5kYXRhLmN1cnJlbnRUYXJnZXQpLFxuICAgICAgICAgICAgcm93SWQgID0gdmlldy5nZXRSb3dJZChyZWNvcmQpO1xuXG4gICAgICAgIGlmIChyb3dJZCkge1xuICAgICAgICAgICAgbWUuc2VsZWN0ZWRSb3dzID0gW3Jvd0lkXTtcbiAgICAgICAgICAgIHZpZXcuY3JlYXRlVmlld0RhdGEodHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLm9uQ2VsbENsaWNrKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBvbk5hdktleVJvdyhzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICAgICAgID0gbWUsXG4gICAgICAgICAgICB7c3RvcmV9ICAgICAgPSB2aWV3LFxuICAgICAgICAgICAgY291bnRSZWNvcmRzID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIHJvd0lkICAgICAgICA9IG1lLnNlbGVjdGVkUm93c1swXSB8fCB2aWV3LmdldFJvd0lkKHN0b3JlLmdldEF0KDApKSxcbiAgICAgICAgICAgIHJlY29yZCAgICAgICA9IHZpZXcuZ2V0UmVjb3JkKHJvd0lkKSxcbiAgICAgICAgICAgIGluZGV4ICAgICAgICA9IHN0b3JlLmluZGV4T2YocmVjb3JkKSxcbiAgICAgICAgICAgIG5ld0luZGV4ICAgICA9IChpbmRleCArIHN0ZXApICUgY291bnRSZWNvcmRzLFxuICAgICAgICAgICAgaWQ7XG5cbiAgICAgICAgd2hpbGUgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgbmV3SW5kZXggKz0gY291bnRSZWNvcmRzXG4gICAgICAgIH1cblxuICAgICAgICBpZCA9IHZpZXcuZ2V0Um93SWQoc3RvcmUuZ2V0QXQobmV3SW5kZXgpKTtcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdGVkUm93cyA9IFtpZF07XG4gICAgICAgICAgICB2aWV3LmNyZWF0ZVZpZXdEYXRhKHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5vbk5hdktleVJvdyhzdGVwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFJvd3MgPSBbXTtcbiAgICAgICAgdGhpcy52aWV3LmNyZWF0ZVZpZXdEYXRhKCk7XG5cbiAgICAgICAgc3VwZXIudW5yZWdpc3RlcigpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDZWxsUm93TW9kZWwpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9