"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_table_Container_mjs"],{

/***/ "./src/selection/table/BaseModel.mjs":
/*!*******************************************!*\
  !*** ./src/selection/table/BaseModel.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Model.mjs */ "./src/selection/Model.mjs");


/**
 * Abstract base class for all table related selection models
 * @class Neo.selection.table.BaseModel
 * @extends Neo.selection.Model
 * @abstract
 */
class BaseModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.table.BaseModel'
         * @protected
         */
        className: 'Neo.selection.table.BaseModel'
    }

    /**
     * Convenience shortcut
     * @member {String[]} dataFields
     */
    get dataFields() {
        return this.view.parent.columns.map(column => column.dataField)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BaseModel));


/***/ }),

/***/ "./src/selection/table/RowModel.mjs":
/*!******************************************!*\
  !*** ./src/selection/table/RowModel.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseModel.mjs */ "./src/selection/table/BaseModel.mjs");


/**
 * @class Neo.selection.table.RowModel
 * @extends Neo.selection.table.BaseModel
 */
class RowModel extends _BaseModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.table.RowModel'
         * @protected
         */
        className: 'Neo.selection.table.RowModel',
        /**
         * @member {String} ntype='selection-table-rowmodel'
         * @protected
         */
        ntype: 'selection-table-rowmodel',
        /**
         * @member {String} cls='neo-selection-rowmodel'
         * @protected
         */
        cls: 'neo-selection-rowmodel'
    }

    /**
     * @param {Record} record
     * @returns {Boolean}
     */
    hasAnnotations(record) {
        return !!Object.getOwnPropertyDescriptor(record.__proto__, this.view.selectedRecordField)
    }

    /**
     *
     */
    addDomListener() {
        let me = this;

        me.view.parent.on('rowClick', me.onRowClick, me)
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.view.parent.un('rowClick', me.onRowClick, me);

        super.destroy(...args)
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        this.onNavKeyRow(1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        this.onNavKeyRow(-1)
    }

    /**
     * @param {Number} step
     */
    onNavKeyRow(step) {
        let me           = this,
            {view}       = me,
            {store}      = view,
            countRecords = store.getCount(),
            currentIndex = 0,
            newIndex, record, rowId;

        if (me.hasSelection()) {
            currentIndex = store.indexOf(view.getRecordByRowId(me.items[0]))
        }

        newIndex = (currentIndex + step) % countRecords;

        while (newIndex < 0) {
            newIndex += countRecords
        }

        record = store.getAt(newIndex);

        if (me.hasAnnotations(record)) {
            me.updateAnnotations(record)
        } else {
            rowId = view.getRowId(record);

            if (rowId) {
                me.select(rowId);
                view.fire('select', {record})
            }
        }
    }

    /**
     * @param {Object} data
     */
    onRowClick(data) {
        let me     = this,
            id     = data.data.currentTarget,
            {view} = me,
            isSelected, record;

        if (id) {
            record = view.getRecord(id);

            if (me.hasAnnotations(record)) {
                me.updateAnnotations(record)
            } else {
                me.toggleSelection(id);

                isSelected = me.isSelected(id);

                !isSelected && view.onDeselect?.(record);

                view.fire(isSelected ? 'select' : 'deselect', {record})
            }
        }
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let {id, view} = this;

        view.keys?._keys.push(
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        )
    }

    /**
     *
     */
    unregister() {
        let {id, view} = this;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown', key: 'Down', scope: id},
            {fn: 'onKeyDownUp',   key: 'Up',   scope: id}
        ]);

        super.unregister()
    }

    /**
     * @param {Record} record
     */
    updateAnnotations(record) {
        let me               = this,
            {view}           = me,
            rowId            = view.getRowId(record),
            isSelected       = me.isSelected(rowId),
            annotationsField = view.selectedRecordField;

        if (me.singleSelect) {
            if (isSelected) {
                record[annotationsField] = false
            } else {
                me.items.forEach(rowId => {
                    // We can use setSilent(), since the last change will trigger a view update
                    view.getRecordByRowId(rowId).setSilent({[annotationsField]: false})
                });

                record[annotationsField] = true
            }
        } else {
            record[annotationsField] = !record[annotationsField]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RowModel));


/***/ }),

/***/ "./src/table/Container.mjs":
/*!*********************************!*\
  !*** ./src/table/Container.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Css_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Css.mjs */ "./src/util/Css.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _View_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./View.mjs */ "./src/table/View.mjs");
/* harmony import */ var _header_export_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./header/_export.mjs */ "./src/table/header/_export.mjs");








/**
 * @class Neo.table.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.table.Container'
         * @protected
         */
        className: 'Neo.table.Container',
        /**
         * @member {String} ntype='table-container'
         * @protected
         */
        ntype: 'table-container',
        /**
         * @member {String[]} baseCls=['neo-table-container']
         */
        baseCls: ['neo-table-container'],
        /**
         * true uses table.plugin.CellEditing
         * @member {Boolean} cellEditing_=false
         */
        cellEditing_: false,
        /**
         * Default configs for each column
         * @member {Object} columnDefaults=null
         */
        columnDefaults: null,
        /**
         * @member {Object[]} columns_=[]
         */
        columns_: [],
        /**
         * Configs for Neo.table.header.Toolbar
         * @member {Object|null} [headerToolbarConfig=null]
         */
        headerToolbarConfig: null,
        /**
         * @member {String|null} headerToolbarId_=null
         */
        headerToolbarId_: null,
        /**
         * @member {String} layout='base'
         */
        layout: 'base',
        /**
         * @member {Boolean} scrollbarsCssApplied=false
         * @protected
         */
        scrollbarsCssApplied: false,
        /**
         * Will get removed in neo v9, assign selection models to table.View instead
         * @member {Neo.selection.Model} selectionModel_=null
         * @deprecated
         */
        selectionModel_: null,
        /**
         * @member {Boolean} showHeaderFilters_=false
         */
        showHeaderFilters_: false,
        /**
         * @member {Boolean} sortable_=true
         */
        sortable_: true,
        /**
         * @member {Neo.data.Store} store_=null
         */
        store_: null,
        /**
         * todo: only works for chrome & safari -> add a check
         * @member {Boolean} useCustomScrollbars_=true
         */
        useCustomScrollbars_: true,
        /**
         * Configs for Neo.table.View
         * @member {Object|null} [viewConfig=null]
         */
        viewConfig: null,
        /**
         * @member {String|null} viewId_=null
         * @protected
         */
        viewId_: null,
        /**
         * @member {Array|null} items=null
         * @protected
         */
        items: null,
        /**
         * @member {Object} _vdom={cls: ['neo-table-wrapper'],cn : [{tag: 'table',cn : []}]}
         */
        _vdom:
        {cls: ['neo-table-wrapper'], cn: [
            {tag: 'table', cn: []}
        ]}
    }

    /**
     * Convenience method to access the Neo.table.header.Toolbar
     * @returns {Neo.table.header.Toolbar|null}
     */
    get headerToolbar() {
        return Neo.getComponent(this.headerToolbarId) || Neo.get(this.headerToolbarId)
    }

    /**
     * Convenience method to access the Neo.table.View
     * @returns {Neo.table.View|null}
     */
    get view() {
        return Neo.getComponent(this.viewId) || Neo.get(this.viewId)
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.headerToolbarId = Neo.getId('table-header-toolbar');
        me.viewId          = Neo.getId('table-view');

        me.items = [{
            module           : _header_export_mjs__WEBPACK_IMPORTED_MODULE_6__.Toolbar,
            id               : me.headerToolbarId,
            showHeaderFilters: me.showHeaderFilters,
            sortable         : me.sortable,
            ...me.headerToolbarConfig
        }, {
            module        : _View_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
            containerId   : me.id,
            id            : me.viewId,
            selectionModel: me.selectionModel, // todo: remove this line in neo v9
            store         : me.store,
            ...me.viewConfig
        }];

        me.vdom.id = me.getWrapperId();

        me.createColumns(me.columns)
    }

    /**
     * Triggered after the cellEditing config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetCellEditing(value, oldValue) {
        if (value) {
            __webpack_require__.e(/*! import() */ "vendors-src_table_plugin_CellEditing_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/CellEditing.mjs */ "./src/table/plugin/CellEditing.mjs")).then(module => {
                let me        = this,
                    {appName} = me,
                    plugins   = me.plugins || [];

                plugins.push({
                    module: module.default,
                    appName
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the columns config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetColumns(value, oldValue) {
        if (Array.isArray(oldValue) && oldValue.length > 0) {
            let me              = this,
                {headerToolbar} = me;

            if (headerToolbar) {
                headerToolbar.items = value;
                headerToolbar.createItems()
            }

            me.view?.createViewData()
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     * @deprecated
     */
    afterSetSelectionModel(value, oldValue) {
        if (value && this.view) {
            this.view.selectionModel = value
        }
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.showHeaderFilters = value
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            this.headerToolbar.sortable = value
        }
    }

    /**
     * Triggered after the useCustomScrollbars config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseCustomScrollbars(value, oldValue) {
        if (value === true) {
            this.vdom.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].union(this.vdom.cls, ['neo-use-custom-scrollbar'])
        }
    }

    /**
     * @protected
     */
    applyCustomScrollbarsCss() {
        let me       = this,
            id       = me.getWrapperId(),
            cssRules = [];

        if (me.dockLeftMargin) {
            cssRules.push('#' + id + '::-webkit-scrollbar-track:horizontal {margin-left: ' + me.dockLeftMargin + 'px;}')
        }

        if (me.dockRightMargin) {
            cssRules.push('#' + id + '::-webkit-scrollbar-track:horizontal {margin-right: ' + me.dockRightMargin + 'px;}')
        }

        if (cssRules.length > 0) {
            _util_Css_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].insertRules(me.windowId, cssRules)
        }

        me.scrollbarsCssApplied = true
    }

    /**
     * Triggered before the columns config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    beforeSetColumns(value, oldValue) {
        if (this.configsApplied) {
            return this.createColumns(value)
        }

        return value
    }

    /**
     * Triggered before the headerToolbarId config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetHeaderToolbarId(value, oldValue) {
        return value || oldValue
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    beforeSetStore(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me = this,

            listeners = {
                filter      : me.onStoreFilter,
                load        : me.onStoreLoad,
                recordChange: me.onStoreRecordChange,
                scope       : me
            };

            if (value instanceof _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]) {
                value.on(listeners)
            } else {
                value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], {
                    listeners
                })
            }

            // in case we dynamically change the store, the view needs to get the new reference
            if (me.view) {
                me.view.store = value
            }
        }

        return value
    }

    /**
     * Triggered before the viewId config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetViewId(value, oldValue) {
        return value || oldValue
    }

    /**
     * In case you want to update multiple existing records in parallel,
     * using this method is faster than updating each record one by one.
     * At least until we introduce row based vdom updates.
     * @param {Object[]} records
     */
    bulkUpdateRecords(records) {
        let {store, view} = this,
            {keyProperty} = store;

        if (view) {
            view.silentVdomUpdate = true;

            records.forEach(item => {
                store.get(item[keyProperty])?.set(item)
            });

            view.silentVdomUpdate = false;

            view.update()
        }
    }

    /**
     * @param {Object[]} columns
     * @returns {*}
     */
    createColumns(columns) {
        let me               = this,
            {columnDefaults} = me,
            sorters          = me.store?.sorters,
            renderer;

        if (!columns || !columns.length) {
            Neo.logError('Attempting to create a table.Container without defined columns', me.id);
        }

        columns.forEach(column => {
            renderer = column.renderer;

            columnDefaults && Neo.assignDefaults(column, columnDefaults);

            if (column.dock && !column.width) {
                Neo.logError('Attempting to create a docked column without a defined width', column, me.id);
            }

            if (renderer && Neo.isString(renderer) && me[renderer]) {
                column.renderer = me[renderer]
            }

            if (sorters?.[0]) {
                if (column.dataField === sorters[0].property) {
                    column.isSorted = sorters[0].direction
                }
            }

            column.listeners = {
                sort : me.onSortColumn,
                scope: me
            }
        });

        me.items[0].items = columns;

        return columns
    }

    /**
     *
     */
    createViewData() {
        let me = this;

        me.view.createViewData();

        if (me.useCustomScrollbars && me.scrollbarsCssApplied === false) {
            me.applyCustomScrollbarsCss()
        }
    }

    /**
     * @override
     * @returns {*}
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @returns {Object[]} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.vdom.cn[0]
    }

    /**
     * @override
     * @returns {Neo.vdom.VNode}
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @returns {String}
     */
    getWrapperId() {
        return `${this.id}__wrapper`
    }

    /**
     * @param {Object} opts
     * @param {String} opts.direction
     * @param {String} opts.property
     * @protected
     */
    onSortColumn(opts) {
        let me = this;

        me.store.sort(opts);
        me.removeSortingCss(opts.property);
        me.onStoreLoad(me.store.items)
    }

    /**
     *
     */
    onStoreFilter() {
        this.onStoreLoad(this.store.items)
    }

    /**
     * @param {Object[]} data
     * @protected
     */
    onStoreLoad(data) {
        let me = this;

        if (me.rendered) {
            me.createViewData();

            if (me.store.sorters.length < 1) {
                me.removeSortingCss()
            }
        } else {
            me.on('rendered', () => {
                me.timeout(50).then(() => {
                    me.createViewData()
                })
            }, me, {once: true})
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {String} opts.field The name of the field which got changed
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {*} opts.oldValue
     * @param {Object} opts.record
     * @param {*} opts.value
     */
    onStoreRecordChange(opts) {
        this.view.onStoreRecordChange(opts)
    }

    /**
     * @param {String} dataField
     * @protected
     */
    removeSortingCss(dataField) {
        this.headerToolbar.items.forEach(column => {
            if (column.dataField !== dataField) {
                column.removeSortingCss()
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ }),

/***/ "./src/table/View.mjs":
/*!****************************!*\
  !*** ./src/table/View.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_table_RowModel_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../selection/table/RowModel.mjs */ "./src/selection/table/RowModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.table.View
 * @extends Neo.component.Base
 */
class View extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.table.View'
         * @protected
         */
        className: 'Neo.table.View',
        /**
         * @member {String} ntype='table-view'
         * @protected
         */
        ntype: 'table-view',
        /**
         * @member {String[]} baseCls=['neo-table-view']
         */
        baseCls: ['neo-table-view'],
        /**
         * Define which model field contains the value of colspan definitions
         * @member {String} colspanField='colspan'
         */
        colspanField: 'colspan',
        /**
         * @member {String|null} containerId=null
         * @protected
         */
        containerId: null,
        /**
         * @member {Boolean} highlightModifiedCells_=false
         */
        highlightModifiedCells_: false,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * @member {Object} recordVnodeMap={}
         */
        recordVnodeMap: {},
        /**
         * @member {Neo.selection.Model} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * @member {String} selectedRecordField='annotations.selected'
         */
        selectedRecordField: 'annotations.selected',
        /**
         * @member {Neo.data.Store|null} store=null
         */
        store: null,
        /**
         * @member {Boolean} useRowRecordIds=true
         */
        useRowRecordIds: true,
        /**
         * @member {Object} _vdom={tag: 'tbody', cn : []}
         */
        _vdom:
        {tag: 'tbody', tabIndex: -1, cn: []}
    }

    /**
     * @member {String[]} selectedRows
     */
    get selectedRows() {
        if (this.selectionModel.ntype === 'selection-table-rowmodel') {
            return this.selectionModel.items
        }

        return []
    }

    /**
     * @param config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([{
            click   : me.onCellClick,
            dblclick: me.onCellDoubleClick,
            delegate: '.neo-table-cell',
            scope   : me
        }, {
            click   : me.onRowClick,
            dblclick: me.onRowDoubleClick,
            delegate: '.neo-table-row',
            scope   : me
        }])
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.rendered && value.register(this)
    }

    /**
     * @param {Object} data
     * @param {String} [data.cellId]
     * @param {Object} data.column
     * @param {Number} data.columnIndex
     * @param {Object} data.record
     * @param {Number} data.rowIndex
     * @param {Neo.table.Container} data.tableContainer
     * @returns {Object}
     */
    applyRendererOutput(data) {
        let {cellId, column, columnIndex, record, rowIndex, tableContainer} = data,
            me          = this,
            cellCls     = ['neo-table-cell'],
            colspan     = record[me.colspanField],
            {dataField} = column,
            {model}     = me.store,
            fieldValue  = record[dataField],
            hasStore    = !!model, // todo: remove as soon as all tables use stores (examples table)
            {vdom}      = me,
            cellConfig, rendererOutput;

        if (!model?.getField(dataField)) {
            let nsArray   = dataField.split('.'),
                fieldName = nsArray.pop();

            fieldValue = Neo.ns(nsArray, false, record[Symbol.for('data')])?.[fieldName]
        }

        if (fieldValue === null || fieldValue === undefined) {
            fieldValue = ''
        }

        rendererOutput = column.renderer.call(column.rendererScope || tableContainer, {
            column,
            columnIndex,
            dataField,
            record,
            rowIndex,
            tableContainer,
            value: fieldValue
        });

        switch (Neo.typeOf(rendererOutput)) {
            case 'Object': {
                if (rendererOutput.html) {
                    rendererOutput.cls && cellCls.push(...rendererOutput.cls);
                } else {
                    rendererOutput = [rendererOutput];
                }
                break
            }
            case 'Date':
            case 'Number':
            case 'String': {
                rendererOutput = {
                    cls : cellCls,
                    html: rendererOutput?.toString()
                };
                break
            }
        }

        if (rendererOutput === null || rendererOutput === undefined) {
            rendererOutput = ''
        }

        if (column.cellAlign !== 'left') {
            cellCls.push('neo-' + column.cellAlign)
        }

        if (me.highlightModifiedCells) {
            if (record.isModifiedField(dataField)) {
                cellCls.push('neo-is-modified')
            }
        }

        if (!cellId) {
            // todo: remove the else part as soon as all tables use stores (examples table)
            if (hasStore) {
                cellId = me.getCellId(record, column.dataField)
            } else {
                cellId = vdom.cn[rowIndex]?.cn[me.getColumn(column.dataField, true)]?.id || Neo.getId('td')
            }
        }

        cellConfig = {
            tag  : 'td',
            id   : cellId,
            cls  : cellCls,
            style: rendererOutput.style || {}
        };

        if (colspan && Object.keys(colspan).includes(dataField)) {
            cellConfig.colspan = colspan[dataField]
        }

        if (Neo.typeOf(rendererOutput) === 'Object') {
            cellConfig.innerHTML = rendererOutput.html  || ''
        } else {
            cellConfig.cn = rendererOutput
        }

        return cellConfig
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_table_RowModel_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])
    }

    /**
     * @param {Object} opts
     * @param {Object} opts.record
     * @param {Number} [opts.rowIndex]
     * @returns {Object}
     */
    createRow({record, rowIndex}) {
        if (!Neo.isNumber(rowIndex)) {
            rowIndex = this.store.indexOf(record)
        }

        let me              = this,
            tableContainer  = me.parent,
            colspan         = record[me.colspanField],
            colspanKeys     = colspan && Object.keys(colspan),
            columns         = tableContainer.items[0].items,
            colCount        = columns.length,
            dockLeftMargin  = 0,
            dockRightMargin = 0,
            id              = me.getRowId(record, rowIndex),
            {selectedRows}  = me,
            trCls           = me.getTrClass(record, rowIndex),
            config, column, columnIndex, i, tableRow;

        me.recordVnodeMap[id] = rowIndex;

        if (selectedRows && record[me.selectedRecordField]) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(selectedRows, id)
        }

        if (selectedRows?.includes(id)) {
            trCls.push('neo-selected');

            me.parent.fire('select', {
                record
            })
        }

        tableRow = {
            tag: 'tr',
            id,
            cls: trCls,
            cn : []
        };

        for (i=0; i < colCount; i++) {
            column = columns[i];
            config = me.applyRendererOutput({column, columnIndex: i, record, rowIndex, tableContainer});

            if (column.dock) {
                config.cls = ['neo-locked', ...config.cls || []];

                if (column.dock === 'left') {
                    config.style.left = dockLeftMargin + 'px';
                    dockLeftMargin += (column.width + 1) // todo: borders fix
                }
            }

            if (column.flex) {
                config.style.width = '100%'
            }

            tableRow.cn.push(config);

            if (colspanKeys?.includes(column.dataField)) {
                i += (colspan[column.dataField] - 1)
            }
        }

        for (i=0; i < colCount; i++) {
            columnIndex = colCount - i -1;
            column      = columns[columnIndex];

            if (column.dock === 'right') {
                tableRow.cn[columnIndex].style.right = dockRightMargin + 'px';
                dockRightMargin += (column.width + 1) // todo: borders fix
            }

            if (colspanKeys?.includes(column.dataField)) {
                i += (colspan[column.dataField] - 1)
            }
        }

        // the dock margins are the same for each row
        rowIndex === 0 && Object.assign(tableContainer, {dockLeftMargin, dockRightMargin});

        return tableRow
    }

    /**
     *
     */
    createViewData() {
        let me                    = this,
            {selectedRows, store} = me,
            countRecords          = store.getCount(),
            i                     = 0,
            rows                  = [];

        for (; i < countRecords; i++) {
            rows.push(me.createRow({record: store.items[i], rowIndex: i}))
        }

        me.vdom.cn = rows;

        me.promiseUpdate().then(() => {
            if (selectedRows?.length > 0) {
                // this logic only works for selection.table.RowModel
                Neo.main.DomAccess.scrollToTableRow({appName: me.appName, id: selectedRows[0]})
            }
        })
    }

    /**
     * @param args
     */
    destroy(...args) {
        this.store = null;
        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @param {String} eventName
     */
    fireCellEvent(data, eventName) {
        let me        = this,
            id        = data.currentTarget,
            dataField = me.getCellDataField(id),
            record    = me.getRecord(id);

        me.parent.fire(eventName, {data, dataField, record, view: me})
    }

    /**
     * @param {Object} data
     * @param {String} eventName
     */
    fireRowEvent(data, eventName) {
        let me     = this,
            id     = data.currentTarget,
            record = me.getRecord(id);

        me.parent.fire(eventName, {data, record, view: me})
    }

    /**
     * @param {String} cellId
     * @returns {String}
     */
    getCellDataField(cellId) {
        return cellId.split('__')[2]
    }

    /**
     * @param {Object} record
     * @param {String} dataField
     * @returns {String}
     */
    getCellId(record, dataField) {
        return this.id + '__' + record[this.store.keyProperty] + '__' + dataField
    }

    /**
     * Get a table column or column index by a given field name
     * @param {String} field
     * @param {Boolean} returnIndex=false
     * @returns {Object|Number|null}
     */
    getColumn(field, returnIndex=false) {
        let container = this.parent,
            columns   = container.headerToolbar.items,
            i         = 0,
            len       = columns.length,
            column;

        for (; i < len; i++) {
            column = columns[i];

            if (column.dataField === field) {
                return returnIndex ? i : column
            }
        }

        return null
    }

    /**
     * @param {String} cellId
     * @returns {String}
     */
    getDataField(cellId) {
        return cellId.split('__')[2]
    }

    /**
     * Get the matching record by passing a row id, a cell id or an id inside a table cell.
     * @param {String} nodeId
     * @returns {Object|null}
     */
    getRecord(nodeId) {
        let me     = this,
            record = me.getRecordByRowId(nodeId),
            node, parentNodes;

        if (record) {
            return record;
        }

        parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getParentNodes(me.vdom, nodeId);

        for (node of parentNodes) {
            record = me.getRecordByRowId(node.id);

            if (record) {
                return record
            }
        }

        return null
    }

    /**
     * @param {String} rowId
     * @returns {Object}
     */
    getRecordByRowId(rowId) {
        return this.store.getAt(this.recordVnodeMap[rowId])
    }

    /**
     * @param {Object} record
     * @param {Number} [index]
     * @returns {String}
     */
    getRowId(record, index) {
        let me      = this,
            {store} = me;

        if (me.useRowRecordIds) {
            return `${me.id}__tr__${record[store.keyProperty]}`
        } else {
            index = Neo.isNumber(index) ? index : store.indexOf(record);
            return me.vdom.cn[index]?.id || Neo.getId('tr')
        }
    }

    /**
     * Override this method to apply custom CSS rules to table rows
     * @param {Object} record
     * @param {Number} rowIndex
     * @returns {String[]}
     */
    getTrClass(record, rowIndex) {
        return ['neo-table-row']
    }

    /**
     * @param {Object} data
     */
    onCellClick(data) {
        this.fireCellEvent(data, 'cellClick')
    }

    /**
     * @param {Object} data
     */
    onCellDoubleClick(data) {
        this.fireCellEvent(data, 'cellDoubleClick')
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.selectionModel?.register(this)
    }

    /**
     * @param {Object} data
     */
    onRowClick(data) {
        this.fireRowEvent(data, 'rowClick')
    }

    /**
     * @param {Object} data
     */
    onRowDoubleClick(data) {
        this.fireRowEvent(data, 'rowDoubleClick')
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onStoreRecordChange({fields, model, record}) {
        let me                     = this,
            fieldNames             = fields.map(field => field.name),
            needsUpdate            = false,
            tableContainer         = me.parent,
            rowIndex               = me.store.indexOf(record),
            {selectionModel, vdom} = me,
            cellId, cellNode, cellVdom, column, columnIndex, scope;

        if (fieldNames.includes(me.colspanField)) {
            me.vdom.cn[rowIndex] = me.createRow({record, rowIndex});
            me.update()
        } else {
            fields.forEach(field => {
                if (field.name === me.selectedRecordField) {
                    if (selectionModel.ntype === 'selection-table-rowmodel') {
                        selectionModel[field.value ? 'select' : 'deselect'](me.getRowId(record))
                    }
                } else {
                    cellId   = me.getCellId(record, field.name);
                    cellNode = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].find(vdom, cellId);

                    // the vdom might not exist yet => nothing to do in this case
                    if (cellNode?.vdom) {
                        column      = me.getColumn(field.name);
                        columnIndex = cellNode.index;
                        needsUpdate = true;
                        scope       = column.rendererScope || tableContainer;
                        cellVdom    = me.applyRendererOutput({cellId, column, columnIndex, record, rowIndex, tableContainer});

                        cellNode.parentNode.cn[columnIndex] = cellVdom
                    }
                }
            })
        }

        needsUpdate && me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(View));


/***/ }),

/***/ "./src/table/header/Button.mjs":
/*!*************************************!*\
  !*** ./src/table/header/Button.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");





/**
 * @class Neo.table.header.Button
 * @extends Neo.button.Base
 */
class Button extends _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} cellAlignValues: ['left','center','right']
     * @protected
     * @static
     */
    static cellAlignValues = ['left', 'center', 'right']

    static config = {
        /**
         * @member {String} className='Neo.table.header.Button'
         * @protected
         */
        className: 'Neo.table.header.Button',
        /**
         * @member {String} ntype='table-header-button'
         * @protected
         */
        ntype: 'table-header-button',
        /**
         * @member {String[]} baseCls=['neo-table-header-button']
         */
        baseCls: ['neo-table-header-button'],
        /**
         * Alignment of the matching table cells. Valid values are left, center, right
         * @member {String} cellAlign_='left'
         */
        cellAlign_: 'left',
        /**
         * @member {String|null} dataField=null
         */
        dataField: null,
        /**
         * Sort direction when clicking on an unsorted button
         * @member {String} defaultSortDirection='ASC'
         */
        defaultSortDirection: 'ASC',
        /**
         * @member {Boolean} draggable_=true
         */
        draggable_: true,
        /**
         * @member {Object} editorConfig=null
         */
        editorConfig: null,
        /**
         * @member {Object} filterConfig=null
         */
        filterConfig: null,
        /**
         * @member {Neo.form.field.Base|null} filterField=null
         * @protected
         */
        filterField: null,
        /**
         * @member {String} iconCls='fa fa-arrow-circle-up'
         */
        iconCls: 'fa fa-arrow-circle-up',
        /**
         * @member {String} iconPosition='right'
         */
        iconPosition: 'right',
        /**
         * 'ASC', 'DESC' or null
         * @member {String|null} isSorted_=null
         * @protected
         */
        isSorted_: null,
        /**
         * @member {Function|String|null} renderer_='cellRenderer'
         */
        renderer_: 'cellRenderer',
        /**
         * Scope to execute the column renderer.
         * Defaults to the matching table.Container
         * @member {Neo.core.Base|null} rendererScope=null
         */
        rendererScope: null,
        /**
         * @member {Boolean} showHeaderFilter_=false
         */
        showHeaderFilter_: false,
        /**
         * @member {Boolean} sortable_=true
         */
        sortable_: true,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'th', cn: [
            {tag: 'button', cn: [
                {tag: 'span', cls: ['neo-button-glyph']},
                {tag: 'span', cls: ['neo-button-text']},
                {tag: 'span', cls: ['neo-button-badge']},
                {tag: 'span', cls: ['neo-button-ripple-wrapper'], cn: [
                    {tag: 'span', cls: ['neo-button-ripple']}
                ]}
            ]}
        ]}
    }

    /**
     * Triggered after the isSorted config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetIsSorted(value, oldValue) {
        let me        = this,
            {cls}     = me,
            container = me.up('table-container');

        switch(value) {
            case null:
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');
                break
            case 'ASC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-desc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-asc');
                break
            case 'DESC':
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-asc');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-desc');
                break
        }

        me.cls = cls;

        // testing check until all example tables have a store
        if (!container || !container.store) {
            return
        }

        me.mounted && me.fire('sort', {
            direction: value,
            property : me.dataField
        })
    }

    /**
     * Triggered after the showHeaderFilter config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilter(value, oldValue) {
        let me = this;

        if (value) {
            if (!me.filterField) {
                me.filterField = Neo.create({
                    module   : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                    appName  : me.appName,
                    flag     : 'filter-field',
                    hideLabel: true,
                    parentId : me.id,
                    style    : {marginLeft: '.5em', marginRight: '.5em'},
                    windowId : me.windowId,

                    listeners: {
                        change        : me.changeFilterValue,
                        operatorChange: me.changeFilterOperator,
                        scope         : me
                    },

                    ...me.editorConfig
                });

                me.vdom.cn.push(me.filterField.createVdomReference())
            } else {
                delete me.filterField.vdom.removeDom
            }
        } else if (me.filterField) {
            me.filterField.vdom.removeDom = true
        }

        me.updateDepth = 2;
        me.update()
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
     afterSetSortable(value, oldValue) {
        let me    = this,
            {cls} = me;

        if (value === true) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-sort-hidden');

            me.addDomListeners({
                click: me.onButtonClick,
                scope: me
            })
        } else {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

            me.removeDomListeners({
                click: me.onButtonClick,
                scope: me
            })
        }

        me.cls = cls;
        me.update()
    }

    /**
     * Triggered before the cellAlign config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetCellAlign(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'cellAlign', 'cellAlignValues')
    }

    /**
     * Triggered before the renderer config gets changed
     * @param {Function|String|null} value
     * @param {Function|String|null} oldValue
     * @protected
     */
    beforeSetRenderer(value, oldValue) {
        return (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCallback)(value, this).fn
    }

    /**
     * @param {Object}              data
     * @param {Neo.button.Base}     data.column
     * @param {Number}              data.columnIndex
     * @param {String}              data.dataField
     * @param {Object}              data.record
     * @param {Number}              data.rowIndex
     * @param {Neo.table.Container} data.tableContainer
     * @param {Number|String}       data.value
     * @returns {*}
     */
    cellRenderer(data) {
        return data.value
    }

    /**
     * @param {Object} data
     */
    changeFilterOperator(data) {
        let me             = this,
            tableContainer = me.up('table-container'),
            store          = tableContainer?.store,
            operator       = data.value,
            filter, filters;

        if (store) {
            filter = store.getFilter(me.dataField);

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator,
                    value   : null,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.operator = operator
            }
        }
    }

    /**
     * @param {Object} data
     */
    changeFilterValue(data) {
        let me             = this,
            tableContainer = me.up('table-container'),
            store          = tableContainer?.store,
            {value}        = data,
            field, filter, filters, model;

        if (store) {
            filter = store.getFilter(me.dataField);
            model  = store.model;
            field  = model && model.getField(me.dataField);

            if (value && field.type.toLowerCase() === 'date') {
                value = new Date(value)
            }

            if (Neo.isRecord(value)) {
                value = value[me.filterField.displayField]
            }

            if (!filter) {
                filters = store.filters;

                filters.push({
                    property: me.dataField,
                    operator: 'like',
                    value,
                    ...me.filterConfig
                });

                store.filters = filters
            } else {
                filter.value = value
            }
        }
    }

    /**
     *
     */
    destroy(...args) {
        this.filterField?.destroy();

        super.destroy(...args)
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }

    /**
     * @protected
     */
    onButtonClick() {
        let me = this,
            map;

        if (me.defaultSortDirection === 'DESC') {
            map = {
                ASC : null,
                DESC: 'ASC',
                null: 'DESC'
            }
        } else {
            map = {
                ASC : 'DESC',
                DESC: null,
                null: 'ASC'
            }
        }

        me.isSorted = map[me.isSorted + '']
    }

    /**
     * @protected
     */
    removeSortingCss() {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-sort-hidden');

        me.cls       = cls;
        me._isSorted = null
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Button));


/***/ }),

/***/ "./src/table/header/Toolbar.mjs":
/*!**************************************!*\
  !*** ./src/table/header/Toolbar.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.table.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.table.header.Toolbar'
         * @protected
         */
        className: 'Neo.table.header.Toolbar',
        /**
         * @member {String} ntype='table-header-toolbar'
         * @protected
         */
        ntype: 'table-header-toolbar',
        /**
         * @member {String[]} baseCls=['neo-table-header-toolbar']
         */
        baseCls: ['neo-table-header-toolbar'],
        /**
         * @member {Boolean} draggable_=true
         */
        draggable_: true,
        /**
         * @member {String} layout='base'
         */
        layout: 'base',
        /**
         * @member {Object} itemDefaults={ntype : 'table-header-button'}
         */
        itemDefaults: {
            ntype: 'table-header-button'
        },
        /**
         * @member {Boolean} showHeaderFilters_=false
         */
        showHeaderFilters_: false,
        /**
         * Convenience shortcut to pass sortable to all toolbar items.
         * If set to true, header clicks will sort the matching column (ASC, DESC, null)
         * @member {Boolean} sortable=true
         */
        sortable: true,
        /**
         * @member {Object} _vdom={tag:'thead',cn:[{tag:'tr',cn:[]}]}
         */
        _vdom:
        {tag: 'thead', cn: [
            {tag: 'tr', cn: []}
        ]}
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_toolbar_SortZone_mjs"), __webpack_require__.e("src_draggable_table_header_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../draggable/table/header/toolbar/SortZone.mjs */ "./src/draggable/table/header/toolbar/SortZone.mjs")).then(module => {
                let {appName, id, windowId} = me;

                me.sortZone = Neo.create({
                    module             : module.default,
                    appName,
                    boundaryContainerId: id,
                    owner              : me,
                    windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the showHeaderFilters config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowHeaderFilters(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    showHeaderFilter: value
                })
            });

            me.updateDepth = -1; // filters can be deeply nested
            me.update()
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
     afterSetSortable(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items.forEach(item => {
                item.setSilent({
                    sortable: value
                })
            });

            me.updateDepth = 2;
            me.update()
        }
    }

    /**
     *
     */
    createItems() {
        let me = this;

        me.itemDefaults.showHeaderFilter = me.showHeaderFilters;

        me.items.forEach(item => {
            if (!Object.hasOwn(item, 'sortable')) {
                item.sortable = me.sortable
            }
        });

        super.createItems();

        let dockLeftWidth  = 0,
            dockRightWidth = 0,
            {items}        = me,
            len            = items.length,
            style;

        items.forEach((item, index) => {
            style = item.wrapperStyle;

            // todo: only add px if number
            if (item.maxWidth) {style.maxWidth = item.maxWidth + 'px'}
            if (item.minWidth) {style.minWidth = item.minWidth + 'px'}
            if (item.width)    {style.width    = item.width    + 'px'}

            if (item.dock) {
                item.vdom.cls = ['neo-locked'];

                if (item.dock === 'left') {
                    style.left = dockLeftWidth + 'px'
                }

                dockLeftWidth += (item.width + 1) // todo: borders fix
            } else {
                item.vdom.cls = [] // remove the button cls from the th tag
            }

            item.wrapperStyle = style;

            // inverse loop direction
            item = items[len - index -1];

            if (item.dock === 'right') {
                style = item.wrapperStyle;
                style.right = dockRightWidth + 'px';

                item.wrapperStyle = style;

                dockRightWidth += (item.width + 1) // todo: borders fix
            }
        });

        me.update()
    }

    /**
     * @param {String} dataField
     * @returns {Neo.button.Base|null}
     */
    getColumn(dataField) {
        for (const item of this.items) {
            if (item.dataField === dataField) {
                return item
            }
        }

        return null
    }

    /**
     * @param {String} dock
     * @returns {String} layoutConfig
     * @override
     */
    getLayoutConfig(dock) {
        return 'base'
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom.cn[0]
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ }),

/***/ "./src/table/header/_export.mjs":
/*!**************************************!*\
  !*** ./src/table/header/_export.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* reexport safe */ _Button_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   Toolbar: () => (/* reexport safe */ _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _Button_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.mjs */ "./src/table/header/Button.mjs");
/* harmony import */ var _Toolbar_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Toolbar.mjs */ "./src/table/header/Toolbar.mjs");





/***/ }),

/***/ "./src/util/Css.mjs":
/*!**************************!*\
  !*** ./src/util/Css.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Css
 * @extends Neo.core.Base
 */
class Css extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Css'
         * @protected
         */
        className: 'Neo.util.Css'
    }

    /**
     * Pass the selectorText of the rules which you want to remove
     * @param {Number} windowId
     * @param {String[]|String} rules
     */
    static deleteRules(windowId, rules) {
        if (!Array.isArray(rules)) {
            rules = [rules]
        }

        Neo.main.addon.Stylesheet.deleteCssRules({rules, windowId})
    }

    /**
     * @param {Number} windowId
     * @param {String[]|String} rules
     */
    static insertRules(windowId, rules) {
        if (!Array.isArray(rules)) {
            rules = [rules]
        }

        Neo.main.addon.Stylesheet.insertCssRules({rules, windowId})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Css));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190YWJsZV9Db250YWluZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQUs7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHlCQUF5QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDMUJEOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBUztBQUNoQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFR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O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsdUJBQXVCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hPSjtBQUNDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0RBOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBSTtBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7O0FBRUEsaUVBQWUsbUJBQW1CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi90YWJsZS9CYXNlTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL3RhYmxlL1Jvd01vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3RhYmxlL0NvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90YWJsZS9WaWV3Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3RhYmxlL2hlYWRlci9CdXR0b24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFibGUvaGVhZGVyL1Rvb2xiYXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFibGUvaGVhZGVyL19leHBvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9Dc3MubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNb2RlbCBmcm9tICcuLi9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCB0YWJsZSByZWxhdGVkIHNlbGVjdGlvbiBtb2RlbHNcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLnRhYmxlLkJhc2VNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEJhc2VNb2RlbCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24udGFibGUuQmFzZU1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLnRhYmxlLkJhc2VNb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkYXRhRmllbGRzXG4gICAgICovXG4gICAgZ2V0IGRhdGFGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcucGFyZW50LmNvbHVtbnMubWFwKGNvbHVtbiA9PiBjb2x1bW4uZGF0YUZpZWxkKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZU1vZGVsKTtcbiIsImltcG9ydCBCYXNlTW9kZWwgZnJvbSAnLi9CYXNlTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi50YWJsZS5Sb3dNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi50YWJsZS5CYXNlTW9kZWxcbiAqL1xuY2xhc3MgUm93TW9kZWwgZXh0ZW5kcyBCYXNlTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi50YWJsZS5Sb3dNb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi50YWJsZS5Sb3dNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tdGFibGUtcm93bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLXRhYmxlLXJvd21vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xzPSduZW8tc2VsZWN0aW9uLXJvd21vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6ICduZW8tc2VsZWN0aW9uLXJvd21vZGVsJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNBbm5vdGF0aW9ucyhyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuICEhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWNvcmQuX19wcm90b19fLCB0aGlzLnZpZXcuc2VsZWN0ZWRSZWNvcmRGaWVsZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZpZXcucGFyZW50Lm9uKCdyb3dDbGljaycsIG1lLm9uUm93Q2xpY2ssIG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmlldy5wYXJlbnQudW4oJ3Jvd0NsaWNrJywgbWUub25Sb3dDbGljaywgbWUpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkRvd24oZGF0YSkge1xuICAgICAgICB0aGlzLm9uTmF2S2V5Um93KDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25VcChkYXRhKSB7XG4gICAgICAgIHRoaXMub25OYXZLZXlSb3coLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBvbk5hdktleVJvdyhzdGVwKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICAgICAgID0gbWUsXG4gICAgICAgICAgICB7c3RvcmV9ICAgICAgPSB2aWV3LFxuICAgICAgICAgICAgY291bnRSZWNvcmRzID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IDAsXG4gICAgICAgICAgICBuZXdJbmRleCwgcmVjb3JkLCByb3dJZDtcblxuICAgICAgICBpZiAobWUuaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IHN0b3JlLmluZGV4T2Yodmlldy5nZXRSZWNvcmRCeVJvd0lkKG1lLml0ZW1zWzBdKSlcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0luZGV4ID0gKGN1cnJlbnRJbmRleCArIHN0ZXApICUgY291bnRSZWNvcmRzO1xuXG4gICAgICAgIHdoaWxlIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIG5ld0luZGV4ICs9IGNvdW50UmVjb3Jkc1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQobmV3SW5kZXgpO1xuXG4gICAgICAgIGlmIChtZS5oYXNBbm5vdGF0aW9ucyhyZWNvcmQpKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVBbm5vdGF0aW9ucyhyZWNvcmQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3dJZCA9IHZpZXcuZ2V0Um93SWQocmVjb3JkKTtcblxuICAgICAgICAgICAgaWYgKHJvd0lkKSB7XG4gICAgICAgICAgICAgICAgbWUuc2VsZWN0KHJvd0lkKTtcbiAgICAgICAgICAgICAgICB2aWV3LmZpcmUoJ3NlbGVjdCcsIHtyZWNvcmR9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJvd0NsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgPSBkYXRhLmRhdGEuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lLFxuICAgICAgICAgICAgaXNTZWxlY3RlZCwgcmVjb3JkO1xuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcmVjb3JkID0gdmlldy5nZXRSZWNvcmQoaWQpO1xuXG4gICAgICAgICAgICBpZiAobWUuaGFzQW5ub3RhdGlvbnMocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUFubm90YXRpb25zKHJlY29yZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUudG9nZ2xlU2VsZWN0aW9uKGlkKTtcblxuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBtZS5pc1NlbGVjdGVkKGlkKTtcblxuICAgICAgICAgICAgICAgICFpc1NlbGVjdGVkICYmIHZpZXcub25EZXNlbGVjdD8uKHJlY29yZCk7XG5cbiAgICAgICAgICAgICAgICB2aWV3LmZpcmUoaXNTZWxlY3RlZCA/ICdzZWxlY3QnIDogJ2Rlc2VsZWN0Jywge3JlY29yZH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyKGNvbXBvbmVudCk7XG5cbiAgICAgICAgbGV0IHtpZCwgdmlld30gPSB0aGlzO1xuXG4gICAgICAgIHZpZXcua2V5cz8uX2tleXMucHVzaChcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nLCBrZXk6ICdEb3duJywgc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJywgICBrZXk6ICdVcCcsICAgc2NvcGU6IGlkfVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBsZXQge2lkLCB2aWV3fSA9IHRoaXM7XG5cbiAgICAgICAgdmlldy5rZXlzPy5yZW1vdmVLZXlzKFtcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkRvd24nLCBrZXk6ICdEb3duJywgc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blVwJywgICBrZXk6ICdVcCcsICAgc2NvcGU6IGlkfVxuICAgICAgICBdKTtcblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gcmVjb3JkXG4gICAgICovXG4gICAgdXBkYXRlQW5ub3RhdGlvbnMocmVjb3JkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIHJvd0lkICAgICAgICAgICAgPSB2aWV3LmdldFJvd0lkKHJlY29yZCksXG4gICAgICAgICAgICBpc1NlbGVjdGVkICAgICAgID0gbWUuaXNTZWxlY3RlZChyb3dJZCksXG4gICAgICAgICAgICBhbm5vdGF0aW9uc0ZpZWxkID0gdmlldy5zZWxlY3RlZFJlY29yZEZpZWxkO1xuXG4gICAgICAgIGlmIChtZS5zaW5nbGVTZWxlY3QpIHtcbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkW2Fubm90YXRpb25zRmllbGRdID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuaXRlbXMuZm9yRWFjaChyb3dJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2Ugc2V0U2lsZW50KCksIHNpbmNlIHRoZSBsYXN0IGNoYW5nZSB3aWxsIHRyaWdnZXIgYSB2aWV3IHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmdldFJlY29yZEJ5Um93SWQocm93SWQpLnNldFNpbGVudCh7W2Fubm90YXRpb25zRmllbGRdOiBmYWxzZX0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZWNvcmRbYW5ub3RhdGlvbnNGaWVsZF0gPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRbYW5ub3RhdGlvbnNGaWVsZF0gPSAhcmVjb3JkW2Fubm90YXRpb25zRmllbGRdXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFJvd01vZGVsKTtcbiIsImltcG9ydCBCYXNlQ29udGFpbmVyICAgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENzc1V0aWwgICAgICAgICBmcm9tICcuLi91dGlsL0Nzcy5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgU3RvcmUgICAgICAgICAgIGZyb20gJy4uL2RhdGEvU3RvcmUubWpzJztcbmltcG9ydCBWaWV3ICAgICAgICAgICAgZnJvbSAnLi9WaWV3Lm1qcyc7XG5pbXBvcnQgKiBhcyBoZWFkZXIgICAgIGZyb20gJy4vaGVhZGVyL19leHBvcnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRhYmxlLkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIEJhc2VDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYmxlLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYmxlLkNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWJsZS1jb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGFibGUtY29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRhYmxlLWNvbnRhaW5lciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10YWJsZS1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgdXNlcyB0YWJsZS5wbHVnaW4uQ2VsbEVkaXRpbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY2VsbEVkaXRpbmdfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjZWxsRWRpdGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWdzIGZvciBlYWNoIGNvbHVtblxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNvbHVtbkRlZmF1bHRzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbkRlZmF1bHRzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGNvbHVtbnNfPVtdXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5zXzogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWdzIGZvciBOZW8udGFibGUuaGVhZGVyLlRvb2xiYXJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IFtoZWFkZXJUb29sYmFyQ29uZmlnPW51bGxdXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJUb29sYmFyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGhlYWRlclRvb2xiYXJJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyVG9vbGJhcklkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGF5b3V0PSdiYXNlJ1xuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiAnYmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzY3JvbGxiYXJzQ3NzQXBwbGllZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxiYXJzQ3NzQXBwbGllZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGdldCByZW1vdmVkIGluIG5lbyB2OSwgYXNzaWduIHNlbGVjdGlvbiBtb2RlbHMgdG8gdGFibGUuVmlldyBpbnN0ZWFkXG4gICAgICAgICAqIEBtZW1iZXIge05lby5zZWxlY3Rpb24uTW9kZWx9IHNlbGVjdGlvbk1vZGVsXz1udWxsXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25Nb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93SGVhZGVyRmlsdGVyc189ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNob3dIZWFkZXJGaWx0ZXJzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzb3J0YWJsZV89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV9IHN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b2RvOiBvbmx5IHdvcmtzIGZvciBjaHJvbWUgJiBzYWZhcmkgLT4gYWRkIGEgY2hlY2tcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlQ3VzdG9tU2Nyb2xsYmFyc189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlQ3VzdG9tU2Nyb2xsYmFyc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWdzIGZvciBOZW8udGFibGUuVmlld1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gW3ZpZXdDb25maWc9bnVsbF1cbiAgICAgICAgICovXG4gICAgICAgIHZpZXdDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdmlld0lkXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZpZXdJZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBpdGVtcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17Y2xzOiBbJ25lby10YWJsZS13cmFwcGVyJ10sY24gOiBbe3RhZzogJ3RhYmxlJyxjbiA6IFtdfV19XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NsczogWyduZW8tdGFibGUtd3JhcHBlciddLCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ3RhYmxlJywgY246IFtdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhY2Nlc3MgdGhlIE5lby50YWJsZS5oZWFkZXIuVG9vbGJhclxuICAgICAqIEByZXR1cm5zIHtOZW8udGFibGUuaGVhZGVyLlRvb2xiYXJ8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgaGVhZGVyVG9vbGJhcigpIHtcbiAgICAgICAgcmV0dXJuIE5lby5nZXRDb21wb25lbnQodGhpcy5oZWFkZXJUb29sYmFySWQpIHx8IE5lby5nZXQodGhpcy5oZWFkZXJUb29sYmFySWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFjY2VzcyB0aGUgTmVvLnRhYmxlLlZpZXdcbiAgICAgKiBAcmV0dXJucyB7TmVvLnRhYmxlLlZpZXd8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgdmlldygpIHtcbiAgICAgICAgcmV0dXJuIE5lby5nZXRDb21wb25lbnQodGhpcy52aWV3SWQpIHx8IE5lby5nZXQodGhpcy52aWV3SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5oZWFkZXJUb29sYmFySWQgPSBOZW8uZ2V0SWQoJ3RhYmxlLWhlYWRlci10b29sYmFyJyk7XG4gICAgICAgIG1lLnZpZXdJZCAgICAgICAgICA9IE5lby5nZXRJZCgndGFibGUtdmlldycpO1xuXG4gICAgICAgIG1lLml0ZW1zID0gW3tcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgOiBoZWFkZXIuVG9vbGJhcixcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgOiBtZS5oZWFkZXJUb29sYmFySWQsXG4gICAgICAgICAgICBzaG93SGVhZGVyRmlsdGVyczogbWUuc2hvd0hlYWRlckZpbHRlcnMsXG4gICAgICAgICAgICBzb3J0YWJsZSAgICAgICAgIDogbWUuc29ydGFibGUsXG4gICAgICAgICAgICAuLi5tZS5oZWFkZXJUb29sYmFyQ29uZmlnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgOiBWaWV3LFxuICAgICAgICAgICAgY29udGFpbmVySWQgICA6IG1lLmlkLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICA6IG1lLnZpZXdJZCxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsOiBtZS5zZWxlY3Rpb25Nb2RlbCwgLy8gdG9kbzogcmVtb3ZlIHRoaXMgbGluZSBpbiBuZW8gdjlcbiAgICAgICAgICAgIHN0b3JlICAgICAgICAgOiBtZS5zdG9yZSxcbiAgICAgICAgICAgIC4uLm1lLnZpZXdDb25maWdcbiAgICAgICAgfV07XG5cbiAgICAgICAgbWUudmRvbS5pZCA9IG1lLmdldFdyYXBwZXJJZCgpO1xuXG4gICAgICAgIG1lLmNyZWF0ZUNvbHVtbnMobWUuY29sdW1ucylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNlbGxFZGl0aW5nIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q2VsbEVkaXRpbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuL3BsdWdpbi9DZWxsRWRpdGluZy5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHthcHBOYW1lfSA9IG1lLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5zICAgPSBtZS5wbHVnaW5zIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbHVtbnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvbGRWYWx1ZSkgJiYgb2xkVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2hlYWRlclRvb2xiYXJ9ID0gbWU7XG5cbiAgICAgICAgICAgIGlmIChoZWFkZXJUb29sYmFyKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyVG9vbGJhci5pdGVtcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGhlYWRlclRvb2xiYXIuY3JlYXRlSXRlbXMoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS52aWV3Py5jcmVhdGVWaWV3RGF0YSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMudmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3LnNlbGVjdGlvbk1vZGVsID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0hlYWRlckZpbHRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93SGVhZGVyRmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyVG9vbGJhci5zaG93SGVhZGVyRmlsdGVycyA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNvcnRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclRvb2xiYXIuc29ydGFibGUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB1c2VDdXN0b21TY3JvbGxiYXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VXNlQ3VzdG9tU2Nyb2xsYmFycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnZkb20uY2xzID0gTmVvQXJyYXkudW5pb24odGhpcy52ZG9tLmNscywgWyduZW8tdXNlLWN1c3RvbS1zY3JvbGxiYXInXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhcHBseUN1c3RvbVNjcm9sbGJhcnNDc3MoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICA9IG1lLmdldFdyYXBwZXJJZCgpLFxuICAgICAgICAgICAgY3NzUnVsZXMgPSBbXTtcblxuICAgICAgICBpZiAobWUuZG9ja0xlZnRNYXJnaW4pIHtcbiAgICAgICAgICAgIGNzc1J1bGVzLnB1c2goJyMnICsgaWQgKyAnOjotd2Via2l0LXNjcm9sbGJhci10cmFjazpob3Jpem9udGFsIHttYXJnaW4tbGVmdDogJyArIG1lLmRvY2tMZWZ0TWFyZ2luICsgJ3B4O30nKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmRvY2tSaWdodE1hcmdpbikge1xuICAgICAgICAgICAgY3NzUnVsZXMucHVzaCgnIycgKyBpZCArICc6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrOmhvcml6b250YWwge21hcmdpbi1yaWdodDogJyArIG1lLmRvY2tSaWdodE1hcmdpbiArICdweDt9JylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjc3NSdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBDc3NVdGlsLmluc2VydFJ1bGVzKG1lLndpbmRvd0lkLCBjc3NSdWxlcylcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnNjcm9sbGJhcnNDc3NBcHBsaWVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGNvbHVtbnMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldENvbHVtbnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb2x1bW5zKHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaGVhZGVyVG9vbGJhcklkIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEhlYWRlclRvb2xiYXJJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IG9sZFZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgICAgIGZpbHRlciAgICAgIDogbWUub25TdG9yZUZpbHRlcixcbiAgICAgICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uU3RvcmVMb2FkLFxuICAgICAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25TdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdG9yZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLm9uKGxpc3RlbmVycylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFN0b3JlLCB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UgZHluYW1pY2FsbHkgY2hhbmdlIHRoZSBzdG9yZSwgdGhlIHZpZXcgbmVlZHMgdG8gZ2V0IHRoZSBuZXcgcmVmZXJlbmNlXG4gICAgICAgICAgICBpZiAobWUudmlldykge1xuICAgICAgICAgICAgICAgIG1lLnZpZXcuc3RvcmUgPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgdmlld0lkIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFZpZXdJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IG9sZFZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3Ugd2FudCB0byB1cGRhdGUgbXVsdGlwbGUgZXhpc3RpbmcgcmVjb3JkcyBpbiBwYXJhbGxlbCxcbiAgICAgKiB1c2luZyB0aGlzIG1ldGhvZCBpcyBmYXN0ZXIgdGhhbiB1cGRhdGluZyBlYWNoIHJlY29yZCBvbmUgYnkgb25lLlxuICAgICAqIEF0IGxlYXN0IHVudGlsIHdlIGludHJvZHVjZSByb3cgYmFzZWQgdmRvbSB1cGRhdGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHJlY29yZHNcbiAgICAgKi9cbiAgICBidWxrVXBkYXRlUmVjb3JkcyhyZWNvcmRzKSB7XG4gICAgICAgIGxldCB7c3RvcmUsIHZpZXd9ID0gdGhpcyxcbiAgICAgICAgICAgIHtrZXlQcm9wZXJ0eX0gPSBzdG9yZTtcblxuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdmlldy5zaWxlbnRWZG9tVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIHN0b3JlLmdldChpdGVtW2tleVByb3BlcnR5XSk/LnNldChpdGVtKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZpZXcuc2lsZW50VmRvbVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBjb2x1bW5zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY3JlYXRlQ29sdW1ucyhjb2x1bW5zKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb2x1bW5EZWZhdWx0c30gPSBtZSxcbiAgICAgICAgICAgIHNvcnRlcnMgICAgICAgICAgPSBtZS5zdG9yZT8uc29ydGVycyxcbiAgICAgICAgICAgIHJlbmRlcmVyO1xuXG4gICAgICAgIGlmICghY29sdW1ucyB8fCAhY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcignQXR0ZW1wdGluZyB0byBjcmVhdGUgYSB0YWJsZS5Db250YWluZXIgd2l0aG91dCBkZWZpbmVkIGNvbHVtbnMnLCBtZS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIHJlbmRlcmVyID0gY29sdW1uLnJlbmRlcmVyO1xuXG4gICAgICAgICAgICBjb2x1bW5EZWZhdWx0cyAmJiBOZW8uYXNzaWduRGVmYXVsdHMoY29sdW1uLCBjb2x1bW5EZWZhdWx0cyk7XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW4uZG9jayAmJiAhY29sdW1uLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKCdBdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIGRvY2tlZCBjb2x1bW4gd2l0aG91dCBhIGRlZmluZWQgd2lkdGgnLCBjb2x1bW4sIG1lLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyICYmIE5lby5pc1N0cmluZyhyZW5kZXJlcikgJiYgbWVbcmVuZGVyZXJdKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLnJlbmRlcmVyID0gbWVbcmVuZGVyZXJdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3J0ZXJzPy5bMF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmRhdGFGaWVsZCA9PT0gc29ydGVyc1swXS5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uaXNTb3J0ZWQgPSBzb3J0ZXJzWzBdLmRpcmVjdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sdW1uLmxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgICAgICBzb3J0IDogbWUub25Tb3J0Q29sdW1uLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5pdGVtc1swXS5pdGVtcyA9IGNvbHVtbnM7XG5cbiAgICAgICAgcmV0dXJuIGNvbHVtbnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXdEYXRhKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZpZXcuY3JlYXRlVmlld0RhdGEoKTtcblxuICAgICAgICBpZiAobWUudXNlQ3VzdG9tU2Nyb2xsYmFycyAmJiBtZS5zY3JvbGxiYXJzQ3NzQXBwbGllZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1lLmFwcGx5Q3VzdG9tU2Nyb2xsYmFyc0NzcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWZG9tUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX0gVGhlIG5ldyB2ZG9tIGl0ZW1zIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWZG9tSXRlbXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMge05lby52ZG9tLlZOb2RlfVxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGUuY2hpbGROb2Rlc1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0V3JhcHBlcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX3dyYXBwZXJgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5kaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5wcm9wZXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNvcnRDb2x1bW4ob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnN0b3JlLnNvcnQob3B0cyk7XG4gICAgICAgIG1lLnJlbW92ZVNvcnRpbmdDc3Mob3B0cy5wcm9wZXJ0eSk7XG4gICAgICAgIG1lLm9uU3RvcmVMb2FkKG1lLnN0b3JlLml0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25TdG9yZUZpbHRlcigpIHtcbiAgICAgICAgdGhpcy5vblN0b3JlTG9hZCh0aGlzLnN0b3JlLml0ZW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5yZW5kZXJlZCkge1xuICAgICAgICAgICAgbWUuY3JlYXRlVmlld0RhdGEoKTtcblxuICAgICAgICAgICAgaWYgKG1lLnN0b3JlLnNvcnRlcnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIG1lLnJlbW92ZVNvcnRpbmdDc3MoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUub24oJ3JlbmRlcmVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVWaWV3RGF0YSgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB3aGljaCBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG9wdHMubW9kZWwgVGhlIG1vZGVsIGluc3RhbmNlIG9mIHRoZSBjaGFuZ2VkIHJlY29yZFxuICAgICAqIEBwYXJhbSB7Kn0gb3B0cy5vbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnJlY29yZFxuICAgICAqIEBwYXJhbSB7Kn0gb3B0cy52YWx1ZVxuICAgICAqL1xuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2Uob3B0cykge1xuICAgICAgICB0aGlzLnZpZXcub25TdG9yZVJlY29yZENoYW5nZShvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlU29ydGluZ0NzcyhkYXRhRmllbGQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJUb29sYmFyLml0ZW1zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZGF0YUZpZWxkICE9PSBkYXRhRmllbGQpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4ucmVtb3ZlU29ydGluZ0NzcygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb250YWluZXIpO1xuIiwiaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBSb3dNb2RlbCAgICAgICAgZnJvbSAnLi4vc2VsZWN0aW9uL3RhYmxlL1Jvd01vZGVsLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFibGUuVmlld1xuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIFZpZXcgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYmxlLlZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50YWJsZS5WaWV3JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RhYmxlLXZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndGFibGUtdmlldycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10YWJsZS12aWV3J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRhYmxlLXZpZXcnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSB3aGljaCBtb2RlbCBmaWVsZCBjb250YWlucyB0aGUgdmFsdWUgb2YgY29sc3BhbiBkZWZpbml0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbHNwYW5GaWVsZD0nY29sc3BhbidcbiAgICAgICAgICovXG4gICAgICAgIGNvbHNwYW5GaWVsZDogJ2NvbHNwYW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbnRhaW5lcklkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWdobGlnaHRNb2RpZmllZENlbGxzXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlnaGxpZ2h0TW9kaWZpZWRDZWxsc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVjb3JkVm5vZGVNYXA9e31cbiAgICAgICAgICovXG4gICAgICAgIHJlY29yZFZub2RlTWFwOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5zZWxlY3Rpb24uTW9kZWx9IHNlbGVjdGlvbk1vZGVsXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Rpb25Nb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNlbGVjdGVkUmVjb3JkRmllbGQ9J2Fubm90YXRpb25zLnNlbGVjdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRSZWNvcmRGaWVsZDogJ2Fubm90YXRpb25zLnNlbGVjdGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLlN0b3JlfG51bGx9IHN0b3JlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlUm93UmVjb3JkSWRzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHVzZVJvd1JlY29yZElkczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb209e3RhZzogJ3Rib2R5JywgY24gOiBbXX1cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAndGJvZHknLCB0YWJJbmRleDogLTEsIGNuOiBbXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gc2VsZWN0ZWRSb3dzXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkUm93cygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZWwubnR5cGUgPT09ICdzZWxlY3Rpb24tdGFibGUtcm93bW9kZWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pdGVtc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tcbiAgICAgICAgICAgIGNsaWNrICAgOiBtZS5vbkNlbGxDbGljayxcbiAgICAgICAgICAgIGRibGNsaWNrOiBtZS5vbkNlbGxEb3VibGVDbGljayxcbiAgICAgICAgICAgIGRlbGVnYXRlOiAnLm5lby10YWJsZS1jZWxsJyxcbiAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjbGljayAgIDogbWUub25Sb3dDbGljayxcbiAgICAgICAgICAgIGRibGNsaWNrOiBtZS5vblJvd0RvdWJsZUNsaWNrLFxuICAgICAgICAgICAgZGVsZWdhdGU6ICcubmVvLXRhYmxlLXJvdycsXG4gICAgICAgICAgICBzY29wZSAgIDogbWVcbiAgICAgICAgfV0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVkICYmIHZhbHVlLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEuY2VsbElkXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLmNvbHVtblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmNvbHVtbkluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93SW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby50YWJsZS5Db250YWluZXJ9IGRhdGEudGFibGVDb250YWluZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFwcGx5UmVuZGVyZXJPdXRwdXQoZGF0YSkge1xuICAgICAgICBsZXQge2NlbGxJZCwgY29sdW1uLCBjb2x1bW5JbmRleCwgcmVjb3JkLCByb3dJbmRleCwgdGFibGVDb250YWluZXJ9ID0gZGF0YSxcbiAgICAgICAgICAgIG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNlbGxDbHMgICAgID0gWyduZW8tdGFibGUtY2VsbCddLFxuICAgICAgICAgICAgY29sc3BhbiAgICAgPSByZWNvcmRbbWUuY29sc3BhbkZpZWxkXSxcbiAgICAgICAgICAgIHtkYXRhRmllbGR9ID0gY29sdW1uLFxuICAgICAgICAgICAge21vZGVsfSAgICAgPSBtZS5zdG9yZSxcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgID0gcmVjb3JkW2RhdGFGaWVsZF0sXG4gICAgICAgICAgICBoYXNTdG9yZSAgICA9ICEhbW9kZWwsIC8vIHRvZG86IHJlbW92ZSBhcyBzb29uIGFzIGFsbCB0YWJsZXMgdXNlIHN0b3JlcyAoZXhhbXBsZXMgdGFibGUpXG4gICAgICAgICAgICB7dmRvbX0gICAgICA9IG1lLFxuICAgICAgICAgICAgY2VsbENvbmZpZywgcmVuZGVyZXJPdXRwdXQ7XG5cbiAgICAgICAgaWYgKCFtb2RlbD8uZ2V0RmllbGQoZGF0YUZpZWxkKSkge1xuICAgICAgICAgICAgbGV0IG5zQXJyYXkgICA9IGRhdGFGaWVsZC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IG5zQXJyYXkucG9wKCk7XG5cbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIHJlY29yZFtTeW1ib2wuZm9yKCdkYXRhJyldKT8uW2ZpZWxkTmFtZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSBudWxsIHx8IGZpZWxkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmllbGRWYWx1ZSA9ICcnXG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlck91dHB1dCA9IGNvbHVtbi5yZW5kZXJlci5jYWxsKGNvbHVtbi5yZW5kZXJlclNjb3BlIHx8IHRhYmxlQ29udGFpbmVyLCB7XG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGRhdGFGaWVsZCxcbiAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgIHJvd0luZGV4LFxuICAgICAgICAgICAgdGFibGVDb250YWluZXIsXG4gICAgICAgICAgICB2YWx1ZTogZmllbGRWYWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBzd2l0Y2ggKE5lby50eXBlT2YocmVuZGVyZXJPdXRwdXQpKSB7XG4gICAgICAgICAgICBjYXNlICdPYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVyT3V0cHV0Lmh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJPdXRwdXQuY2xzICYmIGNlbGxDbHMucHVzaCguLi5yZW5kZXJlck91dHB1dC5jbHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyT3V0cHV0ID0gW3JlbmRlcmVyT3V0cHV0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ1N0cmluZyc6IHtcbiAgICAgICAgICAgICAgICByZW5kZXJlck91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2xzIDogY2VsbENscyxcbiAgICAgICAgICAgICAgICAgICAgaHRtbDogcmVuZGVyZXJPdXRwdXQ/LnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyZXJPdXRwdXQgPT09IG51bGwgfHwgcmVuZGVyZXJPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVuZGVyZXJPdXRwdXQgPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHVtbi5jZWxsQWxpZ24gIT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgY2VsbENscy5wdXNoKCduZW8tJyArIGNvbHVtbi5jZWxsQWxpZ24pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaGlnaGxpZ2h0TW9kaWZpZWRDZWxscykge1xuICAgICAgICAgICAgaWYgKHJlY29yZC5pc01vZGlmaWVkRmllbGQoZGF0YUZpZWxkKSkge1xuICAgICAgICAgICAgICAgIGNlbGxDbHMucHVzaCgnbmVvLWlzLW1vZGlmaWVkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2VsbElkKSB7XG4gICAgICAgICAgICAvLyB0b2RvOiByZW1vdmUgdGhlIGVsc2UgcGFydCBhcyBzb29uIGFzIGFsbCB0YWJsZXMgdXNlIHN0b3JlcyAoZXhhbXBsZXMgdGFibGUpXG4gICAgICAgICAgICBpZiAoaGFzU3RvcmUpIHtcbiAgICAgICAgICAgICAgICBjZWxsSWQgPSBtZS5nZXRDZWxsSWQocmVjb3JkLCBjb2x1bW4uZGF0YUZpZWxkKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxsSWQgPSB2ZG9tLmNuW3Jvd0luZGV4XT8uY25bbWUuZ2V0Q29sdW1uKGNvbHVtbi5kYXRhRmllbGQsIHRydWUpXT8uaWQgfHwgTmVvLmdldElkKCd0ZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjZWxsQ29uZmlnID0ge1xuICAgICAgICAgICAgdGFnICA6ICd0ZCcsXG4gICAgICAgICAgICBpZCAgIDogY2VsbElkLFxuICAgICAgICAgICAgY2xzICA6IGNlbGxDbHMsXG4gICAgICAgICAgICBzdHlsZTogcmVuZGVyZXJPdXRwdXQuc3R5bGUgfHwge31cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29sc3BhbiAmJiBPYmplY3Qua2V5cyhjb2xzcGFuKS5pbmNsdWRlcyhkYXRhRmllbGQpKSB7XG4gICAgICAgICAgICBjZWxsQ29uZmlnLmNvbHNwYW4gPSBjb2xzcGFuW2RhdGFGaWVsZF1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8udHlwZU9mKHJlbmRlcmVyT3V0cHV0KSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIGNlbGxDb25maWcuaW5uZXJIVE1MID0gcmVuZGVyZXJPdXRwdXQuaHRtbCAgfHwgJydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxDb25maWcuY24gPSByZW5kZXJlck91dHB1dFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGxDb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFJvd01vZGVsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnJvd0luZGV4XVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlUm93KHtyZWNvcmQsIHJvd0luZGV4fSkge1xuICAgICAgICBpZiAoIU5lby5pc051bWJlcihyb3dJbmRleCkpIHtcbiAgICAgICAgICAgIHJvd0luZGV4ID0gdGhpcy5zdG9yZS5pbmRleE9mKHJlY29yZClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdGFibGVDb250YWluZXIgID0gbWUucGFyZW50LFxuICAgICAgICAgICAgY29sc3BhbiAgICAgICAgID0gcmVjb3JkW21lLmNvbHNwYW5GaWVsZF0sXG4gICAgICAgICAgICBjb2xzcGFuS2V5cyAgICAgPSBjb2xzcGFuICYmIE9iamVjdC5rZXlzKGNvbHNwYW4pLFxuICAgICAgICAgICAgY29sdW1ucyAgICAgICAgID0gdGFibGVDb250YWluZXIuaXRlbXNbMF0uaXRlbXMsXG4gICAgICAgICAgICBjb2xDb3VudCAgICAgICAgPSBjb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgICAgIGRvY2tMZWZ0TWFyZ2luICA9IDAsXG4gICAgICAgICAgICBkb2NrUmlnaHRNYXJnaW4gPSAwLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgID0gbWUuZ2V0Um93SWQocmVjb3JkLCByb3dJbmRleCksXG4gICAgICAgICAgICB7c2VsZWN0ZWRSb3dzfSAgPSBtZSxcbiAgICAgICAgICAgIHRyQ2xzICAgICAgICAgICA9IG1lLmdldFRyQ2xhc3MocmVjb3JkLCByb3dJbmRleCksXG4gICAgICAgICAgICBjb25maWcsIGNvbHVtbiwgY29sdW1uSW5kZXgsIGksIHRhYmxlUm93O1xuXG4gICAgICAgIG1lLnJlY29yZFZub2RlTWFwW2lkXSA9IHJvd0luZGV4O1xuXG4gICAgICAgIGlmIChzZWxlY3RlZFJvd3MgJiYgcmVjb3JkW21lLnNlbGVjdGVkUmVjb3JkRmllbGRdKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoc2VsZWN0ZWRSb3dzLCBpZClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZFJvd3M/LmluY2x1ZGVzKGlkKSkge1xuICAgICAgICAgICAgdHJDbHMucHVzaCgnbmVvLXNlbGVjdGVkJyk7XG5cbiAgICAgICAgICAgIG1lLnBhcmVudC5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgcmVjb3JkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGFibGVSb3cgPSB7XG4gICAgICAgICAgICB0YWc6ICd0cicsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNsczogdHJDbHMsXG4gICAgICAgICAgICBjbiA6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChpPTA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgICAgICAgY29uZmlnID0gbWUuYXBwbHlSZW5kZXJlck91dHB1dCh7Y29sdW1uLCBjb2x1bW5JbmRleDogaSwgcmVjb3JkLCByb3dJbmRleCwgdGFibGVDb250YWluZXJ9KTtcblxuICAgICAgICAgICAgaWYgKGNvbHVtbi5kb2NrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNscyA9IFsnbmVvLWxvY2tlZCcsIC4uLmNvbmZpZy5jbHMgfHwgW11dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5kb2NrID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0eWxlLmxlZnQgPSBkb2NrTGVmdE1hcmdpbiArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGRvY2tMZWZ0TWFyZ2luICs9IChjb2x1bW4ud2lkdGggKyAxKSAvLyB0b2RvOiBib3JkZXJzIGZpeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbHVtbi5mbGV4KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhYmxlUm93LmNuLnB1c2goY29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKGNvbHNwYW5LZXlzPy5pbmNsdWRlcyhjb2x1bW4uZGF0YUZpZWxkKSkge1xuICAgICAgICAgICAgICAgIGkgKz0gKGNvbHNwYW5bY29sdW1uLmRhdGFGaWVsZF0gLSAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpPTA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCA9IGNvbENvdW50IC0gaSAtMTtcbiAgICAgICAgICAgIGNvbHVtbiAgICAgID0gY29sdW1uc1tjb2x1bW5JbmRleF07XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW4uZG9jayA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIHRhYmxlUm93LmNuW2NvbHVtbkluZGV4XS5zdHlsZS5yaWdodCA9IGRvY2tSaWdodE1hcmdpbiArICdweCc7XG4gICAgICAgICAgICAgICAgZG9ja1JpZ2h0TWFyZ2luICs9IChjb2x1bW4ud2lkdGggKyAxKSAvLyB0b2RvOiBib3JkZXJzIGZpeFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sc3BhbktleXM/LmluY2x1ZGVzKGNvbHVtbi5kYXRhRmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaSArPSAoY29sc3Bhbltjb2x1bW4uZGF0YUZpZWxkXSAtIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZG9jayBtYXJnaW5zIGFyZSB0aGUgc2FtZSBmb3IgZWFjaCByb3dcbiAgICAgICAgcm93SW5kZXggPT09IDAgJiYgT2JqZWN0LmFzc2lnbih0YWJsZUNvbnRhaW5lciwge2RvY2tMZWZ0TWFyZ2luLCBkb2NrUmlnaHRNYXJnaW59KTtcblxuICAgICAgICByZXR1cm4gdGFibGVSb3dcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXdEYXRhKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzZWxlY3RlZFJvd3MsIHN0b3JlfSA9IG1lLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzICAgICAgICAgID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICByb3dzICAgICAgICAgICAgICAgICAgPSBbXTtcblxuICAgICAgICBmb3IgKDsgaSA8IGNvdW50UmVjb3JkczsgaSsrKSB7XG4gICAgICAgICAgICByb3dzLnB1c2gobWUuY3JlYXRlUm93KHtyZWNvcmQ6IHN0b3JlLml0ZW1zW2ldLCByb3dJbmRleDogaX0pKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudmRvbS5jbiA9IHJvd3M7XG5cbiAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkUm93cz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbG9naWMgb25seSB3b3JrcyBmb3Igc2VsZWN0aW9uLnRhYmxlLlJvd01vZGVsXG4gICAgICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbFRvVGFibGVSb3coe2FwcE5hbWU6IG1lLmFwcE5hbWUsIGlkOiBzZWxlY3RlZFJvd3NbMF19KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBudWxsO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICovXG4gICAgZmlyZUNlbGxFdmVudChkYXRhLCBldmVudE5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICAgPSBkYXRhLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICBkYXRhRmllbGQgPSBtZS5nZXRDZWxsRGF0YUZpZWxkKGlkKSxcbiAgICAgICAgICAgIHJlY29yZCAgICA9IG1lLmdldFJlY29yZChpZCk7XG5cbiAgICAgICAgbWUucGFyZW50LmZpcmUoZXZlbnROYW1lLCB7ZGF0YSwgZGF0YUZpZWxkLCByZWNvcmQsIHZpZXc6IG1lfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKi9cbiAgICBmaXJlUm93RXZlbnQoZGF0YSwgZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICAgID0gZGF0YS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgcmVjb3JkID0gbWUuZ2V0UmVjb3JkKGlkKTtcblxuICAgICAgICBtZS5wYXJlbnQuZmlyZShldmVudE5hbWUsIHtkYXRhLCByZWNvcmQsIHZpZXc6IG1lfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2VsbElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDZWxsRGF0YUZpZWxkKGNlbGxJZCkge1xuICAgICAgICByZXR1cm4gY2VsbElkLnNwbGl0KCdfXycpWzJdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENlbGxJZChyZWNvcmQsIGRhdGFGaWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCArICdfXycgKyByZWNvcmRbdGhpcy5zdG9yZS5rZXlQcm9wZXJ0eV0gKyAnX18nICsgZGF0YUZpZWxkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgdGFibGUgY29sdW1uIG9yIGNvbHVtbiBpbmRleCBieSBhIGdpdmVuIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkluZGV4PWZhbHNlXG4gICAgICogQHJldHVybnMge09iamVjdHxOdW1iZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW4oZmllbGQsIHJldHVybkluZGV4PWZhbHNlKSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgICAgIGNvbHVtbnMgICA9IGNvbnRhaW5lci5oZWFkZXJUb29sYmFyLml0ZW1zLFxuICAgICAgICAgICAgaSAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICA9IGNvbHVtbnMubGVuZ3RoLFxuICAgICAgICAgICAgY29sdW1uO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaV07XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW4uZGF0YUZpZWxkID09PSBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5JbmRleCA/IGkgOiBjb2x1bW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNlbGxJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0RGF0YUZpZWxkKGNlbGxJZCkge1xuICAgICAgICByZXR1cm4gY2VsbElkLnNwbGl0KCdfXycpWzJdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtYXRjaGluZyByZWNvcmQgYnkgcGFzc2luZyBhIHJvdyBpZCwgYSBjZWxsIGlkIG9yIGFuIGlkIGluc2lkZSBhIHRhYmxlIGNlbGwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRSZWNvcmQobm9kZUlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUuZ2V0UmVjb3JkQnlSb3dJZChub2RlSWQpLFxuICAgICAgICAgICAgbm9kZSwgcGFyZW50Tm9kZXM7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE5vZGVzID0gVkRvbVV0aWwuZ2V0UGFyZW50Tm9kZXMobWUudmRvbSwgbm9kZUlkKTtcblxuICAgICAgICBmb3IgKG5vZGUgb2YgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIHJlY29yZCA9IG1lLmdldFJlY29yZEJ5Um93SWQobm9kZS5pZCk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb3dJZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0UmVjb3JkQnlSb3dJZChyb3dJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRBdCh0aGlzLnJlY29yZFZub2RlTWFwW3Jvd0lkXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFJvd0lkKHJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3N0b3JlfSA9IG1lO1xuXG4gICAgICAgIGlmIChtZS51c2VSb3dSZWNvcmRJZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHttZS5pZH1fX3RyX18ke3JlY29yZFtzdG9yZS5rZXlQcm9wZXJ0eV19YFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSBOZW8uaXNOdW1iZXIoaW5kZXgpID8gaW5kZXggOiBzdG9yZS5pbmRleE9mKHJlY29yZCk7XG4gICAgICAgICAgICByZXR1cm4gbWUudmRvbS5jbltpbmRleF0/LmlkIHx8IE5lby5nZXRJZCgndHInKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY3VzdG9tIENTUyBydWxlcyB0byB0YWJsZSByb3dzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3dJbmRleFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRUckNsYXNzKHJlY29yZCwgcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFsnbmVvLXRhYmxlLXJvdyddXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNlbGxDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZUNlbGxFdmVudChkYXRhLCAnY2VsbENsaWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2VsbERvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlQ2VsbEV2ZW50KGRhdGEsICdjZWxsRG91YmxlQ2xpY2snKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsPy5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3dDbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZVJvd0V2ZW50KGRhdGEsICdyb3dDbGljaycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJvd0RvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlUm93RXZlbnQoZGF0YSwgJ3Jvd0RvdWJsZUNsaWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdHMuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBvcHRzLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZWNvcmRcbiAgICAgKi9cbiAgICBvblN0b3JlUmVjb3JkQ2hhbmdlKHtmaWVsZHMsIG1vZGVsLCByZWNvcmR9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpZWxkTmFtZXMgICAgICAgICAgICAgPSBmaWVsZHMubWFwKGZpZWxkID0+IGZpZWxkLm5hbWUpLFxuICAgICAgICAgICAgbmVlZHNVcGRhdGUgICAgICAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdGFibGVDb250YWluZXIgICAgICAgICA9IG1lLnBhcmVudCxcbiAgICAgICAgICAgIHJvd0luZGV4ICAgICAgICAgICAgICAgPSBtZS5zdG9yZS5pbmRleE9mKHJlY29yZCksXG4gICAgICAgICAgICB7c2VsZWN0aW9uTW9kZWwsIHZkb219ID0gbWUsXG4gICAgICAgICAgICBjZWxsSWQsIGNlbGxOb2RlLCBjZWxsVmRvbSwgY29sdW1uLCBjb2x1bW5JbmRleCwgc2NvcGU7XG5cbiAgICAgICAgaWYgKGZpZWxkTmFtZXMuaW5jbHVkZXMobWUuY29sc3BhbkZpZWxkKSkge1xuICAgICAgICAgICAgbWUudmRvbS5jbltyb3dJbmRleF0gPSBtZS5jcmVhdGVSb3coe3JlY29yZCwgcm93SW5kZXh9KTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IG1lLnNlbGVjdGVkUmVjb3JkRmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLm50eXBlID09PSAnc2VsZWN0aW9uLXRhYmxlLXJvd21vZGVsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWxbZmllbGQudmFsdWUgPyAnc2VsZWN0JyA6ICdkZXNlbGVjdCddKG1lLmdldFJvd0lkKHJlY29yZCkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjZWxsSWQgICA9IG1lLmdldENlbGxJZChyZWNvcmQsIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsTm9kZSA9IFZEb21VdGlsLmZpbmQodmRvbSwgY2VsbElkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmRvbSBtaWdodCBub3QgZXhpc3QgeWV0ID0+IG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTm9kZT8udmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uICAgICAgPSBtZS5nZXRDb2x1bW4oZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IGNlbGxOb2RlLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgICAgICAgPSBjb2x1bW4ucmVuZGVyZXJTY29wZSB8fCB0YWJsZUNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWZG9tICAgID0gbWUuYXBwbHlSZW5kZXJlck91dHB1dCh7Y2VsbElkLCBjb2x1bW4sIGNvbHVtbkluZGV4LCByZWNvcmQsIHJvd0luZGV4LCB0YWJsZUNvbnRhaW5lcn0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsTm9kZS5wYXJlbnROb2RlLmNuW2NvbHVtbkluZGV4XSA9IGNlbGxWZG9tXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmVlZHNVcGRhdGUgJiYgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXcpO1xuIiwiaW1wb3J0IEJhc2VCdXR0b24gICAgICAgIGZyb20gJy4uLy4uL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCAgICAgICAgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvVGV4dC5tanMnO1xuaW1wb3J0IHtyZXNvbHZlQ2FsbGJhY2t9IGZyb20gJy4uLy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRhYmxlLmhlYWRlci5CdXR0b25cbiAqIEBleHRlbmRzIE5lby5idXR0b24uQmFzZVxuICovXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQnV0dG9uIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGFsaWduXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGNlbGxBbGlnblZhbHVlczogWydsZWZ0JywnY2VudGVyJywncmlnaHQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGNlbGxBbGlnblZhbHVlcyA9IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udGFibGUuaGVhZGVyLkJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYmxlLmhlYWRlci5CdXR0b24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndGFibGUtaGVhZGVyLWJ1dHRvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0YWJsZS1oZWFkZXItYnV0dG9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRhYmxlLWhlYWRlci1idXR0b24nXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdGFibGUtaGVhZGVyLWJ1dHRvbiddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpZ25tZW50IG9mIHRoZSBtYXRjaGluZyB0YWJsZSBjZWxscy4gVmFsaWQgdmFsdWVzIGFyZSBsZWZ0LCBjZW50ZXIsIHJpZ2h0XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2VsbEFsaWduXz0nbGVmdCdcbiAgICAgICAgICovXG4gICAgICAgIGNlbGxBbGlnbl86ICdsZWZ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBkYXRhRmllbGQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YUZpZWxkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU29ydCBkaXJlY3Rpb24gd2hlbiBjbGlja2luZyBvbiBhbiB1bnNvcnRlZCBidXR0b25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkZWZhdWx0U29ydERpcmVjdGlvbj0nQVNDJ1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFNvcnREaXJlY3Rpb246ICdBU0MnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ2dhYmxlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBlZGl0b3JDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdG9yQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBmaWx0ZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmZvcm0uZmllbGQuQmFzZXxudWxsfSBmaWx0ZXJGaWVsZD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlckZpZWxkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpY29uQ2xzPSdmYSBmYS1hcnJvdy1jaXJjbGUtdXAnXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiAnZmEgZmEtYXJyb3ctY2lyY2xlLXVwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaWNvblBvc2l0aW9uPSdyaWdodCdcbiAgICAgICAgICovXG4gICAgICAgIGljb25Qb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqICdBU0MnLCAnREVTQycgb3IgbnVsbFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaXNTb3J0ZWRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNTb3J0ZWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb258U3RyaW5nfG51bGx9IHJlbmRlcmVyXz0nY2VsbFJlbmRlcmVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXJfOiAnY2VsbFJlbmRlcmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjb3BlIHRvIGV4ZWN1dGUgdGhlIGNvbHVtbiByZW5kZXJlci5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gdGhlIG1hdGNoaW5nIHRhYmxlLkNvbnRhaW5lclxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5CYXNlfG51bGx9IHJlbmRlcmVyU2NvcGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXJTY29wZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dIZWFkZXJGaWx0ZXJfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SGVhZGVyRmlsdGVyXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzb3J0YWJsZV89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICd0aCcsIGNuOiBbXG4gICAgICAgICAgICB7dGFnOiAnYnV0dG9uJywgY246IFtcbiAgICAgICAgICAgICAgICB7dGFnOiAnc3BhbicsIGNsczogWyduZW8tYnV0dG9uLWdseXBoJ119LFxuICAgICAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1idXR0b24tdGV4dCddfSxcbiAgICAgICAgICAgICAgICB7dGFnOiAnc3BhbicsIGNsczogWyduZW8tYnV0dG9uLWJhZGdlJ119LFxuICAgICAgICAgICAgICAgIHt0YWc6ICdzcGFuJywgY2xzOiBbJ25lby1idXR0b24tcmlwcGxlLXdyYXBwZXInXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge3RhZzogJ3NwYW4nLCBjbHM6IFsnbmVvLWJ1dHRvbi1yaXBwbGUnXX1cbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlzU29ydGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1NvcnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgPSBtZSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG1lLnVwKCd0YWJsZS1jb250YWluZXInKTtcblxuICAgICAgICBzd2l0Y2godmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FTQyc6XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWRlc2MnKTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1zb3J0LWFzYycpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdERVNDJzpcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLXNvcnQtYXNjJyk7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1kZXNjJyk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNscyA9IGNscztcblxuICAgICAgICAvLyB0ZXN0aW5nIGNoZWNrIHVudGlsIGFsbCBleGFtcGxlIHRhYmxlcyBoYXZlIGEgc3RvcmVcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5zdG9yZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5tb3VudGVkICYmIG1lLmZpcmUoJ3NvcnQnLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IHZhbHVlLFxuICAgICAgICAgICAgcHJvcGVydHkgOiBtZS5kYXRhRmllbGRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNob3dIZWFkZXJGaWx0ZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93SGVhZGVyRmlsdGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFtZS5maWx0ZXJGaWVsZCkge1xuICAgICAgICAgICAgICAgIG1lLmZpbHRlckZpZWxkID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgICAgIDogJ2ZpbHRlci1maWVsZCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgICAgOiB7bWFyZ2luTGVmdDogJy41ZW0nLCBtYXJnaW5SaWdodDogJy41ZW0nfSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQgOiBtZS53aW5kb3dJZCxcblxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSAgICAgICAgOiBtZS5jaGFuZ2VGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yQ2hhbmdlOiBtZS5jaGFuZ2VGaWx0ZXJPcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlICAgICAgICAgOiBtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmVkaXRvckNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUudmRvbS5jbi5wdXNoKG1lLmZpbHRlckZpZWxkLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lLmZpbHRlckZpZWxkLnZkb20ucmVtb3ZlRG9tXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWUuZmlsdGVyRmllbGQpIHtcbiAgICAgICAgICAgIG1lLmZpbHRlckZpZWxkLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlRGVwdGggPSAyO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuXG4gICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgIGNsaWNrOiBtZS5vbkJ1dHRvbkNsaWNrLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tc29ydC1oaWRkZW4nKTtcblxuICAgICAgICAgICAgbWUucmVtb3ZlRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgICAgICBjbGljazogbWUub25CdXR0b25DbGljayxcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2VsbEFsaWduIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2VsbEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnY2VsbEFsaWduJywgJ2NlbGxBbGlnblZhbHVlcycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcmVuZGVyZXIgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UmVuZGVyZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQ2FsbGJhY2sodmFsdWUsIHRoaXMpLmZuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uYnV0dG9uLkJhc2V9ICAgICBkYXRhLmNvbHVtblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgZGF0YS5jb2x1bW5JbmRleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgZGF0YS5kYXRhRmllbGRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBkYXRhLnJvd0luZGV4XG4gICAgICogQHBhcmFtIHtOZW8udGFibGUuQ29udGFpbmVyfSBkYXRhLnRhYmxlQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSAgICAgICBkYXRhLnZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY2VsbFJlbmRlcmVyKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEudmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNoYW5nZUZpbHRlck9wZXJhdG9yKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRhYmxlQ29udGFpbmVyID0gbWUudXAoJ3RhYmxlLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICAgPSB0YWJsZUNvbnRhaW5lcj8uc3RvcmUsXG4gICAgICAgICAgICBvcGVyYXRvciAgICAgICA9IGRhdGEudmFsdWUsXG4gICAgICAgICAgICBmaWx0ZXIsIGZpbHRlcnM7XG5cbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzID0gc3RvcmUuZmlsdGVycztcblxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtZS5kYXRhRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuZmlsdGVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdG9yZS5maWx0ZXJzID0gZmlsdGVyc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIub3BlcmF0b3IgPSBvcGVyYXRvclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBjaGFuZ2VGaWx0ZXJWYWx1ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0YWJsZUNvbnRhaW5lciA9IG1lLnVwKCd0YWJsZS1jb250YWluZXInKSxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICAgID0gdGFibGVDb250YWluZXI/LnN0b3JlLFxuICAgICAgICAgICAge3ZhbHVlfSAgICAgICAgPSBkYXRhLFxuICAgICAgICAgICAgZmllbGQsIGZpbHRlciwgZmlsdGVycywgbW9kZWw7XG5cbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGF0YUZpZWxkKTtcbiAgICAgICAgICAgIG1vZGVsICA9IHN0b3JlLm1vZGVsO1xuICAgICAgICAgICAgZmllbGQgID0gbW9kZWwgJiYgbW9kZWwuZ2V0RmllbGQobWUuZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIGZpZWxkLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE5lby5pc1JlY29yZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW21lLmZpbHRlckZpZWxkLmRpc3BsYXlGaWVsZF1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzID0gc3RvcmUuZmlsdGVycztcblxuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtZS5kYXRhRmllbGQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnbGlrZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5maWx0ZXJDb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHN0b3JlLmZpbHRlcnMgPSBmaWx0ZXJzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlci52YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLmZpbHRlckZpZWxkPy5kZXN0cm95KCk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdmRvbSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWbm9kZVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZkb20gcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2bm9kZSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWZG9tUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdm5vZGUgcm9vdFxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGUuY2hpbGROb2Rlc1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkJ1dHRvbkNsaWNrKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbWFwO1xuXG4gICAgICAgIGlmIChtZS5kZWZhdWx0U29ydERpcmVjdGlvbiA9PT0gJ0RFU0MnKSB7XG4gICAgICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICAgICAgQVNDIDogbnVsbCxcbiAgICAgICAgICAgICAgICBERVNDOiAnQVNDJyxcbiAgICAgICAgICAgICAgICBudWxsOiAnREVTQydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgICAgICBBU0MgOiAnREVTQycsXG4gICAgICAgICAgICAgICAgREVTQzogbnVsbCxcbiAgICAgICAgICAgICAgICBudWxsOiAnQVNDJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNTb3J0ZWQgPSBtYXBbbWUuaXNTb3J0ZWQgKyAnJ11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlU29ydGluZ0NzcygpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1zb3J0LWhpZGRlbicpO1xuXG4gICAgICAgIG1lLmNscyAgICAgICA9IGNscztcbiAgICAgICAgbWUuX2lzU29ydGVkID0gbnVsbFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQnV0dG9uKTtcbiIsImltcG9ydCBCYXNlVG9vbGJhciBmcm9tICcuLi8uLi90b29sYmFyL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRhYmxlLmhlYWRlci5Ub29sYmFyXG4gKiBAZXh0ZW5kcyBOZW8udG9vbGJhci5CYXNlXG4gKi9cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlVG9vbGJhciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udGFibGUuaGVhZGVyLlRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50YWJsZS5oZWFkZXIuVG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0YWJsZS1oZWFkZXItdG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0YWJsZS1oZWFkZXItdG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10YWJsZS1oZWFkZXItdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10YWJsZS1oZWFkZXItdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ2dhYmxlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsYXlvdXQ9J2Jhc2UnXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6ICdiYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtudHlwZSA6ICd0YWJsZS1oZWFkZXItYnV0dG9uJ31cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGU6ICd0YWJsZS1oZWFkZXItYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0hlYWRlckZpbHRlcnNfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SGVhZGVyRmlsdGVyc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gcGFzcyBzb3J0YWJsZSB0byBhbGwgdG9vbGJhciBpdGVtcy5cbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIGhlYWRlciBjbGlja3Mgd2lsbCBzb3J0IHRoZSBtYXRjaGluZyBjb2x1bW4gKEFTQywgREVTQywgbnVsbClcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc29ydGFibGU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt0YWc6J3RoZWFkJyxjbjpbe3RhZzondHInLGNuOltdfV19XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ3RoZWFkJywgY246IFtcbiAgICAgICAgICAgIHt0YWc6ICd0cicsIGNuOiBbXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyYWdnYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLnNvcnRab25lKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL2RyYWdnYWJsZS90YWJsZS9oZWFkZXIvdG9vbGJhci9Tb3J0Wm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgICAgICAgICBtZS5zb3J0Wm9uZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuc29ydFpvbmVDb25maWdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0hlYWRlckZpbHRlcnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93SGVhZGVyRmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRTaWxlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzaG93SGVhZGVyRmlsdGVyOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUudXBkYXRlRGVwdGggPSAtMTsgLy8gZmlsdGVycyBjYW4gYmUgZGVlcGx5IG5lc3RlZFxuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2lsZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGFibGU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVEZXB0aCA9IDI7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pdGVtRGVmYXVsdHMuc2hvd0hlYWRlckZpbHRlciA9IG1lLnNob3dIZWFkZXJGaWx0ZXJzO1xuXG4gICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oaXRlbSwgJ3NvcnRhYmxlJykpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNvcnRhYmxlID0gbWUuc29ydGFibGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKTtcblxuICAgICAgICBsZXQgZG9ja0xlZnRXaWR0aCAgPSAwLFxuICAgICAgICAgICAgZG9ja1JpZ2h0V2lkdGggPSAwLFxuICAgICAgICAgICAge2l0ZW1zfSAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgc3R5bGU7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHN0eWxlID0gaXRlbS53cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgIC8vIHRvZG86IG9ubHkgYWRkIHB4IGlmIG51bWJlclxuICAgICAgICAgICAgaWYgKGl0ZW0ubWF4V2lkdGgpIHtzdHlsZS5tYXhXaWR0aCA9IGl0ZW0ubWF4V2lkdGggKyAncHgnfVxuICAgICAgICAgICAgaWYgKGl0ZW0ubWluV2lkdGgpIHtzdHlsZS5taW5XaWR0aCA9IGl0ZW0ubWluV2lkdGggKyAncHgnfVxuICAgICAgICAgICAgaWYgKGl0ZW0ud2lkdGgpICAgIHtzdHlsZS53aWR0aCAgICA9IGl0ZW0ud2lkdGggICAgKyAncHgnfVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5kb2NrKSB7XG4gICAgICAgICAgICAgICAgaXRlbS52ZG9tLmNscyA9IFsnbmVvLWxvY2tlZCddO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZG9jayA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBkb2NrTGVmdFdpZHRoICsgJ3B4J1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvY2tMZWZ0V2lkdGggKz0gKGl0ZW0ud2lkdGggKyAxKSAvLyB0b2RvOiBib3JkZXJzIGZpeFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLnZkb20uY2xzID0gW10gLy8gcmVtb3ZlIHRoZSBidXR0b24gY2xzIGZyb20gdGhlIHRoIHRhZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgICAgICAvLyBpbnZlcnNlIGxvb3AgZGlyZWN0aW9uXG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbbGVuIC0gaW5kZXggLTFdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5kb2NrID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZTtcbiAgICAgICAgICAgICAgICBzdHlsZS5yaWdodCA9IGRvY2tSaWdodFdpZHRoICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gc3R5bGU7XG5cbiAgICAgICAgICAgICAgICBkb2NrUmlnaHRXaWR0aCArPSAoaXRlbS53aWR0aCArIDEpIC8vIHRvZG86IGJvcmRlcnMgZml4XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWVsZFxuICAgICAqIEByZXR1cm5zIHtOZW8uYnV0dG9uLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW4oZGF0YUZpZWxkKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kYXRhRmllbGQgPT09IGRhdGFGaWVsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkb2NrXG4gICAgICogQHJldHVybnMge1N0cmluZ30gbGF5b3V0Q29uZmlnXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZ2V0TGF5b3V0Q29uZmlnKGRvY2spIHtcbiAgICAgICAgcmV0dXJuICdiYXNlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdmRvbSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWbm9kZVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZkb20gcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2bm9kZSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWZG9tUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdm5vZGUgcm9vdFxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGUuY2hpbGROb2Rlc1swXVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVG9vbGJhcik7XG4iLCJpbXBvcnQgQnV0dG9uICBmcm9tICcuL0J1dHRvbi5tanMnO1xuaW1wb3J0IFRvb2xiYXIgZnJvbSAnLi9Ub29sYmFyLm1qcyc7XG5cbmV4cG9ydCB7QnV0dG9uLCBUb29sYmFyfTsiLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuQ3NzXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIENzcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuQ3NzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5Dc3MnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzcyB0aGUgc2VsZWN0b3JUZXh0IG9mIHRoZSBydWxlcyB3aGljaCB5b3Ugd2FudCB0byByZW1vdmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2luZG93SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gcnVsZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlUnVsZXMod2luZG93SWQsIHJ1bGVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShydWxlcykpIHtcbiAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzXVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldC5kZWxldGVDc3NSdWxlcyh7cnVsZXMsIHdpbmRvd0lkfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2luZG93SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gcnVsZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zZXJ0UnVsZXMod2luZG93SWQsIHJ1bGVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShydWxlcykpIHtcbiAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzXVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uU3R5bGVzaGVldC5pbnNlcnRDc3NSdWxlcyh7cnVsZXMsIHdpbmRvd0lkfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENzcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=