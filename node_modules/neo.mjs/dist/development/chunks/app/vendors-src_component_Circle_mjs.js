export const __webpack_esm_id__ = "vendors-src_component_Circle_mjs";
export const __webpack_esm_ids__ = ["vendors-src_component_Circle_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/component/Circle.mjs"
/*!**********************************!*\
  !*** ./src/component/Circle.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _selection_CircleModel_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selection/CircleModel.mjs */ "./src/selection/CircleModel.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







let DragZone;

/**
 * @summary A highly interactive circular component for displaying and arranging items in a radial layout.
 *
 * This component renders a central circle that can be expanded or collapsed on mouse interaction. When expanded,
 * it reveals a series of items arranged in an outer circle. The component is flippable, showing a backside
 * with additional actions. Items within the circle are draggable.
 *
 * This class is a sophisticated example of leveraging the framework's VDOM manipulation for complex animations
 * and interactions. It demonstrates concepts like dynamic styling, event handling for custom drag-and-drop,
 * and managing a collection of items within a non-standard layout.
 *
 * @class Neo.component.Circle
 * @extends Neo.component.Base
 */
class Circle extends _Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Circle'
         * @protected
         */
        className: 'Neo.component.Circle',
        /**
         * @member {String} ntype='circle'
         * @protected
         */
        ntype: 'circle',
        /**
         * Will get set inside the ctor to avoid issues inside the webpack builds
         * @member {String|null} backsideIconPath=Neo.config.resourcesPath + 'images/circle/'
         */
        backsideIconPath: null,
        /**
         * @member {String[]} baseCls=['neo-circle-component']
         */
        baseCls: ['neo-circle-component'],
        /**
         * @member {Boolean} circleCenterHasTransitionCls=true
         * @protected
         */
        circleCenterHasTransitionCls: true,
        /**
         * @member {Boolean} collapsed=true
         */
        collapsed: true,
        /**
         * @member {Boolean} draggable_=true
         * @reactive
         */
        draggable_: true,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys={}
         * @reactive
         */
        keys: {},
        /**
         * @member {Number} innerRadius_=100
         * @reactive
         */
        innerRadius_: 100,
        /**
         * @member {Boolean} isFlipped=false
         */
        isFlipped: false,
        /**
         * Will get set inside the ctor to avoid issues inside the webpack builds
         * @member {String} itemImagePath=Neo.config.resourcesPath + 'examples/images/'
         */
        itemImagePath: null,
        /**
         * @member {Number} itemSize_=60
         * @reactive
         */
        itemSize_: 60,
        /**
         * @member {Number} maxItems_=12
         * @reactive
         */
        maxItems_: 12,
        /**
         * The amount in px which the outerRadius is bigger than the innerRadius
         * @member {Number} outerRadiusDelta_=10
         * @reactive
         */
        outerRadiusDelta_: 10,
        /**
         * @member {Number} rotateX_=0
         * @reactive
         */
        rotateX_: 0,
        /**
         * @member {Number} rotateY_=0
         * @reactive
         */
        rotateY_: 0,
        /**
         * @member {Number} rotateZ_=0
         * @reactive
         */
        rotateZ_: 0,
        /**
         * @member {Number} rotationIndex_=0
         * @reactive
         */
        rotationIndex_: 0,
        /**
         * @member {Neo.selection.Model|null} selectionModel_=null
         * @reactive
         */
        selectionModel_: null,
        /**
         * @member {Neo.collection.Base|null} store_=null
         * @reactive
         */
        store_: null,
        /**
         * @member {String} title_='Circle 1'
         * @reactive
         */
        title_: 'Circle 1',
        /**
         * The url for the store to load the data
         * @member {String} url_='../resources/examples/data/circles/group1.json'
         * @reactive
         */
        url_: '../../resources/examples/data/circles/group1.json',
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tabIndex: -1, cn: [
            {cls: ['neo-circle-center'], style: {}, cn: [
                {cls: ['neo-circle-front'], cn: [
                    {cls: ['neo-circle'], style: {}, cn: [
                        {cls: ['neo-count-items']},
                        {cls: ['neo-circle-name']}
                    ]},
                    {cls: ['neo-outer-circle'], style: {}}
                ]},
                {cls: ['neo-circle-back'], cn: []}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me              = this,
            {resourcesPath} = Neo.config;

        Neo.main.DomEvents.registerPreventDefaultTargets({
            name    : 'contextmenu',
            cls     : ['neo-circle', 'neo-circle-back'],
            windowId: me.windowId
        });

        if (!me.backsideIconPath) {
            me.backsideIconPath = resourcesPath + 'images/circle/'
        }

        if (!me.itemImagePath) {
            me.itemImagePath = resourcesPath + 'examples/'
        }

        me.addDomListeners([{
            mouseenter: me.expand,
            mouseleave: me.collapse,
            scope     : me
        }, {
            contextmenu: me.onContextMenu,
            delegate   : 'neo-circle-back',
            scope      : me
        }, {
            click   : me.onBacksideIconClick,
            delegate: 'neo-backside-icon',
            scope   : me
        }, {
            mouseenter: me.expandItem,
            mouseleave: me.collapseItem,
            delegate  : 'neo-circle-item',
            scope     : me
        }, {
            contextmenu: me.onContextMenu,
            delegate   : 'neo-circle',
            scope      : me,
            wheel      : {
                bubble : false,
                fn     : me.onMouseWheel,
                local  : true,
                passive: false
            }
        }]);

        me.store = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            keyProperty: 'id'
        });

        // silent updates
        me.createBacksideItems(true);
        me.updateInnerCircle(true);
        me.updateOuterCircle(true);
        me.updateTitle(true);

        me.update()
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me           = this,
            domListeners = [];

        value && Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-_ef4c1")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs")).then(module => {
            DragZone = module.default;

            if (!me.dragListenersAdded) {
                domListeners.push(
                    {'drag:end'  : me.onDragEnd,   scope: me, delegate: 'neo-circle-item'},
                    {'drag:start': me.onDragStart, scope: me, delegate: 'neo-circle-item'}
                );

                me.addDomListeners(domListeners);
                me.dragListenersAdded = true
            }
        })
    }

    /**
     * Triggered after the innerRadius config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInnerRadius(value, oldValue) {
        if (oldValue) {
            let me = this;

            me.updateItemPositions(true);
            me.updateInnerCircle(true);
            me.updateOuterCircle(false)
        }
    }

    /**
     * Triggered after the maxItems config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMaxItems(value, oldValue) {
        if (oldValue && this.vnodeInitialized) {
            let me      = this,
                frontEl = me.getFrontEl();

            if (value < oldValue) {
                if (me.collapsed) {
                    frontEl.cn.splice(value + 2);
                } else {
                    me.updateItemOpacity(0, true, value);

                    me.timeout(300).then(() => {
                        frontEl.cn.splice(value + 2);
                        me.update()
                    })
                }

                me.updateItemPositions(true);
                me.update()
            } else {
                me.createItems(oldValue, true);
                me.updateItemPositions(true);

                me.promiseUpdate().then(() => {
                    if (!me.collapsed) {
                        me.updateItemOpacity(1, true, oldValue);
                        me.update()
                    }
                })
            }
        }
    }

    /**
     * Triggered after the itemSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetItemSize(value, oldValue) {
        let me = this;

        if (oldValue && me.vnodeInitialized) {
            !me.collapsed && me.updateOuterCircle(true);
            me.updateItemPositions()
        }
    }

    /**
     * Triggered after the rotateX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateX(value, oldValue) {
        oldValue && this.vnodeInitialized && this.rotate()
    }

    /**
     * Triggered after the rotateY config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateY(value, oldValue) {
        oldValue && this.vnodeInitialized && this.rotate()
    }

    /**
     * Triggered after the rotateZ config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateZ(value, oldValue) {
        oldValue && this.vnodeInitialized && this.rotate()
    }

    /**
     * Triggered after the rotationIndex config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotationIndex(value, oldValue) {
        if (Neo.isNumber(oldValue)) {
            console.log('afterSetRotationIndex', value)
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        this.vnodeInitialized && value.register(this);
    }

    /**
     * Triggered after the title config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTitle(value, oldValue) {
        oldValue && this.updateTitle()
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue && oldValue.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_CircleModel_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])
    }

    /**
     * @returns {Object[]}
     */
    calculateItemPositions() {
        let me         = this,
            angle      = 360 / me.maxItems,
            circlePos  = [],
            {itemSize} = me,
            radius     = me.innerRadius + itemSize / 2 + 4,
            i          = 0,
            len        = me.maxItems,
            nr;

        for (; i < len; i++) {
            nr = (angle * i + 180) * Math.PI / 180;

            circlePos.push({
                left: -Math.round(radius * Math.sin(nr)) - itemSize / 2,
                top :  Math.round(radius * Math.cos(nr)) - itemSize / 2
            })
        }

        return circlePos
    }

    /**
     *
     */
    collapse() {
        let me = this;

        if (!me.collapsed) {
            me.collapsed = true;
            me.updateOuterCircle(true);
            me.updateItemOpacity(0, false);
        }
    }

    /**
     * @param {Object} data
     */
    collapseItem(data) {
        let me    = this,
            item  = me.getItemEl(data.path[0].id),
            style = item.cn[0].style;

        delete style.marginLeft;
        delete style.marginTop;
        delete style.zIndex;

        style.height = me.itemSize + 'px';
        style.width  = me.itemSize + 'px';

        me.update()
    }

    /**
     * @param {Boolean} silent=false
     */
    createBacksideItems(silent=false) {
        let me         = this,
            backEl     = me.getBackEl(),
            itemCls    = ['neo-flip', 'neo-pencil', 'neo-trash'],
            itemFile   = ['flip.png', 'pencil.png', 'trash.png'],
            countItems = 3,
            i          = 0;

        backEl.cn.push(
            {cls: ['neo-count-items']},
            {cls: ['neo-circle-name']}
        );

        for (; i < countItems; i++) {
            backEl.cn.push({
                tag: 'img',
                cls: ['neo-backside-icon', itemCls[i]],
                src: me.backsideIconPath + itemFile[i]
            })
        }

        !silent && me.update()
    }

    /**
     * @param {Number} startIndex=0
     * @param {Boolean} silent=false
     */
    createItems(startIndex=0, silent=false) {
        let me            = this,
            frontEl       = me.getFrontEl(),
            itemCls       = ['neo-circle-item'],
            itemPositions = me.calculateItemPositions(),
            {itemSize}    = me,
            countItems    = Math.min(me.store.getCount(), me.maxItems),
            i             = startIndex;

        me.draggable && itemCls.push('neo-draggable');

        for (; i < countItems; i++) {
            frontEl.cn.push({
                id      : me.getItemId(i),
                cls     : itemCls,
                tabIndex: -1,
                style: {
                    height: itemSize              + 'px',
                    left  : itemPositions[i].left + 'px',
                    top   : itemPositions[i].top  + 'px',
                    width : itemSize              + 'px'
                },
                cn: [{
                    tag  : 'img',
                    cls  : ['neo-circle-item-image'],
                    src  : me.itemImagePath + me.store.getAt(i).image,
                    style: {
                        height: itemSize + 'px',
                        width : itemSize + 'px'
                    }
                }]
            })
        }

        !silent && me.update()
    }

    /**
     * @param {Object} data
     */
    expand(data) {
        let me = this;

        if (me.collapsed) {
            me.collapsed = false;
            me.updateOuterCircle(true);
            me.updateItemOpacity(1, false)
        }
    }

    /**
     * @param {Object} data
     */
    expandItem(data) {
        let me   = this,
            item = me.getItemEl(data.path[0].id);

        item.cn[0].style = {
            height    : (me.itemSize + 20) + 'px',
            marginLeft: -10 + 'px',
            marginTop : -10 + 'px',
            width     : (me.itemSize + 20) + 'px',
            zIndex    : 40
        };

        me.update()
    }

    flipCircle() {
        let me = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"][me.isFlipped ? 'remove': 'add'](me.vdom.cn[0].cls, 'neo-flipped');

        me.isFlipped = !me.isFlipped;
        me.update()
    }

    /**
     *
     */
    getBackEl() {
        return this.vdom.cn[0].cn[1]
    }

    /**
     *
     */
    getFrontEl() {
        return this.vdom.cn[0].cn[0]
    }

    /**
     *
     */
    getInnerCircle() {
        return this.vdom.cn[0].cn[0].cn[0]
    }

    /**
     * @param {String} itemId
     * @returns {Object}
     */
    getItemEl(itemId) {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(this.getFrontEl(), itemId)?.vdom
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getItemId(index) {
        let {store} = this;

        return this.id + '__' + store.getAt(index)[store.keyProperty]
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId   = vnodeId.split('__').pop(),
            model    = this.store.model,
            keyField = model?.getField(model.keyProperty);

        if (keyField?.type.toLowerCase() === 'number') {
            itemId = parseInt(itemId)
        }

        return itemId
    }

    /**
     *
     */
    getOuterCircle() {
        return this.vdom.cn[0].cn[0].cn[1]
    }

    /**
     *
     */
    async loadData() {
        let me = this,
            data;

        try {
            data = await me.trap(Neo.Xhr.promiseJson({
                insideNeo: true,
                url      : me.url
            }));

            me.store.items = data.json.data;

            await me.timeout(100);

            me.updateTitle();
            me.createItems()
        } catch (err) {
            if (err !== Neo.isDestroyed) {
                console.log('Error for Neo.Xhr.request', err, me.id)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onBacksideIconClick(data) {
        let me  = this,
            cls = data.path[0].cls;

             if (cls.includes('neo-flip'))   {me.flipCircle()}
        else if (cls.includes('neo-pencil')) {console.log('edit circle')}
        else if (cls.includes('neo-trash'))  {console.log('delete circle')}
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.selectionModel?.register(me);
        me.loadData()
    }

    /**
     * @param {Object} data
     */
    onContextMenu(data) {
        this.flipCircle()
    }

    /**
     * @param data
     */
    onDragEnd(data) {
        console.log('onDragEnd', data)
    }

    /**
     * @param data
     */
    onDragStart(data) {
        console.log('onDragStart', data)

        let me           = this,
            wrapperStyle = me.wrapperStyle || {};

        me.isDragging = true;

        if (!me.dragZone) {
            me.dragZone = Neo.create({
                module         : DragZone,
                appName        : me.appName,
                bodyCursorStyle: 'move !important',
                dragElement    : me.vdom,
                dragProxyConfig: {vdom: me.getProxyVdom()},
                owner          : me,
                useProxyWrapper: false,
                windowId       : me.windowId,
                ...me.dragZoneConfig
            })
        }

        me.dragZone.dragStart(data);

        wrapperStyle.opacity = 0.7;

        me.wrapperStyle = wrapperStyle
    }

    /**
     * @param {Object} data
     */
    onMouseWheel(data) {
        let me        = this,
            deltaY    = data.deltaY,
            itemAngle = 360 / me.maxItems,
            maxAngle  = Math.max(0, (me.store.getCount() - me.maxItems) * itemAngle),
            rotateZ   = me.rotateZ;

        if (deltaY >  1 || deltaY < -1) {
            rotateZ += deltaY
        }

        if (rotateZ < 0) {
            rotateZ = 0;
        } else if (rotateZ > maxAngle) {
            rotateZ = maxAngle
        }

        if (!(me.rotateZ === 0 && rotateZ === 0) && !(me.rotateZ === maxAngle && rotateZ === maxAngle)) {
            me.rotateZ       = rotateZ;
            me.rotationIndex = Math.floor(rotateZ / itemAngle);

            me.rotate()
        }
    }

    /**
     *
     */
    rotate() {
        let me             = this,
            circleCenterEl = me.vdom.cn[0],
            transform = [
                `rotateX(${me.rotateX}deg)`,
                `rotateY(${me.rotateY}deg)`,
                `rotateZ(${me.rotateZ}deg)`
            ].join(' ');

        if (me.circleCenterHasTransitionCls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(circleCenterEl.cls, 'no-transition');

            me.circleCenterHasTransitionCls = false;

            me.promiseUpdate().then(() => {
                me.updateItemAngle(true);
                circleCenterEl.style.transform = transform;
                me.update()
            })
        } else {
            me.updateItemAngle(true);
            circleCenterEl.style.transform = transform;
            me.update()
        }
    }

    /**
     * @param {Boolean} silent=false
     */
    updateInnerCircle(silent=false) {
        let me            = this,
            innerCircle   = me.getInnerCircle(),
            {innerRadius} = me,
            innerSize     = innerRadius * 2;

        Object.assign(innerCircle.style, {
            height: innerSize + 'px',
            left  : '-' + innerRadius + 'px',
            top   : '-' + innerRadius + 'px',
            width : innerSize + 'px'
        });

        !silent && me.update()
    }

    /**
     * @param {Boolean} silent=false
     */
    updateItemAngle(silent=false) {
        let me      = this,
            frontEl = me.getFrontEl(),
            i       = 2,
            len     = frontEl.cn.length;

        for (; i < len; i++) {
            frontEl.cn[i].style.transform = 'rotateZ(' + (-me.rotateZ) + 'deg)'
        }

        !silent && me.update()
    }

    /**
     * @param {Number} value
     * @param {Boolean} silent=false
     * @param {Number} startIndex=0
     */
    updateItemOpacity(value, silent=false, startIndex=0) {
        let me      = this,
            i       = startIndex + 2,
            frontEl = me.getFrontEl(),
            len     = frontEl.cn.length;

        for (; i < len; i++) {
            frontEl.cn[i].style.opacity = value;
        }

        !silent && me.update()
    }

    /**
     * @param {Boolean} silent=false
     */
    updateItemPositions(silent=false) {
        let me            = this,
            frontEl       = me.getFrontEl(),
            itemPositions = me.calculateItemPositions(),
            {itemSize}    = me,
            i             = 2,
            len           = Math.min(frontEl.cn.length, itemPositions.length + 2);

        for (; i < len; i++) {
            Object.assign(frontEl.cn[i].style, {
                height: itemSize                + 'px',
                left  : itemPositions[i-2].left + 'px',
                top   : itemPositions[i-2].top  + 'px',
                width : itemSize                + 'px'
            });

            Object.assign(frontEl.cn[i].cn[0].style, {
                height: itemSize + 'px',
                width : itemSize + 'px'
            })
        }

        !silent && me.update()
    }

    /**
     * @param {Boolean} silent=false
     */
    updateOuterCircle(silent=false) {
        let me           = this,
            {itemSize}   = me,
            outerCircle  = me.getOuterCircle(),
            outerRadius  = me.innerRadius + me.outerRadiusDelta,
            outerSize    = me.collapsed ? outerRadius * 2 : (outerRadius + itemSize) * 2,
            opts;

        if (me.collapsed) {
            opts = {
                height: outerSize + 'px',
                left  : '-' + outerRadius + 'px',
                top   : '-' + outerRadius + 'px',
                width : outerSize + 'px'
            }
        } else {
            opts = {
                height: outerSize + 'px',
                left  : '-' + (outerRadius + itemSize) + 'px',
                top   : '-' + (outerRadius + itemSize) + 'px',
                width : outerSize + 'px'
            }
        }

        Object.assign(outerCircle.style, opts);

        !silent && me.update()
    }

    /**
     * @param {Boolean} silent=false
     */
    updateTitle(silent=false) {
        let me          = this,
            innerCircle = me.getInnerCircle();

        innerCircle.cn[0].text = me.store?.getCount() || 0;
        innerCircle.cn[1].text = me.title;

        !silent && me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Circle));


/***/ },

/***/ "./src/selection/CircleModel.mjs"
/*!***************************************!*\
  !*** ./src/selection/CircleModel.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");


/**
 * @class Neo.selection.CircleModel
 * @extends Neo.selection.Model
 */
class CircleModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.CircleModel'
         * @protected
         */
        className: 'Neo.selection.CircleModel',
        /**
         * @member {String} ntype='selection-circlemodel'
         * @protected
         */
        ntype: 'selection-circlemodel'
    }

    /**
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        this.onNavKey(data, -1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownRight(data) {
        this.onNavKey(data, 1)
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        let me       = this,
            item     = data.path[0],
            {view}   = me,
            {store}  = view,
            maxIndex = Math.min(store.getCount(), view.maxItems) - 1,
            index, itemId, recordId;

        if (item.cls.includes('neo-circle-item')) {
            recordId = parseInt(view.getItemRecordId(item.id));
            index    = store.indexOf(recordId) + step;

                 if (index < 0)        {index = maxIndex}
            else if (index > maxIndex) {index = 0}
        } else {
            index = 0
        }

        itemId = view.getItemId(index);

        me.select(itemId);
        view.focus(itemId)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let {id, view} = this;

        view.keys?._keys.push(
            {fn: 'onKeyDownLeft'  ,key: 'Down'  ,scope: id},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Up'    ,scope: id}
        )
    }

    /**
     *
     */
    unregister() {
        let {id, view} = this;

        view.keys?.removeKeys([
            {fn: 'onKeyDownLeft'  ,key: 'Down'  ,scope: id},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Up'    ,scope: id}
        ]);

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CircleModel));


/***/ },

/***/ "./src/selection/Model.mjs"
/*!*********************************!*\
  !*** ./src/selection/Model.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");





/**
 * @class Neo.selection.Model
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.selection.Model'
         * @protected
         */
        className: 'Neo.selection.Model',
        /**
         * @member {String} ntype='selection-model'
         * @protected
         */
        ntype: 'selection-model',
        /**
         * Placeholder for extended classes to add a custom css rule to this owner component
         * @member {String|null} cls=null
         * @protected
         */
        cls: null,
        /**
         * @member {Array} items_
         * @protected
         * @reactive
         */
        items_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_3__.isDescriptor]: true,
            clone         : 'shallow',
            cloneOnGet    : 'none',
            isEqual       : () => false,
            value         : []
        },
        /**
         * @member {String} selectedCls='selected'
         */
        selectedCls: 'neo-selected',
        /**
         * @member {Boolean} singleSelect=true
         */
        singleSelect: true,
        /**
         * Internally saves the view id, but the getter will return the matching instance
         * @member {Object} view_=null
         * @protected
         * @reactive
         */
        view_: null
    }

    /**
     * Gets triggered before getting the value of the view config
     * @param {String} value
     * @returns {Neo.component.Base}
     */
    beforeGetView(value) {
        return Neo.getComponent(this._view)
    }

    /**
     * Gets triggered before setting the value of the view config
     * @returns {String} the view id
     */
    beforeSetView(value) {
        return value && value.id
    }

    /**
     *
     */
    addDomListener() {}

    /**
     * @param {Object} item
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    deselect(item, silent, itemCollection=this.items, selectedCls) {
        let me     = this,
            {view} = me,
            node;

        // We hold vdom ids for now, so all incoming selections must be converted.
        item = item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item;

        if (itemCollection.includes(item)) {
            node = view.getVdomChild(item);

            if (node) {
                node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(node.cls || [], selectedCls || me.selectedCls);
                delete node['aria-selected']
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(itemCollection, item);

            if (!silent) {
                view.update();

                view.parent?.onDeselect?.(); // grid.Container & table.Container
                view.onDeselect?.();

                me.fire('selectionChange', {
                    selection: itemCollection
                })
            }
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     * @param {Boolean} [silent] true to prevent a vdom update
     * @param {Object[]|String[]} itemCollection=this.items
     */
    deselectAll(silent, itemCollection=this.items) {
        let me     = this,
            items  = [...itemCollection],
            {view} = me;

        if (items.length) {
            items.forEach(item => {
                me.deselect(item, true)
            });

            if (!silent && items.length > 0) {
                view.update()
            }

            me.fire('selectionChange', {
                selection: this.items
            })
        } else if (!silent) {
            me.fire('noChange')
        }
    }

    /**
     *
     */
    destroy(...args) {
        this.unregister();
        super.destroy(...args)
    }

    /**
     * Important for mapping listeners to view controllers
     * @returns {Neo.controller.Component|null}
     */
    getController() {
        return this.view.getController()
    }

    /**
     * @returns {Array} this.items
     */
    getSelection() {
        return this.items
    }

    /**
     * @returns {Boolean}
     */
    hasSelection() {
        return this.items.length > 0
    }

    /**
     * @param {String} id
     * @returns {Boolean} true in case the item is selected
     */
    isSelected(id) {
        return this.items.includes(id)
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me  = this,
            cls = component.wrapperCls || [];

        if (me.cls && !cls.includes(me.cls)) {
            cls.push(me.cls);
            component.wrapperCls = cls
        }

        me.view = component;
        me.addDomListener();

        component.fire('selectionModelChange', {
            value: me
        })
    }

    /**
     *
     */
    removeDomListeners() {
        let me           = this,
            component    = me.view,
            domListeners = [...component.domListeners];

        component.domListeners.forEach(listener => {
            if (listener.scope === me) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(domListeners, listener)
            }
        });

        component.domListeners = domListeners
    }

    /**
     * @param {Object|Object[]|String[]} items
     * @param {Object[]|String[]} itemCollection=this.items
     * @param {String} [selectedCls]
     */
    select(items, itemCollection=this.items, selectedCls) {
        if (!Array.isArray(items)) {
            items = [items]
        }

        let me      = this,
            {view}  = me,
            records = items.map(item => {
                if (item.isRecord) return item;

                const recordId = view.getItemRecordId?.(item);

                return recordId && view.store?.get(recordId) || item
            });

        // We hold vdom ids for now, so all incoming selections must be converted.
        items = items.map(item => item.isRecord ? view.getItemId(item) : Neo.isObject(item) ? item.id : item);

        if (!Neo.isEqual(itemCollection, items)) {
            if (me.singleSelect && itemCollection === me.items) {
                me.deselectAll(true, itemCollection)
            }

            items.forEach(node => {
                node = view.getVdomChild(node);

                if (node) {
                    node.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(node.cls || [], selectedCls || me.selectedCls);
                    node['aria-selected'] = true
                }
            });

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemCollection, items);

            if (!view.silentSelect) {
                view.update()
            }

            view.parent?.onSelect?.(items); // grid.Container & table.Container
            view.onSelect?.(items);

            view.fire('select', {
                records,
                selection: itemCollection
            });

            me.fire('selectionChange', {
                records,
                selection: itemCollection
            })
        }
        else {
            me.fire('noChange')
        }
    }

    /**
     * @param {Object} item
     */
    toggleSelection(item) {
        let me = this;

        if (me.isSelected(item)) {
            me.deselect(item)
        } else {
            me.select(item)
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        const
            me    = this,
            items = (me.items || []).map(item => {
                if (Neo.isRecord(item)) {
                    return item.toJSON()
                }

                return item
            });

        return {
            ...super.toJSON(),
            items,
            selectedCls : me.selectedCls,
            singleSelect: me.singleSelect
        }
    }

    /**
     *
     */
    unregister() {
        let me     = this,
            {view} = me;

        if (!view.isDestroying) {
            let cls = view.wrapperCls || [];

            if (me.cls && cls.includes(me.cls)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, me.cls);
                view.wrapperCls = cls
            }

            me.deselectAll();

            me.removeDomListeners()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfQ2lyY2xlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUNLO0FBQ047QUFDWjtBQUNPO0FBQ0Q7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQVM7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Is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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQix1REFBUTtBQUN4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvQ2lyY2xlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9DaXJjbGVNb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vTW9kZWwubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENpcmNsZU1vZGVsICAgICBmcm9tICcuLi9zZWxlY3Rpb24vQ2lyY2xlTW9kZWwubWpzJztcbmltcG9ydCBDb2xsZWN0aW9uICAgICAgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuXG5sZXQgRHJhZ1pvbmU7XG5cbi8qKlxuICogQHN1bW1hcnkgQSBoaWdobHkgaW50ZXJhY3RpdmUgY2lyY3VsYXIgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGFuZCBhcnJhbmdpbmcgaXRlbXMgaW4gYSByYWRpYWwgbGF5b3V0LlxuICpcbiAqIFRoaXMgY29tcG9uZW50IHJlbmRlcnMgYSBjZW50cmFsIGNpcmNsZSB0aGF0IGNhbiBiZSBleHBhbmRlZCBvciBjb2xsYXBzZWQgb24gbW91c2UgaW50ZXJhY3Rpb24uIFdoZW4gZXhwYW5kZWQsXG4gKiBpdCByZXZlYWxzIGEgc2VyaWVzIG9mIGl0ZW1zIGFycmFuZ2VkIGluIGFuIG91dGVyIGNpcmNsZS4gVGhlIGNvbXBvbmVudCBpcyBmbGlwcGFibGUsIHNob3dpbmcgYSBiYWNrc2lkZVxuICogd2l0aCBhZGRpdGlvbmFsIGFjdGlvbnMuIEl0ZW1zIHdpdGhpbiB0aGUgY2lyY2xlIGFyZSBkcmFnZ2FibGUuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBhIHNvcGhpc3RpY2F0ZWQgZXhhbXBsZSBvZiBsZXZlcmFnaW5nIHRoZSBmcmFtZXdvcmsncyBWRE9NIG1hbmlwdWxhdGlvbiBmb3IgY29tcGxleCBhbmltYXRpb25zXG4gKiBhbmQgaW50ZXJhY3Rpb25zLiBJdCBkZW1vbnN0cmF0ZXMgY29uY2VwdHMgbGlrZSBkeW5hbWljIHN0eWxpbmcsIGV2ZW50IGhhbmRsaW5nIGZvciBjdXN0b20gZHJhZy1hbmQtZHJvcCxcbiAqIGFuZCBtYW5hZ2luZyBhIGNvbGxlY3Rpb24gb2YgaXRlbXMgd2l0aGluIGEgbm9uLXN0YW5kYXJkIGxheW91dC5cbiAqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5DaXJjbGVcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5DaXJjbGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuQ2lyY2xlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NpcmNsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgc2V0IGluc2lkZSB0aGUgY3RvciB0byBhdm9pZCBpc3N1ZXMgaW5zaWRlIHRoZSB3ZWJwYWNrIGJ1aWxkc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYmFja3NpZGVJY29uUGF0aD1OZW8uY29uZmlnLnJlc291cmNlc1BhdGggKyAnaW1hZ2VzL2NpcmNsZS8nXG4gICAgICAgICAqL1xuICAgICAgICBiYWNrc2lkZUljb25QYXRoOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2lyY2xlLWNvbXBvbmVudCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jaXJjbGUtY29tcG9uZW50J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjaXJjbGVDZW50ZXJIYXNUcmFuc2l0aW9uQ2xzPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2lyY2xlQ2VudGVySGFzVHJhbnNpdGlvbkNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNvbGxhcHNlZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnZ2FibGVfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCB1c2VkIGtleXMgZm9yIHRoZSBzZWxlY3Rpb24gbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzPXt9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5czoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGlubmVyUmFkaXVzXz0xMDBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpbm5lclJhZGl1c186IDEwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzRmxpcHBlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNGbGlwcGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgZ2V0IHNldCBpbnNpZGUgdGhlIGN0b3IgdG8gYXZvaWQgaXNzdWVzIGluc2lkZSB0aGUgd2VicGFjayBidWlsZHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpdGVtSW1hZ2VQYXRoPU5lby5jb25maWcucmVzb3VyY2VzUGF0aCArICdleGFtcGxlcy9pbWFnZXMvJ1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUltYWdlUGF0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaXRlbVNpemVfPTYwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVNpemVfOiA2MCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4SXRlbXNfPTEyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4SXRlbXNfOiAxMixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgaW4gcHggd2hpY2ggdGhlIG91dGVyUmFkaXVzIGlzIGJpZ2dlciB0aGFuIHRoZSBpbm5lclJhZGl1c1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG91dGVyUmFkaXVzRGVsdGFfPTEwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgb3V0ZXJSYWRpdXNEZWx0YV86IDEwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3RhdGVYXz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlWF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvdGF0ZVlfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVZXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm90YXRlWl89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZVpfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3RhdGlvbkluZGV4Xz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRpb25JbmRleF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uc2VsZWN0aW9uLk1vZGVsfG51bGx9IHNlbGVjdGlvbk1vZGVsXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uTW9kZWxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbGxlY3Rpb24uQmFzZXxudWxsfSBzdG9yZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGl0bGVfPSdDaXJjbGUgMSdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZV86ICdDaXJjbGUgMScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXJsIGZvciB0aGUgc3RvcmUgdG8gbG9hZCB0aGUgZGF0YVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHVybF89Jy4uL3Jlc291cmNlcy9leGFtcGxlcy9kYXRhL2NpcmNsZXMvZ3JvdXAxLmpzb24nXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXJsXzogJy4uLy4uL3Jlc291cmNlcy9leGFtcGxlcy9kYXRhL2NpcmNsZXMvZ3JvdXAxLmpzb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWJJbmRleDogLTEsIGNuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1jaXJjbGUtY2VudGVyJ10sIHN0eWxlOiB7fSwgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1jaXJjbGUtZnJvbnQnXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tY2lyY2xlJ10sIHN0eWxlOiB7fSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNvdW50LWl0ZW1zJ119LFxuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tY2lyY2xlLW5hbWUnXX1cbiAgICAgICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW91dGVyLWNpcmNsZSddLCBzdHlsZToge319XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tY2lyY2xlLWJhY2snXSwgY246IFtdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZXNvdXJjZXNQYXRofSA9IE5lby5jb25maWc7XG5cbiAgICAgICAgTmVvLm1haW4uRG9tRXZlbnRzLnJlZ2lzdGVyUHJldmVudERlZmF1bHRUYXJnZXRzKHtcbiAgICAgICAgICAgIG5hbWUgICAgOiAnY29udGV4dG1lbnUnLFxuICAgICAgICAgICAgY2xzICAgICA6IFsnbmVvLWNpcmNsZScsICduZW8tY2lyY2xlLWJhY2snXSxcbiAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW1lLmJhY2tzaWRlSWNvblBhdGgpIHtcbiAgICAgICAgICAgIG1lLmJhY2tzaWRlSWNvblBhdGggPSByZXNvdXJjZXNQYXRoICsgJ2ltYWdlcy9jaXJjbGUvJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5pdGVtSW1hZ2VQYXRoKSB7XG4gICAgICAgICAgICBtZS5pdGVtSW1hZ2VQYXRoID0gcmVzb3VyY2VzUGF0aCArICdleGFtcGxlcy8nXG4gICAgICAgIH1cblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tcbiAgICAgICAgICAgIG1vdXNlZW50ZXI6IG1lLmV4cGFuZCxcbiAgICAgICAgICAgIG1vdXNlbGVhdmU6IG1lLmNvbGxhcHNlLFxuICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY29udGV4dG1lbnU6IG1lLm9uQ29udGV4dE1lbnUsXG4gICAgICAgICAgICBkZWxlZ2F0ZSAgIDogJ25lby1jaXJjbGUtYmFjaycsXG4gICAgICAgICAgICBzY29wZSAgICAgIDogbWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2xpY2sgICA6IG1lLm9uQmFja3NpZGVJY29uQ2xpY2ssXG4gICAgICAgICAgICBkZWxlZ2F0ZTogJ25lby1iYWNrc2lkZS1pY29uJyxcbiAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb3VzZWVudGVyOiBtZS5leHBhbmRJdGVtLFxuICAgICAgICAgICAgbW91c2VsZWF2ZTogbWUuY29sbGFwc2VJdGVtLFxuICAgICAgICAgICAgZGVsZWdhdGUgIDogJ25lby1jaXJjbGUtaXRlbScsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb250ZXh0bWVudTogbWUub25Db250ZXh0TWVudSxcbiAgICAgICAgICAgIGRlbGVnYXRlICAgOiAnbmVvLWNpcmNsZScsXG4gICAgICAgICAgICBzY29wZSAgICAgIDogbWUsXG4gICAgICAgICAgICB3aGVlbCAgICAgIDoge1xuICAgICAgICAgICAgICAgIGJ1YmJsZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZuICAgICA6IG1lLm9uTW91c2VXaGVlbCxcbiAgICAgICAgICAgICAgICBsb2NhbCAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dKTtcblxuICAgICAgICBtZS5zdG9yZSA9IE5lby5jcmVhdGUoQ29sbGVjdGlvbiwge1xuICAgICAgICAgICAga2V5UHJvcGVydHk6ICdpZCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2lsZW50IHVwZGF0ZXNcbiAgICAgICAgbWUuY3JlYXRlQmFja3NpZGVJdGVtcyh0cnVlKTtcbiAgICAgICAgbWUudXBkYXRlSW5uZXJDaXJjbGUodHJ1ZSk7XG4gICAgICAgIG1lLnVwZGF0ZU91dGVyQ2lyY2xlKHRydWUpO1xuICAgICAgICBtZS51cGRhdGVUaXRsZSh0cnVlKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZHJhZ2dhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RHJhZ2dhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRvbUxpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgIHZhbHVlICYmIGltcG9ydCgnLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgIERyYWdab25lID0gbW9kdWxlLmRlZmF1bHQ7XG5cbiAgICAgICAgICAgIGlmICghbWUuZHJhZ0xpc3RlbmVyc0FkZGVkKSB7XG4gICAgICAgICAgICAgICAgZG9tTGlzdGVuZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uRHJhZ0VuZCwgICBzY29wZTogbWUsIGRlbGVnYXRlOiAnbmVvLWNpcmNsZS1pdGVtJ30sXG4gICAgICAgICAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uRHJhZ1N0YXJ0LCBzY29wZTogbWUsIGRlbGVnYXRlOiAnbmVvLWNpcmNsZS1pdGVtJ31cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKGRvbUxpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ0xpc3RlbmVyc0FkZGVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW5uZXJSYWRpdXMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW5uZXJSYWRpdXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUudXBkYXRlSXRlbVBvc2l0aW9ucyh0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUlubmVyQ2lyY2xlKHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlT3V0ZXJDaXJjbGUoZmFsc2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heEl0ZW1zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1heEl0ZW1zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgJiYgdGhpcy52bm9kZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZnJvbnRFbCA9IG1lLmdldEZyb250RWwoKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb250RWwuY24uc3BsaWNlKHZhbHVlICsgMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlSXRlbU9wYWNpdHkoMCwgdHJ1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoMzAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb250RWwuY24uc3BsaWNlKHZhbHVlICsgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1Qb3NpdGlvbnModHJ1ZSk7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMob2xkVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1Qb3NpdGlvbnModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBtZS5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVJdGVtT3BhY2l0eSgxLCB0cnVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXRlbVNpemUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXRlbVNpemUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICYmIG1lLnZub2RlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICFtZS5jb2xsYXBzZWQgJiYgbWUudXBkYXRlT3V0ZXJDaXJjbGUodHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVJdGVtUG9zaXRpb25zKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRlWCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGVYKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnZub2RlSW5pdGlhbGl6ZWQgJiYgdGhpcy5yb3RhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRlWSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGVZKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnZub2RlSW5pdGlhbGl6ZWQgJiYgdGhpcy5yb3RhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRlWiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGVaKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnZub2RlSW5pdGlhbGl6ZWQgJiYgdGhpcy5yb3RhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRpb25JbmRleCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGlvbkluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FmdGVyU2V0Um90YXRpb25JbmRleCcsIHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZub2RlSW5pdGlhbGl6ZWQgJiYgdmFsdWUucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aXRsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaXRsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgdGhpcy51cGRhdGVUaXRsZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgb2xkVmFsdWUuZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIENpcmNsZU1vZGVsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVJdGVtUG9zaXRpb25zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhbmdsZSAgICAgID0gMzYwIC8gbWUubWF4SXRlbXMsXG4gICAgICAgICAgICBjaXJjbGVQb3MgID0gW10sXG4gICAgICAgICAgICB7aXRlbVNpemV9ID0gbWUsXG4gICAgICAgICAgICByYWRpdXMgICAgID0gbWUuaW5uZXJSYWRpdXMgKyBpdGVtU2l6ZSAvIDIgKyA0LFxuICAgICAgICAgICAgaSAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgID0gbWUubWF4SXRlbXMsXG4gICAgICAgICAgICBucjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuciA9IChhbmdsZSAqIGkgKyAxODApICogTWF0aC5QSSAvIDE4MDtcblxuICAgICAgICAgICAgY2lyY2xlUG9zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxlZnQ6IC1NYXRoLnJvdW5kKHJhZGl1cyAqIE1hdGguc2luKG5yKSkgLSBpdGVtU2l6ZSAvIDIsXG4gICAgICAgICAgICAgICAgdG9wIDogIE1hdGgucm91bmQocmFkaXVzICogTWF0aC5jb3MobnIpKSAtIGl0ZW1TaXplIC8gMlxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaXJjbGVQb3NcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbGxhcHNlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBtZS5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgbWUudXBkYXRlT3V0ZXJDaXJjbGUodHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVJdGVtT3BhY2l0eSgwLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNvbGxhcHNlSXRlbShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtICA9IG1lLmdldEl0ZW1FbChkYXRhLnBhdGhbMF0uaWQpLFxuICAgICAgICAgICAgc3R5bGUgPSBpdGVtLmNuWzBdLnN0eWxlO1xuXG4gICAgICAgIGRlbGV0ZSBzdHlsZS5tYXJnaW5MZWZ0O1xuICAgICAgICBkZWxldGUgc3R5bGUubWFyZ2luVG9wO1xuICAgICAgICBkZWxldGUgc3R5bGUuekluZGV4O1xuXG4gICAgICAgIHN0eWxlLmhlaWdodCA9IG1lLml0ZW1TaXplICsgJ3B4JztcbiAgICAgICAgc3R5bGUud2lkdGggID0gbWUuaXRlbVNpemUgKyAncHgnO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICBjcmVhdGVCYWNrc2lkZUl0ZW1zKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBiYWNrRWwgICAgID0gbWUuZ2V0QmFja0VsKCksXG4gICAgICAgICAgICBpdGVtQ2xzICAgID0gWyduZW8tZmxpcCcsICduZW8tcGVuY2lsJywgJ25lby10cmFzaCddLFxuICAgICAgICAgICAgaXRlbUZpbGUgICA9IFsnZmxpcC5wbmcnLCAncGVuY2lsLnBuZycsICd0cmFzaC5wbmcnXSxcbiAgICAgICAgICAgIGNvdW50SXRlbXMgPSAzLFxuICAgICAgICAgICAgaSAgICAgICAgICA9IDA7XG5cbiAgICAgICAgYmFja0VsLmNuLnB1c2goXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1jb3VudC1pdGVtcyddfSxcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNpcmNsZS1uYW1lJ119XG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBjb3VudEl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgIGJhY2tFbC5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YWc6ICdpbWcnLFxuICAgICAgICAgICAgICAgIGNsczogWyduZW8tYmFja3NpZGUtaWNvbicsIGl0ZW1DbHNbaV1dLFxuICAgICAgICAgICAgICAgIHNyYzogbWUuYmFja3NpZGVJY29uUGF0aCArIGl0ZW1GaWxlW2ldXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4PTBcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKHN0YXJ0SW5kZXg9MCwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZyb250RWwgICAgICAgPSBtZS5nZXRGcm9udEVsKCksXG4gICAgICAgICAgICBpdGVtQ2xzICAgICAgID0gWyduZW8tY2lyY2xlLWl0ZW0nXSxcbiAgICAgICAgICAgIGl0ZW1Qb3NpdGlvbnMgPSBtZS5jYWxjdWxhdGVJdGVtUG9zaXRpb25zKCksXG4gICAgICAgICAgICB7aXRlbVNpemV9ICAgID0gbWUsXG4gICAgICAgICAgICBjb3VudEl0ZW1zICAgID0gTWF0aC5taW4obWUuc3RvcmUuZ2V0Q291bnQoKSwgbWUubWF4SXRlbXMpLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICA9IHN0YXJ0SW5kZXg7XG5cbiAgICAgICAgbWUuZHJhZ2dhYmxlICYmIGl0ZW1DbHMucHVzaCgnbmVvLWRyYWdnYWJsZScpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgY291bnRJdGVtczsgaSsrKSB7XG4gICAgICAgICAgICBmcm9udEVsLmNuLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkICAgICAgOiBtZS5nZXRJdGVtSWQoaSksXG4gICAgICAgICAgICAgICAgY2xzICAgICA6IGl0ZW1DbHMsXG4gICAgICAgICAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemUgICAgICAgICAgICAgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgOiBpdGVtUG9zaXRpb25zW2ldLmxlZnQgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICB0b3AgICA6IGl0ZW1Qb3NpdGlvbnNbaV0udG9wICArICdweCcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbVNpemUgICAgICAgICAgICAgICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgIHRhZyAgOiAnaW1nJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLWNpcmNsZS1pdGVtLWltYWdlJ10sXG4gICAgICAgICAgICAgICAgICAgIHNyYyAgOiBtZS5pdGVtSW1hZ2VQYXRoICsgbWUuc3RvcmUuZ2V0QXQoaSkuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW1TaXplICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbVNpemUgKyAncHgnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGV4cGFuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgbWUuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBtZS51cGRhdGVPdXRlckNpcmNsZSh0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1PcGFjaXR5KDEsIGZhbHNlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBleHBhbmRJdGVtKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLmdldEl0ZW1FbChkYXRhLnBhdGhbMF0uaWQpO1xuXG4gICAgICAgIGl0ZW0uY25bMF0uc3R5bGUgPSB7XG4gICAgICAgICAgICBoZWlnaHQgICAgOiAobWUuaXRlbVNpemUgKyAyMCkgKyAncHgnLFxuICAgICAgICAgICAgbWFyZ2luTGVmdDogLTEwICsgJ3B4JyxcbiAgICAgICAgICAgIG1hcmdpblRvcCA6IC0xMCArICdweCcsXG4gICAgICAgICAgICB3aWR0aCAgICAgOiAobWUuaXRlbVNpemUgKyAyMCkgKyAncHgnLFxuICAgICAgICAgICAgekluZGV4ICAgIDogNDBcbiAgICAgICAgfTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIGZsaXBDaXJjbGUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvQXJyYXlbbWUuaXNGbGlwcGVkID8gJ3JlbW92ZSc6ICdhZGQnXShtZS52ZG9tLmNuWzBdLmNscywgJ25lby1mbGlwcGVkJyk7XG5cbiAgICAgICAgbWUuaXNGbGlwcGVkID0gIW1lLmlzRmxpcHBlZDtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldEJhY2tFbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXS5jblsxXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0RnJvbnRFbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXS5jblswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0SW5uZXJDaXJjbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF0uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRJdGVtRWwoaXRlbUlkKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kKHRoaXMuZ2V0RnJvbnRFbCgpLCBpdGVtSWQpPy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJdGVtSWQoaW5kZXgpIHtcbiAgICAgICAgbGV0IHtzdG9yZX0gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJ19fJyArIHN0b3JlLmdldEF0KGluZGV4KVtzdG9yZS5rZXlQcm9wZXJ0eV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdm5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfSBpdGVtSWRcbiAgICAgKi9cbiAgICBnZXRJdGVtUmVjb3JkSWQodm5vZGVJZCkge1xuICAgICAgICBsZXQgaXRlbUlkICAgPSB2bm9kZUlkLnNwbGl0KCdfXycpLnBvcCgpLFxuICAgICAgICAgICAgbW9kZWwgICAgPSB0aGlzLnN0b3JlLm1vZGVsLFxuICAgICAgICAgICAga2V5RmllbGQgPSBtb2RlbD8uZ2V0RmllbGQobW9kZWwua2V5UHJvcGVydHkpO1xuXG4gICAgICAgIGlmIChrZXlGaWVsZD8udHlwZS50b0xvd2VyQ2FzZSgpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaXRlbUlkID0gcGFyc2VJbnQoaXRlbUlkKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1JZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0T3V0ZXJDaXJjbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF0uY25bMV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGxvYWREYXRhKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IG1lLnRyYXAoTmVvLlhoci5wcm9taXNlSnNvbih7XG4gICAgICAgICAgICAgICAgaW5zaWRlTmVvOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVybCAgICAgIDogbWUudXJsXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIG1lLnN0b3JlLml0ZW1zID0gZGF0YS5qc29uLmRhdGE7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMTAwKTtcblxuICAgICAgICAgICAgbWUudXBkYXRlVGl0bGUoKTtcbiAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICE9PSBOZW8uaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgZm9yIE5lby5YaHIucmVxdWVzdCcsIGVyciwgbWUuaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQmFja3NpZGVJY29uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IGRhdGEucGF0aFswXS5jbHM7XG5cbiAgICAgICAgICAgICBpZiAoY2xzLmluY2x1ZGVzKCduZW8tZmxpcCcpKSAgIHttZS5mbGlwQ2lyY2xlKCl9XG4gICAgICAgIGVsc2UgaWYgKGNscy5pbmNsdWRlcygnbmVvLXBlbmNpbCcpKSB7Y29uc29sZS5sb2coJ2VkaXQgY2lyY2xlJyl9XG4gICAgICAgIGVsc2UgaWYgKGNscy5pbmNsdWRlcygnbmVvLXRyYXNoJykpICB7Y29uc29sZS5sb2coJ2RlbGV0ZSBjaXJjbGUnKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5yZWdpc3RlcihtZSk7XG4gICAgICAgIG1lLmxvYWREYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29udGV4dE1lbnUoZGF0YSkge1xuICAgICAgICB0aGlzLmZsaXBDaXJjbGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29uRHJhZ0VuZCcsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkRyYWdTdGFydCcsIGRhdGEpXG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSBtZS53cmFwcGVyU3R5bGUgfHwge307XG5cbiAgICAgICAgbWUuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICA6IERyYWdab25lLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBib2R5Q3Vyc29yU3R5bGU6ICdtb3ZlICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgIDogbWUudmRvbSxcbiAgICAgICAgICAgICAgICBkcmFnUHJveHlDb25maWc6IHt2ZG9tOiBtZS5nZXRQcm94eVZkb20oKX0sXG4gICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICB1c2VQcm94eVdyYXBwZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgIDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgLi4ubWUuZHJhZ1pvbmVDb25maWdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS5kcmFnWm9uZS5kcmFnU3RhcnQoZGF0YSk7XG5cbiAgICAgICAgd3JhcHBlclN0eWxlLm9wYWNpdHkgPSAwLjc7XG5cbiAgICAgICAgbWUud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlV2hlZWwoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRlbHRhWSAgICA9IGRhdGEuZGVsdGFZLFxuICAgICAgICAgICAgaXRlbUFuZ2xlID0gMzYwIC8gbWUubWF4SXRlbXMsXG4gICAgICAgICAgICBtYXhBbmdsZSAgPSBNYXRoLm1heCgwLCAobWUuc3RvcmUuZ2V0Q291bnQoKSAtIG1lLm1heEl0ZW1zKSAqIGl0ZW1BbmdsZSksXG4gICAgICAgICAgICByb3RhdGVaICAgPSBtZS5yb3RhdGVaO1xuXG4gICAgICAgIGlmIChkZWx0YVkgPiAgMSB8fCBkZWx0YVkgPCAtMSkge1xuICAgICAgICAgICAgcm90YXRlWiArPSBkZWx0YVlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3RhdGVaIDwgMCkge1xuICAgICAgICAgICAgcm90YXRlWiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocm90YXRlWiA+IG1heEFuZ2xlKSB7XG4gICAgICAgICAgICByb3RhdGVaID0gbWF4QW5nbGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKG1lLnJvdGF0ZVogPT09IDAgJiYgcm90YXRlWiA9PT0gMCkgJiYgIShtZS5yb3RhdGVaID09PSBtYXhBbmdsZSAmJiByb3RhdGVaID09PSBtYXhBbmdsZSkpIHtcbiAgICAgICAgICAgIG1lLnJvdGF0ZVogICAgICAgPSByb3RhdGVaO1xuICAgICAgICAgICAgbWUucm90YXRpb25JbmRleCA9IE1hdGguZmxvb3Iocm90YXRlWiAvIGl0ZW1BbmdsZSk7XG5cbiAgICAgICAgICAgIG1lLnJvdGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJvdGF0ZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNpcmNsZUNlbnRlckVsID0gbWUudmRvbS5jblswXSxcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IFtcbiAgICAgICAgICAgICAgICBgcm90YXRlWCgke21lLnJvdGF0ZVh9ZGVnKWAsXG4gICAgICAgICAgICAgICAgYHJvdGF0ZVkoJHttZS5yb3RhdGVZfWRlZylgLFxuICAgICAgICAgICAgICAgIGByb3RhdGVaKCR7bWUucm90YXRlWn1kZWcpYFxuICAgICAgICAgICAgXS5qb2luKCcgJyk7XG5cbiAgICAgICAgaWYgKG1lLmNpcmNsZUNlbnRlckhhc1RyYW5zaXRpb25DbHMpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjaXJjbGVDZW50ZXJFbC5jbHMsICduby10cmFuc2l0aW9uJyk7XG5cbiAgICAgICAgICAgIG1lLmNpcmNsZUNlbnRlckhhc1RyYW5zaXRpb25DbHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUl0ZW1BbmdsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBjaXJjbGVDZW50ZXJFbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS51cGRhdGVJdGVtQW5nbGUodHJ1ZSk7XG4gICAgICAgICAgICBjaXJjbGVDZW50ZXJFbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICB1cGRhdGVJbm5lckNpcmNsZShzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5uZXJDaXJjbGUgICA9IG1lLmdldElubmVyQ2lyY2xlKCksXG4gICAgICAgICAgICB7aW5uZXJSYWRpdXN9ID0gbWUsXG4gICAgICAgICAgICBpbm5lclNpemUgICAgID0gaW5uZXJSYWRpdXMgKiAyO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oaW5uZXJDaXJjbGUuc3R5bGUsIHtcbiAgICAgICAgICAgIGhlaWdodDogaW5uZXJTaXplICsgJ3B4JyxcbiAgICAgICAgICAgIGxlZnQgIDogJy0nICsgaW5uZXJSYWRpdXMgKyAncHgnLFxuICAgICAgICAgICAgdG9wICAgOiAnLScgKyBpbm5lclJhZGl1cyArICdweCcsXG4gICAgICAgICAgICB3aWR0aCA6IGlubmVyU2l6ZSArICdweCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlSXRlbUFuZ2xlKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBmcm9udEVsID0gbWUuZ2V0RnJvbnRFbCgpLFxuICAgICAgICAgICAgaSAgICAgICA9IDIsXG4gICAgICAgICAgICBsZW4gICAgID0gZnJvbnRFbC5jbi5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZnJvbnRFbC5jbltpXS5zdHlsZS50cmFuc2Zvcm0gPSAncm90YXRlWignICsgKC1tZS5yb3RhdGVaKSArICdkZWcpJ1xuICAgICAgICB9XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0SW5kZXg9MFxuICAgICAqL1xuICAgIHVwZGF0ZUl0ZW1PcGFjaXR5KHZhbHVlLCBzaWxlbnQ9ZmFsc2UsIHN0YXJ0SW5kZXg9MCkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpICAgICAgID0gc3RhcnRJbmRleCArIDIsXG4gICAgICAgICAgICBmcm9udEVsID0gbWUuZ2V0RnJvbnRFbCgpLFxuICAgICAgICAgICAgbGVuICAgICA9IGZyb250RWwuY24ubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZyb250RWwuY25baV0uc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlSXRlbVBvc2l0aW9ucyhzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZnJvbnRFbCAgICAgICA9IG1lLmdldEZyb250RWwoKSxcbiAgICAgICAgICAgIGl0ZW1Qb3NpdGlvbnMgPSBtZS5jYWxjdWxhdGVJdGVtUG9zaXRpb25zKCksXG4gICAgICAgICAgICB7aXRlbVNpemV9ICAgID0gbWUsXG4gICAgICAgICAgICBpICAgICAgICAgICAgID0gMixcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgPSBNYXRoLm1pbihmcm9udEVsLmNuLmxlbmd0aCwgaXRlbVBvc2l0aW9ucy5sZW5ndGggKyAyKTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGZyb250RWwuY25baV0uc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW1TaXplICAgICAgICAgICAgICAgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBsZWZ0ICA6IGl0ZW1Qb3NpdGlvbnNbaS0yXS5sZWZ0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0b3AgICA6IGl0ZW1Qb3NpdGlvbnNbaS0yXS50b3AgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IGl0ZW1TaXplICAgICAgICAgICAgICAgICsgJ3B4J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZnJvbnRFbC5jbltpXS5jblswXS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemUgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbVNpemUgKyAncHgnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlT3V0ZXJDaXJjbGUoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1TaXplfSAgID0gbWUsXG4gICAgICAgICAgICBvdXRlckNpcmNsZSAgPSBtZS5nZXRPdXRlckNpcmNsZSgpLFxuICAgICAgICAgICAgb3V0ZXJSYWRpdXMgID0gbWUuaW5uZXJSYWRpdXMgKyBtZS5vdXRlclJhZGl1c0RlbHRhLFxuICAgICAgICAgICAgb3V0ZXJTaXplICAgID0gbWUuY29sbGFwc2VkID8gb3V0ZXJSYWRpdXMgKiAyIDogKG91dGVyUmFkaXVzICsgaXRlbVNpemUpICogMixcbiAgICAgICAgICAgIG9wdHM7XG5cbiAgICAgICAgaWYgKG1lLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG91dGVyU2l6ZSArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiAnLScgKyBvdXRlclJhZGl1cyArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wICAgOiAnLScgKyBvdXRlclJhZGl1cyArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggOiBvdXRlclNpemUgKyAncHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogb3V0ZXJTaXplICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBsZWZ0ICA6ICctJyArIChvdXRlclJhZGl1cyArIGl0ZW1TaXplKSArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wICAgOiAnLScgKyAob3V0ZXJSYWRpdXMgKyBpdGVtU2l6ZSkgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogb3V0ZXJTaXplICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRlckNpcmNsZS5zdHlsZSwgb3B0cyk7XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlVGl0bGUoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbm5lckNpcmNsZSA9IG1lLmdldElubmVyQ2lyY2xlKCk7XG5cbiAgICAgICAgaW5uZXJDaXJjbGUuY25bMF0udGV4dCA9IG1lLnN0b3JlPy5nZXRDb3VudCgpIHx8IDA7XG4gICAgICAgIGlubmVyQ2lyY2xlLmNuWzFdLnRleHQgPSBtZS50aXRsZTtcblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDaXJjbGUpO1xuIiwiaW1wb3J0IE1vZGVsIGZyb20gJy4vTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5DaXJjbGVNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5Nb2RlbFxuICovXG5jbGFzcyBDaXJjbGVNb2RlbCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uQ2lyY2xlTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uQ2lyY2xlTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLWNpcmNsZW1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi1jaXJjbGVtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkxlZnQoZGF0YSkge1xuICAgICAgICB0aGlzLm9uTmF2S2V5KGRhdGEsIC0xKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duUmlnaHQoZGF0YSkge1xuICAgICAgICB0aGlzLm9uTmF2S2V5KGRhdGEsIDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIG9uTmF2S2V5KGRhdGEsIHN0ZXApIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gICAgID0gZGF0YS5wYXRoWzBdLFxuICAgICAgICAgICAge3ZpZXd9ICAgPSBtZSxcbiAgICAgICAgICAgIHtzdG9yZX0gID0gdmlldyxcbiAgICAgICAgICAgIG1heEluZGV4ID0gTWF0aC5taW4oc3RvcmUuZ2V0Q291bnQoKSwgdmlldy5tYXhJdGVtcykgLSAxLFxuICAgICAgICAgICAgaW5kZXgsIGl0ZW1JZCwgcmVjb3JkSWQ7XG5cbiAgICAgICAgaWYgKGl0ZW0uY2xzLmluY2x1ZGVzKCduZW8tY2lyY2xlLWl0ZW0nKSkge1xuICAgICAgICAgICAgcmVjb3JkSWQgPSBwYXJzZUludCh2aWV3LmdldEl0ZW1SZWNvcmRJZChpdGVtLmlkKSk7XG4gICAgICAgICAgICBpbmRleCAgICA9IHN0b3JlLmluZGV4T2YocmVjb3JkSWQpICsgc3RlcDtcblxuICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSAgICAgICAge2luZGV4ID0gbWF4SW5kZXh9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA+IG1heEluZGV4KSB7aW5kZXggPSAwfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSAwXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtSWQgPSB2aWV3LmdldEl0ZW1JZChpbmRleCk7XG5cbiAgICAgICAgbWUuc2VsZWN0KGl0ZW1JZCk7XG4gICAgICAgIHZpZXcuZm9jdXMoaXRlbUlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoY29tcG9uZW50KTtcblxuICAgICAgICBsZXQge2lkLCB2aWV3fSA9IHRoaXM7XG5cbiAgICAgICAgdmlldy5rZXlzPy5fa2V5cy5wdXNoKFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duTGVmdCcgICxrZXk6ICdEb3duJyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgLGtleTogJ0xlZnQnICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAsa2V5OiAnUmlnaHQnICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICxrZXk6ICdVcCcgICAgLHNjb3BlOiBpZH1cbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgbGV0IHtpZCwgdmlld30gPSB0aGlzO1xuXG4gICAgICAgIHZpZXcua2V5cz8ucmVtb3ZlS2V5cyhbXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgLGtleTogJ0Rvd24nICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkxlZnQnICAsa2V5OiAnTGVmdCcgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICxrZXk6ICdSaWdodCcgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25SaWdodCcgLGtleTogJ1VwJyAgICAsc2NvcGU6IGlkfVxuICAgICAgICBdKTtcblxuICAgICAgICBzdXBlci51bnJlZ2lzdGVyKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENpcmNsZU1vZGVsKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uTW9kZWxcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKi9cbmNsYXNzIE1vZGVsIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5Nb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5Nb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLW1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYWNlaG9sZGVyIGZvciBleHRlbmRlZCBjbGFzc2VzIHRvIGFkZCBhIGN1c3RvbSBjc3MgcnVsZSB0byB0aGlzIG93bmVyIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2xzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl9IGl0ZW1zX1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIGNsb25lICAgICAgICAgOiAnc2hhbGxvdycsXG4gICAgICAgICAgICBjbG9uZU9uR2V0ICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaXNFcXVhbCAgICAgICA6ICgpID0+IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNlbGVjdGVkQ2xzPSdzZWxlY3RlZCdcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkQ2xzOiAnbmVvLXNlbGVjdGVkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZVNlbGVjdD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGVTZWxlY3Q6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbGx5IHNhdmVzIHRoZSB2aWV3IGlkLCBidXQgdGhlIGdldHRlciB3aWxsIHJldHVybiB0aGUgbWF0Y2hpbmcgaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2aWV3Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2aWV3XzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJlZm9yZSBnZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgdmlldyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfVxuICAgICAqL1xuICAgIGJlZm9yZUdldFZpZXcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lby5nZXRDb21wb25lbnQodGhpcy5fdmlldylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIHZpZXcgY29uZmlnXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIHZpZXcgaWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRWaWV3KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkRG9tTGlzdGVuZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnRdIHRydWUgdG8gcHJldmVudCBhIHZkb20gdXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0ZWRDbHNdXG4gICAgICovXG4gICAgZGVzZWxlY3QoaXRlbSwgc2lsZW50LCBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zLCBzZWxlY3RlZENscykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICAvLyBXZSBob2xkIHZkb20gaWRzIGZvciBub3csIHNvIGFsbCBpbmNvbWluZyBzZWxlY3Rpb25zIG11c3QgYmUgY29udmVydGVkLlxuICAgICAgICBpdGVtID0gaXRlbS5pc1JlY29yZCA/IHZpZXcuZ2V0SXRlbUlkKGl0ZW0pIDogTmVvLmlzT2JqZWN0KGl0ZW0pID8gaXRlbS5pZCA6IGl0ZW07XG5cbiAgICAgICAgaWYgKGl0ZW1Db2xsZWN0aW9uLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICBub2RlID0gdmlldy5nZXRWZG9tQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5yZW1vdmUobm9kZS5jbHMgfHwgW10sIHNlbGVjdGVkQ2xzIHx8IG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZVsnYXJpYS1zZWxlY3RlZCddXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShpdGVtQ29sbGVjdGlvbiwgaXRlbSk7XG5cbiAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHZpZXcucGFyZW50Py5vbkRlc2VsZWN0Py4oKTsgLy8gZ3JpZC5Db250YWluZXIgJiB0YWJsZS5Db250YWluZXJcbiAgICAgICAgICAgICAgICB2aWV3Lm9uRGVzZWxlY3Q/LigpO1xuXG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGl0ZW1Db2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBtZS5maXJlKCdub0NoYW5nZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnRdIHRydWUgdG8gcHJldmVudCBhIHZkb20gdXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtc1xuICAgICAqL1xuICAgIGRlc2VsZWN0QWxsKHNpbGVudCwgaXRlbUNvbGxlY3Rpb249dGhpcy5pdGVtcykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICA9IFsuLi5pdGVtQ29sbGVjdGlvbl0sXG4gICAgICAgICAgICB7dmlld30gPSBtZTtcblxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIG1lLmRlc2VsZWN0KGl0ZW0sIHRydWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFzaWxlbnQgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5pdGVtc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBtZS5maXJlKCdub0NoYW5nZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcG9ydGFudCBmb3IgbWFwcGluZyBsaXN0ZW5lcnMgdG8gdmlldyBjb250cm9sbGVyc1xuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldENvbnRyb2xsZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gdGhpcy5pdGVtc1xuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA+IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgaXNTZWxlY3RlZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmNsdWRlcyhpZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gY29tcG9uZW50LndyYXBwZXJDbHMgfHwgW107XG5cbiAgICAgICAgaWYgKG1lLmNscyAmJiAhY2xzLmluY2x1ZGVzKG1lLmNscykpIHtcbiAgICAgICAgICAgIGNscy5wdXNoKG1lLmNscyk7XG4gICAgICAgICAgICBjb21wb25lbnQud3JhcHBlckNscyA9IGNsc1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudmlldyA9IGNvbXBvbmVudDtcbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXIoKTtcblxuICAgICAgICBjb21wb25lbnQuZmlyZSgnc2VsZWN0aW9uTW9kZWxDaGFuZ2UnLCB7XG4gICAgICAgICAgICB2YWx1ZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZURvbUxpc3RlbmVycygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgICAgPSBtZS52aWV3LFxuICAgICAgICAgICAgZG9tTGlzdGVuZXJzID0gWy4uLmNvbXBvbmVudC5kb21MaXN0ZW5lcnNdO1xuXG4gICAgICAgIGNvbXBvbmVudC5kb21MaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIuc2NvcGUgPT09IG1lKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGRvbUxpc3RlbmVycywgbGlzdGVuZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbXBvbmVudC5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXXxTdHJpbmdbXX0gaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfFN0cmluZ1tdfSBpdGVtQ29sbGVjdGlvbj10aGlzLml0ZW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3RlZENsc11cbiAgICAgKi9cbiAgICBzZWxlY3QoaXRlbXMsIGl0ZW1Db2xsZWN0aW9uPXRoaXMuaXRlbXMsIHNlbGVjdGVkQ2xzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gW2l0ZW1zXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ICA9IG1lLFxuICAgICAgICAgICAgcmVjb3JkcyA9IGl0ZW1zLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc1JlY29yZCkgcmV0dXJuIGl0ZW07XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRJZCA9IHZpZXcuZ2V0SXRlbVJlY29yZElkPy4oaXRlbSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkSWQgJiYgdmlldy5zdG9yZT8uZ2V0KHJlY29yZElkKSB8fCBpdGVtXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBXZSBob2xkIHZkb20gaWRzIGZvciBub3csIHNvIGFsbCBpbmNvbWluZyBzZWxlY3Rpb25zIG11c3QgYmUgY29udmVydGVkLlxuICAgICAgICBpdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IGl0ZW0uaXNSZWNvcmQgPyB2aWV3LmdldEl0ZW1JZChpdGVtKSA6IE5lby5pc09iamVjdChpdGVtKSA/IGl0ZW0uaWQgOiBpdGVtKTtcblxuICAgICAgICBpZiAoIU5lby5pc0VxdWFsKGl0ZW1Db2xsZWN0aW9uLCBpdGVtcykpIHtcbiAgICAgICAgICAgIGlmIChtZS5zaW5nbGVTZWxlY3QgJiYgaXRlbUNvbGxlY3Rpb24gPT09IG1lLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwodHJ1ZSwgaXRlbUNvbGxlY3Rpb24pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHZpZXcuZ2V0VmRvbUNoaWxkKG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbHMgPSBOZW9BcnJheS5hZGQobm9kZS5jbHMgfHwgW10sIHNlbGVjdGVkQ2xzIHx8IG1lLnNlbGVjdGVkQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVsnYXJpYS1zZWxlY3RlZCddID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoaXRlbUNvbGxlY3Rpb24sIGl0ZW1zKTtcblxuICAgICAgICAgICAgaWYgKCF2aWV3LnNpbGVudFNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldy5wYXJlbnQ/Lm9uU2VsZWN0Py4oaXRlbXMpOyAvLyBncmlkLkNvbnRhaW5lciAmIHRhYmxlLkNvbnRhaW5lclxuICAgICAgICAgICAgdmlldy5vblNlbGVjdD8uKGl0ZW1zKTtcblxuICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgcmVjb3JkcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGl0ZW1Db2xsZWN0aW9uXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHJlY29yZHMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBpdGVtQ29sbGVjdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ25vQ2hhbmdlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICovXG4gICAgdG9nZ2xlU2VsZWN0aW9uKGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICAgICAgbWUuZGVzZWxlY3QoaXRlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdChpdGVtKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyA9IChtZS5pdGVtcyB8fCBbXSkubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9KU09OKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICBzZWxlY3RlZENscyA6IG1lLnNlbGVjdGVkQ2xzLFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0OiBtZS5zaW5nbGVTZWxlY3RcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gPSBtZTtcblxuICAgICAgICBpZiAoIXZpZXcuaXNEZXN0cm95aW5nKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gdmlldy53cmFwcGVyQ2xzIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAobWUuY2xzICYmIGNscy5pbmNsdWRlcyhtZS5jbHMpKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgbWUuY2xzKTtcbiAgICAgICAgICAgICAgICB2aWV3LndyYXBwZXJDbHMgPSBjbHNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwoKTtcblxuICAgICAgICAgICAgbWUucmVtb3ZlRG9tTGlzdGVuZXJzKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTW9kZWwpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9