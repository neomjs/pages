"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_treeAccordion_app_mjs-src_form_field_Base_mjs"],{

/***/ "./examples/treeAccordion/MainContainer.mjs":
/*!**************************************************!*\
  !*** ./examples/treeAccordion/MainContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_tree_Accordion_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/tree/Accordion.mjs */ "./src/tree/Accordion.mjs");
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/container/Panel.mjs */ "./src/container/Panel.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/state/Provider.mjs */ "./src/state/Provider.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../src/controller/Component.mjs */ "./src/controller/Component.mjs");









/**
 * @class Neo.examples.treeAccordion.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        className           : 'Neo.examples.treeAccordion.MainContainer',
        autoMount           : true,
        configItemLabelWidth: 100,
        configItemWidth     : 230,
        layout              : {ntype: 'hbox', align: 'stretch'},
        cls                 : ['examples-container-accordion']
    }

    createConfigurationComponents() {
        let me       = this,
            treeList = me.exampleComponent.items[0];

        return [{
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            checked       : treeList.rootParentsAreCollapsible,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'rootParentsAreCollapsible')},
            valueLabelText: 'rootParentsAreCollapsible'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            checked       : treeList.firstParentIsVisible,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'firstParentIsVisible')},
            style         : {marginTop: '10px'},
            valueLabelText: 'firstParentIsVisible'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            checked       : treeList.showIcon,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'showIcon')},
            style         : {marginTop: '10px'},
            valueLabelText: 'showIcon'
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable: true,
            labelText: 'height',
            listeners: {change: me.onConfigChange.bind(me, 'height')},
            maxValue : 1200,
            minValue : 250,
            stepSize : 50,
            value    : 650,
            style    : {marginTop: '10px'}
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable: true,
            labelText: 'width',
            listeners: {change: me.onConfigChange.bind(me, 'width')},
            maxValue : 1200,
            minValue : 200,
            stepSize : 3,
            style    : {marginTop: '10px'},
            value    : 400
        }, {
            ntype  : 'button',
            handler: me.onRemoveDomButtonClick.bind(me),
            style  : {marginTop: '20px'},
            text   : 'Remove DOM',
            width  : 100
        }]
    }

    /**
     * @returns {*}
     */
    createExampleComponent() {
        const me    = this,
              store = Neo.create(_src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_6__["default"], {
                  keyProperty: 'id',
                  model      : {
                      fields: [
                          {name: 'collapsed', type: 'Boolean'},
                          {name: 'content', type: 'String'},
                          {name: 'iconCls', type: 'String'},
                          {name: 'id', type: 'Integer'},
                          {name: 'isLeaf', type: 'Boolean'},
                          {name: 'name', type: 'String'},
                          {name: 'parentId', type: 'Integer'}
                      ]
                  },

                  autoLoad: true,
                  url     : '../../examples/treeAccordion/tree.json'
              });

        return Neo.ntype({
            ntype: 'container',

            stateProvider: {
                data: {
                    selection: [{name: 'Please select something'}]
                }
            },

            layout: {ntype: 'hbox', align: 'stretch'},
            items : [{
                module: _src_tree_Accordion_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],

                bind: {selection: {twoWay: true, value: data => data.selection}},

                store: store,

                /**
                 * We are using data-binding.
                 * Here is an example for listener and controller
                 */
                // controller: {
                //     module: ViewController,
                //
                //     onAccordionItemClick(record) {
                //         let viewport = Neo.get('neo-configuration-viewport-1'),
                //             outputEl = viewport.getReference('output');
                //
                //         outputEl.html = record.name;
                //     }
                // },
                //
                // listeners: {
                //     leafItemClick: 'onAccordionItemClick'
                // }

                listeners: {
                    selectPreFirstItem: () => Neo.log('listener selectPreFirstItem fired'),
                    selectPostLastItem: () => Neo.log('listener selectPostLastItem fired')
                }
            }, {
                module: _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                height: 150,
                flex : 1,

                itemDefaults: {
                    style: {
                        padding: '10px'
                    }
                },

                headers: [{
                    dock : 'top',
                    style: {borderRightColor: 'transparent'},

                    items: [{
                        ntype: 'label',
                        text : 'Accordion Selection'
                    }]
                }],

                items: [{
                    ntype    : 'component',
                    reference: 'output',
                    bind     : {html: data => data.selection[0].name}
                }]
            }]
        })
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        this.exampleComponent.items[0][config] = opts.value
    }

    /**
     *
     * @param data
     */
    onRemoveDomButtonClick(data) {
        let accordion = this.exampleComponent.items[0];
        accordion.hidden = !accordion.hidden
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./examples/treeAccordion/app.mjs":
/*!****************************************!*\
  !*** ./examples/treeAccordion/app.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/treeAccordion/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.treeAccordion'
});


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");




/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me,
            listenerId;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            listenerId = component.on('constructed', () => {
                component.un('constructed', listenerId);
                me.onComponentConstructed()
            })
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            const handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me = this,
            {handler, listeners, reference, validator} = component,
            eventHandler, handlerScope;

        if (handler && typeof handler === 'string') {
            handlerScope = me.getHandlerScope(handler, component);

            // If the handler name was not resolved in the Component itself, bind it
            if (handlerScope !== true) {
                component.handler = handlerScope[handler].bind(component.handlerScope || handlerScope);
            }
        }

        listeners && Object.entries(listeners).forEach(([key, value]) => {
            if (key !== 'scope' && key !== 'delegate') {
                if (Neo.isString(value)) {
                    eventHandler = value;
                    handlerScope = me.getHandlerScope(eventHandler, component);

                    if (!handlerScope) {
                        _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].logError('Unknown event handler for', eventHandler, component)
                    } else if (handlerScope !== true) {
                        listeners[key] = {};
                        listeners[key].fn = handlerScope[eventHandler].bind(handlerScope)
                    }
                } else {
                    value.forEach(listener => {
                        if (Neo.isObject(listener) && listener.hasOwnProperty('fn') && Neo.isString(listener.fn)) {
                            eventHandler = listener.fn;
                            handlerScope = me.getHandlerScope(eventHandler, component);

                            if (!handlerScope) {
                                console.error('Unknown event handler for', eventHandler, component)
                            } else if (handlerScope !== true) {
                                listener.fn = handlerScope[eventHandler].bind(handlerScope)
                            }
                        }
                    })
                }
            }
        });

        if (Neo.isString(validator)) {
            handlerScope = me.getHandlerScope(validator);

            if (!handlerScope) {
                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].logError('Unknown validator for', component.id, component)
            } else {
                component.validator = handlerScope[validator].bind(handlerScope)
            }
        }

        if (reference) {
            me.references[reference] = component
        }
    }

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseDomListeners(component=this.component) {
        let me             = this,
            {domListeners} = component,
            eventHandler, scope;

        domListeners?.forEach(domListener => {
            Object.entries(domListener).forEach(([key, value]) => {
                eventHandler = null;

                if (key !== 'scope' && key !== 'delegate') {
                    if (Neo.isString(value)) {
                        eventHandler = value;
                    } else if (Neo.isObject(value) && value.hasOwnProperty('fn') && Neo.isString(value.fn)) {
                        eventHandler = value.fn;
                    }

                    if (eventHandler) {
                        scope = me.getHandlerScope(eventHandler);

                        // There can be string based listeners like 'up.onClick', which will resolved inside manager.DomEvents
                        // => Do nothing in case there is no match inside the controller hierarchy.
                        if (scope) {
                            domListener[key] = scope[eventHandler].bind(scope)
                        }
                    }
                }
            })
        })
    }

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/form/field/Base.mjs":
/*!*********************************!*\
  !*** ./src/form/field/Base.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * Abstract base class for form fields
 * @class Neo.form.field.Base
 * @extends Neo.component.Base
 */
class Base extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for isTouchedEvent
     * @member {String[]} isTouchedEvents=['focusEnter','focusLeave']
     * @protected
     * @static
     */
    static isTouchedEvents = ['focusEnter', 'focusLeave']

    static config = {
        /**
         * @member {String} className='Neo.form.field.Base'
         * @protected
         */
        className: 'Neo.form.field.Base',
        /**
         * @member {String} ntype='basefield'
         * @protected
         */
        ntype: 'basefield',
        /**
         * Form groups can get set on any parent component level.
         * An alternative way for using dots in field names.
         * @member {String|null} formGroup_=null
         */
        formGroup_: null,
        /**
         * True indicates that a user has interacted with the form field
         * @member {Boolean} isTouched_=false
         */
        isTouched_: false,
        /**
         * Event name which sets isTouched to true. Valid options are 'focusEnter' & 'focusLeave'
         * @member {String} isTouched_=false
         */
        isTouchedEvent_: 'focusLeave',
        /**
         * @member {String|null} name_=null
         */
        name_: null,
        /**
         * Neo itself does not need field names to get mapped to the DOM (input nodes),
         * except for CheckBoxes & Radios to work. It can be useful for testing tools
         * & accessibility though, so the default got set to true.
         * Feel free to change it to false to keep the DOM minimal.
         * @member {Boolean} renderName_=true
         */
        renderName_: true,
        /**
         * In case renderName is set to true, you can optionally render the combination
         * of all formGroup(s) & the field name into the DOM => input node
         * @member {Boolean} renderPath=true
         */
        renderPath: true,
        /**
         * @member {*} value_=null
         */
        value_: null
    }

    /**
     * An internal cache for formGroups of all parent levels
     * @member {String|null} formGroupString=null
     */
    formGroupString = null
    /**
     * Base implementation to check if the fields value has changed.
     * Can get overridden in superclasses.
     * @returns {Boolean}
     */
    get isDirty() {
        return !Neo.isEqual(this.getSubmitValue(), this.originalConfig.value)
    }
    /**
     * An internal cache for formGroup(s) and the field name
     * @member {String|null} path=null
     */
    path = null

    /**
     * Triggered after the name isTouched got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetIsTouched(value, oldValue) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'neo-is-touched', value);
        this.cls = cls
    }

    /**
     * Triggered after the name config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetName(value, oldValue) {
        let me = this;

        me.renderName && me.changeInputElKey('name', me.renderPath ? me.getPath() : value)
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.getInputEl().role = value;
        this.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {*} value
     * @param {*} oldValue
     */
    afterSetValue(value, oldValue) {
        oldValue !== undefined && this.fireChangeEvent(value, oldValue)
    }

    /**
     * Triggered when accessing the formGroup config
     * @param {String|null} value
     * @returns {String|null} parents
     * @protected
     */
    beforeGetFormGroup(value) {
        let me    = this,
            group = [],
            returnValue;

        if (me.formGroupString) {
            return me.formGroupString
        }

        value && group.push(value);

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
            parent.formGroup && group.unshift(parent.formGroup)
        });

        returnValue = group.join('.');

        me.formGroupString = returnValue;

        return returnValue
    }

    /**
     * Triggered before the isTouchedEvent config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetIsTouchedEvent(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'isTouchedEvent')
    }

    /**
     * Changes the value of a inputEl vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     * @param {Boolean} silent=false
     */
    changeInputElKey(key, value, silent=false) {
        let me = this;

        if (value || Neo.isBoolean(value) || value === 0) {
            me.getInputEl()[key] = value
        } else {
            delete me.getInputEl()[key]
        }

        !silent && me.update()
    }

    /**
     * Override this method as needed
     * @param {*}      value
     * @param {*}      oldValue
     * @param {String} eventName
     */
    doFireChangeEvent(value, oldValue, eventName) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            formEvent     = 'field' + Neo.capitalize(eventName),
            opts          = {component: me, oldValue, value};

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        me.fire(eventName, opts);

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire(formEvent, opts)
                }
            })
        }
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'change')
    }

    /**
     * Override this method as needed
     * @param {*} value
     * @param {*} oldValue
     */
    fireUserChangeEvent(value, oldValue) {
        this.doFireChangeEvent(value, oldValue, 'userChange')
    }

    /**
     * Forms in neo can be nested. This method will return the closest parent which is a form.Container or null.
     * @returns {Neo.form.Container|null}
     */
    getClosestForm() {
        let me            = this,
            FormContainer = Neo.form?.Container,
            parent;

        for (parent of _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me)) {
            if (FormContainer && parent instanceof FormContainer) {
                return parent
            }
        }

        return null
    }

    /**
     * Override this method as needed
     * @returns {Object|null}
     */
    getInputEl() {
        return this.vdom
    }

    /**
     * Returns the combination of the field formGroup(s) & name
     * @returns {String|null}
     */
    getPath() {
        let me = this,
            path;

        // fields could have formGroups, but no name.
        // returning the namespace can confuse form.Container.adjustTreeLeaves(),
        // since namespaces could be considered as field instances.
        if (!me.name) {
            return null
        }

        if (!me.path) {
            path = me.formGroup ? me.formGroup.split('.') : [];

            me.name && path.push(me.name);

            if (path.length < 1) {
                return null
            }

            me.path = path.join('.');
        }

        if (!me.path) {
            me.path = 'none'
        }

        return me.path === 'none' ? null: me.path
    }

    /**
     * @returns {*}
     */
    getSubmitValue() {
        return this.value
    }

    /**
     * @deprecated in v7.x
     * @returns {*}
     */
    getValue() {
        return this.getSubmitValue()
    }

    /**
     * @returns {Boolean}
     */
    isValid() {
        return true
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        super.onFocusLeave(data);

        if (this.isTouchedEvent === 'focusEnter') {
            this.isTouched = true
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        super.onFocusLeave(data);

        let me            = this,
            FormContainer = Neo.form?.Container,
            opts          = {...data, component: me, value: me.getSubmitValue()};

        if (me.isTouchedEvent === 'focusLeave') {
            me.isTouched = true
        }

        if (Neo.isFunction(me.getGroupValue)) {
            opts.groupValue = me.getGroupValue()
        }

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldFocusLeave', opts)
                }
            })
        }
    }

    /**
     * Resets the field to a new value or null
     * @param {*} value=null
     */
    reset(value=null) {
        this.originalConfig.value = value;
        this.value = value
    }

    /**
     * Checks for client-side field errors
     * @param {Boolean} silent=true
     * @returns {Boolean} Returns true in case there are no client-side errors
     */
    validate(silent=true) {
        return true
    }
}

/**
 * The change event fires after the value config gets changed
 * @event change
 * @param {*} value
 * @param {*} oldValue
 * @returns {Object}
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/selection/TreeAccordionModel.mjs":
/*!**********************************************!*\
  !*** ./src/selection/TreeAccordionModel.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TreeModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeModel.mjs */ "./src/selection/TreeModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.selection.TreeAccordionModel
 * @extends Neo.selection.TreeModel
 */
class TreeAccordionModel extends _TreeModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.TreeAccordionModel'
         * @protected
         */
        className: 'Neo.selection.TreeAccordionModel',
        /**
         * @member {String} ntype='selection-treeaccordionmodel'
         * @protected
         */
        ntype: 'selection-treeaccordionmodel'
    }

    /**
     * Tries to find a child and returns it
     * @param {Object} record
     * @returns {Object|null}
     */
    checkForChild(record) {
        let {view}      = this,
            recordId    = record[view.getKeyProperty()],
            childRecord = null;

        for (const item of view.store.items) {
            if (item.parentId === recordId) {
                childRecord = item;
                break
            }
        }

        return childRecord
    }

    /**
     * Return the parent record if any
     * @param {Object} record
     * @returns {Object|null}
     */
    checkForParent({parentId}) {
        return parentId ? this.view.store.get(parentId) : null
    }

    /**
     * Depending on {-1|1} step return
     * -1: previous record OR parent record
     *  1: next record or null
     *
     * @param {Object} record
     * @param {Number} step
     * @returns {Object|null}
     */
    checkForSibling(record, step) {
        let {view}         = this,
            {store}        = view,
            parentRecordId = record.parentId,
            recordId       = record[view.getKeyProperty()],
            hasFoundNext   = false,
            nextItemRecord = null,
            previousItemRecord;

        for (let item of store.items) {
            if (hasFoundNext && item.parentId === parentRecordId) {
                nextItemRecord = item;
                break
            }

            if (!hasFoundNext && item.parentId === parentRecordId) {
                if (!hasFoundNext && item[view.getKeyProperty()] === recordId) {
                    if (step === -1) break;
                    hasFoundNext = true
                } else {
                    previousItemRecord = item
                }
            }
        }

        return step === 1 ? nextItemRecord : (previousItemRecord || store.get(parentRecordId))
    }

    /**
     * Find the next sibling of a parent item
     * @param {Object} record
     * @returns {Object|null}
     */
    checkNextParentSibling(record) {
        let me            = this,
            parent        = me.view.store.get(record.parentId),
            parentSibling = me.checkForSibling(parent, 1);

        if (!parentSibling && parent.parentId) {
            me.checkNextParentSibling(parent)
        }

        return parentSibling
    }

    /**
     * Called by keys (List.mjs:register)
     * Toggle collapse or if isLeaf select next item
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        let me     = this,
            {view} = me,
            itemId = me.getSelection()[0],
            record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || record.collapsed) {
            me.onKeyDownRight(data)
        } else {
            me.onKeyDownLeft(data)
        }
    }

    /**
     * Called by keys (List.mjs:register)
     * Deselect all and fire event selectPostLastItem
     * @param {Object} data
     */
    onKeyDownEscape(data) {
        this.deselectAll()
    }

    /**
     * Collapse folder or select previous
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        let me     = this,
            {view} = me,
            itemId = me.getSelection()[0],
            record;

        if (!itemId) {
            me.selectRoot();
            return
        }

        record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || record.collapsed || !view.rootParentsAreCollapsible) {
            me.onNavKey(data, -1)
        } else {
            me.toggleCollapsed(record, itemId, true)
        }
    }

    /**
     * Open folder or select next
     * @param {Object} data
     */
    onKeyDownRight(data) {
        let me     = this,
            {view} = me,
            itemId = me.getSelection()[0],
            record;

        if (!itemId) {
            me.selectRoot();
            return
        }

        record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || !record.collapsed) {
            me.onNavKey(data, 1)
        } else {
            me.toggleCollapsed(record, itemId, false)
        }
    }

    /**
     * Handles 'up' and 'down' keys
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        let me     = this,
            {view} = me,
            item   = me.getSelection()[0],
            newRecord, record, recordId;

        if (item) {
            recordId = view.getItemRecordId(item);
            record   = view.store.get(recordId);

            if (step === 1) {
                if (!record.isLeaf && !record.collapsed) {
                    // find first child
                    newRecord = me.checkForChild(record)
                } else {
                    // find next sibling
                    newRecord = me.checkForSibling(record, step);
                    // no ==> loop through parent next siblings until no parent
                    if (!newRecord) {
                        newRecord = me.checkNextParentSibling(record)
                    }
                }
                // current item was the last item
                if (!newRecord) {
                    me.deselectAll();
                    view.fire('selectPostLastItem')
                }
            } else if (step === -1) {
                // check previous sibling
                newRecord = me.checkForSibling(record, step);
                // no ==> get parent
                if (!newRecord) {
                    newRecord = me.checkForParent(record)
                }
                // current item was the first item
                if (!newRecord) {
                    me.deselectAll();
                    view.fire('selectPreFirstItem')
                }
            }
        } else {
            me.selectRoot()
        }

        if (newRecord) {
            const itemId = view.getItemId(newRecord[me.view.getKeyProperty()]);

            me.selectAndScrollIntoView(itemId)
        }
    }

    /**
     * Select an item and scroll the tree to show the item in the center
     * @param {String} itemId
     */
    selectAndScrollIntoView(itemId) {
        this.select(itemId);

        Neo.main.DomAccess.scrollIntoView({
            id      : itemId,
            block   : 'center',
            windowId: this.view.windowId
        })
    }

    /**
     * Select the root item of the tree
     */
    selectRoot() {
        let {view}  = this,
            {store} = view,
            record, rootItemId;

        for (record of store.items) {
            if (!record.parentId) {
                rootItemId = view.getItemId(record[view.getKeyProperty()]);
                break
            }
        }

        this.selectAndScrollIntoView(rootItemId)
    }

    /**
     * Return the parent record if any
     * @param {Object} record
     * @param {String} itemId
     * @param {Boolean} collapse
     */
    toggleCollapsed(record, itemId, collapse) {
        let item  = this.view.getVdomChild(itemId),
            clsFn = collapse ? 'remove' : 'add';

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][clsFn](item.cls, 'neo-folder-open');
        this.view.update();

        record.collapsed = collapse
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeAccordionModel));


/***/ }),

/***/ "./src/tree/Accordion.mjs":
/*!********************************!*\
  !*** ./src/tree/Accordion.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _tree_List_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/List.mjs */ "./src/tree/List.mjs");
/* harmony import */ var _selection_TreeAccordionModel_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../selection/TreeAccordionModel.mjs */ "./src/selection/TreeAccordionModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.tree.Accordion
 * @extends Neo.tree.List
 *
 * Accordion Store expects the following fields
 *
 *      [
 *          iconCls,        // can be defined in fields:icon
 *          content,        // can be defined in fields:text
 *          name,           // can be defined in fields:header
 *
 *          collapsed,      // collapsed state for non-leaf-items
 *          isLeaf,         // defines it item is leaf-item
 *          id,             // defines item id
 *          parentId        // leaf or sub-items need a parentId
 *      ]
 *
 */
class AccordionTree extends _tree_List_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tree.Accordion'
         * @protected
         */
        className: 'Neo.tree.Accordion',
        /**
         * @member {String} ntype='treeaccordion'
         * @protected
         */
        ntype: 'treeaccordion',
        /**
         * @member {String[]} baseCls=['neo-tree-accordion']
         */
        baseCls: ['neo-tree-list'],
        /**
         * Define the field names for the store to show header, text and icon
         * @member {Object} fields={header:'name',icon:'iconCls',text:'content'}
         */
        fields: {
            header: 'name',
            icon  : 'iconCls',
            text  : 'content'
        },
        /**
         * Set to false to hide the initial root item
         * @member {Boolean} firstParentIsVisible=true
         */
        firstParentIsVisible_: true,
        /**
         * Set to false will auto expand root parent items and disallow collapsing
         * @member {Boolean} rootParentIsCollapsible=false
         */
        rootParentsAreCollapsible_: false,
        /**
         * Currently selected item, which is bindable
         * @member {Record[]|null} selection=null
         *
         * @example
         *     module: AccordionTree,
         *     bind  : {selection: {twoWay: true, value: data => data.selection}}
         *
         *     ntype: 'component',
         *     bind : {html: data => data.selection[0].name}
         */
        selection_: null,
        /**
         * Set to false will hide the icons for all leaf items
         * @member {Boolean} showIcon=true
         */
        showIcon_: true,
        /**
         * @member {Boolean} showCollapseExpandAllIcons=true
         */
        showCollapseExpandAllIcons: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'ul', cls: ['neo-list-container', 'neo-list', 'neo-accordion-style'], cn: []}
        ]}
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.addDomListeners({
            focusin: me.onFocus,
            scope  : me
        })
    }

    /**
     * Called when changing firstParentIsVisible
     * First store item gets marked and additional css class
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetFirstParentIsVisible(value, oldValue) {
        let firstRecord = this.store.first();

        this.toggleCls('first-parent-not-visible', !value);

        if (firstRecord) {
            firstRecord.visible = value
        }
    }

    /**
     * Called when changing rootParentsAreCollapsible
     * Ensures that root items are expanded if not collapsible
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetRootParentsAreCollapsible(value, oldValue) {
        let me = this;

        me[!value ? 'addCls' : 'removeCls']('root-not-collapsible');

        if (me.rendered && value === false) {
            let {store} = me;

            store.items.forEach(record => {
                if (record.parentId === null && !record.isLeaf) {
                    me.expandItem(record)
                }
            })
        }
    }

    /**
     * Called when changing showIcon
     * Changes the display of the icons
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetShowIcon(value, oldValue) {
        const me      = this,
              {store} = me,
              hide    = !value;

        store.items.forEach((record) => {
            const itemId   = me.getItemId(record[me.getKeyProperty()]),
                  vdom     = me.getVdomChild(itemId),
                  itemVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(vdom, 'iconCls');

            if (record.isLeaf) {
                itemVdom.removeDom = hide
            }
        })

        me.update()
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_TreeAccordionModel_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])
    }

    /**
     * Remove all items from the accordion
     * If you do not need to update the view after clearing, set `withUpdate = false`
     *
     * @param {Boolean} [withUpdate=true]
     */
    clear(withUpdate=true) {
        delete this.getVdomRoot().cn[0].cn

        withUpdate && this.update()
    }

    /**
     * Remove all items from the selection
     */
    clearSelection() {
        this.selectionModel.deselectAll();
    }

    /**
     * @param {String} [parentId] The parent node
     * @param {Object} [vdomRoot] The vdom template root for the current sub tree
     * @param {Number} level The hierarchy level of the tree
     * @returns {Object} vdomRoot
     * @protected
     */
    createItems(parentId, vdomRoot, level) {
        let me                   = this,
            {folderCls, itemCls} = me,
            items                = me.store.find('parentId', parentId),
            cls, id, itemIconCls, tmpRoot;

        if (items.length > 0) {
            if (!vdomRoot.cn) {
                vdomRoot.cn = []
            }

            if (parentId !== null) {
                vdomRoot.cn.push({
                    tag: 'ul',
                    cls: ['neo-list'],
                    cn : [],
                    id : `${me.id}__${parentId}__ul`
                });

                tmpRoot = vdomRoot.cn[vdomRoot.cn.length - 1]
            } else {
                tmpRoot = vdomRoot
            }

            items.forEach(item => {
                cls         = [itemCls];
                itemIconCls = ['neo-accordion-item-icon'];

                if (item.iconCls) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemIconCls, item.iconCls.split(' '))
                }

                if (item.isLeaf) {
                    cls.push(itemCls + (item.singleton ? '-leaf-singleton' : '-leaf'))
                } else {
                    cls.push(folderCls);

                    if (!item.parentId && !me.rootParentsAreCollapsible) {
                        cls.push('neo-not-collapsible');

                        if (item.collapsed) {
                            item.collapsed = false
                        }
                    }

                    if (!item.collapsed) {
                        cls.push('neo-folder-open')
                    }
                }

                id = me.getItemId(item.id);

                tmpRoot.cn.push({
                    tag     : 'li',
                    tabIndex: -1,
                    cls,
                    id,
                    cn      : [{
                        flag     : 'iconCls',
                        tag      : 'span',
                        cls      : itemIconCls,
                        id       : id + '__icon',
                        removeDom: (!item.isLeaf || !me.showIcon)
                    }, {
                        cls  : [itemCls + '-content'],
                        id   : id + '__item-content',
                        style: {pointerEvents: 'none'},
                        cn   : [{
                            flag     : 'name',
                            tag      : 'span',
                            cls      : [itemCls + '-content-header'],
                            id       : id + '__item-content-header',
                            innerHTML: item[me.fields.header]
                        }, {
                            flag     : 'content',
                            tag      : 'span',
                            cls      : [itemCls + '-content-text'],
                            id       : id + '__item-content-text',
                            innerHTML: item[me.fields.text]
                        }]
                    }],
                    style: {
                        position: item.isLeaf ? null : 'sticky',
                        top     : item.isLeaf ? null : (level * 38) + 'px',
                        zIndex  : item.isLeaf ? null : (20 / (level + 1)),
                    }
                });

                tmpRoot = me.createItems(item.id, tmpRoot, level + 1)
            })
        }

        return vdomRoot
    }


    /**
     * Expands an item based on the record
     * @param {Object} record
     */
    expandItem(record) {
        let me     = this,
            itemId = me.getItemId(record[me.getKeyProperty()]),
            item   = me.getVdomChild(itemId);

        record.collapsed = false;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(item.cls, 'neo-folder-open');
        me.update()
    }

    /**
     * @param {Object} item
     * @param {Object} data
     */
    onItemClick(item, data) {
        super.onItemClick(item, data);

        let me               = this,
            {selectionModel} = me,
            itemId           = item.id,
            id               = Number(itemId.split('__')[1]),
            record           = me.store.get(id);

        selectionModel.select(item.id);

        if (!record.isLeaf) {
            /**
             * The folderItemClick event fires when a click occurs on a list item which does have child items.
             * Passes the item record to the event handler.
             * @event folderItemClick
             * @returns {Object} record
             */
            me.fire('folderItemClick', {record});

            record.collapsed = !record.collapsed
        }
    }

    /**
     * To place the root item at the correct location
     * @returns {Object}
     */
    getListItemsRoot() {
        return this.vdom.cn[0]
    }

    /**
     * Accordion gaining focus without selection => setSelection
     * @param {Object} data
     */
    onFocus(data) {
        let me               = this,
            {selectionModel} = me,
            selection        = selectionModel.getSelection()[0];

        !selection && selectionModel.selectRoot()
    }

    /**
     * Called from SelectionModel select()
     * @param {String[]} value
     */
    onSelect(value) {
        let me      = this,
            records = [];

        value.forEach((selectItemId) => {
            let id     = me.getItemRecordId(selectItemId),
                record = me.store.get(id);

            records.push(record)
        });

        me.selection = records
    }

    /**
     * After the store loaded, create the items for the list
     * @param {Record[]} records
     */
    onStoreLoad(records) {
        let me = this;

        me.clear(false);

        if (!me.mounted && me.rendering) {
            me.on('mounted', () => {
                me.createItems(null, me.getListItemsRoot(), 0);
                me.update()
            }, me, {once: true})
        } else {
            me.createItems(null, me.getListItemsRoot(), 0);
            me.update()
        }
    }

    /**
     * Update a record
     * @param {Object}         data
     * @param {Object[]}       data.fields
     * @param {Number}         data.index
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     */
    onStoreRecordChange(data) {
        let me               = this,
            {fields, record} = data,
            itemId           = me.getItemId(record[me.getKeyProperty()]),
            vdom             = me.getVdomChild(itemId),
            itemVdom;

        fields.forEach((field) => {
            itemVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(vdom, field.name);

            if (itemVdom) {
                if (field.name === 'iconCls') {
                    let clsItems = field.value.split(' '),
                        cls      = ['neo-accordion-item-icon'];

                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, clsItems);
                    itemVdom.cls = cls
                } else {
                    itemVdom.html = field.value
                }
            }
        });

        me.update()
    }

    /**
     * Set the selection either bei record id or record.
     * You can pass a record or a recordId as value
     *
     * @param {Record|Record[]|Number|Number[]|String|String[]} value
     */
    setSelection(value) {
        if (value === null) {
            this.clearSelection();
            return
        }

        // In case you pass in an array use only the first item
        if (Neo.isArray(value)) {
            value = value[0]
        }

        let me = this,
            recordKeyProperty, elId;

        if (Neo.isRecord(value)) {
            recordKeyProperty = value[me.getKeyProperty()];
        } else {
            // RecordId
            recordKeyProperty = value;
        }

        elId = me.getItemId(recordKeyProperty);

        me.selectionModel.selectAndScrollIntoView(elId)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AccordionTree));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX3RyZWVBY2NvcmRpb25fYXBwX21qcy1zcmNfZm9ybV9maWVsZF9CYXNlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDSztBQUNMO0FBQ0c7QUFDRjtBQUNEO0FBQ0o7QUFDVTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLG9FQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnRUFBZ0U7QUFDN0Y7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLG9FQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyREFBMkQ7QUFDeEYsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBLFNBQVM7QUFDVCw0QkFBNEIsb0VBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtDQUErQztBQUM1RSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsU0FBUztBQUNULHVCQUF1QixrRUFBVztBQUNsQztBQUNBO0FBQ0Esd0JBQXdCLDZDQUE2QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1QsdUJBQXVCLGtFQUFXO0FBQ2xDO0FBQ0E7QUFDQSx3QkFBd0IsNENBQTRDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RCwyQkFBMkIsZ0NBQWdDO0FBQzNELDJC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QUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9CLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHNEQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdURBQVE7QUFDNUI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBaUQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy90cmVlQWNjb3JkaW9uL01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy90cmVlQWNjb3JkaW9uL2FwcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL1RyZWVBY2NvcmRpb25Nb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90cmVlL0FjY29yZGlvbi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFjY29yZGlvblRyZWUgICAgICAgICBmcm9tICcuLi8uLi9zcmMvdHJlZS9BY2NvcmRpb24ubWpzJztcbmltcG9ydCBDaGVja0JveCAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vc3JjL2Zvcm0vZmllbGQvQ2hlY2tCb3gubWpzJztcbmltcG9ydCBDb25maWd1cmF0aW9uVmlld3BvcnQgZnJvbSAnLi4vQ29uZmlndXJhdGlvblZpZXdwb3J0Lm1qcyc7XG5pbXBvcnQgTnVtYmVyRmllbGQgICAgICAgICAgIGZyb20gJy4uLy4uL3NyYy9mb3JtL2ZpZWxkL051bWJlci5tanMnO1xuaW1wb3J0IFBhbmVsICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi9zcmMvY29udGFpbmVyL1BhbmVsLm1qcyc7XG5pbXBvcnQgU3RhdGVQcm92aWRlciAgICAgICAgIGZyb20gJy4uLy4uL3NyYy9zdGF0ZS9Qcm92aWRlci5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi9zcmMvZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFZpZXdDb250cm9sbGVyICAgICAgICBmcm9tICcuLi8uLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmV4YW1wbGVzLnRyZWVBY2NvcmRpb24uTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmV4YW1wbGVzLkNvbmZpZ3VyYXRpb25WaWV3cG9ydFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgQ29uZmlndXJhdGlvblZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWUgICAgICAgICAgIDogJ05lby5leGFtcGxlcy50cmVlQWNjb3JkaW9uLk1haW5Db250YWluZXInLFxuICAgICAgICBhdXRvTW91bnQgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgY29uZmlnSXRlbUxhYmVsV2lkdGg6IDEwMCxcbiAgICAgICAgY29uZmlnSXRlbVdpZHRoICAgICA6IDIzMCxcbiAgICAgICAgbGF5b3V0ICAgICAgICAgICAgICA6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgY2xzICAgICAgICAgICAgICAgICA6IFsnZXhhbXBsZXMtY29udGFpbmVyLWFjY29yZGlvbiddXG4gICAgfVxuXG4gICAgY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudHMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0cmVlTGlzdCA9IG1lLmV4YW1wbGVDb21wb25lbnQuaXRlbXNbMF07XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogQ2hlY2tCb3gsXG4gICAgICAgICAgICBjaGVja2VkICAgICAgIDogdHJlZUxpc3Qucm9vdFBhcmVudHNBcmVDb2xsYXBzaWJsZSxcbiAgICAgICAgICAgIGhpZGVMYWJlbCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgaGlkZVZhbHVlTGFiZWw6IGZhbHNlLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgICA6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdyb290UGFyZW50c0FyZUNvbGxhcHNpYmxlJyl9LFxuICAgICAgICAgICAgdmFsdWVMYWJlbFRleHQ6ICdyb290UGFyZW50c0FyZUNvbGxhcHNpYmxlJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogQ2hlY2tCb3gsXG4gICAgICAgICAgICBjaGVja2VkICAgICAgIDogdHJlZUxpc3QuZmlyc3RQYXJlbnRJc1Zpc2libGUsXG4gICAgICAgICAgICBoaWRlTGFiZWwgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGhpZGVWYWx1ZUxhYmVsOiBmYWxzZSxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICAgOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnZmlyc3RQYXJlbnRJc1Zpc2libGUnKX0sXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgIDoge21hcmdpblRvcDogJzEwcHgnfSxcbiAgICAgICAgICAgIHZhbHVlTGFiZWxUZXh0OiAnZmlyc3RQYXJlbnRJc1Zpc2libGUnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgOiBDaGVja0JveCxcbiAgICAgICAgICAgIGNoZWNrZWQgICAgICAgOiB0cmVlTGlzdC5zaG93SWNvbixcbiAgICAgICAgICAgIGhpZGVMYWJlbCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgaGlkZVZhbHVlTGFiZWw6IGZhbHNlLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgICA6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdzaG93SWNvbicpfSxcbiAgICAgICAgICAgIHN0eWxlICAgICAgICAgOiB7bWFyZ2luVG9wOiAnMTBweCd9LFxuICAgICAgICAgICAgdmFsdWVMYWJlbFRleHQ6ICdzaG93SWNvbidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBOdW1iZXJGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ2hlaWdodCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdoZWlnaHQnKX0sXG4gICAgICAgICAgICBtYXhWYWx1ZSA6IDEyMDAsXG4gICAgICAgICAgICBtaW5WYWx1ZSA6IDI1MCxcbiAgICAgICAgICAgIHN0ZXBTaXplIDogNTAsXG4gICAgICAgICAgICB2YWx1ZSAgICA6IDY1MCxcbiAgICAgICAgICAgIHN0eWxlICAgIDoge21hcmdpblRvcDogJzEwcHgnfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IE51bWJlckZpZWxkLFxuICAgICAgICAgICAgY2xlYXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnd2lkdGgnLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnd2lkdGgnKX0sXG4gICAgICAgICAgICBtYXhWYWx1ZSA6IDEyMDAsXG4gICAgICAgICAgICBtaW5WYWx1ZSA6IDIwMCxcbiAgICAgICAgICAgIHN0ZXBTaXplIDogMyxcbiAgICAgICAgICAgIHN0eWxlICAgIDoge21hcmdpblRvcDogJzEwcHgnfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogNDAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG50eXBlICA6ICdidXR0b24nLFxuICAgICAgICAgICAgaGFuZGxlcjogbWUub25SZW1vdmVEb21CdXR0b25DbGljay5iaW5kKG1lKSxcbiAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5Ub3A6ICcyMHB4J30sXG4gICAgICAgICAgICB0ZXh0ICAgOiAnUmVtb3ZlIERPTScsXG4gICAgICAgICAgICB3aWR0aCAgOiAxMDBcbiAgICAgICAgfV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBjcmVhdGVFeGFtcGxlQ29tcG9uZW50KCkge1xuICAgICAgICBjb25zdCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICAgIHN0b3JlID0gTmVvLmNyZWF0ZShTdG9yZSwge1xuICAgICAgICAgICAgICAgICAga2V5UHJvcGVydHk6ICdpZCcsXG4gICAgICAgICAgICAgICAgICBtb2RlbCAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2NvbGxhcHNlZCcsIHR5cGU6ICdCb29sZWFuJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnY29udGVudCcsIHR5cGU6ICdTdHJpbmcnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdpY29uQ2xzJywgdHlwZTogJ1N0cmluZyd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2lkJywgdHlwZTogJ0ludGVnZXInfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdpc0xlYWYnLCB0eXBlOiAnQm9vbGVhbid9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ25hbWUnLCB0eXBlOiAnU3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncGFyZW50SWQnLCB0eXBlOiAnSW50ZWdlcid9XG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICB1cmwgICAgIDogJy4uLy4uL2V4YW1wbGVzL3RyZWVBY2NvcmRpb24vdHJlZS5qc29uJ1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gTmVvLm50eXBlKHtcbiAgICAgICAgICAgIG50eXBlOiAnY29udGFpbmVyJyxcblxuICAgICAgICAgICAgc3RhdGVQcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbe25hbWU6ICdQbGVhc2Ugc2VsZWN0IHNvbWV0aGluZyd9XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGxheW91dDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAgICAgaXRlbXMgOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZTogQWNjb3JkaW9uVHJlZSxcblxuICAgICAgICAgICAgICAgIGJpbmQ6IHtzZWxlY3Rpb246IHt0d29XYXk6IHRydWUsIHZhbHVlOiBkYXRhID0+IGRhdGEuc2VsZWN0aW9ufX0sXG5cbiAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXZSBhcmUgdXNpbmcgZGF0YS1iaW5kaW5nLlxuICAgICAgICAgICAgICAgICAqIEhlcmUgaXMgYW4gZXhhbXBsZSBmb3IgbGlzdGVuZXIgYW5kIGNvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvLyBjb250cm9sbGVyOiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIG1vZHVsZTogVmlld0NvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgb25BY2NvcmRpb25JdGVtQ2xpY2socmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgdmlld3BvcnQgPSBOZW8uZ2V0KCduZW8tY29uZmlndXJhdGlvbi12aWV3cG9ydC0xJyksXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgb3V0cHV0RWwgPSB2aWV3cG9ydC5nZXRSZWZlcmVuY2UoJ291dHB1dCcpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBvdXRwdXRFbC5odG1sID0gcmVjb3JkLm5hbWU7XG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyB9LFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGxlYWZJdGVtQ2xpY2s6ICdvbkFjY29yZGlvbkl0ZW1DbGljaydcbiAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0UHJlRmlyc3RJdGVtOiAoKSA9PiBOZW8ubG9nKCdsaXN0ZW5lciBzZWxlY3RQcmVGaXJzdEl0ZW0gZmlyZWQnKSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0UG9zdExhc3RJdGVtOiAoKSA9PiBOZW8ubG9nKCdsaXN0ZW5lciBzZWxlY3RQb3N0TGFzdEl0ZW0gZmlyZWQnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6IFBhbmVsLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTUwLFxuICAgICAgICAgICAgICAgIGZsZXggOiAxLFxuXG4gICAgICAgICAgICAgICAgaXRlbURlZmF1bHRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMTBweCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICBkb2NrIDogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7Ym9yZGVyUmlnaHRDb2xvcjogJ3RyYW5zcGFyZW50J30sXG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgOiAnQWNjb3JkaW9uIFNlbGVjdGlvbidcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9XSxcblxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICA6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6ICdvdXRwdXQnLFxuICAgICAgICAgICAgICAgICAgICBiaW5kICAgICA6IHtodG1sOiBkYXRhID0+IGRhdGEuc2VsZWN0aW9uWzBdLm5hbWV9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgb25Db25maWdDaGFuZ2UoY29uZmlnLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuZXhhbXBsZUNvbXBvbmVudC5pdGVtc1swXVtjb25maWddID0gb3B0cy52YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvblJlbW92ZURvbUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IGFjY29yZGlvbiA9IHRoaXMuZXhhbXBsZUNvbXBvbmVudC5pdGVtc1swXTtcbiAgICAgICAgYWNjb3JkaW9uLmhpZGRlbiA9ICFhY2NvcmRpb24uaGlkZGVuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyKTtcbiIsImltcG9ydCBNYWluQ29udGFpbmVyIGZyb20gJy4vTWFpbkNvbnRhaW5lci5tanMnO1xuXG5leHBvcnQgY29uc3Qgb25TdGFydCA9ICgpID0+IE5lby5hcHAoe1xuICAgIG1haW5WaWV3OiBNYWluQ29udGFpbmVyLFxuICAgIG5hbWUgICAgOiAnTmVvLmV4YW1wbGVzLnRyZWVBY2NvcmRpb24nXG59KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9Mb2dnZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udHJvbGxlci5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LWNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LWNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlZmVyZW5jZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZWZlcmVuY2VzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb21wb25lbnR9ID0gbWUsXG4gICAgICAgICAgICBsaXN0ZW5lcklkO1xuXG4gICAgICAgIG1lLnJlZmVyZW5jZXMgPSB7fTtcblxuICAgICAgICBpZiAoY29tcG9uZW50LmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXJJZCA9IGNvbXBvbmVudC5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnVuKCdjb25zdHJ1Y3RlZCcsIGxpc3RlbmVySWQpO1xuICAgICAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHBhcmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYXJlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCB0aGlzLmdldFBhcmVudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IFtjb21wb25lbnRdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxCb29sZWFufG51bGx9XG4gICAgICovXG4gICAgZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnR9ID0gbWU7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhzIGZ1bmN0aW9uICpuYW1lKiBmaXJzdCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZi5cbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgaXQsIHJldHVybiB0cnVlIHNvIGNhbGxpbmcgY29kZSBrbm93cyBub3QgdG8gY29udGludWUgdG8gc2VhcmNoLlxuICAgICAgICAgICAgY29uc3QgaGFuZGxlckNiID0gcmVzb2x2ZUNhbGxiYWNrKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyIGZuIGlzIHJlc29sdmVkIGluIHRoZSBDb21wb25lbnQgb3IgaXRzIG93biBwYXJlbnQgY2hhaW4uXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBzdGF0dXMgaW5kaWNhdGluZyB0aGF0IHdlIGRvIG5vdCBuZWVkIGFuIGVhcmx5IGJpbmRpbmdcbiAgICAgICAgICAgIGlmIChoYW5kbGVyQ2IuZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5pc0Z1bmN0aW9uKG1lW2hhbmRsZXJOYW1lXSkgP1xuICAgICAgICAgICAgbWUgOiBwYXJlbnQ/LmdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBjb250cm9sbGVyIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5jb21wb25lbnQucGFyZW50Py5nZXRDb250cm9sbGVyKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHVwZGF0ZSBjaGFuZ2VkIHJlZmVyZW5jZXMgKGUuZy4gY29udGFpbmVyLnJlbW92ZSgpIHRoZW4gY29udGFpbmVyLmFkZCgpIHVzaW5nIHRoZSBzYW1lIGtleSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUucmVmZXJlbmNlc1tuYW1lXTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LmRvd24oe3JlZmVyZW5jZTogbmFtZX0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tuYW1lXSA9IGNvbXBvbmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudCB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYW1lTGV2ZWxPbmx5PWZhbHNlIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgaW5zaWRlIHRoZSBjb21wb25lbnQgcGFyZW50IHRyZWUsXG4gICAgICogaW4gY2FzZSB0aGVyZSBpcyBub25lIG9uIHRoZSBzYW1lIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NhbWVMZXZlbE9ubHk9ZmFsc2VdXG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihzYW1lTGV2ZWxPbmx5PWZhbHNlKSB7XG4gICAgICAgIGxldCB7Y29tcG9uZW50fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzYW1lTGV2ZWxPbmx5ID8gY29tcG9uZW50LnN0YXRlUHJvdmlkZXIgOiBjb21wb25lbnQuZ2V0U3RhdGVQcm92aWRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIGFjY2Vzc2luZyBzdGF0ZS5Qcm92aWRlciBiYXNlZCBkYXRhLlN0b3Jlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZShrZXkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW5zaWRlIHlvdXIgdmlldyBjb250cm9sbGVycyBhcyBhIHN0YXJ0aW5nIHBvaW50IGluIGNhc2UgeW91IG5lZWQgcmVmZXJlbmNlc1xuICAgICAqIChpbnN0ZWFkIG9mIHVzaW5nIG9uQ29uc3RydWN0ZWQoKSBpbnNpZGUgeW91ciBjb250cm9sbGVyKVxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudD10aGlzLmNvbXBvbmVudFxuICAgICAqL1xuICAgIHBhcnNlQ29uZmlnKGNvbXBvbmVudD10aGlzLmNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2hhbmRsZXIsIGxpc3RlbmVycywgcmVmZXJlbmNlLCB2YWxpZGF0b3J9ID0gY29tcG9uZW50LFxuICAgICAgICAgICAgZXZlbnRIYW5kbGVyLCBoYW5kbGVyU2NvcGU7XG5cbiAgICAgICAgaWYgKGhhbmRsZXIgJiYgdHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBoYW5kbGVyU2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUoaGFuZGxlciwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgbmFtZSB3YXMgbm90IHJlc29sdmVkIGluIHRoZSBDb21wb25lbnQgaXRzZWxmLCBiaW5kIGl0XG4gICAgICAgICAgICBpZiAoaGFuZGxlclNjb3BlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmhhbmRsZXIgPSBoYW5kbGVyU2NvcGVbaGFuZGxlcl0uYmluZChjb21wb25lbnQuaGFuZGxlclNjb3BlIHx8IGhhbmRsZXJTY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lcnMgJiYgT2JqZWN0LmVudHJpZXMobGlzdGVuZXJzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdzY29wZScgJiYga2V5ICE9PSAnZGVsZWdhdGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJTY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZShldmVudEhhbmRsZXIsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIGZvcicsIGV2ZW50SGFuZGxlciwgY29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXJTY29wZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1trZXldLmZuID0gaGFuZGxlclNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChoYW5kbGVyU2NvcGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QobGlzdGVuZXIpICYmIGxpc3RlbmVyLmhhc093blByb3BlcnR5KCdmbicpICYmIE5lby5pc1N0cmluZyhsaXN0ZW5lci5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSBsaXN0ZW5lci5mbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyU2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUoZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyU2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIGZvcicsIGV2ZW50SGFuZGxlciwgY29tcG9uZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlclNjb3BlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmZuID0gaGFuZGxlclNjb3BlW2V2ZW50SGFuZGxlcl0uYmluZChoYW5kbGVyU2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWxpZGF0b3IpKSB7XG4gICAgICAgICAgICBoYW5kbGVyU2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUodmFsaWRhdG9yKTtcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyU2NvcGUpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ1Vua25vd24gdmFsaWRhdG9yIGZvcicsIGNvbXBvbmVudC5pZCwgY29tcG9uZW50KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudmFsaWRhdG9yID0gaGFuZGxlclNjb3BlW3ZhbGlkYXRvcl0uYmluZChoYW5kbGVyU2NvcGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBtZS5yZWZlcmVuY2VzW3JlZmVyZW5jZV0gPSBjb21wb25lbnRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnQ9dGhpcy5jb21wb25lbnRcbiAgICAgKi9cbiAgICBwYXJzZURvbUxpc3RlbmVycyhjb21wb25lbnQ9dGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkb21MaXN0ZW5lcnN9ID0gY29tcG9uZW50LFxuICAgICAgICAgICAgZXZlbnRIYW5kbGVyLCBzY29wZTtcblxuICAgICAgICBkb21MaXN0ZW5lcnM/LmZvckVhY2goZG9tTGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZG9tTGlzdGVuZXIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnc2NvcGUnICYmIGtleSAhPT0gJ2RlbGVnYXRlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZm4nKSAmJiBOZW8uaXNTdHJpbmcodmFsdWUuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZS5mbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGNhbiBiZSBzdHJpbmcgYmFzZWQgbGlzdGVuZXJzIGxpa2UgJ3VwLm9uQ2xpY2snLCB3aGljaCB3aWxsIHJlc29sdmVkIGluc2lkZSBtYW5hZ2VyLkRvbUV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPT4gRG8gbm90aGluZyBpbiBjYXNlIHRoZXJlIGlzIG5vIG1hdGNoIGluc2lkZSB0aGUgY29udHJvbGxlciBoaWVyYXJjaHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21MaXN0ZW5lcltrZXldID0gc2NvcGVbZXZlbnRIYW5kbGVyXS5iaW5kKHNjb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGdldCBjYWxsZWQgYnkgY29tcG9uZW50LkJhc2U6IGRlc3Ryb3koKSBpbiBjYXNlIHRoZSBjb21wb25lbnQgaGFzIGEgcmVmZXJlbmNlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3JlZmVyZW5jZXN9ID0gbWUsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gcmVmZXJlbmNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlZmVyZW5jZXNba2V5XTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0UGFyZW50KCk/LnJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHNldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuc2V0RGF0YSguLi5hcmdzKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBDb21wb25lbnQgICAgICAgIGZyb20gJy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGZvcm0gZmllbGRzXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaXNUb3VjaGVkRXZlbnRcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaXNUb3VjaGVkRXZlbnRzPVsnZm9jdXNFbnRlcicsJ2ZvY3VzTGVhdmUnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGlzVG91Y2hlZEV2ZW50cyA9IFsnZm9jdXNFbnRlcicsICdmb2N1c0xlYXZlJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdiYXNlZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnYmFzZWZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcm0gZ3JvdXBzIGNhbiBnZXQgc2V0IG9uIGFueSBwYXJlbnQgY29tcG9uZW50IGxldmVsLlxuICAgICAgICAgKiBBbiBhbHRlcm5hdGl2ZSB3YXkgZm9yIHVzaW5nIGRvdHMgaW4gZmllbGQgbmFtZXMuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBmb3JtR3JvdXBfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGZvcm1Hcm91cF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluZGljYXRlcyB0aGF0IGEgdXNlciBoYXMgaW50ZXJhY3RlZCB3aXRoIHRoZSBmb3JtIGZpZWxkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVG91Y2hlZF89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzVG91Y2hlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgbmFtZSB3aGljaCBzZXRzIGlzVG91Y2hlZCB0byB0cnVlLiBWYWxpZCBvcHRpb25zIGFyZSAnZm9jdXNFbnRlcicgJiAnZm9jdXNMZWF2ZSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpc1RvdWNoZWRfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc1RvdWNoZWRFdmVudF86ICdmb2N1c0xlYXZlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBuYW1lXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBuYW1lXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5lbyBpdHNlbGYgZG9lcyBub3QgbmVlZCBmaWVsZCBuYW1lcyB0byBnZXQgbWFwcGVkIHRvIHRoZSBET00gKGlucHV0IG5vZGVzKSxcbiAgICAgICAgICogZXhjZXB0IGZvciBDaGVja0JveGVzICYgUmFkaW9zIHRvIHdvcmsuIEl0IGNhbiBiZSB1c2VmdWwgZm9yIHRlc3RpbmcgdG9vbHNcbiAgICAgICAgICogJiBhY2Nlc3NpYmlsaXR5IHRob3VnaCwgc28gdGhlIGRlZmF1bHQgZ290IHNldCB0byB0cnVlLlxuICAgICAgICAgKiBGZWVsIGZyZWUgdG8gY2hhbmdlIGl0IHRvIGZhbHNlIHRvIGtlZXAgdGhlIERPTSBtaW5pbWFsLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJOYW1lXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJOYW1lXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2UgcmVuZGVyTmFtZSBpcyBzZXQgdG8gdHJ1ZSwgeW91IGNhbiBvcHRpb25hbGx5IHJlbmRlciB0aGUgY29tYmluYXRpb25cbiAgICAgICAgICogb2YgYWxsIGZvcm1Hcm91cChzKSAmIHRoZSBmaWVsZCBuYW1lIGludG8gdGhlIERPTSA9PiBpbnB1dCBub2RlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlclBhdGg9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyUGF0aDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIgeyp9IHZhbHVlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZSBmb3IgZm9ybUdyb3VwcyBvZiBhbGwgcGFyZW50IGxldmVsc1xuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBmb3JtR3JvdXBTdHJpbmc9bnVsbFxuICAgICAqL1xuICAgIGZvcm1Hcm91cFN0cmluZyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBCYXNlIGltcGxlbWVudGF0aW9uIHRvIGNoZWNrIGlmIHRoZSBmaWVsZHMgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICogQ2FuIGdldCBvdmVycmlkZGVuIGluIHN1cGVyY2xhc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaXNEaXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuICFOZW8uaXNFcXVhbCh0aGlzLmdldFN1Ym1pdFZhbHVlKCksIHRoaXMub3JpZ2luYWxDb25maWcudmFsdWUpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIGNhY2hlIGZvciBmb3JtR3JvdXAocykgYW5kIHRoZSBmaWVsZCBuYW1lXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHBhdGg9bnVsbFxuICAgICAqL1xuICAgIHBhdGggPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG5hbWUgaXNUb3VjaGVkIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNUb3VjaGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQge2Nsc30gPSB0aGlzO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8taXMtdG91Y2hlZCcsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0TmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZW5kZXJOYW1lICYmIG1lLmNoYW5nZUlucHV0RWxLZXkoJ25hbWUnLCBtZS5yZW5kZXJQYXRoID8gbWUuZ2V0UGF0aCgpIDogdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb2xlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb2xlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmdldElucHV0RWwoKS5yb2xlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBmb3JtR3JvdXAgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IHBhcmVudHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0Rm9ybUdyb3VwKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBncm91cCA9IFtdLFxuICAgICAgICAgICAgcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgaWYgKG1lLmZvcm1Hcm91cFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmZvcm1Hcm91cFN0cmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgJiYgZ3JvdXAucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICBwYXJlbnQuZm9ybUdyb3VwICYmIGdyb3VwLnVuc2hpZnQocGFyZW50LmZvcm1Hcm91cClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuVmFsdWUgPSBncm91cC5qb2luKCcuJyk7XG5cbiAgICAgICAgbWUuZm9ybUdyb3VwU3RyaW5nID0gcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaXNUb3VjaGVkRXZlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRJc1RvdWNoZWRFdmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2lzVG91Y2hlZEV2ZW50JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIGlucHV0RWwgdmRvbSBvYmplY3QgYXR0cmlidXRlIG9yIHJlbW92ZXMgaXQgaW4gY2FzZSBpdCBoYXMgbm8gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ8T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICovXG4gICAgY2hhbmdlSW5wdXRFbEtleShrZXksIHZhbHVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgfHwgTmVvLmlzQm9vbGVhbih2YWx1ZSkgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIG1lLmdldElucHV0RWwoKVtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5nZXRJbnB1dEVsKClba2V5XVxuICAgICAgICB9XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7Kn0gICAgICB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gICAgICBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKi9cbiAgICBkb0ZpcmVDaGFuZ2VFdmVudCh2YWx1ZSwgb2xkVmFsdWUsIGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBGb3JtQ29udGFpbmVyID0gTmVvLmZvcm0/LkNvbnRhaW5lcixcbiAgICAgICAgICAgIGZvcm1FdmVudCAgICAgPSAnZmllbGQnICsgTmVvLmNhcGl0YWxpemUoZXZlbnROYW1lKSxcbiAgICAgICAgICAgIG9wdHMgICAgICAgICAgPSB7Y29tcG9uZW50OiBtZSwgb2xkVmFsdWUsIHZhbHVlfTtcblxuICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24obWUuZ2V0R3JvdXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9wdHMuZ3JvdXBWYWx1ZSA9IG1lLmdldEdyb3VwVmFsdWUoKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZShldmVudE5hbWUsIG9wdHMpO1xuXG4gICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEZvcm1Db250YWluZXIgJiYgcGFyZW50IGluc3RhbmNlb2YgRm9ybUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZmlyZShmb3JtRXZlbnQsIG9wdHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRvRmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSwgJ2NoYW5nZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBmaXJlVXNlckNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRvRmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSwgJ3VzZXJDaGFuZ2UnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1zIGluIG5lbyBjYW4gYmUgbmVzdGVkLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBwYXJlbnQgd2hpY2ggaXMgYSBmb3JtLkNvbnRhaW5lciBvciBudWxsLlxuICAgICAqIEByZXR1cm5zIHtOZW8uZm9ybS5Db250YWluZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDbG9zZXN0Rm9ybSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgRm9ybUNvbnRhaW5lciA9IE5lby5mb3JtPy5Db250YWluZXIsXG4gICAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgICAgZm9yIChwYXJlbnQgb2YgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKSkge1xuICAgICAgICAgICAgaWYgKEZvcm1Db250YWluZXIgJiYgcGFyZW50IGluc3RhbmNlb2YgRm9ybUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgbmVlZGVkXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldElucHV0RWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgZmllbGQgZm9ybUdyb3VwKHMpICYgbmFtZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcGF0aDtcblxuICAgICAgICAvLyBmaWVsZHMgY291bGQgaGF2ZSBmb3JtR3JvdXBzLCBidXQgbm8gbmFtZS5cbiAgICAgICAgLy8gcmV0dXJuaW5nIHRoZSBuYW1lc3BhY2UgY2FuIGNvbmZ1c2UgZm9ybS5Db250YWluZXIuYWRqdXN0VHJlZUxlYXZlcygpLFxuICAgICAgICAvLyBzaW5jZSBuYW1lc3BhY2VzIGNvdWxkIGJlIGNvbnNpZGVyZWQgYXMgZmllbGQgaW5zdGFuY2VzLlxuICAgICAgICBpZiAoIW1lLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggPSBtZS5mb3JtR3JvdXAgPyBtZS5mb3JtR3JvdXAuc3BsaXQoJy4nKSA6IFtdO1xuXG4gICAgICAgICAgICBtZS5uYW1lICYmIHBhdGgucHVzaChtZS5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnBhdGggPSBwYXRoLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUucGF0aCkge1xuICAgICAgICAgICAgbWUucGF0aCA9ICdub25lJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLnBhdGggPT09ICdub25lJyA/IG51bGw6IG1lLnBhdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTdWJtaXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBpbiB2Ny54XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN1Ym1pdFZhbHVlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Gb2N1c0VudGVyKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hlZEV2ZW50ID09PSAnZm9jdXNFbnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIEZvcm1Db250YWluZXIgPSBOZW8uZm9ybT8uQ29udGFpbmVyLFxuICAgICAgICAgICAgb3B0cyAgICAgICAgICA9IHsuLi5kYXRhLCBjb21wb25lbnQ6IG1lLCB2YWx1ZTogbWUuZ2V0U3VibWl0VmFsdWUoKX07XG5cbiAgICAgICAgaWYgKG1lLmlzVG91Y2hlZEV2ZW50ID09PSAnZm9jdXNMZWF2ZScpIHtcbiAgICAgICAgICAgIG1lLmlzVG91Y2hlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihtZS5nZXRHcm91cFZhbHVlKSkge1xuICAgICAgICAgICAgb3B0cy5ncm91cFZhbHVlID0gbWUuZ2V0R3JvdXBWYWx1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLnN1c3BlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIuZ2V0UGFyZW50cyhtZSkuZm9yRWFjaChwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChGb3JtQ29udGFpbmVyICYmIHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmZpcmUoJ2ZpZWxkRm9jdXNMZWF2ZScsIG9wdHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgZmllbGQgdG8gYSBuZXcgdmFsdWUgb3IgbnVsbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWU9bnVsbFxuICAgICAqL1xuICAgIHJlc2V0KHZhbHVlPW51bGwpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvbmZpZy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGNsaWVudC1zaWRlIGZpZWxkIGVycm9yc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PXRydWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNsaWVudC1zaWRlIGVycm9yc1xuICAgICAqL1xuICAgIHZhbGlkYXRlKHNpbGVudD10cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBjaGFuZ2UgZXZlbnQgZmlyZXMgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAqIEBldmVudCBjaGFuZ2VcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCJpbXBvcnQgVHJlZU1vZGVsIGZyb20gJy4vVHJlZU1vZGVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gXCIuLi91dGlsL0FycmF5Lm1qc1wiO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLlRyZWVBY2NvcmRpb25Nb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWxcbiAqL1xuY2xhc3MgVHJlZUFjY29yZGlvbk1vZGVsIGV4dGVuZHMgVHJlZU1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uVHJlZUFjY29yZGlvbk1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLlRyZWVBY2NvcmRpb25Nb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tdHJlZWFjY29yZGlvbm1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi10cmVlYWNjb3JkaW9ubW9kZWwnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gZmluZCBhIGNoaWxkIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja0ZvckNoaWxkKHJlY29yZCkge1xuICAgICAgICBsZXQge3ZpZXd9ICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkSWQgICAgPSByZWNvcmRbdmlldy5nZXRLZXlQcm9wZXJ0eSgpXSxcbiAgICAgICAgICAgIGNoaWxkUmVjb3JkID0gbnVsbDtcblxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygdmlldy5zdG9yZS5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucGFyZW50SWQgPT09IHJlY29yZElkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRSZWNvcmQgPSBpdGVtO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGRSZWNvcmRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBhcmVudCByZWNvcmQgaWYgYW55XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja0ZvclBhcmVudCh7cGFyZW50SWR9KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRJZCA/IHRoaXMudmlldy5zdG9yZS5nZXQocGFyZW50SWQpIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcGVuZGluZyBvbiB7LTF8MX0gc3RlcCByZXR1cm5cbiAgICAgKiAtMTogcHJldmlvdXMgcmVjb3JkIE9SIHBhcmVudCByZWNvcmRcbiAgICAgKiAgMTogbmV4dCByZWNvcmQgb3IgbnVsbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGNoZWNrRm9yU2libGluZyhyZWNvcmQsIHN0ZXApIHtcbiAgICAgICAgbGV0IHt2aWV3fSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzdG9yZX0gICAgICAgID0gdmlldyxcbiAgICAgICAgICAgIHBhcmVudFJlY29yZElkID0gcmVjb3JkLnBhcmVudElkLFxuICAgICAgICAgICAgcmVjb3JkSWQgICAgICAgPSByZWNvcmRbdmlldy5nZXRLZXlQcm9wZXJ0eSgpXSxcbiAgICAgICAgICAgIGhhc0ZvdW5kTmV4dCAgID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0SXRlbVJlY29yZCA9IG51bGwsXG4gICAgICAgICAgICBwcmV2aW91c0l0ZW1SZWNvcmQ7XG5cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBzdG9yZS5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGhhc0ZvdW5kTmV4dCAmJiBpdGVtLnBhcmVudElkID09PSBwYXJlbnRSZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgIG5leHRJdGVtUmVjb3JkID0gaXRlbTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc0ZvdW5kTmV4dCAmJiBpdGVtLnBhcmVudElkID09PSBwYXJlbnRSZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzRm91bmROZXh0ICYmIGl0ZW1bdmlldy5nZXRLZXlQcm9wZXJ0eSgpXSA9PT0gcmVjb3JkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXAgPT09IC0xKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaGFzRm91bmROZXh0ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSXRlbVJlY29yZCA9IGl0ZW1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RlcCA9PT0gMSA/IG5leHRJdGVtUmVjb3JkIDogKHByZXZpb3VzSXRlbVJlY29yZCB8fCBzdG9yZS5nZXQocGFyZW50UmVjb3JkSWQpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG5leHQgc2libGluZyBvZiBhIHBhcmVudCBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja05leHRQYXJlbnRTaWJsaW5nKHJlY29yZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJlbnQgICAgICAgID0gbWUudmlldy5zdG9yZS5nZXQocmVjb3JkLnBhcmVudElkKSxcbiAgICAgICAgICAgIHBhcmVudFNpYmxpbmcgPSBtZS5jaGVja0ZvclNpYmxpbmcocGFyZW50LCAxKTtcblxuICAgICAgICBpZiAoIXBhcmVudFNpYmxpbmcgJiYgcGFyZW50LnBhcmVudElkKSB7XG4gICAgICAgICAgICBtZS5jaGVja05leHRQYXJlbnRTaWJsaW5nKHBhcmVudClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRTaWJsaW5nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGtleXMgKExpc3QubWpzOnJlZ2lzdGVyKVxuICAgICAqIFRvZ2dsZSBjb2xsYXBzZSBvciBpZiBpc0xlYWYgc2VsZWN0IG5leHQgaXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRW50ZXIoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lLFxuICAgICAgICAgICAgaXRlbUlkID0gbWUuZ2V0U2VsZWN0aW9uKClbMF0sXG4gICAgICAgICAgICByZWNvcmQgPSB2aWV3LnN0b3JlLmdldCh2aWV3LmdldEl0ZW1SZWNvcmRJZChpdGVtSWQpKTtcblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiB8fCByZWNvcmQuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBtZS5vbktleURvd25SaWdodChkYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUub25LZXlEb3duTGVmdChkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGtleXMgKExpc3QubWpzOnJlZ2lzdGVyKVxuICAgICAqIERlc2VsZWN0IGFsbCBhbmQgZmlyZSBldmVudCBzZWxlY3RQb3N0TGFzdEl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVzY2FwZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZGVzZWxlY3RBbGwoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlIGZvbGRlciBvciBzZWxlY3QgcHJldmlvdXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkxlZnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lLFxuICAgICAgICAgICAgaXRlbUlkID0gbWUuZ2V0U2VsZWN0aW9uKClbMF0sXG4gICAgICAgICAgICByZWNvcmQ7XG5cbiAgICAgICAgaWYgKCFpdGVtSWQpIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdFJvb3QoKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgcmVjb3JkID0gdmlldy5zdG9yZS5nZXQodmlldy5nZXRJdGVtUmVjb3JkSWQoaXRlbUlkKSk7XG5cbiAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgfHwgcmVjb3JkLmNvbGxhcHNlZCB8fCAhdmlldy5yb290UGFyZW50c0FyZUNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgICBtZS5vbk5hdktleShkYXRhLCAtMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnRvZ2dsZUNvbGxhcHNlZChyZWNvcmQsIGl0ZW1JZCwgdHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gZm9sZGVyIG9yIHNlbGVjdCBuZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25SaWdodChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICBpdGVtSWQgPSBtZS5nZXRTZWxlY3Rpb24oKVswXSxcbiAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICBpZiAoIWl0ZW1JZCkge1xuICAgICAgICAgICAgbWUuc2VsZWN0Um9vdCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICByZWNvcmQgPSB2aWV3LnN0b3JlLmdldCh2aWV3LmdldEl0ZW1SZWNvcmRJZChpdGVtSWQpKTtcblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiB8fCAhcmVjb3JkLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgbWUub25OYXZLZXkoZGF0YSwgMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnRvZ2dsZUNvbGxhcHNlZChyZWNvcmQsIGl0ZW1JZCwgZmFsc2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzICd1cCcgYW5kICdkb3duJyBrZXlzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIG9uTmF2S2V5KGRhdGEsIHN0ZXApIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gPSBtZSxcbiAgICAgICAgICAgIGl0ZW0gICA9IG1lLmdldFNlbGVjdGlvbigpWzBdLFxuICAgICAgICAgICAgbmV3UmVjb3JkLCByZWNvcmQsIHJlY29yZElkO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICByZWNvcmRJZCA9IHZpZXcuZ2V0SXRlbVJlY29yZElkKGl0ZW0pO1xuICAgICAgICAgICAgcmVjb3JkICAgPSB2aWV3LnN0b3JlLmdldChyZWNvcmRJZCk7XG5cbiAgICAgICAgICAgIGlmIChzdGVwID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNvcmQuaXNMZWFmICYmICFyZWNvcmQuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlyc3QgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVjb3JkID0gbWUuY2hlY2tGb3JDaGlsZChyZWNvcmQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBuZXh0IHNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVjb3JkID0gbWUuY2hlY2tGb3JTaWJsaW5nKHJlY29yZCwgc3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vID09PiBsb29wIHRocm91Z2ggcGFyZW50IG5leHQgc2libGluZ3MgdW50aWwgbm8gcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3UmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWNvcmQgPSBtZS5jaGVja05leHRQYXJlbnRTaWJsaW5nKHJlY29yZClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGl0ZW0gd2FzIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAoIW5ld1JlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5kZXNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmZpcmUoJ3NlbGVjdFBvc3RMYXN0SXRlbScpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHByZXZpb3VzIHNpYmxpbmdcbiAgICAgICAgICAgICAgICBuZXdSZWNvcmQgPSBtZS5jaGVja0ZvclNpYmxpbmcocmVjb3JkLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAvLyBubyA9PT4gZ2V0IHBhcmVudFxuICAgICAgICAgICAgICAgIGlmICghbmV3UmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JlY29yZCA9IG1lLmNoZWNrRm9yUGFyZW50KHJlY29yZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBpdGVtIHdhcyB0aGUgZmlyc3QgaXRlbVxuICAgICAgICAgICAgICAgIGlmICghbmV3UmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRlc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZmlyZSgnc2VsZWN0UHJlRmlyc3RJdGVtJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5zZWxlY3RSb290KClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JZCA9IHZpZXcuZ2V0SXRlbUlkKG5ld1JlY29yZFttZS52aWV3LmdldEtleVByb3BlcnR5KCldKTtcblxuICAgICAgICAgICAgbWUuc2VsZWN0QW5kU2Nyb2xsSW50b1ZpZXcoaXRlbUlkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGFuIGl0ZW0gYW5kIHNjcm9sbCB0aGUgdHJlZSB0byBzaG93IHRoZSBpdGVtIGluIHRoZSBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkXG4gICAgICovXG4gICAgc2VsZWN0QW5kU2Nyb2xsSW50b1ZpZXcoaXRlbUlkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0KGl0ZW1JZCk7XG5cbiAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgIGlkICAgICAgOiBpdGVtSWQsXG4gICAgICAgICAgICBibG9jayAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICB3aW5kb3dJZDogdGhpcy52aWV3LndpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSByb290IGl0ZW0gb2YgdGhlIHRyZWVcbiAgICAgKi9cbiAgICBzZWxlY3RSb290KCkge1xuICAgICAgICBsZXQge3ZpZXd9ICA9IHRoaXMsXG4gICAgICAgICAgICB7c3RvcmV9ID0gdmlldyxcbiAgICAgICAgICAgIHJlY29yZCwgcm9vdEl0ZW1JZDtcblxuICAgICAgICBmb3IgKHJlY29yZCBvZiBzdG9yZS5pdGVtcykge1xuICAgICAgICAgICAgaWYgKCFyZWNvcmQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICByb290SXRlbUlkID0gdmlldy5nZXRJdGVtSWQocmVjb3JkW3ZpZXcuZ2V0S2V5UHJvcGVydHkoKV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbGVjdEFuZFNjcm9sbEludG9WaWV3KHJvb3RJdGVtSWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXJlbnQgcmVjb3JkIGlmIGFueVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbUlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb2xsYXBzZVxuICAgICAqL1xuICAgIHRvZ2dsZUNvbGxhcHNlZChyZWNvcmQsIGl0ZW1JZCwgY29sbGFwc2UpIHtcbiAgICAgICAgbGV0IGl0ZW0gID0gdGhpcy52aWV3LmdldFZkb21DaGlsZChpdGVtSWQpLFxuICAgICAgICAgICAgY2xzRm4gPSBjb2xsYXBzZSA/ICdyZW1vdmUnIDogJ2FkZCc7XG5cbiAgICAgICAgTmVvQXJyYXlbY2xzRm5dKGl0ZW0uY2xzLCAnbmVvLWZvbGRlci1vcGVuJyk7XG4gICAgICAgIHRoaXMudmlldy51cGRhdGUoKTtcblxuICAgICAgICByZWNvcmQuY29sbGFwc2VkID0gY29sbGFwc2VcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRyZWVBY2NvcmRpb25Nb2RlbCk7XG4iLCJpbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICAgIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFRyZWVMaXN0ICAgICAgICAgICBmcm9tICcuLi90cmVlL0xpc3QubWpzJztcbmltcG9ydCBUcmVlQWNjb3JkaW9uTW9kZWwgZnJvbSAnLi4vc2VsZWN0aW9uL1RyZWVBY2NvcmRpb25Nb2RlbC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRyZWUuQWNjb3JkaW9uXG4gKiBAZXh0ZW5kcyBOZW8udHJlZS5MaXN0XG4gKlxuICogQWNjb3JkaW9uIFN0b3JlIGV4cGVjdHMgdGhlIGZvbGxvd2luZyBmaWVsZHNcbiAqXG4gKiAgICAgIFtcbiAqICAgICAgICAgIGljb25DbHMsICAgICAgICAvLyBjYW4gYmUgZGVmaW5lZCBpbiBmaWVsZHM6aWNvblxuICogICAgICAgICAgY29udGVudCwgICAgICAgIC8vIGNhbiBiZSBkZWZpbmVkIGluIGZpZWxkczp0ZXh0XG4gKiAgICAgICAgICBuYW1lLCAgICAgICAgICAgLy8gY2FuIGJlIGRlZmluZWQgaW4gZmllbGRzOmhlYWRlclxuICpcbiAqICAgICAgICAgIGNvbGxhcHNlZCwgICAgICAvLyBjb2xsYXBzZWQgc3RhdGUgZm9yIG5vbi1sZWFmLWl0ZW1zXG4gKiAgICAgICAgICBpc0xlYWYsICAgICAgICAgLy8gZGVmaW5lcyBpdCBpdGVtIGlzIGxlYWYtaXRlbVxuICogICAgICAgICAgaWQsICAgICAgICAgICAgIC8vIGRlZmluZXMgaXRlbSBpZFxuICogICAgICAgICAgcGFyZW50SWQgICAgICAgIC8vIGxlYWYgb3Igc3ViLWl0ZW1zIG5lZWQgYSBwYXJlbnRJZFxuICogICAgICBdXG4gKlxuICovXG5jbGFzcyBBY2NvcmRpb25UcmVlIGV4dGVuZHMgVHJlZUxpc3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRyZWUuQWNjb3JkaW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udHJlZS5BY2NvcmRpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndHJlZWFjY29yZGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0cmVlYWNjb3JkaW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRyZWUtYWNjb3JkaW9uJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRyZWUtbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIHRoZSBmaWVsZCBuYW1lcyBmb3IgdGhlIHN0b3JlIHRvIHNob3cgaGVhZGVyLCB0ZXh0IGFuZCBpY29uXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZmllbGRzPXtoZWFkZXI6J25hbWUnLGljb246J2ljb25DbHMnLHRleHQ6J2NvbnRlbnQnfVxuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBoZWFkZXI6ICduYW1lJyxcbiAgICAgICAgICAgIGljb24gIDogJ2ljb25DbHMnLFxuICAgICAgICAgICAgdGV4dCAgOiAnY29udGVudCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byBmYWxzZSB0byBoaWRlIHRoZSBpbml0aWFsIHJvb3QgaXRlbVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmaXJzdFBhcmVudElzVmlzaWJsZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBmaXJzdFBhcmVudElzVmlzaWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gZmFsc2Ugd2lsbCBhdXRvIGV4cGFuZCByb290IHBhcmVudCBpdGVtcyBhbmQgZGlzYWxsb3cgY29sbGFwc2luZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByb290UGFyZW50SXNDb2xsYXBzaWJsZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcm9vdFBhcmVudHNBcmVDb2xsYXBzaWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIHdoaWNoIGlzIGJpbmRhYmxlXG4gICAgICAgICAqIEBtZW1iZXIge1JlY29yZFtdfG51bGx9IHNlbGVjdGlvbj1udWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAgICBtb2R1bGU6IEFjY29yZGlvblRyZWUsXG4gICAgICAgICAqICAgICBiaW5kICA6IHtzZWxlY3Rpb246IHt0d29XYXk6IHRydWUsIHZhbHVlOiBkYXRhID0+IGRhdGEuc2VsZWN0aW9ufX1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICogICAgIGJpbmQgOiB7aHRtbDogZGF0YSA9PiBkYXRhLnNlbGVjdGlvblswXS5uYW1lfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byBmYWxzZSB3aWxsIGhpZGUgdGhlIGljb25zIGZvciBhbGwgbGVhZiBpdGVtc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93SWNvbj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SWNvbl86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29uczogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7dGFnOiAndWwnLCBjbHM6IFsnbmVvLWxpc3QtY29udGFpbmVyJywgJ25lby1saXN0JywgJ25lby1hY2NvcmRpb24tc3R5bGUnXSwgY246IFtdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGZvY3VzaW46IG1lLm9uRm9jdXMsXG4gICAgICAgICAgICBzY29wZSAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5naW5nIGZpcnN0UGFyZW50SXNWaXNpYmxlXG4gICAgICogRmlyc3Qgc3RvcmUgaXRlbSBnZXRzIG1hcmtlZCBhbmQgYWRkaXRpb25hbCBjc3MgY2xhc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGaXJzdFBhcmVudElzVmlzaWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGZpcnN0UmVjb3JkID0gdGhpcy5zdG9yZS5maXJzdCgpO1xuXG4gICAgICAgIHRoaXMudG9nZ2xlQ2xzKCdmaXJzdC1wYXJlbnQtbm90LXZpc2libGUnLCAhdmFsdWUpO1xuXG4gICAgICAgIGlmIChmaXJzdFJlY29yZCkge1xuICAgICAgICAgICAgZmlyc3RSZWNvcmQudmlzaWJsZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2luZyByb290UGFyZW50c0FyZUNvbGxhcHNpYmxlXG4gICAgICogRW5zdXJlcyB0aGF0IHJvb3QgaXRlbXMgYXJlIGV4cGFuZGVkIGlmIG5vdCBjb2xsYXBzaWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWVbIXZhbHVlID8gJ2FkZENscycgOiAncmVtb3ZlQ2xzJ10oJ3Jvb3Qtbm90LWNvbGxhcHNpYmxlJyk7XG5cbiAgICAgICAgaWYgKG1lLnJlbmRlcmVkICYmIHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbGV0IHtzdG9yZX0gPSBtZTtcblxuICAgICAgICAgICAgc3RvcmUuaXRlbXMuZm9yRWFjaChyZWNvcmQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQucGFyZW50SWQgPT09IG51bGwgJiYgIXJlY29yZC5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZXhwYW5kSXRlbShyZWNvcmQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5naW5nIHNob3dJY29uXG4gICAgICogQ2hhbmdlcyB0aGUgZGlzcGxheSBvZiB0aGUgaWNvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93SWNvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgIHtzdG9yZX0gPSBtZSxcbiAgICAgICAgICAgICAgaGlkZSAgICA9ICF2YWx1ZTtcblxuICAgICAgICBzdG9yZS5pdGVtcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JZCAgID0gbWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSksXG4gICAgICAgICAgICAgICAgICB2ZG9tICAgICA9IG1lLmdldFZkb21DaGlsZChpdGVtSWQpLFxuICAgICAgICAgICAgICAgICAgaXRlbVZkb20gPSBWRG9tVXRpbC5nZXRCeUZsYWcodmRvbSwgJ2ljb25DbHMnKTtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBpdGVtVmRvbS5yZW1vdmVEb20gPSBoaWRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5zZWxlY3Rpb24uTW9kZWx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFRyZWVBY2NvcmRpb25Nb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGl0ZW1zIGZyb20gdGhlIGFjY29yZGlvblxuICAgICAqIElmIHlvdSBkbyBub3QgbmVlZCB0byB1cGRhdGUgdGhlIHZpZXcgYWZ0ZXIgY2xlYXJpbmcsIHNldCBgd2l0aFVwZGF0ZSA9IGZhbHNlYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFVwZGF0ZT10cnVlXVxuICAgICAqL1xuICAgIGNsZWFyKHdpdGhVcGRhdGU9dHJ1ZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5nZXRWZG9tUm9vdCgpLmNuWzBdLmNuXG5cbiAgICAgICAgd2l0aFVwZGF0ZSAmJiB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBpdGVtcyBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdEFsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyZW50SWRdIFRoZSBwYXJlbnQgbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbVJvb3RdIFRoZSB2ZG9tIHRlbXBsYXRlIHJvb3QgZm9yIHRoZSBjdXJyZW50IHN1YiB0cmVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBoaWVyYXJjaHkgbGV2ZWwgb2YgdGhlIHRyZWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tUm9vdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcyhwYXJlbnRJZCwgdmRvbVJvb3QsIGxldmVsKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Zm9sZGVyQ2xzLCBpdGVtQ2xzfSA9IG1lLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICAgICAgICAgPSBtZS5zdG9yZS5maW5kKCdwYXJlbnRJZCcsIHBhcmVudElkKSxcbiAgICAgICAgICAgIGNscywgaWQsIGl0ZW1JY29uQ2xzLCB0bXBSb290O1xuXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXZkb21Sb290LmNuKSB7XG4gICAgICAgICAgICAgICAgdmRvbVJvb3QuY24gPSBbXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2ZG9tUm9vdC5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiAndWwnLFxuICAgICAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLWxpc3QnXSxcbiAgICAgICAgICAgICAgICAgICAgY24gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaWQgOiBgJHttZS5pZH1fXyR7cGFyZW50SWR9X191bGBcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSB2ZG9tUm9vdC5jblt2ZG9tUm9vdC5jbi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bXBSb290ID0gdmRvbVJvb3RcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjbHMgICAgICAgICA9IFtpdGVtQ2xzXTtcbiAgICAgICAgICAgICAgICBpdGVtSWNvbkNscyA9IFsnbmVvLWFjY29yZGlvbi1pdGVtLWljb24nXTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmljb25DbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGl0ZW1JY29uQ2xzLCBpdGVtLmljb25DbHMuc3BsaXQoJyAnKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzLnB1c2goaXRlbUNscyArIChpdGVtLnNpbmdsZXRvbiA/ICctbGVhZi1zaW5nbGV0b24nIDogJy1sZWFmJykpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzLnB1c2goZm9sZGVyQ2xzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ucGFyZW50SWQgJiYgIW1lLnJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tbm90LWNvbGxhcHNpYmxlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29sbGFwc2VkID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZm9sZGVyLW9wZW4nKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWQgPSBtZS5nZXRJdGVtSWQoaXRlbS5pZCk7XG5cbiAgICAgICAgICAgICAgICB0bXBSb290LmNuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0YWcgICAgIDogJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBjbiAgICAgIDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgICAgIDogJ2ljb25DbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IGl0ZW1JY29uQ2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBpZCArICdfX2ljb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiAoIWl0ZW0uaXNMZWFmIHx8ICFtZS5zaG93SWNvbilcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzICA6IFtpdGVtQ2xzICsgJy1jb250ZW50J10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgIDogaWQgKyAnX19pdGVtLWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtwb2ludGVyRXZlbnRzOiAnbm9uZSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY24gICA6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyAgICAgOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbaXRlbUNscyArICctY29udGVudC1oZWFkZXInXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IGlkICsgJ19faXRlbS1jb250ZW50LWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MOiBpdGVtW21lLmZpZWxkcy5oZWFkZXJdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyAgICAgOiAnY29udGVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbaXRlbUNscyArICctY29udGVudC10ZXh0J10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBpZCArICdfX2l0ZW0tY29udGVudC10ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUw6IGl0ZW1bbWUuZmllbGRzLnRleHRdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpdGVtLmlzTGVhZiA/IG51bGwgOiAnc3RpY2t5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBpdGVtLmlzTGVhZiA/IG51bGwgOiAobGV2ZWwgKiAzOCkgKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4ICA6IGl0ZW0uaXNMZWFmID8gbnVsbCA6ICgyMCAvIChsZXZlbCArIDEpKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdG1wUm9vdCA9IG1lLmNyZWF0ZUl0ZW1zKGl0ZW0uaWQsIHRtcFJvb3QsIGxldmVsICsgMSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbVJvb3RcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYW4gaXRlbSBiYXNlZCBvbiB0aGUgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqL1xuICAgIGV4cGFuZEl0ZW0ocmVjb3JkKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbUlkID0gbWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSksXG4gICAgICAgICAgICBpdGVtICAgPSBtZS5nZXRWZG9tQ2hpbGQoaXRlbUlkKTtcblxuICAgICAgICByZWNvcmQuY29sbGFwc2VkID0gZmFsc2U7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGl0ZW0uY2xzLCAnbmVvLWZvbGRlci1vcGVuJyk7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKGl0ZW0sIGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25JdGVtQ2xpY2soaXRlbSwgZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3NlbGVjdGlvbk1vZGVsfSA9IG1lLFxuICAgICAgICAgICAgaXRlbUlkICAgICAgICAgICA9IGl0ZW0uaWQsXG4gICAgICAgICAgICBpZCAgICAgICAgICAgICAgID0gTnVtYmVyKGl0ZW1JZC5zcGxpdCgnX18nKVsxXSksXG4gICAgICAgICAgICByZWNvcmQgICAgICAgICAgID0gbWUuc3RvcmUuZ2V0KGlkKTtcblxuICAgICAgICBzZWxlY3Rpb25Nb2RlbC5zZWxlY3QoaXRlbS5pZCk7XG5cbiAgICAgICAgaWYgKCFyZWNvcmQuaXNMZWFmKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBmb2xkZXJJdGVtQ2xpY2sgZXZlbnQgZmlyZXMgd2hlbiBhIGNsaWNrIG9jY3VycyBvbiBhIGxpc3QgaXRlbSB3aGljaCBkb2VzIGhhdmUgY2hpbGQgaXRlbXMuXG4gICAgICAgICAgICAgKiBQYXNzZXMgdGhlIGl0ZW0gcmVjb3JkIHRvIHRoZSBldmVudCBoYW5kbGVyLlxuICAgICAgICAgICAgICogQGV2ZW50IGZvbGRlckl0ZW1DbGlja1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gcmVjb3JkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1lLmZpcmUoJ2ZvbGRlckl0ZW1DbGljaycsIHtyZWNvcmR9KTtcblxuICAgICAgICAgICAgcmVjb3JkLmNvbGxhcHNlZCA9ICFyZWNvcmQuY29sbGFwc2VkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBwbGFjZSB0aGUgcm9vdCBpdGVtIGF0IHRoZSBjb3JyZWN0IGxvY2F0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMaXN0SXRlbXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjb3JkaW9uIGdhaW5pbmcgZm9jdXMgd2l0aG91dCBzZWxlY3Rpb24gPT4gc2V0U2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkZvY3VzKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3NlbGVjdGlvbk1vZGVsfSA9IG1lLFxuICAgICAgICAgICAgc2VsZWN0aW9uICAgICAgICA9IHNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbigpWzBdO1xuXG4gICAgICAgICFzZWxlY3Rpb24gJiYgc2VsZWN0aW9uTW9kZWwuc2VsZWN0Um9vdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGZyb20gU2VsZWN0aW9uTW9kZWwgc2VsZWN0KClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqL1xuICAgIG9uU2VsZWN0KHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZHMgPSBbXTtcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKChzZWxlY3RJdGVtSWQpID0+IHtcbiAgICAgICAgICAgIGxldCBpZCAgICAgPSBtZS5nZXRJdGVtUmVjb3JkSWQoc2VsZWN0SXRlbUlkKSxcbiAgICAgICAgICAgICAgICByZWNvcmQgPSBtZS5zdG9yZS5nZXQoaWQpO1xuXG4gICAgICAgICAgICByZWNvcmRzLnB1c2gocmVjb3JkKVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5zZWxlY3Rpb24gPSByZWNvcmRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIHN0b3JlIGxvYWRlZCwgY3JlYXRlIHRoZSBpdGVtcyBmb3IgdGhlIGxpc3RcbiAgICAgKiBAcGFyYW0ge1JlY29yZFtdfSByZWNvcmRzXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQocmVjb3Jkcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNsZWFyKGZhbHNlKTtcblxuICAgICAgICBpZiAoIW1lLm1vdW50ZWQgJiYgbWUucmVuZGVyaW5nKSB7XG4gICAgICAgICAgICBtZS5vbignbW91bnRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVJdGVtcyhudWxsLCBtZS5nZXRMaXN0SXRlbXNSb290KCksIDApO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuY3JlYXRlSXRlbXMobnVsbCwgbWUuZ2V0TGlzdEl0ZW1zUm9vdCgpLCAwKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gICAgICAgZGF0YS5maWVsZHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICBkYXRhLmluZGV4XG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbFxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICovXG4gICAgb25TdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmaWVsZHMsIHJlY29yZH0gPSBkYXRhLFxuICAgICAgICAgICAgaXRlbUlkICAgICAgICAgICA9IG1lLmdldEl0ZW1JZChyZWNvcmRbbWUuZ2V0S2V5UHJvcGVydHkoKV0pLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgICAgICA9IG1lLmdldFZkb21DaGlsZChpdGVtSWQpLFxuICAgICAgICAgICAgaXRlbVZkb207XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpdGVtVmRvbSA9IFZEb21VdGlsLmdldEJ5RmxhZyh2ZG9tLCBmaWVsZC5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW1WZG9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09ICdpY29uQ2xzJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2xzSXRlbXMgPSBmaWVsZC52YWx1ZS5zcGxpdCgnICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgPSBbJ25lby1hY2NvcmRpb24taXRlbS1pY29uJ107XG5cbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgY2xzSXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtVmRvbS5jbHMgPSBjbHNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtVmRvbS5odG1sID0gZmllbGQudmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzZWxlY3Rpb24gZWl0aGVyIGJlaSByZWNvcmQgaWQgb3IgcmVjb3JkLlxuICAgICAqIFlvdSBjYW4gcGFzcyBhIHJlY29yZCBvciBhIHJlY29yZElkIGFzIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlY29yZHxSZWNvcmRbXXxOdW1iZXJ8TnVtYmVyW118U3RyaW5nfFN0cmluZ1tdfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gY2FzZSB5b3UgcGFzcyBpbiBhbiBhcnJheSB1c2Ugb25seSB0aGUgZmlyc3QgaXRlbVxuICAgICAgICBpZiAoTmVvLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkS2V5UHJvcGVydHksIGVsSWQ7XG5cbiAgICAgICAgaWYgKE5lby5pc1JlY29yZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlY29yZEtleVByb3BlcnR5ID0gdmFsdWVbbWUuZ2V0S2V5UHJvcGVydHkoKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWNvcmRJZFxuICAgICAgICAgICAgcmVjb3JkS2V5UHJvcGVydHkgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsSWQgPSBtZS5nZXRJdGVtSWQocmVjb3JkS2V5UHJvcGVydHkpO1xuXG4gICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsLnNlbGVjdEFuZFNjcm9sbEludG9WaWV3KGVsSWQpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBY2NvcmRpb25UcmVlKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9