"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_functional__export_mjs"],{

/***/ "./src/core/Effect.mjs":
/*!*****************************!*\
  !*** ./src/core/Effect.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _EffectBatchManager_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EffectBatchManager.mjs */ "./src/core/EffectBatchManager.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");





/**
 * Creates a reactive effect that automatically tracks its dependencies and re-runs when any of them change.
 * This is a lightweight, plain JavaScript class for performance.
 * It serves as a core reactive primitive, enabling automatic and dynamic dependency tracking.
 * @class Neo.core.Effect
 */
class Effect {
    /**
     * The optional component id this effect belongs to.
     * @member {String|null} componentId=null
     */
    componentId = null
    /**
     * A Map containing Config instances as keys and their cleanup functions as values.
     * @member {Map} dependencies=new Map()
     * @protected
     */
    dependencies = new Map()
    /**
     * The function to execute.
     * @member {Function|null} _fn=null
     */
    _fn = null
    /**
     * The unique identifier for this effect instance.
     * @member {String|null}
     */
    id = _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].getId('effect')
    /**
     * @member {Boolean}
     * @protected
     */
    isDestroyed = false
    /**
     * @member {Neo.core.Config}
     * @protected
     */
    isRunning = null

    /**
     * @member fn
     */
    get fn() {
        return this._fn
    }
    set fn(value) {
        this._fn = value;
        // Assigning a new function to `fn` automatically triggers a re-run.
        // This ensures that the effect immediately re-evaluates its dependencies
        // based on the new function's logic, clearing old dependencies and establishing new ones.
        this.run()
    }

    /**
     * @param {Function|Object}  fn              - The function to execute, or a config object for the effect.
     * @param {Function}        [fn.fn]          - The function to execute for the effect (if the first argument is an object).
     * @param {String}          [fn.componentId] - The component id this effect belongs to.
     * @param {Boolean}         [fn.lazy=false]  - If true, the effect will not run immediately upon creation.
     * @param {Object|Object[]} [fn.subscriber]  - A single subscriber or an array of subscribers for the isRunning config.
     * @param {Object}          [options={}]     - Optional. Used if the first argument is a function, this object contains the options.
     * @example
     * // Signature 1: Function and Options
     * const myEffect = new Effect(() => console.log('Run'), {lazy: true});
     * @example
     * // Signature 2: Single Config Object
     * const myEffect = new Effect({fn: () => console.log('Run'), lazy: true});
     */
    constructor(fn, options={}) {
        const me = this;

        // This single statement handles both (fn, options) and ({...}) signatures
        // by normalizing them into a single object that we can destructure.
        const {
              fn: effectFn,
              componentId,
              lazy = false,
              subscriber
        } = (typeof fn === 'function') ? { ...options, fn } : (fn || {});

        if (componentId) {
            me.componentId = componentId
        }

        me.isRunning = new _Config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](false);

        // The subscriber(s) must be added *before* the first run is triggered.
        // This is critical for consumers like functional components, which need to process
        // the initial VDOM synchronously within the constructor lifecycle.
        if (subscriber) {
            // A concise way to handle both single and array subscribers.
            [].concat(subscriber).forEach(sub => me.isRunning.subscribe(sub))
        }

        // If lazy, just store the function without running it.
        // Otherwise, use the setter to trigger the initial run.
        if (lazy) {
            me._fn = effectFn
        } else {
            me.fn = effectFn
        }
    }

    /**
     * Cleans up all subscriptions and destroys the effect.
     */
    destroy() {
        const me = this;

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        me.isDestroyed = true
    }

    /**
     * Executes the effect function, tracking its dependencies.
     * This is called automatically on creation and whenever a dependency changes.
     * The dynamic re-tracking ensures the effect always reflects its current dependencies,
     * even if the logic within `fn` changes conditionally.
     * @protected
     */
    run() {
        const me = this;

        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pause(); // Pause dependency tracking for isRunning.get()
        if (me.isDestroyed || me.isRunning.get()) {
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resume(); // Resume if we return early
            return
        }

        if (_EffectBatchManager_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].isBatchActive()) {
            _EffectBatchManager_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].queueEffect(me);
            return
        }

        me.isRunning.set(true);

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();

        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].push(me);
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resume();

        try {
            me.fn()
        } finally {
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pop();
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pause(); // Pause dependency tracking for isRunning.set(false)
            me.isRunning.set(false);
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resume() // Resume after isRunning.set(false)
        }
    }

    /**
     * Adds a `Neo.core.Config` instance as a dependency for this effect.
     * @param {Neo.core.Config} config The config instance to subscribe to.
     * @protected
     */
    addDependency(config) {
        const me = this;

        // Only add if not already a dependency. Map uses strict equality (===) for object keys.
        if (!me.dependencies.has(config)) {
            const cleanup = config.subscribe({
                id: me.id,
                fn: me.run.bind(me)
            });

            me.dependencies.set(config, cleanup)
        }
    }
}

Neo.core ??= {};

if (!Neo.core.Effect) {
    Neo.core.Effect = Effect;

    /**
     * Factory shortcut to create a new Neo.core.Effect instance.
     * @function Neo.effect
     * @param {Function|Object} fn - The function to execute, or a config object for the effect.
     * @param {Object} [options] - Optional. Used if the first argument is a function.
     * @returns {Neo.core.Effect}
     */
    Neo.effect = (fn, options) => new Effect(fn, options)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.core.Effect);


/***/ }),

/***/ "./src/functional/_export.mjs":
/*!************************************!*\
  !*** ./src/functional/_export.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* reexport safe */ _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   defineComponent: () => (/* reexport safe */ _defineComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   useConfig: () => (/* reexport safe */ _useConfig_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   useEvent: () => (/* reexport safe */ _useEvent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component/Base.mjs */ "./src/functional/component/Base.mjs");
/* harmony import */ var _defineComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defineComponent.mjs */ "./src/functional/defineComponent.mjs");
/* harmony import */ var _useConfig_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useConfig.mjs */ "./src/functional/useConfig.mjs");
/* harmony import */ var _useEvent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEvent.mjs */ "./src/functional/useEvent.mjs");








/***/ }),

/***/ "./src/functional/component/Base.mjs":
/*!*******************************************!*\
  !*** ./src/functional/component/Base.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _mixin_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixin/DomEvents.mjs */ "./src/mixin/DomEvents.mjs");
/* harmony import */ var _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/Effect.mjs */ "./src/core/Effect.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _mixin_VdomLifecycle_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixin/VdomLifecycle.mjs */ "./src/mixin/VdomLifecycle.mjs");








const
    activeDomListenersSymbol = Symbol.for('activeDomListeners'),
    hookIndexSymbol          = Symbol.for('hookIndex'),
    hooksSymbol              = Symbol.for('hooks'),
    pendingDomEventsSymbol   = Symbol.for('pendingDomEvents'),
    vdomToApplySymbol        = Symbol('vdomToApply');

/**
 * @class Neo.functional.component.Base
 * @extends Neo.core.Base
 * @mixes Neo.component.mixin.DomEvents
 * @mixes Neo.core.Observable
 * @mixes Neo.component.mixin.VdomLifecycle
 */
class FunctionalBase extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.functional.component.Base'
         * @protected
         */
        className: 'Neo.functional.component.Base',
        /**
         * @member {String} ntype='functional-component'
         * @protected
         */
        ntype: 'functional-component',
        /**
         * Custom CSS selectors to apply to the root level node of this component
         * @member {String[]} cls=null
         * @reactive
         */
        cls: null,
        /**
         * @member {Neo.core.Base[]} mixins=[DomEvents, Observable, VdomLifecycle]
         */
        mixins: [_mixin_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], _mixin_VdomLifecycle_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]],
        /**
         * True after the component render() method was called. Also fires the rendered event.
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * @member {String|null} parentId_=null
         * @protected
         * @reactive
         */
        parentId_: null,
        /**
         * The vdom markup for this component.
         * @member {Object} vdom={}
         */
        vdom: {},
        /**
         * The custom windowIs (timestamp) this component belongs to
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * Neo component instances, which got defined inside createVdom()
     * @member {Map|null} childComponents=null
     */
    childComponents = null
    /**
     * Internal flag which will get set to true while a component is waiting for its mountedPromise
     * @member {Boolean} isAwaitingMount=false
     * @protected
     */
    isAwaitingMount = false
    /**
     * Internal Map to store the next set of components after the createVdom() Effect has run.
     * @member {Map|null} nextChildComponents=null
     * @private
     */
    #nextChildComponents = null

    /**
     * A Promise that resolves when the component is mounted to the DOM.
     * This provides a convenient way to wait for the component to be fully
     * available and interactive before executing subsequent logic.
     *
     * It also handles unmounting by resetting the promise, so it can be safely
     * awaited again if the component is remounted.
     * @returns {Promise<Neo.component.Base>}
     */
    get mountedPromise() {
        let me = this;

        if (!me._mountedPromise) {
            me._mountedPromise = new Promise(resolve => {
                if (me.mounted) {
                    resolve(me);
                } else {
                    me.mountedPromiseResolve = resolve
                }
            })
        }

        return me._mountedPromise
    }

    /**
     * Convenience method to access the parent component
     * @returns {Neo.component.Base|null}
     */
    get parent() {
        let me = this;

        return me.parentComponent || (me.parentId === 'document.body' ? null : Neo.getComponent(me.parentId))
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me   = this,
            opts = {configurable: true, enumerable: false, writable: true};

        Object.defineProperties(me, {
            [activeDomListenersSymbol]: {...opts, value: []},
            [hookIndexSymbol]         : {...opts, value: 0},
            [hooksSymbol]             : {...opts, value: []},
            [pendingDomEventsSymbol]  : {...opts, value: []},
            [vdomToApplySymbol]       : {...opts, value: null}
        });

        // Creates a reactive effect that re-executes createVdom() when dependencies change.
        me.vdomEffect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]({
            fn: () => {
                me[hookIndexSymbol]        = 0;
                me[pendingDomEventsSymbol] = []; // Clear pending events for new render
                me[vdomToApplySymbol]      = me.createVdom(me, me.data)
            },
            componentId: me.id,
            subscriber : {
                id   : me.id,
                fn   : me.onEffectRunStateChange,
                scope: me
            }
        })
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);

        oldValue && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unregister(oldValue);
        value    && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].register(this)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            const me = this;

            if (value) { // mount
                me.initDomEvents();

                // Initial registration of DOM event listeners when component mounts
                me.applyPendingDomListeners();

                me.mountedPromiseResolve?.(this);
                delete me.mountedPromiseResolve
            } else { // unmount
                delete me._mountedPromise
            }
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        const me = this;

        if (value) {
            Neo.currentWorker.insertThemeFiles(value, me.__proto__)
        }

        me.childComponents?.forEach(childData => {
            childData.instance.windowId = value
        })

        // If a component gets moved into a different window, an update cycle might still be running.
        // Since the update might no longer get mapped, we want to re-enable this instance for future updates.
        if (oldValue) {
            me.isVdomUpdating = false
        }
    }

    /**
     * Applies the pending DOM event listeners and updates the active list.
     * @private
     */
    applyPendingDomListeners() {
        const
            me            = this,
            activeEvents  = me[activeDomListenersSymbol],
            pendingEvents = me[pendingDomEventsSymbol];

        if (pendingEvents.length > 0) {
            if (!Neo.isEqual(activeEvents, pendingEvents)) {
                if (activeEvents?.length > 0) {
                    // Remove old dynamic listeners
                    me.removeDomListeners(me[activeDomListenersSymbol])
                }

                me.addDomListeners([...pendingEvents]);

                me[activeDomListenersSymbol] = [...pendingEvents]
            }

            // Clear pending events for next `createVdom()` Effect run
            me[pendingDomEventsSymbol] = []
        }
    }

    /**
     * Override this method in your functional component to return its VDOM structure.
     * This method will be automatically re-executed when any of the component's configs change.
     * @param {Neo.functional.component.Base} config - Mental model: while it contains the instance, it makes it clear to access configs
     * @param {Object}                        data   - Convenience shortcut for accessing `state.Provider` data
     * @returns {Object} The VDOM structure for the component.
     */
    createVdom(config, data) {
        // This method should be overridden by subclasses
        return {}
    }

    /**
     *
     */
    destroy() {
        const me = this;

        me.vdomEffect?.destroy();

        // Destroy all classic components instantiated by this functional component
        me.childComponents?.forEach(childData => {
            childData.instance.destroy()
        });
        me.childComponents?.clear();

        me.removeDomEvents();

        // Remove any pending DOM event listeners that might not have been mounted
        me[pendingDomEventsSymbol] = null;

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unregister(me);

        super.destroy()
    }

    /**
     * This method recursively compares the new VDOM config with the last applied config
     * for a given component instance and its sub-instances.
     * @param {Neo.core.Base} instance The component instance to update.
     * @param {Object} newConfig The new configuration object from the VDOM.
     * @param {Object} lastConfig The last applied configuration object.
     * @private
     */
    diffAndSet(instance, newConfig, lastConfig) {
        const deltaConfig = {};

        for (const key in newConfig) {
            const newValue = newConfig[key],
                  oldValue = lastConfig[key];

            if (!Neo.isEqual(newValue, oldValue)) {
                // If the config property is an object and it maps to a sub-component instance, recurse.
                if (Neo.typeOf(newValue) === 'Object' && Neo.typeOf(instance[key]) === 'NeoInstance') {
                    this.diffAndSet(instance[key], newValue, oldValue || {})
                } else {
                    // Otherwise, add it to the delta to be set on the current instance.
                    deltaConfig[key] = newValue
                }
            }
        }

        // Only call set() if there are actual changes for the current instance.
        if (Object.keys(deltaConfig).length > 0) {
            instance.set(deltaConfig)
        }
    }

    /**
     * This handler runs when the effect's `isRunning` state changes.
     * It runs outside the effect's tracking scope, preventing feedback loops.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    onEffectRunStateChange(value, oldValue) {
        // When the effect has just finished running...
        if (value === false) {
            const me      = this,
                  newVdom = me[vdomToApplySymbol];

            if (newVdom) {
                // Create a new map for components instantiated in this render cycle
                me.#nextChildComponents = new Map();

                // Process the newVdom to instantiate components
                // The parentId for these components will be the functional component's id
                const processedVdom = me.processVdomForComponents(newVdom, me.id);

                // Destroy components that are no longer present in the new VDOM
                if (me.childComponents?.size > 0) {
                    [...me.childComponents].forEach(([key, childData]) => {
                        if (!me.#nextChildComponents.has(key)) {
                            me.childComponents.delete(key);
                            childData.instance.destroy()
                        }
                    })
                }

                // If this component created other classic or functional components,
                // include their full vdom into the next update cycle.
                const oldKeys = me.childComponents ? new Set(me.childComponents.keys()) : new Set();
                let hasNewChildren = false;

                for (const newKey of me.#nextChildComponents.keys()) {
                    if (!oldKeys.has(newKey)) {
                        hasNewChildren = true;
                        break
                    }
                }

                if (hasNewChildren) {
                    // When new child components are created, we need to send their full VDOM
                    // to the vdom-worker, so they can get rendered.
                    // Subsequent updates will be granular via diffAndSet() => set() on the child.
                    me.updateDepth = -1;
                }

                // Update the main map of instantiated components
                me.childComponents = me.#nextChildComponents;

                // Clear the old vdom properties
                for (const key in me.vdom) {
                    delete me.vdom[key]
                }

                // Assign the new properties
                Object.assign(me.vdom, processedVdom); // Use processedVdom here

                me[vdomToApplySymbol] = null;

                const root = me.getVdomRoot();

                if (me.cls) {
                    root.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].union(me.cls, root.cls)
                }

                if (me.id) {
                    root.id = me.id
                }

                me.updateVdom();

                // Update DOM event listeners based on the new render
                if (me.mounted) {
                    me.applyPendingDomListeners()
                }
            }
        }
    }

    /**
     * Recursively processes a VDOM node to instantiate components defined within it.
     * @param {Object} vdomTree The VDOM node to process.
     * @param {String} parentId The ID of the parent component (the functional component hosting it).
     * @param {Number} [parentIndex] The index of the vdomNode within its parent's children.
     * @returns {Object} The processed VDOM node, potentially replaced with a component reference.
     * @private
     */
    processVdomForComponents(vdomTree, parentId, parentIndex) {
        if (!vdomTree) {
            return vdomTree
        }

        // If it's already a component reference, no need to process further
        if (vdomTree.componentId) {
            return vdomTree
        }

        const me = this;

        // Check if it's a component definition (functional or classic)
        if (vdomTree.className || vdomTree.module || vdomTree.ntype) {
            // Components are reconciled based on their `id` property in the VDOM definition.
            // If no `id` is provided, a new instance will be created on every render.
            const componentKey = vdomTree.id;

            if (!componentKey) {
                console.error([
                    'Component definition in functional component VDOM is missing an "id". For stable reconciliation, ',
                    'especially in dynamic lists, provide a unique "id" property.'
                    ].join(''),
                    vdomTree
                )
            }

            let childData = me.childComponents?.get(componentKey),
                newConfig = {...vdomTree}, // Shallow copy
                instance;

            delete newConfig.className;
            delete newConfig.id;
            delete newConfig.module;
            delete newConfig.ntype;

            if (!childData) {
                me.childComponents ??= new Map();

                // Instantiate the component
                instance = Neo[(vdomTree.className || vdomTree.module) ? 'create' : 'ntype']({
                    ...vdomTree,
                    parentId,
                    parentIndex,
                    windowId: me.windowId
                });
            } else {
                instance = childData.instance;

                // Recursively diff and set configs
                this.diffAndSet(instance, newConfig, childData.lastConfig);
            }

            // Add to the new map for tracking in this render cycle
            me.#nextChildComponents.set(componentKey, {
                instance,
                lastConfig: newConfig
            });

            // Replace the definition with a reference using the component's own method
            return instance.createVdomReference();
        }

        // Recursively process children
        if (vdomTree.cn && Array.isArray(vdomTree.cn)) {
            vdomTree.cn = vdomTree.cn.map((child, index) =>
                me.processVdomForComponents(child, parentId, index)
            )
        }

        return vdomTree
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} silent=false
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        let me = this;

        me.silentVdomUpdate = true;

        super.set(values);

        me.silentVdomUpdate = false;

        if (silent || !me.needsVdomUpdate) {
            return Promise.resolve()
        }

        return me.promiseUpdate()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(FunctionalBase));


/***/ }),

/***/ "./src/functional/defineComponent.mjs":
/*!********************************************!*\
  !*** ./src/functional/defineComponent.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defineComponent: () => (/* binding */ defineComponent)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component/Base.mjs */ "./src/functional/component/Base.mjs");


/**
 * Factory function to create a functional component class from a specification object.
 * This enables a "Beginner Mode" for creating components without writing a class,
 * while still providing access to the full class-based feature set.
 *
 * It's important to understand the two ways of managing state:
 *
 * 1.  **Named Configs (Public API):** Defined in the `config` object (e.g., `text_`).
 *     - **Purpose:** Defines the component's public API for external control, similar to props.
 *     - **Use Case:** For data that a parent component will set or change.
 *     - **Features:** Integrates with the full config system (e.g., `afterSetText()` hooks).
 *
 * 2.  **`useConfig()` (Internal State):** Used inside `createVdom` or other methods.
 *     - **Purpose:** Manages private, encapsulated state that is internal to the component.
 *     - **Use Case:** For state that the component manages itself and is not controlled by the parent.
 *     - **Features:** Provides a simple, concise way to handle local reactive state.
 *
 * @param {Object} spec - The specification object for the component.
 * @returns {Neo.functional.component.Base} The generated component class.
 *
 * @example
 * import { defineComponent } from 'neo/functional/defineComponent.mjs';
 * import { useConfig }       from 'neo/functional/useConfig.mjs';
 *
 * const MyComponent = defineComponent({
 *     // 1. Define the Public API via the `config` object.
 *     config: {
 *         className: 'MyApp.MyFunctionalComponent',
 *         ntype    : 'my-functional-component',
 *
 *         // `text_` is a NAMED CONFIG. It's part of the component's public API.
 *         // A parent can create this component with a `text` config.
 *         // It is reactive and will generate `afterSetText()` and `beforeSetText()` hooks.
 *         text_: 'Hello World'
 *     },
 *
 *     // 2. Define the component's logic and VDOM.
 *     createVdom(config) {
 *         // `useConfig` creates ANONYMOUS, INTERNAL STATE.
 *         // The `count` state is private to this component and cannot be set by a parent.
 *         const [count, setCount] = useConfig(0);
 *
 *         return {
 *             tag: 'div',
 *             cn: [{
 *                 tag: 'h1',
 *                 // Access the public, named config via the `config` parameter.
 *                 text: config.text
 *             }, {
 *                 tag: 'p',
 *                 // Access the private, internal state directly.
 *                 text: `You clicked ${count} times`
 *             }, {
 *                 tag: 'button',
 *                 text: 'Click me',
 *                 // The setter from `useConfig` updates the internal state.
 *                 onclick: () => setCount(count + 1)
 *             }]
 *         };
 *     },
 *
 *     // 3. Lifecycle hooks for named configs work automatically.
 *     afterSetText(newValue, oldValue) {
 *         console.log(`Text changed from '${oldValue}' to '${newValue}'`);
 *     }
 * });
 *
 * // The returned MyComponent is a class constructor that can be used with Neo.create()
 * // const instance = Neo.create(MyComponent, {
 * //     text: 'Welcome to Neo.mjs!' // Set the public config on creation.
 * // });
 */
function defineComponent(spec) {
    const configSpec = spec.config;
    delete spec.config;

    if (!configSpec?.className) {
        throw new Error('defineComponent requires a config object with a className.');
    }

    class FunctionalComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
        static config = {
            ...configSpec
            // We can add our own configurations here
        }
    }

    // Assign instance methods
    Object.entries(spec).forEach(([key, value]) => {
        FunctionalComponent.prototype[key] = value
    });

    // To support multiple envs (like `devmode`, `dist/esm`, `dist/production` in parallel,
    // we must re-assign FunctionalComponent to the setupClass() output.
    FunctionalComponent = Neo.setupClass(FunctionalComponent);

    return FunctionalComponent
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defineComponent);


/***/ }),

/***/ "./src/functional/useConfig.mjs":
/*!**************************************!*\
  !*** ./src/functional/useConfig.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   useConfig: () => (/* binding */ useConfig)
/* harmony export */ });
/* harmony import */ var _core_Config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/EffectManager.mjs */ "./src/core/EffectManager.mjs");



const
    hookIndexSymbol = Symbol.for('hookIndex'),
    hooksSymbol     = Symbol.for('hooks');

/**
 * A hook for managing reactive state within a functional component's `createVdom` method.
 * It mirrors the behavior of React's `useState` but is powered by `Neo.core.Config` for reactivity.
 * @param {*} initialValue The initial value for the state.
 * @returns {Array<any>} A tuple containing the current value and a setter function.
 */
function useConfig(initialValue) {
    _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pause();

    const
        effect    = _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getActiveEffect(),
        component = effect && Neo.getComponent(effect.componentId);

    if (!component) {
        throw new Error('useConfig must be called from within a functional component\'s createVdom method.')
    }

    const currentIndex = component[hookIndexSymbol];

    // Increment the index for the next hook call within the same component render cycle.
    component[hookIndexSymbol]++;

    // If this is the first time this hook is being called for this component, initialize its state.
    if (!component[hooksSymbol][currentIndex]) {
        const config = new _core_Config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](initialValue);

        const customSetter = (newValue) => {
            if (typeof newValue === 'function') {
                newValue = newValue(config.get())
            }
            config.set(newValue)
        };

        component[hooksSymbol][currentIndex] = [config, customSetter]
    }

    const [config, setter] = component[hooksSymbol][currentIndex];

    _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resume();

    // Call config.get() to ensure this component's effect tracks this config as a dependency.
    return [config.get(), setter]
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useConfig);


/***/ }),

/***/ "./src/functional/useEvent.mjs":
/*!*************************************!*\
  !*** ./src/functional/useEvent.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   useEvent: () => (/* binding */ useEvent)
/* harmony export */ });
/* harmony import */ var _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EffectManager.mjs */ "./src/core/EffectManager.mjs");


const pendingDomEventsSymbol = Symbol.for('pendingDomEvents');

/**
 * A hook for registering DOM event listeners within a functional component.
 * Event listeners registered via this hook will be managed by Neo.mjs's
 * delegated DOM event system, ensuring efficient and proper lifecycle handling.
 *
 * @param {String} eventType - The type of DOM event to listen for (e.g., 'click', 'input').
 * @param {Function} handler - The event handler function. It will receive the event data as its argument.
 * @param {String} [delegate] - An optional CSS selector for event delegation. If provided,
 *                               the handler will only fire if the event target matches this selector.
 */
function useEvent(eventType, handler, delegate) {
    const
        activeEffect = _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getActiveEffect(),
        componentId  = activeEffect?.componentId;

    if (!componentId) {
        throw new Error('useEvent must be called from within a functional component\'s createVdom method.')
    }

    _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].pause();
    const component = Neo.getComponent(componentId);
    _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].resume();

    if (!component) {
        throw new Error(`Component with id ${componentId} not found for useEvent hook.`);
    }

    // Ensure pendingDomEventsSymbol exists on the component instance
    component[pendingDomEventsSymbol] ??= [];

    // Add the event listener configuration to the component's pending list
    component[pendingDomEventsSymbol].push({
        [eventType]: handler,
        delegate,
        scope      : component // The component instance itself will be the scope
    })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useEvent);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mdW5jdGlvbmFsX19leHBvcnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ087QUFDSztBQUNQOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVMsd0RBQVc7QUFDcEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxpQkFBaUIsV0FBVztBQUMzQztBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBeUM7QUFDN0U7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUEsa0VBQWtFLElBQUk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUMsaUJBQWlCLFdBQVc7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbURBQU07O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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QTtBQUNBOztBQUVBLGlFQUFlLFNBQVMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRDZCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNPO0FBQ1A7QUFDQSx1QkFBdUIsK0RBQWE7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksK0RBQWE7QUFDakI7QUFDQSxJQUFJLCtEQUFhOztBQUVqQjtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxpRUFBZSxRQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvRWZmZWN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Z1bmN0aW9uYWwvX2V4cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mdW5jdGlvbmFsL2NvbXBvbmVudC9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Z1bmN0aW9uYWwvZGVmaW5lQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Z1bmN0aW9uYWwvdXNlQ29uZmlnLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Z1bmN0aW9uYWwvdXNlRXZlbnQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb25maWcgICAgICAgICAgICAgZnJvbSAnLi9Db25maWcubWpzJztcbmltcG9ydCBFZmZlY3RNYW5hZ2VyICAgICAgZnJvbSAnLi9FZmZlY3RNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgRWZmZWN0QmF0Y2hNYW5hZ2VyIGZyb20gJy4vRWZmZWN0QmF0Y2hNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgSWRHZW5lcmF0b3IgICAgICAgIGZyb20gJy4vSWRHZW5lcmF0b3IubWpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgYXV0b21hdGljYWxseSB0cmFja3MgaXRzIGRlcGVuZGVuY2llcyBhbmQgcmUtcnVucyB3aGVuIGFueSBvZiB0aGVtIGNoYW5nZS5cbiAqIFRoaXMgaXMgYSBsaWdodHdlaWdodCwgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcyBmb3IgcGVyZm9ybWFuY2UuXG4gKiBJdCBzZXJ2ZXMgYXMgYSBjb3JlIHJlYWN0aXZlIHByaW1pdGl2ZSwgZW5hYmxpbmcgYXV0b21hdGljIGFuZCBkeW5hbWljIGRlcGVuZGVuY3kgdHJhY2tpbmcuXG4gKiBAY2xhc3MgTmVvLmNvcmUuRWZmZWN0XG4gKi9cbmNsYXNzIEVmZmVjdCB7XG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGNvbXBvbmVudCBpZCB0aGlzIGVmZmVjdCBiZWxvbmdzIHRvLlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb21wb25lbnRJZD1udWxsXG4gICAgICovXG4gICAgY29tcG9uZW50SWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQSBNYXAgY29udGFpbmluZyBDb25maWcgaW5zdGFuY2VzIGFzIGtleXMgYW5kIHRoZWlyIGNsZWFudXAgZnVuY3Rpb25zIGFzIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyIHtNYXB9IGRlcGVuZGVuY2llcz1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb258bnVsbH0gX2ZuPW51bGxcbiAgICAgKi9cbiAgICBfZm4gPSBudWxsXG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGVmZmVjdCBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBpZCA9IElkR2VuZXJhdG9yLmdldElkKCdlZmZlY3QnKVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzRGVzdHJveWVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5Db25maWd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzUnVubmluZyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgZm5cbiAgICAgKi9cbiAgICBnZXQgZm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mblxuICAgIH1cbiAgICBzZXQgZm4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZm4gPSB2YWx1ZTtcbiAgICAgICAgLy8gQXNzaWduaW5nIGEgbmV3IGZ1bmN0aW9uIHRvIGBmbmAgYXV0b21hdGljYWxseSB0cmlnZ2VycyBhIHJlLXJ1bi5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGVmZmVjdCBpbW1lZGlhdGVseSByZS1ldmFsdWF0ZXMgaXRzIGRlcGVuZGVuY2llc1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgbmV3IGZ1bmN0aW9uJ3MgbG9naWMsIGNsZWFyaW5nIG9sZCBkZXBlbmRlbmNpZXMgYW5kIGVzdGFibGlzaGluZyBuZXcgb25lcy5cbiAgICAgICAgdGhpcy5ydW4oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSAgZm4gICAgICAgICAgICAgIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIG9yIGEgY29uZmlnIG9iamVjdCBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgW2ZuLmZuXSAgICAgICAgICAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciB0aGUgZWZmZWN0IChpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0KS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgW2ZuLmNvbXBvbmVudElkXSAtIFRoZSBjb21wb25lbnQgaWQgdGhpcyBlZmZlY3QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW2ZuLmxhenk9ZmFsc2VdICAtIElmIHRydWUsIHRoZSBlZmZlY3Qgd2lsbCBub3QgcnVuIGltbWVkaWF0ZWx5IHVwb24gY3JlYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IFtmbi5zdWJzY3JpYmVyXSAgLSBBIHNpbmdsZSBzdWJzY3JpYmVyIG9yIGFuIGFycmF5IG9mIHN1YnNjcmliZXJzIGZvciB0aGUgaXNSdW5uaW5nIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnM9e31dICAgICAtIE9wdGlvbmFsLiBVc2VkIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCB0aGlzIG9iamVjdCBjb250YWlucyB0aGUgb3B0aW9ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNpZ25hdHVyZSAxOiBGdW5jdGlvbiBhbmQgT3B0aW9uc1xuICAgICAqIGNvbnN0IG15RWZmZWN0ID0gbmV3IEVmZmVjdCgoKSA9PiBjb25zb2xlLmxvZygnUnVuJyksIHtsYXp5OiB0cnVlfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaWduYXR1cmUgMjogU2luZ2xlIENvbmZpZyBPYmplY3RcbiAgICAgKiBjb25zdCBteUVmZmVjdCA9IG5ldyBFZmZlY3Qoe2ZuOiAoKSA9PiBjb25zb2xlLmxvZygnUnVuJyksIGxhenk6IHRydWV9KTtcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihmbiwgb3B0aW9ucz17fSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gVGhpcyBzaW5nbGUgc3RhdGVtZW50IGhhbmRsZXMgYm90aCAoZm4sIG9wdGlvbnMpIGFuZCAoey4uLn0pIHNpZ25hdHVyZXNcbiAgICAgICAgLy8gYnkgbm9ybWFsaXppbmcgdGhlbSBpbnRvIGEgc2luZ2xlIG9iamVjdCB0aGF0IHdlIGNhbiBkZXN0cnVjdHVyZS5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBmbjogZWZmZWN0Rm4sXG4gICAgICAgICAgICAgIGNvbXBvbmVudElkLFxuICAgICAgICAgICAgICBsYXp5ID0gZmFsc2UsXG4gICAgICAgICAgICAgIHN1YnNjcmliZXJcbiAgICAgICAgfSA9ICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpID8geyAuLi5vcHRpb25zLCBmbiB9IDogKGZuIHx8IHt9KTtcblxuICAgICAgICBpZiAoY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIG1lLmNvbXBvbmVudElkID0gY29tcG9uZW50SWRcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzUnVubmluZyA9IG5ldyBDb25maWcoZmFsc2UpO1xuXG4gICAgICAgIC8vIFRoZSBzdWJzY3JpYmVyKHMpIG11c3QgYmUgYWRkZWQgKmJlZm9yZSogdGhlIGZpcnN0IHJ1biBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIC8vIFRoaXMgaXMgY3JpdGljYWwgZm9yIGNvbnN1bWVycyBsaWtlIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgd2hpY2ggbmVlZCB0byBwcm9jZXNzXG4gICAgICAgIC8vIHRoZSBpbml0aWFsIFZET00gc3luY2hyb25vdXNseSB3aXRoaW4gdGhlIGNvbnN0cnVjdG9yIGxpZmVjeWNsZS5cbiAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIC8vIEEgY29uY2lzZSB3YXkgdG8gaGFuZGxlIGJvdGggc2luZ2xlIGFuZCBhcnJheSBzdWJzY3JpYmVycy5cbiAgICAgICAgICAgIFtdLmNvbmNhdChzdWJzY3JpYmVyKS5mb3JFYWNoKHN1YiA9PiBtZS5pc1J1bm5pbmcuc3Vic2NyaWJlKHN1YikpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsYXp5LCBqdXN0IHN0b3JlIHRoZSBmdW5jdGlvbiB3aXRob3V0IHJ1bm5pbmcgaXQuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBzZXR0ZXIgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBydW4uXG4gICAgICAgIGlmIChsYXp5KSB7XG4gICAgICAgICAgICBtZS5fZm4gPSBlZmZlY3RGblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuZm4gPSBlZmZlY3RGblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGFsbCBzdWJzY3JpcHRpb25zIGFuZCBkZXN0cm95cyB0aGUgZWZmZWN0LlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kZXBlbmRlbmNpZXMuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5jbGVhcigpO1xuICAgICAgICBtZS5pc0Rlc3Ryb3llZCA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgZWZmZWN0IGZ1bmN0aW9uLCB0cmFja2luZyBpdHMgZGVwZW5kZW5jaWVzLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgb24gY3JlYXRpb24gYW5kIHdoZW5ldmVyIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICAgICAqIFRoZSBkeW5hbWljIHJlLXRyYWNraW5nIGVuc3VyZXMgdGhlIGVmZmVjdCBhbHdheXMgcmVmbGVjdHMgaXRzIGN1cnJlbnQgZGVwZW5kZW5jaWVzLFxuICAgICAqIGV2ZW4gaWYgdGhlIGxvZ2ljIHdpdGhpbiBgZm5gIGNoYW5nZXMgY29uZGl0aW9uYWxseS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcnVuKCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgRWZmZWN0TWFuYWdlci5wYXVzZSgpOyAvLyBQYXVzZSBkZXBlbmRlbmN5IHRyYWNraW5nIGZvciBpc1J1bm5pbmcuZ2V0KClcbiAgICAgICAgaWYgKG1lLmlzRGVzdHJveWVkIHx8IG1lLmlzUnVubmluZy5nZXQoKSkge1xuICAgICAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWUoKTsgLy8gUmVzdW1lIGlmIHdlIHJldHVybiBlYXJseVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRWZmZWN0QmF0Y2hNYW5hZ2VyLmlzQmF0Y2hBY3RpdmUoKSkge1xuICAgICAgICAgICAgRWZmZWN0QmF0Y2hNYW5hZ2VyLnF1ZXVlRWZmZWN0KG1lKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNSdW5uaW5nLnNldCh0cnVlKTtcblxuICAgICAgICBtZS5kZXBlbmRlbmNpZXMuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5jbGVhcigpO1xuXG4gICAgICAgIEVmZmVjdE1hbmFnZXIucHVzaChtZSk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lLmZuKClcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucG9wKCk7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnBhdXNlKCk7IC8vIFBhdXNlIGRlcGVuZGVuY3kgdHJhY2tpbmcgZm9yIGlzUnVubmluZy5zZXQoZmFsc2UpXG4gICAgICAgICAgICBtZS5pc1J1bm5pbmcuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lKCkgLy8gUmVzdW1lIGFmdGVyIGlzUnVubmluZy5zZXQoZmFsc2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYE5lby5jb3JlLkNvbmZpZ2AgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGlzIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkNvbmZpZ30gY29uZmlnIFRoZSBjb25maWcgaW5zdGFuY2UgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZGREZXBlbmRlbmN5KGNvbmZpZykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gT25seSBhZGQgaWYgbm90IGFscmVhZHkgYSBkZXBlbmRlbmN5LiBNYXAgdXNlcyBzdHJpY3QgZXF1YWxpdHkgKD09PSkgZm9yIG9iamVjdCBrZXlzLlxuICAgICAgICBpZiAoIW1lLmRlcGVuZGVuY2llcy5oYXMoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9IGNvbmZpZy5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIGlkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBmbjogbWUucnVuLmJpbmQobWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuZGVwZW5kZW5jaWVzLnNldChjb25maWcsIGNsZWFudXApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5jb3JlID8/PSB7fTtcblxuaWYgKCFOZW8uY29yZS5FZmZlY3QpIHtcbiAgICBOZW8uY29yZS5FZmZlY3QgPSBFZmZlY3Q7XG5cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IHNob3J0Y3V0IHRvIGNyZWF0ZSBhIG5ldyBOZW8uY29yZS5FZmZlY3QgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIE5lby5lZmZlY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSwgb3IgYSBjb25maWcgb2JqZWN0IGZvciB0aGUgZWZmZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbC4gVXNlZCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuRWZmZWN0fVxuICAgICAqL1xuICAgIE5lby5lZmZlY3QgPSAoZm4sIG9wdGlvbnMpID0+IG5ldyBFZmZlY3QoZm4sIG9wdGlvbnMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5jb3JlLkVmZmVjdDtcbiIsImltcG9ydCBDb21wb25lbnQgICAgICAgZnJvbSAnLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IGRlZmluZUNvbXBvbmVudCBmcm9tICcuL2RlZmluZUNvbXBvbmVudC5tanMnO1xuaW1wb3J0IHVzZUNvbmZpZyAgICAgICBmcm9tICcuL3VzZUNvbmZpZy5tanMnO1xuaW1wb3J0IHVzZUV2ZW50ICAgICAgICBmcm9tICcuL3VzZUV2ZW50Lm1qcyc7XG5cbmV4cG9ydCB7Q29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIHVzZUNvbmZpZywgdXNlRXZlbnR9O1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IERvbUV2ZW50cyAgICAgICAgZnJvbSAnLi4vLi4vbWl4aW4vRG9tRXZlbnRzLm1qcyc7XG5pbXBvcnQgRWZmZWN0ICAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0VmZmVjdC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICAgZnJvbSAnLi4vLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgVmRvbUxpZmVjeWNsZSAgICBmcm9tICcuLi8uLi9taXhpbi9WZG9tTGlmZWN5Y2xlLm1qcyc7XG5cbmNvbnN0XG4gICAgYWN0aXZlRG9tTGlzdGVuZXJzU3ltYm9sID0gU3ltYm9sLmZvcignYWN0aXZlRG9tTGlzdGVuZXJzJyksXG4gICAgaG9va0luZGV4U3ltYm9sICAgICAgICAgID0gU3ltYm9sLmZvcignaG9va0luZGV4JyksXG4gICAgaG9va3NTeW1ib2wgICAgICAgICAgICAgID0gU3ltYm9sLmZvcignaG9va3MnKSxcbiAgICBwZW5kaW5nRG9tRXZlbnRzU3ltYm9sICAgPSBTeW1ib2wuZm9yKCdwZW5kaW5nRG9tRXZlbnRzJyksXG4gICAgdmRvbVRvQXBwbHlTeW1ib2wgICAgICAgID0gU3ltYm9sKCd2ZG9tVG9BcHBseScpO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZnVuY3Rpb25hbC5jb21wb25lbnQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb21wb25lbnQubWl4aW4uRG9tRXZlbnRzXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICogQG1peGVzIE5lby5jb21wb25lbnQubWl4aW4uVmRvbUxpZmVjeWNsZVxuICovXG5jbGFzcyBGdW5jdGlvbmFsQmFzZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Z1bmN0aW9uYWwtY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Z1bmN0aW9uYWwtY29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBDU1Mgc2VsZWN0b3JzIHRvIGFwcGx5IHRvIHRoZSByb290IGxldmVsIG5vZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvcmUuQmFzZVtdfSBtaXhpbnM9W0RvbUV2ZW50cywgT2JzZXJ2YWJsZSwgVmRvbUxpZmVjeWNsZV1cbiAgICAgICAgICovXG4gICAgICAgIG1peGluczogW0RvbUV2ZW50cywgT2JzZXJ2YWJsZSwgVmRvbUxpZmVjeWNsZV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGFmdGVyIHRoZSBjb21wb25lbnQgcmVuZGVyKCkgbWV0aG9kIHdhcyBjYWxsZWQuIEFsc28gZmlyZXMgdGhlIHJlbmRlcmVkIGV2ZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3VudGVkXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHBhcmVudElkXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRJZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmRvbSBtYXJrdXAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209e31cbiAgICAgICAgICovXG4gICAgICAgIHZkb206IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1c3RvbSB3aW5kb3dJcyAodGltZXN0YW1wKSB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lbyBjb21wb25lbnQgaW5zdGFuY2VzLCB3aGljaCBnb3QgZGVmaW5lZCBpbnNpZGUgY3JlYXRlVmRvbSgpXG4gICAgICogQG1lbWJlciB7TWFwfG51bGx9IGNoaWxkQ29tcG9uZW50cz1udWxsXG4gICAgICovXG4gICAgY2hpbGRDb21wb25lbnRzID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgd2hpbGUgYSBjb21wb25lbnQgaXMgd2FpdGluZyBmb3IgaXRzIG1vdW50ZWRQcm9taXNlXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNBd2FpdGluZ01vdW50PWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzQXdhaXRpbmdNb3VudCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgTWFwIHRvIHN0b3JlIHRoZSBuZXh0IHNldCBvZiBjb21wb25lbnRzIGFmdGVyIHRoZSBjcmVhdGVWZG9tKCkgRWZmZWN0IGhhcyBydW4uXG4gICAgICogQG1lbWJlciB7TWFwfG51bGx9IG5leHRDaGlsZENvbXBvbmVudHM9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI25leHRDaGlsZENvbXBvbmVudHMgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCB0byB0aGUgRE9NLlxuICAgICAqIFRoaXMgcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byB3YWl0IGZvciB0aGUgY29tcG9uZW50IHRvIGJlIGZ1bGx5XG4gICAgICogYXZhaWxhYmxlIGFuZCBpbnRlcmFjdGl2ZSBiZWZvcmUgZXhlY3V0aW5nIHN1YnNlcXVlbnQgbG9naWMuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGhhbmRsZXMgdW5tb3VudGluZyBieSByZXNldHRpbmcgdGhlIHByb21pc2UsIHNvIGl0IGNhbiBiZSBzYWZlbHlcbiAgICAgKiBhd2FpdGVkIGFnYWluIGlmIHRoZSBjb21wb25lbnQgaXMgcmVtb3VudGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby5jb21wb25lbnQuQmFzZT59XG4gICAgICovXG4gICAgZ2V0IG1vdW50ZWRQcm9taXNlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuX21vdW50ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICBtZS5fbW91bnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudGVkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5fbW91bnRlZFByb21pc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWNjZXNzIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLnBhcmVudENvbXBvbmVudCB8fCAobWUucGFyZW50SWQgPT09ICdkb2N1bWVudC5ib2R5JyA/IG51bGwgOiBOZW8uZ2V0Q29tcG9uZW50KG1lLnBhcmVudElkKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBvcHRzID0ge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlfTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZSwge1xuICAgICAgICAgICAgW2FjdGl2ZURvbUxpc3RlbmVyc1N5bWJvbF06IHsuLi5vcHRzLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW2hvb2tJbmRleFN5bWJvbF0gICAgICAgICA6IHsuLi5vcHRzLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICBbaG9va3NTeW1ib2xdICAgICAgICAgICAgIDogey4uLm9wdHMsIHZhbHVlOiBbXX0sXG4gICAgICAgICAgICBbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF0gIDogey4uLm9wdHMsIHZhbHVlOiBbXX0sXG4gICAgICAgICAgICBbdmRvbVRvQXBwbHlTeW1ib2xdICAgICAgIDogey4uLm9wdHMsIHZhbHVlOiBudWxsfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGVzIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgcmUtZXhlY3V0ZXMgY3JlYXRlVmRvbSgpIHdoZW4gZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgICAgICAgbWUudmRvbUVmZmVjdCA9IG5ldyBFZmZlY3Qoe1xuICAgICAgICAgICAgZm46ICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZVtob29rSW5kZXhTeW1ib2xdICAgICAgICA9IDA7XG4gICAgICAgICAgICAgICAgbWVbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF0gPSBbXTsgLy8gQ2xlYXIgcGVuZGluZyBldmVudHMgZm9yIG5ldyByZW5kZXJcbiAgICAgICAgICAgICAgICBtZVt2ZG9tVG9BcHBseVN5bWJvbF0gICAgICA9IG1lLmNyZWF0ZVZkb20obWUsIG1lLmRhdGEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcG9uZW50SWQ6IG1lLmlkLFxuICAgICAgICAgICAgc3Vic2NyaWJlciA6IHtcbiAgICAgICAgICAgICAgICBpZCAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgZm4gICA6IG1lLm9uRWZmZWN0UnVuU3RhdGVDaGFuZ2UsXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBvbGRWYWx1ZSAmJiBDb21wb25lbnRNYW5hZ2VyLnVucmVnaXN0ZXIob2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAgICAmJiBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7IC8vIG1vdW50XG4gICAgICAgICAgICAgICAgbWUuaW5pdERvbUV2ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCByZWdpc3RyYXRpb24gb2YgRE9NIGV2ZW50IGxpc3RlbmVycyB3aGVuIGNvbXBvbmVudCBtb3VudHNcbiAgICAgICAgICAgICAgICBtZS5hcHBseVBlbmRpbmdEb21MaXN0ZW5lcnMoKTtcblxuICAgICAgICAgICAgICAgIG1lLm1vdW50ZWRQcm9taXNlUmVzb2x2ZT8uKHRoaXMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZS5tb3VudGVkUHJvbWlzZVJlc29sdmVcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVubW91bnRcbiAgICAgICAgICAgICAgICBkZWxldGUgbWUuX21vdW50ZWRQcm9taXNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgbWUuX19wcm90b19fKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuY2hpbGRDb21wb25lbnRzPy5mb3JFYWNoKGNoaWxkRGF0YSA9PiB7XG4gICAgICAgICAgICBjaGlsZERhdGEuaW5zdGFuY2Uud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIElmIGEgY29tcG9uZW50IGdldHMgbW92ZWQgaW50byBhIGRpZmZlcmVudCB3aW5kb3csIGFuIHVwZGF0ZSBjeWNsZSBtaWdodCBzdGlsbCBiZSBydW5uaW5nLlxuICAgICAgICAvLyBTaW5jZSB0aGUgdXBkYXRlIG1pZ2h0IG5vIGxvbmdlciBnZXQgbWFwcGVkLCB3ZSB3YW50IHRvIHJlLWVuYWJsZSB0aGlzIGluc3RhbmNlIGZvciBmdXR1cmUgdXBkYXRlcy5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBwZW5kaW5nIERPTSBldmVudCBsaXN0ZW5lcnMgYW5kIHVwZGF0ZXMgdGhlIGFjdGl2ZSBsaXN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXBwbHlQZW5kaW5nRG9tTGlzdGVuZXJzKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhY3RpdmVFdmVudHMgID0gbWVbYWN0aXZlRG9tTGlzdGVuZXJzU3ltYm9sXSxcbiAgICAgICAgICAgIHBlbmRpbmdFdmVudHMgPSBtZVtwZW5kaW5nRG9tRXZlbnRzU3ltYm9sXTtcblxuICAgICAgICBpZiAocGVuZGluZ0V2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKGFjdGl2ZUV2ZW50cywgcGVuZGluZ0V2ZW50cykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXZlbnRzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgZHluYW1pYyBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgbWUucmVtb3ZlRG9tTGlzdGVuZXJzKG1lW2FjdGl2ZURvbUxpc3RlbmVyc1N5bWJvbF0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFsuLi5wZW5kaW5nRXZlbnRzXSk7XG5cbiAgICAgICAgICAgICAgICBtZVthY3RpdmVEb21MaXN0ZW5lcnNTeW1ib2xdID0gWy4uLnBlbmRpbmdFdmVudHNdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHBlbmRpbmcgZXZlbnRzIGZvciBuZXh0IGBjcmVhdGVWZG9tKClgIEVmZmVjdCBydW5cbiAgICAgICAgICAgIG1lW3BlbmRpbmdEb21FdmVudHNTeW1ib2xdID0gW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluIHlvdXIgZnVuY3Rpb25hbCBjb21wb25lbnQgdG8gcmV0dXJuIGl0cyBWRE9NIHN0cnVjdHVyZS5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmUtZXhlY3V0ZWQgd2hlbiBhbnkgb2YgdGhlIGNvbXBvbmVudCdzIGNvbmZpZ3MgY2hhbmdlLlxuICAgICAqIEBwYXJhbSB7TmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2V9IGNvbmZpZyAtIE1lbnRhbCBtb2RlbDogd2hpbGUgaXQgY29udGFpbnMgdGhlIGluc3RhbmNlLCBpdCBtYWtlcyBpdCBjbGVhciB0byBhY2Nlc3MgY29uZmlnc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgICAtIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBhY2Nlc3NpbmcgYHN0YXRlLlByb3ZpZGVyYCBkYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIFZET00gc3RydWN0dXJlIGZvciB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGNyZWF0ZVZkb20oY29uZmlnLCBkYXRhKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXNcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmRvbUVmZmVjdD8uZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIERlc3Ryb3kgYWxsIGNsYXNzaWMgY29tcG9uZW50cyBpbnN0YW50aWF0ZWQgYnkgdGhpcyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgICBtZS5jaGlsZENvbXBvbmVudHM/LmZvckVhY2goY2hpbGREYXRhID0+IHtcbiAgICAgICAgICAgIGNoaWxkRGF0YS5pbnN0YW5jZS5kZXN0cm95KClcbiAgICAgICAgfSk7XG4gICAgICAgIG1lLmNoaWxkQ29tcG9uZW50cz8uY2xlYXIoKTtcblxuICAgICAgICBtZS5yZW1vdmVEb21FdmVudHMoKTtcblxuICAgICAgICAvLyBSZW1vdmUgYW55IHBlbmRpbmcgRE9NIGV2ZW50IGxpc3RlbmVycyB0aGF0IG1pZ2h0IG5vdCBoYXZlIGJlZW4gbW91bnRlZFxuICAgICAgICBtZVtwZW5kaW5nRG9tRXZlbnRzU3ltYm9sXSA9IG51bGw7XG5cbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci51bnJlZ2lzdGVyKG1lKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZWN1cnNpdmVseSBjb21wYXJlcyB0aGUgbmV3IFZET00gY29uZmlnIHdpdGggdGhlIGxhc3QgYXBwbGllZCBjb25maWdcbiAgICAgKiBmb3IgYSBnaXZlbiBjb21wb25lbnQgaW5zdGFuY2UgYW5kIGl0cyBzdWItaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gaW5zdGFuY2UgVGhlIGNvbXBvbmVudCBpbnN0YW5jZSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0NvbmZpZyBUaGUgbmV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gdGhlIFZET00uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxhc3RDb25maWcgVGhlIGxhc3QgYXBwbGllZCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpZmZBbmRTZXQoaW5zdGFuY2UsIG5ld0NvbmZpZywgbGFzdENvbmZpZykge1xuICAgICAgICBjb25zdCBkZWx0YUNvbmZpZyA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld0NvbmZpZykge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBuZXdDb25maWdba2V5XSxcbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbGFzdENvbmZpZ1trZXldO1xuXG4gICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29uZmlnIHByb3BlcnR5IGlzIGFuIG9iamVjdCBhbmQgaXQgbWFwcyB0byBhIHN1Yi1jb21wb25lbnQgaW5zdGFuY2UsIHJlY3Vyc2UuXG4gICAgICAgICAgICAgICAgaWYgKE5lby50eXBlT2YobmV3VmFsdWUpID09PSAnT2JqZWN0JyAmJiBOZW8udHlwZU9mKGluc3RhbmNlW2tleV0pID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlmZkFuZFNldChpbnN0YW5jZVtrZXldLCBuZXdWYWx1ZSwgb2xkVmFsdWUgfHwge30pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgaXQgdG8gdGhlIGRlbHRhIHRvIGJlIHNldCBvbiB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgZGVsdGFDb25maWdba2V5XSA9IG5ld1ZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBjYWxsIHNldCgpIGlmIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcyBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWx0YUNvbmZpZykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0KGRlbHRhQ29uZmlnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYW5kbGVyIHJ1bnMgd2hlbiB0aGUgZWZmZWN0J3MgYGlzUnVubmluZ2Agc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBJdCBydW5zIG91dHNpZGUgdGhlIGVmZmVjdCdzIHRyYWNraW5nIHNjb3BlLCBwcmV2ZW50aW5nIGZlZWRiYWNrIGxvb3BzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgb25FZmZlY3RSdW5TdGF0ZUNoYW5nZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgZWZmZWN0IGhhcyBqdXN0IGZpbmlzaGVkIHJ1bm5pbmcuLi5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICBuZXdWZG9tID0gbWVbdmRvbVRvQXBwbHlTeW1ib2xdO1xuXG4gICAgICAgICAgICBpZiAobmV3VmRvbSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtYXAgZm9yIGNvbXBvbmVudHMgaW5zdGFudGlhdGVkIGluIHRoaXMgcmVuZGVyIGN5Y2xlXG4gICAgICAgICAgICAgICAgbWUuI25leHRDaGlsZENvbXBvbmVudHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBuZXdWZG9tIHRvIGluc3RhbnRpYXRlIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAvLyBUaGUgcGFyZW50SWQgZm9yIHRoZXNlIGNvbXBvbmVudHMgd2lsbCBiZSB0aGUgZnVuY3Rpb25hbCBjb21wb25lbnQncyBpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFZkb20gPSBtZS5wcm9jZXNzVmRvbUZvckNvbXBvbmVudHMobmV3VmRvbSwgbWUuaWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGVzdHJveSBjb21wb25lbnRzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50IGluIHRoZSBuZXcgVkRPTVxuICAgICAgICAgICAgICAgIGlmIChtZS5jaGlsZENvbXBvbmVudHM/LnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFsuLi5tZS5jaGlsZENvbXBvbmVudHNdLmZvckVhY2goKFtrZXksIGNoaWxkRGF0YV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWUuI25leHRDaGlsZENvbXBvbmVudHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5jaGlsZENvbXBvbmVudHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREYXRhLmluc3RhbmNlLmRlc3Ryb3koKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGNyZWF0ZWQgb3RoZXIgY2xhc3NpYyBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkZSB0aGVpciBmdWxsIHZkb20gaW50byB0aGUgbmV4dCB1cGRhdGUgY3ljbGUuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkS2V5cyA9IG1lLmNoaWxkQ29tcG9uZW50cyA/IG5ldyBTZXQobWUuY2hpbGRDb21wb25lbnRzLmtleXMoKSkgOiBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgbGV0IGhhc05ld0NoaWxkcmVuID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5ld0tleSBvZiBtZS4jbmV4dENoaWxkQ29tcG9uZW50cy5rZXlzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRLZXlzLmhhcyhuZXdLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNOZXdDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhc05ld0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbmV3IGNoaWxkIGNvbXBvbmVudHMgYXJlIGNyZWF0ZWQsIHdlIG5lZWQgdG8gc2VuZCB0aGVpciBmdWxsIFZET01cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHZkb20td29ya2VyLCBzbyB0aGV5IGNhbiBnZXQgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1YnNlcXVlbnQgdXBkYXRlcyB3aWxsIGJlIGdyYW51bGFyIHZpYSBkaWZmQW5kU2V0KCkgPT4gc2V0KCkgb24gdGhlIGNoaWxkLlxuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVEZXB0aCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFpbiBtYXAgb2YgaW5zdGFudGlhdGVkIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICBtZS5jaGlsZENvbXBvbmVudHMgPSBtZS4jbmV4dENoaWxkQ29tcG9uZW50cztcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBvbGQgdmRvbSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWUudmRvbSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWUudmRvbVtrZXldXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIHRoZSBuZXcgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUudmRvbSwgcHJvY2Vzc2VkVmRvbSk7IC8vIFVzZSBwcm9jZXNzZWRWZG9tIGhlcmVcblxuICAgICAgICAgICAgICAgIG1lW3Zkb21Ub0FwcGx5U3ltYm9sXSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByb290ID0gbWUuZ2V0VmRvbVJvb3QoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5jbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5jbHMgPSBOZW9BcnJheS51bmlvbihtZS5jbHMsIHJvb3QuY2xzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICByb290LmlkID0gbWUuaWRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS51cGRhdGVWZG9tKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgRE9NIGV2ZW50IGxpc3RlbmVycyBiYXNlZCBvbiB0aGUgbmV3IHJlbmRlclxuICAgICAgICAgICAgICAgIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFwcGx5UGVuZGluZ0RvbUxpc3RlbmVycygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgcHJvY2Vzc2VzIGEgVkRPTSBub2RlIHRvIGluc3RhbnRpYXRlIGNvbXBvbmVudHMgZGVmaW5lZCB3aXRoaW4gaXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21UcmVlIFRoZSBWRE9NIG5vZGUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWQgVGhlIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50ICh0aGUgZnVuY3Rpb25hbCBjb21wb25lbnQgaG9zdGluZyBpdCkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJlbnRJbmRleF0gVGhlIGluZGV4IG9mIHRoZSB2ZG9tTm9kZSB3aXRoaW4gaXRzIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9jZXNzZWQgVkRPTSBub2RlLCBwb3RlbnRpYWxseSByZXBsYWNlZCB3aXRoIGEgY29tcG9uZW50IHJlZmVyZW5jZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3NWZG9tRm9yQ29tcG9uZW50cyh2ZG9tVHJlZSwgcGFyZW50SWQsIHBhcmVudEluZGV4KSB7XG4gICAgICAgIGlmICghdmRvbVRyZWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZG9tVHJlZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGEgY29tcG9uZW50IHJlZmVyZW5jZSwgbm8gbmVlZCB0byBwcm9jZXNzIGZ1cnRoZXJcbiAgICAgICAgaWYgKHZkb21UcmVlLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmRvbVRyZWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgY29tcG9uZW50IGRlZmluaXRpb24gKGZ1bmN0aW9uYWwgb3IgY2xhc3NpYylcbiAgICAgICAgaWYgKHZkb21UcmVlLmNsYXNzTmFtZSB8fCB2ZG9tVHJlZS5tb2R1bGUgfHwgdmRvbVRyZWUubnR5cGUpIHtcbiAgICAgICAgICAgIC8vIENvbXBvbmVudHMgYXJlIHJlY29uY2lsZWQgYmFzZWQgb24gdGhlaXIgYGlkYCBwcm9wZXJ0eSBpbiB0aGUgVkRPTSBkZWZpbml0aW9uLlxuICAgICAgICAgICAgLy8gSWYgbm8gYGlkYCBpcyBwcm92aWRlZCwgYSBuZXcgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkIG9uIGV2ZXJ5IHJlbmRlci5cbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudEtleSA9IHZkb21UcmVlLmlkO1xuXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudEtleSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoW1xuICAgICAgICAgICAgICAgICAgICAnQ29tcG9uZW50IGRlZmluaXRpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnQgVkRPTSBpcyBtaXNzaW5nIGFuIFwiaWRcIi4gRm9yIHN0YWJsZSByZWNvbmNpbGlhdGlvbiwgJyxcbiAgICAgICAgICAgICAgICAgICAgJ2VzcGVjaWFsbHkgaW4gZHluYW1pYyBsaXN0cywgcHJvdmlkZSBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkuJ1xuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgICAgICAgICAgICAgICB2ZG9tVHJlZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNoaWxkRGF0YSA9IG1lLmNoaWxkQ29tcG9uZW50cz8uZ2V0KGNvbXBvbmVudEtleSksXG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnID0gey4uLnZkb21UcmVlfSwgLy8gU2hhbGxvdyBjb3B5XG4gICAgICAgICAgICAgICAgaW5zdGFuY2U7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBuZXdDb25maWcuY2xhc3NOYW1lO1xuICAgICAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5pZDtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdDb25maWcubW9kdWxlO1xuICAgICAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5udHlwZTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZERhdGEpIHtcbiAgICAgICAgICAgICAgICBtZS5jaGlsZENvbXBvbmVudHMgPz89IG5ldyBNYXAoKTtcblxuICAgICAgICAgICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IE5lb1sodmRvbVRyZWUuY2xhc3NOYW1lIHx8IHZkb21UcmVlLm1vZHVsZSkgPyAnY3JlYXRlJyA6ICdudHlwZSddKHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmRvbVRyZWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gY2hpbGREYXRhLmluc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZGlmZiBhbmQgc2V0IGNvbmZpZ3NcbiAgICAgICAgICAgICAgICB0aGlzLmRpZmZBbmRTZXQoaW5zdGFuY2UsIG5ld0NvbmZpZywgY2hpbGREYXRhLmxhc3RDb25maWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIG5ldyBtYXAgZm9yIHRyYWNraW5nIGluIHRoaXMgcmVuZGVyIGN5Y2xlXG4gICAgICAgICAgICBtZS4jbmV4dENoaWxkQ29tcG9uZW50cy5zZXQoY29tcG9uZW50S2V5LCB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbGFzdENvbmZpZzogbmV3Q29uZmlnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgZGVmaW5pdGlvbiB3aXRoIGEgcmVmZXJlbmNlIHVzaW5nIHRoZSBjb21wb25lbnQncyBvd24gbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuY3JlYXRlVmRvbVJlZmVyZW5jZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcHJvY2VzcyBjaGlsZHJlblxuICAgICAgICBpZiAodmRvbVRyZWUuY24gJiYgQXJyYXkuaXNBcnJheSh2ZG9tVHJlZS5jbikpIHtcbiAgICAgICAgICAgIHZkb21UcmVlLmNuID0gdmRvbVRyZWUuY24ubWFwKChjaGlsZCwgaW5kZXgpID0+XG4gICAgICAgICAgICAgICAgbWUucHJvY2Vzc1Zkb21Gb3JDb21wb25lbnRzKGNoaWxkLCBwYXJlbnRJZCwgaW5kZXgpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbVRyZWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgbXVsdGlwbGUgY29uZmlncyBhdCBvbmNlLCBlbnN1cmluZyB0aGF0IGFsbCBhZnRlclNldCBtZXRob2RzIGdldCBhbGwgbmV3IGFzc2lnbmVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHNldCh2YWx1ZXM9e30sIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHN1cGVyLnNldCh2YWx1ZXMpO1xuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2lsZW50IHx8ICFtZS5uZWVkc1Zkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLnByb21pc2VVcGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRnVuY3Rpb25hbEJhc2UpO1xuIiwiaW1wb3J0IEZ1bmN0aW9uYWxCYXNlIGZyb20gJy4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50IGNsYXNzIGZyb20gYSBzcGVjaWZpY2F0aW9uIG9iamVjdC5cbiAqIFRoaXMgZW5hYmxlcyBhIFwiQmVnaW5uZXIgTW9kZVwiIGZvciBjcmVhdGluZyBjb21wb25lbnRzIHdpdGhvdXQgd3JpdGluZyBhIGNsYXNzLFxuICogd2hpbGUgc3RpbGwgcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgZnVsbCBjbGFzcy1iYXNlZCBmZWF0dXJlIHNldC5cbiAqXG4gKiBJdCdzIGltcG9ydGFudCB0byB1bmRlcnN0YW5kIHRoZSB0d28gd2F5cyBvZiBtYW5hZ2luZyBzdGF0ZTpcbiAqXG4gKiAxLiAgKipOYW1lZCBDb25maWdzIChQdWJsaWMgQVBJKToqKiBEZWZpbmVkIGluIHRoZSBgY29uZmlnYCBvYmplY3QgKGUuZy4sIGB0ZXh0X2ApLlxuICogICAgIC0gKipQdXJwb3NlOioqIERlZmluZXMgdGhlIGNvbXBvbmVudCdzIHB1YmxpYyBBUEkgZm9yIGV4dGVybmFsIGNvbnRyb2wsIHNpbWlsYXIgdG8gcHJvcHMuXG4gKiAgICAgLSAqKlVzZSBDYXNlOioqIEZvciBkYXRhIHRoYXQgYSBwYXJlbnQgY29tcG9uZW50IHdpbGwgc2V0IG9yIGNoYW5nZS5cbiAqICAgICAtICoqRmVhdHVyZXM6KiogSW50ZWdyYXRlcyB3aXRoIHRoZSBmdWxsIGNvbmZpZyBzeXN0ZW0gKGUuZy4sIGBhZnRlclNldFRleHQoKWAgaG9va3MpLlxuICpcbiAqIDIuICAqKmB1c2VDb25maWcoKWAgKEludGVybmFsIFN0YXRlKToqKiBVc2VkIGluc2lkZSBgY3JlYXRlVmRvbWAgb3Igb3RoZXIgbWV0aG9kcy5cbiAqICAgICAtICoqUHVycG9zZToqKiBNYW5hZ2VzIHByaXZhdGUsIGVuY2Fwc3VsYXRlZCBzdGF0ZSB0aGF0IGlzIGludGVybmFsIHRvIHRoZSBjb21wb25lbnQuXG4gKiAgICAgLSAqKlVzZSBDYXNlOioqIEZvciBzdGF0ZSB0aGF0IHRoZSBjb21wb25lbnQgbWFuYWdlcyBpdHNlbGYgYW5kIGlzIG5vdCBjb250cm9sbGVkIGJ5IHRoZSBwYXJlbnQuXG4gKiAgICAgLSAqKkZlYXR1cmVzOioqIFByb3ZpZGVzIGEgc2ltcGxlLCBjb25jaXNlIHdheSB0byBoYW5kbGUgbG9jYWwgcmVhY3RpdmUgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNwZWMgLSBUaGUgc3BlY2lmaWNhdGlvbiBvYmplY3QgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBAcmV0dXJucyB7TmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2V9IFRoZSBnZW5lcmF0ZWQgY29tcG9uZW50IGNsYXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBkZWZpbmVDb21wb25lbnQgfSBmcm9tICduZW8vZnVuY3Rpb25hbC9kZWZpbmVDb21wb25lbnQubWpzJztcbiAqIGltcG9ydCB7IHVzZUNvbmZpZyB9ICAgICAgIGZyb20gJ25lby9mdW5jdGlvbmFsL3VzZUNvbmZpZy5tanMnO1xuICpcbiAqIGNvbnN0IE15Q29tcG9uZW50ID0gZGVmaW5lQ29tcG9uZW50KHtcbiAqICAgICAvLyAxLiBEZWZpbmUgdGhlIFB1YmxpYyBBUEkgdmlhIHRoZSBgY29uZmlnYCBvYmplY3QuXG4gKiAgICAgY29uZmlnOiB7XG4gKiAgICAgICAgIGNsYXNzTmFtZTogJ015QXBwLk15RnVuY3Rpb25hbENvbXBvbmVudCcsXG4gKiAgICAgICAgIG50eXBlICAgIDogJ215LWZ1bmN0aW9uYWwtY29tcG9uZW50JyxcbiAqXG4gKiAgICAgICAgIC8vIGB0ZXh0X2AgaXMgYSBOQU1FRCBDT05GSUcuIEl0J3MgcGFydCBvZiB0aGUgY29tcG9uZW50J3MgcHVibGljIEFQSS5cbiAqICAgICAgICAgLy8gQSBwYXJlbnQgY2FuIGNyZWF0ZSB0aGlzIGNvbXBvbmVudCB3aXRoIGEgYHRleHRgIGNvbmZpZy5cbiAqICAgICAgICAgLy8gSXQgaXMgcmVhY3RpdmUgYW5kIHdpbGwgZ2VuZXJhdGUgYGFmdGVyU2V0VGV4dCgpYCBhbmQgYGJlZm9yZVNldFRleHQoKWAgaG9va3MuXG4gKiAgICAgICAgIHRleHRfOiAnSGVsbG8gV29ybGQnXG4gKiAgICAgfSxcbiAqXG4gKiAgICAgLy8gMi4gRGVmaW5lIHRoZSBjb21wb25lbnQncyBsb2dpYyBhbmQgVkRPTS5cbiAqICAgICBjcmVhdGVWZG9tKGNvbmZpZykge1xuICogICAgICAgICAvLyBgdXNlQ29uZmlnYCBjcmVhdGVzIEFOT05ZTU9VUywgSU5URVJOQUwgU1RBVEUuXG4gKiAgICAgICAgIC8vIFRoZSBgY291bnRgIHN0YXRlIGlzIHByaXZhdGUgdG8gdGhpcyBjb21wb25lbnQgYW5kIGNhbm5vdCBiZSBzZXQgYnkgYSBwYXJlbnQuXG4gKiAgICAgICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlQ29uZmlnKDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICAgIHRhZzogJ2RpdicsXG4gKiAgICAgICAgICAgICBjbjogW3tcbiAqICAgICAgICAgICAgICAgICB0YWc6ICdoMScsXG4gKiAgICAgICAgICAgICAgICAgLy8gQWNjZXNzIHRoZSBwdWJsaWMsIG5hbWVkIGNvbmZpZyB2aWEgdGhlIGBjb25maWdgIHBhcmFtZXRlci5cbiAqICAgICAgICAgICAgICAgICB0ZXh0OiBjb25maWcudGV4dFxuICogICAgICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgICAgIHRhZzogJ3AnLFxuICogICAgICAgICAgICAgICAgIC8vIEFjY2VzcyB0aGUgcHJpdmF0ZSwgaW50ZXJuYWwgc3RhdGUgZGlyZWN0bHkuXG4gKiAgICAgICAgICAgICAgICAgdGV4dDogYFlvdSBjbGlja2VkICR7Y291bnR9IHRpbWVzYFxuICogICAgICAgICAgICAgfSwge1xuICogICAgICAgICAgICAgICAgIHRhZzogJ2J1dHRvbicsXG4gKiAgICAgICAgICAgICAgICAgdGV4dDogJ0NsaWNrIG1lJyxcbiAqICAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGVyIGZyb20gYHVzZUNvbmZpZ2AgdXBkYXRlcyB0aGUgaW50ZXJuYWwgc3RhdGUuXG4gKiAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gc2V0Q291bnQoY291bnQgKyAxKVxuICogICAgICAgICAgICAgfV1cbiAqICAgICAgICAgfTtcbiAqICAgICB9LFxuICpcbiAqICAgICAvLyAzLiBMaWZlY3ljbGUgaG9va3MgZm9yIG5hbWVkIGNvbmZpZ3Mgd29yayBhdXRvbWF0aWNhbGx5LlxuICogICAgIGFmdGVyU2V0VGV4dChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coYFRleHQgY2hhbmdlZCBmcm9tICcke29sZFZhbHVlfScgdG8gJyR7bmV3VmFsdWV9J2ApO1xuICogICAgIH1cbiAqIH0pO1xuICpcbiAqIC8vIFRoZSByZXR1cm5lZCBNeUNvbXBvbmVudCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBOZW8uY3JlYXRlKClcbiAqIC8vIGNvbnN0IGluc3RhbmNlID0gTmVvLmNyZWF0ZShNeUNvbXBvbmVudCwge1xuICogLy8gICAgIHRleHQ6ICdXZWxjb21lIHRvIE5lby5tanMhJyAvLyBTZXQgdGhlIHB1YmxpYyBjb25maWcgb24gY3JlYXRpb24uXG4gKiAvLyB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChzcGVjKSB7XG4gICAgY29uc3QgY29uZmlnU3BlYyA9IHNwZWMuY29uZmlnO1xuICAgIGRlbGV0ZSBzcGVjLmNvbmZpZztcblxuICAgIGlmICghY29uZmlnU3BlYz8uY2xhc3NOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVmaW5lQ29tcG9uZW50IHJlcXVpcmVzIGEgY29uZmlnIG9iamVjdCB3aXRoIGEgY2xhc3NOYW1lLicpO1xuICAgIH1cblxuICAgIGNsYXNzIEZ1bmN0aW9uYWxDb21wb25lbnQgZXh0ZW5kcyBGdW5jdGlvbmFsQmFzZSB7XG4gICAgICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgICAgICAuLi5jb25maWdTcGVjXG4gICAgICAgICAgICAvLyBXZSBjYW4gYWRkIG91ciBvd24gY29uZmlndXJhdGlvbnMgaGVyZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXNzaWduIGluc3RhbmNlIG1ldGhvZHNcbiAgICBPYmplY3QuZW50cmllcyhzcGVjKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgRnVuY3Rpb25hbENvbXBvbmVudC5wcm90b3R5cGVba2V5XSA9IHZhbHVlXG4gICAgfSk7XG5cbiAgICAvLyBUbyBzdXBwb3J0IG11bHRpcGxlIGVudnMgKGxpa2UgYGRldm1vZGVgLCBgZGlzdC9lc21gLCBgZGlzdC9wcm9kdWN0aW9uYCBpbiBwYXJhbGxlbCxcbiAgICAvLyB3ZSBtdXN0IHJlLWFzc2lnbiBGdW5jdGlvbmFsQ29tcG9uZW50IHRvIHRoZSBzZXR1cENsYXNzKCkgb3V0cHV0LlxuICAgIEZ1bmN0aW9uYWxDb21wb25lbnQgPSBOZW8uc2V0dXBDbGFzcyhGdW5jdGlvbmFsQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBGdW5jdGlvbmFsQ29tcG9uZW50XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZUNvbXBvbmVudDtcbiIsImltcG9ydCBDb25maWcgICAgICAgIGZyb20gJy4uL2NvcmUvQ29uZmlnLm1qcyc7XG5pbXBvcnQgRWZmZWN0TWFuYWdlciBmcm9tICcuLi9jb3JlL0VmZmVjdE1hbmFnZXIubWpzJztcblxuY29uc3RcbiAgICBob29rSW5kZXhTeW1ib2wgPSBTeW1ib2wuZm9yKCdob29rSW5kZXgnKSxcbiAgICBob29rc1N5bWJvbCAgICAgPSBTeW1ib2wuZm9yKCdob29rcycpO1xuXG4vKipcbiAqIEEgaG9vayBmb3IgbWFuYWdpbmcgcmVhY3RpdmUgc3RhdGUgd2l0aGluIGEgZnVuY3Rpb25hbCBjb21wb25lbnQncyBgY3JlYXRlVmRvbWAgbWV0aG9kLlxuICogSXQgbWlycm9ycyB0aGUgYmVoYXZpb3Igb2YgUmVhY3QncyBgdXNlU3RhdGVgIGJ1dCBpcyBwb3dlcmVkIGJ5IGBOZW8uY29yZS5Db25maWdgIGZvciByZWFjdGl2aXR5LlxuICogQHBhcmFtIHsqfSBpbml0aWFsVmFsdWUgVGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBzdGF0ZS5cbiAqIEByZXR1cm5zIHtBcnJheTxhbnk+fSBBIHR1cGxlIGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgdmFsdWUgYW5kIGEgc2V0dGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29uZmlnKGluaXRpYWxWYWx1ZSkge1xuICAgIEVmZmVjdE1hbmFnZXIucGF1c2UoKTtcblxuICAgIGNvbnN0XG4gICAgICAgIGVmZmVjdCAgICA9IEVmZmVjdE1hbmFnZXIuZ2V0QWN0aXZlRWZmZWN0KCksXG4gICAgICAgIGNvbXBvbmVudCA9IGVmZmVjdCAmJiBOZW8uZ2V0Q29tcG9uZW50KGVmZmVjdC5jb21wb25lbnRJZCk7XG5cbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUNvbmZpZyBtdXN0IGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XFwncyBjcmVhdGVWZG9tIG1ldGhvZC4nKVxuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGNvbXBvbmVudFtob29rSW5kZXhTeW1ib2xdO1xuXG4gICAgLy8gSW5jcmVtZW50IHRoZSBpbmRleCBmb3IgdGhlIG5leHQgaG9vayBjYWxsIHdpdGhpbiB0aGUgc2FtZSBjb21wb25lbnQgcmVuZGVyIGN5Y2xlLlxuICAgIGNvbXBvbmVudFtob29rSW5kZXhTeW1ib2xdKys7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoaXMgaG9vayBpcyBiZWluZyBjYWxsZWQgZm9yIHRoaXMgY29tcG9uZW50LCBpbml0aWFsaXplIGl0cyBzdGF0ZS5cbiAgICBpZiAoIWNvbXBvbmVudFtob29rc1N5bWJvbF1bY3VycmVudEluZGV4XSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgQ29uZmlnKGluaXRpYWxWYWx1ZSk7XG5cbiAgICAgICAgY29uc3QgY3VzdG9tU2V0dGVyID0gKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZShjb25maWcuZ2V0KCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuc2V0KG5ld1ZhbHVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbXBvbmVudFtob29rc1N5bWJvbF1bY3VycmVudEluZGV4XSA9IFtjb25maWcsIGN1c3RvbVNldHRlcl1cbiAgICB9XG5cbiAgICBjb25zdCBbY29uZmlnLCBzZXR0ZXJdID0gY29tcG9uZW50W2hvb2tzU3ltYm9sXVtjdXJyZW50SW5kZXhdO1xuXG4gICAgRWZmZWN0TWFuYWdlci5yZXN1bWUoKTtcblxuICAgIC8vIENhbGwgY29uZmlnLmdldCgpIHRvIGVuc3VyZSB0aGlzIGNvbXBvbmVudCdzIGVmZmVjdCB0cmFja3MgdGhpcyBjb25maWcgYXMgYSBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBbY29uZmlnLmdldCgpLCBzZXR0ZXJdXG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNvbmZpZztcbiIsImltcG9ydCBFZmZlY3RNYW5hZ2VyIGZyb20gJy4uL2NvcmUvRWZmZWN0TWFuYWdlci5tanMnO1xuXG5jb25zdCBwZW5kaW5nRG9tRXZlbnRzU3ltYm9sID0gU3ltYm9sLmZvcigncGVuZGluZ0RvbUV2ZW50cycpO1xuXG4vKipcbiAqIEEgaG9vayBmb3IgcmVnaXN0ZXJpbmcgRE9NIGV2ZW50IGxpc3RlbmVycyB3aXRoaW4gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC5cbiAqIEV2ZW50IGxpc3RlbmVycyByZWdpc3RlcmVkIHZpYSB0aGlzIGhvb2sgd2lsbCBiZSBtYW5hZ2VkIGJ5IE5lby5tanMnc1xuICogZGVsZWdhdGVkIERPTSBldmVudCBzeXN0ZW0sIGVuc3VyaW5nIGVmZmljaWVudCBhbmQgcHJvcGVyIGxpZmVjeWNsZSBoYW5kbGluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIC0gVGhlIHR5cGUgb2YgRE9NIGV2ZW50IHRvIGxpc3RlbiBmb3IgKGUuZy4sICdjbGljaycsICdpbnB1dCcpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIFRoZSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uLiBJdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50IGRhdGEgYXMgaXRzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWxlZ2F0ZV0gLSBBbiBvcHRpb25hbCBDU1Mgc2VsZWN0b3IgZm9yIGV2ZW50IGRlbGVnYXRpb24uIElmIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGhhbmRsZXIgd2lsbCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHRhcmdldCBtYXRjaGVzIHRoaXMgc2VsZWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFdmVudChldmVudFR5cGUsIGhhbmRsZXIsIGRlbGVnYXRlKSB7XG4gICAgY29uc3RcbiAgICAgICAgYWN0aXZlRWZmZWN0ID0gRWZmZWN0TWFuYWdlci5nZXRBY3RpdmVFZmZlY3QoKSxcbiAgICAgICAgY29tcG9uZW50SWQgID0gYWN0aXZlRWZmZWN0Py5jb21wb25lbnRJZDtcblxuICAgIGlmICghY29tcG9uZW50SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VFdmVudCBtdXN0IGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XFwncyBjcmVhdGVWZG9tIG1ldGhvZC4nKVxuICAgIH1cblxuICAgIEVmZmVjdE1hbmFnZXIucGF1c2UoKTtcbiAgICBjb25zdCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGNvbXBvbmVudElkKTtcbiAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZSgpO1xuXG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgd2l0aCBpZCAke2NvbXBvbmVudElkfSBub3QgZm91bmQgZm9yIHVzZUV2ZW50IGhvb2suYCk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHBlbmRpbmdEb21FdmVudHNTeW1ib2wgZXhpc3RzIG9uIHRoZSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICBjb21wb25lbnRbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF0gPz89IFtdO1xuXG4gICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciBjb25maWd1cmF0aW9uIHRvIHRoZSBjb21wb25lbnQncyBwZW5kaW5nIGxpc3RcbiAgICBjb21wb25lbnRbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF0ucHVzaCh7XG4gICAgICAgIFtldmVudFR5cGVdOiBoYW5kbGVyLFxuICAgICAgICBkZWxlZ2F0ZSxcbiAgICAgICAgc2NvcGUgICAgICA6IGNvbXBvbmVudCAvLyBUaGUgY29tcG9uZW50IGluc3RhbmNlIGl0c2VsZiB3aWxsIGJlIHRoZSBzY29wZVxuICAgIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUV2ZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9