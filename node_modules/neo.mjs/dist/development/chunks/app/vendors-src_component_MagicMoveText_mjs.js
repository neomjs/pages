"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_MagicMoveText_mjs"],{

/***/ "./src/component/MagicMoveText.mjs"
/*!*****************************************!*\
  !*** ./src/component/MagicMoveText.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @summary Animates text transitions by calculating character positions and applying CSS transforms.
 *
 * This component creates a "Magic Move" style effect, where changing from one string of text to another results
 * in a smooth animation. Characters that are common between the two strings appear to move to their new positions,
 * while old characters fade out and new characters fade in.
 *
 * This effect is achieved using a two-phase process that leverages Neo.mjs's VDOM and rendering pipeline:
 * 1.  **Measurement Phase (`measureChars`):** When the text changes, the component first needs to know the exact
 *     final position of every character. It does this by briefly rendering all characters into a hidden
 *     `measure-element` div, getting their `DOMRect` values, and caching the results. This is a critical
 *     performance optimization that avoids layout thrashing.
 * 2.  **Animation Phase (`updateChars`):** With the character positions known, the component calculates the delta
 *     between the old and new text. It then manipulates the VDOM by applying CSS classes and styles to
 *     individual character `<span>` elements to trigger CSS transitions for movement and opacity.
 *
 * This component is a prime example of using the framework for complex, declarative, and performant animations.
 * It is useful for grabbing user attention on landing pages or for creating dynamic, keynote-style presentations.
 *
 * Relevant concepts: `text animation`, `character transition`, `magic move`, `declarative animation`, `CSS transitions`.
 *
 * Deeply inspired by https://github.com/yangshun 's video on LinkedIn
 * as well as Apple's Keynote Magic Move effect.
 * @class Neo.component.MagicMoveText
 * @extends Neo.component.Base
 */
class MagicMoveText extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.MagicMoveText'
         * @protected
         */
        className: 'Neo.component.MagicMoveText',
        /**
         * @member {String} ntype='magic-move-text'
         * @protected
         */
        ntype: 'magic-move-text',
        /**
         * Set to true to automatically cycle through the `cycleTexts` array.
         * @member {Boolean} autoCycle_=true
         * @reactive
         */
        autoCycle_: true,
        /**
         * The time in milliseconds between each automatic text transition.
         * @member {Number} autoCycleInterval_=2000
         * @reactive
         */
        autoCycleInterval_: 2000,
        /**
         * The number of text cycles before the measurement cache is automatically cleared.
         * Set to 0 to disable automatic clearing.
         * @member {Number} cacheClearInterval_=10
         * @reactive
         */
        cacheClearInterval_: 10,
        /**
         * @member {String[]} baseCls=['neo-magic-move-text']
         * @protected
         */
        baseCls: ['neo-magic-move-text'],
        /**
         * The color applied to characters that are moving to a new position.
         * @member {String|null} colorMove=null
         */
        colorMove: null,
        /**
         * The color applied to new characters as they fade in.
         * @member {String|null} colorFadeIn=null
         */
        colorFadeIn: null,
        /**
         * The color applied to old characters as they fade out.
         * @member {String|null} colorFadeOut=null
         */
        colorFadeOut: null,
        /**
         * An array of strings to automatically cycle through if `autoCycle` is true.
         * @member {String[]|null} cycleTexts=null
         */
        cycleTexts: null,
        /**
         * The font-family for the text. Changing this will trigger a cache invalidation and remeasurement.
         * @member {String} fontFamily_='Helvetica Neue'
         * @reactive
         */
        fontFamily_: 'Helvetica Neue',
        /**
         * The duration in milliseconds for the fade-in, fade-out, and move animations.
         * This value is applied to the `--neo-transition-time` CSS variable.
         * @member {Number} transitionTime_=500
         * @reactive
         */
        transitionTime_: 500,
        /**
         * The VDOM structure for the component, including a content area and a hidden measurement element.
         * @member {Object} _vdom
         * @protected
         */
        _vdom:
        {style: {}, cn: [
            {cls: ['neo-content'], cn: []},
            {cls: ['neo-measure-element-wrapper'], removeDom: true, cn: [
                {cls: ['neo-measure-element'], cn:[]}
            ]}
        ]}
    }

    /**
     * An array of objects, where each object represents a character in the current `text`.
     * Each object contains the character's `name` (the character itself) and its calculated
     * `left` and `top` positions relative to the container.
     * @member {Object[]} chars=[]
     * @protected
     */
    chars = []
    /**
     * A cached representation of the VDOM for the currently displayed characters.
     * This is used to persist the character state during resize events, preventing
     * the need for a full recalculation.
     * @member {Object[]} charsVdom=[]
     * @protected
     */
    charsVdom = []
    /**
     * The height of the component's content area, determined on mount and resize.
     * Used to size the measurement wrapper.
     * @member {Number} contentHeight=0
     * @protected
     */
    contentHeight = 0
    /**
     * The width of the component's content area, determined on mount and resize.
     * Used to size the measurement wrapper.
     * @member {Number} contentWidth=0
     * @protected
     */
    contentWidth = 0
    /**
     * Counter for the number of text cycles since the last cache clear.
     * @member {Number} cycleCount=0
     * @protected
     */
    cycleCount = 0
    /**
     * The index of the string currently displayed from the `cycleTexts` array.
     * @member {Number} currentIndex=0
     * @protected
     */
    currentIndex = 0
    /**
     * A flag to ignore the very first resize event that fires immediately after mounting,
     * as the initial measurement is handled by `afterSetMounted`.
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * The ID for the `setInterval` used for `autoCycle`. Stored so it can be cleared.
     * @member {Number|null} intervalId=null
     * @protected
     */
    intervalId = null
    /**
     * Internal flag to prevent infinite retry loops in case of errors during the animation.
     * @member {Boolean} isRetrying=false
     * @protected
     */
    isRetrying = false
    /**
     * A flag to indicate that the component is currently in the middle of an animation.
     * This is used to prevent concurrent, overlapping updates (e.g., from a resize event).
     * @member {Boolean} isTransitioning=false
     * @protected
     */
    isTransitioning = false
    /**
     * A performance-critical cache. Maps a text string to an array of `DOMRect` objects
     * for each of its characters. This avoids costly DOM measurements if the same text is
     * displayed again. It is invalidated when the component resizes or its font changes.
     * @member {Object} measureCache={}
     * @protected
     */
    measureCache = {}
    /**
     * Stores the `chars` array from the *previous* text state. This is essential for calculating
     * the transition, as it's compared against the new `chars` array to determine which characters
     * need to move, fade in, or fade out.
     * @member {Object[]} previousChars=[]
     * @protected
     */
    previousChars = []
    /**
     * A getter for the VDOM node used to measure character positions.
     * @member {Object} measureElement
     * @protected
     */
    get measureElement() {
        return this.measureWrapper.cn[0]
    }
    /**
     * A getter for the wrapper of the measurement VDOM node. This wrapper is temporarily
     * added to the DOM to perform measurements.
     * @member {Object} measureWrapper
     * @protected
     */
    get measureWrapper() {
        return this.vdom.cn[1]
    }

    /**
     * The constructor registers a resize listener to invalidate the measurement cache when the component size changes.
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        });

        me.app?.on('visibilitychange', me.onVisibilityChange, me)
    }

    /**
     * Registers or unregisters this component with the global ResizeObserver addon.
     * This is more efficient than having a separate observer for each component instance.
     * @param {Boolean} mounted True to register, false to unregister.
     * @protected
     */
    async addResizeObserver(mounted) {
        let {id, windowId} = this,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId);

        ResizeObserver[mounted ? 'register' : 'unregister']({id, windowId});

        if (mounted) {
            this.initialResizeEvent = true
        }
    }

    /**
     * Starts or stops the automatic text cycling when the `autoCycle` config changes.
     * @param {Boolean} value    The new value of `autoCycle`.
     * @param {Boolean} oldValue The old value of `autoCycle`.
     * @protected
     */
    afterSetAutoCycle(value, oldValue) {
        this.mounted && this.startAutoCycle(value)
    }

    /**
     * Restarts the automatic text cycling with the new interval when the `autoCycleInterval` config changes.
     * @param {Number} value    The new value of `autoCycleInterval`.
     * @param {Number} oldValue The old value of `autoCycleInterval`.
     * @protected
     */
    afterSetAutoCycleInterval(value, oldValue) {
        let me = this;

        if (oldValue && me.mounted) {
            me.startAutoCycle(false);
            me.startAutoCycle()
        }
    }

    /**
     * Invalidates the measurement cache and updates the VDOM when the `fontFamily` config changes,
     * as a new font will change all character dimensions.
     * @param {String} value    The new value of `fontFamily`.
     * @param {String} oldValue The old value of `fontFamily`.
     * @protected
     */
    afterSetFontFamily(value, oldValue) {
        let me = this;

        me.measureCache = {};

        me.vdom.style.fontFamily = value;
        me.update()
    }

    /**
     * Handles the component's mounted state changes. When mounted, it determines the component's
     * dimensions. When unmounted, it clears the measurement cache and character state.
     * @param {Boolean} value    The new value of `mounted`.
     * @param {Boolean} oldValue The old value of `mounted`.
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value) {
            me.getDomRect().then(rect => {
                me.contentHeight = rect.height;
                me.contentWidth  = rect.width;
            })
        } else {
            me.measureCache  = {};
            me.previousChars = []
        }

        if (oldValue !== undefined) {
            me.addResizeObserver(value);

            me.autoCycle && me.startAutoCycle(value)
        }
    }

    /**
     * This is the main entry point for the animation when the `text` config is changed.
     * It orchestrates the measurement and animation phases. It also contains a `try/catch`
     * block to handle potential errors during the complex animation logic, with a single-retry
     * mechanism to recover from transient states by clearing the cache and re-running the process.
     * @param {String} value    The new text value.
     * @param {String} oldValue The old text value.
     * @returns {Promise<void>}
     * @protected
     */
    async afterSetText(value, oldValue) {
        let me               = this,
            {measureElement} = me;

        if (oldValue) {
            me.previousChars = me.chars
        }

        if (value) {
            if (me.cacheClearInterval > 0) {
                me.cycleCount++;

                if (me.cycleCount >= me.cacheClearInterval) {
                    me.measureCache = {};
                    me.cycleCount   = 0
                }
            }

            try {
                me.chars = [];
                measureElement.cn = [];

                value?.split('').forEach(char => {
                    me.chars.push({name: char});
                    measureElement.cn.push({tag: 'span', text: char})
                });

                if (me.mounted) {
                    await me.measureChars()
                }

                await me.updateChars()
            } catch (e) {
                if (!me.isRetrying) {
                    me.isRetrying    = true;
                    me.measureCache  = {};
                    me.previousChars = [];

                    // Reset a transitioning state
                    me.vdom.cn[0].cn.length = 0;

                    await me.afterSetText(value, oldValue)
                }
            }

            me.isRetrying = false
        }
    }

    /**
     * Applies the transition time to a CSS variable, allowing the animations to be controlled via JavaScript.
     * @param {Number} value    The new value of `transitionTime`.
     * @param {Number} oldValue The old value of `transitionTime`.
     * @protected
     */
    afterSetTransitionTime(value, oldValue) {
        this.vdom.style['--neo-transition-time'] = value + 'ms';
        this.update()
    }

    /**
     * Creates the VDOM for new characters that are fading in. It filters out characters
     * that are already present (and will be moved instead).
     * @param {String[]} letters An array representing the new text, with `null` for characters that already existed.
     * @returns {Object[]} An array of VDOM nodes for the new characters.
     * @protected
     */
    createCharsVdom(letters) {
        let me             = this,
            {chars}        = me,
            charsContainer = [],
            char;

        letters.forEach((letter, index) => {
            if (letter !== null) {
                char = chars[index];

                charsContainer.push({
                    cls  : ['neo-char'],
                    style: {color: me.colorFadeIn, left: char.left, opacity: 0, top: char.top},
                    text : char.name
                })
            }
        });

        return charsContainer
    }

    /**
     * Advances the text to the next string in the `cycleTexts` array.
     * @protected
     */
    cycleText() {
        let me = this;

        me.text         = me.cycleTexts[me.currentIndex];
        me.currentIndex = (me.currentIndex + 1) % me.cycleTexts.length
    }

    /**
     * The first phase of the animation: calculating character positions.
     * If the positions for the current text are not in the cache, this method temporarily
     * renders the characters into a hidden div, measures their bounding rectangles,
     * stores the results in the cache, and then removes the measurement elements from the DOM.
     * @returns {Promise<void>}
     * @protected
     */
    async measureChars() {
        let me = this,
            {measureCache, measureElement, measureWrapper, text} = me,
            parentRect, rects, rootRect;

        if (measureCache[text] && measureCache[text].width === me.contentWidth && measureCache[text].height === me.contentHeight) {
            rects      = [...measureCache[text].rects];
            parentRect = rects.shift()
        } else {
            measureWrapper.style = {
                height: me.contentHeight + 'px',
                width : me.contentWidth  + 'px'
            };

            delete measureWrapper.removeDom;

            await me.promiseUpdate();
            await me.timeout(20);

            rects      = await me.getDomRect([me.id, measureWrapper.id, ...measureElement.cn.map(node => node.id)]);
            rootRect   = rects.shift();
            parentRect = rects.shift();

            // Self-Correction: If the real DOM size differs from our expected size, we update and retry.
            // We allow a small tolerance (2px) for sub-pixel rendering differences.
            // We also check for > 0 to avoid zeroing out dimensions if the component is temporarily hidden.
            if (rootRect.width > 0 && (Math.abs(rootRect.width - me.contentWidth) > 2 || Math.abs(rootRect.height - me.contentHeight) > 2)) {
                me.contentWidth  = rootRect.width;
                me.contentHeight = rootRect.height;

                return me.measureChars()
            }

            measureCache[text] = {
                height: me.contentHeight,
                rects : [parentRect, ...rects],
                width : me.contentWidth
            }
        }

        rects.forEach((rect, index) => {
            me.chars[index].left = `${rect.left - parentRect.left}px`;
            me.chars[index].top  = `${rect.top  - parentRect.top }px`;
        });

        await me.promiseUpdate()
    }

    /**
     * The resize event handler. It updates the component's dimensions, invalidates the
     * measurement cache, and triggers a remeasurement and VDOM update.
     * @param {Object} data      The event data from the resize observer.
     * @param {Object} data.rect The new bounding rectangle of the component.
     * @returns {Promise<void>}
     * @protected
     */
    async onResize({rect}) {
        let me = this;

        me.contentHeight = rect.height;
        me.contentWidth  = rect.width;

        me.measureCache = {};

        if (!me.initialResizeEvent) {
            if (!me.isTransitioning) {
                await me.measureChars();

                me.charsVdom = me.createCharsVdom(me.chars.map(char => char.name))
            }
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * Triggered when switching browser tabs or minimizing the browser
     * @param {Object}  data
     * @param {Boolean} data.hidden
     * @param {String}  data.visibilityState
     * @param {Number}  data.windowId
     */
    onVisibilityChange(data) {
        let me = this;

        if (me.autoCycle) {
            if (data.hidden) {
                me.startAutoCycle(false)
            } else {
                me.isRetrying    = false;
                me.measureCache  = {};
                me.previousChars = [];

                me.startAutoCycle()
            }
        }
    }

    /**
     * A sort comparator function used to order character VDOM nodes based on their
     * `top` and `left` style properties. This ensures a consistent DOM order.
     * @param {Object} a The first VDOM node.
     * @param {Object} b The second VDOM node.
     * @returns {Number}
     * @protected
     */
    sortCharacters(a, b) {
        let deltaTop = parseFloat(a.style.top) - parseFloat(b.style.top);

        if (deltaTop !== 0) {
            return deltaTop
        }

        return parseFloat(a.style.left) - parseFloat(b.style.left)
    }

    /**
     * Starts or stops the `setInterval` for automatic text cycling.
     * @param {Boolean} start=true True to start the timer, false to stop it.
     * @protected
     */
    startAutoCycle(start=true) {
        let me = this;

        if (start) {
            me.intervalId = setInterval(me.cycleText.bind(me), me.autoCycleInterval);

            me.timeout(20).then(() => {me.cycleText()})
        } else {
            clearInterval(me.intervalId)
        }
    }

    /**
     * The second and most complex phase of the animation: updating the VDOM to trigger CSS transitions.
     * This method implements the core "magic move" logic by determining the delta between the old
     * and new text states and applying styles accordingly.
     *
     * The algorithm is as follows:
     * 1. Iterate through the `previousChars`.
     * 2. For each old character, check if it exists in the new text.
     *    - If YES: This character needs to **move**. Apply the new `left` and `top` styles to its VDOM node.
     *    - If NO: This character needs to **fade out**. Flag it for removal.
     * 3. Create new VDOM nodes for all characters that are unique to the new text. These will **fade in**.
     * 4. Apply styles to all nodes simultaneously to trigger the CSS transitions (move, fade-in, fade-out).
     * 5. After the transition duration, clean up the VDOM by removing the faded-out nodes.
     * 6. Finally, for performance, collapse all the individual character `<span>` nodes back into a single
     *    text node until the next animation is triggered.
     * @returns {Promise<void>}
     * @protected
     */
    async updateChars() {
        let me                     = this,
            {chars, previousChars} = me,
            charsContainer         = me.vdom.cn[0],
            letters                = chars.map(char => char.name),
            charNode, index;

        me.isTransitioning = true;

        if (me.charsVdom.length > 1) {
            charsContainer.cn = me.charsVdom;
            await me.promiseUpdate()
        }

        previousChars.forEach((previousChar, previousIndex) => {
            index = letters.indexOf(previousChar.name);

            if (index > -1) {
                charNode = charsContainer.cn[previousIndex];

                Object.assign(charNode.style, {
                    color: me.colorMove,
                    left : chars[index].left,
                    top  : chars[index].top
                });

                letters[index] = null
            } else {
                charNode = charsContainer.cn[previousIndex];

                charNode.flag = 'remove'
            }
        });

        charsContainer.cn.push(...me.createCharsVdom(letters));

        await me.promiseUpdate();

        charsContainer.cn.forEach(charNode => {
            if (charNode.flag === 'remove') {
                charNode.style.color   = me.colorFadeOut;
                charNode.style.opacity = 0
            } else {
                delete charNode.style.opacity
            }
        });

        await me.promiseUpdate();
        await me.timeout(me.transitionTime);

        charsContainer.cn.sort(me.sortCharacters);

        index = charsContainer.cn.length - 1;

        for (; index >= 0; index--) {
            charNode = charsContainer.cn[index];

            delete charNode.flag;
            delete charNode.style.color;

            if (charNode.style.opacity === 0) {
                charsContainer.cn.splice(index, 1)
            }
        }

        await me.promiseUpdate();
        await me.timeout(200);

        me.charsVdom = [...charsContainer.cn];

        charsContainer.cn.length = 0;

        charsContainer.cn.push({text: me.text});
        await me.promiseUpdate();

        me.isTransitioning = false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MagicMoveText));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfTWFnaWNNb3ZlVGV4dF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQVM7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEIsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOztBQUVBLDZEQUE2RCxhQUFhOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUMsNENBQTRDLHdCQUF3QjtBQUNwRSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFrRTtBQUM5RjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9EQUFvRDtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRSxzQ0FBc0MsNEJBQTRCO0FBQ2xFLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLGVBQWU7QUFDdEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsWUFBWTtBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLGNBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTWFnaWNNb3ZlVGV4dC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEFuaW1hdGVzIHRleHQgdHJhbnNpdGlvbnMgYnkgY2FsY3VsYXRpbmcgY2hhcmFjdGVyIHBvc2l0aW9ucyBhbmQgYXBwbHlpbmcgQ1NTIHRyYW5zZm9ybXMuXG4gKlxuICogVGhpcyBjb21wb25lbnQgY3JlYXRlcyBhIFwiTWFnaWMgTW92ZVwiIHN0eWxlIGVmZmVjdCwgd2hlcmUgY2hhbmdpbmcgZnJvbSBvbmUgc3RyaW5nIG9mIHRleHQgdG8gYW5vdGhlciByZXN1bHRzXG4gKiBpbiBhIHNtb290aCBhbmltYXRpb24uIENoYXJhY3RlcnMgdGhhdCBhcmUgY29tbW9uIGJldHdlZW4gdGhlIHR3byBzdHJpbmdzIGFwcGVhciB0byBtb3ZlIHRvIHRoZWlyIG5ldyBwb3NpdGlvbnMsXG4gKiB3aGlsZSBvbGQgY2hhcmFjdGVycyBmYWRlIG91dCBhbmQgbmV3IGNoYXJhY3RlcnMgZmFkZSBpbi5cbiAqXG4gKiBUaGlzIGVmZmVjdCBpcyBhY2hpZXZlZCB1c2luZyBhIHR3by1waGFzZSBwcm9jZXNzIHRoYXQgbGV2ZXJhZ2VzIE5lby5tanMncyBWRE9NIGFuZCByZW5kZXJpbmcgcGlwZWxpbmU6XG4gKiAxLiAgKipNZWFzdXJlbWVudCBQaGFzZSAoYG1lYXN1cmVDaGFyc2ApOioqIFdoZW4gdGhlIHRleHQgY2hhbmdlcywgdGhlIGNvbXBvbmVudCBmaXJzdCBuZWVkcyB0byBrbm93IHRoZSBleGFjdFxuICogICAgIGZpbmFsIHBvc2l0aW9uIG9mIGV2ZXJ5IGNoYXJhY3Rlci4gSXQgZG9lcyB0aGlzIGJ5IGJyaWVmbHkgcmVuZGVyaW5nIGFsbCBjaGFyYWN0ZXJzIGludG8gYSBoaWRkZW5cbiAqICAgICBgbWVhc3VyZS1lbGVtZW50YCBkaXYsIGdldHRpbmcgdGhlaXIgYERPTVJlY3RgIHZhbHVlcywgYW5kIGNhY2hpbmcgdGhlIHJlc3VsdHMuIFRoaXMgaXMgYSBjcml0aWNhbFxuICogICAgIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0aGF0IGF2b2lkcyBsYXlvdXQgdGhyYXNoaW5nLlxuICogMi4gICoqQW5pbWF0aW9uIFBoYXNlIChgdXBkYXRlQ2hhcnNgKToqKiBXaXRoIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb25zIGtub3duLCB0aGUgY29tcG9uZW50IGNhbGN1bGF0ZXMgdGhlIGRlbHRhXG4gKiAgICAgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcgdGV4dC4gSXQgdGhlbiBtYW5pcHVsYXRlcyB0aGUgVkRPTSBieSBhcHBseWluZyBDU1MgY2xhc3NlcyBhbmQgc3R5bGVzIHRvXG4gKiAgICAgaW5kaXZpZHVhbCBjaGFyYWN0ZXIgYDxzcGFuPmAgZWxlbWVudHMgdG8gdHJpZ2dlciBDU1MgdHJhbnNpdGlvbnMgZm9yIG1vdmVtZW50IGFuZCBvcGFjaXR5LlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIGEgcHJpbWUgZXhhbXBsZSBvZiB1c2luZyB0aGUgZnJhbWV3b3JrIGZvciBjb21wbGV4LCBkZWNsYXJhdGl2ZSwgYW5kIHBlcmZvcm1hbnQgYW5pbWF0aW9ucy5cbiAqIEl0IGlzIHVzZWZ1bCBmb3IgZ3JhYmJpbmcgdXNlciBhdHRlbnRpb24gb24gbGFuZGluZyBwYWdlcyBvciBmb3IgY3JlYXRpbmcgZHluYW1pYywga2V5bm90ZS1zdHlsZSBwcmVzZW50YXRpb25zLlxuICpcbiAqIFJlbGV2YW50IGNvbmNlcHRzOiBgdGV4dCBhbmltYXRpb25gLCBgY2hhcmFjdGVyIHRyYW5zaXRpb25gLCBgbWFnaWMgbW92ZWAsIGBkZWNsYXJhdGl2ZSBhbmltYXRpb25gLCBgQ1NTIHRyYW5zaXRpb25zYC5cbiAqXG4gKiBEZWVwbHkgaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL3lhbmdzaHVuICdzIHZpZGVvIG9uIExpbmtlZEluXG4gKiBhcyB3ZWxsIGFzIEFwcGxlJ3MgS2V5bm90ZSBNYWdpYyBNb3ZlIGVmZmVjdC5cbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50Lk1hZ2ljTW92ZVRleHRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBNYWdpY01vdmVUZXh0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuTWFnaWNNb3ZlVGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5NYWdpY01vdmVUZXh0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21hZ2ljLW1vdmUtdGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdtYWdpYy1tb3ZlLXRleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSBjeWNsZSB0aHJvdWdoIHRoZSBgY3ljbGVUZXh0c2AgYXJyYXkuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9DeWNsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9DeWNsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiBlYWNoIGF1dG9tYXRpYyB0ZXh0IHRyYW5zaXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXV0b0N5Y2xlSW50ZXJ2YWxfPTIwMDBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvQ3ljbGVJbnRlcnZhbF86IDIwMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHRleHQgY3ljbGVzIGJlZm9yZSB0aGUgbWVhc3VyZW1lbnQgY2FjaGUgaXMgYXV0b21hdGljYWxseSBjbGVhcmVkLlxuICAgICAgICAgKiBTZXQgdG8gMCB0byBkaXNhYmxlIGF1dG9tYXRpYyBjbGVhcmluZy5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjYWNoZUNsZWFySW50ZXJ2YWxfPTEwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2FjaGVDbGVhckludGVydmFsXzogMTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1tYWdpYy1tb3ZlLXRleHQnXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1tYWdpYy1tb3ZlLXRleHQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xvciBhcHBsaWVkIHRvIGNoYXJhY3RlcnMgdGhhdCBhcmUgbW92aW5nIHRvIGEgbmV3IHBvc2l0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29sb3JNb3ZlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yTW92ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xvciBhcHBsaWVkIHRvIG5ldyBjaGFyYWN0ZXJzIGFzIHRoZXkgZmFkZSBpbi5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbG9yRmFkZUluPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmFkZUluOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIGFwcGxpZWQgdG8gb2xkIGNoYXJhY3RlcnMgYXMgdGhleSBmYWRlIG91dC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbG9yRmFkZU91dD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZhZGVPdXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBzdHJpbmdzIHRvIGF1dG9tYXRpY2FsbHkgY3ljbGUgdGhyb3VnaCBpZiBgYXV0b0N5Y2xlYCBpcyB0cnVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxudWxsfSBjeWNsZVRleHRzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGN5Y2xlVGV4dHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9udC1mYW1pbHkgZm9yIHRoZSB0ZXh0LiBDaGFuZ2luZyB0aGlzIHdpbGwgdHJpZ2dlciBhIGNhY2hlIGludmFsaWRhdGlvbiBhbmQgcmVtZWFzdXJlbWVudC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmb250RmFtaWx5Xz0nSGVsdmV0aWNhIE5ldWUnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9udEZhbWlseV86ICdIZWx2ZXRpY2EgTmV1ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgZmFkZS1pbiwgZmFkZS1vdXQsIGFuZCBtb3ZlIGFuaW1hdGlvbnMuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgYXBwbGllZCB0byB0aGUgYC0tbmVvLXRyYW5zaXRpb24tdGltZWAgQ1NTIHZhcmlhYmxlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRyYW5zaXRpb25UaW1lXz01MDBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uVGltZV86IDUwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBWRE9NIHN0cnVjdHVyZSBmb3IgdGhlIGNvbXBvbmVudCwgaW5jbHVkaW5nIGEgY29udGVudCBhcmVhIGFuZCBhIGhpZGRlbiBtZWFzdXJlbWVudCBlbGVtZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7c3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tY29udGVudCddLCBjbjogW119LFxuICAgICAgICAgICAge2NsczogWyduZW8tbWVhc3VyZS1lbGVtZW50LXdyYXBwZXInXSwgcmVtb3ZlRG9tOiB0cnVlLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1lYXN1cmUtZWxlbWVudCddLCBjbjpbXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2Ygb2JqZWN0cywgd2hlcmUgZWFjaCBvYmplY3QgcmVwcmVzZW50cyBhIGNoYXJhY3RlciBpbiB0aGUgY3VycmVudCBgdGV4dGAuXG4gICAgICogRWFjaCBvYmplY3QgY29udGFpbnMgdGhlIGNoYXJhY3RlcidzIGBuYW1lYCAodGhlIGNoYXJhY3RlciBpdHNlbGYpIGFuZCBpdHMgY2FsY3VsYXRlZFxuICAgICAqIGBsZWZ0YCBhbmQgYHRvcGAgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIuXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IGNoYXJzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYXJzID0gW11cbiAgICAvKipcbiAgICAgKiBBIGNhY2hlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVkRPTSBmb3IgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgY2hhcmFjdGVycy5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gcGVyc2lzdCB0aGUgY2hhcmFjdGVyIHN0YXRlIGR1cmluZyByZXNpemUgZXZlbnRzLCBwcmV2ZW50aW5nXG4gICAgICogdGhlIG5lZWQgZm9yIGEgZnVsbCByZWNhbGN1bGF0aW9uLlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBjaGFyc1Zkb209W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2hhcnNWZG9tID0gW11cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQncyBjb250ZW50IGFyZWEsIGRldGVybWluZWQgb24gbW91bnQgYW5kIHJlc2l6ZS5cbiAgICAgKiBVc2VkIHRvIHNpemUgdGhlIG1lYXN1cmVtZW50IHdyYXBwZXIuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBjb250ZW50SGVpZ2h0PTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29udGVudEhlaWdodCA9IDBcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNvbXBvbmVudCdzIGNvbnRlbnQgYXJlYSwgZGV0ZXJtaW5lZCBvbiBtb3VudCBhbmQgcmVzaXplLlxuICAgICAqIFVzZWQgdG8gc2l6ZSB0aGUgbWVhc3VyZW1lbnQgd3JhcHBlci5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbnRlbnRXaWR0aD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnRlbnRXaWR0aCA9IDBcbiAgICAvKipcbiAgICAgKiBDb3VudGVyIGZvciB0aGUgbnVtYmVyIG9mIHRleHQgY3ljbGVzIHNpbmNlIHRoZSBsYXN0IGNhY2hlIGNsZWFyLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gY3ljbGVDb3VudD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGN5Y2xlQ291bnQgPSAwXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBzdHJpbmcgY3VycmVudGx5IGRpc3BsYXllZCBmcm9tIHRoZSBgY3ljbGVUZXh0c2AgYXJyYXkuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBjdXJyZW50SW5kZXg9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjdXJyZW50SW5kZXggPSAwXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGlnbm9yZSB0aGUgdmVyeSBmaXJzdCByZXNpemUgZXZlbnQgdGhhdCBmaXJlcyBpbW1lZGlhdGVseSBhZnRlciBtb3VudGluZyxcbiAgICAgKiBhcyB0aGUgaW5pdGlhbCBtZWFzdXJlbWVudCBpcyBoYW5kbGVkIGJ5IGBhZnRlclNldE1vdW50ZWRgLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGluaXRpYWxSZXNpemVFdmVudD10cnVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluaXRpYWxSZXNpemVFdmVudCA9IHRydWVcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgZm9yIHRoZSBgc2V0SW50ZXJ2YWxgIHVzZWQgZm9yIGBhdXRvQ3ljbGVgLiBTdG9yZWQgc28gaXQgY2FuIGJlIGNsZWFyZWQuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGludGVydmFsSWQ9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbnRlcnZhbElkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZsYWcgdG8gcHJldmVudCBpbmZpbml0ZSByZXRyeSBsb29wcyBpbiBjYXNlIG9mIGVycm9ycyBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1JldHJ5aW5nPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzUmV0cnlpbmcgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSBjb21wb25lbnQgaXMgY3VycmVudGx5IGluIHRoZSBtaWRkbGUgb2YgYW4gYW5pbWF0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IGNvbmN1cnJlbnQsIG92ZXJsYXBwaW5nIHVwZGF0ZXMgKGUuZy4sIGZyb20gYSByZXNpemUgZXZlbnQpLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVHJhbnNpdGlvbmluZz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEEgcGVyZm9ybWFuY2UtY3JpdGljYWwgY2FjaGUuIE1hcHMgYSB0ZXh0IHN0cmluZyB0byBhbiBhcnJheSBvZiBgRE9NUmVjdGAgb2JqZWN0c1xuICAgICAqIGZvciBlYWNoIG9mIGl0cyBjaGFyYWN0ZXJzLiBUaGlzIGF2b2lkcyBjb3N0bHkgRE9NIG1lYXN1cmVtZW50cyBpZiB0aGUgc2FtZSB0ZXh0IGlzXG4gICAgICogZGlzcGxheWVkIGFnYWluLiBJdCBpcyBpbnZhbGlkYXRlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVzaXplcyBvciBpdHMgZm9udCBjaGFuZ2VzLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVhc3VyZUNhY2hlPXt9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1lYXN1cmVDYWNoZSA9IHt9XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBgY2hhcnNgIGFycmF5IGZyb20gdGhlICpwcmV2aW91cyogdGV4dCBzdGF0ZS4gVGhpcyBpcyBlc3NlbnRpYWwgZm9yIGNhbGN1bGF0aW5nXG4gICAgICogdGhlIHRyYW5zaXRpb24sIGFzIGl0J3MgY29tcGFyZWQgYWdhaW5zdCB0aGUgbmV3IGBjaGFyc2AgYXJyYXkgdG8gZGV0ZXJtaW5lIHdoaWNoIGNoYXJhY3RlcnNcbiAgICAgKiBuZWVkIHRvIG1vdmUsIGZhZGUgaW4sIG9yIGZhZGUgb3V0LlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBwcmV2aW91c0NoYXJzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByZXZpb3VzQ2hhcnMgPSBbXVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciB0aGUgVkRPTSBub2RlIHVzZWQgdG8gbWVhc3VyZSBjaGFyYWN0ZXIgcG9zaXRpb25zLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVhc3VyZUVsZW1lbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0IG1lYXN1cmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWFzdXJlV3JhcHBlci5jblswXVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGdldHRlciBmb3IgdGhlIHdyYXBwZXIgb2YgdGhlIG1lYXN1cmVtZW50IFZET00gbm9kZS4gVGhpcyB3cmFwcGVyIGlzIHRlbXBvcmFyaWx5XG4gICAgICogYWRkZWQgdG8gdGhlIERPTSB0byBwZXJmb3JtIG1lYXN1cmVtZW50cy5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1lYXN1cmVXcmFwcGVyXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldCBtZWFzdXJlV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblsxXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciByZWdpc3RlcnMgYSByZXNpemUgbGlzdGVuZXIgdG8gaW52YWxpZGF0ZSB0aGUgbWVhc3VyZW1lbnQgY2FjaGUgd2hlbiB0aGUgY29tcG9uZW50IHNpemUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICByZXNpemU6IG1lLm9uUmVzaXplLFxuICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5hcHA/Lm9uKCd2aXNpYmlsaXR5Y2hhbmdlJywgbWUub25WaXNpYmlsaXR5Q2hhbmdlLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgb3IgdW5yZWdpc3RlcnMgdGhpcyBjb21wb25lbnQgd2l0aCB0aGUgZ2xvYmFsIFJlc2l6ZU9ic2VydmVyIGFkZG9uLlxuICAgICAqIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoYXZpbmcgYSBzZXBhcmF0ZSBvYnNlcnZlciBmb3IgZWFjaCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBtb3VudGVkIFRydWUgdG8gcmVnaXN0ZXIsIGZhbHNlIHRvIHVucmVnaXN0ZXIuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFkZFJlc2l6ZU9ic2VydmVyKG1vdW50ZWQpIHtcbiAgICAgICAgbGV0IHtpZCwgd2luZG93SWR9ID0gdGhpcyxcbiAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyID0gYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIuZ2V0QWRkb24oJ1Jlc2l6ZU9ic2VydmVyJywgd2luZG93SWQpO1xuXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyW21vdW50ZWQgPyAncmVnaXN0ZXInIDogJ3VucmVnaXN0ZXInXSh7aWQsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFJlc2l6ZUV2ZW50ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIG9yIHN0b3BzIHRoZSBhdXRvbWF0aWMgdGV4dCBjeWNsaW5nIHdoZW4gdGhlIGBhdXRvQ3ljbGVgIGNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiBgYXV0b0N5Y2xlYC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgYGF1dG9DeWNsZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0N5Y2xlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLm1vdW50ZWQgJiYgdGhpcy5zdGFydEF1dG9DeWNsZSh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0cyB0aGUgYXV0b21hdGljIHRleHQgY3ljbGluZyB3aXRoIHRoZSBuZXcgaW50ZXJ2YWwgd2hlbiB0aGUgYGF1dG9DeWNsZUludGVydmFsYCBjb25maWcgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiBgYXV0b0N5Y2xlSW50ZXJ2YWxgLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIGBhdXRvQ3ljbGVJbnRlcnZhbGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0N5Y2xlSW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICYmIG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKGZhbHNlKTtcbiAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHRoZSBtZWFzdXJlbWVudCBjYWNoZSBhbmQgdXBkYXRlcyB0aGUgVkRPTSB3aGVuIHRoZSBgZm9udEZhbWlseWAgY29uZmlnIGNoYW5nZXMsXG4gICAgICogYXMgYSBuZXcgZm9udCB3aWxsIGNoYW5nZSBhbGwgY2hhcmFjdGVyIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgIFRoZSBuZXcgdmFsdWUgb2YgYGZvbnRGYW1pbHlgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIGBmb250RmFtaWx5YC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGb250RmFtaWx5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm1lYXN1cmVDYWNoZSA9IHt9O1xuXG4gICAgICAgIG1lLnZkb20uc3R5bGUuZm9udEZhbWlseSA9IHZhbHVlO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGNvbXBvbmVudCdzIG1vdW50ZWQgc3RhdGUgY2hhbmdlcy4gV2hlbiBtb3VudGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjb21wb25lbnQnc1xuICAgICAqIGRpbWVuc2lvbnMuIFdoZW4gdW5tb3VudGVkLCBpdCBjbGVhcnMgdGhlIG1lYXN1cmVtZW50IGNhY2hlIGFuZCBjaGFyYWN0ZXIgc3RhdGUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIGBtb3VudGVkYC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgYG1vdW50ZWRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS5nZXREb21SZWN0KCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jb250ZW50SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbWUuY29udGVudFdpZHRoICA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUubWVhc3VyZUNhY2hlICA9IHt9O1xuICAgICAgICAgICAgbWUucHJldmlvdXNDaGFycyA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWUuYWRkUmVzaXplT2JzZXJ2ZXIodmFsdWUpO1xuXG4gICAgICAgICAgICBtZS5hdXRvQ3ljbGUgJiYgbWUuc3RhcnRBdXRvQ3ljbGUodmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciB0aGUgYW5pbWF0aW9uIHdoZW4gdGhlIGB0ZXh0YCBjb25maWcgaXMgY2hhbmdlZC5cbiAgICAgKiBJdCBvcmNoZXN0cmF0ZXMgdGhlIG1lYXN1cmVtZW50IGFuZCBhbmltYXRpb24gcGhhc2VzLiBJdCBhbHNvIGNvbnRhaW5zIGEgYHRyeS9jYXRjaGBcbiAgICAgKiBibG9jayB0byBoYW5kbGUgcG90ZW50aWFsIGVycm9ycyBkdXJpbmcgdGhlIGNvbXBsZXggYW5pbWF0aW9uIGxvZ2ljLCB3aXRoIGEgc2luZ2xlLXJldHJ5XG4gICAgICogbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0cmFuc2llbnQgc3RhdGVzIGJ5IGNsZWFyaW5nIHRoZSBjYWNoZSBhbmQgcmUtcnVubmluZyB0aGUgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgVGhlIG5ldyB0ZXh0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHRleHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge21lYXN1cmVFbGVtZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUucHJldmlvdXNDaGFycyA9IG1lLmNoYXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChtZS5jYWNoZUNsZWFySW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUuY3ljbGVDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmN5Y2xlQ291bnQgPj0gbWUuY2FjaGVDbGVhckludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1lYXN1cmVDYWNoZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBtZS5jeWNsZUNvdW50ICAgPSAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1lLmNoYXJzID0gW107XG4gICAgICAgICAgICAgICAgbWVhc3VyZUVsZW1lbnQuY24gPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhbHVlPy5zcGxpdCgnJykuZm9yRWFjaChjaGFyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2hhcnMucHVzaCh7bmFtZTogY2hhcn0pO1xuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlRWxlbWVudC5jbi5wdXNoKHt0YWc6ICdzcGFuJywgdGV4dDogY2hhcn0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBtZS5tZWFzdXJlQ2hhcnMoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnVwZGF0ZUNoYXJzKClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLmlzUmV0cnlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNSZXRyeWluZyAgICA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1lYXN1cmVDYWNoZSAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbWUucHJldmlvdXNDaGFycyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGEgdHJhbnNpdGlvbmluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBtZS52ZG9tLmNuWzBdLmNuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbWUuYWZ0ZXJTZXRUZXh0KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmlzUmV0cnlpbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgdHJhbnNpdGlvbiB0aW1lIHRvIGEgQ1NTIHZhcmlhYmxlLCBhbGxvd2luZyB0aGUgYW5pbWF0aW9ucyB0byBiZSBjb250cm9sbGVkIHZpYSBKYXZhU2NyaXB0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIGB0cmFuc2l0aW9uVGltZWAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgYHRyYW5zaXRpb25UaW1lYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUcmFuc2l0aW9uVGltZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLnN0eWxlWyctLW5lby10cmFuc2l0aW9uLXRpbWUnXSA9IHZhbHVlICsgJ21zJztcbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFZET00gZm9yIG5ldyBjaGFyYWN0ZXJzIHRoYXQgYXJlIGZhZGluZyBpbi4gSXQgZmlsdGVycyBvdXQgY2hhcmFjdGVyc1xuICAgICAqIHRoYXQgYXJlIGFscmVhZHkgcHJlc2VudCAoYW5kIHdpbGwgYmUgbW92ZWQgaW5zdGVhZCkuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gbGV0dGVycyBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIG5ldyB0ZXh0LCB3aXRoIGBudWxsYCBmb3IgY2hhcmFjdGVycyB0aGF0IGFscmVhZHkgZXhpc3RlZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119IEFuIGFycmF5IG9mIFZET00gbm9kZXMgZm9yIHRoZSBuZXcgY2hhcmFjdGVycy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hhcnNWZG9tKGxldHRlcnMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjaGFyc30gICAgICAgID0gbWUsXG4gICAgICAgICAgICBjaGFyc0NvbnRhaW5lciA9IFtdLFxuICAgICAgICAgICAgY2hhcjtcblxuICAgICAgICBsZXR0ZXJzLmZvckVhY2goKGxldHRlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChsZXR0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFyID0gY2hhcnNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgY2hhcnNDb250YWluZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNscyAgOiBbJ25lby1jaGFyJ10sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7Y29sb3I6IG1lLmNvbG9yRmFkZUluLCBsZWZ0OiBjaGFyLmxlZnQsIG9wYWNpdHk6IDAsIHRvcDogY2hhci50b3B9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0IDogY2hhci5uYW1lXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJzQ29udGFpbmVyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWR2YW5jZXMgdGhlIHRleHQgdG8gdGhlIG5leHQgc3RyaW5nIGluIHRoZSBgY3ljbGVUZXh0c2AgYXJyYXkuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGN5Y2xlVGV4dCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS50ZXh0ICAgICAgICAgPSBtZS5jeWNsZVRleHRzW21lLmN1cnJlbnRJbmRleF07XG4gICAgICAgIG1lLmN1cnJlbnRJbmRleCA9IChtZS5jdXJyZW50SW5kZXggKyAxKSAlIG1lLmN5Y2xlVGV4dHMubGVuZ3RoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IHBoYXNlIG9mIHRoZSBhbmltYXRpb246IGNhbGN1bGF0aW5nIGNoYXJhY3RlciBwb3NpdGlvbnMuXG4gICAgICogSWYgdGhlIHBvc2l0aW9ucyBmb3IgdGhlIGN1cnJlbnQgdGV4dCBhcmUgbm90IGluIHRoZSBjYWNoZSwgdGhpcyBtZXRob2QgdGVtcG9yYXJpbHlcbiAgICAgKiByZW5kZXJzIHRoZSBjaGFyYWN0ZXJzIGludG8gYSBoaWRkZW4gZGl2LCBtZWFzdXJlcyB0aGVpciBib3VuZGluZyByZWN0YW5nbGVzLFxuICAgICAqIHN0b3JlcyB0aGUgcmVzdWx0cyBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIHJlbW92ZXMgdGhlIG1lYXN1cmVtZW50IGVsZW1lbnRzIGZyb20gdGhlIERPTS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgbWVhc3VyZUNoYXJzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge21lYXN1cmVDYWNoZSwgbWVhc3VyZUVsZW1lbnQsIG1lYXN1cmVXcmFwcGVyLCB0ZXh0fSA9IG1lLFxuICAgICAgICAgICAgcGFyZW50UmVjdCwgcmVjdHMsIHJvb3RSZWN0O1xuXG4gICAgICAgIGlmIChtZWFzdXJlQ2FjaGVbdGV4dF0gJiYgbWVhc3VyZUNhY2hlW3RleHRdLndpZHRoID09PSBtZS5jb250ZW50V2lkdGggJiYgbWVhc3VyZUNhY2hlW3RleHRdLmhlaWdodCA9PT0gbWUuY29udGVudEhlaWdodCkge1xuICAgICAgICAgICAgcmVjdHMgICAgICA9IFsuLi5tZWFzdXJlQ2FjaGVbdGV4dF0ucmVjdHNdO1xuICAgICAgICAgICAgcGFyZW50UmVjdCA9IHJlY3RzLnNoaWZ0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lYXN1cmVXcmFwcGVyLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogbWUuY29udGVudEhlaWdodCArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggOiBtZS5jb250ZW50V2lkdGggICsgJ3B4J1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZGVsZXRlIG1lYXN1cmVXcmFwcGVyLnJlbW92ZURvbTtcblxuICAgICAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMCk7XG5cbiAgICAgICAgICAgIHJlY3RzICAgICAgPSBhd2FpdCBtZS5nZXREb21SZWN0KFttZS5pZCwgbWVhc3VyZVdyYXBwZXIuaWQsIC4uLm1lYXN1cmVFbGVtZW50LmNuLm1hcChub2RlID0+IG5vZGUuaWQpXSk7XG4gICAgICAgICAgICByb290UmVjdCAgID0gcmVjdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHBhcmVudFJlY3QgPSByZWN0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBTZWxmLUNvcnJlY3Rpb246IElmIHRoZSByZWFsIERPTSBzaXplIGRpZmZlcnMgZnJvbSBvdXIgZXhwZWN0ZWQgc2l6ZSwgd2UgdXBkYXRlIGFuZCByZXRyeS5cbiAgICAgICAgICAgIC8vIFdlIGFsbG93IGEgc21hbGwgdG9sZXJhbmNlICgycHgpIGZvciBzdWItcGl4ZWwgcmVuZGVyaW5nIGRpZmZlcmVuY2VzLlxuICAgICAgICAgICAgLy8gV2UgYWxzbyBjaGVjayBmb3IgPiAwIHRvIGF2b2lkIHplcm9pbmcgb3V0IGRpbWVuc2lvbnMgaWYgdGhlIGNvbXBvbmVudCBpcyB0ZW1wb3JhcmlseSBoaWRkZW4uXG4gICAgICAgICAgICBpZiAocm9vdFJlY3Qud2lkdGggPiAwICYmIChNYXRoLmFicyhyb290UmVjdC53aWR0aCAtIG1lLmNvbnRlbnRXaWR0aCkgPiAyIHx8IE1hdGguYWJzKHJvb3RSZWN0LmhlaWdodCAtIG1lLmNvbnRlbnRIZWlnaHQpID4gMikpIHtcbiAgICAgICAgICAgICAgICBtZS5jb250ZW50V2lkdGggID0gcm9vdFJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgbWUuY29udGVudEhlaWdodCA9IHJvb3RSZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBtZS5tZWFzdXJlQ2hhcnMoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZWFzdXJlQ2FjaGVbdGV4dF0gPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtZS5jb250ZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJlY3RzIDogW3BhcmVudFJlY3QsIC4uLnJlY3RzXSxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IG1lLmNvbnRlbnRXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVjdHMuZm9yRWFjaCgocmVjdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIG1lLmNoYXJzW2luZGV4XS5sZWZ0ID0gYCR7cmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgIG1lLmNoYXJzW2luZGV4XS50b3AgID0gYCR7cmVjdC50b3AgIC0gcGFyZW50UmVjdC50b3AgfXB4YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc2l6ZSBldmVudCBoYW5kbGVyLiBJdCB1cGRhdGVzIHRoZSBjb21wb25lbnQncyBkaW1lbnNpb25zLCBpbnZhbGlkYXRlcyB0aGVcbiAgICAgKiBtZWFzdXJlbWVudCBjYWNoZSwgYW5kIHRyaWdnZXJzIGEgcmVtZWFzdXJlbWVudCBhbmQgVkRPTSB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICBUaGUgZXZlbnQgZGF0YSBmcm9tIHRoZSByZXNpemUgb2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjdCBUaGUgbmV3IGJvdW5kaW5nIHJlY3RhbmdsZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBvblJlc2l6ZSh7cmVjdH0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jb250ZW50SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIG1lLmNvbnRlbnRXaWR0aCAgPSByZWN0LndpZHRoO1xuXG4gICAgICAgIG1lLm1lYXN1cmVDYWNoZSA9IHt9O1xuXG4gICAgICAgIGlmICghbWUuaW5pdGlhbFJlc2l6ZUV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIW1lLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm1lYXN1cmVDaGFycygpO1xuXG4gICAgICAgICAgICAgICAgbWUuY2hhcnNWZG9tID0gbWUuY3JlYXRlQ2hhcnNWZG9tKG1lLmNoYXJzLm1hcChjaGFyID0+IGNoYXIubmFtZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5pbml0aWFsUmVzaXplRXZlbnQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gc3dpdGNoaW5nIGJyb3dzZXIgdGFicyBvciBtaW5pbWl6aW5nIHRoZSBicm93c2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLmhpZGRlblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS52aXNpYmlsaXR5U3RhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvblZpc2liaWxpdHlDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5hdXRvQ3ljbGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKGZhbHNlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5pc1JldHJ5aW5nICAgID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWUubWVhc3VyZUNhY2hlICA9IHt9O1xuICAgICAgICAgICAgICAgIG1lLnByZXZpb3VzQ2hhcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc29ydCBjb21wYXJhdG9yIGZ1bmN0aW9uIHVzZWQgdG8gb3JkZXIgY2hhcmFjdGVyIFZET00gbm9kZXMgYmFzZWQgb24gdGhlaXJcbiAgICAgKiBgdG9wYCBhbmQgYGxlZnRgIHN0eWxlIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyBhIGNvbnNpc3RlbnQgRE9NIG9yZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBmaXJzdCBWRE9NIG5vZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIHNlY29uZCBWRE9NIG5vZGUuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc29ydENoYXJhY3RlcnMoYSwgYikge1xuICAgICAgICBsZXQgZGVsdGFUb3AgPSBwYXJzZUZsb2F0KGEuc3R5bGUudG9wKSAtIHBhcnNlRmxvYXQoYi5zdHlsZS50b3ApO1xuXG4gICAgICAgIGlmIChkZWx0YVRvcCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhVG9wXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhLnN0eWxlLmxlZnQpIC0gcGFyc2VGbG9hdChiLnN0eWxlLmxlZnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIG9yIHN0b3BzIHRoZSBgc2V0SW50ZXJ2YWxgIGZvciBhdXRvbWF0aWMgdGV4dCBjeWNsaW5nLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhcnQ9dHJ1ZSBUcnVlIHRvIHN0YXJ0IHRoZSB0aW1lciwgZmFsc2UgdG8gc3RvcCBpdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhcnRBdXRvQ3ljbGUoc3RhcnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgbWUuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKG1lLmN5Y2xlVGV4dC5iaW5kKG1lKSwgbWUuYXV0b0N5Y2xlSW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICBtZS50aW1lb3V0KDIwKS50aGVuKCgpID0+IHttZS5jeWNsZVRleHQoKX0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKG1lLmludGVydmFsSWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kIGFuZCBtb3N0IGNvbXBsZXggcGhhc2Ugb2YgdGhlIGFuaW1hdGlvbjogdXBkYXRpbmcgdGhlIFZET00gdG8gdHJpZ2dlciBDU1MgdHJhbnNpdGlvbnMuXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgY29yZSBcIm1hZ2ljIG1vdmVcIiBsb2dpYyBieSBkZXRlcm1pbmluZyB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgb2xkXG4gICAgICogYW5kIG5ldyB0ZXh0IHN0YXRlcyBhbmQgYXBwbHlpbmcgc3R5bGVzIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogVGhlIGFsZ29yaXRobSBpcyBhcyBmb2xsb3dzOlxuICAgICAqIDEuIEl0ZXJhdGUgdGhyb3VnaCB0aGUgYHByZXZpb3VzQ2hhcnNgLlxuICAgICAqIDIuIEZvciBlYWNoIG9sZCBjaGFyYWN0ZXIsIGNoZWNrIGlmIGl0IGV4aXN0cyBpbiB0aGUgbmV3IHRleHQuXG4gICAgICogICAgLSBJZiBZRVM6IFRoaXMgY2hhcmFjdGVyIG5lZWRzIHRvICoqbW92ZSoqLiBBcHBseSB0aGUgbmV3IGBsZWZ0YCBhbmQgYHRvcGAgc3R5bGVzIHRvIGl0cyBWRE9NIG5vZGUuXG4gICAgICogICAgLSBJZiBOTzogVGhpcyBjaGFyYWN0ZXIgbmVlZHMgdG8gKipmYWRlIG91dCoqLiBGbGFnIGl0IGZvciByZW1vdmFsLlxuICAgICAqIDMuIENyZWF0ZSBuZXcgVkRPTSBub2RlcyBmb3IgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgdW5pcXVlIHRvIHRoZSBuZXcgdGV4dC4gVGhlc2Ugd2lsbCAqKmZhZGUgaW4qKi5cbiAgICAgKiA0LiBBcHBseSBzdHlsZXMgdG8gYWxsIG5vZGVzIHNpbXVsdGFuZW91c2x5IHRvIHRyaWdnZXIgdGhlIENTUyB0cmFuc2l0aW9ucyAobW92ZSwgZmFkZS1pbiwgZmFkZS1vdXQpLlxuICAgICAqIDUuIEFmdGVyIHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uLCBjbGVhbiB1cCB0aGUgVkRPTSBieSByZW1vdmluZyB0aGUgZmFkZWQtb3V0IG5vZGVzLlxuICAgICAqIDYuIEZpbmFsbHksIGZvciBwZXJmb3JtYW5jZSwgY29sbGFwc2UgYWxsIHRoZSBpbmRpdmlkdWFsIGNoYXJhY3RlciBgPHNwYW4+YCBub2RlcyBiYWNrIGludG8gYSBzaW5nbGVcbiAgICAgKiAgICB0ZXh0IG5vZGUgdW50aWwgdGhlIG5leHQgYW5pbWF0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ2hhcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjaGFycywgcHJldmlvdXNDaGFyc30gPSBtZSxcbiAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyICAgICAgICAgPSBtZS52ZG9tLmNuWzBdLFxuICAgICAgICAgICAgbGV0dGVycyAgICAgICAgICAgICAgICA9IGNoYXJzLm1hcChjaGFyID0+IGNoYXIubmFtZSksXG4gICAgICAgICAgICBjaGFyTm9kZSwgaW5kZXg7XG5cbiAgICAgICAgbWUuaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAobWUuY2hhcnNWZG9tLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLmNuID0gbWUuY2hhcnNWZG9tO1xuICAgICAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c0NoYXJzLmZvckVhY2goKHByZXZpb3VzQ2hhciwgcHJldmlvdXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgaW5kZXggPSBsZXR0ZXJzLmluZGV4T2YocHJldmlvdXNDaGFyLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlID0gY2hhcnNDb250YWluZXIuY25bcHJldmlvdXNJbmRleF07XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNoYXJOb2RlLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBtZS5jb2xvck1vdmUsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgOiBjaGFyc1tpbmRleF0ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wICA6IGNoYXJzW2luZGV4XS50b3BcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxldHRlcnNbaW5kZXhdID0gbnVsbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW3ByZXZpb3VzSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgY2hhck5vZGUuZmxhZyA9ICdyZW1vdmUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLnB1c2goLi4ubWUuY3JlYXRlQ2hhcnNWZG9tKGxldHRlcnMpKTtcblxuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKCk7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24uZm9yRWFjaChjaGFyTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhck5vZGUuZmxhZyA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZS5zdHlsZS5jb2xvciAgID0gbWUuY29sb3JGYWRlT3V0O1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGFyTm9kZS5zdHlsZS5vcGFjaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dChtZS50cmFuc2l0aW9uVGltZSk7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24uc29ydChtZS5zb3J0Q2hhcmFjdGVycyk7XG5cbiAgICAgICAgaW5kZXggPSBjaGFyc0NvbnRhaW5lci5jbi5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAoOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW2luZGV4XTtcblxuICAgICAgICAgICAgZGVsZXRlIGNoYXJOb2RlLmZsYWc7XG4gICAgICAgICAgICBkZWxldGUgY2hhck5vZGUuc3R5bGUuY29sb3I7XG5cbiAgICAgICAgICAgIGlmIChjaGFyTm9kZS5zdHlsZS5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNDb250YWluZXIuY24uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwMCk7XG5cbiAgICAgICAgbWUuY2hhcnNWZG9tID0gWy4uLmNoYXJzQ29udGFpbmVyLmNuXTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5sZW5ndGggPSAwO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLnB1c2goe3RleHQ6IG1lLnRleHR9KTtcbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuXG4gICAgICAgIG1lLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWdpY01vdmVUZXh0KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=