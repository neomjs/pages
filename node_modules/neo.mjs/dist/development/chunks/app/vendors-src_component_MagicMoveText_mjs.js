export const __webpack_esm_id__ = "vendors-src_component_MagicMoveText_mjs";
export const __webpack_esm_ids__ = ["vendors-src_component_MagicMoveText_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/component/MagicMoveText.mjs"
/*!*****************************************!*\
  !*** ./src/component/MagicMoveText.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @summary Animates text transitions by calculating character positions and applying CSS transforms.
 *
 * This component creates a "Magic Move" style effect, where changing from one string of text to another results
 * in a smooth animation. Characters that are common between the two strings appear to move to their new positions,
 * while old characters fade out and new characters fade in.
 *
 * This effect is achieved using a two-phase process that leverages Neo.mjs's VDOM and rendering pipeline:
 * 1.  **Measurement Phase (`measureChars`):** When the text changes, the component determines the exact final
 *     position of every character by briefly rendering them into a hidden `measure-element` div and retrieving
 *     their `DOMRect` values. This ensures pixel-perfect transitions even when fonts or dimensions change.
 * 2.  **Animation Phase (`updateChars`):** Using the measured positions, the component calculates the delta
 *     between the old and new text. It manipulates the VDOM to apply CSS transforms for movement and opacity
 *     to individual `<span>` elements.
 *
 * **SEO & Accessibility:**
 * The component supports a `renderSeoList` config which injects a hidden, semantically correct `<ul>` containing
 * all cycle texts. This ensures that search engines and screen readers can index and access the full content
 * without being hindered by the visual animation DOM structure.
 *
 * Relevant concepts: `text animation`, `character transition`, `magic move`, `declarative animation`, `CSS transitions`, `SEO`, `accessibility`.
 *
 * Deeply inspired by https://github.com/yangshun 's video on LinkedIn
 * as well as Apple's Keynote Magic Move effect.
 * @class Neo.component.MagicMoveText
 * @extends Neo.component.Base
 */
class MagicMoveText extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.MagicMoveText'
         * @protected
         */
        className: 'Neo.component.MagicMoveText',
        /**
         * @member {String} ntype='magic-move-text'
         * @protected
         */
        ntype: 'magic-move-text',
        /**
         * Set to true to automatically cycle through the `cycleTexts` array.
         * @member {Boolean} autoCycle_=true
         * @reactive
         */
        autoCycle_: true,
        /**
         * The time in milliseconds between each automatic text transition.
         * @member {Number} autoCycleInterval_=2000
         * @reactive
         */
        autoCycleInterval_: 2000,
        /**
         * @member {String[]} baseCls=['neo-magic-move-text']
         * @protected
         */
        baseCls: ['neo-magic-move-text'],
        /**
         * The color applied to characters that are moving to a new position.
         * @member {String|null} colorMove=null
         */
        colorMove: null,
        /**
         * The color applied to new characters as they fade in.
         * @member {String|null} colorFadeIn=null
         */
        colorFadeIn: null,
        /**
         * The color applied to old characters as they fade out.
         * @member {String|null} colorFadeOut=null
         */
        colorFadeOut: null,
        /**
         * An array of strings to automatically cycle through if `autoCycle` is true.
         * @member {String[]|null} cycleTexts=null
         */
        cycleTexts: null,
        /**
         * The font-family for the text. Changing this will trigger a cache invalidation and remeasurement.
         * @member {String} fontFamily_='Helvetica Neue'
         * @reactive
         */
        fontFamily_: 'Helvetica Neue',
        /**
         * The duration in milliseconds for the fade-in, fade-out, and move animations.
         * This value is applied to the `--neo-transition-time` CSS variable.
         * @member {Number} transitionTime_=500
         * @reactive
         */
        transitionTime_: 500,
        /**
         * Set to true to render a semantic `<ul>` containing all cycleTexts for SEO.
         * @member {Boolean} renderSeoList_=false
         * @reactive
         */
        renderSeoList_: false,
        /**
         * The VDOM structure for the component, including a content area and a hidden measurement element.
         * @member {Object} _vdom
         * @protected
         */
        _vdom:
        {style: {}, cn: [
            {ariaHidden: true, cn: [
                {cls: ['neo-content'], cn: []},
                {cls: ['neo-measure-element-wrapper'], removeDom: true, cn: [
                    {cls: ['neo-measure-element'], cn:[]}
                ]}
            ]}
        ]}
    }

    /**
     * An array of objects, where each object represents a character in the current `text`.
     * Each object contains the character's `name` (the character itself) and its calculated
     * `left` and `top` positions relative to the container.
     * @member {Object[]} chars=[]
     * @protected
     */
    chars = []
    /**
     * A cached representation of the VDOM for the currently displayed characters.
     * This is used to persist the character state during resize events, preventing
     * the need for a full recalculation.
     * @member {Object[]} charsVdom=[]
     * @protected
     */
    charsVdom = []
    /**
     * The height of the component's content area, determined on mount and resize.
     * Used to size the measurement wrapper.
     * @member {Number} contentHeight=0
     * @protected
     */
    contentHeight = 0
    /**
     * The width of the component's content area, determined on mount and resize.
     * Used to size the measurement wrapper.
     * @member {Number} contentWidth=0
     * @protected
     */
    contentWidth = 0
    /**
     * The index of the string currently displayed from the `cycleTexts` array.
     * @member {Number} currentIndex=0
     * @protected
     */
    currentIndex = 0
    /**
     * A flag to ignore the very first resize event that fires immediately after mounting,
     * as the initial measurement is handled by `afterSetMounted`.
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * The ID for the `setInterval` used for `autoCycle`. Stored so it can be cleared.
     * @member {Number|null} intervalId=null
     * @protected
     */
    intervalId = null
    /**
     * Internal flag to prevent infinite retry loops in case of errors during the animation.
     * @member {Boolean} isRetrying=false
     * @protected
     */
    isRetrying = false
    /**
     * A flag to indicate that the component is currently in the middle of an animation.
     * This is used to prevent concurrent, overlapping updates (e.g., from a resize event).
     * @member {Boolean} isTransitioning=false
     * @protected
     */
    isTransitioning = false
    /**
     * Stores the `chars` array from the *previous* text state. This is essential for calculating
     * the transition, as it's compared against the new `chars` array to determine which characters
     * need to move, fade in, or fade out.
     * @member {Object[]} previousChars=[]
     * @protected
     */
    previousChars = []
    /**
     * A getter for the VDOM node used to measure character positions.
     * @member {Object} measureElement
     * @protected
     */
    get measureElement() {
        return this.measureWrapper.cn[0]
    }
    /**
     * A getter for the wrapper of the measurement VDOM node. This wrapper is temporarily
     * added to the DOM to perform measurements.
     * @member {Object} measureWrapper
     * @protected
     */
    get measureWrapper() {
        return this.vdom.cn[0].cn[1]
    }
    /**
     * A getter for the visual content container.
     * @member {Object} visualWrapper
     * @protected
     */
    get visualWrapper() {
        return this.vdom.cn[0].cn[0]
    }

    /**
     * The constructor registers a resize listener to invalidate the measurement cache when the component size changes.
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        });

        me.app?.on('visibilitychange', me.onVisibilityChange, me)
    }

    /**
     * Registers or unregisters this component with the global ResizeObserver addon.
     * This is more efficient than having a separate observer for each component instance.
     * @param {Boolean} mounted True to register, false to unregister.
     * @protected
     */
    async addResizeObserver(mounted) {
        let {id, windowId} = this,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId);

        ResizeObserver[mounted ? 'register' : 'unregister']({id, windowId});

        if (mounted) {
            this.initialResizeEvent = true
        }
    }

    /**
     * Starts or stops the automatic text cycling when the `autoCycle` config changes.
     * @param {Boolean} value    The new value of `autoCycle`.
     * @param {Boolean} oldValue The old value of `autoCycle`.
     * @protected
     */
    afterSetAutoCycle(value, oldValue) {
        this.mounted && this.startAutoCycle(value)
    }

    /**
     * Restarts the automatic text cycling with the new interval when the `autoCycleInterval` config changes.
     * @param {Number} value    The new value of `autoCycleInterval`.
     * @param {Number} oldValue The old value of `autoCycleInterval`.
     * @protected
     */
    afterSetAutoCycleInterval(value, oldValue) {
        let me = this;

        if (oldValue && me.mounted) {
            me.startAutoCycle(false);
            me.startAutoCycle()
        }
    }

    /**
     * Invalidates the measurement cache and updates the VDOM when the `fontFamily` config changes,
     * as a new font will change all character dimensions.
     * @param {String} value    The new value of `fontFamily`.
     * @param {String} oldValue The old value of `fontFamily`.
     * @protected
     */
    afterSetFontFamily(value, oldValue) {
        let me = this;

        me.vdom.style.fontFamily = value;
        me.update()
    }

    /**
     * Handles the component's mounted state changes. When mounted, it determines the component's
     * dimensions. When unmounted, it clears the measurement cache and character state.
     * @param {Boolean} value    The new value of `mounted`.
     * @param {Boolean} oldValue The old value of `mounted`.
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value) {
            me.getDomRect().then(rect => {
                me.contentHeight = rect.height;
                me.contentWidth  = rect.width;
            })
        } else {
            me.previousChars = []
        }

        if (oldValue !== undefined) {
            me.addResizeObserver(value);

            me.autoCycle && me.startAutoCycle(value)
        }
    }

    /**
     * This is the main entry point for the animation when the `text` config is changed.
     * It orchestrates the measurement and animation phases. It also contains a `try/catch`
     * block to handle potential errors during the complex animation logic, with a single-retry
     * mechanism to recover from transient states by clearing the cache and re-running the process.
     * @param {String} value    The new text value.
     * @param {String} oldValue The old text value.
     * @returns {Promise<void>}
     * @protected
     */
    async afterSetText(value, oldValue) {
        let me               = this,
            {measureElement} = me;

        if (oldValue) {
            me.previousChars = me.chars
        }

        if (value) {
            try {
                me.chars = [];
                measureElement.cn = [];

                value?.split('').forEach(char => {
                    me.chars.push({name: char});
                    measureElement.cn.push({tag: 'span', text: char})
                });

                if (me.mounted) {
                    await me.measureChars()
                }

                if (me.isDestroyed) return;

                await me.updateChars()
            } catch (e) {
                if (e === Neo.isDestroyed) return;

                if (!me.isRetrying) {
                    me.isRetrying    = true;
                    me.previousChars = [];

                    // Reset a transitioning state
                    me.visualWrapper.cn.length = 0;

                    await me.afterSetText(value, oldValue)
                }
            }

            me.isRetrying = false
        }
    }

    /**
     * Updates the VDOM to include or remove the SEO-friendly list.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetRenderSeoList(value, oldValue) {
        let me = this;

        if (value) {
            if (!me.vdom.cn[1]) {
                me.vdom.cn.push({
                    tag: 'ul',
                    cls: ['neo-seo-list'],
                    cn : me.cycleTexts?.map(text => ({tag: 'li', text})) || []
                });
                me.update();
            }
        } else {
            if (me.vdom.cn[1] && me.vdom.cn[1].cls.includes('neo-seo-list')) {
                me.vdom.cn.pop();
                me.update();
            }
        }
    }

    /**
     * Applies the transition time to a CSS variable, allowing the animations to be controlled via JavaScript.
     * @param {Number} value    The new value of `transitionTime`.
     * @param {Number} oldValue The old value of `transitionTime`.
     * @protected
     */
    afterSetTransitionTime(value, oldValue) {
        this.vdom.style['--neo-transition-time'] = value + 'ms';
        this.update()
    }

    /**
     * Creates the VDOM for new characters that are fading in. It filters out characters
     * that are already present (and will be moved instead).
     * @param {String[]} letters An array representing the new text, with `null` for characters that already existed.
     * @returns {Object[]} An array of VDOM nodes for the new characters.
     * @protected
     */
    createCharsVdom(letters) {
        let me             = this,
            {chars}        = me,
            charsContainer = [],
            char;

        letters.forEach((letter, index) => {
            if (letter !== null) {
                char = chars[index];

                charsContainer.push({
                    cls  : ['neo-char'],
                    style: {color: me.colorFadeIn, left: char.left, opacity: 0, top: char.top},
                    text : char.name
                })
            }
        });

        return charsContainer
    }

    /**
     * Advances the text to the next string in the `cycleTexts` array.
     * @protected
     */
    cycleText() {
        let me = this;

        me.text         = me.cycleTexts[me.currentIndex];
        me.currentIndex = (me.currentIndex + 1) % me.cycleTexts.length
    }

    /**
     * The first phase of the animation: calculating character positions.
     * If the positions for the current text are not in the cache, this method temporarily
     * renders the characters into a hidden div, measures their bounding rectangles,
     * stores the results in the cache, and then removes the measurement elements from the DOM.
     * @returns {Promise<void>}
     * @protected
     */
    async measureChars() {
        let me = this,
            {measureElement, measureWrapper} = me,
            parentRect, rects, rootRect;

        measureWrapper.style = {
            height: me.contentHeight + 'px',
            width : me.contentWidth  + 'px'
        };

        delete measureWrapper.removeDom;

        await me.promiseUpdate();
        if (me.isDestroyed) return;
        await me.timeout(20);

        rects      = await me.getDomRect([me.id, measureWrapper.id, ...measureElement.cn.map(node => node.id)]);
        if (me.isDestroyed) return;
        rootRect   = rects.shift();
        parentRect = rects.shift();

        // Self-Correction: If the real DOM size differs from our expected size, we update and retry.
        // We allow a small tolerance (2px) for sub-pixel rendering differences.
        // We also check for > 0 to avoid zeroing out dimensions if the component is temporarily hidden.
        if (rootRect.width > 0 && (Math.abs(rootRect.width - me.contentWidth) > 2 || Math.abs(rootRect.height - me.contentHeight) > 2)) {
            me.contentWidth  = rootRect.width;
            me.contentHeight = rootRect.height;

            return me.measureChars()
        }

        // Race condition guard: If text changed while we were measuring, me.chars might be out of sync.
        if (rects.length !== me.chars.length) {
            return
        }

        rects.forEach((rect, index) => {
            me.chars[index].left = `${rect.left - parentRect.left}px`;
            me.chars[index].top  = `${rect.top  - parentRect.top }px`;
        });

        await me.promiseUpdate()
    }

    /**
     * The resize event handler. It updates the component's dimensions, invalidates the
     * measurement cache, and triggers a remeasurement and VDOM update.
     * @param {Object} data      The event data from the resize observer.
     * @param {Object} data.rect The new bounding rectangle of the component.
     * @returns {Promise<void>}
     * @protected
     */
    async onResize({rect}) {
        let me = this;

        me.contentHeight = rect.height;
        me.contentWidth  = rect.width;

        if (!me.initialResizeEvent) {
            if (!me.isTransitioning) {
                await me.measureChars();

                me.charsVdom = me.createCharsVdom(me.chars.map(char => char.name))
            }
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * Triggered when switching browser tabs or minimizing the browser
     * @param {Object}  data
     * @param {Boolean} data.hidden
     * @param {String}  data.visibilityState
     * @param {Number}  data.windowId
     */
    onVisibilityChange(data) {
        let me = this;

        if (me.autoCycle) {
            if (data.hidden) {
                me.startAutoCycle(false)
            } else {
                me.isRetrying    = false;
                me.previousChars = [];

                me.startAutoCycle()
            }
        }
    }

    /**
     * A sort comparator function used to order character VDOM nodes based on their
     * `top` and `left` style properties. This ensures a consistent DOM order.
     * @param {Object} a The first VDOM node.
     * @param {Object} b The second VDOM node.
     * @returns {Number}
     * @protected
     */
    sortCharacters(a, b) {
        let deltaTop = parseFloat(a.style.top) - parseFloat(b.style.top);

        if (deltaTop !== 0) {
            return deltaTop
        }

        return parseFloat(a.style.left) - parseFloat(b.style.left)
    }

    /**
     * Starts or stops the `setInterval` for automatic text cycling.
     * @param {Boolean} start=true True to start the timer, false to stop it.
     * @protected
     */
    startAutoCycle(start=true) {
        let me = this;

        if (start) {
            me.intervalId = setInterval(me.cycleText.bind(me), me.autoCycleInterval);

            me.timeout(20).then(() => {me.cycleText()})
        } else {
            clearInterval(me.intervalId)
        }
    }

    /**
     * The second and most complex phase of the animation: updating the VDOM to trigger CSS transitions.
     * This method implements the core "magic move" logic by determining the delta between the old
     * and new text states and applying styles accordingly.
     *
     * The algorithm is as follows:
     * 1. Iterate through the `previousChars`.
     * 2. For each old character, check if it exists in the new text.
     *    - If YES: This character needs to **move**. Apply the new `left` and `top` styles to its VDOM node.
     *    - If NO: This character needs to **fade out**. Flag it for removal.
     * 3. Create new VDOM nodes for all characters that are unique to the new text. These will **fade in**.
     * 4. Apply styles to all nodes simultaneously to trigger the CSS transitions (move, fade-in, fade-out).
     * 5. After the transition duration, clean up the VDOM by removing the faded-out nodes.
     * 6. Finally, for performance, collapse all the individual character `<span>` nodes back into a single
     *    text node until the next animation is triggered.
     * @returns {Promise<void>}
     * @protected
     */
    async updateChars() {
        let me                     = this,
            {chars, previousChars} = me,
            charsContainer         = me.visualWrapper,
            letters                = chars.map(char => char.name),
            charNode, index;

        me.isTransitioning = true;

        if (me.charsVdom.length > 1) {
            charsContainer.cn = me.charsVdom;
            await me.promiseUpdate();
            if (me.isDestroyed) return;
        }

        previousChars.forEach((previousChar, previousIndex) => {
            index = letters.indexOf(previousChar.name);

            if (index > -1) {
                charNode = charsContainer.cn[previousIndex];

                Object.assign(charNode.style, {
                    color: me.colorMove,
                    left : chars[index].left,
                    top  : chars[index].top
                });

                letters[index] = null
            } else {
                charNode = charsContainer.cn[previousIndex];

                charNode.flag = 'remove'
            }
        });

        charsContainer.cn.push(...me.createCharsVdom(letters));

        await me.promiseUpdate();
        if (me.isDestroyed) return;

        charsContainer.cn.forEach(charNode => {
            if (charNode.flag === 'remove') {
                charNode.style.color   = me.colorFadeOut;
                charNode.style.opacity = 0
            } else {
                delete charNode.style.opacity
            }
        });

        await me.promiseUpdate();
        if (me.isDestroyed) return;
        await me.timeout(me.transitionTime);

        charsContainer.cn.sort(me.sortCharacters);

        index = charsContainer.cn.length - 1;

        for (; index >= 0; index--) {
            charNode = charsContainer.cn[index];

            delete charNode.flag;
            delete charNode.style.color;

            if (charNode.style.opacity === 0) {
                charsContainer.cn.splice(index, 1)
            }
        }

        await me.promiseUpdate();
        if (me.isDestroyed) return;
        await me.timeout(200);

        me.charsVdom = [...charsContainer.cn];

        me.isTransitioning = false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MagicMoveText));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfTWFnaWNNb3ZlVGV4dF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQVM7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCLGFBQWE7QUFDYixpQkFBaUIsNkJBQTZCO0FBQzlDLGlCQUFpQjtBQUNqQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUEsNkRBQTZELGFBQWE7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsV0FBVztBQUM5Qyw0Q0FBNEMsd0JBQXdCO0FBQ3BFLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0U7QUFDOUY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRSxzQ0FBc0MsNEJBQTRCO0FBQ2xFLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxlQUFlO0FBQ3RELFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLFlBQVk7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTWFnaWNNb3ZlVGV4dC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEFuaW1hdGVzIHRleHQgdHJhbnNpdGlvbnMgYnkgY2FsY3VsYXRpbmcgY2hhcmFjdGVyIHBvc2l0aW9ucyBhbmQgYXBwbHlpbmcgQ1NTIHRyYW5zZm9ybXMuXG4gKlxuICogVGhpcyBjb21wb25lbnQgY3JlYXRlcyBhIFwiTWFnaWMgTW92ZVwiIHN0eWxlIGVmZmVjdCwgd2hlcmUgY2hhbmdpbmcgZnJvbSBvbmUgc3RyaW5nIG9mIHRleHQgdG8gYW5vdGhlciByZXN1bHRzXG4gKiBpbiBhIHNtb290aCBhbmltYXRpb24uIENoYXJhY3RlcnMgdGhhdCBhcmUgY29tbW9uIGJldHdlZW4gdGhlIHR3byBzdHJpbmdzIGFwcGVhciB0byBtb3ZlIHRvIHRoZWlyIG5ldyBwb3NpdGlvbnMsXG4gKiB3aGlsZSBvbGQgY2hhcmFjdGVycyBmYWRlIG91dCBhbmQgbmV3IGNoYXJhY3RlcnMgZmFkZSBpbi5cbiAqXG4gKiBUaGlzIGVmZmVjdCBpcyBhY2hpZXZlZCB1c2luZyBhIHR3by1waGFzZSBwcm9jZXNzIHRoYXQgbGV2ZXJhZ2VzIE5lby5tanMncyBWRE9NIGFuZCByZW5kZXJpbmcgcGlwZWxpbmU6XG4gKiAxLiAgKipNZWFzdXJlbWVudCBQaGFzZSAoYG1lYXN1cmVDaGFyc2ApOioqIFdoZW4gdGhlIHRleHQgY2hhbmdlcywgdGhlIGNvbXBvbmVudCBkZXRlcm1pbmVzIHRoZSBleGFjdCBmaW5hbFxuICogICAgIHBvc2l0aW9uIG9mIGV2ZXJ5IGNoYXJhY3RlciBieSBicmllZmx5IHJlbmRlcmluZyB0aGVtIGludG8gYSBoaWRkZW4gYG1lYXN1cmUtZWxlbWVudGAgZGl2IGFuZCByZXRyaWV2aW5nXG4gKiAgICAgdGhlaXIgYERPTVJlY3RgIHZhbHVlcy4gVGhpcyBlbnN1cmVzIHBpeGVsLXBlcmZlY3QgdHJhbnNpdGlvbnMgZXZlbiB3aGVuIGZvbnRzIG9yIGRpbWVuc2lvbnMgY2hhbmdlLlxuICogMi4gICoqQW5pbWF0aW9uIFBoYXNlIChgdXBkYXRlQ2hhcnNgKToqKiBVc2luZyB0aGUgbWVhc3VyZWQgcG9zaXRpb25zLCB0aGUgY29tcG9uZW50IGNhbGN1bGF0ZXMgdGhlIGRlbHRhXG4gKiAgICAgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcgdGV4dC4gSXQgbWFuaXB1bGF0ZXMgdGhlIFZET00gdG8gYXBwbHkgQ1NTIHRyYW5zZm9ybXMgZm9yIG1vdmVtZW50IGFuZCBvcGFjaXR5XG4gKiAgICAgdG8gaW5kaXZpZHVhbCBgPHNwYW4+YCBlbGVtZW50cy5cbiAqXG4gKiAqKlNFTyAmIEFjY2Vzc2liaWxpdHk6KipcbiAqIFRoZSBjb21wb25lbnQgc3VwcG9ydHMgYSBgcmVuZGVyU2VvTGlzdGAgY29uZmlnIHdoaWNoIGluamVjdHMgYSBoaWRkZW4sIHNlbWFudGljYWxseSBjb3JyZWN0IGA8dWw+YCBjb250YWluaW5nXG4gKiBhbGwgY3ljbGUgdGV4dHMuIFRoaXMgZW5zdXJlcyB0aGF0IHNlYXJjaCBlbmdpbmVzIGFuZCBzY3JlZW4gcmVhZGVycyBjYW4gaW5kZXggYW5kIGFjY2VzcyB0aGUgZnVsbCBjb250ZW50XG4gKiB3aXRob3V0IGJlaW5nIGhpbmRlcmVkIGJ5IHRoZSB2aXN1YWwgYW5pbWF0aW9uIERPTSBzdHJ1Y3R1cmUuXG4gKlxuICogUmVsZXZhbnQgY29uY2VwdHM6IGB0ZXh0IGFuaW1hdGlvbmAsIGBjaGFyYWN0ZXIgdHJhbnNpdGlvbmAsIGBtYWdpYyBtb3ZlYCwgYGRlY2xhcmF0aXZlIGFuaW1hdGlvbmAsIGBDU1MgdHJhbnNpdGlvbnNgLCBgU0VPYCwgYGFjY2Vzc2liaWxpdHlgLlxuICpcbiAqIERlZXBseSBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20veWFuZ3NodW4gJ3MgdmlkZW8gb24gTGlua2VkSW5cbiAqIGFzIHdlbGwgYXMgQXBwbGUncyBLZXlub3RlIE1hZ2ljIE1vdmUgZWZmZWN0LlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuTWFnaWNNb3ZlVGV4dFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIE1hZ2ljTW92ZVRleHQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5NYWdpY01vdmVUZXh0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50Lk1hZ2ljTW92ZVRleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbWFnaWMtbW92ZS10ZXh0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21hZ2ljLW1vdmUtdGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGN5Y2xlIHRocm91Z2ggdGhlIGBjeWNsZVRleHRzYCBhcnJheS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0N5Y2xlXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0N5Y2xlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIGVhY2ggYXV0b21hdGljIHRleHQgdHJhbnNpdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhdXRvQ3ljbGVJbnRlcnZhbF89MjAwMFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9DeWNsZUludGVydmFsXzogMjAwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLW1hZ2ljLW1vdmUtdGV4dCddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLW1hZ2ljLW1vdmUtdGV4dCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIGFwcGxpZWQgdG8gY2hhcmFjdGVycyB0aGF0IGFyZSBtb3ZpbmcgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb2xvck1vdmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JNb3ZlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIGFwcGxpZWQgdG8gbmV3IGNoYXJhY3RlcnMgYXMgdGhleSBmYWRlIGluLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29sb3JGYWRlSW49bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGYWRlSW46IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29sb3IgYXBwbGllZCB0byBvbGQgY2hhcmFjdGVycyBhcyB0aGV5IGZhZGUgb3V0LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29sb3JGYWRlT3V0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmFkZU91dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIHN0cmluZ3MgdG8gYXV0b21hdGljYWxseSBjeWNsZSB0aHJvdWdoIGlmIGBhdXRvQ3ljbGVgIGlzIHRydWUuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGN5Y2xlVGV4dHM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY3ljbGVUZXh0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmb250LWZhbWlseSBmb3IgdGhlIHRleHQuIENoYW5naW5nIHRoaXMgd2lsbCB0cmlnZ2VyIGEgY2FjaGUgaW52YWxpZGF0aW9uIGFuZCByZW1lYXN1cmVtZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGZvbnRGYW1pbHlfPSdIZWx2ZXRpY2EgTmV1ZSdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBmb250RmFtaWx5XzogJ0hlbHZldGljYSBOZXVlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBmYWRlLWluLCBmYWRlLW91dCwgYW5kIG1vdmUgYW5pbWF0aW9ucy5cbiAgICAgICAgICogVGhpcyB2YWx1ZSBpcyBhcHBsaWVkIHRvIHRoZSBgLS1uZW8tdHJhbnNpdGlvbi10aW1lYCBDU1MgdmFyaWFibGUuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdHJhbnNpdGlvblRpbWVfPTUwMFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25UaW1lXzogNTAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIHRydWUgdG8gcmVuZGVyIGEgc2VtYW50aWMgYDx1bD5gIGNvbnRhaW5pbmcgYWxsIGN5Y2xlVGV4dHMgZm9yIFNFTy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVuZGVyU2VvTGlzdF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJTZW9MaXN0XzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVkRPTSBzdHJ1Y3R1cmUgZm9yIHRoZSBjb21wb25lbnQsIGluY2x1ZGluZyBhIGNvbnRlbnQgYXJlYSBhbmQgYSBoaWRkZW4gbWVhc3VyZW1lbnQgZWxlbWVudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3N0eWxlOiB7fSwgY246IFtcbiAgICAgICAgICAgIHthcmlhSGlkZGVuOiB0cnVlLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNvbnRlbnQnXSwgY246IFtdfSxcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tZWFzdXJlLWVsZW1lbnQtd3JhcHBlciddLCByZW1vdmVEb206IHRydWUsIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1lYXN1cmUtZWxlbWVudCddLCBjbjpbXX1cbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBvYmplY3RzLCB3aGVyZSBlYWNoIG9iamVjdCByZXByZXNlbnRzIGEgY2hhcmFjdGVyIGluIHRoZSBjdXJyZW50IGB0ZXh0YC5cbiAgICAgKiBFYWNoIG9iamVjdCBjb250YWlucyB0aGUgY2hhcmFjdGVyJ3MgYG5hbWVgICh0aGUgY2hhcmFjdGVyIGl0c2VsZikgYW5kIGl0cyBjYWxjdWxhdGVkXG4gICAgICogYGxlZnRgIGFuZCBgdG9wYCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lci5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gY2hhcnM9W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2hhcnMgPSBbXVxuICAgIC8qKlxuICAgICAqIEEgY2FjaGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWRE9NIGZvciB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBjaGFyYWN0ZXJzLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBwZXJzaXN0IHRoZSBjaGFyYWN0ZXIgc3RhdGUgZHVyaW5nIHJlc2l6ZSBldmVudHMsIHByZXZlbnRpbmdcbiAgICAgKiB0aGUgbmVlZCBmb3IgYSBmdWxsIHJlY2FsY3VsYXRpb24uXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IGNoYXJzVmRvbT1bXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjaGFyc1Zkb20gPSBbXVxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCdzIGNvbnRlbnQgYXJlYSwgZGV0ZXJtaW5lZCBvbiBtb3VudCBhbmQgcmVzaXplLlxuICAgICAqIFVzZWQgdG8gc2l6ZSB0aGUgbWVhc3VyZW1lbnQgd3JhcHBlci5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbnRlbnRIZWlnaHQ9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjb250ZW50SGVpZ2h0ID0gMFxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY29tcG9uZW50J3MgY29udGVudCBhcmVhLCBkZXRlcm1pbmVkIG9uIG1vdW50IGFuZCByZXNpemUuXG4gICAgICogVXNlZCB0byBzaXplIHRoZSBtZWFzdXJlbWVudCB3cmFwcGVyLlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gY29udGVudFdpZHRoPTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29udGVudFdpZHRoID0gMFxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgc3RyaW5nIGN1cnJlbnRseSBkaXNwbGF5ZWQgZnJvbSB0aGUgYGN5Y2xlVGV4dHNgIGFycmF5LlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gY3VycmVudEluZGV4PTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3VycmVudEluZGV4ID0gMFxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBpZ25vcmUgdGhlIHZlcnkgZmlyc3QgcmVzaXplIGV2ZW50IHRoYXQgZmlyZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgbW91bnRpbmcsXG4gICAgICogYXMgdGhlIGluaXRpYWwgbWVhc3VyZW1lbnQgaXMgaGFuZGxlZCBieSBgYWZ0ZXJTZXRNb3VudGVkYC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbml0aWFsUmVzaXplRXZlbnQ9dHJ1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsUmVzaXplRXZlbnQgPSB0cnVlXG4gICAgLyoqXG4gICAgICogVGhlIElEIGZvciB0aGUgYHNldEludGVydmFsYCB1c2VkIGZvciBgYXV0b0N5Y2xlYC4gU3RvcmVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkLlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpbnRlcnZhbElkPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW50ZXJ2YWxJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHByZXZlbnQgaW5maW5pdGUgcmV0cnkgbG9vcHMgaW4gY2FzZSBvZiBlcnJvcnMgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNSZXRyeWluZz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc1JldHJ5aW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgY29tcG9uZW50IGlzIGN1cnJlbnRseSBpbiB0aGUgbWlkZGxlIG9mIGFuIGFuaW1hdGlvbi5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBjb25jdXJyZW50LCBvdmVybGFwcGluZyB1cGRhdGVzIChlLmcuLCBmcm9tIGEgcmVzaXplIGV2ZW50KS5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1RyYW5zaXRpb25pbmc9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGBjaGFyc2AgYXJyYXkgZnJvbSB0aGUgKnByZXZpb3VzKiB0ZXh0IHN0YXRlLiBUaGlzIGlzIGVzc2VudGlhbCBmb3IgY2FsY3VsYXRpbmdcbiAgICAgKiB0aGUgdHJhbnNpdGlvbiwgYXMgaXQncyBjb21wYXJlZCBhZ2FpbnN0IHRoZSBuZXcgYGNoYXJzYCBhcnJheSB0byBkZXRlcm1pbmUgd2hpY2ggY2hhcmFjdGVyc1xuICAgICAqIG5lZWQgdG8gbW92ZSwgZmFkZSBpbiwgb3IgZmFkZSBvdXQuXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHByZXZpb3VzQ2hhcnM9W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJldmlvdXNDaGFycyA9IFtdXG4gICAgLyoqXG4gICAgICogQSBnZXR0ZXIgZm9yIHRoZSBWRE9NIG5vZGUgdXNlZCB0byBtZWFzdXJlIGNoYXJhY3RlciBwb3NpdGlvbnMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtZWFzdXJlRWxlbWVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgbWVhc3VyZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lYXN1cmVXcmFwcGVyLmNuWzBdXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciB0aGUgd3JhcHBlciBvZiB0aGUgbWVhc3VyZW1lbnQgVkRPTSBub2RlLiBUaGlzIHdyYXBwZXIgaXMgdGVtcG9yYXJpbHlcbiAgICAgKiBhZGRlZCB0byB0aGUgRE9NIHRvIHBlcmZvcm0gbWVhc3VyZW1lbnRzLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVhc3VyZVdyYXBwZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0IG1lYXN1cmVXcmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzFdXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciB0aGUgdmlzdWFsIGNvbnRlbnQgY29udGFpbmVyLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gdmlzdWFsV3JhcHBlclxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgdmlzdWFsV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXS5jblswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciByZWdpc3RlcnMgYSByZXNpemUgbGlzdGVuZXIgdG8gaW52YWxpZGF0ZSB0aGUgbWVhc3VyZW1lbnQgY2FjaGUgd2hlbiB0aGUgY29tcG9uZW50IHNpemUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICByZXNpemU6IG1lLm9uUmVzaXplLFxuICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5hcHA/Lm9uKCd2aXNpYmlsaXR5Y2hhbmdlJywgbWUub25WaXNpYmlsaXR5Q2hhbmdlLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgb3IgdW5yZWdpc3RlcnMgdGhpcyBjb21wb25lbnQgd2l0aCB0aGUgZ2xvYmFsIFJlc2l6ZU9ic2VydmVyIGFkZG9uLlxuICAgICAqIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoYXZpbmcgYSBzZXBhcmF0ZSBvYnNlcnZlciBmb3IgZWFjaCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBtb3VudGVkIFRydWUgdG8gcmVnaXN0ZXIsIGZhbHNlIHRvIHVucmVnaXN0ZXIuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFkZFJlc2l6ZU9ic2VydmVyKG1vdW50ZWQpIHtcbiAgICAgICAgbGV0IHtpZCwgd2luZG93SWR9ID0gdGhpcyxcbiAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyID0gYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIuZ2V0QWRkb24oJ1Jlc2l6ZU9ic2VydmVyJywgd2luZG93SWQpO1xuXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyW21vdW50ZWQgPyAncmVnaXN0ZXInIDogJ3VucmVnaXN0ZXInXSh7aWQsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFJlc2l6ZUV2ZW50ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIG9yIHN0b3BzIHRoZSBhdXRvbWF0aWMgdGV4dCBjeWNsaW5nIHdoZW4gdGhlIGBhdXRvQ3ljbGVgIGNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiBgYXV0b0N5Y2xlYC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgYGF1dG9DeWNsZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0N5Y2xlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLm1vdW50ZWQgJiYgdGhpcy5zdGFydEF1dG9DeWNsZSh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0cyB0aGUgYXV0b21hdGljIHRleHQgY3ljbGluZyB3aXRoIHRoZSBuZXcgaW50ZXJ2YWwgd2hlbiB0aGUgYGF1dG9DeWNsZUludGVydmFsYCBjb25maWcgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiBgYXV0b0N5Y2xlSW50ZXJ2YWxgLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIGBhdXRvQ3ljbGVJbnRlcnZhbGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0N5Y2xlSW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICYmIG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKGZhbHNlKTtcbiAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHRoZSBtZWFzdXJlbWVudCBjYWNoZSBhbmQgdXBkYXRlcyB0aGUgVkRPTSB3aGVuIHRoZSBgZm9udEZhbWlseWAgY29uZmlnIGNoYW5nZXMsXG4gICAgICogYXMgYSBuZXcgZm9udCB3aWxsIGNoYW5nZSBhbGwgY2hhcmFjdGVyIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgIFRoZSBuZXcgdmFsdWUgb2YgYGZvbnRGYW1pbHlgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIGBmb250RmFtaWx5YC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGb250RmFtaWx5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZkb20uc3R5bGUuZm9udEZhbWlseSA9IHZhbHVlO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGNvbXBvbmVudCdzIG1vdW50ZWQgc3RhdGUgY2hhbmdlcy4gV2hlbiBtb3VudGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjb21wb25lbnQnc1xuICAgICAqIGRpbWVuc2lvbnMuIFdoZW4gdW5tb3VudGVkLCBpdCBjbGVhcnMgdGhlIG1lYXN1cmVtZW50IGNhY2hlIGFuZCBjaGFyYWN0ZXIgc3RhdGUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIGBtb3VudGVkYC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgYG1vdW50ZWRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS5nZXREb21SZWN0KCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jb250ZW50SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbWUuY29udGVudFdpZHRoICA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUucHJldmlvdXNDaGFycyA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWUuYWRkUmVzaXplT2JzZXJ2ZXIodmFsdWUpO1xuXG4gICAgICAgICAgICBtZS5hdXRvQ3ljbGUgJiYgbWUuc3RhcnRBdXRvQ3ljbGUodmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciB0aGUgYW5pbWF0aW9uIHdoZW4gdGhlIGB0ZXh0YCBjb25maWcgaXMgY2hhbmdlZC5cbiAgICAgKiBJdCBvcmNoZXN0cmF0ZXMgdGhlIG1lYXN1cmVtZW50IGFuZCBhbmltYXRpb24gcGhhc2VzLiBJdCBhbHNvIGNvbnRhaW5zIGEgYHRyeS9jYXRjaGBcbiAgICAgKiBibG9jayB0byBoYW5kbGUgcG90ZW50aWFsIGVycm9ycyBkdXJpbmcgdGhlIGNvbXBsZXggYW5pbWF0aW9uIGxvZ2ljLCB3aXRoIGEgc2luZ2xlLXJldHJ5XG4gICAgICogbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0cmFuc2llbnQgc3RhdGVzIGJ5IGNsZWFyaW5nIHRoZSBjYWNoZSBhbmQgcmUtcnVubmluZyB0aGUgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgVGhlIG5ldyB0ZXh0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHRleHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge21lYXN1cmVFbGVtZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUucHJldmlvdXNDaGFycyA9IG1lLmNoYXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWUuY2hhcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZWFzdXJlRWxlbWVudC5jbiA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFsdWU/LnNwbGl0KCcnKS5mb3JFYWNoKGNoYXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5jaGFycy5wdXNoKHtuYW1lOiBjaGFyfSk7XG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50LmNuLnB1c2goe3RhZzogJ3NwYW4nLCB0ZXh0OiBjaGFyfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lLm1lYXN1cmVDaGFycygpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmlzRGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBtZS51cGRhdGVDaGFycygpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IE5lby5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5pc1JldHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzUmV0cnlpbmcgICAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5wcmV2aW91c0NoYXJzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgYSB0cmFuc2l0aW9uaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIG1lLnZpc3VhbFdyYXBwZXIuY24ubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBtZS5hZnRlclNldFRleHQodmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuaXNSZXRyeWluZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBWRE9NIHRvIGluY2x1ZGUgb3IgcmVtb3ZlIHRoZSBTRU8tZnJpZW5kbHkgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJlbmRlclNlb0xpc3QodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIW1lLnZkb20uY25bMV0pIHtcbiAgICAgICAgICAgICAgICBtZS52ZG9tLmNuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0YWc6ICd1bCcsXG4gICAgICAgICAgICAgICAgICAgIGNsczogWyduZW8tc2VvLWxpc3QnXSxcbiAgICAgICAgICAgICAgICAgICAgY24gOiBtZS5jeWNsZVRleHRzPy5tYXAodGV4dCA9PiAoe3RhZzogJ2xpJywgdGV4dH0pKSB8fCBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1lLnZkb20uY25bMV0gJiYgbWUudmRvbS5jblsxXS5jbHMuaW5jbHVkZXMoJ25lby1zZW8tbGlzdCcpKSB7XG4gICAgICAgICAgICAgICAgbWUudmRvbS5jbi5wb3AoKTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHRyYW5zaXRpb24gdGltZSB0byBhIENTUyB2YXJpYWJsZSwgYWxsb3dpbmcgdGhlIGFuaW1hdGlvbnMgdG8gYmUgY29udHJvbGxlZCB2aWEgSmF2YVNjcmlwdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiBgdHJhbnNpdGlvblRpbWVgLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIGB0cmFuc2l0aW9uVGltZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvblRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmRvbS5zdHlsZVsnLS1uZW8tdHJhbnNpdGlvbi10aW1lJ10gPSB2YWx1ZSArICdtcyc7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBWRE9NIGZvciBuZXcgY2hhcmFjdGVycyB0aGF0IGFyZSBmYWRpbmcgaW4uIEl0IGZpbHRlcnMgb3V0IGNoYXJhY3RlcnNcbiAgICAgKiB0aGF0IGFyZSBhbHJlYWR5IHByZXNlbnQgKGFuZCB3aWxsIGJlIG1vdmVkIGluc3RlYWQpLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGxldHRlcnMgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBuZXcgdGV4dCwgd2l0aCBgbnVsbGAgZm9yIGNoYXJhY3RlcnMgdGhhdCBhbHJlYWR5IGV4aXN0ZWQuXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBBbiBhcnJheSBvZiBWRE9NIG5vZGVzIGZvciB0aGUgbmV3IGNoYXJhY3RlcnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoYXJzVmRvbShsZXR0ZXJzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2hhcnN9ICAgICAgICA9IG1lLFxuICAgICAgICAgICAgY2hhcnNDb250YWluZXIgPSBbXSxcbiAgICAgICAgICAgIGNoYXI7XG5cbiAgICAgICAgbGV0dGVycy5mb3JFYWNoKChsZXR0ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAobGV0dGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IGNoYXJzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tY2hhciddLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge2NvbG9yOiBtZS5jb2xvckZhZGVJbiwgbGVmdDogY2hhci5sZWZ0LCBvcGFjaXR5OiAwLCB0b3A6IGNoYXIudG9wfSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA6IGNoYXIubmFtZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFyc0NvbnRhaW5lclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2VzIHRoZSB0ZXh0IHRvIHRoZSBuZXh0IHN0cmluZyBpbiB0aGUgYGN5Y2xlVGV4dHNgIGFycmF5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjeWNsZVRleHQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudGV4dCAgICAgICAgID0gbWUuY3ljbGVUZXh0c1ttZS5jdXJyZW50SW5kZXhdO1xuICAgICAgICBtZS5jdXJyZW50SW5kZXggPSAobWUuY3VycmVudEluZGV4ICsgMSkgJSBtZS5jeWNsZVRleHRzLmxlbmd0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBwaGFzZSBvZiB0aGUgYW5pbWF0aW9uOiBjYWxjdWxhdGluZyBjaGFyYWN0ZXIgcG9zaXRpb25zLlxuICAgICAqIElmIHRoZSBwb3NpdGlvbnMgZm9yIHRoZSBjdXJyZW50IHRleHQgYXJlIG5vdCBpbiB0aGUgY2FjaGUsIHRoaXMgbWV0aG9kIHRlbXBvcmFyaWx5XG4gICAgICogcmVuZGVycyB0aGUgY2hhcmFjdGVycyBpbnRvIGEgaGlkZGVuIGRpdiwgbWVhc3VyZXMgdGhlaXIgYm91bmRpbmcgcmVjdGFuZ2xlcyxcbiAgICAgKiBzdG9yZXMgdGhlIHJlc3VsdHMgaW4gdGhlIGNhY2hlLCBhbmQgdGhlbiByZW1vdmVzIHRoZSBtZWFzdXJlbWVudCBlbGVtZW50cyBmcm9tIHRoZSBET00uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIG1lYXN1cmVDaGFycygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHttZWFzdXJlRWxlbWVudCwgbWVhc3VyZVdyYXBwZXJ9ID0gbWUsXG4gICAgICAgICAgICBwYXJlbnRSZWN0LCByZWN0cywgcm9vdFJlY3Q7XG5cbiAgICAgICAgbWVhc3VyZVdyYXBwZXIuc3R5bGUgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IG1lLmNvbnRlbnRIZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGggOiBtZS5jb250ZW50V2lkdGggICsgJ3B4J1xuICAgICAgICB9O1xuXG4gICAgICAgIGRlbGV0ZSBtZWFzdXJlV3JhcHBlci5yZW1vdmVEb207XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBpZiAobWUuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMCk7XG5cbiAgICAgICAgcmVjdHMgICAgICA9IGF3YWl0IG1lLmdldERvbVJlY3QoW21lLmlkLCBtZWFzdXJlV3JhcHBlci5pZCwgLi4ubWVhc3VyZUVsZW1lbnQuY24ubWFwKG5vZGUgPT4gbm9kZS5pZCldKTtcbiAgICAgICAgaWYgKG1lLmlzRGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIHJvb3RSZWN0ICAgPSByZWN0cy5zaGlmdCgpO1xuICAgICAgICBwYXJlbnRSZWN0ID0gcmVjdHMuc2hpZnQoKTtcblxuICAgICAgICAvLyBTZWxmLUNvcnJlY3Rpb246IElmIHRoZSByZWFsIERPTSBzaXplIGRpZmZlcnMgZnJvbSBvdXIgZXhwZWN0ZWQgc2l6ZSwgd2UgdXBkYXRlIGFuZCByZXRyeS5cbiAgICAgICAgLy8gV2UgYWxsb3cgYSBzbWFsbCB0b2xlcmFuY2UgKDJweCkgZm9yIHN1Yi1waXhlbCByZW5kZXJpbmcgZGlmZmVyZW5jZXMuXG4gICAgICAgIC8vIFdlIGFsc28gY2hlY2sgZm9yID4gMCB0byBhdm9pZCB6ZXJvaW5nIG91dCBkaW1lbnNpb25zIGlmIHRoZSBjb21wb25lbnQgaXMgdGVtcG9yYXJpbHkgaGlkZGVuLlxuICAgICAgICBpZiAocm9vdFJlY3Qud2lkdGggPiAwICYmIChNYXRoLmFicyhyb290UmVjdC53aWR0aCAtIG1lLmNvbnRlbnRXaWR0aCkgPiAyIHx8IE1hdGguYWJzKHJvb3RSZWN0LmhlaWdodCAtIG1lLmNvbnRlbnRIZWlnaHQpID4gMikpIHtcbiAgICAgICAgICAgIG1lLmNvbnRlbnRXaWR0aCAgPSByb290UmVjdC53aWR0aDtcbiAgICAgICAgICAgIG1lLmNvbnRlbnRIZWlnaHQgPSByb290UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiBtZS5tZWFzdXJlQ2hhcnMoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmFjZSBjb25kaXRpb24gZ3VhcmQ6IElmIHRleHQgY2hhbmdlZCB3aGlsZSB3ZSB3ZXJlIG1lYXN1cmluZywgbWUuY2hhcnMgbWlnaHQgYmUgb3V0IG9mIHN5bmMuXG4gICAgICAgIGlmIChyZWN0cy5sZW5ndGggIT09IG1lLmNoYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICByZWN0cy5mb3JFYWNoKChyZWN0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbWUuY2hhcnNbaW5kZXhdLmxlZnQgPSBgJHtyZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnR9cHhgO1xuICAgICAgICAgICAgbWUuY2hhcnNbaW5kZXhdLnRvcCAgPSBgJHtyZWN0LnRvcCAgLSBwYXJlbnRSZWN0LnRvcCB9cHhgO1xuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzaXplIGV2ZW50IGhhbmRsZXIuIEl0IHVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGRpbWVuc2lvbnMsIGludmFsaWRhdGVzIHRoZVxuICAgICAqIG1lYXN1cmVtZW50IGNhY2hlLCBhbmQgdHJpZ2dlcnMgYSByZW1lYXN1cmVtZW50IGFuZCBWRE9NIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgIFRoZSBldmVudCBkYXRhIGZyb20gdGhlIHJlc2l6ZSBvYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWN0IFRoZSBuZXcgYm91bmRpbmcgcmVjdGFuZ2xlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIG9uUmVzaXplKHtyZWN0fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNvbnRlbnRIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgbWUuY29udGVudFdpZHRoICA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgaWYgKCFtZS5pbml0aWFsUmVzaXplRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghbWUuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUubWVhc3VyZUNoYXJzKCk7XG5cbiAgICAgICAgICAgICAgICBtZS5jaGFyc1Zkb20gPSBtZS5jcmVhdGVDaGFyc1Zkb20obWUuY2hhcnMubWFwKGNoYXIgPT4gY2hhci5uYW1lKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmluaXRpYWxSZXNpemVFdmVudCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBzd2l0Y2hpbmcgYnJvd3NlciB0YWJzIG9yIG1pbmltaXppbmcgdGhlIGJyb3dzZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuaGlkZGVuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBkYXRhLnZpc2liaWxpdHlTdGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIG9uVmlzaWJpbGl0eUNoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmF1dG9DeWNsZSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgbWUuc3RhcnRBdXRvQ3ljbGUoZmFsc2UpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmlzUmV0cnlpbmcgICAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtZS5wcmV2aW91c0NoYXJzID0gW107XG5cbiAgICAgICAgICAgICAgICBtZS5zdGFydEF1dG9DeWNsZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNvcnQgY29tcGFyYXRvciBmdW5jdGlvbiB1c2VkIHRvIG9yZGVyIGNoYXJhY3RlciBWRE9NIG5vZGVzIGJhc2VkIG9uIHRoZWlyXG4gICAgICogYHRvcGAgYW5kIGBsZWZ0YCBzdHlsZSBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgYSBjb25zaXN0ZW50IERPTSBvcmRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgZmlyc3QgVkRPTSBub2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBzZWNvbmQgVkRPTSBub2RlLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNvcnRDaGFyYWN0ZXJzKGEsIGIpIHtcbiAgICAgICAgbGV0IGRlbHRhVG9wID0gcGFyc2VGbG9hdChhLnN0eWxlLnRvcCkgLSBwYXJzZUZsb2F0KGIuc3R5bGUudG9wKTtcblxuICAgICAgICBpZiAoZGVsdGFUb3AgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YVRvcFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYS5zdHlsZS5sZWZ0KSAtIHBhcnNlRmxvYXQoYi5zdHlsZS5sZWZ0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBvciBzdG9wcyB0aGUgYHNldEludGVydmFsYCBmb3IgYXV0b21hdGljIHRleHQgY3ljbGluZy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXJ0PXRydWUgVHJ1ZSB0byBzdGFydCB0aGUgdGltZXIsIGZhbHNlIHRvIHN0b3AgaXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXJ0QXV0b0N5Y2xlKHN0YXJ0PXRydWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIG1lLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChtZS5jeWNsZVRleHQuYmluZChtZSksIG1lLmF1dG9DeWNsZUludGVydmFsKTtcblxuICAgICAgICAgICAgbWUudGltZW91dCgyMCkudGhlbigoKSA9PiB7bWUuY3ljbGVUZXh0KCl9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChtZS5pbnRlcnZhbElkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZCBhbmQgbW9zdCBjb21wbGV4IHBoYXNlIG9mIHRoZSBhbmltYXRpb246IHVwZGF0aW5nIHRoZSBWRE9NIHRvIHRyaWdnZXIgQ1NTIHRyYW5zaXRpb25zLlxuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIGNvcmUgXCJtYWdpYyBtb3ZlXCIgbG9naWMgYnkgZGV0ZXJtaW5pbmcgdGhlIGRlbHRhIGJldHdlZW4gdGhlIG9sZFxuICAgICAqIGFuZCBuZXcgdGV4dCBzdGF0ZXMgYW5kIGFwcGx5aW5nIHN0eWxlcyBhY2NvcmRpbmdseS5cbiAgICAgKlxuICAgICAqIFRoZSBhbGdvcml0aG0gaXMgYXMgZm9sbG93czpcbiAgICAgKiAxLiBJdGVyYXRlIHRocm91Z2ggdGhlIGBwcmV2aW91c0NoYXJzYC5cbiAgICAgKiAyLiBGb3IgZWFjaCBvbGQgY2hhcmFjdGVyLCBjaGVjayBpZiBpdCBleGlzdHMgaW4gdGhlIG5ldyB0ZXh0LlxuICAgICAqICAgIC0gSWYgWUVTOiBUaGlzIGNoYXJhY3RlciBuZWVkcyB0byAqKm1vdmUqKi4gQXBwbHkgdGhlIG5ldyBgbGVmdGAgYW5kIGB0b3BgIHN0eWxlcyB0byBpdHMgVkRPTSBub2RlLlxuICAgICAqICAgIC0gSWYgTk86IFRoaXMgY2hhcmFjdGVyIG5lZWRzIHRvICoqZmFkZSBvdXQqKi4gRmxhZyBpdCBmb3IgcmVtb3ZhbC5cbiAgICAgKiAzLiBDcmVhdGUgbmV3IFZET00gbm9kZXMgZm9yIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIHVuaXF1ZSB0byB0aGUgbmV3IHRleHQuIFRoZXNlIHdpbGwgKipmYWRlIGluKiouXG4gICAgICogNC4gQXBwbHkgc3R5bGVzIHRvIGFsbCBub2RlcyBzaW11bHRhbmVvdXNseSB0byB0cmlnZ2VyIHRoZSBDU1MgdHJhbnNpdGlvbnMgKG1vdmUsIGZhZGUtaW4sIGZhZGUtb3V0KS5cbiAgICAgKiA1LiBBZnRlciB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiwgY2xlYW4gdXAgdGhlIFZET00gYnkgcmVtb3ZpbmcgdGhlIGZhZGVkLW91dCBub2Rlcy5cbiAgICAgKiA2LiBGaW5hbGx5LCBmb3IgcGVyZm9ybWFuY2UsIGNvbGxhcHNlIGFsbCB0aGUgaW5kaXZpZHVhbCBjaGFyYWN0ZXIgYDxzcGFuPmAgbm9kZXMgYmFjayBpbnRvIGEgc2luZ2xlXG4gICAgICogICAgdGV4dCBub2RlIHVudGlsIHRoZSBuZXh0IGFuaW1hdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUNoYXJzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2hhcnMsIHByZXZpb3VzQ2hhcnN9ID0gbWUsXG4gICAgICAgICAgICBjaGFyc0NvbnRhaW5lciAgICAgICAgID0gbWUudmlzdWFsV3JhcHBlcixcbiAgICAgICAgICAgIGxldHRlcnMgICAgICAgICAgICAgICAgPSBjaGFycy5tYXAoY2hhciA9PiBjaGFyLm5hbWUpLFxuICAgICAgICAgICAgY2hhck5vZGUsIGluZGV4O1xuXG4gICAgICAgIG1lLmlzVHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKG1lLmNoYXJzVmRvbS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjaGFyc0NvbnRhaW5lci5jbiA9IG1lLmNoYXJzVmRvbTtcbiAgICAgICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZS5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNDaGFycy5mb3JFYWNoKChwcmV2aW91c0NoYXIsIHByZXZpb3VzSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGluZGV4ID0gbGV0dGVycy5pbmRleE9mKHByZXZpb3VzQ2hhci5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW3ByZXZpb3VzSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjaGFyTm9kZS5zdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogbWUuY29sb3JNb3ZlLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0IDogY2hhcnNbaW5kZXhdLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgOiBjaGFyc1tpbmRleF0udG9wXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsZXR0ZXJzW2luZGV4XSA9IG51bGxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUgPSBjaGFyc0NvbnRhaW5lci5jbltwcmV2aW91c0luZGV4XTtcblxuICAgICAgICAgICAgICAgIGNoYXJOb2RlLmZsYWcgPSAncmVtb3ZlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5wdXNoKC4uLm1lLmNyZWF0ZUNoYXJzVmRvbShsZXR0ZXJzKSk7XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBpZiAobWUuaXNEZXN0cm95ZWQpIHJldHVybjtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5mb3JFYWNoKGNoYXJOb2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFyTm9kZS5mbGFnID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlLnN0eWxlLmNvbG9yICAgPSBtZS5jb2xvckZhZGVPdXQ7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUuc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoYXJOb2RlLnN0eWxlLm9wYWNpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBpZiAobWUuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dChtZS50cmFuc2l0aW9uVGltZSk7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24uc29ydChtZS5zb3J0Q2hhcmFjdGVycyk7XG5cbiAgICAgICAgaW5kZXggPSBjaGFyc0NvbnRhaW5lci5jbi5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAoOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW2luZGV4XTtcblxuICAgICAgICAgICAgZGVsZXRlIGNoYXJOb2RlLmZsYWc7XG4gICAgICAgICAgICBkZWxldGUgY2hhck5vZGUuc3R5bGUuY29sb3I7XG5cbiAgICAgICAgICAgIGlmIChjaGFyTm9kZS5zdHlsZS5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNDb250YWluZXIuY24uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBpZiAobWUuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMDApO1xuXG4gICAgICAgIG1lLmNoYXJzVmRvbSA9IFsuLi5jaGFyc0NvbnRhaW5lci5jbl07XG5cbiAgICAgICAgbWUuaXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1hZ2ljTW92ZVRleHQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9