"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_MagicMoveText_mjs"],{

/***/ "./src/component/MagicMoveText.mjs":
/*!*****************************************!*\
  !*** ./src/component/MagicMoveText.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @summary Animates text transitions by calculating character positions and applying CSS transforms.
 *
 * This component creates a "Magic Move" style effect, where changing from one string of text to another results
 * in a smooth animation. Characters that are common between the two strings appear to move to their new positions,
 * while old characters fade out and new characters fade in.
 *
 * This effect is achieved using a two-phase process that leverages Neo.mjs's VDOM and rendering pipeline:
 * 1.  **Measurement Phase (`measureChars`):** When the text changes, the component first needs to know the exact
 *     final position of every character. It does this by briefly rendering all characters into a hidden
 *     `measure-element` div, getting their `DOMRect` values, and caching the results. This is a critical
 *     performance optimization that avoids layout thrashing.
 * 2.  **Animation Phase (`updateChars`):** With the character positions known, the component calculates the delta
 *     between the old and new text. It then manipulates the VDOM by applying CSS classes and styles to
 *     individual character `<span>` elements to trigger CSS transitions for movement and opacity.
 *
 * This component is a prime example of using the framework for complex, declarative, and performant animations.
 * It is useful for grabbing user attention on landing pages or for creating dynamic, keynote-style presentations.
 *
 * Relevant concepts: `text animation`, `character transition`, `magic move`, `declarative animation`, `CSS transitions`.
 *
 * Deeply inspired by https://github.com/yangshun 's video on LinkedIn
 * as well as Apple's Keynote Magic Move effect.
 * @class Neo.component.MagicMoveText
 * @extends Neo.component.Base
 */
class MagicMoveText extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.MagicMoveText'
         * @protected
         */
        className: 'Neo.component.MagicMoveText',
        /**
         * @member {String} ntype='magic-move-text'
         * @protected
         */
        ntype: 'magic-move-text',
        /**
         * Set to true to automatically cycle through the `cycleTexts` array.
         * @member {Boolean} autoCycle_=true
         * @reactive
         */
        autoCycle_: true,
        /**
         * The time in milliseconds between each automatic text transition.
         * @member {Number} autoCycleInterval_=2000
         * @reactive
         */
        autoCycleInterval_: 2000,
        /**
         * @member {String[]} baseCls=['neo-magic-move-text']
         * @protected
         */
        baseCls: ['neo-magic-move-text'],
        /**
         * The color applied to characters that are moving to a new position.
         * @member {String|null} colorMove=null
         */
        colorMove: null,
        /**
         * The color applied to new characters as they fade in.
         * @member {String|null} colorFadeIn=null
         */
        colorFadeIn: null,
        /**
         * The color applied to old characters as they fade out.
         * @member {String|null} colorFadeOut=null
         */
        colorFadeOut: null,
        /**
         * An array of strings to automatically cycle through if `autoCycle` is true.
         * @member {String[]|null} cycleTexts=null
         */
        cycleTexts: null,
        /**
         * The font-family for the text. Changing this will trigger a cache invalidation and remeasurement.
         * @member {String} fontFamily_='Helvetica Neue'
         * @reactive
         */
        fontFamily_: 'Helvetica Neue',
        /**
         * The duration in milliseconds for the fade-in, fade-out, and move animations.
         * This value is applied to the `--neo-transition-time` CSS variable.
         * @member {Number} transitionTime_=500
         * @reactive
         */
        transitionTime_: 500,
        /**
         * The VDOM structure for the component, including a content area and a hidden measurement element.
         * @member {Object} _vdom
         * @protected
         */
        _vdom:
        {style: {}, cn: [
            {cls: ['neo-content'], cn: []},
            {cls: ['neo-measure-element-wrapper'], removeDom: true, cn: [
                {cls: ['neo-measure-element'], cn:[]}
            ]}
        ]}
    }

    /**
     * An array of objects, where each object represents a character in the current `text`.
     * Each object contains the character's `name` (the character itself) and its calculated
     * `left` and `top` positions relative to the container.
     * @member {Object[]} chars=[]
     * @protected
     */
    chars = []
    /**
     * A cached representation of the VDOM for the currently displayed characters.
     * This is used to persist the character state during resize events, preventing
     * the need for a full recalculation.
     * @member {Object[]} charsVdom=[]
     * @protected
     */
    charsVdom = []
    /**
     * The height of the component's content area, determined on mount and resize.
     * Used to size the measurement wrapper.
     * @member {Number} contentHeight=0
     * @protected
     */
    contentHeight = 0
    /**
     * The width of the component's content area, determined on mount and resize.
     * Used to size the measurement wrapper.
     * @member {Number} contentWidth=0
     * @protected
     */
    contentWidth = 0
    /**
     * The index of the string currently displayed from the `cycleTexts` array.
     * @member {Number} currentIndex=0
     * @protected
     */
    currentIndex = 0
    /**
     * A flag to ignore the very first resize event that fires immediately after mounting,
     * as the initial measurement is handled by `afterSetMounted`.
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * The ID for the `setInterval` used for `autoCycle`. Stored so it can be cleared.
     * @member {Number|null} intervalId=null
     * @protected
     */
    intervalId = null
    /**
     * Internal flag to prevent infinite retry loops in case of errors during the animation.
     * @member {Boolean} isRetrying=false
     * @protected
     */
    isRetrying = false
    /**
     * A flag to indicate that the component is currently in the middle of an animation.
     * This is used to prevent concurrent, overlapping updates (e.g., from a resize event).
     * @member {Boolean} isTransitioning=false
     * @protected
     */
    isTransitioning = false
    /**
     * A performance-critical cache. Maps a text string to an array of `DOMRect` objects
     * for each of its characters. This avoids costly DOM measurements if the same text is
     * displayed again. It is invalidated when the component resizes or its font changes.
     * @member {Object} measureCache={}
     * @protected
     */
    measureCache = {}
    /**
     * Stores the `chars` array from the *previous* text state. This is essential for calculating
     * the transition, as it's compared against the new `chars` array to determine which characters
     * need to move, fade in, or fade out.
     * @member {Object[]} previousChars=[]
     * @protected
     */
    previousChars = []
    /**
     * A getter for the VDOM node used to measure character positions.
     * @member {Object} measureElement
     * @protected
     */
    get measureElement() {
        return this.measureWrapper.cn[0]
    }
    /**
     * A getter for the wrapper of the measurement VDOM node. This wrapper is temporarily
     * added to the DOM to perform measurements.
     * @member {Object} measureWrapper
     * @protected
     */
    get measureWrapper() {
        return this.vdom.cn[1]
    }

    /**
     * The constructor registers a resize listener to invalidate the measurement cache when the component size changes.
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        });

        me.app?.on('visibilitychange', me.onVisibilityChange, me)
    }

    /**
     * Registers or unregisters this component with the global ResizeObserver addon.
     * This is more efficient than having a separate observer for each component instance.
     * @param {Boolean} mounted True to register, false to unregister.
     * @protected
     */
    async addResizeObserver(mounted) {
        let {id, windowId} = this,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId);

        ResizeObserver[mounted ? 'register' : 'unregister']({id, windowId});

        if (mounted) {
            this.initialResizeEvent = true
        }
    }

    /**
     * Starts or stops the automatic text cycling when the `autoCycle` config changes.
     * @param {Boolean} value    The new value of `autoCycle`.
     * @param {Boolean} oldValue The old value of `autoCycle`.
     * @protected
     */
    afterSetAutoCycle(value, oldValue) {
        this.mounted && this.startAutoCycle(value)
    }

    /**
     * Restarts the automatic text cycling with the new interval when the `autoCycleInterval` config changes.
     * @param {Number} value    The new value of `autoCycleInterval`.
     * @param {Number} oldValue The old value of `autoCycleInterval`.
     * @protected
     */
    afterSetAutoCycleInterval(value, oldValue) {
        let me = this;

        if (oldValue && me.mounted) {
            me.startAutoCycle(false);
            me.startAutoCycle()
        }
    }

    /**
     * Invalidates the measurement cache and updates the VDOM when the `fontFamily` config changes,
     * as a new font will change all character dimensions.
     * @param {String} value    The new value of `fontFamily`.
     * @param {String} oldValue The old value of `fontFamily`.
     * @protected
     */
    afterSetFontFamily(value, oldValue) {
        let me = this;

        me.measureCache = {};

        me.vdom.style.fontFamily = value;
        me.update()
    }

    /**
     * Handles the component's mounted state changes. When mounted, it determines the component's
     * dimensions. When unmounted, it clears the measurement cache and character state.
     * @param {Boolean} value    The new value of `mounted`.
     * @param {Boolean} oldValue The old value of `mounted`.
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value) {
            me.getDomRect().then(rect => {
                me.contentHeight = rect.height;
                me.contentWidth  = rect.width;
            })
        } else {
            me.measureCache  = {};
            me.previousChars = []
        }

        if (oldValue !== undefined) {
            me.addResizeObserver(value);

            me.autoCycle && me.startAutoCycle(value)
        }
    }

    /**
     * This is the main entry point for the animation when the `text` config is changed.
     * It orchestrates the measurement and animation phases. It also contains a `try/catch`
     * block to handle potential errors during the complex animation logic, with a single-retry
     * mechanism to recover from transient states by clearing the cache and re-running the process.
     * @param {String} value    The new text value.
     * @param {String} oldValue The old text value.
     * @returns {Promise<void>}
     * @protected
     */
    async afterSetText(value, oldValue) {
        let me               = this,
            {measureElement} = me;

        if (oldValue) {
            me.previousChars = me.chars
        }

        if (value) {
            try {
                me.chars = [];
                measureElement.cn = [];

                value?.split('').forEach(char => {
                    me.chars.push({name: char});
                    measureElement.cn.push({tag: 'span', text: char})
                });

                if (me.mounted) {
                    await me.measureChars()
                }

                await me.updateChars()
            } catch (e) {
                if (!me.isRetrying) {
                    me.isRetrying    = true;
                    me.measureCache  = {};
                    me.previousChars = [];

                    // Reset a transitioning state
                    me.vdom.cn[0].cn.length = 0;

                    await me.afterSetText(value, oldValue)
                }
            }

            me.isRetrying = false
        }
    }

    /**
     * Applies the transition time to a CSS variable, allowing the animations to be controlled via JavaScript.
     * @param {Number} value    The new value of `transitionTime`.
     * @param {Number} oldValue The old value of `transitionTime`.
     * @protected
     */
    afterSetTransitionTime(value, oldValue) {
        this.vdom.style['--neo-transition-time'] = value + 'ms';
        this.update()
    }

    /**
     * Creates the VDOM for new characters that are fading in. It filters out characters
     * that are already present (and will be moved instead).
     * @param {String[]} letters An array representing the new text, with `null` for characters that already existed.
     * @returns {Object[]} An array of VDOM nodes for the new characters.
     * @protected
     */
    createCharsVdom(letters) {
        let me             = this,
            {chars}        = me,
            charsContainer = [],
            char;

        letters.forEach((letter, index) => {
            if (letter !== null) {
                char = chars[index];

                charsContainer.push({
                    cls  : ['neo-char'],
                    style: {color: me.colorFadeIn, left: char.left, opacity: 0, top: char.top},
                    text : char.name
                })
            }
        });

        return charsContainer
    }

    /**
     * Advances the text to the next string in the `cycleTexts` array.
     * @protected
     */
    cycleText() {
        let me = this;

        me.text         = me.cycleTexts[me.currentIndex];
        me.currentIndex = (me.currentIndex + 1) % me.cycleTexts.length
    }

    /**
     * The first phase of the animation: calculating character positions.
     * If the positions for the current text are not in the cache, this method temporarily
     * renders the characters into a hidden div, measures their bounding rectangles,
     * stores the results in the cache, and then removes the measurement elements from the DOM.
     * @returns {Promise<void>}
     * @protected
     */
    async measureChars() {
        let me = this,
            {measureCache, measureElement, measureWrapper, text} = me,
            parentRect, rects;

        if (measureCache[text]) {
            rects      = [...measureCache[text]];
            parentRect = rects.shift()
        } else {
            measureWrapper.style = {
                height: me.contentHeight + 'px',
                width : me.contentWidth  + 'px'
            };

            delete measureWrapper.removeDom;

            await me.promiseUpdate();
            await me.timeout(20);

            rects      = await me.getDomRect([measureWrapper.id, ...measureElement.cn.map(node => node.id)]);
            parentRect = rects.shift();

            measureCache[text] = [parentRect, ...rects]
        }

        rects.forEach((rect, index) => {
            me.chars[index].left = `${rect.left - parentRect.left}px`;
            me.chars[index].top  = `${rect.top  - parentRect.top }px`;
        });

        await me.promiseUpdate()
    }

    /**
     * The resize event handler. It updates the component's dimensions, invalidates the
     * measurement cache, and triggers a remeasurement and VDOM update.
     * @param {Object} data      The event data from the resize observer.
     * @param {Object} data.rect The new bounding rectangle of the component.
     * @returns {Promise<void>}
     * @protected
     */
    async onResize({rect}) {
        let me = this;

        me.contentHeight = rect.height;
        me.contentWidth  = rect.width;

        me.measureCache = {};

        if (!me.initialResizeEvent) {
            if (!me.isTransitioning) {
                await me.measureChars();

                me.charsVdom = me.createCharsVdom(me.chars.map(char => char.name))
            }
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * Triggered when switching browser tabs or minimizing the browser
     * @param {Object}  data
     * @param {Boolean} data.hidden
     * @param {String}  data.visibilityState
     * @param {Number}  data.windowId
     */
    onVisibilityChange(data) {
        let me = this;

        if (me.autoCycle) {
            if (data.hidden) {
                me.startAutoCycle(false)
            } else {
                me.isRetrying    = false;
                me.measureCache  = {};
                me.previousChars = [];

                me.startAutoCycle()
            }
        }
    }

    /**
     * A sort comparator function used to order character VDOM nodes based on their
     * `top` and `left` style properties. This ensures a consistent DOM order.
     * @param {Object} a The first VDOM node.
     * @param {Object} b The second VDOM node.
     * @returns {Number}
     * @protected
     */
    sortCharacters(a, b) {
        let deltaTop = parseFloat(a.style.top) - parseFloat(b.style.top);

        if (deltaTop !== 0) {
            return deltaTop
        }

        return parseFloat(a.style.left) - parseFloat(b.style.left)
    }

    /**
     * Starts or stops the `setInterval` for automatic text cycling.
     * @param {Boolean} start=true True to start the timer, false to stop it.
     * @protected
     */
    startAutoCycle(start=true) {
        let me = this;

        if (start) {
            me.intervalId = setInterval(me.cycleText.bind(me), me.autoCycleInterval);

            me.timeout(20).then(() => {me.cycleText()})
        } else {
            clearInterval(me.intervalId)
        }
    }

    /**
     * The second and most complex phase of the animation: updating the VDOM to trigger CSS transitions.
     * This method implements the core "magic move" logic by determining the delta between the old
     * and new text states and applying styles accordingly.
     *
     * The algorithm is as follows:
     * 1. Iterate through the `previousChars`.
     * 2. For each old character, check if it exists in the new text.
     *    - If YES: This character needs to **move**. Apply the new `left` and `top` styles to its VDOM node.
     *    - If NO: This character needs to **fade out**. Flag it for removal.
     * 3. Create new VDOM nodes for all characters that are unique to the new text. These will **fade in**.
     * 4. Apply styles to all nodes simultaneously to trigger the CSS transitions (move, fade-in, fade-out).
     * 5. After the transition duration, clean up the VDOM by removing the faded-out nodes.
     * 6. Finally, for performance, collapse all the individual character `<span>` nodes back into a single
     *    text node until the next animation is triggered.
     * @returns {Promise<void>}
     * @protected
     */
    async updateChars() {
        let me                     = this,
            {chars, previousChars} = me,
            charsContainer         = me.vdom.cn[0],
            letters                = chars.map(char => char.name),
            charNode, index;

        me.isTransitioning = true;

        if (me.charsVdom.length > 1) {
            charsContainer.cn = me.charsVdom;
            await me.promiseUpdate()
        }

        previousChars.forEach((previousChar, previousIndex) => {
            index = letters.indexOf(previousChar.name);

            if (index > -1) {
                charNode = charsContainer.cn[previousIndex];

                Object.assign(charNode.style, {
                    color: me.colorMove,
                    left : chars[index].left,
                    top  : chars[index].top
                });

                letters[index] = null
            } else {
                charNode = charsContainer.cn[previousIndex];

                charNode.flag = 'remove'
            }
        });

        charsContainer.cn.push(...me.createCharsVdom(letters));

        await me.promiseUpdate();

        charsContainer.cn.forEach(charNode => {
            if (charNode.flag === 'remove') {
                charNode.style.color   = me.colorFadeOut;
                charNode.style.opacity = 0
            } else {
                delete charNode.style.opacity
            }
        });

        await me.promiseUpdate();
        await me.timeout(me.transitionTime);

        charsContainer.cn.sort(me.sortCharacters);

        index = charsContainer.cn.length - 1;

        for (; index >= 0; index--) {
            charNode = charsContainer.cn[index];

            delete charNode.flag;
            delete charNode.style.color;

            if (charNode.style.opacity === 0) {
                charsContainer.cn.splice(index, 1)
            }
        }

        await me.promiseUpdate();
        await me.timeout(200);

        me.charsVdom = [...charsContainer.cn];

        charsContainer.cn.length = 0;

        charsContainer.cn.push({text: me.text});
        await me.promiseUpdate();

        me.isTransitioning = false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MagicMoveText));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfTWFnaWNNb3ZlVGV4dF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQVM7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEIsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUEsNkRBQTZELGFBQWE7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDLDRDQUE0Qyx3QkFBd0I7QUFDcEUsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0U7QUFDOUY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBb0Q7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRSxzQ0FBc0MsNEJBQTRCO0FBQ2xFLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLGVBQWU7QUFDdEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsWUFBWTtBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLGNBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTWFnaWNNb3ZlVGV4dC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEFuaW1hdGVzIHRleHQgdHJhbnNpdGlvbnMgYnkgY2FsY3VsYXRpbmcgY2hhcmFjdGVyIHBvc2l0aW9ucyBhbmQgYXBwbHlpbmcgQ1NTIHRyYW5zZm9ybXMuXG4gKlxuICogVGhpcyBjb21wb25lbnQgY3JlYXRlcyBhIFwiTWFnaWMgTW92ZVwiIHN0eWxlIGVmZmVjdCwgd2hlcmUgY2hhbmdpbmcgZnJvbSBvbmUgc3RyaW5nIG9mIHRleHQgdG8gYW5vdGhlciByZXN1bHRzXG4gKiBpbiBhIHNtb290aCBhbmltYXRpb24uIENoYXJhY3RlcnMgdGhhdCBhcmUgY29tbW9uIGJldHdlZW4gdGhlIHR3byBzdHJpbmdzIGFwcGVhciB0byBtb3ZlIHRvIHRoZWlyIG5ldyBwb3NpdGlvbnMsXG4gKiB3aGlsZSBvbGQgY2hhcmFjdGVycyBmYWRlIG91dCBhbmQgbmV3IGNoYXJhY3RlcnMgZmFkZSBpbi5cbiAqXG4gKiBUaGlzIGVmZmVjdCBpcyBhY2hpZXZlZCB1c2luZyBhIHR3by1waGFzZSBwcm9jZXNzIHRoYXQgbGV2ZXJhZ2VzIE5lby5tanMncyBWRE9NIGFuZCByZW5kZXJpbmcgcGlwZWxpbmU6XG4gKiAxLiAgKipNZWFzdXJlbWVudCBQaGFzZSAoYG1lYXN1cmVDaGFyc2ApOioqIFdoZW4gdGhlIHRleHQgY2hhbmdlcywgdGhlIGNvbXBvbmVudCBmaXJzdCBuZWVkcyB0byBrbm93IHRoZSBleGFjdFxuICogICAgIGZpbmFsIHBvc2l0aW9uIG9mIGV2ZXJ5IGNoYXJhY3Rlci4gSXQgZG9lcyB0aGlzIGJ5IGJyaWVmbHkgcmVuZGVyaW5nIGFsbCBjaGFyYWN0ZXJzIGludG8gYSBoaWRkZW5cbiAqICAgICBgbWVhc3VyZS1lbGVtZW50YCBkaXYsIGdldHRpbmcgdGhlaXIgYERPTVJlY3RgIHZhbHVlcywgYW5kIGNhY2hpbmcgdGhlIHJlc3VsdHMuIFRoaXMgaXMgYSBjcml0aWNhbFxuICogICAgIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0aGF0IGF2b2lkcyBsYXlvdXQgdGhyYXNoaW5nLlxuICogMi4gICoqQW5pbWF0aW9uIFBoYXNlIChgdXBkYXRlQ2hhcnNgKToqKiBXaXRoIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb25zIGtub3duLCB0aGUgY29tcG9uZW50IGNhbGN1bGF0ZXMgdGhlIGRlbHRhXG4gKiAgICAgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcgdGV4dC4gSXQgdGhlbiBtYW5pcHVsYXRlcyB0aGUgVkRPTSBieSBhcHBseWluZyBDU1MgY2xhc3NlcyBhbmQgc3R5bGVzIHRvXG4gKiAgICAgaW5kaXZpZHVhbCBjaGFyYWN0ZXIgYDxzcGFuPmAgZWxlbWVudHMgdG8gdHJpZ2dlciBDU1MgdHJhbnNpdGlvbnMgZm9yIG1vdmVtZW50IGFuZCBvcGFjaXR5LlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIGEgcHJpbWUgZXhhbXBsZSBvZiB1c2luZyB0aGUgZnJhbWV3b3JrIGZvciBjb21wbGV4LCBkZWNsYXJhdGl2ZSwgYW5kIHBlcmZvcm1hbnQgYW5pbWF0aW9ucy5cbiAqIEl0IGlzIHVzZWZ1bCBmb3IgZ3JhYmJpbmcgdXNlciBhdHRlbnRpb24gb24gbGFuZGluZyBwYWdlcyBvciBmb3IgY3JlYXRpbmcgZHluYW1pYywga2V5bm90ZS1zdHlsZSBwcmVzZW50YXRpb25zLlxuICpcbiAqIFJlbGV2YW50IGNvbmNlcHRzOiBgdGV4dCBhbmltYXRpb25gLCBgY2hhcmFjdGVyIHRyYW5zaXRpb25gLCBgbWFnaWMgbW92ZWAsIGBkZWNsYXJhdGl2ZSBhbmltYXRpb25gLCBgQ1NTIHRyYW5zaXRpb25zYC5cbiAqXG4gKiBEZWVwbHkgaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL3lhbmdzaHVuICdzIHZpZGVvIG9uIExpbmtlZEluXG4gKiBhcyB3ZWxsIGFzIEFwcGxlJ3MgS2V5bm90ZSBNYWdpYyBNb3ZlIGVmZmVjdC5cbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50Lk1hZ2ljTW92ZVRleHRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBNYWdpY01vdmVUZXh0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuTWFnaWNNb3ZlVGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5NYWdpY01vdmVUZXh0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21hZ2ljLW1vdmUtdGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdtYWdpYy1tb3ZlLXRleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSBjeWNsZSB0aHJvdWdoIHRoZSBgY3ljbGVUZXh0c2AgYXJyYXkuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9DeWNsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9DeWNsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiBlYWNoIGF1dG9tYXRpYyB0ZXh0IHRyYW5zaXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXV0b0N5Y2xlSW50ZXJ2YWxfPTIwMDBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvQ3ljbGVJbnRlcnZhbF86IDIwMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1tYWdpYy1tb3ZlLXRleHQnXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1tYWdpYy1tb3ZlLXRleHQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xvciBhcHBsaWVkIHRvIGNoYXJhY3RlcnMgdGhhdCBhcmUgbW92aW5nIHRvIGEgbmV3IHBvc2l0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29sb3JNb3ZlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yTW92ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xvciBhcHBsaWVkIHRvIG5ldyBjaGFyYWN0ZXJzIGFzIHRoZXkgZmFkZSBpbi5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbG9yRmFkZUluPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmFkZUluOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbG9yIGFwcGxpZWQgdG8gb2xkIGNoYXJhY3RlcnMgYXMgdGhleSBmYWRlIG91dC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbG9yRmFkZU91dD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZhZGVPdXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBzdHJpbmdzIHRvIGF1dG9tYXRpY2FsbHkgY3ljbGUgdGhyb3VnaCBpZiBgYXV0b0N5Y2xlYCBpcyB0cnVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxudWxsfSBjeWNsZVRleHRzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGN5Y2xlVGV4dHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9udC1mYW1pbHkgZm9yIHRoZSB0ZXh0LiBDaGFuZ2luZyB0aGlzIHdpbGwgdHJpZ2dlciBhIGNhY2hlIGludmFsaWRhdGlvbiBhbmQgcmVtZWFzdXJlbWVudC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmb250RmFtaWx5Xz0nSGVsdmV0aWNhIE5ldWUnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9udEZhbWlseV86ICdIZWx2ZXRpY2EgTmV1ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgZmFkZS1pbiwgZmFkZS1vdXQsIGFuZCBtb3ZlIGFuaW1hdGlvbnMuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgYXBwbGllZCB0byB0aGUgYC0tbmVvLXRyYW5zaXRpb24tdGltZWAgQ1NTIHZhcmlhYmxlLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRyYW5zaXRpb25UaW1lXz01MDBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uVGltZV86IDUwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBWRE9NIHN0cnVjdHVyZSBmb3IgdGhlIGNvbXBvbmVudCwgaW5jbHVkaW5nIGEgY29udGVudCBhcmVhIGFuZCBhIGhpZGRlbiBtZWFzdXJlbWVudCBlbGVtZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7c3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tY29udGVudCddLCBjbjogW119LFxuICAgICAgICAgICAge2NsczogWyduZW8tbWVhc3VyZS1lbGVtZW50LXdyYXBwZXInXSwgcmVtb3ZlRG9tOiB0cnVlLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1lYXN1cmUtZWxlbWVudCddLCBjbjpbXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2Ygb2JqZWN0cywgd2hlcmUgZWFjaCBvYmplY3QgcmVwcmVzZW50cyBhIGNoYXJhY3RlciBpbiB0aGUgY3VycmVudCBgdGV4dGAuXG4gICAgICogRWFjaCBvYmplY3QgY29udGFpbnMgdGhlIGNoYXJhY3RlcidzIGBuYW1lYCAodGhlIGNoYXJhY3RlciBpdHNlbGYpIGFuZCBpdHMgY2FsY3VsYXRlZFxuICAgICAqIGBsZWZ0YCBhbmQgYHRvcGAgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIuXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IGNoYXJzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYXJzID0gW11cbiAgICAvKipcbiAgICAgKiBBIGNhY2hlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVkRPTSBmb3IgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgY2hhcmFjdGVycy5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gcGVyc2lzdCB0aGUgY2hhcmFjdGVyIHN0YXRlIGR1cmluZyByZXNpemUgZXZlbnRzLCBwcmV2ZW50aW5nXG4gICAgICogdGhlIG5lZWQgZm9yIGEgZnVsbCByZWNhbGN1bGF0aW9uLlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBjaGFyc1Zkb209W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2hhcnNWZG9tID0gW11cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQncyBjb250ZW50IGFyZWEsIGRldGVybWluZWQgb24gbW91bnQgYW5kIHJlc2l6ZS5cbiAgICAgKiBVc2VkIHRvIHNpemUgdGhlIG1lYXN1cmVtZW50IHdyYXBwZXIuXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBjb250ZW50SGVpZ2h0PTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29udGVudEhlaWdodCA9IDBcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNvbXBvbmVudCdzIGNvbnRlbnQgYXJlYSwgZGV0ZXJtaW5lZCBvbiBtb3VudCBhbmQgcmVzaXplLlxuICAgICAqIFVzZWQgdG8gc2l6ZSB0aGUgbWVhc3VyZW1lbnQgd3JhcHBlci5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbnRlbnRXaWR0aD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnRlbnRXaWR0aCA9IDBcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHN0cmluZyBjdXJyZW50bHkgZGlzcGxheWVkIGZyb20gdGhlIGBjeWNsZVRleHRzYCBhcnJheS5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbmRleD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGN1cnJlbnRJbmRleCA9IDBcbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gaWdub3JlIHRoZSB2ZXJ5IGZpcnN0IHJlc2l6ZSBldmVudCB0aGF0IGZpcmVzIGltbWVkaWF0ZWx5IGFmdGVyIG1vdW50aW5nLFxuICAgICAqIGFzIHRoZSBpbml0aWFsIG1lYXN1cmVtZW50IGlzIGhhbmRsZWQgYnkgYGFmdGVyU2V0TW91bnRlZGAuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaW5pdGlhbFJlc2l6ZUV2ZW50PXRydWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdGlhbFJlc2l6ZUV2ZW50ID0gdHJ1ZVxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBmb3IgdGhlIGBzZXRJbnRlcnZhbGAgdXNlZCBmb3IgYGF1dG9DeWNsZWAuIFN0b3JlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZC5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gaW50ZXJ2YWxJZD1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGludGVydmFsSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZmxhZyB0byBwcmV2ZW50IGluZmluaXRlIHJldHJ5IGxvb3BzIGluIGNhc2Ugb2YgZXJyb3JzIGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzUmV0cnlpbmc9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNSZXRyeWluZyA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBjdXJyZW50bHkgaW4gdGhlIG1pZGRsZSBvZiBhbiBhbmltYXRpb24uXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgY29uY3VycmVudCwgb3ZlcmxhcHBpbmcgdXBkYXRlcyAoZS5nLiwgZnJvbSBhIHJlc2l6ZSBldmVudCkuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNUcmFuc2l0aW9uaW5nPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQSBwZXJmb3JtYW5jZS1jcml0aWNhbCBjYWNoZS4gTWFwcyBhIHRleHQgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGBET01SZWN0YCBvYmplY3RzXG4gICAgICogZm9yIGVhY2ggb2YgaXRzIGNoYXJhY3RlcnMuIFRoaXMgYXZvaWRzIGNvc3RseSBET00gbWVhc3VyZW1lbnRzIGlmIHRoZSBzYW1lIHRleHQgaXNcbiAgICAgKiBkaXNwbGF5ZWQgYWdhaW4uIEl0IGlzIGludmFsaWRhdGVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXNpemVzIG9yIGl0cyBmb250IGNoYW5nZXMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtZWFzdXJlQ2FjaGU9e31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbWVhc3VyZUNhY2hlID0ge31cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGBjaGFyc2AgYXJyYXkgZnJvbSB0aGUgKnByZXZpb3VzKiB0ZXh0IHN0YXRlLiBUaGlzIGlzIGVzc2VudGlhbCBmb3IgY2FsY3VsYXRpbmdcbiAgICAgKiB0aGUgdHJhbnNpdGlvbiwgYXMgaXQncyBjb21wYXJlZCBhZ2FpbnN0IHRoZSBuZXcgYGNoYXJzYCBhcnJheSB0byBkZXRlcm1pbmUgd2hpY2ggY2hhcmFjdGVyc1xuICAgICAqIG5lZWQgdG8gbW92ZSwgZmFkZSBpbiwgb3IgZmFkZSBvdXQuXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHByZXZpb3VzQ2hhcnM9W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJldmlvdXNDaGFycyA9IFtdXG4gICAgLyoqXG4gICAgICogQSBnZXR0ZXIgZm9yIHRoZSBWRE9NIG5vZGUgdXNlZCB0byBtZWFzdXJlIGNoYXJhY3RlciBwb3NpdGlvbnMuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtZWFzdXJlRWxlbWVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgbWVhc3VyZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lYXN1cmVXcmFwcGVyLmNuWzBdXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciB0aGUgd3JhcHBlciBvZiB0aGUgbWVhc3VyZW1lbnQgVkRPTSBub2RlLiBUaGlzIHdyYXBwZXIgaXMgdGVtcG9yYXJpbHlcbiAgICAgKiBhZGRlZCB0byB0aGUgRE9NIHRvIHBlcmZvcm0gbWVhc3VyZW1lbnRzLlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVhc3VyZVdyYXBwZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0IG1lYXN1cmVXcmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzFdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIHJlZ2lzdGVycyBhIHJlc2l6ZSBsaXN0ZW5lciB0byBpbnZhbGlkYXRlIHRoZSBtZWFzdXJlbWVudCBjYWNoZSB3aGVuIHRoZSBjb21wb25lbnQgc2l6ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIHJlc2l6ZTogbWUub25SZXNpemUsXG4gICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmFwcD8ub24oJ3Zpc2liaWxpdHljaGFuZ2UnLCBtZS5vblZpc2liaWxpdHlDaGFuZ2UsIG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBvciB1bnJlZ2lzdGVycyB0aGlzIGNvbXBvbmVudCB3aXRoIHRoZSBnbG9iYWwgUmVzaXplT2JzZXJ2ZXIgYWRkb24uXG4gICAgICogVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhhdmluZyBhIHNlcGFyYXRlIG9ic2VydmVyIGZvciBlYWNoIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1vdW50ZWQgVHJ1ZSB0byByZWdpc3RlciwgZmFsc2UgdG8gdW5yZWdpc3Rlci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWRkUmVzaXplT2JzZXJ2ZXIobW91bnRlZCkge1xuICAgICAgICBsZXQge2lkLCB3aW5kb3dJZH0gPSB0aGlzLFxuICAgICAgICAgICAgUmVzaXplT2JzZXJ2ZXIgPSBhd2FpdCBOZW8uY3VycmVudFdvcmtlci5nZXRBZGRvbignUmVzaXplT2JzZXJ2ZXInLCB3aW5kb3dJZCk7XG5cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJbbW91bnRlZCA/ICdyZWdpc3RlcicgOiAndW5yZWdpc3RlciddKHtpZCwgd2luZG93SWR9KTtcblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsUmVzaXplRXZlbnQgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgb3Igc3RvcHMgdGhlIGF1dG9tYXRpYyB0ZXh0IGN5Y2xpbmcgd2hlbiB0aGUgYGF1dG9DeWNsZWAgY29uZmlnIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIGBhdXRvQ3ljbGVgLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiBgYXV0b0N5Y2xlYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvQ3ljbGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLnN0YXJ0QXV0b0N5Y2xlKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RhcnRzIHRoZSBhdXRvbWF0aWMgdGV4dCBjeWNsaW5nIHdpdGggdGhlIG5ldyBpbnRlcnZhbCB3aGVuIHRoZSBgYXV0b0N5Y2xlSW50ZXJ2YWxgIGNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAgICBUaGUgbmV3IHZhbHVlIG9mIGBhdXRvQ3ljbGVJbnRlcnZhbGAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgYGF1dG9DeWNsZUludGVydmFsYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvQ3ljbGVJbnRlcnZhbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUgJiYgbWUubW91bnRlZCkge1xuICAgICAgICAgICAgbWUuc3RhcnRBdXRvQ3ljbGUoZmFsc2UpO1xuICAgICAgICAgICAgbWUuc3RhcnRBdXRvQ3ljbGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgdGhlIG1lYXN1cmVtZW50IGNhY2hlIGFuZCB1cGRhdGVzIHRoZSBWRE9NIHdoZW4gdGhlIGBmb250RmFtaWx5YCBjb25maWcgY2hhbmdlcyxcbiAgICAgKiBhcyBhIG5ldyBmb250IHdpbGwgY2hhbmdlIGFsbCBjaGFyYWN0ZXIgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiBgZm9udEZhbWlseWAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgYGZvbnRGYW1pbHlgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZvbnRGYW1pbHkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubWVhc3VyZUNhY2hlID0ge307XG5cbiAgICAgICAgbWUudmRvbS5zdHlsZS5mb250RmFtaWx5ID0gdmFsdWU7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgY29tcG9uZW50J3MgbW91bnRlZCBzdGF0ZSBjaGFuZ2VzLiBXaGVuIG1vdW50ZWQsIGl0IGRldGVybWluZXMgdGhlIGNvbXBvbmVudCdzXG4gICAgICogZGltZW5zaW9ucy4gV2hlbiB1bm1vdW50ZWQsIGl0IGNsZWFycyB0aGUgbWVhc3VyZW1lbnQgY2FjaGUgYW5kIGNoYXJhY3RlciBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlICAgIFRoZSBuZXcgdmFsdWUgb2YgYG1vdW50ZWRgLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiBgbW91bnRlZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmdldERvbVJlY3QoKS50aGVuKHJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmNvbnRlbnRIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBtZS5jb250ZW50V2lkdGggID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5tZWFzdXJlQ2FjaGUgID0ge307XG4gICAgICAgICAgICBtZS5wcmV2aW91c0NoYXJzID0gW11cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS5hZGRSZXNpemVPYnNlcnZlcih2YWx1ZSk7XG5cbiAgICAgICAgICAgIG1lLmF1dG9DeWNsZSAmJiBtZS5zdGFydEF1dG9DeWNsZSh2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIHRoZSBhbmltYXRpb24gd2hlbiB0aGUgYHRleHRgIGNvbmZpZyBpcyBjaGFuZ2VkLlxuICAgICAqIEl0IG9yY2hlc3RyYXRlcyB0aGUgbWVhc3VyZW1lbnQgYW5kIGFuaW1hdGlvbiBwaGFzZXMuIEl0IGFsc28gY29udGFpbnMgYSBgdHJ5L2NhdGNoYFxuICAgICAqIGJsb2NrIHRvIGhhbmRsZSBwb3RlbnRpYWwgZXJyb3JzIGR1cmluZyB0aGUgY29tcGxleCBhbmltYXRpb24gbG9naWMsIHdpdGggYSBzaW5nbGUtcmV0cnlcbiAgICAgKiBtZWNoYW5pc20gdG8gcmVjb3ZlciBmcm9tIHRyYW5zaWVudCBzdGF0ZXMgYnkgY2xlYXJpbmcgdGhlIGNhY2hlIGFuZCByZS1ydW5uaW5nIHRoZSBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICBUaGUgbmV3IHRleHQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlIFRoZSBvbGQgdGV4dCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bWVhc3VyZUVsZW1lbnR9ID0gbWU7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5wcmV2aW91c0NoYXJzID0gbWUuY2hhcnNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtZS5jaGFycyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50LmNuID0gW107XG5cbiAgICAgICAgICAgICAgICB2YWx1ZT8uc3BsaXQoJycpLmZvckVhY2goY2hhciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNoYXJzLnB1c2goe25hbWU6IGNoYXJ9KTtcbiAgICAgICAgICAgICAgICAgICAgbWVhc3VyZUVsZW1lbnQuY24ucHVzaCh7dGFnOiAnc3BhbicsIHRleHQ6IGNoYXJ9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbWUubWVhc3VyZUNoYXJzKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBtZS51cGRhdGVDaGFycygpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZS5pc1JldHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzUmV0cnlpbmcgICAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5tZWFzdXJlQ2FjaGUgID0ge307XG4gICAgICAgICAgICAgICAgICAgIG1lLnByZXZpb3VzQ2hhcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBhIHRyYW5zaXRpb25pbmcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgbWUudmRvbS5jblswXS5jbi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lLmFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5pc1JldHJ5aW5nID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHRyYW5zaXRpb24gdGltZSB0byBhIENTUyB2YXJpYWJsZSwgYWxsb3dpbmcgdGhlIGFuaW1hdGlvbnMgdG8gYmUgY29udHJvbGxlZCB2aWEgSmF2YVNjcmlwdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgICAgVGhlIG5ldyB2YWx1ZSBvZiBgdHJhbnNpdGlvblRpbWVgLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIGB0cmFuc2l0aW9uVGltZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvblRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmRvbS5zdHlsZVsnLS1uZW8tdHJhbnNpdGlvbi10aW1lJ10gPSB2YWx1ZSArICdtcyc7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBWRE9NIGZvciBuZXcgY2hhcmFjdGVycyB0aGF0IGFyZSBmYWRpbmcgaW4uIEl0IGZpbHRlcnMgb3V0IGNoYXJhY3RlcnNcbiAgICAgKiB0aGF0IGFyZSBhbHJlYWR5IHByZXNlbnQgKGFuZCB3aWxsIGJlIG1vdmVkIGluc3RlYWQpLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGxldHRlcnMgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBuZXcgdGV4dCwgd2l0aCBgbnVsbGAgZm9yIGNoYXJhY3RlcnMgdGhhdCBhbHJlYWR5IGV4aXN0ZWQuXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBBbiBhcnJheSBvZiBWRE9NIG5vZGVzIGZvciB0aGUgbmV3IGNoYXJhY3RlcnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoYXJzVmRvbShsZXR0ZXJzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2hhcnN9ICAgICAgICA9IG1lLFxuICAgICAgICAgICAgY2hhcnNDb250YWluZXIgPSBbXSxcbiAgICAgICAgICAgIGNoYXI7XG5cbiAgICAgICAgbGV0dGVycy5mb3JFYWNoKChsZXR0ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAobGV0dGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IGNoYXJzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tY2hhciddLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge2NvbG9yOiBtZS5jb2xvckZhZGVJbiwgbGVmdDogY2hhci5sZWZ0LCBvcGFjaXR5OiAwLCB0b3A6IGNoYXIudG9wfSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA6IGNoYXIubmFtZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFyc0NvbnRhaW5lclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2VzIHRoZSB0ZXh0IHRvIHRoZSBuZXh0IHN0cmluZyBpbiB0aGUgYGN5Y2xlVGV4dHNgIGFycmF5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjeWNsZVRleHQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudGV4dCAgICAgICAgID0gbWUuY3ljbGVUZXh0c1ttZS5jdXJyZW50SW5kZXhdO1xuICAgICAgICBtZS5jdXJyZW50SW5kZXggPSAobWUuY3VycmVudEluZGV4ICsgMSkgJSBtZS5jeWNsZVRleHRzLmxlbmd0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBwaGFzZSBvZiB0aGUgYW5pbWF0aW9uOiBjYWxjdWxhdGluZyBjaGFyYWN0ZXIgcG9zaXRpb25zLlxuICAgICAqIElmIHRoZSBwb3NpdGlvbnMgZm9yIHRoZSBjdXJyZW50IHRleHQgYXJlIG5vdCBpbiB0aGUgY2FjaGUsIHRoaXMgbWV0aG9kIHRlbXBvcmFyaWx5XG4gICAgICogcmVuZGVycyB0aGUgY2hhcmFjdGVycyBpbnRvIGEgaGlkZGVuIGRpdiwgbWVhc3VyZXMgdGhlaXIgYm91bmRpbmcgcmVjdGFuZ2xlcyxcbiAgICAgKiBzdG9yZXMgdGhlIHJlc3VsdHMgaW4gdGhlIGNhY2hlLCBhbmQgdGhlbiByZW1vdmVzIHRoZSBtZWFzdXJlbWVudCBlbGVtZW50cyBmcm9tIHRoZSBET00uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIG1lYXN1cmVDaGFycygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHttZWFzdXJlQ2FjaGUsIG1lYXN1cmVFbGVtZW50LCBtZWFzdXJlV3JhcHBlciwgdGV4dH0gPSBtZSxcbiAgICAgICAgICAgIHBhcmVudFJlY3QsIHJlY3RzO1xuXG4gICAgICAgIGlmIChtZWFzdXJlQ2FjaGVbdGV4dF0pIHtcbiAgICAgICAgICAgIHJlY3RzICAgICAgPSBbLi4ubWVhc3VyZUNhY2hlW3RleHRdXTtcbiAgICAgICAgICAgIHBhcmVudFJlY3QgPSByZWN0cy5zaGlmdCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZWFzdXJlV3JhcHBlci5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lLmNvbnRlbnRIZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogbWUuY29udGVudFdpZHRoICArICdweCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZWFzdXJlV3JhcHBlci5yZW1vdmVEb207XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMjApO1xuXG4gICAgICAgICAgICByZWN0cyAgICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChbbWVhc3VyZVdyYXBwZXIuaWQsIC4uLm1lYXN1cmVFbGVtZW50LmNuLm1hcChub2RlID0+IG5vZGUuaWQpXSk7XG4gICAgICAgICAgICBwYXJlbnRSZWN0ID0gcmVjdHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgbWVhc3VyZUNhY2hlW3RleHRdID0gW3BhcmVudFJlY3QsIC4uLnJlY3RzXVxuICAgICAgICB9XG5cbiAgICAgICAgcmVjdHMuZm9yRWFjaCgocmVjdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIG1lLmNoYXJzW2luZGV4XS5sZWZ0ID0gYCR7cmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgIG1lLmNoYXJzW2luZGV4XS50b3AgID0gYCR7cmVjdC50b3AgIC0gcGFyZW50UmVjdC50b3AgfXB4YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc2l6ZSBldmVudCBoYW5kbGVyLiBJdCB1cGRhdGVzIHRoZSBjb21wb25lbnQncyBkaW1lbnNpb25zLCBpbnZhbGlkYXRlcyB0aGVcbiAgICAgKiBtZWFzdXJlbWVudCBjYWNoZSwgYW5kIHRyaWdnZXJzIGEgcmVtZWFzdXJlbWVudCBhbmQgVkRPTSB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICBUaGUgZXZlbnQgZGF0YSBmcm9tIHRoZSByZXNpemUgb2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjdCBUaGUgbmV3IGJvdW5kaW5nIHJlY3RhbmdsZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBvblJlc2l6ZSh7cmVjdH0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jb250ZW50SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIG1lLmNvbnRlbnRXaWR0aCAgPSByZWN0LndpZHRoO1xuXG4gICAgICAgIG1lLm1lYXN1cmVDYWNoZSA9IHt9O1xuXG4gICAgICAgIGlmICghbWUuaW5pdGlhbFJlc2l6ZUV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIW1lLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm1lYXN1cmVDaGFycygpO1xuXG4gICAgICAgICAgICAgICAgbWUuY2hhcnNWZG9tID0gbWUuY3JlYXRlQ2hhcnNWZG9tKG1lLmNoYXJzLm1hcChjaGFyID0+IGNoYXIubmFtZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5pbml0aWFsUmVzaXplRXZlbnQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gc3dpdGNoaW5nIGJyb3dzZXIgdGFicyBvciBtaW5pbWl6aW5nIHRoZSBicm93c2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLmhpZGRlblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS52aXNpYmlsaXR5U3RhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvblZpc2liaWxpdHlDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5hdXRvQ3ljbGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKGZhbHNlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5pc1JldHJ5aW5nICAgID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWUubWVhc3VyZUNhY2hlICA9IHt9O1xuICAgICAgICAgICAgICAgIG1lLnByZXZpb3VzQ2hhcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc29ydCBjb21wYXJhdG9yIGZ1bmN0aW9uIHVzZWQgdG8gb3JkZXIgY2hhcmFjdGVyIFZET00gbm9kZXMgYmFzZWQgb24gdGhlaXJcbiAgICAgKiBgdG9wYCBhbmQgYGxlZnRgIHN0eWxlIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyBhIGNvbnNpc3RlbnQgRE9NIG9yZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBmaXJzdCBWRE9NIG5vZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIHNlY29uZCBWRE9NIG5vZGUuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc29ydENoYXJhY3RlcnMoYSwgYikge1xuICAgICAgICBsZXQgZGVsdGFUb3AgPSBwYXJzZUZsb2F0KGEuc3R5bGUudG9wKSAtIHBhcnNlRmxvYXQoYi5zdHlsZS50b3ApO1xuXG4gICAgICAgIGlmIChkZWx0YVRvcCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhVG9wXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhLnN0eWxlLmxlZnQpIC0gcGFyc2VGbG9hdChiLnN0eWxlLmxlZnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIG9yIHN0b3BzIHRoZSBgc2V0SW50ZXJ2YWxgIGZvciBhdXRvbWF0aWMgdGV4dCBjeWNsaW5nLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhcnQ9dHJ1ZSBUcnVlIHRvIHN0YXJ0IHRoZSB0aW1lciwgZmFsc2UgdG8gc3RvcCBpdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhcnRBdXRvQ3ljbGUoc3RhcnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgbWUuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKG1lLmN5Y2xlVGV4dC5iaW5kKG1lKSwgbWUuYXV0b0N5Y2xlSW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICBtZS50aW1lb3V0KDIwKS50aGVuKCgpID0+IHttZS5jeWNsZVRleHQoKX0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKG1lLmludGVydmFsSWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kIGFuZCBtb3N0IGNvbXBsZXggcGhhc2Ugb2YgdGhlIGFuaW1hdGlvbjogdXBkYXRpbmcgdGhlIFZET00gdG8gdHJpZ2dlciBDU1MgdHJhbnNpdGlvbnMuXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgY29yZSBcIm1hZ2ljIG1vdmVcIiBsb2dpYyBieSBkZXRlcm1pbmluZyB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgb2xkXG4gICAgICogYW5kIG5ldyB0ZXh0IHN0YXRlcyBhbmQgYXBwbHlpbmcgc3R5bGVzIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogVGhlIGFsZ29yaXRobSBpcyBhcyBmb2xsb3dzOlxuICAgICAqIDEuIEl0ZXJhdGUgdGhyb3VnaCB0aGUgYHByZXZpb3VzQ2hhcnNgLlxuICAgICAqIDIuIEZvciBlYWNoIG9sZCBjaGFyYWN0ZXIsIGNoZWNrIGlmIGl0IGV4aXN0cyBpbiB0aGUgbmV3IHRleHQuXG4gICAgICogICAgLSBJZiBZRVM6IFRoaXMgY2hhcmFjdGVyIG5lZWRzIHRvICoqbW92ZSoqLiBBcHBseSB0aGUgbmV3IGBsZWZ0YCBhbmQgYHRvcGAgc3R5bGVzIHRvIGl0cyBWRE9NIG5vZGUuXG4gICAgICogICAgLSBJZiBOTzogVGhpcyBjaGFyYWN0ZXIgbmVlZHMgdG8gKipmYWRlIG91dCoqLiBGbGFnIGl0IGZvciByZW1vdmFsLlxuICAgICAqIDMuIENyZWF0ZSBuZXcgVkRPTSBub2RlcyBmb3IgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgdW5pcXVlIHRvIHRoZSBuZXcgdGV4dC4gVGhlc2Ugd2lsbCAqKmZhZGUgaW4qKi5cbiAgICAgKiA0LiBBcHBseSBzdHlsZXMgdG8gYWxsIG5vZGVzIHNpbXVsdGFuZW91c2x5IHRvIHRyaWdnZXIgdGhlIENTUyB0cmFuc2l0aW9ucyAobW92ZSwgZmFkZS1pbiwgZmFkZS1vdXQpLlxuICAgICAqIDUuIEFmdGVyIHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uLCBjbGVhbiB1cCB0aGUgVkRPTSBieSByZW1vdmluZyB0aGUgZmFkZWQtb3V0IG5vZGVzLlxuICAgICAqIDYuIEZpbmFsbHksIGZvciBwZXJmb3JtYW5jZSwgY29sbGFwc2UgYWxsIHRoZSBpbmRpdmlkdWFsIGNoYXJhY3RlciBgPHNwYW4+YCBub2RlcyBiYWNrIGludG8gYSBzaW5nbGVcbiAgICAgKiAgICB0ZXh0IG5vZGUgdW50aWwgdGhlIG5leHQgYW5pbWF0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ2hhcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjaGFycywgcHJldmlvdXNDaGFyc30gPSBtZSxcbiAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyICAgICAgICAgPSBtZS52ZG9tLmNuWzBdLFxuICAgICAgICAgICAgbGV0dGVycyAgICAgICAgICAgICAgICA9IGNoYXJzLm1hcChjaGFyID0+IGNoYXIubmFtZSksXG4gICAgICAgICAgICBjaGFyTm9kZSwgaW5kZXg7XG5cbiAgICAgICAgbWUuaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAobWUuY2hhcnNWZG9tLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLmNuID0gbWUuY2hhcnNWZG9tO1xuICAgICAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c0NoYXJzLmZvckVhY2goKHByZXZpb3VzQ2hhciwgcHJldmlvdXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgaW5kZXggPSBsZXR0ZXJzLmluZGV4T2YocHJldmlvdXNDaGFyLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlID0gY2hhcnNDb250YWluZXIuY25bcHJldmlvdXNJbmRleF07XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNoYXJOb2RlLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBtZS5jb2xvck1vdmUsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgOiBjaGFyc1tpbmRleF0ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wICA6IGNoYXJzW2luZGV4XS50b3BcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxldHRlcnNbaW5kZXhdID0gbnVsbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW3ByZXZpb3VzSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgY2hhck5vZGUuZmxhZyA9ICdyZW1vdmUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLnB1c2goLi4ubWUuY3JlYXRlQ2hhcnNWZG9tKGxldHRlcnMpKTtcblxuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKCk7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24uZm9yRWFjaChjaGFyTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhck5vZGUuZmxhZyA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZS5zdHlsZS5jb2xvciAgID0gbWUuY29sb3JGYWRlT3V0O1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGFyTm9kZS5zdHlsZS5vcGFjaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dChtZS50cmFuc2l0aW9uVGltZSk7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24uc29ydChtZS5zb3J0Q2hhcmFjdGVycyk7XG5cbiAgICAgICAgaW5kZXggPSBjaGFyc0NvbnRhaW5lci5jbi5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAoOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW2luZGV4XTtcblxuICAgICAgICAgICAgZGVsZXRlIGNoYXJOb2RlLmZsYWc7XG4gICAgICAgICAgICBkZWxldGUgY2hhck5vZGUuc3R5bGUuY29sb3I7XG5cbiAgICAgICAgICAgIGlmIChjaGFyTm9kZS5zdHlsZS5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNDb250YWluZXIuY24uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwMCk7XG5cbiAgICAgICAgbWUuY2hhcnNWZG9tID0gWy4uLmNoYXJzQ29udGFpbmVyLmNuXTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5sZW5ndGggPSAwO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLnB1c2goe3RleHQ6IG1lLnRleHR9KTtcbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuXG4gICAgICAgIG1lLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWdpY01vdmVUZXh0KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=