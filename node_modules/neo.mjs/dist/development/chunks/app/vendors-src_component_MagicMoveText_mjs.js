"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_MagicMoveText_mjs"],{

/***/ "./src/component/MagicMoveText.mjs":
/*!*****************************************!*\
  !*** ./src/component/MagicMoveText.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * Deeply inspired by https://github.com/yangshun 's video on LinkedIn
 * as well as Apple's Keynote Magic Move effect
 * @class Neo.component.MagicMoveText
 * @extends Neo.component.Base
 */
class MagicMoveText extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.MagicMoveText'
         * @protected
         */
        className: 'Neo.component.MagicMoveText',
        /**
         * @member {String} ntype='magic-move-text'
         * @protected
         */
        ntype: 'magic-move-text',
        /**
         * @member {Boolean} autoCycle_=true
         */
        autoCycle_: true,
        /**
         * @member {Number} autoCycleInterval_=2000
         */
        autoCycleInterval_: 2000,
        /**
         * @member {String[]} baseCls=['neo-magic-move-text']
         * @protected
         */
        baseCls: ['neo-magic-move-text'],
        /**
         * @member {String|null} colorMove=null
         */
        colorMove: null,
        /**
         * @member {String|null} colorFadeIn=null
         */
        colorFadeIn: null,
        /**
         * @member {String|null} colorFadeOut=null
         */
        colorFadeOut: null,
        /**
         * @member {String[]|null} cycleTexts=null
         */
        cycleTexts: null,
        /**
         * @member {String} fontFamily_='Helvetica Neue'
         */
        fontFamily_: 'Helvetica Neue',
        /**
         * @member {String} text_=null
         */
        text_: null,
        /**
         * Time in ms for the fadeIn, fadeOut and move character OPs
         * @member {Number} transitionTime_=500
         */
        transitionTime_: 500,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {style: {}, cn: [
            {cls: ['neo-content'], cn: []},
            {cls: ['neo-measure-element-wrapper'], removeDom: true, cn: [
                {cls: ['neo-measure-element'], cn:[]}
            ]}
        ]}
    }

    /**
     * @member {Object[]} chars=[]
     * @protected
     */
    chars = []
    /**
     * @member {Object[]} charsVdom=[]
     * @protected
     */
    charsVdom = []
    /**
     * @member {Number} contentHeight=0
     * @protected
     */
    contentHeight = 0
    /**
     * @member {Number} contentWidth=0
     * @protected
     */
    contentWidth = 0
    /**
     * @member {Number} currentIndex=0
     * @protected
     */
    currentIndex = 0
    /**
     * We do not need the first event to trigger logic, since afterSetMounted() handles this
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * @member {Number|null} intervalId=null
     * @protected
     */
    intervalId = null
    /**
     * Internal flag which gets set to true while the animated char transitions are running
     * @member {Boolean} isTransitioning=false
     * @protected
     */
    isTransitioning = false
    /**
     * @member {Object} measureCache={}
     * @protected
     */
    measureCache = {}
    /**
     * @member {Object[]} previousChars=[]
     * @protected
     */
    previousChars = []
    /**
     * @member {Object} measureElement
     * @protected
     */
    get measureElement() {
        return this.measureWrapper.cn[0]
    }
    /**
     * @member {Object} measureElement
     * @protected
     */
    get measureWrapper() {
        return this.vdom.cn[1]
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        })
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addResizeObserver(mounted) {
        let {id, windowId} = this,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId);

        ResizeObserver[mounted ? 'register' : 'unregister']({id, windowId});

        if (mounted) {
            this.initialResizeEvent = true
        }
    }

    /**
     * Triggered after the autoCycle config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAutoCycle(value, oldValue) {
        this.mounted && this.startAutoCycle(value)
    }

    /**
     * Triggered after the autoCycleInterval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAutoCycleInterval(value, oldValue) {
        let me = this;

        if (oldValue && me.mounted) {
            me.startAutoCycle(false);
            me.startAutoCycle()
        }
    }

    /**
     * Triggered after the fontFamily config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetFontFamily(value, oldValue) {
        let me = this;

        me.measureCache = {};

        me.vdom.style.fontFamily = value;
        me.update()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        value && me.getDomRect().then(rect => {
            me.contentHeight = rect.height;
            me.contentWidth  = rect.width;

            me.autoCycle && me.startAutoCycle(value)
        });

        oldValue !== undefined && me.addResizeObserver(value)
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {Promise<void>}
     * @protected
     */
    async afterSetText(value, oldValue) {
        let me               = this,
            {measureElement} = me;

        if (oldValue) {
            me.previousChars = me.chars
        }

        if (value) {
            me.chars = [];
            measureElement.cn = [];

            value?.split('').forEach(char => {
                me.chars.push({name: char});

                if (char === ' ') {
                    char = '&#32;'
                }

                measureElement.cn.push({tag: 'span', html: char})
            });

            if (me.mounted) {
                await me.measureChars()
            }

            await me.updateChars()
        }
    }

    /**
     * Triggered after the transitionTime config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetTransitionTime(value, oldValue) {
        this.vdom.style['--neo-transition-time'] = value + 'ms';
        this.update()
    }

    /**
     * @param {String[]} letters
     * @returns {Object[]}
     * @protected
     */
    createCharsVdom(letters) {
        let me             = this,
            {chars}        = me,
            charsContainer = [],
            char;

        letters.forEach((letter, index) => {
            if (letter !== null) {
                char = chars[index];

                charsContainer.push({
                    cls  : ['neo-char'],
                    html : char.name,
                    style: {color: me.colorFadeIn, left: char.left, opacity: 0, top: char.top}
                })
            }
        });

        return charsContainer
    }

    /**
     * @protected
     */
    cycleText() {
        let me = this;

        me.text         = me.cycleTexts[me.currentIndex];
        me.currentIndex = (me.currentIndex + 1) % me.cycleTexts.length
    }

    /**
     * @returns {Promise<void>}
     * @protected
     */
    async measureChars() {
        let me = this,
            {measureCache, measureElement, measureWrapper, text} = me,
            parentRect, rects;

        if (measureCache[text]) {
            rects      = [...measureCache[text]];
            parentRect = rects.shift()
        } else {
            measureWrapper.style = {
                height: me.contentHeight + 'px',
                width : me.contentWidth  + 'px'
            };

            delete measureWrapper.removeDom;

            await me.promiseUpdate();
            await me.timeout(20);

            rects      = await me.getDomRect([measureWrapper.id, ...measureElement.cn.map(node => node.id)]);
            parentRect = rects.shift();

            measureCache[text] = [parentRect, ...rects]
        }

        rects.forEach((rect, index) => {
            me.chars[index].left = `${rect.left - parentRect.left}px`;
            me.chars[index].top  = `${rect.top  - parentRect.top }px`;
        });

        measureWrapper.removeDom = true;
        await me.promiseUpdate()
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     * @protected
     */
    async onResize({rect}) {
        let me = this;

        me.contentHeight = rect.height;
        me.contentWidth  = rect.width;

        me.measureCache = {};


        if (!me.initialResizeEvent) {
            if (!me.isTransitioning) {
                await me.measureChars();

                me.charsVdom = me.createCharsVdom(me.chars.map(char => char.name))
            }
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * @param {Object} a
     * @param {Object} b
     * @returns {Number}
     * @protected
     */
    sortCharacters(a, b) {
        let deltaTop = parseFloat(a.style.top) - parseFloat(b.style.top);

        if (deltaTop !== 0) {
            return deltaTop
        }

        return parseFloat(a.style.left) - parseFloat(b.style.left)
    }

    /**
     * @param {Boolean} start=true
     * @protected
     */
    startAutoCycle(start=true) {
        let me = this;

        if (start) {
            me.intervalId = setInterval(me.cycleText.bind(me), me.autoCycleInterval);

            me.timeout(20).then(() => {me.cycleText()});
        } else {
            clearInterval(me.intervalId)
        }
    }

    /**
     * @returns {Promise<void>}
     * @protected
     */
    async updateChars() {
        let me                     = this,
            {chars, previousChars} = me,
            charsContainer         = me.vdom.cn[0],
            letters                = chars.map(char => char.name),
            charNode, index;

        me.isTransitioning = true;

        if (me.charsVdom.length > 1) {
            charsContainer.cn = me.charsVdom;
            await me.promiseUpdate()
        }

        previousChars.forEach((previousChar, previousIndex) => {
            index = letters.indexOf(previousChar.name);

            if (index > -1) {
                charNode = charsContainer.cn[previousIndex];

                Object.assign(charNode.style, {
                    color: me.colorMove,
                    left : chars[index].left,
                    top  : chars[index].top
                });

                letters[index] = null
            } else {
                charNode = charsContainer.cn[previousIndex];

                charNode.flag = 'remove'
            }
        });

        charsContainer.cn.push(...me.createCharsVdom(letters));

        await me.promiseUpdate();

        charsContainer.cn.forEach(charNode => {
            if (charNode.flag === 'remove') {
                charNode.style.color   = me.colorFadeOut;
                charNode.style.opacity = 0
            } else {
                delete charNode.style.opacity
            }
        });

        await me.promiseUpdate();
        await me.timeout(me.transitionTime);

        charsContainer.cn.sort(me.sortCharacters);

        index = charsContainer.cn.length - 1;

        for (; index >= 0; index--) {
            charNode = charsContainer.cn[index];

            delete charNode.flag;
            delete charNode.style.color;

            if (charNode.style.opacity === 0) {
                charsContainer.cn.splice(index, 1)
            }
        }

        await me.promiseUpdate();
        await me.timeout(200);

        me.charsVdom = [...charsContainer.cn];

        charsContainer.cn.length = 0;

        charsContainer.cn.push({html: me.text});
        await me.promiseUpdate();

        me.isTransitioning = false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MagicMoveText));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfTWFnaWNNb3ZlVGV4dF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyREFBUztBQUNyQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCLGFBQWEsNkJBQTZCO0FBQzFDLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsZUFBZTtBQUN0RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLFlBQVk7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQyxjQUFjO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSw2QkFBNkIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L01hZ2ljTW92ZVRleHQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBEZWVwbHkgaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL3lhbmdzaHVuICdzIHZpZGVvIG9uIExpbmtlZEluXG4gKiBhcyB3ZWxsIGFzIEFwcGxlJ3MgS2V5bm90ZSBNYWdpYyBNb3ZlIGVmZmVjdFxuICogQGNsYXNzIE5lby5jb21wb25lbnQuTWFnaWNNb3ZlVGV4dFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIE1hZ2ljTW92ZVRleHQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5NYWdpY01vdmVUZXh0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50Lk1hZ2ljTW92ZVRleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbWFnaWMtbW92ZS10ZXh0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21hZ2ljLW1vdmUtdGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvQ3ljbGVfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9DeWNsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGF1dG9DeWNsZUludGVydmFsXz0yMDAwXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvQ3ljbGVJbnRlcnZhbF86IDIwMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1tYWdpYy1tb3ZlLXRleHQnXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1tYWdpYy1tb3ZlLXRleHQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb2xvck1vdmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JNb3ZlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbG9yRmFkZUluPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmFkZUluOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbG9yRmFkZU91dD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZhZGVPdXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxudWxsfSBjeWNsZVRleHRzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGN5Y2xlVGV4dHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGZvbnRGYW1pbHlfPSdIZWx2ZXRpY2EgTmV1ZSdcbiAgICAgICAgICovXG4gICAgICAgIGZvbnRGYW1pbHlfOiAnSGVsdmV0aWNhIE5ldWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0ZXh0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWUgaW4gbXMgZm9yIHRoZSBmYWRlSW4sIGZhZGVPdXQgYW5kIG1vdmUgY2hhcmFjdGVyIE9Qc1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRyYW5zaXRpb25UaW1lXz01MDBcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25UaW1lXzogNTAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtzdHlsZToge30sIGNuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1jb250ZW50J10sIGNuOiBbXX0sXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1tZWFzdXJlLWVsZW1lbnQtd3JhcHBlciddLCByZW1vdmVEb206IHRydWUsIGNuOiBbXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tbWVhc3VyZS1lbGVtZW50J10sIGNuOltdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gY2hhcnM9W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2hhcnMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBjaGFyc1Zkb209W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2hhcnNWZG9tID0gW11cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbnRlbnRIZWlnaHQ9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjb250ZW50SGVpZ2h0ID0gMFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gY29udGVudFdpZHRoPTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29udGVudFdpZHRoID0gMFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gY3VycmVudEluZGV4PTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3VycmVudEluZGV4ID0gMFxuICAgIC8qKlxuICAgICAqIFdlIGRvIG5vdCBuZWVkIHRoZSBmaXJzdCBldmVudCB0byB0cmlnZ2VyIGxvZ2ljLCBzaW5jZSBhZnRlclNldE1vdW50ZWQoKSBoYW5kbGVzIHRoaXNcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpbml0aWFsUmVzaXplRXZlbnQ9dHJ1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsUmVzaXplRXZlbnQgPSB0cnVlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGludGVydmFsSWQ9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbnRlcnZhbElkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggZ2V0cyBzZXQgdG8gdHJ1ZSB3aGlsZSB0aGUgYW5pbWF0ZWQgY2hhciB0cmFuc2l0aW9ucyBhcmUgcnVubmluZ1xuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVHJhbnNpdGlvbmluZz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVhc3VyZUNhY2hlPXt9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1lYXN1cmVDYWNoZSA9IHt9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHByZXZpb3VzQ2hhcnM9W11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJldmlvdXNDaGFycyA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtZWFzdXJlRWxlbWVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgbWVhc3VyZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lYXN1cmVXcmFwcGVyLmNuWzBdXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVhc3VyZUVsZW1lbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0IG1lYXN1cmVXcmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzFdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgcmVzaXplOiBtZS5vblJlc2l6ZSxcbiAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1vdW50ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWRkUmVzaXplT2JzZXJ2ZXIobW91bnRlZCkge1xuICAgICAgICBsZXQge2lkLCB3aW5kb3dJZH0gPSB0aGlzLFxuICAgICAgICAgICAgUmVzaXplT2JzZXJ2ZXIgPSBhd2FpdCBOZW8uY3VycmVudFdvcmtlci5nZXRBZGRvbignUmVzaXplT2JzZXJ2ZXInLCB3aW5kb3dJZCk7XG5cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJbbW91bnRlZCA/ICdyZWdpc3RlcicgOiAndW5yZWdpc3RlciddKHtpZCwgd2luZG93SWR9KTtcblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsUmVzaXplRXZlbnQgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGF1dG9DeWNsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEF1dG9DeWNsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5tb3VudGVkICYmIHRoaXMuc3RhcnRBdXRvQ3ljbGUodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdXRvQ3ljbGVJbnRlcnZhbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvQ3ljbGVJbnRlcnZhbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUgJiYgbWUubW91bnRlZCkge1xuICAgICAgICAgICAgbWUuc3RhcnRBdXRvQ3ljbGUoZmFsc2UpO1xuICAgICAgICAgICAgbWUuc3RhcnRBdXRvQ3ljbGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmb250RmFtaWx5IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZvbnRGYW1pbHkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubWVhc3VyZUNhY2hlID0ge307XG5cbiAgICAgICAgbWUudmRvbS5zdHlsZS5mb250RmFtaWx5ID0gdmFsdWU7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICB2YWx1ZSAmJiBtZS5nZXREb21SZWN0KCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgIG1lLmNvbnRlbnRIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgIG1lLmNvbnRlbnRXaWR0aCAgPSByZWN0LndpZHRoO1xuXG4gICAgICAgICAgICBtZS5hdXRvQ3ljbGUgJiYgbWUuc3RhcnRBdXRvQ3ljbGUodmFsdWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgbWUuYWRkUmVzaXplT2JzZXJ2ZXIodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0ZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttZWFzdXJlRWxlbWVudH0gPSBtZTtcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnByZXZpb3VzQ2hhcnMgPSBtZS5jaGFyc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS5jaGFycyA9IFtdO1xuICAgICAgICAgICAgbWVhc3VyZUVsZW1lbnQuY24gPSBbXTtcblxuICAgICAgICAgICAgdmFsdWU/LnNwbGl0KCcnKS5mb3JFYWNoKGNoYXIgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmNoYXJzLnB1c2goe25hbWU6IGNoYXJ9KTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9ICcmIzMyOydcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZWFzdXJlRWxlbWVudC5jbi5wdXNoKHt0YWc6ICdzcGFuJywgaHRtbDogY2hhcn0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5tZWFzdXJlQ2hhcnMoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCBtZS51cGRhdGVDaGFycygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb25UaW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRyYW5zaXRpb25UaW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZkb20uc3R5bGVbJy0tbmVvLXRyYW5zaXRpb24tdGltZSddID0gdmFsdWUgKyAnbXMnO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gbGV0dGVyc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hhcnNWZG9tKGxldHRlcnMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjaGFyc30gICAgICAgID0gbWUsXG4gICAgICAgICAgICBjaGFyc0NvbnRhaW5lciA9IFtdLFxuICAgICAgICAgICAgY2hhcjtcblxuICAgICAgICBsZXR0ZXJzLmZvckVhY2goKGxldHRlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChsZXR0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFyID0gY2hhcnNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgY2hhcnNDb250YWluZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNscyAgOiBbJ25lby1jaGFyJ10sXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgOiBjaGFyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7Y29sb3I6IG1lLmNvbG9yRmFkZUluLCBsZWZ0OiBjaGFyLmxlZnQsIG9wYWNpdHk6IDAsIHRvcDogY2hhci50b3B9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJzQ29udGFpbmVyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGN5Y2xlVGV4dCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS50ZXh0ICAgICAgICAgPSBtZS5jeWNsZVRleHRzW21lLmN1cnJlbnRJbmRleF07XG4gICAgICAgIG1lLmN1cnJlbnRJbmRleCA9IChtZS5jdXJyZW50SW5kZXggKyAxKSAlIG1lLmN5Y2xlVGV4dHMubGVuZ3RoXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIG1lYXN1cmVDaGFycygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHttZWFzdXJlQ2FjaGUsIG1lYXN1cmVFbGVtZW50LCBtZWFzdXJlV3JhcHBlciwgdGV4dH0gPSBtZSxcbiAgICAgICAgICAgIHBhcmVudFJlY3QsIHJlY3RzO1xuXG4gICAgICAgIGlmIChtZWFzdXJlQ2FjaGVbdGV4dF0pIHtcbiAgICAgICAgICAgIHJlY3RzICAgICAgPSBbLi4ubWVhc3VyZUNhY2hlW3RleHRdXTtcbiAgICAgICAgICAgIHBhcmVudFJlY3QgPSByZWN0cy5zaGlmdCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZWFzdXJlV3JhcHBlci5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lLmNvbnRlbnRIZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogbWUuY29udGVudFdpZHRoICArICdweCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZWFzdXJlV3JhcHBlci5yZW1vdmVEb207XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMjApO1xuXG4gICAgICAgICAgICByZWN0cyAgICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChbbWVhc3VyZVdyYXBwZXIuaWQsIC4uLm1lYXN1cmVFbGVtZW50LmNuLm1hcChub2RlID0+IG5vZGUuaWQpXSk7XG4gICAgICAgICAgICBwYXJlbnRSZWN0ID0gcmVjdHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgbWVhc3VyZUNhY2hlW3RleHRdID0gW3BhcmVudFJlY3QsIC4uLnJlY3RzXVxuICAgICAgICB9XG5cbiAgICAgICAgcmVjdHMuZm9yRWFjaCgocmVjdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIG1lLmNoYXJzW2luZGV4XS5sZWZ0ID0gYCR7cmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgIG1lLmNoYXJzW2luZGV4XS50b3AgID0gYCR7cmVjdC50b3AgIC0gcGFyZW50UmVjdC50b3AgfXB4YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVhc3VyZVdyYXBwZXIucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgb25SZXNpemUoe3JlY3R9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY29udGVudEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICBtZS5jb250ZW50V2lkdGggID0gcmVjdC53aWR0aDtcblxuICAgICAgICBtZS5tZWFzdXJlQ2FjaGUgPSB7fTtcblxuXG4gICAgICAgIGlmICghbWUuaW5pdGlhbFJlc2l6ZUV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIW1lLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm1lYXN1cmVDaGFycygpO1xuXG4gICAgICAgICAgICAgICAgbWUuY2hhcnNWZG9tID0gbWUuY3JlYXRlQ2hhcnNWZG9tKG1lLmNoYXJzLm1hcChjaGFyID0+IGNoYXIubmFtZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5pbml0aWFsUmVzaXplRXZlbnQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNvcnRDaGFyYWN0ZXJzKGEsIGIpIHtcbiAgICAgICAgbGV0IGRlbHRhVG9wID0gcGFyc2VGbG9hdChhLnN0eWxlLnRvcCkgLSBwYXJzZUZsb2F0KGIuc3R5bGUudG9wKTtcblxuICAgICAgICBpZiAoZGVsdGFUb3AgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YVRvcFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYS5zdHlsZS5sZWZ0KSAtIHBhcnNlRmxvYXQoYi5zdHlsZS5sZWZ0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhcnQ9dHJ1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGFydEF1dG9DeWNsZShzdGFydD10cnVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBtZS5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwobWUuY3ljbGVUZXh0LmJpbmQobWUpLCBtZS5hdXRvQ3ljbGVJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgIG1lLnRpbWVvdXQoMjApLnRoZW4oKCkgPT4ge21lLmN5Y2xlVGV4dCgpfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKG1lLmludGVydmFsSWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ2hhcnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjaGFycywgcHJldmlvdXNDaGFyc30gPSBtZSxcbiAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyICAgICAgICAgPSBtZS52ZG9tLmNuWzBdLFxuICAgICAgICAgICAgbGV0dGVycyAgICAgICAgICAgICAgICA9IGNoYXJzLm1hcChjaGFyID0+IGNoYXIubmFtZSksXG4gICAgICAgICAgICBjaGFyTm9kZSwgaW5kZXg7XG5cbiAgICAgICAgbWUuaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAobWUuY2hhcnNWZG9tLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLmNuID0gbWUuY2hhcnNWZG9tO1xuICAgICAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c0NoYXJzLmZvckVhY2goKHByZXZpb3VzQ2hhciwgcHJldmlvdXNJbmRleCkgPT4ge1xuICAgICAgICAgICAgaW5kZXggPSBsZXR0ZXJzLmluZGV4T2YocHJldmlvdXNDaGFyLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlID0gY2hhcnNDb250YWluZXIuY25bcHJldmlvdXNJbmRleF07XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNoYXJOb2RlLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBtZS5jb2xvck1vdmUsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgOiBjaGFyc1tpbmRleF0ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wICA6IGNoYXJzW2luZGV4XS50b3BcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxldHRlcnNbaW5kZXhdID0gbnVsbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW3ByZXZpb3VzSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgY2hhck5vZGUuZmxhZyA9ICdyZW1vdmUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLnB1c2goLi4ubWUuY3JlYXRlQ2hhcnNWZG9tKGxldHRlcnMpKTtcblxuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKCk7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24uZm9yRWFjaChjaGFyTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhck5vZGUuZmxhZyA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZS5zdHlsZS5jb2xvciAgID0gbWUuY29sb3JGYWRlT3V0O1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGFyTm9kZS5zdHlsZS5vcGFjaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dChtZS50cmFuc2l0aW9uVGltZSk7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24uc29ydChtZS5zb3J0Q2hhcmFjdGVycyk7XG5cbiAgICAgICAgaW5kZXggPSBjaGFyc0NvbnRhaW5lci5jbi5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAoOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW2luZGV4XTtcblxuICAgICAgICAgICAgZGVsZXRlIGNoYXJOb2RlLmZsYWc7XG4gICAgICAgICAgICBkZWxldGUgY2hhck5vZGUuc3R5bGUuY29sb3I7XG5cbiAgICAgICAgICAgIGlmIChjaGFyTm9kZS5zdHlsZS5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNDb250YWluZXIuY24uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwMCk7XG5cbiAgICAgICAgbWUuY2hhcnNWZG9tID0gWy4uLmNoYXJzQ29udGFpbmVyLmNuXTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5sZW5ndGggPSAwO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLnB1c2goe2h0bWw6IG1lLnRleHR9KTtcbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuXG4gICAgICAgIG1lLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWdpY01vdmVUZXh0KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==