"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_MagicMoveText_mjs"],{

/***/ "./src/component/MagicMoveText.mjs":
/*!*****************************************!*\
  !*** ./src/component/MagicMoveText.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * Deeply inspired by https://github.com/yangshun 's video on LinkedIn
 * as well as Apple's Keynote Magic Move effect
 * @class Neo.component.MagicMoveText
 * @extends Neo.component.Base
 */
class MagicMoveText extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.MagicMoveText'
         * @protected
         */
        className: 'Neo.component.MagicMoveText',
        /**
         * @member {String} ntype='magic-move-text'
         * @protected
         */
        ntype: 'magic-move-text',
        /**
         * @member {Boolean} autoCycle_=true
         */
        autoCycle_: true,
        /**
         * @member {Number} autoCycleInterval_=2000
         */
        autoCycleInterval_: 2000,
        /**
         * @member {String[]} baseCls=['neo-magic-move-text']
         * @protected
         */
        baseCls: ['neo-magic-move-text'],
        /**
         * @member {String|null} colorMove=null
         */
        colorMove: null,
        /**
         * @member {String|null} colorFadeIn=null
         */
        colorFadeIn: null,
        /**
         * @member {String|null} colorFadeOut=null
         */
        colorFadeOut: null,
        /**
         * @member {String[]|null} cycleTexts=null
         */
        cycleTexts: null,
        /**
         * @member {String} fontFamily_='Helvetica Neue'
         */
        fontFamily_: 'Helvetica Neue',
        /**
         * @member {String} text_=null
         */
        text_: null,
        /**
         * Time in ms for the fadeIn, fadeOut and move character OPs
         * @member {Number} transitionTime_=500
         */
        transitionTime_: 500,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {style: {}, cn: [
            {cls: ['neo-content'], cn: []},
            {cls: ['neo-measure-element-wrapper'], removeDom: true, cn: [
                {cls: ['neo-measure-element'], cn:[]}
            ]}
        ]}
    }

    /**
     * @member {Object[]} chars=[]
     * @protected
     */
    chars = []
    /**
     * @member {Object[]} charsVdom=[]
     * @protected
     */
    charsVdom = []
    /**
     * @member {Number} contentHeight=0
     * @protected
     */
    contentHeight = 0
    /**
     * @member {Number} contentWidth=0
     * @protected
     */
    contentWidth = 0
    /**
     * @member {Number} currentIndex=0
     * @protected
     */
    currentIndex = 0
    /**
     * We do not need the first event to trigger logic, since afterSetMounted() handles this
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * @member {Number|null} intervalId=null
     * @protected
     */
    intervalId = null
    /**
     * Internal flag which gets set to true while the animated char transitions are running
     * @member {Boolean} isTransitioning=false
     * @protected
     */
    isTransitioning = false
    /**
     * @member {Object} measureCache={}
     * @protected
     */
    measureCache = {}
    /**
     * @member {Object[]} previousChars=[]
     * @protected
     */
    previousChars = []
    /**
     * @member {Object} measureElement
     * @protected
     */
    get measureElement() {
        return this.measureWrapper.cn[0]
    }
    /**
     * @member {Object} measureElement
     * @protected
     */
    get measureWrapper() {
        return this.vdom.cn[1]
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        })
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addResizeObserver(mounted) {
        let {id, windowId} = this,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId);

        ResizeObserver[mounted ? 'register' : 'unregister']({id, windowId});

        if (mounted) {
            this.initialResizeEvent = true
        }
    }

    /**
     * Triggered after the autoCycle config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAutoCycle(value, oldValue) {
        this.mounted && this.startAutoCycle(value)
    }

    /**
     * Triggered after the autoCycleInterval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAutoCycleInterval(value, oldValue) {
        let me = this;

        if (oldValue && me.mounted) {
            me.startAutoCycle(false);
            me.startAutoCycle()
        }
    }

    /**
     * Triggered after the fontFamily config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetFontFamily(value, oldValue) {
        let me = this;

        me.measureCache = {};

        me.vdom.style.fontFamily = value;
        me.update()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value) {
            me.getDomRect().then(rect => {
                me.contentHeight = rect.height;
                me.contentWidth  = rect.width;
            })
        } else {
            me.measureCache  = {};
            me.previousChars = []
        }

        if (oldValue !== undefined) {
            me.addResizeObserver(value);

            me.autoCycle && me.startAutoCycle(value)
        }
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {Promise<void>}
     * @protected
     */
    async afterSetText(value, oldValue) {
        let me               = this,
            {measureElement} = me;

        if (oldValue) {
            me.previousChars = me.chars
        }

        if (value) {
            me.chars = [];
            measureElement.cn = [];

            value?.split('').forEach(char => {
                me.chars.push({name: char});

                if (char === ' ') {
                    char = '&#32;'
                }

                measureElement.cn.push({tag: 'span', html: char})
            });

            if (me.mounted) {
                await me.measureChars()
            }

            await me.updateChars()
        }
    }

    /**
     * Triggered after the transitionTime config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetTransitionTime(value, oldValue) {
        this.vdom.style['--neo-transition-time'] = value + 'ms';
        this.update()
    }

    /**
     * @param {String[]} letters
     * @returns {Object[]}
     * @protected
     */
    createCharsVdom(letters) {
        let me             = this,
            {chars}        = me,
            charsContainer = [],
            char;

        letters.forEach((letter, index) => {
            if (letter !== null) {
                char = chars[index];

                charsContainer.push({
                    cls  : ['neo-char'],
                    html : char.name,
                    style: {color: me.colorFadeIn, left: char.left, opacity: 0, top: char.top}
                })
            }
        });

        return charsContainer
    }

    /**
     * @protected
     */
    cycleText() {
        let me = this;

        me.text         = me.cycleTexts[me.currentIndex];
        me.currentIndex = (me.currentIndex + 1) % me.cycleTexts.length
    }

    /**
     * @returns {Promise<void>}
     * @protected
     */
    async measureChars() {
        let me = this,
            {measureCache, measureElement, measureWrapper, text} = me,
            parentRect, rects;

        if (measureCache[text]) {
            rects      = [...measureCache[text]];
            parentRect = rects.shift()
        } else {
            measureWrapper.style = {
                height: me.contentHeight + 'px',
                width : me.contentWidth  + 'px'
            };

            delete measureWrapper.removeDom;

            await me.promiseUpdate();
            await me.timeout(20);

            rects      = await me.getDomRect([measureWrapper.id, ...measureElement.cn.map(node => node.id)]);
            parentRect = rects.shift();

            measureCache[text] = [parentRect, ...rects]
        }

        rects.forEach((rect, index) => {
            me.chars[index].left = `${rect.left - parentRect.left}px`;
            me.chars[index].top  = `${rect.top  - parentRect.top }px`;
        });

        measureWrapper.removeDom = true;
        await me.promiseUpdate()
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     * @protected
     */
    async onResize({rect}) {
        let me = this;

        me.contentHeight = rect.height;
        me.contentWidth  = rect.width;

        me.measureCache = {};


        if (!me.initialResizeEvent) {
            if (!me.isTransitioning) {
                await me.measureChars();

                me.charsVdom = me.createCharsVdom(me.chars.map(char => char.name))
            }
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * @param {Object} a
     * @param {Object} b
     * @returns {Number}
     * @protected
     */
    sortCharacters(a, b) {
        let deltaTop = parseFloat(a.style.top) - parseFloat(b.style.top);

        if (deltaTop !== 0) {
            return deltaTop
        }

        return parseFloat(a.style.left) - parseFloat(b.style.left)
    }

    /**
     * @param {Boolean} start=true
     * @protected
     */
    startAutoCycle(start=true) {
        let me = this;

        if (start) {
            me.intervalId = setInterval(me.cycleText.bind(me), me.autoCycleInterval);

            me.timeout(20).then(() => {me.cycleText()});
        } else {
            clearInterval(me.intervalId)
        }
    }

    /**
     * @returns {Promise<void>}
     * @protected
     */
    async updateChars() {
        let me                     = this,
            {chars, previousChars} = me,
            charsContainer         = me.vdom.cn[0],
            letters                = chars.map(char => char.name),
            charNode, index;

        me.isTransitioning = true;

        if (me.charsVdom.length > 1) {
            charsContainer.cn = me.charsVdom;
            await me.promiseUpdate()
        }

        previousChars.forEach((previousChar, previousIndex) => {
            index = letters.indexOf(previousChar.name);

            if (index > -1) {
                charNode = charsContainer.cn[previousIndex];

                Object.assign(charNode.style, {
                    color: me.colorMove,
                    left : chars[index].left,
                    top  : chars[index].top
                });

                letters[index] = null
            } else {
                charNode = charsContainer.cn[previousIndex];

                charNode.flag = 'remove'
            }
        });

        charsContainer.cn.push(...me.createCharsVdom(letters));

        await me.promiseUpdate();

        charsContainer.cn.forEach(charNode => {
            if (charNode.flag === 'remove') {
                charNode.style.color   = me.colorFadeOut;
                charNode.style.opacity = 0
            } else {
                delete charNode.style.opacity
            }
        });

        await me.promiseUpdate();
        await me.timeout(me.transitionTime);

        charsContainer.cn.sort(me.sortCharacters);

        index = charsContainer.cn.length - 1;

        for (; index >= 0; index--) {
            charNode = charsContainer.cn[index];

            delete charNode.flag;
            delete charNode.style.color;

            if (charNode.style.opacity === 0) {
                charsContainer.cn.splice(index, 1)
            }
        }

        await me.promiseUpdate();
        await me.timeout(200);

        me.charsVdom = [...charsContainer.cn];

        charsContainer.cn.length = 0;

        charsContainer.cn.push({html: me.text});
        await me.promiseUpdate();

        me.isTransitioning = false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MagicMoveText));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfTWFnaWNNb3ZlVGV4dF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyREFBUztBQUNyQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCLGFBQWEsNkJBQTZCO0FBQzFDLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNB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QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLGVBQWU7QUFDdEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsY0FBYztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9NYWdpY01vdmVUZXh0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogRGVlcGx5IGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS95YW5nc2h1biAncyB2aWRlbyBvbiBMaW5rZWRJblxuICogYXMgd2VsbCBhcyBBcHBsZSdzIEtleW5vdGUgTWFnaWMgTW92ZSBlZmZlY3RcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50Lk1hZ2ljTW92ZVRleHRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBNYWdpY01vdmVUZXh0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuTWFnaWNNb3ZlVGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5NYWdpY01vdmVUZXh0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21hZ2ljLW1vdmUtdGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdtYWdpYy1tb3ZlLXRleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0N5Y2xlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvQ3ljbGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhdXRvQ3ljbGVJbnRlcnZhbF89MjAwMFxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0N5Y2xlSW50ZXJ2YWxfOiAyMDAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tbWFnaWMtbW92ZS10ZXh0J11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tbWFnaWMtbW92ZS10ZXh0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29sb3JNb3ZlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yTW92ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb2xvckZhZGVJbj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZhZGVJbjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb2xvckZhZGVPdXQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGYWRlT3V0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118bnVsbH0gY3ljbGVUZXh0cz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjeWNsZVRleHRzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmb250RmFtaWx5Xz0nSGVsdmV0aWNhIE5ldWUnXG4gICAgICAgICAqL1xuICAgICAgICBmb250RmFtaWx5XzogJ0hlbHZldGljYSBOZXVlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGV4dF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIGluIG1zIGZvciB0aGUgZmFkZUluLCBmYWRlT3V0IGFuZCBtb3ZlIGNoYXJhY3RlciBPUHNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0cmFuc2l0aW9uVGltZV89NTAwXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uVGltZV86IDUwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7c3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tY29udGVudCddLCBjbjogW119LFxuICAgICAgICAgICAge2NsczogWyduZW8tbWVhc3VyZS1lbGVtZW50LXdyYXBwZXInXSwgcmVtb3ZlRG9tOiB0cnVlLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1lYXN1cmUtZWxlbWVudCddLCBjbjpbXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IGNoYXJzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYXJzID0gW11cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gY2hhcnNWZG9tPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYXJzVmRvbSA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBjb250ZW50SGVpZ2h0PTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29udGVudEhlaWdodCA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbnRlbnRXaWR0aD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnRlbnRXaWR0aCA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbmRleD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGN1cnJlbnRJbmRleCA9IDBcbiAgICAvKipcbiAgICAgKiBXZSBkbyBub3QgbmVlZCB0aGUgZmlyc3QgZXZlbnQgdG8gdHJpZ2dlciBsb2dpYywgc2luY2UgYWZ0ZXJTZXRNb3VudGVkKCkgaGFuZGxlcyB0aGlzXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaW5pdGlhbFJlc2l6ZUV2ZW50PXRydWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdGlhbFJlc2l6ZUV2ZW50ID0gdHJ1ZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpbnRlcnZhbElkPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW50ZXJ2YWxJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIGdldHMgc2V0IHRvIHRydWUgd2hpbGUgdGhlIGFuaW1hdGVkIGNoYXIgdHJhbnNpdGlvbnMgYXJlIHJ1bm5pbmdcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1RyYW5zaXRpb25pbmc9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1lYXN1cmVDYWNoZT17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZWFzdXJlQ2FjaGUgPSB7fVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBwcmV2aW91c0NoYXJzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByZXZpb3VzQ2hhcnMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVhc3VyZUVsZW1lbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0IG1lYXN1cmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWFzdXJlV3JhcHBlci5jblswXVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1lYXN1cmVFbGVtZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldCBtZWFzdXJlV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblsxXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIHJlc2l6ZTogbWUub25SZXNpemUsXG4gICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBtb3VudGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFkZFJlc2l6ZU9ic2VydmVyKG1vdW50ZWQpIHtcbiAgICAgICAgbGV0IHtpZCwgd2luZG93SWR9ID0gdGhpcyxcbiAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyID0gYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIuZ2V0QWRkb24oJ1Jlc2l6ZU9ic2VydmVyJywgd2luZG93SWQpO1xuXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyW21vdW50ZWQgPyAncmVnaXN0ZXInIDogJ3VucmVnaXN0ZXInXSh7aWQsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFJlc2l6ZUV2ZW50ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdXRvQ3ljbGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvQ3ljbGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLnN0YXJ0QXV0b0N5Y2xlKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXV0b0N5Y2xlSW50ZXJ2YWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0N5Y2xlSW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICYmIG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKGZhbHNlKTtcbiAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZm9udEZhbWlseSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGb250RmFtaWx5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm1lYXN1cmVDYWNoZSA9IHt9O1xuXG4gICAgICAgIG1lLnZkb20uc3R5bGUuZm9udEZhbWlseSA9IHZhbHVlO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS5nZXREb21SZWN0KCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jb250ZW50SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbWUuY29udGVudFdpZHRoICA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUubWVhc3VyZUNhY2hlICA9IHt9O1xuICAgICAgICAgICAgbWUucHJldmlvdXNDaGFycyA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWUuYWRkUmVzaXplT2JzZXJ2ZXIodmFsdWUpO1xuXG4gICAgICAgICAgICBtZS5hdXRvQ3ljbGUgJiYgbWUuc3RhcnRBdXRvQ3ljbGUodmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge21lYXN1cmVFbGVtZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUucHJldmlvdXNDaGFycyA9IG1lLmNoYXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmNoYXJzID0gW107XG4gICAgICAgICAgICBtZWFzdXJlRWxlbWVudC5jbiA9IFtdO1xuXG4gICAgICAgICAgICB2YWx1ZT8uc3BsaXQoJycpLmZvckVhY2goY2hhciA9PiB7XG4gICAgICAgICAgICAgICAgbWUuY2hhcnMucHVzaCh7bmFtZTogY2hhcn0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBjaGFyID0gJyYjMzI7J1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50LmNuLnB1c2goe3RhZzogJ3NwYW4nLCBodG1sOiBjaGFyfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm1lYXN1cmVDaGFycygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnVwZGF0ZUNoYXJzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHJhbnNpdGlvblRpbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvblRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmRvbS5zdHlsZVsnLS1uZW8tdHJhbnNpdGlvbi10aW1lJ10gPSB2YWx1ZSArICdtcyc7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBsZXR0ZXJzXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFyc1Zkb20obGV0dGVycykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NoYXJzfSAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyID0gW10sXG4gICAgICAgICAgICBjaGFyO1xuXG4gICAgICAgIGxldHRlcnMuZm9yRWFjaCgobGV0dGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxldHRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYXIgPSBjaGFyc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICBjaGFyc0NvbnRhaW5lci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLWNoYXInXSxcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA6IGNoYXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtjb2xvcjogbWUuY29sb3JGYWRlSW4sIGxlZnQ6IGNoYXIubGVmdCwgb3BhY2l0eTogMCwgdG9wOiBjaGFyLnRvcH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnNDb250YWluZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3ljbGVUZXh0KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnRleHQgICAgICAgICA9IG1lLmN5Y2xlVGV4dHNbbWUuY3VycmVudEluZGV4XTtcbiAgICAgICAgbWUuY3VycmVudEluZGV4ID0gKG1lLmN1cnJlbnRJbmRleCArIDEpICUgbWUuY3ljbGVUZXh0cy5sZW5ndGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgbWVhc3VyZUNoYXJzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge21lYXN1cmVDYWNoZSwgbWVhc3VyZUVsZW1lbnQsIG1lYXN1cmVXcmFwcGVyLCB0ZXh0fSA9IG1lLFxuICAgICAgICAgICAgcGFyZW50UmVjdCwgcmVjdHM7XG5cbiAgICAgICAgaWYgKG1lYXN1cmVDYWNoZVt0ZXh0XSkge1xuICAgICAgICAgICAgcmVjdHMgICAgICA9IFsuLi5tZWFzdXJlQ2FjaGVbdGV4dF1dO1xuICAgICAgICAgICAgcGFyZW50UmVjdCA9IHJlY3RzLnNoaWZ0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lYXN1cmVXcmFwcGVyLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogbWUuY29udGVudEhlaWdodCArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggOiBtZS5jb250ZW50V2lkdGggICsgJ3B4J1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZGVsZXRlIG1lYXN1cmVXcmFwcGVyLnJlbW92ZURvbTtcblxuICAgICAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMCk7XG5cbiAgICAgICAgICAgIHJlY3RzICAgICAgPSBhd2FpdCBtZS5nZXREb21SZWN0KFttZWFzdXJlV3JhcHBlci5pZCwgLi4ubWVhc3VyZUVsZW1lbnQuY24ubWFwKG5vZGUgPT4gbm9kZS5pZCldKTtcbiAgICAgICAgICAgIHBhcmVudFJlY3QgPSByZWN0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgICBtZWFzdXJlQ2FjaGVbdGV4dF0gPSBbcGFyZW50UmVjdCwgLi4ucmVjdHNdXG4gICAgICAgIH1cblxuICAgICAgICByZWN0cy5mb3JFYWNoKChyZWN0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbWUuY2hhcnNbaW5kZXhdLmxlZnQgPSBgJHtyZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnR9cHhgO1xuICAgICAgICAgICAgbWUuY2hhcnNbaW5kZXhdLnRvcCAgPSBgJHtyZWN0LnRvcCAgLSBwYXJlbnRSZWN0LnRvcCB9cHhgO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZWFzdXJlV3JhcHBlci5yZW1vdmVEb20gPSB0cnVlO1xuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBvblJlc2l6ZSh7cmVjdH0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jb250ZW50SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIG1lLmNvbnRlbnRXaWR0aCAgPSByZWN0LndpZHRoO1xuXG4gICAgICAgIG1lLm1lYXN1cmVDYWNoZSA9IHt9O1xuXG5cbiAgICAgICAgaWYgKCFtZS5pbml0aWFsUmVzaXplRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghbWUuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUubWVhc3VyZUNoYXJzKCk7XG5cbiAgICAgICAgICAgICAgICBtZS5jaGFyc1Zkb20gPSBtZS5jcmVhdGVDaGFyc1Zkb20obWUuY2hhcnMubWFwKGNoYXIgPT4gY2hhci5uYW1lKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmluaXRpYWxSZXNpemVFdmVudCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc29ydENoYXJhY3RlcnMoYSwgYikge1xuICAgICAgICBsZXQgZGVsdGFUb3AgPSBwYXJzZUZsb2F0KGEuc3R5bGUudG9wKSAtIHBhcnNlRmxvYXQoYi5zdHlsZS50b3ApO1xuXG4gICAgICAgIGlmIChkZWx0YVRvcCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhVG9wXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhLnN0eWxlLmxlZnQpIC0gcGFyc2VGbG9hdChiLnN0eWxlLmxlZnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdGFydD10cnVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXJ0QXV0b0N5Y2xlKHN0YXJ0PXRydWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIG1lLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChtZS5jeWNsZVRleHQuYmluZChtZSksIG1lLmF1dG9DeWNsZUludGVydmFsKTtcblxuICAgICAgICAgICAgbWUudGltZW91dCgyMCkudGhlbigoKSA9PiB7bWUuY3ljbGVUZXh0KCl9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobWUuaW50ZXJ2YWxJZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVDaGFycygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NoYXJzLCBwcmV2aW91c0NoYXJzfSA9IG1lLFxuICAgICAgICAgICAgY2hhcnNDb250YWluZXIgICAgICAgICA9IG1lLnZkb20uY25bMF0sXG4gICAgICAgICAgICBsZXR0ZXJzICAgICAgICAgICAgICAgID0gY2hhcnMubWFwKGNoYXIgPT4gY2hhci5uYW1lKSxcbiAgICAgICAgICAgIGNoYXJOb2RlLCBpbmRleDtcblxuICAgICAgICBtZS5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG4gICAgICAgIGlmIChtZS5jaGFyc1Zkb20ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY2hhcnNDb250YWluZXIuY24gPSBtZS5jaGFyc1Zkb207XG4gICAgICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzQ2hhcnMuZm9yRWFjaCgocHJldmlvdXNDaGFyLCBwcmV2aW91c0luZGV4KSA9PiB7XG4gICAgICAgICAgICBpbmRleCA9IGxldHRlcnMuaW5kZXhPZihwcmV2aW91c0NoYXIubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUgPSBjaGFyc0NvbnRhaW5lci5jbltwcmV2aW91c0luZGV4XTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2hhck5vZGUuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IG1lLmNvbG9yTW92ZSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA6IGNoYXJzW2luZGV4XS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3AgIDogY2hhcnNbaW5kZXhdLnRvcFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGV0dGVyc1tpbmRleF0gPSBudWxsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlID0gY2hhcnNDb250YWluZXIuY25bcHJldmlvdXNJbmRleF07XG5cbiAgICAgICAgICAgICAgICBjaGFyTm9kZS5mbGFnID0gJ3JlbW92ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24ucHVzaCguLi5tZS5jcmVhdGVDaGFyc1Zkb20obGV0dGVycykpO1xuXG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5mb3JFYWNoKGNoYXJOb2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFyTm9kZS5mbGFnID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlLnN0eWxlLmNvbG9yICAgPSBtZS5jb2xvckZhZGVPdXQ7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUuc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoYXJOb2RlLnN0eWxlLm9wYWNpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KG1lLnRyYW5zaXRpb25UaW1lKTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5zb3J0KG1lLnNvcnRDaGFyYWN0ZXJzKTtcblxuICAgICAgICBpbmRleCA9IGNoYXJzQ29udGFpbmVyLmNuLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgZm9yICg7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgIGNoYXJOb2RlID0gY2hhcnNDb250YWluZXIuY25baW5kZXhdO1xuXG4gICAgICAgICAgICBkZWxldGUgY2hhck5vZGUuZmxhZztcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFyTm9kZS5zdHlsZS5jb2xvcjtcblxuICAgICAgICAgICAgaWYgKGNoYXJOb2RlLnN0eWxlLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKCk7XG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMjAwKTtcblxuICAgICAgICBtZS5jaGFyc1Zkb20gPSBbLi4uY2hhcnNDb250YWluZXIuY25dO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24ucHVzaCh7aHRtbDogbWUudGV4dH0pO1xuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKCk7XG5cbiAgICAgICAgbWUuaXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1hZ2ljTW92ZVRleHQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9