"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_MagicMoveText_mjs"],{

/***/ "./src/component/MagicMoveText.mjs":
/*!*****************************************!*\
  !*** ./src/component/MagicMoveText.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * Deeply inspired by https://github.com/yangshun 's video on LinkedIn
 * as well as Apple's Keynote Magic Move effect
 * @class Neo.component.MagicMoveText
 * @extends Neo.component.Base
 */
class MagicMoveText extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.MagicMoveText'
         * @protected
         */
        className: 'Neo.component.MagicMoveText',
        /**
         * @member {String} ntype='magic-move-text'
         * @protected
         */
        ntype: 'magic-move-text',
        /**
         * @member {Boolean} autoCycle_=true
         */
        autoCycle_: true,
        /**
         * @member {Number} autoCycleInterval_=2000
         */
        autoCycleInterval_: 2000,
        /**
         * @member {String[]} baseCls=['neo-magic-move-text']
         * @protected
         */
        baseCls: ['neo-magic-move-text'],
        /**
         * @member {String|null} colorMove=null
         */
        colorMove: null,
        /**
         * @member {String|null} colorFadeIn=null
         */
        colorFadeIn: null,
        /**
         * @member {String|null} colorFadeOut=null
         */
        colorFadeOut: null,
        /**
         * @member {String[]|null} cycleTexts=null
         */
        cycleTexts: null,
        /**
         * @member {String} fontFamily_='Helvetica Neue'
         */
        fontFamily_: 'Helvetica Neue',
        /**
         * @member {String} text_=null
         */
        text_: null,
        /**
         * Time in ms for the fadeIn, fadeOut and move character OPs
         * @member {Number} transitionTime_=500
         */
        transitionTime_: 500,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {style: {}, cn: [
            {cls: ['neo-content'], cn: []},
            {cls: ['neo-measure-element-wrapper'], removeDom: true, cn: [
                {cls: ['neo-measure-element'], cn:[]}
            ]}
        ]}
    }

    /**
     * @member {Object[]} chars=[]
     * @protected
     */
    chars = []
    /**
     * @member {Object[]} charsVdom=[]
     * @protected
     */
    charsVdom = []
    /**
     * @member {Number} contentHeight=0
     * @protected
     */
    contentHeight = 0
    /**
     * @member {Number} contentWidth=0
     * @protected
     */
    contentWidth = 0
    /**
     * @member {Number} currentIndex=0
     * @protected
     */
    currentIndex = 0
    /**
     * We do not need the first event to trigger logic, since afterSetMounted() handles this
     * @member {Boolean} initialResizeEvent=true
     * @protected
     */
    initialResizeEvent = true
    /**
     * @member {Number|null} intervalId=null
     * @protected
     */
    intervalId = null
    /**
     * Internal flag which gets set to true while the animated char transitions are running
     * @member {Boolean} isTransitioning=false
     * @protected
     */
    isTransitioning = false
    /**
     * @member {Object} measureCache={}
     * @protected
     */
    measureCache = {}
    /**
     * @member {Object[]} previousChars=[]
     * @protected
     */
    previousChars = []
    /**
     * @member {Object} measureElement
     * @protected
     */
    get measureElement() {
        return this.measureWrapper.cn[0]
    }
    /**
     * @member {Object} measureElement
     * @protected
     */
    get measureWrapper() {
        return this.vdom.cn[1]
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            resize: me.onResize,
            scope : me
        })
    }

    /**
     * @param {Boolean} mounted
     * @protected
     */
    async addResizeObserver(mounted) {
        let {id, windowId} = this,
            ResizeObserver = await Neo.currentWorker.getAddon('ResizeObserver', windowId);

        ResizeObserver[mounted ? 'register' : 'unregister']({id, windowId});

        if (mounted) {
            this.initialResizeEvent = true
        }
    }

    /**
     * Triggered after the autoCycle config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAutoCycle(value, oldValue) {
        this.mounted && this.startAutoCycle(value)
    }

    /**
     * Triggered after the autoCycleInterval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAutoCycleInterval(value, oldValue) {
        let me = this;

        if (oldValue && me.mounted) {
            me.startAutoCycle(false);
            me.startAutoCycle()
        }
    }

    /**
     * Triggered after the fontFamily config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetFontFamily(value, oldValue) {
        let me = this;

        me.measureCache = {};

        me.vdom.style.fontFamily = value;
        me.update()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value) {
            me.getDomRect().then(rect => {
                me.contentHeight = rect.height;
                me.contentWidth  = rect.width;
            })
        } else {
            me.measureCache  = {};
            me.previousChars = []
        }

        if(oldValue !== undefined) {
            me.addResizeObserver(value);

            me.autoCycle && me.startAutoCycle(value)
        }
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {Promise<void>}
     * @protected
     */
    async afterSetText(value, oldValue) {
        let me               = this,
            {measureElement} = me;

        if (oldValue) {
            me.previousChars = me.chars
        }

        if (value) {
            me.chars = [];
            measureElement.cn = [];

            value?.split('').forEach(char => {
                me.chars.push({name: char});

                if (char === ' ') {
                    char = '&#32;'
                }

                measureElement.cn.push({tag: 'span', html: char})
            });

            if (me.mounted) {
                await me.measureChars()
            }

            await me.updateChars()
        }
    }

    /**
     * Triggered after the transitionTime config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetTransitionTime(value, oldValue) {
        this.vdom.style['--neo-transition-time'] = value + 'ms';
        this.update()
    }

    /**
     * @param {String[]} letters
     * @returns {Object[]}
     * @protected
     */
    createCharsVdom(letters) {
        let me             = this,
            {chars}        = me,
            charsContainer = [],
            char;

        letters.forEach((letter, index) => {
            if (letter !== null) {
                char = chars[index];

                charsContainer.push({
                    cls  : ['neo-char'],
                    html : char.name,
                    style: {color: me.colorFadeIn, left: char.left, opacity: 0, top: char.top}
                })
            }
        });

        return charsContainer
    }

    /**
     * @protected
     */
    cycleText() {
        let me = this;

        me.text         = me.cycleTexts[me.currentIndex];
        me.currentIndex = (me.currentIndex + 1) % me.cycleTexts.length
    }

    /**
     * @returns {Promise<void>}
     * @protected
     */
    async measureChars() {
        let me = this,
            {measureCache, measureElement, measureWrapper, text} = me,
            parentRect, rects;

        if (measureCache[text]) {
            rects      = [...measureCache[text]];
            parentRect = rects.shift()
        } else {
            measureWrapper.style = {
                height: me.contentHeight + 'px',
                width : me.contentWidth  + 'px'
            };

            delete measureWrapper.removeDom;

            await me.promiseUpdate();
            await me.timeout(20);

            rects      = await me.getDomRect([measureWrapper.id, ...measureElement.cn.map(node => node.id)]);
            parentRect = rects.shift();

            measureCache[text] = [parentRect, ...rects]
        }

        rects.forEach((rect, index) => {
            me.chars[index].left = `${rect.left - parentRect.left}px`;
            me.chars[index].top  = `${rect.top  - parentRect.top }px`;
        });

        measureWrapper.removeDom = true;
        await me.promiseUpdate()
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     * @protected
     */
    async onResize({rect}) {
        let me = this;

        me.contentHeight = rect.height;
        me.contentWidth  = rect.width;

        me.measureCache = {};


        if (!me.initialResizeEvent) {
            if (!me.isTransitioning) {
                await me.measureChars();

                me.charsVdom = me.createCharsVdom(me.chars.map(char => char.name))
            }
        } else {
            me.initialResizeEvent = false
        }
    }

    /**
     * @param {Object} a
     * @param {Object} b
     * @returns {Number}
     * @protected
     */
    sortCharacters(a, b) {
        let deltaTop = parseFloat(a.style.top) - parseFloat(b.style.top);

        if (deltaTop !== 0) {
            return deltaTop
        }

        return parseFloat(a.style.left) - parseFloat(b.style.left)
    }

    /**
     * @param {Boolean} start=true
     * @protected
     */
    startAutoCycle(start=true) {
        let me = this;

        if (start) {
            me.intervalId = setInterval(me.cycleText.bind(me), me.autoCycleInterval);

            me.timeout(20).then(() => {me.cycleText()});
        } else {
            clearInterval(me.intervalId)
        }
    }

    /**
     * @returns {Promise<void>}
     * @protected
     */
    async updateChars() {
        let me                     = this,
            {chars, previousChars} = me,
            charsContainer         = me.vdom.cn[0],
            letters                = chars.map(char => char.name),
            charNode, index;

        me.isTransitioning = true;

        if (me.charsVdom.length > 1) {
            charsContainer.cn = me.charsVdom;
            await me.promiseUpdate()
        }

        previousChars.forEach((previousChar, previousIndex) => {
            index = letters.indexOf(previousChar.name);

            if (index > -1) {
                charNode = charsContainer.cn[previousIndex];

                Object.assign(charNode.style, {
                    color: me.colorMove,
                    left : chars[index].left,
                    top  : chars[index].top
                });

                letters[index] = null
            } else {
                charNode = charsContainer.cn[previousIndex];

                charNode.flag = 'remove'
            }
        });

        charsContainer.cn.push(...me.createCharsVdom(letters));

        await me.promiseUpdate();

        charsContainer.cn.forEach(charNode => {
            if (charNode.flag === 'remove') {
                charNode.style.color   = me.colorFadeOut;
                charNode.style.opacity = 0
            } else {
                delete charNode.style.opacity
            }
        });

        await me.promiseUpdate();
        await me.timeout(me.transitionTime);

        charsContainer.cn.sort(me.sortCharacters);

        index = charsContainer.cn.length - 1;

        for (; index >= 0; index--) {
            charNode = charsContainer.cn[index];

            delete charNode.flag;
            delete charNode.style.color;

            if (charNode.style.opacity === 0) {
                charsContainer.cn.splice(index, 1)
            }
        }

        await me.promiseUpdate();
        await me.timeout(200);

        me.charsVdom = [...charsContainer.cn];

        charsContainer.cn.length = 0;

        charsContainer.cn.push({html: me.text});
        await me.promiseUpdate();

        me.isTransitioning = false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MagicMoveText));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfTWFnaWNNb3ZlVGV4dF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyREFBUztBQUNyQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCLGFBQWEsNkJBQTZCO0FBQzFDLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNB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QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLGVBQWU7QUFDdEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsY0FBYztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9NYWdpY01vdmVUZXh0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogRGVlcGx5IGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS95YW5nc2h1biAncyB2aWRlbyBvbiBMaW5rZWRJblxuICogYXMgd2VsbCBhcyBBcHBsZSdzIEtleW5vdGUgTWFnaWMgTW92ZSBlZmZlY3RcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50Lk1hZ2ljTW92ZVRleHRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBNYWdpY01vdmVUZXh0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuTWFnaWNNb3ZlVGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5NYWdpY01vdmVUZXh0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21hZ2ljLW1vdmUtdGV4dCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdtYWdpYy1tb3ZlLXRleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0N5Y2xlXz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvQ3ljbGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhdXRvQ3ljbGVJbnRlcnZhbF89MjAwMFxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0N5Y2xlSW50ZXJ2YWxfOiAyMDAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tbWFnaWMtbW92ZS10ZXh0J11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tbWFnaWMtbW92ZS10ZXh0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29sb3JNb3ZlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yTW92ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb2xvckZhZGVJbj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvckZhZGVJbjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb2xvckZhZGVPdXQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGYWRlT3V0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118bnVsbH0gY3ljbGVUZXh0cz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjeWNsZVRleHRzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmb250RmFtaWx5Xz0nSGVsdmV0aWNhIE5ldWUnXG4gICAgICAgICAqL1xuICAgICAgICBmb250RmFtaWx5XzogJ0hlbHZldGljYSBOZXVlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGV4dF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIGluIG1zIGZvciB0aGUgZmFkZUluLCBmYWRlT3V0IGFuZCBtb3ZlIGNoYXJhY3RlciBPUHNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0cmFuc2l0aW9uVGltZV89NTAwXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2l0aW9uVGltZV86IDUwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7c3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tY29udGVudCddLCBjbjogW119LFxuICAgICAgICAgICAge2NsczogWyduZW8tbWVhc3VyZS1lbGVtZW50LXdyYXBwZXInXSwgcmVtb3ZlRG9tOiB0cnVlLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1lYXN1cmUtZWxlbWVudCddLCBjbjpbXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IGNoYXJzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYXJzID0gW11cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gY2hhcnNWZG9tPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYXJzVmRvbSA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBjb250ZW50SGVpZ2h0PTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29udGVudEhlaWdodCA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbnRlbnRXaWR0aD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnRlbnRXaWR0aCA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbmRleD0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGN1cnJlbnRJbmRleCA9IDBcbiAgICAvKipcbiAgICAgKiBXZSBkbyBub3QgbmVlZCB0aGUgZmlyc3QgZXZlbnQgdG8gdHJpZ2dlciBsb2dpYywgc2luY2UgYWZ0ZXJTZXRNb3VudGVkKCkgaGFuZGxlcyB0aGlzXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaW5pdGlhbFJlc2l6ZUV2ZW50PXRydWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdGlhbFJlc2l6ZUV2ZW50ID0gdHJ1ZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpbnRlcnZhbElkPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW50ZXJ2YWxJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIGdldHMgc2V0IHRvIHRydWUgd2hpbGUgdGhlIGFuaW1hdGVkIGNoYXIgdHJhbnNpdGlvbnMgYXJlIHJ1bm5pbmdcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1RyYW5zaXRpb25pbmc9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1lYXN1cmVDYWNoZT17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZWFzdXJlQ2FjaGUgPSB7fVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBwcmV2aW91c0NoYXJzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByZXZpb3VzQ2hhcnMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVhc3VyZUVsZW1lbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0IG1lYXN1cmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWFzdXJlV3JhcHBlci5jblswXVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1lYXN1cmVFbGVtZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldCBtZWFzdXJlV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblsxXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIHJlc2l6ZTogbWUub25SZXNpemUsXG4gICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBtb3VudGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFkZFJlc2l6ZU9ic2VydmVyKG1vdW50ZWQpIHtcbiAgICAgICAgbGV0IHtpZCwgd2luZG93SWR9ID0gdGhpcyxcbiAgICAgICAgICAgIFJlc2l6ZU9ic2VydmVyID0gYXdhaXQgTmVvLmN1cnJlbnRXb3JrZXIuZ2V0QWRkb24oJ1Jlc2l6ZU9ic2VydmVyJywgd2luZG93SWQpO1xuXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyW21vdW50ZWQgPyAncmVnaXN0ZXInIDogJ3VucmVnaXN0ZXInXSh7aWQsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFJlc2l6ZUV2ZW50ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhdXRvQ3ljbGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvQ3ljbGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLnN0YXJ0QXV0b0N5Y2xlKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXV0b0N5Y2xlSW50ZXJ2YWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0N5Y2xlSW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICYmIG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKGZhbHNlKTtcbiAgICAgICAgICAgIG1lLnN0YXJ0QXV0b0N5Y2xlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZm9udEZhbWlseSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGb250RmFtaWx5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm1lYXN1cmVDYWNoZSA9IHt9O1xuXG4gICAgICAgIG1lLnZkb20uc3R5bGUuZm9udEZhbWlseSA9IHZhbHVlO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS5nZXREb21SZWN0KCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jb250ZW50SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbWUuY29udGVudFdpZHRoICA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUubWVhc3VyZUNhY2hlICA9IHt9O1xuICAgICAgICAgICAgbWUucHJldmlvdXNDaGFycyA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICBpZihvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS5hZGRSZXNpemVPYnNlcnZlcih2YWx1ZSk7XG5cbiAgICAgICAgICAgIG1lLmF1dG9DeWNsZSAmJiBtZS5zdGFydEF1dG9DeWNsZSh2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bWVhc3VyZUVsZW1lbnR9ID0gbWU7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5wcmV2aW91c0NoYXJzID0gbWUuY2hhcnNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUuY2hhcnMgPSBbXTtcbiAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50LmNuID0gW107XG5cbiAgICAgICAgICAgIHZhbHVlPy5zcGxpdCgnJykuZm9yRWFjaChjaGFyID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jaGFycy5wdXNoKHtuYW1lOiBjaGFyfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPSAnJiMzMjsnXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWVhc3VyZUVsZW1lbnQuY24ucHVzaCh7dGFnOiAnc3BhbicsIGh0bWw6IGNoYXJ9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUubWVhc3VyZUNoYXJzKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgbWUudXBkYXRlQ2hhcnMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0cmFuc2l0aW9uVGltZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUcmFuc2l0aW9uVGltZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLnN0eWxlWyctLW5lby10cmFuc2l0aW9uLXRpbWUnXSA9IHZhbHVlICsgJ21zJztcbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGxldHRlcnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoYXJzVmRvbShsZXR0ZXJzKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2hhcnN9ICAgICAgICA9IG1lLFxuICAgICAgICAgICAgY2hhcnNDb250YWluZXIgPSBbXSxcbiAgICAgICAgICAgIGNoYXI7XG5cbiAgICAgICAgbGV0dGVycy5mb3JFYWNoKChsZXR0ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAobGV0dGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IGNoYXJzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjbHMgIDogWyduZW8tY2hhciddLFxuICAgICAgICAgICAgICAgICAgICBodG1sIDogY2hhci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge2NvbG9yOiBtZS5jb2xvckZhZGVJbiwgbGVmdDogY2hhci5sZWZ0LCBvcGFjaXR5OiAwLCB0b3A6IGNoYXIudG9wfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFyc0NvbnRhaW5lclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjeWNsZVRleHQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudGV4dCAgICAgICAgID0gbWUuY3ljbGVUZXh0c1ttZS5jdXJyZW50SW5kZXhdO1xuICAgICAgICBtZS5jdXJyZW50SW5kZXggPSAobWUuY3VycmVudEluZGV4ICsgMSkgJSBtZS5jeWNsZVRleHRzLmxlbmd0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBtZWFzdXJlQ2hhcnMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7bWVhc3VyZUNhY2hlLCBtZWFzdXJlRWxlbWVudCwgbWVhc3VyZVdyYXBwZXIsIHRleHR9ID0gbWUsXG4gICAgICAgICAgICBwYXJlbnRSZWN0LCByZWN0cztcblxuICAgICAgICBpZiAobWVhc3VyZUNhY2hlW3RleHRdKSB7XG4gICAgICAgICAgICByZWN0cyAgICAgID0gWy4uLm1lYXN1cmVDYWNoZVt0ZXh0XV07XG4gICAgICAgICAgICBwYXJlbnRSZWN0ID0gcmVjdHMuc2hpZnQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVhc3VyZVdyYXBwZXIuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtZS5jb250ZW50SGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IG1lLmNvbnRlbnRXaWR0aCAgKyAncHgnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkZWxldGUgbWVhc3VyZVdyYXBwZXIucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKCk7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwKTtcblxuICAgICAgICAgICAgcmVjdHMgICAgICA9IGF3YWl0IG1lLmdldERvbVJlY3QoW21lYXN1cmVXcmFwcGVyLmlkLCAuLi5tZWFzdXJlRWxlbWVudC5jbi5tYXAobm9kZSA9PiBub2RlLmlkKV0pO1xuICAgICAgICAgICAgcGFyZW50UmVjdCA9IHJlY3RzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIG1lYXN1cmVDYWNoZVt0ZXh0XSA9IFtwYXJlbnRSZWN0LCAuLi5yZWN0c11cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3RzLmZvckVhY2goKHJlY3QsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBtZS5jaGFyc1tpbmRleF0ubGVmdCA9IGAke3JlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdH1weGA7XG4gICAgICAgICAgICBtZS5jaGFyc1tpbmRleF0udG9wICA9IGAke3JlY3QudG9wICAtIHBhcmVudFJlY3QudG9wIH1weGA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lYXN1cmVXcmFwcGVyLnJlbW92ZURvbSA9IHRydWU7XG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIG9uUmVzaXplKHtyZWN0fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNvbnRlbnRIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgbWUuY29udGVudFdpZHRoICA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgbWUubWVhc3VyZUNhY2hlID0ge307XG5cblxuICAgICAgICBpZiAoIW1lLmluaXRpYWxSZXNpemVFdmVudCkge1xuICAgICAgICAgICAgaWYgKCFtZS5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5tZWFzdXJlQ2hhcnMoKTtcblxuICAgICAgICAgICAgICAgIG1lLmNoYXJzVmRvbSA9IG1lLmNyZWF0ZUNoYXJzVmRvbShtZS5jaGFycy5tYXAoY2hhciA9PiBjaGFyLm5hbWUpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuaW5pdGlhbFJlc2l6ZUV2ZW50ID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzb3J0Q2hhcmFjdGVycyhhLCBiKSB7XG4gICAgICAgIGxldCBkZWx0YVRvcCA9IHBhcnNlRmxvYXQoYS5zdHlsZS50b3ApIC0gcGFyc2VGbG9hdChiLnN0eWxlLnRvcCk7XG5cbiAgICAgICAgaWYgKGRlbHRhVG9wICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGFUb3BcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEuc3R5bGUubGVmdCkgLSBwYXJzZUZsb2F0KGIuc3R5bGUubGVmdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXJ0PXRydWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhcnRBdXRvQ3ljbGUoc3RhcnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgbWUuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKG1lLmN5Y2xlVGV4dC5iaW5kKG1lKSwgbWUuYXV0b0N5Y2xlSW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICBtZS50aW1lb3V0KDIwKS50aGVuKCgpID0+IHttZS5jeWNsZVRleHQoKX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChtZS5pbnRlcnZhbElkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUNoYXJzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2hhcnMsIHByZXZpb3VzQ2hhcnN9ID0gbWUsXG4gICAgICAgICAgICBjaGFyc0NvbnRhaW5lciAgICAgICAgID0gbWUudmRvbS5jblswXSxcbiAgICAgICAgICAgIGxldHRlcnMgICAgICAgICAgICAgICAgPSBjaGFycy5tYXAoY2hhciA9PiBjaGFyLm5hbWUpLFxuICAgICAgICAgICAgY2hhck5vZGUsIGluZGV4O1xuXG4gICAgICAgIG1lLmlzVHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKG1lLmNoYXJzVmRvbS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjaGFyc0NvbnRhaW5lci5jbiA9IG1lLmNoYXJzVmRvbTtcbiAgICAgICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNDaGFycy5mb3JFYWNoKChwcmV2aW91c0NoYXIsIHByZXZpb3VzSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGluZGV4ID0gbGV0dGVycy5pbmRleE9mKHByZXZpb3VzQ2hhci5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZSA9IGNoYXJzQ29udGFpbmVyLmNuW3ByZXZpb3VzSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjaGFyTm9kZS5zdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogbWUuY29sb3JNb3ZlLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0IDogY2hhcnNbaW5kZXhdLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgOiBjaGFyc1tpbmRleF0udG9wXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsZXR0ZXJzW2luZGV4XSA9IG51bGxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUgPSBjaGFyc0NvbnRhaW5lci5jbltwcmV2aW91c0luZGV4XTtcblxuICAgICAgICAgICAgICAgIGNoYXJOb2RlLmZsYWcgPSAncmVtb3ZlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5wdXNoKC4uLm1lLmNyZWF0ZUNoYXJzVmRvbShsZXR0ZXJzKSk7XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLmZvckVhY2goY2hhck5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYXJOb2RlLmZsYWcgPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUuc3R5bGUuY29sb3IgICA9IG1lLmNvbG9yRmFkZU91dDtcbiAgICAgICAgICAgICAgICBjaGFyTm9kZS5zdHlsZS5vcGFjaXR5ID0gMFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2hhck5vZGUuc3R5bGUub3BhY2l0eVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKCk7XG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQobWUudHJhbnNpdGlvblRpbWUpO1xuXG4gICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLnNvcnQobWUuc29ydENoYXJhY3RlcnMpO1xuXG4gICAgICAgIGluZGV4ID0gY2hhcnNDb250YWluZXIuY24ubGVuZ3RoIC0gMTtcblxuICAgICAgICBmb3IgKDsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgICAgICAgY2hhck5vZGUgPSBjaGFyc0NvbnRhaW5lci5jbltpbmRleF07XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjaGFyTm9kZS5mbGFnO1xuICAgICAgICAgICAgZGVsZXRlIGNoYXJOb2RlLnN0eWxlLmNvbG9yO1xuXG4gICAgICAgICAgICBpZiAoY2hhck5vZGUuc3R5bGUub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLmNuLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMDApO1xuXG4gICAgICAgIG1lLmNoYXJzVmRvbSA9IFsuLi5jaGFyc0NvbnRhaW5lci5jbl07XG5cbiAgICAgICAgY2hhcnNDb250YWluZXIuY24ubGVuZ3RoID0gMDtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5jbi5wdXNoKHtodG1sOiBtZS50ZXh0fSk7XG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcblxuICAgICAgICBtZS5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFnaWNNb3ZlVGV4dCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=