export const __webpack_esm_id__ = "vendors-src_container_Base_mjs";
export const __webpack_esm_ids__ = ["vendors-src_container_Base_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/container/Base.mjs"
/*!********************************!*\
  !*** ./src/container/Base.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _layout_Card_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layout/Card.mjs */ "./src/layout/Card.mjs");
/* harmony import */ var _layout_Fit_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layout/Fit.mjs */ "./src/layout/Fit.mjs");
/* harmony import */ var _layout_Grid_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layout/Grid.mjs */ "./src/layout/Grid.mjs");
/* harmony import */ var _layout_HBox_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layout/HBox.mjs */ "./src/layout/HBox.mjs");
/* harmony import */ var _layout_VBox_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layout/VBox.mjs */ "./src/layout/VBox.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");











const byWeight = ({ weight : lhs = 0 }, { weight : rhs = 0 }) => lhs - rhs;

/**
 * @class Neo.container.Base
 * @extends Neo.component.Base
 */
class Container extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Base'
         * @protected
         */
        className: 'Neo.container.Base',
        /**
         * @member {String} ntype='container'
         * @protected
         */
        ntype: 'container',
        /**
         * @member {String[]} baseCls=['neo-container']
         */
        baseCls: ['neo-container'],
        /**
         * @member {Boolean} dragResortable_=false
         * @reactive
         */
        dragResortable_: false,
        /**
         * Default configuration for child items within this container.
         * This config uses a descriptor to enable deep merging with instance based itemDefaults.
         * @member {Object} itemDefaults_={[isDescriptor]: true, merge: 'deep', value: null}
         * @reactive
         */
        itemDefaults_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * An array or an object of config objects|instances|modules for each child component
         * @member {Object[]} items_=[]
         * @example
         * import Button      from '../button/Base.mjs';
         * import Toolbar     from '../toolbar/Base.mjs';
         *
         * let myButton = Neo.create(Button, {
         *     text: 'Button1'
         * });
         *
         * Neo.create(Toolbar, {
         *     //...
         *     items: {
         *         buttonRef : {
         *             ntype: 'button',   // by ntype
         *             text : 'Button 2'
         *         },
         *         secondRef : {
         *             module: Button,    // by imported module
         *             text  : 'Button 3'
         *         }
         *     }
         * });
         *
         * or
         * @example
         * import Button      from '../button/Base.mjs';
         * import MyRedButton from 'myapp/MyRedButton.mjs';
         * import Toolbar     from '../toolbar/Base.mjs';
         *
         * let myButton = Neo.create(Button, {
         *     text: 'Button1'
         * });
         *
         * Neo.create(Toolbar, {
         *     //...
         *     items: [
         *         myButton,              // passed instance
         *         {
         *             ntype: 'button',   // by ntype
         *             text : 'Button 2'
         *         },
         *         {
         *             module: Button,    // by imported module
         *             text  : 'Button 3'
         *         },
         *         MyRedButton            // you can drop imported modules directly into the items array
         *     ]
         * });
         * @reactive
         */
        items_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__.isDescriptor]: true,
            clone         : 'shallow',
            cloneOnGet    : 'none',
            isEqual       : () => false,
            value         : []
        },
        /**
         * @member {Object|String|null} layout_={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        layout_: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Neo.draggable.container.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {String} sortZoneCls='Neo.draggable.container.SortZone'
         */
        sortZoneCls: 'Neo.draggable.container.SortZone',
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null,
        /**
         * @member {Object} _vdom={cn: []}
         */
        _vdom:
        {cn: []}
    }

    /**
     * Inserts an item or array of items at the last index
     * @param {Object|Array} item
     * @param {Boolean} [silent=false]
     * @param {Boolean} [removeFromPreviousParent=true]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    add(item, silent=false, removeFromPreviousParent=true) {
        let me = this;
        return me.insert(me.items ? me.items.length : 0, item, silent, removeFromPreviousParent)
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        let me = this;

        super.afterSetAppName(value, oldValue);

        if (value && me.items) {
            me.items.forEach(item => {
                if (!Neo.isString(item)) {
                    item.appName = value
                }
            })
        }

        if (value && me.layout) {
            me.layout.appName = value
        }

        if (me.sortZone) {
            me.sortZone.appName = value
        }
    }

    /**
     * @param {Neo.layout.Base|null} value
     * @param {Neo.layout.Base|null} oldValue
     * @protected
     */
    afterSetLayout(value, oldValue) {
        let me = this;

        if (me.vnodeInitialized) {
            oldValue?.removeRenderAttributes();
            value?.applyRenderAttributes();

            me.items.forEach((item, index) => {
                oldValue?.removeChildAttributes(item, index);
                value?.applyChildAttributes(item, index)
            })
        }

        oldValue?.destroy?.()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            super.afterSetMounted(value, oldValue);

            for (let i = 0, {items} = this, {length} = items; i < length; i++) {
                if (!items[i].vdom.removeDom) {
                    items[i].mounted = value
                }
            }
        }
    }

    /**
     * Triggered after the needsVdomUpdate config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetNeedsVdomUpdate(value, oldValue) {
        if (!value) {
            this.items?.forEach(item => {
                // check for e.g. Toolbar items like '->'
                if (typeof item !== 'string') {
                    // we can not set the config directly => it could already be false,
                    // and we still want to pass it further into subtrees
                    item._needsVdomUpdate = false;
                    item.afterSetNeedsVdomUpdate?.(false, true)
                }
            })
        }
    }

    /**
     * Triggered after the vnodeInitializing config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsVnodeInitializing(value, oldValue) {
        if (oldValue !== undefined) {
            let {items} = this,
                i       = 0,
                len     = items.length;

            for (; i < len; i++) {
                if (!items[i].vdom.removeDom) {
                    items[i].isVnodeInitializing = value
                }
            }
        }
    }

    /**
     * Triggered after the dragResortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetDragResortable(value, oldValue) {
        let me = this,
            module;

        if (value && !me.sortZone) {
            if (me.sortZoneConfig?.module) {
                module = me.sortZoneConfig.module;

                if (!me.isConstructed) {
                    await Promise.resolve()
                }
            } else {
                module = await me.loadSortZoneModule();
                module = module.default
            }

            me.createSortZone(Neo.merge({
                module,
                appName            : me.appName,
                boundaryContainerId: me.id,
                owner              : me,
                windowId           : me.windowId
            }, me.sortZoneConfig))
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        value && this.items?.forEach(item => {
            if (!Neo.isString(item)) {
                item.theme = value
            }
        })
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let me       = this,
            {layout} = me;

        value && me.items?.forEach(item => {
            if (!Neo.isString(item)) {
                item.windowId = value
            }
        })

        if (value && layout && !Neo.isString(layout)) {
            layout.windowId = value
        }

        if (me.sortZone) {
            me.sortZone.windowId = value
        }
    }

    /**
     * Convert items object to an array for onward storage as _items
     * @param {Object|Object[]} value
     * @param {Object|Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
     beforeSetItems(value, oldValue) {
        if (Neo.typeOf(value) === 'Object') {
            let result = [],
                hasWeight, item;

            for (const ref in value) {
                item = value[ref]

                item.reference = ref;
                result.push(item);
                hasWeight ||= ('weight' in item)
            }

            if (hasWeight) {
                result.sort(byWeight)
            }

            value = result
        }

        return value
    }

    /**
     * @param {Object|String} value
     * @param {Object|String|Neo.layout.Base} oldValue
     * @returns {Neo.layout.Base}
     * @protected
     */
    beforeSetLayout(value, oldValue) {
        return this.createLayout(value)
    }

    /**
     * @param {*} item
     * @param {Number} index
     * @param {Boolean} [removeFromPreviousParent=true]
     * @returns {Neo.component.Base|Object} Object for lazy loaded items
     */
    createItem(item, index, removeFromPreviousParent=true) {
        let me       = this,
            config   = {appName: me.appName, parentId: me.id, parentIndex: index, windowId: me.windowId},
            defaults = {...me.itemDefaults},
            lazyLoadItem, module, parent;

        if (defaults) {
            if (item.module) {
                delete defaults.ntype;
            }

            if (item.ntype) {
                delete defaults.module;
            }
        }

        switch (Neo.typeOf(item)) {
            case 'NeoClass': {
                item = Neo.create({
                    theme: item.config.theme || me.theme,
                    ...defaults,
                    module: item,
                    ...config
                });
                break
            }

            case 'NeoInstance': {
                parent = item.parent;

                if (parent && parent !== me) {
                    if (removeFromPreviousParent) {
                        parent.remove?.(item, false);
                        delete item.vdom.removeDom
                    }

                    if (parent.windowId !== me.windowId) {
                        // In case we are duplicating vdom into a different browser window, we need a silent
                        // _mounted update to ensure that afterSetMounted() still gets triggered.
                        item[removeFromPreviousParent ? 'mounted' : '_mounted'] = false
                    }

                    // Convenience logic, especially for moving components into different browser windows:
                    // A component might rely on references & handler methods inside the previous controller realm
                    // todo: We need ?. until functional.component.Base supports controllers
                    if (!item.controller && !me.getController() && parent.getController?.()) {
                        item.controller = {parent: parent.getController()}
                    }
                }

                item.set(config);
                item.getStateProvider?.()?.createBindings(item);
                break
            }

            case 'Object': {
                if (defaults) {
                    Neo.assignDefaults(item, defaults)
                }

                if (!item.module && !item.ntype && !item.className) {
                    item.module = _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
                }

                module = item.module;

                lazyLoadItem = module && !module.isClass && Neo.isFunction(module);

                if (module && !lazyLoadItem) {
                    item.className = module.prototype.className;
                    item.theme     = defaults.theme || module.config.theme || me.theme
                }

                if (item.handlerScope === 'this') {
                    item.handlerScope = me;

                    if (Neo.typeOf(item.handler) === 'String' && Neo.typeOf(me[item.handler]) === 'Function') {
                        item.handler = me[item.handler]
                    }
                }

                Object.assign(item, config);

                if (!lazyLoadItem) {
                    item = Neo[item.className ? 'create' : 'ntype'](item)
                } else {
                    item.vdom = Object.assign(item.vdom || {}, {removeDom: true})
                }

                break
            }

            case 'String': {
                item = Neo.create({
                    module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                    vdom  : {text: item},
                    ...config
                });

                break
            }
        }

        return item
    }

    /**
     * @protected
     */
    createItems() {
        let me        = this,
            items     = me._items,
            itemsRoot = me.getVdomItemsRoot(),
            {layout}  = me,
            vdom;

        itemsRoot.cn = [];

        items.forEach((item, index) => {
            items[index] = item = me.createItem(item, index);

            if (item instanceof Neo.core.Base) {
                layout?.applyChildAttributes(item, index);
                vdom = item.createVdomReference()
            } else {
                vdom = item.vdom
            }

            itemsRoot.cn.push(vdom)
        });

        // We need to add items into the vdom
        me.updateDepth = -1;
        me.isConstructed && me.update();

        me.fire('itemsCreated', {id: me.id, items})
    }

    /**
     * @param {Object|String|Neo.layout.Base} value
     * @protected
     * @returns {Neo.layout.Base}
     */
    createLayout(value) {
        if (value) {
            let me                      = this,
                {appName, id, windowId} = me;

            if (value instanceof _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] && value.isLayout) {
                Object.assign(value, {appName, containerId: id, windowId})
            } else {
                value = me.parseLayoutClass(value);
                Object.assign(value, {appName, containerId: id, windowId});
                value = Neo.ntype(value)
            }
        }

        return value
    }

    /**
     * @param {Object} config
     */
    createSortZone(config) {
        this.sortZone = Neo.create(config)
    }

    /**
     * Destroys all components inside this.items before the super() call.
     * @param {Boolean} [updateParentVdom=false] true to remove the component from the parent vdom => real dom
     * @param {Boolean} [silent=false] true to update the vdom silently (useful for destroying multiple child items in a row)
     */
    destroy(updateParentVdom=false, silent=false) {
        this.layout?.destroy();

        this.items?.forEach(item => {
            item.destroy?.(false, true)
        });

        super.destroy(updateParentVdom, silent)
    }

    /**
     * An alternative for `getReference()` which is useful before a component tree got created.
     * `getReference()` relies on child items being registered inside `manager.Component`,
     * while this method simply walks down the items array.
     *
     * However, classes / modules inside the items tree can not get parsed further.
     * @param {String} reference
     * @param {Object[]} items=this.items
     * @returns {Object|Neo.component.Base|null}
     */
    getItem(reference, items=this.items) {
        let i   = 0,
            len = items.length,
            childItem, item;

        for (; i < len; i++) {
            item = items[i];
            if (item.reference === reference) {
                return item
            } else if (item.items) {
                childItem = this.getItem(reference, item.items);

                if (childItem) {
                    return childItem
                }
            }
        }

        return null
    }

    /**
     * Specify a different vdom items root if needed (useful in case this container uses a wrapper node).
     * @returns {Object} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.getVdomRoot()
    }

    /**
     * Finds the index of a direct child component inside this.items.
     * @param {Neo.component.Base|String} itemId Either the item reference or the item id
     * @returns {Number} -1 in case no match was found
     */
    indexOf(itemId) {
        let me  = this,
            i   = 0,
            len = me.items?.length || 0;

        if (!Neo.isString(itemId)) {
            itemId = itemId.id;
        }

        for (; i < len; i++) {
            if (me.items[i].id === itemId) {
                return i
            }
        }

        return -1
    }

    /**
     * Inserts an item or array of items at a specific index.
     *
     * **Atomic Moves:**
     * If the `item` is an existing `Neo.component.Base` instance that already has a parent container
     * within the same browser window, this method performs an **atomic move**.
     * 1. The item is silently removed from its old parent (without triggering a DOM removal).
     * 2. The item is inserted into this container.
     * 3. This container updates, sending an `insertNode` delta.
     * 4. The `DeltaUpdates` system detects the existing DOM node and moves it physically, preserving
     *    DOM state such as focus, input values, and iframe content.
     *
     * @param {Number} index
     * @param {Array|Object|Neo.component.Base} item
     * @param {Boolean} [silent=false]
     * @param {Boolean} [removeFromPreviousParent=true]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false, removeFromPreviousParent=true) {
        let me          = this,
            {items}     = me,
            lca         = null,
            i, itemParent, itemType, len, oldParent, parentsA, parentsB, returnArray;

        if (Array.isArray(item)) {
            i           = 0;
            len         = item.length;
            returnArray = [];

            for (; i < len; i++) {
                // insert the array backwards
                returnArray.unshift(me.insert(index, item[len - 1 - i], true, removeFromPreviousParent))
            }

            item = returnArray
        } else {
            itemType = Neo.typeOf(item);

            if (itemType === 'NeoInstance') {
                itemParent = item.parent;

                if (itemParent === me && items.indexOf(item) === index) {
                    return item
                }

                if (itemParent && itemParent !== me && removeFromPreviousParent) {
                    oldParent = itemParent;

                    if (oldParent.windowId === me.windowId) {
                        parentsA = [me,        ...me.getParents()];
                        parentsB = [oldParent, ...oldParent.getParents()];

                        lca = parentsA.find(p => parentsB.includes(p))
                    }

                    if (lca) {
                        oldParent.remove(item, false, true, true);
                        removeFromPreviousParent = false
                    }
                }
            }

            item = me.createItem(item, index, removeFromPreviousParent);

            // added the true param => for card layouts, we do not want a dynamically inserted cmp to get removed right away
            // since it will most likely get activated right away
            me.layout?.applyChildAttributes(item, index, true);

            items.splice(index, 0, item);

            me.items = items;

            me.getVdomItemsRoot().cn.splice(index, 0, item.createVdomReference())
        }

        if (!silent) {
            (lca || me).updateDepth = -1; // pass the full vdom tree to honor new nested component trees

            (lca || me).promiseUpdate().then(() => {
                me.fire('insert', {index, item})
            })
        }

        return item;
    }

    /**
     * Load items from a remote endpoint.
     * See: https://github.com/neomjs/neo/tree/dev/examples/serverside
     * The response should return a JSON file in the following format:
     * {"modules": [], "items": []}
     * See: https://github.com/neomjs/neo/blob/dev/examples/serverside/gridContainer/resources/data/grid-container.json
     * It is important to add modules which are not already imported inside your app yet.
     * @param {Object} data
     * @param {Object} [data.options={}]
     * @param {String} data.url
     * @returns {Promise<Object[]>}
     */
    async loadItems({options={}, url}) {
        let me         = this,
            response   = await me.trap(fetch(url, options)),
            remoteData = await me.trap(response.json());

        if (remoteData.modules?.length > 0) {
            await me.trap(Promise.all(remoteData.modules.map(modulePath => {
                // Adjust relative URLs
                if (!modulePath.startsWith('http')) {
                    modulePath = (Neo.config.environment === 'development' ? '../../' : '../../../../') + modulePath
                }

                return import(/* webpackIgnore: true */ modulePath)
            })))
        }

        return remoteData.items
    }

    /**
     * @returns {Promise<any>}
     */
    loadSortZoneModule() {
        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-_ef4c0")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/container/SortZone.mjs */ "./src/draggable/container/SortZone.mjs"))
    }

    /**
     *
     */
    mergeConfig(...args) {
        let me     = this,
            config = super.mergeConfig(...args),
            ctorItems;

        // Avoid any interference on prototype level
        // Does not clone existing Neo instances
        if (config.items) {
            ctorItems = me.constructor.config.items;

            // If we are passed an object, merge the class's own items object into it
            if (Neo.typeOf(config.items) === 'Object') {
                if (Neo.isArray(ctorItems)) {
                    me.items = Neo.clone(config.items, true, true)
                } else {
                    me.items = Neo.merge(Neo.clone(ctorItems), config.items)
                }
            } else {
                me._items = Neo.clone(config.items, true, true)
            }
            delete config.items
        }

        return config
    }

    /**
     * Moves an existing item to a new index
     * @param {Number} fromIndex
     * @param {Number} toIndex
     * @returns {Neo.component.Base}
     */
    moveTo(fromIndex, toIndex) {
        let me   = this,
            item = me.items[fromIndex];

        fromIndex !== toIndex && me.switchItems(toIndex, fromIndex);

        return item
    }

    /**
     *
     */
    onConstructed() {
        let me           = this,
            layoutConfig = me.layout;

        // If the layout is a config object (not an instance), deep clone it
        // to prevent prototype pollution.
        if (layoutConfig && !(layoutConfig instanceof _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            layoutConfig = Neo.clone(layoutConfig, true)
        }

        // in case the Container does not have a layout config, the setter won't trigger
        me._layout = me.createLayout(layoutConfig);
        me._layout?.applyRenderAttributes();

        super.onConstructed();

        me.parseItemConfigs(me._items);
        me.createItems()
    }

    /**
     * @param {Object|String} config
     * @protected
     * @returns {Object} layoutConfig
     */
    parseLayoutClass(config) {
        if (Neo.isObject(config)) {
            if (!config.ntype.startsWith('layout-')) {
                config.ntype = `layout-${config.ntype}`
            }
        } else {
            config = {
                ntype: config.startsWith('layout-') ? config : `layout-${config}`
            }
        }

        return config
    }

    /**
     * Removes a container item by reference
     * @param {Neo.component.Base} component
     * @param {Boolean} [destroyItem=true]
     * @param {Boolean} [silent=false]
     * @param {Boolean} [keepMounted=false]
     * @returns {Neo.component.Base|null}
     */
    remove(component, destroyItem=true, silent=false, keepMounted=false) {
        let items = [...this.items],
            i     = 0,
            len   = items.length;

        for (; i < len; i++) {
            if (items[i].id === component.id) {
                return this.removeAt(i, destroyItem, silent, keepMounted)
            }
        }
    }

    /**
     * Clears the item array
     * @param {Boolean} destroyItems=true
     * @param {Boolean} silent=false
     */
    removeAll(destroyItems=true, silent=false) {
        let me = this;

        me.items.forEach(item => {
            if (destroyItems) {
                item.destroy(true, true)
            } else {
                item.mounted = false
            }
        });

        me.items = [];

        me.getVdomItemsRoot().cn = [];

        if (!silent || destroyItems) {
            me.update()
        }
    }

    /**
     * Removes a container item at a given index.
     *
     * @param {Number} index
     * @param {Boolean} destroyItem=true
     * @param {Boolean} silent=false
     * @param {Boolean} keepMounted=false Set to `true` to keep the item's `mounted` state as `true`.
     * This is critical for **Atomic Moves**, where the item is removed from one container and immediately added
     * to another, and we do not want to trigger unmount lifecycle hooks in between.
     * @returns {Neo.component.Base|null}
     */
    removeAt(index, destroyItem=true, silent=false, keepMounted=false) {
        let me      = this,
            {items} = me,
            item;

        if (index >= items.length) {
            Neo.warn('Container.removeAt: index >= items.length. ' + me.id)
        } else {
            item = items[index];

            items.splice(index, 1);

            me.getVdomItemsRoot().cn.splice(index, 1);

            // the next update cycle needs to include direct children
            me.updateDepth = 2;

            !silent && me.update();

            if (destroyItem) {
                item.destroy(true, silent);
                return null
            } else {
                me.layout?.removeChildAttributes(item);
                if (!keepMounted) {
                    item.mounted = false
                }
                return item
            }
        }
    }

    /**
     * Removes the container item at the last index
     * @param {Boolean} [destroyItem=true]
     * @param {Boolean} [silent=false]
     */
    removeLast(destroyItem=true, silent=false) {
        this.removeAt(this.items.length - 1, destroyItem, silent)
    }

    /**
     * Replaces a container item at a given index
     * @param {Number} index
     * @param {Neo.component.Base} item
     * @param {Boolean} destroyItem=true
     * @param {Boolean} silent=false
     */
    replaceAt(index, item, destroyItem=true, silent=false) {
        this.removeAt(index, destroyItem, true);
        this.insert(index, item, silent)
    }

    /**
     * Switches the position of 2 direct child items
     * You can either pass an index (Number) or id (String)
     * @param {Number|String} item1id
     * @param {Number|String} item2id
     */
    switchItems(item1id, item2id) {
        let me         = this,
            item1Index = Neo.isNumber(item1id) ? item1id : me.indexOf(item1id),
            item2Index = Neo.isNumber(item2id) ? item2id : me.indexOf(item2id);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].move(me.items,                 item2Index, item1Index);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].move(me.getVdomItemsRoot().cn, item2Index, item1Index);

        // the next update cycle needs to include direct children
        me.updateDepth = 2;

        me.update()
    }

    /**
     * Serializes the container into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            dragResortable: me.dragResortable,
            itemCount     : me.items?.length || 0,
            itemDefaults  : me.itemDefaults,
            items         : me.items?.map(item => {
                const itemType = Neo.typeOf(item);

                if (itemType === 'NeoInstance') {
                    return item.id
                }

                if (itemType === 'Object') {
                    if (Neo.isFunction(item.module) && !item.module.isClass) {
                        return {
                            ...item,
                            module: item.module.toString()
                        }
                    }
                }

                return me.serializeConfig(item)
            }),
            layout: me.layout?.toJSON()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ },

/***/ "./src/layout/Base.mjs"
/*!*****************************!*\
  !*** ./src/layout/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * The base class for all other layouts.
 * Use it directly in case you want to create a container without a layout.
 * @class Neo.layout.Base
 * @extends Neo.core.Base
 */
class Layout extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Base'
         * @protected
         */
        className: 'Neo.layout.Base',
        /**
         * @member {String} ntype='layout-base'
         * @protected
         */
        ntype: 'layout-base',
        /**
         * The name of the App this layout belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * The id of the Container instance this layout is bound to
         * @member {?String} containerId=null
         * @protected
         */
        containerId: null,
        /**
         * A layout specific CSS selector which gets added to Container the layout is bound to.
         * @member {String|null} containerCls_=null
         * @protected
         * @reactive
         */
        containerCls_: null,
        /**
         * Identifier for all classes that extend layout.Base
         * @member {Boolean} isLayout=true
         * @protected
         */
        isLayout: true,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @returns {Neo.container.Base|null}
     */
    get container() {
        let {containerId} = this;

        // the instance might not be registered yet
        return Neo.getComponent(containerId) || Neo.get(containerId)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Placeholder method
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    applyChildAttributes(item, index) {}

    /**
     * @param {Boolean} silent=false
     * @protected
     */
    applyRenderAttributes(silent=false) {
        let me                        = this,
            {container, containerCls} = me,
            {wrapperCls}              = container;

        if (containerCls) {
            if (!container) {
                Neo.logError(me.className + ': applyRenderAttributes -> container not yet created', me.containerId)
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, containerCls);

            container[silent ? 'setSilent' :  'set']({wrapperCls})
        }
    }

    /**
     *
     */
    destroy() {
        let me = this;

        me.bind && me.getStateProvider()?.removeBindings(me.id);

        super.destroy()
    }

    /**
     * Returns the container stateProvider or its closest parent stateProvider
     * @param {String} [ntype]
     * @returns {Neo.state.Provider|null}
     */
    getStateProvider(ntype) {
        return this.container.getStateProvider(ntype)
    }

    /**
     * Applies all class configs to this instance
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     */
    initConfig(config, preventOriginalConfig) {
        super.initConfig(config, preventOriginalConfig);

        let me = this;

        me.bind && me.container.getStateProvider()?.createBindings(me)
    }

    /**
     * Placeholder method
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    removeChildAttributes(item, index) {}

    /**
     * @protected
     */
    removeRenderAttributes() {
        let me                        = this,
            {container, containerCls} = me,
            {wrapperCls}              = container;

        if (containerCls) {
            if (!container) {
                Neo.logError(me.className + ': removeRenderAttributes -> container not yet created', me.containerId)
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, containerCls);

            container.wrapperCls = wrapperCls
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} silent=false
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        let me          = this,
            {container} = me;

        container.silentVdomUpdate = true;

        super.set(values);

        container.silentVdomUpdate = false;

        if (silent || !container.needsVdomUpdate) {
            return Promise.resolve()
        } else {
            return container.promiseUpdate()
        }
    }

    /**
     * Convenience shortcut calling set() with the silent flag
     * @param {Object} values={}
     */
    setSilent(values={}) {
        return this.set(values, true)
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            appName     : me.appName,
            containerCls: me.containerCls,
            containerId : me.containerId,
            windowId    : me.windowId
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Layout));


/***/ },

/***/ "./src/layout/Card.mjs"
/*!*****************************!*\
  !*** ./src/layout/Card.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Card
 * @extends Neo.layout.Base
 */
class Card extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /*
     * The name of the CSS class for an active item inside the card layout
     * @member {String} activeItemCls='neo-active-item'
     * @static
     */
    static activeItemCls = 'neo-active-item'
    /*
     * The name of the CSS class for an inactive item inside the card layout
     * @member {String} inactiveItemCls='neo-inactive-item'
     * @static
     */
    static inactiveItemCls = 'neo-inactive-item'
    /*
     * The name of the CSS class for an item inside the card layout
     * @member itemCls
     * @static
     */
    static itemCls = 'neo-layout-card-item'
    /**
     * Valid values for slideDirection
     * @member {String[]} iconPositions=['horizontal','vertical',null]
     * @protected
     * @static
     */
    static slideDirections = ['horizontal', 'vertical', null]

    static config = {
        /**
         * @member {String} className='Neo.layout.Card'
         * @protected
         */
        className: 'Neo.layout.Card',
        /**
         * @member {String} ntype='layout-card'
         * @protected
         */
        ntype: 'layout-card',
        /*
         * The item index of the card, which is currently active.
         * Change this value to activate a different card.
         * @member {Number} activeIndex_=0
         */
        activeIndex_: 0,
        /**
         * @member {String|null} containerCls='neo-layout-card'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-card',
        /*
         * Remove the DOM of inactive cards.
         * This will keep the instances & vdom trees
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /*
         * Valid values: 'horizontal', 'vertical', null
         * @member {String|null} slideDirection_=null
         */
        slideDirection_: null
    }

    /**
     * Modifies the CSS classes of the container items this layout is bound to.
     * Automatically gets triggered after changing the value of activeIndex.
     * Lazy loads items which use a module config containing a function.
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    async afterSetActiveIndex(value, oldValue) {
        let me              = this,
            {container, removeInactiveCards} = me,
            sCfg            = me.constructor,
            needsTransition = me.slideDirection && oldValue !== undefined,
            needsUpdate     = false,
            i, isActiveIndex, item, items, len, module, wrapperCls;

        if (Neo.isNumber(value) && container) {
            items = container.items;
            len   = items.length;

            if (!items[value]) {
                Neo.error('Trying to activate a non existing card', value, items)
            }

            // we need to run the loop twice, since lazy loading a module at a higher index does affect lower indexes
            for (i=0; i < len; i++) {
                module = items[i].module;

                if (i === value && Neo.typeOf(module) === 'Function') {
                    needsUpdate = true;
                    break
                }
            }

            for (i=0; i < len; i++) {
                isActiveIndex = i === value;
                item          = items[i];
                module        = item.module;

                if (isActiveIndex && Neo.typeOf(module) === 'Function') {
                    item = await me.loadModule(item, i)
                }

                if (item instanceof Neo.component.Base) {
                    wrapperCls = item.wrapperCls;

                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, isActiveIndex ? sCfg.inactiveItemCls : sCfg.activeItemCls);
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(   wrapperCls, isActiveIndex ? sCfg.activeItemCls   : sCfg.inactiveItemCls);

                    if (removeInactiveCards || needsUpdate) {
                        if (isActiveIndex) {
                            delete item.vdom.removeDom;
                            !needsTransition && item.activate?.()
                        } else if (removeInactiveCards) {
                            item.mounted        = false;
                            item.vdom.removeDom = true
                        }
                    }

                    item.wrapperCls = wrapperCls
                }
            }

            if (needsTransition) {
                await me.slideCards(value, oldValue)
            } else if (removeInactiveCards || needsUpdate) {
                container.updateDepth = -1; // include the full tree to honor new or changed inactive cards
                container.update()
            }
        }
    }

    /**
     * Initially sets the CSS classes of the container items this layout is bound to.
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @param {Boolean} [keepInDom=false]
     */
    applyChildAttributes(item, index, keepInDom=false) {
        let me            = this,
            isActiveIndex = me.activeIndex === index,
            sCfg          = me.constructor,
            childCls      = item.wrapperCls || [],
            {vdom}        = item;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(childCls, sCfg.itemCls);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(childCls, isActiveIndex ? sCfg.activeItemCls : sCfg.inactiveItemCls);

        if (!keepInDom && me.removeInactiveCards) {
            vdom.removeDom  = !isActiveIndex;
            item.wrapperCls = childCls;
            item.update?.() // can get called for an item config
        } else {
            item.wrapperCls = childCls
        }
    }

    /**
     * Triggered before the slideDirection config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetSlideDirection(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'slideDirection')
    }

    /**
     * Loads a component.Base module which is defined via module: () => import('...')
     * @param {Object} item
     * @param {Number} [index]
     * @returns {Neo.component.Base}
     */
    async loadModule(item, index) {
        let me          = this,
            {container} = me,
            items       = container.items,
            {module}    = item,
            proto;

        if (!Neo.isNumber(index)) {
            index = items.indexOf(item)
        }

        item.isLoading = true; // prevent the item from getting queued multiple times inside form.Container

        module = await module();
        module = module.default;
        proto  = module.prototype;

        item.className = proto.className;
        item.module    = module;

        delete item.isLoading;
        delete item.vdom;

        items[index] = item = Neo.create(item);

        me.applyChildAttributes(item, index);

        container.getVdomItemsRoot().cn[index] = item.createVdomReference();

        container.fire('cardLoaded', {item});

        return item
    }

    /**
     * @param {Number} index
     * @param {Number} oldIndex
     */
    async slideCards(index, oldIndex) {
        let me            = this,
            {container}   = me,
            slideVertical = me.slideDirection === 'vertical',
            {items, vdom} = container,
            card          = items[index],
            oldCard       = items[oldIndex],
            slideIn       = index > oldIndex,
            rect          = await container.getDomRect(container.id),
            animationWrapper, style, x, y;

        delete oldCard.vdom.removeDom;

        if (slideVertical) {
            y = slideIn ? 0 : -rect.height;

            style = {
                flexDirection: 'column',
                height       : `${2 * rect.height}px`,
                transform    : `translateY(${y}px)`,
                width        : `${rect.width}px`
            }
        } else {
            x = slideIn ? 0 : -rect.width;

            style = {
                height   : `${rect.height}px`,
                transform: `translateX(${x}px)`,
                width    : `${2 * rect.width}px`
            }
        }

        vdom.cn = [
            {cls: ['neo-relative'], cn: [
                {cls: ['neo-animation-wrapper'], style, cn: [card.createVdomReference()]}
            ]}
        ];

        animationWrapper = vdom.cn[0].cn[0];

        animationWrapper.cn[slideIn ? 'unshift' : 'push'](oldCard.createVdomReference());

        container.updateDepth = -1;

        await container.promiseUpdate();

        animationWrapper.style.transform = slideVertical ?
            `translateY(${slideIn ? -rect.height : 0}px)` :
            `translateX(${slideIn ? -rect.width  : 0}px)`;

        await container.promiseUpdate();

        await me.timeout(300); // transition duration defined via CSS for now

        vdom.cn = [];

        container.items.forEach(item => {
            vdom.cn.push(item.createVdomReference())
        });

        oldCard.vdom.removeDom = true;

        container.updateDepth = -1;

        await container.promiseUpdate()
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            activeIndex        : me.activeIndex,
            containerCls       : me.containerCls,
            removeInactiveCards: me.removeInactiveCards,
            slideDirection     : me.slideDirection
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Card));


/***/ },

/***/ "./src/layout/Fit.mjs"
/*!****************************!*\
  !*** ./src/layout/Fit.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Fit
 * @extends Neo.layout.Base
 */
class Fit extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Fit'
         * @protected
         */
        className: 'Neo.layout.Fit',
        /**
         * @member {String} ntype='layout-fit'
         * @protected
         */
        ntype: 'layout-fit',
        /**
         * @member {String|null} containerCls='neo-layout-fit'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-fit'
    }

    /**
     * Initially sets the CSS classes of the container items this layout is bound to.
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        if (!item.ignoreLayout) {
            item.wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(item.wrapperCls, 'neo-layout-fit-item')
        }
    }

    /**
     * Removes all CSS rules from a container item this layout is bound to.
     * Gets called when switching to a different layout.
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    removeChildAttributes(item, index) {
        if (!item.ignoreLayout) {
            let {wrapperCls} = item;

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-layout-fit-item');
            item.wrapperCls = wrapperCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Fit));


/***/ },

/***/ "./src/layout/Flexbox.mjs"
/*!********************************!*\
  !*** ./src/layout/Flexbox.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Flexbox
 * @extends Neo.layout.Base
 */
class Flexbox extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} alignValues=['center','end','start','stretch',null]
     * @protected
     * @static
     */
    static alignValues = ['center', 'end', 'start', 'stretch', null]
    /**
     * Valid values for direction
     * @member {String[]} directionValues=['column','column-reverse','row','row-reverse',null]
     * @protected
     * @static
     */
    static directionValues = ['column', 'column-reverse', 'row', 'row-reverse', null]
    /**
     * Valid values for pack
     * @member {String[]} packValues=['center','end','start',null]
     * @protected
     * @static
     */
    static packValues = ['center', 'end', 'start', null]
    /**
     * Valid values for wrap
     * @member {String[]} wrapValues=['nowrap','wrap','wrap-reverse']
     * @protected
     * @static
     */
    static wrapValues = ['nowrap', 'wrap', 'wrap-reverse']

    static config = {
        /**
         * @member {String} className='Neo.layout.Flexbox'
         * @protected
         */
        className: 'Neo.layout.Flexbox',
        /**
         * @member {String} ntype='layout-flexbox'
         * @protected
         */
        ntype: 'layout-flexbox',
        /**
         * Valid values: 'center', 'end', 'start', 'stretch', null
         * @member {String|null} align_=null
         * @reactive
         */
        align_: null,
        /**
         * Valid values: 'column', 'column-reverse', 'row', 'row-reverse', null
         * @member {String|null} direction_=null
         * @reactive
         */
        direction_: null,
        /**
         * flex css allows gap. This adds it to the component style
         * @member {String} gap_=null
         * @reactive
         */
        gap_: null,
        /**
         * Valid values: 'center', 'end', 'start', null
         * @member {String|null} pack_=null
         * @reactive
         */
        pack_: null,
        /**
         * CSS className prefix
         * @member {String} prefix='neo-flex-'
         */
        prefix: 'neo-flex-',
        /**
         * Valid values: nowrap, wrap, wrapreverse
         * @member {String} wrap_='nowrap'
         * @reactive
         */
        wrap_: 'nowrap'
    }

    /**
     * Updates the Container CSS cls after "align" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAlign(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'align')
    }

    /**
     * Updates the Container CSS cls after "direction" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetDirection(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'direction')
    }

    /**
     * Updates the Container style to add a gap to display:flex
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetGap(value, oldValue) {
        if (!value && !oldValue) return;

        let {container}    = this,
            {wrapperStyle} = container;

        wrapperStyle.gap = value;

        container.wrapperStyle = wrapperStyle
    }

    /**
     * Updates the Container CSS cls after "pack" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetPack(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'pack')
    }

    /**
     * Updates the Container CSS cls after "wrap" gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetWrap(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'wrap')
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        if (!item.wrapperStyle) return;

        let style = item.wrapperStyle,
            flex  = style.flex || item.flex || (this.align === 'stretch' ? 1 : '0 1 auto');

        if (Neo.isNumber(flex)) {
            flex = `${flex} 1 0%`
        }

        style.flex = flex;
        item.wrapperStyle = style
    }

    /**
     * Applies CSS classes to the container this layout is bound to
     */
    applyRenderAttributes() {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (!container) {
            Neo.logError('layout.Flexbox: applyRenderAttributes -> container not yet created', me.containerId)
        }

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'container');

        me.align     && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'align-'     + me.align);
        me.direction && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'direction-' + me.direction);
        me.pack      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'pack-'      + me.pack);
        me.wrap      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'wrap-'      + me.wrap);

        container.wrapperCls = wrapperCls
    }

    /**
     * Checks if the new value for "align" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetAlign(value, oldValue) {
        return this.testInputValue(value, oldValue, 'alignValues', 'align')
    }

    /**
     * Checks if the new value for "direction" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetDirection(value, oldValue) {
        return this.testInputValue(value, oldValue, 'directionValues', 'direction')
    }

    /**
     * Checks if the new value for "pack" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetPack(value, oldValue) {
        return this.testInputValue(value, oldValue, 'packValues', 'pack')
    }

    /**
     * Checks if the new value for "wrap" is valid
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String} value
     */
    beforeSetWrap(value, oldValue) {
        return this.testInputValue(value, oldValue, 'wrapValues', 'wrap')
    }

    /**
     * Removes all CSS rules from a container item this layout is bound to.
     * Gets called when switching to a different layout.
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    removeChildAttributes(item, index) {
        let style = item.wrapperStyle || {};

        style.flex = item.flex || null;
        item.wrapperStyle = style
    }

    /**
     * Removes all CSS rules from the container this layout is bound to.
     * Gets called when switching to a different layout.
     * @protected
     */
    removeRenderAttributes() {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (!container) {
            Neo.logError('layout.Flexbox: removeRenderAttributes -> container not yet created', me.containerId)
        }

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'container');

        me.align     && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'align-'     + me.align);
        me.direction && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'direction-' + me.direction);
        me.pack      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'pack-'      + me.pack);
        me.wrap      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'wrap-'      + me.wrap);

        container.wrapperCls = wrapperCls
    }

    /**
     * Checks if the new value for propertyName is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @param {String} validValuesName
     * @param {String} propertyName
     * @protected
     * @returns {String|null} value
     */
    testInputValue(value, oldValue, validValuesName, propertyName) {
        let validValues = this.getStaticConfig(validValuesName);

        if (!_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].hasItem(validValues, value)) {
            Neo.logError(this.containerId, '-> layout: supported values for "' + propertyName + '" are' , validValues);
            return oldValue
        }

        return value;
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            align    : me.align,
            direction: me.direction,
            gap      : me.gap,
            pack     : me.pack,
            prefix   : me.prefix,
            wrap     : me.wrap
        }
    }

    /**
     * Updates the Container CSS wrapperCls
     * @param {String|null} value
     * @param {String|null} oldValue
     * @param {String} propertyName
     * @protected
     */
    updateInputValue(value, oldValue, propertyName) {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (container?.vnodeInitialized) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + propertyName + '-' + oldValue);

            if (value !== null) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + propertyName + '-' + value)
            }

            container.wrapperCls = wrapperCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Flexbox));


/***/ },

/***/ "./src/layout/Grid.mjs"
/*!*****************************!*\
  !*** ./src/layout/Grid.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Grid
 * @extends Neo.layout.Base
 */
class Grid extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Grid'
         * @protected
         */
        className: 'Neo.layout.Grid',
        /**
         * @member {String} ntype='layout-hbox'
         * @protected
         */
        ntype: 'layout-grid',
        /**
         * @member {String|null} containerCls='neo-layout-fit'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-grid'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Grid));


/***/ },

/***/ "./src/layout/HBox.mjs"
/*!*****************************!*\
  !*** ./src/layout/HBox.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Flexbox.mjs */ "./src/layout/Flexbox.mjs");


/**
 * The HBox layout allows you to arrange components horizontally in a container.
 * @class Neo.layout.HBox
 * @extends Neo.layout.Flexbox
 */
class HBox extends _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.HBox'
         * @protected
         */
        className: 'Neo.layout.HBox',
        /**
         * @member {String} ntype='layout-hbox'
         * @protected
         */
        ntype: 'layout-hbox',
        /**
         * @member {String} direction='row'
         * @protected
         * @reactive
         */
        direction: 'row'
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        // Do not apply flex if fixed width
        !item.width && super.applyChildAttributes(item, index)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HBox));


/***/ },

/***/ "./src/layout/VBox.mjs"
/*!*****************************!*\
  !*** ./src/layout/VBox.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Flexbox.mjs */ "./src/layout/Flexbox.mjs");


/**
 * The VBox layout allows you to arrange components vertically in a container.
 * @class Neo.layout.VBox
 * @extends Neo.layout.Flexbox
 */
class VBox extends _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.VBox'
         * @protected
         */
        className: 'Neo.layout.VBox',
        /**
         * @member {String} ntype='layout-vbox'
         * @protected
         */
        ntype: 'layout-vbox',
        /**
         * @member {String} direction='column'
         * @protected
         * @reactive
         */
        direction: 'column'
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        // Do not apply flex if fixed height
        !item.height && super.applyChildAttributes(item, index)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VBox));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1EO0FBQ0g7QUFDQTtBQUNEO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNROztBQUV2RCxvQkFBb0Isa0JBQWtCLElBQUksa0JBQWtCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBUztBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBWTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLG9CQUFvQixTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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Q0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUJBOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFPO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBTztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9DYXJkLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9GaXQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbGF5b3V0L0ZsZXhib3gubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbGF5b3V0L0dyaWQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbGF5b3V0L0hCb3gubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbGF5b3V0L1ZCb3gubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb21wb25lbnQgICAgICBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IExheW91dEJhc2UgICAgIGZyb20gJy4uL2xheW91dC9CYXNlLm1qcyc7XG5pbXBvcnQgTGF5b3V0Q2FyZCAgICAgZnJvbSAnLi4vbGF5b3V0L0NhcmQubWpzJztcbmltcG9ydCBMYXlvdXRGaXQgICAgICBmcm9tICcuLi9sYXlvdXQvRml0Lm1qcyc7XG5pbXBvcnQgTGF5b3V0R3JpZCAgICAgZnJvbSAnLi4vbGF5b3V0L0dyaWQubWpzJztcbmltcG9ydCBMYXlvdXRIYm94ICAgICBmcm9tICcuLi9sYXlvdXQvSEJveC5tanMnO1xuaW1wb3J0IExheW91dFZCb3ggICAgIGZyb20gJy4uL2xheW91dC9WQm94Lm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgZnJvbSAnLi4vdXRpbC9Mb2dnZXIubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbmNvbnN0IGJ5V2VpZ2h0ID0gKHsgd2VpZ2h0IDogbGhzID0gMCB9LCB7IHdlaWdodCA6IHJocyA9IDAgfSkgPT4gbGhzIC0gcmhzO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udGFpbmVyLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnUmVzb3J0YWJsZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUmVzb3J0YWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBjaGlsZCBpdGVtcyB3aXRoaW4gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAqIFRoaXMgY29uZmlnIHVzZXMgYSBkZXNjcmlwdG9yIHRvIGVuYWJsZSBkZWVwIG1lcmdpbmcgd2l0aCBpbnN0YW5jZSBiYXNlZCBpdGVtRGVmYXVsdHMuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzXz17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnZGVlcCcsIHZhbHVlOiBudWxsfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0c186IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdkZWVwJyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvciBhbiBvYmplY3Qgb2YgY29uZmlnIG9iamVjdHN8aW5zdGFuY2VzfG1vZHVsZXMgZm9yIGVhY2ggY2hpbGQgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBpdGVtc189W11cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogaW1wb3J0IEJ1dHRvbiAgICAgIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG4gICAgICAgICAqIGltcG9ydCBUb29sYmFyICAgICBmcm9tICcuLi90b29sYmFyL0Jhc2UubWpzJztcbiAgICAgICAgICpcbiAgICAgICAgICogbGV0IG15QnV0dG9uID0gTmVvLmNyZWF0ZShCdXR0b24sIHtcbiAgICAgICAgICogICAgIHRleHQ6ICdCdXR0b24xJ1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogTmVvLmNyZWF0ZShUb29sYmFyLCB7XG4gICAgICAgICAqICAgICAvLy4uLlxuICAgICAgICAgKiAgICAgaXRlbXM6IHtcbiAgICAgICAgICogICAgICAgICBidXR0b25SZWYgOiB7XG4gICAgICAgICAqICAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJywgICAvLyBieSBudHlwZVxuICAgICAgICAgKiAgICAgICAgICAgICB0ZXh0IDogJ0J1dHRvbiAyJ1xuICAgICAgICAgKiAgICAgICAgIH0sXG4gICAgICAgICAqICAgICAgICAgc2Vjb25kUmVmIDoge1xuICAgICAgICAgKiAgICAgICAgICAgICBtb2R1bGU6IEJ1dHRvbiwgICAgLy8gYnkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAgICAqICAgICAgICAgICAgIHRleHQgIDogJ0J1dHRvbiAzJ1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG9yXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGltcG9ydCBCdXR0b24gICAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuICAgICAgICAgKiBpbXBvcnQgTXlSZWRCdXR0b24gZnJvbSAnbXlhcHAvTXlSZWRCdXR0b24ubWpzJztcbiAgICAgICAgICogaW1wb3J0IFRvb2xiYXIgICAgIGZyb20gJy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuICAgICAgICAgKlxuICAgICAgICAgKiBsZXQgbXlCdXR0b24gPSBOZW8uY3JlYXRlKEJ1dHRvbiwge1xuICAgICAgICAgKiAgICAgdGV4dDogJ0J1dHRvbjEnXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBOZW8uY3JlYXRlKFRvb2xiYXIsIHtcbiAgICAgICAgICogICAgIC8vLi4uXG4gICAgICAgICAqICAgICBpdGVtczogW1xuICAgICAgICAgKiAgICAgICAgIG15QnV0dG9uLCAgICAgICAgICAgICAgLy8gcGFzc2VkIGluc3RhbmNlXG4gICAgICAgICAqICAgICAgICAge1xuICAgICAgICAgKiAgICAgICAgICAgICBudHlwZTogJ2J1dHRvbicsICAgLy8gYnkgbnR5cGVcbiAgICAgICAgICogICAgICAgICAgICAgdGV4dCA6ICdCdXR0b24gMidcbiAgICAgICAgICogICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgIHtcbiAgICAgICAgICogICAgICAgICAgICAgbW9kdWxlOiBCdXR0b24sICAgIC8vIGJ5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgICAgKiAgICAgICAgICAgICB0ZXh0ICA6ICdCdXR0b24gMydcbiAgICAgICAgICogICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgIE15UmVkQnV0dG9uICAgICAgICAgICAgLy8geW91IGNhbiBkcm9wIGltcG9ydGVkIG1vZHVsZXMgZGlyZWN0bHkgaW50byB0aGUgaXRlbXMgYXJyYXlcbiAgICAgICAgICogICAgIF1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIGNsb25lICAgICAgICAgOiAnc2hhbGxvdycsXG4gICAgICAgICAgICBjbG9uZU9uR2V0ICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaXNFcXVhbCAgICAgICA6ICgpID0+IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfG51bGx9IGxheW91dF89e250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0Xzoge1xuICAgICAgICAgICAgbnR5cGU6ICd2Ym94JyxcbiAgICAgICAgICAgIGFsaWduOiAnc3RyZXRjaCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lfG51bGx9IHNvcnRab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzb3J0Wm9uZUNscz0nTmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmUnXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZUNsczogJ05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc29ydFpvbmVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXtjbjogW119XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMgYXQgdGhlIGxhc3QgaW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQ9dHJ1ZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGFkZChpdGVtLCBzaWxlbnQ9ZmFsc2UsIHJlbW92ZUZyb21QcmV2aW91c1BhcmVudD10cnVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtZS5pbnNlcnQobWUuaXRlbXMgPyBtZS5pdGVtcy5sZW5ndGggOiAwLCBpdGVtLCBzaWxlbnQsIHJlbW92ZUZyb21QcmV2aW91c1BhcmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLml0ZW1zKSB7XG4gICAgICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5sYXlvdXQpIHtcbiAgICAgICAgICAgIG1lLmxheW91dC5hcHBOYW1lID0gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgbWUuc29ydFpvbmUuYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5sYXlvdXQuQmFzZXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmxheW91dC5CYXNlfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGF5b3V0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS52bm9kZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZT8ucmVtb3ZlUmVuZGVyQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgdmFsdWU/LmFwcGx5UmVuZGVyQXR0cmlidXRlcygpO1xuXG4gICAgICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlPy5yZW1vdmVDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhbHVlPy5hcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveT8uKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCB7aXRlbXN9ID0gdGhpcywge2xlbmd0aH0gPSBpdGVtczsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS52ZG9tLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5tb3VudGVkID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG5lZWRzVmRvbVVwZGF0ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE5lZWRzVmRvbVVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcz8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZS5nLiBUb29sYmFyIGl0ZW1zIGxpa2UgJy0+J1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIG5vdCBzZXQgdGhlIGNvbmZpZyBkaXJlY3RseSA9PiBpdCBjb3VsZCBhbHJlYWR5IGJlIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgd2Ugc3RpbGwgd2FudCB0byBwYXNzIGl0IGZ1cnRoZXIgaW50byBzdWJ0cmVlc1xuICAgICAgICAgICAgICAgICAgICBpdGVtLl9uZWVkc1Zkb21VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hZnRlclNldE5lZWRzVmRvbVVwZGF0ZT8uKGZhbHNlLCB0cnVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZub2RlSW5pdGlhbGl6aW5nIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNWbm9kZUluaXRpYWxpemluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB7aXRlbXN9ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gICAgID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS52ZG9tLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5pc1Zub2RlSW5pdGlhbGl6aW5nID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdSZXNvcnRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0RHJhZ1Jlc29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBtb2R1bGU7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFtZS5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgaWYgKG1lLnNvcnRab25lQ29uZmlnPy5tb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBtZS5zb3J0Wm9uZUNvbmZpZy5tb2R1bGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1lLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA9IGF3YWl0IG1lLmxvYWRTb3J0Wm9uZU1vZHVsZSgpO1xuICAgICAgICAgICAgICAgIG1vZHVsZSA9IG1vZHVsZS5kZWZhdWx0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmNyZWF0ZVNvcnRab25lKE5lby5tZXJnZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgICAgICAgICAgIDogbWUud2luZG93SWRcbiAgICAgICAgICAgIH0sIG1lLnNvcnRab25lQ29uZmlnKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGhlbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy5pdGVtcz8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaXRlbS50aGVtZSA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2xheW91dH0gPSBtZTtcblxuICAgICAgICB2YWx1ZSAmJiBtZS5pdGVtcz8uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghTmVvLmlzU3RyaW5nKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaXRlbS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHZhbHVlICYmIGxheW91dCAmJiAhTmVvLmlzU3RyaW5nKGxheW91dCkpIHtcbiAgICAgICAgICAgIGxheW91dC53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIG1lLnNvcnRab25lLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgaXRlbXMgb2JqZWN0IHRvIGFuIGFycmF5IGZvciBvbndhcmQgc3RvcmFnZSBhcyBfaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgICBiZWZvcmVTZXRJdGVtcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgICAgIGhhc1dlaWdodCwgaXRlbTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCByZWYgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbcmVmXVxuXG4gICAgICAgICAgICAgICAgaXRlbS5yZWZlcmVuY2UgPSByZWY7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaGFzV2VpZ2h0IHx8PSAoJ3dlaWdodCcgaW4gaXRlbSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc1dlaWdodCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zb3J0KGJ5V2VpZ2h0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOZW8ubGF5b3V0LkJhc2V9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5sYXlvdXQuQmFzZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TGF5b3V0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXlvdXQodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVtb3ZlRnJvbVByZXZpb3VzUGFyZW50PXRydWVdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxPYmplY3R9IE9iamVjdCBmb3IgbGF6eSBsb2FkZWQgaXRlbXNcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtKGl0ZW0sIGluZGV4LCByZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnICAgPSB7YXBwTmFtZTogbWUuYXBwTmFtZSwgcGFyZW50SWQ6IG1lLmlkLCBwYXJlbnRJbmRleDogaW5kZXgsIHdpbmRvd0lkOiBtZS53aW5kb3dJZH0sXG4gICAgICAgICAgICBkZWZhdWx0cyA9IHsuLi5tZS5pdGVtRGVmYXVsdHN9LFxuICAgICAgICAgICAgbGF6eUxvYWRJdGVtLCBtb2R1bGUsIHBhcmVudDtcblxuICAgICAgICBpZiAoZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLm1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWZhdWx0cy5udHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGl0ZW0ubnR5cGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGVmYXVsdHMubW9kdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChOZW8udHlwZU9mKGl0ZW0pKSB7XG4gICAgICAgICAgICBjYXNlICdOZW9DbGFzcyc6IHtcbiAgICAgICAgICAgICAgICBpdGVtID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRoZW1lOiBpdGVtLmNvbmZpZy50aGVtZSB8fCBtZS50aGVtZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnTmVvSW5zdGFuY2UnOiB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gaXRlbS5wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZUZyb21QcmV2aW91c1BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZT8uKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnZkb20ucmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LndpbmRvd0lkICE9PSBtZS53aW5kb3dJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB3ZSBhcmUgZHVwbGljYXRpbmcgdmRvbSBpbnRvIGEgZGlmZmVyZW50IGJyb3dzZXIgd2luZG93LCB3ZSBuZWVkIGEgc2lsZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBfbW91bnRlZCB1cGRhdGUgdG8gZW5zdXJlIHRoYXQgYWZ0ZXJTZXRNb3VudGVkKCkgc3RpbGwgZ2V0cyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtW3JlbW92ZUZyb21QcmV2aW91c1BhcmVudCA/ICdtb3VudGVkJyA6ICdfbW91bnRlZCddID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlbmllbmNlIGxvZ2ljLCBlc3BlY2lhbGx5IGZvciBtb3ZpbmcgY29tcG9uZW50cyBpbnRvIGRpZmZlcmVudCBicm93c2VyIHdpbmRvd3M6XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgY29tcG9uZW50IG1pZ2h0IHJlbHkgb24gcmVmZXJlbmNlcyAmIGhhbmRsZXIgbWV0aG9kcyBpbnNpZGUgdGhlIHByZXZpb3VzIGNvbnRyb2xsZXIgcmVhbG1cbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogV2UgbmVlZCA/LiB1bnRpbCBmdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlIHN1cHBvcnRzIGNvbnRyb2xsZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5jb250cm9sbGVyICYmICFtZS5nZXRDb250cm9sbGVyKCkgJiYgcGFyZW50LmdldENvbnRyb2xsZXI/LigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbnRyb2xsZXIgPSB7cGFyZW50OiBwYXJlbnQuZ2V0Q29udHJvbGxlcigpfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS5zZXQoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpdGVtLmdldFN0YXRlUHJvdmlkZXI/LigpPy5jcmVhdGVCaW5kaW5ncyhpdGVtKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdPYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lby5hc3NpZ25EZWZhdWx0cyhpdGVtLCBkZWZhdWx0cylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ubW9kdWxlICYmICFpdGVtLm50eXBlICYmICFpdGVtLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLm1vZHVsZSA9IENvbXBvbmVudFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1vZHVsZSA9IGl0ZW0ubW9kdWxlO1xuXG4gICAgICAgICAgICAgICAgbGF6eUxvYWRJdGVtID0gbW9kdWxlICYmICFtb2R1bGUuaXNDbGFzcyAmJiBOZW8uaXNGdW5jdGlvbihtb2R1bGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZSAmJiAhbGF6eUxvYWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NOYW1lID0gbW9kdWxlLnByb3RvdHlwZS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udGhlbWUgICAgID0gZGVmYXVsdHMudGhlbWUgfHwgbW9kdWxlLmNvbmZpZy50aGVtZSB8fCBtZS50aGVtZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmhhbmRsZXJTY29wZSA9PT0gJ3RoaXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaGFuZGxlclNjb3BlID0gbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoaXRlbS5oYW5kbGVyKSA9PT0gJ1N0cmluZycgJiYgTmVvLnR5cGVPZihtZVtpdGVtLmhhbmRsZXJdKSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5oYW5kbGVyID0gbWVbaXRlbS5oYW5kbGVyXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdGVtLCBjb25maWcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsYXp5TG9hZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IE5lb1tpdGVtLmNsYXNzTmFtZSA/ICdjcmVhdGUnIDogJ250eXBlJ10oaXRlbSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnZkb20gPSBPYmplY3QuYXNzaWduKGl0ZW0udmRvbSB8fCB7fSwge3JlbW92ZURvbTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnU3RyaW5nJzoge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIHZkb20gIDoge3RleHQ6IGl0ZW19LFxuICAgICAgICAgICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyAgICAgPSBtZS5faXRlbXMsXG4gICAgICAgICAgICBpdGVtc1Jvb3QgPSBtZS5nZXRWZG9tSXRlbXNSb290KCksXG4gICAgICAgICAgICB7bGF5b3V0fSAgPSBtZSxcbiAgICAgICAgICAgIHZkb207XG5cbiAgICAgICAgaXRlbXNSb290LmNuID0gW107XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGl0ZW1zW2luZGV4XSA9IGl0ZW0gPSBtZS5jcmVhdGVJdGVtKGl0ZW0sIGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOZW8uY29yZS5CYXNlKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Py5hcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdmRvbSA9IGl0ZW0uY3JlYXRlVmRvbVJlZmVyZW5jZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZkb20gPSBpdGVtLnZkb21cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXNSb290LmNuLnB1c2godmRvbSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBhZGQgaXRlbXMgaW50byB0aGUgdmRvbVxuICAgICAgICBtZS51cGRhdGVEZXB0aCA9IC0xO1xuICAgICAgICBtZS5pc0NvbnN0cnVjdGVkICYmIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgIG1lLmZpcmUoJ2l0ZW1zQ3JlYXRlZCcsIHtpZDogbWUuaWQsIGl0ZW1zfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8TmVvLmxheW91dC5CYXNlfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmxheW91dC5CYXNlfVxuICAgICAqL1xuICAgIGNyZWF0ZUxheW91dCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSBtZTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF5b3V0QmFzZSAmJiB2YWx1ZS5pc0xheW91dCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWUsIHthcHBOYW1lLCBjb250YWluZXJJZDogaWQsIHdpbmRvd0lkfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtZS5wYXJzZUxheW91dENsYXNzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlLCB7YXBwTmFtZSwgY29udGFpbmVySWQ6IGlkLCB3aW5kb3dJZH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLm50eXBlKHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNyZWF0ZVNvcnRab25lKGNvbmZpZykge1xuICAgICAgICB0aGlzLnNvcnRab25lID0gTmVvLmNyZWF0ZShjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYWxsIGNvbXBvbmVudHMgaW5zaWRlIHRoaXMuaXRlbXMgYmVmb3JlIHRoZSBzdXBlcigpIGNhbGwuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdXBkYXRlUGFyZW50VmRvbT1mYWxzZV0gdHJ1ZSB0byByZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBwYXJlbnQgdmRvbSA9PiByZWFsIGRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gdHJ1ZSB0byB1cGRhdGUgdGhlIHZkb20gc2lsZW50bHkgKHVzZWZ1bCBmb3IgZGVzdHJveWluZyBtdWx0aXBsZSBjaGlsZCBpdGVtcyBpbiBhIHJvdylcbiAgICAgKi9cbiAgICBkZXN0cm95KHVwZGF0ZVBhcmVudFZkb209ZmFsc2UsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICB0aGlzLmxheW91dD8uZGVzdHJveSgpO1xuXG4gICAgICAgIHRoaXMuaXRlbXM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmRlc3Ryb3k/LihmYWxzZSwgdHJ1ZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgZm9yIGBnZXRSZWZlcmVuY2UoKWAgd2hpY2ggaXMgdXNlZnVsIGJlZm9yZSBhIGNvbXBvbmVudCB0cmVlIGdvdCBjcmVhdGVkLlxuICAgICAqIGBnZXRSZWZlcmVuY2UoKWAgcmVsaWVzIG9uIGNoaWxkIGl0ZW1zIGJlaW5nIHJlZ2lzdGVyZWQgaW5zaWRlIGBtYW5hZ2VyLkNvbXBvbmVudGAsXG4gICAgICogd2hpbGUgdGhpcyBtZXRob2Qgc2ltcGx5IHdhbGtzIGRvd24gdGhlIGl0ZW1zIGFycmF5LlxuICAgICAqXG4gICAgICogSG93ZXZlciwgY2xhc3NlcyAvIG1vZHVsZXMgaW5zaWRlIHRoZSBpdGVtcyB0cmVlIGNhbiBub3QgZ2V0IHBhcnNlZCBmdXJ0aGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWZlcmVuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBpdGVtcz10aGlzLml0ZW1zXG4gICAgICogQHJldHVybnMge09iamVjdHxOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRJdGVtKHJlZmVyZW5jZSwgaXRlbXM9dGhpcy5pdGVtcykge1xuICAgICAgICBsZXQgaSAgID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGNoaWxkSXRlbSwgaXRlbTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbS5yZWZlcmVuY2UgPT09IHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjaGlsZEl0ZW0gPSB0aGlzLmdldEl0ZW0ocmVmZXJlbmNlLCBpdGVtLml0ZW1zKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkSXRlbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2ZG9tIGl0ZW1zIHJvb3QgaWYgbmVlZGVkICh1c2VmdWwgaW4gY2FzZSB0aGlzIGNvbnRhaW5lciB1c2VzIGEgd3JhcHBlciBub2RlKS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZkb20gaXRlbXMgcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21JdGVtc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZkb21Sb290KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgYSBkaXJlY3QgY2hpbGQgY29tcG9uZW50IGluc2lkZSB0aGlzLml0ZW1zLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfFN0cmluZ30gaXRlbUlkIEVpdGhlciB0aGUgaXRlbSByZWZlcmVuY2Ugb3IgdGhlIGl0ZW0gaWRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAtMSBpbiBjYXNlIG5vIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIGluZGV4T2YoaXRlbUlkKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgaSAgID0gMCxcbiAgICAgICAgICAgIGxlbiA9IG1lLml0ZW1zPy5sZW5ndGggfHwgMDtcblxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyhpdGVtSWQpKSB7XG4gICAgICAgICAgICBpdGVtSWQgPSBpdGVtSWQuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWUuaXRlbXNbaV0uaWQgPT09IGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMgYXQgYSBzcGVjaWZpYyBpbmRleC5cbiAgICAgKlxuICAgICAqICoqQXRvbWljIE1vdmVzOioqXG4gICAgICogSWYgdGhlIGBpdGVtYCBpcyBhbiBleGlzdGluZyBgTmVvLmNvbXBvbmVudC5CYXNlYCBpbnN0YW5jZSB0aGF0IGFscmVhZHkgaGFzIGEgcGFyZW50IGNvbnRhaW5lclxuICAgICAqIHdpdGhpbiB0aGUgc2FtZSBicm93c2VyIHdpbmRvdywgdGhpcyBtZXRob2QgcGVyZm9ybXMgYW4gKiphdG9taWMgbW92ZSoqLlxuICAgICAqIDEuIFRoZSBpdGVtIGlzIHNpbGVudGx5IHJlbW92ZWQgZnJvbSBpdHMgb2xkIHBhcmVudCAod2l0aG91dCB0cmlnZ2VyaW5nIGEgRE9NIHJlbW92YWwpLlxuICAgICAqIDIuIFRoZSBpdGVtIGlzIGluc2VydGVkIGludG8gdGhpcyBjb250YWluZXIuXG4gICAgICogMy4gVGhpcyBjb250YWluZXIgdXBkYXRlcywgc2VuZGluZyBhbiBgaW5zZXJ0Tm9kZWAgZGVsdGEuXG4gICAgICogNC4gVGhlIGBEZWx0YVVwZGF0ZXNgIHN5c3RlbSBkZXRlY3RzIHRoZSBleGlzdGluZyBET00gbm9kZSBhbmQgbW92ZXMgaXQgcGh5c2ljYWxseSwgcHJlc2VydmluZ1xuICAgICAqICAgIERPTSBzdGF0ZSBzdWNoIGFzIGZvY3VzLCBpbnB1dCB2YWx1ZXMsIGFuZCBpZnJhbWUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fE5lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQ9dHJ1ZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSwgc2lsZW50PWZhbHNlLCByZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1zfSAgICAgPSBtZSxcbiAgICAgICAgICAgIGxjYSAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIGksIGl0ZW1QYXJlbnQsIGl0ZW1UeXBlLCBsZW4sIG9sZFBhcmVudCwgcGFyZW50c0EsIHBhcmVudHNCLCByZXR1cm5BcnJheTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwO1xuICAgICAgICAgICAgbGVuICAgICAgICAgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybkFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIGFycmF5IGJhY2t3YXJkc1xuICAgICAgICAgICAgICAgIHJldHVybkFycmF5LnVuc2hpZnQobWUuaW5zZXJ0KGluZGV4LCBpdGVtW2xlbiAtIDEgLSBpXSwgdHJ1ZSwgcmVtb3ZlRnJvbVByZXZpb3VzUGFyZW50KSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbSA9IHJldHVybkFycmF5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtVHlwZSA9IE5lby50eXBlT2YoaXRlbSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgICAgIGl0ZW1QYXJlbnQgPSBpdGVtLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtUGFyZW50ID09PSBtZSAmJiBpdGVtcy5pbmRleE9mKGl0ZW0pID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdGVtUGFyZW50ICYmIGl0ZW1QYXJlbnQgIT09IG1lICYmIHJlbW92ZUZyb21QcmV2aW91c1BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQgPSBpdGVtUGFyZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQYXJlbnQud2luZG93SWQgPT09IG1lLndpbmRvd0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzQSA9IFttZSwgICAgICAgIC4uLm1lLmdldFBhcmVudHMoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzQiA9IFtvbGRQYXJlbnQsIC4uLm9sZFBhcmVudC5nZXRQYXJlbnRzKCldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsY2EgPSBwYXJlbnRzQS5maW5kKHAgPT4gcGFyZW50c0IuaW5jbHVkZXMocCkpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobGNhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQucmVtb3ZlKGl0ZW0sIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUZyb21QcmV2aW91c1BhcmVudCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0gPSBtZS5jcmVhdGVJdGVtKGl0ZW0sIGluZGV4LCByZW1vdmVGcm9tUHJldmlvdXNQYXJlbnQpO1xuXG4gICAgICAgICAgICAvLyBhZGRlZCB0aGUgdHJ1ZSBwYXJhbSA9PiBmb3IgY2FyZCBsYXlvdXRzLCB3ZSBkbyBub3Qgd2FudCBhIGR5bmFtaWNhbGx5IGluc2VydGVkIGNtcCB0byBnZXQgcmVtb3ZlZCByaWdodCBhd2F5XG4gICAgICAgICAgICAvLyBzaW5jZSBpdCB3aWxsIG1vc3QgbGlrZWx5IGdldCBhY3RpdmF0ZWQgcmlnaHQgYXdheVxuICAgICAgICAgICAgbWUubGF5b3V0Py5hcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zID0gaXRlbXM7XG5cbiAgICAgICAgICAgIG1lLmdldFZkb21JdGVtc1Jvb3QoKS5jbi5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0uY3JlYXRlVmRvbVJlZmVyZW5jZSgpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIChsY2EgfHwgbWUpLnVwZGF0ZURlcHRoID0gLTE7IC8vIHBhc3MgdGhlIGZ1bGwgdmRvbSB0cmVlIHRvIGhvbm9yIG5ldyBuZXN0ZWQgY29tcG9uZW50IHRyZWVzXG5cbiAgICAgICAgICAgIChsY2EgfHwgbWUpLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5maXJlKCdpbnNlcnQnLCB7aW5kZXgsIGl0ZW19KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgaXRlbXMgZnJvbSBhIHJlbW90ZSBlbmRwb2ludC5cbiAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL3RyZWUvZGV2L2V4YW1wbGVzL3NlcnZlcnNpZGVcbiAgICAgKiBUaGUgcmVzcG9uc2Ugc2hvdWxkIHJldHVybiBhIEpTT04gZmlsZSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAgICAgKiB7XCJtb2R1bGVzXCI6IFtdLCBcIml0ZW1zXCI6IFtdfVxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vYmxvYi9kZXYvZXhhbXBsZXMvc2VydmVyc2lkZS9ncmlkQ29udGFpbmVyL3Jlc291cmNlcy9kYXRhL2dyaWQtY29udGFpbmVyLmpzb25cbiAgICAgKiBJdCBpcyBpbXBvcnRhbnQgdG8gYWRkIG1vZHVsZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGltcG9ydGVkIGluc2lkZSB5b3VyIGFwcCB5ZXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGEub3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS51cmxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3RbXT59XG4gICAgICovXG4gICAgYXN5bmMgbG9hZEl0ZW1zKHtvcHRpb25zPXt9LCB1cmx9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlc3BvbnNlICAgPSBhd2FpdCBtZS50cmFwKGZldGNoKHVybCwgb3B0aW9ucykpLFxuICAgICAgICAgICAgcmVtb3RlRGF0YSA9IGF3YWl0IG1lLnRyYXAocmVzcG9uc2UuanNvbigpKTtcblxuICAgICAgICBpZiAocmVtb3RlRGF0YS5tb2R1bGVzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS50cmFwKFByb21pc2UuYWxsKHJlbW90ZURhdGEubW9kdWxlcy5tYXAobW9kdWxlUGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHJlbGF0aXZlIFVSTHNcbiAgICAgICAgICAgICAgICBpZiAoIW1vZHVsZVBhdGguc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZVBhdGggPSAoTmVvLmNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2RldmVsb3BtZW50JyA/ICcuLi8uLi8nIDogJy4uLy4uLy4uLy4uLycpICsgbW9kdWxlUGF0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyBtb2R1bGVQYXRoKVxuICAgICAgICAgICAgfSkpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbW90ZURhdGEuaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGxvYWRTb3J0Wm9uZU1vZHVsZSgpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydCgnLi4vZHJhZ2dhYmxlL2NvbnRhaW5lci9Tb3J0Wm9uZS5tanMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbWVyZ2VDb25maWcoLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9IHN1cGVyLm1lcmdlQ29uZmlnKC4uLmFyZ3MpLFxuICAgICAgICAgICAgY3Rvckl0ZW1zO1xuXG4gICAgICAgIC8vIEF2b2lkIGFueSBpbnRlcmZlcmVuY2Ugb24gcHJvdG90eXBlIGxldmVsXG4gICAgICAgIC8vIERvZXMgbm90IGNsb25lIGV4aXN0aW5nIE5lbyBpbnN0YW5jZXNcbiAgICAgICAgaWYgKGNvbmZpZy5pdGVtcykge1xuICAgICAgICAgICAgY3Rvckl0ZW1zID0gbWUuY29uc3RydWN0b3IuY29uZmlnLml0ZW1zO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgcGFzc2VkIGFuIG9iamVjdCwgbWVyZ2UgdGhlIGNsYXNzJ3Mgb3duIGl0ZW1zIG9iamVjdCBpbnRvIGl0XG4gICAgICAgICAgICBpZiAoTmVvLnR5cGVPZihjb25maWcuaXRlbXMpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNBcnJheShjdG9ySXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLml0ZW1zID0gTmVvLmNsb25lKGNvbmZpZy5pdGVtcywgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5pdGVtcyA9IE5lby5tZXJnZShOZW8uY2xvbmUoY3Rvckl0ZW1zKSwgY29uZmlnLml0ZW1zKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuX2l0ZW1zID0gTmVvLmNsb25lKGNvbmZpZy5pdGVtcywgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBleGlzdGluZyBpdGVtIHRvIGEgbmV3IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBtb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5pdGVtc1tmcm9tSW5kZXhdO1xuXG4gICAgICAgIGZyb21JbmRleCAhPT0gdG9JbmRleCAmJiBtZS5zd2l0Y2hJdGVtcyh0b0luZGV4LCBmcm9tSW5kZXgpO1xuXG4gICAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGxheW91dENvbmZpZyA9IG1lLmxheW91dDtcblxuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGlzIGEgY29uZmlnIG9iamVjdCAobm90IGFuIGluc3RhbmNlKSwgZGVlcCBjbG9uZSBpdFxuICAgICAgICAvLyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb24uXG4gICAgICAgIGlmIChsYXlvdXRDb25maWcgJiYgIShsYXlvdXRDb25maWcgaW5zdGFuY2VvZiBMYXlvdXRCYXNlKSkge1xuICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0gTmVvLmNsb25lKGxheW91dENvbmZpZywgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluIGNhc2UgdGhlIENvbnRhaW5lciBkb2VzIG5vdCBoYXZlIGEgbGF5b3V0IGNvbmZpZywgdGhlIHNldHRlciB3b24ndCB0cmlnZ2VyXG4gICAgICAgIG1lLl9sYXlvdXQgPSBtZS5jcmVhdGVMYXlvdXQobGF5b3V0Q29uZmlnKTtcbiAgICAgICAgbWUuX2xheW91dD8uYXBwbHlSZW5kZXJBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIG1lLnBhcnNlSXRlbUNvbmZpZ3MobWUuX2l0ZW1zKTtcbiAgICAgICAgbWUuY3JlYXRlSXRlbXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29uZmlnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGxheW91dENvbmZpZ1xuICAgICAqL1xuICAgIHBhcnNlTGF5b3V0Q2xhc3MoY29uZmlnKSB7XG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgICAgICAgaWYgKCFjb25maWcubnR5cGUuc3RhcnRzV2l0aCgnbGF5b3V0LScpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLm50eXBlID0gYGxheW91dC0ke2NvbmZpZy5udHlwZX1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbnR5cGU6IGNvbmZpZy5zdGFydHNXaXRoKCdsYXlvdXQtJykgPyBjb25maWcgOiBgbGF5b3V0LSR7Y29uZmlnfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29udGFpbmVyIGl0ZW0gYnkgcmVmZXJlbmNlXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Rlc3Ryb3lJdGVtPXRydWVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2tlZXBNb3VudGVkPWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICByZW1vdmUoY29tcG9uZW50LCBkZXN0cm95SXRlbT10cnVlLCBzaWxlbnQ9ZmFsc2UsIGtlZXBNb3VudGVkPWZhbHNlKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IFsuLi50aGlzLml0ZW1zXSxcbiAgICAgICAgICAgIGkgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpdGVtc1tpXS5pZCA9PT0gY29tcG9uZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQXQoaSwgZGVzdHJveUl0ZW0sIHNpbGVudCwga2VlcE1vdW50ZWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGl0ZW0gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lJdGVtcz10cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICByZW1vdmVBbGwoZGVzdHJveUl0ZW1zPXRydWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoZGVzdHJveUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5kZXN0cm95KHRydWUsIHRydWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0ubW91bnRlZCA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLml0ZW1zID0gW107XG5cbiAgICAgICAgbWUuZ2V0VmRvbUl0ZW1zUm9vdCgpLmNuID0gW107XG5cbiAgICAgICAgaWYgKCFzaWxlbnQgfHwgZGVzdHJveUl0ZW1zKSB7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbnRhaW5lciBpdGVtIGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lJdGVtPXRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0ga2VlcE1vdW50ZWQ9ZmFsc2UgU2V0IHRvIGB0cnVlYCB0byBrZWVwIHRoZSBpdGVtJ3MgYG1vdW50ZWRgIHN0YXRlIGFzIGB0cnVlYC5cbiAgICAgKiBUaGlzIGlzIGNyaXRpY2FsIGZvciAqKkF0b21pYyBNb3ZlcyoqLCB3aGVyZSB0aGUgaXRlbSBpcyByZW1vdmVkIGZyb20gb25lIGNvbnRhaW5lciBhbmQgaW1tZWRpYXRlbHkgYWRkZWRcbiAgICAgKiB0byBhbm90aGVyLCBhbmQgd2UgZG8gbm90IHdhbnQgdG8gdHJpZ2dlciB1bm1vdW50IGxpZmVjeWNsZSBob29rcyBpbiBiZXR3ZWVuLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICByZW1vdmVBdChpbmRleCwgZGVzdHJveUl0ZW09dHJ1ZSwgc2lsZW50PWZhbHNlLCBrZWVwTW91bnRlZD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aXRlbXN9ID0gbWUsXG4gICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIE5lby53YXJuKCdDb250YWluZXIucmVtb3ZlQXQ6IGluZGV4ID49IGl0ZW1zLmxlbmd0aC4gJyArIG1lLmlkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2luZGV4XTtcblxuICAgICAgICAgICAgaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgbWUuZ2V0VmRvbUl0ZW1zUm9vdCgpLmNuLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZSBuZWVkcyB0byBpbmNsdWRlIGRpcmVjdCBjaGlsZHJlblxuICAgICAgICAgICAgbWUudXBkYXRlRGVwdGggPSAyO1xuXG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRlc3Ryb3kodHJ1ZSwgc2lsZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5sYXlvdXQ/LnJlbW92ZUNoaWxkQXR0cmlidXRlcyhpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubW91bnRlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjb250YWluZXIgaXRlbSBhdCB0aGUgbGFzdCBpbmRleFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Rlc3Ryb3lJdGVtPXRydWVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIHJlbW92ZUxhc3QoZGVzdHJveUl0ZW09dHJ1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQodGhpcy5pdGVtcy5sZW5ndGggLSAxLCBkZXN0cm95SXRlbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGEgY29udGFpbmVyIGl0ZW0gYXQgYSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZXN0cm95SXRlbT10cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKi9cbiAgICByZXBsYWNlQXQoaW5kZXgsIGl0ZW0sIGRlc3Ryb3lJdGVtPXRydWUsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KGluZGV4LCBkZXN0cm95SXRlbSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoZXMgdGhlIHBvc2l0aW9uIG9mIDIgZGlyZWN0IGNoaWxkIGl0ZW1zXG4gICAgICogWW91IGNhbiBlaXRoZXIgcGFzcyBhbiBpbmRleCAoTnVtYmVyKSBvciBpZCAoU3RyaW5nKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaXRlbTFpZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaXRlbTJpZFxuICAgICAqL1xuICAgIHN3aXRjaEl0ZW1zKGl0ZW0xaWQsIGl0ZW0yaWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbTFJbmRleCA9IE5lby5pc051bWJlcihpdGVtMWlkKSA/IGl0ZW0xaWQgOiBtZS5pbmRleE9mKGl0ZW0xaWQpLFxuICAgICAgICAgICAgaXRlbTJJbmRleCA9IE5lby5pc051bWJlcihpdGVtMmlkKSA/IGl0ZW0yaWQgOiBtZS5pbmRleE9mKGl0ZW0yaWQpO1xuXG4gICAgICAgIE5lb0FycmF5Lm1vdmUobWUuaXRlbXMsICAgICAgICAgICAgICAgICBpdGVtMkluZGV4LCBpdGVtMUluZGV4KTtcbiAgICAgICAgTmVvQXJyYXkubW92ZShtZS5nZXRWZG9tSXRlbXNSb290KCkuY24sIGl0ZW0ySW5kZXgsIGl0ZW0xSW5kZXgpO1xuXG4gICAgICAgIC8vIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZSBuZWVkcyB0byBpbmNsdWRlIGRpcmVjdCBjaGlsZHJlblxuICAgICAgICBtZS51cGRhdGVEZXB0aCA9IDI7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBjb250YWluZXIgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgZHJhZ1Jlc29ydGFibGU6IG1lLmRyYWdSZXNvcnRhYmxlLFxuICAgICAgICAgICAgaXRlbUNvdW50ICAgICA6IG1lLml0ZW1zPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGl0ZW1EZWZhdWx0cyAgOiBtZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgIDogbWUuaXRlbXM/Lm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IE5lby50eXBlT2YoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbVR5cGUgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbVR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihpdGVtLm1vZHVsZSkgJiYgIWl0ZW0ubW9kdWxlLmlzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IGl0ZW0ubW9kdWxlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtZS5zZXJpYWxpemVDb25maWcoaXRlbSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbGF5b3V0OiBtZS5sYXlvdXQ/LnRvSlNPTigpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbnRhaW5lcik7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgb3RoZXIgbGF5b3V0cy5cbiAqIFVzZSBpdCBkaXJlY3RseSBpbiBjYXNlIHlvdSB3YW50IHRvIGNyZWF0ZSBhIGNvbnRhaW5lciB3aXRob3V0IGEgbGF5b3V0LlxuICogQGNsYXNzIE5lby5sYXlvdXQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBMYXlvdXQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5sYXlvdXQuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxheW91dC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1iYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xheW91dC1iYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBsYXlvdXQgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwTmFtZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkIG9mIHRoZSBDb250YWluZXIgaW5zdGFuY2UgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG9cbiAgICAgICAgICogQG1lbWJlciB7P1N0cmluZ30gY29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGF5b3V0IHNwZWNpZmljIENTUyBzZWxlY3RvciB3aGljaCBnZXRzIGFkZGVkIHRvIENvbnRhaW5lciB0aGUgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29udGFpbmVyQ2xzXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJDbHNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllciBmb3IgYWxsIGNsYXNzZXMgdGhhdCBleHRlbmQgbGF5b3V0LkJhc2VcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNMYXlvdXQ9dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc0xheW91dDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udGFpbmVyLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgY29udGFpbmVyKCkge1xuICAgICAgICBsZXQge2NvbnRhaW5lcklkfSA9IHRoaXM7XG5cbiAgICAgICAgLy8gdGhlIGluc3RhbmNlIG1pZ2h0IG5vdCBiZSByZWdpc3RlcmVkIHlldFxuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudChjb250YWluZXJJZCkgfHwgTmVvLmdldChjb250YWluZXJJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMuX19wcm90b19fKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXBwbHlSZW5kZXJBdHRyaWJ1dGVzKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBjb250YWluZXJDbHN9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmIChjb250YWluZXJDbHMpIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKG1lLmNsYXNzTmFtZSArICc6IGFwcGx5UmVuZGVyQXR0cmlidXRlcyAtPiBjb250YWluZXIgbm90IHlldCBjcmVhdGVkJywgbWUuY29udGFpbmVySWQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCBjb250YWluZXJDbHMpO1xuXG4gICAgICAgICAgICBjb250YWluZXJbc2lsZW50ID8gJ3NldFNpbGVudCcgOiAgJ3NldCddKHt3cmFwcGVyQ2xzfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5iaW5kICYmIG1lLmdldFN0YXRlUHJvdmlkZXIoKT8ucmVtb3ZlQmluZGluZ3MobWUuaWQpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRhaW5lciBzdGF0ZVByb3ZpZGVyIG9yIGl0cyBjbG9zZXN0IHBhcmVudCBzdGF0ZVByb3ZpZGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtudHlwZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihudHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuZ2V0U3RhdGVQcm92aWRlcihudHlwZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCBjbGFzcyBjb25maWdzIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKi9cbiAgICBpbml0Q29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmluaXRDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYmluZCAmJiBtZS5jb250YWluZXIuZ2V0U3RhdGVQcm92aWRlcigpPy5jcmVhdGVCaW5kaW5ncyhtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2RcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlUmVuZGVyQXR0cmlidXRlcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbnRhaW5lciwgY29udGFpbmVyQ2xzfSA9IG1lLFxuICAgICAgICAgICAge3dyYXBwZXJDbHN9ICAgICAgICAgICAgICA9IGNvbnRhaW5lcjtcblxuICAgICAgICBpZiAoY29udGFpbmVyQ2xzKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIE5lby5sb2dFcnJvcihtZS5jbGFzc05hbWUgKyAnOiByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzIC0+IGNvbnRhaW5lciBub3QgeWV0IGNyZWF0ZWQnLCBtZS5jb250YWluZXJJZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsIGNvbnRhaW5lckNscyk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIG11bHRpcGxlIGNvbmZpZ3MgYXQgb25jZSwgZW5zdXJpbmcgdGhhdCBhbGwgYWZ0ZXJTZXQgbWV0aG9kcyBnZXQgYWxsIG5ldyBhc3NpZ25lZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBzZXQodmFsdWVzPXt9LCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXJ9ID0gbWU7XG5cbiAgICAgICAgY29udGFpbmVyLnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHN1cGVyLnNldCh2YWx1ZXMpO1xuXG4gICAgICAgIGNvbnRhaW5lci5zaWxlbnRWZG9tVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNpbGVudCB8fCAhY29udGFpbmVyLm5lZWRzVmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLnByb21pc2VVcGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgY2FsbGluZyBzZXQoKSB3aXRoIHRoZSBzaWxlbnQgZmxhZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKi9cbiAgICBzZXRTaWxlbnQodmFsdWVzPXt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldCh2YWx1ZXMsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBhcHBOYW1lICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBjb250YWluZXJDbHM6IG1lLmNvbnRhaW5lckNscyxcbiAgICAgICAgICAgIGNvbnRhaW5lcklkIDogbWUuY29udGFpbmVySWQsXG4gICAgICAgICAgICB3aW5kb3dJZCAgICA6IG1lLndpbmRvd0lkXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExheW91dCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkNhcmRcbiAqIEBleHRlbmRzIE5lby5sYXlvdXQuQmFzZVxuICovXG5jbGFzcyBDYXJkIGV4dGVuZHMgQmFzZSB7XG4gICAgLypcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgQ1NTIGNsYXNzIGZvciBhbiBhY3RpdmUgaXRlbSBpbnNpZGUgdGhlIGNhcmQgbGF5b3V0XG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBhY3RpdmVJdGVtQ2xzPSduZW8tYWN0aXZlLWl0ZW0nXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhY3RpdmVJdGVtQ2xzID0gJ25lby1hY3RpdmUtaXRlbSdcbiAgICAvKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBDU1MgY2xhc3MgZm9yIGFuIGluYWN0aXZlIGl0ZW0gaW5zaWRlIHRoZSBjYXJkIGxheW91dFxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gaW5hY3RpdmVJdGVtQ2xzPSduZW8taW5hY3RpdmUtaXRlbSdcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGluYWN0aXZlSXRlbUNscyA9ICduZW8taW5hY3RpdmUtaXRlbSdcbiAgICAvKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBDU1MgY2xhc3MgZm9yIGFuIGl0ZW0gaW5zaWRlIHRoZSBjYXJkIGxheW91dFxuICAgICAqIEBtZW1iZXIgaXRlbUNsc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXRlbUNscyA9ICduZW8tbGF5b3V0LWNhcmQtaXRlbSdcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHNsaWRlRGlyZWN0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGljb25Qb3NpdGlvbnM9Wydob3Jpem9udGFsJywndmVydGljYWwnLG51bGxdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgc2xpZGVEaXJlY3Rpb25zID0gWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5DYXJkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkNhcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWNhcmQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWNhcmQnLFxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgaXRlbSBpbmRleCBvZiB0aGUgY2FyZCwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICAgICAgICogQ2hhbmdlIHRoaXMgdmFsdWUgdG8gYWN0aXZhdGUgYSBkaWZmZXJlbnQgY2FyZC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhY3RpdmVJbmRleF89MFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlSW5kZXhfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbnRhaW5lckNscz0nbmVvLWxheW91dC1jYXJkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ2xzOiAnbmVvLWxheW91dC1jYXJkJyxcbiAgICAgICAgLypcbiAgICAgICAgICogUmVtb3ZlIHRoZSBET00gb2YgaW5hY3RpdmUgY2FyZHMuXG4gICAgICAgICAqIFRoaXMgd2lsbCBrZWVwIHRoZSBpbnN0YW5jZXMgJiB2ZG9tIHRyZWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW92ZUluYWN0aXZlQ2FyZHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogdHJ1ZSxcbiAgICAgICAgLypcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNsaWRlRGlyZWN0aW9uXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzbGlkZURpcmVjdGlvbl86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyB0aGUgQ1NTIGNsYXNzZXMgb2YgdGhlIGNvbnRhaW5lciBpdGVtcyB0aGlzIGxheW91dCBpcyBib3VuZCB0by5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhY3RpdmVJbmRleC5cbiAgICAgKiBMYXp5IGxvYWRzIGl0ZW1zIHdoaWNoIHVzZSBhIG1vZHVsZSBjb25maWcgY29udGFpbmluZyBhIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldEFjdGl2ZUluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXIsIHJlbW92ZUluYWN0aXZlQ2FyZHN9ID0gbWUsXG4gICAgICAgICAgICBzQ2ZnICAgICAgICAgICAgPSBtZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG5lZWRzVHJhbnNpdGlvbiA9IG1lLnNsaWRlRGlyZWN0aW9uICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGksIGlzQWN0aXZlSW5kZXgsIGl0ZW0sIGl0ZW1zLCBsZW4sIG1vZHVsZSwgd3JhcHBlckNscztcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSAmJiBjb250YWluZXIpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gY29udGFpbmVyLml0ZW1zO1xuICAgICAgICAgICAgbGVuICAgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghaXRlbXNbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgTmVvLmVycm9yKCdUcnlpbmcgdG8gYWN0aXZhdGUgYSBub24gZXhpc3RpbmcgY2FyZCcsIHZhbHVlLCBpdGVtcylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBydW4gdGhlIGxvb3AgdHdpY2UsIHNpbmNlIGxhenkgbG9hZGluZyBhIG1vZHVsZSBhdCBhIGhpZ2hlciBpbmRleCBkb2VzIGFmZmVjdCBsb3dlciBpbmRleGVzXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlID0gaXRlbXNbaV0ubW9kdWxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHZhbHVlICYmIE5lby50eXBlT2YobW9kdWxlKSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXNBY3RpdmVJbmRleCA9IGkgPT09IHZhbHVlO1xuICAgICAgICAgICAgICAgIGl0ZW0gICAgICAgICAgPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgID0gaXRlbS5tb2R1bGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVJbmRleCAmJiBOZW8udHlwZU9mKG1vZHVsZSkgPT09ICdGdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGF3YWl0IG1lLmxvYWRNb2R1bGUoaXRlbSwgaSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5lby5jb21wb25lbnQuQmFzZSkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyQ2xzID0gaXRlbS53cmFwcGVyQ2xzO1xuXG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBpc0FjdGl2ZUluZGV4ID8gc0NmZy5pbmFjdGl2ZUl0ZW1DbHMgOiBzQ2ZnLmFjdGl2ZUl0ZW1DbHMpO1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoICAgd3JhcHBlckNscywgaXNBY3RpdmVJbmRleCA/IHNDZmcuYWN0aXZlSXRlbUNscyAgIDogc0NmZy5pbmFjdGl2ZUl0ZW1DbHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVJbmFjdGl2ZUNhcmRzIHx8IG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnZkb20ucmVtb3ZlRG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuZWVkc1RyYW5zaXRpb24gJiYgaXRlbS5hY3RpdmF0ZT8uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlSW5hY3RpdmVDYXJkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubW91bnRlZCAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lZWRzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnNsaWRlQ2FyZHModmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1vdmVJbmFjdGl2ZUNhcmRzIHx8IG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7IC8vIGluY2x1ZGUgdGhlIGZ1bGwgdHJlZSB0byBob25vciBuZXcgb3IgY2hhbmdlZCBpbmFjdGl2ZSBjYXJkc1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGx5IHNldHMgdGhlIENTUyBjbGFzc2VzIG9mIHRoZSBjb250YWluZXIgaXRlbXMgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtrZWVwSW5Eb209ZmFsc2VdXG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgsIGtlZXBJbkRvbT1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpc0FjdGl2ZUluZGV4ID0gbWUuYWN0aXZlSW5kZXggPT09IGluZGV4LFxuICAgICAgICAgICAgc0NmZyAgICAgICAgICA9IG1lLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY2hpbGRDbHMgICAgICA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXSxcbiAgICAgICAgICAgIHt2ZG9tfSAgICAgICAgPSBpdGVtO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjaGlsZENscywgc0NmZy5pdGVtQ2xzKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKGNoaWxkQ2xzLCBpc0FjdGl2ZUluZGV4ID8gc0NmZy5hY3RpdmVJdGVtQ2xzIDogc0NmZy5pbmFjdGl2ZUl0ZW1DbHMpO1xuXG4gICAgICAgIGlmICgha2VlcEluRG9tICYmIG1lLnJlbW92ZUluYWN0aXZlQ2FyZHMpIHtcbiAgICAgICAgICAgIHZkb20ucmVtb3ZlRG9tICA9ICFpc0FjdGl2ZUluZGV4O1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gY2hpbGRDbHM7XG4gICAgICAgICAgICBpdGVtLnVwZGF0ZT8uKCkgLy8gY2FuIGdldCBjYWxsZWQgZm9yIGFuIGl0ZW0gY29uZmlnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSBjaGlsZENsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2xpZGVEaXJlY3Rpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNsaWRlRGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnc2xpZGVEaXJlY3Rpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgY29tcG9uZW50LkJhc2UgbW9kdWxlIHdoaWNoIGlzIGRlZmluZWQgdmlhIG1vZHVsZTogKCkgPT4gaW1wb3J0KCcuLi4nKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWRNb2R1bGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXJ9ID0gbWUsXG4gICAgICAgICAgICBpdGVtcyAgICAgICA9IGNvbnRhaW5lci5pdGVtcyxcbiAgICAgICAgICAgIHttb2R1bGV9ICAgID0gaXRlbSxcbiAgICAgICAgICAgIHByb3RvO1xuXG4gICAgICAgIGlmICghTmVvLmlzTnVtYmVyKGluZGV4KSkge1xuICAgICAgICAgICAgaW5kZXggPSBpdGVtcy5pbmRleE9mKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLmlzTG9hZGluZyA9IHRydWU7IC8vIHByZXZlbnQgdGhlIGl0ZW0gZnJvbSBnZXR0aW5nIHF1ZXVlZCBtdWx0aXBsZSB0aW1lcyBpbnNpZGUgZm9ybS5Db250YWluZXJcblxuICAgICAgICBtb2R1bGUgPSBhd2FpdCBtb2R1bGUoKTtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgIHByb3RvICA9IG1vZHVsZS5wcm90b3R5cGU7XG5cbiAgICAgICAgaXRlbS5jbGFzc05hbWUgPSBwcm90by5jbGFzc05hbWU7XG4gICAgICAgIGl0ZW0ubW9kdWxlICAgID0gbW9kdWxlO1xuXG4gICAgICAgIGRlbGV0ZSBpdGVtLmlzTG9hZGluZztcbiAgICAgICAgZGVsZXRlIGl0ZW0udmRvbTtcblxuICAgICAgICBpdGVtc1tpbmRleF0gPSBpdGVtID0gTmVvLmNyZWF0ZShpdGVtKTtcblxuICAgICAgICBtZS5hcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgY29udGFpbmVyLmdldFZkb21JdGVtc1Jvb3QoKS5jbltpbmRleF0gPSBpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKTtcblxuICAgICAgICBjb250YWluZXIuZmlyZSgnY2FyZExvYWRlZCcsIHtpdGVtfSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkSW5kZXhcbiAgICAgKi9cbiAgICBhc3luYyBzbGlkZUNhcmRzKGluZGV4LCBvbGRJbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyfSAgID0gbWUsXG4gICAgICAgICAgICBzbGlkZVZlcnRpY2FsID0gbWUuc2xpZGVEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICB7aXRlbXMsIHZkb219ID0gY29udGFpbmVyLFxuICAgICAgICAgICAgY2FyZCAgICAgICAgICA9IGl0ZW1zW2luZGV4XSxcbiAgICAgICAgICAgIG9sZENhcmQgICAgICAgPSBpdGVtc1tvbGRJbmRleF0sXG4gICAgICAgICAgICBzbGlkZUluICAgICAgID0gaW5kZXggPiBvbGRJbmRleCxcbiAgICAgICAgICAgIHJlY3QgICAgICAgICAgPSBhd2FpdCBjb250YWluZXIuZ2V0RG9tUmVjdChjb250YWluZXIuaWQpLFxuICAgICAgICAgICAgYW5pbWF0aW9uV3JhcHBlciwgc3R5bGUsIHgsIHk7XG5cbiAgICAgICAgZGVsZXRlIG9sZENhcmQudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgaWYgKHNsaWRlVmVydGljYWwpIHtcbiAgICAgICAgICAgIHkgPSBzbGlkZUluID8gMCA6IC1yZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgIDogYCR7MiAqIHJlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gICAgOiBgdHJhbnNsYXRlWSgke3l9cHgpYCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHNsaWRlSW4gPyAwIDogLXJlY3Qud2lkdGg7XG5cbiAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgIDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHt4fXB4KWAsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgOiBgJHsyICogcmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZkb20uY24gPSBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1yZWxhdGl2ZSddLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWFuaW1hdGlvbi13cmFwcGVyJ10sIHN0eWxlLCBjbjogW2NhcmQuY3JlYXRlVmRvbVJlZmVyZW5jZSgpXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF07XG5cbiAgICAgICAgYW5pbWF0aW9uV3JhcHBlciA9IHZkb20uY25bMF0uY25bMF07XG5cbiAgICAgICAgYW5pbWF0aW9uV3JhcHBlci5jbltzbGlkZUluID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShvbGRDYXJkLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSk7XG5cbiAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG5cbiAgICAgICAgYXdhaXQgY29udGFpbmVyLnByb21pc2VVcGRhdGUoKTtcblxuICAgICAgICBhbmltYXRpb25XcmFwcGVyLnN0eWxlLnRyYW5zZm9ybSA9IHNsaWRlVmVydGljYWwgP1xuICAgICAgICAgICAgYHRyYW5zbGF0ZVkoJHtzbGlkZUluID8gLXJlY3QuaGVpZ2h0IDogMH1weClgIDpcbiAgICAgICAgICAgIGB0cmFuc2xhdGVYKCR7c2xpZGVJbiA/IC1yZWN0LndpZHRoICA6IDB9cHgpYDtcblxuICAgICAgICBhd2FpdCBjb250YWluZXIucHJvbWlzZVVwZGF0ZSgpO1xuXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzAwKTsgLy8gdHJhbnNpdGlvbiBkdXJhdGlvbiBkZWZpbmVkIHZpYSBDU1MgZm9yIG5vd1xuXG4gICAgICAgIHZkb20uY24gPSBbXTtcblxuICAgICAgICBjb250YWluZXIuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHZkb20uY24ucHVzaChpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2xkQ2FyZC52ZG9tLnJlbW92ZURvbSA9IHRydWU7XG5cbiAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG5cbiAgICAgICAgYXdhaXQgY29udGFpbmVyLnByb21pc2VVcGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYWN0aXZlSW5kZXggICAgICAgIDogbWUuYWN0aXZlSW5kZXgsXG4gICAgICAgICAgICBjb250YWluZXJDbHMgICAgICAgOiBtZS5jb250YWluZXJDbHMsXG4gICAgICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiBtZS5yZW1vdmVJbmFjdGl2ZUNhcmRzLFxuICAgICAgICAgICAgc2xpZGVEaXJlY3Rpb24gICAgIDogbWUuc2xpZGVEaXJlY3Rpb25cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FyZCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkZpdFxuICogQGV4dGVuZHMgTmVvLmxheW91dC5CYXNlXG4gKi9cbmNsYXNzIEZpdCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5GaXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5sYXlvdXQuRml0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1maXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWZpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29udGFpbmVyQ2xzPSduZW8tbGF5b3V0LWZpdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNsczogJ25lby1sYXlvdXQtZml0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxseSBzZXRzIHRoZSBDU1MgY2xhc3NlcyBvZiB0aGUgY29udGFpbmVyIGl0ZW1zIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpdGVtLmlnbm9yZUxheW91dCkge1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gTmVvQXJyYXkudW5pb24oaXRlbS53cmFwcGVyQ2xzLCAnbmVvLWxheW91dC1maXQtaXRlbScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBDU1MgcnVsZXMgZnJvbSBhIGNvbnRhaW5lciBpdGVtIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gc3dpdGNoaW5nIHRvIGEgZGlmZmVyZW50IGxheW91dC5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoIWl0ZW0uaWdub3JlTGF5b3V0KSB7XG4gICAgICAgICAgICBsZXQge3dyYXBwZXJDbHN9ID0gaXRlbTtcblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsICduZW8tbGF5b3V0LWZpdC1pdGVtJyk7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZpdCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkZsZXhib3hcbiAqIEBleHRlbmRzIE5lby5sYXlvdXQuQmFzZVxuICovXG5jbGFzcyBGbGV4Ym94IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBhbGlnblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhbGlnblZhbHVlcz1bJ2NlbnRlcicsJ2VuZCcsJ3N0YXJ0Jywnc3RyZXRjaCcsbnVsbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhbGlnblZhbHVlcyA9IFsnY2VudGVyJywgJ2VuZCcsICdzdGFydCcsICdzdHJldGNoJywgbnVsbF1cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGRpcmVjdGlvblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkaXJlY3Rpb25WYWx1ZXM9Wydjb2x1bW4nLCdjb2x1bW4tcmV2ZXJzZScsJ3JvdycsJ3Jvdy1yZXZlcnNlJyxudWxsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRpcmVjdGlvblZhbHVlcyA9IFsnY29sdW1uJywgJ2NvbHVtbi1yZXZlcnNlJywgJ3JvdycsICdyb3ctcmV2ZXJzZScsIG51bGxdXG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBwYWNrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHBhY2tWYWx1ZXM9WydjZW50ZXInLCdlbmQnLCdzdGFydCcsbnVsbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBwYWNrVmFsdWVzID0gWydjZW50ZXInLCAnZW5kJywgJ3N0YXJ0JywgbnVsbF1cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHdyYXBcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gd3JhcFZhbHVlcz1bJ25vd3JhcCcsJ3dyYXAnLCd3cmFwLXJldmVyc2UnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHdyYXBWYWx1ZXMgPSBbJ25vd3JhcCcsICd3cmFwJywgJ3dyYXAtcmV2ZXJzZSddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5sYXlvdXQuRmxleGJveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxheW91dC5GbGV4Ym94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1mbGV4Ym94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xheW91dC1mbGV4Ym94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2NlbnRlcicsICdlbmQnLCAnc3RhcnQnLCAnc3RyZXRjaCcsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFsaWduXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ25fOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnY29sdW1uJywgJ2NvbHVtbi1yZXZlcnNlJywgJ3JvdycsICdyb3ctcmV2ZXJzZScsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRpcmVjdGlvbl89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmbGV4IGNzcyBhbGxvd3MgZ2FwLiBUaGlzIGFkZHMgaXQgdG8gdGhlIGNvbXBvbmVudCBzdHlsZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGdhcF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGdhcF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6ICdjZW50ZXInLCAnZW5kJywgJ3N0YXJ0JywgbnVsbFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcGFja189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhY2tfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIGNsYXNzTmFtZSBwcmVmaXhcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcmVmaXg9J25lby1mbGV4LSdcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogJ25lby1mbGV4LScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6IG5vd3JhcCwgd3JhcCwgd3JhcHJldmVyc2VcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB3cmFwXz0nbm93cmFwJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBfOiAnbm93cmFwJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIENvbnRhaW5lciBDU1MgY2xzIGFmdGVyIFwiYWxpZ25cIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWxpZ24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMudXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdhbGlnbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29udGFpbmVyIENTUyBjbHMgYWZ0ZXIgXCJkaXJlY3Rpb25cIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnVwZGF0ZUlucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZGlyZWN0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDb250YWluZXIgc3R5bGUgdG8gYWRkIGEgZ2FwIHRvIGRpc3BsYXk6ZmxleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRHYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgIW9sZFZhbHVlKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHtjb250YWluZXJ9ICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3cmFwcGVyU3R5bGV9ID0gY29udGFpbmVyO1xuXG4gICAgICAgIHdyYXBwZXJTdHlsZS5nYXAgPSB2YWx1ZTtcblxuICAgICAgICBjb250YWluZXIud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29udGFpbmVyIENTUyBjbHMgYWZ0ZXIgXCJwYWNrXCIgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMudXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdwYWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDb250YWluZXIgQ1NTIGNscyBhZnRlciBcIndyYXBcIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXcmFwKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnVwZGF0ZUlucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnd3JhcCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmxleCB2YWx1ZSB0byBhbiBpdGVtIG9mIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIGFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmICghaXRlbS53cmFwcGVyU3R5bGUpIHJldHVybjtcblxuICAgICAgICBsZXQgc3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZSxcbiAgICAgICAgICAgIGZsZXggID0gc3R5bGUuZmxleCB8fCBpdGVtLmZsZXggfHwgKHRoaXMuYWxpZ24gPT09ICdzdHJldGNoJyA/IDEgOiAnMCAxIGF1dG8nKTtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKGZsZXgpKSB7XG4gICAgICAgICAgICBmbGV4ID0gYCR7ZmxleH0gMSAwJWBcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLmZsZXggPSBmbGV4O1xuICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBDU1MgY2xhc3NlcyB0byB0aGUgY29udGFpbmVyIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvXG4gICAgICovXG4gICAgYXBwbHlSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBwcmVmaXh9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ2xheW91dC5GbGV4Ym94OiBhcHBseVJlbmRlckF0dHJpYnV0ZXMgLT4gY29udGFpbmVyIG5vdCB5ZXQgY3JlYXRlZCcsIG1lLmNvbnRhaW5lcklkKVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdjb250YWluZXInKTtcblxuICAgICAgICBtZS5hbGlnbiAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdhbGlnbi0nICAgICArIG1lLmFsaWduKTtcbiAgICAgICAgbWUuZGlyZWN0aW9uICYmIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnZGlyZWN0aW9uLScgKyBtZS5kaXJlY3Rpb24pO1xuICAgICAgICBtZS5wYWNrICAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdwYWNrLScgICAgICArIG1lLnBhY2spO1xuICAgICAgICBtZS53cmFwICAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICd3cmFwLScgICAgICArIG1lLndyYXApO1xuXG4gICAgICAgIGNvbnRhaW5lci53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcImFsaWduXCIgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBbGlnbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVzdElucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWxpZ25WYWx1ZXMnLCAnYWxpZ24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcImRpcmVjdGlvblwiIGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICovXG4gICAgYmVmb3JlU2V0RGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkaXJlY3Rpb25WYWx1ZXMnLCAnZGlyZWN0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyB2YWx1ZSBmb3IgXCJwYWNrXCIgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYWNrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdwYWNrVmFsdWVzJywgJ3BhY2snKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcIndyYXBcIiBpcyB2YWxpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGJlZm9yZVNldFdyYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlc3RJbnB1dFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3dyYXBWYWx1ZXMnLCAnd3JhcCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgQ1NTIHJ1bGVzIGZyb20gYSBjb250YWluZXIgaXRlbSB0aGlzIGxheW91dCBpcyBib3VuZCB0by5cbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHN3aXRjaGluZyB0byBhIGRpZmZlcmVudCBsYXlvdXQuXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgIHN0eWxlLmZsZXggPSBpdGVtLmZsZXggfHwgbnVsbDtcbiAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSBzdHlsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIENTUyBydWxlcyBmcm9tIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiBzd2l0Y2hpbmcgdG8gYSBkaWZmZXJlbnQgbGF5b3V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBwcmVmaXh9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ2xheW91dC5GbGV4Ym94OiByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzIC0+IGNvbnRhaW5lciBub3QgeWV0IGNyZWF0ZWQnLCBtZS5jb250YWluZXJJZClcbiAgICAgICAgfVxuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnY29udGFpbmVyJyk7XG5cbiAgICAgICAgbWUuYWxpZ24gICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnYWxpZ24tJyAgICAgKyBtZS5hbGlnbik7XG4gICAgICAgIG1lLmRpcmVjdGlvbiAmJiBOZW9BcnJheS5yZW1vdmUod3JhcHBlckNscywgcHJlZml4ICsgJ2RpcmVjdGlvbi0nICsgbWUuZGlyZWN0aW9uKTtcbiAgICAgICAgbWUucGFjayAgICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAncGFjay0nICAgICAgKyBtZS5wYWNrKTtcbiAgICAgICAgbWUud3JhcCAgICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnd3JhcC0nICAgICAgKyBtZS53cmFwKTtcblxuICAgICAgICBjb250YWluZXIud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyB2YWx1ZSBmb3IgcHJvcGVydHlOYW1lIGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWxpZFZhbHVlc05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICB0ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHZhbGlkVmFsdWVzTmFtZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGxldCB2YWxpZFZhbHVlcyA9IHRoaXMuZ2V0U3RhdGljQ29uZmlnKHZhbGlkVmFsdWVzTmFtZSk7XG5cbiAgICAgICAgaWYgKCFOZW9BcnJheS5oYXNJdGVtKHZhbGlkVmFsdWVzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcih0aGlzLmNvbnRhaW5lcklkLCAnLT4gbGF5b3V0OiBzdXBwb3J0ZWQgdmFsdWVzIGZvciBcIicgKyBwcm9wZXJ0eU5hbWUgKyAnXCIgYXJlJyAsIHZhbGlkVmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYWxpZ24gICAgOiBtZS5hbGlnbixcbiAgICAgICAgICAgIGRpcmVjdGlvbjogbWUuZGlyZWN0aW9uLFxuICAgICAgICAgICAgZ2FwICAgICAgOiBtZS5nYXAsXG4gICAgICAgICAgICBwYWNrICAgICA6IG1lLnBhY2ssXG4gICAgICAgICAgICBwcmVmaXggICA6IG1lLnByZWZpeCxcbiAgICAgICAgICAgIHdyYXAgICAgIDogbWUud3JhcFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29udGFpbmVyIENTUyB3cmFwcGVyQ2xzXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBwcmVmaXh9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmIChjb250YWluZXI/LnZub2RlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyBwcm9wZXJ0eU5hbWUgKyAnLScgKyBvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCBwcmVmaXggKyBwcm9wZXJ0eU5hbWUgKyAnLScgKyB2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZsZXhib3gpO1xuIiwiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxheW91dC5HcmlkXG4gKiBAZXh0ZW5kcyBOZW8ubGF5b3V0LkJhc2VcbiAqL1xuY2xhc3MgR3JpZCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5HcmlkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkdyaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWhib3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWdyaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbnRhaW5lckNscz0nbmVvLWxheW91dC1maXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJDbHM6ICduZW8tbGF5b3V0LWdyaWQnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhHcmlkKTtcbiIsImltcG9ydCBGbGV4Ym94IGZyb20gJy4vRmxleGJveC5tanMnO1xuXG4vKipcbiAqIFRoZSBIQm94IGxheW91dCBhbGxvd3MgeW91IHRvIGFycmFuZ2UgY29tcG9uZW50cyBob3Jpem9udGFsbHkgaW4gYSBjb250YWluZXIuXG4gKiBAY2xhc3MgTmVvLmxheW91dC5IQm94XG4gKiBAZXh0ZW5kcyBOZW8ubGF5b3V0LkZsZXhib3hcbiAqL1xuY2xhc3MgSEJveCBleHRlbmRzIEZsZXhib3gge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5IQm94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkhCb3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWhib3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWhib3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXJlY3Rpb249J3JvdydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbjogJ3JvdydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmbGV4IHZhbHVlIHRvIGFuIGl0ZW0gb2YgdGhlIGNvbnRhaW5lciB0aGlzIGxheW91dCBpcyBib3VuZCB0b1xuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG8gbm90IGFwcGx5IGZsZXggaWYgZml4ZWQgd2lkdGhcbiAgICAgICAgIWl0ZW0ud2lkdGggJiYgc3VwZXIuYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhIQm94KTtcbiIsImltcG9ydCBGbGV4Ym94IGZyb20gJy4vRmxleGJveC5tanMnO1xuXG4vKipcbiAqIFRoZSBWQm94IGxheW91dCBhbGxvd3MgeW91IHRvIGFycmFuZ2UgY29tcG9uZW50cyB2ZXJ0aWNhbGx5IGluIGEgY29udGFpbmVyLlxuICogQGNsYXNzIE5lby5sYXlvdXQuVkJveFxuICogQGV4dGVuZHMgTmVvLmxheW91dC5GbGV4Ym94XG4gKi9cbmNsYXNzIFZCb3ggZXh0ZW5kcyBGbGV4Ym94IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5sYXlvdXQuVkJveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxheW91dC5WQm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC12Ym94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xheW91dC12Ym94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGlyZWN0aW9uPSdjb2x1bW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXJlY3Rpb246ICdjb2x1bW4nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmxleCB2YWx1ZSB0byBhbiBpdGVtIG9mIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIGFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIC8vIERvIG5vdCBhcHBseSBmbGV4IGlmIGZpeGVkIGhlaWdodFxuICAgICAgICAhaXRlbS5oZWlnaHQgJiYgc3VwZXIuYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWQm94KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=