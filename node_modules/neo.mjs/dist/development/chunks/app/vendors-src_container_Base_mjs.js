"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_container_Base_mjs"],{

/***/ "./src/container/Base.mjs":
/*!********************************!*\
  !*** ./src/container/Base.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _layout_Card_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layout/Card.mjs */ "./src/layout/Card.mjs");
/* harmony import */ var _layout_Fit_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../layout/Fit.mjs */ "./src/layout/Fit.mjs");
/* harmony import */ var _layout_Grid_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layout/Grid.mjs */ "./src/layout/Grid.mjs");
/* harmony import */ var _layout_HBox_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layout/HBox.mjs */ "./src/layout/HBox.mjs");
/* harmony import */ var _layout_VBox_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layout/VBox.mjs */ "./src/layout/VBox.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");











const byWeight = ({ weight : lhs = 0 }, { weight : rhs = 0 }) => lhs - rhs;

/**
 * @class Neo.container.Base
 * @extends Neo.component.Base
 */
class Container extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Base'
         * @protected
         */
        className: 'Neo.container.Base',
        /**
         * @member {String} ntype='container'
         * @protected
         */
        ntype: 'container',
        /**
         * @member {String[]} baseCls=['neo-container']
         */
        baseCls: ['neo-container'],
        /**
         * Default configuration for child items within this container.
         * This config uses a descriptor to enable deep merging with instance based itemDefaults.
         * @member {Object} itemDefaults_={[isDescriptor]: true, merge: 'deep', value: null}
         * @reactive
         */
        itemDefaults_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * An array or an object of config objects|instances|modules for each child component
         * @member {Object[]} items_=[]
         * @example
         * import Button      from '../button/Base.mjs';
         * import Toolbar     from '../toolbar/Base.mjs';
         *
         * let myButton = Neo.create(Button, {
         *     text: 'Button1'
         * });
         *
         * Neo.create(Toolbar, {
         *     //...
         *     items: {
         *         buttonRef : {
         *             ntype: 'button',   // by ntype
         *             text : 'Button 2'
         *         },
         *         secondRef : {
         *             module: Button,    // by imported module
         *             text  : 'Button 3'
         *         }
         *     }
         * });
         *
         * or
         * @example
         * import Button      from '../button/Base.mjs';
         * import MyRedButton from 'myapp/MyRedButton.mjs';
         * import Toolbar     from '../toolbar/Base.mjs';
         *
         * let myButton = Neo.create(Button, {
         *     text: 'Button1'
         * });
         *
         * Neo.create(Toolbar, {
         *     //...
         *     items: [
         *         myButton,              // passed instance
         *         {
         *             ntype: 'button',   // by ntype
         *             text : 'Button 2'
         *         },
         *         {
         *             module: Button,    // by imported module
         *             text  : 'Button 3'
         *         },
         *         MyRedButton            // you can drop imported modules directly into the items array
         *     ]
         * });
         * @reactive
         */
        items_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_9__.isDescriptor]: true,
            clone         : 'shallow',
            cloneOnGet    : 'none',
            isEqual       : () => false,
            value         : []
        },
        /**
         * It is crucial to define a layout before the container does get vdomInitialized.
         * Meaning: onConstructed() is the latest life-cycle point.
         * You can use layout: 'base', in case you do not need a layout at all.
         * @member {Object|String|null} layout_={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        layout_: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Object} _vdom={cn: []}
         */
        _vdom:
        {cn: []}
    }

    /**
     * Inserts an item or array of items at the last index
     * @param {Object|Array} item
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    add(item) {
        let me = this;
        return me.insert(me.items ? me.items.length : 0, item)
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        let me = this;

        super.afterSetAppName(value, oldValue);

        if (value && me.items) {
            me.items.forEach(item => {
                if (!Neo.isString(item)) {
                    item.appName = value
                }
            })
        }

        if (value && me.layout) {
            me.layout.appName = value
        }
    }

    /**
     * @param {Neo.layout.Base|null} value
     * @param {Neo.layout.Base|null} oldValue
     * @protected
     */
    afterSetLayout(value, oldValue) {
        let me = this;

        if (me.vnodeInitialized) {
            oldValue?.removeRenderAttributes();
            value?.applyRenderAttributes();

            me.items.forEach((item, index) => {
                oldValue?.removeChildAttributes(item, index);
                value?.applyChildAttributes(item, index)
            })
        }

        oldValue?.destroy?.()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            super.afterSetMounted(value, oldValue);

            for (let i = 0, {items} = this, {length} = items; i < length; i++) {
                if (!items[i].vdom.removeDom) {
                    items[i].mounted = value
                }
            }
        }
    }

    /**
     * Triggered after the needsVdomUpdate config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetNeedsVdomUpdate(value, oldValue) {
        if (!value) {
            this.items?.forEach(item => {
                // check for e.g. Toolbar items like '->'
                if (typeof item !== 'string') {
                    // we can not set the config directly => it could already be false,
                    // and we still want to pass it further into subtrees
                    item._needsVdomUpdate = false;
                    item.afterSetNeedsVdomUpdate?.(false, true)
                }
            })
        }
    }

    /**
     * Triggered after the vnodeInitializing config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsVnodeInitializing(value, oldValue) {
        if (oldValue !== undefined) {
            let {items} = this,
                i       = 0,
                len     = items.length;

            for (; i < len; i++) {
                if (!items[i].vdom.removeDom) {
                    items[i].isVnodeInitializing = value
                }
            }
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        value && this.items?.forEach(item => {
            if (!Neo.isString(item)) {
                item.theme = value
            }
        })
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let me       = this,
            {layout} = me;

        value && me.items?.forEach(item => {
            if (!Neo.isString(item)) {
                item.windowId = value
            }
        })

        if (value && layout && !Neo.isString(layout)) {
            layout.windowId = value
        }
    }

    /**
     * Convert items object to an array for onward storage as _items
     * @param {Object|Object[]} value
     * @param {Object|Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
     beforeSetItems(value, oldValue) {
        if (Neo.typeOf(value) === 'Object') {
            let result = [],
                hasWeight, item;

            for (const ref in value) {
                item = value[ref]

                item.reference = ref;
                result.push(item);
                hasWeight ||= ('weight' in item)
            }

            if (hasWeight) {
                result.sort(byWeight)
            }

            value = result
        }

        return value
    }

    /**
     * @param {Object|String} value
     * @param {Object|String|Neo.layout.Base} oldValue
     * @returns {Neo.layout.Base}
     * @protected
     */
    beforeSetLayout(value, oldValue) {
        return this.createLayout(value)
    }

    /**
     * @param {*} item
     * @param {Number} index
     * @returns {Neo.component.Base|Object} Object for lazy loaded items
     */
    createItem(item, index) {
        let me       = this,
            config   = {appName: me.appName, parentId: me.id, parentIndex: index, windowId: me.windowId},
            defaults = {...me.itemDefaults},
            lazyLoadItem, module, parent;

        if (defaults) {
            if (item.module) {
                delete defaults.ntype;
            }

            if (item.ntype) {
                delete defaults.module;
            }
        }

        switch (Neo.typeOf(item)) {
            case 'NeoClass': {
                item = Neo.create({
                    theme: item.config.theme || me.theme,
                    ...defaults,
                    module: item,
                    ...config
                });
                break
            }

            case 'NeoInstance': {
                parent = item.parent;

                if (parent && parent !== me) {
                    parent.remove?.(item, false);
                    delete item.vdom.removeDom;

                    // Convenience logic, especially for moving components into different browser windows:
                    // A component might rely on references & handler methods inside the previous controller realm
                    // todo: We need ?. until functional.component.Base supports controllers
                    if (!item.controller && !me.getController() && parent.getController?.()) {
                        item.controller = {parent: parent.getController()}
                    }
                }

                item.set(config);
                item.getStateProvider?.()?.createBindings(item);
                break
            }

            case 'Object': {
                if (defaults) {
                    Neo.assignDefaults(item, defaults)
                }

                if (!item.module && !item.ntype && !item.className) {
                    item.module = _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
                }

                module = item.module;

                lazyLoadItem = module && !module.isClass && Neo.isFunction(module);

                if (module && !lazyLoadItem) {
                    item.className = module.prototype.className;
                    item.theme     = defaults.theme || module.config.theme || me.theme
                }

                if (item.handlerScope === 'this') {
                    item.handlerScope = me;

                    if (Neo.typeOf(item.handler) === 'String' && Neo.typeOf(me[item.handler]) === 'Function') {
                        item.handler = me[item.handler]
                    }
                }

                Object.assign(item, config);

                if (!lazyLoadItem) {
                    item = Neo[item.className ? 'create' : 'ntype'](item)
                } else {
                    item.vdom = Object.assign(item.vdom || {}, {removeDom: true})
                }

                break
            }

            case 'String': {
                item = Neo.create({
                    module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                    vdom  : {text: item},
                    ...config
                });

                break
            }
        }

        return item
    }

    /**
     * @protected
     */
    createItems() {
        let me        = this,
            items     = me._items,
            itemsRoot = me.getVdomItemsRoot(),
            {layout}  = me,
            vdom;

        itemsRoot.cn = [];

        items.forEach((item, index) => {
            items[index] = item = me.createItem(item, index);

            if (item instanceof Neo.core.Base) {
                layout?.applyChildAttributes(item, index);
                vdom = item.createVdomReference()
            } else {
                vdom = item.vdom
            }

            itemsRoot.cn.push(vdom)
        });

        // We need to add items into the vdom
        me.updateDepth = -1;
        me.isConstructed && me.update();

        me.fire('itemsCreated', {id: me.id, items})
    }

    /**
     * @param {Object|String|Neo.layout.Base} value
     * @protected
     * @returns {Neo.layout.Base}
     */
    createLayout(value) {
        if (value) {
            let me                      = this,
                {appName, id, windowId} = me;

            if (value instanceof _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] && value.isLayout) {
                Object.assign(value, {appName, containerId: id, windowId})
            } else {
                value = me.parseLayoutClass(value);
                Object.assign(value, {appName, containerId: id, windowId});
                value = Neo.ntype(value)
            }
        }

        return value
    }

    /**
     * Destroys all components inside this.items before the super() call.
     * @param {Boolean} [updateParentVdom=false] true to remove the component from the parent vdom => real dom
     * @param {Boolean} [silent=false] true to update the vdom silently (useful for destroying multiple child items in a row)
     */
    destroy(updateParentVdom=false, silent=false) {
        this.layout?.destroy();

        this.items?.forEach(item => {
            item.destroy?.(false, true)
        });

        super.destroy(updateParentVdom, silent)
    }

    /**
     * An alternative for `getReference()` which is useful before a component tree got created.
     * `getReference()` relies on child items being registered inside `manager.Component`,
     * while this method simply walks down the items array.
     *
     * However, classes / modules inside the items tree can not get parsed further.
     * @param {String} reference
     * @param {Object[]} items=this.items
     * @returns {Object|Neo.component.Base|null}
     */
    getItem(reference, items=this.items) {
        let i   = 0,
            len = items.length,
            childItem, item;

        for (; i < len; i++) {
            item = items[i];
            if (item.reference === reference) {
                return item
            } else if (item.items) {
                childItem = this.getItem(reference, item.items);

                if (childItem) {
                    return childItem
                }
            }
        }

        return null
    }

    /**
     * Specify a different vdom items root if needed (useful in case this container uses a wrapper node).
     * @returns {Object} The new vdom items root
     */
    getVdomItemsRoot() {
        return this.getVdomRoot()
    }

    /**
     * Finds the index of a direct child component inside this.items.
     * @param {Neo.component.Base|String} itemId Either the item reference or the item id
     * @returns {Number} -1 in case no match was found
     */
    indexOf(itemId) {
        let me  = this,
            i   = 0,
            len = me.items?.length || 0;

        if (!Neo.isString(itemId)) {
            itemId = itemId.id;
        }

        for (; i < len; i++) {
            if (me.items[i].id === itemId) {
                return i
            }
        }

        return -1
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        let me      = this,
            {items} = me,
            i, len, returnArray;

        if (Array.isArray(item)) {
            i           = 0;
            len         = item.length;
            returnArray = [];

            for (; i < len; i++) {
                // insert the array backwards
                returnArray.unshift(me.insert(index, item[len - 1 - i], true))
            }

            item = returnArray
        } else {
            item = me.createItem(item, index);

            // added the true param => for card layouts, we do not want a dynamically inserted cmp to get removed right away
            // since it will most likely get activated right away
            me.layout.applyChildAttributes(item, index, true);

            items.splice(index, 0, item);

            me.items = items;

            me.getVdomItemsRoot().cn.splice(index, 0, item.createVdomReference())
        }

        if (!silent) {
            me.updateDepth = -1; // pass the full vdom tree to honor new nested component trees

            me.promiseUpdate().then(() => {
                me.fire('insert', {index, item})
            })
        }

        return item;
    }

    /**
     * Load items from a remote endpoint.
     * See: https://github.com/neomjs/neo/tree/dev/examples/serverside
     * The response should return a JSON file in the following format:
     * {"modules": [], "items": []}
     * See: https://github.com/neomjs/neo/blob/dev/examples/serverside/gridContainer/resources/data/grid-container.json
     * It is important to add modules which are not already imported inside your app yet.
     * @param {Object} data
     * @param {Object} [data.options={}]
     * @param {String} data.url
     * @returns {Promise<Object[]>}
     */
    async loadItems({options={}, url}) {
        let response   = await fetch(url, options),
            remoteData = await response.json();

        if (remoteData.modules?.length > 0) {
            await Promise.all(remoteData.modules.map(modulePath => {
                // Adjust relative URLs
                if (!modulePath.startsWith('http')) {
                    modulePath = (Neo.config.environment === 'development' ? '../../' : '../../../../') + modulePath
                }

                return import(/* webpackIgnore: true */ modulePath)
            }))
        }

        return remoteData.items
    }

    /**
     *
     */
    mergeConfig(...args) {
        let me     = this,
            config = super.mergeConfig(...args),
            ctorItems;

        // Avoid any interference on prototype level
        // Does not clone existing Neo instances
        if (config.items) {
            ctorItems = me.constructor.config.items;

            // If we are passed an object, merge the class's own items object into it
            if (Neo.typeOf(config.items) === 'Object') {
                if (Neo.isArray(ctorItems)) {
                    me.items = Neo.clone(config.items, true, true)
                } else {
                    me.items = Neo.merge(Neo.clone(ctorItems), config.items)
                }
            } else {
                me._items = Neo.clone(config.items, true, true)
            }
            delete config.items
        }

        return config
    }

    /**
     * Moves an existing item to a new index
     * @param {Number} fromIndex
     * @param {Number} toIndex
     * @returns {Neo.component.Base}
     */
    moveTo(fromIndex, toIndex) {
        let me   = this,
            item = me.items[fromIndex];

        fromIndex !== toIndex && me.switchItems(toIndex, fromIndex);

        return item
    }

    /**
     *
     */
    onConstructed() {
        let me           = this,
            layoutConfig = me.layout;

        // If the layout is a config object (not an instance), deep clone it
        // to prevent prototype pollution.
        if (layoutConfig && !(layoutConfig instanceof _layout_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            layoutConfig = Neo.clone(layoutConfig, true)
        }

        // in case the Container does not have a layout config, the setter won't trigger
        me._layout = me.createLayout(layoutConfig);
        me._layout?.applyRenderAttributes();

        super.onConstructed();

        me.parseItemConfigs(me.items);
        me.createItems()
    }

    /**
     * @param {Object|String} config
     * @protected
     * @returns {Object} layoutConfig
     */
    parseLayoutClass(config) {
        if (Neo.isObject(config)) {
            if (!config.ntype.startsWith('layout-')) {
                config.ntype = `layout-${config.ntype}`
            }
        } else {
            config = {
                ntype: config.startsWith('layout-') ? config : `layout-${config}`
            }
        }

        return config
    }

    /**
     * Removes a container item by reference
     * @param {Neo.component.Base} component
     * @param {Boolean} [destroyItem=true]
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|null}
     */
    remove(component, destroyItem=true, silent=false) {
        let items = [...this.items],
            i     = 0,
            len   = items.length;

        for (; i < len; i++) {
            if (items[i].id === component.id) {
                return this.removeAt(i, destroyItem, silent)
            }
        }
    }

    /**
     * Clears the item array
     * @param {Boolean} destroyItems=true
     * @param {Boolean} silent=false
     */
    removeAll(destroyItems=true, silent=false) {
        let me = this;

        me.items.forEach(item => {
            if (destroyItems) {
                item.destroy(true, true)
            } else {
                item.mounted = false
            }
        });

        me.items = [];

        me.getVdomItemsRoot().cn = [];

        if (!silent || destroyItems) {
            me.update()
        }
    }

    /**
     * Removes a container item at a given index
     * @param {Number} index
     * @param {Boolean} destroyItem=true
     * @param {Boolean} silent=false
     * @returns {Neo.component.Base|null}
     */
    removeAt(index, destroyItem=true, silent=false) {
        let me      = this,
            {items} = me,
            item;

        if (index >= items.length) {
            Neo.warn('Container.removeAt: index >= items.length. ' + me.id)
        } else {
            item = items[index];

            items.splice(index, 1);

            me.getVdomItemsRoot().cn.splice(index, 1);

            // the next update cycle needs to include direct children
            me.updateDepth = 2;

            !silent && me.update();

            if (destroyItem) {
                item.destroy(true, silent);
                return null
            } else {
                me.layout?.removeChildAttributes(item);
                item.mounted = false;
                return item
            }
        }
    }

    /**
     * Removes the container item at the last index
     * @param {Boolean} [destroyItem=true]
     * @param {Boolean} [silent=false]
     */
    removeLast(destroyItem=true, silent=false) {
        this.removeAt(this.items.length - 1, destroyItem, silent)
    }

    /**
     * Replaces a container item at a given index
     * @param {Number} index
     * @param {Neo.component.Base} item
     * @param {Boolean} destroyItem=true
     * @param {Boolean} silent=false
     */
    replaceAt(index, item, destroyItem=true, silent=false) {
        this.removeAt(index, destroyItem, true);
        this.insert(index, item, silent)
    }

    /**
     * Switches the position of 2 direct child items
     * You can either pass an index (Number) or id (String)
     * @param {Number|String} item1id
     * @param {Number|String} item2id
     */
    switchItems(item1id, item2id) {
        let me         = this,
            item1Index = Neo.isNumber(item1id) ? item1id : me.indexOf(item1id),
            item2Index = Neo.isNumber(item2id) ? item2id : me.indexOf(item2id);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].move(me.items,                 item2Index, item1Index);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].move(me.getVdomItemsRoot().cn, item2Index, item1Index);

        // the next update cycle needs to include direct children
        me.updateDepth = 2;

        me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ }),

/***/ "./src/layout/Base.mjs":
/*!*****************************!*\
  !*** ./src/layout/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * The base class for all other layouts.
 * Use it directly in case you want to create a container without a layout.
 * @class Neo.layout.Base
 * @extends Neo.core.Base
 */
class Layout extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Base'
         * @protected
         */
        className: 'Neo.layout.Base',
        /**
         * @member {String} ntype='layout-base'
         * @protected
         */
        ntype: 'layout-base',
        /**
         * The name of the App this layout belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * The id of the Container instance this layout is bound to
         * @member {?String} containerId=null
         * @protected
         */
        containerId: null,
        /**
         * A layout specific CSS selector which gets added to Container the layout is bound to.
         * @member {String|null} containerCls_=null
         * @protected
         * @reactive
         */
        containerCls_: null,
        /**
         * Identifier for all classes that extend layout.Base
         * @member {Boolean} isLayout=true
         * @protected
         */
        isLayout: true,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @returns {Neo.container.Base|null}
     */
    get container() {
        let {containerId} = this;

        // the instance might not be registered yet
        return Neo.getComponent(containerId) || Neo.get(containerId)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Placeholder method
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    applyChildAttributes(item, index) {}

    /**
     * @param {Boolean} silent=false
     * @protected
     */
    applyRenderAttributes(silent=false) {
        let me                        = this,
            {container, containerCls} = me,
            {wrapperCls}              = container;

        if (containerCls) {
            if (!container) {
                Neo.logError(me.className + ': applyRenderAttributes -> container not yet created', me.containerId)
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, containerCls);

            container[silent ? 'setSilent' :  'set']({wrapperCls})
        }
    }

    /**
     *
     */
    destroy() {
        let me = this;

        me.bind && me.getStateProvider()?.removeBindings(me.id);

        super.destroy()
    }

    /**
     * Returns the container stateProvider or its closest parent stateProvider
     * @param {String} [ntype]
     * @returns {Neo.state.Provider|null}
     */
    getStateProvider(ntype) {
        return this.container.getStateProvider(ntype)
    }

    /**
     * Applies all class configs to this instance
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     */
    initConfig(config, preventOriginalConfig) {
        super.initConfig(config, preventOriginalConfig);

        let me = this;

        me.bind && me.container.getStateProvider()?.parseConfig(me)
    }

    /**
     * Placeholder method
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    removeChildAttributes(item, index) {}

    /**
     * @protected
     */
    removeRenderAttributes() {
        let me                        = this,
            {container, containerCls} = me,
            {wrapperCls}              = container;

        if (containerCls) {
            if (!container) {
                Neo.logError(me.className + ': removeRenderAttributes -> container not yet created', me.containerId)
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, containerCls);

            container.wrapperCls = wrapperCls
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} silent=false
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        let me          = this,
            {container} = me;

        container.silentVdomUpdate = true;

        super.set(values);

        container.silentVdomUpdate = false;

        if (silent || !container.needsVdomUpdate) {
            return Promise.resolve()
        } else {
            return container.promiseUpdate()
        }
    }

    /**
     * Convenience shortcut calling set() with the silent flag
     * @param {Object} values={}
     */
    setSilent(values={}) {
        return this.set(values, true)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Layout));


/***/ }),

/***/ "./src/layout/Card.mjs":
/*!*****************************!*\
  !*** ./src/layout/Card.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Card
 * @extends Neo.layout.Base
 */
class Card extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /*
     * The name of the CSS class for an active item inside the card layout
     * @member {String} activeItemCls='neo-active-item'
     * @static
     */
    static activeItemCls = 'neo-active-item'
    /*
     * The name of the CSS class for an inactive item inside the card layout
     * @member {String} inactiveItemCls='neo-inactive-item'
     * @static
     */
    static inactiveItemCls = 'neo-inactive-item'
    /*
     * The name of the CSS class for an item inside the card layout
     * @member itemCls
     * @static
     */
    static itemCls = 'neo-layout-card-item'
    /**
     * Valid values for slideDirection
     * @member {String[]} iconPositions=['horizontal','vertical',null]
     * @protected
     * @static
     */
    static slideDirections = ['horizontal', 'vertical', null]

    static config = {
        /**
         * @member {String} className='Neo.layout.Card'
         * @protected
         */
        className: 'Neo.layout.Card',
        /**
         * @member {String} ntype='layout-card'
         * @protected
         */
        ntype: 'layout-card',
        /*
         * The item index of the card, which is currently active.
         * Change this value to activate a different card.
         * @member {Number} activeIndex_=0
         */
        activeIndex_: 0,
        /**
         * @member {String|null} containerCls='neo-layout-card'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-card',
        /*
         * Remove the DOM of inactive cards.
         * This will keep the instances & vdom trees
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /*
         * Valid values: 'horizontal', 'vertical', null
         * @member {String|null} slideDirection_=null
         */
        slideDirection_: null
    }

    /**
     * Modifies the CSS classes of the container items this layout is bound to.
     * Automatically gets triggered after changing the value of activeIndex.
     * Lazy loads items which use a module config containing a function.
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    async afterSetActiveIndex(value, oldValue) {
        let me              = this,
            {container, removeInactiveCards} = me,
            sCfg            = me.constructor,
            needsTransition = me.slideDirection && oldValue !== undefined,
            needsUpdate     = false,
            i, isActiveIndex, item, items, len, module, wrapperCls;

        if (Neo.isNumber(value) && container) {
            items = container.items;
            len   = items.length;

            if (!items[value]) {
                Neo.error('Trying to activate a non existing card', value, items)
            }

            // we need to run the loop twice, since lazy loading a module at a higher index does affect lower indexes
            for (i=0; i < len; i++) {
                module = items[i].module;

                if (i === value && Neo.typeOf(module) === 'Function') {
                    needsUpdate = true;
                    break
                }
            }

            for (i=0; i < len; i++) {
                isActiveIndex = i === value;
                item          = items[i];
                module        = item.module;

                if (isActiveIndex && Neo.typeOf(module) === 'Function') {
                    item = await me.loadModule(item, i)
                }

                if (item instanceof Neo.component.Base) {
                    wrapperCls = item.wrapperCls;

                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, isActiveIndex ? sCfg.inactiveItemCls : sCfg.activeItemCls);
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(   wrapperCls, isActiveIndex ? sCfg.activeItemCls   : sCfg.inactiveItemCls);

                    if (removeInactiveCards || needsUpdate) {
                        if (isActiveIndex) {
                            delete item.vdom.removeDom;
                            !needsTransition && item.activate?.()
                        } else if (removeInactiveCards) {
                            item.mounted        = false;
                            item.vdom.removeDom = true
                        }
                    }

                    item.wrapperCls = wrapperCls
                }
            }

            if (needsTransition) {
                await me.slideCards(value, oldValue)
            } else if (removeInactiveCards || needsUpdate) {
                container.updateDepth = -1; // include the full tree to honor new or changed inactive cards
                container.update()
            }
        }
    }

    /**
     * Initially sets the CSS classes of the container items this layout is bound to.
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @param {Boolean} [keepInDom=false]
     */
    applyChildAttributes(item, index, keepInDom=false) {
        let me            = this,
            isActiveIndex = me.activeIndex === index,
            sCfg          = me.constructor,
            childCls      = item.wrapperCls || [],
            {vdom}        = item;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(childCls, sCfg.itemCls);
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(childCls, isActiveIndex ? sCfg.activeItemCls : sCfg.inactiveItemCls);

        if (!keepInDom && me.removeInactiveCards) {
            vdom.removeDom  = !isActiveIndex;
            item.wrapperCls = childCls;
            item.update?.() // can get called for an item config
        } else {
            item.wrapperCls = childCls
        }
    }

    /**
     * Triggered before the slideDirection config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetSlideDirection(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'slideDirection')
    }

    /**
     * Loads a component.Base module which is defined via module: () => import('...')
     * @param {Object} item
     * @param {Number} [index]
     * @returns {Neo.component.Base}
     */
    async loadModule(item, index) {
        let me          = this,
            {container} = me,
            items       = container.items,
            {module}    = item,
            proto;

        if (!Neo.isNumber(index)) {
            index = items.indexOf(item)
        }

        item.isLoading = true; // prevent the item from getting queued multiple times inside form.Container

        module = await module();
        module = module.default;
        proto  = module.prototype;

        item.className = proto.className;
        item.module    = module;

        delete item.isLoading;
        delete item.vdom;

        items[index] = item = Neo.create(item);

        me.applyChildAttributes(item, index);

        container.getVdomItemsRoot().cn[index] = item.createVdomReference();

        container.fire('cardLoaded', {item});

        return item
    }

    /**
     * @param {Number} index
     * @param {Number} oldIndex
     */
    async slideCards(index, oldIndex) {
        let me            = this,
            {container}   = me,
            slideVertical = me.slideDirection === 'vertical',
            {items, vdom} = container,
            card          = items[index],
            oldCard       = items[oldIndex],
            slideIn       = index > oldIndex,
            rect          = await container.getDomRect(container.id),
            animationWrapper, style, x, y;

        delete oldCard.vdom.removeDom;

        if (slideVertical) {
            y = slideIn ? 0 : -rect.height;

            style = {
                flexDirection: 'column',
                height       : `${2 * rect.height}px`,
                transform    : `translateY(${y}px)`,
                width        : `${rect.width}px`
            }
        } else {
            x = slideIn ? 0 : -rect.width;

            style = {
                height   : `${rect.height}px`,
                transform: `translateX(${x}px)`,
                width    : `${2 * rect.width}px`
            }
        }

        vdom.cn = [
            {cls: ['neo-relative'], cn: [
                {cls: ['neo-animation-wrapper'], style, cn: [card.createVdomReference()]}
            ]}
        ];

        animationWrapper = vdom.cn[0].cn[0];

        animationWrapper.cn[slideIn ? 'unshift' : 'push'](oldCard.createVdomReference());

        container.updateDepth = -1;

        await container.promiseUpdate();

        animationWrapper.style.transform = slideVertical ?
            `translateY(${slideIn ? -rect.height : 0}px)` :
            `translateX(${slideIn ? -rect.width  : 0}px)`;

        await container.promiseUpdate();

        await me.timeout(300); // transition duration defined via CSS for now

        vdom.cn = [];

        container.items.forEach(item => {
            vdom.cn.push(item.createVdomReference())
        });

        oldCard.vdom.removeDom = true;

        container.updateDepth = -1;

        await container.promiseUpdate()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Card));


/***/ }),

/***/ "./src/layout/Fit.mjs":
/*!****************************!*\
  !*** ./src/layout/Fit.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Fit
 * @extends Neo.layout.Base
 */
class Fit extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Fit'
         * @protected
         */
        className: 'Neo.layout.Fit',
        /**
         * @member {String} ntype='layout-fit'
         * @protected
         */
        ntype: 'layout-fit',
        /**
         * @member {String|null} containerCls='neo-layout-fit'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-fit'
    }

    /**
     * Initially sets the CSS classes of the container items this layout is bound to.
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        if (!item.ignoreLayout) {
            item.wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(item.wrapperCls, 'neo-layout-fit-item')
        }
    }

    /**
     * Removes all CSS rules from a container item this layout is bound to.
     * Gets called when switching to a different layout.
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    removeChildAttributes(item, index) {
        if (!item.ignoreLayout) {
            let {wrapperCls} = item;

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-layout-fit-item');
            item.wrapperCls = wrapperCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Fit));


/***/ }),

/***/ "./src/layout/Flexbox.mjs":
/*!********************************!*\
  !*** ./src/layout/Flexbox.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Flexbox
 * @extends Neo.layout.Base
 */
class Flexbox extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for align
     * @member {String[]} alignValues=['center','end','start','stretch',null]
     * @protected
     * @static
     */
    static alignValues = ['center', 'end', 'start', 'stretch', null]
    /**
     * Valid values for direction
     * @member {String[]} directionValues=['column','column-reverse','row','row-reverse',null]
     * @protected
     * @static
     */
    static directionValues = ['column', 'column-reverse', 'row', 'row-reverse', null]
    /**
     * Valid values for pack
     * @member {String[]} packValues=['center','end','start',null]
     * @protected
     * @static
     */
    static packValues = ['center', 'end', 'start', null]
    /**
     * Valid values for wrap
     * @member {String[]} wrapValues=['nowrap','wrap','wrap-reverse']
     * @protected
     * @static
     */
    static wrapValues = ['nowrap', 'wrap', 'wrap-reverse']

    static config = {
        /**
         * @member {String} className='Neo.layout.Flexbox'
         * @protected
         */
        className: 'Neo.layout.Flexbox',
        /**
         * @member {String} ntype='layout-flexbox'
         * @protected
         */
        ntype: 'layout-flexbox',
        /**
         * Valid values: 'center', 'end', 'start', 'stretch', null
         * @member {String|null} align_=null
         * @reactive
         */
        align_: null,
        /**
         * Valid values: 'column', 'column-reverse', 'row', 'row-reverse', null
         * @member {String|null} direction_=null
         * @reactive
         */
        direction_: null,
        /**
         * flex css allows gap. This adds it to the component style
         * @member {String} gap_=null
         * @reactive
         */
        gap_: null,
        /**
         * Valid values: 'center', 'end', 'start', null
         * @member {String|null} pack_=null
         * @reactive
         */
        pack_: null,
        /**
         * CSS className prefix
         * @member {String} prefix='neo-flex-'
         */
        prefix: 'neo-flex-',
        /**
         * Valid values: nowrap, wrap, wrapreverse
         * @member {String} wrap_='nowrap'
         * @reactive
         */
        wrap_: 'nowrap'
    }

    /**
     * Updates the Container CSS cls after "align" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAlign(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'align')
    }

    /**
     * Updates the Container CSS cls after "direction" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetDirection(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'direction')
    }

    /**
     * Updates the Container style to add a gap to display:flex
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetGap(value, oldValue) {
        if (!value && !oldValue) return;

        let {container}    = this,
            {wrapperStyle} = container;

        wrapperStyle.gap = value;

        container.wrapperStyle = wrapperStyle
    }

    /**
     * Updates the Container CSS cls after "pack" gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetPack(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'pack')
    }

    /**
     * Updates the Container CSS cls after "wrap" gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetWrap(value, oldValue) {
        oldValue && this.updateInputValue(value, oldValue, 'wrap')
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        if (!item.wrapperStyle) return;

        let style = item.wrapperStyle,
            flex  = style.flex || item.flex || (this.align === 'stretch' ? 1 : '0 1 auto');

        if (flex === 1) {
            flex = '1 1 auto'
        }

        style.flex = flex;
        item.wrapperStyle = style
    }

    /**
     * Applies CSS classes to the container this layout is bound to
     */
    applyRenderAttributes() {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (!container) {
            Neo.logError('layout.Flexbox: applyRenderAttributes -> container not yet created', me.containerId)
        }

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'container');

        me.align     && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'align-'     + me.align);
        me.direction && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'direction-' + me.direction);
        me.pack      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'pack-'      + me.pack);
        me.wrap      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + 'wrap-'      + me.wrap);

        container.wrapperCls = wrapperCls
    }

    /**
     * Checks if the new value for "align" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetAlign(value, oldValue) {
        return this.testInputValue(value, oldValue, 'alignValues', 'align')
    }

    /**
     * Checks if the new value for "direction" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetDirection(value, oldValue) {
        return this.testInputValue(value, oldValue, 'directionValues', 'direction')
    }

    /**
     * Checks if the new value for "pack" is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     * @returns {String|null} value
     */
    beforeSetPack(value, oldValue) {
        return this.testInputValue(value, oldValue, 'packValues', 'pack')
    }

    /**
     * Checks if the new value for "wrap" is valid
     * @param {String} value
     * @param {String} oldValue
     * @protected
     * @returns {String} value
     */
    beforeSetWrap(value, oldValue) {
        return this.testInputValue(value, oldValue, 'wrapValues', 'wrap')
    }

    /**
     * Removes all CSS rules from a container item this layout is bound to.
     * Gets called when switching to a different layout.
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    removeChildAttributes(item, index) {
        let style = item.wrapperStyle || {};

        style.flex = item.flex || null;
        item.wrapperStyle = style
    }

    /**
     * Removes all CSS rules from the container this layout is bound to.
     * Gets called when switching to a different layout.
     * @protected
     */
    removeRenderAttributes() {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (!container) {
            Neo.logError('layout.Flexbox: removeRenderAttributes -> container not yet created', me.containerId)
        }

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'container');

        me.align     && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'align-'     + me.align);
        me.direction && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'direction-' + me.direction);
        me.pack      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'pack-'      + me.pack);
        me.wrap      && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + 'wrap-'      + me.wrap);

        container.wrapperCls = wrapperCls
    }

    /**
     * Checks if the new value for propertyName is valid
     * @param {String|null} value
     * @param {String|null} oldValue
     * @param {String} validValuesName
     * @param {String} propertyName
     * @protected
     * @returns {String|null} value
     */
    testInputValue(value, oldValue, validValuesName, propertyName) {
        let validValues = this.getStaticConfig(validValuesName);

        if (!_util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].hasItem(validValues, value)) {
            Neo.logError(this.containerId, '-> layout: supported values for "' + propertyName + '" are' , validValues);
            return oldValue
        }

        return value;
    }

    /**
     * Updates the Container CSS wrapperCls
     * @param {String|null} value
     * @param {String|null} oldValue
     * @param {String} propertyName
     * @protected
     */
    updateInputValue(value, oldValue, propertyName) {
        let me                  = this,
            {container, prefix} = me,
            {wrapperCls}        = container;

        if (container?.rendered) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, prefix + propertyName + '-' + oldValue);

            if (value !== null) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, prefix + propertyName + '-' + value)
            }

            container.wrapperCls = wrapperCls
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Flexbox));


/***/ }),

/***/ "./src/layout/Grid.mjs":
/*!*****************************!*\
  !*** ./src/layout/Grid.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/layout/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.layout.Grid
 * @extends Neo.layout.Base
 */
class Grid extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.Grid'
         * @protected
         */
        className: 'Neo.layout.Grid',
        /**
         * @member {String} ntype='layout-hbox'
         * @protected
         */
        ntype: 'layout-grid',
        /**
         * @member {String|null} containerCls='neo-layout-fit'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-grid'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Grid));


/***/ }),

/***/ "./src/layout/HBox.mjs":
/*!*****************************!*\
  !*** ./src/layout/HBox.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Flexbox.mjs */ "./src/layout/Flexbox.mjs");


/**
 * @class Neo.layout.HBox
 * @extends Neo.layout.Flexbox
 */
class HBox extends _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.HBox'
         * @protected
         */
        className: 'Neo.layout.HBox',
        /**
         * @member {String} ntype='layout-hbox'
         * @protected
         */
        ntype: 'layout-hbox',
        /**
         * @member {String} direction='row'
         * @protected
         * @reactive
         */
        direction: 'row'
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        // Do not apply flex if fixed width
        !item.width && super.applyChildAttributes(item, index)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HBox));


/***/ }),

/***/ "./src/layout/VBox.mjs":
/*!*****************************!*\
  !*** ./src/layout/VBox.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Flexbox.mjs */ "./src/layout/Flexbox.mjs");


/**
 * @class Neo.layout.VBox
 * @extends Neo.layout.Flexbox
 */
class VBox extends _Flexbox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.layout.VBox'
         * @protected
         */
        className: 'Neo.layout.VBox',
        /**
         * @member {String} ntype='layout-vbox'
         * @protected
         */
        ntype: 'layout-vbox',
        /**
         * @member {String} direction='column'
         * @protected
         * @reactive
         */
        direction: 'column'
    }

    /**
     * Applies the flex value to an item of the container this layout is bound to
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        // Do not apply flex if fixed height
        !item.height && super.applyChildAttributes(item, index)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VBox));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb250YWluZXJfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUQ7QUFDSDtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ1E7O0FBRXZELG9CQUFvQixrQkFBa0IsSUFBSSxrQkFBa0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFTO0FBQ2pDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBWTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQixTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsUUFBUSxPQUFPO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLE9BQU8sU0FBUyxRQUFRLFNBQVMsWUFBWTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLCtCQUErQjtBQUM5QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0ZBQWdGO0FBQ3hHLHdCQUF3QixtQkFBbUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLDJEQUFTO0FBQzNDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw2REFBNkQsR0FBRyxnQkFBZ0I7QUFDaEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFTO0FBQ3JDLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGlCQUFpQjtBQUNsRDs7QUFFQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1Qjs7QUFFeEMsaUNBQWlDLHdEQUFVO0FBQzNDLHNDQUFzQyxtQ0FBbUM7QUFDekUsY0FBYztBQUNkO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBLG1DQUFtQyxZQUFZO0FBQy9DLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLGdCQUFnQjtBQUN2QyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0EscUJBQXFCLFVBQVUsTUFBTTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCx3REFBVTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUVBQXlFLE9BQU87QUFDaEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsdURBQVE7QUFDaEIsUUFBUSx1REFBUTs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUseUJBQXlCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbDBCRDtBQUNDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUk7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYSxhQUFhOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEseUJBQXlCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHVEQUFROztBQUVwQixzREFBc0QsV0FBVztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSx5QkFBeUI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksdURBQVE7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhLFdBQVc7O0FBRXhCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pNSjtBQUNPOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBSTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsdURBQVE7QUFDNUIsb0JBQW9CLHVEQUFROztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhOztBQUUxQixRQUFRLHVEQUFRO0FBQ2hCLFFBQVEsdURBQVE7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLEtBQUs7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQsNkNBQTZDLEVBQUU7QUFDL0Msa0NBQWtDLFdBQVc7QUFDN0M7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyx5Q0FBeUMsRUFBRTtBQUMzQyw4QkFBOEIsZUFBZTtBQUM3QztBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRCwwQkFBMEIsMkJBQTJCOztBQUVyRDs7QUFFQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsU0Y7QUFDTzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQUk7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVEQUFRO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZOztBQUU3QixZQUFZLHVEQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG1CQUFtQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RERDtBQUNPOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBSTtBQUMxQjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxjQUFjOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsbUJBQW1COztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTs7QUFFaEIsd0JBQXdCLHVEQUFRO0FBQ2hDLHdCQUF3Qix1REFBUTtBQUNoQyx3QkFBd0IsdURBQVE7QUFDaEMsd0JBQXdCLHVEQUFROztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsbUJBQW1COztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTs7QUFFaEIsd0JBQXdCLHVEQUFRO0FBQ2hDLHdCQUF3Qix1REFBUTtBQUNoQyx3QkFBd0IsdURBQVE7QUFDaEMsd0JBQXdCLHVEQUFROztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSx1REFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLG1CQUFtQjs7QUFFaEM7QUFDQSxZQUFZLHVEQUFROztBQUVwQjtBQUNBLGdCQUFnQix1REFBUTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyVEw7QUFDTzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQUk7QUFDdkI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QkE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFPO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU87QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9sYXlvdXQvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9sYXlvdXQvQ2FyZC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9sYXlvdXQvRml0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9GbGV4Ym94Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9HcmlkLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9IQm94Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9WQm94Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29tcG9uZW50ICAgICAgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBMYXlvdXRCYXNlICAgICBmcm9tICcuLi9sYXlvdXQvQmFzZS5tanMnO1xuaW1wb3J0IExheW91dENhcmQgICAgIGZyb20gJy4uL2xheW91dC9DYXJkLm1qcyc7XG5pbXBvcnQgTGF5b3V0Rml0ICAgICAgZnJvbSAnLi4vbGF5b3V0L0ZpdC5tanMnO1xuaW1wb3J0IExheW91dEdyaWQgICAgIGZyb20gJy4uL2xheW91dC9HcmlkLm1qcyc7XG5pbXBvcnQgTGF5b3V0SGJveCAgICAgZnJvbSAnLi4vbGF5b3V0L0hCb3gubWpzJztcbmltcG9ydCBMYXlvdXRWQm94ICAgICBmcm9tICcuLi9sYXlvdXQvVkJveC5tanMnO1xuaW1wb3J0IExvZ2dlciAgICAgICAgIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9IGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG5jb25zdCBieVdlaWdodCA9ICh7IHdlaWdodCA6IGxocyA9IDAgfSwgeyB3ZWlnaHQgOiByaHMgPSAwIH0pID0+IGxocyAtIHJocztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBjaGlsZCBpdGVtcyB3aXRoaW4gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAqIFRoaXMgY29uZmlnIHVzZXMgYSBkZXNjcmlwdG9yIHRvIGVuYWJsZSBkZWVwIG1lcmdpbmcgd2l0aCBpbnN0YW5jZSBiYXNlZCBpdGVtRGVmYXVsdHMuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzXz17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnZGVlcCcsIHZhbHVlOiBudWxsfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0c186IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdkZWVwJyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvciBhbiBvYmplY3Qgb2YgY29uZmlnIG9iamVjdHN8aW5zdGFuY2VzfG1vZHVsZXMgZm9yIGVhY2ggY2hpbGQgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBpdGVtc189W11cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogaW1wb3J0IEJ1dHRvbiAgICAgIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG4gICAgICAgICAqIGltcG9ydCBUb29sYmFyICAgICBmcm9tICcuLi90b29sYmFyL0Jhc2UubWpzJztcbiAgICAgICAgICpcbiAgICAgICAgICogbGV0IG15QnV0dG9uID0gTmVvLmNyZWF0ZShCdXR0b24sIHtcbiAgICAgICAgICogICAgIHRleHQ6ICdCdXR0b24xJ1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogTmVvLmNyZWF0ZShUb29sYmFyLCB7XG4gICAgICAgICAqICAgICAvLy4uLlxuICAgICAgICAgKiAgICAgaXRlbXM6IHtcbiAgICAgICAgICogICAgICAgICBidXR0b25SZWYgOiB7XG4gICAgICAgICAqICAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJywgICAvLyBieSBudHlwZVxuICAgICAgICAgKiAgICAgICAgICAgICB0ZXh0IDogJ0J1dHRvbiAyJ1xuICAgICAgICAgKiAgICAgICAgIH0sXG4gICAgICAgICAqICAgICAgICAgc2Vjb25kUmVmIDoge1xuICAgICAgICAgKiAgICAgICAgICAgICBtb2R1bGU6IEJ1dHRvbiwgICAgLy8gYnkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAgICAqICAgICAgICAgICAgIHRleHQgIDogJ0J1dHRvbiAzJ1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG9yXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGltcG9ydCBCdXR0b24gICAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuICAgICAgICAgKiBpbXBvcnQgTXlSZWRCdXR0b24gZnJvbSAnbXlhcHAvTXlSZWRCdXR0b24ubWpzJztcbiAgICAgICAgICogaW1wb3J0IFRvb2xiYXIgICAgIGZyb20gJy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuICAgICAgICAgKlxuICAgICAgICAgKiBsZXQgbXlCdXR0b24gPSBOZW8uY3JlYXRlKEJ1dHRvbiwge1xuICAgICAgICAgKiAgICAgdGV4dDogJ0J1dHRvbjEnXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBOZW8uY3JlYXRlKFRvb2xiYXIsIHtcbiAgICAgICAgICogICAgIC8vLi4uXG4gICAgICAgICAqICAgICBpdGVtczogW1xuICAgICAgICAgKiAgICAgICAgIG15QnV0dG9uLCAgICAgICAgICAgICAgLy8gcGFzc2VkIGluc3RhbmNlXG4gICAgICAgICAqICAgICAgICAge1xuICAgICAgICAgKiAgICAgICAgICAgICBudHlwZTogJ2J1dHRvbicsICAgLy8gYnkgbnR5cGVcbiAgICAgICAgICogICAgICAgICAgICAgdGV4dCA6ICdCdXR0b24gMidcbiAgICAgICAgICogICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgIHtcbiAgICAgICAgICogICAgICAgICAgICAgbW9kdWxlOiBCdXR0b24sICAgIC8vIGJ5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgICAgKiAgICAgICAgICAgICB0ZXh0ICA6ICdCdXR0b24gMydcbiAgICAgICAgICogICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgIE15UmVkQnV0dG9uICAgICAgICAgICAgLy8geW91IGNhbiBkcm9wIGltcG9ydGVkIG1vZHVsZXMgZGlyZWN0bHkgaW50byB0aGUgaXRlbXMgYXJyYXlcbiAgICAgICAgICogICAgIF1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXNfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIGNsb25lICAgICAgICAgOiAnc2hhbGxvdycsXG4gICAgICAgICAgICBjbG9uZU9uR2V0ICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaXNFcXVhbCAgICAgICA6ICgpID0+IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdCBpcyBjcnVjaWFsIHRvIGRlZmluZSBhIGxheW91dCBiZWZvcmUgdGhlIGNvbnRhaW5lciBkb2VzIGdldCB2ZG9tSW5pdGlhbGl6ZWQuXG4gICAgICAgICAqIE1lYW5pbmc6IG9uQ29uc3RydWN0ZWQoKSBpcyB0aGUgbGF0ZXN0IGxpZmUtY3ljbGUgcG9pbnQuXG4gICAgICAgICAqIFlvdSBjYW4gdXNlIGxheW91dDogJ2Jhc2UnLCBpbiBjYXNlIHlvdSBkbyBub3QgbmVlZCBhIGxheW91dCBhdCBhbGwuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd8bnVsbH0gbGF5b3V0Xz17bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXRfOiB7XG4gICAgICAgICAgICBudHlwZTogJ3Zib3gnLFxuICAgICAgICAgICAgYWxpZ246ICdzdHJldGNoJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17Y246IFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW119XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGF0IHRoZSBsYXN0IGluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGFkZChpdGVtKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtZS5pbnNlcnQobWUuaXRlbXMgPyBtZS5pdGVtcy5sZW5ndGggOiAwLCBpdGVtKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXBwTmFtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBzdXBlci5hZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUuaXRlbXMpIHtcbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hcHBOYW1lID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLmxheW91dCkge1xuICAgICAgICAgICAgbWUubGF5b3V0LmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8ubGF5b3V0LkJhc2V8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5sYXlvdXQuQmFzZXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExheW91dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUudm5vZGVJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgb2xkVmFsdWU/LnJlbW92ZVJlbmRlckF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIHZhbHVlPy5hcHBseVJlbmRlckF0dHJpYnV0ZXMoKTtcblxuICAgICAgICAgICAgbWUuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZT8ucmVtb3ZlQ2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YWx1ZT8uYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3k/LigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwge2l0ZW1zfSA9IHRoaXMsIHtsZW5ndGh9ID0gaXRlbXM7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXNbaV0udmRvbS5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0ubW91bnRlZCA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBuZWVkc1Zkb21VcGRhdGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXROZWVkc1Zkb21VcGRhdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGUuZy4gVG9vbGJhciBpdGVtcyBsaWtlICctPidcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBub3Qgc2V0IHRoZSBjb25maWcgZGlyZWN0bHkgPT4gaXQgY291bGQgYWxyZWFkeSBiZSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlIHN0aWxsIHdhbnQgdG8gcGFzcyBpdCBmdXJ0aGVyIGludG8gc3VidHJlZXNcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fbmVlZHNWZG9tVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWZ0ZXJTZXROZWVkc1Zkb21VcGRhdGU/LihmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2bm9kZUluaXRpYWxpemluZyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzVm5vZGVJbml0aWFsaXppbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQge2l0ZW1zfSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaSAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICAgICA9IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXNbaV0udmRvbS5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0uaXNWbm9kZUluaXRpYWxpemluZyA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aGVtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICB2YWx1ZSAmJiB0aGlzLml0ZW1zPy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnRoZW1lID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bGF5b3V0fSA9IG1lO1xuXG4gICAgICAgIHZhbHVlICYmIG1lLml0ZW1zPy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpZiAodmFsdWUgJiYgbGF5b3V0ICYmICFOZW8uaXNTdHJpbmcobGF5b3V0KSkge1xuICAgICAgICAgICAgbGF5b3V0LndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgaXRlbXMgb2JqZWN0IHRvIGFuIGFycmF5IGZvciBvbndhcmQgc3RvcmFnZSBhcyBfaXRlbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgICBiZWZvcmVTZXRJdGVtcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgICAgIGhhc1dlaWdodCwgaXRlbTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCByZWYgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbcmVmXVxuXG4gICAgICAgICAgICAgICAgaXRlbS5yZWZlcmVuY2UgPSByZWY7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaGFzV2VpZ2h0IHx8PSAoJ3dlaWdodCcgaW4gaXRlbSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc1dlaWdodCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zb3J0KGJ5V2VpZ2h0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOZW8ubGF5b3V0LkJhc2V9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5sYXlvdXQuQmFzZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0TGF5b3V0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXlvdXQodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxPYmplY3R9IE9iamVjdCBmb3IgbGF6eSBsb2FkZWQgaXRlbXNcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgICA9IHthcHBOYW1lOiBtZS5hcHBOYW1lLCBwYXJlbnRJZDogbWUuaWQsIHBhcmVudEluZGV4OiBpbmRleCwgd2luZG93SWQ6IG1lLndpbmRvd0lkfSxcbiAgICAgICAgICAgIGRlZmF1bHRzID0gey4uLm1lLml0ZW1EZWZhdWx0c30sXG4gICAgICAgICAgICBsYXp5TG9hZEl0ZW0sIG1vZHVsZSwgcGFyZW50O1xuXG4gICAgICAgIGlmIChkZWZhdWx0cykge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRlZmF1bHRzLm50eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5udHlwZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWZhdWx0cy5tb2R1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKE5lby50eXBlT2YoaXRlbSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ05lb0NsYXNzJzoge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdGhlbWU6IGl0ZW0uY29uZmlnLnRoZW1lIHx8IG1lLnRoZW1lLFxuICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdOZW9JbnN0YW5jZSc6IHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBpdGVtLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSBtZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlPy4oaXRlbSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS52ZG9tLnJlbW92ZURvbTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZW5pZW5jZSBsb2dpYywgZXNwZWNpYWxseSBmb3IgbW92aW5nIGNvbXBvbmVudHMgaW50byBkaWZmZXJlbnQgYnJvd3NlciB3aW5kb3dzOlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGNvbXBvbmVudCBtaWdodCByZWx5IG9uIHJlZmVyZW5jZXMgJiBoYW5kbGVyIG1ldGhvZHMgaW5zaWRlIHRoZSBwcmV2aW91cyBjb250cm9sbGVyIHJlYWxtXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IFdlIG5lZWQgPy4gdW50aWwgZnVuY3Rpb25hbC5jb21wb25lbnQuQmFzZSBzdXBwb3J0cyBjb250cm9sbGVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uY29udHJvbGxlciAmJiAhbWUuZ2V0Q29udHJvbGxlcigpICYmIHBhcmVudC5nZXRDb250cm9sbGVyPy4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb250cm9sbGVyID0ge3BhcmVudDogcGFyZW50LmdldENvbnRyb2xsZXIoKX1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0KGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaXRlbS5nZXRTdGF0ZVByb3ZpZGVyPy4oKT8uY3JlYXRlQmluZGluZ3MoaXRlbSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnT2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXNzaWduRGVmYXVsdHMoaXRlbSwgZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLm1vZHVsZSAmJiAhaXRlbS5udHlwZSAmJiAhaXRlbS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5tb2R1bGUgPSBDb21wb25lbnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBpdGVtLm1vZHVsZTtcblxuICAgICAgICAgICAgICAgIGxhenlMb2FkSXRlbSA9IG1vZHVsZSAmJiAhbW9kdWxlLmlzQ2xhc3MgJiYgTmVvLmlzRnVuY3Rpb24obW9kdWxlKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUgJiYgIWxhenlMb2FkSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTmFtZSA9IG1vZHVsZS5wcm90b3R5cGUuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRoZW1lICAgICA9IGRlZmF1bHRzLnRoZW1lIHx8IG1vZHVsZS5jb25maWcudGhlbWUgfHwgbWUudGhlbWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYW5kbGVyU2NvcGUgPT09ICd0aGlzJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmhhbmRsZXJTY29wZSA9IG1lO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKGl0ZW0uaGFuZGxlcikgPT09ICdTdHJpbmcnICYmIE5lby50eXBlT2YobWVbaXRlbS5oYW5kbGVyXSkgPT09ICdGdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaGFuZGxlciA9IG1lW2l0ZW0uaGFuZGxlcl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbSwgY29uZmlnKTtcblxuICAgICAgICAgICAgICAgIGlmICghbGF6eUxvYWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBOZW9baXRlbS5jbGFzc05hbWUgPyAnY3JlYXRlJyA6ICdudHlwZSddKGl0ZW0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52ZG9tID0gT2JqZWN0LmFzc2lnbihpdGVtLnZkb20gfHwge30sIHtyZW1vdmVEb206IHRydWV9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ1N0cmluZyc6IHtcbiAgICAgICAgICAgICAgICBpdGVtID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICB2ZG9tICA6IHt0ZXh0OiBpdGVtfSxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgICAgID0gbWUuX2l0ZW1zLFxuICAgICAgICAgICAgaXRlbXNSb290ID0gbWUuZ2V0VmRvbUl0ZW1zUm9vdCgpLFxuICAgICAgICAgICAge2xheW91dH0gID0gbWUsXG4gICAgICAgICAgICB2ZG9tO1xuXG4gICAgICAgIGl0ZW1zUm9vdC5jbiA9IFtdO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtc1tpbmRleF0gPSBpdGVtID0gbWUuY3JlYXRlSXRlbShpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTmVvLmNvcmUuQmFzZSkge1xuICAgICAgICAgICAgICAgIGxheW91dD8uYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZkb20gPSBpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZG9tID0gaXRlbS52ZG9tXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zUm9vdC5jbi5wdXNoKHZkb20pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gYWRkIGl0ZW1zIGludG8gdGhlIHZkb21cbiAgICAgICAgbWUudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgbWUuaXNDb25zdHJ1Y3RlZCAmJiBtZS51cGRhdGUoKTtcblxuICAgICAgICBtZS5maXJlKCdpdGVtc0NyZWF0ZWQnLCB7aWQ6IG1lLmlkLCBpdGVtc30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfE5lby5sYXlvdXQuQmFzZX0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge05lby5sYXlvdXQuQmFzZX1cbiAgICAgKi9cbiAgICBjcmVhdGVMYXlvdXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExheW91dEJhc2UgJiYgdmFsdWUuaXNMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlLCB7YXBwTmFtZSwgY29udGFpbmVySWQ6IGlkLCB3aW5kb3dJZH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbWUucGFyc2VMYXlvdXRDbGFzcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZSwge2FwcE5hbWUsIGNvbnRhaW5lcklkOiBpZCwgd2luZG93SWR9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE5lby5udHlwZSh2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFsbCBjb21wb25lbnRzIGluc2lkZSB0aGlzLml0ZW1zIGJlZm9yZSB0aGUgc3VwZXIoKSBjYWxsLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VwZGF0ZVBhcmVudFZkb209ZmFsc2VdIHRydWUgdG8gcmVtb3ZlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgcGFyZW50IHZkb20gPT4gcmVhbCBkb21cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHRydWUgdG8gdXBkYXRlIHRoZSB2ZG9tIHNpbGVudGx5ICh1c2VmdWwgZm9yIGRlc3Ryb3lpbmcgbXVsdGlwbGUgY2hpbGQgaXRlbXMgaW4gYSByb3cpXG4gICAgICovXG4gICAgZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tPWZhbHNlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQ/LmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLml0ZW1zPy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5kZXN0cm95Py4oZmFsc2UsIHRydWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIGZvciBgZ2V0UmVmZXJlbmNlKClgIHdoaWNoIGlzIHVzZWZ1bCBiZWZvcmUgYSBjb21wb25lbnQgdHJlZSBnb3QgY3JlYXRlZC5cbiAgICAgKiBgZ2V0UmVmZXJlbmNlKClgIHJlbGllcyBvbiBjaGlsZCBpdGVtcyBiZWluZyByZWdpc3RlcmVkIGluc2lkZSBgbWFuYWdlci5Db21wb25lbnRgLFxuICAgICAqIHdoaWxlIHRoaXMgbWV0aG9kIHNpbXBseSB3YWxrcyBkb3duIHRoZSBpdGVtcyBhcnJheS5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGNsYXNzZXMgLyBtb2R1bGVzIGluc2lkZSB0aGUgaXRlbXMgdHJlZSBjYW4gbm90IGdldCBwYXJzZWQgZnVydGhlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVmZXJlbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXM9dGhpcy5pdGVtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0SXRlbShyZWZlcmVuY2UsIGl0ZW1zPXRoaXMuaXRlbXMpIHtcbiAgICAgICAgbGV0IGkgICA9IDAsXG4gICAgICAgICAgICBsZW4gPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBjaGlsZEl0ZW0sIGl0ZW07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmVmZXJlbmNlID09PSByZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRJdGVtID0gdGhpcy5nZXRJdGVtKHJlZmVyZW5jZSwgaXRlbS5pdGVtcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEl0ZW1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdmRvbSBpdGVtcyByb290IGlmIG5lZWRlZCAodXNlZnVsIGluIGNhc2UgdGhpcyBjb250YWluZXIgdXNlcyBhIHdyYXBwZXIgbm9kZSkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2ZG9tIGl0ZW1zIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWZG9tSXRlbXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWZG9tUm9vdCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIGEgZGlyZWN0IGNoaWxkIGNvbXBvbmVudCBpbnNpZGUgdGhpcy5pdGVtcy5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxTdHJpbmd9IGl0ZW1JZCBFaXRoZXIgdGhlIGl0ZW0gcmVmZXJlbmNlIG9yIHRoZSBpdGVtIGlkXG4gICAgICogQHJldHVybnMge051bWJlcn0gLTEgaW4gY2FzZSBubyBtYXRjaCB3YXMgZm91bmRcbiAgICAgKi9cbiAgICBpbmRleE9mKGl0ZW1JZCkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICBsZW4gPSBtZS5pdGVtcz8ubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgaWYgKCFOZW8uaXNTdHJpbmcoaXRlbUlkKSkge1xuICAgICAgICAgICAgaXRlbUlkID0gaXRlbUlkLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKG1lLml0ZW1zW2ldLmlkID09PSBpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpdGVtc30gPSBtZSxcbiAgICAgICAgICAgIGksIGxlbiwgcmV0dXJuQXJyYXk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGkgICAgICAgICAgID0gMDtcbiAgICAgICAgICAgIGxlbiAgICAgICAgID0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBhcnJheSBiYWNrd2FyZHNcbiAgICAgICAgICAgICAgICByZXR1cm5BcnJheS51bnNoaWZ0KG1lLmluc2VydChpbmRleCwgaXRlbVtsZW4gLSAxIC0gaV0sIHRydWUpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtID0gcmV0dXJuQXJyYXlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5jcmVhdGVJdGVtKGl0ZW0sIGluZGV4KTtcblxuICAgICAgICAgICAgLy8gYWRkZWQgdGhlIHRydWUgcGFyYW0gPT4gZm9yIGNhcmQgbGF5b3V0cywgd2UgZG8gbm90IHdhbnQgYSBkeW5hbWljYWxseSBpbnNlcnRlZCBjbXAgdG8gZ2V0IHJlbW92ZWQgcmlnaHQgYXdheVxuICAgICAgICAgICAgLy8gc2luY2UgaXQgd2lsbCBtb3N0IGxpa2VseSBnZXQgYWN0aXZhdGVkIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgIG1lLmxheW91dC5hcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zID0gaXRlbXM7XG5cbiAgICAgICAgICAgIG1lLmdldFZkb21JdGVtc1Jvb3QoKS5jbi5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0uY3JlYXRlVmRvbVJlZmVyZW5jZSgpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gLTE7IC8vIHBhc3MgdGhlIGZ1bGwgdmRvbSB0cmVlIHRvIGhvbm9yIG5ldyBuZXN0ZWQgY29tcG9uZW50IHRyZWVzXG5cbiAgICAgICAgICAgIG1lLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5maXJlKCdpbnNlcnQnLCB7aW5kZXgsIGl0ZW19KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgaXRlbXMgZnJvbSBhIHJlbW90ZSBlbmRwb2ludC5cbiAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL3RyZWUvZGV2L2V4YW1wbGVzL3NlcnZlcnNpZGVcbiAgICAgKiBUaGUgcmVzcG9uc2Ugc2hvdWxkIHJldHVybiBhIEpTT04gZmlsZSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiAgICAgKiB7XCJtb2R1bGVzXCI6IFtdLCBcIml0ZW1zXCI6IFtdfVxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vYmxvYi9kZXYvZXhhbXBsZXMvc2VydmVyc2lkZS9ncmlkQ29udGFpbmVyL3Jlc291cmNlcy9kYXRhL2dyaWQtY29udGFpbmVyLmpzb25cbiAgICAgKiBJdCBpcyBpbXBvcnRhbnQgdG8gYWRkIG1vZHVsZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGltcG9ydGVkIGluc2lkZSB5b3VyIGFwcCB5ZXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGEub3B0aW9ucz17fV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS51cmxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3RbXT59XG4gICAgICovXG4gICAgYXN5bmMgbG9hZEl0ZW1zKHtvcHRpb25zPXt9LCB1cmx9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSAgID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKSxcbiAgICAgICAgICAgIHJlbW90ZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgaWYgKHJlbW90ZURhdGEubW9kdWxlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVtb3RlRGF0YS5tb2R1bGVzLm1hcChtb2R1bGVQYXRoID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgcmVsYXRpdmUgVVJMc1xuICAgICAgICAgICAgICAgIGlmICghbW9kdWxlUGF0aC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlUGF0aCA9IChOZW8uY29uZmlnLmVudmlyb25tZW50ID09PSAnZGV2ZWxvcG1lbnQnID8gJy4uLy4uLycgOiAnLi4vLi4vLi4vLi4vJykgKyBtb2R1bGVQYXRoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIG1vZHVsZVBhdGgpXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1vdGVEYXRhLml0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gc3VwZXIubWVyZ2VDb25maWcoLi4uYXJncyksXG4gICAgICAgICAgICBjdG9ySXRlbXM7XG5cbiAgICAgICAgLy8gQXZvaWQgYW55IGludGVyZmVyZW5jZSBvbiBwcm90b3R5cGUgbGV2ZWxcbiAgICAgICAgLy8gRG9lcyBub3QgY2xvbmUgZXhpc3RpbmcgTmVvIGluc3RhbmNlc1xuICAgICAgICBpZiAoY29uZmlnLml0ZW1zKSB7XG4gICAgICAgICAgICBjdG9ySXRlbXMgPSBtZS5jb25zdHJ1Y3Rvci5jb25maWcuaXRlbXM7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBwYXNzZWQgYW4gb2JqZWN0LCBtZXJnZSB0aGUgY2xhc3MncyBvd24gaXRlbXMgb2JqZWN0IGludG8gaXRcbiAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKGNvbmZpZy5pdGVtcykgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc0FycmF5KGN0b3JJdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXRlbXMgPSBOZW8uY2xvbmUoY29uZmlnLml0ZW1zLCB0cnVlLCB0cnVlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLml0ZW1zID0gTmVvLm1lcmdlKE5lby5jbG9uZShjdG9ySXRlbXMpLCBjb25maWcuaXRlbXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5faXRlbXMgPSBOZW8uY2xvbmUoY29uZmlnLml0ZW1zLCB0cnVlLCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5pdGVtc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGV4aXN0aW5nIGl0ZW0gdG8gYSBuZXcgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfVxuICAgICAqL1xuICAgIG1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLml0ZW1zW2Zyb21JbmRleF07XG5cbiAgICAgICAgZnJvbUluZGV4ICE9PSB0b0luZGV4ICYmIG1lLnN3aXRjaEl0ZW1zKHRvSW5kZXgsIGZyb21JbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0gbWUubGF5b3V0O1xuXG4gICAgICAgIC8vIElmIHRoZSBsYXlvdXQgaXMgYSBjb25maWcgb2JqZWN0IChub3QgYW4gaW5zdGFuY2UpLCBkZWVwIGNsb25lIGl0XG4gICAgICAgIC8vIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvbi5cbiAgICAgICAgaWYgKGxheW91dENvbmZpZyAmJiAhKGxheW91dENvbmZpZyBpbnN0YW5jZW9mIExheW91dEJhc2UpKSB7XG4gICAgICAgICAgICBsYXlvdXRDb25maWcgPSBOZW8uY2xvbmUobGF5b3V0Q29uZmlnLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgQ29udGFpbmVyIGRvZXMgbm90IGhhdmUgYSBsYXlvdXQgY29uZmlnLCB0aGUgc2V0dGVyIHdvbid0IHRyaWdnZXJcbiAgICAgICAgbWUuX2xheW91dCA9IG1lLmNyZWF0ZUxheW91dChsYXlvdXRDb25maWcpO1xuICAgICAgICBtZS5fbGF5b3V0Py5hcHBseVJlbmRlckF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbWUucGFyc2VJdGVtQ29uZmlncyhtZS5pdGVtcyk7XG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBsYXlvdXRDb25maWdcbiAgICAgKi9cbiAgICBwYXJzZUxheW91dENsYXNzKGNvbmZpZykge1xuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnLm50eXBlLnN0YXJ0c1dpdGgoJ2xheW91dC0nKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5udHlwZSA9IGBsYXlvdXQtJHtjb25maWcubnR5cGV9YFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG50eXBlOiBjb25maWcuc3RhcnRzV2l0aCgnbGF5b3V0LScpID8gY29uZmlnIDogYGxheW91dC0ke2NvbmZpZ31gXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbnRhaW5lciBpdGVtIGJ5IHJlZmVyZW5jZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZXN0cm95SXRlbT10cnVlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgcmVtb3ZlKGNvbXBvbmVudCwgZGVzdHJveUl0ZW09dHJ1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IFsuLi50aGlzLml0ZW1zXSxcbiAgICAgICAgICAgIGkgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpdGVtc1tpXS5pZCA9PT0gY29tcG9uZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQXQoaSwgZGVzdHJveUl0ZW0sIHNpbGVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgaXRlbSBhcnJheVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveUl0ZW1zPXRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIHJlbW92ZUFsbChkZXN0cm95SXRlbXM9dHJ1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChkZXN0cm95SXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRlc3Ryb3kodHJ1ZSwgdHJ1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5tb3VudGVkID0gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBbXTtcblxuICAgICAgICBtZS5nZXRWZG9tSXRlbXNSb290KCkuY24gPSBbXTtcblxuICAgICAgICBpZiAoIXNpbGVudCB8fCBkZXN0cm95SXRlbXMpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29udGFpbmVyIGl0ZW0gYXQgYSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVzdHJveUl0ZW09dHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIHJlbW92ZUF0KGluZGV4LCBkZXN0cm95SXRlbT10cnVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1zfSA9IG1lLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBOZW8ud2FybignQ29udGFpbmVyLnJlbW92ZUF0OiBpbmRleCA+PSBpdGVtcy5sZW5ndGguICcgKyBtZS5pZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpbmRleF07XG5cbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIG1lLmdldFZkb21JdGVtc1Jvb3QoKS5jbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCB1cGRhdGUgY3ljbGUgbmVlZHMgdG8gaW5jbHVkZSBkaXJlY3QgY2hpbGRyZW5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcblxuICAgICAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKTtcblxuICAgICAgICAgICAgaWYgKGRlc3Ryb3lJdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5kZXN0cm95KHRydWUsIHNpbGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUubGF5b3V0Py5yZW1vdmVDaGlsZEF0dHJpYnV0ZXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgaXRlbS5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRhaW5lciBpdGVtIGF0IHRoZSBsYXN0IGluZGV4XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVzdHJveUl0ZW09dHJ1ZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgcmVtb3ZlTGFzdChkZXN0cm95SXRlbT10cnVlLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdCh0aGlzLml0ZW1zLmxlbmd0aCAtIDEsIGRlc3Ryb3lJdGVtLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYSBjb250YWluZXIgaXRlbSBhdCBhIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lJdGVtPXRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIHJlcGxhY2VBdChpbmRleCwgaXRlbSwgZGVzdHJveUl0ZW09dHJ1ZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQoaW5kZXgsIGRlc3Ryb3lJdGVtLCB0cnVlKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgcG9zaXRpb24gb2YgMiBkaXJlY3QgY2hpbGQgaXRlbXNcbiAgICAgKiBZb3UgY2FuIGVpdGhlciBwYXNzIGFuIGluZGV4IChOdW1iZXIpIG9yIGlkIChTdHJpbmcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpdGVtMWlkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpdGVtMmlkXG4gICAgICovXG4gICAgc3dpdGNoSXRlbXMoaXRlbTFpZCwgaXRlbTJpZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtMUluZGV4ID0gTmVvLmlzTnVtYmVyKGl0ZW0xaWQpID8gaXRlbTFpZCA6IG1lLmluZGV4T2YoaXRlbTFpZCksXG4gICAgICAgICAgICBpdGVtMkluZGV4ID0gTmVvLmlzTnVtYmVyKGl0ZW0yaWQpID8gaXRlbTJpZCA6IG1lLmluZGV4T2YoaXRlbTJpZCk7XG5cbiAgICAgICAgTmVvQXJyYXkubW92ZShtZS5pdGVtcywgICAgICAgICAgICAgICAgIGl0ZW0ySW5kZXgsIGl0ZW0xSW5kZXgpO1xuICAgICAgICBOZW9BcnJheS5tb3ZlKG1lLmdldFZkb21JdGVtc1Jvb3QoKS5jbiwgaXRlbTJJbmRleCwgaXRlbTFJbmRleCk7XG5cbiAgICAgICAgLy8gdGhlIG5leHQgdXBkYXRlIGN5Y2xlIG5lZWRzIHRvIGluY2x1ZGUgZGlyZWN0IGNoaWxkcmVuXG4gICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29udGFpbmVyKTtcbiIsImltcG9ydCBCYXNlICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBvdGhlciBsYXlvdXRzLlxuICogVXNlIGl0IGRpcmVjdGx5IGluIGNhc2UgeW91IHdhbnQgdG8gY3JlYXRlIGEgY29udGFpbmVyIHdpdGhvdXQgYSBsYXlvdXQuXG4gKiBAY2xhc3MgTmVvLmxheW91dC5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIExheW91dCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIEFwcCB0aGlzIGxheW91dCBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhcHBOYW1lXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwTmFtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgb2YgdGhlIENvbnRhaW5lciBpbnN0YW5jZSB0aGlzIGxheW91dCBpcyBib3VuZCB0b1xuICAgICAgICAgKiBAbWVtYmVyIHs/U3RyaW5nfSBjb250YWluZXJJZD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lcklkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBsYXlvdXQgc3BlY2lmaWMgQ1NTIHNlbGVjdG9yIHdoaWNoIGdldHMgYWRkZWQgdG8gQ29udGFpbmVyIHRoZSBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb250YWluZXJDbHNfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVyIGZvciBhbGwgY2xhc3NlcyB0aGF0IGV4dGVuZCBsYXlvdXQuQmFzZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0xheW91dD10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzTGF5b3V0OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5jb250YWluZXIuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldCBjb250YWluZXIoKSB7XG4gICAgICAgIGxldCB7Y29udGFpbmVySWR9ID0gdGhpcztcblxuICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWlnaHQgbm90IGJlIHJlZ2lzdGVyZWQgeWV0XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KGNvbnRhaW5lcklkKSB8fCBOZW8uZ2V0KGNvbnRhaW5lcklkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgdGhpcy5fX3Byb3RvX18pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhcHBseVJlbmRlckF0dHJpYnV0ZXMoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXIsIGNvbnRhaW5lckNsc30gPSBtZSxcbiAgICAgICAgICAgIHt3cmFwcGVyQ2xzfSAgICAgICAgICAgICAgPSBjb250YWluZXI7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lckNscykge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBOZW8ubG9nRXJyb3IobWUuY2xhc3NOYW1lICsgJzogYXBwbHlSZW5kZXJBdHRyaWJ1dGVzIC0+IGNvbnRhaW5lciBub3QgeWV0IGNyZWF0ZWQnLCBtZS5jb250YWluZXJJZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIGNvbnRhaW5lckNscyk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lcltzaWxlbnQgPyAnc2V0U2lsZW50JyA6ICAnc2V0J10oe3dyYXBwZXJDbHN9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmJpbmQgJiYgbWUuZ2V0U3RhdGVQcm92aWRlcigpPy5yZW1vdmVCaW5kaW5ncyhtZS5pZCk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGFpbmVyIHN0YXRlUHJvdmlkZXIgb3IgaXRzIGNsb3Nlc3QgcGFyZW50IHN0YXRlUHJvdmlkZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uc3RhdGUuUHJvdmlkZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZVByb3ZpZGVyKG50eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5nZXRTdGF0ZVByb3ZpZGVyKG50eXBlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYWxsIGNsYXNzIGNvbmZpZ3MgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGluaXRDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgc3VwZXIuaW5pdENvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5iaW5kICYmIG1lLmNvbnRhaW5lci5nZXRTdGF0ZVByb3ZpZGVyKCk/LnBhcnNlQ29uZmlnKG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCkge31cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBjb250YWluZXJDbHN9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmIChjb250YWluZXJDbHMpIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgTmVvLmxvZ0Vycm9yKG1lLmNsYXNzTmFtZSArICc6IHJlbW92ZVJlbmRlckF0dHJpYnV0ZXMgLT4gY29udGFpbmVyIG5vdCB5ZXQgY3JlYXRlZCcsIG1lLmNvbnRhaW5lcklkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUod3JhcHBlckNscywgY29udGFpbmVyQ2xzKTtcblxuICAgICAgICAgICAgY29udGFpbmVyLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgbXVsdGlwbGUgY29uZmlncyBhdCBvbmNlLCBlbnN1cmluZyB0aGF0IGFsbCBhZnRlclNldCBtZXRob2RzIGdldCBhbGwgbmV3IGFzc2lnbmVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHNldCh2YWx1ZXM9e30sIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbnRhaW5lcn0gPSBtZTtcblxuICAgICAgICBjb250YWluZXIuc2lsZW50VmRvbVVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgc3VwZXIuc2V0KHZhbHVlcyk7XG5cbiAgICAgICAgY29udGFpbmVyLnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2lsZW50IHx8ICFjb250YWluZXIubmVlZHNWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXIucHJvbWlzZVVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBjYWxsaW5nIHNldCgpIHdpdGggdGhlIHNpbGVudCBmbGFnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcz17fVxuICAgICAqL1xuICAgIHNldFNpbGVudCh2YWx1ZXM9e30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHZhbHVlcywgdHJ1ZSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExheW91dCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkNhcmRcbiAqIEBleHRlbmRzIE5lby5sYXlvdXQuQmFzZVxuICovXG5jbGFzcyBDYXJkIGV4dGVuZHMgQmFzZSB7XG4gICAgLypcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgQ1NTIGNsYXNzIGZvciBhbiBhY3RpdmUgaXRlbSBpbnNpZGUgdGhlIGNhcmQgbGF5b3V0XG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBhY3RpdmVJdGVtQ2xzPSduZW8tYWN0aXZlLWl0ZW0nXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhY3RpdmVJdGVtQ2xzID0gJ25lby1hY3RpdmUtaXRlbSdcbiAgICAvKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBDU1MgY2xhc3MgZm9yIGFuIGluYWN0aXZlIGl0ZW0gaW5zaWRlIHRoZSBjYXJkIGxheW91dFxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gaW5hY3RpdmVJdGVtQ2xzPSduZW8taW5hY3RpdmUtaXRlbSdcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGluYWN0aXZlSXRlbUNscyA9ICduZW8taW5hY3RpdmUtaXRlbSdcbiAgICAvKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBDU1MgY2xhc3MgZm9yIGFuIGl0ZW0gaW5zaWRlIHRoZSBjYXJkIGxheW91dFxuICAgICAqIEBtZW1iZXIgaXRlbUNsc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXRlbUNscyA9ICduZW8tbGF5b3V0LWNhcmQtaXRlbSdcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHNsaWRlRGlyZWN0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGljb25Qb3NpdGlvbnM9Wydob3Jpem9udGFsJywndmVydGljYWwnLG51bGxdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgc2xpZGVEaXJlY3Rpb25zID0gWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5DYXJkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkNhcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWNhcmQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWNhcmQnLFxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgaXRlbSBpbmRleCBvZiB0aGUgY2FyZCwgd2hpY2ggaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICAgICAgICogQ2hhbmdlIHRoaXMgdmFsdWUgdG8gYWN0aXZhdGUgYSBkaWZmZXJlbnQgY2FyZC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBhY3RpdmVJbmRleF89MFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlSW5kZXhfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbnRhaW5lckNscz0nbmVvLWxheW91dC1jYXJkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ2xzOiAnbmVvLWxheW91dC1jYXJkJyxcbiAgICAgICAgLypcbiAgICAgICAgICogUmVtb3ZlIHRoZSBET00gb2YgaW5hY3RpdmUgY2FyZHMuXG4gICAgICAgICAqIFRoaXMgd2lsbCBrZWVwIHRoZSBpbnN0YW5jZXMgJiB2ZG9tIHRyZWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW92ZUluYWN0aXZlQ2FyZHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogdHJ1ZSxcbiAgICAgICAgLypcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNsaWRlRGlyZWN0aW9uXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzbGlkZURpcmVjdGlvbl86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyB0aGUgQ1NTIGNsYXNzZXMgb2YgdGhlIGNvbnRhaW5lciBpdGVtcyB0aGlzIGxheW91dCBpcyBib3VuZCB0by5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhY3RpdmVJbmRleC5cbiAgICAgKiBMYXp5IGxvYWRzIGl0ZW1zIHdoaWNoIHVzZSBhIG1vZHVsZSBjb25maWcgY29udGFpbmluZyBhIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldEFjdGl2ZUluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXIsIHJlbW92ZUluYWN0aXZlQ2FyZHN9ID0gbWUsXG4gICAgICAgICAgICBzQ2ZnICAgICAgICAgICAgPSBtZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG5lZWRzVHJhbnNpdGlvbiA9IG1lLnNsaWRlRGlyZWN0aW9uICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIGksIGlzQWN0aXZlSW5kZXgsIGl0ZW0sIGl0ZW1zLCBsZW4sIG1vZHVsZSwgd3JhcHBlckNscztcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSAmJiBjb250YWluZXIpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gY29udGFpbmVyLml0ZW1zO1xuICAgICAgICAgICAgbGVuICAgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghaXRlbXNbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgTmVvLmVycm9yKCdUcnlpbmcgdG8gYWN0aXZhdGUgYSBub24gZXhpc3RpbmcgY2FyZCcsIHZhbHVlLCBpdGVtcylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBydW4gdGhlIGxvb3AgdHdpY2UsIHNpbmNlIGxhenkgbG9hZGluZyBhIG1vZHVsZSBhdCBhIGhpZ2hlciBpbmRleCBkb2VzIGFmZmVjdCBsb3dlciBpbmRleGVzXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlID0gaXRlbXNbaV0ubW9kdWxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHZhbHVlICYmIE5lby50eXBlT2YobW9kdWxlKSA9PT0gJ0Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXNBY3RpdmVJbmRleCA9IGkgPT09IHZhbHVlO1xuICAgICAgICAgICAgICAgIGl0ZW0gICAgICAgICAgPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgID0gaXRlbS5tb2R1bGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVJbmRleCAmJiBOZW8udHlwZU9mKG1vZHVsZSkgPT09ICdGdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGF3YWl0IG1lLmxvYWRNb2R1bGUoaXRlbSwgaSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5lby5jb21wb25lbnQuQmFzZSkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyQ2xzID0gaXRlbS53cmFwcGVyQ2xzO1xuXG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBpc0FjdGl2ZUluZGV4ID8gc0NmZy5pbmFjdGl2ZUl0ZW1DbHMgOiBzQ2ZnLmFjdGl2ZUl0ZW1DbHMpO1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoICAgd3JhcHBlckNscywgaXNBY3RpdmVJbmRleCA/IHNDZmcuYWN0aXZlSXRlbUNscyAgIDogc0NmZy5pbmFjdGl2ZUl0ZW1DbHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVJbmFjdGl2ZUNhcmRzIHx8IG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnZkb20ucmVtb3ZlRG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuZWVkc1RyYW5zaXRpb24gJiYgaXRlbS5hY3RpdmF0ZT8uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVtb3ZlSW5hY3RpdmVDYXJkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubW91bnRlZCAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lZWRzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnNsaWRlQ2FyZHModmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1vdmVJbmFjdGl2ZUNhcmRzIHx8IG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7IC8vIGluY2x1ZGUgdGhlIGZ1bGwgdHJlZSB0byBob25vciBuZXcgb3IgY2hhbmdlZCBpbmFjdGl2ZSBjYXJkc1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGx5IHNldHMgdGhlIENTUyBjbGFzc2VzIG9mIHRoZSBjb250YWluZXIgaXRlbXMgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtrZWVwSW5Eb209ZmFsc2VdXG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgsIGtlZXBJbkRvbT1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpc0FjdGl2ZUluZGV4ID0gbWUuYWN0aXZlSW5kZXggPT09IGluZGV4LFxuICAgICAgICAgICAgc0NmZyAgICAgICAgICA9IG1lLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY2hpbGRDbHMgICAgICA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXSxcbiAgICAgICAgICAgIHt2ZG9tfSAgICAgICAgPSBpdGVtO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjaGlsZENscywgc0NmZy5pdGVtQ2xzKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKGNoaWxkQ2xzLCBpc0FjdGl2ZUluZGV4ID8gc0NmZy5hY3RpdmVJdGVtQ2xzIDogc0NmZy5pbmFjdGl2ZUl0ZW1DbHMpO1xuXG4gICAgICAgIGlmICgha2VlcEluRG9tICYmIG1lLnJlbW92ZUluYWN0aXZlQ2FyZHMpIHtcbiAgICAgICAgICAgIHZkb20ucmVtb3ZlRG9tICA9ICFpc0FjdGl2ZUluZGV4O1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gY2hpbGRDbHM7XG4gICAgICAgICAgICBpdGVtLnVwZGF0ZT8uKCkgLy8gY2FuIGdldCBjYWxsZWQgZm9yIGFuIGl0ZW0gY29uZmlnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSBjaGlsZENsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2xpZGVEaXJlY3Rpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNsaWRlRGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnc2xpZGVEaXJlY3Rpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgY29tcG9uZW50LkJhc2UgbW9kdWxlIHdoaWNoIGlzIGRlZmluZWQgdmlhIG1vZHVsZTogKCkgPT4gaW1wb3J0KCcuLi4nKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfVxuICAgICAqL1xuICAgIGFzeW5jIGxvYWRNb2R1bGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXJ9ID0gbWUsXG4gICAgICAgICAgICBpdGVtcyAgICAgICA9IGNvbnRhaW5lci5pdGVtcyxcbiAgICAgICAgICAgIHttb2R1bGV9ICAgID0gaXRlbSxcbiAgICAgICAgICAgIHByb3RvO1xuXG4gICAgICAgIGlmICghTmVvLmlzTnVtYmVyKGluZGV4KSkge1xuICAgICAgICAgICAgaW5kZXggPSBpdGVtcy5pbmRleE9mKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLmlzTG9hZGluZyA9IHRydWU7IC8vIHByZXZlbnQgdGhlIGl0ZW0gZnJvbSBnZXR0aW5nIHF1ZXVlZCBtdWx0aXBsZSB0aW1lcyBpbnNpZGUgZm9ybS5Db250YWluZXJcblxuICAgICAgICBtb2R1bGUgPSBhd2FpdCBtb2R1bGUoKTtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgIHByb3RvICA9IG1vZHVsZS5wcm90b3R5cGU7XG5cbiAgICAgICAgaXRlbS5jbGFzc05hbWUgPSBwcm90by5jbGFzc05hbWU7XG4gICAgICAgIGl0ZW0ubW9kdWxlICAgID0gbW9kdWxlO1xuXG4gICAgICAgIGRlbGV0ZSBpdGVtLmlzTG9hZGluZztcbiAgICAgICAgZGVsZXRlIGl0ZW0udmRvbTtcblxuICAgICAgICBpdGVtc1tpbmRleF0gPSBpdGVtID0gTmVvLmNyZWF0ZShpdGVtKTtcblxuICAgICAgICBtZS5hcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgY29udGFpbmVyLmdldFZkb21JdGVtc1Jvb3QoKS5jbltpbmRleF0gPSBpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKTtcblxuICAgICAgICBjb250YWluZXIuZmlyZSgnY2FyZExvYWRlZCcsIHtpdGVtfSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkSW5kZXhcbiAgICAgKi9cbiAgICBhc3luYyBzbGlkZUNhcmRzKGluZGV4LCBvbGRJbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyfSAgID0gbWUsXG4gICAgICAgICAgICBzbGlkZVZlcnRpY2FsID0gbWUuc2xpZGVEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICB7aXRlbXMsIHZkb219ID0gY29udGFpbmVyLFxuICAgICAgICAgICAgY2FyZCAgICAgICAgICA9IGl0ZW1zW2luZGV4XSxcbiAgICAgICAgICAgIG9sZENhcmQgICAgICAgPSBpdGVtc1tvbGRJbmRleF0sXG4gICAgICAgICAgICBzbGlkZUluICAgICAgID0gaW5kZXggPiBvbGRJbmRleCxcbiAgICAgICAgICAgIHJlY3QgICAgICAgICAgPSBhd2FpdCBjb250YWluZXIuZ2V0RG9tUmVjdChjb250YWluZXIuaWQpLFxuICAgICAgICAgICAgYW5pbWF0aW9uV3JhcHBlciwgc3R5bGUsIHgsIHk7XG5cbiAgICAgICAgZGVsZXRlIG9sZENhcmQudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgaWYgKHNsaWRlVmVydGljYWwpIHtcbiAgICAgICAgICAgIHkgPSBzbGlkZUluID8gMCA6IC1yZWN0LmhlaWdodDtcblxuICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgIDogYCR7MiAqIHJlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gICAgOiBgdHJhbnNsYXRlWSgke3l9cHgpYCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHNsaWRlSW4gPyAwIDogLXJlY3Qud2lkdGg7XG5cbiAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgIDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHt4fXB4KWAsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgOiBgJHsyICogcmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZkb20uY24gPSBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1yZWxhdGl2ZSddLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWFuaW1hdGlvbi13cmFwcGVyJ10sIHN0eWxlLCBjbjogW2NhcmQuY3JlYXRlVmRvbVJlZmVyZW5jZSgpXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF07XG5cbiAgICAgICAgYW5pbWF0aW9uV3JhcHBlciA9IHZkb20uY25bMF0uY25bMF07XG5cbiAgICAgICAgYW5pbWF0aW9uV3JhcHBlci5jbltzbGlkZUluID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShvbGRDYXJkLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSk7XG5cbiAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG5cbiAgICAgICAgYXdhaXQgY29udGFpbmVyLnByb21pc2VVcGRhdGUoKTtcblxuICAgICAgICBhbmltYXRpb25XcmFwcGVyLnN0eWxlLnRyYW5zZm9ybSA9IHNsaWRlVmVydGljYWwgP1xuICAgICAgICAgICAgYHRyYW5zbGF0ZVkoJHtzbGlkZUluID8gLXJlY3QuaGVpZ2h0IDogMH1weClgIDpcbiAgICAgICAgICAgIGB0cmFuc2xhdGVYKCR7c2xpZGVJbiA/IC1yZWN0LndpZHRoICA6IDB9cHgpYDtcblxuICAgICAgICBhd2FpdCBjb250YWluZXIucHJvbWlzZVVwZGF0ZSgpO1xuXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzAwKTsgLy8gdHJhbnNpdGlvbiBkdXJhdGlvbiBkZWZpbmVkIHZpYSBDU1MgZm9yIG5vd1xuXG4gICAgICAgIHZkb20uY24gPSBbXTtcblxuICAgICAgICBjb250YWluZXIuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHZkb20uY24ucHVzaChpdGVtLmNyZWF0ZVZkb21SZWZlcmVuY2UoKSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2xkQ2FyZC52ZG9tLnJlbW92ZURvbSA9IHRydWU7XG5cbiAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG5cbiAgICAgICAgYXdhaXQgY29udGFpbmVyLnByb21pc2VVcGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FyZCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkZpdFxuICogQGV4dGVuZHMgTmVvLmxheW91dC5CYXNlXG4gKi9cbmNsYXNzIEZpdCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5GaXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5sYXlvdXQuRml0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1maXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWZpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29udGFpbmVyQ2xzPSduZW8tbGF5b3V0LWZpdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNsczogJ25lby1sYXlvdXQtZml0J1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxseSBzZXRzIHRoZSBDU1MgY2xhc3NlcyBvZiB0aGUgY29udGFpbmVyIGl0ZW1zIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpdGVtLmlnbm9yZUxheW91dCkge1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gTmVvQXJyYXkudW5pb24oaXRlbS53cmFwcGVyQ2xzLCAnbmVvLWxheW91dC1maXQtaXRlbScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBDU1MgcnVsZXMgZnJvbSBhIGNvbnRhaW5lciBpdGVtIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gc3dpdGNoaW5nIHRvIGEgZGlmZmVyZW50IGxheW91dC5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoIWl0ZW0uaWdub3JlTGF5b3V0KSB7XG4gICAgICAgICAgICBsZXQge3dyYXBwZXJDbHN9ID0gaXRlbTtcblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsICduZW8tbGF5b3V0LWZpdC1pdGVtJyk7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZpdCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkZsZXhib3hcbiAqIEBleHRlbmRzIE5lby5sYXlvdXQuQmFzZVxuICovXG5jbGFzcyBGbGV4Ym94IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBhbGlnblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhbGlnblZhbHVlcz1bJ2NlbnRlcicsJ2VuZCcsJ3N0YXJ0Jywnc3RyZXRjaCcsbnVsbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhbGlnblZhbHVlcyA9IFsnY2VudGVyJywgJ2VuZCcsICdzdGFydCcsICdzdHJldGNoJywgbnVsbF1cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGRpcmVjdGlvblxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkaXJlY3Rpb25WYWx1ZXM9Wydjb2x1bW4nLCdjb2x1bW4tcmV2ZXJzZScsJ3JvdycsJ3Jvdy1yZXZlcnNlJyxudWxsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRpcmVjdGlvblZhbHVlcyA9IFsnY29sdW1uJywgJ2NvbHVtbi1yZXZlcnNlJywgJ3JvdycsICdyb3ctcmV2ZXJzZScsIG51bGxdXG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBwYWNrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHBhY2tWYWx1ZXM9WydjZW50ZXInLCdlbmQnLCdzdGFydCcsbnVsbF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBwYWNrVmFsdWVzID0gWydjZW50ZXInLCAnZW5kJywgJ3N0YXJ0JywgbnVsbF1cbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHdyYXBcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gd3JhcFZhbHVlcz1bJ25vd3JhcCcsJ3dyYXAnLCd3cmFwLXJldmVyc2UnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHdyYXBWYWx1ZXMgPSBbJ25vd3JhcCcsICd3cmFwJywgJ3dyYXAtcmV2ZXJzZSddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5sYXlvdXQuRmxleGJveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxheW91dC5GbGV4Ym94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1mbGV4Ym94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xheW91dC1mbGV4Ym94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogJ2NlbnRlcicsICdlbmQnLCAnc3RhcnQnLCAnc3RyZXRjaCcsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFsaWduXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ25fOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiAnY29sdW1uJywgJ2NvbHVtbi1yZXZlcnNlJywgJ3JvdycsICdyb3ctcmV2ZXJzZScsIG51bGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRpcmVjdGlvbl89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmbGV4IGNzcyBhbGxvd3MgZ2FwLiBUaGlzIGFkZHMgaXQgdG8gdGhlIGNvbXBvbmVudCBzdHlsZVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGdhcF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGdhcF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6ICdjZW50ZXInLCAnZW5kJywgJ3N0YXJ0JywgbnVsbFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcGFja189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhY2tfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIGNsYXNzTmFtZSBwcmVmaXhcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcmVmaXg9J25lby1mbGV4LSdcbiAgICAgICAgICovXG4gICAgICAgIHByZWZpeDogJ25lby1mbGV4LScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6IG5vd3JhcCwgd3JhcCwgd3JhcHJldmVyc2VcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB3cmFwXz0nbm93cmFwJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBfOiAnbm93cmFwJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIENvbnRhaW5lciBDU1MgY2xzIGFmdGVyIFwiYWxpZ25cIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWxpZ24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMudXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdhbGlnbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29udGFpbmVyIENTUyBjbHMgYWZ0ZXIgXCJkaXJlY3Rpb25cIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnVwZGF0ZUlucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZGlyZWN0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDb250YWluZXIgc3R5bGUgdG8gYWRkIGEgZ2FwIHRvIGRpc3BsYXk6ZmxleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRHYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgIW9sZFZhbHVlKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHtjb250YWluZXJ9ICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3cmFwcGVyU3R5bGV9ID0gY29udGFpbmVyO1xuXG4gICAgICAgIHdyYXBwZXJTdHlsZS5nYXAgPSB2YWx1ZTtcblxuICAgICAgICBjb250YWluZXIud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29udGFpbmVyIENTUyBjbHMgYWZ0ZXIgXCJwYWNrXCIgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMudXBkYXRlSW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdwYWNrJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDb250YWluZXIgQ1NTIGNscyBhZnRlciBcIndyYXBcIiBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXcmFwKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLnVwZGF0ZUlucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnd3JhcCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmxleCB2YWx1ZSB0byBhbiBpdGVtIG9mIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIGFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmICghaXRlbS53cmFwcGVyU3R5bGUpIHJldHVybjtcblxuICAgICAgICBsZXQgc3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZSxcbiAgICAgICAgICAgIGZsZXggID0gc3R5bGUuZmxleCB8fCBpdGVtLmZsZXggfHwgKHRoaXMuYWxpZ24gPT09ICdzdHJldGNoJyA/IDEgOiAnMCAxIGF1dG8nKTtcblxuICAgICAgICBpZiAoZmxleCA9PT0gMSkge1xuICAgICAgICAgICAgZmxleCA9ICcxIDEgYXV0bydcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLmZsZXggPSBmbGV4O1xuICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBDU1MgY2xhc3NlcyB0byB0aGUgY29udGFpbmVyIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvXG4gICAgICovXG4gICAgYXBwbHlSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBwcmVmaXh9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ2xheW91dC5GbGV4Ym94OiBhcHBseVJlbmRlckF0dHJpYnV0ZXMgLT4gY29udGFpbmVyIG5vdCB5ZXQgY3JlYXRlZCcsIG1lLmNvbnRhaW5lcklkKVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdjb250YWluZXInKTtcblxuICAgICAgICBtZS5hbGlnbiAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdhbGlnbi0nICAgICArIG1lLmFsaWduKTtcbiAgICAgICAgbWUuZGlyZWN0aW9uICYmIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnZGlyZWN0aW9uLScgKyBtZS5kaXJlY3Rpb24pO1xuICAgICAgICBtZS5wYWNrICAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICdwYWNrLScgICAgICArIG1lLnBhY2spO1xuICAgICAgICBtZS53cmFwICAgICAgJiYgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArICd3cmFwLScgICAgICArIG1lLndyYXApO1xuXG4gICAgICAgIGNvbnRhaW5lci53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcImFsaWduXCIgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBbGlnbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVzdElucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWxpZ25WYWx1ZXMnLCAnYWxpZ24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcImRpcmVjdGlvblwiIGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICovXG4gICAgYmVmb3JlU2V0RGlyZWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkaXJlY3Rpb25WYWx1ZXMnLCAnZGlyZWN0aW9uJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyB2YWx1ZSBmb3IgXCJwYWNrXCIgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYWNrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdwYWNrVmFsdWVzJywgJ3BhY2snKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IHZhbHVlIGZvciBcIndyYXBcIiBpcyB2YWxpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGJlZm9yZVNldFdyYXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlc3RJbnB1dFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3dyYXBWYWx1ZXMnLCAnd3JhcCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgQ1NTIHJ1bGVzIGZyb20gYSBjb250YWluZXIgaXRlbSB0aGlzIGxheW91dCBpcyBib3VuZCB0by5cbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHN3aXRjaGluZyB0byBhIGRpZmZlcmVudCBsYXlvdXQuXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgIHN0eWxlLmZsZXggPSBpdGVtLmZsZXggfHwgbnVsbDtcbiAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSBzdHlsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIENTUyBydWxlcyBmcm9tIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiBzd2l0Y2hpbmcgdG8gYSBkaWZmZXJlbnQgbGF5b3V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyLCBwcmVmaXh9ID0gbWUsXG4gICAgICAgICAgICB7d3JhcHBlckNsc30gICAgICAgID0gY29udGFpbmVyO1xuXG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ2xheW91dC5GbGV4Ym94OiByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzIC0+IGNvbnRhaW5lciBub3QgeWV0IGNyZWF0ZWQnLCBtZS5jb250YWluZXJJZClcbiAgICAgICAgfVxuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnY29udGFpbmVyJyk7XG5cbiAgICAgICAgbWUuYWxpZ24gICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnYWxpZ24tJyAgICAgKyBtZS5hbGlnbik7XG4gICAgICAgIG1lLmRpcmVjdGlvbiAmJiBOZW9BcnJheS5yZW1vdmUod3JhcHBlckNscywgcHJlZml4ICsgJ2RpcmVjdGlvbi0nICsgbWUuZGlyZWN0aW9uKTtcbiAgICAgICAgbWUucGFjayAgICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAncGFjay0nICAgICAgKyBtZS5wYWNrKTtcbiAgICAgICAgbWUud3JhcCAgICAgICYmIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCBwcmVmaXggKyAnd3JhcC0nICAgICAgKyBtZS53cmFwKTtcblxuICAgICAgICBjb250YWluZXIud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyB2YWx1ZSBmb3IgcHJvcGVydHlOYW1lIGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWxpZFZhbHVlc05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICB0ZXN0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIHZhbGlkVmFsdWVzTmFtZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGxldCB2YWxpZFZhbHVlcyA9IHRoaXMuZ2V0U3RhdGljQ29uZmlnKHZhbGlkVmFsdWVzTmFtZSk7XG5cbiAgICAgICAgaWYgKCFOZW9BcnJheS5oYXNJdGVtKHZhbGlkVmFsdWVzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcih0aGlzLmNvbnRhaW5lcklkLCAnLT4gbGF5b3V0OiBzdXBwb3J0ZWQgdmFsdWVzIGZvciBcIicgKyBwcm9wZXJ0eU5hbWUgKyAnXCIgYXJlJyAsIHZhbGlkVmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIENvbnRhaW5lciBDU1Mgd3JhcHBlckNsc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUlucHV0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbnRhaW5lciwgcHJlZml4fSA9IG1lLFxuICAgICAgICAgICAge3dyYXBwZXJDbHN9ICAgICAgICA9IGNvbnRhaW5lcjtcblxuICAgICAgICBpZiAoY29udGFpbmVyPy5yZW5kZXJlZCkge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsIHByZWZpeCArIHByb3BlcnR5TmFtZSArICctJyArIG9sZFZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsIHByZWZpeCArIHByb3BlcnR5TmFtZSArICctJyArIHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRmxleGJveCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubGF5b3V0LkdyaWRcbiAqIEBleHRlbmRzIE5lby5sYXlvdXQuQmFzZVxuICovXG5jbGFzcyBHcmlkIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubGF5b3V0LkdyaWQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5sYXlvdXQuR3JpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYXlvdXQtaGJveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYXlvdXQtZ3JpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29udGFpbmVyQ2xzPSduZW8tbGF5b3V0LWZpdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNsczogJ25lby1sYXlvdXQtZ3JpZCdcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEdyaWQpO1xuIiwiaW1wb3J0IEZsZXhib3ggZnJvbSAnLi9GbGV4Ym94Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5sYXlvdXQuSEJveFxuICogQGV4dGVuZHMgTmVvLmxheW91dC5GbGV4Ym94XG4gKi9cbmNsYXNzIEhCb3ggZXh0ZW5kcyBGbGV4Ym94IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5sYXlvdXQuSEJveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxheW91dC5IQm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xheW91dC1oYm94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xheW91dC1oYm94JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGlyZWN0aW9uPSdyb3cnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXJlY3Rpb246ICdyb3cnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmxleCB2YWx1ZSB0byBhbiBpdGVtIG9mIHRoZSBjb250YWluZXIgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIGFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIC8vIERvIG5vdCBhcHBseSBmbGV4IGlmIGZpeGVkIHdpZHRoXG4gICAgICAgICFpdGVtLndpZHRoICYmIHN1cGVyLmFwcGx5Q2hpbGRBdHRyaWJ1dGVzKGl0ZW0sIGluZGV4KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSEJveCk7XG4iLCJpbXBvcnQgRmxleGJveCBmcm9tICcuL0ZsZXhib3gubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmxheW91dC5WQm94XG4gKiBAZXh0ZW5kcyBOZW8ubGF5b3V0LkZsZXhib3hcbiAqL1xuY2xhc3MgVkJveCBleHRlbmRzIEZsZXhib3gge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5WQm94J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LlZCb3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LXZib3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LXZib3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXJlY3Rpb249J2NvbHVtbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmbGV4IHZhbHVlIHRvIGFuIGl0ZW0gb2YgdGhlIGNvbnRhaW5lciB0aGlzIGxheW91dCBpcyBib3VuZCB0b1xuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG8gbm90IGFwcGx5IGZsZXggaWYgZml4ZWQgaGVpZ2h0XG4gICAgICAgICFpdGVtLmhlaWdodCAmJiBzdXBlci5hcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZCb3gpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9