"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_toolbar_SortZone_mjs"],{

/***/ "./src/draggable/toolbar/DragZone.mjs":
/*!********************************************!*\
  !*** ./src/draggable/toolbar/DragZone.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.draggable.toolbar.DragZone
 * @extends Neo.draggable.DragZone
 */
class DragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.toolbar.DragZone'
         * @protected
         */
        className: 'Neo.draggable.toolbar.DragZone',
        /**
         * @member {String} ntype='toolbar-dragzone'
         * @protected
         */
        ntype: 'toolbar-dragzone'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            opts    = {delegate: '.neo-draggable', scope: me};

        owner.addDomListeners([
            {'drag:end'  : me.onDragEnd,   ...opts},
            {'drag:move' : me.onDragMove,  ...opts},
            {'drag:start': me.onDragStart, ...opts}
        ]);

        owner.on({
            insert      : me.onItemInsert,
            itemsCreated: me.onItemsCreated,
            scope       : me
        });

        // The toolbar items can already be created
        me.adjustToolbarItemCls(true)
    }

    /**
     * @param {Boolean} draggable
     */
    adjustToolbarItemCls(draggable) {
        let me      = this,
            {owner} = me,
            wrapperCls;

        owner.items.forEach(item => {
            wrapperCls = item.wrapperCls || [];

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
            item.wrapperCls = wrapperCls
        })
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.owner.draggable) {
            let me           = this,
                proxy        = me.dragProxy,
                cls          = proxy.cls || {},
                rect         = me.dragElementRect,
                wrapperStyle = proxy.wrapperStyle || {};

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-animate');
            proxy.cls = cls;

            // ensure to get into the next animation frame
            me.timeout(30).then(() => {
                wrapperStyle.left = `${rect.left}px`;
                wrapperStyle.top  = `${rect.top}px`;

                proxy.wrapperStyle = wrapperStyle;

                me.timeout(100).then(() => {
                    me.dragEnd()
                })
            })
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me = this;

        if (me.owner.draggable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.owner.vdom, data.path[0].id).vdom;
            await me.dragStart(data)
        }
    }

    /**
     * @param {Object}             data
     * @param {Number}             data.index
     * @param {Neo.component.Base} data.item
     */
    onItemInsert(data) {
        let {item}     = data,
            wrapperCls = item.wrapperCls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, 'neo-draggable');
        item.wrapperCls = wrapperCls
    }

    /**
     * @param {Object}               data
     * @param {String}               data.id
     * @param {Neo.component.Base[]} data.items
     */
    onItemsCreated(data) {console.log('onItemsCreated');
        this.adjustToolbarItemCls(true)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragZone));


/***/ }),

/***/ "./src/draggable/toolbar/SortZone.mjs":
/*!********************************************!*\
  !*** ./src/draggable/toolbar/SortZone.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragZone.mjs */ "./src/draggable/toolbar/DragZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");



/**
 * @class Neo.draggable.toolbar.SortZone
 * @extends Neo.draggable.toolbar.DragZone
 */
class SortZone extends _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.toolbar.SortZone'
         * @protected
         */
        className: 'Neo.draggable.toolbar.SortZone',
        /**
         * @member {String} ntype='toolbar-sortzone'
         * @protected
         */
        ntype: 'toolbar-sortzone',
        /**
         * @member {Boolean} alwaysFireDragMove=true
         */
        alwaysFireDragMove: true,
        /**
         * @member {Number} currentIndex=-1
         * @protected
         */
        currentIndex: -1,
        /**
         * @member {Object} indexMap=null
         * @protected
         */
        indexMap: null,
        /**
         * @member {String|null} itemMargin=null
         * @protected
         */
        itemMargin: null,
        /**
         * @member {Array|null} itemRects=null
         * @protected
         */
        itemRects: null,
        /**
         * @member {Array|null} itemStyles=null
         * @protected
         */
        itemStyles: null,
        /**
         * @member {Object} ownerRect=null
         * @protected
         */
        ownerRect: null,
        /**
         * @member {Object} ownerStyle=null
         * @protected
         */
        ownerStyle: null,
        /**
         * @member {Boolean} alwaysFireDragMove=false
         * @protected
         */
        reversedLayoutDirection: false,
        /**
         * @member {Number} scrollLeft=0
         */
        scrollLeft: 0,
        /**
         * @member {Number} scrollTop=0
         */
        scrollTop: 0,
        /**
         * Internal flag: onDragStart() will set the value to horizontal or vertical, depending on the current layout.
         * @member {String} sortDirection='horizontal'
         * @protected
         */
        sortDirection: 'horizontal',
        /**
         * @member {Number} startIndex=-1
         * @protected
         */
        startIndex: -1
    }

    /**
     * @member {Boolean} isOverDragging=false
     * @protected
     */
    isOverDragging = false

    /**
     * Override this method for class extensions (e.g. tab.header.Toolbar)
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        this.owner.moveTo(fromIndex, toIndex);
    }

    /**
     * @param {Object} data
     */
    async onDragEnd(data) {
        let me                  = this,
            {itemStyles, owner} = me,
            ownerStyle          = owner.style || {},
            itemStyle;

        await me.timeout(10);

        if (owner.sortable) {
            ownerStyle.height = me.ownerStyle.height || null;
            ownerStyle.width  = me.ownerStyle.width  || null;

            owner.style = ownerStyle;

            owner.items.forEach((item, index) => {
                itemStyle = item.wrapperStyle || {};

                Object.assign(itemStyle, {
                    height  : itemStyles[index].height || null,
                    left    : null,
                    margin  : null,
                    position: null,
                    top     : null,
                    width   : itemStyles[index].width || null
                });

                if (index === me.startIndex) {
                    itemStyle.visibility = null
                }

                item.wrapperStyle = itemStyle
            });

            if (me.startIndex !== me.currentIndex) {
                me.moveTo(me.startIndex, me.currentIndex)
            }

            Object.assign(me, {
                currentIndex: -1,
                indexMap    : null,
                itemRects   : null,
                itemStyles  : null,
                ownerRect   : null,
                startIndex  : -1
            });

            await me.timeout(30);

            me.dragEnd(data) // we do not want to trigger the super class call here
        }
    }

    /**
     * @param {Object} data
     */
    async onDragMove(data) {
        // The method can trigger before we got the client rects from the main thread
        if (!this.itemRects || this.isScrolling) {
            return
        }

        let me          = this,
            index       = me.currentIndex,
            {itemRects} = me,
            maxItems    = itemRects.length - 1,
            reversed    = me.reversedLayoutDirection,
            delta, isOverDragging, isOverDraggingEnd, isOverDraggingStart, itemHeightOrWidth, moveFactor;

        if (me.sortDirection === 'horizontal') {
            delta               = data.clientX + me.scrollLeft - me.offsetX - itemRects[index].left;
            isOverDraggingEnd   = data.clientX > me.boundaryContainerRect.right;
            isOverDraggingStart = data.clientX < me.boundaryContainerRect.left;
            itemHeightOrWidth   = 'width'
        } else {
            delta               = data.clientY + me.scrollTop - me.offsetY - itemRects[index].top;
            isOverDraggingEnd   = data.clientY > me.boundaryContainerRect.bottom;
            isOverDraggingStart = data.clientY < me.boundaryContainerRect.top;
            itemHeightOrWidth   = 'height'
        }

        isOverDragging = isOverDraggingEnd || isOverDraggingStart;
        moveFactor     = isOverDragging ? 0.02 : 0.55; // We can not use 0.5, since items would jump back & forth

        if (isOverDraggingStart) {
            if (index > 0) {
                me.currentIndex--;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (isOverDraggingEnd) {
            if (index < maxItems) {
                me.currentIndex++;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index > 0 && (!reversed && delta < 0 || reversed && delta > 0)) {
            if (Math.abs(delta) > itemRects[index - 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex--;
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index < maxItems && (!reversed && delta > 0 || reversed && delta < 0)) {
            if (Math.abs(delta) > itemRects[index + 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex++;
                me.switchItems(index, me.currentIndex)
            }
        }

        me.isOverDragging = isOverDragging && me.currentIndex !== 0 && me.currentIndex !== maxItems;

        if (me.isOverDragging) {
            await me.timeout(30); // wait for 1 frame

            if (me.isOverDragging) {
                await me.onDragMove(data)
            }
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me         = this,
            button     = Neo.getComponent(data.path[0].id),
            {owner}    = me,
            itemStyles = me.itemStyles = [],
            {layout}   = owner,
            ownerStyle = owner.style || {},
            index, indexMap, itemStyle, rect;

        if (owner.sortable) {
            index    = owner.indexOf(button.id);
            indexMap = {};

            Object.assign(me, {
                currentIndex           : index,
                dragElement            : _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find(owner.vdom, button.id).vdom,
                dragProxyConfig        : {...me.dragProxyConfig, cls : [...owner.cls]},
                indexMap               : indexMap,
                ownerStyle             : {height: ownerStyle.height, width : ownerStyle.width},
                reversedLayoutDirection: layout.direction === 'column-reverse' || layout.direction === 'row-reverse',
                sortDirection          : owner.layout.ntype === 'layout-vbox' ? 'vertical' : 'horizontal',
                startIndex             : index
            });

            await me.dragStart(data); // We do not want to trigger the super class call here

            owner.items.forEach((item, index) => {
                indexMap[index] = index;

                itemStyles.push({
                    height: item.height ? `${item.height}px` :  item.style?.height,
                    width : item.width  ? `${item.width}px`  :  item.style?.width
                })
            });

            owner.getDomRect([owner.id].concat(owner.items.map(e => e.id))).then(itemRects => {
                me.ownerRect = itemRects[0];

                ownerStyle.height = `${itemRects[0].height}px`;
                ownerStyle.width  = `${itemRects[0].width}px`;

                // The only reason we are adjusting the toolbar style is that there is no min height or width present.
                // removing items from the layout could trigger a change in size.
                owner.style = ownerStyle;

                itemRects.shift();
                me.itemRects = itemRects;

                owner.items.forEach((item, index) => {
                    itemStyle = item.wrapperStyle || {};
                    rect      = itemRects[index];

                    me.adjustProxyRectToParent?.(rect, me.ownerRect);

                    item.wrapperStyle = Object.assign(itemStyle, {
                        height  : `${rect.height}px`,
                        left    : `${rect.left}px`,
                        margin  : me.itemMargin,
                        position: 'absolute',
                        top     : `${rect.top}px`,
                        width   : `${rect.width}px`
                    })
                });

                // we need to add a short (1 frame) delay to ensure the item has switched to an absolute position
                me.timeout(5).then(() => {
                    itemStyle = button.wrapperStyle || {};
                    itemStyle.visibility = 'hidden';
                    button.wrapperStyle = itemStyle
                })
            })
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async scrollToIndex() {
        let me = this;

        me.isScrolling = true;
        await me.owner.scrollToIndex?.(me.currentIndex, me.itemRects[me.currentIndex]);
        me.isScrolling = false
    }

    /**
     * @param {Number} index1
     * @param {Number} index2
     */
    switchItems(index1, index2) {
        let me       = this,
            reversed = me.reversedLayoutDirection,
            tmp;

        if ((!reversed && index2 < index1) || (reversed && index1 < index2)) {
            tmp    = index1;
            index1 = index2;
            index2 = tmp;
        }

        let itemRects = me.itemRects,
            map       = me.indexMap,
            rect1     = itemRects[index1],
            rect2     = itemRects[index2],
            rect1Copy = rect1.clone(),
            rect2Copy = rect2.clone();

        if (me.sortDirection === 'horizontal') {
            rect1.width = rect2Copy.width;
            rect2.x     = rect1Copy.x + rect2Copy.width;
            rect2.width = rect1Copy.width
        } else {
            rect1.height = rect2Copy.height;
            rect2.height = rect1Copy.height;
            rect2.y      = rect1Copy.y + rect2Copy.height
        }

        tmp         = map[index1];
        map[index1] = map[index2];
        map[index2] = tmp;

        me.updateItem(index1, rect1);
        me.updateItem(index2, rect2)
    }

    /**
     * @param {Number} index
     * @param {Object} rect
     */
    updateItem(index, rect) {
        let me             = this,
            item           = me.owner.items[me.indexMap[index]],
            {wrapperStyle} = item;

        wrapperStyle.left = `${rect.left}px`;
        wrapperStyle.top  = `${rect.top}px`;

        item.wrapperStyle = wrapperStyle
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SortZone));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfdG9vbGJhcl9Tb3J0Wm9uZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNSO0FBQ0Q7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFZO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQix1QkFBdUI7O0FBRXZCO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYSxzQ0FBc0M7QUFDbkQsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSx1REFBUTtBQUNwQjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUEsWUFBWSx1REFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQsdUNBQXVDLFNBQVM7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUEsUUFB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QWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTs7QUFFQSx1Q0FBdUMsb0JBQW9CO0FBQzNELHVDQUF1QyxtQkFBbUI7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pELHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QyxxQ0FBcUMsV0FBVztBQUNoRCxxQkFBcUI7QUFDckIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYzs7QUFFM0IsK0JBQStCLFVBQVU7QUFDekMsK0JBQStCLFNBQVM7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL3Rvb2xiYXIvRHJhZ1pvbmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlRHJhZ1pvbmUgZnJvbSAnLi4vLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUudG9vbGJhci5EcmFnWm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS5EcmFnWm9uZVxuICovXG5jbGFzcyBEcmFnWm9uZSBleHRlbmRzIEJhc2VEcmFnWm9uZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuRHJhZ1pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUudG9vbGJhci5EcmFnWm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyLWRyYWd6b25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXItZHJhZ3pvbmUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgb3B0cyAgICA9IHtkZWxlZ2F0ZTogJy5uZW8tZHJhZ2dhYmxlJywgc2NvcGU6IG1lfTtcblxuICAgICAgICBvd25lci5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25EcmFnRW5kLCAgIC4uLm9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25EcmFnTW92ZSwgIC4uLm9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOnN0YXJ0JzogbWUub25EcmFnU3RhcnQsIC4uLm9wdHN9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIG93bmVyLm9uKHtcbiAgICAgICAgICAgIGluc2VydCAgICAgIDogbWUub25JdGVtSW5zZXJ0LFxuICAgICAgICAgICAgaXRlbXNDcmVhdGVkOiBtZS5vbkl0ZW1zQ3JlYXRlZCxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGhlIHRvb2xiYXIgaXRlbXMgY2FuIGFscmVhZHkgYmUgY3JlYXRlZFxuICAgICAgICBtZS5hZGp1c3RUb29sYmFySXRlbUNscyh0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJhZ2dhYmxlXG4gICAgICovXG4gICAgYWRqdXN0VG9vbGJhckl0ZW1DbHMoZHJhZ2dhYmxlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIHdyYXBwZXJDbHM7XG5cbiAgICAgICAgb3duZXIuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIHdyYXBwZXJDbHMgPSBpdGVtLndyYXBwZXJDbHMgfHwgW107XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZSh3cmFwcGVyQ2xzLCAnbmVvLWRyYWdnYWJsZScsIGRyYWdnYWJsZSk7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5vd25lci5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHByb3h5ICAgICAgICA9IG1lLmRyYWdQcm94eSxcbiAgICAgICAgICAgICAgICBjbHMgICAgICAgICAgPSBwcm94eS5jbHMgfHwge30sXG4gICAgICAgICAgICAgICAgcmVjdCAgICAgICAgID0gbWUuZHJhZ0VsZW1lbnRSZWN0LFxuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IHByb3h5LndyYXBwZXJTdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1hbmltYXRlJyk7XG4gICAgICAgICAgICBwcm94eS5jbHMgPSBjbHM7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBnZXQgaW50byB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgICAgIG1lLnRpbWVvdXQoMzApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUudG9wICA9IGAke3JlY3QudG9wfXB4YDtcblxuICAgICAgICAgICAgICAgIHByb3h5LndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoMTAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ0VuZCgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub3duZXIuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBtZS5kcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmQobWUub3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tO1xuICAgICAgICAgICAgYXdhaXQgbWUuZHJhZ1N0YXJ0KGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICBkYXRhLmluZGV4XG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuaXRlbVxuICAgICAqL1xuICAgIG9uSXRlbUluc2VydChkYXRhKSB7XG4gICAgICAgIGxldCB7aXRlbX0gICAgID0gZGF0YSxcbiAgICAgICAgICAgIHdyYXBwZXJDbHMgPSBpdGVtLndyYXBwZXJDbHMgfHwgW107XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsICduZW8tZHJhZ2dhYmxlJyk7XG4gICAgICAgIGl0ZW0ud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlW119IGRhdGEuaXRlbXNcbiAgICAgKi9cbiAgICBvbkl0ZW1zQ3JlYXRlZChkYXRhKSB7Y29uc29sZS5sb2coJ29uSXRlbXNDcmVhdGVkJyk7XG4gICAgICAgIHRoaXMuYWRqdXN0VG9vbGJhckl0ZW1DbHModHJ1ZSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERyYWdab25lKTtcbiIsImltcG9ydCBEcmFnWm9uZSBmcm9tICcuL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUudG9vbGJhci5Tb3J0Wm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS50b29sYmFyLkRyYWdab25lXG4gKi9cbmNsYXNzIFNvcnRab25lIGV4dGVuZHMgRHJhZ1pvbmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS50b29sYmFyLlNvcnRab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9vbGJhci1zb3J0em9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0b29sYmFyLXNvcnR6b25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhbHdheXNGaXJlRHJhZ01vdmU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbmRleD0tMVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50SW5kZXg6IC0xLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpbmRleE1hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4TWFwOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGl0ZW1NYXJnaW49bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtTWFyZ2luOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaXRlbVJlY3RzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVJlY3RzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaXRlbVN0eWxlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1TdHlsZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG93bmVyUmVjdD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyUmVjdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gb3duZXJTdHlsZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyU3R5bGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbHdheXNGaXJlRHJhZ01vdmU9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmV2ZXJzZWRMYXlvdXREaXJlY3Rpb246IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxMZWZ0PTBcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbFRvcD0wXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnOiBvbkRyYWdTdGFydCgpIHdpbGwgc2V0IHRoZSB2YWx1ZSB0byBob3Jpem9udGFsIG9yIHZlcnRpY2FsLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgbGF5b3V0LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHNvcnREaXJlY3Rpb249J2hvcml6b250YWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNvcnREaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc3RhcnRJbmRleD0tMVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydEluZGV4OiAtMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzT3ZlckRyYWdnaW5nPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzT3ZlckRyYWdnaW5nID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjbGFzcyBleHRlbnNpb25zIChlLmcuIHRhYi5oZWFkZXIuVG9vbGJhcilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXhcbiAgICAgKi9cbiAgICBtb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIHRoaXMub3duZXIubW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aXRlbVN0eWxlcywgb3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBvd25lclN0eWxlICAgICAgICAgID0gb3duZXIuc3R5bGUgfHwge30sXG4gICAgICAgICAgICBpdGVtU3R5bGU7XG5cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMCk7XG5cbiAgICAgICAgaWYgKG93bmVyLnNvcnRhYmxlKSB7XG4gICAgICAgICAgICBvd25lclN0eWxlLmhlaWdodCA9IG1lLm93bmVyU3R5bGUuaGVpZ2h0IHx8IG51bGw7XG4gICAgICAgICAgICBvd25lclN0eWxlLndpZHRoICA9IG1lLm93bmVyU3R5bGUud2lkdGggIHx8IG51bGw7XG5cbiAgICAgICAgICAgIG93bmVyLnN0eWxlID0gb3duZXJTdHlsZTtcblxuICAgICAgICAgICAgb3duZXIuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbVN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAgOiBpdGVtU3R5bGVzW2luZGV4XS5oZWlnaHQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICAgOiBpdGVtU3R5bGVzW2luZGV4XS53aWR0aCB8fCBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IG1lLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlLnZpc2liaWxpdHkgPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSBpdGVtU3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWUuc3RhcnRJbmRleCAhPT0gbWUuY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgbWUubW92ZVRvKG1lLnN0YXJ0SW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgaW5kZXhNYXAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGl0ZW1SZWN0cyAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGVzICA6IG51bGwsXG4gICAgICAgICAgICAgICAgb3duZXJSZWN0ICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggIDogLTFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTtcblxuICAgICAgICAgICAgbWUuZHJhZ0VuZChkYXRhKSAvLyB3ZSBkbyBub3Qgd2FudCB0byB0cmlnZ2VyIHRoZSBzdXBlciBjbGFzcyBjYWxsIGhlcmVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIC8vIFRoZSBtZXRob2QgY2FuIHRyaWdnZXIgYmVmb3JlIHdlIGdvdCB0aGUgY2xpZW50IHJlY3RzIGZyb20gdGhlIG1haW4gdGhyZWFkXG4gICAgICAgIGlmICghdGhpcy5pdGVtUmVjdHMgfHwgdGhpcy5pc1Njcm9sbGluZykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5kZXggICAgICAgPSBtZS5jdXJyZW50SW5kZXgsXG4gICAgICAgICAgICB7aXRlbVJlY3RzfSA9IG1lLFxuICAgICAgICAgICAgbWF4SXRlbXMgICAgPSBpdGVtUmVjdHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHJldmVyc2VkICAgID0gbWUucmV2ZXJzZWRMYXlvdXREaXJlY3Rpb24sXG4gICAgICAgICAgICBkZWx0YSwgaXNPdmVyRHJhZ2dpbmcsIGlzT3ZlckRyYWdnaW5nRW5kLCBpc092ZXJEcmFnZ2luZ1N0YXJ0LCBpdGVtSGVpZ2h0T3JXaWR0aCwgbW92ZUZhY3RvcjtcblxuICAgICAgICBpZiAobWUuc29ydERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBkZWx0YSAgICAgICAgICAgICAgID0gZGF0YS5jbGllbnRYICsgbWUuc2Nyb2xsTGVmdCAtIG1lLm9mZnNldFggLSBpdGVtUmVjdHNbaW5kZXhdLmxlZnQ7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gZGF0YS5jbGllbnRYID4gbWUuYm91bmRhcnlDb250YWluZXJSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgaXNPdmVyRHJhZ2dpbmdTdGFydCA9IGRhdGEuY2xpZW50WCA8IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5sZWZ0O1xuICAgICAgICAgICAgaXRlbUhlaWdodE9yV2lkdGggICA9ICd3aWR0aCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhICAgICAgICAgICAgICAgPSBkYXRhLmNsaWVudFkgKyBtZS5zY3JvbGxUb3AgLSBtZS5vZmZzZXRZIC0gaXRlbVJlY3RzW2luZGV4XS50b3A7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gZGF0YS5jbGllbnRZID4gbWUuYm91bmRhcnlDb250YWluZXJSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGlzT3ZlckRyYWdnaW5nU3RhcnQgPSBkYXRhLmNsaWVudFkgPCBtZS5ib3VuZGFyeUNvbnRhaW5lclJlY3QudG9wO1xuICAgICAgICAgICAgaXRlbUhlaWdodE9yV2lkdGggICA9ICdoZWlnaHQnXG4gICAgICAgIH1cblxuICAgICAgICBpc092ZXJEcmFnZ2luZyA9IGlzT3ZlckRyYWdnaW5nRW5kIHx8IGlzT3ZlckRyYWdnaW5nU3RhcnQ7XG4gICAgICAgIG1vdmVGYWN0b3IgICAgID0gaXNPdmVyRHJhZ2dpbmcgPyAwLjAyIDogMC41NTsgLy8gV2UgY2FuIG5vdCB1c2UgMC41LCBzaW5jZSBpdGVtcyB3b3VsZCBqdW1wIGJhY2sgJiBmb3J0aFxuXG4gICAgICAgIGlmIChpc092ZXJEcmFnZ2luZ1N0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWUuY3VycmVudEluZGV4LS07XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUuc2Nyb2xsVG9JbmRleCgpO1xuICAgICAgICAgICAgICAgIG1lLnN3aXRjaEl0ZW1zKGluZGV4LCBtZS5jdXJyZW50SW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChpc092ZXJEcmFnZ2luZ0VuZCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbWF4SXRlbXMpIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5zY3JvbGxUb0luZGV4KCk7XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID4gMCAmJiAoIXJldmVyc2VkICYmIGRlbHRhIDwgMCB8fCByZXZlcnNlZCAmJiBkZWx0YSA+IDApKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gaXRlbVJlY3RzW2luZGV4IC0gMV1baXRlbUhlaWdodE9yV2lkdGhdICogbW92ZUZhY3Rvcikge1xuICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleC0tO1xuICAgICAgICAgICAgICAgIG1lLnN3aXRjaEl0ZW1zKGluZGV4LCBtZS5jdXJyZW50SW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChpbmRleCA8IG1heEl0ZW1zICYmICghcmV2ZXJzZWQgJiYgZGVsdGEgPiAwIHx8IHJldmVyc2VkICYmIGRlbHRhIDwgMCkpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBpdGVtUmVjdHNbaW5kZXggKyAxXVtpdGVtSGVpZ2h0T3JXaWR0aF0gKiBtb3ZlRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgbWUuY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzT3ZlckRyYWdnaW5nID0gaXNPdmVyRHJhZ2dpbmcgJiYgbWUuY3VycmVudEluZGV4ICE9PSAwICYmIG1lLmN1cnJlbnRJbmRleCAhPT0gbWF4SXRlbXM7XG5cbiAgICAgICAgaWYgKG1lLmlzT3ZlckRyYWdnaW5nKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTsgLy8gd2FpdCBmb3IgMSBmcmFtZVxuXG4gICAgICAgICAgICBpZiAobWUuaXNPdmVyRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5vbkRyYWdNb3ZlKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYnV0dG9uICAgICA9IE5lby5nZXRDb21wb25lbnQoZGF0YS5wYXRoWzBdLmlkKSxcbiAgICAgICAgICAgIHtvd25lcn0gICAgPSBtZSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZXMgPSBtZS5pdGVtU3R5bGVzID0gW10sXG4gICAgICAgICAgICB7bGF5b3V0fSAgID0gb3duZXIsXG4gICAgICAgICAgICBvd25lclN0eWxlID0gb3duZXIuc3R5bGUgfHwge30sXG4gICAgICAgICAgICBpbmRleCwgaW5kZXhNYXAsIGl0ZW1TdHlsZSwgcmVjdDtcblxuICAgICAgICBpZiAob3duZXIuc29ydGFibGUpIHtcbiAgICAgICAgICAgIGluZGV4ICAgID0gb3duZXIuaW5kZXhPZihidXR0b24uaWQpO1xuICAgICAgICAgICAgaW5kZXhNYXAgPSB7fTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCAgICAgICAgICAgOiBpbmRleCxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCAgICAgICAgICAgIDogVkRvbVV0aWwuZmluZChvd25lci52ZG9tLCBidXR0b24uaWQpLnZkb20sXG4gICAgICAgICAgICAgICAgZHJhZ1Byb3h5Q29uZmlnICAgICAgICA6IHsuLi5tZS5kcmFnUHJveHlDb25maWcsIGNscyA6IFsuLi5vd25lci5jbHNdfSxcbiAgICAgICAgICAgICAgICBpbmRleE1hcCAgICAgICAgICAgICAgIDogaW5kZXhNYXAsXG4gICAgICAgICAgICAgICAgb3duZXJTdHlsZSAgICAgICAgICAgICA6IHtoZWlnaHQ6IG93bmVyU3R5bGUuaGVpZ2h0LCB3aWR0aCA6IG93bmVyU3R5bGUud2lkdGh9LFxuICAgICAgICAgICAgICAgIHJldmVyc2VkTGF5b3V0RGlyZWN0aW9uOiBsYXlvdXQuZGlyZWN0aW9uID09PSAnY29sdW1uLXJldmVyc2UnIHx8IGxheW91dC5kaXJlY3Rpb24gPT09ICdyb3ctcmV2ZXJzZScsXG4gICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiAgICAgICAgICA6IG93bmVyLmxheW91dC5udHlwZSA9PT0gJ2xheW91dC12Ym94JyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCAgICAgICAgICAgICA6IGluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgbWUuZHJhZ1N0YXJ0KGRhdGEpOyAvLyBXZSBkbyBub3Qgd2FudCB0byB0cmlnZ2VyIHRoZSBzdXBlciBjbGFzcyBjYWxsIGhlcmVcblxuICAgICAgICAgICAgb3duZXIuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpbmRleE1hcFtpbmRleF0gPSBpbmRleDtcblxuICAgICAgICAgICAgICAgIGl0ZW1TdHlsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbS5oZWlnaHQgPyBgJHtpdGVtLmhlaWdodH1weGAgOiAgaXRlbS5zdHlsZT8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IGl0ZW0ud2lkdGggID8gYCR7aXRlbS53aWR0aH1weGAgIDogIGl0ZW0uc3R5bGU/LndpZHRoXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvd25lci5nZXREb21SZWN0KFtvd25lci5pZF0uY29uY2F0KG93bmVyLml0ZW1zLm1hcChlID0+IGUuaWQpKSkudGhlbihpdGVtUmVjdHMgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm93bmVyUmVjdCA9IGl0ZW1SZWN0c1swXTtcblxuICAgICAgICAgICAgICAgIG93bmVyU3R5bGUuaGVpZ2h0ID0gYCR7aXRlbVJlY3RzWzBdLmhlaWdodH1weGA7XG4gICAgICAgICAgICAgICAgb3duZXJTdHlsZS53aWR0aCAgPSBgJHtpdGVtUmVjdHNbMF0ud2lkdGh9cHhgO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG9ubHkgcmVhc29uIHdlIGFyZSBhZGp1c3RpbmcgdGhlIHRvb2xiYXIgc3R5bGUgaXMgdGhhdCB0aGVyZSBpcyBubyBtaW4gaGVpZ2h0IG9yIHdpZHRoIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgbGF5b3V0IGNvdWxkIHRyaWdnZXIgYSBjaGFuZ2UgaW4gc2l6ZS5cbiAgICAgICAgICAgICAgICBvd25lci5zdHlsZSA9IG93bmVyU3R5bGU7XG5cbiAgICAgICAgICAgICAgICBpdGVtUmVjdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBtZS5pdGVtUmVjdHMgPSBpdGVtUmVjdHM7XG5cbiAgICAgICAgICAgICAgICBvd25lci5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCAgICAgID0gaXRlbVJlY3RzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5hZGp1c3RQcm94eVJlY3RUb1BhcmVudD8uKHJlY3QsIG1lLm93bmVyUmVjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSBPYmplY3QuYXNzaWduKGl0ZW1TdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgICAgOiBgJHtyZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luICA6IG1lLml0ZW1NYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBgJHtyZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAgIDogYCR7cmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYWRkIGEgc2hvcnQgKDEgZnJhbWUpIGRlbGF5IHRvIGVuc3VyZSB0aGUgaXRlbSBoYXMgc3dpdGNoZWQgdG8gYW4gYWJzb2x1dGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBidXR0b24ud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgICAgICBidXR0b24ud3JhcHBlclN0eWxlID0gaXRlbVN0eWxlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBzY3JvbGxUb0luZGV4KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgbWUub3duZXIuc2Nyb2xsVG9JbmRleD8uKG1lLmN1cnJlbnRJbmRleCwgbWUuaXRlbVJlY3RzW21lLmN1cnJlbnRJbmRleF0pO1xuICAgICAgICBtZS5pc1Njcm9sbGluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDJcbiAgICAgKi9cbiAgICBzd2l0Y2hJdGVtcyhpbmRleDEsIGluZGV4Mikge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmV2ZXJzZWQgPSBtZS5yZXZlcnNlZExheW91dERpcmVjdGlvbixcbiAgICAgICAgICAgIHRtcDtcblxuICAgICAgICBpZiAoKCFyZXZlcnNlZCAmJiBpbmRleDIgPCBpbmRleDEpIHx8IChyZXZlcnNlZCAmJiBpbmRleDEgPCBpbmRleDIpKSB7XG4gICAgICAgICAgICB0bXAgICAgPSBpbmRleDE7XG4gICAgICAgICAgICBpbmRleDEgPSBpbmRleDI7XG4gICAgICAgICAgICBpbmRleDIgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXRlbVJlY3RzID0gbWUuaXRlbVJlY3RzLFxuICAgICAgICAgICAgbWFwICAgICAgID0gbWUuaW5kZXhNYXAsXG4gICAgICAgICAgICByZWN0MSAgICAgPSBpdGVtUmVjdHNbaW5kZXgxXSxcbiAgICAgICAgICAgIHJlY3QyICAgICA9IGl0ZW1SZWN0c1tpbmRleDJdLFxuICAgICAgICAgICAgcmVjdDFDb3B5ID0gcmVjdDEuY2xvbmUoKSxcbiAgICAgICAgICAgIHJlY3QyQ29weSA9IHJlY3QyLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKG1lLnNvcnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgcmVjdDEud2lkdGggPSByZWN0MkNvcHkud2lkdGg7XG4gICAgICAgICAgICByZWN0Mi54ICAgICA9IHJlY3QxQ29weS54ICsgcmVjdDJDb3B5LndpZHRoO1xuICAgICAgICAgICAgcmVjdDIud2lkdGggPSByZWN0MUNvcHkud2lkdGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY3QxLmhlaWdodCA9IHJlY3QyQ29weS5oZWlnaHQ7XG4gICAgICAgICAgICByZWN0Mi5oZWlnaHQgPSByZWN0MUNvcHkuaGVpZ2h0O1xuICAgICAgICAgICAgcmVjdDIueSAgICAgID0gcmVjdDFDb3B5LnkgKyByZWN0MkNvcHkuaGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgICAgICAgICA9IG1hcFtpbmRleDFdO1xuICAgICAgICBtYXBbaW5kZXgxXSA9IG1hcFtpbmRleDJdO1xuICAgICAgICBtYXBbaW5kZXgyXSA9IHRtcDtcblxuICAgICAgICBtZS51cGRhdGVJdGVtKGluZGV4MSwgcmVjdDEpO1xuICAgICAgICBtZS51cGRhdGVJdGVtKGluZGV4MiwgcmVjdDIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKi9cbiAgICB1cGRhdGVJdGVtKGluZGV4LCByZWN0KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtICAgICAgICAgICA9IG1lLm93bmVyLml0ZW1zW21lLmluZGV4TWFwW2luZGV4XV0sXG4gICAgICAgICAgICB7d3JhcHBlclN0eWxlfSA9IGl0ZW07XG5cbiAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBgJHtyZWN0LmxlZnR9cHhgO1xuICAgICAgICB3cmFwcGVyU3R5bGUudG9wICA9IGAke3JlY3QudG9wfXB4YDtcblxuICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU29ydFpvbmUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9