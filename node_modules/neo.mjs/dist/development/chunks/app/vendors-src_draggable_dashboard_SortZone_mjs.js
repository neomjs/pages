export const __webpack_esm_id__ = "vendors-src_draggable_dashboard_SortZone_mjs";
export const __webpack_esm_ids__ = ["vendors-src_draggable_dashboard_SortZone_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/draggable/dashboard/SortZone.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/dashboard/SortZone.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/DragCoordinator.mjs */ "./src/manager/DragCoordinator.mjs");
/* harmony import */ var _DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DragProxyContainer.mjs */ "./src/draggable/DragProxyContainer.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _container_SortZone_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../container/SortZone.mjs */ "./src/draggable/container/SortZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");








/**
 * @class Neo.draggable.dashboard.SortZone
 * @extends Neo.draggable.container.SortZone
 */
class DashboardSortZone extends _container_SortZone_mjs__WEBPACK_IMPORTED_MODULE_5__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.dashboard.SortZone'
         * @protected
         */
        className: 'Neo.draggable.dashboard.SortZone',
        /**
         * @member {String} ntype='dashboard-sortzone'
         * @protected
         */
        ntype: 'dashboard-sortzone',
        /**
         * The CSS selector for the drag handle.
         * @member {String} dragHandleSelector='.neo-draggable'
         */
        dragHandleSelector: '.neo-draggable',
        /**
         * Add extra CSS selectors to the drag proxy root.
         * @member {String[]} dragProxyExtraCls=[]
         */
        dragProxyExtraCls: [],
        /**
         * @member {String|null} sortGroup=null
         */
        sortGroup: null
    }

    /**
     * @member {Boolean} isRemoteDragging=false
     * @protected
     */
    isRemoteDragging = false

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].register(this)
    }

    /**
     * Checks if the remote drag coordinates intersect with the sort zone.
     * Triggers an async fetch of ownerRect if not currently cached.
     * @param {Number} x
     * @param {Number} y
     * @returns {Boolean}
     */
    acceptsRemoteDrag(x, y) {
        let me = this;

        if (!me.ownerRect) {
            if (!me.isFetchingRect) {
                me.isFetchingRect = true;
                me.owner.getDomRect([me.owner.id]).then(rects => {
                    me.ownerRect = rects[0];
                    me.isFetchingRect = false
                })
            }
            return false
        }

        return x >= me.ownerRect.x &&
               x <= me.ownerRect.x + me.ownerRect.width &&
               y >= me.ownerRect.y &&
               y <= me.ownerRect.y + me.ownerRect.height
    }

    /**
     *
     */
    applyAbsolutePositioning() {
        let me = this,
            itemStyle;

        me.sortableItems.forEach((item, i) => {
            let rect = me.itemRects[i];

            itemStyle = item.wrapperStyle || {};

            me.adjustProxyRectToParent?.(rect, me.ownerRect);

            console.log('applyAbsolutePositioning', {
                height  : `${rect.height}px`,
                left    : `${rect.left}px`,
                top     : `${rect.top}px`,
                width   : `${rect.width}px`
            });

            item.wrapperStyle = Object.assign(itemStyle, {
                flex    : 'none',
                height  : `${rect.height}px`,
                left    : `${rect.left}px`,
                margin  : '0px',
                position: 'absolute',
                top     : `${rect.top}px`,
                width   : `${rect.width}px`
            })
        })
    }

    /**
     * Calculates a new layout for the remaining items when one item is dragged out of the container (e.g., into a new window).
     *
     * This method ensures the dashboard doesn't leave a "hole" where the dragged item was. Instead, it:
     * 1.  **Infers Gaps & Offsets:** Analyzes the cached `itemRects` to mathematically derive the container's padding
     *     and the gaps between items, ensuring the new layout respects the original design tokens.
     * 2.  **Identifies Remaining Items:** Filters out the dragged component and its placeholder.
     * 3.  **Distributes Space:** Calculates the available space (Total Size - Offsets - Gaps - Fixed Items) and distributes
     *     it among flex items proportional to their flex values.
     * 4.  **Generates Styles:** Returns a list of style objects (`top`, `left`, `width`, `height`) to be applied to the remaining items.
     *
     * @returns {Object[]} Array of objects containing the `item` reference and the calculated `style` object.
     */
    calculateExpandedLayout() {
        let me           = this,
            ownerRect    = me.ownerRect,
            isHorizontal = me.sortDirection === 'horizontal',
            totalSize    = isHorizontal ? ownerRect.width : ownerRect.height,
            items        = [],
            totalFlex    = 0,
            usedSize     = 0,
            rects        = [],
            startOffset  = 0,
            endOffset    = 0,
            gap          = 0,
            topOffset    = 0,
            bottomOffset = 0,
            leftOffset   = 0,
            rightOffset  = 0,
            startX       = me.adjustItemRectsToParent ? 0 : ownerRect.x,
            startY       = me.adjustItemRectsToParent ? 0 : ownerRect.y;

        // 1. Calculate offsets and gaps from the original slots (itemRects)
        if (me.itemRects.length > 0) {
            let r0 = me.itemRects[0],
                rn = me.itemRects[me.itemRects.length - 1];

            if (isHorizontal) {
                startOffset  = me.adjustItemRectsToParent ? r0.x : r0.x - ownerRect.x;
                endOffset    = totalSize - (me.adjustItemRectsToParent ? (rn.x + rn.width) : (rn.x - ownerRect.x + rn.width));
                topOffset    = me.adjustItemRectsToParent ? r0.y : r0.y - ownerRect.y;
                bottomOffset = ownerRect.height - (me.adjustItemRectsToParent ? (r0.y + r0.height) : (r0.y - ownerRect.y + r0.height)); // Approx from first item

                if (me.itemRects.length > 1) {
                    let r1 = me.itemRects[1];
                    gap = r1.x - (r0.x + r0.width);
                }
            } else {
                startOffset = me.adjustItemRectsToParent ? r0.y : r0.y - ownerRect.y;
                endOffset   = totalSize - (me.adjustItemRectsToParent ? (rn.y + rn.height) : (rn.y - ownerRect.y + rn.height));
                leftOffset  = me.adjustItemRectsToParent ? r0.x : r0.x - ownerRect.x;
                rightOffset = ownerRect.width - (me.adjustItemRectsToParent ? (r0.x + r0.width) : (r0.x - ownerRect.x + r0.width));

                if (me.itemRects.length > 1) {
                    let r1 = me.itemRects[1];
                    gap = r1.y - (r0.y + r0.height);
                }
            }
        }
        // 2. Filter valid items
        for (let i = 0; i < me.itemRects.length; i++) {
            let mappedIndex = me.indexMap[i];

            if (mappedIndex === -1) {
                continue
            }

            let item = me.owner.items[mappedIndex];

            if (item === me.dragPlaceholder || item === me.dragComponent) {
                continue
            }

            let rect = me.itemRects[i];

            items.push({item, rect});

            if (item.flex) {
                totalFlex += item.flex
            } else {
                let size = isHorizontal ? rect.width : rect.height;
                usedSize += size
            }
        }

        // 3. Calculate available space
        let totalGaps      = Math.max(0, items.length - 1),
            availableSpace = Math.max(0, totalSize - startOffset - endOffset - (totalGaps * gap) - usedSize);

        // 4. Distribute space
        let currentPos = startOffset;

        items.forEach(({item, rect}, index) => {
            let itemSize, style = {};

            if (item.flex) {
                itemSize = (item.flex / totalFlex) * availableSpace
            } else {
                itemSize = isHorizontal ? rect.width : rect.height
            }

            if (isHorizontal) {
                style = {
                    left  : `${startX + currentPos}px`,
                    top   : `${startY + topOffset}px`,
                    height: `${ownerRect.height - topOffset - bottomOffset}px`,
                    width : `${itemSize}px`
                }
            } else {
                style = {
                    left  : `${startX + leftOffset}px`,
                    top   : `${startY + currentPos}px`,
                    height: `${itemSize}px`,
                    width : `${ownerRect.width - leftOffset - rightOffset}px`
                }
            }

            rects.push({item, style});
            currentPos += itemSize + gap
        });

        return rects
    }

    /**
     *
     */
    destroy() {
        _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unregister(this);
        super.destroy()
    }

    /**
     * @returns {Object}
     */
    getDragProxyConfig() {
        const config = super.getDragProxyConfig();

        config.cls = config.cls.filter(cls => !cls.includes('neo-viewport'));
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(config.cls, this.dragProxyExtraCls);

        return config
    }

    /**
     * @param {Object} data The drag end event data.
     */
    async onDragEnd(data) {
        let me = this;

        if (!me.isRemoteDragging) {
            // Signal Coordinator about end of drag
            _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].onDragEnd({
                draggedItem   : me.dragComponent,
                sourceSortZone: me
            })
        }

        super.onDragEnd(data)
    }

    /**
     * Handles the drag move event. This is the core logic loop for the drag operation.
     *
     * Responsibilities:
     * 1.  **Window Drag Re-entry:** Checks if a window drag has re-entered the original container boundaries.
     *     If so, it restores the original layout snapshot (`itemRects`) and shows the placeholder, effectively
     *     "snapping" the dashboard back to its sortable state.
     * 2.  **Window Drag Exit:** Detects if the drag proxy has left the container boundaries (if `enableProxyToPopup` is true)
     *     and triggers the `dragBoundaryExit` event to potentially start a window drag.
     * 3.  **Standard Sorting:** If not in window-drag mode, it calculates the drag delta and swaps items (`switchItems`)
     *     if the threshold is crossed, updating the `currentIndex`.
     * 4.  **Auto-Scrolling:** Manages auto-scrolling when dragging near the edges of the container.
     *
     * @param {Object} data The drag move event data.
     */
    async onDragMove(data) {
        let me = this;

        // The method can trigger before we got the client rects from the main thread
        if (!me.itemRects || !me.boundaryContainerRect || me.isScrolling) {
            return
        }

        await super.onDragMove(data)
    }

    /**
     * @param {Object} data
     */
    async onRemoteDragLeave(data) {
        let me = this;

        if (me.isRemoteDragging) {
            me.isRemoteDragging = false;
            await me.onDragEnd({})
        }
    }

    /**
     * @param {Object} data
     */
    async onRemoteDragMove(data) {
        let me = this;

        if (!me.isRemoteDragging) {
            await me.startRemoteDrag(data)
        }

        // Delegate to standard onDragMove logic, which updates the proxy
        me.onDragMove({
            clientX  : data.localX,
            clientY  : data.localY,
            proxyRect: data.proxyRect
        });

        me.dragMove({
            clientX: data.localX,
            clientY: data.localY
        }, true)
    }

    /**
     * @param {Neo.component.Base} draggedItem
     */
    async onRemoteDrop(draggedItem) {
        let me    = this,
            index = me.currentIndex;

        // Ensure we are in remote drag mode
        if (me.isRemoteDragging) {
            // Cleanup placeholder but keep layout ready
            await me.onDragEnd({});

            // Remove from old parent (if not already detached)
            const parentId = draggedItem.parentId;
            if (parentId && parentId !== 'document.body') {
                Neo.getComponent(parentId)?.remove(draggedItem, false)
            }

            // Insert into new owner
            me.owner.insert(index, draggedItem);

            me.isRemoteDragging = false
        }
    }

    /**
     * @param {Neo.component.Base} draggedItem
     */
    onRemoteDropOut(draggedItem) {
        // Called on the source sort zone when a drop occurred elsewhere.
        // We need to cleanup any detached state tracking.
        let me = this;

        if (me.owner.detachedItems) {
            for (const [key, value] of me.owner.detachedItems.entries()) {
                if (value.widget === draggedItem) {
                    me.owner.detachedItems.delete(key);
                    // The window is already closed by suspendWindowDrag, so we just clean up the map.
                    break
                }
            }
        }
    }

    /**
     * @param {Number} intersectionRatio
     * @param {Object} data
     */
    onWindowDragContinue(intersectionRatio, data) {
        let me = this;

        // Signal Coordinator
        _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].onDragMove({
            draggedItem   : me.dragComponent,
            offsetX       : me.offsetX,
            offsetY       : me.offsetY,
            proxyRect     : data.proxyRect,
            screenX       : data.screenX,
            screenY       : data.screenY,
            sourceSortZone: me
        })
    }

    /**
     * @param {String} widgetName
     * @param {DOMRect} proxyRect
     */
    resumeWindowDrag(widgetName, proxyRect) {
        this.owner.resumeWindowDrag(widgetName, proxyRect)
    }

    /**
     * @param {Neo.component.Base} draggedItem
     */
    async setupDragState(draggedItem) {
        let me                               = this,
            {adjustItemRectsToParent, owner} = me,
            itemStyles                       = me.itemStyles = [],
            {layout}                         = owner,
            ownerStyle                       = owner.style || {},
            index, indexMap, itemRects, sortableItems;

        sortableItems = owner.items.filter(item => !item.isDestroyed);
        index         = sortableItems.indexOf(draggedItem);

        indexMap = {};

        Object.assign(me, {
            currentIndex           : index,
            dragElement            : _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].find(owner.vdom, draggedItem.id).vdom,
            dragProxyConfig        : me.getDragProxyConfig(),
            indexMap,
            ownerStyle             : {height: ownerStyle.height, minWidth: ownerStyle.minWidth, width: ownerStyle.width},
            reversedLayoutDirection: layout.direction === 'column-reverse' || layout.direction === 'row-reverse',
            sortableItems,
            sortDirection          : layout.direction?.includes('column') ? 'vertical' : 'horizontal',
            startIndex             : index
        });

        me.dragComponent = draggedItem;

        sortableItems.forEach((item, i) => {
            indexMap[i] = owner.items.indexOf(item);

            itemStyles.push({
                height: item.height ? `${item.height}px` :  item.style?.height,
                width : item.width  ? `${item.width}px`  :  item.style?.width
            })
        });

        itemRects = await owner.getDomRect([owner.id].concat(sortableItems.map(e => e.id)));

        itemRects.forEach(rect => {
            console.log('itemRect', {
                height  : `${rect.height}px`,
                left    : `${rect.left}px`,
                top     : `${rect.top}px`,
                width   : `${rect.width}px`
            });
        });

        me.ownerRect = itemRects.shift();
        me.boundaryContainerRect = me.ownerRect;

        owner.style = {
            ...ownerStyle,
            height  : `${me.ownerRect.height}px`,
            minWidth: `${me.ownerRect.width}px`,
            width   : `${me.ownerRect.width}px`
        };

        console.log('adjustItemRectsToParent', adjustItemRectsToParent);

        adjustItemRectsToParent && itemRects.forEach(rect => {
            rect.x -= me.ownerRect.x;
            rect.y -= me.ownerRect.y
        });

        me.itemRects = itemRects
    }

    /**
     * @param {Object} data
     */
    async startRemoteDrag(data) {
        let me          = this,
            {owner}     = me,
            {proxyRect} = data,
            draggedItem = data.draggedItem,
            config;

        me.isRemoteDragging = true;

        // Mock the drag element rect for DragZone logic if needed
        me.dragElementRect = {
            height: proxyRect.height,
            width : proxyRect.width,
            x     : data.localX,
            y     : data.localY,
            left  : data.localX,
            top   : data.localY
        };

        // Update dragged item to target app context
        draggedItem.appName = me.appName;

        console.log('startRemoteDrag', draggedItem.id, draggedItem.windowId, draggedItem.parentId, draggedItem.parentComponent);

        // Break the parent chain to prevent circular config lookups during handover
        draggedItem.parentId        = null;
        draggedItem.parentComponent = null;

        // Since the component was mounted in a different window, we need to reset the state
        draggedItem.mounted          = false;
        draggedItem.vnode            = null;
        draggedItem.vnodeInitialized = false;

        console.log('parent cleared:', draggedItem.parentId, draggedItem.parentComponent);

        // 1. Get Owner Rect (needed for proxy positioning)
        let rects = await owner.getDomRect([owner.id]);
        me.ownerRect = rects[0];

        console.log('ownerRect', me.ownerRect);

        // Assign the drag offsets to the instance, so that the DragZone onDragMove logic works
        me.offsetX = data.offsetX;
        me.offsetY = data.offsetY;

        console.log('startRemoteDrag: ownerRect', me.ownerRect);
        console.log('startRemoteDrag: local coords', data.localX, data.localY);
        console.log('startRemoteDrag: calculated coords', data.localX - me.offsetX, data.localY - me.offsetY);

        // 2. Create a local DragProxy manually (using DragProxyContainer to hold the live widget)
        // We use DragProxyContainer to ensure the widget remains active/connected.
        config = {
            module          : _DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName         : me.appName,
            cls             : ['neo-dragproxy', ...me.owner.cls],
            items           : [draggedItem],
            moveInMainThread: false,
            windowId        : me.windowId,

            style: {
                left: `${data.localX - me.offsetX}px`,
                top : `${data.localY - me.offsetY}px`
            }
        };

        console.log('Creating local drag proxy', config);

        me.dragProxy = Neo.create(config);

        console.log('Created local drag proxy', me.dragProxy);

        // 3. Create Placeholder
        me.dragPlaceholder = Neo.create({
            module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex  : 'none',
            style : {height: `${proxyRect.height}px`, visibility: 'hidden'}
        });

        owner.add(me.dragPlaceholder);

        // 4. Setup Sort State
        await me.timeout(50);
        await me.setupDragState(me.dragPlaceholder);

        // Update proxy size to match the measured placeholder
        let placeholderIndex = me.sortableItems.indexOf(me.dragPlaceholder);

        if (placeholderIndex > -1) {
            let rect = me.itemRects[placeholderIndex];
            me.dragProxy.width  = rect.width;
            me.dragProxy.height = rect.height;
        }

        await me.timeout(50);
        // 5. Apply Absolute Positioning
        me.applyAbsolutePositioning()
    }

    /**
     * Handles the drag move event. This is the core logic loop for the drag operation.
     *
     * Responsibilities:
     * 1.  **Window Drag Re-entry:** Checks if a window drag has re-entered the original container boundaries.
     *     If so, it restores the original layout snapshot (`itemRects`) and shows the placeholder, effectively
     *     "snapping" the dashboard back to its sortable state.
     * 2.  **Window Drag Exit:** Detects if the drag proxy has left the container boundaries (if `enableProxyToPopup` is true)
     *     and triggers the `dragBoundaryExit` event to potentially start a window drag.
     * 3.  **Standard Sorting:** If not in window-drag mode, it calculates the drag delta and swaps items (`switchItems`)
     *     if the threshold is crossed, updating the `currentIndex`.
     * 4.  **Auto-Scrolling:** Manages auto-scrolling when dragging near the edges of the container.
     *
     * @param {Object} data - The drag move event data.
     */
    startWindowDrag(data) {
        let me = this,
            {popupHeight, popupWidth, windowName} = data;

        // Keep the proxy active to capture mouse events, but make it invisible
        me.dragProxy.style = {opacity: 0};
        me.isWindowDragging = true;

        if (me.dragPlaceholder) {
            me.dragPlaceholder.wrapperStyle = {
                ...me.dragPlaceholder.wrapperStyle,
                visibility: 'hidden'
            }
        }

        // Apply expanded layout
        let expandedLayout = me.calculateExpandedLayout();
        expandedLayout.forEach(({item, style}) => {
            item.wrapperStyle = {...item.wrapperStyle, ...style}
        });

        Neo.main.addon.DragDrop.startWindowDrag({
            popupHeight,
            popupName: windowName,
            popupWidth,
            windowId : me.windowId
        })
    }

    /**
     * @param {String} widgetName
     */
    suspendWindowDrag(widgetName) {
        this.owner.suspendWindowDrag(widgetName)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DashboardSortZone));


/***/ },

/***/ "./src/manager/DragCoordinator.mjs"
/*!*****************************************!*\
  !*** ./src/manager/DragCoordinator.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _Window_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Window.mjs */ "./src/manager/Window.mjs");




/**
 * @class Neo.manager.DragCoordinator
 * @extends Neo.manager.Base
 * @singleton
 */
class DragCoordinator extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.DragCoordinator'
         * @protected
         */
        className: 'Neo.manager.DragCoordinator',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Map} sortZones=new Map()
         * @protected
         */
        sortZones: new Map()
    }

    /**
     * @member {Neo.draggable.container.SortZone|null} activeTargetZone=null
     * @protected
     */
    activeTargetZone = null

    /**
     * @param {Neo.draggable.container.SortZone} sourceSortZone
     * @param {Neo.component.Base} draggedItem
     * @param {DOMRect} proxyRect
     */
    handleVoid(sourceSortZone, draggedItem, proxyRect) {
        let me = this;

        if (me.activeTargetZone) {
            me.activeTargetZone.onRemoteDragLeave();
            me.activeTargetZone = null;

            // Resume source drag (re-open popup)
            sourceSortZone.resumeWindowDrag(draggedItem.reference || draggedItem.id, proxyRect)
        }
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.draggedItem
     * @param {Number} data.offsetX
     * @param {Number} data.offsetY
     * @param {Number} data.screenX
     * @param {Number} data.screenY
     * @param {Neo.draggable.container.SortZone} data.sourceSortZone
     */
    onDragMove(data) {
        let me             = this,
            {draggedItem, offsetX, offsetY, proxyRect, screenX, screenY, sourceSortZone} = data,
            {sortGroup}    = sourceSortZone,
            targetWindowId = _Window_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getWindowAt(screenX, screenY),
            targetSortZone;

        if (targetWindowId && targetWindowId !== sourceSortZone.windowId) {
            targetSortZone = me.sortZones.get(sortGroup)?.get(targetWindowId);

            if (targetSortZone) {
                let targetWindow = _Window_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].get(targetWindowId),
                    localX       = screenX - targetWindow.innerRect.x,
                    localY       = screenY - targetWindow.innerRect.y,
                    targetProxyRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
                        localX - offsetX,
                        localY - offsetY,
                        proxyRect.width,
                        proxyRect.height
                    );

                if (targetSortZone.acceptsRemoteDrag(localX, localY)) {
                    // console.log('DragCoordinator target found', {targetWindowId, localX, localY});

                    // Entering a new target zone
                    if (me.activeTargetZone !== targetSortZone) {
                        // Leaving previous target (if any)
                        me.activeTargetZone?.onRemoteDragLeave();

                        // Suspend source drag (close popup, etc)
                        // We only do this once when leaving the void/source context
                        if (!me.activeTargetZone) {
                            sourceSortZone.suspendWindowDrag(draggedItem.reference || draggedItem.id)
                        }

                        me.activeTargetZone = targetSortZone
                    }

                    targetSortZone.onRemoteDragMove({
                        draggedItem,
                        localX,
                        localY,
                        offsetX,
                        offsetY,
                        proxyRect: targetProxyRect
                    });

                    return
                }
            }
        }

        // In void or back in source window
        me.handleVoid(sourceSortZone, draggedItem, proxyRect)
    }

    /**
     * @param {Object} data
     * @param {Neo.draggable.container.SortZone} data.sourceSortZone
     */
    onDragEnd(data) {
        let me = this;

        if (me.activeTargetZone) {
            // Drop on target
            me.activeTargetZone.onRemoteDrop(data.draggedItem);

            // Notify source to finalize cleanup
            data.sourceSortZone.onRemoteDropOut(data.draggedItem);

            me.activeTargetZone = null
        } else {
            // Drag ended in void or source window (handled locally by source)
        }
    }

    /**
     * @param {Neo.draggable.container.SortZone} sortZone
     */
    register(sortZone) {
        let me                    = this,
            {sortGroup, windowId} = sortZone;

        if (sortGroup) {
            if (!me.sortZones.has(sortGroup)) {
                me.sortZones.set(sortGroup, new Map())
            }

            me.sortZones.get(sortGroup).set(windowId, sortZone)
        }
    }

    /**
     * @param {Neo.draggable.container.SortZone} sortZone
     */
    unregister(sortZone) {
        let me                    = this,
            {sortGroup, windowId} = sortZone;

        if (sortGroup && me.sortZones.has(sortGroup)) {
            let group = me.sortZones.get(sortGroup);
            group.delete(windowId);

            if (group.size === 0) {
                me.sortZones.delete(sortGroup)
            }
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            className       : me.className,
            activeTargetZone: me.activeTargetZone ? {
                id       : me.activeTargetZone.id,
                sortGroup: me.activeTargetZone.sortGroup,
                windowId : me.activeTargetZone.windowId
            } : null,
            sortZones: Array.from(me.sortZones.entries()).map(([group, map]) => ({
                group,
                windows: Array.from(map.keys())
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragCoordinator));


/***/ },

/***/ "./src/manager/Window.mjs"
/*!********************************!*\
  !*** ./src/manager/Window.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");



/**
 * @summary The "God View" for the multi-window application workspace.
 * @description This manager maintains a real-time geometric map of all connected browser windows in the App Worker.
 * It is the central authority for spatial awareness, enabling features like the "Infinite Canvas" where
 * interactions (like Drag & Drop) can span across multiple OS-level windows.
 *
 * It receives high-frequency position updates from the Main Thread (via `Neo.main.addon.WindowPosition`)
 * and provides intersection testing APIs to determine which window is under a given screen coordinate.
 *
 * @class Neo.manager.Window
 * @extends Neo.manager.Base
 * @singleton
 * @see Neo.main.addon.WindowPosition
 */
class Window extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Window'
         * @protected
         */
        className: 'Neo.manager.Window',
        /**
         * @member {Boolean} isSafari
         * @protected
         */
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * Returns the windowId which intersects with the given global screen coordinates.
     * This is the core intersection test for cross-window drag and drop operations.
     * @param {Number} x Screen X coordinate
     * @param {Number} y Screen Y coordinate
     * @returns {String|null} The windowId of the target window, or null if no intersection.
     */
    getWindowAt(x, y) {
        let item = this.items.find(item => item.outerRect?.intersects({bottom: y, right: x, x, y}));

        return item ? item.id : null
    }

    /**
     * @param {Object} data
     * @returns {Object} {chrome, innerRect, outerRect}
     */
    calculateGeometry(data) {
        const
            {innerHeight, innerWidth, mozInnerScreenX, mozInnerScreenY, outerHeight, outerWidth, screenLeft, screenTop} = data,
            widthDiff    = outerWidth  - innerWidth,
            heightDiff   = outerHeight - innerHeight,
            // Assumption: Side borders are symmetric
            sideBorder   = widthDiff / 2,
            // Assumption: Bottom border matches side border (common in Windows)
            bottomBorder = sideBorder,
            // The rest is the top chrome (header)
            topChrome    = heightDiff - bottomBorder;

        const chrome = {
            bottom: bottomBorder,
            left  : sideBorder,
            right : sideBorder,
            top   : topChrome
        };

        let viewportLeft, viewportTop;

        if (typeof mozInnerScreenX === 'number') {
            // Firefox: explicit viewport coordinates
            viewportLeft = mozInnerScreenX;
            viewportTop  = mozInnerScreenY
        } else if (this.isSafari) {
            // Safari: screenLeft/Top is Frame position. Add chrome to get Viewport.
            viewportLeft = screenLeft + sideBorder;
            viewportTop  = screenTop  + topChrome
        } else {
            // Chrome/Edge: screenLeft/Top is Viewport position.
            viewportLeft = screenLeft;
            viewportTop  = screenTop
        }

        const innerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](viewportLeft, viewportTop, innerWidth, innerHeight);

        const outerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            viewportLeft - sideBorder,
            viewportTop  - topChrome,
            outerWidth,
            outerHeight
        );

        return {chrome, innerRect, outerRect}
    }

    /**
     * Triggered when a new browser window connects to the SharedWorker.
     * In Shared Worker mode, `Neo.worker.App#onConnect` ensures that `windowData`
     * is fetched from the Main Thread and included in the payload.
     * @param {Object} data
     * @param {Number} data.appName
     * @param {Object} [data.windowData] Contains geometry data (screenLeft, innerHeight, etc.)
     * @param {String} data.windowId
     */
    onWindowConnect({appName, windowData, windowId}) {
        let chrome    = null,
            innerRect = null,
            outerRect = null;

        if (windowData) {
            ({chrome, innerRect, outerRect} = this.calculateGeometry(windowData))
        }

        console.log('Window.onWindowConnect', {windowId, appName, chrome, innerRect, outerRect});

        this.register({appName, chrome, id: windowId, innerRect, outerRect})
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowDisconnect({windowId}) {
        this.unregister(windowId)
    }

    /**
     * Updates the geometric state of a window based on data from the Main Thread.
     * This method is called via direct delegation from the App Worker to minimize overhead.
     * @param {Object} data
     * @param {Number} data.innerHeight
     * @param {Number} data.outerHeight
     * @param {Number} data.outerWidth
     * @param {Number} data.screenLeft
     * @param {Number} data.screenTop
     * @param {String} data.windowId
     */
    onWindowPositionChange(data) {
        const
            me   = this,
            item = me.get(data.windowId),
            {chrome, innerRect, outerRect} = me.calculateGeometry(data);

        if (item) {
            item.chrome    = chrome;
            item.innerRect = innerRect;
            item.outerRect = outerRect
        } else {
            me.register({
                chrome,
                id: data.windowId,
                innerRect,
                outerRect
            })
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            className: this.className,
            windows  : this.items.map(win => ({
                id       : win.id,
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Window));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfZGFzaGJvYXJkX1NvcnRab25lX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDUztBQUNSO0FBQ0w7QUFDSTtBQUNDO0FBQ047O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFRO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFlO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsWUFBWTtBQUN6Qyw2QkFBNkIsVUFBVTtBQUN2Qyw2QkFBNkIsU0FBUztBQUN0Qyw2QkFBNkIsV0FBVztBQUN4QyxhQUFhOztBQUViO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6Qyw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEMsNkJBQTZCLFdBQVc7QUFDeEMsYUFBYTtBQUNiLFNBQVM7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QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kcmFnZ2FibGUvZGFzaGJvYXJkL1NvcnRab25lLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvRHJhZ0Nvb3JkaW5hdG9yLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvV2luZG93Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29tcG9uZW50ICAgICAgICAgIGZyb20gJy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ0Nvb3JkaW5hdG9yICAgIGZyb20gJy4uLy4uL21hbmFnZXIvRHJhZ0Nvb3JkaW5hdG9yLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29udGFpbmVyIGZyb20gJy4uL0RyYWdQcm94eUNvbnRhaW5lci5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlICAgICAgICAgIGZyb20gJy4uLy4uL3V0aWwvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgU29ydFpvbmUgICAgICAgICAgIGZyb20gJy4uL2NvbnRhaW5lci9Tb3J0Wm9uZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5kYXNoYm9hcmQuU29ydFpvbmVcbiAqIEBleHRlbmRzIE5lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lXG4gKi9cbmNsYXNzIERhc2hib2FyZFNvcnRab25lIGV4dGVuZHMgU29ydFpvbmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5kYXNoYm9hcmQuU29ydFpvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuZGFzaGJvYXJkLlNvcnRab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Rhc2hib2FyZC1zb3J0em9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkYXNoYm9hcmQtc29ydHpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIENTUyBzZWxlY3RvciBmb3IgdGhlIGRyYWcgaGFuZGxlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRyYWdIYW5kbGVTZWxlY3Rvcj0nLm5lby1kcmFnZ2FibGUnXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnSGFuZGxlU2VsZWN0b3I6ICcubmVvLWRyYWdnYWJsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZXh0cmEgQ1NTIHNlbGVjdG9ycyB0byB0aGUgZHJhZyBwcm94eSByb290LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gZHJhZ1Byb3h5RXh0cmFDbHM9W11cbiAgICAgICAgICovXG4gICAgICAgIGRyYWdQcm94eUV4dHJhQ2xzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzb3J0R3JvdXA9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydEdyb3VwOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNSZW1vdGVEcmFnZ2luZz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc1JlbW90ZURyYWdnaW5nID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICBEcmFnQ29vcmRpbmF0b3IucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHJlbW90ZSBkcmFnIGNvb3JkaW5hdGVzIGludGVyc2VjdCB3aXRoIHRoZSBzb3J0IHpvbmUuXG4gICAgICogVHJpZ2dlcnMgYW4gYXN5bmMgZmV0Y2ggb2Ygb3duZXJSZWN0IGlmIG5vdCBjdXJyZW50bHkgY2FjaGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBhY2NlcHRzUmVtb3RlRHJhZyh4LCB5KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5vd25lclJlY3QpIHtcbiAgICAgICAgICAgIGlmICghbWUuaXNGZXRjaGluZ1JlY3QpIHtcbiAgICAgICAgICAgICAgICBtZS5pc0ZldGNoaW5nUmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWUub3duZXIuZ2V0RG9tUmVjdChbbWUub3duZXIuaWRdKS50aGVuKHJlY3RzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUub3duZXJSZWN0ID0gcmVjdHNbMF07XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzRmV0Y2hpbmdSZWN0ID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geCA+PSBtZS5vd25lclJlY3QueCAmJlxuICAgICAgICAgICAgICAgeCA8PSBtZS5vd25lclJlY3QueCArIG1lLm93bmVyUmVjdC53aWR0aCAmJlxuICAgICAgICAgICAgICAgeSA+PSBtZS5vd25lclJlY3QueSAmJlxuICAgICAgICAgICAgICAgeSA8PSBtZS5vd25lclJlY3QueSArIG1lLm93bmVyUmVjdC5oZWlnaHRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFwcGx5QWJzb2x1dGVQb3NpdGlvbmluZygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1TdHlsZTtcblxuICAgICAgICBtZS5zb3J0YWJsZUl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gbWUuaXRlbVJlY3RzW2ldO1xuXG4gICAgICAgICAgICBpdGVtU3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgbWUuYWRqdXN0UHJveHlSZWN0VG9QYXJlbnQ/LihyZWN0LCBtZS5vd25lclJlY3QpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYXBwbHlBYnNvbHV0ZVBvc2l0aW9uaW5nJywge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgOiBgJHtyZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgbGVmdCAgICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgdG9wICAgICA6IGAke3JlY3QudG9wfXB4YCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgIDogYCR7cmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IE9iamVjdC5hc3NpZ24oaXRlbVN0eWxlLCB7XG4gICAgICAgICAgICAgICAgZmxleCAgICA6ICdub25lJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgIDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgOiBgJHtyZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgIG1hcmdpbiAgOiAnMHB4JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICB0b3AgICAgIDogYCR7cmVjdC50b3B9cHhgLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGEgbmV3IGxheW91dCBmb3IgdGhlIHJlbWFpbmluZyBpdGVtcyB3aGVuIG9uZSBpdGVtIGlzIGRyYWdnZWQgb3V0IG9mIHRoZSBjb250YWluZXIgKGUuZy4sIGludG8gYSBuZXcgd2luZG93KS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIGRhc2hib2FyZCBkb2Vzbid0IGxlYXZlIGEgXCJob2xlXCIgd2hlcmUgdGhlIGRyYWdnZWQgaXRlbSB3YXMuIEluc3RlYWQsIGl0OlxuICAgICAqIDEuICAqKkluZmVycyBHYXBzICYgT2Zmc2V0czoqKiBBbmFseXplcyB0aGUgY2FjaGVkIGBpdGVtUmVjdHNgIHRvIG1hdGhlbWF0aWNhbGx5IGRlcml2ZSB0aGUgY29udGFpbmVyJ3MgcGFkZGluZ1xuICAgICAqICAgICBhbmQgdGhlIGdhcHMgYmV0d2VlbiBpdGVtcywgZW5zdXJpbmcgdGhlIG5ldyBsYXlvdXQgcmVzcGVjdHMgdGhlIG9yaWdpbmFsIGRlc2lnbiB0b2tlbnMuXG4gICAgICogMi4gICoqSWRlbnRpZmllcyBSZW1haW5pbmcgSXRlbXM6KiogRmlsdGVycyBvdXQgdGhlIGRyYWdnZWQgY29tcG9uZW50IGFuZCBpdHMgcGxhY2Vob2xkZXIuXG4gICAgICogMy4gICoqRGlzdHJpYnV0ZXMgU3BhY2U6KiogQ2FsY3VsYXRlcyB0aGUgYXZhaWxhYmxlIHNwYWNlIChUb3RhbCBTaXplIC0gT2Zmc2V0cyAtIEdhcHMgLSBGaXhlZCBJdGVtcykgYW5kIGRpc3RyaWJ1dGVzXG4gICAgICogICAgIGl0IGFtb25nIGZsZXggaXRlbXMgcHJvcG9ydGlvbmFsIHRvIHRoZWlyIGZsZXggdmFsdWVzLlxuICAgICAqIDQuICAqKkdlbmVyYXRlcyBTdHlsZXM6KiogUmV0dXJucyBhIGxpc3Qgb2Ygc3R5bGUgb2JqZWN0cyAoYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGApIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJlbWFpbmluZyBpdGVtcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX0gQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBgaXRlbWAgcmVmZXJlbmNlIGFuZCB0aGUgY2FsY3VsYXRlZCBgc3R5bGVgIG9iamVjdC5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVFeHBhbmRlZExheW91dCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lclJlY3QgICAgPSBtZS5vd25lclJlY3QsXG4gICAgICAgICAgICBpc0hvcml6b250YWwgPSBtZS5zb3J0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICB0b3RhbFNpemUgICAgPSBpc0hvcml6b250YWwgPyBvd25lclJlY3Qud2lkdGggOiBvd25lclJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgaXRlbXMgICAgICAgID0gW10sXG4gICAgICAgICAgICB0b3RhbEZsZXggICAgPSAwLFxuICAgICAgICAgICAgdXNlZFNpemUgICAgID0gMCxcbiAgICAgICAgICAgIHJlY3RzICAgICAgICA9IFtdLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQgID0gMCxcbiAgICAgICAgICAgIGVuZE9mZnNldCAgICA9IDAsXG4gICAgICAgICAgICBnYXAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgdG9wT2Zmc2V0ICAgID0gMCxcbiAgICAgICAgICAgIGJvdHRvbU9mZnNldCA9IDAsXG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ICAgPSAwLFxuICAgICAgICAgICAgcmlnaHRPZmZzZXQgID0gMCxcbiAgICAgICAgICAgIHN0YXJ0WCAgICAgICA9IG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gMCA6IG93bmVyUmVjdC54LFxuICAgICAgICAgICAgc3RhcnRZICAgICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyAwIDogb3duZXJSZWN0Lnk7XG5cbiAgICAgICAgLy8gMS4gQ2FsY3VsYXRlIG9mZnNldHMgYW5kIGdhcHMgZnJvbSB0aGUgb3JpZ2luYWwgc2xvdHMgKGl0ZW1SZWN0cylcbiAgICAgICAgaWYgKG1lLml0ZW1SZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgcjAgPSBtZS5pdGVtUmVjdHNbMF0sXG4gICAgICAgICAgICAgICAgcm4gPSBtZS5pdGVtUmVjdHNbbWUuaXRlbVJlY3RzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyByMC54IDogcjAueCAtIG93bmVyUmVjdC54O1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCAgICA9IHRvdGFsU2l6ZSAtIChtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IChybi54ICsgcm4ud2lkdGgpIDogKHJuLnggLSBvd25lclJlY3QueCArIHJuLndpZHRoKSk7XG4gICAgICAgICAgICAgICAgdG9wT2Zmc2V0ICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyByMC55IDogcjAueSAtIG93bmVyUmVjdC55O1xuICAgICAgICAgICAgICAgIGJvdHRvbU9mZnNldCA9IG93bmVyUmVjdC5oZWlnaHQgLSAobWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyAocjAueSArIHIwLmhlaWdodCkgOiAocjAueSAtIG93bmVyUmVjdC55ICsgcjAuaGVpZ2h0KSk7IC8vIEFwcHJveCBmcm9tIGZpcnN0IGl0ZW1cblxuICAgICAgICAgICAgICAgIGlmIChtZS5pdGVtUmVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcjEgPSBtZS5pdGVtUmVjdHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGdhcCA9IHIxLnggLSAocjAueCArIHIwLndpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyByMC55IDogcjAueSAtIG93bmVyUmVjdC55O1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCAgID0gdG90YWxTaXplIC0gKG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gKHJuLnkgKyBybi5oZWlnaHQpIDogKHJuLnkgLSBvd25lclJlY3QueSArIHJuLmhlaWdodCkpO1xuICAgICAgICAgICAgICAgIGxlZnRPZmZzZXQgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyByMC54IDogcjAueCAtIG93bmVyUmVjdC54O1xuICAgICAgICAgICAgICAgIHJpZ2h0T2Zmc2V0ID0gb3duZXJSZWN0LndpZHRoIC0gKG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gKHIwLnggKyByMC53aWR0aCkgOiAocjAueCAtIG93bmVyUmVjdC54ICsgcjAud2lkdGgpKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5pdGVtUmVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcjEgPSBtZS5pdGVtUmVjdHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGdhcCA9IHIxLnkgLSAocjAueSArIHIwLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDIuIEZpbHRlciB2YWxpZCBpdGVtc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLml0ZW1SZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZEluZGV4ID0gbWUuaW5kZXhNYXBbaV07XG5cbiAgICAgICAgICAgIGlmIChtYXBwZWRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaXRlbSA9IG1lLm93bmVyLml0ZW1zW21hcHBlZEluZGV4XTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IG1lLmRyYWdQbGFjZWhvbGRlciB8fCBpdGVtID09PSBtZS5kcmFnQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlY3QgPSBtZS5pdGVtUmVjdHNbaV07XG5cbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe2l0ZW0sIHJlY3R9KTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uZmxleCkge1xuICAgICAgICAgICAgICAgIHRvdGFsRmxleCArPSBpdGVtLmZsZXhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBpc0hvcml6b250YWwgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdXNlZFNpemUgKz0gc2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQ2FsY3VsYXRlIGF2YWlsYWJsZSBzcGFjZVxuICAgICAgICBsZXQgdG90YWxHYXBzICAgICAgPSBNYXRoLm1heCgwLCBpdGVtcy5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgIGF2YWlsYWJsZVNwYWNlID0gTWF0aC5tYXgoMCwgdG90YWxTaXplIC0gc3RhcnRPZmZzZXQgLSBlbmRPZmZzZXQgLSAodG90YWxHYXBzICogZ2FwKSAtIHVzZWRTaXplKTtcblxuICAgICAgICAvLyA0LiBEaXN0cmlidXRlIHNwYWNlXG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gc3RhcnRPZmZzZXQ7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoe2l0ZW0sIHJlY3R9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGl0ZW1TaXplLCBzdHlsZSA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5mbGV4KSB7XG4gICAgICAgICAgICAgICAgaXRlbVNpemUgPSAoaXRlbS5mbGV4IC8gdG90YWxGbGV4KSAqIGF2YWlsYWJsZVNwYWNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1TaXplID0gaXNIb3Jpem9udGFsID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgOiBgJHtzdGFydFggKyBjdXJyZW50UG9zfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBgJHtzdGFydFkgKyB0b3BPZmZzZXR9cHhgLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke293bmVyUmVjdC5oZWlnaHQgLSB0b3BPZmZzZXQgLSBib3R0b21PZmZzZXR9cHhgLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IGAke2l0ZW1TaXplfXB4YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgIDogYCR7c3RhcnRYICsgbGVmdE9mZnNldH1weGAsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgIDogYCR7c3RhcnRZICsgY3VycmVudFBvc31weGAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7aXRlbVNpemV9cHhgLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IGAke293bmVyUmVjdC53aWR0aCAtIGxlZnRPZmZzZXQgLSByaWdodE9mZnNldH1weGBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY3RzLnB1c2goe2l0ZW0sIHN0eWxlfSk7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IGl0ZW1TaXplICsgZ2FwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWN0c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgRHJhZ0Nvb3JkaW5hdG9yLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RHJhZ1Byb3h5Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBzdXBlci5nZXREcmFnUHJveHlDb25maWcoKTtcblxuICAgICAgICBjb25maWcuY2xzID0gY29uZmlnLmNscy5maWx0ZXIoY2xzID0+ICFjbHMuaW5jbHVkZXMoJ25lby12aWV3cG9ydCcpKTtcbiAgICAgICAgTmVvQXJyYXkuYWRkKGNvbmZpZy5jbHMsIHRoaXMuZHJhZ1Byb3h5RXh0cmFDbHMpO1xuXG4gICAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZHJhZyBlbmQgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaXNSZW1vdGVEcmFnZ2luZykge1xuICAgICAgICAgICAgLy8gU2lnbmFsIENvb3JkaW5hdG9yIGFib3V0IGVuZCBvZiBkcmFnXG4gICAgICAgICAgICBEcmFnQ29vcmRpbmF0b3Iub25EcmFnRW5kKHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbSAgIDogbWUuZHJhZ0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzb3VyY2VTb3J0Wm9uZTogbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5vbkRyYWdFbmQoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBkcmFnIG1vdmUgZXZlbnQuIFRoaXMgaXMgdGhlIGNvcmUgbG9naWMgbG9vcCBmb3IgdGhlIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogUmVzcG9uc2liaWxpdGllczpcbiAgICAgKiAxLiAgKipXaW5kb3cgRHJhZyBSZS1lbnRyeToqKiBDaGVja3MgaWYgYSB3aW5kb3cgZHJhZyBoYXMgcmUtZW50ZXJlZCB0aGUgb3JpZ2luYWwgY29udGFpbmVyIGJvdW5kYXJpZXMuXG4gICAgICogICAgIElmIHNvLCBpdCByZXN0b3JlcyB0aGUgb3JpZ2luYWwgbGF5b3V0IHNuYXBzaG90IChgaXRlbVJlY3RzYCkgYW5kIHNob3dzIHRoZSBwbGFjZWhvbGRlciwgZWZmZWN0aXZlbHlcbiAgICAgKiAgICAgXCJzbmFwcGluZ1wiIHRoZSBkYXNoYm9hcmQgYmFjayB0byBpdHMgc29ydGFibGUgc3RhdGUuXG4gICAgICogMi4gICoqV2luZG93IERyYWcgRXhpdDoqKiBEZXRlY3RzIGlmIHRoZSBkcmFnIHByb3h5IGhhcyBsZWZ0IHRoZSBjb250YWluZXIgYm91bmRhcmllcyAoaWYgYGVuYWJsZVByb3h5VG9Qb3B1cGAgaXMgdHJ1ZSlcbiAgICAgKiAgICAgYW5kIHRyaWdnZXJzIHRoZSBgZHJhZ0JvdW5kYXJ5RXhpdGAgZXZlbnQgdG8gcG90ZW50aWFsbHkgc3RhcnQgYSB3aW5kb3cgZHJhZy5cbiAgICAgKiAzLiAgKipTdGFuZGFyZCBTb3J0aW5nOioqIElmIG5vdCBpbiB3aW5kb3ctZHJhZyBtb2RlLCBpdCBjYWxjdWxhdGVzIHRoZSBkcmFnIGRlbHRhIGFuZCBzd2FwcyBpdGVtcyAoYHN3aXRjaEl0ZW1zYClcbiAgICAgKiAgICAgaWYgdGhlIHRocmVzaG9sZCBpcyBjcm9zc2VkLCB1cGRhdGluZyB0aGUgYGN1cnJlbnRJbmRleGAuXG4gICAgICogNC4gICoqQXV0by1TY3JvbGxpbmc6KiogTWFuYWdlcyBhdXRvLXNjcm9sbGluZyB3aGVuIGRyYWdnaW5nIG5lYXIgdGhlIGVkZ2VzIG9mIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZHJhZyBtb3ZlIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gVGhlIG1ldGhvZCBjYW4gdHJpZ2dlciBiZWZvcmUgd2UgZ290IHRoZSBjbGllbnQgcmVjdHMgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgICAgICAgaWYgKCFtZS5pdGVtUmVjdHMgfHwgIW1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCB8fCBtZS5pc1Njcm9sbGluZykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBzdXBlci5vbkRyYWdNb3ZlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvblJlbW90ZURyYWdMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzUmVtb3RlRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIG1lLmlzUmVtb3RlRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGF3YWl0IG1lLm9uRHJhZ0VuZCh7fSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25SZW1vdGVEcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc1JlbW90ZURyYWdnaW5nKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS5zdGFydFJlbW90ZURyYWcoZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlbGVnYXRlIHRvIHN0YW5kYXJkIG9uRHJhZ01vdmUgbG9naWMsIHdoaWNoIHVwZGF0ZXMgdGhlIHByb3h5XG4gICAgICAgIG1lLm9uRHJhZ01vdmUoe1xuICAgICAgICAgICAgY2xpZW50WCAgOiBkYXRhLmxvY2FsWCxcbiAgICAgICAgICAgIGNsaWVudFkgIDogZGF0YS5sb2NhbFksXG4gICAgICAgICAgICBwcm94eVJlY3Q6IGRhdGEucHJveHlSZWN0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdNb3ZlKHtcbiAgICAgICAgICAgIGNsaWVudFg6IGRhdGEubG9jYWxYLFxuICAgICAgICAgICAgY2xpZW50WTogZGF0YS5sb2NhbFlcbiAgICAgICAgfSwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZHJhZ2dlZEl0ZW1cbiAgICAgKi9cbiAgICBhc3luYyBvblJlbW90ZURyb3AoZHJhZ2dlZEl0ZW0pIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGluZGV4ID0gbWUuY3VycmVudEluZGV4O1xuXG4gICAgICAgIC8vIEVuc3VyZSB3ZSBhcmUgaW4gcmVtb3RlIGRyYWcgbW9kZVxuICAgICAgICBpZiAobWUuaXNSZW1vdGVEcmFnZ2luZykge1xuICAgICAgICAgICAgLy8gQ2xlYW51cCBwbGFjZWhvbGRlciBidXQga2VlcCBsYXlvdXQgcmVhZHlcbiAgICAgICAgICAgIGF3YWl0IG1lLm9uRHJhZ0VuZCh7fSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBwYXJlbnQgKGlmIG5vdCBhbHJlYWR5IGRldGFjaGVkKVxuICAgICAgICAgICAgY29uc3QgcGFyZW50SWQgPSBkcmFnZ2VkSXRlbS5wYXJlbnRJZDtcbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCAmJiBwYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCk/LnJlbW92ZShkcmFnZ2VkSXRlbSwgZmFsc2UpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIG5ldyBvd25lclxuICAgICAgICAgICAgbWUub3duZXIuaW5zZXJ0KGluZGV4LCBkcmFnZ2VkSXRlbSk7XG5cbiAgICAgICAgICAgIG1lLmlzUmVtb3RlRHJhZ2dpbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRyYWdnZWRJdGVtXG4gICAgICovXG4gICAgb25SZW1vdGVEcm9wT3V0KGRyYWdnZWRJdGVtKSB7XG4gICAgICAgIC8vIENhbGxlZCBvbiB0aGUgc291cmNlIHNvcnQgem9uZSB3aGVuIGEgZHJvcCBvY2N1cnJlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2xlYW51cCBhbnkgZGV0YWNoZWQgc3RhdGUgdHJhY2tpbmcuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm93bmVyLmRldGFjaGVkSXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1lLm93bmVyLmRldGFjaGVkSXRlbXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLndpZGdldCA9PT0gZHJhZ2dlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWUub3duZXIuZGV0YWNoZWRJdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHdpbmRvdyBpcyBhbHJlYWR5IGNsb3NlZCBieSBzdXNwZW5kV2luZG93RHJhZywgc28gd2UganVzdCBjbGVhbiB1cCB0aGUgbWFwLlxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnNlY3Rpb25SYXRpb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25XaW5kb3dEcmFnQ29udGludWUoaW50ZXJzZWN0aW9uUmF0aW8sIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBTaWduYWwgQ29vcmRpbmF0b3JcbiAgICAgICAgRHJhZ0Nvb3JkaW5hdG9yLm9uRHJhZ01vdmUoe1xuICAgICAgICAgICAgZHJhZ2dlZEl0ZW0gICA6IG1lLmRyYWdDb21wb25lbnQsXG4gICAgICAgICAgICBvZmZzZXRYICAgICAgIDogbWUub2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFkgICAgICAgOiBtZS5vZmZzZXRZLFxuICAgICAgICAgICAgcHJveHlSZWN0ICAgICA6IGRhdGEucHJveHlSZWN0LFxuICAgICAgICAgICAgc2NyZWVuWCAgICAgICA6IGRhdGEuc2NyZWVuWCxcbiAgICAgICAgICAgIHNjcmVlblkgICAgICAgOiBkYXRhLnNjcmVlblksXG4gICAgICAgICAgICBzb3VyY2VTb3J0Wm9uZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2lkZ2V0TmFtZVxuICAgICAqIEBwYXJhbSB7RE9NUmVjdH0gcHJveHlSZWN0XG4gICAgICovXG4gICAgcmVzdW1lV2luZG93RHJhZyh3aWRnZXROYW1lLCBwcm94eVJlY3QpIHtcbiAgICAgICAgdGhpcy5vd25lci5yZXN1bWVXaW5kb3dEcmFnKHdpZGdldE5hbWUsIHByb3h5UmVjdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZHJhZ2dlZEl0ZW1cbiAgICAgKi9cbiAgICBhc3luYyBzZXR1cERyYWdTdGF0ZShkcmFnZ2VkSXRlbSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FkanVzdEl0ZW1SZWN0c1RvUGFyZW50LCBvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZXMgICAgICAgICAgICAgICAgICAgICAgID0gbWUuaXRlbVN0eWxlcyA9IFtdLFxuICAgICAgICAgICAge2xheW91dH0gICAgICAgICAgICAgICAgICAgICAgICAgPSBvd25lcixcbiAgICAgICAgICAgIG93bmVyU3R5bGUgICAgICAgICAgICAgICAgICAgICAgID0gb3duZXIuc3R5bGUgfHwge30sXG4gICAgICAgICAgICBpbmRleCwgaW5kZXhNYXAsIGl0ZW1SZWN0cywgc29ydGFibGVJdGVtcztcblxuICAgICAgICBzb3J0YWJsZUl0ZW1zID0gb3duZXIuaXRlbXMuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0uaXNEZXN0cm95ZWQpO1xuICAgICAgICBpbmRleCAgICAgICAgID0gc29ydGFibGVJdGVtcy5pbmRleE9mKGRyYWdnZWRJdGVtKTtcblxuICAgICAgICBpbmRleE1hcCA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCAgICAgICAgICAgOiBpbmRleCxcbiAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgICAgICAgICAgOiBWRG9tVXRpbC5maW5kKG93bmVyLnZkb20sIGRyYWdnZWRJdGVtLmlkKS52ZG9tLFxuICAgICAgICAgICAgZHJhZ1Byb3h5Q29uZmlnICAgICAgICA6IG1lLmdldERyYWdQcm94eUNvbmZpZygpLFxuICAgICAgICAgICAgaW5kZXhNYXAsXG4gICAgICAgICAgICBvd25lclN0eWxlICAgICAgICAgICAgIDoge2hlaWdodDogb3duZXJTdHlsZS5oZWlnaHQsIG1pbldpZHRoOiBvd25lclN0eWxlLm1pbldpZHRoLCB3aWR0aDogb3duZXJTdHlsZS53aWR0aH0sXG4gICAgICAgICAgICByZXZlcnNlZExheW91dERpcmVjdGlvbjogbGF5b3V0LmRpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyB8fCBsYXlvdXQuZGlyZWN0aW9uID09PSAncm93LXJldmVyc2UnLFxuICAgICAgICAgICAgc29ydGFibGVJdGVtcyxcbiAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gICAgICAgICAgOiBsYXlvdXQuZGlyZWN0aW9uPy5pbmNsdWRlcygnY29sdW1uJykgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgc3RhcnRJbmRleCAgICAgICAgICAgICA6IGluZGV4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdDb21wb25lbnQgPSBkcmFnZ2VkSXRlbTtcblxuICAgICAgICBzb3J0YWJsZUl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGluZGV4TWFwW2ldID0gb3duZXIuaXRlbXMuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgaXRlbVN0eWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW0uaGVpZ2h0ID8gYCR7aXRlbS5oZWlnaHR9cHhgIDogIGl0ZW0uc3R5bGU/LmhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IGl0ZW0ud2lkdGggID8gYCR7aXRlbS53aWR0aH1weGAgIDogIGl0ZW0uc3R5bGU/LndpZHRoXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtUmVjdHMgPSBhd2FpdCBvd25lci5nZXREb21SZWN0KFtvd25lci5pZF0uY29uY2F0KHNvcnRhYmxlSXRlbXMubWFwKGUgPT4gZS5pZCkpKTtcblxuICAgICAgICBpdGVtUmVjdHMuZm9yRWFjaChyZWN0ID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpdGVtUmVjdCcsIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgIDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgOiBgJHtyZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgOiBgJHtyZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IGAke3JlY3Qud2lkdGh9cHhgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUub3duZXJSZWN0ID0gaXRlbVJlY3RzLnNoaWZ0KCk7XG4gICAgICAgIG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCA9IG1lLm93bmVyUmVjdDtcblxuICAgICAgICBvd25lci5zdHlsZSA9IHtcbiAgICAgICAgICAgIC4uLm93bmVyU3R5bGUsXG4gICAgICAgICAgICBoZWlnaHQgIDogYCR7bWUub3duZXJSZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICBtaW5XaWR0aDogYCR7bWUub3duZXJSZWN0LndpZHRofXB4YCxcbiAgICAgICAgICAgIHdpZHRoICAgOiBgJHttZS5vd25lclJlY3Qud2lkdGh9cHhgXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coJ2FkanVzdEl0ZW1SZWN0c1RvUGFyZW50JywgYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQpO1xuXG4gICAgICAgIGFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ICYmIGl0ZW1SZWN0cy5mb3JFYWNoKHJlY3QgPT4ge1xuICAgICAgICAgICAgcmVjdC54IC09IG1lLm93bmVyUmVjdC54O1xuICAgICAgICAgICAgcmVjdC55IC09IG1lLm93bmVyUmVjdC55XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLml0ZW1SZWN0cyA9IGl0ZW1SZWN0c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRSZW1vdGVEcmFnKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gICAgID0gbWUsXG4gICAgICAgICAgICB7cHJveHlSZWN0fSA9IGRhdGEsXG4gICAgICAgICAgICBkcmFnZ2VkSXRlbSA9IGRhdGEuZHJhZ2dlZEl0ZW0sXG4gICAgICAgICAgICBjb25maWc7XG5cbiAgICAgICAgbWUuaXNSZW1vdGVEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLy8gTW9jayB0aGUgZHJhZyBlbGVtZW50IHJlY3QgZm9yIERyYWdab25lIGxvZ2ljIGlmIG5lZWRlZFxuICAgICAgICBtZS5kcmFnRWxlbWVudFJlY3QgPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IHByb3h5UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aCA6IHByb3h5UmVjdC53aWR0aCxcbiAgICAgICAgICAgIHggICAgIDogZGF0YS5sb2NhbFgsXG4gICAgICAgICAgICB5ICAgICA6IGRhdGEubG9jYWxZLFxuICAgICAgICAgICAgbGVmdCAgOiBkYXRhLmxvY2FsWCxcbiAgICAgICAgICAgIHRvcCAgIDogZGF0YS5sb2NhbFlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVcGRhdGUgZHJhZ2dlZCBpdGVtIHRvIHRhcmdldCBhcHAgY29udGV4dFxuICAgICAgICBkcmFnZ2VkSXRlbS5hcHBOYW1lID0gbWUuYXBwTmFtZTtcblxuICAgICAgICBjb25zb2xlLmxvZygnc3RhcnRSZW1vdGVEcmFnJywgZHJhZ2dlZEl0ZW0uaWQsIGRyYWdnZWRJdGVtLndpbmRvd0lkLCBkcmFnZ2VkSXRlbS5wYXJlbnRJZCwgZHJhZ2dlZEl0ZW0ucGFyZW50Q29tcG9uZW50KTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgcGFyZW50IGNoYWluIHRvIHByZXZlbnQgY2lyY3VsYXIgY29uZmlnIGxvb2t1cHMgZHVyaW5nIGhhbmRvdmVyXG4gICAgICAgIGRyYWdnZWRJdGVtLnBhcmVudElkICAgICAgICA9IG51bGw7XG4gICAgICAgIGRyYWdnZWRJdGVtLnBhcmVudENvbXBvbmVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gU2luY2UgdGhlIGNvbXBvbmVudCB3YXMgbW91bnRlZCBpbiBhIGRpZmZlcmVudCB3aW5kb3csIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHN0YXRlXG4gICAgICAgIGRyYWdnZWRJdGVtLm1vdW50ZWQgICAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dlZEl0ZW0udm5vZGUgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIGRyYWdnZWRJdGVtLnZub2RlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICBjb25zb2xlLmxvZygncGFyZW50IGNsZWFyZWQ6JywgZHJhZ2dlZEl0ZW0ucGFyZW50SWQsIGRyYWdnZWRJdGVtLnBhcmVudENvbXBvbmVudCk7XG5cbiAgICAgICAgLy8gMS4gR2V0IE93bmVyIFJlY3QgKG5lZWRlZCBmb3IgcHJveHkgcG9zaXRpb25pbmcpXG4gICAgICAgIGxldCByZWN0cyA9IGF3YWl0IG93bmVyLmdldERvbVJlY3QoW293bmVyLmlkXSk7XG4gICAgICAgIG1lLm93bmVyUmVjdCA9IHJlY3RzWzBdO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdvd25lclJlY3QnLCBtZS5vd25lclJlY3QpO1xuXG4gICAgICAgIC8vIEFzc2lnbiB0aGUgZHJhZyBvZmZzZXRzIHRvIHRoZSBpbnN0YW5jZSwgc28gdGhhdCB0aGUgRHJhZ1pvbmUgb25EcmFnTW92ZSBsb2dpYyB3b3Jrc1xuICAgICAgICBtZS5vZmZzZXRYID0gZGF0YS5vZmZzZXRYO1xuICAgICAgICBtZS5vZmZzZXRZID0gZGF0YS5vZmZzZXRZO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdzdGFydFJlbW90ZURyYWc6IG93bmVyUmVjdCcsIG1lLm93bmVyUmVjdCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzdGFydFJlbW90ZURyYWc6IGxvY2FsIGNvb3JkcycsIGRhdGEubG9jYWxYLCBkYXRhLmxvY2FsWSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzdGFydFJlbW90ZURyYWc6IGNhbGN1bGF0ZWQgY29vcmRzJywgZGF0YS5sb2NhbFggLSBtZS5vZmZzZXRYLCBkYXRhLmxvY2FsWSAtIG1lLm9mZnNldFkpO1xuXG4gICAgICAgIC8vIDIuIENyZWF0ZSBhIGxvY2FsIERyYWdQcm94eSBtYW51YWxseSAodXNpbmcgRHJhZ1Byb3h5Q29udGFpbmVyIHRvIGhvbGQgdGhlIGxpdmUgd2lkZ2V0KVxuICAgICAgICAvLyBXZSB1c2UgRHJhZ1Byb3h5Q29udGFpbmVyIHRvIGVuc3VyZSB0aGUgd2lkZ2V0IHJlbWFpbnMgYWN0aXZlL2Nvbm5lY3RlZC5cbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgIDogRHJhZ1Byb3h5Q29udGFpbmVyLFxuICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICA6IFsnbmVvLWRyYWdwcm94eScsIC4uLm1lLm93bmVyLmNsc10sXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgICAgOiBbZHJhZ2dlZEl0ZW1dLFxuICAgICAgICAgICAgbW92ZUluTWFpblRocmVhZDogZmFsc2UsXG4gICAgICAgICAgICB3aW5kb3dJZCAgICAgICAgOiBtZS53aW5kb3dJZCxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHtkYXRhLmxvY2FsWCAtIG1lLm9mZnNldFh9cHhgLFxuICAgICAgICAgICAgICAgIHRvcCA6IGAke2RhdGEubG9jYWxZIC0gbWUub2Zmc2V0WX1weGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbG9jYWwgZHJhZyBwcm94eScsIGNvbmZpZyk7XG5cbiAgICAgICAgbWUuZHJhZ1Byb3h5ID0gTmVvLmNyZWF0ZShjb25maWcpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGVkIGxvY2FsIGRyYWcgcHJveHknLCBtZS5kcmFnUHJveHkpO1xuXG4gICAgICAgIC8vIDMuIENyZWF0ZSBQbGFjZWhvbGRlclxuICAgICAgICBtZS5kcmFnUGxhY2Vob2xkZXIgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgIG1vZHVsZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgZmxleCAgOiAnbm9uZScsXG4gICAgICAgICAgICBzdHlsZSA6IHtoZWlnaHQ6IGAke3Byb3h5UmVjdC5oZWlnaHR9cHhgLCB2aXNpYmlsaXR5OiAnaGlkZGVuJ31cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3duZXIuYWRkKG1lLmRyYWdQbGFjZWhvbGRlcik7XG5cbiAgICAgICAgLy8gNC4gU2V0dXAgU29ydCBTdGF0ZVxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUwKTtcbiAgICAgICAgYXdhaXQgbWUuc2V0dXBEcmFnU3RhdGUobWUuZHJhZ1BsYWNlaG9sZGVyKTtcblxuICAgICAgICAvLyBVcGRhdGUgcHJveHkgc2l6ZSB0byBtYXRjaCB0aGUgbWVhc3VyZWQgcGxhY2Vob2xkZXJcbiAgICAgICAgbGV0IHBsYWNlaG9sZGVySW5kZXggPSBtZS5zb3J0YWJsZUl0ZW1zLmluZGV4T2YobWUuZHJhZ1BsYWNlaG9sZGVyKTtcblxuICAgICAgICBpZiAocGxhY2Vob2xkZXJJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IG1lLml0ZW1SZWN0c1twbGFjZWhvbGRlckluZGV4XTtcbiAgICAgICAgICAgIG1lLmRyYWdQcm94eS53aWR0aCAgPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgbWUuZHJhZ1Byb3h5LmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCg1MCk7XG4gICAgICAgIC8vIDUuIEFwcGx5IEFic29sdXRlIFBvc2l0aW9uaW5nXG4gICAgICAgIG1lLmFwcGx5QWJzb2x1dGVQb3NpdGlvbmluZygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgZHJhZyBtb3ZlIGV2ZW50LiBUaGlzIGlzIHRoZSBjb3JlIGxvZ2ljIGxvb3AgZm9yIHRoZSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFJlc3BvbnNpYmlsaXRpZXM6XG4gICAgICogMS4gICoqV2luZG93IERyYWcgUmUtZW50cnk6KiogQ2hlY2tzIGlmIGEgd2luZG93IGRyYWcgaGFzIHJlLWVudGVyZWQgdGhlIG9yaWdpbmFsIGNvbnRhaW5lciBib3VuZGFyaWVzLlxuICAgICAqICAgICBJZiBzbywgaXQgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIGxheW91dCBzbmFwc2hvdCAoYGl0ZW1SZWN0c2ApIGFuZCBzaG93cyB0aGUgcGxhY2Vob2xkZXIsIGVmZmVjdGl2ZWx5XG4gICAgICogICAgIFwic25hcHBpbmdcIiB0aGUgZGFzaGJvYXJkIGJhY2sgdG8gaXRzIHNvcnRhYmxlIHN0YXRlLlxuICAgICAqIDIuICAqKldpbmRvdyBEcmFnIEV4aXQ6KiogRGV0ZWN0cyBpZiB0aGUgZHJhZyBwcm94eSBoYXMgbGVmdCB0aGUgY29udGFpbmVyIGJvdW5kYXJpZXMgKGlmIGBlbmFibGVQcm94eVRvUG9wdXBgIGlzIHRydWUpXG4gICAgICogICAgIGFuZCB0cmlnZ2VycyB0aGUgYGRyYWdCb3VuZGFyeUV4aXRgIGV2ZW50IHRvIHBvdGVudGlhbGx5IHN0YXJ0IGEgd2luZG93IGRyYWcuXG4gICAgICogMy4gICoqU3RhbmRhcmQgU29ydGluZzoqKiBJZiBub3QgaW4gd2luZG93LWRyYWcgbW9kZSwgaXQgY2FsY3VsYXRlcyB0aGUgZHJhZyBkZWx0YSBhbmQgc3dhcHMgaXRlbXMgKGBzd2l0Y2hJdGVtc2ApXG4gICAgICogICAgIGlmIHRoZSB0aHJlc2hvbGQgaXMgY3Jvc3NlZCwgdXBkYXRpbmcgdGhlIGBjdXJyZW50SW5kZXhgLlxuICAgICAqIDQuICAqKkF1dG8tU2Nyb2xsaW5nOioqIE1hbmFnZXMgYXV0by1zY3JvbGxpbmcgd2hlbiBkcmFnZ2luZyBuZWFyIHRoZSBlZGdlcyBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZHJhZyBtb3ZlIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgc3RhcnRXaW5kb3dEcmFnKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHtwb3B1cEhlaWdodCwgcG9wdXBXaWR0aCwgd2luZG93TmFtZX0gPSBkYXRhO1xuXG4gICAgICAgIC8vIEtlZXAgdGhlIHByb3h5IGFjdGl2ZSB0byBjYXB0dXJlIG1vdXNlIGV2ZW50cywgYnV0IG1ha2UgaXQgaW52aXNpYmxlXG4gICAgICAgIG1lLmRyYWdQcm94eS5zdHlsZSA9IHtvcGFjaXR5OiAwfTtcbiAgICAgICAgbWUuaXNXaW5kb3dEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgbWUuZHJhZ1BsYWNlaG9sZGVyLndyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZS5kcmFnUGxhY2Vob2xkZXIud3JhcHBlclN0eWxlLFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBleHBhbmRlZCBsYXlvdXRcbiAgICAgICAgbGV0IGV4cGFuZGVkTGF5b3V0ID0gbWUuY2FsY3VsYXRlRXhwYW5kZWRMYXlvdXQoKTtcbiAgICAgICAgZXhwYW5kZWRMYXlvdXQuZm9yRWFjaCgoe2l0ZW0sIHN0eWxlfSkgPT4ge1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyU3R5bGUgPSB7Li4uaXRlbS53cmFwcGVyU3R5bGUsIC4uLnN0eWxlfVxuICAgICAgICB9KTtcblxuICAgICAgICBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5zdGFydFdpbmRvd0RyYWcoe1xuICAgICAgICAgICAgcG9wdXBIZWlnaHQsXG4gICAgICAgICAgICBwb3B1cE5hbWU6IHdpbmRvd05hbWUsXG4gICAgICAgICAgICBwb3B1cFdpZHRoLFxuICAgICAgICAgICAgd2luZG93SWQgOiBtZS53aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aWRnZXROYW1lXG4gICAgICovXG4gICAgc3VzcGVuZFdpbmRvd0RyYWcod2lkZ2V0TmFtZSkge1xuICAgICAgICB0aGlzLm93bmVyLnN1c3BlbmRXaW5kb3dEcmFnKHdpZGdldE5hbWUpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEYXNoYm9hcmRTb3J0Wm9uZSk7XG4iLCJpbXBvcnQgTWFuYWdlciAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuLi91dGlsL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IFdpbmRvdyAgICBmcm9tICcuL1dpbmRvdy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5EcmFnQ29vcmRpbmF0b3JcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgRHJhZ0Nvb3JkaW5hdG9yIGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5EcmFnQ29vcmRpbmF0b3InXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLkRyYWdDb29yZGluYXRvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtNYXB9IHNvcnRab25lcz1uZXcgTWFwKClcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmVzOiBuZXcgTWFwKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZXxudWxsfSBhY3RpdmVUYXJnZXRab25lPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWN0aXZlVGFyZ2V0Wm9uZSA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmV9IHNvdXJjZVNvcnRab25lXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRyYWdnZWRJdGVtXG4gICAgICogQHBhcmFtIHtET01SZWN0fSBwcm94eVJlY3RcbiAgICAgKi9cbiAgICBoYW5kbGVWb2lkKHNvdXJjZVNvcnRab25lLCBkcmFnZ2VkSXRlbSwgcHJveHlSZWN0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmFjdGl2ZVRhcmdldFpvbmUpIHtcbiAgICAgICAgICAgIG1lLmFjdGl2ZVRhcmdldFpvbmUub25SZW1vdGVEcmFnTGVhdmUoKTtcbiAgICAgICAgICAgIG1lLmFjdGl2ZVRhcmdldFpvbmUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBSZXN1bWUgc291cmNlIGRyYWcgKHJlLW9wZW4gcG9wdXApXG4gICAgICAgICAgICBzb3VyY2VTb3J0Wm9uZS5yZXN1bWVXaW5kb3dEcmFnKGRyYWdnZWRJdGVtLnJlZmVyZW5jZSB8fCBkcmFnZ2VkSXRlbS5pZCwgcHJveHlSZWN0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5kcmFnZ2VkSXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm9mZnNldFhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vZmZzZXRZXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyZWVuWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNjcmVlbllcbiAgICAgKiBAcGFyYW0ge05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lfSBkYXRhLnNvdXJjZVNvcnRab25lXG4gICAgICovXG4gICAgb25EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZHJhZ2dlZEl0ZW0sIG9mZnNldFgsIG9mZnNldFksIHByb3h5UmVjdCwgc2NyZWVuWCwgc2NyZWVuWSwgc291cmNlU29ydFpvbmV9ID0gZGF0YSxcbiAgICAgICAgICAgIHtzb3J0R3JvdXB9ICAgID0gc291cmNlU29ydFpvbmUsXG4gICAgICAgICAgICB0YXJnZXRXaW5kb3dJZCA9IFdpbmRvdy5nZXRXaW5kb3dBdChzY3JlZW5YLCBzY3JlZW5ZKSxcbiAgICAgICAgICAgIHRhcmdldFNvcnRab25lO1xuXG4gICAgICAgIGlmICh0YXJnZXRXaW5kb3dJZCAmJiB0YXJnZXRXaW5kb3dJZCAhPT0gc291cmNlU29ydFpvbmUud2luZG93SWQpIHtcbiAgICAgICAgICAgIHRhcmdldFNvcnRab25lID0gbWUuc29ydFpvbmVzLmdldChzb3J0R3JvdXApPy5nZXQodGFyZ2V0V2luZG93SWQpO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0U29ydFpvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0V2luZG93ID0gV2luZG93LmdldCh0YXJnZXRXaW5kb3dJZCksXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsWCAgICAgICA9IHNjcmVlblggLSB0YXJnZXRXaW5kb3cuaW5uZXJSZWN0LngsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsWSAgICAgICA9IHNjcmVlblkgLSB0YXJnZXRXaW5kb3cuaW5uZXJSZWN0LnksXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFByb3h5UmVjdCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFggLSBvZmZzZXRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxZIC0gb2Zmc2V0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjdC5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTb3J0Wm9uZS5hY2NlcHRzUmVtb3RlRHJhZyhsb2NhbFgsIGxvY2FsWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0RyYWdDb29yZGluYXRvciB0YXJnZXQgZm91bmQnLCB7dGFyZ2V0V2luZG93SWQsIGxvY2FsWCwgbG9jYWxZfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW50ZXJpbmcgYSBuZXcgdGFyZ2V0IHpvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmFjdGl2ZVRhcmdldFpvbmUgIT09IHRhcmdldFNvcnRab25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWF2aW5nIHByZXZpb3VzIHRhcmdldCAoaWYgYW55KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuYWN0aXZlVGFyZ2V0Wm9uZT8ub25SZW1vdGVEcmFnTGVhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VzcGVuZCBzb3VyY2UgZHJhZyAoY2xvc2UgcG9wdXAsIGV0YylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBvbmNlIHdoZW4gbGVhdmluZyB0aGUgdm9pZC9zb3VyY2UgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZS5hY3RpdmVUYXJnZXRab25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlU29ydFpvbmUuc3VzcGVuZFdpbmRvd0RyYWcoZHJhZ2dlZEl0ZW0ucmVmZXJlbmNlIHx8IGRyYWdnZWRJdGVtLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5hY3RpdmVUYXJnZXRab25lID0gdGFyZ2V0U29ydFpvbmVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNvcnRab25lLm9uUmVtb3RlRHJhZ01vdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFksXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjdDogdGFyZ2V0UHJveHlSZWN0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIHZvaWQgb3IgYmFjayBpbiBzb3VyY2Ugd2luZG93XG4gICAgICAgIG1lLmhhbmRsZVZvaWQoc291cmNlU29ydFpvbmUsIGRyYWdnZWRJdGVtLCBwcm94eVJlY3QpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lfSBkYXRhLnNvdXJjZVNvcnRab25lXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuYWN0aXZlVGFyZ2V0Wm9uZSkge1xuICAgICAgICAgICAgLy8gRHJvcCBvbiB0YXJnZXRcbiAgICAgICAgICAgIG1lLmFjdGl2ZVRhcmdldFpvbmUub25SZW1vdGVEcm9wKGRhdGEuZHJhZ2dlZEl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBOb3RpZnkgc291cmNlIHRvIGZpbmFsaXplIGNsZWFudXBcbiAgICAgICAgICAgIGRhdGEuc291cmNlU29ydFpvbmUub25SZW1vdGVEcm9wT3V0KGRhdGEuZHJhZ2dlZEl0ZW0pO1xuXG4gICAgICAgICAgICBtZS5hY3RpdmVUYXJnZXRab25lID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRHJhZyBlbmRlZCBpbiB2b2lkIG9yIHNvdXJjZSB3aW5kb3cgKGhhbmRsZWQgbG9jYWxseSBieSBzb3VyY2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lfSBzb3J0Wm9uZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyKHNvcnRab25lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3NvcnRHcm91cCwgd2luZG93SWR9ID0gc29ydFpvbmU7XG5cbiAgICAgICAgaWYgKHNvcnRHcm91cCkge1xuICAgICAgICAgICAgaWYgKCFtZS5zb3J0Wm9uZXMuaGFzKHNvcnRHcm91cCkpIHtcbiAgICAgICAgICAgICAgICBtZS5zb3J0Wm9uZXMuc2V0KHNvcnRHcm91cCwgbmV3IE1hcCgpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5zb3J0Wm9uZXMuZ2V0KHNvcnRHcm91cCkuc2V0KHdpbmRvd0lkLCBzb3J0Wm9uZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmV9IHNvcnRab25lXG4gICAgICovXG4gICAgdW5yZWdpc3Rlcihzb3J0Wm9uZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzb3J0R3JvdXAsIHdpbmRvd0lkfSA9IHNvcnRab25lO1xuXG4gICAgICAgIGlmIChzb3J0R3JvdXAgJiYgbWUuc29ydFpvbmVzLmhhcyhzb3J0R3JvdXApKSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSBtZS5zb3J0Wm9uZXMuZ2V0KHNvcnRHcm91cCk7XG4gICAgICAgICAgICBncm91cC5kZWxldGUod2luZG93SWQpO1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lcy5kZWxldGUoc29ydEdyb3VwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSAgICAgICA6IG1lLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldFpvbmU6IG1lLmFjdGl2ZVRhcmdldFpvbmUgPyB7XG4gICAgICAgICAgICAgICAgaWQgICAgICAgOiBtZS5hY3RpdmVUYXJnZXRab25lLmlkLFxuICAgICAgICAgICAgICAgIHNvcnRHcm91cDogbWUuYWN0aXZlVGFyZ2V0Wm9uZS5zb3J0R3JvdXAsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiBtZS5hY3RpdmVUYXJnZXRab25lLndpbmRvd0lkXG4gICAgICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgICAgIHNvcnRab25lczogQXJyYXkuZnJvbShtZS5zb3J0Wm9uZXMuZW50cmllcygpKS5tYXAoKFtncm91cCwgbWFwXSkgPT4gKHtcbiAgICAgICAgICAgICAgICBncm91cCxcbiAgICAgICAgICAgICAgICB3aW5kb3dzOiBBcnJheS5mcm9tKG1hcC5rZXlzKCkpXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ0Nvb3JkaW5hdG9yKTtcbiIsImltcG9ydCBNYW5hZ2VyICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4uL3V0aWwvUmVjdGFuZ2xlLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIFwiR29kIFZpZXdcIiBmb3IgdGhlIG11bHRpLXdpbmRvdyBhcHBsaWNhdGlvbiB3b3Jrc3BhY2UuXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBtYW5hZ2VyIG1haW50YWlucyBhIHJlYWwtdGltZSBnZW9tZXRyaWMgbWFwIG9mIGFsbCBjb25uZWN0ZWQgYnJvd3NlciB3aW5kb3dzIGluIHRoZSBBcHAgV29ya2VyLlxuICogSXQgaXMgdGhlIGNlbnRyYWwgYXV0aG9yaXR5IGZvciBzcGF0aWFsIGF3YXJlbmVzcywgZW5hYmxpbmcgZmVhdHVyZXMgbGlrZSB0aGUgXCJJbmZpbml0ZSBDYW52YXNcIiB3aGVyZVxuICogaW50ZXJhY3Rpb25zIChsaWtlIERyYWcgJiBEcm9wKSBjYW4gc3BhbiBhY3Jvc3MgbXVsdGlwbGUgT1MtbGV2ZWwgd2luZG93cy5cbiAqXG4gKiBJdCByZWNlaXZlcyBoaWdoLWZyZXF1ZW5jeSBwb3NpdGlvbiB1cGRhdGVzIGZyb20gdGhlIE1haW4gVGhyZWFkICh2aWEgYE5lby5tYWluLmFkZG9uLldpbmRvd1Bvc2l0aW9uYClcbiAqIGFuZCBwcm92aWRlcyBpbnRlcnNlY3Rpb24gdGVzdGluZyBBUElzIHRvIGRldGVybWluZSB3aGljaCB3aW5kb3cgaXMgdW5kZXIgYSBnaXZlbiBzY3JlZW4gY29vcmRpbmF0ZS5cbiAqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuV2luZG93XG4gKiBAZXh0ZW5kcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKiBAc2VlIE5lby5tYWluLmFkZG9uLldpbmRvd1Bvc2l0aW9uXG4gKi9cbmNsYXNzIFdpbmRvdyBleHRlbmRzIE1hbmFnZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuV2luZG93J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5XaW5kb3cnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNTYWZhcmlcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNTYWZhcmk6IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uV2luZG93Q29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uV2luZG93RGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2luZG93SWQgd2hpY2ggaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBnbG9iYWwgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICAgICAqIFRoaXMgaXMgdGhlIGNvcmUgaW50ZXJzZWN0aW9uIHRlc3QgZm9yIGNyb3NzLXdpbmRvdyBkcmFnIGFuZCBkcm9wIG9wZXJhdGlvbnMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggU2NyZWVuIFggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFNjcmVlbiBZIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFRoZSB3aW5kb3dJZCBvZiB0aGUgdGFyZ2V0IHdpbmRvdywgb3IgbnVsbCBpZiBubyBpbnRlcnNlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0V2luZG93QXQoeCwgeSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ub3V0ZXJSZWN0Py5pbnRlcnNlY3RzKHtib3R0b206IHksIHJpZ2h0OiB4LCB4LCB5fSkpO1xuXG4gICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5pZCA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUdlb21ldHJ5KGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHtpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgbW96SW5uZXJTY3JlZW5YLCBtb3pJbm5lclNjcmVlblksIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoLCBzY3JlZW5MZWZ0LCBzY3JlZW5Ub3B9ID0gZGF0YSxcbiAgICAgICAgICAgIHdpZHRoRGlmZiAgICA9IG91dGVyV2lkdGggIC0gaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodERpZmYgICA9IG91dGVySGVpZ2h0IC0gaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBTaWRlIGJvcmRlcnMgYXJlIHN5bW1ldHJpY1xuICAgICAgICAgICAgc2lkZUJvcmRlciAgID0gd2lkdGhEaWZmIC8gMixcbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IEJvdHRvbSBib3JkZXIgbWF0Y2hlcyBzaWRlIGJvcmRlciAoY29tbW9uIGluIFdpbmRvd3MpXG4gICAgICAgICAgICBib3R0b21Cb3JkZXIgPSBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgLy8gVGhlIHJlc3QgaXMgdGhlIHRvcCBjaHJvbWUgKGhlYWRlcilcbiAgICAgICAgICAgIHRvcENocm9tZSAgICA9IGhlaWdodERpZmYgLSBib3R0b21Cb3JkZXI7XG5cbiAgICAgICAgY29uc3QgY2hyb21lID0ge1xuICAgICAgICAgICAgYm90dG9tOiBib3R0b21Cb3JkZXIsXG4gICAgICAgICAgICBsZWZ0ICA6IHNpZGVCb3JkZXIsXG4gICAgICAgICAgICByaWdodCA6IHNpZGVCb3JkZXIsXG4gICAgICAgICAgICB0b3AgICA6IHRvcENocm9tZVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCB2aWV3cG9ydExlZnQsIHZpZXdwb3J0VG9wO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbW96SW5uZXJTY3JlZW5YID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gRmlyZWZveDogZXhwbGljaXQgdmlld3BvcnQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IG1veklubmVyU2NyZWVuWDtcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICA9IG1veklubmVyU2NyZWVuWVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTYWZhcmkpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaTogc2NyZWVuTGVmdC9Ub3AgaXMgRnJhbWUgcG9zaXRpb24uIEFkZCBjaHJvbWUgdG8gZ2V0IFZpZXdwb3J0LlxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gc2NyZWVuTGVmdCArIHNpZGVCb3JkZXI7XG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgPSBzY3JlZW5Ub3AgICsgdG9wQ2hyb21lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUvRWRnZTogc2NyZWVuTGVmdC9Ub3AgaXMgVmlld3BvcnQgcG9zaXRpb24uXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSBzY3JlZW5MZWZ0O1xuICAgICAgICAgICAgdmlld3BvcnRUb3AgID0gc2NyZWVuVG9wXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbm5lclJlY3QgPSBuZXcgUmVjdGFuZ2xlKHZpZXdwb3J0TGVmdCwgdmlld3BvcnRUb3AsIGlubmVyV2lkdGgsIGlubmVySGVpZ2h0KTtcblxuICAgICAgICBjb25zdCBvdXRlclJlY3QgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0IC0gc2lkZUJvcmRlcixcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICAtIHRvcENocm9tZSxcbiAgICAgICAgICAgIG91dGVyV2lkdGgsXG4gICAgICAgICAgICBvdXRlckhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB7Y2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIG5ldyBicm93c2VyIHdpbmRvdyBjb25uZWN0cyB0byB0aGUgU2hhcmVkV29ya2VyLlxuICAgICAqIEluIFNoYXJlZCBXb3JrZXIgbW9kZSwgYE5lby53b3JrZXIuQXBwI29uQ29ubmVjdGAgZW5zdXJlcyB0aGF0IGB3aW5kb3dEYXRhYFxuICAgICAqIGlzIGZldGNoZWQgZnJvbSB0aGUgTWFpbiBUaHJlYWQgYW5kIGluY2x1ZGVkIGluIHRoZSBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YS53aW5kb3dEYXRhXSBDb250YWlucyBnZW9tZXRyeSBkYXRhIChzY3JlZW5MZWZ0LCBpbm5lckhlaWdodCwgZXRjLilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIG9uV2luZG93Q29ubmVjdCh7YXBwTmFtZSwgd2luZG93RGF0YSwgd2luZG93SWR9KSB7XG4gICAgICAgIGxldCBjaHJvbWUgICAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJSZWN0ID0gbnVsbCxcbiAgICAgICAgICAgIG91dGVyUmVjdCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHdpbmRvd0RhdGEpIHtcbiAgICAgICAgICAgICh7Y2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH0gPSB0aGlzLmNhbGN1bGF0ZUdlb21ldHJ5KHdpbmRvd0RhdGEpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1dpbmRvdy5vbldpbmRvd0Nvbm5lY3QnLCB7d2luZG93SWQsIGFwcE5hbWUsIGNocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9KTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHthcHBOYW1lLCBjaHJvbWUsIGlkOiB3aW5kb3dJZCwgaW5uZXJSZWN0LCBvdXRlclJlY3R9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25XaW5kb3dEaXNjb25uZWN0KHt3aW5kb3dJZH0pIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKHdpbmRvd0lkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdlb21ldHJpYyBzdGF0ZSBvZiBhIHdpbmRvdyBiYXNlZCBvbiBkYXRhIGZyb20gdGhlIE1haW4gVGhyZWFkLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB2aWEgZGlyZWN0IGRlbGVnYXRpb24gZnJvbSB0aGUgQXBwIFdvcmtlciB0byBtaW5pbWl6ZSBvdmVyaGVhZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmlubmVySGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEub3V0ZXJIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vdXRlcldpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyZWVuTGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNjcmVlblRvcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25XaW5kb3dQb3NpdGlvbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5nZXQoZGF0YS53aW5kb3dJZCksXG4gICAgICAgICAgICB7Y2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH0gPSBtZS5jYWxjdWxhdGVHZW9tZXRyeShkYXRhKTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5jaHJvbWUgICAgPSBjaHJvbWU7XG4gICAgICAgICAgICBpdGVtLmlubmVyUmVjdCA9IGlubmVyUmVjdDtcbiAgICAgICAgICAgIGl0ZW0ub3V0ZXJSZWN0ID0gb3V0ZXJSZWN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgY2hyb21lLFxuICAgICAgICAgICAgICAgIGlkOiBkYXRhLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgIGlubmVyUmVjdCxcbiAgICAgICAgICAgICAgICBvdXRlclJlY3RcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jbGFzc05hbWUsXG4gICAgICAgICAgICB3aW5kb3dzICA6IHRoaXMuaXRlbXMubWFwKHdpbiA9PiAoe1xuICAgICAgICAgICAgICAgIGlkICAgICAgIDogd2luLmlkLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgIDogd2luLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY2hyb21lICAgOiB3aW4uY2hyb21lLFxuICAgICAgICAgICAgICAgIGlubmVyUmVjdDogd2luLmlubmVyUmVjdCxcbiAgICAgICAgICAgICAgICBvdXRlclJlY3Q6IHdpbi5vdXRlclJlY3RcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhXaW5kb3cpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9