"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_dashboard_SortZone_mjs"],{

/***/ "./src/draggable/dashboard/SortZone.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/dashboard/SortZone.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/DragCoordinator.mjs */ "./src/manager/DragCoordinator.mjs");
/* harmony import */ var _DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DragProxyContainer.mjs */ "./src/draggable/DragProxyContainer.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _container_SortZone_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../container/SortZone.mjs */ "./src/draggable/container/SortZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");








/**
 * @class Neo.draggable.dashboard.SortZone
 * @extends Neo.draggable.container.SortZone
 */
class DashboardSortZone extends _container_SortZone_mjs__WEBPACK_IMPORTED_MODULE_5__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.dashboard.SortZone'
         * @protected
         */
        className: 'Neo.draggable.dashboard.SortZone',
        /**
         * @member {String} ntype='dashboard-sortzone'
         * @protected
         */
        ntype: 'dashboard-sortzone',
        /**
         * The CSS selector for the drag handle.
         * @member {String} dragHandleSelector='.neo-draggable'
         */
        dragHandleSelector: '.neo-draggable',
        /**
         * Add extra CSS selectors to the drag proxy root.
         * @member {String[]} dragProxyExtraCls=[]
         */
        dragProxyExtraCls: [],
        /**
         * @member {String|null} sortGroup=null
         */
        sortGroup: null
    }

    /**
     * @member {Boolean} isRemoteDragging=false
     * @protected
     */
    isRemoteDragging = false

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].register(this)
    }

    /**
     * Checks if the remote drag coordinates intersect with the sort zone.
     * Triggers an async fetch of ownerRect if not currently cached.
     * @param {Number} x
     * @param {Number} y
     * @returns {Boolean}
     */
    acceptsRemoteDrag(x, y) {
        let me = this;

        if (!me.ownerRect) {
            if (!me.isFetchingRect) {
                me.isFetchingRect = true;
                me.owner.getDomRect([me.owner.id]).then(rects => {
                    me.ownerRect = rects[0];
                    me.isFetchingRect = false
                })
            }
            return false
        }

        return x >= me.ownerRect.x &&
               x <= me.ownerRect.x + me.ownerRect.width &&
               y >= me.ownerRect.y &&
               y <= me.ownerRect.y + me.ownerRect.height
    }

    /**
     *
     */
    applyAbsolutePositioning() {
        let me = this,
            itemStyle;

        me.sortableItems.forEach((item, i) => {
            let rect = me.itemRects[i];

            itemStyle = item.wrapperStyle || {};

            me.adjustProxyRectToParent?.(rect, me.ownerRect);

            console.log('applyAbsolutePositioning', {
                height  : `${rect.height}px`,
                left    : `${rect.left}px`,
                top     : `${rect.top}px`,
                width   : `${rect.width}px`
            });

            item.wrapperStyle = Object.assign(itemStyle, {
                flex    : 'none',
                height  : `${rect.height}px`,
                left    : `${rect.left}px`,
                margin  : '0px',
                position: 'absolute',
                top     : `${rect.top}px`,
                width   : `${rect.width}px`
            })
        })
    }

    /**
     * Calculates a new layout for the remaining items when one item is dragged out of the container (e.g., into a new window).
     *
     * This method ensures the dashboard doesn't leave a "hole" where the dragged item was. Instead, it:
     * 1.  **Infers Gaps & Offsets:** Analyzes the cached `itemRects` to mathematically derive the container's padding
     *     and the gaps between items, ensuring the new layout respects the original design tokens.
     * 2.  **Identifies Remaining Items:** Filters out the dragged component and its placeholder.
     * 3.  **Distributes Space:** Calculates the available space (Total Size - Offsets - Gaps - Fixed Items) and distributes
     *     it among flex items proportional to their flex values.
     * 4.  **Generates Styles:** Returns a list of style objects (`top`, `left`, `width`, `height`) to be applied to the remaining items.
     *
     * @returns {Object[]} Array of objects containing the `item` reference and the calculated `style` object.
     */
    calculateExpandedLayout() {
        let me           = this,
            ownerRect    = me.ownerRect,
            isHorizontal = me.sortDirection === 'horizontal',
            totalSize    = isHorizontal ? ownerRect.width : ownerRect.height,
            items        = [],
            totalFlex    = 0,
            usedSize     = 0,
            rects        = [],
            startOffset  = 0,
            endOffset    = 0,
            gap          = 0,
            topOffset    = 0,
            bottomOffset = 0,
            leftOffset   = 0,
            rightOffset  = 0,
            startX       = me.adjustItemRectsToParent ? 0 : ownerRect.x,
            startY       = me.adjustItemRectsToParent ? 0 : ownerRect.y;

        // 1. Calculate offsets and gaps from the original slots (itemRects)
        if (me.itemRects.length > 0) {
            let r0 = me.itemRects[0],
                rn = me.itemRects[me.itemRects.length - 1];

            if (isHorizontal) {
                startOffset  = me.adjustItemRectsToParent ? r0.x : r0.x - ownerRect.x;
                endOffset    = totalSize - (me.adjustItemRectsToParent ? (rn.x + rn.width) : (rn.x - ownerRect.x + rn.width));
                topOffset    = me.adjustItemRectsToParent ? r0.y : r0.y - ownerRect.y;
                bottomOffset = ownerRect.height - (me.adjustItemRectsToParent ? (r0.y + r0.height) : (r0.y - ownerRect.y + r0.height)); // Approx from first item

                if (me.itemRects.length > 1) {
                    let r1 = me.itemRects[1];
                    gap = r1.x - (r0.x + r0.width);
                }
            } else {
                startOffset = me.adjustItemRectsToParent ? r0.y : r0.y - ownerRect.y;
                endOffset   = totalSize - (me.adjustItemRectsToParent ? (rn.y + rn.height) : (rn.y - ownerRect.y + rn.height));
                leftOffset  = me.adjustItemRectsToParent ? r0.x : r0.x - ownerRect.x;
                rightOffset = ownerRect.width - (me.adjustItemRectsToParent ? (r0.x + r0.width) : (r0.x - ownerRect.x + r0.width));

                if (me.itemRects.length > 1) {
                    let r1 = me.itemRects[1];
                    gap = r1.y - (r0.y + r0.height);
                }
            }
        }
        // 2. Filter valid items
        for (let i = 0; i < me.itemRects.length; i++) {
            let mappedIndex = me.indexMap[i];

            if (mappedIndex === -1) {
                continue
            }

            let item = me.owner.items[mappedIndex];

            if (item === me.dragPlaceholder || item === me.dragComponent) {
                continue
            }

            let rect = me.itemRects[i];

            items.push({item, rect});

            if (item.flex) {
                totalFlex += item.flex
            } else {
                let size = isHorizontal ? rect.width : rect.height;
                usedSize += size
            }
        }

        // 3. Calculate available space
        let totalGaps      = Math.max(0, items.length - 1),
            availableSpace = Math.max(0, totalSize - startOffset - endOffset - (totalGaps * gap) - usedSize);

        // 4. Distribute space
        let currentPos = startOffset;

        items.forEach(({item, rect}, index) => {
            let itemSize, style = {};

            if (item.flex) {
                itemSize = (item.flex / totalFlex) * availableSpace
            } else {
                itemSize = isHorizontal ? rect.width : rect.height
            }

            if (isHorizontal) {
                style = {
                    left  : `${startX + currentPos}px`,
                    top   : `${startY + topOffset}px`,
                    height: `${ownerRect.height - topOffset - bottomOffset}px`,
                    width : `${itemSize}px`
                }
            } else {
                style = {
                    left  : `${startX + leftOffset}px`,
                    top   : `${startY + currentPos}px`,
                    height: `${itemSize}px`,
                    width : `${ownerRect.width - leftOffset - rightOffset}px`
                }
            }

            rects.push({item, style});
            currentPos += itemSize + gap
        });

        return rects
    }

    /**
     *
     */
    destroy() {
        _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].unregister(this);
        super.destroy()
    }

    /**
     * @returns {Object}
     */
    getDragProxyConfig() {
        const config = super.getDragProxyConfig();

        config.cls = config.cls.filter(cls => !cls.includes('neo-viewport'));
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(config.cls, this.dragProxyExtraCls);

        return config
    }

    /**
     * @param {Object} data The drag end event data.
     */
    async onDragEnd(data) {
        let me = this;

        if (!me.isRemoteDragging) {
            // Signal Coordinator about end of drag
            _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].onDragEnd({
                draggedItem   : me.dragComponent,
                sourceSortZone: me
            })
        }

        super.onDragEnd(data)
    }

    /**
     * Handles the drag move event. This is the core logic loop for the drag operation.
     *
     * Responsibilities:
     * 1.  **Window Drag Re-entry:** Checks if a window drag has re-entered the original container boundaries.
     *     If so, it restores the original layout snapshot (`itemRects`) and shows the placeholder, effectively
     *     "snapping" the dashboard back to its sortable state.
     * 2.  **Window Drag Exit:** Detects if the drag proxy has left the container boundaries (if `enableProxyToPopup` is true)
     *     and triggers the `dragBoundaryExit` event to potentially start a window drag.
     * 3.  **Standard Sorting:** If not in window-drag mode, it calculates the drag delta and swaps items (`switchItems`)
     *     if the threshold is crossed, updating the `currentIndex`.
     * 4.  **Auto-Scrolling:** Manages auto-scrolling when dragging near the edges of the container.
     *
     * @param {Object} data The drag move event data.
     */
    async onDragMove(data) {
        let me = this;

        // The method can trigger before we got the client rects from the main thread
        if (!me.itemRects || !me.boundaryContainerRect || me.isScrolling) {
            return
        }

        await super.onDragMove(data)
    }

    /**
     * @param {Object} data
     */
    async onRemoteDragLeave(data) {
        let me = this;

        if (me.isRemoteDragging) {
            me.isRemoteDragging = false;
            await me.onDragEnd({})
        }
    }

    /**
     * @param {Object} data
     */
    async onRemoteDragMove(data) {
        let me = this;

        if (!me.isRemoteDragging) {
            await me.startRemoteDrag(data)
        }

        // Delegate to standard onDragMove logic, which updates the proxy
        me.onDragMove({
            clientX  : data.localX,
            clientY  : data.localY,
            proxyRect: data.proxyRect
        });

        me.dragMove({
            clientX: data.localX,
            clientY: data.localY
        }, true)
    }

    /**
     * @param {Neo.component.Base} draggedItem
     */
    async onRemoteDrop(draggedItem) {
        let me    = this,
            index = me.currentIndex;

        // Ensure we are in remote drag mode
        if (me.isRemoteDragging) {
            // Cleanup placeholder but keep layout ready
            await me.onDragEnd({});

            // Remove from old parent (if not already detached)
            const parentId = draggedItem.parentId;
            if (parentId && parentId !== 'document.body') {
                Neo.getComponent(parentId)?.remove(draggedItem, false)
            }

            // Insert into new owner
            me.owner.insert(index, draggedItem);

            me.isRemoteDragging = false
        }
    }

    /**
     * @param {Neo.component.Base} draggedItem
     */
    onRemoteDropOut(draggedItem) {
        // Called on the source sort zone when a drop occurred elsewhere.
        // We need to cleanup any detached state tracking.
        let me = this;

        if (me.owner.detachedItems) {
            for (const [key, value] of me.owner.detachedItems.entries()) {
                if (value.widget === draggedItem) {
                    me.owner.detachedItems.delete(key);
                    // The window is already closed by suspendWindowDrag, so we just clean up the map.
                    break
                }
            }
        }
    }

    /**
     * @param {Number} intersectionRatio
     * @param {Object} data
     */
    onWindowDragContinue(intersectionRatio, data) {
        let me = this;

        // Signal Coordinator
        _manager_DragCoordinator_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].onDragMove({
            draggedItem   : me.dragComponent,
            offsetX       : me.offsetX,
            offsetY       : me.offsetY,
            proxyRect     : data.proxyRect,
            screenX       : data.screenX,
            screenY       : data.screenY,
            sourceSortZone: me
        })
    }

    /**
     * @param {String} widgetName
     * @param {DOMRect} proxyRect
     */
    resumeWindowDrag(widgetName, proxyRect) {
        this.owner.resumeWindowDrag(widgetName, proxyRect)
    }

    /**
     * @param {Neo.component.Base} draggedItem
     */
    async setupDragState(draggedItem) {
        let me                               = this,
            {adjustItemRectsToParent, owner} = me,
            itemStyles                       = me.itemStyles = [],
            {layout}                         = owner,
            ownerStyle                       = owner.style || {},
            index, indexMap, itemRects, sortableItems;

        sortableItems = owner.items.filter(item => !item.isDestroyed);
        index         = sortableItems.indexOf(draggedItem);

        indexMap = {};

        Object.assign(me, {
            currentIndex           : index,
            dragElement            : _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].find(owner.vdom, draggedItem.id).vdom,
            dragProxyConfig        : me.getDragProxyConfig(),
            indexMap,
            ownerStyle             : {height: ownerStyle.height, minWidth: ownerStyle.minWidth, width: ownerStyle.width},
            reversedLayoutDirection: layout.direction === 'column-reverse' || layout.direction === 'row-reverse',
            sortableItems,
            sortDirection          : layout.direction?.includes('column') ? 'vertical' : 'horizontal',
            startIndex             : index
        });

        me.dragComponent = draggedItem;

        sortableItems.forEach((item, i) => {
            indexMap[i] = owner.items.indexOf(item);

            itemStyles.push({
                height: item.height ? `${item.height}px` :  item.style?.height,
                width : item.width  ? `${item.width}px`  :  item.style?.width
            })
        });

        itemRects = await owner.getDomRect([owner.id].concat(sortableItems.map(e => e.id)));

        itemRects.forEach(rect => {
            console.log('itemRect', {
                height  : `${rect.height}px`,
                left    : `${rect.left}px`,
                top     : `${rect.top}px`,
                width   : `${rect.width}px`
            });
        });

        me.ownerRect = itemRects.shift();
        me.boundaryContainerRect = me.ownerRect;

        owner.style = {
            ...ownerStyle,
            height  : `${me.ownerRect.height}px`,
            minWidth: `${me.ownerRect.width}px`,
            width   : `${me.ownerRect.width}px`
        };

        console.log('adjustItemRectsToParent', adjustItemRectsToParent);

        adjustItemRectsToParent && itemRects.forEach(rect => {
            rect.x -= me.ownerRect.x;
            rect.y -= me.ownerRect.y
        });

        me.itemRects = itemRects
    }

    /**
     * @param {Object} data
     */
    async startRemoteDrag(data) {
        let me          = this,
            {owner}     = me,
            {proxyRect} = data,
            draggedItem = data.draggedItem,
            config;

        me.isRemoteDragging = true;

        // Mock the drag element rect for DragZone logic if needed
        me.dragElementRect = {
            height: proxyRect.height,
            width : proxyRect.width,
            x     : data.localX,
            y     : data.localY,
            left  : data.localX,
            top   : data.localY
        };

        // Update dragged item to target app context
        draggedItem.appName = me.appName;

        console.log('startRemoteDrag', draggedItem.id, draggedItem.windowId, draggedItem.parentId, draggedItem.parentComponent);

        // Break the parent chain to prevent circular config lookups during handover
        draggedItem.parentId        = null;
        draggedItem.parentComponent = null;

        // Since the component was mounted in a different window, we need to reset the state
        draggedItem.mounted          = false;
        draggedItem.vnode            = null;
        draggedItem.vnodeInitialized = false;

        console.log('parent cleared:', draggedItem.parentId, draggedItem.parentComponent);

        // 1. Get Owner Rect (needed for proxy positioning)
        let rects = await owner.getDomRect([owner.id]);
        me.ownerRect = rects[0];

        console.log('ownerRect', me.ownerRect);

        // Assign the drag offsets to the instance, so that the DragZone onDragMove logic works
        me.offsetX = data.offsetX;
        me.offsetY = data.offsetY;

        console.log('startRemoteDrag: ownerRect', me.ownerRect);
        console.log('startRemoteDrag: local coords', data.localX, data.localY);
        console.log('startRemoteDrag: calculated coords', data.localX - me.offsetX, data.localY - me.offsetY);

        // 2. Create a local DragProxy manually (using DragProxyContainer to hold the live widget)
        // We use DragProxyContainer to ensure the widget remains active/connected.
        config = {
            module          : _DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName         : me.appName,
            cls             : ['neo-dragproxy', ...me.owner.cls],
            items           : [draggedItem],
            moveInMainThread: false,
            windowId        : me.windowId,

            style: {
                left: `${data.localX - me.offsetX}px`,
                top : `${data.localY - me.offsetY}px`
            }
        };

        console.log('Creating local drag proxy', config);

        me.dragProxy = Neo.create(config);

        console.log('Created local drag proxy', me.dragProxy);

        // 3. Create Placeholder
        me.dragPlaceholder = Neo.create({
            module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex  : 'none',
            style : {height: `${proxyRect.height}px`, visibility: 'hidden'}
        });

        owner.add(me.dragPlaceholder);

        // 4. Setup Sort State
        await me.timeout(50);
        await me.setupDragState(me.dragPlaceholder);

        // Update proxy size to match the measured placeholder
        let placeholderIndex = me.sortableItems.indexOf(me.dragPlaceholder);

        if (placeholderIndex > -1) {
            let rect = me.itemRects[placeholderIndex];
            me.dragProxy.width  = rect.width;
            me.dragProxy.height = rect.height;
        }

        await me.timeout(50);
        // 5. Apply Absolute Positioning
        me.applyAbsolutePositioning()
    }

    /**
     * Handles the drag move event. This is the core logic loop for the drag operation.
     *
     * Responsibilities:
     * 1.  **Window Drag Re-entry:** Checks if a window drag has re-entered the original container boundaries.
     *     If so, it restores the original layout snapshot (`itemRects`) and shows the placeholder, effectively
     *     "snapping" the dashboard back to its sortable state.
     * 2.  **Window Drag Exit:** Detects if the drag proxy has left the container boundaries (if `enableProxyToPopup` is true)
     *     and triggers the `dragBoundaryExit` event to potentially start a window drag.
     * 3.  **Standard Sorting:** If not in window-drag mode, it calculates the drag delta and swaps items (`switchItems`)
     *     if the threshold is crossed, updating the `currentIndex`.
     * 4.  **Auto-Scrolling:** Manages auto-scrolling when dragging near the edges of the container.
     *
     * @param {Object} data - The drag move event data.
     */
    startWindowDrag(data) {
        let me = this,
            {popupHeight, popupWidth, windowName} = data;

        // Keep the proxy active to capture mouse events, but make it invisible
        me.dragProxy.style = {opacity: 0};
        me.isWindowDragging = true;

        if (me.dragPlaceholder) {
            me.dragPlaceholder.wrapperStyle = {
                ...me.dragPlaceholder.wrapperStyle,
                visibility: 'hidden'
            }
        }

        // Apply expanded layout
        let expandedLayout = me.calculateExpandedLayout();
        expandedLayout.forEach(({item, style}) => {
            item.wrapperStyle = {...item.wrapperStyle, ...style}
        });

        Neo.main.addon.DragDrop.startWindowDrag({
            popupHeight,
            popupName: windowName,
            popupWidth,
            windowId : me.windowId
        })
    }

    /**
     * @param {String} widgetName
     */
    suspendWindowDrag(widgetName) {
        this.owner.suspendWindowDrag(widgetName)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DashboardSortZone));


/***/ },

/***/ "./src/manager/DragCoordinator.mjs"
/*!*****************************************!*\
  !*** ./src/manager/DragCoordinator.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _Window_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Window.mjs */ "./src/manager/Window.mjs");




/**
 * @class Neo.manager.DragCoordinator
 * @extends Neo.manager.Base
 * @singleton
 */
class DragCoordinator extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.DragCoordinator'
         * @protected
         */
        className: 'Neo.manager.DragCoordinator',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * @member {Map} sortZones=new Map()
         * @protected
         */
        sortZones: new Map()
    }

    /**
     * @member {Neo.draggable.container.SortZone|null} activeTargetZone=null
     * @protected
     */
    activeTargetZone = null

    /**
     * @param {Neo.draggable.container.SortZone} sourceSortZone
     * @param {Neo.component.Base} draggedItem
     * @param {DOMRect} proxyRect
     */
    handleVoid(sourceSortZone, draggedItem, proxyRect) {
        let me = this;

        if (me.activeTargetZone) {
            me.activeTargetZone.onRemoteDragLeave();
            me.activeTargetZone = null;

            // Resume source drag (re-open popup)
            sourceSortZone.resumeWindowDrag(draggedItem.reference || draggedItem.id, proxyRect)
        }
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.draggedItem
     * @param {Number} data.offsetX
     * @param {Number} data.offsetY
     * @param {Number} data.screenX
     * @param {Number} data.screenY
     * @param {Neo.draggable.container.SortZone} data.sourceSortZone
     */
    onDragMove(data) {
        let me             = this,
            {draggedItem, offsetX, offsetY, proxyRect, screenX, screenY, sourceSortZone} = data,
            {sortGroup}    = sourceSortZone,
            targetWindowId = _Window_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getWindowAt(screenX, screenY),
            targetSortZone;

        if (targetWindowId && targetWindowId !== sourceSortZone.windowId) {
            targetSortZone = me.sortZones.get(sortGroup)?.get(targetWindowId);

            if (targetSortZone) {
                let targetWindow = _Window_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].get(targetWindowId),
                    localX       = screenX - targetWindow.innerRect.x,
                    localY       = screenY - targetWindow.innerRect.y,
                    targetProxyRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
                        localX - offsetX,
                        localY - offsetY,
                        proxyRect.width,
                        proxyRect.height
                    );

                if (targetSortZone.acceptsRemoteDrag(localX, localY)) {
                    // console.log('DragCoordinator target found', {targetWindowId, localX, localY});

                    // Entering a new target zone
                    if (me.activeTargetZone !== targetSortZone) {
                        // Leaving previous target (if any)
                        me.activeTargetZone?.onRemoteDragLeave();

                        // Suspend source drag (close popup, etc)
                        // We only do this once when leaving the void/source context
                        if (!me.activeTargetZone) {
                            sourceSortZone.suspendWindowDrag(draggedItem.reference || draggedItem.id)
                        }

                        me.activeTargetZone = targetSortZone
                    }

                    targetSortZone.onRemoteDragMove({
                        draggedItem,
                        localX,
                        localY,
                        offsetX,
                        offsetY,
                        proxyRect: targetProxyRect
                    });

                    return
                }
            }
        }

        // In void or back in source window
        me.handleVoid(sourceSortZone, draggedItem, proxyRect)
    }

    /**
     * @param {Object} data
     * @param {Neo.draggable.container.SortZone} data.sourceSortZone
     */
    onDragEnd(data) {
        let me = this;

        if (me.activeTargetZone) {
            // Drop on target
            me.activeTargetZone.onRemoteDrop(data.draggedItem);

            // Notify source to finalize cleanup
            data.sourceSortZone.onRemoteDropOut(data.draggedItem);

            me.activeTargetZone = null
        } else {
            // Drag ended in void or source window (handled locally by source)
        }
    }

    /**
     * @param {Neo.draggable.container.SortZone} sortZone
     */
    register(sortZone) {
        let me                    = this,
            {sortGroup, windowId} = sortZone;

        if (sortGroup) {
            if (!me.sortZones.has(sortGroup)) {
                me.sortZones.set(sortGroup, new Map())
            }

            me.sortZones.get(sortGroup).set(windowId, sortZone)
        }
    }

    /**
     * @param {Neo.draggable.container.SortZone} sortZone
     */
    unregister(sortZone) {
        let me                    = this,
            {sortGroup, windowId} = sortZone;

        if (sortGroup && me.sortZones.has(sortGroup)) {
            let group = me.sortZones.get(sortGroup);
            group.delete(windowId);

            if (group.size === 0) {
                me.sortZones.delete(sortGroup)
            }
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            className       : me.className,
            activeTargetZone: me.activeTargetZone ? {
                id       : me.activeTargetZone.id,
                sortGroup: me.activeTargetZone.sortGroup,
                windowId : me.activeTargetZone.windowId
            } : null,
            sortZones: Array.from(me.sortZones.entries()).map(([group, map]) => ({
                group,
                windows: Array.from(map.keys())
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragCoordinator));


/***/ },

/***/ "./src/manager/Window.mjs"
/*!********************************!*\
  !*** ./src/manager/Window.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");



/**
 * @summary The "God View" for the multi-window application workspace.
 * @description This manager maintains a real-time geometric map of all connected browser windows in the App Worker.
 * It is the central authority for spatial awareness, enabling features like the "Infinite Canvas" where
 * interactions (like Drag & Drop) can span across multiple OS-level windows.
 *
 * It receives high-frequency position updates from the Main Thread (via `Neo.main.addon.WindowPosition`)
 * and provides intersection testing APIs to determine which window is under a given screen coordinate.
 *
 * @class Neo.manager.Window
 * @extends Neo.manager.Base
 * @singleton
 * @see Neo.main.addon.WindowPosition
 */
class Window extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Window'
         * @protected
         */
        className: 'Neo.manager.Window',
        /**
         * @member {Boolean} isSafari
         * @protected
         */
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * Returns the windowId which intersects with the given global screen coordinates.
     * This is the core intersection test for cross-window drag and drop operations.
     * @param {Number} x Screen X coordinate
     * @param {Number} y Screen Y coordinate
     * @returns {String|null} The windowId of the target window, or null if no intersection.
     */
    getWindowAt(x, y) {
        let item = this.items.find(item => item.outerRect?.intersects({bottom: y, right: x, x, y}));

        return item ? item.id : null
    }

    /**
     * @param {Object} data
     * @returns {Object} {chrome, innerRect, outerRect}
     */
    calculateGeometry(data) {
        const
            {innerHeight, innerWidth, mozInnerScreenX, mozInnerScreenY, outerHeight, outerWidth, screenLeft, screenTop} = data,
            widthDiff    = outerWidth  - innerWidth,
            heightDiff   = outerHeight - innerHeight,
            // Assumption: Side borders are symmetric
            sideBorder   = widthDiff / 2,
            // Assumption: Bottom border matches side border (common in Windows)
            bottomBorder = sideBorder,
            // The rest is the top chrome (header)
            topChrome    = heightDiff - bottomBorder;

        const chrome = {
            bottom: bottomBorder,
            left  : sideBorder,
            right : sideBorder,
            top   : topChrome
        };

        let viewportLeft, viewportTop;

        if (typeof mozInnerScreenX === 'number') {
            // Firefox: explicit viewport coordinates
            viewportLeft = mozInnerScreenX;
            viewportTop  = mozInnerScreenY
        } else if (this.isSafari) {
            // Safari: screenLeft/Top is Frame position. Add chrome to get Viewport.
            viewportLeft = screenLeft + sideBorder;
            viewportTop  = screenTop  + topChrome
        } else {
            // Chrome/Edge: screenLeft/Top is Viewport position.
            viewportLeft = screenLeft;
            viewportTop  = screenTop
        }

        const innerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](viewportLeft, viewportTop, innerWidth, innerHeight);

        const outerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            viewportLeft - sideBorder,
            viewportTop  - topChrome,
            outerWidth,
            outerHeight
        );

        return {chrome, innerRect, outerRect}
    }

    /**
     * Triggered when a new browser window connects to the SharedWorker.
     * In Shared Worker mode, `Neo.worker.App#onConnect` ensures that `windowData`
     * is fetched from the Main Thread and included in the payload.
     * @param {Object} data
     * @param {Number} data.appName
     * @param {Object} [data.windowData] Contains geometry data (screenLeft, innerHeight, etc.)
     * @param {String} data.windowId
     */
    onWindowConnect({appName, windowData, windowId}) {
        let chrome    = null,
            innerRect = null,
            outerRect = null;

        if (windowData) {
            ({chrome, innerRect, outerRect} = this.calculateGeometry(windowData))
        }

        console.log('Window.onWindowConnect', {windowId, appName, chrome, innerRect, outerRect});

        this.register({appName, chrome, id: windowId, innerRect, outerRect})
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowDisconnect({windowId}) {
        this.unregister(windowId)
    }

    /**
     * Updates the geometric state of a window based on data from the Main Thread.
     * This method is called via direct delegation from the App Worker to minimize overhead.
     * @param {Object} data
     * @param {Number} data.innerHeight
     * @param {Number} data.outerHeight
     * @param {Number} data.outerWidth
     * @param {Number} data.screenLeft
     * @param {Number} data.screenTop
     * @param {String} data.windowId
     */
    onWindowPositionChange(data) {
        const
            me   = this,
            item = me.get(data.windowId),
            {chrome, innerRect, outerRect} = me.calculateGeometry(data);

        if (item) {
            item.chrome    = chrome;
            item.innerRect = innerRect;
            item.outerRect = outerRect
        } else {
            me.register({
                chrome,
                id: data.windowId,
                innerRect,
                outerRect
            })
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            className: this.className,
            windows  : this.items.map(win => ({
                id       : win.id,
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Window));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfZGFzaGJvYXJkX1NvcnRab25lX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNTO0FBQ1I7QUFDTDtBQUNJO0FBQ0M7QUFDTjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0RBQVE7QUFDeEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQWU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDLDZCQUE2QixVQUFVO0FBQ3ZDLDZCQUE2QixTQUFTO0FBQ3RDLDZCQUE2QixXQUFXO0FBQ3hDLGFBQWE7O0FBRWI7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0Qyw2QkFBNkIsV0FBVztBQUN4QyxhQUFhO0FBQ2IsU0FBUztB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QUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9kYXNoYm9hcmQvU29ydFpvbmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9EcmFnQ29vcmRpbmF0b3IubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9XaW5kb3cubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb21wb25lbnQgICAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBEcmFnQ29vcmRpbmF0b3IgICAgZnJvbSAnLi4vLi4vbWFuYWdlci9EcmFnQ29vcmRpbmF0b3IubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb250YWluZXIgZnJvbSAnLi4vRHJhZ1Byb3h5Q29udGFpbmVyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcbmltcG9ydCBTb3J0Wm9uZSAgICAgICAgICAgZnJvbSAnLi4vY29udGFpbmVyL1NvcnRab25lLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICAgIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLmRhc2hib2FyZC5Tb3J0Wm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmVcbiAqL1xuY2xhc3MgRGFzaGJvYXJkU29ydFpvbmUgZXh0ZW5kcyBTb3J0Wm9uZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLmRhc2hib2FyZC5Tb3J0Wm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5kYXNoYm9hcmQuU29ydFpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZGFzaGJvYXJkLXNvcnR6b25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Rhc2hib2FyZC1zb3J0em9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgQ1NTIHNlbGVjdG9yIGZvciB0aGUgZHJhZyBoYW5kbGUuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZHJhZ0hhbmRsZVNlbGVjdG9yPScubmVvLWRyYWdnYWJsZSdcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdIYW5kbGVTZWxlY3RvcjogJy5uZW8tZHJhZ2dhYmxlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBleHRyYSBDU1Mgc2VsZWN0b3JzIHRvIHRoZSBkcmFnIHByb3h5IHJvb3QuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkcmFnUHJveHlFeHRyYUNscz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5RXh0cmFDbHM6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNvcnRHcm91cD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0R3JvdXA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1JlbW90ZURyYWdnaW5nPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzUmVtb3RlRHJhZ2dpbmcgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIERyYWdDb29yZGluYXRvci5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcmVtb3RlIGRyYWcgY29vcmRpbmF0ZXMgaW50ZXJzZWN0IHdpdGggdGhlIHNvcnQgem9uZS5cbiAgICAgKiBUcmlnZ2VycyBhbiBhc3luYyBmZXRjaCBvZiBvd25lclJlY3QgaWYgbm90IGN1cnJlbnRseSBjYWNoZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGFjY2VwdHNSZW1vdGVEcmFnKHgsIHkpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLm93bmVyUmVjdCkge1xuICAgICAgICAgICAgaWYgKCFtZS5pc0ZldGNoaW5nUmVjdCkge1xuICAgICAgICAgICAgICAgIG1lLmlzRmV0Y2hpbmdSZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtZS5vd25lci5nZXREb21SZWN0KFttZS5vd25lci5pZF0pLnRoZW4ocmVjdHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3QgPSByZWN0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNGZXRjaGluZ1JlY3QgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4ID49IG1lLm93bmVyUmVjdC54ICYmXG4gICAgICAgICAgICAgICB4IDw9IG1lLm93bmVyUmVjdC54ICsgbWUub3duZXJSZWN0LndpZHRoICYmXG4gICAgICAgICAgICAgICB5ID49IG1lLm93bmVyUmVjdC55ICYmXG4gICAgICAgICAgICAgICB5IDw9IG1lLm93bmVyUmVjdC55ICsgbWUub3duZXJSZWN0LmhlaWdodFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYXBwbHlBYnNvbHV0ZVBvc2l0aW9uaW5nKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbVN0eWxlO1xuXG4gICAgICAgIG1lLnNvcnRhYmxlSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBtZS5pdGVtUmVjdHNbaV07XG5cbiAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBtZS5hZGp1c3RQcm94eVJlY3RUb1BhcmVudD8uKHJlY3QsIG1lLm93bmVyUmVjdCk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhcHBseUFic29sdXRlUG9zaXRpb25pbmcnLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgIDogYCR7cmVjdC5sZWZ0fXB4YCxcbiAgICAgICAgICAgICAgICB0b3AgICAgIDogYCR7cmVjdC50b3B9cHhgLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gT2JqZWN0LmFzc2lnbihpdGVtU3R5bGUsIHtcbiAgICAgICAgICAgICAgICBmbGV4ICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGhlaWdodCAgOiBgJHtyZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgbGVmdCAgICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgbWFyZ2luICA6ICcwcHgnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgOiBgJHtyZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IGAke3JlY3Qud2lkdGh9cHhgXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYSBuZXcgbGF5b3V0IGZvciB0aGUgcmVtYWluaW5nIGl0ZW1zIHdoZW4gb25lIGl0ZW0gaXMgZHJhZ2dlZCBvdXQgb2YgdGhlIGNvbnRhaW5lciAoZS5nLiwgaW50byBhIG5ldyB3aW5kb3cpLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgZGFzaGJvYXJkIGRvZXNuJ3QgbGVhdmUgYSBcImhvbGVcIiB3aGVyZSB0aGUgZHJhZ2dlZCBpdGVtIHdhcy4gSW5zdGVhZCwgaXQ6XG4gICAgICogMS4gICoqSW5mZXJzIEdhcHMgJiBPZmZzZXRzOioqIEFuYWx5emVzIHRoZSBjYWNoZWQgYGl0ZW1SZWN0c2AgdG8gbWF0aGVtYXRpY2FsbHkgZGVyaXZlIHRoZSBjb250YWluZXIncyBwYWRkaW5nXG4gICAgICogICAgIGFuZCB0aGUgZ2FwcyBiZXR3ZWVuIGl0ZW1zLCBlbnN1cmluZyB0aGUgbmV3IGxheW91dCByZXNwZWN0cyB0aGUgb3JpZ2luYWwgZGVzaWduIHRva2Vucy5cbiAgICAgKiAyLiAgKipJZGVudGlmaWVzIFJlbWFpbmluZyBJdGVtczoqKiBGaWx0ZXJzIG91dCB0aGUgZHJhZ2dlZCBjb21wb25lbnQgYW5kIGl0cyBwbGFjZWhvbGRlci5cbiAgICAgKiAzLiAgKipEaXN0cmlidXRlcyBTcGFjZToqKiBDYWxjdWxhdGVzIHRoZSBhdmFpbGFibGUgc3BhY2UgKFRvdGFsIFNpemUgLSBPZmZzZXRzIC0gR2FwcyAtIEZpeGVkIEl0ZW1zKSBhbmQgZGlzdHJpYnV0ZXNcbiAgICAgKiAgICAgaXQgYW1vbmcgZmxleCBpdGVtcyBwcm9wb3J0aW9uYWwgdG8gdGhlaXIgZmxleCB2YWx1ZXMuXG4gICAgICogNC4gICoqR2VuZXJhdGVzIFN0eWxlczoqKiBSZXR1cm5zIGEgbGlzdCBvZiBzdHlsZSBvYmplY3RzIChgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCkgdG8gYmUgYXBwbGllZCB0byB0aGUgcmVtYWluaW5nIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBBcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGBpdGVtYCByZWZlcmVuY2UgYW5kIHRoZSBjYWxjdWxhdGVkIGBzdHlsZWAgb2JqZWN0LlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUV4cGFuZGVkTGF5b3V0KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG93bmVyUmVjdCAgICA9IG1lLm93bmVyUmVjdCxcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbCA9IG1lLnNvcnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIHRvdGFsU2l6ZSAgICA9IGlzSG9yaXpvbnRhbCA/IG93bmVyUmVjdC53aWR0aCA6IG93bmVyUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHRvdGFsRmxleCAgICA9IDAsXG4gICAgICAgICAgICB1c2VkU2l6ZSAgICAgPSAwLFxuICAgICAgICAgICAgcmVjdHMgICAgICAgID0gW10sXG4gICAgICAgICAgICBzdGFydE9mZnNldCAgPSAwLFxuICAgICAgICAgICAgZW5kT2Zmc2V0ICAgID0gMCxcbiAgICAgICAgICAgIGdhcCAgICAgICAgICA9IDAsXG4gICAgICAgICAgICB0b3BPZmZzZXQgICAgPSAwLFxuICAgICAgICAgICAgYm90dG9tT2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgICA9IDAsXG4gICAgICAgICAgICByaWdodE9mZnNldCAgPSAwLFxuICAgICAgICAgICAgc3RhcnRYICAgICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyAwIDogb3duZXJSZWN0LngsXG4gICAgICAgICAgICBzdGFydFkgICAgICAgPSBtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IDAgOiBvd25lclJlY3QueTtcblxuICAgICAgICAvLyAxLiBDYWxjdWxhdGUgb2Zmc2V0cyBhbmQgZ2FwcyBmcm9tIHRoZSBvcmlnaW5hbCBzbG90cyAoaXRlbVJlY3RzKVxuICAgICAgICBpZiAobWUuaXRlbVJlY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCByMCA9IG1lLml0ZW1SZWN0c1swXSxcbiAgICAgICAgICAgICAgICBybiA9IG1lLml0ZW1SZWN0c1ttZS5pdGVtUmVjdHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCAgPSBtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IHIwLnggOiByMC54IC0gb3duZXJSZWN0Lng7XG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ICAgID0gdG90YWxTaXplIC0gKG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gKHJuLnggKyBybi53aWR0aCkgOiAocm4ueCAtIG93bmVyUmVjdC54ICsgcm4ud2lkdGgpKTtcbiAgICAgICAgICAgICAgICB0b3BPZmZzZXQgICAgPSBtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IHIwLnkgOiByMC55IC0gb3duZXJSZWN0Lnk7XG4gICAgICAgICAgICAgICAgYm90dG9tT2Zmc2V0ID0gb3duZXJSZWN0LmhlaWdodCAtIChtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IChyMC55ICsgcjAuaGVpZ2h0KSA6IChyMC55IC0gb3duZXJSZWN0LnkgKyByMC5oZWlnaHQpKTsgLy8gQXBwcm94IGZyb20gZmlyc3QgaXRlbVxuXG4gICAgICAgICAgICAgICAgaWYgKG1lLml0ZW1SZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByMSA9IG1lLml0ZW1SZWN0c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgZ2FwID0gcjEueCAtIChyMC54ICsgcjAud2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IHIwLnkgOiByMC55IC0gb3duZXJSZWN0Lnk7XG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ICAgPSB0b3RhbFNpemUgLSAobWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyAocm4ueSArIHJuLmhlaWdodCkgOiAocm4ueSAtIG93bmVyUmVjdC55ICsgcm4uaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgbGVmdE9mZnNldCAgPSBtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IHIwLnggOiByMC54IC0gb3duZXJSZWN0Lng7XG4gICAgICAgICAgICAgICAgcmlnaHRPZmZzZXQgPSBvd25lclJlY3Qud2lkdGggLSAobWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyAocjAueCArIHIwLndpZHRoKSA6IChyMC54IC0gb3duZXJSZWN0LnggKyByMC53aWR0aCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLml0ZW1SZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByMSA9IG1lLml0ZW1SZWN0c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgZ2FwID0gcjEueSAtIChyMC55ICsgcjAuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gRmlsdGVyIHZhbGlkIGl0ZW1zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWUuaXRlbVJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkSW5kZXggPSBtZS5pbmRleE1hcFtpXTtcblxuICAgICAgICAgICAgaWYgKG1hcHBlZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpdGVtID0gbWUub3duZXIuaXRlbXNbbWFwcGVkSW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gbWUuZHJhZ1BsYWNlaG9sZGVyIHx8IGl0ZW0gPT09IG1lLmRyYWdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVjdCA9IG1lLml0ZW1SZWN0c1tpXTtcblxuICAgICAgICAgICAgaXRlbXMucHVzaCh7aXRlbSwgcmVjdH0pO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5mbGV4KSB7XG4gICAgICAgICAgICAgICAgdG90YWxGbGV4ICs9IGl0ZW0uZmxleFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IGlzSG9yaXpvbnRhbCA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB1c2VkU2l6ZSArPSBzaXplXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBDYWxjdWxhdGUgYXZhaWxhYmxlIHNwYWNlXG4gICAgICAgIGxldCB0b3RhbEdhcHMgICAgICA9IE1hdGgubWF4KDAsIGl0ZW1zLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgYXZhaWxhYmxlU3BhY2UgPSBNYXRoLm1heCgwLCB0b3RhbFNpemUgLSBzdGFydE9mZnNldCAtIGVuZE9mZnNldCAtICh0b3RhbEdhcHMgKiBnYXApIC0gdXNlZFNpemUpO1xuXG4gICAgICAgIC8vIDQuIERpc3RyaWJ1dGUgc3BhY2VcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSBzdGFydE9mZnNldDtcblxuICAgICAgICBpdGVtcy5mb3JFYWNoKCh7aXRlbSwgcmVjdH0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgaXRlbVNpemUsIHN0eWxlID0ge307XG5cbiAgICAgICAgICAgIGlmIChpdGVtLmZsZXgpIHtcbiAgICAgICAgICAgICAgICBpdGVtU2l6ZSA9IChpdGVtLmZsZXggLyB0b3RhbEZsZXgpICogYXZhaWxhYmxlU3BhY2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbVNpemUgPSBpc0hvcml6b250YWwgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ICA6IGAke3N0YXJ0WCArIGN1cnJlbnRQb3N9cHhgLFxuICAgICAgICAgICAgICAgICAgICB0b3AgICA6IGAke3N0YXJ0WSArIHRvcE9mZnNldH1weGAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7b3duZXJSZWN0LmhlaWdodCAtIHRvcE9mZnNldCAtIGJvdHRvbU9mZnNldH1weGAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7aXRlbVNpemV9cHhgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgOiBgJHtzdGFydFggKyBsZWZ0T2Zmc2V0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBgJHtzdGFydFkgKyBjdXJyZW50UG9zfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtpdGVtU2l6ZX1weGAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7b3duZXJSZWN0LndpZHRoIC0gbGVmdE9mZnNldCAtIHJpZ2h0T2Zmc2V0fXB4YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjdHMucHVzaCh7aXRlbSwgc3R5bGV9KTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gaXRlbVNpemUgKyBnYXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlY3RzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBEcmFnQ29vcmRpbmF0b3IudW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREcmFnUHJveHlDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHN1cGVyLmdldERyYWdQcm94eUNvbmZpZygpO1xuXG4gICAgICAgIGNvbmZpZy5jbHMgPSBjb25maWcuY2xzLmZpbHRlcihjbHMgPT4gIWNscy5pbmNsdWRlcygnbmVvLXZpZXdwb3J0JykpO1xuICAgICAgICBOZW9BcnJheS5hZGQoY29uZmlnLmNscywgdGhpcy5kcmFnUHJveHlFeHRyYUNscyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkcmFnIGVuZCBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc1JlbW90ZURyYWdnaW5nKSB7XG4gICAgICAgICAgICAvLyBTaWduYWwgQ29vcmRpbmF0b3IgYWJvdXQgZW5kIG9mIGRyYWdcbiAgICAgICAgICAgIERyYWdDb29yZGluYXRvci5vbkRyYWdFbmQoe1xuICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtICAgOiBtZS5kcmFnQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHNvdXJjZVNvcnRab25lOiBtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLm9uRHJhZ0VuZChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGRyYWcgbW92ZSBldmVudC4gVGhpcyBpcyB0aGUgY29yZSBsb2dpYyBsb29wIGZvciB0aGUgZHJhZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBSZXNwb25zaWJpbGl0aWVzOlxuICAgICAqIDEuICAqKldpbmRvdyBEcmFnIFJlLWVudHJ5OioqIENoZWNrcyBpZiBhIHdpbmRvdyBkcmFnIGhhcyByZS1lbnRlcmVkIHRoZSBvcmlnaW5hbCBjb250YWluZXIgYm91bmRhcmllcy5cbiAgICAgKiAgICAgSWYgc28sIGl0IHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBsYXlvdXQgc25hcHNob3QgKGBpdGVtUmVjdHNgKSBhbmQgc2hvd3MgdGhlIHBsYWNlaG9sZGVyLCBlZmZlY3RpdmVseVxuICAgICAqICAgICBcInNuYXBwaW5nXCIgdGhlIGRhc2hib2FyZCBiYWNrIHRvIGl0cyBzb3J0YWJsZSBzdGF0ZS5cbiAgICAgKiAyLiAgKipXaW5kb3cgRHJhZyBFeGl0OioqIERldGVjdHMgaWYgdGhlIGRyYWcgcHJveHkgaGFzIGxlZnQgdGhlIGNvbnRhaW5lciBib3VuZGFyaWVzIChpZiBgZW5hYmxlUHJveHlUb1BvcHVwYCBpcyB0cnVlKVxuICAgICAqICAgICBhbmQgdHJpZ2dlcnMgdGhlIGBkcmFnQm91bmRhcnlFeGl0YCBldmVudCB0byBwb3RlbnRpYWxseSBzdGFydCBhIHdpbmRvdyBkcmFnLlxuICAgICAqIDMuICAqKlN0YW5kYXJkIFNvcnRpbmc6KiogSWYgbm90IGluIHdpbmRvdy1kcmFnIG1vZGUsIGl0IGNhbGN1bGF0ZXMgdGhlIGRyYWcgZGVsdGEgYW5kIHN3YXBzIGl0ZW1zIChgc3dpdGNoSXRlbXNgKVxuICAgICAqICAgICBpZiB0aGUgdGhyZXNob2xkIGlzIGNyb3NzZWQsIHVwZGF0aW5nIHRoZSBgY3VycmVudEluZGV4YC5cbiAgICAgKiA0LiAgKipBdXRvLVNjcm9sbGluZzoqKiBNYW5hZ2VzIGF1dG8tc2Nyb2xsaW5nIHdoZW4gZHJhZ2dpbmcgbmVhciB0aGUgZWRnZXMgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkcmFnIG1vdmUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBUaGUgbWV0aG9kIGNhbiB0cmlnZ2VyIGJlZm9yZSB3ZSBnb3QgdGhlIGNsaWVudCByZWN0cyBmcm9tIHRoZSBtYWluIHRocmVhZFxuICAgICAgICBpZiAoIW1lLml0ZW1SZWN0cyB8fCAhbWUuYm91bmRhcnlDb250YWluZXJSZWN0IHx8IG1lLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHN1cGVyLm9uRHJhZ01vdmUoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uUmVtb3RlRHJhZ0xlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNSZW1vdGVEcmFnZ2luZykge1xuICAgICAgICAgICAgbWUuaXNSZW1vdGVEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgYXdhaXQgbWUub25EcmFnRW5kKHt9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvblJlbW90ZURyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzUmVtb3RlRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnN0YXJ0UmVtb3RlRHJhZyhkYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsZWdhdGUgdG8gc3RhbmRhcmQgb25EcmFnTW92ZSBsb2dpYywgd2hpY2ggdXBkYXRlcyB0aGUgcHJveHlcbiAgICAgICAgbWUub25EcmFnTW92ZSh7XG4gICAgICAgICAgICBjbGllbnRYICA6IGRhdGEubG9jYWxYLFxuICAgICAgICAgICAgY2xpZW50WSAgOiBkYXRhLmxvY2FsWSxcbiAgICAgICAgICAgIHByb3h5UmVjdDogZGF0YS5wcm94eVJlY3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZHJhZ01vdmUoe1xuICAgICAgICAgICAgY2xpZW50WDogZGF0YS5sb2NhbFgsXG4gICAgICAgICAgICBjbGllbnRZOiBkYXRhLmxvY2FsWVxuICAgICAgICB9LCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkcmFnZ2VkSXRlbVxuICAgICAqL1xuICAgIGFzeW5jIG9uUmVtb3RlRHJvcChkcmFnZ2VkSXRlbSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaW5kZXggPSBtZS5jdXJyZW50SW5kZXg7XG5cbiAgICAgICAgLy8gRW5zdXJlIHdlIGFyZSBpbiByZW1vdGUgZHJhZyBtb2RlXG4gICAgICAgIGlmIChtZS5pc1JlbW90ZURyYWdnaW5nKSB7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIHBsYWNlaG9sZGVyIGJ1dCBrZWVwIGxheW91dCByZWFkeVxuICAgICAgICAgICAgYXdhaXQgbWUub25EcmFnRW5kKHt9KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gb2xkIHBhcmVudCAoaWYgbm90IGFscmVhZHkgZGV0YWNoZWQpXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9IGRyYWdnZWRJdGVtLnBhcmVudElkO1xuICAgICAgICAgICAgaWYgKHBhcmVudElkICYmIHBhcmVudElkICE9PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkKT8ucmVtb3ZlKGRyYWdnZWRJdGVtLCBmYWxzZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5zZXJ0IGludG8gbmV3IG93bmVyXG4gICAgICAgICAgICBtZS5vd25lci5pbnNlcnQoaW5kZXgsIGRyYWdnZWRJdGVtKTtcblxuICAgICAgICAgICAgbWUuaXNSZW1vdGVEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZHJhZ2dlZEl0ZW1cbiAgICAgKi9cbiAgICBvblJlbW90ZURyb3BPdXQoZHJhZ2dlZEl0ZW0pIHtcbiAgICAgICAgLy8gQ2FsbGVkIG9uIHRoZSBzb3VyY2Ugc29ydCB6b25lIHdoZW4gYSBkcm9wIG9jY3VycmVkIGVsc2V3aGVyZS5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjbGVhbnVwIGFueSBkZXRhY2hlZCBzdGF0ZSB0cmFja2luZy5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub3duZXIuZGV0YWNoZWRJdGVtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWUub3duZXIuZGV0YWNoZWRJdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUud2lkZ2V0ID09PSBkcmFnZ2VkSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vd25lci5kZXRhY2hlZEl0ZW1zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd2luZG93IGlzIGFscmVhZHkgY2xvc2VkIGJ5IHN1c3BlbmRXaW5kb3dEcmFnLCBzbyB3ZSBqdXN0IGNsZWFuIHVwIHRoZSBtYXAuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGludGVyc2VjdGlvblJhdGlvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbldpbmRvd0RyYWdDb250aW51ZShpbnRlcnNlY3Rpb25SYXRpbywgZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIFNpZ25hbCBDb29yZGluYXRvclxuICAgICAgICBEcmFnQ29vcmRpbmF0b3Iub25EcmFnTW92ZSh7XG4gICAgICAgICAgICBkcmFnZ2VkSXRlbSAgIDogbWUuZHJhZ0NvbXBvbmVudCxcbiAgICAgICAgICAgIG9mZnNldFggICAgICAgOiBtZS5vZmZzZXRYLFxuICAgICAgICAgICAgb2Zmc2V0WSAgICAgICA6IG1lLm9mZnNldFksXG4gICAgICAgICAgICBwcm94eVJlY3QgICAgIDogZGF0YS5wcm94eVJlY3QsXG4gICAgICAgICAgICBzY3JlZW5YICAgICAgIDogZGF0YS5zY3JlZW5YLFxuICAgICAgICAgICAgc2NyZWVuWSAgICAgICA6IGRhdGEuc2NyZWVuWSxcbiAgICAgICAgICAgIHNvdXJjZVNvcnRab25lOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aWRnZXROYW1lXG4gICAgICogQHBhcmFtIHtET01SZWN0fSBwcm94eVJlY3RcbiAgICAgKi9cbiAgICByZXN1bWVXaW5kb3dEcmFnKHdpZGdldE5hbWUsIHByb3h5UmVjdCkge1xuICAgICAgICB0aGlzLm93bmVyLnJlc3VtZVdpbmRvd0RyYWcod2lkZ2V0TmFtZSwgcHJveHlSZWN0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkcmFnZ2VkSXRlbVxuICAgICAqL1xuICAgIGFzeW5jIHNldHVwRHJhZ1N0YXRlKGRyYWdnZWRJdGVtKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQsIG93bmVyfSA9IG1lLFxuICAgICAgICAgICAgaXRlbVN0eWxlcyAgICAgICAgICAgICAgICAgICAgICAgPSBtZS5pdGVtU3R5bGVzID0gW10sXG4gICAgICAgICAgICB7bGF5b3V0fSAgICAgICAgICAgICAgICAgICAgICAgICA9IG93bmVyLFxuICAgICAgICAgICAgb3duZXJTdHlsZSAgICAgICAgICAgICAgICAgICAgICAgPSBvd25lci5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGluZGV4LCBpbmRleE1hcCwgaXRlbVJlY3RzLCBzb3J0YWJsZUl0ZW1zO1xuXG4gICAgICAgIHNvcnRhYmxlSXRlbXMgPSBvd25lci5pdGVtcy5maWx0ZXIoaXRlbSA9PiAhaXRlbS5pc0Rlc3Ryb3llZCk7XG4gICAgICAgIGluZGV4ICAgICAgICAgPSBzb3J0YWJsZUl0ZW1zLmluZGV4T2YoZHJhZ2dlZEl0ZW0pO1xuXG4gICAgICAgIGluZGV4TWFwID0ge307XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgY3VycmVudEluZGV4ICAgICAgICAgICA6IGluZGV4LFxuICAgICAgICAgICAgZHJhZ0VsZW1lbnQgICAgICAgICAgICA6IFZEb21VdGlsLmZpbmQob3duZXIudmRvbSwgZHJhZ2dlZEl0ZW0uaWQpLnZkb20sXG4gICAgICAgICAgICBkcmFnUHJveHlDb25maWcgICAgICAgIDogbWUuZ2V0RHJhZ1Byb3h5Q29uZmlnKCksXG4gICAgICAgICAgICBpbmRleE1hcCxcbiAgICAgICAgICAgIG93bmVyU3R5bGUgICAgICAgICAgICAgOiB7aGVpZ2h0OiBvd25lclN0eWxlLmhlaWdodCwgbWluV2lkdGg6IG93bmVyU3R5bGUubWluV2lkdGgsIHdpZHRoOiBvd25lclN0eWxlLndpZHRofSxcbiAgICAgICAgICAgIHJldmVyc2VkTGF5b3V0RGlyZWN0aW9uOiBsYXlvdXQuZGlyZWN0aW9uID09PSAnY29sdW1uLXJldmVyc2UnIHx8IGxheW91dC5kaXJlY3Rpb24gPT09ICdyb3ctcmV2ZXJzZScsXG4gICAgICAgICAgICBzb3J0YWJsZUl0ZW1zLFxuICAgICAgICAgICAgc29ydERpcmVjdGlvbiAgICAgICAgICA6IGxheW91dC5kaXJlY3Rpb24/LmluY2x1ZGVzKCdjb2x1bW4nKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICBzdGFydEluZGV4ICAgICAgICAgICAgIDogaW5kZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZHJhZ0NvbXBvbmVudCA9IGRyYWdnZWRJdGVtO1xuXG4gICAgICAgIHNvcnRhYmxlSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBvd25lci5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICBpdGVtU3R5bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbS5oZWlnaHQgPyBgJHtpdGVtLmhlaWdodH1weGAgOiAgaXRlbS5zdHlsZT8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbS53aWR0aCAgPyBgJHtpdGVtLndpZHRofXB4YCAgOiAgaXRlbS5zdHlsZT8ud2lkdGhcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW1SZWN0cyA9IGF3YWl0IG93bmVyLmdldERvbVJlY3QoW293bmVyLmlkXS5jb25jYXQoc29ydGFibGVJdGVtcy5tYXAoZSA9PiBlLmlkKSkpO1xuXG4gICAgICAgIGl0ZW1SZWN0cy5mb3JFYWNoKHJlY3QgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2l0ZW1SZWN0Jywge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgOiBgJHtyZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgbGVmdCAgICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgdG9wICAgICA6IGAke3JlY3QudG9wfXB4YCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgIDogYCR7cmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZS5vd25lclJlY3QgPSBpdGVtUmVjdHMuc2hpZnQoKTtcbiAgICAgICAgbWUuYm91bmRhcnlDb250YWluZXJSZWN0ID0gbWUub3duZXJSZWN0O1xuXG4gICAgICAgIG93bmVyLnN0eWxlID0ge1xuICAgICAgICAgICAgLi4ub3duZXJTdHlsZSxcbiAgICAgICAgICAgIGhlaWdodCAgOiBgJHttZS5vd25lclJlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBgJHttZS5vd25lclJlY3Qud2lkdGh9cHhgLFxuICAgICAgICAgICAgd2lkdGggICA6IGAke21lLm93bmVyUmVjdC53aWR0aH1weGBcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZygnYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQnLCBhZGp1c3RJdGVtUmVjdHNUb1BhcmVudCk7XG5cbiAgICAgICAgYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgJiYgaXRlbVJlY3RzLmZvckVhY2gocmVjdCA9PiB7XG4gICAgICAgICAgICByZWN0LnggLT0gbWUub3duZXJSZWN0Lng7XG4gICAgICAgICAgICByZWN0LnkgLT0gbWUub3duZXJSZWN0LnlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaXRlbVJlY3RzID0gaXRlbVJlY3RzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBzdGFydFJlbW90ZURyYWcoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSAgICAgPSBtZSxcbiAgICAgICAgICAgIHtwcm94eVJlY3R9ID0gZGF0YSxcbiAgICAgICAgICAgIGRyYWdnZWRJdGVtID0gZGF0YS5kcmFnZ2VkSXRlbSxcbiAgICAgICAgICAgIGNvbmZpZztcblxuICAgICAgICBtZS5pc1JlbW90ZURyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBNb2NrIHRoZSBkcmFnIGVsZW1lbnQgcmVjdCBmb3IgRHJhZ1pvbmUgbG9naWMgaWYgbmVlZGVkXG4gICAgICAgIG1lLmRyYWdFbGVtZW50UmVjdCA9IHtcbiAgICAgICAgICAgIGhlaWdodDogcHJveHlSZWN0LmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoIDogcHJveHlSZWN0LndpZHRoLFxuICAgICAgICAgICAgeCAgICAgOiBkYXRhLmxvY2FsWCxcbiAgICAgICAgICAgIHkgICAgIDogZGF0YS5sb2NhbFksXG4gICAgICAgICAgICBsZWZ0ICA6IGRhdGEubG9jYWxYLFxuICAgICAgICAgICAgdG9wICAgOiBkYXRhLmxvY2FsWVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSBkcmFnZ2VkIGl0ZW0gdG8gdGFyZ2V0IGFwcCBjb250ZXh0XG4gICAgICAgIGRyYWdnZWRJdGVtLmFwcE5hbWUgPSBtZS5hcHBOYW1lO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdzdGFydFJlbW90ZURyYWcnLCBkcmFnZ2VkSXRlbS5pZCwgZHJhZ2dlZEl0ZW0ud2luZG93SWQsIGRyYWdnZWRJdGVtLnBhcmVudElkLCBkcmFnZ2VkSXRlbS5wYXJlbnRDb21wb25lbnQpO1xuXG4gICAgICAgIC8vIEJyZWFrIHRoZSBwYXJlbnQgY2hhaW4gdG8gcHJldmVudCBjaXJjdWxhciBjb25maWcgbG9va3VwcyBkdXJpbmcgaGFuZG92ZXJcbiAgICAgICAgZHJhZ2dlZEl0ZW0ucGFyZW50SWQgICAgICAgID0gbnVsbDtcbiAgICAgICAgZHJhZ2dlZEl0ZW0ucGFyZW50Q29tcG9uZW50ID0gbnVsbDtcblxuICAgICAgICAvLyBTaW5jZSB0aGUgY29tcG9uZW50IHdhcyBtb3VudGVkIGluIGEgZGlmZmVyZW50IHdpbmRvdywgd2UgbmVlZCB0byByZXNldCB0aGUgc3RhdGVcbiAgICAgICAgZHJhZ2dlZEl0ZW0ubW91bnRlZCAgICAgICAgICA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2VkSXRlbS52bm9kZSAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgZHJhZ2dlZEl0ZW0udm5vZGVJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdwYXJlbnQgY2xlYXJlZDonLCBkcmFnZ2VkSXRlbS5wYXJlbnRJZCwgZHJhZ2dlZEl0ZW0ucGFyZW50Q29tcG9uZW50KTtcblxuICAgICAgICAvLyAxLiBHZXQgT3duZXIgUmVjdCAobmVlZGVkIGZvciBwcm94eSBwb3NpdGlvbmluZylcbiAgICAgICAgbGV0IHJlY3RzID0gYXdhaXQgb3duZXIuZ2V0RG9tUmVjdChbb3duZXIuaWRdKTtcbiAgICAgICAgbWUub3duZXJSZWN0ID0gcmVjdHNbMF07XG5cbiAgICAgICAgY29uc29sZS5sb2coJ293bmVyUmVjdCcsIG1lLm93bmVyUmVjdCk7XG5cbiAgICAgICAgLy8gQXNzaWduIHRoZSBkcmFnIG9mZnNldHMgdG8gdGhlIGluc3RhbmNlLCBzbyB0aGF0IHRoZSBEcmFnWm9uZSBvbkRyYWdNb3ZlIGxvZ2ljIHdvcmtzXG4gICAgICAgIG1lLm9mZnNldFggPSBkYXRhLm9mZnNldFg7XG4gICAgICAgIG1lLm9mZnNldFkgPSBkYXRhLm9mZnNldFk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ3N0YXJ0UmVtb3RlRHJhZzogb3duZXJSZWN0JywgbWUub3duZXJSZWN0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3N0YXJ0UmVtb3RlRHJhZzogbG9jYWwgY29vcmRzJywgZGF0YS5sb2NhbFgsIGRhdGEubG9jYWxZKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3N0YXJ0UmVtb3RlRHJhZzogY2FsY3VsYXRlZCBjb29yZHMnLCBkYXRhLmxvY2FsWCAtIG1lLm9mZnNldFgsIGRhdGEubG9jYWxZIC0gbWUub2Zmc2V0WSk7XG5cbiAgICAgICAgLy8gMi4gQ3JlYXRlIGEgbG9jYWwgRHJhZ1Byb3h5IG1hbnVhbGx5ICh1c2luZyBEcmFnUHJveHlDb250YWluZXIgdG8gaG9sZCB0aGUgbGl2ZSB3aWRnZXQpXG4gICAgICAgIC8vIFdlIHVzZSBEcmFnUHJveHlDb250YWluZXIgdG8gZW5zdXJlIHRoZSB3aWRnZXQgcmVtYWlucyBhY3RpdmUvY29ubmVjdGVkLlxuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgICAgOiBEcmFnUHJveHlDb250YWluZXIsXG4gICAgICAgICAgICBhcHBOYW1lICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgY2xzICAgICAgICAgICAgIDogWyduZW8tZHJhZ3Byb3h5JywgLi4ubWUub3duZXIuY2xzXSxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgICAgICA6IFtkcmFnZ2VkSXRlbV0sXG4gICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBmYWxzZSxcbiAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICA6IG1lLndpbmRvd0lkLFxuXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGAke2RhdGEubG9jYWxYIC0gbWUub2Zmc2V0WH1weGAsXG4gICAgICAgICAgICAgICAgdG9wIDogYCR7ZGF0YS5sb2NhbFkgLSBtZS5vZmZzZXRZfXB4YFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBsb2NhbCBkcmFnIHByb3h5JywgY29uZmlnKTtcblxuICAgICAgICBtZS5kcmFnUHJveHkgPSBOZW8uY3JlYXRlKGNvbmZpZyk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgbG9jYWwgZHJhZyBwcm94eScsIG1lLmRyYWdQcm94eSk7XG5cbiAgICAgICAgLy8gMy4gQ3JlYXRlIFBsYWNlaG9sZGVyXG4gICAgICAgIG1lLmRyYWdQbGFjZWhvbGRlciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBmbGV4ICA6ICdub25lJyxcbiAgICAgICAgICAgIHN0eWxlIDoge2hlaWdodDogYCR7cHJveHlSZWN0LmhlaWdodH1weGAsIHZpc2liaWxpdHk6ICdoaWRkZW4nfVxuICAgICAgICB9KTtcblxuICAgICAgICBvd25lci5hZGQobWUuZHJhZ1BsYWNlaG9sZGVyKTtcblxuICAgICAgICAvLyA0LiBTZXR1cCBTb3J0IFN0YXRlXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoNTApO1xuICAgICAgICBhd2FpdCBtZS5zZXR1cERyYWdTdGF0ZShtZS5kcmFnUGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBwcm94eSBzaXplIHRvIG1hdGNoIHRoZSBtZWFzdXJlZCBwbGFjZWhvbGRlclxuICAgICAgICBsZXQgcGxhY2Vob2xkZXJJbmRleCA9IG1lLnNvcnRhYmxlSXRlbXMuaW5kZXhPZihtZS5kcmFnUGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGlmIChwbGFjZWhvbGRlckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gbWUuaXRlbVJlY3RzW3BsYWNlaG9sZGVySW5kZXhdO1xuICAgICAgICAgICAgbWUuZHJhZ1Byb3h5LndpZHRoICA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICBtZS5kcmFnUHJveHkuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUwKTtcbiAgICAgICAgLy8gNS4gQXBwbHkgQWJzb2x1dGUgUG9zaXRpb25pbmdcbiAgICAgICAgbWUuYXBwbHlBYnNvbHV0ZVBvc2l0aW9uaW5nKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBkcmFnIG1vdmUgZXZlbnQuIFRoaXMgaXMgdGhlIGNvcmUgbG9naWMgbG9vcCBmb3IgdGhlIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogUmVzcG9uc2liaWxpdGllczpcbiAgICAgKiAxLiAgKipXaW5kb3cgRHJhZyBSZS1lbnRyeToqKiBDaGVja3MgaWYgYSB3aW5kb3cgZHJhZyBoYXMgcmUtZW50ZXJlZCB0aGUgb3JpZ2luYWwgY29udGFpbmVyIGJvdW5kYXJpZXMuXG4gICAgICogICAgIElmIHNvLCBpdCByZXN0b3JlcyB0aGUgb3JpZ2luYWwgbGF5b3V0IHNuYXBzaG90IChgaXRlbVJlY3RzYCkgYW5kIHNob3dzIHRoZSBwbGFjZWhvbGRlciwgZWZmZWN0aXZlbHlcbiAgICAgKiAgICAgXCJzbmFwcGluZ1wiIHRoZSBkYXNoYm9hcmQgYmFjayB0byBpdHMgc29ydGFibGUgc3RhdGUuXG4gICAgICogMi4gICoqV2luZG93IERyYWcgRXhpdDoqKiBEZXRlY3RzIGlmIHRoZSBkcmFnIHByb3h5IGhhcyBsZWZ0IHRoZSBjb250YWluZXIgYm91bmRhcmllcyAoaWYgYGVuYWJsZVByb3h5VG9Qb3B1cGAgaXMgdHJ1ZSlcbiAgICAgKiAgICAgYW5kIHRyaWdnZXJzIHRoZSBgZHJhZ0JvdW5kYXJ5RXhpdGAgZXZlbnQgdG8gcG90ZW50aWFsbHkgc3RhcnQgYSB3aW5kb3cgZHJhZy5cbiAgICAgKiAzLiAgKipTdGFuZGFyZCBTb3J0aW5nOioqIElmIG5vdCBpbiB3aW5kb3ctZHJhZyBtb2RlLCBpdCBjYWxjdWxhdGVzIHRoZSBkcmFnIGRlbHRhIGFuZCBzd2FwcyBpdGVtcyAoYHN3aXRjaEl0ZW1zYClcbiAgICAgKiAgICAgaWYgdGhlIHRocmVzaG9sZCBpcyBjcm9zc2VkLCB1cGRhdGluZyB0aGUgYGN1cnJlbnRJbmRleGAuXG4gICAgICogNC4gICoqQXV0by1TY3JvbGxpbmc6KiogTWFuYWdlcyBhdXRvLXNjcm9sbGluZyB3aGVuIGRyYWdnaW5nIG5lYXIgdGhlIGVkZ2VzIG9mIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkcmFnIG1vdmUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBzdGFydFdpbmRvd0RyYWcoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge3BvcHVwSGVpZ2h0LCBwb3B1cFdpZHRoLCB3aW5kb3dOYW1lfSA9IGRhdGE7XG5cbiAgICAgICAgLy8gS2VlcCB0aGUgcHJveHkgYWN0aXZlIHRvIGNhcHR1cmUgbW91c2UgZXZlbnRzLCBidXQgbWFrZSBpdCBpbnZpc2libGVcbiAgICAgICAgbWUuZHJhZ1Byb3h5LnN0eWxlID0ge29wYWNpdHk6IDB9O1xuICAgICAgICBtZS5pc1dpbmRvd0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAobWUuZHJhZ1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBtZS5kcmFnUGxhY2Vob2xkZXIud3JhcHBlclN0eWxlID0ge1xuICAgICAgICAgICAgICAgIC4uLm1lLmRyYWdQbGFjZWhvbGRlci53cmFwcGVyU3R5bGUsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IGV4cGFuZGVkIGxheW91dFxuICAgICAgICBsZXQgZXhwYW5kZWRMYXlvdXQgPSBtZS5jYWxjdWxhdGVFeHBhbmRlZExheW91dCgpO1xuICAgICAgICBleHBhbmRlZExheW91dC5mb3JFYWNoKCh7aXRlbSwgc3R5bGV9KSA9PiB7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHsuLi5pdGVtLndyYXBwZXJTdHlsZSwgLi4uc3R5bGV9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnN0YXJ0V2luZG93RHJhZyh7XG4gICAgICAgICAgICBwb3B1cEhlaWdodCxcbiAgICAgICAgICAgIHBvcHVwTmFtZTogd2luZG93TmFtZSxcbiAgICAgICAgICAgIHBvcHVwV2lkdGgsXG4gICAgICAgICAgICB3aW5kb3dJZCA6IG1lLndpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdpZGdldE5hbWVcbiAgICAgKi9cbiAgICBzdXNwZW5kV2luZG93RHJhZyh3aWRnZXROYW1lKSB7XG4gICAgICAgIHRoaXMub3duZXIuc3VzcGVuZFdpbmRvd0RyYWcod2lkZ2V0TmFtZSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERhc2hib2FyZFNvcnRab25lKTtcbiIsImltcG9ydCBNYW5hZ2VyICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4uL3V0aWwvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgV2luZG93ICAgIGZyb20gJy4vV2luZG93Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLkRyYWdDb29yZGluYXRvclxuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBEcmFnQ29vcmRpbmF0b3IgZXh0ZW5kcyBNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLkRyYWdDb29yZGluYXRvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuRHJhZ0Nvb3JkaW5hdG9yJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge01hcH0gc29ydFpvbmVzPW5ldyBNYXAoKVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZXM6IG5ldyBNYXAoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lfG51bGx9IGFjdGl2ZVRhcmdldFpvbmU9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhY3RpdmVUYXJnZXRab25lID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZX0gc291cmNlU29ydFpvbmVcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZHJhZ2dlZEl0ZW1cbiAgICAgKiBAcGFyYW0ge0RPTVJlY3R9IHByb3h5UmVjdFxuICAgICAqL1xuICAgIGhhbmRsZVZvaWQoc291cmNlU29ydFpvbmUsIGRyYWdnZWRJdGVtLCBwcm94eVJlY3QpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuYWN0aXZlVGFyZ2V0Wm9uZSkge1xuICAgICAgICAgICAgbWUuYWN0aXZlVGFyZ2V0Wm9uZS5vblJlbW90ZURyYWdMZWF2ZSgpO1xuICAgICAgICAgICAgbWUuYWN0aXZlVGFyZ2V0Wm9uZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIFJlc3VtZSBzb3VyY2UgZHJhZyAocmUtb3BlbiBwb3B1cClcbiAgICAgICAgICAgIHNvdXJjZVNvcnRab25lLnJlc3VtZVdpbmRvd0RyYWcoZHJhZ2dlZEl0ZW0ucmVmZXJlbmNlIHx8IGRyYWdnZWRJdGVtLmlkLCBwcm94eVJlY3QpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkYXRhLmRyYWdnZWRJdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEub2Zmc2V0WFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm9mZnNldFlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JlZW5YXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyZWVuWVxuICAgICAqIEBwYXJhbSB7TmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmV9IGRhdGEuc291cmNlU29ydFpvbmVcbiAgICAgKi9cbiAgICBvbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtkcmFnZ2VkSXRlbSwgb2Zmc2V0WCwgb2Zmc2V0WSwgcHJveHlSZWN0LCBzY3JlZW5YLCBzY3JlZW5ZLCBzb3VyY2VTb3J0Wm9uZX0gPSBkYXRhLFxuICAgICAgICAgICAge3NvcnRHcm91cH0gICAgPSBzb3VyY2VTb3J0Wm9uZSxcbiAgICAgICAgICAgIHRhcmdldFdpbmRvd0lkID0gV2luZG93LmdldFdpbmRvd0F0KHNjcmVlblgsIHNjcmVlblkpLFxuICAgICAgICAgICAgdGFyZ2V0U29ydFpvbmU7XG5cbiAgICAgICAgaWYgKHRhcmdldFdpbmRvd0lkICYmIHRhcmdldFdpbmRvd0lkICE9PSBzb3VyY2VTb3J0Wm9uZS53aW5kb3dJZCkge1xuICAgICAgICAgICAgdGFyZ2V0U29ydFpvbmUgPSBtZS5zb3J0Wm9uZXMuZ2V0KHNvcnRHcm91cCk/LmdldCh0YXJnZXRXaW5kb3dJZCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRTb3J0Wm9uZSkge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRXaW5kb3cgPSBXaW5kb3cuZ2V0KHRhcmdldFdpbmRvd0lkKSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxYICAgICAgID0gc2NyZWVuWCAtIHRhcmdldFdpbmRvdy5pbm5lclJlY3QueCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxZICAgICAgID0gc2NyZWVuWSAtIHRhcmdldFdpbmRvdy5pbm5lclJlY3QueSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJveHlSZWN0ID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsWCAtIG9mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFkgLSBvZmZzZXRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlSZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlSZWN0LmhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFNvcnRab25lLmFjY2VwdHNSZW1vdGVEcmFnKGxvY2FsWCwgbG9jYWxZKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRHJhZ0Nvb3JkaW5hdG9yIHRhcmdldCBmb3VuZCcsIHt0YXJnZXRXaW5kb3dJZCwgbG9jYWxYLCBsb2NhbFl9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnRlcmluZyBhIG5ldyB0YXJnZXQgem9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuYWN0aXZlVGFyZ2V0Wm9uZSAhPT0gdGFyZ2V0U29ydFpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlYXZpbmcgcHJldmlvdXMgdGFyZ2V0IChpZiBhbnkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5hY3RpdmVUYXJnZXRab25lPy5vblJlbW90ZURyYWdMZWF2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXNwZW5kIHNvdXJjZSBkcmFnIChjbG9zZSBwb3B1cCwgZXRjKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBkbyB0aGlzIG9uY2Ugd2hlbiBsZWF2aW5nIHRoZSB2b2lkL3NvdXJjZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLmFjdGl2ZVRhcmdldFpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTb3J0Wm9uZS5zdXNwZW5kV2luZG93RHJhZyhkcmFnZ2VkSXRlbS5yZWZlcmVuY2UgfHwgZHJhZ2dlZEl0ZW0uaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmFjdGl2ZVRhcmdldFpvbmUgPSB0YXJnZXRTb3J0Wm9uZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U29ydFpvbmUub25SZW1vdGVEcmFnTW92ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlSZWN0OiB0YXJnZXRQcm94eVJlY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gdm9pZCBvciBiYWNrIGluIHNvdXJjZSB3aW5kb3dcbiAgICAgICAgbWUuaGFuZGxlVm9pZChzb3VyY2VTb3J0Wm9uZSwgZHJhZ2dlZEl0ZW0sIHByb3h5UmVjdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmV9IGRhdGEuc291cmNlU29ydFpvbmVcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5hY3RpdmVUYXJnZXRab25lKSB7XG4gICAgICAgICAgICAvLyBEcm9wIG9uIHRhcmdldFxuICAgICAgICAgICAgbWUuYWN0aXZlVGFyZ2V0Wm9uZS5vblJlbW90ZURyb3AoZGF0YS5kcmFnZ2VkSXRlbSk7XG5cbiAgICAgICAgICAgIC8vIE5vdGlmeSBzb3VyY2UgdG8gZmluYWxpemUgY2xlYW51cFxuICAgICAgICAgICAgZGF0YS5zb3VyY2VTb3J0Wm9uZS5vblJlbW90ZURyb3BPdXQoZGF0YS5kcmFnZ2VkSXRlbSk7XG5cbiAgICAgICAgICAgIG1lLmFjdGl2ZVRhcmdldFpvbmUgPSBudWxsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEcmFnIGVuZGVkIGluIHZvaWQgb3Igc291cmNlIHdpbmRvdyAoaGFuZGxlZCBsb2NhbGx5IGJ5IHNvdXJjZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmV9IHNvcnRab25lXG4gICAgICovXG4gICAgcmVnaXN0ZXIoc29ydFpvbmUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c29ydEdyb3VwLCB3aW5kb3dJZH0gPSBzb3J0Wm9uZTtcblxuICAgICAgICBpZiAoc29ydEdyb3VwKSB7XG4gICAgICAgICAgICBpZiAoIW1lLnNvcnRab25lcy5oYXMoc29ydEdyb3VwKSkge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lcy5zZXQoc29ydEdyb3VwLCBuZXcgTWFwKCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnNvcnRab25lcy5nZXQoc29ydEdyb3VwKS5zZXQod2luZG93SWQsIHNvcnRab25lKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZX0gc29ydFpvbmVcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKHNvcnRab25lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3NvcnRHcm91cCwgd2luZG93SWR9ID0gc29ydFpvbmU7XG5cbiAgICAgICAgaWYgKHNvcnRHcm91cCAmJiBtZS5zb3J0Wm9uZXMuaGFzKHNvcnRHcm91cCkpIHtcbiAgICAgICAgICAgIGxldCBncm91cCA9IG1lLnNvcnRab25lcy5nZXQoc29ydEdyb3VwKTtcbiAgICAgICAgICAgIGdyb3VwLmRlbGV0ZSh3aW5kb3dJZCk7XG5cbiAgICAgICAgICAgIGlmIChncm91cC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUuc29ydFpvbmVzLmRlbGV0ZShzb3J0R3JvdXApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xhc3NOYW1lICAgICAgIDogbWUuY2xhc3NOYW1lLFxuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0Wm9uZTogbWUuYWN0aXZlVGFyZ2V0Wm9uZSA/IHtcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmFjdGl2ZVRhcmdldFpvbmUuaWQsXG4gICAgICAgICAgICAgICAgc29ydEdyb3VwOiBtZS5hY3RpdmVUYXJnZXRab25lLnNvcnRHcm91cCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCA6IG1lLmFjdGl2ZVRhcmdldFpvbmUud2luZG93SWRcbiAgICAgICAgICAgIH0gOiBudWxsLFxuICAgICAgICAgICAgc29ydFpvbmVzOiBBcnJheS5mcm9tKG1lLnNvcnRab25lcy5lbnRyaWVzKCkpLm1hcCgoW2dyb3VwLCBtYXBdKSA9PiAoe1xuICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgIHdpbmRvd3M6IEFycmF5LmZyb20obWFwLmtleXMoKSlcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEcmFnQ29vcmRpbmF0b3IpO1xuIiwiaW1wb3J0IE1hbmFnZXIgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBUaGUgXCJHb2QgVmlld1wiIGZvciB0aGUgbXVsdGktd2luZG93IGFwcGxpY2F0aW9uIHdvcmtzcGFjZS5cbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1hbmFnZXIgbWFpbnRhaW5zIGEgcmVhbC10aW1lIGdlb21ldHJpYyBtYXAgb2YgYWxsIGNvbm5lY3RlZCBicm93c2VyIHdpbmRvd3MgaW4gdGhlIEFwcCBXb3JrZXIuXG4gKiBJdCBpcyB0aGUgY2VudHJhbCBhdXRob3JpdHkgZm9yIHNwYXRpYWwgYXdhcmVuZXNzLCBlbmFibGluZyBmZWF0dXJlcyBsaWtlIHRoZSBcIkluZmluaXRlIENhbnZhc1wiIHdoZXJlXG4gKiBpbnRlcmFjdGlvbnMgKGxpa2UgRHJhZyAmIERyb3ApIGNhbiBzcGFuIGFjcm9zcyBtdWx0aXBsZSBPUy1sZXZlbCB3aW5kb3dzLlxuICpcbiAqIEl0IHJlY2VpdmVzIGhpZ2gtZnJlcXVlbmN5IHBvc2l0aW9uIHVwZGF0ZXMgZnJvbSB0aGUgTWFpbiBUaHJlYWQgKHZpYSBgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb25gKVxuICogYW5kIHByb3ZpZGVzIGludGVyc2VjdGlvbiB0ZXN0aW5nIEFQSXMgdG8gZGV0ZXJtaW5lIHdoaWNoIHdpbmRvdyBpcyB1bmRlciBhIGdpdmVuIHNjcmVlbiBjb29yZGluYXRlLlxuICpcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5XaW5kb3dcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqIEBzZWUgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb25cbiAqL1xuY2xhc3MgV2luZG93IGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5XaW5kb3cnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLldpbmRvdycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1NhZmFyaVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1NhZmFyaTogL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIub24oe1xuICAgICAgICAgICAgY29ubmVjdCAgIDogbWUub25XaW5kb3dDb25uZWN0LFxuICAgICAgICAgICAgZGlzY29ubmVjdDogbWUub25XaW5kb3dEaXNjb25uZWN0LFxuICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aW5kb3dJZCB3aGljaCBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIGdsb2JhbCBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBpcyB0aGUgY29yZSBpbnRlcnNlY3Rpb24gdGVzdCBmb3IgY3Jvc3Mtd2luZG93IGRyYWcgYW5kIGRyb3Agb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBTY3JlZW4gWCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgU2NyZWVuIFkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gVGhlIHdpbmRvd0lkIG9mIHRoZSB0YXJnZXQgd2luZG93LCBvciBudWxsIGlmIG5vIGludGVyc2VjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRXaW5kb3dBdCh4LCB5KSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5vdXRlclJlY3Q/LmludGVyc2VjdHMoe2JvdHRvbTogeSwgcmlnaHQ6IHgsIHgsIHl9KSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlkIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH0ge2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9XG4gICAgICovXG4gICAgY2FsY3VsYXRlR2VvbWV0cnkoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAge2lubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBtb3pJbm5lclNjcmVlblgsIG1veklubmVyU2NyZWVuWSwgb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGgsIHNjcmVlbkxlZnQsIHNjcmVlblRvcH0gPSBkYXRhLFxuICAgICAgICAgICAgd2lkdGhEaWZmICAgID0gb3V0ZXJXaWR0aCAgLSBpbm5lcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0RGlmZiAgID0gb3V0ZXJIZWlnaHQgLSBpbm5lckhlaWdodCxcbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IFNpZGUgYm9yZGVycyBhcmUgc3ltbWV0cmljXG4gICAgICAgICAgICBzaWRlQm9yZGVyICAgPSB3aWR0aERpZmYgLyAyLFxuICAgICAgICAgICAgLy8gQXNzdW1wdGlvbjogQm90dG9tIGJvcmRlciBtYXRjaGVzIHNpZGUgYm9yZGVyIChjb21tb24gaW4gV2luZG93cylcbiAgICAgICAgICAgIGJvdHRvbUJvcmRlciA9IHNpZGVCb3JkZXIsXG4gICAgICAgICAgICAvLyBUaGUgcmVzdCBpcyB0aGUgdG9wIGNocm9tZSAoaGVhZGVyKVxuICAgICAgICAgICAgdG9wQ2hyb21lICAgID0gaGVpZ2h0RGlmZiAtIGJvdHRvbUJvcmRlcjtcblxuICAgICAgICBjb25zdCBjaHJvbWUgPSB7XG4gICAgICAgICAgICBib3R0b206IGJvdHRvbUJvcmRlcixcbiAgICAgICAgICAgIGxlZnQgIDogc2lkZUJvcmRlcixcbiAgICAgICAgICAgIHJpZ2h0IDogc2lkZUJvcmRlcixcbiAgICAgICAgICAgIHRvcCAgIDogdG9wQ2hyb21lXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHZpZXdwb3J0TGVmdCwgdmlld3BvcnRUb3A7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb3pJbm5lclNjcmVlblggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94OiBleHBsaWNpdCB2aWV3cG9ydCBjb29yZGluYXRlc1xuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gbW96SW5uZXJTY3JlZW5YO1xuICAgICAgICAgICAgdmlld3BvcnRUb3AgID0gbW96SW5uZXJTY3JlZW5ZXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1NhZmFyaSkge1xuICAgICAgICAgICAgLy8gU2FmYXJpOiBzY3JlZW5MZWZ0L1RvcCBpcyBGcmFtZSBwb3NpdGlvbi4gQWRkIGNocm9tZSB0byBnZXQgVmlld3BvcnQuXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSBzY3JlZW5MZWZ0ICsgc2lkZUJvcmRlcjtcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICA9IHNjcmVlblRvcCAgKyB0b3BDaHJvbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZS9FZGdlOiBzY3JlZW5MZWZ0L1RvcCBpcyBWaWV3cG9ydCBwb3NpdGlvbi5cbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IHNjcmVlbkxlZnQ7XG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgPSBzY3JlZW5Ub3BcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlubmVyUmVjdCA9IG5ldyBSZWN0YW5nbGUodmlld3BvcnRMZWZ0LCB2aWV3cG9ydFRvcCwgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IG91dGVyUmVjdCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgLSBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgdmlld3BvcnRUb3AgIC0gdG9wQ2hyb21lLFxuICAgICAgICAgICAgb3V0ZXJXaWR0aCxcbiAgICAgICAgICAgIG91dGVySGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgbmV3IGJyb3dzZXIgd2luZG93IGNvbm5lY3RzIHRvIHRoZSBTaGFyZWRXb3JrZXIuXG4gICAgICogSW4gU2hhcmVkIFdvcmtlciBtb2RlLCBgTmVvLndvcmtlci5BcHAjb25Db25uZWN0YCBlbnN1cmVzIHRoYXQgYHdpbmRvd0RhdGFgXG4gICAgICogaXMgZmV0Y2hlZCBmcm9tIHRoZSBNYWluIFRocmVhZCBhbmQgaW5jbHVkZWQgaW4gdGhlIHBheWxvYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhLndpbmRvd0RhdGFdIENvbnRhaW5zIGdlb21ldHJ5IGRhdGEgKHNjcmVlbkxlZnQsIGlubmVySGVpZ2h0LCBldGMuKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25XaW5kb3dDb25uZWN0KHthcHBOYW1lLCB3aW5kb3dEYXRhLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IGNocm9tZSAgICA9IG51bGwsXG4gICAgICAgICAgICBpbm5lclJlY3QgPSBudWxsLFxuICAgICAgICAgICAgb3V0ZXJSZWN0ID0gbnVsbDtcblxuICAgICAgICBpZiAod2luZG93RGF0YSkge1xuICAgICAgICAgICAgKHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSA9IHRoaXMuY2FsY3VsYXRlR2VvbWV0cnkod2luZG93RGF0YSkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnV2luZG93Lm9uV2luZG93Q29ubmVjdCcsIHt3aW5kb3dJZCwgYXBwTmFtZSwgY2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH0pO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoe2FwcE5hbWUsIGNocm9tZSwgaWQ6IHdpbmRvd0lkLCBpbm5lclJlY3QsIG91dGVyUmVjdH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd0Rpc2Nvbm5lY3Qoe3dpbmRvd0lkfSkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIod2luZG93SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2VvbWV0cmljIHN0YXRlIG9mIGEgd2luZG93IGJhc2VkIG9uIGRhdGEgZnJvbSB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHZpYSBkaXJlY3QgZGVsZWdhdGlvbiBmcm9tIHRoZSBBcHAgV29ya2VyIHRvIG1pbmltaXplIG92ZXJoZWFkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaW5uZXJIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vdXRlckhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm91dGVyV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JlZW5MZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyZWVuVG9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd1Bvc2l0aW9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLmdldChkYXRhLndpbmRvd0lkKSxcbiAgICAgICAgICAgIHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSA9IG1lLmNhbGN1bGF0ZUdlb21ldHJ5KGRhdGEpO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmNocm9tZSAgICA9IGNocm9tZTtcbiAgICAgICAgICAgIGl0ZW0uaW5uZXJSZWN0ID0gaW5uZXJSZWN0O1xuICAgICAgICAgICAgaXRlbS5vdXRlclJlY3QgPSBvdXRlclJlY3RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBjaHJvbWUsXG4gICAgICAgICAgICAgICAgaWQ6IGRhdGEud2luZG93SWQsXG4gICAgICAgICAgICAgICAgaW5uZXJSZWN0LFxuICAgICAgICAgICAgICAgIG91dGVyUmVjdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHdpbmRvd3MgIDogdGhpcy5pdGVtcy5tYXAod2luID0+ICh7XG4gICAgICAgICAgICAgICAgaWQgICAgICAgOiB3aW4uaWQsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgOiB3aW4uYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjaHJvbWUgICA6IHdpbi5jaHJvbWUsXG4gICAgICAgICAgICAgICAgaW5uZXJSZWN0OiB3aW4uaW5uZXJSZWN0LFxuICAgICAgICAgICAgICAgIG91dGVyUmVjdDogd2luLm91dGVyUmVjdFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFdpbmRvdyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9