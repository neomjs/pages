export const __webpack_esm_id__ = "vendors-src_ai_Client_mjs";
export const __webpack_esm_ids__ = ["vendors-src_ai_Client_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/ai/Client.mjs"
/*!***************************!*\
  !*** ./src/ai/Client.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _client_ComponentService_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./client/ComponentService.mjs */ "./src/ai/client/ComponentService.mjs");
/* harmony import */ var _client_DataService_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/DataService.mjs */ "./src/ai/client/DataService.mjs");
/* harmony import */ var _client_InstanceService_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/InstanceService.mjs */ "./src/ai/client/InstanceService.mjs");
/* harmony import */ var _client_InteractionService_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/InteractionService.mjs */ "./src/ai/client/InteractionService.mjs");
/* harmony import */ var _client_RuntimeService_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./client/RuntimeService.mjs */ "./src/ai/client/RuntimeService.mjs");
/* harmony import */ var _data_connection_WebSocket_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../data/connection/WebSocket.mjs */ "./src/data/connection/WebSocket.mjs");
/* harmony import */ var _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../manager/Window.mjs */ "./src/manager/Window.mjs");










/**
 * The AI Client establishes a WebSocket connection to the Neural Link MCP Server.
 * It acts as a bridge, enabling external AI agents to inspect and manipulate the running Neo.mjs application
 * via a standardized JSON-RPC protocol.
 * @class Neo.ai.Client
 * @extends Neo.core.Base
 * @singleton
 */
class Client extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.Client'
         * @protected
         */
        className: 'Neo.ai.Client',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * Add custom configs for data.connection.Websocket, or pass a module or instance.
         * @member {Object|Neo.data.connection.WebSocket|null} socket=null
         */
        socketConfig: null,
        /**
         * The URL of the Neural Link MCP Server's WebSocket endpoint.
         * @member {String} url='ws://127.0.0.1:8081'
         */
        url: 'ws://127.0.0.1:8081'
    }

    /**
     * @member {Boolean} isConnected=false
     * @protected
     */
    isConnected = false
    /**
     * Buffer for console logs generated before connection is established
     * @member {Array} logs=[]
     * @protected
     */
    logs = []
    /**
     * Map JSON-RPC method prefixes to service instances
     * @member {Object} serviceMap
     * @protected
     */
    serviceMap = null
    /**
     * @member {Object} services=null
     * @protected
     */
    services = null
    /**
     * @member {Neo.data.connection.WebSocket|null} socket=null
     * @protected
     */
    socket = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.services = {
            component  : Neo.create(_client_ComponentService_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],   {client: me}),
            data       : Neo.create(_client_DataService_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],        {client: me}),
            instance   : Neo.create(_client_InstanceService_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],    {client: me}),
            interaction: Neo.create(_client_InteractionService_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], {client: me}),
            runtime    : Neo.create(_client_RuntimeService_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],     {client: me})
        };

        const {component, data, instance, interaction, runtime} = me.services;

        me.serviceMap = {
            get_component         : component,
            get_computed_styles   : component,
            get_dom_rect          : component,
            get_vdom              : component,
            get_vdom_vnode        : component,
            get_vnode             : component,
            highlight_component   : component,
            query_component       : component,
            query_vdom            : component,
            set_component         : component,

            find_instances         : instance,
            get_instance_properties: instance,
            set_instance_properties: instance,

            get_record            : data,
            inspect_state_provider: data,
            inspect_store         : data,
            list_stores           : data,
            modify_state_provider : data,

            get_dom_event         : runtime,
            get_drag              : runtime,
            get_method_source     : runtime,
            get_route             : runtime,
            get_window            : runtime,
            inspect_class         : runtime,
            patch_code            : runtime,
            reload_page           : runtime,
            set_route             : runtime,
            simulate_event        : interaction
        };

        Neo.currentWorker.on({
            connect   : me.onAppWorkerWindowConnect,
            disconnect: me.onAppWorkerWindowDisconnect,
            scope     : me
        });

        me.connect()
    }

    /**
     * Establishes the WebSocket connection to the Neural Link MCP Server.
     * Uses Neo.data.connection.WebSocket for robust connection management.
     */
    connect() {
        let me = this;

        try {
            let url     = new URL(Neo.config.neuralLinkUrl || me.url),
                appName = 'Unknown App';

            if (Neo.config.appPath) {
                const match = Neo.config.appPath.match(/apps\/([^\/]+)\//);
                if (match) {
                    appName = match[1]
                }
            }

            url.searchParams.set('appWorkerId', Neo.worker.App.id);
            url.searchParams.set('appName', appName);

            me.socket = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(me.socketConfig, _data_connection_WebSocket_mjs__WEBPACK_IMPORTED_MODULE_7__["default"], {
                serverAddress: url.toString(),
                listeners    : {
                    close  : me.onSocketClose,
                    error  : me.onSocketError,
                    message: me.onSocketMessage,
                    open   : me.onSocketOpen,
                    scope  : me
                }
            })
        } catch (e) {
            console.error('Neo.ai.Client: Failed to create WebSocket connection', e)
        }
    }

    /**
     * Routes specific JSON-RPC methods to their corresponding implementation.
     * This method acts as the central dispatcher for all AI-driven commands.
     * @param {String} method The JSON-RPC method name
     * @param {Object} params The parameters associated with the method
     * @returns {Promise<*>} The result of the operation
     */
    async handleRequest(method, params) {
        let me      = this,
            service = null,
            prefix;

        // Find matching service based on prefix
        // e.g. "get_component_property" -> matches "get_component" prefix
        for (prefix in me.serviceMap) {
            if (method.startsWith(prefix)) {
                service = me.serviceMap[prefix];
                break
            }
        }

        const fnName = Neo.snakeToCamel(method);

        if (service) {
            const fn = service[fnName];

            if (Neo.isFunction(fn)) {
                return fn.call(service, params)
            } else if (Neo.isPromise(fn)) {
                return await fn.call(service, params)
            }
        }

        if (service && typeof service[fnName] === 'function') {
            return service[fnName](params)
        }

        throw new Error(`Unknown method: ${method}`);
    }

    /**
     * @param {Object} data
     */
    onAppWorkerWindowConnect(data) {
        if (this.isConnected) {
            const
                win = _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].get(data.windowId),
                {appName, windowId} = data;

            this.sendNotification('window_connected', {
                appName,
                chrome   : win?.chrome,
                innerRect: win?.innerRect,
                outerRect: win?.outerRect,
                windowId
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.windowId
     */
    onAppWorkerWindowDisconnect({windowId}) {
        if (this.isConnected) {
            this.sendNotification('window_disconnected', {windowId})
        }
    }

    /**
     * Handles incoming messages from the WebSocket.
     * Parses the JSON-RPC payload and delegates valid requests to `handleRequest`.
     * @param {Object} data
     */
    async onSocketMessage({data}) {
        if (data.method) {
            try {
                const result = await this.handleRequest(data.method, data.params);
                this.sendResponse(data.id, result)
            } catch (e) {
                console.error('Neo.ai.Client: Failed to handle message', e);
                this.sendError(data.id, e.message, e.stack)
            }
        }
    }

    /**
     * @param {Event} event
     */
    onSocketOpen(event) {
        console.log('Neo.ai.Client: Connected to MCP Server');
        this.isConnected = true;

        // Flush buffered logs
        if (this.logs.length > 0) {
            this.logs.forEach(log => {
                this.sendNotification('console_log', log)
            });
            this.logs.length = 0
        }

        const appWorker = Neo.worker.App;

        // 1. Register the worker
        this.socket.sendMessage({
            jsonrpc: '2.0',
            method : 'register',
            params : {
                appWorkerId   : appWorker.id,
                environment   : Neo.config.environment,
                isSharedWorker: appWorker.isSharedWorker,
                userAgent     : navigator.userAgent
            }
        });

        // 2. Rehydrate window topology
        _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].items.forEach(win => {
            this.sendNotification('window_connected', {
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect,
                windowId : win.id
            })
        })

        // 3. Rehydrate drag state (if active)
        const dragCoordinator = Neo.manager?.DragCoordinator;

        if (dragCoordinator?.activeTargetZone) {
            this.sendNotification('drag_active', {
                sortGroup : dragCoordinator.activeTargetZone.sortGroup,
                sourceZone: dragCoordinator.activeTargetZone.id
            })
        }
    }

    /**
     * @param {CloseEvent} event
     */
    onSocketClose(event) {
        console.log('Neo.ai.Client: Disconnected');
        this.isConnected = false
    }

    /**
     * @param {Event} event
     */
    onSocketError(event) {
        console.error('Neo.ai.Client: WebSocket Error', event)
    }

    /**
     * Sends a JSON-RPC error response
     * @param {Number|String} id
     * @param {String} message
     * @param {String} [stack]
     */
    sendError(id, message, stack) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                id,
                error: {
                    code   : -32603, // Internal error
                    message: message,
                    data   : {stack}
                }
            })
        }
    }

    /**
     * Sends a JSON-RPC notification (no id)
     * @param {String} method
     * @param {Object} params
     */
    sendNotification(method, params) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                method,
                params
            })
        }
    }

    /**
     * Sends a JSON-RPC response
     * @param {Number|String} id
     * @param {*} result
     */
    sendResponse(id, result) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                id,
                result
            })
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Client));


/***/ },

/***/ "./src/ai/client/ComponentService.mjs"
/*!********************************************!*\
  !*** ./src/ai/client/ComponentService.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");
/* harmony import */ var _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/vdom/TreeBuilder.mjs */ "./src/util/vdom/TreeBuilder.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * Handles component-related Neural Link requests.
 * @class Neo.ai.client.ComponentService
 * @extends Neo.ai.client.Service
 */
class ComponentService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.ComponentService'
         * @protected
         */
        className: 'Neo.ai.client.ComponentService'
    }

    /**
     * @param {Object}   params
     * @param {String}   params.componentId
     * @param {String[]} params.variables
     * @returns {Object}
     */
    async getComputedStyles({componentId, variables}) {
        const component = Neo.getComponent(componentId);

        if (!component) {
            throw new Error(`Component not found: ${componentId}`)
        }

        const styles = await Neo.main.DomAccess.getComputedStyle({
            id   : component.id,
            style: variables
        });

        return {styles}
    }

    /**
     * @param {Object}   params
     * @param {String[]} params.componentIds
     * @returns {Object}
     */
    async getDomRect({componentIds}) {
        if (!Array.isArray(componentIds) || componentIds.length === 0) {
            throw new Error('componentIds must be a non-empty array')
        }

        // Use the first component to resolve the windowId context
        const component = Neo.getComponent(componentIds[0]);

        if (!component) {
            throw new Error(`Component not found: ${componentIds[0]}`)
        }

        const rects = await component.getDomRect(componentIds);

        return {
            rects: Array.isArray(rects) ? rects : [rects]
        }
    }

    /**
     * @param {Object} params
     * @param {String} params.componentId
     * @param {Object} [params.options]
     * @returns {Object}
     */
    highlightComponent({componentId, options}) {
        let component = Neo.getComponent(componentId),
            originalStyle;

        if (!component) {
            throw new Error(`Component not found: ${componentId}`)
        }

        options = options || {};

        const
            color    = options.color    || 'red',
            duration = options.duration || 2000,
            mode     = options.style    || 'outline'; // 'outline' or 'box-shadow'

        originalStyle = component.style || {};

        let highlightStyle = {};

        if (mode === 'outline') {
            highlightStyle.outline       = `2px solid ${color}`;
            highlightStyle.outlineOffset = '-2px'
        } else {
            highlightStyle.boxShadow = `0 0 10px ${color}, inset 0 0 10px ${color}`
        }

        component.style = {...originalStyle, ...highlightStyle};

        this.timeout(duration).then(() => {
            component.style = originalStyle
        });

        return {success: true}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getComponentTree({depth, rootId}) {
        return {tree: this.serializeComponent(this.getComponentRoot(rootId), depth || -1)}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVdomTree({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {vdom: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVdomTree(component.vdom, depth)}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVnodeTree({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVnodeTree(component.vnode, depth)}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVdomVnode({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {
            vdom : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVdomTree(component.vdom, depth),
            vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVnodeTree(component.vnode, depth)
        }
    }

    /**
     * @param {Object}   params
     * @param {String}   [params.rootId]
     * @param {Object}   params.selector
     * @param {String[]} [params.returnProperties]
     * @returns {Object}
     */
    queryComponent({rootId, selector, returnProperties}) {
        let matches;

        if (rootId) {
            const component = Neo.getComponent(rootId);
            if (!component) throw new Error(`Root component not found: ${rootId}`);
            matches = component.down(selector, false)
        } else {
            matches = Neo.manager.Component.find(selector)
        }

        const components = matches.map(c => {
            if (Array.isArray(returnProperties) && returnProperties.length > 0) {
                const props = {};
                returnProperties.forEach(prop => {
                    props[prop] = this.safeSerialize(c[prop])
                });

                return {
                    className : c.className,
                    id        : c.id,
                    properties: props
                }
            }

            return c.toJSON()
        });

        return {components}
    }

    /**
     * @param {Object} params
     * @param {String} [params.rootId]
     * @param {Object} params.selector
     * @returns {Object}
     */
    queryVdom({rootId, selector}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');

        const result = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(component.vdom, selector);

        return {
            vdom    : result?.vdom || null,
            index   : result?.index,
            parentId: result?.parentNode?.id
        }
    }

    /**
     * @param {String} [rootId]
     * @returns {Neo.component.Base|null}
     */
    getComponentRoot(rootId) {
        if (rootId) {
            return Neo.getComponent(rootId)
        }

        const apps = Object.values(Neo.apps || {});

        if (apps.length > 0) {
            return apps[0].mainView
        }

        return null
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Number} maxDepth
     * @param {Number} currentDepth
     * @returns {Object}
     */
    serializeComponent(component, maxDepth, currentDepth=1) {
        if (!component) return null;

        const result = component.toJSON();

        if (maxDepth === -1 || currentDepth < maxDepth) {
            const children = Neo.manager.Component.getChildComponents(component);

            if (children && children.length > 0) {
                result.items = children.map(child => this.serializeComponent(child, maxDepth, currentDepth + 1))
            }
        }

        return result
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ComponentService));


/***/ },

/***/ "./src/ai/client/DataService.mjs"
/*!***************************************!*\
  !*** ./src/ai/client/DataService.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");
/* harmony import */ var _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Store.mjs */ "./src/manager/Store.mjs");



/**
 * Handles data-related Neural Link requests.
 * @class Neo.ai.client.DataService
 * @extends Neo.ai.client.Service
 */
class DataService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.DataService'
         * @protected
         */
        className: 'Neo.ai.client.DataService'
    }

    /**
     * @param {Object} params
     * @param {String} params.recordId
     * @param {String} [params.storeId]
     * @returns {Object}
     */
    getRecord({recordId, storeId}) {
        let record;

        if (storeId) {
            const store = Neo.get(storeId);
            if (!store) throw new Error(`Store not found: ${storeId}`);
            record = store.get(recordId)
        } else {
            const matches = [];
            _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].items.forEach(store => {
                const rec = store.get(recordId);
                if (rec) matches.push(rec)
            });

            if (matches.length > 1) {
                throw new Error(`Multiple records found with ID ${recordId}. Please specify storeId.`)
            } else if (matches.length === 1) {
                record = matches[0]
            }
        }

        if (!record) throw new Error(`Record not found: ${recordId}`);

        return record.toJSON()
    }

    /**
     * @param {Object} params
     * @param {String} params.providerId
     * @returns {Object}
     */
    inspectStateProvider({providerId}) {
        const provider = Neo.get(providerId);
        if (!provider) throw new Error(`StateProvider not found: ${providerId}`);

        return provider.toJSON()
    }

    /**
     * @param {Object} params
     * @param {Number} [params.limit=50]
     * @param {Number} [params.offset=0]
     * @param {String} params.storeId
     * @returns {Object}
     */
    inspectStore({limit=50, offset=0, storeId}) {
        const store = Neo.get(storeId);
        if (!store) throw new Error(`Store not found: ${storeId}`);

        return {
            ...store.toJSON(),
            items: store.getRange(offset, offset + limit).map(record => record.toJSON())
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    listStores(params) {
        return {
            stores: _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].items.map(s => ({
                id      : s.id,
                model   : s.model?.className || 'N/A',
                count   : s.count,
                isLoaded: s.isLoaded
            }))
        }
    }

    /**
     * @param {Object} params
     * @param {Object} params.data
     * @param {String} params.providerId
     * @returns {Object}
     */
    modifyStateProvider({data, providerId}) {
        const provider = Neo.get(providerId);
        if (!provider) throw new Error(`StateProvider not found: ${providerId}`);

        provider.setData(data);
        return {success: true}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DataService));


/***/ },

/***/ "./src/ai/client/InstanceService.mjs"
/*!*******************************************!*\
  !*** ./src/ai/client/InstanceService.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");


/**
 * Handles generic instance-related Neural Link requests.
 * @class Neo.ai.client.InstanceService
 * @extends Neo.ai.client.Service
 */
class InstanceService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.InstanceService'
         * @protected
         */
        className: 'Neo.ai.client.InstanceService'
    }

    /**
     * Retrieves properties from a specific instance by its ID.
     * @param {Object} params
     * @param {String} params.id
     * @param {String[]} params.properties
     * @returns {Object}
     */
    getInstanceProperties({id, properties}) {
        const
            instance = Neo.get(id),
            result   = {};

        if (!instance) {
            throw new Error(`Instance not found: ${id}`)
        }

        properties.forEach(property => {
            result[property] = this.safeSerialize(instance[property])
        });

        return {properties: result}
    }

    /**
     * Finds instances matching a selector.
     * @param {Object} params
     * @param {Object} params.selector
     * @param {String[]} [params.returnProperties]
     * @returns {Object}
     */
    findInstances({selector, returnProperties}) {
        const instances = Neo.manager.Instance.find(selector).map(instance => {
            if (Array.isArray(returnProperties) && returnProperties.length > 0) {
                const props = {};
                returnProperties.forEach(prop => {
                    props[prop] = this.safeSerialize(instance[prop])
                });

                return {
                    className : instance.className,
                    id        : instance.id,
                    properties: props
                }
            }

            return instance.toJSON()
        });

        return {instances}
    }

    /**
     * Sets properties on a specific instance by its ID.
     * @param {Object} params
     * @param {String} params.id
     * @param {Object} params.properties
     * @returns {Object}
     */
    setInstanceProperties({id, properties}) {
        const instance = Neo.get(id);

        if (!instance) {
            throw new Error(`Instance not found: ${id}`)
        }

        instance.set(properties);

        return {success: true}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(InstanceService));


/***/ },

/***/ "./src/ai/client/InteractionService.mjs"
/*!**********************************************!*\
  !*** ./src/ai/client/InteractionService.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");


/**
 * Service for handling interaction simulation commands.
 *
 * @class Neo.ai.client.InteractionService
 * @extends Neo.ai.client.Service
 */
class InteractionService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.InteractionService'
         * @protected
         */
        className: 'Neo.ai.client.InteractionService'
    }

    /**
     * Simulates a native DOM event sequence on the client.
     *
     * @param {Object} params
     * @param {Object[]} params.events - Sequence of event config objects
     * @returns {Promise<Boolean>}
     */
    async simulateEvent({events}) {
        let me = this;

        if (!Array.isArray(events)) {
            throw new Error('InteractionService: events must be an array')
        }

        for (const event of events) {
            if (event.delay) {
                await me.timeout(event.delay)
            }

            await me.dispatch({
                id      : event.targetId,
                options : event.options,
                type    : event.type,
                windowId: event.windowId
            })
        }

        return true
    }

    /**
     * Helper to dispatch a single event to the correct window
     * @param {Object} data
     * @param {String} data.id
     * @param {Object} data.options
     * @param {String} data.type
     * @param {String} data.windowId
     * @returns {Promise<Boolean>}
     */
    async dispatch({id, options, type, windowId}) {
        await Neo.Main.importAddon({name: 'EventSimulator', windowId});

        return await Neo.main.addon.EventSimulator.dispatch({
            id,
            options,
            type,
            windowId
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(InteractionService));


/***/ },

/***/ "./src/ai/client/RuntimeService.mjs"
/*!******************************************!*\
  !*** ./src/ai/client/RuntimeService.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");




/**
 * Handles runtime environment related Neural Link requests.
 * @class Neo.ai.client.RuntimeService
 * @extends Neo.ai.client.Service
 */
class RuntimeService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.RuntimeService'
         * @protected
         */
        className: 'Neo.ai.client.RuntimeService'
    }

    /**
     * Checks if a namespace exists in the current environment.
     * @param {Object} params
     * @param {String} params.namespace
     * @returns {Object} {exists: Boolean}
     */
    checkNamespace({namespace}) {
        return {
            exists: !!Neo.ns(namespace)
        }
    }

    /**
     * @param {Object} params
     * @param {String} params.componentId
     * @returns {Object}
     */
    getDomEventListeners({componentId}) {
        const
            listeners = [],
            eventMap  = _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].items?.[componentId];

        if (eventMap) {
            Object.entries(eventMap).forEach(([eventName, events]) => {
                events.forEach(event => {
                    listeners.push({
                        delegate: event.delegate,
                        event   : eventName,
                        handler : typeof event.fn === 'function' ? event.fn.name || 'anonymous' : event.fn,
                        priority: event.priority,
                        scope   : event.scope?.id || 'unknown'
                    })
                })
            })
        }

        return {listeners}
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getDomEventSummary(params) {
        const summary = {
            byComponent: {},
            byEvent    : {},
            totalEvents: 0
        };

        Object.entries(_manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].items).forEach(([componentId, eventMap]) => {
            let componentCount = 0;

            Object.entries(eventMap).forEach(([eventName, events]) => {
                const count = events.length;

                summary.totalEvents       += count;
                componentCount            += count;
                summary.byEvent[eventName] = (summary.byEvent[eventName] || 0) + count
            });

            if (componentCount > 0) {
                summary.byComponent[componentId] = componentCount
            }
        });

        return summary
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getDragState(params) {
        const dragCoordinator = Neo.manager?.DragCoordinator;

        if (dragCoordinator) {
            return dragCoordinator.toJSON()
        }

        return {};
    }

    /**
     * Retrieves the source code of a method on a class prototype.
     * @param {Object} params
     * @param {String} params.className  The fully qualified class name.
     * @param {String} params.methodName The name of the method.
     * @returns {Object} {success: Boolean, source?: String, error?: String}
     */
    getMethodSource({className, methodName}) {
        const cls = Neo.ns(className);

        if (!cls) {
            return {success: false, error: `Class '${className}' not found`}
        }

        const type = Neo.typeOf(cls);
        let proto;

        if (type === 'NeoClass') {
            proto = cls.prototype
        } else if (type === 'NeoInstance') {
            proto = cls.constructor.prototype
        } else {
            return {success: false, error: `Target '${className}' is not a Neo class or instance`}
        }

        if (typeof proto[methodName] !== 'function') {
            return {success: false, error: `Method '${methodName}' not found on '${className}'`}
        }

        return {
            success: true,
            source : proto[methodName].toString()
        }
    }

    /**
     * Retrieves the loaded namespace tree.
     * @param {Object} params
     * @param {String} [params.root='Neo'] The root namespace to start from (e.g., 'Neo', 'MyApp').
     * @returns {Object}
     */
    getNamespaceTree({root='Neo'}) {
        const
            me        = this,
            startNode = Neo.ns(root),
            tree      = {};

        if (!startNode) {
            return {tree: {}, error: `Namespace '${root}' not found`}
        }

        me.#traverseNamespace(startNode, root, tree);

        return {root, tree}
    }

    /**
     * @param {Object} params
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    getNeoConfig({windowId}) {
        if (windowId) {
            return Neo.windowConfigs?.[windowId] || null
        }
        return Neo.config
    }

    /**
     * @param {Object} params
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    getRouteHistory({windowId}) {
        const stack = _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getStack(windowId);

        return {
            count   : stack.length,
            history : stack,
            windowId: windowId || null
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getWindowInfo(params) {
        const windowManager = Neo.manager?.Window;

        if (windowManager) {
            return windowManager.toJSON()
        }

        return {windows: []};
    }

    /**
     * Inspects a class to retrieve its full schema (configs, methods, hierarchy).
     * @param {Object} params
     * @param {String} params.className
     * @param {String} [params.detail='standard'] 'standard' | 'compact'
     * @returns {Object}
     */
    inspectClass({className, detail='standard'}) {
        const cls = Neo.ns(className);

        if (!cls) {
            throw new Error(`Class not found: ${className}`)
        }

        const
            isClass = cls.isClass,
            ctor    = isClass ? cls : cls.constructor,
            proto   = ctor.prototype;

        // 1. Hierarchy & Mixins
        const getMixinNames = (obj) => {
            const names = [];
            if (Neo.isObject(obj)) {
                Object.values(obj).forEach(value => {
                    if (value && value.isClass) {
                        names.push(value.prototype.className)
                    } else {
                        names.push(...getMixinNames(value))
                    }
                })
            }
            return names
        };

        // 2. Configs & Methods
        const
            configs        = {},
            methods        = new Set(),
            configKeys     = new Set(Object.keys(ctor.config)),
            descriptors    = ctor.configDescriptors || {},
            ignoredProps   = ['constructor', 'construct', 'init', 'onConstructed', 'onAfterConstructed'],
            hookRegex      = /^(before|after)(Get|Set)([A-Z])/,
            // Helper to get raw hook name from config key
            getHookName    = (prefix, key) => prefix + key[0].toUpperCase() + key.slice(1);

        // Serialize the default values first
        const defaultValues = this.serializeConfig(ctor.config);

        // Get superclass config for comparison in compact mode
        const
            superCtor   = ctor.__proto__,
            superConfig = superCtor?.config || {};

        // Process Configs
        Object.keys(defaultValues).forEach(key => {
            // In compact mode, only include configs that are "own" (not in super or changed)
            if (detail === 'compact') {
                const isOwn = !Object.hasOwn(superConfig, key) || superConfig[key] !== ctor.config[key];
                if (!isOwn) return
            }

            configs[key] = {
                value: defaultValues[key]
            };

            // Add Descriptor info if available
            if (descriptors[key]) {
                configs[key].meta = this.serializeConfig(descriptors[key])
            }

            // Check for Hooks
            const hooks = [];
            ['beforeGet', 'beforeSet', 'afterSet'].forEach(prefix => {
                const hookName = getHookName(prefix, key);
                // In compact mode, only check for hooks on the current prototype
                if (detail === 'compact') {
                    if (Object.hasOwn(proto, hookName)) {
                        hooks.push(prefix)
                    }
                } else {
                    if (typeof proto[hookName] === 'function') {
                        hooks.push(prefix)
                    }
                }
            });

            if (hooks.length > 0) {
                configs[key].hooks = hooks
            }
        });

        // Process Methods
        let currentProto = proto;

        // Traverse up to Neo.core.Base
        while (currentProto && currentProto.constructor.className !== 'Object') {
            Object.getOwnPropertyNames(currentProto).forEach(name => {
                if (
                    !configKeys.has(name) &&
                    !ignoredProps.includes(name) &&
                    !name.startsWith('_') &&
                    !name.startsWith('#')
                ) {
                    // Check if it's a hook
                    const hookMatch = name.match(hookRegex);
                    if (hookMatch) {
                        // It is a hook. We only care if it wasn't already caught by the config loop.
                        // But since we want a clean method list, we generally exclude hooks here.
                        // The config loop above captures hooks *associated with known configs*.
                        // Orphaned hooks (for non-existent configs?) are rare/invalid.
                    } else {
                        const descriptor = Object.getOwnPropertyDescriptor(currentProto, name);
                        if (typeof descriptor.value === 'function') {
                            methods.add(name)
                        }
                    }
                }
            });

            // In compact mode, we only look at the top-level prototype
            if (detail === 'compact') {
                break
            }

            currentProto = currentProto.__proto__
        }

        return {
            className : proto.className,
            ntype     : proto.ntype,
            ntypeChain: ctor.ntypeChain,
            superClass: proto.__proto__?.constructor?.config?.className || null,
            mixins    : proto.mixins ? getMixinNames(proto.mixins) : [],
            configs,
            methods   : Array.from(methods).sort()
        }
    }

    /**
     * Replaces a method implementation on a class prototype at runtime.
     * RESTRICTED: Requires Neo.config.enableHotPatching = true.
     *
     * @param {Object} params
     * @param {String} params.className  The fully qualified class name (e.g., 'Neo.button.Base')
     * @param {String} params.methodName The name of the method to patch
     * @param {String} params.source     The new function source code (e.g., 'function(args) { ... }' or 'async (args) => { ... }')
     * @returns {Object} {success: Boolean, error?: String}
     */
    patchCode({className, methodName, source}) {
        if (Neo.config.enableHotPatching !== true) {
            return {
                success: false,
                error  : 'Hot patching is disabled. Set Neo.config.enableHotPatching = true to enable.'
            }
        }

        const cls = Neo.ns(className);

        if (!cls) {
            return {
                success: false,
                error  : `Class '${className}' not found`
            }
        }

        if (!cls.prototype) {
            return {
                success: false,
                error  : `Class '${className}' has no prototype (is it a singleton?)`
            }
        }

        try {
            // Use new Function to parse the source code safely into a function object.
            // This avoids direct use of eval() and ensures the code runs in the global scope.
            // eslint-disable-next-line no-new-func
            const fn = new Function('return ' + source)();

            if (typeof fn !== 'function') {
                return {
                    success: false,
                    error  : 'Source did not evaluate to a function'
                }
            }

            // 1. Log the patch for audit
            console.warn(`[Neo.ai.client.RuntimeService] Hot-patching ${className}.prototype.${methodName}`);

            // 2. Apply the patch
            cls.prototype[methodName] = fn;

            // 3. Mark method as patched (useful for debugging)
            fn.$isPatched = true;
            fn.$originalSource = source;

            return {success: true}

        } catch (e) {
            console.error('[Neo.ai.client.RuntimeService] Hot patch failed:', e);
            return {
                success: false,
                error  : e.message
            }
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    reloadPage(params) {
        Neo.Main.reloadWindow();
        return {status: 'reloading'};
    }

    /**
     * @param {Object} params
     * @param {Object} params.config
     * @returns {Object}
     */
    setNeoConfig({config}) {
        Neo.setGlobalConfig(config);
        return {status: 'ok'}
    }

    /**
     * @param {Object} params
     * @param {String} params.hash
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    setRoute({hash, windowId}) {
        Neo.Main.setRoute({
            value: hash,
            windowId
        });

        return {status: 'ok', hash}
    }

    /**
     * @param {Object} node
     * @param {String} path
     * @param {Object} output
     */
    #traverseNamespace(node, path, output) {
        Object.keys(node).forEach(key => {
            const
                value       = node[key],
                type        = Neo.typeOf(value),
                currentPath = path ? `${path}.${key}` : key;

            if (type === 'NeoClass') {
                output[key] = {
                    type     : 'class',
                    className: value.prototype.className
                }
            } else if (type === 'NeoInstance') {
                output[key] = {
                    type     : 'singleton',
                    className: value.className
                }
            } else if (type === 'Object') {
                // Only traverse plain objects (namespaces)
                // Neo.typeOf returns 'Object' for plain objects
                output[key] = {};
                this.#traverseNamespace(value, currentPath, output[key]);

                // Clean up empty packages
                if (Object.keys(output[key]).length === 0) {
                    delete output[key]
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RuntimeService));


/***/ },

/***/ "./src/ai/client/Service.mjs"
/*!***********************************!*\
  !*** ./src/ai/client/Service.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for Neural Link Client Services.
 * @class Neo.ai.client.Service
 * @extends Neo.core.Base
 */
class Service extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.Service'
         * @protected
         */
        className: 'Neo.ai.client.Service',
        /**
         * @member {Neo.ai.Client|null} client=null
         * @protected
         */
        client: null
    }

    /**
     * @param {*} value
     * @returns {*}
     */
    safeSerialize(value) {
        const type = Neo.typeOf(value);

        if (type === 'NeoInstance') {
            return value.toJSON()
        }

        if (type === 'Object') {
            const result = {};
            Object.entries(value).forEach(([k, v]) => {
                result[k] = this.safeSerialize(v)
            });
            return result
        }

        if (type === 'Array') {
            return value.map(v => this.safeSerialize(v))
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Service));


/***/ },

/***/ "./src/data/connection/WebSocket.mjs"
/*!*******************************************!*\
  !*** ./src/data/connection/WebSocket.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.data.connection.WebSocket
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Socket extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.connection.WebSocket'
         * @protected
         */
        className: 'Neo.data.connection.WebSocket',
        /**
         * @member {String} ntype='socket-connection'
         * @protected
         */
        ntype: 'socket-connection',
        /**
         * @member {Function} backoffStrategy=attempt=>Math.min(1000*Math.pow(2,attempt-1),30000)
         */
        backoffStrategy: attempt => Math.min(1000 * Math.pow(2, attempt - 1), 30000),
        /**
         * @member {WebSocket|null} socket_=null
         * @protected
         * @reactive
         */
        socket_: null
    }

    /**
     * @member {String|null} channel=null
     */
    channel = null
    /**
     * @member {Number} maxReconnectAttempts=5
     */
    maxReconnectAttempts = 5
    /**
     * @member {Object} messageCallbacks={}
     * @protected
     */
    messageCallbacks = {}
    /**
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * @member {Number} reconnectAttempts=0
     * @protected
     */
    reconnectAttempts = 0
    /**
     * @member {String|null} serverAddress=null
     */
    serverAddress = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createSocket()
    }

    /**
     * @param {Function} callback
     * @param {Object} scope
     */
    async attemptReconnect(callback, scope) {
        let me = this;

        me.reconnectAttempts++;

        if (me.reconnectAttempts < me.maxReconnectAttempts) {
            const delay = me.backoffStrategy(me.reconnectAttempts);

            me.fire('reconnecting', {
                attempt    : me.reconnectAttempts,
                maxAttempts: me.maxReconnectAttempts,
                delay
            });

            console.log(`WebSocket reconnect attempt ${me.reconnectAttempts}/${me.maxReconnectAttempts} in ${delay}ms`);

            await me.timeout(delay);

            if (!me.isDestroyed) {
                me.createSocket();

                callback && me.on('open', {
                    callback,
                    scope : scope || me,
                    single: true
                })
            }
        } else {
            console.error('Max reconnection attempts reached');
            me.fire('reconnect_failed')
        }
    }

    /**
     * Intercepts the WebSocket send calls
     * @param {Object} data
     * @returns {String}
     */
    beforeSend(data) {
        let me        = this,
            {channel} = me;

        return JSON.stringify(channel ? {channel, data} : data)
    }

    /**
     * Triggered before the socket config gets changed.
     * @param {WebSocket|null} value
     * @param {WebSocket|null} oldValue
     * @returns {WebSocket|null}
     * @protected
     */
    beforeSetSocket(value, oldValue) {
        if (value) {
            let me = this;

            Object.assign(value, {
                onclose  : me.onClose  .bind(me),
                onerror  : me.onError  .bind(me),
                onmessage: me.onMessage.bind(me),
                onopen   : me.onOpen   .bind(me)
            });

            (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.createInterceptor)(value, 'send', me.beforeSend, me)
        }

        return value
    }

    /**
     * @param {Number} [code] defaults to 1000
     * @param {String} [reason]
     */
    close(code, reason) {
        this.socket.close(code, reason)
    }

    /**
     *
     */
    createSocket() {
        this.socket = new WebSocket(this.serverAddress)
    }

    /**
     *
     */
    destroy(...args) {
        this.close();
        super.destroy(...args)
    }

    /**
     * @param {CloseEvent} event The Websocket generated CloseEvent
     * @param {Number}     event.code The WebSocket connection close code provided by the server
     *
     *        Code        Name                  Description
     *        0-999                             Reserved and not used.
     *        1000        CLOSE_NORMAL          Normal closure; the connection successfully completed whatever purpose for which it was created.
     *        1001        CLOSE_GOING_AWAY      The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.
     *        1002        CLOSE_PROTOCOL_ERROR  The endpoint is terminating the connection due to a protocol error.
     *        1003        CLOSE_UNSUPPORTED     The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).
     *        1004        CLOSE_TOO_LARGE       The endpoint is terminating the connection because a data frame was received that is too large.
     *        1005        CLOSE_NO_STATUS       Reserved.  Indicates that no status code was provided even though one was expected.
     *        1006        CLOSE_ABNORMAL        Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.
     *        1007-1999                         Reserved for future use by the WebSocket standard.
     *        2000-2999                         Reserved for use by WebSocket extensions.
     *        3000-3999                         Available for use by libraries and frameworks. May not be used by applications.
     *        4000-4999                         Available for use by applications.
     *
     * @param {String}     reason A string indicating the reason the server closed the connection. This is specific to the particular server and sub-protocol.
     * @param {Boolean}    wasClean Indicates whether or not the connection was cleanly closed.
     */
    onClose(event, reason, wasClean) {
        this.fire('close', {event, reason, wasClean});

        // Auto-reconnect on abnormal closure
        if (!wasClean || event.code !== 1000) {
            console.warn('WebSocket closed abnormally, attempting reconnect...');
            this.attemptReconnect()
        }
    }

    /**
     *
     */
    onError(error) {
        this.fire('error', {error})
    }

    /**
     * @param {MessageEvent} event
     */
    onMessage(event) {
        let me   = this,
            data = JSON.parse(event.data);

        me.fire('message', {data});

        if (data.mId) {
            me.messageCallbacks[data.mId].resolve(data.data);
            delete me.messageCallbacks[data.mId]
        }
    }

    /**
     *
     */
    onOpen() {
        this.reconnectAttempts = 0;
        this.fire('open', {scope: this})
    }

    /**
     * @param {Object} data
     * @returns {Promise<any>}
     */
    promiseMessage(data) {
        let me = this;

        return new Promise((resolve, reject) => {
            me.messageCallbacks[me.messageId] = {reject, resolve};

            me.sendMessage({data, mId: me.messageId});
            me.messageId++
        })
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        let me       = this,
            {socket} = me,
            d        = data;

        // CONNECTING  0   The connection is not yet open.
        // OPEN        1   The connection is open and ready to communicate.
        // CLOSING     2   The connection is in the process of closing.
        // CLOSED      3   The connection is closed or couldn't be opened.

        // If socket is not yet ready let's defer to open then resend
        switch (socket.readyState) {
            case WebSocket.CLOSED:
            case WebSocket.CLOSING:
                me.attemptReconnect(function() {
                    me.sendMessage(d);
                });
                break;
            case WebSocket.CONNECTING:
                me.on('open', function() {
                    me.sendMessage(d)
                }, me, {once: true});
                break;
            case WebSocket.OPEN:
                socket.send(data);
                break;
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Socket));


/***/ },

/***/ "./src/manager/Store.mjs"
/*!*******************************!*\
  !*** ./src/manager/Store.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.Store
 * @extends Neo.manager.Base
 * @singleton
 */
class Store extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Store'
         * @protected
         */
        className: 'Neo.manager.Store',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        
        // Alias Neo.getStore to this manager?
        // Neo.getStore = this.get.bind(this);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/manager/Window.mjs"
/*!********************************!*\
  !*** ./src/manager/Window.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");



/**
 * @summary The "God View" for the multi-window application workspace.
 * @description This manager maintains a real-time geometric map of all connected browser windows in the App Worker.
 * It is the central authority for spatial awareness, enabling features like the "Infinite Canvas" where
 * interactions (like Drag & Drop) can span across multiple OS-level windows.
 *
 * It receives high-frequency position updates from the Main Thread (via `Neo.main.addon.WindowPosition`)
 * and provides intersection testing APIs to determine which window is under a given screen coordinate.
 *
 * @class Neo.manager.Window
 * @extends Neo.manager.Base
 * @singleton
 * @see Neo.main.addon.WindowPosition
 */
class Window extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Window'
         * @protected
         */
        className: 'Neo.manager.Window',
        /**
         * @member {Boolean} isSafari
         * @protected
         */
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * Returns the windowId which intersects with the given global screen coordinates.
     * This is the core intersection test for cross-window drag and drop operations.
     * @param {Number} x Screen X coordinate
     * @param {Number} y Screen Y coordinate
     * @returns {String|null} The windowId of the target window, or null if no intersection.
     */
    getWindowAt(x, y) {
        let item = this.items.find(item => item.outerRect?.intersects({bottom: y, right: x, x, y}));

        return item ? item.id : null
    }

    /**
     * @param {Object} data
     * @returns {Object} {chrome, innerRect, outerRect}
     */
    calculateGeometry(data) {
        const
            {innerHeight, innerWidth, mozInnerScreenX, mozInnerScreenY, outerHeight, outerWidth, screenLeft, screenTop} = data,
            widthDiff    = outerWidth  - innerWidth,
            heightDiff   = outerHeight - innerHeight,
            // Assumption: Side borders are symmetric
            sideBorder   = widthDiff / 2,
            // Assumption: Bottom border matches side border (common in Windows)
            bottomBorder = sideBorder,
            // The rest is the top chrome (header)
            topChrome    = heightDiff - bottomBorder;

        const chrome = {
            bottom: bottomBorder,
            left  : sideBorder,
            right : sideBorder,
            top   : topChrome
        };

        let viewportLeft, viewportTop;

        if (typeof mozInnerScreenX === 'number') {
            // Firefox: explicit viewport coordinates
            viewportLeft = mozInnerScreenX;
            viewportTop  = mozInnerScreenY
        } else if (this.isSafari) {
            // Safari: screenLeft/Top is Frame position. Add chrome to get Viewport.
            viewportLeft = screenLeft + sideBorder;
            viewportTop  = screenTop  + topChrome
        } else {
            // Chrome/Edge: screenLeft/Top is Viewport position.
            viewportLeft = screenLeft;
            viewportTop  = screenTop
        }

        const innerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](viewportLeft, viewportTop, innerWidth, innerHeight);

        const outerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            viewportLeft - sideBorder,
            viewportTop  - topChrome,
            outerWidth,
            outerHeight
        );

        return {chrome, innerRect, outerRect}
    }

    /**
     * Triggered when a new browser window connects to the SharedWorker.
     * In Shared Worker mode, `Neo.worker.App#onConnect` ensures that `windowData`
     * is fetched from the Main Thread and included in the payload.
     * @param {Object} data
     * @param {Number} data.appName
     * @param {Object} [data.windowData] Contains geometry data (screenLeft, innerHeight, etc.)
     * @param {String} data.windowId
     */
    onWindowConnect({appName, windowData, windowId}) {
        let chrome    = null,
            innerRect = null,
            outerRect = null;

        if (windowData) {
            ({chrome, innerRect, outerRect} = this.calculateGeometry(windowData))
        }

        console.log('Window.onWindowConnect', {windowId, appName, chrome, innerRect, outerRect});

        this.register({appName, chrome, id: windowId, innerRect, outerRect})
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowDisconnect({windowId}) {
        this.unregister(windowId)
    }

    /**
     * Updates the geometric state of a window based on data from the Main Thread.
     * This method is called via direct delegation from the App Worker to minimize overhead.
     * @param {Object} data
     * @param {Number} data.innerHeight
     * @param {Number} data.outerHeight
     * @param {Number} data.outerWidth
     * @param {Number} data.screenLeft
     * @param {Number} data.screenTop
     * @param {String} data.windowId
     */
    onWindowPositionChange(data) {
        const
            me   = this,
            item = me.get(data.windowId),
            {chrome, innerRect, outerRect} = me.calculateGeometry(data);

        if (item) {
            item.chrome    = chrome;
            item.innerRect = innerRect;
            item.outerRect = outerRect
        } else {
            me.register({
                chrome,
                id: data.windowId,
                innerRect,
                outerRect
            })
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            className: this.className,
            windows  : this.items.map(win => ({
                id       : win.id,
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Window));


/***/ },

/***/ "./src/util/vdom/TreeBuilder.mjs"
/*!***************************************!*\
  !*** ./src/util/vdom/TreeBuilder.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * A singleton utility class responsible for recursively building VDOM and VNode trees.
 * It can expand component references within a tree structure into their full VDOM/VNode representations,
 * supporting selective (asymmetric) tree expansion for optimized updates.
 * @class Neo.util.vdom.TreeBuilder
 * @extends Neo.core.Base
 * @singleton
 */
class TreeBuilder extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.vdom.TreeBuilder'
         * @protected
         */
        className: 'Neo.util.vdom.TreeBuilder',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Private helper to recursively build a tree, abstracting the child node key.
     * @param {Object} node The vdom or vnode to process.
     * @param {Number} depth The current recursion depth.
     * @param {Set<String>|null} mergedChildIds A set of component IDs to selectively expand.
     * @param {String} childKey The property name for child nodes ('cn' or 'childNodes').
     * @returns {Object}
     * @private
     */
    #buildTree(node, depth, mergedChildIds, childKey) {
        // We can not use Neo.isObject() here, since inside unit-test scenarios, we will import vdom.Helper into main threads.
        // Inside this scenario, Neo.isObject() returns false for VNode instances
        if (typeof node !== 'object' || node === null) {
            return node
        }

        // JIT ID Generation (App Authority)
        // If we are processing a VDOM tree (childKey === 'cn') and the node has no ID,
        // we must generate one now to ensure deterministic identity before the VDOM leaves the App Worker.
        if (childKey === 'cn' && !node.id) {
            node.id = Neo.getId(node.vtype === 'text' ? 'vtext' : 'vnode')
        }

        let output = {...node}; // Shallow copy

        if (node[childKey]) {
            output[childKey] = [];

            node[childKey].forEach(item => {
                let currentItem = item,
                    childDepth;

                if (currentItem.componentId) {
                    const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(currentItem.componentId);

                    // Sparse Tree Generation & Scoped Updates
                    // We prune the branch (send a placeholder) if:
                    // 1. We are at the depth boundary (depth === 1) AND it's not a merged update.
                    // 2. We are in a Merged Update (mergedChildIds exists) AND this component is not in the AllowList (not dirty/bridge).
                    // Exception: We never prune if depth is -1 (Full Tree) or if the component is not mounted yet.
                    if (depth !== -1 && component?.vnode) {
                        const isExpandable = mergedChildIds?.has(currentItem.componentId);

                        if ((depth === 1 && !isExpandable) || (mergedChildIds && !isExpandable)) {
                            output[childKey].push({...currentItem, neoIgnore: true});
                            return // Stop processing this branch
                        }
                    }

                    // Expand the branch if it's part of a merged update, or if the depth requires it, OR if the vnode is missing
                    if (depth > 1 || depth === -1 || mergedChildIds?.has(currentItem.componentId) || !component?.vnode) {
                        // Use the correct tree type based on the childKey
                        const componentTree = childKey === 'cn' ? component?.vdom : component?.vnode;
                        if (componentTree) {
                            currentItem = componentTree
                        }
                    }
                }

                if (item.componentId) {
                    childDepth = (depth === -1) ? -1 : Math.max(0, depth - 1)
                } else {
                    childDepth = depth
                }

                output[childKey].push(this.#buildTree(currentItem, childDepth, mergedChildIds, childKey))
            })
        }

        return output
    }


    /**
     * Copies a given vdom tree and replaces child component references with their vdom.
     * @param {Object} vdom
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVdomTree(vdom, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vdom, depth, mergedChildIds, 'cn')
    }

    /**
     * Copies a given vnode tree and replaces child component references with their vnode.
     * @param {Object} vnode
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVnodeTree(vnode, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vnode, depth, mergedChildIds, 'childNodes')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeBuilder));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19haV9DbGllbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ087QUFDUTtBQUNMO0FBQ0k7QUFDRztBQUNKO0FBQ0s7QUFDWDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxvRUFBZ0IsS0FBSyxXQUFXO0FBQ3BFLG9DQUFvQywrREFBVyxVQUFVLFdBQVc7QUFDcEUsb0NBQW9DLG1FQUFlLE1BQU0sV0FBVztBQUNwRSxvQ0FBb0Msc0VBQWtCLEdBQUcsV0FBVztBQUNwRSxvQ0FBb0Msa0VBQWMsT0FBTyxXQUFXO0FBQ3BFOztBQUVBLGVBQWUsaURBQWlEOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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akI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvQ2xpZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2FpL2NsaWVudC9Db21wb25lbnRTZXJ2aWNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2FpL2NsaWVudC9EYXRhU2VydmljZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9haS9jbGllbnQvSW5zdGFuY2VTZXJ2aWNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2FpL2NsaWVudC9JbnRlcmFjdGlvblNlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L1J1bnRpbWVTZXJ2aWNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2FpL2NsaWVudC9TZXJ2aWNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvY29ubmVjdGlvbi9XZWJTb2NrZXQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9TdG9yZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1dpbmRvdy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL3Zkb20vVHJlZUJ1aWxkZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCAgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbXBvbmVudFNlcnZpY2UgICBmcm9tICcuL2NsaWVudC9Db21wb25lbnRTZXJ2aWNlLm1qcyc7XG5pbXBvcnQgRGF0YVNlcnZpY2UgICAgICAgIGZyb20gJy4vY2xpZW50L0RhdGFTZXJ2aWNlLm1qcyc7XG5pbXBvcnQgSW5zdGFuY2VTZXJ2aWNlICAgIGZyb20gJy4vY2xpZW50L0luc3RhbmNlU2VydmljZS5tanMnO1xuaW1wb3J0IEludGVyYWN0aW9uU2VydmljZSBmcm9tICcuL2NsaWVudC9JbnRlcmFjdGlvblNlcnZpY2UubWpzJztcbmltcG9ydCBSdW50aW1lU2VydmljZSAgICAgZnJvbSAnLi9jbGllbnQvUnVudGltZVNlcnZpY2UubWpzJztcbmltcG9ydCBTb2NrZXQgICAgICAgICAgICAgZnJvbSAnLi4vZGF0YS9jb25uZWN0aW9uL1dlYlNvY2tldC5tanMnO1xuaW1wb3J0IFdpbmRvd01hbmFnZXIgICAgICBmcm9tICcuLi9tYW5hZ2VyL1dpbmRvdy5tanMnO1xuXG4vKipcbiAqIFRoZSBBSSBDbGllbnQgZXN0YWJsaXNoZXMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTmV1cmFsIExpbmsgTUNQIFNlcnZlci5cbiAqIEl0IGFjdHMgYXMgYSBicmlkZ2UsIGVuYWJsaW5nIGV4dGVybmFsIEFJIGFnZW50cyB0byBpbnNwZWN0IGFuZCBtYW5pcHVsYXRlIHRoZSBydW5uaW5nIE5lby5tanMgYXBwbGljYXRpb25cbiAqIHZpYSBhIHN0YW5kYXJkaXplZCBKU09OLVJQQyBwcm90b2NvbC5cbiAqIEBjbGFzcyBOZW8uYWkuQ2xpZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIENsaWVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFpLkNsaWVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmFpLkNsaWVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgY3VzdG9tIGNvbmZpZ3MgZm9yIGRhdGEuY29ubmVjdGlvbi5XZWJzb2NrZXQsIG9yIHBhc3MgYSBtb2R1bGUgb3IgaW5zdGFuY2UuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldHxudWxsfSBzb2NrZXQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ja2V0Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgTmV1cmFsIExpbmsgTUNQIFNlcnZlcidzIFdlYlNvY2tldCBlbmRwb2ludC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB1cmw9J3dzOi8vMTI3LjAuMC4xOjgwODEnXG4gICAgICAgICAqL1xuICAgICAgICB1cmw6ICd3czovLzEyNy4wLjAuMTo4MDgxJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQ29ubmVjdGVkPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBCdWZmZXIgZm9yIGNvbnNvbGUgbG9ncyBnZW5lcmF0ZWQgYmVmb3JlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcbiAgICAgKiBAbWVtYmVyIHtBcnJheX0gbG9ncz1bXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBsb2dzID0gW11cbiAgICAvKipcbiAgICAgKiBNYXAgSlNPTi1SUEMgbWV0aG9kIHByZWZpeGVzIHRvIHNlcnZpY2UgaW5zdGFuY2VzXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBzZXJ2aWNlTWFwXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlcnZpY2VNYXAgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBzZXJ2aWNlcz1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNlcnZpY2VzID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0fG51bGx9IHNvY2tldD1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNvY2tldCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2VydmljZXMgPSB7XG4gICAgICAgICAgICBjb21wb25lbnQgIDogTmVvLmNyZWF0ZShDb21wb25lbnRTZXJ2aWNlLCAgIHtjbGllbnQ6IG1lfSksXG4gICAgICAgICAgICBkYXRhICAgICAgIDogTmVvLmNyZWF0ZShEYXRhU2VydmljZSwgICAgICAgIHtjbGllbnQ6IG1lfSksXG4gICAgICAgICAgICBpbnN0YW5jZSAgIDogTmVvLmNyZWF0ZShJbnN0YW5jZVNlcnZpY2UsICAgIHtjbGllbnQ6IG1lfSksXG4gICAgICAgICAgICBpbnRlcmFjdGlvbjogTmVvLmNyZWF0ZShJbnRlcmFjdGlvblNlcnZpY2UsIHtjbGllbnQ6IG1lfSksXG4gICAgICAgICAgICBydW50aW1lICAgIDogTmVvLmNyZWF0ZShSdW50aW1lU2VydmljZSwgICAgIHtjbGllbnQ6IG1lfSlcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB7Y29tcG9uZW50LCBkYXRhLCBpbnN0YW5jZSwgaW50ZXJhY3Rpb24sIHJ1bnRpbWV9ID0gbWUuc2VydmljZXM7XG5cbiAgICAgICAgbWUuc2VydmljZU1hcCA9IHtcbiAgICAgICAgICAgIGdldF9jb21wb25lbnQgICAgICAgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGdldF9jb21wdXRlZF9zdHlsZXMgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGdldF9kb21fcmVjdCAgICAgICAgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGdldF92ZG9tICAgICAgICAgICAgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGdldF92ZG9tX3Zub2RlICAgICAgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGdldF92bm9kZSAgICAgICAgICAgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGhpZ2hsaWdodF9jb21wb25lbnQgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIHF1ZXJ5X2NvbXBvbmVudCAgICAgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIHF1ZXJ5X3Zkb20gICAgICAgICAgICA6IGNvbXBvbmVudCxcbiAgICAgICAgICAgIHNldF9jb21wb25lbnQgICAgICAgICA6IGNvbXBvbmVudCxcblxuICAgICAgICAgICAgZmluZF9pbnN0YW5jZXMgICAgICAgICA6IGluc3RhbmNlLFxuICAgICAgICAgICAgZ2V0X2luc3RhbmNlX3Byb3BlcnRpZXM6IGluc3RhbmNlLFxuICAgICAgICAgICAgc2V0X2luc3RhbmNlX3Byb3BlcnRpZXM6IGluc3RhbmNlLFxuXG4gICAgICAgICAgICBnZXRfcmVjb3JkICAgICAgICAgICAgOiBkYXRhLFxuICAgICAgICAgICAgaW5zcGVjdF9zdGF0ZV9wcm92aWRlcjogZGF0YSxcbiAgICAgICAgICAgIGluc3BlY3Rfc3RvcmUgICAgICAgICA6IGRhdGEsXG4gICAgICAgICAgICBsaXN0X3N0b3JlcyAgICAgICAgICAgOiBkYXRhLFxuICAgICAgICAgICAgbW9kaWZ5X3N0YXRlX3Byb3ZpZGVyIDogZGF0YSxcblxuICAgICAgICAgICAgZ2V0X2RvbV9ldmVudCAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIGdldF9kcmFnICAgICAgICAgICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBnZXRfbWV0aG9kX3NvdXJjZSAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgZ2V0X3JvdXRlICAgICAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIGdldF93aW5kb3cgICAgICAgICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBpbnNwZWN0X2NsYXNzICAgICAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgcGF0Y2hfY29kZSAgICAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIHJlbG9hZF9wYWdlICAgICAgICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBzZXRfcm91dGUgICAgICAgICAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgc2ltdWxhdGVfZXZlbnQgICAgICAgIDogaW50ZXJhY3Rpb25cbiAgICAgICAgfTtcblxuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5vbih7XG4gICAgICAgICAgICBjb25uZWN0ICAgOiBtZS5vbkFwcFdvcmtlcldpbmRvd0Nvbm5lY3QsXG4gICAgICAgICAgICBkaXNjb25uZWN0OiBtZS5vbkFwcFdvcmtlcldpbmRvd0Rpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5jb25uZWN0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIE5ldXJhbCBMaW5rIE1DUCBTZXJ2ZXIuXG4gICAgICogVXNlcyBOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldCBmb3Igcm9idXN0IGNvbm5lY3Rpb24gbWFuYWdlbWVudC5cbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdXJsICAgICA9IG5ldyBVUkwoTmVvLmNvbmZpZy5uZXVyYWxMaW5rVXJsIHx8IG1lLnVybCksXG4gICAgICAgICAgICAgICAgYXBwTmFtZSA9ICdVbmtub3duIEFwcCc7XG5cbiAgICAgICAgICAgIGlmIChOZW8uY29uZmlnLmFwcFBhdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IE5lby5jb25maWcuYXBwUGF0aC5tYXRjaCgvYXBwc1xcLyhbXlxcL10rKVxcLy8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lID0gbWF0Y2hbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhcHBXb3JrZXJJZCcsIE5lby53b3JrZXIuQXBwLmlkKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhcHBOYW1lJywgYXBwTmFtZSk7XG5cbiAgICAgICAgICAgIG1lLnNvY2tldCA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZShtZS5zb2NrZXRDb25maWcsIFNvY2tldCwge1xuICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3M6IHVybC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2UgIDogbWUub25Tb2NrZXRDbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgIDogbWUub25Tb2NrZXRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWUub25Tb2NrZXRNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuICAgOiBtZS5vblNvY2tldE9wZW4sXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlICA6IG1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTmVvLmFpLkNsaWVudDogRmFpbGVkIHRvIGNyZWF0ZSBXZWJTb2NrZXQgY29ubmVjdGlvbicsIGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3V0ZXMgc3BlY2lmaWMgSlNPTi1SUEMgbWV0aG9kcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIGltcGxlbWVudGF0aW9uLlxuICAgICAqIFRoaXMgbWV0aG9kIGFjdHMgYXMgdGhlIGNlbnRyYWwgZGlzcGF0Y2hlciBmb3IgYWxsIEFJLWRyaXZlbiBjb21tYW5kcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFRoZSBKU09OLVJQQyBtZXRob2QgbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gVGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgaGFuZGxlUmVxdWVzdChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzZXJ2aWNlID0gbnVsbCxcbiAgICAgICAgICAgIHByZWZpeDtcblxuICAgICAgICAvLyBGaW5kIG1hdGNoaW5nIHNlcnZpY2UgYmFzZWQgb24gcHJlZml4XG4gICAgICAgIC8vIGUuZy4gXCJnZXRfY29tcG9uZW50X3Byb3BlcnR5XCIgLT4gbWF0Y2hlcyBcImdldF9jb21wb25lbnRcIiBwcmVmaXhcbiAgICAgICAgZm9yIChwcmVmaXggaW4gbWUuc2VydmljZU1hcCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlID0gbWUuc2VydmljZU1hcFtwcmVmaXhdO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmbk5hbWUgPSBOZW8uc25ha2VUb0NhbWVsKG1ldGhvZCk7XG5cbiAgICAgICAgaWYgKHNlcnZpY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gc2VydmljZVtmbk5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoTmVvLmlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoc2VydmljZSwgcGFyYW1zKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNQcm9taXNlKGZuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbi5jYWxsKHNlcnZpY2UsIHBhcmFtcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXJ2aWNlICYmIHR5cGVvZiBzZXJ2aWNlW2ZuTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlW2ZuTmFtZV0ocGFyYW1zKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG1ldGhvZDogJHttZXRob2R9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkFwcFdvcmtlcldpbmRvd0Nvbm5lY3QoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICB3aW4gPSBXaW5kb3dNYW5hZ2VyLmdldChkYXRhLndpbmRvd0lkKSxcbiAgICAgICAgICAgICAgICB7YXBwTmFtZSwgd2luZG93SWR9ID0gZGF0YTtcblxuICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZpY2F0aW9uKCd3aW5kb3dfY29ubmVjdGVkJywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY2hyb21lICAgOiB3aW4/LmNocm9tZSxcbiAgICAgICAgICAgICAgICBpbm5lclJlY3Q6IHdpbj8uaW5uZXJSZWN0LFxuICAgICAgICAgICAgICAgIG91dGVyUmVjdDogd2luPy5vdXRlclJlY3QsXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25BcHBXb3JrZXJXaW5kb3dEaXNjb25uZWN0KHt3aW5kb3dJZH0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE5vdGlmaWNhdGlvbignd2luZG93X2Rpc2Nvbm5lY3RlZCcsIHt3aW5kb3dJZH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAgICAgKiBQYXJzZXMgdGhlIEpTT04tUlBDIHBheWxvYWQgYW5kIGRlbGVnYXRlcyB2YWxpZCByZXF1ZXN0cyB0byBgaGFuZGxlUmVxdWVzdGAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvblNvY2tldE1lc3NhZ2Uoe2RhdGF9KSB7XG4gICAgICAgIGlmIChkYXRhLm1ldGhvZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmhhbmRsZVJlcXVlc3QoZGF0YS5tZXRob2QsIGRhdGEucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXNwb25zZShkYXRhLmlkLCByZXN1bHQpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTmVvLmFpLkNsaWVudDogRmFpbGVkIHRvIGhhbmRsZSBtZXNzYWdlJywgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3IoZGF0YS5pZCwgZS5tZXNzYWdlLCBlLnN0YWNrKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNvY2tldE9wZW4oZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05lby5haS5DbGllbnQ6IENvbm5lY3RlZCB0byBNQ1AgU2VydmVyJyk7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIEZsdXNoIGJ1ZmZlcmVkIGxvZ3NcbiAgICAgICAgaWYgKHRoaXMubG9ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ3MuZm9yRWFjaChsb2cgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE5vdGlmaWNhdGlvbignY29uc29sZV9sb2cnLCBsb2cpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubG9ncy5sZW5ndGggPSAwXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcHBXb3JrZXIgPSBOZW8ud29ya2VyLkFwcDtcblxuICAgICAgICAvLyAxLiBSZWdpc3RlciB0aGUgd29ya2VyXG4gICAgICAgIHRoaXMuc29ja2V0LnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgbWV0aG9kIDogJ3JlZ2lzdGVyJyxcbiAgICAgICAgICAgIHBhcmFtcyA6IHtcbiAgICAgICAgICAgICAgICBhcHBXb3JrZXJJZCAgIDogYXBwV29ya2VyLmlkLFxuICAgICAgICAgICAgICAgIGVudmlyb25tZW50ICAgOiBOZW8uY29uZmlnLmVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIGlzU2hhcmVkV29ya2VyOiBhcHBXb3JrZXIuaXNTaGFyZWRXb3JrZXIsXG4gICAgICAgICAgICAgICAgdXNlckFnZW50ICAgICA6IG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gMi4gUmVoeWRyYXRlIHdpbmRvdyB0b3BvbG9neVxuICAgICAgICBXaW5kb3dNYW5hZ2VyLml0ZW1zLmZvckVhY2god2luID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE5vdGlmaWNhdGlvbignd2luZG93X2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lICA6IHdpbi5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGNocm9tZSAgIDogd2luLmNocm9tZSxcbiAgICAgICAgICAgICAgICBpbm5lclJlY3Q6IHdpbi5pbm5lclJlY3QsXG4gICAgICAgICAgICAgICAgb3V0ZXJSZWN0OiB3aW4ub3V0ZXJSZWN0LFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkIDogd2luLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIDMuIFJlaHlkcmF0ZSBkcmFnIHN0YXRlIChpZiBhY3RpdmUpXG4gICAgICAgIGNvbnN0IGRyYWdDb29yZGluYXRvciA9IE5lby5tYW5hZ2VyPy5EcmFnQ29vcmRpbmF0b3I7XG5cbiAgICAgICAgaWYgKGRyYWdDb29yZGluYXRvcj8uYWN0aXZlVGFyZ2V0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZpY2F0aW9uKCdkcmFnX2FjdGl2ZScsIHtcbiAgICAgICAgICAgICAgICBzb3J0R3JvdXAgOiBkcmFnQ29vcmRpbmF0b3IuYWN0aXZlVGFyZ2V0Wm9uZS5zb3J0R3JvdXAsXG4gICAgICAgICAgICAgICAgc291cmNlWm9uZTogZHJhZ0Nvb3JkaW5hdG9yLmFjdGl2ZVRhcmdldFpvbmUuaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb3NlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Tb2NrZXRDbG9zZShldmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnTmVvLmFpLkNsaWVudDogRGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Tb2NrZXRFcnJvcihldmVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdOZW8uYWkuQ2xpZW50OiBXZWJTb2NrZXQgRXJyb3InLCBldmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIEpTT04tUlBDIGVycm9yIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzdGFja11cbiAgICAgKi9cbiAgICBzZW5kRXJyb3IoaWQsIG1lc3NhZ2UsIHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSAgIDogLTMyNjAzLCAvLyBJbnRlcm5hbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhICAgOiB7c3RhY2t9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgSlNPTi1SUEMgbm90aWZpY2F0aW9uIChubyBpZClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqL1xuICAgIHNlbmROb3RpZmljYXRpb24obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBKU09OLVJQQyByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0geyp9IHJlc3VsdFxuICAgICAqL1xuICAgIHNlbmRSZXNwb25zZShpZCwgcmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDbGllbnQpO1xuIiwiaW1wb3J0IFNlcnZpY2UgICAgIGZyb20gJy4vU2VydmljZS5tanMnO1xuaW1wb3J0IFRyZWVCdWlsZGVyIGZyb20gJy4uLy4uL3V0aWwvdmRvbS9UcmVlQnVpbGRlci5tanMnO1xuaW1wb3J0IFZkb21VdGlsICAgIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEhhbmRsZXMgY29tcG9uZW50LXJlbGF0ZWQgTmV1cmFsIExpbmsgcmVxdWVzdHMuXG4gKiBAY2xhc3MgTmVvLmFpLmNsaWVudC5Db21wb25lbnRTZXJ2aWNlXG4gKiBAZXh0ZW5kcyBOZW8uYWkuY2xpZW50LlNlcnZpY2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50U2VydmljZSBleHRlbmRzIFNlcnZpY2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFpLmNsaWVudC5Db21wb25lbnRTZXJ2aWNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuY2xpZW50LkNvbXBvbmVudFNlcnZpY2UnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgcGFyYW1zLmNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGFyYW1zLnZhcmlhYmxlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29tcHV0ZWRTdHlsZXMoe2NvbXBvbmVudElkLCB2YXJpYWJsZXN9KSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoY29tcG9uZW50SWQpO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCBub3QgZm91bmQ6ICR7Y29tcG9uZW50SWR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IGF3YWl0IE5lby5tYWluLkRvbUFjY2Vzcy5nZXRDb21wdXRlZFN0eWxlKHtcbiAgICAgICAgICAgIGlkICAgOiBjb21wb25lbnQuaWQsXG4gICAgICAgICAgICBzdHlsZTogdmFyaWFibGVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7c3R5bGVzfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHBhcmFtcy5jb21wb25lbnRJZHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFzeW5jIGdldERvbVJlY3Qoe2NvbXBvbmVudElkc30pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbXBvbmVudElkcykgfHwgY29tcG9uZW50SWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb25lbnRJZHMgbXVzdCBiZSBhIG5vbi1lbXB0eSBhcnJheScpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IGNvbXBvbmVudCB0byByZXNvbHZlIHRoZSB3aW5kb3dJZCBjb250ZXh0XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoY29tcG9uZW50SWRzWzBdKTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgbm90IGZvdW5kOiAke2NvbXBvbmVudElkc1swXX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjdHMgPSBhd2FpdCBjb21wb25lbnQuZ2V0RG9tUmVjdChjb21wb25lbnRJZHMpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWN0czogQXJyYXkuaXNBcnJheShyZWN0cykgPyByZWN0cyA6IFtyZWN0c11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMub3B0aW9uc11cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGhpZ2hsaWdodENvbXBvbmVudCh7Y29tcG9uZW50SWQsIG9wdGlvbnN9KSB7XG4gICAgICAgIGxldCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGNvbXBvbmVudElkKSxcbiAgICAgICAgICAgIG9yaWdpbmFsU3R5bGU7XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IG5vdCBmb3VuZDogJHtjb21wb25lbnRJZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGNvbG9yICAgID0gb3B0aW9ucy5jb2xvciAgICB8fCAncmVkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCAyMDAwLFxuICAgICAgICAgICAgbW9kZSAgICAgPSBvcHRpb25zLnN0eWxlICAgIHx8ICdvdXRsaW5lJzsgLy8gJ291dGxpbmUnIG9yICdib3gtc2hhZG93J1xuXG4gICAgICAgIG9yaWdpbmFsU3R5bGUgPSBjb21wb25lbnQuc3R5bGUgfHwge307XG5cbiAgICAgICAgbGV0IGhpZ2hsaWdodFN0eWxlID0ge307XG5cbiAgICAgICAgaWYgKG1vZGUgPT09ICdvdXRsaW5lJykge1xuICAgICAgICAgICAgaGlnaGxpZ2h0U3R5bGUub3V0bGluZSAgICAgICA9IGAycHggc29saWQgJHtjb2xvcn1gO1xuICAgICAgICAgICAgaGlnaGxpZ2h0U3R5bGUub3V0bGluZU9mZnNldCA9ICctMnB4J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaGxpZ2h0U3R5bGUuYm94U2hhZG93ID0gYDAgMCAxMHB4ICR7Y29sb3J9LCBpbnNldCAwIDAgMTBweCAke2NvbG9yfWBcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvbmVudC5zdHlsZSA9IHsuLi5vcmlnaW5hbFN0eWxlLCAuLi5oaWdobGlnaHRTdHlsZX07XG5cbiAgICAgICAgdGhpcy50aW1lb3V0KGR1cmF0aW9uKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZSA9IG9yaWdpbmFsU3R5bGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtzdWNjZXNzOiB0cnVlfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5kZXB0aF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5yb290SWRdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnRUcmVlKHtkZXB0aCwgcm9vdElkfSkge1xuICAgICAgICByZXR1cm4ge3RyZWU6IHRoaXMuc2VyaWFsaXplQ29tcG9uZW50KHRoaXMuZ2V0Q29tcG9uZW50Um9vdChyb290SWQpLCBkZXB0aCB8fCAtMSl9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLmRlcHRoXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnJvb3RJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZkb21UcmVlKHtkZXB0aCwgcm9vdElkfSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudFJvb3Qocm9vdElkKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignUm9vdCBjb21wb25lbnQgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB7dmRvbTogVHJlZUJ1aWxkZXIuZ2V0VmRvbVRyZWUoY29tcG9uZW50LnZkb20sIGRlcHRoKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuZGVwdGhdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucm9vdElkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Vm5vZGVUcmVlKHtkZXB0aCwgcm9vdElkfSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudFJvb3Qocm9vdElkKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignUm9vdCBjb21wb25lbnQgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB7dm5vZGU6IFRyZWVCdWlsZGVyLmdldFZub2RlVHJlZShjb21wb25lbnQudm5vZGUsIGRlcHRoKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuZGVwdGhdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucm9vdElkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmRvbVZub2RlKHtkZXB0aCwgcm9vdElkfSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudFJvb3Qocm9vdElkKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignUm9vdCBjb21wb25lbnQgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZG9tIDogVHJlZUJ1aWxkZXIuZ2V0VmRvbVRyZWUoY29tcG9uZW50LnZkb20sIGRlcHRoKSxcbiAgICAgICAgICAgIHZub2RlOiBUcmVlQnVpbGRlci5nZXRWbm9kZVRyZWUoY29tcG9uZW50LnZub2RlLCBkZXB0aClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIFtwYXJhbXMucm9vdElkXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIHBhcmFtcy5zZWxlY3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IFtwYXJhbXMucmV0dXJuUHJvcGVydGllc11cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHF1ZXJ5Q29tcG9uZW50KHtyb290SWQsIHNlbGVjdG9yLCByZXR1cm5Qcm9wZXJ0aWVzfSkge1xuICAgICAgICBsZXQgbWF0Y2hlcztcblxuICAgICAgICBpZiAocm9vdElkKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KHJvb3RJZCk7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKGBSb290IGNvbXBvbmVudCBub3QgZm91bmQ6ICR7cm9vdElkfWApO1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGNvbXBvbmVudC5kb3duKHNlbGVjdG9yLCBmYWxzZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoZXMgPSBOZW8ubWFuYWdlci5Db21wb25lbnQuZmluZChzZWxlY3RvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBtYXRjaGVzLm1hcChjID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJldHVyblByb3BlcnRpZXMpICYmIHJldHVyblByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuUHJvcGVydGllcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1twcm9wXSA9IHRoaXMuc2FmZVNlcmlhbGl6ZShjW3Byb3BdKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIDogYy5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICA6IGMuaWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYy50b0pTT04oKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge2NvbXBvbmVudHN9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnJvb3RJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnNlbGVjdG9yXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBxdWVyeVZkb20oe3Jvb3RJZCwgc2VsZWN0b3J9KSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZ2V0Q29tcG9uZW50Um9vdChyb290SWQpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKCdSb290IGNvbXBvbmVudCBub3QgZm91bmQnKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBWZG9tVXRpbC5maW5kKGNvbXBvbmVudC52ZG9tLCBzZWxlY3Rvcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZkb20gICAgOiByZXN1bHQ/LnZkb20gfHwgbnVsbCxcbiAgICAgICAgICAgIGluZGV4ICAgOiByZXN1bHQ/LmluZGV4LFxuICAgICAgICAgICAgcGFyZW50SWQ6IHJlc3VsdD8ucGFyZW50Tm9kZT8uaWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcm9vdElkXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnRSb290KHJvb3RJZCkge1xuICAgICAgICBpZiAocm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudChyb290SWQpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcHBzID0gT2JqZWN0LnZhbHVlcyhOZW8uYXBwcyB8fCB7fSk7XG5cbiAgICAgICAgaWYgKGFwcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcHNbMF0ubWFpblZpZXdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEZXB0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50RGVwdGhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZUNvbXBvbmVudChjb21wb25lbnQsIG1heERlcHRoLCBjdXJyZW50RGVwdGg9MSkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcG9uZW50LnRvSlNPTigpO1xuXG4gICAgICAgIGlmIChtYXhEZXB0aCA9PT0gLTEgfHwgY3VycmVudERlcHRoIDwgbWF4RGVwdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gTmVvLm1hbmFnZXIuQ29tcG9uZW50LmdldENoaWxkQ29tcG9uZW50cyhjb21wb25lbnQpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pdGVtcyA9IGNoaWxkcmVuLm1hcChjaGlsZCA9PiB0aGlzLnNlcmlhbGl6ZUNvbXBvbmVudChjaGlsZCwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aCArIDEpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50U2VydmljZSk7XG4iLCJpbXBvcnQgU2VydmljZSAgICAgIGZyb20gJy4vU2VydmljZS5tanMnO1xuaW1wb3J0IFN0b3JlTWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogSGFuZGxlcyBkYXRhLXJlbGF0ZWQgTmV1cmFsIExpbmsgcmVxdWVzdHMuXG4gKiBAY2xhc3MgTmVvLmFpLmNsaWVudC5EYXRhU2VydmljZVxuICogQGV4dGVuZHMgTmVvLmFpLmNsaWVudC5TZXJ2aWNlXG4gKi9cbmNsYXNzIERhdGFTZXJ2aWNlIGV4dGVuZHMgU2VydmljZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuY2xpZW50LkRhdGFTZXJ2aWNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuY2xpZW50LkRhdGFTZXJ2aWNlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnJlY29yZElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuc3RvcmVJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJlY29yZCh7cmVjb3JkSWQsIHN0b3JlSWR9KSB7XG4gICAgICAgIGxldCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKHN0b3JlSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gTmVvLmdldChzdG9yZUlkKTtcbiAgICAgICAgICAgIGlmICghc3RvcmUpIHRocm93IG5ldyBFcnJvcihgU3RvcmUgbm90IGZvdW5kOiAke3N0b3JlSWR9YCk7XG4gICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXQocmVjb3JkSWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgICAgICBTdG9yZU1hbmFnZXIuaXRlbXMuZm9yRWFjaChzdG9yZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjID0gc3RvcmUuZ2V0KHJlY29yZElkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjKSBtYXRjaGVzLnB1c2gocmVjKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIHJlY29yZHMgZm91bmQgd2l0aCBJRCAke3JlY29yZElkfS4gUGxlYXNlIHNwZWNpZnkgc3RvcmVJZC5gKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IG1hdGNoZXNbMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVjb3JkKSB0aHJvdyBuZXcgRXJyb3IoYFJlY29yZCBub3QgZm91bmQ6ICR7cmVjb3JkSWR9YCk7XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZC50b0pTT04oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnByb3ZpZGVySWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGluc3BlY3RTdGF0ZVByb3ZpZGVyKHtwcm92aWRlcklkfSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IE5lby5nZXQocHJvdmlkZXJJZCk7XG4gICAgICAgIGlmICghcHJvdmlkZXIpIHRocm93IG5ldyBFcnJvcihgU3RhdGVQcm92aWRlciBub3QgZm91bmQ6ICR7cHJvdmlkZXJJZH1gKTtcblxuICAgICAgICByZXR1cm4gcHJvdmlkZXIudG9KU09OKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubGltaXQ9NTBdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMub2Zmc2V0PTBdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5zdG9yZUlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBpbnNwZWN0U3RvcmUoe2xpbWl0PTUwLCBvZmZzZXQ9MCwgc3RvcmVJZH0pIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBOZW8uZ2V0KHN0b3JlSWQpO1xuICAgICAgICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoYFN0b3JlIG5vdCBmb3VuZDogJHtzdG9yZUlkfWApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdG9yZS50b0pTT04oKSxcbiAgICAgICAgICAgIGl0ZW1zOiBzdG9yZS5nZXRSYW5nZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KS5tYXAocmVjb3JkID0+IHJlY29yZC50b0pTT04oKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxpc3RTdG9yZXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9yZXM6IFN0b3JlTWFuYWdlci5pdGVtcy5tYXAocyA9PiAoe1xuICAgICAgICAgICAgICAgIGlkICAgICAgOiBzLmlkLFxuICAgICAgICAgICAgICAgIG1vZGVsICAgOiBzLm1vZGVsPy5jbGFzc05hbWUgfHwgJ04vQScsXG4gICAgICAgICAgICAgICAgY291bnQgICA6IHMuY291bnQsXG4gICAgICAgICAgICAgICAgaXNMb2FkZWQ6IHMuaXNMb2FkZWRcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMuZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucHJvdmlkZXJJZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGVQcm92aWRlcih7ZGF0YSwgcHJvdmlkZXJJZH0pIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBOZW8uZ2V0KHByb3ZpZGVySWQpO1xuICAgICAgICBpZiAoIXByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlUHJvdmlkZXIgbm90IGZvdW5kOiAke3Byb3ZpZGVySWR9YCk7XG5cbiAgICAgICAgcHJvdmlkZXIuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtzdWNjZXNzOiB0cnVlfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRGF0YVNlcnZpY2UpO1xuIiwiaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi9TZXJ2aWNlLm1qcyc7XG5cbi8qKlxuICogSGFuZGxlcyBnZW5lcmljIGluc3RhbmNlLXJlbGF0ZWQgTmV1cmFsIExpbmsgcmVxdWVzdHMuXG4gKiBAY2xhc3MgTmVvLmFpLmNsaWVudC5JbnN0YW5jZVNlcnZpY2VcbiAqIEBleHRlbmRzIE5lby5haS5jbGllbnQuU2VydmljZVxuICovXG5jbGFzcyBJbnN0YW5jZVNlcnZpY2UgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5haS5jbGllbnQuSW5zdGFuY2VTZXJ2aWNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuY2xpZW50Lkluc3RhbmNlU2VydmljZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgcHJvcGVydGllcyBmcm9tIGEgc3BlY2lmaWMgaW5zdGFuY2UgYnkgaXRzIElELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGFyYW1zLnByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldEluc3RhbmNlUHJvcGVydGllcyh7aWQsIHByb3BlcnRpZXN9KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBpbnN0YW5jZSA9IE5lby5nZXQoaWQpLFxuICAgICAgICAgICAgcmVzdWx0ICAgPSB7fTtcblxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZDogJHtpZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSB0aGlzLnNhZmVTZXJpYWxpemUoaW5zdGFuY2VbcHJvcGVydHldKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge3Byb3BlcnRpZXM6IHJlc3VsdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBpbnN0YW5jZXMgbWF0Y2hpbmcgYSBzZWxlY3Rvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5zZWxlY3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IFtwYXJhbXMucmV0dXJuUHJvcGVydGllc11cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZpbmRJbnN0YW5jZXMoe3NlbGVjdG9yLCByZXR1cm5Qcm9wZXJ0aWVzfSkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZXMgPSBOZW8ubWFuYWdlci5JbnN0YW5jZS5maW5kKHNlbGVjdG9yKS5tYXAoaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmV0dXJuUHJvcGVydGllcykgJiYgcmV0dXJuUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm5Qcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3Byb3BdID0gdGhpcy5zYWZlU2VyaWFsaXplKGluc3RhbmNlW3Byb3BdKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIDogaW5zdGFuY2UuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgOiBpbnN0YW5jZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS50b0pTT04oKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge2luc3RhbmNlc31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHByb3BlcnRpZXMgb24gYSBzcGVjaWZpYyBpbnN0YW5jZSBieSBpdHMgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNldEluc3RhbmNlUHJvcGVydGllcyh7aWQsIHByb3BlcnRpZXN9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gTmVvLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQ6ICR7aWR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3RhbmNlLnNldChwcm9wZXJ0aWVzKTtcblxuICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IHRydWV9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhJbnN0YW5jZVNlcnZpY2UpO1xuIiwiaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi9TZXJ2aWNlLm1qcyc7XG5cbi8qKlxuICogU2VydmljZSBmb3IgaGFuZGxpbmcgaW50ZXJhY3Rpb24gc2ltdWxhdGlvbiBjb21tYW5kcy5cbiAqXG4gKiBAY2xhc3MgTmVvLmFpLmNsaWVudC5JbnRlcmFjdGlvblNlcnZpY2VcbiAqIEBleHRlbmRzIE5lby5haS5jbGllbnQuU2VydmljZVxuICovXG5jbGFzcyBJbnRlcmFjdGlvblNlcnZpY2UgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5haS5jbGllbnQuSW50ZXJhY3Rpb25TZXJ2aWNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuY2xpZW50LkludGVyYWN0aW9uU2VydmljZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZXMgYSBuYXRpdmUgRE9NIGV2ZW50IHNlcXVlbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcGFyYW1zLmV2ZW50cyAtIFNlcXVlbmNlIG9mIGV2ZW50IGNvbmZpZyBvYmplY3RzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgc2ltdWxhdGVFdmVudCh7ZXZlbnRzfSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShldmVudHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVyYWN0aW9uU2VydmljZTogZXZlbnRzIG11c3QgYmUgYW4gYXJyYXknKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5kZWxheSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoZXZlbnQuZGVsYXkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogZXZlbnQudGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA6IGV2ZW50Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdHlwZSAgICA6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IGV2ZW50LndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gZGlzcGF0Y2ggYSBzaW5nbGUgZXZlbnQgdG8gdGhlIGNvcnJlY3Qgd2luZG93XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLm9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCb29sZWFuPn1cbiAgICAgKi9cbiAgICBhc3luYyBkaXNwYXRjaCh7aWQsIG9wdGlvbnMsIHR5cGUsIHdpbmRvd0lkfSkge1xuICAgICAgICBhd2FpdCBOZW8uTWFpbi5pbXBvcnRBZGRvbih7bmFtZTogJ0V2ZW50U2ltdWxhdG9yJywgd2luZG93SWR9KTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgTmVvLm1haW4uYWRkb24uRXZlbnRTaW11bGF0b3IuZGlzcGF0Y2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhJbnRlcmFjdGlvblNlcnZpY2UpO1xuIiwiaW1wb3J0IERvbUV2ZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0RvbUV2ZW50Lm1qcyc7XG5pbXBvcnQgSGFzaEhpc3RvcnkgICAgIGZyb20gJy4uLy4uL3V0aWwvSGFzaEhpc3RvcnkubWpzJztcbmltcG9ydCBTZXJ2aWNlICAgICAgICAgZnJvbSAnLi9TZXJ2aWNlLm1qcyc7XG5cbi8qKlxuICogSGFuZGxlcyBydW50aW1lIGVudmlyb25tZW50IHJlbGF0ZWQgTmV1cmFsIExpbmsgcmVxdWVzdHMuXG4gKiBAY2xhc3MgTmVvLmFpLmNsaWVudC5SdW50aW1lU2VydmljZVxuICogQGV4dGVuZHMgTmVvLmFpLmNsaWVudC5TZXJ2aWNlXG4gKi9cbmNsYXNzIFJ1bnRpbWVTZXJ2aWNlIGV4dGVuZHMgU2VydmljZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuY2xpZW50LlJ1bnRpbWVTZXJ2aWNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuY2xpZW50LlJ1bnRpbWVTZXJ2aWNlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG5hbWVzcGFjZSBleGlzdHMgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubmFtZXNwYWNlXG4gICAgICogQHJldHVybnMge09iamVjdH0ge2V4aXN0czogQm9vbGVhbn1cbiAgICAgKi9cbiAgICBjaGVja05hbWVzcGFjZSh7bmFtZXNwYWNlfSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhpc3RzOiAhIU5lby5ucyhuYW1lc3BhY2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5jb21wb25lbnRJZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RG9tRXZlbnRMaXN0ZW5lcnMoe2NvbXBvbmVudElkfSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gW10sXG4gICAgICAgICAgICBldmVudE1hcCAgPSBEb21FdmVudE1hbmFnZXIuaXRlbXM/Lltjb21wb25lbnRJZF07XG5cbiAgICAgICAgaWYgKGV2ZW50TWFwKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhldmVudE1hcCkuZm9yRWFjaCgoW2V2ZW50TmFtZSwgZXZlbnRzXSkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGU6IGV2ZW50LmRlbGVnYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgICA6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgOiB0eXBlb2YgZXZlbnQuZm4gPT09ICdmdW5jdGlvbicgPyBldmVudC5mbi5uYW1lIHx8ICdhbm9ueW1vdXMnIDogZXZlbnQuZm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogZXZlbnQucHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSAgIDogZXZlbnQuc2NvcGU/LmlkIHx8ICd1bmtub3duJ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtsaXN0ZW5lcnN9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RG9tRXZlbnRTdW1tYXJ5KHBhcmFtcykge1xuICAgICAgICBjb25zdCBzdW1tYXJ5ID0ge1xuICAgICAgICAgICAgYnlDb21wb25lbnQ6IHt9LFxuICAgICAgICAgICAgYnlFdmVudCAgICA6IHt9LFxuICAgICAgICAgICAgdG90YWxFdmVudHM6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3QuZW50cmllcyhEb21FdmVudE1hbmFnZXIuaXRlbXMpLmZvckVhY2goKFtjb21wb25lbnRJZCwgZXZlbnRNYXBdKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50Q291bnQgPSAwO1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhldmVudE1hcCkuZm9yRWFjaCgoW2V2ZW50TmFtZSwgZXZlbnRzXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZXZlbnRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHN1bW1hcnkudG90YWxFdmVudHMgICAgICAgKz0gY291bnQ7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Q291bnQgICAgICAgICAgICArPSBjb3VudDtcbiAgICAgICAgICAgICAgICBzdW1tYXJ5LmJ5RXZlbnRbZXZlbnROYW1lXSA9IChzdW1tYXJ5LmJ5RXZlbnRbZXZlbnROYW1lXSB8fCAwKSArIGNvdW50XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHN1bW1hcnkuYnlDb21wb25lbnRbY29tcG9uZW50SWRdID0gY29tcG9uZW50Q291bnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN1bW1hcnlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREcmFnU3RhdGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRyYWdDb29yZGluYXRvciA9IE5lby5tYW5hZ2VyPy5EcmFnQ29vcmRpbmF0b3I7XG5cbiAgICAgICAgaWYgKGRyYWdDb29yZGluYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWdDb29yZGluYXRvci50b0pTT04oKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc291cmNlIGNvZGUgb2YgYSBtZXRob2Qgb24gYSBjbGFzcyBwcm90b3R5cGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY2xhc3NOYW1lICBUaGUgZnVsbHkgcXVhbGlmaWVkIGNsYXNzIG5hbWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5tZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QuXG4gICAgICogQHJldHVybnMge09iamVjdH0ge3N1Y2Nlc3M6IEJvb2xlYW4sIHNvdXJjZT86IFN0cmluZywgZXJyb3I/OiBTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TWV0aG9kU291cmNlKHtjbGFzc05hbWUsIG1ldGhvZE5hbWV9KSB7XG4gICAgICAgIGNvbnN0IGNscyA9IE5lby5ucyhjbGFzc05hbWUpO1xuXG4gICAgICAgIGlmICghY2xzKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYENsYXNzICcke2NsYXNzTmFtZX0nIG5vdCBmb3VuZGB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eXBlID0gTmVvLnR5cGVPZihjbHMpO1xuICAgICAgICBsZXQgcHJvdG87XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgIHByb3RvID0gY2xzLnByb3RvdHlwZVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgIHByb3RvID0gY2xzLmNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBUYXJnZXQgJyR7Y2xhc3NOYW1lfScgaXMgbm90IGEgTmVvIGNsYXNzIG9yIGluc3RhbmNlYH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9bbWV0aG9kTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3VjY2VzczogZmFsc2UsIGVycm9yOiBgTWV0aG9kICcke21ldGhvZE5hbWV9JyBub3QgZm91bmQgb24gJyR7Y2xhc3NOYW1lfSdgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBzb3VyY2UgOiBwcm90b1ttZXRob2ROYW1lXS50b1N0cmluZygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxvYWRlZCBuYW1lc3BhY2UgdHJlZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucm9vdD0nTmVvJ10gVGhlIHJvb3QgbmFtZXNwYWNlIHRvIHN0YXJ0IGZyb20gKGUuZy4sICdOZW8nLCAnTXlBcHAnKS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldE5hbWVzcGFjZVRyZWUoe3Jvb3Q9J05lbyd9KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RhcnROb2RlID0gTmVvLm5zKHJvb3QpLFxuICAgICAgICAgICAgdHJlZSAgICAgID0ge307XG5cbiAgICAgICAgaWYgKCFzdGFydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7dHJlZToge30sIGVycm9yOiBgTmFtZXNwYWNlICcke3Jvb3R9JyBub3QgZm91bmRgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuI3RyYXZlcnNlTmFtZXNwYWNlKHN0YXJ0Tm9kZSwgcm9vdCwgdHJlZSk7XG5cbiAgICAgICAgcmV0dXJuIHtyb290LCB0cmVlfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy53aW5kb3dJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldE5lb0NvbmZpZyh7d2luZG93SWR9KSB7XG4gICAgICAgIGlmICh3aW5kb3dJZCkge1xuICAgICAgICAgICAgcmV0dXJuIE5lby53aW5kb3dDb25maWdzPy5bd2luZG93SWRdIHx8IG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTmVvLmNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy53aW5kb3dJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJvdXRlSGlzdG9yeSh7d2luZG93SWR9KSB7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gSGFzaEhpc3RvcnkuZ2V0U3RhY2sod2luZG93SWQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb3VudCAgIDogc3RhY2subGVuZ3RoLFxuICAgICAgICAgICAgaGlzdG9yeSA6IHN0YWNrLFxuICAgICAgICAgICAgd2luZG93SWQ6IHdpbmRvd0lkIHx8IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFdpbmRvd0luZm8ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd01hbmFnZXIgPSBOZW8ubWFuYWdlcj8uV2luZG93O1xuXG4gICAgICAgIGlmICh3aW5kb3dNYW5hZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93TWFuYWdlci50b0pTT04oKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt3aW5kb3dzOiBbXX07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zcGVjdHMgYSBjbGFzcyB0byByZXRyaWV2ZSBpdHMgZnVsbCBzY2hlbWEgKGNvbmZpZ3MsIG1ldGhvZHMsIGhpZXJhcmNoeSkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuZGV0YWlsPSdzdGFuZGFyZCddICdzdGFuZGFyZCcgfCAnY29tcGFjdCdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGluc3BlY3RDbGFzcyh7Y2xhc3NOYW1lLCBkZXRhaWw9J3N0YW5kYXJkJ30pIHtcbiAgICAgICAgY29uc3QgY2xzID0gTmVvLm5zKGNsYXNzTmFtZSk7XG5cbiAgICAgICAgaWYgKCFjbHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xhc3Mgbm90IGZvdW5kOiAke2NsYXNzTmFtZX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGlzQ2xhc3MgPSBjbHMuaXNDbGFzcyxcbiAgICAgICAgICAgIGN0b3IgICAgPSBpc0NsYXNzID8gY2xzIDogY2xzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgcHJvdG8gICA9IGN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgIC8vIDEuIEhpZXJhcmNoeSAmIE1peGluc1xuICAgICAgICBjb25zdCBnZXRNaXhpbk5hbWVzID0gKG9iaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXMob2JqKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2godmFsdWUucHJvdG90eXBlLmNsYXNzTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goLi4uZ2V0TWl4aW5OYW1lcyh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWVzXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMi4gQ29uZmlncyAmIE1ldGhvZHNcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGNvbmZpZ3MgICAgICAgID0ge30sXG4gICAgICAgICAgICBtZXRob2RzICAgICAgICA9IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGNvbmZpZ0tleXMgICAgID0gbmV3IFNldChPYmplY3Qua2V5cyhjdG9yLmNvbmZpZykpLFxuICAgICAgICAgICAgZGVzY3JpcHRvcnMgICAgPSBjdG9yLmNvbmZpZ0Rlc2NyaXB0b3JzIHx8IHt9LFxuICAgICAgICAgICAgaWdub3JlZFByb3BzICAgPSBbJ2NvbnN0cnVjdG9yJywgJ2NvbnN0cnVjdCcsICdpbml0JywgJ29uQ29uc3RydWN0ZWQnLCAnb25BZnRlckNvbnN0cnVjdGVkJ10sXG4gICAgICAgICAgICBob29rUmVnZXggICAgICA9IC9eKGJlZm9yZXxhZnRlcikoR2V0fFNldCkoW0EtWl0pLyxcbiAgICAgICAgICAgIC8vIEhlbHBlciB0byBnZXQgcmF3IGhvb2sgbmFtZSBmcm9tIGNvbmZpZyBrZXlcbiAgICAgICAgICAgIGdldEhvb2tOYW1lICAgID0gKHByZWZpeCwga2V5KSA9PiBwcmVmaXggKyBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcblxuICAgICAgICAvLyBTZXJpYWxpemUgdGhlIGRlZmF1bHQgdmFsdWVzIGZpcnN0XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSB0aGlzLnNlcmlhbGl6ZUNvbmZpZyhjdG9yLmNvbmZpZyk7XG5cbiAgICAgICAgLy8gR2V0IHN1cGVyY2xhc3MgY29uZmlnIGZvciBjb21wYXJpc29uIGluIGNvbXBhY3QgbW9kZVxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgc3VwZXJDdG9yICAgPSBjdG9yLl9fcHJvdG9fXyxcbiAgICAgICAgICAgIHN1cGVyQ29uZmlnID0gc3VwZXJDdG9yPy5jb25maWcgfHwge307XG5cbiAgICAgICAgLy8gUHJvY2VzcyBDb25maWdzXG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRWYWx1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIC8vIEluIGNvbXBhY3QgbW9kZSwgb25seSBpbmNsdWRlIGNvbmZpZ3MgdGhhdCBhcmUgXCJvd25cIiAobm90IGluIHN1cGVyIG9yIGNoYW5nZWQpXG4gICAgICAgICAgICBpZiAoZGV0YWlsID09PSAnY29tcGFjdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc093biA9ICFPYmplY3QuaGFzT3duKHN1cGVyQ29uZmlnLCBrZXkpIHx8IHN1cGVyQ29uZmlnW2tleV0gIT09IGN0b3IuY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCFpc093bikgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZ3Nba2V5XSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVmYXVsdFZhbHVlc1trZXldXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBBZGQgRGVzY3JpcHRvciBpbmZvIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3JzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25maWdzW2tleV0ubWV0YSA9IHRoaXMuc2VyaWFsaXplQ29uZmlnKGRlc2NyaXB0b3JzW2tleV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBIb29rc1xuICAgICAgICAgICAgY29uc3QgaG9va3MgPSBbXTtcbiAgICAgICAgICAgIFsnYmVmb3JlR2V0JywgJ2JlZm9yZVNldCcsICdhZnRlclNldCddLmZvckVhY2gocHJlZml4ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBob29rTmFtZSA9IGdldEhvb2tOYW1lKHByZWZpeCwga2V5KTtcbiAgICAgICAgICAgICAgICAvLyBJbiBjb21wYWN0IG1vZGUsIG9ubHkgY2hlY2sgZm9yIGhvb2tzIG9uIHRoZSBjdXJyZW50IHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIGlmIChkZXRhaWwgPT09ICdjb21wYWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihwcm90bywgaG9va05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rcy5wdXNoKHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG9baG9va05hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rcy5wdXNoKHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaG9va3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3Nba2V5XS5ob29rcyA9IGhvb2tzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgTWV0aG9kc1xuICAgICAgICBsZXQgY3VycmVudFByb3RvID0gcHJvdG87XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgdXAgdG8gTmVvLmNvcmUuQmFzZVxuICAgICAgICB3aGlsZSAoY3VycmVudFByb3RvICYmIGN1cnJlbnRQcm90by5jb25zdHJ1Y3Rvci5jbGFzc05hbWUgIT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdXJyZW50UHJvdG8pLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhY29uZmlnS2V5cy5oYXMobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlnbm9yZWRQcm9wcy5pbmNsdWRlcyhuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAhbmFtZS5zdGFydHNXaXRoKCdfJykgJiZcbiAgICAgICAgICAgICAgICAgICAgIW5hbWUuc3RhcnRzV2l0aCgnIycpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBob29rXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tNYXRjaCA9IG5hbWUubWF0Y2goaG9va1JlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvb2tNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBob29rLiBXZSBvbmx5IGNhcmUgaWYgaXQgd2Fzbid0IGFscmVhZHkgY2F1Z2h0IGJ5IHRoZSBjb25maWcgbG9vcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBzaW5jZSB3ZSB3YW50IGEgY2xlYW4gbWV0aG9kIGxpc3QsIHdlIGdlbmVyYWxseSBleGNsdWRlIGhvb2tzIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnIGxvb3AgYWJvdmUgY2FwdHVyZXMgaG9va3MgKmFzc29jaWF0ZWQgd2l0aCBrbm93biBjb25maWdzKi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ycGhhbmVkIGhvb2tzIChmb3Igbm9uLWV4aXN0ZW50IGNvbmZpZ3M/KSBhcmUgcmFyZS9pbnZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3VycmVudFByb3RvLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHMuYWRkKG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSW4gY29tcGFjdCBtb2RlLCB3ZSBvbmx5IGxvb2sgYXQgdGhlIHRvcC1sZXZlbCBwcm90b3R5cGVcbiAgICAgICAgICAgIGlmIChkZXRhaWwgPT09ICdjb21wYWN0Jykge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRQcm90byA9IGN1cnJlbnRQcm90by5fX3Byb3RvX19cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGFzc05hbWUgOiBwcm90by5jbGFzc05hbWUsXG4gICAgICAgICAgICBudHlwZSAgICAgOiBwcm90by5udHlwZSxcbiAgICAgICAgICAgIG50eXBlQ2hhaW46IGN0b3IubnR5cGVDaGFpbixcbiAgICAgICAgICAgIHN1cGVyQ2xhc3M6IHByb3RvLl9fcHJvdG9fXz8uY29uc3RydWN0b3I/LmNvbmZpZz8uY2xhc3NOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBtaXhpbnMgICAgOiBwcm90by5taXhpbnMgPyBnZXRNaXhpbk5hbWVzKHByb3RvLm1peGlucykgOiBbXSxcbiAgICAgICAgICAgIGNvbmZpZ3MsXG4gICAgICAgICAgICBtZXRob2RzICAgOiBBcnJheS5mcm9tKG1ldGhvZHMpLnNvcnQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYSBtZXRob2QgaW1wbGVtZW50YXRpb24gb24gYSBjbGFzcyBwcm90b3R5cGUgYXQgcnVudGltZS5cbiAgICAgKiBSRVNUUklDVEVEOiBSZXF1aXJlcyBOZW8uY29uZmlnLmVuYWJsZUhvdFBhdGNoaW5nID0gdHJ1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNsYXNzTmFtZSAgVGhlIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lIChlLmcuLCAnTmVvLmJ1dHRvbi5CYXNlJylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBwYXRjaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuc291cmNlICAgICBUaGUgbmV3IGZ1bmN0aW9uIHNvdXJjZSBjb2RlIChlLmcuLCAnZnVuY3Rpb24oYXJncykgeyAuLi4gfScgb3IgJ2FzeW5jIChhcmdzKSA9PiB7IC4uLiB9JylcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7c3VjY2VzczogQm9vbGVhbiwgZXJyb3I/OiBTdHJpbmd9XG4gICAgICovXG4gICAgcGF0Y2hDb2RlKHtjbGFzc05hbWUsIG1ldGhvZE5hbWUsIHNvdXJjZX0pIHtcbiAgICAgICAgaWYgKE5lby5jb25maWcuZW5hYmxlSG90UGF0Y2hpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3IgIDogJ0hvdCBwYXRjaGluZyBpcyBkaXNhYmxlZC4gU2V0IE5lby5jb25maWcuZW5hYmxlSG90UGF0Y2hpbmcgPSB0cnVlIHRvIGVuYWJsZS4nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbHMgPSBOZW8ubnMoY2xhc3NOYW1lKTtcblxuICAgICAgICBpZiAoIWNscykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvciAgOiBgQ2xhc3MgJyR7Y2xhc3NOYW1lfScgbm90IGZvdW5kYFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbHMucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yICA6IGBDbGFzcyAnJHtjbGFzc05hbWV9JyBoYXMgbm8gcHJvdG90eXBlIChpcyBpdCBhIHNpbmdsZXRvbj8pYFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFVzZSBuZXcgRnVuY3Rpb24gdG8gcGFyc2UgdGhlIHNvdXJjZSBjb2RlIHNhZmVseSBpbnRvIGEgZnVuY3Rpb24gb2JqZWN0LlxuICAgICAgICAgICAgLy8gVGhpcyBhdm9pZHMgZGlyZWN0IHVzZSBvZiBldmFsKCkgYW5kIGVuc3VyZXMgdGhlIGNvZGUgcnVucyBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAgICAgICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBzb3VyY2UpKCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgIDogJ1NvdXJjZSBkaWQgbm90IGV2YWx1YXRlIHRvIGEgZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxLiBMb2cgdGhlIHBhdGNoIGZvciBhdWRpdFxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbTmVvLmFpLmNsaWVudC5SdW50aW1lU2VydmljZV0gSG90LXBhdGNoaW5nICR7Y2xhc3NOYW1lfS5wcm90b3R5cGUuJHttZXRob2ROYW1lfWApO1xuXG4gICAgICAgICAgICAvLyAyLiBBcHBseSB0aGUgcGF0Y2hcbiAgICAgICAgICAgIGNscy5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmbjtcblxuICAgICAgICAgICAgLy8gMy4gTWFyayBtZXRob2QgYXMgcGF0Y2hlZCAodXNlZnVsIGZvciBkZWJ1Z2dpbmcpXG4gICAgICAgICAgICBmbi4kaXNQYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLiRvcmlnaW5hbFNvdXJjZSA9IHNvdXJjZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtzdWNjZXNzOiB0cnVlfVxuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tOZW8uYWkuY2xpZW50LlJ1bnRpbWVTZXJ2aWNlXSBIb3QgcGF0Y2ggZmFpbGVkOicsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvciAgOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHJlbG9hZFBhZ2UocGFyYW1zKSB7XG4gICAgICAgIE5lby5NYWluLnJlbG9hZFdpbmRvdygpO1xuICAgICAgICByZXR1cm4ge3N0YXR1czogJ3JlbG9hZGluZyd9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLmNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc2V0TmVvQ29uZmlnKHtjb25maWd9KSB7XG4gICAgICAgIE5lby5zZXRHbG9iYWxDb25maWcoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHtzdGF0dXM6ICdvayd9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuaGFzaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLndpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc2V0Um91dGUoe2hhc2gsIHdpbmRvd0lkfSkge1xuICAgICAgICBOZW8uTWFpbi5zZXRSb3V0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogaGFzaCxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7c3RhdHVzOiAnb2snLCBoYXNofVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0XG4gICAgICovXG4gICAgI3RyYXZlcnNlTmFtZXNwYWNlKG5vZGUsIHBhdGgsIG91dHB1dCkge1xuICAgICAgICBPYmplY3Qua2V5cyhub2RlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgID0gbm9kZVtrZXldLFxuICAgICAgICAgICAgICAgIHR5cGUgICAgICAgID0gTmVvLnR5cGVPZih2YWx1ZSksXG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGggPSBwYXRoID8gYCR7cGF0aH0uJHtrZXl9YCA6IGtleTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdOZW9DbGFzcycpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAgICAgOiAnY2xhc3MnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHZhbHVlLnByb3RvdHlwZS5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAgICAgOiAnc2luZ2xldG9uJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB2YWx1ZS5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSB0cmF2ZXJzZSBwbGFpbiBvYmplY3RzIChuYW1lc3BhY2VzKVxuICAgICAgICAgICAgICAgIC8vIE5lby50eXBlT2YgcmV0dXJucyAnT2JqZWN0JyBmb3IgcGxhaW4gb2JqZWN0c1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy4jdHJhdmVyc2VOYW1lc3BhY2UodmFsdWUsIGN1cnJlbnRQYXRoLCBvdXRwdXRba2V5XSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBlbXB0eSBwYWNrYWdlc1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvdXRwdXRba2V5XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdXRwdXRba2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFJ1bnRpbWVTZXJ2aWNlKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIE5ldXJhbCBMaW5rIENsaWVudCBTZXJ2aWNlcy5cbiAqIEBjbGFzcyBOZW8uYWkuY2xpZW50LlNlcnZpY2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgU2VydmljZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFpLmNsaWVudC5TZXJ2aWNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuY2xpZW50LlNlcnZpY2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmFpLkNsaWVudHxudWxsfSBjbGllbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGllbnQ6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2FmZVNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gTmVvLnR5cGVPZih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0pTT04oKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRba10gPSB0aGlzLnNhZmVTZXJpYWxpemUodilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAodiA9PiB0aGlzLnNhZmVTZXJpYWxpemUodikpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNlcnZpY2UpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQge2NyZWF0ZUludGVyY2VwdG9yfSBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKi9cbmNsYXNzIFNvY2tldCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzb2NrZXQtY29ubmVjdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzb2NrZXQtY29ubmVjdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gYmFja29mZlN0cmF0ZWd5PWF0dGVtcHQ9Pk1hdGgubWluKDEwMDAqTWF0aC5wb3coMixhdHRlbXB0LTEpLDMwMDAwKVxuICAgICAgICAgKi9cbiAgICAgICAgYmFja29mZlN0cmF0ZWd5OiBhdHRlbXB0ID0+IE1hdGgubWluKDEwMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSksIDMwMDAwKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1dlYlNvY2tldHxudWxsfSBzb2NrZXRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvY2tldF86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY2hhbm5lbD1udWxsXG4gICAgICovXG4gICAgY2hhbm5lbCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heFJlY29ubmVjdEF0dGVtcHRzPTVcbiAgICAgKi9cbiAgICBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IDVcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1lc3NhZ2VDYWxsYmFja3M9e31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbWVzc2FnZUNhbGxiYWNrcyA9IHt9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBtZXNzYWdlSWQ9MVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXNzYWdlSWQgPSAxXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSByZWNvbm5lY3RBdHRlbXB0cz0wXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlY29ubmVjdEF0dGVtcHRzID0gMFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzZXJ2ZXJBZGRyZXNzPW51bGxcbiAgICAgKi9cbiAgICBzZXJ2ZXJBZGRyZXNzID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY3JlYXRlU29ja2V0KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICAgICAqL1xuICAgIGFzeW5jIGF0dGVtcHRSZWNvbm5lY3QoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUucmVjb25uZWN0QXR0ZW1wdHMrKztcblxuICAgICAgICBpZiAobWUucmVjb25uZWN0QXR0ZW1wdHMgPCBtZS5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBtZS5iYWNrb2ZmU3RyYXRlZ3kobWUucmVjb25uZWN0QXR0ZW1wdHMpO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdyZWNvbm5lY3RpbmcnLCB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdCAgICA6IG1lLnJlY29ubmVjdEF0dGVtcHRzLFxuICAgICAgICAgICAgICAgIG1heEF0dGVtcHRzOiBtZS5tYXhSZWNvbm5lY3RBdHRlbXB0cyxcbiAgICAgICAgICAgICAgICBkZWxheVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBXZWJTb2NrZXQgcmVjb25uZWN0IGF0dGVtcHQgJHttZS5yZWNvbm5lY3RBdHRlbXB0c30vJHttZS5tYXhSZWNvbm5lY3RBdHRlbXB0c30gaW4gJHtkZWxheX1tc2ApO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KGRlbGF5KTtcblxuICAgICAgICAgICAgaWYgKCFtZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZVNvY2tldCgpO1xuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgbWUub24oJ29wZW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSA6IHNjb3BlIHx8IG1lLFxuICAgICAgICAgICAgICAgICAgICBzaW5nbGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyByZWFjaGVkJyk7XG4gICAgICAgICAgICBtZS5maXJlKCdyZWNvbm5lY3RfZmFpbGVkJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVyY2VwdHMgdGhlIFdlYlNvY2tldCBzZW5kIGNhbGxzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNlbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjaGFubmVsfSA9IG1lO1xuXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjaGFubmVsID8ge2NoYW5uZWwsIGRhdGF9IDogZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzb2NrZXQgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7V2ViU29ja2V0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1dlYlNvY2tldHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTb2NrZXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZSwge1xuICAgICAgICAgICAgICAgIG9uY2xvc2UgIDogbWUub25DbG9zZSAgLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uZXJyb3IgIDogbWUub25FcnJvciAgLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9ubWVzc2FnZTogbWUub25NZXNzYWdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9ub3BlbiAgIDogbWUub25PcGVuICAgLmJpbmQobWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY3JlYXRlSW50ZXJjZXB0b3IodmFsdWUsICdzZW5kJywgbWUuYmVmb3JlU2VuZCwgbWUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIGRlZmF1bHRzIHRvIDEwMDBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlYXNvbl1cbiAgICAgKi9cbiAgICBjbG9zZShjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlU29ja2V0KCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5zZXJ2ZXJBZGRyZXNzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2xvc2VFdmVudH0gZXZlbnQgVGhlIFdlYnNvY2tldCBnZW5lcmF0ZWQgQ2xvc2VFdmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgZXZlbnQuY29kZSBUaGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSBwcm92aWRlZCBieSB0aGUgc2VydmVyXG4gICAgICpcbiAgICAgKiAgICAgICAgQ29kZSAgICAgICAgTmFtZSAgICAgICAgICAgICAgICAgIERlc2NyaXB0aW9uXG4gICAgICogICAgICAgIDAtOTk5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXNlcnZlZCBhbmQgbm90IHVzZWQuXG4gICAgICogICAgICAgIDEwMDAgICAgICAgIENMT1NFX05PUk1BTCAgICAgICAgICBOb3JtYWwgY2xvc3VyZTsgdGhlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB3aGF0ZXZlciBwdXJwb3NlIGZvciB3aGljaCBpdCB3YXMgY3JlYXRlZC5cbiAgICAgKiAgICAgICAgMTAwMSAgICAgICAgQ0xPU0VfR09JTkdfQVdBWSAgICAgIFRoZSBlbmRwb2ludCBpcyBnb2luZyBhd2F5LCBlaXRoZXIgYmVjYXVzZSBvZiBhIHNlcnZlciBmYWlsdXJlIG9yIGJlY2F1c2UgdGhlIGJyb3dzZXIgaXMgbmF2aWdhdGluZyBhd2F5IGZyb20gdGhlIHBhZ2UgdGhhdCBvcGVuZWQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICogICAgICAgIDEwMDIgICAgICAgIENMT1NFX1BST1RPQ09MX0VSUk9SICBUaGUgZW5kcG9pbnQgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gZHVlIHRvIGEgcHJvdG9jb2wgZXJyb3IuXG4gICAgICogICAgICAgIDEwMDMgICAgICAgIENMT1NFX1VOU1VQUE9SVEVEICAgICBUaGUgY29ubmVjdGlvbiBpcyBiZWluZyB0ZXJtaW5hdGVkIGJlY2F1c2UgdGhlIGVuZHBvaW50IHJlY2VpdmVkIGRhdGEgb2YgYSB0eXBlIGl0IGNhbm5vdCBhY2NlcHQgKGZvciBleGFtcGxlLCBhIHRleHQtb25seSBlbmRwb2ludCByZWNlaXZlZCBiaW5hcnkgZGF0YSkuXG4gICAgICogICAgICAgIDEwMDQgICAgICAgIENMT1NFX1RPT19MQVJHRSAgICAgICBUaGUgZW5kcG9pbnQgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBhIGRhdGEgZnJhbWUgd2FzIHJlY2VpdmVkIHRoYXQgaXMgdG9vIGxhcmdlLlxuICAgICAqICAgICAgICAxMDA1ICAgICAgICBDTE9TRV9OT19TVEFUVVMgICAgICAgUmVzZXJ2ZWQuICBJbmRpY2F0ZXMgdGhhdCBubyBzdGF0dXMgY29kZSB3YXMgcHJvdmlkZWQgZXZlbiB0aG91Z2ggb25lIHdhcyBleHBlY3RlZC5cbiAgICAgKiAgICAgICAgMTAwNiAgICAgICAgQ0xPU0VfQUJOT1JNQUwgICAgICAgIFJlc2VydmVkLiBVc2VkIHRvIGluZGljYXRlIHRoYXQgYSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWJub3JtYWxseSAodGhhdCBpcywgd2l0aCBubyBjbG9zZSBmcmFtZSBiZWluZyBzZW50KSB3aGVuIGEgc3RhdHVzIGNvZGUgaXMgZXhwZWN0ZWQuXG4gICAgICogICAgICAgIDEwMDctMTk5OSAgICAgICAgICAgICAgICAgICAgICAgICBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBieSB0aGUgV2ViU29ja2V0IHN0YW5kYXJkLlxuICAgICAqICAgICAgICAyMDAwLTI5OTkgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgZm9yIHVzZSBieSBXZWJTb2NrZXQgZXh0ZW5zaW9ucy5cbiAgICAgKiAgICAgICAgMzAwMC0zOTk5ICAgICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSBmb3IgdXNlIGJ5IGxpYnJhcmllcyBhbmQgZnJhbWV3b3Jrcy4gTWF5IG5vdCBiZSB1c2VkIGJ5IGFwcGxpY2F0aW9ucy5cbiAgICAgKiAgICAgICAgNDAwMC00OTk5ICAgICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSBmb3IgdXNlIGJ5IGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgcmVhc29uIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHJlYXNvbiB0aGUgc2VydmVyIGNsb3NlZCB0aGUgY29ubmVjdGlvbi4gVGhpcyBpcyBzcGVjaWZpYyB0byB0aGUgcGFydGljdWxhciBzZXJ2ZXIgYW5kIHN1Yi1wcm90b2NvbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgIHdhc0NsZWFuIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgY29ubmVjdGlvbiB3YXMgY2xlYW5seSBjbG9zZWQuXG4gICAgICovXG4gICAgb25DbG9zZShldmVudCwgcmVhc29uLCB3YXNDbGVhbikge1xuICAgICAgICB0aGlzLmZpcmUoJ2Nsb3NlJywge2V2ZW50LCByZWFzb24sIHdhc0NsZWFufSk7XG5cbiAgICAgICAgLy8gQXV0by1yZWNvbm5lY3Qgb24gYWJub3JtYWwgY2xvc3VyZVxuICAgICAgICBpZiAoIXdhc0NsZWFuIHx8IGV2ZW50LmNvZGUgIT09IDEwMDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViU29ja2V0IGNsb3NlZCBhYm5vcm1hbGx5LCBhdHRlbXB0aW5nIHJlY29ubmVjdC4uLicpO1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25FcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG5cbiAgICAgICAgbWUuZmlyZSgnbWVzc2FnZScsIHtkYXRhfSk7XG5cbiAgICAgICAgaWYgKGRhdGEubUlkKSB7XG4gICAgICAgICAgICBtZS5tZXNzYWdlQ2FsbGJhY2tzW2RhdGEubUlkXS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICAgICAgICBkZWxldGUgbWUubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1JZF1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25PcGVuKCkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5maXJlKCdvcGVuJywge3Njb3BlOiB0aGlzfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZU1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZS5tZXNzYWdlQ2FsbGJhY2tzW21lLm1lc3NhZ2VJZF0gPSB7cmVqZWN0LCByZXNvbHZlfTtcblxuICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2Uoe2RhdGEsIG1JZDogbWUubWVzc2FnZUlkfSk7XG4gICAgICAgICAgICBtZS5tZXNzYWdlSWQrK1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3NvY2tldH0gPSBtZSxcbiAgICAgICAgICAgIGQgICAgICAgID0gZGF0YTtcblxuICAgICAgICAvLyBDT05ORUNUSU5HICAwICAgVGhlIGNvbm5lY3Rpb24gaXMgbm90IHlldCBvcGVuLlxuICAgICAgICAvLyBPUEVOICAgICAgICAxICAgVGhlIGNvbm5lY3Rpb24gaXMgb3BlbiBhbmQgcmVhZHkgdG8gY29tbXVuaWNhdGUuXG4gICAgICAgIC8vIENMT1NJTkcgICAgIDIgICBUaGUgY29ubmVjdGlvbiBpcyBpbiB0aGUgcHJvY2VzcyBvZiBjbG9zaW5nLlxuICAgICAgICAvLyBDTE9TRUQgICAgICAzICAgVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkIG9yIGNvdWxkbid0IGJlIG9wZW5lZC5cblxuICAgICAgICAvLyBJZiBzb2NrZXQgaXMgbm90IHlldCByZWFkeSBsZXQncyBkZWZlciB0byBvcGVuIHRoZW4gcmVzZW5kXG4gICAgICAgIHN3aXRjaCAoc29ja2V0LnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0LkNMT1NFRDpcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0LkNMT1NJTkc6XG4gICAgICAgICAgICAgICAgbWUuYXR0ZW1wdFJlY29ubmVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UoZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DT05ORUNUSU5HOlxuICAgICAgICAgICAgICAgIG1lLm9uKCdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKGQpXG4gICAgICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5PUEVOOlxuICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTb2NrZXQpO1xuIiwiaW1wb3J0IE1hbmFnZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLlN0b3JlXG4gKiBAZXh0ZW5kcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFN0b3JlIGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5TdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuU3RvcmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIFxuICAgICAgICAvLyBBbGlhcyBOZW8uZ2V0U3RvcmUgdG8gdGhpcyBtYW5hZ2VyP1xuICAgICAgICAvLyBOZW8uZ2V0U3RvcmUgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3RvcmUpO1xuIiwiaW1wb3J0IE1hbmFnZXIgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBUaGUgXCJHb2QgVmlld1wiIGZvciB0aGUgbXVsdGktd2luZG93IGFwcGxpY2F0aW9uIHdvcmtzcGFjZS5cbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1hbmFnZXIgbWFpbnRhaW5zIGEgcmVhbC10aW1lIGdlb21ldHJpYyBtYXAgb2YgYWxsIGNvbm5lY3RlZCBicm93c2VyIHdpbmRvd3MgaW4gdGhlIEFwcCBXb3JrZXIuXG4gKiBJdCBpcyB0aGUgY2VudHJhbCBhdXRob3JpdHkgZm9yIHNwYXRpYWwgYXdhcmVuZXNzLCBlbmFibGluZyBmZWF0dXJlcyBsaWtlIHRoZSBcIkluZmluaXRlIENhbnZhc1wiIHdoZXJlXG4gKiBpbnRlcmFjdGlvbnMgKGxpa2UgRHJhZyAmIERyb3ApIGNhbiBzcGFuIGFjcm9zcyBtdWx0aXBsZSBPUy1sZXZlbCB3aW5kb3dzLlxuICpcbiAqIEl0IHJlY2VpdmVzIGhpZ2gtZnJlcXVlbmN5IHBvc2l0aW9uIHVwZGF0ZXMgZnJvbSB0aGUgTWFpbiBUaHJlYWQgKHZpYSBgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb25gKVxuICogYW5kIHByb3ZpZGVzIGludGVyc2VjdGlvbiB0ZXN0aW5nIEFQSXMgdG8gZGV0ZXJtaW5lIHdoaWNoIHdpbmRvdyBpcyB1bmRlciBhIGdpdmVuIHNjcmVlbiBjb29yZGluYXRlLlxuICpcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5XaW5kb3dcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqIEBzZWUgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb25cbiAqL1xuY2xhc3MgV2luZG93IGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5XaW5kb3cnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLldpbmRvdycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1NhZmFyaVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1NhZmFyaTogL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIub24oe1xuICAgICAgICAgICAgY29ubmVjdCAgIDogbWUub25XaW5kb3dDb25uZWN0LFxuICAgICAgICAgICAgZGlzY29ubmVjdDogbWUub25XaW5kb3dEaXNjb25uZWN0LFxuICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aW5kb3dJZCB3aGljaCBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIGdsb2JhbCBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBpcyB0aGUgY29yZSBpbnRlcnNlY3Rpb24gdGVzdCBmb3IgY3Jvc3Mtd2luZG93IGRyYWcgYW5kIGRyb3Agb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBTY3JlZW4gWCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgU2NyZWVuIFkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gVGhlIHdpbmRvd0lkIG9mIHRoZSB0YXJnZXQgd2luZG93LCBvciBudWxsIGlmIG5vIGludGVyc2VjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRXaW5kb3dBdCh4LCB5KSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5vdXRlclJlY3Q/LmludGVyc2VjdHMoe2JvdHRvbTogeSwgcmlnaHQ6IHgsIHgsIHl9KSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlkIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH0ge2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9XG4gICAgICovXG4gICAgY2FsY3VsYXRlR2VvbWV0cnkoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAge2lubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBtb3pJbm5lclNjcmVlblgsIG1veklubmVyU2NyZWVuWSwgb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGgsIHNjcmVlbkxlZnQsIHNjcmVlblRvcH0gPSBkYXRhLFxuICAgICAgICAgICAgd2lkdGhEaWZmICAgID0gb3V0ZXJXaWR0aCAgLSBpbm5lcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0RGlmZiAgID0gb3V0ZXJIZWlnaHQgLSBpbm5lckhlaWdodCxcbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IFNpZGUgYm9yZGVycyBhcmUgc3ltbWV0cmljXG4gICAgICAgICAgICBzaWRlQm9yZGVyICAgPSB3aWR0aERpZmYgLyAyLFxuICAgICAgICAgICAgLy8gQXNzdW1wdGlvbjogQm90dG9tIGJvcmRlciBtYXRjaGVzIHNpZGUgYm9yZGVyIChjb21tb24gaW4gV2luZG93cylcbiAgICAgICAgICAgIGJvdHRvbUJvcmRlciA9IHNpZGVCb3JkZXIsXG4gICAgICAgICAgICAvLyBUaGUgcmVzdCBpcyB0aGUgdG9wIGNocm9tZSAoaGVhZGVyKVxuICAgICAgICAgICAgdG9wQ2hyb21lICAgID0gaGVpZ2h0RGlmZiAtIGJvdHRvbUJvcmRlcjtcblxuICAgICAgICBjb25zdCBjaHJvbWUgPSB7XG4gICAgICAgICAgICBib3R0b206IGJvdHRvbUJvcmRlcixcbiAgICAgICAgICAgIGxlZnQgIDogc2lkZUJvcmRlcixcbiAgICAgICAgICAgIHJpZ2h0IDogc2lkZUJvcmRlcixcbiAgICAgICAgICAgIHRvcCAgIDogdG9wQ2hyb21lXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHZpZXdwb3J0TGVmdCwgdmlld3BvcnRUb3A7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb3pJbm5lclNjcmVlblggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94OiBleHBsaWNpdCB2aWV3cG9ydCBjb29yZGluYXRlc1xuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gbW96SW5uZXJTY3JlZW5YO1xuICAgICAgICAgICAgdmlld3BvcnRUb3AgID0gbW96SW5uZXJTY3JlZW5ZXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1NhZmFyaSkge1xuICAgICAgICAgICAgLy8gU2FmYXJpOiBzY3JlZW5MZWZ0L1RvcCBpcyBGcmFtZSBwb3NpdGlvbi4gQWRkIGNocm9tZSB0byBnZXQgVmlld3BvcnQuXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSBzY3JlZW5MZWZ0ICsgc2lkZUJvcmRlcjtcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICA9IHNjcmVlblRvcCAgKyB0b3BDaHJvbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZS9FZGdlOiBzY3JlZW5MZWZ0L1RvcCBpcyBWaWV3cG9ydCBwb3NpdGlvbi5cbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IHNjcmVlbkxlZnQ7XG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgPSBzY3JlZW5Ub3BcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlubmVyUmVjdCA9IG5ldyBSZWN0YW5nbGUodmlld3BvcnRMZWZ0LCB2aWV3cG9ydFRvcCwgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IG91dGVyUmVjdCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgLSBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgdmlld3BvcnRUb3AgIC0gdG9wQ2hyb21lLFxuICAgICAgICAgICAgb3V0ZXJXaWR0aCxcbiAgICAgICAgICAgIG91dGVySGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgbmV3IGJyb3dzZXIgd2luZG93IGNvbm5lY3RzIHRvIHRoZSBTaGFyZWRXb3JrZXIuXG4gICAgICogSW4gU2hhcmVkIFdvcmtlciBtb2RlLCBgTmVvLndvcmtlci5BcHAjb25Db25uZWN0YCBlbnN1cmVzIHRoYXQgYHdpbmRvd0RhdGFgXG4gICAgICogaXMgZmV0Y2hlZCBmcm9tIHRoZSBNYWluIFRocmVhZCBhbmQgaW5jbHVkZWQgaW4gdGhlIHBheWxvYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhLndpbmRvd0RhdGFdIENvbnRhaW5zIGdlb21ldHJ5IGRhdGEgKHNjcmVlbkxlZnQsIGlubmVySGVpZ2h0LCBldGMuKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25XaW5kb3dDb25uZWN0KHthcHBOYW1lLCB3aW5kb3dEYXRhLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IGNocm9tZSAgICA9IG51bGwsXG4gICAgICAgICAgICBpbm5lclJlY3QgPSBudWxsLFxuICAgICAgICAgICAgb3V0ZXJSZWN0ID0gbnVsbDtcblxuICAgICAgICBpZiAod2luZG93RGF0YSkge1xuICAgICAgICAgICAgKHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSA9IHRoaXMuY2FsY3VsYXRlR2VvbWV0cnkod2luZG93RGF0YSkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnV2luZG93Lm9uV2luZG93Q29ubmVjdCcsIHt3aW5kb3dJZCwgYXBwTmFtZSwgY2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH0pO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoe2FwcE5hbWUsIGNocm9tZSwgaWQ6IHdpbmRvd0lkLCBpbm5lclJlY3QsIG91dGVyUmVjdH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd0Rpc2Nvbm5lY3Qoe3dpbmRvd0lkfSkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIod2luZG93SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2VvbWV0cmljIHN0YXRlIG9mIGEgd2luZG93IGJhc2VkIG9uIGRhdGEgZnJvbSB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHZpYSBkaXJlY3QgZGVsZWdhdGlvbiBmcm9tIHRoZSBBcHAgV29ya2VyIHRvIG1pbmltaXplIG92ZXJoZWFkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaW5uZXJIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vdXRlckhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm91dGVyV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JlZW5MZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyZWVuVG9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd1Bvc2l0aW9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLmdldChkYXRhLndpbmRvd0lkKSxcbiAgICAgICAgICAgIHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSA9IG1lLmNhbGN1bGF0ZUdlb21ldHJ5KGRhdGEpO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmNocm9tZSAgICA9IGNocm9tZTtcbiAgICAgICAgICAgIGl0ZW0uaW5uZXJSZWN0ID0gaW5uZXJSZWN0O1xuICAgICAgICAgICAgaXRlbS5vdXRlclJlY3QgPSBvdXRlclJlY3RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBjaHJvbWUsXG4gICAgICAgICAgICAgICAgaWQ6IGRhdGEud2luZG93SWQsXG4gICAgICAgICAgICAgICAgaW5uZXJSZWN0LFxuICAgICAgICAgICAgICAgIG91dGVyUmVjdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHdpbmRvd3MgIDogdGhpcy5pdGVtcy5tYXAod2luID0+ICh7XG4gICAgICAgICAgICAgICAgaWQgICAgICAgOiB3aW4uaWQsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgOiB3aW4uYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjaHJvbWUgICA6IHdpbi5jaHJvbWUsXG4gICAgICAgICAgICAgICAgaW5uZXJSZWN0OiB3aW4uaW5uZXJSZWN0LFxuICAgICAgICAgICAgICAgIG91dGVyUmVjdDogd2luLm91dGVyUmVjdFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFdpbmRvdyk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQSBzaW5nbGV0b24gdXRpbGl0eSBjbGFzcyByZXNwb25zaWJsZSBmb3IgcmVjdXJzaXZlbHkgYnVpbGRpbmcgVkRPTSBhbmQgVk5vZGUgdHJlZXMuXG4gKiBJdCBjYW4gZXhwYW5kIGNvbXBvbmVudCByZWZlcmVuY2VzIHdpdGhpbiBhIHRyZWUgc3RydWN0dXJlIGludG8gdGhlaXIgZnVsbCBWRE9NL1ZOb2RlIHJlcHJlc2VudGF0aW9ucyxcbiAqIHN1cHBvcnRpbmcgc2VsZWN0aXZlIChhc3ltbWV0cmljKSB0cmVlIGV4cGFuc2lvbiBmb3Igb3B0aW1pemVkIHVwZGF0ZXMuXG4gKiBAY2xhc3MgTmVvLnV0aWwudmRvbS5UcmVlQnVpbGRlclxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBUcmVlQnVpbGRlciBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwudmRvbS5UcmVlQnVpbGRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwudmRvbS5UcmVlQnVpbGRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGhlbHBlciB0byByZWN1cnNpdmVseSBidWlsZCBhIHRyZWUsIGFic3RyYWN0aW5nIHRoZSBjaGlsZCBub2RlIGtleS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgdmRvbSBvciB2bm9kZSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCBUaGUgY3VycmVudCByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtTZXQ8U3RyaW5nPnxudWxsfSBtZXJnZWRDaGlsZElkcyBBIHNldCBvZiBjb21wb25lbnQgSURzIHRvIHNlbGVjdGl2ZWx5IGV4cGFuZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hpbGRLZXkgVGhlIHByb3BlcnR5IG5hbWUgZm9yIGNoaWxkIG5vZGVzICgnY24nIG9yICdjaGlsZE5vZGVzJykuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNidWlsZFRyZWUobm9kZSwgZGVwdGgsIG1lcmdlZENoaWxkSWRzLCBjaGlsZEtleSkge1xuICAgICAgICAvLyBXZSBjYW4gbm90IHVzZSBOZW8uaXNPYmplY3QoKSBoZXJlLCBzaW5jZSBpbnNpZGUgdW5pdC10ZXN0IHNjZW5hcmlvcywgd2Ugd2lsbCBpbXBvcnQgdmRvbS5IZWxwZXIgaW50byBtYWluIHRocmVhZHMuXG4gICAgICAgIC8vIEluc2lkZSB0aGlzIHNjZW5hcmlvLCBOZW8uaXNPYmplY3QoKSByZXR1cm5zIGZhbHNlIGZvciBWTm9kZSBpbnN0YW5jZXNcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSklUIElEIEdlbmVyYXRpb24gKEFwcCBBdXRob3JpdHkpXG4gICAgICAgIC8vIElmIHdlIGFyZSBwcm9jZXNzaW5nIGEgVkRPTSB0cmVlIChjaGlsZEtleSA9PT0gJ2NuJykgYW5kIHRoZSBub2RlIGhhcyBubyBJRCxcbiAgICAgICAgLy8gd2UgbXVzdCBnZW5lcmF0ZSBvbmUgbm93IHRvIGVuc3VyZSBkZXRlcm1pbmlzdGljIGlkZW50aXR5IGJlZm9yZSB0aGUgVkRPTSBsZWF2ZXMgdGhlIEFwcCBXb3JrZXIuXG4gICAgICAgIGlmIChjaGlsZEtleSA9PT0gJ2NuJyAmJiAhbm9kZS5pZCkge1xuICAgICAgICAgICAgbm9kZS5pZCA9IE5lby5nZXRJZChub2RlLnZ0eXBlID09PSAndGV4dCcgPyAndnRleHQnIDogJ3Zub2RlJylcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvdXRwdXQgPSB7Li4ubm9kZX07IC8vIFNoYWxsb3cgY29weVxuXG4gICAgICAgIGlmIChub2RlW2NoaWxkS2V5XSkge1xuICAgICAgICAgICAgb3V0cHV0W2NoaWxkS2V5XSA9IFtdO1xuXG4gICAgICAgICAgICBub2RlW2NoaWxkS2V5XS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50SXRlbSA9IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRGVwdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEl0ZW0uY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gQ29tcG9uZW50TWFuYWdlci5nZXQoY3VycmVudEl0ZW0uY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYXJzZSBUcmVlIEdlbmVyYXRpb24gJiBTY29wZWQgVXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBwcnVuZSB0aGUgYnJhbmNoIChzZW5kIGEgcGxhY2Vob2xkZXIpIGlmOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBXZSBhcmUgYXQgdGhlIGRlcHRoIGJvdW5kYXJ5IChkZXB0aCA9PT0gMSkgQU5EIGl0J3Mgbm90IGEgbWVyZ2VkIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gV2UgYXJlIGluIGEgTWVyZ2VkIFVwZGF0ZSAobWVyZ2VkQ2hpbGRJZHMgZXhpc3RzKSBBTkQgdGhpcyBjb21wb25lbnQgaXMgbm90IGluIHRoZSBBbGxvd0xpc3QgKG5vdCBkaXJ0eS9icmlkZ2UpLlxuICAgICAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb246IFdlIG5ldmVyIHBydW5lIGlmIGRlcHRoIGlzIC0xIChGdWxsIFRyZWUpIG9yIGlmIHRoZSBjb21wb25lbnQgaXMgbm90IG1vdW50ZWQgeWV0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggIT09IC0xICYmIGNvbXBvbmVudD8udm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRXhwYW5kYWJsZSA9IG1lcmdlZENoaWxkSWRzPy5oYXMoY3VycmVudEl0ZW0uY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRlcHRoID09PSAxICYmICFpc0V4cGFuZGFibGUpIHx8IChtZXJnZWRDaGlsZElkcyAmJiAhaXNFeHBhbmRhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtjaGlsZEtleV0ucHVzaCh7Li4uY3VycmVudEl0ZW0sIG5lb0lnbm9yZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvLyBTdG9wIHByb2Nlc3NpbmcgdGhpcyBicmFuY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgYnJhbmNoIGlmIGl0J3MgcGFydCBvZiBhIG1lcmdlZCB1cGRhdGUsIG9yIGlmIHRoZSBkZXB0aCByZXF1aXJlcyBpdCwgT1IgaWYgdGhlIHZub2RlIGlzIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID4gMSB8fCBkZXB0aCA9PT0gLTEgfHwgbWVyZ2VkQ2hpbGRJZHM/LmhhcyhjdXJyZW50SXRlbS5jb21wb25lbnRJZCkgfHwgIWNvbXBvbmVudD8udm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgY29ycmVjdCB0cmVlIHR5cGUgYmFzZWQgb24gdGhlIGNoaWxkS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRUcmVlID0gY2hpbGRLZXkgPT09ICdjbicgPyBjb21wb25lbnQ/LnZkb20gOiBjb21wb25lbnQ/LnZub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlbSA9IGNvbXBvbmVudFRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRGVwdGggPSAoZGVwdGggPT09IC0xKSA/IC0xIDogTWF0aC5tYXgoMCwgZGVwdGggLSAxKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRGVwdGggPSBkZXB0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG91dHB1dFtjaGlsZEtleV0ucHVzaCh0aGlzLiNidWlsZFRyZWUoY3VycmVudEl0ZW0sIGNoaWxkRGVwdGgsIG1lcmdlZENoaWxkSWRzLCBjaGlsZEtleSkpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgZ2l2ZW4gdmRvbSB0cmVlIGFuZCByZXBsYWNlcyBjaGlsZCBjb21wb25lbnQgcmVmZXJlbmNlcyB3aXRoIHRoZWlyIHZkb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoPS0xXVxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gW21lcmdlZENoaWxkSWRzPW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWZG9tVHJlZSh2ZG9tLCBkZXB0aD0tMSwgbWVyZ2VkQ2hpbGRJZHM9bnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYnVpbGRUcmVlKHZkb20sIGRlcHRoLCBtZXJnZWRDaGlsZElkcywgJ2NuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBnaXZlbiB2bm9kZSB0cmVlIGFuZCByZXBsYWNlcyBjaGlsZCBjb21wb25lbnQgcmVmZXJlbmNlcyB3aXRoIHRoZWlyIHZub2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVwdGg9LTFdXG4gICAgICogQHBhcmFtIHtTZXQ8U3RyaW5nPnxudWxsfSBbbWVyZ2VkQ2hpbGRJZHM9bnVsbF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZub2RlVHJlZSh2bm9kZSwgZGVwdGg9LTEsIG1lcmdlZENoaWxkSWRzPW51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1aWxkVHJlZSh2bm9kZSwgZGVwdGgsIG1lcmdlZENoaWxkSWRzLCAnY2hpbGROb2RlcycpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUcmVlQnVpbGRlcik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9