"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_ai_Client_mjs"],{

/***/ "./src/ai/Client.mjs"
/*!***************************!*\
  !*** ./src/ai/Client.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _data_connection_WebSocket_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/connection/WebSocket.mjs */ "./src/data/connection/WebSocket.mjs");




/**
 * The AI Client establishes a WebSocket connection to the Neural Link MCP Server.
 * It acts as a bridge, enabling external AI agents to inspect and manipulate the running Neo.mjs application
 * via a standardized JSON-RPC protocol.
 * @class Neo.ai.Client
 * @extends Neo.core.Base
 * @singleton
 */
class Client extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.Client'
         * @protected
         */
        className: 'Neo.ai.Client',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * Add custom configs for data.connection.Websocket, or pass a module or instance.
         * @member {Object|Neo.data.connection.WebSocket|null} socket=null
         */
        socketConfig: null,
        /**
         * The URL of the Neural Link MCP Server's WebSocket endpoint.
         * @member {String} url='ws://localhost:8081'
         */
        url: 'ws://localhost:8081'
    }

    /**
     * @member {Boolean} isConnected=false
     * @protected
     */
    isConnected = false
    /**
     * @member {Neo.data.connection.WebSocket|null} socket=null
     * @protected
     */
    socket = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.connect();
    }

    /**
     * Establishes the WebSocket connection to the Neural Link MCP Server.
     * Uses Neo.data.connection.WebSocket for robust connection management.
     */
    connect() {
        let me = this;

        me.socket = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(me.socketConfig, _data_connection_WebSocket_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            serverAddress: me.url,
            listeners    : {
                close  : me.onSocketClose,
                error  : me.onSocketError,
                message: me.onSocketMessage,
                open   : me.onSocketOpen,
                scope  : me
            }
        })
    }

    /**
     * Handles incoming messages from the WebSocket.
     * Parses the JSON-RPC payload and delegates valid requests to `handleRequest`.
     * @param {Object} data
     */
    async onSocketMessage({data}) {
        try {
            if (data.method) {
                const result = await this.handleRequest(data.method, data.params);
                this.sendResponse(data.id, result)
            }
        } catch (e) {
            console.error('Neo.ai.Client: Failed to handle message', e)
        }
    }

    /**
     * @param {Event} event
     */
    onSocketOpen(event) {
        console.log('Neo.ai.Client: Connected to MCP Server');
        this.isConnected = true
    }

    /**
     * @param {CloseEvent} event
     */
    onSocketClose(event) {
        console.log('Neo.ai.Client: Disconnected');
        this.isConnected = false
    }

    /**
     * @param {Event} event
     */
    onSocketError(event) {
        console.error('Neo.ai.Client: WebSocket Error', event)
    }

    /**
     * Routes specific JSON-RPC methods to their corresponding implementation.
     * This method acts as the central dispatcher for all AI-driven commands.
     * @param {String} method The JSON-RPC method name
     * @param {Object} params The parameters associated with the method
     * @returns {Promise<*>} The result of the operation
     */
    async handleRequest(method, params) {
        switch (method) {
            case 'reload_page':
                Neo.Main.reloadWindow();
                return {status: 'reloading'};

            case 'get_component_tree':
                // TODO: Implement actual tree retrieval
                return {root: 'viewport'};

            case 'get_component_property':
                // TODO: Implement property retrieval
                return {value: null};

            case 'set_component_property':
                // TODO: Implement property setting
                return {success: true};

            default:
                throw new Error(`Unknown method: ${method}`);
        }
    }

    /**
     * Sends a JSON-RPC response
     * @param {Number|String} id
     * @param {*} result
     */
    sendResponse(id, result) {
        if (this.isConnected) {
            this.socket.sendMessage(JSON.stringify({
                jsonrpc: '2.0',
                id,
                result
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Client));


/***/ },

/***/ "./src/data/connection/WebSocket.mjs"
/*!*******************************************!*\
  !*** ./src/data/connection/WebSocket.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.data.connection.WebSocket
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Socket extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.connection.WebSocket'
         * @protected
         */
        className: 'Neo.data.connection.WebSocket',
        /**
         * @member {String} ntype='socket-connection'
         * @protected
         */
        ntype: 'socket-connection',
        /**
         * @member {WebSocket|null} socket_=null
         * @protected
         * @reactive
         */
        socket_: null
    }

    /**
     * @member {String|null} channel=null
     */
    channel = null
    /**
     * @member {Number} maxReconnectAttempts=5
     */
    maxReconnectAttempts = 5
    /**
     * @member {Object} messageCallbacks={}
     * @protected
     */
    messageCallbacks = {}
    /**
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * @member {Number} reconnectAttempts=0
     * @protected
     */
    reconnectAttempts = 0
    /**
     * @member {String|null} serverAddress=null
     */
    serverAddress = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createSocket()
    }

    /**
     * @param {Function} callback
     * @param {Object} scope
     */
    attemptReconnect(callback, scope) {
        let me = this;

        me.reconnectAttempts++;

        if (me.reconnectAttempts < me.maxReconnectAttempts) {
            me.createSocket();

            callback && me.on('open', {
                callback,
                scope : scope || me,
                single: true
            })
        }
    }

    /**
     * Intercepts the WebSocket send calls
     * @param {Object} data
     * @returns {String}
     */
    beforeSend(data) {
        let me        = this,
            {channel} = me;

        return JSON.stringify(channel ? {channel, data} : data)
    }

    /**
     * Triggered before the socket config gets changed.
     * @param {WebSocket|null} value
     * @param {WebSocket|null} oldValue
     * @returns {WebSocket|null}
     * @protected
     */
    beforeSetSocket(value, oldValue) {
        if (value) {
            let me = this;

            Object.assign(value, {
                onclose  : me.onClose  .bind(me),
                onerror  : me.onError  .bind(me),
                onmessage: me.onMessage.bind(me),
                onopen   : me.onOpen   .bind(me)
            });

            (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.createInterceptor)(value, 'send', me.beforeSend, me)
        }

        return value
    }

    /**
     * @param {Number} [code] defaults to 1000
     * @param {String} [reason]
     */
    close(code, reason) {
        this.socket.close(code, reason)
    }

    /**
     *
     */
    createSocket() {
        this.socket = new WebSocket(this.serverAddress)
    }

    /**
     *
     */
    destroy(...args) {
        this.close();
        super.destroy(...args)
    }

    /**
     * @param {CloseEvent} event The Websocket generated CloseEvent
     * @param {Number}     event.code The WebSocket connection close code provided by the server
     *
     *        Code        Name                  Description
     *        0-999                             Reserved and not used.
     *        1000        CLOSE_NORMAL          Normal closure; the connection successfully completed whatever purpose for which it was created.
     *        1001        CLOSE_GOING_AWAY      The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.
     *        1002        CLOSE_PROTOCOL_ERROR  The endpoint is terminating the connection due to a protocol error.
     *        1003        CLOSE_UNSUPPORTED     The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).
     *        1004        CLOSE_TOO_LARGE       The endpoint is terminating the connection because a data frame was received that is too large.
     *        1005        CLOSE_NO_STATUS       Reserved.  Indicates that no status code was provided even though one was expected.
     *        1006        CLOSE_ABNORMAL        Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.
     *        1007-1999                         Reserved for future use by the WebSocket standard.
     *        2000-2999                         Reserved for use by WebSocket extensions.
     *        3000-3999                         Available for use by libraries and frameworks. May not be used by applications.
     *        4000-4999                         Available for use by applications.
     *
     * @param {String}     reason A string indicating the reason the server closed the connection. This is specific to the particular server and sub-protocol.
     * @param {Boolean}    wasClean Indicates whether or not the connection was cleanly closed.
     */
    onClose(event, reason, wasClean) {
        this.fire('close', {event, reason, wasClean})
    }

    /**
     *
     */
    onError(error) {
        this.fire('error', {error})
    }

    /**
     * @param {MessageEvent} event
     */
    onMessage(event) {
        let me   = this,
            data = JSON.parse(event.data);

        me.fire('message', {data});

        if (data.mId) {
            me.messageCallbacks[data.mId].resolve(data.data);
            delete me.messageCallbacks[data.mId]
        }
    }

    /**
     *
     */
    onOpen() {
        this.fire('open', {scope: this})
    }

    /**
     * @param {Object} data
     * @returns {Promise<any>}
     */
    promiseMessage(data) {
        let me = this;

        return new Promise((resolve, reject) => {
            me.messageCallbacks[me.messageId] = {reject, resolve};

            me.sendMessage({data, mId: me.messageId});
            me.messageId++
        })
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        let me       = this,
            {socket} = me,
            d        = data;

        // CONNECTING  0   The connection is not yet open.
        // OPEN        1   The connection is open and ready to communicate.
        // CLOSING     2   The connection is in the process of closing.
        // CLOSED      3   The connection is closed or couldn't be opened.

        // If socket is not yet ready let's defer to open then resend
        switch (socket.readyState) {
            case WebSocket.CLOSED:
            case WebSocket.CLOSING:
                me.attemptReconnect(function() {
                    me.sendMessage(d);
                });
                break;
            case WebSocket.CONNECTING:
                me.on('open', function() {
                    me.sendMessage(d)
                }, me, {once: true});
                break;
            case WebSocket.OPEN:
                socket.send(data);
                break;
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Socket));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19haV9DbGllbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDTztBQUNTOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNEQUFJO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNkRBQWUsb0NBQW9DLHNFQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvQ2xpZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvY29ubmVjdGlvbi9XZWJTb2NrZXQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBTb2NrZXQgICAgICAgICAgZnJvbSAnLi4vZGF0YS9jb25uZWN0aW9uL1dlYlNvY2tldC5tanMnO1xuXG4vKipcbiAqIFRoZSBBSSBDbGllbnQgZXN0YWJsaXNoZXMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTmV1cmFsIExpbmsgTUNQIFNlcnZlci5cbiAqIEl0IGFjdHMgYXMgYSBicmlkZ2UsIGVuYWJsaW5nIGV4dGVybmFsIEFJIGFnZW50cyB0byBpbnNwZWN0IGFuZCBtYW5pcHVsYXRlIHRoZSBydW5uaW5nIE5lby5tanMgYXBwbGljYXRpb25cbiAqIHZpYSBhIHN0YW5kYXJkaXplZCBKU09OLVJQQyBwcm90b2NvbC5cbiAqIEBjbGFzcyBOZW8uYWkuQ2xpZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIENsaWVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFpLkNsaWVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmFpLkNsaWVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgY3VzdG9tIGNvbmZpZ3MgZm9yIGRhdGEuY29ubmVjdGlvbi5XZWJzb2NrZXQsIG9yIHBhc3MgYSBtb2R1bGUgb3IgaW5zdGFuY2UuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldHxudWxsfSBzb2NrZXQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ja2V0Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgTmV1cmFsIExpbmsgTUNQIFNlcnZlcidzIFdlYlNvY2tldCBlbmRwb2ludC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB1cmw9J3dzOi8vbG9jYWxob3N0OjgwODEnXG4gICAgICAgICAqL1xuICAgICAgICB1cmw6ICd3czovL2xvY2FsaG9zdDo4MDgxJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQ29ubmVjdGVkPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldHxudWxsfSBzb2NrZXQ9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzb2NrZXQgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOZXVyYWwgTGluayBNQ1AgU2VydmVyLlxuICAgICAqIFVzZXMgTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXQgZm9yIHJvYnVzdCBjb25uZWN0aW9uIG1hbmFnZW1lbnQuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zb2NrZXQgPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UobWUuc29ja2V0Q29uZmlnLCBTb2NrZXQsIHtcbiAgICAgICAgICAgIHNlcnZlckFkZHJlc3M6IG1lLnVybCxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICA6IHtcbiAgICAgICAgICAgICAgICBjbG9zZSAgOiBtZS5vblNvY2tldENsb3NlLFxuICAgICAgICAgICAgICAgIGVycm9yICA6IG1lLm9uU29ja2V0RXJyb3IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWUub25Tb2NrZXRNZXNzYWdlLFxuICAgICAgICAgICAgICAgIG9wZW4gICA6IG1lLm9uU29ja2V0T3BlbixcbiAgICAgICAgICAgICAgICBzY29wZSAgOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgV2ViU29ja2V0LlxuICAgICAqIFBhcnNlcyB0aGUgSlNPTi1SUEMgcGF5bG9hZCBhbmQgZGVsZWdhdGVzIHZhbGlkIHJlcXVlc3RzIHRvIGBoYW5kbGVSZXF1ZXN0YC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uU29ja2V0TWVzc2FnZSh7ZGF0YX0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkYXRhLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlUmVxdWVzdChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlc3BvbnNlKGRhdGEuaWQsIHJlc3VsdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTmVvLmFpLkNsaWVudDogRmFpbGVkIHRvIGhhbmRsZSBtZXNzYWdlJywgZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25Tb2NrZXRPcGVuKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZW8uYWkuQ2xpZW50OiBDb25uZWN0ZWQgdG8gTUNQIFNlcnZlcicpO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2xvc2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNvY2tldENsb3NlKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZW8uYWkuQ2xpZW50OiBEaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNvY2tldEVycm9yKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05lby5haS5DbGllbnQ6IFdlYlNvY2tldCBFcnJvcicsIGV2ZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdXRlcyBzcGVjaWZpYyBKU09OLVJQQyBtZXRob2RzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgaW1wbGVtZW50YXRpb24uXG4gICAgICogVGhpcyBtZXRob2QgYWN0cyBhcyB0aGUgY2VudHJhbCBkaXNwYXRjaGVyIGZvciBhbGwgQUktZHJpdmVuIGNvbW1hbmRzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgVGhlIEpTT04tUlBDIG1ldGhvZCBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggdGhlIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBoYW5kbGVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdyZWxvYWRfcGFnZSc6XG4gICAgICAgICAgICAgICAgTmVvLk1haW4ucmVsb2FkV2luZG93KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXM6ICdyZWxvYWRpbmcnfTtcblxuICAgICAgICAgICAgY2FzZSAnZ2V0X2NvbXBvbmVudF90cmVlJzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgYWN0dWFsIHRyZWUgcmV0cmlldmFsXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtyb290OiAndmlld3BvcnQnfTtcblxuICAgICAgICAgICAgY2FzZSAnZ2V0X2NvbXBvbmVudF9wcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHByb3BlcnR5IHJldHJpZXZhbFxuICAgICAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IG51bGx9O1xuXG4gICAgICAgICAgICBjYXNlICdzZXRfY29tcG9uZW50X3Byb3BlcnR5JzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcHJvcGVydHkgc2V0dGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiB7c3VjY2VzczogdHJ1ZX07XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG1ldGhvZDogJHttZXRob2R9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIEpTT04tUlBDIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7Kn0gcmVzdWx0XG4gICAgICovXG4gICAgc2VuZFJlc3BvbnNlKGlkLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmRNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDbGllbnQpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQge2NyZWF0ZUludGVyY2VwdG9yfSBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL09ic2VydmFibGUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKi9cbmNsYXNzIFNvY2tldCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzb2NrZXQtY29ubmVjdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzb2NrZXQtY29ubmVjdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJTb2NrZXR8bnVsbH0gc29ja2V0Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzb2NrZXRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNoYW5uZWw9bnVsbFxuICAgICAqL1xuICAgIGNoYW5uZWwgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhSZWNvbm5lY3RBdHRlbXB0cz01XG4gICAgICovXG4gICAgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSA1XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtZXNzYWdlQ2FsbGJhY2tzPXt9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1lc3NhZ2VDYWxsYmFja3MgPSB7fVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWVzc2FnZUlkPTFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbWVzc2FnZUlkID0gMVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gcmVjb25uZWN0QXR0ZW1wdHM9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZWNvbm5lY3RBdHRlbXB0cyA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc2VydmVyQWRkcmVzcz1udWxsXG4gICAgICovXG4gICAgc2VydmVyQWRkcmVzcyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNvY2tldCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKi9cbiAgICBhdHRlbXB0UmVjb25uZWN0KGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnJlY29ubmVjdEF0dGVtcHRzKys7XG5cbiAgICAgICAgaWYgKG1lLnJlY29ubmVjdEF0dGVtcHRzIDwgbWUubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIG1lLmNyZWF0ZVNvY2tldCgpO1xuXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBtZS5vbignb3BlbicsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBzY29wZSA6IHNjb3BlIHx8IG1lLFxuICAgICAgICAgICAgICAgIHNpbmdsZTogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVyY2VwdHMgdGhlIFdlYlNvY2tldCBzZW5kIGNhbGxzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGJlZm9yZVNlbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjaGFubmVsfSA9IG1lO1xuXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjaGFubmVsID8ge2NoYW5uZWwsIGRhdGF9IDogZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzb2NrZXQgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7V2ViU29ja2V0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1dlYlNvY2tldHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTb2NrZXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZSwge1xuICAgICAgICAgICAgICAgIG9uY2xvc2UgIDogbWUub25DbG9zZSAgLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9uZXJyb3IgIDogbWUub25FcnJvciAgLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9ubWVzc2FnZTogbWUub25NZXNzYWdlLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIG9ub3BlbiAgIDogbWUub25PcGVuICAgLmJpbmQobWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY3JlYXRlSW50ZXJjZXB0b3IodmFsdWUsICdzZW5kJywgbWUuYmVmb3JlU2VuZCwgbWUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIGRlZmF1bHRzIHRvIDEwMDBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlYXNvbl1cbiAgICAgKi9cbiAgICBjbG9zZShjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlU29ja2V0KCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5zZXJ2ZXJBZGRyZXNzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2xvc2VFdmVudH0gZXZlbnQgVGhlIFdlYnNvY2tldCBnZW5lcmF0ZWQgQ2xvc2VFdmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgZXZlbnQuY29kZSBUaGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSBwcm92aWRlZCBieSB0aGUgc2VydmVyXG4gICAgICpcbiAgICAgKiAgICAgICAgQ29kZSAgICAgICAgTmFtZSAgICAgICAgICAgICAgICAgIERlc2NyaXB0aW9uXG4gICAgICogICAgICAgIDAtOTk5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXNlcnZlZCBhbmQgbm90IHVzZWQuXG4gICAgICogICAgICAgIDEwMDAgICAgICAgIENMT1NFX05PUk1BTCAgICAgICAgICBOb3JtYWwgY2xvc3VyZTsgdGhlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB3aGF0ZXZlciBwdXJwb3NlIGZvciB3aGljaCBpdCB3YXMgY3JlYXRlZC5cbiAgICAgKiAgICAgICAgMTAwMSAgICAgICAgQ0xPU0VfR09JTkdfQVdBWSAgICAgIFRoZSBlbmRwb2ludCBpcyBnb2luZyBhd2F5LCBlaXRoZXIgYmVjYXVzZSBvZiBhIHNlcnZlciBmYWlsdXJlIG9yIGJlY2F1c2UgdGhlIGJyb3dzZXIgaXMgbmF2aWdhdGluZyBhd2F5IGZyb20gdGhlIHBhZ2UgdGhhdCBvcGVuZWQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICogICAgICAgIDEwMDIgICAgICAgIENMT1NFX1BST1RPQ09MX0VSUk9SICBUaGUgZW5kcG9pbnQgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gZHVlIHRvIGEgcHJvdG9jb2wgZXJyb3IuXG4gICAgICogICAgICAgIDEwMDMgICAgICAgIENMT1NFX1VOU1VQUE9SVEVEICAgICBUaGUgY29ubmVjdGlvbiBpcyBiZWluZyB0ZXJtaW5hdGVkIGJlY2F1c2UgdGhlIGVuZHBvaW50IHJlY2VpdmVkIGRhdGEgb2YgYSB0eXBlIGl0IGNhbm5vdCBhY2NlcHQgKGZvciBleGFtcGxlLCBhIHRleHQtb25seSBlbmRwb2ludCByZWNlaXZlZCBiaW5hcnkgZGF0YSkuXG4gICAgICogICAgICAgIDEwMDQgICAgICAgIENMT1NFX1RPT19MQVJHRSAgICAgICBUaGUgZW5kcG9pbnQgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBhIGRhdGEgZnJhbWUgd2FzIHJlY2VpdmVkIHRoYXQgaXMgdG9vIGxhcmdlLlxuICAgICAqICAgICAgICAxMDA1ICAgICAgICBDTE9TRV9OT19TVEFUVVMgICAgICAgUmVzZXJ2ZWQuICBJbmRpY2F0ZXMgdGhhdCBubyBzdGF0dXMgY29kZSB3YXMgcHJvdmlkZWQgZXZlbiB0aG91Z2ggb25lIHdhcyBleHBlY3RlZC5cbiAgICAgKiAgICAgICAgMTAwNiAgICAgICAgQ0xPU0VfQUJOT1JNQUwgICAgICAgIFJlc2VydmVkLiBVc2VkIHRvIGluZGljYXRlIHRoYXQgYSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYWJub3JtYWxseSAodGhhdCBpcywgd2l0aCBubyBjbG9zZSBmcmFtZSBiZWluZyBzZW50KSB3aGVuIGEgc3RhdHVzIGNvZGUgaXMgZXhwZWN0ZWQuXG4gICAgICogICAgICAgIDEwMDctMTk5OSAgICAgICAgICAgICAgICAgICAgICAgICBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBieSB0aGUgV2ViU29ja2V0IHN0YW5kYXJkLlxuICAgICAqICAgICAgICAyMDAwLTI5OTkgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgZm9yIHVzZSBieSBXZWJTb2NrZXQgZXh0ZW5zaW9ucy5cbiAgICAgKiAgICAgICAgMzAwMC0zOTk5ICAgICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSBmb3IgdXNlIGJ5IGxpYnJhcmllcyBhbmQgZnJhbWV3b3Jrcy4gTWF5IG5vdCBiZSB1c2VkIGJ5IGFwcGxpY2F0aW9ucy5cbiAgICAgKiAgICAgICAgNDAwMC00OTk5ICAgICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSBmb3IgdXNlIGJ5IGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgcmVhc29uIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHJlYXNvbiB0aGUgc2VydmVyIGNsb3NlZCB0aGUgY29ubmVjdGlvbi4gVGhpcyBpcyBzcGVjaWZpYyB0byB0aGUgcGFydGljdWxhciBzZXJ2ZXIgYW5kIHN1Yi1wcm90b2NvbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgIHdhc0NsZWFuIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgY29ubmVjdGlvbiB3YXMgY2xlYW5seSBjbG9zZWQuXG4gICAgICovXG4gICAgb25DbG9zZShldmVudCwgcmVhc29uLCB3YXNDbGVhbikge1xuICAgICAgICB0aGlzLmZpcmUoJ2Nsb3NlJywge2V2ZW50LCByZWFzb24sIHdhc0NsZWFufSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcn0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuXG4gICAgICAgIG1lLmZpcmUoJ21lc3NhZ2UnLCB7ZGF0YX0pO1xuXG4gICAgICAgIGlmIChkYXRhLm1JZCkge1xuICAgICAgICAgICAgbWUubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1JZF0ucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIG1lLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tSWRdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdvcGVuJywge3Njb3BlOiB0aGlzfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZU1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZS5tZXNzYWdlQ2FsbGJhY2tzW21lLm1lc3NhZ2VJZF0gPSB7cmVqZWN0LCByZXNvbHZlfTtcblxuICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2Uoe2RhdGEsIG1JZDogbWUubWVzc2FnZUlkfSk7XG4gICAgICAgICAgICBtZS5tZXNzYWdlSWQrK1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3NvY2tldH0gPSBtZSxcbiAgICAgICAgICAgIGQgICAgICAgID0gZGF0YTtcblxuICAgICAgICAvLyBDT05ORUNUSU5HICAwICAgVGhlIGNvbm5lY3Rpb24gaXMgbm90IHlldCBvcGVuLlxuICAgICAgICAvLyBPUEVOICAgICAgICAxICAgVGhlIGNvbm5lY3Rpb24gaXMgb3BlbiBhbmQgcmVhZHkgdG8gY29tbXVuaWNhdGUuXG4gICAgICAgIC8vIENMT1NJTkcgICAgIDIgICBUaGUgY29ubmVjdGlvbiBpcyBpbiB0aGUgcHJvY2VzcyBvZiBjbG9zaW5nLlxuICAgICAgICAvLyBDTE9TRUQgICAgICAzICAgVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkIG9yIGNvdWxkbid0IGJlIG9wZW5lZC5cblxuICAgICAgICAvLyBJZiBzb2NrZXQgaXMgbm90IHlldCByZWFkeSBsZXQncyBkZWZlciB0byBvcGVuIHRoZW4gcmVzZW5kXG4gICAgICAgIHN3aXRjaCAoc29ja2V0LnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0LkNMT1NFRDpcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0LkNMT1NJTkc6XG4gICAgICAgICAgICAgICAgbWUuYXR0ZW1wdFJlY29ubmVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UoZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DT05ORUNUSU5HOlxuICAgICAgICAgICAgICAgIG1lLm9uKCdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKGQpXG4gICAgICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5PUEVOOlxuICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTb2NrZXQpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==