export const __webpack_esm_id__ = "vendors-src_ai_Client_mjs";
export const __webpack_esm_ids__ = ["vendors-src_ai_Client_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/ai/Client.mjs"
/*!***************************!*\
  !*** ./src/ai/Client.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _client_ComponentService_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./client/ComponentService.mjs */ "./src/ai/client/ComponentService.mjs");
/* harmony import */ var _client_DataService_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/DataService.mjs */ "./src/ai/client/DataService.mjs");
/* harmony import */ var _client_InstanceService_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/InstanceService.mjs */ "./src/ai/client/InstanceService.mjs");
/* harmony import */ var _client_InteractionService_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/InteractionService.mjs */ "./src/ai/client/InteractionService.mjs");
/* harmony import */ var _client_RuntimeService_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./client/RuntimeService.mjs */ "./src/ai/client/RuntimeService.mjs");
/* harmony import */ var _data_connection_WebSocket_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../data/connection/WebSocket.mjs */ "./src/data/connection/WebSocket.mjs");
/* harmony import */ var _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../manager/Window.mjs */ "./src/manager/Window.mjs");










/**
 * The AI Client establishes a WebSocket connection to the Neural Link MCP Server.
 * It acts as a bridge, enabling external AI agents to inspect and manipulate the running Neo.mjs application
 * via a standardized JSON-RPC protocol.
 * @class Neo.ai.Client
 * @extends Neo.core.Base
 * @singleton
 */
class Client extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.Client'
         * @protected
         */
        className: 'Neo.ai.Client',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * Add custom configs for data.connection.Websocket, or pass a module or instance.
         * @member {Object|Neo.data.connection.WebSocket|null} socket=null
         */
        socketConfig: null,
        /**
         * The URL of the Neural Link MCP Server's WebSocket endpoint.
         * @member {String} url='ws://127.0.0.1:8081'
         */
        url: 'ws://127.0.0.1:8081'
    }

    /**
     * @member {Boolean} isConnected=false
     * @protected
     */
    isConnected = false
    /**
     * Buffer for console logs generated before connection is established
     * @member {Array} logs=[]
     * @protected
     */
    logs = []
    /**
     * Map JSON-RPC method prefixes to service instances
     * @member {Object} serviceMap
     * @protected
     */
    serviceMap = null
    /**
     * @member {Object} services=null
     * @protected
     */
    services = null
    /**
     * @member {Neo.data.connection.WebSocket|null} socket=null
     * @protected
     */
    socket = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.services = {
            component  : Neo.create(_client_ComponentService_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],   {client: me}),
            data       : Neo.create(_client_DataService_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],        {client: me}),
            instance   : Neo.create(_client_InstanceService_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],    {client: me}),
            interaction: Neo.create(_client_InteractionService_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], {client: me}),
            runtime    : Neo.create(_client_RuntimeService_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],     {client: me})
        };

        const {component, data, instance, interaction, runtime} = me.services;

        me.serviceMap = {
            get_component         : component,
            get_computed_styles   : component,
            get_dom_rect          : component,
            get_vdom              : component,
            get_vdom_vnode        : component,
            get_vnode             : component,
            highlight_component   : component,
            query_component       : component,
            query_vdom            : component,
            set_component         : component,

            find_instances         : instance,
            get_instance_properties: instance,
            set_instance_properties: instance,

            get_record            : data,
            inspect_state_provider: data,
            inspect_store         : data,
            list_stores           : data,
            modify_state_provider : data,

            get_dom_event         : runtime,
            get_drag              : runtime,
            get_method_source     : runtime,
            get_route             : runtime,
            get_window            : runtime,
            inspect_class         : runtime,
            patch_code            : runtime,
            reload_page           : runtime,
            set_route             : runtime,
            simulate_event        : interaction
        };

        Neo.currentWorker.on({
            connect   : me.onAppWorkerWindowConnect,
            disconnect: me.onAppWorkerWindowDisconnect,
            scope     : me
        });

        me.connect()
    }

    /**
     * Establishes the WebSocket connection to the Neural Link MCP Server.
     * Uses Neo.data.connection.WebSocket for robust connection management.
     */
    connect() {
        let me = this;

        try {
            let url     = new URL(Neo.config.neuralLinkUrl || me.url),
                appName = 'Unknown App';

            if (Neo.config.appPath) {
                const match = Neo.config.appPath.match(/apps\/([^\/]+)\//);
                if (match) {
                    appName = match[1]
                }
            }

            url.searchParams.set('appWorkerId', Neo.worker.App.id);
            url.searchParams.set('appName', appName);

            me.socket = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(me.socketConfig, _data_connection_WebSocket_mjs__WEBPACK_IMPORTED_MODULE_7__["default"], {
                serverAddress: url.toString(),
                listeners    : {
                    close  : me.onSocketClose,
                    error  : me.onSocketError,
                    message: me.onSocketMessage,
                    open   : me.onSocketOpen,
                    scope  : me
                }
            })
        } catch (e) {
            console.error('Neo.ai.Client: Failed to create WebSocket connection', e)
        }
    }

    /**
     * Routes specific JSON-RPC methods to their corresponding implementation.
     * This method acts as the central dispatcher for all AI-driven commands.
     * @param {String} method The JSON-RPC method name
     * @param {Object} params The parameters associated with the method
     * @returns {Promise<*>} The result of the operation
     */
    async handleRequest(method, params) {
        let me      = this,
            service = null,
            prefix;

        // Find matching service based on prefix
        // e.g. "get_component_property" -> matches "get_component" prefix
        for (prefix in me.serviceMap) {
            if (method.startsWith(prefix)) {
                service = me.serviceMap[prefix];
                break
            }
        }

        const fnName = Neo.snakeToCamel(method);

        if (service) {
            const fn = service[fnName];

            if (Neo.isFunction(fn)) {
                return fn.call(service, params)
            } else if (Neo.isPromise(fn)) {
                return await fn.call(service, params)
            }
        }

        if (service && typeof service[fnName] === 'function') {
            return service[fnName](params)
        }

        throw new Error(`Unknown method: ${method}`);
    }

    /**
     * @param {Object} data
     */
    onAppWorkerWindowConnect(data) {
        if (this.isConnected) {
            const
                win = _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].get(data.windowId),
                {appName, windowId} = data;

            this.sendNotification('window_connected', {
                appName,
                chrome   : win?.chrome,
                innerRect: win?.innerRect,
                outerRect: win?.outerRect,
                windowId
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.windowId
     */
    onAppWorkerWindowDisconnect({windowId}) {
        if (this.isConnected) {
            this.sendNotification('window_disconnected', {windowId})
        }
    }

    /**
     * Handles incoming messages from the WebSocket.
     * Parses the JSON-RPC payload and delegates valid requests to `handleRequest`.
     * @param {Object} data
     */
    async onSocketMessage({data}) {
        if (data.method) {
            try {
                const result = await this.handleRequest(data.method, data.params);
                this.sendResponse(data.id, result)
            } catch (e) {
                console.error('Neo.ai.Client: Failed to handle message', e);
                this.sendError(data.id, e.message, e.stack)
            }
        }
    }

    /**
     * @param {Event} event
     */
    onSocketOpen(event) {
        console.log('Neo.ai.Client: Connected to MCP Server');
        this.isConnected = true;

        // Flush buffered logs
        if (this.logs.length > 0) {
            this.logs.forEach(log => {
                this.sendNotification('console_log', log)
            });
            this.logs.length = 0
        }

        const appWorker = Neo.worker.App;

        // 1. Register the worker
        this.socket.sendMessage({
            jsonrpc: '2.0',
            method : 'register',
            params : {
                appWorkerId   : appWorker.id,
                environment   : Neo.config.environment,
                isSharedWorker: appWorker.isSharedWorker,
                userAgent     : navigator.userAgent
            }
        });

        // 2. Rehydrate window topology
        _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].items.forEach(win => {
            this.sendNotification('window_connected', {
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect,
                windowId : win.id
            })
        })

        // 3. Rehydrate drag state (if active)
        const dragCoordinator = Neo.manager?.DragCoordinator;

        if (dragCoordinator?.activeTargetZone) {
            this.sendNotification('drag_active', {
                sortGroup : dragCoordinator.activeTargetZone.sortGroup,
                sourceZone: dragCoordinator.activeTargetZone.id
            })
        }
    }

    /**
     * @param {CloseEvent} event
     */
    onSocketClose(event) {
        console.log('Neo.ai.Client: Disconnected');
        this.isConnected = false
    }

    /**
     * @param {Event} event
     */
    onSocketError(event) {
        console.error('Neo.ai.Client: WebSocket Error', event)
    }

    /**
     * Sends a JSON-RPC error response
     * @param {Number|String} id
     * @param {String} message
     * @param {String} [stack]
     */
    sendError(id, message, stack) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                id,
                error: {
                    code   : -32603, // Internal error
                    message: message,
                    data   : {stack}
                }
            })
        }
    }

    /**
     * Sends a JSON-RPC notification (no id)
     * @param {String} method
     * @param {Object} params
     */
    sendNotification(method, params) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                method,
                params
            })
        }
    }

    /**
     * Sends a JSON-RPC response
     * @param {Number|String} id
     * @param {*} result
     */
    sendResponse(id, result) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                id,
                result
            })
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Client));


/***/ },

/***/ "./src/ai/client/ComponentService.mjs"
/*!********************************************!*\
  !*** ./src/ai/client/ComponentService.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");
/* harmony import */ var _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/vdom/TreeBuilder.mjs */ "./src/util/vdom/TreeBuilder.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * Handles component-related Neural Link requests.
 * @class Neo.ai.client.ComponentService
 * @extends Neo.ai.client.Service
 */
class ComponentService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.ComponentService'
         * @protected
         */
        className: 'Neo.ai.client.ComponentService'
    }

    /**
     * @param {Object}   params
     * @param {String}   params.componentId
     * @param {String[]} params.variables
     * @returns {Object}
     */
    async getComputedStyles({componentId, variables}) {
        const component = Neo.getComponent(componentId);

        if (!component) {
            throw new Error(`Component not found: ${componentId}`)
        }

        const styles = await Neo.main.DomAccess.getComputedStyle({
            id   : component.id,
            style: variables
        });

        return {styles}
    }

    /**
     * @param {Object}   params
     * @param {String[]} params.componentIds
     * @returns {Object}
     */
    async getDomRect({componentIds}) {
        if (!Array.isArray(componentIds) || componentIds.length === 0) {
            throw new Error('componentIds must be a non-empty array')
        }

        // Use the first component to resolve the windowId context
        const component = Neo.getComponent(componentIds[0]);

        if (!component) {
            throw new Error(`Component not found: ${componentIds[0]}`)
        }

        const rects = await component.getDomRect(componentIds);

        return {
            rects: Array.isArray(rects) ? rects : [rects]
        }
    }

    /**
     * @param {Object} params
     * @param {String} params.componentId
     * @param {Object} [params.options]
     * @returns {Object}
     */
    highlightComponent({componentId, options}) {
        let component = Neo.getComponent(componentId),
            originalStyle;

        if (!component) {
            throw new Error(`Component not found: ${componentId}`)
        }

        options = options || {};

        const
            color    = options.color    || 'red',
            duration = options.duration || 2000,
            mode     = options.style    || 'outline'; // 'outline' or 'box-shadow'

        originalStyle = component.style || {};

        let highlightStyle = {};

        if (mode === 'outline') {
            highlightStyle.outline       = `2px solid ${color}`;
            highlightStyle.outlineOffset = '-2px'
        } else {
            highlightStyle.boxShadow = `0 0 10px ${color}, inset 0 0 10px ${color}`
        }

        component.style = {...originalStyle, ...highlightStyle};

        this.timeout(duration).then(() => {
            component.style = originalStyle
        });

        return {success: true}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getComponentTree({depth, rootId}) {
        return {tree: this.serializeComponent(this.getComponentRoot(rootId), depth || -1)}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVdomTree({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {vdom: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVdomTree(component.vdom, depth)}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVnodeTree({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVnodeTree(component.vnode, depth)}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVdomVnode({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {
            vdom : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVdomTree(component.vdom, depth),
            vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVnodeTree(component.vnode, depth)
        }
    }

    /**
     * @param {Object}   params
     * @param {String}   [params.rootId]
     * @param {Object}   params.selector
     * @param {String[]} [params.returnProperties]
     * @returns {Object}
     */
    queryComponent({rootId, selector, returnProperties}) {
        let matches;

        if (rootId) {
            const component = Neo.getComponent(rootId);
            if (!component) throw new Error(`Root component not found: ${rootId}`);
            matches = component.down(selector, false)
        } else {
            matches = Neo.manager.Component.find(selector)
        }

        const components = matches.map(c => {
            if (Array.isArray(returnProperties) && returnProperties.length > 0) {
                const props = {};
                returnProperties.forEach(prop => {
                    props[prop] = this.safeSerialize(c[prop])
                });

                return {
                    className : c.className,
                    id        : c.id,
                    properties: props
                }
            }

            return c.toJSON()
        });

        return {components}
    }

    /**
     * @param {Object} params
     * @param {String} [params.rootId]
     * @param {Object} params.selector
     * @returns {Object}
     */
    queryVdom({rootId, selector}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');

        const result = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(component.vdom, selector);

        return {
            vdom    : result?.vdom || null,
            index   : result?.index,
            parentId: result?.parentNode?.id
        }
    }

    /**
     * @param {String} [rootId]
     * @returns {Neo.component.Base|null}
     */
    getComponentRoot(rootId) {
        if (rootId) {
            return Neo.getComponent(rootId)
        }

        const apps = Object.values(Neo.apps || {});

        if (apps.length > 0) {
            return apps[0].mainView
        }

        return null
    }

    /**
     * @param {Neo.component.Base} component
     * @param {Number} maxDepth
     * @param {Number} currentDepth
     * @returns {Object}
     */
    serializeComponent(component, maxDepth, currentDepth=1) {
        if (!component) return null;

        const result = component.toJSON();

        if (maxDepth === -1 || currentDepth < maxDepth) {
            const children = Neo.manager.Component.getChildComponents(component);

            if (children && children.length > 0) {
                result.items = children.map(child => this.serializeComponent(child, maxDepth, currentDepth + 1))
            }
        }

        return result
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ComponentService));


/***/ },

/***/ "./src/ai/client/DataService.mjs"
/*!***************************************!*\
  !*** ./src/ai/client/DataService.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");
/* harmony import */ var _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Store.mjs */ "./src/manager/Store.mjs");



/**
 * Handles data-related Neural Link requests.
 * @class Neo.ai.client.DataService
 * @extends Neo.ai.client.Service
 */
class DataService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.DataService'
         * @protected
         */
        className: 'Neo.ai.client.DataService'
    }

    /**
     * @param {Object} params
     * @param {String} params.recordId
     * @param {String} [params.storeId]
     * @returns {Object}
     */
    getRecord({recordId, storeId}) {
        let record;

        if (storeId) {
            const store = Neo.get(storeId);
            if (!store) throw new Error(`Store not found: ${storeId}`);
            record = store.get(recordId)
        } else {
            const matches = [];
            _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].items.forEach(store => {
                const rec = store.get(recordId);
                if (rec) matches.push(rec)
            });

            if (matches.length > 1) {
                throw new Error(`Multiple records found with ID ${recordId}. Please specify storeId.`)
            } else if (matches.length === 1) {
                record = matches[0]
            }
        }

        if (!record) throw new Error(`Record not found: ${recordId}`);

        return record.toJSON()
    }

    /**
     * @param {Object} params
     * @param {String} params.providerId
     * @returns {Object}
     */
    inspectStateProvider({providerId}) {
        const provider = Neo.get(providerId);
        if (!provider) throw new Error(`StateProvider not found: ${providerId}`);

        return provider.toJSON()
    }

    /**
     * @param {Object} params
     * @param {Number} [params.limit=50]
     * @param {Number} [params.offset=0]
     * @param {String} params.storeId
     * @returns {Object}
     */
    inspectStore({limit=50, offset=0, storeId}) {
        const store = Neo.get(storeId);
        if (!store) throw new Error(`Store not found: ${storeId}`);

        return {
            ...store.toJSON(),
            items: store.getRange(offset, offset + limit).map(record => record.toJSON())
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    listStores(params) {
        return {
            stores: _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].items.map(s => ({
                id      : s.id,
                model   : s.model?.className || 'N/A',
                count   : s.count,
                isLoaded: s.isLoaded
            }))
        }
    }

    /**
     * @param {Object} params
     * @param {Object} params.data
     * @param {String} params.providerId
     * @returns {Object}
     */
    modifyStateProvider({data, providerId}) {
        const provider = Neo.get(providerId);
        if (!provider) throw new Error(`StateProvider not found: ${providerId}`);

        provider.setData(data);
        return {success: true}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DataService));


/***/ },

/***/ "./src/ai/client/InstanceService.mjs"
/*!*******************************************!*\
  !*** ./src/ai/client/InstanceService.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");


/**
 * Handles generic instance-related Neural Link requests.
 * @class Neo.ai.client.InstanceService
 * @extends Neo.ai.client.Service
 */
class InstanceService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.InstanceService'
         * @protected
         */
        className: 'Neo.ai.client.InstanceService'
    }

    /**
     * Retrieves properties from a specific instance by its ID.
     * @param {Object} params
     * @param {String} params.id
     * @param {String[]} params.properties
     * @returns {Object}
     */
    getInstanceProperties({id, properties}) {
        const
            instance = Neo.get(id),
            result   = {};

        if (!instance) {
            throw new Error(`Instance not found: ${id}`)
        }

        properties.forEach(property => {
            result[property] = this.safeSerialize(instance[property])
        });

        return {properties: result}
    }

    /**
     * Finds instances matching a selector.
     * @param {Object} params
     * @param {Object} params.selector
     * @param {String[]} [params.returnProperties]
     * @returns {Object}
     */
    findInstances({selector, returnProperties}) {
        const instances = Neo.manager.Instance.find(selector).map(instance => {
            if (Array.isArray(returnProperties) && returnProperties.length > 0) {
                const props = {};
                returnProperties.forEach(prop => {
                    props[prop] = this.safeSerialize(instance[prop])
                });

                return {
                    className : instance.className,
                    id        : instance.id,
                    properties: props
                }
            }

            return instance.toJSON()
        });

        return {instances}
    }

    /**
     * Sets properties on a specific instance by its ID.
     * @param {Object} params
     * @param {String} params.id
     * @param {Object} params.properties
     * @returns {Object}
     */
    setInstanceProperties({id, properties}) {
        const instance = Neo.get(id);

        if (!instance) {
            throw new Error(`Instance not found: ${id}`)
        }

        instance.set(properties);

        return {success: true}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(InstanceService));


/***/ },

/***/ "./src/ai/client/InteractionService.mjs"
/*!**********************************************!*\
  !*** ./src/ai/client/InteractionService.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");


/**
 * Service for handling interaction simulation commands.
 *
 * @class Neo.ai.client.InteractionService
 * @extends Neo.ai.client.Service
 */
class InteractionService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.InteractionService'
         * @protected
         */
        className: 'Neo.ai.client.InteractionService'
    }

    /**
     * Simulates a native DOM event sequence on the client.
     *
     * @param {Object} params
     * @param {Object[]} params.events - Sequence of event config objects
     * @returns {Promise<Boolean>}
     */
    async simulateEvent({events}) {
        let me = this;

        if (!Array.isArray(events)) {
            throw new Error('InteractionService: events must be an array')
        }

        for (const event of events) {
            if (event.delay) {
                await me.timeout(event.delay)
            }

            await me.dispatch({
                id      : event.targetId,
                options : event.options,
                type    : event.type,
                windowId: event.windowId
            })
        }

        return true
    }

    /**
     * Helper to dispatch a single event to the correct window
     * @param {Object} data
     * @param {String} data.id
     * @param {Object} data.options
     * @param {String} data.type
     * @param {String} data.windowId
     * @returns {Promise<Boolean>}
     */
    async dispatch({id, options, type, windowId}) {
        await Neo.Main.importAddon({name: 'EventSimulator', windowId});

        return await Neo.main.addon.EventSimulator.dispatch({
            id,
            options,
            type,
            windowId
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(InteractionService));


/***/ },

/***/ "./src/ai/client/RuntimeService.mjs"
/*!******************************************!*\
  !*** ./src/ai/client/RuntimeService.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");




/**
 * Handles runtime environment related Neural Link requests.
 * @class Neo.ai.client.RuntimeService
 * @extends Neo.ai.client.Service
 */
class RuntimeService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.RuntimeService'
         * @protected
         */
        className: 'Neo.ai.client.RuntimeService'
    }

    /**
     * Checks if a namespace exists in the current environment.
     * @param {Object} params
     * @param {String} params.namespace
     * @returns {Object} {exists: Boolean}
     */
    checkNamespace({namespace}) {
        return {
            exists: !!Neo.ns(namespace)
        }
    }

    /**
     * @param {Object} params
     * @param {String} params.componentId
     * @returns {Object}
     */
    getDomEventListeners({componentId}) {
        const
            listeners = [],
            eventMap  = _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].items?.[componentId];

        if (eventMap) {
            Object.entries(eventMap).forEach(([eventName, events]) => {
                events.forEach(event => {
                    listeners.push({
                        delegate: event.delegate,
                        event   : eventName,
                        handler : typeof event.fn === 'function' ? event.fn.name || 'anonymous' : event.fn,
                        priority: event.priority,
                        scope   : event.scope?.id || 'unknown'
                    })
                })
            })
        }

        return {listeners}
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getDomEventSummary(params) {
        const summary = {
            byComponent: {},
            byEvent    : {},
            totalEvents: 0
        };

        Object.entries(_manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].items).forEach(([componentId, eventMap]) => {
            let componentCount = 0;

            Object.entries(eventMap).forEach(([eventName, events]) => {
                const count = events.length;

                summary.totalEvents       += count;
                componentCount            += count;
                summary.byEvent[eventName] = (summary.byEvent[eventName] || 0) + count
            });

            if (componentCount > 0) {
                summary.byComponent[componentId] = componentCount
            }
        });

        return summary
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getDragState(params) {
        const dragCoordinator = Neo.manager?.DragCoordinator;

        if (dragCoordinator) {
            return dragCoordinator.toJSON()
        }

        return {};
    }

    /**
     * Retrieves the source code of a method on a class prototype.
     * @param {Object} params
     * @param {String} params.className  The fully qualified class name.
     * @param {String} params.methodName The name of the method.
     * @returns {Object} {success: Boolean, source?: String, error?: String}
     */
    getMethodSource({className, methodName}) {
        const cls = Neo.ns(className);

        if (!cls) {
            return {success: false, error: `Class '${className}' not found`}
        }

        const type = Neo.typeOf(cls);
        let proto;

        if (type === 'NeoClass') {
            proto = cls.prototype
        } else if (type === 'NeoInstance') {
            proto = cls.constructor.prototype
        } else {
            return {success: false, error: `Target '${className}' is not a Neo class or instance`}
        }

        if (typeof proto[methodName] !== 'function') {
            return {success: false, error: `Method '${methodName}' not found on '${className}'`}
        }

        return {
            success: true,
            source : proto[methodName].toString()
        }
    }

    /**
     * Retrieves the loaded namespace tree.
     * @param {Object} params
     * @param {String} [params.root='Neo'] The root namespace to start from (e.g., 'Neo', 'MyApp').
     * @returns {Object}
     */
    getNamespaceTree({root='Neo'}) {
        const
            me        = this,
            startNode = Neo.ns(root),
            tree      = {};

        if (!startNode) {
            return {tree: {}, error: `Namespace '${root}' not found`}
        }

        me.#traverseNamespace(startNode, root, tree);

        return {root, tree}
    }

    /**
     * @param {Object} params
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    getNeoConfig({windowId}) {
        if (windowId) {
            return Neo.windowConfigs?.[windowId] || null
        }
        return Neo.config
    }

    /**
     * @param {Object} params
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    getRouteHistory({windowId}) {
        const stack = _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getStack(windowId);

        return {
            count   : stack.length,
            history : stack,
            windowId: windowId || null
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getWindowInfo(params) {
        const windowManager = Neo.manager?.Window;

        if (windowManager) {
            return windowManager.toJSON()
        }

        return {windows: []};
    }

    /**
     * Inspects a class to retrieve its full schema (configs, methods, hierarchy).
     * @param {Object} params
     * @param {String} params.className
     * @param {String} [params.detail='standard'] 'standard' | 'compact'
     * @returns {Object}
     */
    inspectClass({className, detail='standard'}) {
        const cls = Neo.ns(className);

        if (!cls) {
            throw new Error(`Class not found: ${className}`)
        }

        const
            isClass = cls.isClass,
            ctor    = isClass ? cls : cls.constructor,
            proto   = ctor.prototype;

        // 1. Hierarchy & Mixins
        const getMixinNames = (obj) => {
            const names = [];
            if (Neo.isObject(obj)) {
                Object.values(obj).forEach(value => {
                    if (value && value.isClass) {
                        names.push(value.prototype.className)
                    } else {
                        names.push(...getMixinNames(value))
                    }
                })
            }
            return names
        };

        // 2. Configs & Methods
        const
            configs        = {},
            methods        = new Set(),
            configKeys     = new Set(Object.keys(ctor.config)),
            descriptors    = ctor.configDescriptors || {},
            ignoredProps   = ['constructor', 'construct', 'init', 'onConstructed', 'onAfterConstructed'],
            hookRegex      = /^(before|after)(Get|Set)([A-Z])/,
            // Helper to get raw hook name from config key
            getHookName    = (prefix, key) => prefix + key[0].toUpperCase() + key.slice(1);

        // Serialize the default values first
        const defaultValues = this.serializeConfig(ctor.config);

        // Get superclass config for comparison in compact mode
        const
            superCtor   = ctor.__proto__,
            superConfig = superCtor?.config || {};

        // Process Configs
        Object.keys(defaultValues).forEach(key => {
            // In compact mode, only include configs that are "own" (not in super or changed)
            if (detail === 'compact') {
                const isOwn = !Object.hasOwn(superConfig, key) || superConfig[key] !== ctor.config[key];
                if (!isOwn) return
            }

            configs[key] = {
                value: defaultValues[key]
            };

            // Add Descriptor info if available
            if (descriptors[key]) {
                configs[key].meta = this.serializeConfig(descriptors[key])
            }

            // Check for Hooks
            const hooks = [];
            ['beforeGet', 'beforeSet', 'afterSet'].forEach(prefix => {
                const hookName = getHookName(prefix, key);
                // In compact mode, only check for hooks on the current prototype
                if (detail === 'compact') {
                    if (Object.hasOwn(proto, hookName)) {
                        hooks.push(prefix)
                    }
                } else {
                    if (typeof proto[hookName] === 'function') {
                        hooks.push(prefix)
                    }
                }
            });

            if (hooks.length > 0) {
                configs[key].hooks = hooks
            }
        });

        // Process Methods
        let currentProto = proto;

        // Traverse up to Neo.core.Base
        while (currentProto && currentProto.constructor.className !== 'Object') {
            Object.getOwnPropertyNames(currentProto).forEach(name => {
                if (
                    !configKeys.has(name) &&
                    !ignoredProps.includes(name) &&
                    !name.startsWith('_') &&
                    !name.startsWith('#')
                ) {
                    // Check if it's a hook
                    const hookMatch = name.match(hookRegex);
                    if (hookMatch) {
                        // It is a hook. We only care if it wasn't already caught by the config loop.
                        // But since we want a clean method list, we generally exclude hooks here.
                        // The config loop above captures hooks *associated with known configs*.
                        // Orphaned hooks (for non-existent configs?) are rare/invalid.
                    } else {
                        const descriptor = Object.getOwnPropertyDescriptor(currentProto, name);
                        if (typeof descriptor.value === 'function') {
                            methods.add(name)
                        }
                    }
                }
            });

            // In compact mode, we only look at the top-level prototype
            if (detail === 'compact') {
                break
            }

            currentProto = currentProto.__proto__
        }

        return {
            className : proto.className,
            ntype     : proto.ntype,
            ntypeChain: ctor.ntypeChain,
            superClass: proto.__proto__?.constructor?.config?.className || null,
            mixins    : proto.mixins ? getMixinNames(proto.mixins) : [],
            configs,
            methods   : Array.from(methods).sort()
        }
    }

    /**
     * Replaces a method implementation on a class prototype at runtime.
     * RESTRICTED: Requires Neo.config.enableHotPatching = true.
     *
     * @param {Object} params
     * @param {String} params.className  The fully qualified class name (e.g., 'Neo.button.Base')
     * @param {String} params.methodName The name of the method to patch
     * @param {String} params.source     The new function source code (e.g., 'function(args) { ... }' or 'async (args) => { ... }')
     * @returns {Object} {success: Boolean, error?: String}
     */
    patchCode({className, methodName, source}) {
        if (Neo.config.enableHotPatching !== true) {
            return {
                success: false,
                error  : 'Hot patching is disabled. Set Neo.config.enableHotPatching = true to enable.'
            }
        }

        const cls = Neo.ns(className);

        if (!cls) {
            return {
                success: false,
                error  : `Class '${className}' not found`
            }
        }

        if (!cls.prototype) {
            return {
                success: false,
                error  : `Class '${className}' has no prototype (is it a singleton?)`
            }
        }

        try {
            // Use new Function to parse the source code safely into a function object.
            // This avoids direct use of eval() and ensures the code runs in the global scope.
            // eslint-disable-next-line no-new-func
            const fn = new Function('return ' + source)();

            if (typeof fn !== 'function') {
                return {
                    success: false,
                    error  : 'Source did not evaluate to a function'
                }
            }

            // 1. Log the patch for audit
            console.warn(`[Neo.ai.client.RuntimeService] Hot-patching ${className}.prototype.${methodName}`);

            // 2. Apply the patch
            cls.prototype[methodName] = fn;

            // 3. Mark method as patched (useful for debugging)
            fn.$isPatched = true;
            fn.$originalSource = source;

            return {success: true}

        } catch (e) {
            console.error('[Neo.ai.client.RuntimeService] Hot patch failed:', e);
            return {
                success: false,
                error  : e.message
            }
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    reloadPage(params) {
        Neo.Main.reloadWindow();
        return {status: 'reloading'};
    }

    /**
     * @param {Object} params
     * @param {Object} params.config
     * @returns {Object}
     */
    setNeoConfig({config}) {
        Neo.setGlobalConfig(config);
        return {status: 'ok'}
    }

    /**
     * @param {Object} params
     * @param {String} params.hash
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    setRoute({hash, windowId}) {
        Neo.Main.setRoute({
            value: hash,
            windowId
        });

        return {status: 'ok', hash}
    }

    /**
     * @param {Object} node
     * @param {String} path
     * @param {Object} output
     */
    #traverseNamespace(node, path, output) {
        Object.keys(node).forEach(key => {
            const
                value       = node[key],
                type        = Neo.typeOf(value),
                currentPath = path ? `${path}.${key}` : key;

            if (type === 'NeoClass') {
                output[key] = {
                    type     : 'class',
                    className: value.prototype.className
                }
            } else if (type === 'NeoInstance') {
                output[key] = {
                    type     : 'singleton',
                    className: value.className
                }
            } else if (type === 'Object') {
                // Only traverse plain objects (namespaces)
                // Neo.typeOf returns 'Object' for plain objects
                output[key] = {};
                this.#traverseNamespace(value, currentPath, output[key]);

                // Clean up empty packages
                if (Object.keys(output[key]).length === 0) {
                    delete output[key]
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RuntimeService));


/***/ },

/***/ "./src/ai/client/Service.mjs"
/*!***********************************!*\
  !*** ./src/ai/client/Service.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for Neural Link Client Services.
 * @class Neo.ai.client.Service
 * @extends Neo.core.Base
 */
class Service extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.Service'
         * @protected
         */
        className: 'Neo.ai.client.Service',
        /**
         * @member {Neo.ai.Client|null} client=null
         * @protected
         */
        client: null
    }

    /**
     * @param {*} value
     * @returns {*}
     */
    safeSerialize(value) {
        const type = Neo.typeOf(value);

        if (type === 'NeoInstance') {
            return value.toJSON()
        }

        if (type === 'Object') {
            const result = {};
            Object.entries(value).forEach(([k, v]) => {
                result[k] = this.safeSerialize(v)
            });
            return result
        }

        if (type === 'Array') {
            return value.map(v => this.safeSerialize(v))
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Service));


/***/ },

/***/ "./src/data/connection/WebSocket.mjs"
/*!*******************************************!*\
  !*** ./src/data/connection/WebSocket.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.data.connection.WebSocket
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Socket extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.connection.WebSocket'
         * @protected
         */
        className: 'Neo.data.connection.WebSocket',
        /**
         * @member {String} ntype='socket-connection'
         * @protected
         */
        ntype: 'socket-connection',
        /**
         * @member {Function} backoffStrategy=attempt=>Math.min(1000*Math.pow(2,attempt-1),30000)
         */
        backoffStrategy: attempt => Math.min(1000 * Math.pow(2, attempt - 1), 30000),
        /**
         * @member {WebSocket|null} socket_=null
         * @protected
         * @reactive
         */
        socket_: null
    }

    /**
     * @member {String|null} channel=null
     */
    channel = null
    /**
     * @member {Number} maxReconnectAttempts=5
     */
    maxReconnectAttempts = 5
    /**
     * @member {Object} messageCallbacks={}
     * @protected
     */
    messageCallbacks = {}
    /**
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * @member {Number} reconnectAttempts=0
     * @protected
     */
    reconnectAttempts = 0
    /**
     * @member {String|null} serverAddress=null
     */
    serverAddress = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createSocket()
    }

    /**
     * @param {Function} callback
     * @param {Object} scope
     */
    async attemptReconnect(callback, scope) {
        let me = this;

        me.reconnectAttempts++;

        if (me.reconnectAttempts < me.maxReconnectAttempts) {
            const delay = me.backoffStrategy(me.reconnectAttempts);

            me.fire('reconnecting', {
                attempt    : me.reconnectAttempts,
                maxAttempts: me.maxReconnectAttempts,
                delay
            });

            console.log(`WebSocket reconnect attempt ${me.reconnectAttempts}/${me.maxReconnectAttempts} in ${delay}ms`);

            await me.timeout(delay);

            if (!me.isDestroyed) {
                me.createSocket();

                callback && me.on('open', {
                    callback,
                    scope : scope || me,
                    single: true
                })
            }
        } else {
            console.error('Max reconnection attempts reached');
            me.fire('reconnect_failed')
        }
    }

    /**
     * Intercepts the WebSocket send calls
     * @param {Object} data
     * @returns {String}
     */
    beforeSend(data) {
        let me        = this,
            {channel} = me;

        return JSON.stringify(channel ? {channel, data} : data)
    }

    /**
     * Triggered before the socket config gets changed.
     * @param {WebSocket|null} value
     * @param {WebSocket|null} oldValue
     * @returns {WebSocket|null}
     * @protected
     */
    beforeSetSocket(value, oldValue) {
        if (value) {
            let me = this;

            Object.assign(value, {
                onclose  : me.onClose  .bind(me),
                onerror  : me.onError  .bind(me),
                onmessage: me.onMessage.bind(me),
                onopen   : me.onOpen   .bind(me)
            });

            (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.createInterceptor)(value, 'send', me.beforeSend, me)
        }

        return value
    }

    /**
     * @param {Number} [code] defaults to 1000
     * @param {String} [reason]
     */
    close(code, reason) {
        this.socket.close(code, reason)
    }

    /**
     *
     */
    createSocket() {
        this.socket = new WebSocket(this.serverAddress)
    }

    /**
     *
     */
    destroy(...args) {
        this.close();
        super.destroy(...args)
    }

    /**
     * @param {CloseEvent} event The Websocket generated CloseEvent
     * @param {Number}     event.code The WebSocket connection close code provided by the server
     *
     *        Code        Name                  Description
     *        0-999                             Reserved and not used.
     *        1000        CLOSE_NORMAL          Normal closure; the connection successfully completed whatever purpose for which it was created.
     *        1001        CLOSE_GOING_AWAY      The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.
     *        1002        CLOSE_PROTOCOL_ERROR  The endpoint is terminating the connection due to a protocol error.
     *        1003        CLOSE_UNSUPPORTED     The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).
     *        1004        CLOSE_TOO_LARGE       The endpoint is terminating the connection because a data frame was received that is too large.
     *        1005        CLOSE_NO_STATUS       Reserved.  Indicates that no status code was provided even though one was expected.
     *        1006        CLOSE_ABNORMAL        Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.
     *        1007-1999                         Reserved for future use by the WebSocket standard.
     *        2000-2999                         Reserved for use by WebSocket extensions.
     *        3000-3999                         Available for use by libraries and frameworks. May not be used by applications.
     *        4000-4999                         Available for use by applications.
     *
     * @param {String}     reason A string indicating the reason the server closed the connection. This is specific to the particular server and sub-protocol.
     * @param {Boolean}    wasClean Indicates whether or not the connection was cleanly closed.
     */
    onClose(event, reason, wasClean) {
        this.fire('close', {event, reason, wasClean});

        // Auto-reconnect on abnormal closure
        if (!wasClean || event.code !== 1000) {
            console.warn('WebSocket closed abnormally, attempting reconnect...');
            this.attemptReconnect()
        }
    }

    /**
     *
     */
    onError(error) {
        this.fire('error', {error})
    }

    /**
     * @param {MessageEvent} event
     */
    onMessage(event) {
        let me   = this,
            data = JSON.parse(event.data);

        me.fire('message', {data});

        if (data.mId) {
            me.messageCallbacks[data.mId].resolve(data.data);
            delete me.messageCallbacks[data.mId]
        }
    }

    /**
     *
     */
    onOpen() {
        this.reconnectAttempts = 0;
        this.fire('open', {scope: this})
    }

    /**
     * @param {Object} data
     * @returns {Promise<any>}
     */
    promiseMessage(data) {
        let me = this;

        return new Promise((resolve, reject) => {
            me.messageCallbacks[me.messageId] = {reject, resolve};

            me.sendMessage({data, mId: me.messageId});
            me.messageId++
        })
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        let me       = this,
            {socket} = me,
            d        = data;

        // CONNECTING  0   The connection is not yet open.
        // OPEN        1   The connection is open and ready to communicate.
        // CLOSING     2   The connection is in the process of closing.
        // CLOSED      3   The connection is closed or couldn't be opened.

        // If socket is not yet ready let's defer to open then resend
        switch (socket.readyState) {
            case WebSocket.CLOSED:
            case WebSocket.CLOSING:
                me.attemptReconnect(function() {
                    me.sendMessage(d);
                });
                break;
            case WebSocket.CONNECTING:
                me.on('open', function() {
                    me.sendMessage(d)
                }, me, {once: true});
                break;
            case WebSocket.OPEN:
                socket.send(data);
                break;
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Socket));


/***/ },

/***/ "./src/manager/Store.mjs"
/*!*******************************!*\
  !*** ./src/manager/Store.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.Store
 * @extends Neo.manager.Base
 * @singleton
 */
class Store extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Store'
         * @protected
         */
        className: 'Neo.manager.Store',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        
        // Alias Neo.getStore to this manager?
        // Neo.getStore = this.get.bind(this);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/manager/Window.mjs"
/*!********************************!*\
  !*** ./src/manager/Window.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");



/**
 * @summary The "God View" for the multi-window application workspace.
 * @description This manager maintains a real-time geometric map of all connected browser windows in the App Worker.
 * It is the central authority for spatial awareness, enabling features like the "Infinite Canvas" where
 * interactions (like Drag & Drop) can span across multiple OS-level windows.
 *
 * It receives high-frequency position updates from the Main Thread (via `Neo.main.addon.WindowPosition`)
 * and provides intersection testing APIs to determine which window is under a given screen coordinate.
 *
 * @class Neo.manager.Window
 * @extends Neo.manager.Base
 * @singleton
 * @see Neo.main.addon.WindowPosition
 */
class Window extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Window'
         * @protected
         */
        className: 'Neo.manager.Window',
        /**
         * @member {Boolean} isSafari
         * @protected
         */
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * Returns the windowId which intersects with the given global screen coordinates.
     * This is the core intersection test for cross-window drag and drop operations.
     * @param {Number} x Screen X coordinate
     * @param {Number} y Screen Y coordinate
     * @returns {String|null} The windowId of the target window, or null if no intersection.
     */
    getWindowAt(x, y) {
        let item = this.items.find(item => item.outerRect?.intersects({bottom: y, right: x, x, y}));

        return item ? item.id : null
    }

    /**
     * @param {Object} data
     * @returns {Object} {chrome, innerRect, outerRect}
     */
    calculateGeometry(data) {
        const
            {innerHeight, innerWidth, mozInnerScreenX, mozInnerScreenY, outerHeight, outerWidth, screenLeft, screenTop} = data,
            widthDiff    = outerWidth  - innerWidth,
            heightDiff   = outerHeight - innerHeight,
            // Assumption: Side borders are symmetric
            sideBorder   = widthDiff / 2,
            // Assumption: Bottom border matches side border (common in Windows)
            bottomBorder = sideBorder,
            // The rest is the top chrome (header)
            topChrome    = heightDiff - bottomBorder;

        const chrome = {
            bottom: bottomBorder,
            left  : sideBorder,
            right : sideBorder,
            top   : topChrome
        };

        let viewportLeft, viewportTop;

        if (typeof mozInnerScreenX === 'number') {
            // Firefox: explicit viewport coordinates
            viewportLeft = mozInnerScreenX;
            viewportTop  = mozInnerScreenY
        } else if (this.isSafari) {
            // Safari: screenLeft/Top is Frame position. Add chrome to get Viewport.
            viewportLeft = screenLeft + sideBorder;
            viewportTop  = screenTop  + topChrome
        } else {
            // Chrome/Edge: screenLeft/Top is Viewport position.
            viewportLeft = screenLeft;
            viewportTop  = screenTop
        }

        const innerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](viewportLeft, viewportTop, innerWidth, innerHeight);

        const outerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            viewportLeft - sideBorder,
            viewportTop  - topChrome,
            outerWidth,
            outerHeight
        );

        return {chrome, innerRect, outerRect}
    }

    /**
     * Triggered when a new browser window connects to the SharedWorker.
     * In Shared Worker mode, `Neo.worker.App#onConnect` ensures that `windowData`
     * is fetched from the Main Thread and included in the payload.
     * @param {Object} data
     * @param {Number} data.appName
     * @param {Object} [data.windowData] Contains geometry data (screenLeft, innerHeight, etc.)
     * @param {String} data.windowId
     */
    onWindowConnect({appName, windowData, windowId}) {
        let chrome    = null,
            innerRect = null,
            outerRect = null;

        if (windowData) {
            ({chrome, innerRect, outerRect} = this.calculateGeometry(windowData))
        }

        console.log('Window.onWindowConnect', {windowId, appName, chrome, innerRect, outerRect});

        this.register({appName, chrome, id: windowId, innerRect, outerRect})
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowDisconnect({windowId}) {
        this.unregister(windowId)
    }

    /**
     * Updates the geometric state of a window based on data from the Main Thread.
     * This method is called via direct delegation from the App Worker to minimize overhead.
     * @param {Object} data
     * @param {Number} data.innerHeight
     * @param {Number} data.outerHeight
     * @param {Number} data.outerWidth
     * @param {Number} data.screenLeft
     * @param {Number} data.screenTop
     * @param {String} data.windowId
     */
    onWindowPositionChange(data) {
        const
            me   = this,
            item = me.get(data.windowId),
            {chrome, innerRect, outerRect} = me.calculateGeometry(data);

        if (item) {
            item.chrome    = chrome;
            item.innerRect = innerRect;
            item.outerRect = outerRect
        } else {
            me.register({
                chrome,
                id: data.windowId,
                innerRect,
                outerRect
            })
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            className: this.className,
            windows  : this.items.map(win => ({
                id       : win.id,
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Window));


/***/ },

/***/ "./src/util/vdom/TreeBuilder.mjs"
/*!***************************************!*\
  !*** ./src/util/vdom/TreeBuilder.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * A singleton utility class responsible for recursively building VDOM and VNode trees.
 * It can expand component references within a tree structure into their full VDOM/VNode representations,
 * supporting selective (asymmetric) tree expansion for optimized updates.
 * @class Neo.util.vdom.TreeBuilder
 * @extends Neo.core.Base
 * @singleton
 */
class TreeBuilder extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.vdom.TreeBuilder'
         * @protected
         */
        className: 'Neo.util.vdom.TreeBuilder',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Private helper to recursively build a tree, abstracting the child node key.
     * @param {Object} node The vdom or vnode to process.
     * @param {Number} depth The current recursion depth.
     * @param {Set<String>|null} mergedChildIds A set of component IDs to selectively expand.
     * @param {String} childKey The property name for child nodes ('cn' or 'childNodes').
     * @returns {Object}
     * @private
     */
    #buildTree(node, depth, mergedChildIds, childKey) {
        // We can not use Neo.isObject() here, since inside unit-test scenarios, we will import vdom.Helper into main threads.
        // Inside this scenario, Neo.isObject() returns false for VNode instances
        if (typeof node !== 'object' || node === null) {
            return node
        }

        let output = {...node}; // Shallow copy

        if (node[childKey]) {
            output[childKey] = [];

            node[childKey].forEach(item => {
                let currentItem = item,
                    childDepth;

                if (currentItem.componentId) {
                    const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(currentItem.componentId);

                    // Sparse Tree Generation & Scoped Updates
                    // We prune the branch (send a placeholder) if:
                    // 1. We are at the depth boundary (depth === 1) AND it's not a merged update.
                    // 2. We are in a Merged Update (mergedChildIds exists) AND this component is not in the AllowList (not dirty/bridge).
                    // Exception: We never prune if depth is -1 (Full Tree) or if the component is not mounted yet.
                    if (depth !== -1 && component?.vnode) {
                        const isExpandable = mergedChildIds?.has(currentItem.componentId);

                        if ((depth === 1 && !isExpandable) || (mergedChildIds && !isExpandable)) {
                            output[childKey].push({...currentItem, neoIgnore: true});
                            return // Stop processing this branch
                        }
                    }

                    // Expand the branch if it's part of a merged update, or if the depth requires it, OR if the vnode is missing
                    if (depth > 1 || depth === -1 || mergedChildIds?.has(currentItem.componentId) || !component?.vnode) {
                        // Use the correct tree type based on the childKey
                        const componentTree = childKey === 'cn' ? component?.vdom : component?.vnode;
                        if (componentTree) {
                            currentItem = componentTree
                        }
                    }
                }

                if (item.componentId) {
                    childDepth = (depth === -1) ? -1 : Math.max(0, depth - 1)
                } else {
                    childDepth = depth
                }

                output[childKey].push(this.#buildTree(currentItem, childDepth, mergedChildIds, childKey))
            })
        }

        return output
    }


    /**
     * Copies a given vdom tree and replaces child component references with their vdom.
     * @param {Object} vdom
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVdomTree(vdom, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vdom, depth, mergedChildIds, 'cn')
    }

    /**
     * Copies a given vnode tree and replaces child component references with their vnode.
     * @param {Object} vnode
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVnodeTree(vnode, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vnode, depth, mergedChildIds, 'childNodes')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeBuilder));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19haV9DbGllbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ087QUFDUTtBQUNMO0FBQ0k7QUFDRztBQUNKO0FBQ0s7QUFDWDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxvRUFBZ0IsS0FBSyxXQUFXO0FBQ3BFLG9DQUFvQywrREFBVyxVQUFVLFdBQVc7QUFDcEUsb0NBQW9DLG1FQUFlLE1BQU0sV0FBVztBQUNwRSxvQ0FBb0Msc0VBQWtCLEdBQUcsV0FBVztBQUNwRSxvQ0FBb0Msa0VBQWMsT0FBTyxXQUFXO0FBQ3BFOztBQUVBLGVBQWUsaURBQWlEOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFlLDJCQUEyQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9haS9DbGllbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L0NvbXBvbmVudFNlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L0RhdGFTZXJ2aWNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2FpL2NsaWVudC9JbnN0YW5jZVNlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L0ludGVyYWN0aW9uU2VydmljZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9haS9jbGllbnQvUnVudGltZVNlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L1NlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZGF0YS9jb25uZWN0aW9uL1dlYlNvY2tldC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1N0b3JlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvV2luZG93Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvdmRvbS9UcmVlQnVpbGRlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50U2VydmljZSAgIGZyb20gJy4vY2xpZW50L0NvbXBvbmVudFNlcnZpY2UubWpzJztcbmltcG9ydCBEYXRhU2VydmljZSAgICAgICAgZnJvbSAnLi9jbGllbnQvRGF0YVNlcnZpY2UubWpzJztcbmltcG9ydCBJbnN0YW5jZVNlcnZpY2UgICAgZnJvbSAnLi9jbGllbnQvSW5zdGFuY2VTZXJ2aWNlLm1qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb25TZXJ2aWNlIGZyb20gJy4vY2xpZW50L0ludGVyYWN0aW9uU2VydmljZS5tanMnO1xuaW1wb3J0IFJ1bnRpbWVTZXJ2aWNlICAgICBmcm9tICcuL2NsaWVudC9SdW50aW1lU2VydmljZS5tanMnO1xuaW1wb3J0IFNvY2tldCAgICAgICAgICAgICBmcm9tICcuLi9kYXRhL2Nvbm5lY3Rpb24vV2ViU29ja2V0Lm1qcyc7XG5pbXBvcnQgV2luZG93TWFuYWdlciAgICAgIGZyb20gJy4uL21hbmFnZXIvV2luZG93Lm1qcyc7XG5cbi8qKlxuICogVGhlIEFJIENsaWVudCBlc3RhYmxpc2hlcyBhIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOZXVyYWwgTGluayBNQ1AgU2VydmVyLlxuICogSXQgYWN0cyBhcyBhIGJyaWRnZSwgZW5hYmxpbmcgZXh0ZXJuYWwgQUkgYWdlbnRzIHRvIGluc3BlY3QgYW5kIG1hbmlwdWxhdGUgdGhlIHJ1bm5pbmcgTmVvLm1qcyBhcHBsaWNhdGlvblxuICogdmlhIGEgc3RhbmRhcmRpemVkIEpTT04tUlBDIHByb3RvY29sLlxuICogQGNsYXNzIE5lby5haS5DbGllbnRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuQ2xpZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuQ2xpZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBjdXN0b20gY29uZmlncyBmb3IgZGF0YS5jb25uZWN0aW9uLldlYnNvY2tldCwgb3IgcGFzcyBhIG1vZHVsZSBvciBpbnN0YW5jZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fE5lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0fG51bGx9IHNvY2tldD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb2NrZXRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSBOZXVyYWwgTGluayBNQ1AgU2VydmVyJ3MgV2ViU29ja2V0IGVuZHBvaW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHVybD0nd3M6Ly8xMjcuMC4wLjE6ODA4MSdcbiAgICAgICAgICovXG4gICAgICAgIHVybDogJ3dzOi8vMTI3LjAuMC4xOjgwODEnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNDb25uZWN0ZWQ9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEJ1ZmZlciBmb3IgY29uc29sZSBsb2dzIGdlbmVyYXRlZCBiZWZvcmUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICAgICAqIEBtZW1iZXIge0FycmF5fSBsb2dzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGxvZ3MgPSBbXVxuICAgIC8qKlxuICAgICAqIE1hcCBKU09OLVJQQyBtZXRob2QgcHJlZml4ZXMgdG8gc2VydmljZSBpbnN0YW5jZXNcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHNlcnZpY2VNYXBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VydmljZU1hcCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHNlcnZpY2VzPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VydmljZXMgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXR8bnVsbH0gc29ja2V0PW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc29ja2V0ID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zZXJ2aWNlcyA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudCAgOiBOZW8uY3JlYXRlKENvbXBvbmVudFNlcnZpY2UsICAge2NsaWVudDogbWV9KSxcbiAgICAgICAgICAgIGRhdGEgICAgICAgOiBOZW8uY3JlYXRlKERhdGFTZXJ2aWNlLCAgICAgICAge2NsaWVudDogbWV9KSxcbiAgICAgICAgICAgIGluc3RhbmNlICAgOiBOZW8uY3JlYXRlKEluc3RhbmNlU2VydmljZSwgICAge2NsaWVudDogbWV9KSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uOiBOZW8uY3JlYXRlKEludGVyYWN0aW9uU2VydmljZSwge2NsaWVudDogbWV9KSxcbiAgICAgICAgICAgIHJ1bnRpbWUgICAgOiBOZW8uY3JlYXRlKFJ1bnRpbWVTZXJ2aWNlLCAgICAge2NsaWVudDogbWV9KVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHtjb21wb25lbnQsIGRhdGEsIGluc3RhbmNlLCBpbnRlcmFjdGlvbiwgcnVudGltZX0gPSBtZS5zZXJ2aWNlcztcblxuICAgICAgICBtZS5zZXJ2aWNlTWFwID0ge1xuICAgICAgICAgICAgZ2V0X2NvbXBvbmVudCAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X2NvbXB1dGVkX3N0eWxlcyAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X2RvbV9yZWN0ICAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X3Zkb20gICAgICAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X3Zkb21fdm5vZGUgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X3Zub2RlICAgICAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgaGlnaGxpZ2h0X2NvbXBvbmVudCAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgcXVlcnlfY29tcG9uZW50ICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgcXVlcnlfdmRvbSAgICAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgc2V0X2NvbXBvbmVudCAgICAgICAgIDogY29tcG9uZW50LFxuXG4gICAgICAgICAgICBmaW5kX2luc3RhbmNlcyAgICAgICAgIDogaW5zdGFuY2UsXG4gICAgICAgICAgICBnZXRfaW5zdGFuY2VfcHJvcGVydGllczogaW5zdGFuY2UsXG4gICAgICAgICAgICBzZXRfaW5zdGFuY2VfcHJvcGVydGllczogaW5zdGFuY2UsXG5cbiAgICAgICAgICAgIGdldF9yZWNvcmQgICAgICAgICAgICA6IGRhdGEsXG4gICAgICAgICAgICBpbnNwZWN0X3N0YXRlX3Byb3ZpZGVyOiBkYXRhLFxuICAgICAgICAgICAgaW5zcGVjdF9zdG9yZSAgICAgICAgIDogZGF0YSxcbiAgICAgICAgICAgIGxpc3Rfc3RvcmVzICAgICAgICAgICA6IGRhdGEsXG4gICAgICAgICAgICBtb2RpZnlfc3RhdGVfcHJvdmlkZXIgOiBkYXRhLFxuXG4gICAgICAgICAgICBnZXRfZG9tX2V2ZW50ICAgICAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgZ2V0X2RyYWcgICAgICAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIGdldF9tZXRob2Rfc291cmNlICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBnZXRfcm91dGUgICAgICAgICAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgZ2V0X3dpbmRvdyAgICAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIGluc3BlY3RfY2xhc3MgICAgICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBwYXRjaF9jb2RlICAgICAgICAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgcmVsb2FkX3BhZ2UgICAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIHNldF9yb3V0ZSAgICAgICAgICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBzaW11bGF0ZV9ldmVudCAgICAgICAgOiBpbnRlcmFjdGlvblxuICAgICAgICB9O1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uQXBwV29ya2VyV2luZG93Q29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uQXBwV29ya2VyV2luZG93RGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmNvbm5lY3QoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTmV1cmFsIExpbmsgTUNQIFNlcnZlci5cbiAgICAgKiBVc2VzIE5lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0IGZvciByb2J1c3QgY29ubmVjdGlvbiBtYW5hZ2VtZW50LlxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB1cmwgICAgID0gbmV3IFVSTChOZW8uY29uZmlnLm5ldXJhbExpbmtVcmwgfHwgbWUudXJsKSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lID0gJ1Vua25vd24gQXBwJztcblxuICAgICAgICAgICAgaWYgKE5lby5jb25maWcuYXBwUGF0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gTmVvLmNvbmZpZy5hcHBQYXRoLm1hdGNoKC9hcHBzXFwvKFteXFwvXSspXFwvLyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgPSBtYXRjaFsxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2FwcFdvcmtlcklkJywgTmVvLndvcmtlci5BcHAuaWQpO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2FwcE5hbWUnLCBhcHBOYW1lKTtcblxuICAgICAgICAgICAgbWUuc29ja2V0ID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKG1lLnNvY2tldENvbmZpZywgU29ja2V0LCB7XG4gICAgICAgICAgICAgICAgc2VydmVyQWRkcmVzczogdXJsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZSAgOiBtZS5vblNvY2tldENsb3NlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvciAgOiBtZS5vblNvY2tldEVycm9yLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZS5vblNvY2tldE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wZW4gICA6IG1lLm9uU29ja2V0T3BlbixcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgIDogbWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOZW8uYWkuQ2xpZW50OiBGYWlsZWQgdG8gY3JlYXRlIFdlYlNvY2tldCBjb25uZWN0aW9uJywgZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdXRlcyBzcGVjaWZpYyBKU09OLVJQQyBtZXRob2RzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgaW1wbGVtZW50YXRpb24uXG4gICAgICogVGhpcyBtZXRob2QgYWN0cyBhcyB0aGUgY2VudHJhbCBkaXNwYXRjaGVyIGZvciBhbGwgQUktZHJpdmVuIGNvbW1hbmRzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgVGhlIEpTT04tUlBDIG1ldGhvZCBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggdGhlIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBoYW5kbGVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHNlcnZpY2UgPSBudWxsLFxuICAgICAgICAgICAgcHJlZml4O1xuXG4gICAgICAgIC8vIEZpbmQgbWF0Y2hpbmcgc2VydmljZSBiYXNlZCBvbiBwcmVmaXhcbiAgICAgICAgLy8gZS5nLiBcImdldF9jb21wb25lbnRfcHJvcGVydHlcIiAtPiBtYXRjaGVzIFwiZ2V0X2NvbXBvbmVudFwiIHByZWZpeFxuICAgICAgICBmb3IgKHByZWZpeCBpbiBtZS5zZXJ2aWNlTWFwKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHNlcnZpY2UgPSBtZS5zZXJ2aWNlTWFwW3ByZWZpeF07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZuTmFtZSA9IE5lby5zbmFrZVRvQ2FtZWwobWV0aG9kKTtcblxuICAgICAgICBpZiAoc2VydmljZSkge1xuICAgICAgICAgICAgY29uc3QgZm4gPSBzZXJ2aWNlW2ZuTmFtZV07XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbChzZXJ2aWNlLCBwYXJhbXMpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc1Byb21pc2UoZm4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuLmNhbGwoc2VydmljZSwgcGFyYW1zKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcnZpY2UgJiYgdHlwZW9mIHNlcnZpY2VbZm5OYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VbZm5OYW1lXShwYXJhbXMpXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbWV0aG9kOiAke21ldGhvZH1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQXBwV29ya2VyV2luZG93Q29ubmVjdChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIHdpbiA9IFdpbmRvd01hbmFnZXIuZ2V0KGRhdGEud2luZG93SWQpLFxuICAgICAgICAgICAgICAgIHthcHBOYW1lLCB3aW5kb3dJZH0gPSBkYXRhO1xuXG4gICAgICAgICAgICB0aGlzLnNlbmROb3RpZmljYXRpb24oJ3dpbmRvd19jb25uZWN0ZWQnLCB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjaHJvbWUgICA6IHdpbj8uY2hyb21lLFxuICAgICAgICAgICAgICAgIGlubmVyUmVjdDogd2luPy5pbm5lclJlY3QsXG4gICAgICAgICAgICAgICAgb3V0ZXJSZWN0OiB3aW4/Lm91dGVyUmVjdCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbkFwcFdvcmtlcldpbmRvd0Rpc2Nvbm5lY3Qoe3dpbmRvd0lkfSkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZpY2F0aW9uKCd3aW5kb3dfZGlzY29ubmVjdGVkJywge3dpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgV2ViU29ja2V0LlxuICAgICAqIFBhcnNlcyB0aGUgSlNPTi1SUEMgcGF5bG9hZCBhbmQgZGVsZWdhdGVzIHZhbGlkIHJlcXVlc3RzIHRvIGBoYW5kbGVSZXF1ZXN0YC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uU29ja2V0TWVzc2FnZSh7ZGF0YX0pIHtcbiAgICAgICAgaWYgKGRhdGEubWV0aG9kKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlUmVxdWVzdChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlc3BvbnNlKGRhdGEuaWQsIHJlc3VsdClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOZW8uYWkuQ2xpZW50OiBGYWlsZWQgdG8gaGFuZGxlIG1lc3NhZ2UnLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihkYXRhLmlkLCBlLm1lc3NhZ2UsIGUuc3RhY2spXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uU29ja2V0T3BlbihldmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnTmVvLmFpLkNsaWVudDogQ29ubmVjdGVkIHRvIE1DUCBTZXJ2ZXInKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gRmx1c2ggYnVmZmVyZWQgbG9nc1xuICAgICAgICBpZiAodGhpcy5sb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9ncy5mb3JFYWNoKGxvZyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZpY2F0aW9uKCdjb25zb2xlX2xvZycsIGxvZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sb2dzLmxlbmd0aCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFwcFdvcmtlciA9IE5lby53b3JrZXIuQXBwO1xuXG4gICAgICAgIC8vIDEuIFJlZ2lzdGVyIHRoZSB3b3JrZXJcbiAgICAgICAgdGhpcy5zb2NrZXQuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2QgOiAncmVnaXN0ZXInLFxuICAgICAgICAgICAgcGFyYW1zIDoge1xuICAgICAgICAgICAgICAgIGFwcFdvcmtlcklkICAgOiBhcHBXb3JrZXIuaWQsXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQgICA6IE5lby5jb25maWcuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgaXNTaGFyZWRXb3JrZXI6IGFwcFdvcmtlci5pc1NoYXJlZFdvcmtlcixcbiAgICAgICAgICAgICAgICB1c2VyQWdlbnQgICAgIDogbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyAyLiBSZWh5ZHJhdGUgd2luZG93IHRvcG9sb2d5XG4gICAgICAgIFdpbmRvd01hbmFnZXIuaXRlbXMuZm9yRWFjaCh3aW4gPT4ge1xuICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZpY2F0aW9uKCd3aW5kb3dfY29ubmVjdGVkJywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWUgIDogd2luLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY2hyb21lICAgOiB3aW4uY2hyb21lLFxuICAgICAgICAgICAgICAgIGlubmVyUmVjdDogd2luLmlubmVyUmVjdCxcbiAgICAgICAgICAgICAgICBvdXRlclJlY3Q6IHdpbi5vdXRlclJlY3QsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiB3aW4uaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gMy4gUmVoeWRyYXRlIGRyYWcgc3RhdGUgKGlmIGFjdGl2ZSlcbiAgICAgICAgY29uc3QgZHJhZ0Nvb3JkaW5hdG9yID0gTmVvLm1hbmFnZXI/LkRyYWdDb29yZGluYXRvcjtcblxuICAgICAgICBpZiAoZHJhZ0Nvb3JkaW5hdG9yPy5hY3RpdmVUYXJnZXRab25lKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmROb3RpZmljYXRpb24oJ2RyYWdfYWN0aXZlJywge1xuICAgICAgICAgICAgICAgIHNvcnRHcm91cCA6IGRyYWdDb29yZGluYXRvci5hY3RpdmVUYXJnZXRab25lLnNvcnRHcm91cCxcbiAgICAgICAgICAgICAgICBzb3VyY2Vab25lOiBkcmFnQ29vcmRpbmF0b3IuYWN0aXZlVGFyZ2V0Wm9uZS5pZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2xvc2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNvY2tldENsb3NlKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZW8uYWkuQ2xpZW50OiBEaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNvY2tldEVycm9yKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05lby5haS5DbGllbnQ6IFdlYlNvY2tldCBFcnJvcicsIGV2ZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgSlNPTi1SUEMgZXJyb3IgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0YWNrXVxuICAgICAqL1xuICAgIHNlbmRFcnJvcihpZCwgbWVzc2FnZSwgc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlICAgOiAtMzI2MDMsIC8vIEludGVybmFsIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgICA6IHtzdGFja31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBKU09OLVJQQyBub3RpZmljYXRpb24gKG5vIGlkKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICovXG4gICAgc2VuZE5vdGlmaWNhdGlvbihtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIEpTT04tUlBDIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7Kn0gcmVzdWx0XG4gICAgICovXG4gICAgc2VuZFJlc3BvbnNlKGlkLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENsaWVudCk7XG4iLCJpbXBvcnQgU2VydmljZSAgICAgZnJvbSAnLi9TZXJ2aWNlLm1qcyc7XG5pbXBvcnQgVHJlZUJ1aWxkZXIgZnJvbSAnLi4vLi4vdXRpbC92ZG9tL1RyZWVCdWlsZGVyLm1qcyc7XG5pbXBvcnQgVmRvbVV0aWwgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogSGFuZGxlcyBjb21wb25lbnQtcmVsYXRlZCBOZXVyYWwgTGluayByZXF1ZXN0cy5cbiAqIEBjbGFzcyBOZW8uYWkuY2xpZW50LkNvbXBvbmVudFNlcnZpY2VcbiAqIEBleHRlbmRzIE5lby5haS5jbGllbnQuU2VydmljZVxuICovXG5jbGFzcyBDb21wb25lbnRTZXJ2aWNlIGV4dGVuZHMgU2VydmljZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuY2xpZW50LkNvbXBvbmVudFNlcnZpY2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5haS5jbGllbnQuQ29tcG9uZW50U2VydmljZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBwYXJhbXMuY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJhbXMudmFyaWFibGVzXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb21wdXRlZFN0eWxlcyh7Y29tcG9uZW50SWQsIHZhcmlhYmxlc30pIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChjb21wb25lbnRJZCk7XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IG5vdCBmb3VuZDogJHtjb21wb25lbnRJZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLmdldENvbXB1dGVkU3R5bGUoe1xuICAgICAgICAgICAgaWQgICA6IGNvbXBvbmVudC5pZCxcbiAgICAgICAgICAgIHN0eWxlOiB2YXJpYWJsZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtzdHlsZXN9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGFyYW1zLmNvbXBvbmVudElkc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RG9tUmVjdCh7Y29tcG9uZW50SWRzfSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29tcG9uZW50SWRzKSB8fCBjb21wb25lbnRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudElkcyBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5JylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgY29tcG9uZW50IHRvIHJlc29sdmUgdGhlIHdpbmRvd0lkIGNvbnRleHRcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChjb21wb25lbnRJZHNbMF0pO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCBub3QgZm91bmQ6ICR7Y29tcG9uZW50SWRzWzBdfWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWN0cyA9IGF3YWl0IGNvbXBvbmVudC5nZXREb21SZWN0KGNvbXBvbmVudElkcyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlY3RzOiBBcnJheS5pc0FycmF5KHJlY3RzKSA/IHJlY3RzIDogW3JlY3RzXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcy5vcHRpb25zXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgaGlnaGxpZ2h0Q29tcG9uZW50KHtjb21wb25lbnRJZCwgb3B0aW9uc30pIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoY29tcG9uZW50SWQpLFxuICAgICAgICAgICAgb3JpZ2luYWxTdHlsZTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgbm90IGZvdW5kOiAke2NvbXBvbmVudElkfWApXG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY29sb3IgICAgPSBvcHRpb25zLmNvbG9yICAgIHx8ICdyZWQnLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDIwMDAsXG4gICAgICAgICAgICBtb2RlICAgICA9IG9wdGlvbnMuc3R5bGUgICAgfHwgJ291dGxpbmUnOyAvLyAnb3V0bGluZScgb3IgJ2JveC1zaGFkb3cnXG5cbiAgICAgICAgb3JpZ2luYWxTdHlsZSA9IGNvbXBvbmVudC5zdHlsZSB8fCB7fTtcblxuICAgICAgICBsZXQgaGlnaGxpZ2h0U3R5bGUgPSB7fTtcblxuICAgICAgICBpZiAobW9kZSA9PT0gJ291dGxpbmUnKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRTdHlsZS5vdXRsaW5lICAgICAgID0gYDJweCBzb2xpZCAke2NvbG9yfWA7XG4gICAgICAgICAgICBoaWdobGlnaHRTdHlsZS5vdXRsaW5lT2Zmc2V0ID0gJy0ycHgnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdobGlnaHRTdHlsZS5ib3hTaGFkb3cgPSBgMCAwIDEwcHggJHtjb2xvcn0sIGluc2V0IDAgMCAxMHB4ICR7Y29sb3J9YFxuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50LnN0eWxlID0gey4uLm9yaWdpbmFsU3R5bGUsIC4uLmhpZ2hsaWdodFN0eWxlfTtcblxuICAgICAgICB0aGlzLnRpbWVvdXQoZHVyYXRpb24pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlID0gb3JpZ2luYWxTdHlsZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IHRydWV9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLmRlcHRoXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnJvb3RJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldENvbXBvbmVudFRyZWUoe2RlcHRoLCByb290SWR9KSB7XG4gICAgICAgIHJldHVybiB7dHJlZTogdGhpcy5zZXJpYWxpemVDb21wb25lbnQodGhpcy5nZXRDb21wb25lbnRSb290KHJvb3RJZCksIGRlcHRoIHx8IC0xKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuZGVwdGhdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucm9vdElkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmRvbVRyZWUoe2RlcHRoLCByb290SWR9KSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZ2V0Q29tcG9uZW50Um9vdChyb290SWQpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKCdSb290IGNvbXBvbmVudCBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHt2ZG9tOiBUcmVlQnVpbGRlci5nZXRWZG9tVHJlZShjb21wb25lbnQudmRvbSwgZGVwdGgpfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5kZXB0aF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5yb290SWRdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVRyZWUoe2RlcHRoLCByb290SWR9KSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZ2V0Q29tcG9uZW50Um9vdChyb290SWQpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKCdSb290IGNvbXBvbmVudCBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHt2bm9kZTogVHJlZUJ1aWxkZXIuZ2V0Vm5vZGVUcmVlKGNvbXBvbmVudC52bm9kZSwgZGVwdGgpfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5kZXB0aF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5yb290SWRdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWZG9tVm5vZGUoe2RlcHRoLCByb290SWR9KSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZ2V0Q29tcG9uZW50Um9vdChyb290SWQpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKCdSb290IGNvbXBvbmVudCBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZkb20gOiBUcmVlQnVpbGRlci5nZXRWZG9tVHJlZShjb21wb25lbnQudmRvbSwgZGVwdGgpLFxuICAgICAgICAgICAgdm5vZGU6IFRyZWVCdWlsZGVyLmdldFZub2RlVHJlZShjb21wb25lbnQudm5vZGUsIGRlcHRoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgW3BhcmFtcy5yb290SWRdXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgcGFyYW1zLnNlbGVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gW3BhcmFtcy5yZXR1cm5Qcm9wZXJ0aWVzXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgcXVlcnlDb21wb25lbnQoe3Jvb3RJZCwgc2VsZWN0b3IsIHJldHVyblByb3BlcnRpZXN9KSB7XG4gICAgICAgIGxldCBtYXRjaGVzO1xuXG4gICAgICAgIGlmIChyb290SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQocm9vdElkKTtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB0aHJvdyBuZXcgRXJyb3IoYFJvb3QgY29tcG9uZW50IG5vdCBmb3VuZDogJHtyb290SWR9YCk7XG4gICAgICAgICAgICBtYXRjaGVzID0gY29tcG9uZW50LmRvd24oc2VsZWN0b3IsIGZhbHNlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IE5lby5tYW5hZ2VyLkNvbXBvbmVudC5maW5kKHNlbGVjdG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IG1hdGNoZXMubWFwKGMgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmV0dXJuUHJvcGVydGllcykgJiYgcmV0dXJuUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm5Qcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3Byb3BdID0gdGhpcy5zYWZlU2VyaWFsaXplKGNbcHJvcF0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgOiBjLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgIDogYy5pZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjLnRvSlNPTigpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7Y29tcG9uZW50c31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucm9vdElkXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMuc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHF1ZXJ5VmRvbSh7cm9vdElkLCBzZWxlY3Rvcn0pIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5nZXRDb21wb25lbnRSb290KHJvb3RJZCk7XG4gICAgICAgIGlmICghY29tcG9uZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgY29tcG9uZW50IG5vdCBmb3VuZCcpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFZkb21VdGlsLmZpbmQoY29tcG9uZW50LnZkb20sIHNlbGVjdG9yKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmRvbSAgICA6IHJlc3VsdD8udmRvbSB8fCBudWxsLFxuICAgICAgICAgICAgaW5kZXggICA6IHJlc3VsdD8uaW5kZXgsXG4gICAgICAgICAgICBwYXJlbnRJZDogcmVzdWx0Py5wYXJlbnROb2RlPy5pZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtyb290SWRdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldENvbXBvbmVudFJvb3Qocm9vdElkKSB7XG4gICAgICAgIGlmIChyb290SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHJvb3RJZClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFwcHMgPSBPYmplY3QudmFsdWVzKE5lby5hcHBzIHx8IHt9KTtcblxuICAgICAgICBpZiAoYXBwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwc1swXS5tYWluVmlld1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heERlcHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGN1cnJlbnREZXB0aFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc2VyaWFsaXplQ29tcG9uZW50KGNvbXBvbmVudCwgbWF4RGVwdGgsIGN1cnJlbnREZXB0aD0xKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50KSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wb25lbnQudG9KU09OKCk7XG5cbiAgICAgICAgaWYgKG1heERlcHRoID09PSAtMSB8fCBjdXJyZW50RGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBOZW8ubWFuYWdlci5Db21wb25lbnQuZ2V0Q2hpbGRDb21wb25lbnRzKGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lml0ZW1zID0gY2hpbGRyZW4ubWFwKGNoaWxkID0+IHRoaXMuc2VyaWFsaXplQ29tcG9uZW50KGNoaWxkLCBtYXhEZXB0aCwgY3VycmVudERlcHRoICsgMSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnRTZXJ2aWNlKTtcbiIsImltcG9ydCBTZXJ2aWNlICAgICAgZnJvbSAnLi9TZXJ2aWNlLm1qcyc7XG5pbXBvcnQgU3RvcmVNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvU3RvcmUubWpzJztcblxuLyoqXG4gKiBIYW5kbGVzIGRhdGEtcmVsYXRlZCBOZXVyYWwgTGluayByZXF1ZXN0cy5cbiAqIEBjbGFzcyBOZW8uYWkuY2xpZW50LkRhdGFTZXJ2aWNlXG4gKiBAZXh0ZW5kcyBOZW8uYWkuY2xpZW50LlNlcnZpY2VcbiAqL1xuY2xhc3MgRGF0YVNlcnZpY2UgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5haS5jbGllbnQuRGF0YVNlcnZpY2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5haS5jbGllbnQuRGF0YVNlcnZpY2UnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucmVjb3JkSWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5zdG9yZUlkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0UmVjb3JkKHtyZWNvcmRJZCwgc3RvcmVJZH0pIHtcbiAgICAgICAgbGV0IHJlY29yZDtcblxuICAgICAgICBpZiAoc3RvcmVJZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSBOZW8uZ2V0KHN0b3JlSWQpO1xuICAgICAgICAgICAgaWYgKCFzdG9yZSkgdGhyb3cgbmV3IEVycm9yKGBTdG9yZSBub3QgZm91bmQ6ICR7c3RvcmVJZH1gKTtcbiAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldChyZWNvcmRJZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIFN0b3JlTWFuYWdlci5pdGVtcy5mb3JFYWNoKHN0b3JlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWMgPSBzdG9yZS5nZXQocmVjb3JkSWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZWMpIG1hdGNoZXMucHVzaChyZWMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgcmVjb3JkcyBmb3VuZCB3aXRoIElEICR7cmVjb3JkSWR9LiBQbGVhc2Ugc3BlY2lmeSBzdG9yZUlkLmApXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gbWF0Y2hlc1swXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWNvcmQpIHRocm93IG5ldyBFcnJvcihgUmVjb3JkIG5vdCBmb3VuZDogJHtyZWNvcmRJZH1gKTtcblxuICAgICAgICByZXR1cm4gcmVjb3JkLnRvSlNPTigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucHJvdmlkZXJJZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgaW5zcGVjdFN0YXRlUHJvdmlkZXIoe3Byb3ZpZGVySWR9KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gTmVvLmdldChwcm92aWRlcklkKTtcbiAgICAgICAgaWYgKCFwcm92aWRlcikgdGhyb3cgbmV3IEVycm9yKGBTdGF0ZVByb3ZpZGVyIG5vdCBmb3VuZDogJHtwcm92aWRlcklkfWApO1xuXG4gICAgICAgIHJldHVybiBwcm92aWRlci50b0pTT04oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5saW1pdD01MF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5vZmZzZXQ9MF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnN0b3JlSWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGluc3BlY3RTdG9yZSh7bGltaXQ9NTAsIG9mZnNldD0wLCBzdG9yZUlkfSkge1xuICAgICAgICBjb25zdCBzdG9yZSA9IE5lby5nZXQoc3RvcmVJZCk7XG4gICAgICAgIGlmICghc3RvcmUpIHRocm93IG5ldyBFcnJvcihgU3RvcmUgbm90IGZvdW5kOiAke3N0b3JlSWR9YCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0b3JlLnRvSlNPTigpLFxuICAgICAgICAgICAgaXRlbXM6IHN0b3JlLmdldFJhbmdlKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQpLm1hcChyZWNvcmQgPT4gcmVjb3JkLnRvSlNPTigpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgbGlzdFN0b3JlcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3JlczogU3RvcmVNYW5hZ2VyLml0ZW1zLm1hcChzID0+ICh7XG4gICAgICAgICAgICAgICAgaWQgICAgICA6IHMuaWQsXG4gICAgICAgICAgICAgICAgbW9kZWwgICA6IHMubW9kZWw/LmNsYXNzTmFtZSB8fCAnTi9BJyxcbiAgICAgICAgICAgICAgICBjb3VudCAgIDogcy5jb3VudCxcbiAgICAgICAgICAgICAgICBpc0xvYWRlZDogcy5pc0xvYWRlZFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5kYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wcm92aWRlcklkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBtb2RpZnlTdGF0ZVByb3ZpZGVyKHtkYXRhLCBwcm92aWRlcklkfSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IE5lby5nZXQocHJvdmlkZXJJZCk7XG4gICAgICAgIGlmICghcHJvdmlkZXIpIHRocm93IG5ldyBFcnJvcihgU3RhdGVQcm92aWRlciBub3QgZm91bmQ6ICR7cHJvdmlkZXJJZH1gKTtcblxuICAgICAgICBwcm92aWRlci5zZXREYXRhKGRhdGEpO1xuICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IHRydWV9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEYXRhU2VydmljZSk7XG4iLCJpbXBvcnQgU2VydmljZSBmcm9tICcuL1NlcnZpY2UubWpzJztcblxuLyoqXG4gKiBIYW5kbGVzIGdlbmVyaWMgaW5zdGFuY2UtcmVsYXRlZCBOZXVyYWwgTGluayByZXF1ZXN0cy5cbiAqIEBjbGFzcyBOZW8uYWkuY2xpZW50Lkluc3RhbmNlU2VydmljZVxuICogQGV4dGVuZHMgTmVvLmFpLmNsaWVudC5TZXJ2aWNlXG4gKi9cbmNsYXNzIEluc3RhbmNlU2VydmljZSBleHRlbmRzIFNlcnZpY2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFpLmNsaWVudC5JbnN0YW5jZVNlcnZpY2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5haS5jbGllbnQuSW5zdGFuY2VTZXJ2aWNlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBwcm9wZXJ0aWVzIGZyb20gYSBzcGVjaWZpYyBpbnN0YW5jZSBieSBpdHMgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJhbXMucHJvcGVydGllc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0SW5zdGFuY2VQcm9wZXJ0aWVzKHtpZCwgcHJvcGVydGllc30pIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGluc3RhbmNlID0gTmVvLmdldChpZCksXG4gICAgICAgICAgICByZXN1bHQgICA9IHt9O1xuXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugbm90IGZvdW5kOiAke2lkfWApXG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IHRoaXMuc2FmZVNlcmlhbGl6ZShpbnN0YW5jZVtwcm9wZXJ0eV0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7cHJvcGVydGllczogcmVzdWx0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGluc3RhbmNlcyBtYXRjaGluZyBhIHNlbGVjdG9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnNlbGVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gW3BhcmFtcy5yZXR1cm5Qcm9wZXJ0aWVzXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZmluZEluc3RhbmNlcyh7c2VsZWN0b3IsIHJldHVyblByb3BlcnRpZXN9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlcyA9IE5lby5tYW5hZ2VyLkluc3RhbmNlLmZpbmQoc2VsZWN0b3IpLm1hcChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXR1cm5Qcm9wZXJ0aWVzKSAmJiByZXR1cm5Qcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVyblByb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSB0aGlzLnNhZmVTZXJpYWxpemUoaW5zdGFuY2VbcHJvcF0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgOiBpbnN0YW5jZS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICA6IGluc3RhbmNlLmlkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnRvSlNPTigpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7aW5zdGFuY2VzfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgcHJvcGVydGllcyBvbiBhIHNwZWNpZmljIGluc3RhbmNlIGJ5IGl0cyBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5pZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucHJvcGVydGllc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc2V0SW5zdGFuY2VQcm9wZXJ0aWVzKHtpZCwgcHJvcGVydGllc30pIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBOZW8uZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZDogJHtpZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgaW5zdGFuY2Uuc2V0KHByb3BlcnRpZXMpO1xuXG4gICAgICAgIHJldHVybiB7c3VjY2VzczogdHJ1ZX1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEluc3RhbmNlU2VydmljZSk7XG4iLCJpbXBvcnQgU2VydmljZSBmcm9tICcuL1NlcnZpY2UubWpzJztcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBoYW5kbGluZyBpbnRlcmFjdGlvbiBzaW11bGF0aW9uIGNvbW1hbmRzLlxuICpcbiAqIEBjbGFzcyBOZW8uYWkuY2xpZW50LkludGVyYWN0aW9uU2VydmljZVxuICogQGV4dGVuZHMgTmVvLmFpLmNsaWVudC5TZXJ2aWNlXG4gKi9cbmNsYXNzIEludGVyYWN0aW9uU2VydmljZSBleHRlbmRzIFNlcnZpY2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFpLmNsaWVudC5JbnRlcmFjdGlvblNlcnZpY2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5haS5jbGllbnQuSW50ZXJhY3Rpb25TZXJ2aWNlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlcyBhIG5hdGl2ZSBET00gZXZlbnQgc2VxdWVuY2Ugb24gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwYXJhbXMuZXZlbnRzIC0gU2VxdWVuY2Ugb2YgZXZlbnQgY29uZmlnIG9iamVjdHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCb29sZWFuPn1cbiAgICAgKi9cbiAgICBhc3luYyBzaW11bGF0ZUV2ZW50KHtldmVudHN9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJhY3Rpb25TZXJ2aWNlOiBldmVudHMgbXVzdCBiZSBhbiBhcnJheScpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRlbGF5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dChldmVudC5kZWxheSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgbWUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIGlkICAgICAgOiBldmVudC50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zIDogZXZlbnQub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0eXBlICAgIDogZXZlbnQudHlwZSxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZDogZXZlbnQud2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byBkaXNwYXRjaCBhIHNpbmdsZSBldmVudCB0byB0aGUgY29ycmVjdCB3aW5kb3dcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEub3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJvb2xlYW4+fVxuICAgICAqL1xuICAgIGFzeW5jIGRpc3BhdGNoKHtpZCwgb3B0aW9ucywgdHlwZSwgd2luZG93SWR9KSB7XG4gICAgICAgIGF3YWl0IE5lby5NYWluLmltcG9ydEFkZG9uKHtuYW1lOiAnRXZlbnRTaW11bGF0b3InLCB3aW5kb3dJZH0pO1xuXG4gICAgICAgIHJldHVybiBhd2FpdCBOZW8ubWFpbi5hZGRvbi5FdmVudFNpbXVsYXRvci5kaXNwYXRjaCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEludGVyYWN0aW9uU2VydmljZSk7XG4iLCJpbXBvcnQgRG9tRXZlbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvRG9tRXZlbnQubWpzJztcbmltcG9ydCBIYXNoSGlzdG9yeSAgICAgZnJvbSAnLi4vLi4vdXRpbC9IYXNoSGlzdG9yeS5tanMnO1xuaW1wb3J0IFNlcnZpY2UgICAgICAgICBmcm9tICcuL1NlcnZpY2UubWpzJztcblxuLyoqXG4gKiBIYW5kbGVzIHJ1bnRpbWUgZW52aXJvbm1lbnQgcmVsYXRlZCBOZXVyYWwgTGluayByZXF1ZXN0cy5cbiAqIEBjbGFzcyBOZW8uYWkuY2xpZW50LlJ1bnRpbWVTZXJ2aWNlXG4gKiBAZXh0ZW5kcyBOZW8uYWkuY2xpZW50LlNlcnZpY2VcbiAqL1xuY2xhc3MgUnVudGltZVNlcnZpY2UgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5haS5jbGllbnQuUnVudGltZVNlcnZpY2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5haS5jbGllbnQuUnVudGltZVNlcnZpY2UnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbmFtZXNwYWNlIGV4aXN0cyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5uYW1lc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7ZXhpc3RzOiBCb29sZWFufVxuICAgICAqL1xuICAgIGNoZWNrTmFtZXNwYWNlKHtuYW1lc3BhY2V9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleGlzdHM6ICEhTmVvLm5zKG5hbWVzcGFjZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNvbXBvbmVudElkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREb21FdmVudExpc3RlbmVycyh7Y29tcG9uZW50SWR9KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgICAgIGV2ZW50TWFwICA9IERvbUV2ZW50TWFuYWdlci5pdGVtcz8uW2NvbXBvbmVudElkXTtcblxuICAgICAgICBpZiAoZXZlbnRNYXApIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGV2ZW50TWFwKS5mb3JFYWNoKChbZXZlbnROYW1lLCBldmVudHNdKSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZTogZXZlbnQuZGVsZWdhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCAgIDogZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlciA6IHR5cGVvZiBldmVudC5mbiA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50LmZuLm5hbWUgfHwgJ2Fub255bW91cycgOiBldmVudC5mbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBldmVudC5wcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlICAgOiBldmVudC5zY29wZT8uaWQgfHwgJ3Vua25vd24nXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge2xpc3RlbmVyc31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREb21FdmVudFN1bW1hcnkocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHN1bW1hcnkgPSB7XG4gICAgICAgICAgICBieUNvbXBvbmVudDoge30sXG4gICAgICAgICAgICBieUV2ZW50ICAgIDoge30sXG4gICAgICAgICAgICB0b3RhbEV2ZW50czogMFxuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKERvbUV2ZW50TWFuYWdlci5pdGVtcykuZm9yRWFjaCgoW2NvbXBvbmVudElkLCBldmVudE1hcF0pID0+IHtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGV2ZW50TWFwKS5mb3JFYWNoKChbZXZlbnROYW1lLCBldmVudHNdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBldmVudHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgc3VtbWFyeS50b3RhbEV2ZW50cyAgICAgICArPSBjb3VudDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDb3VudCAgICAgICAgICAgICs9IGNvdW50O1xuICAgICAgICAgICAgICAgIHN1bW1hcnkuYnlFdmVudFtldmVudE5hbWVdID0gKHN1bW1hcnkuYnlFdmVudFtldmVudE5hbWVdIHx8IDApICsgY291bnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3VtbWFyeS5ieUNvbXBvbmVudFtjb21wb25lbnRJZF0gPSBjb21wb25lbnRDb3VudFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3VtbWFyeVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldERyYWdTdGF0ZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZHJhZ0Nvb3JkaW5hdG9yID0gTmVvLm1hbmFnZXI/LkRyYWdDb29yZGluYXRvcjtcblxuICAgICAgICBpZiAoZHJhZ0Nvb3JkaW5hdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJhZ0Nvb3JkaW5hdG9yLnRvSlNPTigpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzb3VyY2UgY29kZSBvZiBhIG1ldGhvZCBvbiBhIGNsYXNzIHByb3RvdHlwZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5jbGFzc05hbWUgIFRoZSBmdWxseSBxdWFsaWZpZWQgY2xhc3MgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7c3VjY2VzczogQm9vbGVhbiwgc291cmNlPzogU3RyaW5nLCBlcnJvcj86IFN0cmluZ31cbiAgICAgKi9cbiAgICBnZXRNZXRob2RTb3VyY2Uoe2NsYXNzTmFtZSwgbWV0aG9kTmFtZX0pIHtcbiAgICAgICAgY29uc3QgY2xzID0gTmVvLm5zKGNsYXNzTmFtZSk7XG5cbiAgICAgICAgaWYgKCFjbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3VjY2VzczogZmFsc2UsIGVycm9yOiBgQ2xhc3MgJyR7Y2xhc3NOYW1lfScgbm90IGZvdW5kYH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBOZW8udHlwZU9mKGNscyk7XG4gICAgICAgIGxldCBwcm90bztcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ05lb0NsYXNzJykge1xuICAgICAgICAgICAgcHJvdG8gPSBjbHMucHJvdG90eXBlXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgcHJvdG8gPSBjbHMuY29uc3RydWN0b3IucHJvdG90eXBlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYFRhcmdldCAnJHtjbGFzc05hbWV9JyBpcyBub3QgYSBOZW8gY2xhc3Mgb3IgaW5zdGFuY2VgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b1ttZXRob2ROYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHtzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBNZXRob2QgJyR7bWV0aG9kTmFtZX0nIG5vdCBmb3VuZCBvbiAnJHtjbGFzc05hbWV9J2B9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHNvdXJjZSA6IHByb3RvW21ldGhvZE5hbWVdLnRvU3RyaW5nKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbG9hZGVkIG5hbWVzcGFjZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5yb290PSdOZW8nXSBUaGUgcm9vdCBuYW1lc3BhY2UgdG8gc3RhcnQgZnJvbSAoZS5nLiwgJ05lbycsICdNeUFwcCcpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TmFtZXNwYWNlVHJlZSh7cm9vdD0nTmVvJ30pIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdGFydE5vZGUgPSBOZW8ubnMocm9vdCksXG4gICAgICAgICAgICB0cmVlICAgICAgPSB7fTtcblxuICAgICAgICBpZiAoIXN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0cmVlOiB7fSwgZXJyb3I6IGBOYW1lc3BhY2UgJyR7cm9vdH0nIG5vdCBmb3VuZGB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS4jdHJhdmVyc2VOYW1lc3BhY2Uoc3RhcnROb2RlLCByb290LCB0cmVlKTtcblxuICAgICAgICByZXR1cm4ge3Jvb3QsIHRyZWV9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLndpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TmVvQ29uZmlnKHt3aW5kb3dJZH0pIHtcbiAgICAgICAgaWYgKHdpbmRvd0lkKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLndpbmRvd0NvbmZpZ3M/Llt3aW5kb3dJZF0gfHwgbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOZW8uY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLndpbmRvd0lkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um91dGVIaXN0b3J5KHt3aW5kb3dJZH0pIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBIYXNoSGlzdG9yeS5nZXRTdGFjayh3aW5kb3dJZCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvdW50ICAgOiBzdGFjay5sZW5ndGgsXG4gICAgICAgICAgICBoaXN0b3J5IDogc3RhY2ssXG4gICAgICAgICAgICB3aW5kb3dJZDogd2luZG93SWQgfHwgbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0V2luZG93SW5mbyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgd2luZG93TWFuYWdlciA9IE5lby5tYW5hZ2VyPy5XaW5kb3c7XG5cbiAgICAgICAgaWYgKHdpbmRvd01hbmFnZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3dNYW5hZ2VyLnRvSlNPTigpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge3dpbmRvd3M6IFtdfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNwZWN0cyBhIGNsYXNzIHRvIHJldHJpZXZlIGl0cyBmdWxsIHNjaGVtYSAoY29uZmlncywgbWV0aG9kcywgaGllcmFyY2h5KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5jbGFzc05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5kZXRhaWw9J3N0YW5kYXJkJ10gJ3N0YW5kYXJkJyB8ICdjb21wYWN0J1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgaW5zcGVjdENsYXNzKHtjbGFzc05hbWUsIGRldGFpbD0nc3RhbmRhcmQnfSkge1xuICAgICAgICBjb25zdCBjbHMgPSBOZW8ubnMoY2xhc3NOYW1lKTtcblxuICAgICAgICBpZiAoIWNscykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGFzcyBub3QgZm91bmQ6ICR7Y2xhc3NOYW1lfWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgaXNDbGFzcyA9IGNscy5pc0NsYXNzLFxuICAgICAgICAgICAgY3RvciAgICA9IGlzQ2xhc3MgPyBjbHMgOiBjbHMuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBwcm90byAgID0gY3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgLy8gMS4gSGllcmFyY2h5ICYgTWl4aW5zXG4gICAgICAgIGNvbnN0IGdldE1peGluTmFtZXMgPSAob2JqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdChvYmopKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhvYmopLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMucHVzaCh2YWx1ZS5wcm90b3R5cGUuY2xhc3NOYW1lKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMucHVzaCguLi5nZXRNaXhpbk5hbWVzKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZXNcbiAgICAgICAgfTtcblxuICAgICAgICAvLyAyLiBDb25maWdzICYgTWV0aG9kc1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY29uZmlncyAgICAgICAgPSB7fSxcbiAgICAgICAgICAgIG1ldGhvZHMgICAgICAgID0gbmV3IFNldCgpLFxuICAgICAgICAgICAgY29uZmlnS2V5cyAgICAgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGN0b3IuY29uZmlnKSksXG4gICAgICAgICAgICBkZXNjcmlwdG9ycyAgICA9IGN0b3IuY29uZmlnRGVzY3JpcHRvcnMgfHwge30sXG4gICAgICAgICAgICBpZ25vcmVkUHJvcHMgICA9IFsnY29uc3RydWN0b3InLCAnY29uc3RydWN0JywgJ2luaXQnLCAnb25Db25zdHJ1Y3RlZCcsICdvbkFmdGVyQ29uc3RydWN0ZWQnXSxcbiAgICAgICAgICAgIGhvb2tSZWdleCAgICAgID0gL14oYmVmb3JlfGFmdGVyKShHZXR8U2V0KShbQS1aXSkvLFxuICAgICAgICAgICAgLy8gSGVscGVyIHRvIGdldCByYXcgaG9vayBuYW1lIGZyb20gY29uZmlnIGtleVxuICAgICAgICAgICAgZ2V0SG9va05hbWUgICAgPSAocHJlZml4LCBrZXkpID0+IHByZWZpeCArIGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpO1xuXG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgZGVmYXVsdCB2YWx1ZXMgZmlyc3RcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IHRoaXMuc2VyaWFsaXplQ29uZmlnKGN0b3IuY29uZmlnKTtcblxuICAgICAgICAvLyBHZXQgc3VwZXJjbGFzcyBjb25maWcgZm9yIGNvbXBhcmlzb24gaW4gY29tcGFjdCBtb2RlXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBzdXBlckN0b3IgICA9IGN0b3IuX19wcm90b19fLFxuICAgICAgICAgICAgc3VwZXJDb25maWcgPSBzdXBlckN0b3I/LmNvbmZpZyB8fCB7fTtcblxuICAgICAgICAvLyBQcm9jZXNzIENvbmZpZ3NcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdFZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gSW4gY29tcGFjdCBtb2RlLCBvbmx5IGluY2x1ZGUgY29uZmlncyB0aGF0IGFyZSBcIm93blwiIChub3QgaW4gc3VwZXIgb3IgY2hhbmdlZClcbiAgICAgICAgICAgIGlmIChkZXRhaWwgPT09ICdjb21wYWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT3duID0gIU9iamVjdC5oYXNPd24oc3VwZXJDb25maWcsIGtleSkgfHwgc3VwZXJDb25maWdba2V5XSAhPT0gY3Rvci5jb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3duKSByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnc1trZXldID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWZhdWx0VmFsdWVzW2tleV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEFkZCBEZXNjcmlwdG9yIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcnNba2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3Nba2V5XS5tZXRhID0gdGhpcy5zZXJpYWxpemVDb25maWcoZGVzY3JpcHRvcnNba2V5XSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEhvb2tzXG4gICAgICAgICAgICBjb25zdCBob29rcyA9IFtdO1xuICAgICAgICAgICAgWydiZWZvcmVHZXQnLCAnYmVmb3JlU2V0JywgJ2FmdGVyU2V0J10uZm9yRWFjaChwcmVmaXggPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tOYW1lID0gZ2V0SG9va05hbWUocHJlZml4LCBrZXkpO1xuICAgICAgICAgICAgICAgIC8vIEluIGNvbXBhY3QgbW9kZSwgb25seSBjaGVjayBmb3IgaG9va3Mgb24gdGhlIGN1cnJlbnQgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgaWYgKGRldGFpbCA9PT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHByb3RvLCBob29rTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzLnB1c2gocHJlZml4KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b1tob29rTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzLnB1c2gocHJlZml4KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChob29rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnc1trZXldLmhvb2tzID0gaG9va3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBNZXRob2RzXG4gICAgICAgIGxldCBjdXJyZW50UHJvdG8gPSBwcm90bztcblxuICAgICAgICAvLyBUcmF2ZXJzZSB1cCB0byBOZW8uY29yZS5CYXNlXG4gICAgICAgIHdoaWxlIChjdXJyZW50UHJvdG8gJiYgY3VycmVudFByb3RvLmNvbnN0cnVjdG9yLmNsYXNzTmFtZSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN1cnJlbnRQcm90bykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFjb25maWdLZXlzLmhhcyhuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaWdub3JlZFByb3BzLmluY2x1ZGVzKG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICFuYW1lLnN0YXJ0c1dpdGgoJ18nKSAmJlxuICAgICAgICAgICAgICAgICAgICAhbmFtZS5zdGFydHNXaXRoKCcjJylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIGhvb2tcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va01hdGNoID0gbmFtZS5tYXRjaChob29rUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG9va01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhIGhvb2suIFdlIG9ubHkgY2FyZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeSBjYXVnaHQgYnkgdGhlIGNvbmZpZyBsb29wLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IHNpbmNlIHdlIHdhbnQgYSBjbGVhbiBtZXRob2QgbGlzdCwgd2UgZ2VuZXJhbGx5IGV4Y2x1ZGUgaG9va3MgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb25maWcgbG9vcCBhYm92ZSBjYXB0dXJlcyBob29rcyAqYXNzb2NpYXRlZCB3aXRoIGtub3duIGNvbmZpZ3MqLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JwaGFuZWQgaG9va3MgKGZvciBub24tZXhpc3RlbnQgY29uZmlncz8pIGFyZSByYXJlL2ludmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50UHJvdG8sIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5hZGQobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJbiBjb21wYWN0IG1vZGUsIHdlIG9ubHkgbG9vayBhdCB0aGUgdG9wLWxldmVsIHByb3RvdHlwZVxuICAgICAgICAgICAgaWYgKGRldGFpbCA9PT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFByb3RvID0gY3VycmVudFByb3RvLl9fcHJvdG9fX1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA6IHByb3RvLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIG50eXBlICAgICA6IHByb3RvLm50eXBlLFxuICAgICAgICAgICAgbnR5cGVDaGFpbjogY3Rvci5udHlwZUNoYWluLFxuICAgICAgICAgICAgc3VwZXJDbGFzczogcHJvdG8uX19wcm90b19fPy5jb25zdHJ1Y3Rvcj8uY29uZmlnPy5jbGFzc05hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgIG1peGlucyAgICA6IHByb3RvLm1peGlucyA/IGdldE1peGluTmFtZXMocHJvdG8ubWl4aW5zKSA6IFtdLFxuICAgICAgICAgICAgY29uZmlncyxcbiAgICAgICAgICAgIG1ldGhvZHMgICA6IEFycmF5LmZyb20obWV0aG9kcykuc29ydCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiBvbiBhIGNsYXNzIHByb3RvdHlwZSBhdCBydW50aW1lLlxuICAgICAqIFJFU1RSSUNURUQ6IFJlcXVpcmVzIE5lby5jb25maWcuZW5hYmxlSG90UGF0Y2hpbmcgPSB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY2xhc3NOYW1lICBUaGUgZnVsbHkgcXVhbGlmaWVkIGNsYXNzIG5hbWUgKGUuZy4sICdOZW8uYnV0dG9uLkJhc2UnKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHBhdGNoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5zb3VyY2UgICAgIFRoZSBuZXcgZnVuY3Rpb24gc291cmNlIGNvZGUgKGUuZy4sICdmdW5jdGlvbihhcmdzKSB7IC4uLiB9JyBvciAnYXN5bmMgKGFyZ3MpID0+IHsgLi4uIH0nKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtzdWNjZXNzOiBCb29sZWFuLCBlcnJvcj86IFN0cmluZ31cbiAgICAgKi9cbiAgICBwYXRjaENvZGUoe2NsYXNzTmFtZSwgbWV0aG9kTmFtZSwgc291cmNlfSkge1xuICAgICAgICBpZiAoTmVvLmNvbmZpZy5lbmFibGVIb3RQYXRjaGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvciAgOiAnSG90IHBhdGNoaW5nIGlzIGRpc2FibGVkLiBTZXQgTmVvLmNvbmZpZy5lbmFibGVIb3RQYXRjaGluZyA9IHRydWUgdG8gZW5hYmxlLidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNscyA9IE5lby5ucyhjbGFzc05hbWUpO1xuXG4gICAgICAgIGlmICghY2xzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yICA6IGBDbGFzcyAnJHtjbGFzc05hbWV9JyBub3QgZm91bmRgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNscy5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3IgIDogYENsYXNzICcke2NsYXNzTmFtZX0nIGhhcyBubyBwcm90b3R5cGUgKGlzIGl0IGEgc2luZ2xldG9uPylgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXNlIG5ldyBGdW5jdGlvbiB0byBwYXJzZSB0aGUgc291cmNlIGNvZGUgc2FmZWx5IGludG8gYSBmdW5jdGlvbiBvYmplY3QuXG4gICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBkaXJlY3QgdXNlIG9mIGV2YWwoKSBhbmQgZW5zdXJlcyB0aGUgY29kZSBydW5zIGluIHRoZSBnbG9iYWwgc2NvcGUuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICAgICAgIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIHNvdXJjZSkoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvciAgOiAnU291cmNlIGRpZCBub3QgZXZhbHVhdGUgdG8gYSBmdW5jdGlvbidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDEuIExvZyB0aGUgcGF0Y2ggZm9yIGF1ZGl0XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtOZW8uYWkuY2xpZW50LlJ1bnRpbWVTZXJ2aWNlXSBIb3QtcGF0Y2hpbmcgJHtjbGFzc05hbWV9LnByb3RvdHlwZS4ke21ldGhvZE5hbWV9YCk7XG5cbiAgICAgICAgICAgIC8vIDIuIEFwcGx5IHRoZSBwYXRjaFxuICAgICAgICAgICAgY2xzLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZuO1xuXG4gICAgICAgICAgICAvLyAzLiBNYXJrIG1ldGhvZCBhcyBwYXRjaGVkICh1c2VmdWwgZm9yIGRlYnVnZ2luZylcbiAgICAgICAgICAgIGZuLiRpc1BhdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uJG9yaWdpbmFsU291cmNlID0gc291cmNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IHRydWV9XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW05lby5haS5jbGllbnQuUnVudGltZVNlcnZpY2VdIEhvdCBwYXRjaCBmYWlsZWQ6JywgZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yICA6IGUubWVzc2FnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgcmVsb2FkUGFnZShwYXJhbXMpIHtcbiAgICAgICAgTmVvLk1haW4ucmVsb2FkV2luZG93KCk7XG4gICAgICAgIHJldHVybiB7c3RhdHVzOiAncmVsb2FkaW5nJ307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMuY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzZXROZW9Db25maWcoe2NvbmZpZ30pIHtcbiAgICAgICAgTmVvLnNldEdsb2JhbENvbmZpZyhjb25maWcpO1xuICAgICAgICByZXR1cm4ge3N0YXR1czogJ29rJ31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5oYXNoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMud2luZG93SWRdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzZXRSb3V0ZSh7aGFzaCwgd2luZG93SWR9KSB7XG4gICAgICAgIE5lby5NYWluLnNldFJvdXRlKHtcbiAgICAgICAgICAgIHZhbHVlOiBoYXNoLFxuICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtzdGF0dXM6ICdvaycsIGhhc2h9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXRcbiAgICAgKi9cbiAgICAjdHJhdmVyc2VOYW1lc3BhY2Uobm9kZSwgcGF0aCwgb3V0cHV0KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgPSBub2RlW2tleV0sXG4gICAgICAgICAgICAgICAgdHlwZSAgICAgICAgPSBOZW8udHlwZU9mKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9IHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5O1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ05lb0NsYXNzJykge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlICAgICA6ICdjbGFzcycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdmFsdWUucHJvdG90eXBlLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlICAgICA6ICdzaW5nbGV0b24nLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHZhbHVlLmNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHRyYXZlcnNlIHBsYWluIG9iamVjdHMgKG5hbWVzcGFjZXMpXG4gICAgICAgICAgICAgICAgLy8gTmVvLnR5cGVPZiByZXR1cm5zICdPYmplY3QnIGZvciBwbGFpbiBvYmplY3RzXG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLiN0cmF2ZXJzZU5hbWVzcGFjZSh2YWx1ZSwgY3VycmVudFBhdGgsIG91dHB1dFtrZXldKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGVtcHR5IHBhY2thZ2VzXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG91dHB1dFtrZXldKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG91dHB1dFtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUnVudGltZVNlcnZpY2UpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgTmV1cmFsIExpbmsgQ2xpZW50IFNlcnZpY2VzLlxuICogQGNsYXNzIE5lby5haS5jbGllbnQuU2VydmljZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTZXJ2aWNlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuY2xpZW50LlNlcnZpY2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5haS5jbGllbnQuU2VydmljZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uYWkuQ2xpZW50fG51bGx9IGNsaWVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsaWVudDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzYWZlU2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBOZW8udHlwZU9mKHZhbHVlKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvSlNPTigpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrXSA9IHRoaXMuc2FmZVNlcmlhbGl6ZSh2KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCh2ID0+IHRoaXMuc2FmZVNlcmlhbGl6ZSh2KSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU2VydmljZSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCB7Y3JlYXRlSW50ZXJjZXB0b3J9IGZyb20gJy4uLy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgICAgIGZyb20gJy4uLy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqL1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NvY2tldC1jb25uZWN0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NvY2tldC1jb25uZWN0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBiYWNrb2ZmU3RyYXRlZ3k9YXR0ZW1wdD0+TWF0aC5taW4oMTAwMCpNYXRoLnBvdygyLGF0dGVtcHQtMSksMzAwMDApXG4gICAgICAgICAqL1xuICAgICAgICBiYWNrb2ZmU3RyYXRlZ3k6IGF0dGVtcHQgPT4gTWF0aC5taW4oMTAwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSwgMzAwMDApLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7V2ViU29ja2V0fG51bGx9IHNvY2tldF89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ja2V0XzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjaGFubmVsPW51bGxcbiAgICAgKi9cbiAgICBjaGFubmVsID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4UmVjb25uZWN0QXR0ZW1wdHM9NVxuICAgICAqL1xuICAgIG1heFJlY29ubmVjdEF0dGVtcHRzID0gNVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gbWVzc2FnZUNhbGxiYWNrcz17fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtZXNzYWdlQ2FsbGJhY2tzID0ge31cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1lc3NhZ2VJZD0xXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1lc3NhZ2VJZCA9IDFcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJlY29ubmVjdEF0dGVtcHRzPTBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVjb25uZWN0QXR0ZW1wdHMgPSAwXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNlcnZlckFkZHJlc3M9bnVsbFxuICAgICAqL1xuICAgIHNlcnZlckFkZHJlc3MgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTb2NrZXQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gICAgICovXG4gICAgYXN5bmMgYXR0ZW1wdFJlY29ubmVjdChjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZWNvbm5lY3RBdHRlbXB0cysrO1xuXG4gICAgICAgIGlmIChtZS5yZWNvbm5lY3RBdHRlbXB0cyA8IG1lLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IG1lLmJhY2tvZmZTdHJhdGVneShtZS5yZWNvbm5lY3RBdHRlbXB0cyk7XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3JlY29ubmVjdGluZycsIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0ICAgIDogbWUucmVjb25uZWN0QXR0ZW1wdHMsXG4gICAgICAgICAgICAgICAgbWF4QXR0ZW1wdHM6IG1lLm1heFJlY29ubmVjdEF0dGVtcHRzLFxuICAgICAgICAgICAgICAgIGRlbGF5XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coYFdlYlNvY2tldCByZWNvbm5lY3QgYXR0ZW1wdCAke21lLnJlY29ubmVjdEF0dGVtcHRzfS8ke21lLm1heFJlY29ubmVjdEF0dGVtcHRzfSBpbiAke2RlbGF5fW1zYCk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoZGVsYXkpO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgbWUuY3JlYXRlU29ja2V0KCk7XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBtZS5vbignb3BlbicsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlIDogc2NvcGUgfHwgbWUsXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIHJlYWNoZWQnKTtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3JlY29ubmVjdF9mYWlsZWQnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJjZXB0cyB0aGUgV2ViU29ja2V0IHNlbmQgY2FsbHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgYmVmb3JlU2VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NoYW5uZWx9ID0gbWU7XG5cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNoYW5uZWwgPyB7Y2hhbm5lbCwgZGF0YX0gOiBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNvY2tldCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7V2ViU29ja2V0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtXZWJTb2NrZXR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7V2ViU29ja2V0fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNvY2tldCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgb25jbG9zZSAgOiBtZS5vbkNsb3NlICAuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25lcnJvciAgOiBtZS5vbkVycm9yICAuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25tZXNzYWdlOiBtZS5vbk1lc3NhZ2UuYmluZChtZSksXG4gICAgICAgICAgICAgICAgb25vcGVuICAgOiBtZS5vbk9wZW4gICAuYmluZChtZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjcmVhdGVJbnRlcmNlcHRvcih2YWx1ZSwgJ3NlbmQnLCBtZS5iZWZvcmVTZW5kLCBtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gZGVmYXVsdHMgdG8gMTAwMFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVhc29uXVxuICAgICAqL1xuICAgIGNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVTb2NrZXQoKSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLnNlcnZlckFkZHJlc3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDbG9zZUV2ZW50fSBldmVudCBUaGUgV2Vic29ja2V0IGdlbmVyYXRlZCBDbG9zZUV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICBldmVudC5jb2RlIFRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZSBjb2RlIHByb3ZpZGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICAgKlxuICAgICAqICAgICAgICBDb2RlICAgICAgICBOYW1lICAgICAgICAgICAgICAgICAgRGVzY3JpcHRpb25cbiAgICAgKiAgICAgICAgMC05OTkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2VydmVkIGFuZCBub3QgdXNlZC5cbiAgICAgKiAgICAgICAgMTAwMCAgICAgICAgQ0xPU0VfTk9STUFMICAgICAgICAgIE5vcm1hbCBjbG9zdXJlOyB0aGUgY29ubmVjdGlvbiBzdWNjZXNzZnVsbHkgY29tcGxldGVkIHdoYXRldmVyIHB1cnBvc2UgZm9yIHdoaWNoIGl0IHdhcyBjcmVhdGVkLlxuICAgICAqICAgICAgICAxMDAxICAgICAgICBDTE9TRV9HT0lOR19BV0FZICAgICAgVGhlIGVuZHBvaW50IGlzIGdvaW5nIGF3YXksIGVpdGhlciBiZWNhdXNlIG9mIGEgc2VydmVyIGZhaWx1cmUgb3IgYmVjYXVzZSB0aGUgYnJvd3NlciBpcyBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZSB0aGF0IG9wZW5lZCB0aGUgY29ubmVjdGlvbi5cbiAgICAgKiAgICAgICAgMTAwMiAgICAgICAgQ0xPU0VfUFJPVE9DT0xfRVJST1IgIFRoZSBlbmRwb2ludCBpcyB0ZXJtaW5hdGluZyB0aGUgY29ubmVjdGlvbiBkdWUgdG8gYSBwcm90b2NvbCBlcnJvci5cbiAgICAgKiAgICAgICAgMTAwMyAgICAgICAgQ0xPU0VfVU5TVVBQT1JURUQgICAgIFRoZSBjb25uZWN0aW9uIGlzIGJlaW5nIHRlcm1pbmF0ZWQgYmVjYXVzZSB0aGUgZW5kcG9pbnQgcmVjZWl2ZWQgZGF0YSBvZiBhIHR5cGUgaXQgY2Fubm90IGFjY2VwdCAoZm9yIGV4YW1wbGUsIGEgdGV4dC1vbmx5IGVuZHBvaW50IHJlY2VpdmVkIGJpbmFyeSBkYXRhKS5cbiAgICAgKiAgICAgICAgMTAwNCAgICAgICAgQ0xPU0VfVE9PX0xBUkdFICAgICAgIFRoZSBlbmRwb2ludCBpcyB0ZXJtaW5hdGluZyB0aGUgY29ubmVjdGlvbiBiZWNhdXNlIGEgZGF0YSBmcmFtZSB3YXMgcmVjZWl2ZWQgdGhhdCBpcyB0b28gbGFyZ2UuXG4gICAgICogICAgICAgIDEwMDUgICAgICAgIENMT1NFX05PX1NUQVRVUyAgICAgICBSZXNlcnZlZC4gIEluZGljYXRlcyB0aGF0IG5vIHN0YXR1cyBjb2RlIHdhcyBwcm92aWRlZCBldmVuIHRob3VnaCBvbmUgd2FzIGV4cGVjdGVkLlxuICAgICAqICAgICAgICAxMDA2ICAgICAgICBDTE9TRV9BQk5PUk1BTCAgICAgICAgUmVzZXJ2ZWQuIFVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBhYm5vcm1hbGx5ICh0aGF0IGlzLCB3aXRoIG5vIGNsb3NlIGZyYW1lIGJlaW5nIHNlbnQpIHdoZW4gYSBzdGF0dXMgY29kZSBpcyBleHBlY3RlZC5cbiAgICAgKiAgICAgICAgMTAwNy0xOTk5ICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGJ5IHRoZSBXZWJTb2NrZXQgc3RhbmRhcmQuXG4gICAgICogICAgICAgIDIwMDAtMjk5OSAgICAgICAgICAgICAgICAgICAgICAgICBSZXNlcnZlZCBmb3IgdXNlIGJ5IFdlYlNvY2tldCBleHRlbnNpb25zLlxuICAgICAqICAgICAgICAzMDAwLTM5OTkgICAgICAgICAgICAgICAgICAgICAgICAgQXZhaWxhYmxlIGZvciB1c2UgYnkgbGlicmFyaWVzIGFuZCBmcmFtZXdvcmtzLiBNYXkgbm90IGJlIHVzZWQgYnkgYXBwbGljYXRpb25zLlxuICAgICAqICAgICAgICA0MDAwLTQ5OTkgICAgICAgICAgICAgICAgICAgICAgICAgQXZhaWxhYmxlIGZvciB1c2UgYnkgYXBwbGljYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICByZWFzb24gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgcmVhc29uIHRoZSBzZXJ2ZXIgY2xvc2VkIHRoZSBjb25uZWN0aW9uLiBUaGlzIGlzIHNwZWNpZmljIHRvIHRoZSBwYXJ0aWN1bGFyIHNlcnZlciBhbmQgc3ViLXByb3RvY29sLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgd2FzQ2xlYW4gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZC5cbiAgICAgKi9cbiAgICBvbkNsb3NlKGV2ZW50LCByZWFzb24sIHdhc0NsZWFuKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnY2xvc2UnLCB7ZXZlbnQsIHJlYXNvbiwgd2FzQ2xlYW59KTtcblxuICAgICAgICAvLyBBdXRvLXJlY29ubmVjdCBvbiBhYm5vcm1hbCBjbG9zdXJlXG4gICAgICAgIGlmICghd2FzQ2xlYW4gfHwgZXZlbnQuY29kZSAhPT0gMTAwMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXZWJTb2NrZXQgY2xvc2VkIGFibm9ybWFsbHksIGF0dGVtcHRpbmcgcmVjb25uZWN0Li4uJyk7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3J9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uTWVzc2FnZShldmVudCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcblxuICAgICAgICBtZS5maXJlKCdtZXNzYWdlJywge2RhdGF9KTtcblxuICAgICAgICBpZiAoZGF0YS5tSWQpIHtcbiAgICAgICAgICAgIG1lLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tSWRdLnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5tZXNzYWdlQ2FsbGJhY2tzW2RhdGEubUlkXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICB0aGlzLmZpcmUoJ29wZW4nLCB7c2NvcGU6IHRoaXN9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9taXNlTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1lLm1lc3NhZ2VDYWxsYmFja3NbbWUubWVzc2FnZUlkXSA9IHtyZWplY3QsIHJlc29sdmV9O1xuXG4gICAgICAgICAgICBtZS5zZW5kTWVzc2FnZSh7ZGF0YSwgbUlkOiBtZS5tZXNzYWdlSWR9KTtcbiAgICAgICAgICAgIG1lLm1lc3NhZ2VJZCsrXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c29ja2V0fSA9IG1lLFxuICAgICAgICAgICAgZCAgICAgICAgPSBkYXRhO1xuXG4gICAgICAgIC8vIENPTk5FQ1RJTkcgIDAgICBUaGUgY29ubmVjdGlvbiBpcyBub3QgeWV0IG9wZW4uXG4gICAgICAgIC8vIE9QRU4gICAgICAgIDEgICBUaGUgY29ubmVjdGlvbiBpcyBvcGVuIGFuZCByZWFkeSB0byBjb21tdW5pY2F0ZS5cbiAgICAgICAgLy8gQ0xPU0lORyAgICAgMiAgIFRoZSBjb25uZWN0aW9uIGlzIGluIHRoZSBwcm9jZXNzIG9mIGNsb3NpbmcuXG4gICAgICAgIC8vIENMT1NFRCAgICAgIDMgICBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQgb3IgY291bGRuJ3QgYmUgb3BlbmVkLlxuXG4gICAgICAgIC8vIElmIHNvY2tldCBpcyBub3QgeWV0IHJlYWR5IGxldCdzIGRlZmVyIHRvIG9wZW4gdGhlbiByZXNlbmRcbiAgICAgICAgc3dpdGNoIChzb2NrZXQucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuQ0xPU0VEOlxuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuQ0xPU0lORzpcbiAgICAgICAgICAgICAgICBtZS5hdHRlbXB0UmVjb25uZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZShkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0LkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICAgICAgbWUub24oJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2VuZE1lc3NhZ2UoZClcbiAgICAgICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2ViU29ja2V0Lk9QRU46XG4gICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNvY2tldCk7XG4iLCJpbXBvcnQgTWFuYWdlciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuU3RvcmVcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgU3RvcmUgZXh0ZW5kcyBNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLlN0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5TdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFsaWFzIE5lby5nZXRTdG9yZSB0byB0aGlzIG1hbmFnZXI/XG4gICAgICAgIC8vIE5lby5nZXRTdG9yZSA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdG9yZSk7XG4iLCJpbXBvcnQgTWFuYWdlciAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuLi91dGlsL1JlY3RhbmdsZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFRoZSBcIkdvZCBWaWV3XCIgZm9yIHRoZSBtdWx0aS13aW5kb3cgYXBwbGljYXRpb24gd29ya3NwYWNlLlxuICogQGRlc2NyaXB0aW9uIFRoaXMgbWFuYWdlciBtYWludGFpbnMgYSByZWFsLXRpbWUgZ2VvbWV0cmljIG1hcCBvZiBhbGwgY29ubmVjdGVkIGJyb3dzZXIgd2luZG93cyBpbiB0aGUgQXBwIFdvcmtlci5cbiAqIEl0IGlzIHRoZSBjZW50cmFsIGF1dGhvcml0eSBmb3Igc3BhdGlhbCBhd2FyZW5lc3MsIGVuYWJsaW5nIGZlYXR1cmVzIGxpa2UgdGhlIFwiSW5maW5pdGUgQ2FudmFzXCIgd2hlcmVcbiAqIGludGVyYWN0aW9ucyAobGlrZSBEcmFnICYgRHJvcCkgY2FuIHNwYW4gYWNyb3NzIG11bHRpcGxlIE9TLWxldmVsIHdpbmRvd3MuXG4gKlxuICogSXQgcmVjZWl2ZXMgaGlnaC1mcmVxdWVuY3kgcG9zaXRpb24gdXBkYXRlcyBmcm9tIHRoZSBNYWluIFRocmVhZCAodmlhIGBOZW8ubWFpbi5hZGRvbi5XaW5kb3dQb3NpdGlvbmApXG4gKiBhbmQgcHJvdmlkZXMgaW50ZXJzZWN0aW9uIHRlc3RpbmcgQVBJcyB0byBkZXRlcm1pbmUgd2hpY2ggd2luZG93IGlzIHVuZGVyIGEgZ2l2ZW4gc2NyZWVuIGNvb3JkaW5hdGUuXG4gKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLldpbmRvd1xuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICogQHNlZSBOZW8ubWFpbi5hZGRvbi5XaW5kb3dQb3NpdGlvblxuICovXG5jbGFzcyBXaW5kb3cgZXh0ZW5kcyBNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLldpbmRvdydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuV2luZG93JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzU2FmYXJpXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzU2FmYXJpOiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5vbih7XG4gICAgICAgICAgICBjb25uZWN0ICAgOiBtZS5vbldpbmRvd0Nvbm5lY3QsXG4gICAgICAgICAgICBkaXNjb25uZWN0OiBtZS5vbldpbmRvd0Rpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpbmRvd0lkIHdoaWNoIGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gZ2xvYmFsIHNjcmVlbiBjb29yZGluYXRlcy5cbiAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIGludGVyc2VjdGlvbiB0ZXN0IGZvciBjcm9zcy13aW5kb3cgZHJhZyBhbmQgZHJvcCBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFNjcmVlbiBYIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBTY3JlZW4gWSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBUaGUgd2luZG93SWQgb2YgdGhlIHRhcmdldCB3aW5kb3csIG9yIG51bGwgaWYgbm8gaW50ZXJzZWN0aW9uLlxuICAgICAqL1xuICAgIGdldFdpbmRvd0F0KHgsIHkpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm91dGVyUmVjdD8uaW50ZXJzZWN0cyh7Ym90dG9tOiB5LCByaWdodDogeCwgeCwgeX0pKTtcblxuICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaWQgOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7Y2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH1cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVHZW9tZXRyeShkYXRhKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB7aW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIG1veklubmVyU2NyZWVuWCwgbW96SW5uZXJTY3JlZW5ZLCBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aCwgc2NyZWVuTGVmdCwgc2NyZWVuVG9wfSA9IGRhdGEsXG4gICAgICAgICAgICB3aWR0aERpZmYgICAgPSBvdXRlcldpZHRoICAtIGlubmVyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHREaWZmICAgPSBvdXRlckhlaWdodCAtIGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgLy8gQXNzdW1wdGlvbjogU2lkZSBib3JkZXJzIGFyZSBzeW1tZXRyaWNcbiAgICAgICAgICAgIHNpZGVCb3JkZXIgICA9IHdpZHRoRGlmZiAvIDIsXG4gICAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBCb3R0b20gYm9yZGVyIG1hdGNoZXMgc2lkZSBib3JkZXIgKGNvbW1vbiBpbiBXaW5kb3dzKVxuICAgICAgICAgICAgYm90dG9tQm9yZGVyID0gc2lkZUJvcmRlcixcbiAgICAgICAgICAgIC8vIFRoZSByZXN0IGlzIHRoZSB0b3AgY2hyb21lIChoZWFkZXIpXG4gICAgICAgICAgICB0b3BDaHJvbWUgICAgPSBoZWlnaHREaWZmIC0gYm90dG9tQm9yZGVyO1xuXG4gICAgICAgIGNvbnN0IGNocm9tZSA9IHtcbiAgICAgICAgICAgIGJvdHRvbTogYm90dG9tQm9yZGVyLFxuICAgICAgICAgICAgbGVmdCAgOiBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgcmlnaHQgOiBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgdG9wICAgOiB0b3BDaHJvbWVcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgdmlld3BvcnRMZWZ0LCB2aWV3cG9ydFRvcDtcblxuICAgICAgICBpZiAodHlwZW9mIG1veklubmVyU2NyZWVuWCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3g6IGV4cGxpY2l0IHZpZXdwb3J0IGNvb3JkaW5hdGVzXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSBtb3pJbm5lclNjcmVlblg7XG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgPSBtb3pJbm5lclNjcmVlbllcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2FmYXJpKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmk6IHNjcmVlbkxlZnQvVG9wIGlzIEZyYW1lIHBvc2l0aW9uLiBBZGQgY2hyb21lIHRvIGdldCBWaWV3cG9ydC5cbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IHNjcmVlbkxlZnQgKyBzaWRlQm9yZGVyO1xuICAgICAgICAgICAgdmlld3BvcnRUb3AgID0gc2NyZWVuVG9wICArIHRvcENocm9tZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IHNjcmVlbkxlZnQvVG9wIGlzIFZpZXdwb3J0IHBvc2l0aW9uLlxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gc2NyZWVuTGVmdDtcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICA9IHNjcmVlblRvcFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5uZXJSZWN0ID0gbmV3IFJlY3RhbmdsZSh2aWV3cG9ydExlZnQsIHZpZXdwb3J0VG9wLCBpbm5lcldpZHRoLCBpbm5lckhlaWdodCk7XG5cbiAgICAgICAgY29uc3Qgb3V0ZXJSZWN0ID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCAtIHNpZGVCb3JkZXIsXG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgLSB0b3BDaHJvbWUsXG4gICAgICAgICAgICBvdXRlcldpZHRoLFxuICAgICAgICAgICAgb3V0ZXJIZWlnaHRcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBuZXcgYnJvd3NlciB3aW5kb3cgY29ubmVjdHMgdG8gdGhlIFNoYXJlZFdvcmtlci5cbiAgICAgKiBJbiBTaGFyZWQgV29ya2VyIG1vZGUsIGBOZW8ud29ya2VyLkFwcCNvbkNvbm5lY3RgIGVuc3VyZXMgdGhhdCBgd2luZG93RGF0YWBcbiAgICAgKiBpcyBmZXRjaGVkIGZyb20gdGhlIE1haW4gVGhyZWFkIGFuZCBpbmNsdWRlZCBpbiB0aGUgcGF5bG9hZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGEud2luZG93RGF0YV0gQ29udGFpbnMgZ2VvbWV0cnkgZGF0YSAoc2NyZWVuTGVmdCwgaW5uZXJIZWlnaHQsIGV0Yy4pXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd0Nvbm5lY3Qoe2FwcE5hbWUsIHdpbmRvd0RhdGEsIHdpbmRvd0lkfSkge1xuICAgICAgICBsZXQgY2hyb21lICAgID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVyUmVjdCA9IG51bGwsXG4gICAgICAgICAgICBvdXRlclJlY3QgPSBudWxsO1xuXG4gICAgICAgIGlmICh3aW5kb3dEYXRhKSB7XG4gICAgICAgICAgICAoe2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9ID0gdGhpcy5jYWxjdWxhdGVHZW9tZXRyeSh3aW5kb3dEYXRhKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdXaW5kb3cub25XaW5kb3dDb25uZWN0Jywge3dpbmRvd0lkLCBhcHBOYW1lLCBjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3Rlcih7YXBwTmFtZSwgY2hyb21lLCBpZDogd2luZG93SWQsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIG9uV2luZG93RGlzY29ubmVjdCh7d2luZG93SWR9KSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3Rlcih3aW5kb3dJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnZW9tZXRyaWMgc3RhdGUgb2YgYSB3aW5kb3cgYmFzZWQgb24gZGF0YSBmcm9tIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdmlhIGRpcmVjdCBkZWxlZ2F0aW9uIGZyb20gdGhlIEFwcCBXb3JrZXIgdG8gbWluaW1pemUgb3ZlcmhlYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5pbm5lckhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm91dGVySGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEub3V0ZXJXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNjcmVlbkxlZnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JlZW5Ub3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIG9uV2luZG93UG9zaXRpb25DaGFuZ2UoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gbWUuZ2V0KGRhdGEud2luZG93SWQpLFxuICAgICAgICAgICAge2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9ID0gbWUuY2FsY3VsYXRlR2VvbWV0cnkoZGF0YSk7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uY2hyb21lICAgID0gY2hyb21lO1xuICAgICAgICAgICAgaXRlbS5pbm5lclJlY3QgPSBpbm5lclJlY3Q7XG4gICAgICAgICAgICBpdGVtLm91dGVyUmVjdCA9IG91dGVyUmVjdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgIGNocm9tZSxcbiAgICAgICAgICAgICAgICBpZDogZGF0YS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICBpbm5lclJlY3QsXG4gICAgICAgICAgICAgICAgb3V0ZXJSZWN0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuY2xhc3NOYW1lLFxuICAgICAgICAgICAgd2luZG93cyAgOiB0aGlzLml0ZW1zLm1hcCh3aW4gPT4gKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IHdpbi5pZCxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICA6IHdpbi5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGNocm9tZSAgIDogd2luLmNocm9tZSxcbiAgICAgICAgICAgICAgICBpbm5lclJlY3Q6IHdpbi5pbm5lclJlY3QsXG4gICAgICAgICAgICAgICAgb3V0ZXJSZWN0OiB3aW4ub3V0ZXJSZWN0XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoV2luZG93KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBBIHNpbmdsZXRvbiB1dGlsaXR5IGNsYXNzIHJlc3BvbnNpYmxlIGZvciByZWN1cnNpdmVseSBidWlsZGluZyBWRE9NIGFuZCBWTm9kZSB0cmVlcy5cbiAqIEl0IGNhbiBleHBhbmQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aGluIGEgdHJlZSBzdHJ1Y3R1cmUgaW50byB0aGVpciBmdWxsIFZET00vVk5vZGUgcmVwcmVzZW50YXRpb25zLFxuICogc3VwcG9ydGluZyBzZWxlY3RpdmUgKGFzeW1tZXRyaWMpIHRyZWUgZXhwYW5zaW9uIGZvciBvcHRpbWl6ZWQgdXBkYXRlcy5cbiAqIEBjbGFzcyBOZW8udXRpbC52ZG9tLlRyZWVCdWlsZGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFRyZWVCdWlsZGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC52ZG9tLlRyZWVCdWlsZGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC52ZG9tLlRyZWVCdWlsZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaGVscGVyIHRvIHJlY3Vyc2l2ZWx5IGJ1aWxkIGEgdHJlZSwgYWJzdHJhY3RpbmcgdGhlIGNoaWxkIG5vZGUga2V5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIFRoZSB2ZG9tIG9yIHZub2RlIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIFRoZSBjdXJyZW50IHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge1NldDxTdHJpbmc+fG51bGx9IG1lcmdlZENoaWxkSWRzIEEgc2V0IG9mIGNvbXBvbmVudCBJRHMgdG8gc2VsZWN0aXZlbHkgZXhwYW5kLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGlsZEtleSBUaGUgcHJvcGVydHkgbmFtZSBmb3IgY2hpbGQgbm9kZXMgKCdjbicgb3IgJ2NoaWxkTm9kZXMnKS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2J1aWxkVHJlZShub2RlLCBkZXB0aCwgbWVyZ2VkQ2hpbGRJZHMsIGNoaWxkS2V5KSB7XG4gICAgICAgIC8vIFdlIGNhbiBub3QgdXNlIE5lby5pc09iamVjdCgpIGhlcmUsIHNpbmNlIGluc2lkZSB1bml0LXRlc3Qgc2NlbmFyaW9zLCB3ZSB3aWxsIGltcG9ydCB2ZG9tLkhlbHBlciBpbnRvIG1haW4gdGhyZWFkcy5cbiAgICAgICAgLy8gSW5zaWRlIHRoaXMgc2NlbmFyaW8sIE5lby5pc09iamVjdCgpIHJldHVybnMgZmFsc2UgZm9yIFZOb2RlIGluc3RhbmNlc1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0ID0gey4uLm5vZGV9OyAvLyBTaGFsbG93IGNvcHlcblxuICAgICAgICBpZiAobm9kZVtjaGlsZEtleV0pIHtcbiAgICAgICAgICAgIG91dHB1dFtjaGlsZEtleV0gPSBbXTtcblxuICAgICAgICAgICAgbm9kZVtjaGlsZEtleV0uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IENvbXBvbmVudE1hbmFnZXIuZ2V0KGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTcGFyc2UgVHJlZSBHZW5lcmF0aW9uICYgU2NvcGVkIFVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcHJ1bmUgdGhlIGJyYW5jaCAoc2VuZCBhIHBsYWNlaG9sZGVyKSBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gV2UgYXJlIGF0IHRoZSBkZXB0aCBib3VuZGFyeSAoZGVwdGggPT09IDEpIEFORCBpdCdzIG5vdCBhIG1lcmdlZCB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIFdlIGFyZSBpbiBhIE1lcmdlZCBVcGRhdGUgKG1lcmdlZENoaWxkSWRzIGV4aXN0cykgQU5EIHRoaXMgY29tcG9uZW50IGlzIG5vdCBpbiB0aGUgQWxsb3dMaXN0IChub3QgZGlydHkvYnJpZGdlKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9uOiBXZSBuZXZlciBwcnVuZSBpZiBkZXB0aCBpcyAtMSAoRnVsbCBUcmVlKSBvciBpZiB0aGUgY29tcG9uZW50IGlzIG5vdCBtb3VudGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoICE9PSAtMSAmJiBjb21wb25lbnQ/LnZub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0V4cGFuZGFibGUgPSBtZXJnZWRDaGlsZElkcz8uaGFzKGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkZXB0aCA9PT0gMSAmJiAhaXNFeHBhbmRhYmxlKSB8fCAobWVyZ2VkQ2hpbGRJZHMgJiYgIWlzRXhwYW5kYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbY2hpbGRLZXldLnB1c2goey4uLmN1cnJlbnRJdGVtLCBuZW9JZ25vcmU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLy8gU3RvcCBwcm9jZXNzaW5nIHRoaXMgYnJhbmNoXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgdGhlIGJyYW5jaCBpZiBpdCdzIHBhcnQgb2YgYSBtZXJnZWQgdXBkYXRlLCBvciBpZiB0aGUgZGVwdGggcmVxdWlyZXMgaXQsIE9SIGlmIHRoZSB2bm9kZSBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IDEgfHwgZGVwdGggPT09IC0xIHx8IG1lcmdlZENoaWxkSWRzPy5oYXMoY3VycmVudEl0ZW0uY29tcG9uZW50SWQpIHx8ICFjb21wb25lbnQ/LnZub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGNvcnJlY3QgdHJlZSB0eXBlIGJhc2VkIG9uIHRoZSBjaGlsZEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50VHJlZSA9IGNoaWxkS2V5ID09PSAnY24nID8gY29tcG9uZW50Py52ZG9tIDogY29tcG9uZW50Py52bm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEl0ZW0gPSBjb21wb25lbnRUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoID0gKGRlcHRoID09PSAtMSkgPyAtMSA6IE1hdGgubWF4KDAsIGRlcHRoIC0gMSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoID0gZGVwdGhcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRwdXRbY2hpbGRLZXldLnB1c2godGhpcy4jYnVpbGRUcmVlKGN1cnJlbnRJdGVtLCBjaGlsZERlcHRoLCBtZXJnZWRDaGlsZElkcywgY2hpbGRLZXkpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIGdpdmVuIHZkb20gdHJlZSBhbmQgcmVwbGFjZXMgY2hpbGQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aCB0aGVpciB2ZG9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZXB0aD0tMV1cbiAgICAgKiBAcGFyYW0ge1NldDxTdHJpbmc+fG51bGx9IFttZXJnZWRDaGlsZElkcz1udWxsXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmRvbVRyZWUodmRvbSwgZGVwdGg9LTEsIG1lcmdlZENoaWxkSWRzPW51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1aWxkVHJlZSh2ZG9tLCBkZXB0aCwgbWVyZ2VkQ2hpbGRJZHMsICdjbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgZ2l2ZW4gdm5vZGUgdHJlZSBhbmQgcmVwbGFjZXMgY2hpbGQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aCB0aGVpciB2bm9kZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoPS0xXVxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gW21lcmdlZENoaWxkSWRzPW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVRyZWUodm5vZGUsIGRlcHRoPS0xLCBtZXJnZWRDaGlsZElkcz1udWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNidWlsZFRyZWUodm5vZGUsIGRlcHRoLCBtZXJnZWRDaGlsZElkcywgJ2NoaWxkTm9kZXMnKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVHJlZUJ1aWxkZXIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==