export const __webpack_esm_id__ = "vendors-src_ai_Client_mjs";
export const __webpack_esm_ids__ = ["vendors-src_ai_Client_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/ai/Client.mjs"
/*!***************************!*\
  !*** ./src/ai/Client.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _client_ComponentService_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./client/ComponentService.mjs */ "./src/ai/client/ComponentService.mjs");
/* harmony import */ var _client_DataService_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/DataService.mjs */ "./src/ai/client/DataService.mjs");
/* harmony import */ var _client_InstanceService_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/InstanceService.mjs */ "./src/ai/client/InstanceService.mjs");
/* harmony import */ var _client_InteractionService_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/InteractionService.mjs */ "./src/ai/client/InteractionService.mjs");
/* harmony import */ var _client_RuntimeService_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./client/RuntimeService.mjs */ "./src/ai/client/RuntimeService.mjs");
/* harmony import */ var _data_connection_WebSocket_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../data/connection/WebSocket.mjs */ "./src/data/connection/WebSocket.mjs");
/* harmony import */ var _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../manager/Window.mjs */ "./src/manager/Window.mjs");










/**
 * The AI Client establishes a WebSocket connection to the Neural Link MCP Server.
 * It acts as a bridge, enabling external AI agents to inspect and manipulate the running Neo.mjs application
 * via a standardized JSON-RPC protocol.
 * @class Neo.ai.Client
 * @extends Neo.core.Base
 * @singleton
 */
class Client extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.Client'
         * @protected
         */
        className: 'Neo.ai.Client',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true,
        /**
         * Add custom configs for data.connection.Websocket, or pass a module or instance.
         * @member {Object|Neo.data.connection.WebSocket|null} socket=null
         */
        socketConfig: null,
        /**
         * The URL of the Neural Link MCP Server's WebSocket endpoint.
         * @member {String} url='ws://127.0.0.1:8081'
         */
        url: 'ws://127.0.0.1:8081'
    }

    /**
     * @member {Boolean} isConnected=false
     * @protected
     */
    isConnected = false
    /**
     * Buffer for console logs generated before connection is established
     * @member {Array} logs=[]
     * @protected
     */
    logs = []
    /**
     * Map JSON-RPC method prefixes to service instances
     * @member {Object} serviceMap
     * @protected
     */
    serviceMap = null
    /**
     * @member {Object} services=null
     * @protected
     */
    services = null
    /**
     * @member {Neo.data.connection.WebSocket|null} socket=null
     * @protected
     */
    socket = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.services = {
            component  : Neo.create(_client_ComponentService_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],   {client: me}),
            data       : Neo.create(_client_DataService_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],        {client: me}),
            instance   : Neo.create(_client_InstanceService_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],    {client: me}),
            interaction: Neo.create(_client_InteractionService_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], {client: me}),
            runtime    : Neo.create(_client_RuntimeService_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],     {client: me})
        };

        const {component, data, instance, interaction, runtime} = me.services;

        me.serviceMap = {
            get_component         : component,
            get_computed_styles   : component,
            get_dom_rect          : component,
            get_vdom              : component,
            get_vdom_vnode        : component,
            get_vnode             : component,
            highlight_component   : component,
            query_component       : component,
            query_vdom            : component,

            call_method            : instance,
            find_instances         : instance,
            get_instance_properties: instance,
            set_instance_properties: instance,

            get_record            : data,
            inspect_state_provider: data,
            inspect_store         : data,
            list_stores           : data,
            modify_state_provider : data,

            get_dom_event         : runtime,
            get_drag              : runtime,
            get_method_source     : runtime,
            get_route             : runtime,
            get_window            : runtime,
            inspect_class         : runtime,
            patch_code            : runtime,
            reload_page           : runtime,
            set_route             : runtime,
            simulate_event        : interaction
        };

        Neo.currentWorker.on({
            connect   : me.onAppWorkerWindowConnect,
            disconnect: me.onAppWorkerWindowDisconnect,
            scope     : me
        });

        me.connect()
    }

    /**
     * Establishes the WebSocket connection to the Neural Link MCP Server.
     * Uses Neo.data.connection.WebSocket for robust connection management.
     */
    connect() {
        let me = this;

        try {
            let url     = new URL(Neo.config.neuralLinkUrl || me.url),
                appName = 'Unknown App';

            if (Neo.config.appPath) {
                const match = Neo.config.appPath.match(/apps\/([^\/]+)\//);
                if (match) {
                    appName = match[1]
                }
            }

            url.searchParams.set('appWorkerId', Neo.worker.App.id);
            url.searchParams.set('appName', appName);

            me.socket = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(me.socketConfig, _data_connection_WebSocket_mjs__WEBPACK_IMPORTED_MODULE_7__["default"], {
                serverAddress: url.toString(),
                listeners    : {
                    close  : me.onSocketClose,
                    error  : me.onSocketError,
                    message: me.onSocketMessage,
                    open   : me.onSocketOpen,
                    scope  : me
                }
            })
        } catch (e) {
            console.error('Neo.ai.Client: Failed to create WebSocket connection', e)
        }
    }

    /**
     * Routes specific JSON-RPC methods to their corresponding implementation.
     * This method acts as the central dispatcher for all AI-driven commands.
     * @param {String} method The JSON-RPC method name
     * @param {Object} params The parameters associated with the method
     * @returns {Promise<*>} The result of the operation
     */
    async handleRequest(method, params) {
        let me      = this,
            service = null,
            prefix;

        // Find matching service based on prefix
        // e.g. "get_component_property" -> matches "get_component" prefix
        for (prefix in me.serviceMap) {
            if (method.startsWith(prefix)) {
                service = me.serviceMap[prefix];
                break
            }
        }

        const fnName = Neo.snakeToCamel(method);

        if (service) {
            const fn = service[fnName];

            if (Neo.isFunction(fn)) {
                return fn.call(service, params)
            } else if (Neo.isPromise(fn)) {
                return await fn.call(service, params)
            }
        }

        if (service && typeof service[fnName] === 'function') {
            return service[fnName](params)
        }

        throw new Error(`Unknown method: ${method}`);
    }

    /**
     * @param {Object} data
     */
    onAppWorkerWindowConnect(data) {
        if (this.isConnected) {
            const
                win = _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].get(data.windowId),
                {appName, windowId} = data;

            this.sendNotification('window_connected', {
                appName,
                chrome   : win?.chrome,
                innerRect: win?.innerRect,
                outerRect: win?.outerRect,
                windowId
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.windowId
     */
    onAppWorkerWindowDisconnect({windowId}) {
        if (this.isConnected) {
            this.sendNotification('window_disconnected', {windowId})
        }
    }

    /**
     * Handles incoming messages from the WebSocket.
     * Parses the JSON-RPC payload and delegates valid requests to `handleRequest`.
     * @param {Object} data
     */
    async onSocketMessage({data}) {
        if (data.method) {
            try {
                const result = await this.handleRequest(data.method, data.params);
                this.sendResponse(data.id, result)
            } catch (e) {
                console.error('Neo.ai.Client: Failed to handle message', e);
                this.sendError(data.id, e.message, e.stack)
            }
        }
    }

    /**
     * @param {Event} event
     */
    onSocketOpen(event) {
        console.log('Neo.ai.Client: Connected to MCP Server');
        this.isConnected = true;

        // Flush buffered logs
        if (this.logs.length > 0) {
            this.logs.forEach(log => {
                this.sendNotification('console_log', log)
            });
            this.logs.length = 0
        }

        const appWorker = Neo.worker.App;

        // 1. Register the worker
        this.socket.sendMessage({
            jsonrpc: '2.0',
            method : 'register',
            params : {
                appWorkerId   : appWorker.id,
                environment   : Neo.config.environment,
                isSharedWorker: appWorker.isSharedWorker,
                userAgent     : navigator.userAgent
            }
        });

        // 2. Rehydrate window topology
        _manager_Window_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].items.forEach(win => {
            this.sendNotification('window_connected', {
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect,
                windowId : win.id
            })
        })

        // 3. Rehydrate drag state (if active)
        const dragCoordinator = Neo.manager?.DragCoordinator;

        if (dragCoordinator?.activeTargetZone) {
            this.sendNotification('drag_active', {
                sortGroup : dragCoordinator.activeTargetZone.sortGroup,
                sourceZone: dragCoordinator.activeTargetZone.id
            })
        }
    }

    /**
     * @param {CloseEvent} event
     */
    onSocketClose(event) {
        console.log('Neo.ai.Client: Disconnected');
        this.isConnected = false
    }

    /**
     * @param {Event} event
     */
    onSocketError(event) {
        console.error('Neo.ai.Client: WebSocket Error', event)
    }

    /**
     * Sends a JSON-RPC error response
     * @param {Number|String} id
     * @param {String} message
     * @param {String} [stack]
     */
    sendError(id, message, stack) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                id,
                error: {
                    code   : -32603, // Internal error
                    message: message,
                    data   : {stack}
                }
            })
        }
    }

    /**
     * Sends a JSON-RPC notification (no id)
     * @param {String} method
     * @param {Object} params
     */
    sendNotification(method, params) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                method,
                params
            })
        }
    }

    /**
     * Sends a JSON-RPC response
     * @param {Number|String} id
     * @param {*} result
     */
    sendResponse(id, result) {
        if (this.isConnected) {
            this.socket.sendMessage({
                jsonrpc: '2.0',
                id,
                result
            })
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Client));


/***/ },

/***/ "./src/ai/client/ComponentService.mjs"
/*!********************************************!*\
  !*** ./src/ai/client/ComponentService.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");
/* harmony import */ var _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/vdom/TreeBuilder.mjs */ "./src/util/vdom/TreeBuilder.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * Handles component-related Neural Link requests.
 * @class Neo.ai.client.ComponentService
 * @extends Neo.ai.client.Service
 */
class ComponentService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.ComponentService'
         * @protected
         */
        className: 'Neo.ai.client.ComponentService'
    }

    /**
     * @param {Object}   params
     * @param {String}   params.componentId
     * @param {String[]} params.variables
     * @returns {Object}
     */
    async getComputedStyles({componentId, variables}) {
        const component = Neo.getComponent(componentId);

        if (!component) {
            throw new Error(`Component not found: ${componentId}`)
        }

        const styles = await Neo.main.DomAccess.getComputedStyle({
            id   : component.id,
            style: variables
        });

        return {styles}
    }

    /**
     * @param {Object}   params
     * @param {String[]} params.componentIds
     * @returns {Object}
     */
    async getDomRect({componentIds}) {
        if (!Array.isArray(componentIds) || componentIds.length === 0) {
            throw new Error('componentIds must be a non-empty array')
        }

        // Use the first component to resolve the windowId context
        const component = Neo.getComponent(componentIds[0]);

        if (!component) {
            throw new Error(`Component not found: ${componentIds[0]}`)
        }

        const rects = await component.getDomRect(componentIds);

        return {
            rects: Array.isArray(rects) ? rects : [rects]
        }
    }

    /**
     * @param {Object} params
     * @param {String} params.componentId
     * @param {Object} [params.options]
     * @returns {Object}
     */
    highlightComponent({componentId, options}) {
        let component = Neo.getComponent(componentId),
            originalStyle;

        if (!component) {
            throw new Error(`Component not found: ${componentId}`)
        }

        options = options || {};

        const
            color    = options.color    || 'red',
            duration = options.duration || 2000,
            mode     = options.style    || 'outline'; // 'outline' or 'box-shadow'

        originalStyle = component.style || {};

        let highlightStyle = {};

        if (mode === 'outline') {
            highlightStyle.outline       = `2px solid ${color}`;
            highlightStyle.outlineOffset = '-2px'
        } else {
            highlightStyle.boxShadow = `0 0 10px ${color}, inset 0 0 10px ${color}`
        }

        component.style = {...originalStyle, ...highlightStyle};

        this.timeout(duration).then(() => {
            component.style = originalStyle
        });

        return {success: true}
    }

    /**
     * @param {Object}  params
     * @param {Number}  [params.depth]
     * @param {Boolean} [params.lean=true]
     * @param {String}  [params.rootId]
     * @returns {Object}
     */
    getComponentTree({depth, lean=true, rootId}) {
        return {
            tree: this.serializeComponent({
                component: this.getComponentRoot(rootId),
                lean,
                maxDepth : depth || -1
            })
        }
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVdomTree({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {vdom: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVdomTree(component.vdom, depth)}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVnodeTree({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVnodeTree(component.vnode, depth)}
    }

    /**
     * @param {Object} params
     * @param {Number} [params.depth]
     * @param {String} [params.rootId]
     * @returns {Object}
     */
    getVdomVnode({depth, rootId}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');
        return {
            vdom : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVdomTree(component.vdom, depth),
            vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getVnodeTree(component.vnode, depth)
        }
    }

    /**
     * @param {Object}   params
     * @param {String}   [params.rootId]
     * @param {Object}   params.selector
     * @param {String[]} [params.returnProperties]
     * @returns {Object}
     */
    queryComponent({rootId, selector, returnProperties}) {
        let matches;

        if (rootId) {
            const component = Neo.getComponent(rootId);
            if (!component) throw new Error(`Root component not found: ${rootId}`);
            matches = component.down(selector, false)
        } else {
            matches = Neo.manager.Component.find(selector)
        }

        const components = matches.map(c => {
            if (Array.isArray(returnProperties) && returnProperties.length > 0) {
                const props = {};
                returnProperties.forEach(prop => {
                    props[prop] = this.safeSerialize(c[prop])
                });

                return {
                    className : c.className,
                    id        : c.id,
                    properties: props
                }
            }

            return c.toJSON()
        });

        return {components}
    }

    /**
     * @param {Object} params
     * @param {String} [params.rootId]
     * @param {Object} params.selector
     * @returns {Object}
     */
    queryVdom({rootId, selector}) {
        const component = this.getComponentRoot(rootId);
        if (!component) throw new Error('Root component not found');

        const result = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(component.vdom, selector);

        return {
            vdom    : result?.vdom || null,
            index   : result?.index,
            parentId: result?.parentNode?.id
        }
    }

    /**
     * @param {String} [rootId]
     * @returns {Neo.component.Base|null}
     */
    getComponentRoot(rootId) {
        if (rootId) {
            return Neo.getComponent(rootId)
        }

        const apps = Object.values(Neo.apps || {});

        if (apps.length > 0) {
            return apps[0].mainView
        }

        return null
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number}             [data.currentDepth=1]
     * @param {Boolean}            [data.lean=true]
     * @param {Number}             [data.maxDepth=-1]
     * @returns {Object}
     */
    serializeComponent({component, currentDepth=1, lean=true, maxDepth=-1}) {
        if (!component) return null;

        let result;

        if (lean) {
            result = {
                className: component.className,
                id       : component.id
            };
        } else {
            result = component.toJSON();
        }

        if (maxDepth === -1 || currentDepth < maxDepth) {
            const children = Neo.manager.Component.getChildComponents(component);

            if (children && children.length > 0) {
                result.items = children.map(child => this.serializeComponent({
                    component   : child,
                    currentDepth: currentDepth + 1,
                    lean,
                    maxDepth
                }))
            }
        }

        return result
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ComponentService));


/***/ },

/***/ "./src/ai/client/DataService.mjs"
/*!***************************************!*\
  !*** ./src/ai/client/DataService.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");
/* harmony import */ var _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Store.mjs */ "./src/manager/Store.mjs");



/**
 * Handles data-related Neural Link requests.
 * @class Neo.ai.client.DataService
 * @extends Neo.ai.client.Service
 */
class DataService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.DataService'
         * @protected
         */
        className: 'Neo.ai.client.DataService'
    }

    /**
     * @param {Object} params
     * @param {String} params.recordId
     * @param {String} [params.storeId]
     * @returns {Object}
     */
    getRecord({recordId, storeId}) {
        let record;

        if (storeId) {
            const store = Neo.get(storeId);
            if (!store) throw new Error(`Store not found: ${storeId}`);
            record = store.get(recordId)
        } else {
            const matches = [];
            _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].items.forEach(store => {
                const rec = store.get(recordId);
                if (rec) matches.push(rec)
            });

            if (matches.length > 1) {
                throw new Error(`Multiple records found with ID ${recordId}. Please specify storeId.`)
            } else if (matches.length === 1) {
                record = matches[0]
            }
        }

        if (!record) throw new Error(`Record not found: ${recordId}`);

        return record.toJSON()
    }

    /**
     * @param {Object} params
     * @param {String} params.providerId
     * @returns {Object}
     */
    inspectStateProvider({providerId}) {
        const provider = Neo.get(providerId);
        if (!provider) throw new Error(`StateProvider not found: ${providerId}`);

        return provider.toJSON()
    }

    /**
     * @param {Object} params
     * @param {Number} [params.limit=50]
     * @param {Number} [params.offset=0]
     * @param {String} params.storeId
     * @returns {Object}
     */
    inspectStore({limit=50, offset=0, storeId}) {
        const store = Neo.get(storeId);
        if (!store) throw new Error(`Store not found: ${storeId}`);

        return {
            ...store.toJSON(),
            items: store.getRange(offset, offset + limit).map(record => record.toJSON())
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    listStores(params) {
        return {
            stores: _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].items.map(s => ({
                id      : s.id,
                model   : s.model?.className || 'N/A',
                count   : s.count,
                isLoaded: s.isLoaded
            }))
        }
    }

    /**
     * @param {Object} params
     * @param {Object} params.data
     * @param {String} params.providerId
     * @returns {Object}
     */
    modifyStateProvider({data, providerId}) {
        const provider = Neo.get(providerId);
        if (!provider) throw new Error(`StateProvider not found: ${providerId}`);

        provider.setData(data);
        return {success: true}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DataService));


/***/ },

/***/ "./src/ai/client/InstanceService.mjs"
/*!*******************************************!*\
  !*** ./src/ai/client/InstanceService.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");


/**
 * Handles generic instance-related Neural Link requests.
 * @class Neo.ai.client.InstanceService
 * @extends Neo.ai.client.Service
 */
class InstanceService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.InstanceService'
         * @protected
         */
        className: 'Neo.ai.client.InstanceService'
    }

    /**
     * Retrieves properties from a specific instance by its ID.
     * @param {Object} params
     * @param {String} params.id
     * @param {String[]} params.properties
     * @returns {Object}
     */
    getInstanceProperties({id, properties}) {
        const
            instance = Neo.get(id),
            result   = {};

        if (!instance) {
            throw new Error(`Instance not found: ${id}`)
        }

        properties.forEach(property => {
            result[property] = this.safeSerialize(Neo.ns(property, false, instance))
        });

        return {properties: result}
    }

    /**
     * Finds instances matching a selector.
     * @param {Object} params
     * @param {Object} params.selector
     * @param {String[]} [params.returnProperties]
     * @returns {Object}
     */
    findInstances({selector, returnProperties}) {
        const instances = Neo.manager.Instance.find(selector).map(instance => {
            if (Array.isArray(returnProperties) && returnProperties.length > 0) {
                const props = {};
                returnProperties.forEach(prop => {
                    props[prop] = this.safeSerialize(Neo.ns(prop, false, instance))
                });

                return {
                    className : instance.className,
                    id        : instance.id,
                    properties: props
                }
            }

            return instance.toJSON()
        });

        return {instances}
    }

    /**
     * Sets properties on a specific instance by its ID.
     * @param {Object} params
     * @param {String} params.id
     * @param {Object} params.properties
     * @returns {Object}
     */
    setInstanceProperties({id, properties}) {
        const instance = Neo.get(id);

        if (!instance) {
            throw new Error(`Instance not found: ${id}`)
        }

        instance.set(properties);

        return {success: true}
    }

    /**
     * Calls a method on a specific instance.
     * @param {Object} params
     * @param {String} params.id
     * @param {String} params.method
     * @param {Array}  [params.args]
     * @returns {Object}
     */
    async callMethod({id, method, args=[]}) {
        const instance = Neo.get(id);

        if (!instance) {
            throw new Error(`Instance not found: ${id}`)
        }

        const
            pathArray  = method.split('.'),
            methodName = pathArray.pop(),
            scope      = pathArray.length < 1 ? instance : Neo.ns(pathArray.join('.'), false, instance);

        if (!scope || typeof scope[methodName] !== 'function') {
            throw new Error(`Method not found: ${method} on instance ${id}`)
        }

        const result = await scope[methodName].call(scope, ...args);

        return {result: this.safeSerialize(result)}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(InstanceService));


/***/ },

/***/ "./src/ai/client/InteractionService.mjs"
/*!**********************************************!*\
  !*** ./src/ai/client/InteractionService.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");


/**
 * Service for handling interaction simulation commands.
 *
 * @class Neo.ai.client.InteractionService
 * @extends Neo.ai.client.Service
 */
class InteractionService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.InteractionService'
         * @protected
         */
        className: 'Neo.ai.client.InteractionService'
    }

    /**
     * Simulates a native DOM event sequence on the client.
     *
     * @param {Object} params
     * @param {Object[]} params.events - Sequence of event config objects
     * @returns {Promise<Boolean>}
     */
    async simulateEvent({events}) {
        let me = this;

        if (!Array.isArray(events)) {
            throw new Error('InteractionService: events must be an array')
        }

        for (const event of events) {
            if (event.delay) {
                await me.timeout(event.delay)
            }

            await me.dispatch({
                id      : event.targetId,
                options : event.options,
                type    : event.type,
                windowId: event.windowId
            })
        }

        return true
    }

    /**
     * Helper to dispatch a single event to the correct window
     * @param {Object} data
     * @param {String} data.id
     * @param {Object} data.options
     * @param {String} data.type
     * @param {String} data.windowId
     * @returns {Promise<Boolean>}
     */
    async dispatch({id, options, type, windowId}) {
        await Neo.Main.importAddon({name: 'EventSimulator', windowId});

        return await Neo.main.addon.EventSimulator.dispatch({
            id,
            options,
            type,
            windowId
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(InteractionService));


/***/ },

/***/ "./src/ai/client/RuntimeService.mjs"
/*!******************************************!*\
  !*** ./src/ai/client/RuntimeService.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/HashHistory.mjs */ "./src/util/HashHistory.mjs");
/* harmony import */ var _Service_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Service.mjs */ "./src/ai/client/Service.mjs");




/**
 * Handles runtime environment related Neural Link requests.
 * @class Neo.ai.client.RuntimeService
 * @extends Neo.ai.client.Service
 */
class RuntimeService extends _Service_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.RuntimeService'
         * @protected
         */
        className: 'Neo.ai.client.RuntimeService'
    }

    /**
     * Checks if a namespace exists in the current environment.
     * @param {Object} params
     * @param {String} params.namespace
     * @returns {Object} {exists: Boolean}
     */
    checkNamespace({namespace}) {
        return {
            exists: !!Neo.ns(namespace)
        }
    }

    /**
     * @param {Object} params
     * @param {String} params.componentId
     * @returns {Object}
     */
    getDomEventListeners({componentId}) {
        const
            listeners = [],
            eventMap  = _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].items?.[componentId];

        if (eventMap) {
            Object.entries(eventMap).forEach(([eventName, events]) => {
                events.forEach(event => {
                    listeners.push({
                        delegate: event.delegate,
                        event   : eventName,
                        handler : typeof event.fn === 'function' ? event.fn.name || 'anonymous' : event.fn,
                        priority: event.priority,
                        scope   : event.scope?.id || 'unknown'
                    })
                })
            })
        }

        return {listeners}
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getDomEventSummary(params) {
        const summary = {
            byComponent: {},
            byEvent    : {},
            totalEvents: 0
        };

        Object.entries(_manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].items).forEach(([componentId, eventMap]) => {
            let componentCount = 0;

            Object.entries(eventMap).forEach(([eventName, events]) => {
                const count = events.length;

                summary.totalEvents       += count;
                componentCount            += count;
                summary.byEvent[eventName] = (summary.byEvent[eventName] || 0) + count
            });

            if (componentCount > 0) {
                summary.byComponent[componentId] = componentCount
            }
        });

        return summary
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getDragState(params) {
        const dragCoordinator = Neo.manager?.DragCoordinator;

        if (dragCoordinator) {
            return dragCoordinator.toJSON()
        }

        return {};
    }

    /**
     * Retrieves the source code of a method on a class prototype.
     * @param {Object} params
     * @param {String} params.className  The fully qualified class name.
     * @param {String} params.methodName The name of the method.
     * @returns {Object} {success: Boolean, source?: String, error?: String}
     */
    getMethodSource({className, methodName}) {
        const cls = Neo.ns(className);

        if (!cls) {
            return {success: false, error: `Class '${className}' not found`}
        }

        const type = Neo.typeOf(cls);
        let proto;

        if (type === 'NeoClass') {
            proto = cls.prototype
        } else if (type === 'NeoInstance') {
            proto = cls.constructor.prototype
        } else {
            return {success: false, error: `Target '${className}' is not a Neo class or instance`}
        }

        if (typeof proto[methodName] !== 'function') {
            return {success: false, error: `Method '${methodName}' not found on '${className}'`}
        }

        return {
            success: true,
            source : proto[methodName].toString()
        }
    }

    /**
     * Retrieves the loaded namespace tree.
     * @param {Object} params
     * @param {String} [params.root='Neo'] The root namespace to start from (e.g., 'Neo', 'MyApp').
     * @returns {Object}
     */
    getNamespaceTree({root='Neo'}) {
        const
            me        = this,
            startNode = Neo.ns(root),
            tree      = {};

        if (!startNode) {
            return {tree: {}, error: `Namespace '${root}' not found`}
        }

        me.#traverseNamespace(startNode, root, tree);

        return {root, tree}
    }

    /**
     * @param {Object} params
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    getNeoConfig({windowId}) {
        if (windowId) {
            return Neo.windowConfigs?.[windowId] || null
        }
        return Neo.config
    }

    /**
     * @param {Object} params
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    getRouteHistory({windowId}) {
        const stack = _util_HashHistory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getStack(windowId);

        return {
            count   : stack.length,
            history : stack,
            windowId: windowId || null
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    getWindowInfo(params) {
        const windowManager = Neo.manager?.Window;

        if (windowManager) {
            return windowManager.toJSON()
        }

        return {windows: []};
    }

    /**
     * Inspects a class to retrieve its full schema (configs, methods, hierarchy).
     * @param {Object} params
     * @param {String} params.className
     * @param {String} [params.detail='standard'] 'standard' | 'compact'
     * @returns {Object}
     */
    inspectClass({className, detail='standard'}) {
        const cls = Neo.ns(className);

        if (!cls) {
            throw new Error(`Class not found: ${className}`)
        }

        const
            isClass = cls.isClass,
            ctor    = isClass ? cls : cls.constructor,
            proto   = ctor.prototype;

        // 1. Hierarchy & Mixins
        const getMixinNames = (obj) => {
            const names = [];
            if (Neo.isObject(obj)) {
                Object.values(obj).forEach(value => {
                    if (value && value.isClass) {
                        names.push(value.prototype.className)
                    } else {
                        names.push(...getMixinNames(value))
                    }
                })
            }
            return names
        };

        // 2. Configs & Methods
        const
            configs        = {},
            methods        = new Set(),
            configKeys     = new Set(Object.keys(ctor.config)),
            descriptors    = ctor.configDescriptors || {},
            ignoredProps   = ['constructor', 'construct', 'init', 'onConstructed', 'onAfterConstructed'],
            hookRegex      = /^(before|after)(Get|Set)([A-Z])/,
            // Helper to get raw hook name from config key
            getHookName    = (prefix, key) => prefix + key[0].toUpperCase() + key.slice(1);

        // Serialize the default values first
        const defaultValues = this.serializeConfig(ctor.config);

        // Get superclass config for comparison in compact mode
        const
            superCtor   = ctor.__proto__,
            superConfig = superCtor?.config || {};

        // Process Configs
        Object.keys(defaultValues).forEach(key => {
            // In compact mode, only include configs that are "own" (not in super or changed)
            if (detail === 'compact') {
                const isOwn = !Object.hasOwn(superConfig, key) || superConfig[key] !== ctor.config[key];
                if (!isOwn) return
            }

            configs[key] = {
                value: defaultValues[key]
            };

            // Add Descriptor info if available
            if (descriptors[key]) {
                configs[key].meta = this.serializeConfig(descriptors[key])
            }

            // Check for Hooks
            const hooks = [];
            ['beforeGet', 'beforeSet', 'afterSet'].forEach(prefix => {
                const hookName = getHookName(prefix, key);
                // In compact mode, only check for hooks on the current prototype
                if (detail === 'compact') {
                    if (Object.hasOwn(proto, hookName)) {
                        hooks.push(prefix)
                    }
                } else {
                    if (typeof proto[hookName] === 'function') {
                        hooks.push(prefix)
                    }
                }
            });

            if (hooks.length > 0) {
                configs[key].hooks = hooks
            }
        });

        // Process Methods
        let currentProto = proto;

        // Traverse up to Neo.core.Base
        while (currentProto && currentProto.constructor.className !== 'Object') {
            Object.getOwnPropertyNames(currentProto).forEach(name => {
                if (
                    !configKeys.has(name) &&
                    !ignoredProps.includes(name) &&
                    !name.startsWith('_') &&
                    !name.startsWith('#')
                ) {
                    // Check if it's a hook
                    const hookMatch = name.match(hookRegex);
                    if (hookMatch) {
                        // It is a hook. We only care if it wasn't already caught by the config loop.
                        // But since we want a clean method list, we generally exclude hooks here.
                        // The config loop above captures hooks *associated with known configs*.
                        // Orphaned hooks (for non-existent configs?) are rare/invalid.
                    } else {
                        const descriptor = Object.getOwnPropertyDescriptor(currentProto, name);
                        if (typeof descriptor.value === 'function') {
                            methods.add(name)
                        }
                    }
                }
            });

            // In compact mode, we only look at the top-level prototype
            if (detail === 'compact') {
                break
            }

            currentProto = currentProto.__proto__
        }

        return {
            className : proto.className,
            ntype     : proto.ntype,
            ntypeChain: ctor.ntypeChain,
            superClass: proto.__proto__?.constructor?.config?.className || null,
            mixins    : proto.mixins ? getMixinNames(proto.mixins) : [],
            configs,
            methods   : Array.from(methods).sort()
        }
    }

    /**
     * Replaces a method implementation on a class prototype at runtime.
     * RESTRICTED: Requires Neo.config.enableHotPatching = true.
     *
     * @param {Object} params
     * @param {String} params.className  The fully qualified class name (e.g., 'Neo.button.Base')
     * @param {String} params.methodName The name of the method to patch
     * @param {String} params.source     The new function source code (e.g., 'function(args) { ... }' or 'async (args) => { ... }')
     * @returns {Object} {success: Boolean, error?: String}
     */
    patchCode({className, methodName, source}) {
        if (Neo.config.enableHotPatching !== true) {
            return {
                success: false,
                error  : 'Hot patching is disabled. Set Neo.config.enableHotPatching = true to enable.'
            }
        }

        const cls = Neo.ns(className);

        if (!cls) {
            return {
                success: false,
                error  : `Class '${className}' not found`
            }
        }

        if (!cls.prototype) {
            return {
                success: false,
                error  : `Class '${className}' has no prototype (is it a singleton?)`
            }
        }

        try {
            // Use new Function to parse the source code safely into a function object.
            // This avoids direct use of eval() and ensures the code runs in the global scope.
            // eslint-disable-next-line no-new-func
            const fn = new Function('return ' + source)();

            if (typeof fn !== 'function') {
                return {
                    success: false,
                    error  : 'Source did not evaluate to a function'
                }
            }

            // 1. Log the patch for audit
            console.warn(`[Neo.ai.client.RuntimeService] Hot-patching ${className}.prototype.${methodName}`);

            // 2. Apply the patch
            cls.prototype[methodName] = fn;

            // 3. Mark method as patched (useful for debugging)
            fn.$isPatched = true;
            fn.$originalSource = source;

            return {success: true}

        } catch (e) {
            console.error('[Neo.ai.client.RuntimeService] Hot patch failed:', e);
            return {
                success: false,
                error  : e.message
            }
        }
    }

    /**
     * @param {Object} params
     * @returns {Object}
     */
    reloadPage(params) {
        Neo.Main.reloadWindow();
        return {status: 'reloading'};
    }

    /**
     * @param {Object} params
     * @param {Object} params.config
     * @returns {Object}
     */
    setNeoConfig({config}) {
        Neo.setGlobalConfig(config);
        return {status: 'ok'}
    }

    /**
     * @param {Object} params
     * @param {String} params.hash
     * @param {String} [params.windowId]
     * @returns {Object}
     */
    setRoute({hash, windowId}) {
        Neo.Main.setRoute({
            value: hash,
            windowId
        });

        return {status: 'ok', hash}
    }

    /**
     * @param {Object} node
     * @param {String} path
     * @param {Object} output
     */
    #traverseNamespace(node, path, output) {
        Object.keys(node).forEach(key => {
            const
                value       = node[key],
                type        = Neo.typeOf(value),
                currentPath = path ? `${path}.${key}` : key;

            if (type === 'NeoClass') {
                output[key] = {
                    type     : 'class',
                    className: value.prototype.className
                }
            } else if (type === 'NeoInstance') {
                output[key] = {
                    type     : 'singleton',
                    className: value.className
                }
            } else if (type === 'Object') {
                // Only traverse plain objects (namespaces)
                // Neo.typeOf returns 'Object' for plain objects
                output[key] = {};
                this.#traverseNamespace(value, currentPath, output[key]);

                // Clean up empty packages
                if (Object.keys(output[key]).length === 0) {
                    delete output[key]
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(RuntimeService));


/***/ },

/***/ "./src/ai/client/Service.mjs"
/*!***********************************!*\
  !*** ./src/ai/client/Service.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Base class for Neural Link Client Services.
 * @class Neo.ai.client.Service
 * @extends Neo.core.Base
 */
class Service extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.ai.client.Service'
         * @protected
         */
        className: 'Neo.ai.client.Service',
        /**
         * @member {Neo.ai.Client|null} client=null
         * @protected
         */
        client: null
    }

    /**
     * @param {*} value
     * @returns {*}
     */
    safeSerialize(value) {
        const type = Neo.typeOf(value);

        if (type === 'NeoInstance') {
            return value.toJSON()
        }

        if (type === 'Object') {
            const result = {};
            Object.entries(value).forEach(([k, v]) => {
                result[k] = this.safeSerialize(v)
            });
            return result
        }

        if (type === 'Array') {
            return value.map(v => this.safeSerialize(v))
        }

        return value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Service));


/***/ },

/***/ "./src/data/connection/WebSocket.mjs"
/*!*******************************************!*\
  !*** ./src/data/connection/WebSocket.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/Observable.mjs */ "./src/core/Observable.mjs");




/**
 * @class Neo.data.connection.WebSocket
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Socket extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.connection.WebSocket'
         * @protected
         */
        className: 'Neo.data.connection.WebSocket',
        /**
         * @member {String} ntype='socket-connection'
         * @protected
         */
        ntype: 'socket-connection',
        /**
         * @member {Function} backoffStrategy=attempt=>Math.min(1000*Math.pow(2,attempt-1),30000)
         */
        backoffStrategy: attempt => Math.min(1000 * Math.pow(2, attempt - 1), 30000),
        /**
         * @member {WebSocket|null} socket_=null
         * @protected
         * @reactive
         */
        socket_: null
    }

    /**
     * @member {String|null} channel=null
     */
    channel = null
    /**
     * @member {Number} maxReconnectAttempts=5
     */
    maxReconnectAttempts = 5
    /**
     * @member {Object} messageCallbacks={}
     * @protected
     */
    messageCallbacks = {}
    /**
     * @member {Number} messageId=1
     * @protected
     */
    messageId = 1
    /**
     * @member {Number} reconnectAttempts=0
     * @protected
     */
    reconnectAttempts = 0
    /**
     * @member {String|null} serverAddress=null
     */
    serverAddress = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createSocket()
    }

    /**
     * @param {Function} callback
     * @param {Object} scope
     */
    async attemptReconnect(callback, scope) {
        let me = this;

        me.reconnectAttempts++;

        if (me.reconnectAttempts < me.maxReconnectAttempts) {
            const delay = me.backoffStrategy(me.reconnectAttempts);

            me.fire('reconnecting', {
                attempt    : me.reconnectAttempts,
                maxAttempts: me.maxReconnectAttempts,
                delay
            });

            console.log(`WebSocket reconnect attempt ${me.reconnectAttempts}/${me.maxReconnectAttempts} in ${delay}ms`);

            await me.timeout(delay);

            if (!me.isDestroyed) {
                me.createSocket();

                callback && me.on('open', {
                    callback,
                    scope : scope || me,
                    single: true
                })
            }
        } else {
            console.error('Max reconnection attempts reached');
            me.fire('reconnect_failed')
        }
    }

    /**
     * Intercepts the WebSocket send calls
     * @param {Object} data
     * @returns {String}
     */
    beforeSend(data) {
        let me        = this,
            {channel} = me;

        return JSON.stringify(channel ? {channel, data} : data)
    }

    /**
     * Triggered before the socket config gets changed.
     * @param {WebSocket|null} value
     * @param {WebSocket|null} oldValue
     * @returns {WebSocket|null}
     * @protected
     */
    beforeSetSocket(value, oldValue) {
        if (value) {
            let me = this;

            Object.assign(value, {
                onclose  : me.onClose  .bind(me),
                onerror  : me.onError  .bind(me),
                onmessage: me.onMessage.bind(me),
                onopen   : me.onOpen   .bind(me)
            });

            (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.createInterceptor)(value, 'send', me.beforeSend, me)
        }

        return value
    }

    /**
     * @param {Number} [code] defaults to 1000
     * @param {String} [reason]
     */
    close(code, reason) {
        this.socket.close(code, reason)
    }

    /**
     *
     */
    createSocket() {
        this.socket = new WebSocket(this.serverAddress)
    }

    /**
     *
     */
    destroy(...args) {
        this.close();
        super.destroy(...args)
    }

    /**
     * @param {CloseEvent} event The Websocket generated CloseEvent
     * @param {Number}     event.code The WebSocket connection close code provided by the server
     *
     *        Code        Name                  Description
     *        0-999                             Reserved and not used.
     *        1000        CLOSE_NORMAL          Normal closure; the connection successfully completed whatever purpose for which it was created.
     *        1001        CLOSE_GOING_AWAY      The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.
     *        1002        CLOSE_PROTOCOL_ERROR  The endpoint is terminating the connection due to a protocol error.
     *        1003        CLOSE_UNSUPPORTED     The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).
     *        1004        CLOSE_TOO_LARGE       The endpoint is terminating the connection because a data frame was received that is too large.
     *        1005        CLOSE_NO_STATUS       Reserved.  Indicates that no status code was provided even though one was expected.
     *        1006        CLOSE_ABNORMAL        Reserved. Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.
     *        1007-1999                         Reserved for future use by the WebSocket standard.
     *        2000-2999                         Reserved for use by WebSocket extensions.
     *        3000-3999                         Available for use by libraries and frameworks. May not be used by applications.
     *        4000-4999                         Available for use by applications.
     *
     * @param {String}     reason A string indicating the reason the server closed the connection. This is specific to the particular server and sub-protocol.
     * @param {Boolean}    wasClean Indicates whether or not the connection was cleanly closed.
     */
    onClose(event, reason, wasClean) {
        this.fire('close', {event, reason, wasClean});

        // Auto-reconnect on abnormal closure
        if (!wasClean || event.code !== 1000) {
            console.warn('WebSocket closed abnormally, attempting reconnect...');
            this.attemptReconnect()
        }
    }

    /**
     *
     */
    onError(error) {
        this.fire('error', {error})
    }

    /**
     * @param {MessageEvent} event
     */
    onMessage(event) {
        let me   = this,
            data = JSON.parse(event.data);

        me.fire('message', {data});

        if (data.mId) {
            me.messageCallbacks[data.mId].resolve(data.data);
            delete me.messageCallbacks[data.mId]
        }
    }

    /**
     *
     */
    onOpen() {
        this.reconnectAttempts = 0;
        this.fire('open', {scope: this})
    }

    /**
     * @param {Object} data
     * @returns {Promise<any>}
     */
    promiseMessage(data) {
        let me = this;

        return new Promise((resolve, reject) => {
            me.messageCallbacks[me.messageId] = {reject, resolve};

            me.sendMessage({data, mId: me.messageId});
            me.messageId++
        })
    }

    /**
     * @param {Object} data
     */
    sendMessage(data) {
        let me       = this,
            {socket} = me,
            d        = data;

        // CONNECTING  0   The connection is not yet open.
        // OPEN        1   The connection is open and ready to communicate.
        // CLOSING     2   The connection is in the process of closing.
        // CLOSED      3   The connection is closed or couldn't be opened.

        // If socket is not yet ready let's defer to open then resend
        switch (socket.readyState) {
            case WebSocket.CLOSED:
            case WebSocket.CLOSING:
                me.attemptReconnect(function() {
                    me.sendMessage(d);
                });
                break;
            case WebSocket.CONNECTING:
                me.on('open', function() {
                    me.sendMessage(d)
                }, me, {once: true});
                break;
            case WebSocket.OPEN:
                socket.send(data);
                break;
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Socket));


/***/ },

/***/ "./src/manager/Store.mjs"
/*!*******************************!*\
  !*** ./src/manager/Store.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.Store
 * @extends Neo.manager.Base
 * @singleton
 */
class Store extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Store'
         * @protected
         */
        className: 'Neo.manager.Store',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        
        // Alias Neo.getStore to this manager?
        // Neo.getStore = this.get.bind(this);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/manager/Window.mjs"
/*!********************************!*\
  !*** ./src/manager/Window.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");



/**
 * @summary The "God View" for the multi-window application workspace.
 * @description This manager maintains a real-time geometric map of all connected browser windows in the App Worker.
 * It is the central authority for spatial awareness, enabling features like the "Infinite Canvas" where
 * interactions (like Drag & Drop) can span across multiple OS-level windows.
 *
 * It receives high-frequency position updates from the Main Thread (via `Neo.main.addon.WindowPosition`)
 * and provides intersection testing APIs to determine which window is under a given screen coordinate.
 *
 * @class Neo.manager.Window
 * @extends Neo.manager.Base
 * @singleton
 * @see Neo.main.addon.WindowPosition
 */
class Window extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Window'
         * @protected
         */
        className: 'Neo.manager.Window',
        /**
         * @member {Boolean} isSafari
         * @protected
         */
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * Returns the windowId which intersects with the given global screen coordinates.
     * This is the core intersection test for cross-window drag and drop operations.
     * @param {Number} x Screen X coordinate
     * @param {Number} y Screen Y coordinate
     * @returns {String|null} The windowId of the target window, or null if no intersection.
     */
    getWindowAt(x, y) {
        let item = this.items.find(item => item.outerRect?.intersects({bottom: y, right: x, x, y}));

        return item ? item.id : null
    }

    /**
     * @param {Object} data
     * @returns {Object} {chrome, innerRect, outerRect}
     */
    calculateGeometry(data) {
        const
            {innerHeight, innerWidth, mozInnerScreenX, mozInnerScreenY, outerHeight, outerWidth, screenLeft, screenTop} = data,
            widthDiff    = outerWidth  - innerWidth,
            heightDiff   = outerHeight - innerHeight,
            // Assumption: Side borders are symmetric
            sideBorder   = widthDiff / 2,
            // Assumption: Bottom border matches side border (common in Windows)
            bottomBorder = sideBorder,
            // The rest is the top chrome (header)
            topChrome    = heightDiff - bottomBorder;

        const chrome = {
            bottom: bottomBorder,
            left  : sideBorder,
            right : sideBorder,
            top   : topChrome
        };

        let viewportLeft, viewportTop;

        if (typeof mozInnerScreenX === 'number') {
            // Firefox: explicit viewport coordinates
            viewportLeft = mozInnerScreenX;
            viewportTop  = mozInnerScreenY
        } else if (this.isSafari) {
            // Safari: screenLeft/Top is Frame position. Add chrome to get Viewport.
            viewportLeft = screenLeft + sideBorder;
            viewportTop  = screenTop  + topChrome
        } else {
            // Chrome/Edge: screenLeft/Top is Viewport position.
            viewportLeft = screenLeft;
            viewportTop  = screenTop
        }

        const innerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](viewportLeft, viewportTop, innerWidth, innerHeight);

        const outerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            viewportLeft - sideBorder,
            viewportTop  - topChrome,
            outerWidth,
            outerHeight
        );

        return {chrome, innerRect, outerRect}
    }

    /**
     * Triggered when a new browser window connects to the SharedWorker.
     * In Shared Worker mode, `Neo.worker.App#onConnect` ensures that `windowData`
     * is fetched from the Main Thread and included in the payload.
     * @param {Object} data
     * @param {Number} data.appName
     * @param {Object} [data.windowData] Contains geometry data (screenLeft, innerHeight, etc.)
     * @param {String} data.windowId
     */
    onWindowConnect({appName, windowData, windowId}) {
        let chrome    = null,
            innerRect = null,
            outerRect = null;

        if (windowData) {
            ({chrome, innerRect, outerRect} = this.calculateGeometry(windowData))
        }

        console.log('Window.onWindowConnect', {windowId, appName, chrome, innerRect, outerRect});

        this.register({appName, chrome, id: windowId, innerRect, outerRect})
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowDisconnect({windowId}) {
        this.unregister(windowId)
    }

    /**
     * Updates the geometric state of a window based on data from the Main Thread.
     * This method is called via direct delegation from the App Worker to minimize overhead.
     * @param {Object} data
     * @param {Number} data.innerHeight
     * @param {Number} data.outerHeight
     * @param {Number} data.outerWidth
     * @param {Number} data.screenLeft
     * @param {Number} data.screenTop
     * @param {String} data.windowId
     */
    onWindowPositionChange(data) {
        const
            me   = this,
            item = me.get(data.windowId),
            {chrome, innerRect, outerRect} = me.calculateGeometry(data);

        if (item) {
            item.chrome    = chrome;
            item.innerRect = innerRect;
            item.outerRect = outerRect
        } else {
            me.register({
                chrome,
                id: data.windowId,
                innerRect,
                outerRect
            })
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            className: this.className,
            windows  : this.items.map(win => ({
                id       : win.id,
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Window));


/***/ },

/***/ "./src/util/vdom/TreeBuilder.mjs"
/*!***************************************!*\
  !*** ./src/util/vdom/TreeBuilder.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * A singleton utility class responsible for recursively building VDOM and VNode trees.
 * It can expand component references within a tree structure into their full VDOM/VNode representations,
 * supporting selective (asymmetric) tree expansion for optimized updates.
 * @class Neo.util.vdom.TreeBuilder
 * @extends Neo.core.Base
 * @singleton
 */
class TreeBuilder extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.vdom.TreeBuilder'
         * @protected
         */
        className: 'Neo.util.vdom.TreeBuilder',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Private helper to recursively build a tree, abstracting the child node key.
     * @param {Object} node The vdom or vnode to process.
     * @param {Number} depth The current recursion depth.
     * @param {Set<String>|null} mergedChildIds A set of component IDs to selectively expand.
     * @param {String} childKey The property name for child nodes ('cn' or 'childNodes').
     * @returns {Object}
     * @private
     */
    #buildTree(node, depth, mergedChildIds, childKey) {
        // We can not use Neo.isObject() here, since inside unit-test scenarios, we will import vdom.Helper into main threads.
        // Inside this scenario, Neo.isObject() returns false for VNode instances
        if (typeof node !== 'object' || node === null) {
            return node
        }

        // JIT ID Generation (App Authority)
        // If we are processing a VDOM tree (childKey === 'cn') and the node has no ID,
        // we must generate one now to ensure deterministic identity before the VDOM leaves the App Worker.
        if (childKey === 'cn' && !node.id) {
            node.id = Neo.getId(node.vtype === 'text' ? 'vtext' : 'vnode')
        }

        let output = {...node}; // Shallow copy

        if (node[childKey]) {
            output[childKey] = [];

            for (let i = 0, len = node[childKey].length; i < len; i++) {
                let item        = node[childKey][i],
                    currentItem = item,
                    childDepth;

                if (currentItem.componentId) {
                    const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(currentItem.componentId);

                    // Sparse Tree Generation & Scoped Updates
                    // We prune the branch (send a placeholder) if:
                    // 1. We are at the depth boundary (depth === 1) AND it's not a merged update.
                    // 2. We are in a Merged Update (mergedChildIds exists) AND this component is not in the AllowList (not dirty/bridge).
                    // Exception: We never prune if depth is -1 (Full Tree) or if the component is not mounted yet.
                    if (depth !== -1 && component?.vnode) {
                        const isExpandable = mergedChildIds?.has(currentItem.componentId);

                        if ((depth === 1 && !isExpandable) || (mergedChildIds && !isExpandable)) {
                            output[childKey].push({...currentItem, neoIgnore: true});
                            continue // Stop processing this branch, move to next item
                        }
                    }

                    // Expand the branch if it's part of a merged update, or if the depth requires it, OR if the vnode is missing
                    if (depth > 1 || depth === -1 || mergedChildIds?.has(currentItem.componentId) || !component?.vnode) {
                        // Use the correct tree type based on the childKey
                        const componentTree = childKey === 'cn' ? component?.vdom : component?.vnode;
                        if (componentTree) {
                            currentItem = componentTree
                        }
                    }
                }

                if (item.componentId) {
                    childDepth = (depth === -1) ? -1 : Math.max(0, depth - 1)
                } else {
                    childDepth = depth
                }

                output[childKey].push(this.#buildTree(currentItem, childDepth, mergedChildIds, childKey))
            }
        }

        return output
    }


    /**
     * Copies a given vdom tree and replaces child component references with their vdom.
     * @param {Object} vdom
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVdomTree(vdom, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vdom, depth, mergedChildIds, 'cn')
    }

    /**
     * Copies a given vnode tree and replaces child component references with their vnode.
     * @param {Object} vnode
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVnodeTree(vnode, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vnode, depth, mergedChildIds, 'childNodes')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeBuilder));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19haV9DbGllbnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ087QUFDUTtBQUNMO0FBQ0k7QUFDRztBQUNKO0FBQ0s7QUFDWDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxvRUFBZ0IsS0FBSyxXQUFXO0FBQ3BFLG9DQUFvQywrREFBVyxVQUFVLFdBQVc7QUFDcEUsb0NBQW9DLG1FQUFlLE1BQU0sV0FBVztBQUNwRSxvQ0FBb0Msc0VBQWtCLEdBQUcsV0FBVztBQUNwRSxvQ0FBb0Msa0VBQWMsT0FBTyxXQUFXO0FBQ3BFOztBQUVBLGVBQWUsaURBQWlEOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QztBQUNBOztBQUVBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyw4REFBZ0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDJCQUEyQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9haS9DbGllbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L0NvbXBvbmVudFNlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L0RhdGFTZXJ2aWNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2FpL2NsaWVudC9JbnN0YW5jZVNlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L0ludGVyYWN0aW9uU2VydmljZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9haS9jbGllbnQvUnVudGltZVNlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYWkvY2xpZW50L1NlcnZpY2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZGF0YS9jb25uZWN0aW9uL1dlYlNvY2tldC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1N0b3JlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvV2luZG93Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvdmRvbS9UcmVlQnVpbGRlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50U2VydmljZSAgIGZyb20gJy4vY2xpZW50L0NvbXBvbmVudFNlcnZpY2UubWpzJztcbmltcG9ydCBEYXRhU2VydmljZSAgICAgICAgZnJvbSAnLi9jbGllbnQvRGF0YVNlcnZpY2UubWpzJztcbmltcG9ydCBJbnN0YW5jZVNlcnZpY2UgICAgZnJvbSAnLi9jbGllbnQvSW5zdGFuY2VTZXJ2aWNlLm1qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb25TZXJ2aWNlIGZyb20gJy4vY2xpZW50L0ludGVyYWN0aW9uU2VydmljZS5tanMnO1xuaW1wb3J0IFJ1bnRpbWVTZXJ2aWNlICAgICBmcm9tICcuL2NsaWVudC9SdW50aW1lU2VydmljZS5tanMnO1xuaW1wb3J0IFNvY2tldCAgICAgICAgICAgICBmcm9tICcuLi9kYXRhL2Nvbm5lY3Rpb24vV2ViU29ja2V0Lm1qcyc7XG5pbXBvcnQgV2luZG93TWFuYWdlciAgICAgIGZyb20gJy4uL21hbmFnZXIvV2luZG93Lm1qcyc7XG5cbi8qKlxuICogVGhlIEFJIENsaWVudCBlc3RhYmxpc2hlcyBhIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOZXVyYWwgTGluayBNQ1AgU2VydmVyLlxuICogSXQgYWN0cyBhcyBhIGJyaWRnZSwgZW5hYmxpbmcgZXh0ZXJuYWwgQUkgYWdlbnRzIHRvIGluc3BlY3QgYW5kIG1hbmlwdWxhdGUgdGhlIHJ1bm5pbmcgTmVvLm1qcyBhcHBsaWNhdGlvblxuICogdmlhIGEgc3RhbmRhcmRpemVkIEpTT04tUlBDIHByb3RvY29sLlxuICogQGNsYXNzIE5lby5haS5DbGllbnRcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuQ2xpZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuQ2xpZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBjdXN0b20gY29uZmlncyBmb3IgZGF0YS5jb25uZWN0aW9uLldlYnNvY2tldCwgb3IgcGFzcyBhIG1vZHVsZSBvciBpbnN0YW5jZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fE5lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0fG51bGx9IHNvY2tldD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb2NrZXRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVVJMIG9mIHRoZSBOZXVyYWwgTGluayBNQ1AgU2VydmVyJ3MgV2ViU29ja2V0IGVuZHBvaW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHVybD0nd3M6Ly8xMjcuMC4wLjE6ODA4MSdcbiAgICAgICAgICovXG4gICAgICAgIHVybDogJ3dzOi8vMTI3LjAuMC4xOjgwODEnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNDb25uZWN0ZWQ9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEJ1ZmZlciBmb3IgY29uc29sZSBsb2dzIGdlbmVyYXRlZCBiZWZvcmUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICAgICAqIEBtZW1iZXIge0FycmF5fSBsb2dzPVtdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGxvZ3MgPSBbXVxuICAgIC8qKlxuICAgICAqIE1hcCBKU09OLVJQQyBtZXRob2QgcHJlZml4ZXMgdG8gc2VydmljZSBpbnN0YW5jZXNcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHNlcnZpY2VNYXBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VydmljZU1hcCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHNlcnZpY2VzPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2VydmljZXMgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXR8bnVsbH0gc29ja2V0PW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc29ja2V0ID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zZXJ2aWNlcyA9IHtcbiAgICAgICAgICAgIGNvbXBvbmVudCAgOiBOZW8uY3JlYXRlKENvbXBvbmVudFNlcnZpY2UsICAge2NsaWVudDogbWV9KSxcbiAgICAgICAgICAgIGRhdGEgICAgICAgOiBOZW8uY3JlYXRlKERhdGFTZXJ2aWNlLCAgICAgICAge2NsaWVudDogbWV9KSxcbiAgICAgICAgICAgIGluc3RhbmNlICAgOiBOZW8uY3JlYXRlKEluc3RhbmNlU2VydmljZSwgICAge2NsaWVudDogbWV9KSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uOiBOZW8uY3JlYXRlKEludGVyYWN0aW9uU2VydmljZSwge2NsaWVudDogbWV9KSxcbiAgICAgICAgICAgIHJ1bnRpbWUgICAgOiBOZW8uY3JlYXRlKFJ1bnRpbWVTZXJ2aWNlLCAgICAge2NsaWVudDogbWV9KVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHtjb21wb25lbnQsIGRhdGEsIGluc3RhbmNlLCBpbnRlcmFjdGlvbiwgcnVudGltZX0gPSBtZS5zZXJ2aWNlcztcblxuICAgICAgICBtZS5zZXJ2aWNlTWFwID0ge1xuICAgICAgICAgICAgZ2V0X2NvbXBvbmVudCAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X2NvbXB1dGVkX3N0eWxlcyAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X2RvbV9yZWN0ICAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X3Zkb20gICAgICAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X3Zkb21fdm5vZGUgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0X3Zub2RlICAgICAgICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgaGlnaGxpZ2h0X2NvbXBvbmVudCAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgcXVlcnlfY29tcG9uZW50ICAgICAgIDogY29tcG9uZW50LFxuICAgICAgICAgICAgcXVlcnlfdmRvbSAgICAgICAgICAgIDogY29tcG9uZW50LFxuXG4gICAgICAgICAgICBjYWxsX21ldGhvZCAgICAgICAgICAgIDogaW5zdGFuY2UsXG4gICAgICAgICAgICBmaW5kX2luc3RhbmNlcyAgICAgICAgIDogaW5zdGFuY2UsXG4gICAgICAgICAgICBnZXRfaW5zdGFuY2VfcHJvcGVydGllczogaW5zdGFuY2UsXG4gICAgICAgICAgICBzZXRfaW5zdGFuY2VfcHJvcGVydGllczogaW5zdGFuY2UsXG5cbiAgICAgICAgICAgIGdldF9yZWNvcmQgICAgICAgICAgICA6IGRhdGEsXG4gICAgICAgICAgICBpbnNwZWN0X3N0YXRlX3Byb3ZpZGVyOiBkYXRhLFxuICAgICAgICAgICAgaW5zcGVjdF9zdG9yZSAgICAgICAgIDogZGF0YSxcbiAgICAgICAgICAgIGxpc3Rfc3RvcmVzICAgICAgICAgICA6IGRhdGEsXG4gICAgICAgICAgICBtb2RpZnlfc3RhdGVfcHJvdmlkZXIgOiBkYXRhLFxuXG4gICAgICAgICAgICBnZXRfZG9tX2V2ZW50ICAgICAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgZ2V0X2RyYWcgICAgICAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIGdldF9tZXRob2Rfc291cmNlICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBnZXRfcm91dGUgICAgICAgICAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgZ2V0X3dpbmRvdyAgICAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIGluc3BlY3RfY2xhc3MgICAgICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBwYXRjaF9jb2RlICAgICAgICAgICAgOiBydW50aW1lLFxuICAgICAgICAgICAgcmVsb2FkX3BhZ2UgICAgICAgICAgIDogcnVudGltZSxcbiAgICAgICAgICAgIHNldF9yb3V0ZSAgICAgICAgICAgICA6IHJ1bnRpbWUsXG4gICAgICAgICAgICBzaW11bGF0ZV9ldmVudCAgICAgICAgOiBpbnRlcmFjdGlvblxuICAgICAgICB9O1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uQXBwV29ya2VyV2luZG93Q29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uQXBwV29ya2VyV2luZG93RGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmNvbm5lY3QoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTmV1cmFsIExpbmsgTUNQIFNlcnZlci5cbiAgICAgKiBVc2VzIE5lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0IGZvciByb2J1c3QgY29ubmVjdGlvbiBtYW5hZ2VtZW50LlxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB1cmwgICAgID0gbmV3IFVSTChOZW8uY29uZmlnLm5ldXJhbExpbmtVcmwgfHwgbWUudXJsKSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lID0gJ1Vua25vd24gQXBwJztcblxuICAgICAgICAgICAgaWYgKE5lby5jb25maWcuYXBwUGF0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gTmVvLmNvbmZpZy5hcHBQYXRoLm1hdGNoKC9hcHBzXFwvKFteXFwvXSspXFwvLyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgPSBtYXRjaFsxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2FwcFdvcmtlcklkJywgTmVvLndvcmtlci5BcHAuaWQpO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2FwcE5hbWUnLCBhcHBOYW1lKTtcblxuICAgICAgICAgICAgbWUuc29ja2V0ID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKG1lLnNvY2tldENvbmZpZywgU29ja2V0LCB7XG4gICAgICAgICAgICAgICAgc2VydmVyQWRkcmVzczogdXJsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZSAgOiBtZS5vblNvY2tldENsb3NlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvciAgOiBtZS5vblNvY2tldEVycm9yLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZS5vblNvY2tldE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wZW4gICA6IG1lLm9uU29ja2V0T3BlbixcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgIDogbWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOZW8uYWkuQ2xpZW50OiBGYWlsZWQgdG8gY3JlYXRlIFdlYlNvY2tldCBjb25uZWN0aW9uJywgZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdXRlcyBzcGVjaWZpYyBKU09OLVJQQyBtZXRob2RzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgaW1wbGVtZW50YXRpb24uXG4gICAgICogVGhpcyBtZXRob2QgYWN0cyBhcyB0aGUgY2VudHJhbCBkaXNwYXRjaGVyIGZvciBhbGwgQUktZHJpdmVuIGNvbW1hbmRzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgVGhlIEpTT04tUlBDIG1ldGhvZCBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggdGhlIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBoYW5kbGVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHNlcnZpY2UgPSBudWxsLFxuICAgICAgICAgICAgcHJlZml4O1xuXG4gICAgICAgIC8vIEZpbmQgbWF0Y2hpbmcgc2VydmljZSBiYXNlZCBvbiBwcmVmaXhcbiAgICAgICAgLy8gZS5nLiBcImdldF9jb21wb25lbnRfcHJvcGVydHlcIiAtPiBtYXRjaGVzIFwiZ2V0X2NvbXBvbmVudFwiIHByZWZpeFxuICAgICAgICBmb3IgKHByZWZpeCBpbiBtZS5zZXJ2aWNlTWFwKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHNlcnZpY2UgPSBtZS5zZXJ2aWNlTWFwW3ByZWZpeF07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZuTmFtZSA9IE5lby5zbmFrZVRvQ2FtZWwobWV0aG9kKTtcblxuICAgICAgICBpZiAoc2VydmljZSkge1xuICAgICAgICAgICAgY29uc3QgZm4gPSBzZXJ2aWNlW2ZuTmFtZV07XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbChzZXJ2aWNlLCBwYXJhbXMpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE5lby5pc1Byb21pc2UoZm4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuLmNhbGwoc2VydmljZSwgcGFyYW1zKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcnZpY2UgJiYgdHlwZW9mIHNlcnZpY2VbZm5OYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2VbZm5OYW1lXShwYXJhbXMpXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbWV0aG9kOiAke21ldGhvZH1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQXBwV29ya2VyV2luZG93Q29ubmVjdChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIHdpbiA9IFdpbmRvd01hbmFnZXIuZ2V0KGRhdGEud2luZG93SWQpLFxuICAgICAgICAgICAgICAgIHthcHBOYW1lLCB3aW5kb3dJZH0gPSBkYXRhO1xuXG4gICAgICAgICAgICB0aGlzLnNlbmROb3RpZmljYXRpb24oJ3dpbmRvd19jb25uZWN0ZWQnLCB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjaHJvbWUgICA6IHdpbj8uY2hyb21lLFxuICAgICAgICAgICAgICAgIGlubmVyUmVjdDogd2luPy5pbm5lclJlY3QsXG4gICAgICAgICAgICAgICAgb3V0ZXJSZWN0OiB3aW4/Lm91dGVyUmVjdCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbkFwcFdvcmtlcldpbmRvd0Rpc2Nvbm5lY3Qoe3dpbmRvd0lkfSkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZpY2F0aW9uKCd3aW5kb3dfZGlzY29ubmVjdGVkJywge3dpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgV2ViU29ja2V0LlxuICAgICAqIFBhcnNlcyB0aGUgSlNPTi1SUEMgcGF5bG9hZCBhbmQgZGVsZWdhdGVzIHZhbGlkIHJlcXVlc3RzIHRvIGBoYW5kbGVSZXF1ZXN0YC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uU29ja2V0TWVzc2FnZSh7ZGF0YX0pIHtcbiAgICAgICAgaWYgKGRhdGEubWV0aG9kKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlUmVxdWVzdChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlc3BvbnNlKGRhdGEuaWQsIHJlc3VsdClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOZW8uYWkuQ2xpZW50OiBGYWlsZWQgdG8gaGFuZGxlIG1lc3NhZ2UnLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihkYXRhLmlkLCBlLm1lc3NhZ2UsIGUuc3RhY2spXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIG9uU29ja2V0T3BlbihldmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnTmVvLmFpLkNsaWVudDogQ29ubmVjdGVkIHRvIE1DUCBTZXJ2ZXInKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gRmx1c2ggYnVmZmVyZWQgbG9nc1xuICAgICAgICBpZiAodGhpcy5sb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9ncy5mb3JFYWNoKGxvZyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZpY2F0aW9uKCdjb25zb2xlX2xvZycsIGxvZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sb2dzLmxlbmd0aCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFwcFdvcmtlciA9IE5lby53b3JrZXIuQXBwO1xuXG4gICAgICAgIC8vIDEuIFJlZ2lzdGVyIHRoZSB3b3JrZXJcbiAgICAgICAgdGhpcy5zb2NrZXQuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2QgOiAncmVnaXN0ZXInLFxuICAgICAgICAgICAgcGFyYW1zIDoge1xuICAgICAgICAgICAgICAgIGFwcFdvcmtlcklkICAgOiBhcHBXb3JrZXIuaWQsXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQgICA6IE5lby5jb25maWcuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgaXNTaGFyZWRXb3JrZXI6IGFwcFdvcmtlci5pc1NoYXJlZFdvcmtlcixcbiAgICAgICAgICAgICAgICB1c2VyQWdlbnQgICAgIDogbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyAyLiBSZWh5ZHJhdGUgd2luZG93IHRvcG9sb2d5XG4gICAgICAgIFdpbmRvd01hbmFnZXIuaXRlbXMuZm9yRWFjaCh3aW4gPT4ge1xuICAgICAgICAgICAgdGhpcy5zZW5kTm90aWZpY2F0aW9uKCd3aW5kb3dfY29ubmVjdGVkJywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWUgIDogd2luLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY2hyb21lICAgOiB3aW4uY2hyb21lLFxuICAgICAgICAgICAgICAgIGlubmVyUmVjdDogd2luLmlubmVyUmVjdCxcbiAgICAgICAgICAgICAgICBvdXRlclJlY3Q6IHdpbi5vdXRlclJlY3QsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiB3aW4uaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gMy4gUmVoeWRyYXRlIGRyYWcgc3RhdGUgKGlmIGFjdGl2ZSlcbiAgICAgICAgY29uc3QgZHJhZ0Nvb3JkaW5hdG9yID0gTmVvLm1hbmFnZXI/LkRyYWdDb29yZGluYXRvcjtcblxuICAgICAgICBpZiAoZHJhZ0Nvb3JkaW5hdG9yPy5hY3RpdmVUYXJnZXRab25lKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmROb3RpZmljYXRpb24oJ2RyYWdfYWN0aXZlJywge1xuICAgICAgICAgICAgICAgIHNvcnRHcm91cCA6IGRyYWdDb29yZGluYXRvci5hY3RpdmVUYXJnZXRab25lLnNvcnRHcm91cCxcbiAgICAgICAgICAgICAgICBzb3VyY2Vab25lOiBkcmFnQ29vcmRpbmF0b3IuYWN0aXZlVGFyZ2V0Wm9uZS5pZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2xvc2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNvY2tldENsb3NlKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZW8uYWkuQ2xpZW50OiBEaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNvY2tldEVycm9yKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05lby5haS5DbGllbnQ6IFdlYlNvY2tldCBFcnJvcicsIGV2ZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgSlNPTi1SUEMgZXJyb3IgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0YWNrXVxuICAgICAqL1xuICAgIHNlbmRFcnJvcihpZCwgbWVzc2FnZSwgc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlICAgOiAtMzI2MDMsIC8vIEludGVybmFsIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgICA6IHtzdGFja31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBKU09OLVJQQyBub3RpZmljYXRpb24gKG5vIGlkKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICovXG4gICAgc2VuZE5vdGlmaWNhdGlvbihtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIEpTT04tUlBDIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7Kn0gcmVzdWx0XG4gICAgICovXG4gICAgc2VuZFJlc3BvbnNlKGlkLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENsaWVudCk7XG4iLCJpbXBvcnQgU2VydmljZSAgICAgZnJvbSAnLi9TZXJ2aWNlLm1qcyc7XG5pbXBvcnQgVHJlZUJ1aWxkZXIgZnJvbSAnLi4vLi4vdXRpbC92ZG9tL1RyZWVCdWlsZGVyLm1qcyc7XG5pbXBvcnQgVmRvbVV0aWwgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogSGFuZGxlcyBjb21wb25lbnQtcmVsYXRlZCBOZXVyYWwgTGluayByZXF1ZXN0cy5cbiAqIEBjbGFzcyBOZW8uYWkuY2xpZW50LkNvbXBvbmVudFNlcnZpY2VcbiAqIEBleHRlbmRzIE5lby5haS5jbGllbnQuU2VydmljZVxuICovXG5jbGFzcyBDb21wb25lbnRTZXJ2aWNlIGV4dGVuZHMgU2VydmljZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuY2xpZW50LkNvbXBvbmVudFNlcnZpY2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5haS5jbGllbnQuQ29tcG9uZW50U2VydmljZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBwYXJhbXMuY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJhbXMudmFyaWFibGVzXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb21wdXRlZFN0eWxlcyh7Y29tcG9uZW50SWQsIHZhcmlhYmxlc30pIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChjb21wb25lbnRJZCk7XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50IG5vdCBmb3VuZDogJHtjb21wb25lbnRJZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLmdldENvbXB1dGVkU3R5bGUoe1xuICAgICAgICAgICAgaWQgICA6IGNvbXBvbmVudC5pZCxcbiAgICAgICAgICAgIHN0eWxlOiB2YXJpYWJsZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtzdHlsZXN9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGFyYW1zLmNvbXBvbmVudElkc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RG9tUmVjdCh7Y29tcG9uZW50SWRzfSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29tcG9uZW50SWRzKSB8fCBjb21wb25lbnRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudElkcyBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5JylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSB0aGUgZmlyc3QgY29tcG9uZW50IHRvIHJlc29sdmUgdGhlIHdpbmRvd0lkIGNvbnRleHRcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChjb21wb25lbnRJZHNbMF0pO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCBub3QgZm91bmQ6ICR7Y29tcG9uZW50SWRzWzBdfWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWN0cyA9IGF3YWl0IGNvbXBvbmVudC5nZXREb21SZWN0KGNvbXBvbmVudElkcyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlY3RzOiBBcnJheS5pc0FycmF5KHJlY3RzKSA/IHJlY3RzIDogW3JlY3RzXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcy5vcHRpb25zXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgaGlnaGxpZ2h0Q29tcG9uZW50KHtjb21wb25lbnRJZCwgb3B0aW9uc30pIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoY29tcG9uZW50SWQpLFxuICAgICAgICAgICAgb3JpZ2luYWxTdHlsZTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgbm90IGZvdW5kOiAke2NvbXBvbmVudElkfWApXG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgY29sb3IgICAgPSBvcHRpb25zLmNvbG9yICAgIHx8ICdyZWQnLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDIwMDAsXG4gICAgICAgICAgICBtb2RlICAgICA9IG9wdGlvbnMuc3R5bGUgICAgfHwgJ291dGxpbmUnOyAvLyAnb3V0bGluZScgb3IgJ2JveC1zaGFkb3cnXG5cbiAgICAgICAgb3JpZ2luYWxTdHlsZSA9IGNvbXBvbmVudC5zdHlsZSB8fCB7fTtcblxuICAgICAgICBsZXQgaGlnaGxpZ2h0U3R5bGUgPSB7fTtcblxuICAgICAgICBpZiAobW9kZSA9PT0gJ291dGxpbmUnKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRTdHlsZS5vdXRsaW5lICAgICAgID0gYDJweCBzb2xpZCAke2NvbG9yfWA7XG4gICAgICAgICAgICBoaWdobGlnaHRTdHlsZS5vdXRsaW5lT2Zmc2V0ID0gJy0ycHgnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdobGlnaHRTdHlsZS5ib3hTaGFkb3cgPSBgMCAwIDEwcHggJHtjb2xvcn0sIGluc2V0IDAgMCAxMHB4ICR7Y29sb3J9YFxuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50LnN0eWxlID0gey4uLm9yaWdpbmFsU3R5bGUsIC4uLmhpZ2hsaWdodFN0eWxlfTtcblxuICAgICAgICB0aGlzLnRpbWVvdXQoZHVyYXRpb24pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlID0gb3JpZ2luYWxTdHlsZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IHRydWV9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gIFtwYXJhbXMuZGVwdGhdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmxlYW49dHJ1ZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIFtwYXJhbXMucm9vdElkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50VHJlZSh7ZGVwdGgsIGxlYW49dHJ1ZSwgcm9vdElkfSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJlZTogdGhpcy5zZXJpYWxpemVDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcy5nZXRDb21wb25lbnRSb290KHJvb3RJZCksXG4gICAgICAgICAgICAgICAgbGVhbixcbiAgICAgICAgICAgICAgICBtYXhEZXB0aCA6IGRlcHRoIHx8IC0xXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLmRlcHRoXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnJvb3RJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZkb21UcmVlKHtkZXB0aCwgcm9vdElkfSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudFJvb3Qocm9vdElkKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignUm9vdCBjb21wb25lbnQgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB7dmRvbTogVHJlZUJ1aWxkZXIuZ2V0VmRvbVRyZWUoY29tcG9uZW50LnZkb20sIGRlcHRoKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuZGVwdGhdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucm9vdElkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Vm5vZGVUcmVlKHtkZXB0aCwgcm9vdElkfSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudFJvb3Qocm9vdElkKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignUm9vdCBjb21wb25lbnQgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB7dm5vZGU6IFRyZWVCdWlsZGVyLmdldFZub2RlVHJlZShjb21wb25lbnQudm5vZGUsIGRlcHRoKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuZGVwdGhdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucm9vdElkXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmRvbVZub2RlKHtkZXB0aCwgcm9vdElkfSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldENvbXBvbmVudFJvb3Qocm9vdElkKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignUm9vdCBjb21wb25lbnQgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZG9tIDogVHJlZUJ1aWxkZXIuZ2V0VmRvbVRyZWUoY29tcG9uZW50LnZkb20sIGRlcHRoKSxcbiAgICAgICAgICAgIHZub2RlOiBUcmVlQnVpbGRlci5nZXRWbm9kZVRyZWUoY29tcG9uZW50LnZub2RlLCBkZXB0aClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIFtwYXJhbXMucm9vdElkXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIHBhcmFtcy5zZWxlY3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IFtwYXJhbXMucmV0dXJuUHJvcGVydGllc11cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHF1ZXJ5Q29tcG9uZW50KHtyb290SWQsIHNlbGVjdG9yLCByZXR1cm5Qcm9wZXJ0aWVzfSkge1xuICAgICAgICBsZXQgbWF0Y2hlcztcblxuICAgICAgICBpZiAocm9vdElkKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KHJvb3RJZCk7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKGBSb290IGNvbXBvbmVudCBub3QgZm91bmQ6ICR7cm9vdElkfWApO1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGNvbXBvbmVudC5kb3duKHNlbGVjdG9yLCBmYWxzZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoZXMgPSBOZW8ubWFuYWdlci5Db21wb25lbnQuZmluZChzZWxlY3RvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBtYXRjaGVzLm1hcChjID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJldHVyblByb3BlcnRpZXMpICYmIHJldHVyblByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuUHJvcGVydGllcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1twcm9wXSA9IHRoaXMuc2FmZVNlcmlhbGl6ZShjW3Byb3BdKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIDogYy5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICA6IGMuaWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYy50b0pTT04oKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge2NvbXBvbmVudHN9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnJvb3RJZF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnNlbGVjdG9yXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBxdWVyeVZkb20oe3Jvb3RJZCwgc2VsZWN0b3J9KSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZ2V0Q29tcG9uZW50Um9vdChyb290SWQpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKCdSb290IGNvbXBvbmVudCBub3QgZm91bmQnKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBWZG9tVXRpbC5maW5kKGNvbXBvbmVudC52ZG9tLCBzZWxlY3Rvcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZkb20gICAgOiByZXN1bHQ/LnZkb20gfHwgbnVsbCxcbiAgICAgICAgICAgIGluZGV4ICAgOiByZXN1bHQ/LmluZGV4LFxuICAgICAgICAgICAgcGFyZW50SWQ6IHJlc3VsdD8ucGFyZW50Tm9kZT8uaWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcm9vdElkXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnRSb290KHJvb3RJZCkge1xuICAgICAgICBpZiAocm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudChyb290SWQpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcHBzID0gT2JqZWN0LnZhbHVlcyhOZW8uYXBwcyB8fCB7fSk7XG5cbiAgICAgICAgaWYgKGFwcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcHNbMF0ubWFpblZpZXdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgW2RhdGEuY3VycmVudERlcHRoPTFdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgICAgIFtkYXRhLmxlYW49dHJ1ZV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgW2RhdGEubWF4RGVwdGg9LTFdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzZXJpYWxpemVDb21wb25lbnQoe2NvbXBvbmVudCwgY3VycmVudERlcHRoPTEsIGxlYW49dHJ1ZSwgbWF4RGVwdGg9LTF9KSB7XG4gICAgICAgIGlmICghY29tcG9uZW50KSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgIGlmIChsZWFuKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjb21wb25lbnQuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGlkICAgICAgIDogY29tcG9uZW50LmlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29tcG9uZW50LnRvSlNPTigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heERlcHRoID09PSAtMSB8fCBjdXJyZW50RGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBOZW8ubWFuYWdlci5Db21wb25lbnQuZ2V0Q2hpbGRDb21wb25lbnRzKGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lml0ZW1zID0gY2hpbGRyZW4ubWFwKGNoaWxkID0+IHRoaXMuc2VyaWFsaXplQ29tcG9uZW50KHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ICAgOiBjaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERlcHRoOiBjdXJyZW50RGVwdGggKyAxLFxuICAgICAgICAgICAgICAgICAgICBsZWFuLFxuICAgICAgICAgICAgICAgICAgICBtYXhEZXB0aFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50U2VydmljZSk7XG4iLCJpbXBvcnQgU2VydmljZSAgICAgIGZyb20gJy4vU2VydmljZS5tanMnO1xuaW1wb3J0IFN0b3JlTWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogSGFuZGxlcyBkYXRhLXJlbGF0ZWQgTmV1cmFsIExpbmsgcmVxdWVzdHMuXG4gKiBAY2xhc3MgTmVvLmFpLmNsaWVudC5EYXRhU2VydmljZVxuICogQGV4dGVuZHMgTmVvLmFpLmNsaWVudC5TZXJ2aWNlXG4gKi9cbmNsYXNzIERhdGFTZXJ2aWNlIGV4dGVuZHMgU2VydmljZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuY2xpZW50LkRhdGFTZXJ2aWNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuY2xpZW50LkRhdGFTZXJ2aWNlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnJlY29yZElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMuc3RvcmVJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJlY29yZCh7cmVjb3JkSWQsIHN0b3JlSWR9KSB7XG4gICAgICAgIGxldCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKHN0b3JlSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gTmVvLmdldChzdG9yZUlkKTtcbiAgICAgICAgICAgIGlmICghc3RvcmUpIHRocm93IG5ldyBFcnJvcihgU3RvcmUgbm90IGZvdW5kOiAke3N0b3JlSWR9YCk7XG4gICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXQocmVjb3JkSWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgICAgICBTdG9yZU1hbmFnZXIuaXRlbXMuZm9yRWFjaChzdG9yZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjID0gc3RvcmUuZ2V0KHJlY29yZElkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjKSBtYXRjaGVzLnB1c2gocmVjKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIHJlY29yZHMgZm91bmQgd2l0aCBJRCAke3JlY29yZElkfS4gUGxlYXNlIHNwZWNpZnkgc3RvcmVJZC5gKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IG1hdGNoZXNbMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVjb3JkKSB0aHJvdyBuZXcgRXJyb3IoYFJlY29yZCBub3QgZm91bmQ6ICR7cmVjb3JkSWR9YCk7XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZC50b0pTT04oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnByb3ZpZGVySWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGluc3BlY3RTdGF0ZVByb3ZpZGVyKHtwcm92aWRlcklkfSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IE5lby5nZXQocHJvdmlkZXJJZCk7XG4gICAgICAgIGlmICghcHJvdmlkZXIpIHRocm93IG5ldyBFcnJvcihgU3RhdGVQcm92aWRlciBub3QgZm91bmQ6ICR7cHJvdmlkZXJJZH1gKTtcblxuICAgICAgICByZXR1cm4gcHJvdmlkZXIudG9KU09OKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubGltaXQ9NTBdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMub2Zmc2V0PTBdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5zdG9yZUlkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBpbnNwZWN0U3RvcmUoe2xpbWl0PTUwLCBvZmZzZXQ9MCwgc3RvcmVJZH0pIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBOZW8uZ2V0KHN0b3JlSWQpO1xuICAgICAgICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoYFN0b3JlIG5vdCBmb3VuZDogJHtzdG9yZUlkfWApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdG9yZS50b0pTT04oKSxcbiAgICAgICAgICAgIGl0ZW1zOiBzdG9yZS5nZXRSYW5nZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KS5tYXAocmVjb3JkID0+IHJlY29yZC50b0pTT04oKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxpc3RTdG9yZXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9yZXM6IFN0b3JlTWFuYWdlci5pdGVtcy5tYXAocyA9PiAoe1xuICAgICAgICAgICAgICAgIGlkICAgICAgOiBzLmlkLFxuICAgICAgICAgICAgICAgIG1vZGVsICAgOiBzLm1vZGVsPy5jbGFzc05hbWUgfHwgJ04vQScsXG4gICAgICAgICAgICAgICAgY291bnQgICA6IHMuY291bnQsXG4gICAgICAgICAgICAgICAgaXNMb2FkZWQ6IHMuaXNMb2FkZWRcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMuZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucHJvdmlkZXJJZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgbW9kaWZ5U3RhdGVQcm92aWRlcih7ZGF0YSwgcHJvdmlkZXJJZH0pIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBOZW8uZ2V0KHByb3ZpZGVySWQpO1xuICAgICAgICBpZiAoIXByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlUHJvdmlkZXIgbm90IGZvdW5kOiAke3Byb3ZpZGVySWR9YCk7XG5cbiAgICAgICAgcHJvdmlkZXIuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtzdWNjZXNzOiB0cnVlfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRGF0YVNlcnZpY2UpO1xuIiwiaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi9TZXJ2aWNlLm1qcyc7XG5cbi8qKlxuICogSGFuZGxlcyBnZW5lcmljIGluc3RhbmNlLXJlbGF0ZWQgTmV1cmFsIExpbmsgcmVxdWVzdHMuXG4gKiBAY2xhc3MgTmVvLmFpLmNsaWVudC5JbnN0YW5jZVNlcnZpY2VcbiAqIEBleHRlbmRzIE5lby5haS5jbGllbnQuU2VydmljZVxuICovXG5jbGFzcyBJbnN0YW5jZVNlcnZpY2UgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5haS5jbGllbnQuSW5zdGFuY2VTZXJ2aWNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYWkuY2xpZW50Lkluc3RhbmNlU2VydmljZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgcHJvcGVydGllcyBmcm9tIGEgc3BlY2lmaWMgaW5zdGFuY2UgYnkgaXRzIElELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGFyYW1zLnByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldEluc3RhbmNlUHJvcGVydGllcyh7aWQsIHByb3BlcnRpZXN9KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBpbnN0YW5jZSA9IE5lby5nZXQoaWQpLFxuICAgICAgICAgICAgcmVzdWx0ICAgPSB7fTtcblxuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZDogJHtpZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSB0aGlzLnNhZmVTZXJpYWxpemUoTmVvLm5zKHByb3BlcnR5LCBmYWxzZSwgaW5zdGFuY2UpKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge3Byb3BlcnRpZXM6IHJlc3VsdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBpbnN0YW5jZXMgbWF0Y2hpbmcgYSBzZWxlY3Rvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5zZWxlY3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IFtwYXJhbXMucmV0dXJuUHJvcGVydGllc11cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZpbmRJbnN0YW5jZXMoe3NlbGVjdG9yLCByZXR1cm5Qcm9wZXJ0aWVzfSkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZXMgPSBOZW8ubWFuYWdlci5JbnN0YW5jZS5maW5kKHNlbGVjdG9yKS5tYXAoaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmV0dXJuUHJvcGVydGllcykgJiYgcmV0dXJuUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm5Qcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3Byb3BdID0gdGhpcy5zYWZlU2VyaWFsaXplKE5lby5ucyhwcm9wLCBmYWxzZSwgaW5zdGFuY2UpKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIDogaW5zdGFuY2UuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgOiBpbnN0YW5jZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS50b0pTT04oKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge2luc3RhbmNlc31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHByb3BlcnRpZXMgb24gYSBzcGVjaWZpYyBpbnN0YW5jZSBieSBpdHMgSUQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNldEluc3RhbmNlUHJvcGVydGllcyh7aWQsIHByb3BlcnRpZXN9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gTmVvLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQ6ICR7aWR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3RhbmNlLnNldChwcm9wZXJ0aWVzKTtcblxuICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IHRydWV9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYSBtZXRob2Qgb24gYSBzcGVjaWZpYyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWV0aG9kXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtwYXJhbXMuYXJnc11cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFzeW5jIGNhbGxNZXRob2Qoe2lkLCBtZXRob2QsIGFyZ3M9W119KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gTmVvLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQ6ICR7aWR9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBwYXRoQXJyYXkgID0gbWV0aG9kLnNwbGl0KCcuJyksXG4gICAgICAgICAgICBtZXRob2ROYW1lID0gcGF0aEFycmF5LnBvcCgpLFxuICAgICAgICAgICAgc2NvcGUgICAgICA9IHBhdGhBcnJheS5sZW5ndGggPCAxID8gaW5zdGFuY2UgOiBOZW8ubnMocGF0aEFycmF5LmpvaW4oJy4nKSwgZmFsc2UsIGluc3RhbmNlKTtcblxuICAgICAgICBpZiAoIXNjb3BlIHx8IHR5cGVvZiBzY29wZVttZXRob2ROYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRob2Qgbm90IGZvdW5kOiAke21ldGhvZH0gb24gaW5zdGFuY2UgJHtpZH1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2NvcGVbbWV0aG9kTmFtZV0uY2FsbChzY29wZSwgLi4uYXJncyk7XG5cbiAgICAgICAgcmV0dXJuIHtyZXN1bHQ6IHRoaXMuc2FmZVNlcmlhbGl6ZShyZXN1bHQpfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSW5zdGFuY2VTZXJ2aWNlKTtcbiIsImltcG9ydCBTZXJ2aWNlIGZyb20gJy4vU2VydmljZS5tanMnO1xuXG4vKipcbiAqIFNlcnZpY2UgZm9yIGhhbmRsaW5nIGludGVyYWN0aW9uIHNpbXVsYXRpb24gY29tbWFuZHMuXG4gKlxuICogQGNsYXNzIE5lby5haS5jbGllbnQuSW50ZXJhY3Rpb25TZXJ2aWNlXG4gKiBAZXh0ZW5kcyBOZW8uYWkuY2xpZW50LlNlcnZpY2VcbiAqL1xuY2xhc3MgSW50ZXJhY3Rpb25TZXJ2aWNlIGV4dGVuZHMgU2VydmljZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYWkuY2xpZW50LkludGVyYWN0aW9uU2VydmljZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmFpLmNsaWVudC5JbnRlcmFjdGlvblNlcnZpY2UnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltdWxhdGVzIGEgbmF0aXZlIERPTSBldmVudCBzZXF1ZW5jZSBvbiB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHBhcmFtcy5ldmVudHMgLSBTZXF1ZW5jZSBvZiBldmVudCBjb25maWcgb2JqZWN0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJvb2xlYW4+fVxuICAgICAqL1xuICAgIGFzeW5jIHNpbXVsYXRlRXZlbnQoe2V2ZW50c30pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcmFjdGlvblNlcnZpY2U6IGV2ZW50cyBtdXN0IGJlIGFuIGFycmF5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KGV2ZW50LmRlbGF5KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCBtZS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgaWQgICAgICA6IGV2ZW50LnRhcmdldElkLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgOiBldmVudC5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHR5cGUgICAgOiBldmVudC50eXBlLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBldmVudC53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIHRvIGRpc3BhdGNoIGEgc2luZ2xlIGV2ZW50IHRvIHRoZSBjb3JyZWN0IHdpbmRvd1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5vcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgZGlzcGF0Y2goe2lkLCBvcHRpb25zLCB0eXBlLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgYXdhaXQgTmVvLk1haW4uaW1wb3J0QWRkb24oe25hbWU6ICdFdmVudFNpbXVsYXRvcicsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IE5lby5tYWluLmFkZG9uLkV2ZW50U2ltdWxhdG9yLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSW50ZXJhY3Rpb25TZXJ2aWNlKTtcbiIsImltcG9ydCBEb21FdmVudE1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlci9Eb21FdmVudC5tanMnO1xuaW1wb3J0IEhhc2hIaXN0b3J5ICAgICBmcm9tICcuLi8uLi91dGlsL0hhc2hIaXN0b3J5Lm1qcyc7XG5pbXBvcnQgU2VydmljZSAgICAgICAgIGZyb20gJy4vU2VydmljZS5tanMnO1xuXG4vKipcbiAqIEhhbmRsZXMgcnVudGltZSBlbnZpcm9ubWVudCByZWxhdGVkIE5ldXJhbCBMaW5rIHJlcXVlc3RzLlxuICogQGNsYXNzIE5lby5haS5jbGllbnQuUnVudGltZVNlcnZpY2VcbiAqIEBleHRlbmRzIE5lby5haS5jbGllbnQuU2VydmljZVxuICovXG5jbGFzcyBSdW50aW1lU2VydmljZSBleHRlbmRzIFNlcnZpY2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFpLmNsaWVudC5SdW50aW1lU2VydmljZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmFpLmNsaWVudC5SdW50aW1lU2VydmljZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBuYW1lc3BhY2UgZXhpc3RzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLm5hbWVzcGFjZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtleGlzdHM6IEJvb2xlYW59XG4gICAgICovXG4gICAgY2hlY2tOYW1lc3BhY2Uoe25hbWVzcGFjZX0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4aXN0czogISFOZW8ubnMobmFtZXNwYWNlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY29tcG9uZW50SWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldERvbUV2ZW50TGlzdGVuZXJzKHtjb21wb25lbnRJZH0pIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGxpc3RlbmVycyA9IFtdLFxuICAgICAgICAgICAgZXZlbnRNYXAgID0gRG9tRXZlbnRNYW5hZ2VyLml0ZW1zPy5bY29tcG9uZW50SWRdO1xuXG4gICAgICAgIGlmIChldmVudE1hcCkge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZXZlbnRNYXApLmZvckVhY2goKFtldmVudE5hbWUsIGV2ZW50c10pID0+IHtcbiAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlOiBldmVudC5kZWxlZ2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50ICAgOiBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyIDogdHlwZW9mIGV2ZW50LmZuID09PSAnZnVuY3Rpb24nID8gZXZlbnQuZm4ubmFtZSB8fCAnYW5vbnltb3VzJyA6IGV2ZW50LmZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGV2ZW50LnByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgICA6IGV2ZW50LnNjb3BlPy5pZCB8fCAndW5rbm93bidcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7bGlzdGVuZXJzfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldERvbUV2ZW50U3VtbWFyeShwYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgc3VtbWFyeSA9IHtcbiAgICAgICAgICAgIGJ5Q29tcG9uZW50OiB7fSxcbiAgICAgICAgICAgIGJ5RXZlbnQgICAgOiB7fSxcbiAgICAgICAgICAgIHRvdGFsRXZlbnRzOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoRG9tRXZlbnRNYW5hZ2VyLml0ZW1zKS5mb3JFYWNoKChbY29tcG9uZW50SWQsIGV2ZW50TWFwXSkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudENvdW50ID0gMDtcblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZXZlbnRNYXApLmZvckVhY2goKFtldmVudE5hbWUsIGV2ZW50c10pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGV2ZW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBzdW1tYXJ5LnRvdGFsRXZlbnRzICAgICAgICs9IGNvdW50O1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudENvdW50ICAgICAgICAgICAgKz0gY291bnQ7XG4gICAgICAgICAgICAgICAgc3VtbWFyeS5ieUV2ZW50W2V2ZW50TmFtZV0gPSAoc3VtbWFyeS5ieUV2ZW50W2V2ZW50TmFtZV0gfHwgMCkgKyBjb3VudFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdW1tYXJ5LmJ5Q29tcG9uZW50W2NvbXBvbmVudElkXSA9IGNvbXBvbmVudENvdW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdW1tYXJ5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RHJhZ1N0YXRlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBkcmFnQ29vcmRpbmF0b3IgPSBOZW8ubWFuYWdlcj8uRHJhZ0Nvb3JkaW5hdG9yO1xuXG4gICAgICAgIGlmIChkcmFnQ29vcmRpbmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBkcmFnQ29vcmRpbmF0b3IudG9KU09OKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNvdXJjZSBjb2RlIG9mIGEgbWV0aG9kIG9uIGEgY2xhc3MgcHJvdG90eXBlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNsYXNzTmFtZSAgVGhlIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtzdWNjZXNzOiBCb29sZWFuLCBzb3VyY2U/OiBTdHJpbmcsIGVycm9yPzogU3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1ldGhvZFNvdXJjZSh7Y2xhc3NOYW1lLCBtZXRob2ROYW1lfSkge1xuICAgICAgICBjb25zdCBjbHMgPSBOZW8ubnMoY2xhc3NOYW1lKTtcblxuICAgICAgICBpZiAoIWNscykge1xuICAgICAgICAgICAgcmV0dXJuIHtzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBDbGFzcyAnJHtjbGFzc05hbWV9JyBub3QgZm91bmRgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IE5lby50eXBlT2YoY2xzKTtcbiAgICAgICAgbGV0IHByb3RvO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnTmVvQ2xhc3MnKSB7XG4gICAgICAgICAgICBwcm90byA9IGNscy5wcm90b3R5cGVcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICBwcm90byA9IGNscy5jb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7c3VjY2VzczogZmFsc2UsIGVycm9yOiBgVGFyZ2V0ICcke2NsYXNzTmFtZX0nIGlzIG5vdCBhIE5lbyBjbGFzcyBvciBpbnN0YW5jZWB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHByb3RvW21ldGhvZE5hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYE1ldGhvZCAnJHttZXRob2ROYW1lfScgbm90IGZvdW5kIG9uICcke2NsYXNzTmFtZX0nYH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgc291cmNlIDogcHJvdG9bbWV0aG9kTmFtZV0udG9TdHJpbmcoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBsb2FkZWQgbmFtZXNwYWNlIHRyZWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnJvb3Q9J05lbyddIFRoZSByb290IG5hbWVzcGFjZSB0byBzdGFydCBmcm9tIChlLmcuLCAnTmVvJywgJ015QXBwJykuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXROYW1lc3BhY2VUcmVlKHtyb290PSdOZW8nfSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IE5lby5ucyhyb290KSxcbiAgICAgICAgICAgIHRyZWUgICAgICA9IHt9O1xuXG4gICAgICAgIGlmICghc3RhcnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3RyZWU6IHt9LCBlcnJvcjogYE5hbWVzcGFjZSAnJHtyb290fScgbm90IGZvdW5kYH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLiN0cmF2ZXJzZU5hbWVzcGFjZShzdGFydE5vZGUsIHJvb3QsIHRyZWUpO1xuXG4gICAgICAgIHJldHVybiB7cm9vdCwgdHJlZX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMud2luZG93SWRdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXROZW9Db25maWcoe3dpbmRvd0lkfSkge1xuICAgICAgICBpZiAod2luZG93SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBOZW8ud2luZG93Q29uZmlncz8uW3dpbmRvd0lkXSB8fCBudWxsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5lby5jb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMud2luZG93SWRdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSb3V0ZUhpc3Rvcnkoe3dpbmRvd0lkfSkge1xuICAgICAgICBjb25zdCBzdGFjayA9IEhhc2hIaXN0b3J5LmdldFN0YWNrKHdpbmRvd0lkKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY291bnQgICA6IHN0YWNrLmxlbmd0aCxcbiAgICAgICAgICAgIGhpc3RvcnkgOiBzdGFjayxcbiAgICAgICAgICAgIHdpbmRvd0lkOiB3aW5kb3dJZCB8fCBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRXaW5kb3dJbmZvKHBhcmFtcykge1xuICAgICAgICBjb25zdCB3aW5kb3dNYW5hZ2VyID0gTmVvLm1hbmFnZXI/LldpbmRvdztcblxuICAgICAgICBpZiAod2luZG93TWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd01hbmFnZXIudG9KU09OKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7d2luZG93czogW119O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3BlY3RzIGEgY2xhc3MgdG8gcmV0cmlldmUgaXRzIGZ1bGwgc2NoZW1hIChjb25maWdzLCBtZXRob2RzLCBoaWVyYXJjaHkpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNsYXNzTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmRldGFpbD0nc3RhbmRhcmQnXSAnc3RhbmRhcmQnIHwgJ2NvbXBhY3QnXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBpbnNwZWN0Q2xhc3Moe2NsYXNzTmFtZSwgZGV0YWlsPSdzdGFuZGFyZCd9KSB7XG4gICAgICAgIGNvbnN0IGNscyA9IE5lby5ucyhjbGFzc05hbWUpO1xuXG4gICAgICAgIGlmICghY2xzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsYXNzIG5vdCBmb3VuZDogJHtjbGFzc05hbWV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBpc0NsYXNzID0gY2xzLmlzQ2xhc3MsXG4gICAgICAgICAgICBjdG9yICAgID0gaXNDbGFzcyA/IGNscyA6IGNscy5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIHByb3RvICAgPSBjdG9yLnByb3RvdHlwZTtcblxuICAgICAgICAvLyAxLiBIaWVyYXJjaHkgJiBNaXhpbnNcbiAgICAgICAgY29uc3QgZ2V0TWl4aW5OYW1lcyA9IChvYmopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKG9iaikuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKHZhbHVlLnByb3RvdHlwZS5jbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKC4uLmdldE1peGluTmFtZXModmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lc1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDIuIENvbmZpZ3MgJiBNZXRob2RzXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBjb25maWdzICAgICAgICA9IHt9LFxuICAgICAgICAgICAgbWV0aG9kcyAgICAgICAgPSBuZXcgU2V0KCksXG4gICAgICAgICAgICBjb25maWdLZXlzICAgICA9IG5ldyBTZXQoT2JqZWN0LmtleXMoY3Rvci5jb25maWcpKSxcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzICAgID0gY3Rvci5jb25maWdEZXNjcmlwdG9ycyB8fCB7fSxcbiAgICAgICAgICAgIGlnbm9yZWRQcm9wcyAgID0gWydjb25zdHJ1Y3RvcicsICdjb25zdHJ1Y3QnLCAnaW5pdCcsICdvbkNvbnN0cnVjdGVkJywgJ29uQWZ0ZXJDb25zdHJ1Y3RlZCddLFxuICAgICAgICAgICAgaG9va1JlZ2V4ICAgICAgPSAvXihiZWZvcmV8YWZ0ZXIpKEdldHxTZXQpKFtBLVpdKS8sXG4gICAgICAgICAgICAvLyBIZWxwZXIgdG8gZ2V0IHJhdyBob29rIG5hbWUgZnJvbSBjb25maWcga2V5XG4gICAgICAgICAgICBnZXRIb29rTmFtZSAgICA9IChwcmVmaXgsIGtleSkgPT4gcHJlZml4ICsga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBkZWZhdWx0IHZhbHVlcyBmaXJzdFxuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0gdGhpcy5zZXJpYWxpemVDb25maWcoY3Rvci5jb25maWcpO1xuXG4gICAgICAgIC8vIEdldCBzdXBlcmNsYXNzIGNvbmZpZyBmb3IgY29tcGFyaXNvbiBpbiBjb21wYWN0IG1vZGVcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHN1cGVyQ3RvciAgID0gY3Rvci5fX3Byb3RvX18sXG4gICAgICAgICAgICBzdXBlckNvbmZpZyA9IHN1cGVyQ3Rvcj8uY29uZmlnIHx8IHt9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgQ29uZmlnc1xuICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAvLyBJbiBjb21wYWN0IG1vZGUsIG9ubHkgaW5jbHVkZSBjb25maWdzIHRoYXQgYXJlIFwib3duXCIgKG5vdCBpbiBzdXBlciBvciBjaGFuZ2VkKVxuICAgICAgICAgICAgaWYgKGRldGFpbCA9PT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPd24gPSAhT2JqZWN0Lmhhc093bihzdXBlckNvbmZpZywga2V5KSB8fCBzdXBlckNvbmZpZ1trZXldICE9PSBjdG9yLmNvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgIGlmICghaXNPd24pIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWdzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZmF1bHRWYWx1ZXNba2V5XVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQWRkIERlc2NyaXB0b3IgaW5mbyBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yc1trZXldKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnc1trZXldLm1ldGEgPSB0aGlzLnNlcmlhbGl6ZUNvbmZpZyhkZXNjcmlwdG9yc1trZXldKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgSG9va3NcbiAgICAgICAgICAgIGNvbnN0IGhvb2tzID0gW107XG4gICAgICAgICAgICBbJ2JlZm9yZUdldCcsICdiZWZvcmVTZXQnLCAnYWZ0ZXJTZXQnXS5mb3JFYWNoKHByZWZpeCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9va05hbWUgPSBnZXRIb29rTmFtZShwcmVmaXgsIGtleSk7XG4gICAgICAgICAgICAgICAgLy8gSW4gY29tcGFjdCBtb2RlLCBvbmx5IGNoZWNrIGZvciBob29rcyBvbiB0aGUgY3VycmVudCBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWlsID09PSAnY29tcGFjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24ocHJvdG8sIGhvb2tOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3MucHVzaChwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3RvW2hvb2tOYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3MucHVzaChwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGhvb2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25maWdzW2tleV0uaG9va3MgPSBob29rc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQcm9jZXNzIE1ldGhvZHNcbiAgICAgICAgbGV0IGN1cnJlbnRQcm90byA9IHByb3RvO1xuXG4gICAgICAgIC8vIFRyYXZlcnNlIHVwIHRvIE5lby5jb3JlLkJhc2VcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQcm90byAmJiBjdXJyZW50UHJvdG8uY29uc3RydWN0b3IuY2xhc3NOYW1lICE9PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VycmVudFByb3RvKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIWNvbmZpZ0tleXMuaGFzKG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICFpZ25vcmVkUHJvcHMuaW5jbHVkZXMobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIW5hbWUuc3RhcnRzV2l0aCgnXycpICYmXG4gICAgICAgICAgICAgICAgICAgICFuYW1lLnN0YXJ0c1dpdGgoJyMnKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgaG9va1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob29rTWF0Y2ggPSBuYW1lLm1hdGNoKGhvb2tSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob29rTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgaG9vay4gV2Ugb25seSBjYXJlIGlmIGl0IHdhc24ndCBhbHJlYWR5IGNhdWdodCBieSB0aGUgY29uZmlnIGxvb3AuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgc2luY2Ugd2Ugd2FudCBhIGNsZWFuIG1ldGhvZCBsaXN0LCB3ZSBnZW5lcmFsbHkgZXhjbHVkZSBob29rcyBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbmZpZyBsb29wIGFib3ZlIGNhcHR1cmVzIGhvb2tzICphc3NvY2lhdGVkIHdpdGgga25vd24gY29uZmlncyouXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcnBoYW5lZCBob29rcyAoZm9yIG5vbi1leGlzdGVudCBjb25maWdzPykgYXJlIHJhcmUvaW52YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN1cnJlbnRQcm90bywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzLmFkZChuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEluIGNvbXBhY3QgbW9kZSwgd2Ugb25seSBsb29rIGF0IHRoZSB0b3AtbGV2ZWwgcHJvdG90eXBlXG4gICAgICAgICAgICBpZiAoZGV0YWlsID09PSAnY29tcGFjdCcpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50UHJvdG8gPSBjdXJyZW50UHJvdG8uX19wcm90b19fXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xhc3NOYW1lIDogcHJvdG8uY2xhc3NOYW1lLFxuICAgICAgICAgICAgbnR5cGUgICAgIDogcHJvdG8ubnR5cGUsXG4gICAgICAgICAgICBudHlwZUNoYWluOiBjdG9yLm50eXBlQ2hhaW4sXG4gICAgICAgICAgICBzdXBlckNsYXNzOiBwcm90by5fX3Byb3RvX18/LmNvbnN0cnVjdG9yPy5jb25maWc/LmNsYXNzTmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgbWl4aW5zICAgIDogcHJvdG8ubWl4aW5zID8gZ2V0TWl4aW5OYW1lcyhwcm90by5taXhpbnMpIDogW10sXG4gICAgICAgICAgICBjb25maWdzLFxuICAgICAgICAgICAgbWV0aG9kcyAgIDogQXJyYXkuZnJvbShtZXRob2RzKS5zb3J0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGEgbWV0aG9kIGltcGxlbWVudGF0aW9uIG9uIGEgY2xhc3MgcHJvdG90eXBlIGF0IHJ1bnRpbWUuXG4gICAgICogUkVTVFJJQ1RFRDogUmVxdWlyZXMgTmVvLmNvbmZpZy5lbmFibGVIb3RQYXRjaGluZyA9IHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5jbGFzc05hbWUgIFRoZSBmdWxseSBxdWFsaWZpZWQgY2xhc3MgbmFtZSAoZS5nLiwgJ05lby5idXR0b24uQmFzZScpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5tZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gcGF0Y2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnNvdXJjZSAgICAgVGhlIG5ldyBmdW5jdGlvbiBzb3VyY2UgY29kZSAoZS5nLiwgJ2Z1bmN0aW9uKGFyZ3MpIHsgLi4uIH0nIG9yICdhc3luYyAoYXJncykgPT4geyAuLi4gfScpXG4gICAgICogQHJldHVybnMge09iamVjdH0ge3N1Y2Nlc3M6IEJvb2xlYW4sIGVycm9yPzogU3RyaW5nfVxuICAgICAqL1xuICAgIHBhdGNoQ29kZSh7Y2xhc3NOYW1lLCBtZXRob2ROYW1lLCBzb3VyY2V9KSB7XG4gICAgICAgIGlmIChOZW8uY29uZmlnLmVuYWJsZUhvdFBhdGNoaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yICA6ICdIb3QgcGF0Y2hpbmcgaXMgZGlzYWJsZWQuIFNldCBOZW8uY29uZmlnLmVuYWJsZUhvdFBhdGNoaW5nID0gdHJ1ZSB0byBlbmFibGUuJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xzID0gTmVvLm5zKGNsYXNzTmFtZSk7XG5cbiAgICAgICAgaWYgKCFjbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3IgIDogYENsYXNzICcke2NsYXNzTmFtZX0nIG5vdCBmb3VuZGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2xzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvciAgOiBgQ2xhc3MgJyR7Y2xhc3NOYW1lfScgaGFzIG5vIHByb3RvdHlwZSAoaXMgaXQgYSBzaW5nbGV0b24/KWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2UgbmV3IEZ1bmN0aW9uIHRvIHBhcnNlIHRoZSBzb3VyY2UgY29kZSBzYWZlbHkgaW50byBhIGZ1bmN0aW9uIG9iamVjdC5cbiAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIGRpcmVjdCB1c2Ugb2YgZXZhbCgpIGFuZCBlbnN1cmVzIHRoZSBjb2RlIHJ1bnMgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgICAgICAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgc291cmNlKSgpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yICA6ICdTb3VyY2UgZGlkIG5vdCBldmFsdWF0ZSB0byBhIGZ1bmN0aW9uJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMS4gTG9nIHRoZSBwYXRjaCBmb3IgYXVkaXRcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW05lby5haS5jbGllbnQuUnVudGltZVNlcnZpY2VdIEhvdC1wYXRjaGluZyAke2NsYXNzTmFtZX0ucHJvdG90eXBlLiR7bWV0aG9kTmFtZX1gKTtcblxuICAgICAgICAgICAgLy8gMi4gQXBwbHkgdGhlIHBhdGNoXG4gICAgICAgICAgICBjbHMucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZm47XG5cbiAgICAgICAgICAgIC8vIDMuIE1hcmsgbWV0aG9kIGFzIHBhdGNoZWQgKHVzZWZ1bCBmb3IgZGVidWdnaW5nKVxuICAgICAgICAgICAgZm4uJGlzUGF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICBmbi4kb3JpZ2luYWxTb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7c3VjY2VzczogdHJ1ZX1cblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTmVvLmFpLmNsaWVudC5SdW50aW1lU2VydmljZV0gSG90IHBhdGNoIGZhaWxlZDonLCBlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3IgIDogZS5tZXNzYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICByZWxvYWRQYWdlKHBhcmFtcykge1xuICAgICAgICBOZW8uTWFpbi5yZWxvYWRXaW5kb3coKTtcbiAgICAgICAgcmV0dXJuIHtzdGF0dXM6ICdyZWxvYWRpbmcnfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5jb25maWdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNldE5lb0NvbmZpZyh7Y29uZmlnfSkge1xuICAgICAgICBOZW8uc2V0R2xvYmFsQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB7c3RhdHVzOiAnb2snfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmhhc2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy53aW5kb3dJZF1cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHNldFJvdXRlKHtoYXNoLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgTmVvLk1haW4uc2V0Um91dGUoe1xuICAgICAgICAgICAgdmFsdWU6IGhhc2gsXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge3N0YXR1czogJ29rJywgaGFzaH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dFxuICAgICAqL1xuICAgICN0cmF2ZXJzZU5hbWVzcGFjZShub2RlLCBwYXRoLCBvdXRwdXQpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9kZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IG5vZGVba2V5XSxcbiAgICAgICAgICAgICAgICB0eXBlICAgICAgICA9IE5lby50eXBlT2YodmFsdWUpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoID0gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnTmVvQ2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgICAgIDogJ2NsYXNzJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB2YWx1ZS5wcm90b3R5cGUuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgICAgIDogJ3NpbmdsZXRvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdmFsdWUuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgdHJhdmVyc2UgcGxhaW4gb2JqZWN0cyAobmFtZXNwYWNlcylcbiAgICAgICAgICAgICAgICAvLyBOZW8udHlwZU9mIHJldHVybnMgJ09iamVjdCcgZm9yIHBsYWluIG9iamVjdHNcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuI3RyYXZlcnNlTmFtZXNwYWNlKHZhbHVlLCBjdXJyZW50UGF0aCwgb3V0cHV0W2tleV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZW1wdHkgcGFja2FnZXNcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob3V0cHV0W2tleV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3V0cHV0W2tleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhSdW50aW1lU2VydmljZSk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBOZXVyYWwgTGluayBDbGllbnQgU2VydmljZXMuXG4gKiBAY2xhc3MgTmVvLmFpLmNsaWVudC5TZXJ2aWNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFNlcnZpY2UgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5haS5jbGllbnQuU2VydmljZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmFpLmNsaWVudC5TZXJ2aWNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5haS5DbGllbnR8bnVsbH0gY2xpZW50PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xpZW50OiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNhZmVTZXJpYWxpemUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IE5lby50eXBlT2YodmFsdWUpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gdGhpcy5zYWZlU2VyaWFsaXplKHYpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKHYgPT4gdGhpcy5zYWZlU2VyaWFsaXplKHYpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTZXJ2aWNlKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IHtjcmVhdGVJbnRlcmNlcHRvcn0gZnJvbSAnLi4vLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICAgICAgZnJvbSAnLi4vLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLmNvbm5lY3Rpb24uV2ViU29ja2V0XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGF0YS5jb25uZWN0aW9uLldlYlNvY2tldCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhdGEuY29ubmVjdGlvbi5XZWJTb2NrZXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc29ja2V0LWNvbm5lY3Rpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc29ja2V0LWNvbm5lY3Rpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259IGJhY2tvZmZTdHJhdGVneT1hdHRlbXB0PT5NYXRoLm1pbigxMDAwKk1hdGgucG93KDIsYXR0ZW1wdC0xKSwzMDAwMClcbiAgICAgICAgICovXG4gICAgICAgIGJhY2tvZmZTdHJhdGVneTogYXR0ZW1wdCA9PiBNYXRoLm1pbigxMDAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpLCAzMDAwMCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJTb2NrZXR8bnVsbH0gc29ja2V0Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzb2NrZXRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNoYW5uZWw9bnVsbFxuICAgICAqL1xuICAgIGNoYW5uZWwgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhSZWNvbm5lY3RBdHRlbXB0cz01XG4gICAgICovXG4gICAgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSA1XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtZXNzYWdlQ2FsbGJhY2tzPXt9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1lc3NhZ2VDYWxsYmFja3MgPSB7fVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gbWVzc2FnZUlkPTFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbWVzc2FnZUlkID0gMVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcn0gcmVjb25uZWN0QXR0ZW1wdHM9MFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZWNvbm5lY3RBdHRlbXB0cyA9IDBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc2VydmVyQWRkcmVzcz1udWxsXG4gICAgICovXG4gICAgc2VydmVyQWRkcmVzcyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNvY2tldCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAgICAgKi9cbiAgICBhc3luYyBhdHRlbXB0UmVjb25uZWN0KGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnJlY29ubmVjdEF0dGVtcHRzKys7XG5cbiAgICAgICAgaWYgKG1lLnJlY29ubmVjdEF0dGVtcHRzIDwgbWUubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gbWUuYmFja29mZlN0cmF0ZWd5KG1lLnJlY29ubmVjdEF0dGVtcHRzKTtcblxuICAgICAgICAgICAgbWUuZmlyZSgncmVjb25uZWN0aW5nJywge1xuICAgICAgICAgICAgICAgIGF0dGVtcHQgICAgOiBtZS5yZWNvbm5lY3RBdHRlbXB0cyxcbiAgICAgICAgICAgICAgICBtYXhBdHRlbXB0czogbWUubWF4UmVjb25uZWN0QXR0ZW1wdHMsXG4gICAgICAgICAgICAgICAgZGVsYXlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgV2ViU29ja2V0IHJlY29ubmVjdCBhdHRlbXB0ICR7bWUucmVjb25uZWN0QXR0ZW1wdHN9LyR7bWUubWF4UmVjb25uZWN0QXR0ZW1wdHN9IGluICR7ZGVsYXl9bXNgKTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dChkZWxheSk7XG5cbiAgICAgICAgICAgIGlmICghbWUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVTb2NrZXQoKTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIG1lLm9uKCdvcGVuJywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgOiBzY29wZSB8fCBtZSxcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVhY2hlZCcpO1xuICAgICAgICAgICAgbWUuZmlyZSgncmVjb25uZWN0X2ZhaWxlZCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcmNlcHRzIHRoZSBXZWJTb2NrZXQgc2VuZCBjYWxsc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBiZWZvcmVTZW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2hhbm5lbH0gPSBtZTtcblxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY2hhbm5lbCA/IHtjaGFubmVsLCBkYXRhfSA6IGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc29ja2V0IGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtXZWJTb2NrZXR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtXZWJTb2NrZXR8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U29ja2V0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWUsIHtcbiAgICAgICAgICAgICAgICBvbmNsb3NlICA6IG1lLm9uQ2xvc2UgIC5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbmVycm9yICA6IG1lLm9uRXJyb3IgIC5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbm1lc3NhZ2U6IG1lLm9uTWVzc2FnZS5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBvbm9wZW4gICA6IG1lLm9uT3BlbiAgIC5iaW5kKG1lKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNyZWF0ZUludGVyY2VwdG9yKHZhbHVlLCAnc2VuZCcsIG1lLmJlZm9yZVNlbmQsIG1lKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBkZWZhdWx0cyB0byAxMDAwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtyZWFzb25dXG4gICAgICovXG4gICAgY2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZVNvY2tldCgpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMuc2VydmVyQWRkcmVzcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nsb3NlRXZlbnR9IGV2ZW50IFRoZSBXZWJzb2NrZXQgZ2VuZXJhdGVkIENsb3NlRXZlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgIGV2ZW50LmNvZGUgVGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlIGNvZGUgcHJvdmlkZWQgYnkgdGhlIHNlcnZlclxuICAgICAqXG4gICAgICogICAgICAgIENvZGUgICAgICAgIE5hbWUgICAgICAgICAgICAgICAgICBEZXNjcmlwdGlvblxuICAgICAqICAgICAgICAwLTk5OSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgYW5kIG5vdCB1c2VkLlxuICAgICAqICAgICAgICAxMDAwICAgICAgICBDTE9TRV9OT1JNQUwgICAgICAgICAgTm9ybWFsIGNsb3N1cmU7IHRoZSBjb25uZWN0aW9uIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgd2hhdGV2ZXIgcHVycG9zZSBmb3Igd2hpY2ggaXQgd2FzIGNyZWF0ZWQuXG4gICAgICogICAgICAgIDEwMDEgICAgICAgIENMT1NFX0dPSU5HX0FXQVkgICAgICBUaGUgZW5kcG9pbnQgaXMgZ29pbmcgYXdheSwgZWl0aGVyIGJlY2F1c2Ugb2YgYSBzZXJ2ZXIgZmFpbHVyZSBvciBiZWNhdXNlIHRoZSBicm93c2VyIGlzIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlIHRoYXQgb3BlbmVkIHRoZSBjb25uZWN0aW9uLlxuICAgICAqICAgICAgICAxMDAyICAgICAgICBDTE9TRV9QUk9UT0NPTF9FUlJPUiAgVGhlIGVuZHBvaW50IGlzIHRlcm1pbmF0aW5nIHRoZSBjb25uZWN0aW9uIGR1ZSB0byBhIHByb3RvY29sIGVycm9yLlxuICAgICAqICAgICAgICAxMDAzICAgICAgICBDTE9TRV9VTlNVUFBPUlRFRCAgICAgVGhlIGNvbm5lY3Rpb24gaXMgYmVpbmcgdGVybWluYXRlZCBiZWNhdXNlIHRoZSBlbmRwb2ludCByZWNlaXZlZCBkYXRhIG9mIGEgdHlwZSBpdCBjYW5ub3QgYWNjZXB0IChmb3IgZXhhbXBsZSwgYSB0ZXh0LW9ubHkgZW5kcG9pbnQgcmVjZWl2ZWQgYmluYXJ5IGRhdGEpLlxuICAgICAqICAgICAgICAxMDA0ICAgICAgICBDTE9TRV9UT09fTEFSR0UgICAgICAgVGhlIGVuZHBvaW50IGlzIHRlcm1pbmF0aW5nIHRoZSBjb25uZWN0aW9uIGJlY2F1c2UgYSBkYXRhIGZyYW1lIHdhcyByZWNlaXZlZCB0aGF0IGlzIHRvbyBsYXJnZS5cbiAgICAgKiAgICAgICAgMTAwNSAgICAgICAgQ0xPU0VfTk9fU1RBVFVTICAgICAgIFJlc2VydmVkLiAgSW5kaWNhdGVzIHRoYXQgbm8gc3RhdHVzIGNvZGUgd2FzIHByb3ZpZGVkIGV2ZW4gdGhvdWdoIG9uZSB3YXMgZXhwZWN0ZWQuXG4gICAgICogICAgICAgIDEwMDYgICAgICAgIENMT1NFX0FCTk9STUFMICAgICAgICBSZXNlcnZlZC4gVXNlZCB0byBpbmRpY2F0ZSB0aGF0IGEgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFibm9ybWFsbHkgKHRoYXQgaXMsIHdpdGggbm8gY2xvc2UgZnJhbWUgYmVpbmcgc2VudCkgd2hlbiBhIHN0YXR1cyBjb2RlIGlzIGV4cGVjdGVkLlxuICAgICAqICAgICAgICAxMDA3LTE5OTkgICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgYnkgdGhlIFdlYlNvY2tldCBzdGFuZGFyZC5cbiAgICAgKiAgICAgICAgMjAwMC0yOTk5ICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2VydmVkIGZvciB1c2UgYnkgV2ViU29ja2V0IGV4dGVuc2lvbnMuXG4gICAgICogICAgICAgIDMwMDAtMzk5OSAgICAgICAgICAgICAgICAgICAgICAgICBBdmFpbGFibGUgZm9yIHVzZSBieSBsaWJyYXJpZXMgYW5kIGZyYW1ld29ya3MuIE1heSBub3QgYmUgdXNlZCBieSBhcHBsaWNhdGlvbnMuXG4gICAgICogICAgICAgIDQwMDAtNDk5OSAgICAgICAgICAgICAgICAgICAgICAgICBBdmFpbGFibGUgZm9yIHVzZSBieSBhcHBsaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgIHJlYXNvbiBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSByZWFzb24gdGhlIHNlcnZlciBjbG9zZWQgdGhlIGNvbm5lY3Rpb24uIFRoaXMgaXMgc3BlY2lmaWMgdG8gdGhlIHBhcnRpY3VsYXIgc2VydmVyIGFuZCBzdWItcHJvdG9jb2wuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICB3YXNDbGVhbiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkLlxuICAgICAqL1xuICAgIG9uQ2xvc2UoZXZlbnQsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgICAgICAgdGhpcy5maXJlKCdjbG9zZScsIHtldmVudCwgcmVhc29uLCB3YXNDbGVhbn0pO1xuXG4gICAgICAgIC8vIEF1dG8tcmVjb25uZWN0IG9uIGFibm9ybWFsIGNsb3N1cmVcbiAgICAgICAgaWYgKCF3YXNDbGVhbiB8fCBldmVudC5jb2RlICE9PSAxMDAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYlNvY2tldCBjbG9zZWQgYWJub3JtYWxseSwgYXR0ZW1wdGluZyByZWNvbm5lY3QuLi4nKTtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcn0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuXG4gICAgICAgIG1lLmZpcmUoJ21lc3NhZ2UnLCB7ZGF0YX0pO1xuXG4gICAgICAgIGlmIChkYXRhLm1JZCkge1xuICAgICAgICAgICAgbWUubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1JZF0ucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIG1lLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tSWRdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMuZmlyZSgnb3BlbicsIHtzY29wZTogdGhpc30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHByb21pc2VNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWUubWVzc2FnZUNhbGxiYWNrc1ttZS5tZXNzYWdlSWRdID0ge3JlamVjdCwgcmVzb2x2ZX07XG5cbiAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKHtkYXRhLCBtSWQ6IG1lLm1lc3NhZ2VJZH0pO1xuICAgICAgICAgICAgbWUubWVzc2FnZUlkKytcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzb2NrZXR9ID0gbWUsXG4gICAgICAgICAgICBkICAgICAgICA9IGRhdGE7XG5cbiAgICAgICAgLy8gQ09OTkVDVElORyAgMCAgIFRoZSBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgb3Blbi5cbiAgICAgICAgLy8gT1BFTiAgICAgICAgMSAgIFRoZSBjb25uZWN0aW9uIGlzIG9wZW4gYW5kIHJlYWR5IHRvIGNvbW11bmljYXRlLlxuICAgICAgICAvLyBDTE9TSU5HICAgICAyICAgVGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZy5cbiAgICAgICAgLy8gQ0xPU0VEICAgICAgMyAgIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCBvciBjb3VsZG4ndCBiZSBvcGVuZWQuXG5cbiAgICAgICAgLy8gSWYgc29ja2V0IGlzIG5vdCB5ZXQgcmVhZHkgbGV0J3MgZGVmZXIgdG8gb3BlbiB0aGVuIHJlc2VuZFxuICAgICAgICBzd2l0Y2ggKHNvY2tldC5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DTE9TRUQ6XG4gICAgICAgICAgICBjYXNlIFdlYlNvY2tldC5DTE9TSU5HOlxuICAgICAgICAgICAgICAgIG1lLmF0dGVtcHRSZWNvbm5lY3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNlbmRNZXNzYWdlKGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuQ09OTkVDVElORzpcbiAgICAgICAgICAgICAgICBtZS5vbignb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZW5kTWVzc2FnZShkKVxuICAgICAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXZWJTb2NrZXQuT1BFTjpcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU29ja2V0KTtcbiIsImltcG9ydCBNYW5hZ2VyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5TdG9yZVxuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBTdG9yZSBleHRlbmRzIE1hbmFnZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuU3RvcmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLlN0b3JlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxpYXMgTmVvLmdldFN0b3JlIHRvIHRoaXMgbWFuYWdlcj9cbiAgICAgICAgLy8gTmVvLmdldFN0b3JlID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFN0b3JlKTtcbiIsImltcG9ydCBNYW5hZ2VyICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4uL3V0aWwvUmVjdGFuZ2xlLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIFwiR29kIFZpZXdcIiBmb3IgdGhlIG11bHRpLXdpbmRvdyBhcHBsaWNhdGlvbiB3b3Jrc3BhY2UuXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBtYW5hZ2VyIG1haW50YWlucyBhIHJlYWwtdGltZSBnZW9tZXRyaWMgbWFwIG9mIGFsbCBjb25uZWN0ZWQgYnJvd3NlciB3aW5kb3dzIGluIHRoZSBBcHAgV29ya2VyLlxuICogSXQgaXMgdGhlIGNlbnRyYWwgYXV0aG9yaXR5IGZvciBzcGF0aWFsIGF3YXJlbmVzcywgZW5hYmxpbmcgZmVhdHVyZXMgbGlrZSB0aGUgXCJJbmZpbml0ZSBDYW52YXNcIiB3aGVyZVxuICogaW50ZXJhY3Rpb25zIChsaWtlIERyYWcgJiBEcm9wKSBjYW4gc3BhbiBhY3Jvc3MgbXVsdGlwbGUgT1MtbGV2ZWwgd2luZG93cy5cbiAqXG4gKiBJdCByZWNlaXZlcyBoaWdoLWZyZXF1ZW5jeSBwb3NpdGlvbiB1cGRhdGVzIGZyb20gdGhlIE1haW4gVGhyZWFkICh2aWEgYE5lby5tYWluLmFkZG9uLldpbmRvd1Bvc2l0aW9uYClcbiAqIGFuZCBwcm92aWRlcyBpbnRlcnNlY3Rpb24gdGVzdGluZyBBUElzIHRvIGRldGVybWluZSB3aGljaCB3aW5kb3cgaXMgdW5kZXIgYSBnaXZlbiBzY3JlZW4gY29vcmRpbmF0ZS5cbiAqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuV2luZG93XG4gKiBAZXh0ZW5kcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKiBAc2VlIE5lby5tYWluLmFkZG9uLldpbmRvd1Bvc2l0aW9uXG4gKi9cbmNsYXNzIFdpbmRvdyBleHRlbmRzIE1hbmFnZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuV2luZG93J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5XaW5kb3cnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNTYWZhcmlcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNTYWZhcmk6IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uV2luZG93Q29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uV2luZG93RGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2luZG93SWQgd2hpY2ggaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBnbG9iYWwgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICAgICAqIFRoaXMgaXMgdGhlIGNvcmUgaW50ZXJzZWN0aW9uIHRlc3QgZm9yIGNyb3NzLXdpbmRvdyBkcmFnIGFuZCBkcm9wIG9wZXJhdGlvbnMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggU2NyZWVuIFggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFNjcmVlbiBZIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFRoZSB3aW5kb3dJZCBvZiB0aGUgdGFyZ2V0IHdpbmRvdywgb3IgbnVsbCBpZiBubyBpbnRlcnNlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0V2luZG93QXQoeCwgeSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ub3V0ZXJSZWN0Py5pbnRlcnNlY3RzKHtib3R0b206IHksIHJpZ2h0OiB4LCB4LCB5fSkpO1xuXG4gICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5pZCA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUdlb21ldHJ5KGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIHtpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgbW96SW5uZXJTY3JlZW5YLCBtb3pJbm5lclNjcmVlblksIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoLCBzY3JlZW5MZWZ0LCBzY3JlZW5Ub3B9ID0gZGF0YSxcbiAgICAgICAgICAgIHdpZHRoRGlmZiAgICA9IG91dGVyV2lkdGggIC0gaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodERpZmYgICA9IG91dGVySGVpZ2h0IC0gaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBTaWRlIGJvcmRlcnMgYXJlIHN5bW1ldHJpY1xuICAgICAgICAgICAgc2lkZUJvcmRlciAgID0gd2lkdGhEaWZmIC8gMixcbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IEJvdHRvbSBib3JkZXIgbWF0Y2hlcyBzaWRlIGJvcmRlciAoY29tbW9uIGluIFdpbmRvd3MpXG4gICAgICAgICAgICBib3R0b21Cb3JkZXIgPSBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgLy8gVGhlIHJlc3QgaXMgdGhlIHRvcCBjaHJvbWUgKGhlYWRlcilcbiAgICAgICAgICAgIHRvcENocm9tZSAgICA9IGhlaWdodERpZmYgLSBib3R0b21Cb3JkZXI7XG5cbiAgICAgICAgY29uc3QgY2hyb21lID0ge1xuICAgICAgICAgICAgYm90dG9tOiBib3R0b21Cb3JkZXIsXG4gICAgICAgICAgICBsZWZ0ICA6IHNpZGVCb3JkZXIsXG4gICAgICAgICAgICByaWdodCA6IHNpZGVCb3JkZXIsXG4gICAgICAgICAgICB0b3AgICA6IHRvcENocm9tZVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCB2aWV3cG9ydExlZnQsIHZpZXdwb3J0VG9wO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbW96SW5uZXJTY3JlZW5YID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gRmlyZWZveDogZXhwbGljaXQgdmlld3BvcnQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IG1veklubmVyU2NyZWVuWDtcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICA9IG1veklubmVyU2NyZWVuWVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTYWZhcmkpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaTogc2NyZWVuTGVmdC9Ub3AgaXMgRnJhbWUgcG9zaXRpb24uIEFkZCBjaHJvbWUgdG8gZ2V0IFZpZXdwb3J0LlxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gc2NyZWVuTGVmdCArIHNpZGVCb3JkZXI7XG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgPSBzY3JlZW5Ub3AgICsgdG9wQ2hyb21lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUvRWRnZTogc2NyZWVuTGVmdC9Ub3AgaXMgVmlld3BvcnQgcG9zaXRpb24uXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSBzY3JlZW5MZWZ0O1xuICAgICAgICAgICAgdmlld3BvcnRUb3AgID0gc2NyZWVuVG9wXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbm5lclJlY3QgPSBuZXcgUmVjdGFuZ2xlKHZpZXdwb3J0TGVmdCwgdmlld3BvcnRUb3AsIGlubmVyV2lkdGgsIGlubmVySGVpZ2h0KTtcblxuICAgICAgICBjb25zdCBvdXRlclJlY3QgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0IC0gc2lkZUJvcmRlcixcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICAtIHRvcENocm9tZSxcbiAgICAgICAgICAgIG91dGVyV2lkdGgsXG4gICAgICAgICAgICBvdXRlckhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB7Y2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIG5ldyBicm93c2VyIHdpbmRvdyBjb25uZWN0cyB0byB0aGUgU2hhcmVkV29ya2VyLlxuICAgICAqIEluIFNoYXJlZCBXb3JrZXIgbW9kZSwgYE5lby53b3JrZXIuQXBwI29uQ29ubmVjdGAgZW5zdXJlcyB0aGF0IGB3aW5kb3dEYXRhYFxuICAgICAqIGlzIGZldGNoZWQgZnJvbSB0aGUgTWFpbiBUaHJlYWQgYW5kIGluY2x1ZGVkIGluIHRoZSBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YS53aW5kb3dEYXRhXSBDb250YWlucyBnZW9tZXRyeSBkYXRhIChzY3JlZW5MZWZ0LCBpbm5lckhlaWdodCwgZXRjLilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIG9uV2luZG93Q29ubmVjdCh7YXBwTmFtZSwgd2luZG93RGF0YSwgd2luZG93SWR9KSB7XG4gICAgICAgIGxldCBjaHJvbWUgICAgPSBudWxsLFxuICAgICAgICAgICAgaW5uZXJSZWN0ID0gbnVsbCxcbiAgICAgICAgICAgIG91dGVyUmVjdCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHdpbmRvd0RhdGEpIHtcbiAgICAgICAgICAgICh7Y2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH0gPSB0aGlzLmNhbGN1bGF0ZUdlb21ldHJ5KHdpbmRvd0RhdGEpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1dpbmRvdy5vbldpbmRvd0Nvbm5lY3QnLCB7d2luZG93SWQsIGFwcE5hbWUsIGNocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9KTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHthcHBOYW1lLCBjaHJvbWUsIGlkOiB3aW5kb3dJZCwgaW5uZXJSZWN0LCBvdXRlclJlY3R9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25XaW5kb3dEaXNjb25uZWN0KHt3aW5kb3dJZH0pIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKHdpbmRvd0lkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdlb21ldHJpYyBzdGF0ZSBvZiBhIHdpbmRvdyBiYXNlZCBvbiBkYXRhIGZyb20gdGhlIE1haW4gVGhyZWFkLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB2aWEgZGlyZWN0IGRlbGVnYXRpb24gZnJvbSB0aGUgQXBwIFdvcmtlciB0byBtaW5pbWl6ZSBvdmVyaGVhZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmlubmVySGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEub3V0ZXJIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vdXRlcldpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyZWVuTGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNjcmVlblRvcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25XaW5kb3dQb3NpdGlvbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5nZXQoZGF0YS53aW5kb3dJZCksXG4gICAgICAgICAgICB7Y2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH0gPSBtZS5jYWxjdWxhdGVHZW9tZXRyeShkYXRhKTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5jaHJvbWUgICAgPSBjaHJvbWU7XG4gICAgICAgICAgICBpdGVtLmlubmVyUmVjdCA9IGlubmVyUmVjdDtcbiAgICAgICAgICAgIGl0ZW0ub3V0ZXJSZWN0ID0gb3V0ZXJSZWN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgY2hyb21lLFxuICAgICAgICAgICAgICAgIGlkOiBkYXRhLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgIGlubmVyUmVjdCxcbiAgICAgICAgICAgICAgICBvdXRlclJlY3RcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jbGFzc05hbWUsXG4gICAgICAgICAgICB3aW5kb3dzICA6IHRoaXMuaXRlbXMubWFwKHdpbiA9PiAoe1xuICAgICAgICAgICAgICAgIGlkICAgICAgIDogd2luLmlkLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgIDogd2luLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY2hyb21lICAgOiB3aW4uY2hyb21lLFxuICAgICAgICAgICAgICAgIGlubmVyUmVjdDogd2luLmlubmVyUmVjdCxcbiAgICAgICAgICAgICAgICBvdXRlclJlY3Q6IHdpbi5vdXRlclJlY3RcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhXaW5kb3cpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEEgc2luZ2xldG9uIHV0aWxpdHkgY2xhc3MgcmVzcG9uc2libGUgZm9yIHJlY3Vyc2l2ZWx5IGJ1aWxkaW5nIFZET00gYW5kIFZOb2RlIHRyZWVzLlxuICogSXQgY2FuIGV4cGFuZCBjb21wb25lbnQgcmVmZXJlbmNlcyB3aXRoaW4gYSB0cmVlIHN0cnVjdHVyZSBpbnRvIHRoZWlyIGZ1bGwgVkRPTS9WTm9kZSByZXByZXNlbnRhdGlvbnMsXG4gKiBzdXBwb3J0aW5nIHNlbGVjdGl2ZSAoYXN5bW1ldHJpYykgdHJlZSBleHBhbnNpb24gZm9yIG9wdGltaXplZCB1cGRhdGVzLlxuICogQGNsYXNzIE5lby51dGlsLnZkb20uVHJlZUJ1aWxkZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgVHJlZUJ1aWxkZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLnZkb20uVHJlZUJ1aWxkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLnZkb20uVHJlZUJ1aWxkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBoZWxwZXIgdG8gcmVjdXJzaXZlbHkgYnVpbGQgYSB0cmVlLCBhYnN0cmFjdGluZyB0aGUgY2hpbGQgbm9kZSBrZXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgVGhlIHZkb20gb3Igdm5vZGUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVwdGggVGhlIGN1cnJlbnQgcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gbWVyZ2VkQ2hpbGRJZHMgQSBzZXQgb2YgY29tcG9uZW50IElEcyB0byBzZWxlY3RpdmVseSBleHBhbmQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkS2V5IFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBjaGlsZCBub2RlcyAoJ2NuJyBvciAnY2hpbGROb2RlcycpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjYnVpbGRUcmVlKG5vZGUsIGRlcHRoLCBtZXJnZWRDaGlsZElkcywgY2hpbGRLZXkpIHtcbiAgICAgICAgLy8gV2UgY2FuIG5vdCB1c2UgTmVvLmlzT2JqZWN0KCkgaGVyZSwgc2luY2UgaW5zaWRlIHVuaXQtdGVzdCBzY2VuYXJpb3MsIHdlIHdpbGwgaW1wb3J0IHZkb20uSGVscGVyIGludG8gbWFpbiB0aHJlYWRzLlxuICAgICAgICAvLyBJbnNpZGUgdGhpcyBzY2VuYXJpbywgTmVvLmlzT2JqZWN0KCkgcmV0dXJucyBmYWxzZSBmb3IgVk5vZGUgaW5zdGFuY2VzXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEpJVCBJRCBHZW5lcmF0aW9uIChBcHAgQXV0aG9yaXR5KVxuICAgICAgICAvLyBJZiB3ZSBhcmUgcHJvY2Vzc2luZyBhIFZET00gdHJlZSAoY2hpbGRLZXkgPT09ICdjbicpIGFuZCB0aGUgbm9kZSBoYXMgbm8gSUQsXG4gICAgICAgIC8vIHdlIG11c3QgZ2VuZXJhdGUgb25lIG5vdyB0byBlbnN1cmUgZGV0ZXJtaW5pc3RpYyBpZGVudGl0eSBiZWZvcmUgdGhlIFZET00gbGVhdmVzIHRoZSBBcHAgV29ya2VyLlxuICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICdjbicgJiYgIW5vZGUuaWQpIHtcbiAgICAgICAgICAgIG5vZGUuaWQgPSBOZW8uZ2V0SWQobm9kZS52dHlwZSA9PT0gJ3RleHQnID8gJ3Z0ZXh0JyA6ICd2bm9kZScpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0ID0gey4uLm5vZGV9OyAvLyBTaGFsbG93IGNvcHlcblxuICAgICAgICBpZiAobm9kZVtjaGlsZEtleV0pIHtcbiAgICAgICAgICAgIG91dHB1dFtjaGlsZEtleV0gPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGVbY2hpbGRLZXldLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gICAgICAgID0gbm9kZVtjaGlsZEtleV1baV0sXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGREZXB0aDtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SXRlbS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBDb21wb25lbnRNYW5hZ2VyLmdldChjdXJyZW50SXRlbS5jb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3BhcnNlIFRyZWUgR2VuZXJhdGlvbiAmIFNjb3BlZCBVcGRhdGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHBydW5lIHRoZSBicmFuY2ggKHNlbmQgYSBwbGFjZWhvbGRlcikgaWY6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIFdlIGFyZSBhdCB0aGUgZGVwdGggYm91bmRhcnkgKGRlcHRoID09PSAxKSBBTkQgaXQncyBub3QgYSBtZXJnZWQgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBXZSBhcmUgaW4gYSBNZXJnZWQgVXBkYXRlIChtZXJnZWRDaGlsZElkcyBleGlzdHMpIEFORCB0aGlzIGNvbXBvbmVudCBpcyBub3QgaW4gdGhlIEFsbG93TGlzdCAobm90IGRpcnR5L2JyaWRnZSkuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbjogV2UgbmV2ZXIgcHJ1bmUgaWYgZGVwdGggaXMgLTEgKEZ1bGwgVHJlZSkgb3IgaWYgdGhlIGNvbXBvbmVudCBpcyBub3QgbW91bnRlZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCAhPT0gLTEgJiYgY29tcG9uZW50Py52bm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFeHBhbmRhYmxlID0gbWVyZ2VkQ2hpbGRJZHM/LmhhcyhjdXJyZW50SXRlbS5jb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGVwdGggPT09IDEgJiYgIWlzRXhwYW5kYWJsZSkgfHwgKG1lcmdlZENoaWxkSWRzICYmICFpc0V4cGFuZGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2NoaWxkS2V5XS5wdXNoKHsuLi5jdXJyZW50SXRlbSwgbmVvSWdub3JlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgLy8gU3RvcCBwcm9jZXNzaW5nIHRoaXMgYnJhbmNoLCBtb3ZlIHRvIG5leHQgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwYW5kIHRoZSBicmFuY2ggaWYgaXQncyBwYXJ0IG9mIGEgbWVyZ2VkIHVwZGF0ZSwgb3IgaWYgdGhlIGRlcHRoIHJlcXVpcmVzIGl0LCBPUiBpZiB0aGUgdm5vZGUgaXMgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPiAxIHx8IGRlcHRoID09PSAtMSB8fCBtZXJnZWRDaGlsZElkcz8uaGFzKGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKSB8fCAhY29tcG9uZW50Py52bm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBjb3JyZWN0IHRyZWUgdHlwZSBiYXNlZCBvbiB0aGUgY2hpbGRLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFRyZWUgPSBjaGlsZEtleSA9PT0gJ2NuJyA/IGNvbXBvbmVudD8udmRvbSA6IGNvbXBvbmVudD8udm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50VHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gY29tcG9uZW50VHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGREZXB0aCA9IChkZXB0aCA9PT0gLTEpID8gLTEgOiBNYXRoLm1heCgwLCBkZXB0aCAtIDEpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGREZXB0aCA9IGRlcHRoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3V0cHV0W2NoaWxkS2V5XS5wdXNoKHRoaXMuI2J1aWxkVHJlZShjdXJyZW50SXRlbSwgY2hpbGREZXB0aCwgbWVyZ2VkQ2hpbGRJZHMsIGNoaWxkS2V5KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIGdpdmVuIHZkb20gdHJlZSBhbmQgcmVwbGFjZXMgY2hpbGQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aCB0aGVpciB2ZG9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZXB0aD0tMV1cbiAgICAgKiBAcGFyYW0ge1NldDxTdHJpbmc+fG51bGx9IFttZXJnZWRDaGlsZElkcz1udWxsXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmRvbVRyZWUodmRvbSwgZGVwdGg9LTEsIG1lcmdlZENoaWxkSWRzPW51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1aWxkVHJlZSh2ZG9tLCBkZXB0aCwgbWVyZ2VkQ2hpbGRJZHMsICdjbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgZ2l2ZW4gdm5vZGUgdHJlZSBhbmQgcmVwbGFjZXMgY2hpbGQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aCB0aGVpciB2bm9kZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoPS0xXVxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gW21lcmdlZENoaWxkSWRzPW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVRyZWUodm5vZGUsIGRlcHRoPS0xLCBtZXJnZWRDaGlsZElkcz1udWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNidWlsZFRyZWUodm5vZGUsIGRlcHRoLCBtZXJnZWRDaGlsZElkcywgJ2NoaWxkTm9kZXMnKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVHJlZUJ1aWxkZXIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9