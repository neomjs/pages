export const __webpack_esm_id__ = "vendors-apps_legit_app_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_legit_app_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/legit/app.mjs"
/*!****************************!*\
  !*** ./apps/legit/app.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/Viewport.mjs */ "./apps/legit/view/Viewport.mjs");


const onStart = () => Neo.app({
    mainView: _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Legit'
});

/***/ },

/***/ "./apps/legit/model/Commit.mjs"
/*!*************************************!*\
  !*** ./apps/legit/model/Commit.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Legit.model.Commit
 * @extends Neo.data.Model
 */
class Commit extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.model.Commit'
         * @protected
         */
        className: 'Legit.model.Commit',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'oid',
            type: 'String'
        }, {
            name: 'message',
            type: 'String'
        }, {
            name: 'author',
            type: 'Object'
        }, {
            name: 'timestamp',
            type: 'Integer'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Commit));


/***/ },

/***/ "./apps/legit/model/File.mjs"
/*!***********************************!*\
  !*** ./apps/legit/model/File.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Legit.model.File
 * @extends Neo.data.Model
 */
class File extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.model.File'
         * @protected
         */
        className: 'Legit.model.File',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'className',
            type: 'String'
        }, {
            name: 'collapsed',
            type: 'Boolean'
        }, {
            name: 'hidden',
            type: 'Boolean'
        }, {
            name: 'id',
            type: 'String'
        }, {
            name        : 'isLeaf',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name: 'name',
            type: 'String'
        }, {
            name: 'parentId',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(File));


/***/ },

/***/ "./apps/legit/service/Legit.mjs"
/*!**************************************!*\
  !*** ./apps/legit/service/Legit.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary A singleton service that provides a virtual file system layer for the Legit IDE.
 *
 * This service acts as the central hub for file system operations within the Legit application.
 * It abstracts the underlying storage mechanism (using `memfs`) and provides a git-like interface
 * for interacting with file trees and commits (using `@legit-sdk/core`).
 *
 * Key responsibilities include:
 * - **Initialization:** Dynamically loading external dependencies (`memfs`, `@legit-sdk/core`) to ensure the app remains lightweight until needed.
 * - **File System Seeding:** Populating the in-memory file system with initial demo content.
 * - **Git Operations:** Providing methods to load file trees (`loadTree`) and calculate deltas between commits (`loadTreeDelta`).
 * - **File I/O:** Exposing standard file system methods (`readFile`, `writeFile`, `readdir`, `stat`) that automatically await the service's ready state.
 *
 * This service is designed to be robust against initialization failures and provides a safe, asynchronous API for the `ViewportController` to consume.
 *
 * @class Legit.service.Legit
 * @extends Neo.core.Base
 * @singleton
 */
class Legit extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.service.Legit'
         * @protected
         */
        className: 'Legit.service.Legit',
        /**
         * @member {Object|null} fs=null
         */
        fs: null,
        /**
         * @member {Object|null} legitFs=null
         */
        legitFs: null,
        /**
         * @member {String} path='/.legit/branches/anonymous'
         */
        path: '/.legit/branches/anonymous',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Initializes the service by dynamically importing dependencies and setting up the file system.
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        const me = this;

        try {
            const {openLegitFs} = await import(/* webpackIgnore: true */ 'https://esm.sh/@legit-sdk/core');
            const fsModule      = await import(/* webpackIgnore: true */ 'https://esm.sh/memfs');

            me.fs = fsModule.default;

            me.legitFs = await openLegitFs({
                storageFs: me.fs,
                gitRoot  : '/',
                serverUrl: 'http://localhost:9999/',
                // publicKey: process.env.NEXT_PUBLIC_LEGIT_PUBLIC_KEY,
            });

            // For debugging
            globalThis.legitFs = me.legitFs;

            await me.#seedFileSystem();
        } catch (e) {
            console.error('Failed to initialize Legit Service', e);
        }
    }

    /**
     * Retrieves the commit history for a given branch.
     * @param {String} [branch='anonymous'] The branch name to load history for.
     * @returns {Promise<Object[]>} An array of commit objects.
     */
    async loadHistory(branch='anonymous') {
        await this.ready();

        try {
            const historyJson = await this.legitFs.readFile(`/.legit/branches/${branch}/.legit/history`, 'utf-8');
            return JSON.parse(historyJson);
        } catch (e) {
            console.warn(`Failed to load history for branch ${branch}`, e);
            return [];
        }
    }

    /**
     * Recursively loads the file tree structure from a given path.
     * @param {String} treePath The path to start loading the tree from.
     * @returns {Promise<{hash: string, subEntries: {}}>} The tree structure with hashes.
     */
    async loadTree(treePath) {
        await this.ready();

        const
            me         = this,
            subEntries = {},
            pathEntries = await me.readdir(treePath);

        for (const entryName of pathEntries) {
            const stat = await me.stat(treePath + entryName);

            if (stat.isDirectory()) {
                subEntries[entryName] = await me.loadTree(treePath + entryName + '/');
            } else {
                const contenHash = await crypto.subtle.digest("SHA-1", await me.readFile(treePath + entryName));

                subEntries[entryName] = {
                    // for now its the content instead of the hash
                    hash: contenHash,
                    name: entryName,
                };
            }
        }

        return {
            hash: '',
            subEntries
        }
    }

    /**
     * Calculates the difference between two tree states (commits).
     * Useful for identifying added, deleted, and modified files.
     * @param {String} currentState The hash or path of the current state.
     * @param {String} newState The hash or path of the new state.
     * @returns {Promise<{deleted: String[], added: String[], modified: String[]}>} An object containing arrays of changed file paths.
     */
    async loadTreeDelta(currentState, newState) {
        await this.ready();

        const me = this;

        const prefixNewState = newState.slice(0, 2);
        const suffixNewState = newState.slice(2);

        let currentstateTree = {}

        if (currentState) {
            const prefixCurrentState = currentState.slice(0, 2);
            const suffixCurrentState = currentState.slice(2);

            currentstateTree = await me.loadTree('/.legit/commits/' + prefixCurrentState + '/' + suffixCurrentState + '/');
        }
        const newStateTree = await me.loadTree('/.legit/commits/' + prefixNewState + '/' + suffixNewState + '/');

        const deleted  = [];
        const added    = [];
        const modified = [];

        function flattenTree(tree, path = '') {
            const result = {};

            if (tree.subEntries) {
                for (const [key, value] of Object.entries(tree.subEntries)) {
                    const currentPath = path ? `${path}/${key}` : key;

                    if (value.subEntries) {
                        Object.assign(result, flattenTree(value, currentPath));
                    } else {
                        result[currentPath] = value.hash;
                    }
                }
            }

            return result;
        }

        const currentStateFlat = currentState !== '' ? flattenTree(currentstateTree) : {};
        const newStateFlat     = flattenTree(newStateTree);

        // Find deleted (in current but not in new)
        for (const path in currentStateFlat) {
            if (!(path in newStateFlat)) {
                deleted.push(path);
            }
        }

        // Find added (in new but not in current)
        for (const path in newStateFlat) {
            if (!(path in currentStateFlat)) {
                added.push(path);
            }
        }

        // Find modified (in both but hash differs)
        for (const path in newStateFlat) {
            if (path in currentStateFlat) {
                const currentHash = new Uint8Array(currentStateFlat[path]);
                const newHash     = new Uint8Array(newStateFlat[path]);

                if (currentHash.length !== newHash.length ||
                    !currentHash.every((byte, i) => byte === newHash[i])) {
                    modified.push(path);
                }
            }
        }

        return {
            deleted,
            added,
            modified
        }
    }

    /**
     * Reads the content of a file.
     * @param {String} path The file path.
     * @param {Object} [options] Read options.
     * @returns {Promise<*>} The file content.
     */
    async readFile(path, options) {
        await this.ready();
        return this.legitFs.readFile(path, options)
    }

    /**
     * Reads the contents of a directory.
     * @param {String} path The directory path.
     * @returns {Promise<String[]>} An array of file names.
     */
    async readdir(path) {
        await this.ready();
        return this.legitFs.readdir(path)
    }

    /**
     * Seeds the in-memory file system with initial demo content.
     * This method bypasses the `ready()` check to avoid deadlocks during initialization.
     * @returns {Promise<void>}
     * @private
     */
    async #seedFileSystem() {
        const me = this;

        let mdFile = await fetch('../../learn/benefits/FormsEngine.md');
        mdFile = await mdFile.text();

        await me.writeFile({
            data     : mdFile,
            path     : `${me.path}/FormsEngine.md`,
            skipReady: true
        });

        mdFile = await fetch('../../learn/benefits/OffTheMainThread.md');
        mdFile = await mdFile.text();

        await me.writeFile({
            data     : mdFile,
            path     : `${me.path}/OffTheMainThread.md`,
            skipReady: true
        });

        await me.writeFile({
            data: [
                "import Viewport from '../../examples/component/multiWindowHelix/Viewport.mjs';",
                "",
                "class MainView extends Viewport {",
                "    static config = {",
                "        className           : 'Portal.view.MultiWindowHelix',",
                "        showGitHubStarButton: false,",
                "        theme               : 'neo-theme-dark'",
                "    }",
                "}",
                "",
                "MainView = Neo.setupClass(MainView);"
            ].join('\n'),
            path     : `${me.path}/Helix.mjs`,
            skipReady: true
        });

        await me.writeFile({
            data: [
                "import Viewport from '../../examples/component/multiWindowCoronaGallery/Viewport.mjs';",
                "",
                "class MainView extends Viewport {",
                "    static config = {",
                "        className           : 'Portal.view.MultiWindowHelix',",
                "        showGitHubStarButton: false,",
                "        theme               : 'neo-theme-dark'",
                "    }",
                "}",
                "",
                "MainView = Neo.setupClass(MainView);"
            ].join('\n'),
            path     : `${me.path}/Gallery.mjs`,
            skipReady: true
        });
    }

    /**
     * Retrieves file statistics.
     * @param {String} path The file or directory path.
     * @returns {Promise<Object>} The file statistics object.
     */
    async stat(path) {
        await this.ready();
        return this.legitFs.stat(path)
    }

    /**
     * Writes data to a file.
     * @param {Object}        config Configuration object.
     * @param {String|Buffer} config.data The data to write.
     * @param {Object}        [config.options] Write options.
     * @param {String}        config.path The file path.
     * @param {Boolean}       [config.skipReady=false] If true, bypasses the `await this.ready()` check.
     * @returns {Promise<*>}
     */
    async writeFile({data, options, path, skipReady=false}) {
        !skipReady && await this.ready();
        return this.legitFs.writeFile(path, data, options)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Legit));


/***/ },

/***/ "./apps/legit/store/Commits.mjs"
/*!**************************************!*\
  !*** ./apps/legit/store/Commits.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_Commit_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/Commit.mjs */ "./apps/legit/model/Commit.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Legit.store.Commits
 * @extends Neo.data.Store
 */
class Commits extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.store.Commits'
         * @protected
         */
        className: 'Legit.store.Commits',
        /**
         * @member {Neo.data.Model} model=CommitModel
         * @reactive
         */
        model: _model_Commit_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
        /**
         * @member {Object[]} sorters=[{property:'timestamp',direction:'DESC'}]
         * @reactive
         */
        sorters: [{
            property : 'timestamp',
            direction: 'DESC'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Commits));


/***/ },

/***/ "./apps/legit/store/Files.mjs"
/*!************************************!*\
  !*** ./apps/legit/store/Files.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_File_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/File.mjs */ "./apps/legit/model/File.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Legit.store.Files
 * @extends Neo.data.Store
 */
class Files extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.store.Files'
         * @protected
         */
        className: 'Legit.store.Files',
        /**
         * @member {Neo.data.Model} model=FileModel
         * @reactive
         */
        model: _model_File_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Files));


/***/ },

/***/ "./apps/legit/view/CommitGrid.mjs"
/*!****************************************!*\
  !*** ./apps/legit/view/CommitGrid.mjs ***!
  \****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_grid_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/grid/Container.mjs */ "./src/grid/Container.mjs");


/**
 * @class Legit.view.CommitGrid
 * @extends Neo.grid.Container
 */
class CommitGrid extends _src_grid_Container_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.view.CommitGrid'
         * @protected
         */
        className: 'Legit.view.CommitGrid',
        /**
         * @member {String[]} baseCls=['legit-commit-grid','neo-grid-container']
         * @protected
         */
        baseCls: ['legit-commit-grid', 'neo-grid-container'],
        /**
         * @member {Object} bind={store:'stores.commitStore'}
         */
        bind: {store: 'stores.commitStore'},
        /**
         * @member {Object} columnDefaults={renderer:'onCommitColumnRenderer'}
         */
        columnDefaults: {
            renderer: 'onCommitColumnRenderer'
        },
        /**
         * @member {Object[]} columns
         */
        columns: [{
            dataField: 'timestamp',
            text     : 'Timestamp',
            width    : 150
        }, {
            dataField: 'author',
            text     : 'Author',
            width    : 150
        }, {
            dataField: 'message',
            text     : 'Message',
            flex     : 1
        }, {
            dataField: 'oid',
            text     : 'OID',
            width    : 300
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CommitGrid));


/***/ },

/***/ "./apps/legit/view/Viewport.mjs"
/*!**************************************!*\
  !*** ./apps/legit/view/Viewport.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _CommitGrid_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CommitGrid.mjs */ "./apps/legit/view/CommitGrid.mjs");
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _src_code_LivePreview_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/code/LivePreview.mjs */ "./src/code/LivePreview.mjs");
/* harmony import */ var _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../src/container/Panel.mjs */ "./src/container/Panel.mjs");
/* harmony import */ var _src_tree_List_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../src/tree/List.mjs */ "./src/tree/List.mjs");
/* harmony import */ var _src_component_Splitter_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../src/component/Splitter.mjs */ "./src/component/Splitter.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ViewportController.mjs */ "./apps/legit/view/ViewportController.mjs");
/* harmony import */ var _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ViewportStateProvider.mjs */ "./apps/legit/view/ViewportStateProvider.mjs");












/**
 * @class Legit.view.Viewport
 * @extends Neo.container.Viewport
 */
class Viewport extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.view.Viewport'
         * @protected
         */
        className: 'Legit.view.Viewport',
        /**
         * @member {String[]} cls=['legit-viewport']
         * @reactive
         */
        cls: ['legit-viewport'],
        /**
         * @member {Neo.controller.Component} controller=ViewportController
         * @reactive
         */
        controller: _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_9__["default"],
        /**
         * @member {Neo.state.Provider} stateProvider=ViewportStateProvider
         * @reactive
         */
        stateProvider: _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_10__["default"],
        /*
         * @member {Object} layout={ntype:'hbox',align:'stretch'}
         */
        layout: {ntype: 'hbox', align: 'stretch'},
        /**
         * @member {Object[]} items
         */
        items: [{
            module                    : _src_tree_List_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
            bind                      : {store: 'stores.fileStore'},
            cls                       : ['legit-files-tree'],
            listeners                 : {leafItemClick: 'onFileItemClick', select: 'onTreeListSelect'},
            reference                 : 'files-tree',
            showCollapseExpandAllIcons: false,
            width                     : 300,
        }, {
            module      : _src_component_Splitter_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            resizeTarget: 'previous',
            size        : 5
        }, {
            module: _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex  : 1,
            layout: {ntype: 'vbox', align: 'stretch'},
            items: [{
                module: _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_8__["default"],
                flex  : 'none',
                style : {marginRight: '15px'},
                items :['->', {
                    module   : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    disabled : true,
                    handler  : 'onNewFileButtonClick',
                    iconCls  : 'fa fa-plus',
                    reference: 'new-file-button',
                    text     : 'New File'
                }, {
                    module   : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    disabled : true,
                    handler  : 'onSaveButtonClick',
                    iconCls  : 'fa fa-cloud-upload',
                    reference: 'save-button',
                    style    : {marginLeft: '.5em'},
                    text     : 'Save'
                }]
            }, {
                module   : _src_code_LivePreview_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                flex     : 3,
                language : 'markdown',
                listeners: {editorChange: 'onEditorChange'},
                reference: 'code-live-preview',
                style : {margin: '20px'}
            }, {
                module      : _src_component_Splitter_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
                direction   : 'horizontal',
                resizeTarget: 'previous',
                size        : 5
            }, {
                module: _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                cls   : ['legit-commit-grid-panel'],
                flex  : 1,
                style : {margin: '20px'},
                headers: [{
                    dock: 'top',
                    text: 'Legit History'
                }],
                items : [{
                    module      : _CommitGrid_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                    wrapperStyle: {minHeight: '200px'}
                }]
            }]
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ },

/***/ "./apps/legit/view/ViewportController.mjs"
/*!************************************************!*\
  !*** ./apps/legit/view/ViewportController.mjs ***!
  \************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../service/Legit.mjs */ "./apps/legit/service/Legit.mjs");



/**
 * @class Legit.view.ViewportController
 * @extends Neo.controller.Component
 */
class ViewportController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.view.ViewportController'
         * @protected
         */
        className: 'Legit.view.ViewportController',
        /**
         * @member {Number} pollingInterval=1000
         */
        pollingInterval: 1000
    }

    /**
     * @member {Neo.dialog.Base|null}
     */
    addDialog = null
    /**
     * @member {String} currentTreeState=null
     */
    currentTreeState = null
    /**
     * @member {Boolean} running=false
     */
    running = false

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        const me = this;

        await _service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].ready();

        me.getReference('new-file-button').disabled = false;
        me.getReference('save-button')    .disabled = false;

        setInterval(me.poll.bind(me), me.pollingInterval)
    }

    /**
     * @param {Object} data
     */
    async onAddFileDialogSave(data) {
        const
            me        = this,
            dialog    = me.addDialog,
            textField = dialog.getReference('filename'),
            filePath  = `${_service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].path}/${textField.value}`;

        dialog.hide();

        console.log('onAddFileDialogSave', textField.value);
        await _service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].writeFile({
            data: '',
            path: filePath
        });

        me.setState({currentFile: filePath});
    }

    /**
     * @param {Object} data
     */
    onCommitColumnRenderer(data) {
        if (data.dataField === 'author') {
            return data.value.name;
        }

        if (data.dataField === 'timestamp') {
            return new Intl.DateTimeFormat('default', {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric'
            }).format(new Date(data.value * 1000));
        }

        return data.value;
    }

    /**
     * @param {Record} record
     */
    onFileItemClick(record) {
        console.log('onFileItemClick', record)
    }

    /**
     * @param data
     * @returns {Promise<void>}
     */
    async onEditorChange(data) {
        // console.log('onEditorChange', data);
    }

    /**
     * @param data
     * @returns {Promise<void>}
     */
    async onNewFileButtonClick(data) {
        let me          = this,
            {addDialog} = me,
            button      = data.component,
            {appName, theme, windowId} = button;

        button.disabled = true;

        if (!addDialog) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_dialog_Base_mjs"), __webpack_require__.e("vendors-src_form_Container_mjs"), __webpack_require__.e("apps_legit_view_AddFileDialog_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./AddFileDialog.mjs */ "./apps/legit/view/AddFileDialog.mjs")).then(module => {
                me.addDialog = Neo.create({
                    module         : module.default,
                    animateTargetId: button.id,
                    appName,
                    listeners      : {hide: data => {button.disabled = false}},
                    parentComponent: me.component,
                    theme,
                    windowId
                })
            })
        } else {
            addDialog.show()
        }
    }

    /**
     * @param {Object} data
     */
    async onSaveButtonClick(data) {
        const
            me          = this,
            livePreview = me.getReference('code-live-preview'),
            currentFile = me.getState('currentFile');

        console.log('onSaveButtonClick', me.getState('currentFile'), livePreview.value);

        await _service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].writeFile({
            data: livePreview.value,
            path: `${_service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].path}/${currentFile}`
        });
    }

    /**
     * @param {Object}   data
     * @param {Record[]} data.records
     * @param {String[]} data.selection // selected dom node ids
     * @param {String}   data.source    // id of the event-firing instance
     */
    async onTreeListSelect({records}) {
        const
            livePreview = this.getReference('code-live-preview'),
            record      = records?.[0],
            language    = record.id.includes('.md') ? 'markdown' : 'neomjs';

        if (record?.isLeaf) {
            this.setState({currentFile: record.id});

            const value = await _service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].readFile(`${_service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].path}/${record.id}`, 'utf-8');

            await livePreview.set({language, value});
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async poll() {
        let me = this;

        if (me.running) {
            return
        }

        try {
            me.running = true;

            let newState = await _service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].readFile(_service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].path + '/.legit/head', 'utf-8');

            if (me.currentTreeState === newState) {
                return;
            }

            const commitStore = me.getStore('commitStore');
            const fileStore   = me.getStore('fileStore');
            const treeDelta   = await _service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadTreeDelta(me.currentTreeState, newState);

            commitStore.data = await _service_Legit_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].loadHistory();

            console.log('TREE DELTA:', treeDelta);
            for (const deletedEntry of treeDelta.deleted) {
                console.log('Deleted FROM TREE: ' + deletedEntry);
                fileStore.remove(deletedEntry)
            }

            for (const addedEntry of treeDelta.added) {
                console.log('Added From Tree:' + addedEntry);
                fileStore.insert(0, {
                    id      : addedEntry,
                    name    : addedEntry,
                    parentId: null
                })
            }

            for (const modifiedEntry of treeDelta.modified) {
                // const newItem = await legitFs.readFile(path + '/' + addedEntry, 'utf8');
                // todo update item in tree store
                console.log('MODIFIED From Tree:' + modifiedEntry);
            }

            me.currentTreeState = newState;
        } finally {
            me.running = false;

            let selectionModel = me.getReference('files-tree').selectionModel;

            if (!selectionModel.hasSelection()) {
                selectionModel.selectAt(0)
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportController));


/***/ },

/***/ "./apps/legit/view/ViewportStateProvider.mjs"
/*!***************************************************!*\
  !*** ./apps/legit/view/ViewportStateProvider.mjs ***!
  \***************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_Commits_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/Commits.mjs */ "./apps/legit/store/Commits.mjs");
/* harmony import */ var _store_Files_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/Files.mjs */ "./apps/legit/store/Files.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");




/**
 * @class Legit.view.ViewportStateProvider
 * @extends Neo.state.Provider
 */
class ViewportStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Legit.view.ViewportStateProvider'
         * @protected
         */
        className: 'Legit.view.ViewportStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {String|null} data.currentFile=null
             */
            currentFile: null
        },
        /**
         * @member {Object} stores
         */
        stores: {
            commitStore: _store_Commits_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            fileStore  : _store_Files_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportStateProvider));

/***/ },

/***/ "./src/component/Label.mjs"
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ },

/***/ "./src/container/Panel.mjs"
/*!*********************************!*\
  !*** ./src/container/Panel.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");



/**
 * An extended Container supporting multiple docked header toolbars
 * @class Neo.container.Panel
 * @extends Neo.container.Base
 */
class Panel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Panel'
         * @protected
         */
        className: 'Neo.container.Panel',
        /**
         * @member {String} ntype='panel'
         * @protected
         */
        ntype: 'panel',
        /**
         * @member {String[]} baseCls=['neo-panel','neo-container']
         */
        baseCls: ['neo-panel', 'neo-container'],
        /**
         * @member {Object} containerConfig=null
         */
        containerConfig: null,
        /**
         * @member {Object} headerDefaults=null
         */
        headerDefaults: null,
        /**
         * @member {Array} headers=null
         */
        headers: null,
        /**
         * @member {Object} items={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        _layout: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Boolean} verticalHeadersFirst=false
         */
        verticalHeadersFirst: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.hasHeaders() && me.verticalHeadersFirst === true) {
            me.layout = {
                ntype: 'hbox',
                align: 'stretch'
            };
        }
    }

    /**
     * @param {Object} header the header config
     * @returns {Object}
     */
    static createHeaderConfig(header) {
        if (Neo.typeOf(header) === 'NeoInstance') {
            return header;
        }

        let config = {
            flex: '0 1 auto'
        };

        if (!header.module && !header.ntype) {
            config.cls   = ['neo-panel-header-toolbar', 'neo-toolbar'];
            config.ntype = 'toolbar';
        }

        if (header.text) {
            config.items = [{
                ntype: 'label',
                cls  : ['neo-panel-header-text', 'neo-label'],
                text : header.text
            }];

            delete header.text;
        }

        // assuming all labels inside a Panel Header are meant to be titles -> look the same way
        if (Array.isArray(header.items)) {
            header.items.forEach(item => {
                if (item.ntype === 'label') {
                    item.cls = ['neo-panel-header-text', 'neo-label'];
                }
            });
        }

        return {...config, ...header}
    }

    /**
     *
     */
    createItems() {
        let me              = this,
            containerConfig = me.containerConfig;

        if (!me.hasHeaders()) {
            containerConfig && me.set(containerConfig);
            super.createItems();
        } else {
            let hf                   = me.verticalHeadersFirst === false,
                headers              = me.headers || [],
                bottomHeaders        = headers.filter(header => {return header.dock === (hf ?'bottom': 'right')}),
                leftHeaders          = headers.filter(header => {return header.dock === (hf ?'left'  : 'top')}),
                rightHeaders         = headers.filter(header => {return header.dock === (hf ?'right' : 'bottom')}),
                topHeaders           = headers.filter(header => {return header.dock === (hf ?'top'   : 'left')}),
                hasHorizontalHeaders = bottomHeaders.length > 0 || topHeaders  .length > 0,
                hasVerticalHeaders   = leftHeaders  .length > 0 || rightHeaders.length > 0,
                {items}              = me,
                horizontalItems      = [],
                verticalItems        = [],
                config;

            topHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            if (hasVerticalHeaders && (hf && hasHorizontalHeaders || !hf && hasHorizontalHeaders)) {
                leftHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                horizontalItems.push({...me.headerDefaults, ...config});

                rightHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                verticalItems.push({
                    ntype    : 'container',
                    items    : horizontalItems,
                    layout   : {ntype: (hf ? 'hbox' : 'vbox'), align: 'stretch'},
                    reference: 'bodyContainer'
                });
            } else {
                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    reference   : 'bodyContainer',
                    ...containerConfig
                };

                verticalItems.push({...me.headerDefaults, ...config})
            }

            bottomHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            me.items = verticalItems;

            me.itemDefaults = null;

            super.createItems()
        }
    }

    /**
     * @returns {Boolean}
     */
    hasHeaders() {
        return Array.isArray(this.headers) && this.headers.length > 0
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Panel));


/***/ },

/***/ "./src/container/Viewport.mjs"
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ },

/***/ "./src/controller/Component.mjs"
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {String|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/toolbar/Base.mjs"
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            dock: this.dock
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfbGVnaXRfYXBwX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7O0FBRXBDO0FBQ1AsY0FBYywwREFBUTtBQUN0QjtBQUNBLENBQUMsRTs7Ozs7Ozs7Ozs7Ozs7O0FDTCtDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBSztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDaENVOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBSztBQUN4QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQ1U7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFJO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFv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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsMkRBQVMsV0FBVztBQUM1RDs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvbGVnaXQvYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9sZWdpdC9tb2RlbC9Db21taXQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2xlZ2l0L21vZGVsL0ZpbGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2xlZ2l0L3NlcnZpY2UvTGVnaXQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2xlZ2l0L3N0b3JlL0NvbW1pdHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2xlZ2l0L3N0b3JlL0ZpbGVzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9sZWdpdC92aWV3L0NvbW1pdEdyaWQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2xlZ2l0L3ZpZXcvVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2xlZ2l0L3ZpZXcvVmlld3BvcnRDb250cm9sbGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9sZWdpdC92aWV3L1ZpZXdwb3J0U3RhdGVQcm92aWRlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTGFiZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udGFpbmVyL1BhbmVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90b29sYmFyL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWaWV3cG9ydCBmcm9tICcuL3ZpZXcvVmlld3BvcnQubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogVmlld3BvcnQsXG4gICAgbmFtZSAgICA6ICdMZWdpdCdcbn0pOyIsImltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBMZWdpdC5tb2RlbC5Db21taXRcbiAqIEBleHRlbmRzIE5lby5kYXRhLk1vZGVsXG4gKi9cbmNsYXNzIENvbW1pdCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0xlZ2l0Lm1vZGVsLkNvbW1pdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTGVnaXQubW9kZWwuQ29tbWl0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdvaWQnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2F1dGhvcicsXG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAndGltZXN0YW1wJyxcbiAgICAgICAgICAgIHR5cGU6ICdJbnRlZ2VyJ1xuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tbWl0KTtcbiIsImltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBMZWdpdC5tb2RlbC5GaWxlXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5Nb2RlbFxuICovXG5jbGFzcyBGaWxlIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTGVnaXQubW9kZWwuRmlsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTGVnaXQubW9kZWwuRmlsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZHM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnY2xhc3NOYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdjb2xsYXBzZWQnLFxuICAgICAgICAgICAgdHlwZTogJ0Jvb2xlYW4nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdoaWRkZW4nLFxuICAgICAgICAgICAgdHlwZTogJ0Jvb2xlYW4nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdpZCcsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lICAgICAgICA6ICdpc0xlYWYnLFxuICAgICAgICAgICAgdHlwZSAgICAgICAgOiAnQm9vbGVhbicsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ3BhcmVudElkJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhGaWxlKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uLy4uLy4uL3NyYy9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBBIHNpbmdsZXRvbiBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSB2aXJ0dWFsIGZpbGUgc3lzdGVtIGxheWVyIGZvciB0aGUgTGVnaXQgSURFLlxuICpcbiAqIFRoaXMgc2VydmljZSBhY3RzIGFzIHRoZSBjZW50cmFsIGh1YiBmb3IgZmlsZSBzeXN0ZW0gb3BlcmF0aW9ucyB3aXRoaW4gdGhlIExlZ2l0IGFwcGxpY2F0aW9uLlxuICogSXQgYWJzdHJhY3RzIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgbWVjaGFuaXNtICh1c2luZyBgbWVtZnNgKSBhbmQgcHJvdmlkZXMgYSBnaXQtbGlrZSBpbnRlcmZhY2VcbiAqIGZvciBpbnRlcmFjdGluZyB3aXRoIGZpbGUgdHJlZXMgYW5kIGNvbW1pdHMgKHVzaW5nIGBAbGVnaXQtc2RrL2NvcmVgKS5cbiAqXG4gKiBLZXkgcmVzcG9uc2liaWxpdGllcyBpbmNsdWRlOlxuICogLSAqKkluaXRpYWxpemF0aW9uOioqIER5bmFtaWNhbGx5IGxvYWRpbmcgZXh0ZXJuYWwgZGVwZW5kZW5jaWVzIChgbWVtZnNgLCBgQGxlZ2l0LXNkay9jb3JlYCkgdG8gZW5zdXJlIHRoZSBhcHAgcmVtYWlucyBsaWdodHdlaWdodCB1bnRpbCBuZWVkZWQuXG4gKiAtICoqRmlsZSBTeXN0ZW0gU2VlZGluZzoqKiBQb3B1bGF0aW5nIHRoZSBpbi1tZW1vcnkgZmlsZSBzeXN0ZW0gd2l0aCBpbml0aWFsIGRlbW8gY29udGVudC5cbiAqIC0gKipHaXQgT3BlcmF0aW9uczoqKiBQcm92aWRpbmcgbWV0aG9kcyB0byBsb2FkIGZpbGUgdHJlZXMgKGBsb2FkVHJlZWApIGFuZCBjYWxjdWxhdGUgZGVsdGFzIGJldHdlZW4gY29tbWl0cyAoYGxvYWRUcmVlRGVsdGFgKS5cbiAqIC0gKipGaWxlIEkvTzoqKiBFeHBvc2luZyBzdGFuZGFyZCBmaWxlIHN5c3RlbSBtZXRob2RzIChgcmVhZEZpbGVgLCBgd3JpdGVGaWxlYCwgYHJlYWRkaXJgLCBgc3RhdGApIHRoYXQgYXV0b21hdGljYWxseSBhd2FpdCB0aGUgc2VydmljZSdzIHJlYWR5IHN0YXRlLlxuICpcbiAqIFRoaXMgc2VydmljZSBpcyBkZXNpZ25lZCB0byBiZSByb2J1c3QgYWdhaW5zdCBpbml0aWFsaXphdGlvbiBmYWlsdXJlcyBhbmQgcHJvdmlkZXMgYSBzYWZlLCBhc3luY2hyb25vdXMgQVBJIGZvciB0aGUgYFZpZXdwb3J0Q29udHJvbGxlcmAgdG8gY29uc3VtZS5cbiAqXG4gKiBAY2xhc3MgTGVnaXQuc2VydmljZS5MZWdpdFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBMZWdpdCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTGVnaXQuc2VydmljZS5MZWdpdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTGVnaXQuc2VydmljZS5MZWdpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZnM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbGVnaXRGcz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsZWdpdEZzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwYXRoPScvLmxlZ2l0L2JyYW5jaGVzL2Fub255bW91cydcbiAgICAgICAgICovXG4gICAgICAgIHBhdGg6ICcvLmxlZ2l0L2JyYW5jaGVzL2Fub255bW91cycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgc2VydmljZSBieSBkeW5hbWljYWxseSBpbXBvcnRpbmcgZGVwZW5kZW5jaWVzIGFuZCBzZXR0aW5nIHVwIHRoZSBmaWxlIHN5c3RlbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBpbml0QXN5bmMoKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRBc3luYygpO1xuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qge29wZW5MZWdpdEZzfSA9IGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovICdodHRwczovL2VzbS5zaC9AbGVnaXQtc2RrL2NvcmUnKTtcbiAgICAgICAgICAgIGNvbnN0IGZzTW9kdWxlICAgICAgPSBhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyAnaHR0cHM6Ly9lc20uc2gvbWVtZnMnKTtcblxuICAgICAgICAgICAgbWUuZnMgPSBmc01vZHVsZS5kZWZhdWx0O1xuXG4gICAgICAgICAgICBtZS5sZWdpdEZzID0gYXdhaXQgb3BlbkxlZ2l0RnMoe1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VGczogbWUuZnMsXG4gICAgICAgICAgICAgICAgZ2l0Um9vdCAgOiAnLycsXG4gICAgICAgICAgICAgICAgc2VydmVyVXJsOiAnaHR0cDovL2xvY2FsaG9zdDo5OTk5LycsXG4gICAgICAgICAgICAgICAgLy8gcHVibGljS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19MRUdJVF9QVUJMSUNfS0VZLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgIGdsb2JhbFRoaXMubGVnaXRGcyA9IG1lLmxlZ2l0RnM7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLiNzZWVkRmlsZVN5c3RlbSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBMZWdpdCBTZXJ2aWNlJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbW1pdCBoaXN0b3J5IGZvciBhIGdpdmVuIGJyYW5jaC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2JyYW5jaD0nYW5vbnltb3VzJ10gVGhlIGJyYW5jaCBuYW1lIHRvIGxvYWQgaGlzdG9yeSBmb3IuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0W10+fSBBbiBhcnJheSBvZiBjb21taXQgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkSGlzdG9yeShicmFuY2g9J2Fub255bW91cycpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkeSgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5SnNvbiA9IGF3YWl0IHRoaXMubGVnaXRGcy5yZWFkRmlsZShgLy5sZWdpdC9icmFuY2hlcy8ke2JyYW5jaH0vLmxlZ2l0L2hpc3RvcnlgLCAndXRmLTgnKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGhpc3RvcnlKc29uKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gbG9hZCBoaXN0b3J5IGZvciBicmFuY2ggJHticmFuY2h9YCwgZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBsb2FkcyB0aGUgZmlsZSB0cmVlIHN0cnVjdHVyZSBmcm9tIGEgZ2l2ZW4gcGF0aC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHJlZVBhdGggVGhlIHBhdGggdG8gc3RhcnQgbG9hZGluZyB0aGUgdHJlZSBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHtoYXNoOiBzdHJpbmcsIHN1YkVudHJpZXM6IHt9fT59IFRoZSB0cmVlIHN0cnVjdHVyZSB3aXRoIGhhc2hlcy5cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkVHJlZSh0cmVlUGF0aCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlYWR5KCk7XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3ViRW50cmllcyA9IHt9LFxuICAgICAgICAgICAgcGF0aEVudHJpZXMgPSBhd2FpdCBtZS5yZWFkZGlyKHRyZWVQYXRoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5TmFtZSBvZiBwYXRoRW50cmllcykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IG1lLnN0YXQodHJlZVBhdGggKyBlbnRyeU5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgc3ViRW50cmllc1tlbnRyeU5hbWVdID0gYXdhaXQgbWUubG9hZFRyZWUodHJlZVBhdGggKyBlbnRyeU5hbWUgKyAnLycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW5IYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMVwiLCBhd2FpdCBtZS5yZWFkRmlsZSh0cmVlUGF0aCArIGVudHJ5TmFtZSkpO1xuXG4gICAgICAgICAgICAgICAgc3ViRW50cmllc1tlbnRyeU5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igbm93IGl0cyB0aGUgY29udGVudCBpbnN0ZWFkIG9mIHRoZSBoYXNoXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGNvbnRlbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGVudHJ5TmFtZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc2g6ICcnLFxuICAgICAgICAgICAgc3ViRW50cmllc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0cmVlIHN0YXRlcyAoY29tbWl0cykuXG4gICAgICogVXNlZnVsIGZvciBpZGVudGlmeWluZyBhZGRlZCwgZGVsZXRlZCwgYW5kIG1vZGlmaWVkIGZpbGVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50U3RhdGUgVGhlIGhhc2ggb3IgcGF0aCBvZiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3U3RhdGUgVGhlIGhhc2ggb3IgcGF0aCBvZiB0aGUgbmV3IHN0YXRlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHtkZWxldGVkOiBTdHJpbmdbXSwgYWRkZWQ6IFN0cmluZ1tdLCBtb2RpZmllZDogU3RyaW5nW119Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYXJyYXlzIG9mIGNoYW5nZWQgZmlsZSBwYXRocy5cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkVHJlZURlbHRhKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkeSgpO1xuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBjb25zdCBwcmVmaXhOZXdTdGF0ZSA9IG5ld1N0YXRlLnNsaWNlKDAsIDIpO1xuICAgICAgICBjb25zdCBzdWZmaXhOZXdTdGF0ZSA9IG5ld1N0YXRlLnNsaWNlKDIpO1xuXG4gICAgICAgIGxldCBjdXJyZW50c3RhdGVUcmVlID0ge31cblxuICAgICAgICBpZiAoY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXhDdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUuc2xpY2UoMCwgMik7XG4gICAgICAgICAgICBjb25zdCBzdWZmaXhDdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUuc2xpY2UoMik7XG5cbiAgICAgICAgICAgIGN1cnJlbnRzdGF0ZVRyZWUgPSBhd2FpdCBtZS5sb2FkVHJlZSgnLy5sZWdpdC9jb21taXRzLycgKyBwcmVmaXhDdXJyZW50U3RhdGUgKyAnLycgKyBzdWZmaXhDdXJyZW50U3RhdGUgKyAnLycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlVHJlZSA9IGF3YWl0IG1lLmxvYWRUcmVlKCcvLmxlZ2l0L2NvbW1pdHMvJyArIHByZWZpeE5ld1N0YXRlICsgJy8nICsgc3VmZml4TmV3U3RhdGUgKyAnLycpO1xuXG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgID0gW107XG4gICAgICAgIGNvbnN0IGFkZGVkICAgID0gW107XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gZmxhdHRlblRyZWUodHJlZSwgcGF0aCA9ICcnKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgaWYgKHRyZWUuc3ViRW50cmllcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRyZWUuc3ViRW50cmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhdGggPSBwYXRoID8gYCR7cGF0aH0vJHtrZXl9YCA6IGtleTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3ViRW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIGZsYXR0ZW5UcmVlKHZhbHVlLCBjdXJyZW50UGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJlbnRQYXRoXSA9IHZhbHVlLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGVGbGF0ID0gY3VycmVudFN0YXRlICE9PSAnJyA/IGZsYXR0ZW5UcmVlKGN1cnJlbnRzdGF0ZVRyZWUpIDoge307XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlRmxhdCAgICAgPSBmbGF0dGVuVHJlZShuZXdTdGF0ZVRyZWUpO1xuXG4gICAgICAgIC8vIEZpbmQgZGVsZXRlZCAoaW4gY3VycmVudCBidXQgbm90IGluIG5ldylcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIGluIGN1cnJlbnRTdGF0ZUZsYXQpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGggaW4gbmV3U3RhdGVGbGF0KSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgYWRkZWQgKGluIG5ldyBidXQgbm90IGluIGN1cnJlbnQpXG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBpbiBuZXdTdGF0ZUZsYXQpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGggaW4gY3VycmVudFN0YXRlRmxhdCkpIHtcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCBtb2RpZmllZCAoaW4gYm90aCBidXQgaGFzaCBkaWZmZXJzKVxuICAgICAgICBmb3IgKGNvbnN0IHBhdGggaW4gbmV3U3RhdGVGbGF0KSB7XG4gICAgICAgICAgICBpZiAocGF0aCBpbiBjdXJyZW50U3RhdGVGbGF0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEhhc2ggPSBuZXcgVWludDhBcnJheShjdXJyZW50U3RhdGVGbGF0W3BhdGhdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdIYXNoICAgICA9IG5ldyBVaW50OEFycmF5KG5ld1N0YXRlRmxhdFtwYXRoXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEhhc2gubGVuZ3RoICE9PSBuZXdIYXNoLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICAhY3VycmVudEhhc2guZXZlcnkoKGJ5dGUsIGkpID0+IGJ5dGUgPT09IG5ld0hhc2hbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGV0ZWQsXG4gICAgICAgICAgICBhZGRlZCxcbiAgICAgICAgICAgIG1vZGlmaWVkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgY29udGVudCBvZiBhIGZpbGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIGZpbGUgcGF0aC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFJlYWQgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gVGhlIGZpbGUgY29udGVudC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkRmlsZShwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVhZHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnaXRGcy5yZWFkRmlsZShwYXRoLCBvcHRpb25zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBjb250ZW50cyBvZiBhIGRpcmVjdG9yeS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgZGlyZWN0b3J5IHBhdGguXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3RyaW5nW10+fSBBbiBhcnJheSBvZiBmaWxlIG5hbWVzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRkaXIocGF0aCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlYWR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZ2l0RnMucmVhZGRpcihwYXRoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZWRzIHRoZSBpbi1tZW1vcnkgZmlsZSBzeXN0ZW0gd2l0aCBpbml0aWFsIGRlbW8gY29udGVudC5cbiAgICAgKiBUaGlzIG1ldGhvZCBieXBhc3NlcyB0aGUgYHJlYWR5KClgIGNoZWNrIHRvIGF2b2lkIGRlYWRsb2NrcyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyAjc2VlZEZpbGVTeXN0ZW0oKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBsZXQgbWRGaWxlID0gYXdhaXQgZmV0Y2goJy4uLy4uL2xlYXJuL2JlbmVmaXRzL0Zvcm1zRW5naW5lLm1kJyk7XG4gICAgICAgIG1kRmlsZSA9IGF3YWl0IG1kRmlsZS50ZXh0KCk7XG5cbiAgICAgICAgYXdhaXQgbWUud3JpdGVGaWxlKHtcbiAgICAgICAgICAgIGRhdGEgICAgIDogbWRGaWxlLFxuICAgICAgICAgICAgcGF0aCAgICAgOiBgJHttZS5wYXRofS9Gb3Jtc0VuZ2luZS5tZGAsXG4gICAgICAgICAgICBza2lwUmVhZHk6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWRGaWxlID0gYXdhaXQgZmV0Y2goJy4uLy4uL2xlYXJuL2JlbmVmaXRzL09mZlRoZU1haW5UaHJlYWQubWQnKTtcbiAgICAgICAgbWRGaWxlID0gYXdhaXQgbWRGaWxlLnRleHQoKTtcblxuICAgICAgICBhd2FpdCBtZS53cml0ZUZpbGUoe1xuICAgICAgICAgICAgZGF0YSAgICAgOiBtZEZpbGUsXG4gICAgICAgICAgICBwYXRoICAgICA6IGAke21lLnBhdGh9L09mZlRoZU1haW5UaHJlYWQubWRgLFxuICAgICAgICAgICAgc2tpcFJlYWR5OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG1lLndyaXRlRmlsZSh7XG4gICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgXCJpbXBvcnQgVmlld3BvcnQgZnJvbSAnLi4vLi4vZXhhbXBsZXMvY29tcG9uZW50L211bHRpV2luZG93SGVsaXgvVmlld3BvcnQubWpzJztcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgIFwiY2xhc3MgTWFpblZpZXcgZXh0ZW5kcyBWaWV3cG9ydCB7XCIsXG4gICAgICAgICAgICAgICAgXCIgICAgc3RhdGljIGNvbmZpZyA9IHtcIixcbiAgICAgICAgICAgICAgICBcIiAgICAgICAgY2xhc3NOYW1lICAgICAgICAgICA6ICdQb3J0YWwudmlldy5NdWx0aVdpbmRvd0hlbGl4JyxcIixcbiAgICAgICAgICAgICAgICBcIiAgICAgICAgc2hvd0dpdEh1YlN0YXJCdXR0b246IGZhbHNlLFwiLFxuICAgICAgICAgICAgICAgIFwiICAgICAgICB0aGVtZSAgICAgICAgICAgICAgIDogJ25lby10aGVtZS1kYXJrJ1wiLFxuICAgICAgICAgICAgICAgIFwiICAgIH1cIixcbiAgICAgICAgICAgICAgICBcIn1cIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgIFwiTWFpblZpZXcgPSBOZW8uc2V0dXBDbGFzcyhNYWluVmlldyk7XCJcbiAgICAgICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgICAgICBwYXRoICAgICA6IGAke21lLnBhdGh9L0hlbGl4Lm1qc2AsXG4gICAgICAgICAgICBza2lwUmVhZHk6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUud3JpdGVGaWxlKHtcbiAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICBcImltcG9ydCBWaWV3cG9ydCBmcm9tICcuLi8uLi9leGFtcGxlcy9jb21wb25lbnQvbXVsdGlXaW5kb3dDb3JvbmFHYWxsZXJ5L1ZpZXdwb3J0Lm1qcyc7XCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgICAgICBcImNsYXNzIE1haW5WaWV3IGV4dGVuZHMgVmlld3BvcnQge1wiLFxuICAgICAgICAgICAgICAgIFwiICAgIHN0YXRpYyBjb25maWcgPSB7XCIsXG4gICAgICAgICAgICAgICAgXCIgICAgICAgIGNsYXNzTmFtZSAgICAgICAgICAgOiAnUG9ydGFsLnZpZXcuTXVsdGlXaW5kb3dIZWxpeCcsXCIsXG4gICAgICAgICAgICAgICAgXCIgICAgICAgIHNob3dHaXRIdWJTdGFyQnV0dG9uOiBmYWxzZSxcIixcbiAgICAgICAgICAgICAgICBcIiAgICAgICAgdGhlbWUgICAgICAgICAgICAgICA6ICduZW8tdGhlbWUtZGFyaydcIixcbiAgICAgICAgICAgICAgICBcIiAgICB9XCIsXG4gICAgICAgICAgICAgICAgXCJ9XCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgICAgICBcIk1haW5WaWV3ID0gTmVvLnNldHVwQ2xhc3MoTWFpblZpZXcpO1wiXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgcGF0aCAgICAgOiBgJHttZS5wYXRofS9HYWxsZXJ5Lm1qc2AsXG4gICAgICAgICAgICBza2lwUmVhZHk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGZpbGUgc3RhdGlzdGljcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgZmlsZSBvciBkaXJlY3RvcnkgcGF0aC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgZmlsZSBzdGF0aXN0aWNzIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyBzdGF0KHBhdGgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWFkeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZWdpdEZzLnN0YXQocGF0aClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZGF0YSB0byBhIGZpbGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBjb25maWcuZGF0YSBUaGUgZGF0YSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtjb25maWcub3B0aW9uc10gV3JpdGUgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgIGNvbmZpZy5wYXRoIFRoZSBmaWxlIHBhdGguXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbY29uZmlnLnNraXBSZWFkeT1mYWxzZV0gSWYgdHJ1ZSwgYnlwYXNzZXMgdGhlIGBhd2FpdCB0aGlzLnJlYWR5KClgIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIGFzeW5jIHdyaXRlRmlsZSh7ZGF0YSwgb3B0aW9ucywgcGF0aCwgc2tpcFJlYWR5PWZhbHNlfSkge1xuICAgICAgICAhc2tpcFJlYWR5ICYmIGF3YWl0IHRoaXMucmVhZHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnaXRGcy53cml0ZUZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExlZ2l0KTtcbiIsImltcG9ydCBDb21taXRNb2RlbCBmcm9tICcuLi9tb2RlbC9Db21taXQubWpzJztcbmltcG9ydCBTdG9yZSAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9TdG9yZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBMZWdpdC5zdG9yZS5Db21taXRzXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5TdG9yZVxuICovXG5jbGFzcyBDb21taXRzIGV4dGVuZHMgU3RvcmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTGVnaXQuc3RvcmUuQ29tbWl0cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTGVnaXQuc3RvcmUuQ29tbWl0cycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9Q29tbWl0TW9kZWxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDogQ29tbWl0TW9kZWwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gc29ydGVycz1be3Byb3BlcnR5Oid0aW1lc3RhbXAnLGRpcmVjdGlvbjonREVTQyd9XVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRlcnM6IFt7XG4gICAgICAgICAgICBwcm9wZXJ0eSA6ICd0aW1lc3RhbXAnLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAnREVTQydcbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbW1pdHMpO1xuIiwiaW1wb3J0IEZpbGVNb2RlbCBmcm9tICcuLi9tb2RlbC9GaWxlLm1qcyc7XG5pbXBvcnQgU3RvcmUgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIExlZ2l0LnN0b3JlLkZpbGVzXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5TdG9yZVxuICovXG5jbGFzcyBGaWxlcyBleHRlbmRzIFN0b3JlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0xlZ2l0LnN0b3JlLkZpbGVzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdMZWdpdC5zdG9yZS5GaWxlcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9RmlsZU1vZGVsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IEZpbGVNb2RlbFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRmlsZXMpO1xuIiwiaW1wb3J0IEdyaWQgZnJvbSAnLi4vLi4vLi4vc3JjL2dyaWQvQ29udGFpbmVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIExlZ2l0LnZpZXcuQ29tbWl0R3JpZFxuICogQGV4dGVuZHMgTmVvLmdyaWQuQ29udGFpbmVyXG4gKi9cbmNsYXNzIENvbW1pdEdyaWQgZXh0ZW5kcyBHcmlkIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0xlZ2l0LnZpZXcuQ29tbWl0R3JpZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTGVnaXQudmlldy5Db21taXRHcmlkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbGVnaXQtY29tbWl0LWdyaWQnLCduZW8tZ3JpZC1jb250YWluZXInXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ2xlZ2l0LWNvbW1pdC1ncmlkJywgJ25lby1ncmlkLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kPXtzdG9yZTonc3RvcmVzLmNvbW1pdFN0b3JlJ31cbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IHtzdG9yZTogJ3N0b3Jlcy5jb21taXRTdG9yZSd9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjb2x1bW5EZWZhdWx0cz17cmVuZGVyZXI6J29uQ29tbWl0Q29sdW1uUmVuZGVyZXInfVxuICAgICAgICAgKi9cbiAgICAgICAgY29sdW1uRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIHJlbmRlcmVyOiAnb25Db21taXRDb2x1bW5SZW5kZXJlcidcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBjb2x1bW5zXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5zOiBbe1xuICAgICAgICAgICAgZGF0YUZpZWxkOiAndGltZXN0YW1wJyxcbiAgICAgICAgICAgIHRleHQgICAgIDogJ1RpbWVzdGFtcCcsXG4gICAgICAgICAgICB3aWR0aCAgICA6IDE1MFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkYXRhRmllbGQ6ICdhdXRob3InLFxuICAgICAgICAgICAgdGV4dCAgICAgOiAnQXV0aG9yJyxcbiAgICAgICAgICAgIHdpZHRoICAgIDogMTUwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRhdGFGaWVsZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgdGV4dCAgICAgOiAnTWVzc2FnZScsXG4gICAgICAgICAgICBmbGV4ICAgICA6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZGF0YUZpZWxkOiAnb2lkJyxcbiAgICAgICAgICAgIHRleHQgICAgIDogJ09JRCcsXG4gICAgICAgICAgICB3aWR0aCAgICA6IDMwMFxuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tbWl0R3JpZCk7XG4iLCJpbXBvcnQgQmFzZVZpZXdwb3J0ICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzJztcbmltcG9ydCBCdXR0b24gICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tbWl0R3JpZCAgICAgICAgICAgIGZyb20gJy4vQ29tbWl0R3JpZC5tanMnO1xuaW1wb3J0IENvbnRhaW5lciAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMaXZlUHJldmlldyAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvZGUvTGl2ZVByZXZpZXcubWpzJztcbmltcG9ydCBQYW5lbCAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9QYW5lbC5tanMnO1xuaW1wb3J0IFRyZWVMaXN0ICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvdHJlZS9MaXN0Lm1qcyc7XG5pbXBvcnQgU3BsaXR0ZXIgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvU3BsaXR0ZXIubWpzJztcbmltcG9ydCBUb29sYmFyICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL3Rvb2xiYXIvQmFzZS5tanMnO1xuaW1wb3J0IFZpZXdwb3J0Q29udHJvbGxlciAgICBmcm9tICcuL1ZpZXdwb3J0Q29udHJvbGxlci5tanMnO1xuaW1wb3J0IFZpZXdwb3J0U3RhdGVQcm92aWRlciBmcm9tICcuL1ZpZXdwb3J0U3RhdGVQcm92aWRlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBMZWdpdC52aWV3LlZpZXdwb3J0XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKi9cbmNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgQmFzZVZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0xlZ2l0LnZpZXcuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0xlZ2l0LnZpZXcuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ2xlZ2l0LXZpZXdwb3J0J11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnbGVnaXQtdmlld3BvcnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudH0gY29udHJvbGxlcj1WaWV3cG9ydENvbnRyb2xsZXJcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sbGVyOiBWaWV3cG9ydENvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IHN0YXRlUHJvdmlkZXI9Vmlld3BvcnRTdGF0ZVByb3ZpZGVyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGVQcm92aWRlcjogVmlld3BvcnRTdGF0ZVByb3ZpZGVyLFxuICAgICAgICAvKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2hib3gnLGFsaWduOidzdHJldGNoJ31cbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICAgICAgICAgOiBUcmVlTGlzdCxcbiAgICAgICAgICAgIGJpbmQgICAgICAgICAgICAgICAgICAgICAgOiB7c3RvcmU6ICdzdG9yZXMuZmlsZVN0b3JlJ30sXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgICAgICAgICAgIDogWydsZWdpdC1maWxlcy10cmVlJ10sXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgICAgICAgICAgICAgIDoge2xlYWZJdGVtQ2xpY2s6ICdvbkZpbGVJdGVtQ2xpY2snLCBzZWxlY3Q6ICdvblRyZWVMaXN0U2VsZWN0J30sXG4gICAgICAgICAgICByZWZlcmVuY2UgICAgICAgICAgICAgICAgIDogJ2ZpbGVzLXRyZWUnLFxuICAgICAgICAgICAgc2hvd0NvbGxhcHNlRXhwYW5kQWxsSWNvbnM6IGZhbHNlLFxuICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgICAgICAgICA6IDMwMCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgOiBTcGxpdHRlcixcbiAgICAgICAgICAgIHJlc2l6ZVRhcmdldDogJ3ByZXZpb3VzJyxcbiAgICAgICAgICAgIHNpemUgICAgICAgIDogNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGU6IENvbnRhaW5lcixcbiAgICAgICAgICAgIGZsZXggIDogMSxcbiAgICAgICAgICAgIGxheW91dDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBUb29sYmFyLFxuICAgICAgICAgICAgICAgIGZsZXggIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHN0eWxlIDoge21hcmdpblJpZ2h0OiAnMTVweCd9LFxuICAgICAgICAgICAgICAgIGl0ZW1zIDpbJy0+Jywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyICA6ICdvbk5ld0ZpbGVCdXR0b25DbGljaycsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhIGZhLXBsdXMnLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6ICduZXctZmlsZS1idXR0b24nLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgICA6ICdOZXcgRmlsZSdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgIDogJ29uU2F2ZUJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNscyAgOiAnZmEgZmEtY2xvdWQtdXBsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAnc2F2ZS1idXR0b24nLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSAgICA6IHttYXJnaW5MZWZ0OiAnLjVlbSd9LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgICA6ICdTYXZlJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgOiBMaXZlUHJldmlldyxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICA6IDMsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2UgOiAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge2VkaXRvckNoYW5nZTogJ29uRWRpdG9yQ2hhbmdlJ30sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAnY29kZS1saXZlLXByZXZpZXcnLFxuICAgICAgICAgICAgICAgIHN0eWxlIDoge21hcmdpbjogJzIwcHgnfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgIDogU3BsaXR0ZXIsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uICAgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAgICAgcmVzaXplVGFyZ2V0OiAncHJldmlvdXMnLFxuICAgICAgICAgICAgICAgIHNpemUgICAgICAgIDogNVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogUGFuZWwsXG4gICAgICAgICAgICAgICAgY2xzICAgOiBbJ2xlZ2l0LWNvbW1pdC1ncmlkLXBhbmVsJ10sXG4gICAgICAgICAgICAgICAgZmxleCAgOiAxLFxuICAgICAgICAgICAgICAgIHN0eWxlIDoge21hcmdpbjogJzIwcHgnfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICBkb2NrOiAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0xlZ2l0IEhpc3RvcnknXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgaXRlbXMgOiBbe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICAgICA6IENvbW1pdEdyaWQsXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZToge21pbkhlaWdodDogJzIwMHB4J31cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXdwb3J0KTtcbiIsImltcG9ydCBDb21wb25lbnQgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTGVnaXRTZXJ2aWNlIGZyb20gJy4uL3NlcnZpY2UvTGVnaXQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTGVnaXQudmlldy5WaWV3cG9ydENvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBWaWV3cG9ydENvbnRyb2xsZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTGVnaXQudmlldy5WaWV3cG9ydENvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0xlZ2l0LnZpZXcuVmlld3BvcnRDb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcG9sbGluZ0ludGVydmFsPTEwMDBcbiAgICAgICAgICovXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbDogMTAwMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5kaWFsb2cuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGFkZERpYWxvZyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGN1cnJlbnRUcmVlU3RhdGU9bnVsbFxuICAgICAqL1xuICAgIGN1cnJlbnRUcmVlU3RhdGUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcnVubmluZz1mYWxzZVxuICAgICAqL1xuICAgIHJ1bm5pbmcgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgaW5pdEFzeW5jKCkge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0QXN5bmMoKTtcblxuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgYXdhaXQgTGVnaXRTZXJ2aWNlLnJlYWR5KCk7XG5cbiAgICAgICAgbWUuZ2V0UmVmZXJlbmNlKCduZXctZmlsZS1idXR0b24nKS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICBtZS5nZXRSZWZlcmVuY2UoJ3NhdmUtYnV0dG9uJykgICAgLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgc2V0SW50ZXJ2YWwobWUucG9sbC5iaW5kKG1lKSwgbWUucG9sbGluZ0ludGVydmFsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25BZGRGaWxlRGlhbG9nU2F2ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGlhbG9nICAgID0gbWUuYWRkRGlhbG9nLFxuICAgICAgICAgICAgdGV4dEZpZWxkID0gZGlhbG9nLmdldFJlZmVyZW5jZSgnZmlsZW5hbWUnKSxcbiAgICAgICAgICAgIGZpbGVQYXRoICA9IGAke0xlZ2l0U2VydmljZS5wYXRofS8ke3RleHRGaWVsZC52YWx1ZX1gO1xuXG4gICAgICAgIGRpYWxvZy5oaWRlKCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ29uQWRkRmlsZURpYWxvZ1NhdmUnLCB0ZXh0RmllbGQudmFsdWUpO1xuICAgICAgICBhd2FpdCBMZWdpdFNlcnZpY2Uud3JpdGVGaWxlKHtcbiAgICAgICAgICAgIGRhdGE6ICcnLFxuICAgICAgICAgICAgcGF0aDogZmlsZVBhdGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuc2V0U3RhdGUoe2N1cnJlbnRGaWxlOiBmaWxlUGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db21taXRDb2x1bW5SZW5kZXJlcihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmRhdGFGaWVsZCA9PT0gJ2F1dGhvcicpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnZhbHVlLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5kYXRhRmllbGQgPT09ICd0aW1lc3RhbXAnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2RlZmF1bHQnLCB7XG4gICAgICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHNlY29uZDogJ251bWVyaWMnXG4gICAgICAgICAgICB9KS5mb3JtYXQobmV3IERhdGUoZGF0YS52YWx1ZSAqIDEwMDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSByZWNvcmRcbiAgICAgKi9cbiAgICBvbkZpbGVJdGVtQ2xpY2socmVjb3JkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkZpbGVJdGVtQ2xpY2snLCByZWNvcmQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvbkVkaXRvckNoYW5nZShkYXRhKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvbkVkaXRvckNoYW5nZScsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgb25OZXdGaWxlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FkZERpYWxvZ30gPSBtZSxcbiAgICAgICAgICAgIGJ1dHRvbiAgICAgID0gZGF0YS5jb21wb25lbnQsXG4gICAgICAgICAgICB7YXBwTmFtZSwgdGhlbWUsIHdpbmRvd0lkfSA9IGJ1dHRvbjtcblxuICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICghYWRkRGlhbG9nKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4vQWRkRmlsZURpYWxvZy5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuYWRkRGlhbG9nID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVUYXJnZXRJZDogYnV0dG9uLmlkLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICAgICA6IHtoaWRlOiBkYXRhID0+IHtidXR0b24uZGlzYWJsZWQgPSBmYWxzZX19LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQ6IG1lLmNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGREaWFsb2cuc2hvdygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uU2F2ZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGxpdmVQcmV2aWV3ID0gbWUuZ2V0UmVmZXJlbmNlKCdjb2RlLWxpdmUtcHJldmlldycpLFxuICAgICAgICAgICAgY3VycmVudEZpbGUgPSBtZS5nZXRTdGF0ZSgnY3VycmVudEZpbGUnKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnb25TYXZlQnV0dG9uQ2xpY2snLCBtZS5nZXRTdGF0ZSgnY3VycmVudEZpbGUnKSwgbGl2ZVByZXZpZXcudmFsdWUpO1xuXG4gICAgICAgIGF3YWl0IExlZ2l0U2VydmljZS53cml0ZUZpbGUoe1xuICAgICAgICAgICAgZGF0YTogbGl2ZVByZXZpZXcudmFsdWUsXG4gICAgICAgICAgICBwYXRoOiBgJHtMZWdpdFNlcnZpY2UucGF0aH0vJHtjdXJyZW50RmlsZX1gXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge1JlY29yZFtdfSBkYXRhLnJlY29yZHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBkYXRhLnNlbGVjdGlvbiAvLyBzZWxlY3RlZCBkb20gbm9kZSBpZHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBkYXRhLnNvdXJjZSAgICAvLyBpZCBvZiB0aGUgZXZlbnQtZmlyaW5nIGluc3RhbmNlXG4gICAgICovXG4gICAgYXN5bmMgb25UcmVlTGlzdFNlbGVjdCh7cmVjb3Jkc30pIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGxpdmVQcmV2aWV3ID0gdGhpcy5nZXRSZWZlcmVuY2UoJ2NvZGUtbGl2ZS1wcmV2aWV3JyksXG4gICAgICAgICAgICByZWNvcmQgICAgICA9IHJlY29yZHM/LlswXSxcbiAgICAgICAgICAgIGxhbmd1YWdlICAgID0gcmVjb3JkLmlkLmluY2x1ZGVzKCcubWQnKSA/ICdtYXJrZG93bicgOiAnbmVvbWpzJztcblxuICAgICAgICBpZiAocmVjb3JkPy5pc0xlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe2N1cnJlbnRGaWxlOiByZWNvcmQuaWR9KTtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBMZWdpdFNlcnZpY2UucmVhZEZpbGUoYCR7TGVnaXRTZXJ2aWNlLnBhdGh9LyR7cmVjb3JkLmlkfWAsICd1dGYtOCcpO1xuXG4gICAgICAgICAgICBhd2FpdCBsaXZlUHJldmlldy5zZXQoe2xhbmd1YWdlLCB2YWx1ZX0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgcG9sbCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWUucnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZSA9IGF3YWl0IExlZ2l0U2VydmljZS5yZWFkRmlsZShMZWdpdFNlcnZpY2UucGF0aCArICcvLmxlZ2l0L2hlYWQnLCAndXRmLTgnKTtcblxuICAgICAgICAgICAgaWYgKG1lLmN1cnJlbnRUcmVlU3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb21taXRTdG9yZSA9IG1lLmdldFN0b3JlKCdjb21taXRTdG9yZScpO1xuICAgICAgICAgICAgY29uc3QgZmlsZVN0b3JlICAgPSBtZS5nZXRTdG9yZSgnZmlsZVN0b3JlJyk7XG4gICAgICAgICAgICBjb25zdCB0cmVlRGVsdGEgICA9IGF3YWl0IExlZ2l0U2VydmljZS5sb2FkVHJlZURlbHRhKG1lLmN1cnJlbnRUcmVlU3RhdGUsIG5ld1N0YXRlKTtcblxuICAgICAgICAgICAgY29tbWl0U3RvcmUuZGF0YSA9IGF3YWl0IExlZ2l0U2VydmljZS5sb2FkSGlzdG9yeSgpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVFJFRSBERUxUQTonLCB0cmVlRGVsdGEpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZWxldGVkRW50cnkgb2YgdHJlZURlbHRhLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRGVsZXRlZCBGUk9NIFRSRUU6ICcgKyBkZWxldGVkRW50cnkpO1xuICAgICAgICAgICAgICAgIGZpbGVTdG9yZS5yZW1vdmUoZGVsZXRlZEVudHJ5KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZGVkRW50cnkgb2YgdHJlZURlbHRhLmFkZGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZGVkIEZyb20gVHJlZTonICsgYWRkZWRFbnRyeSk7XG4gICAgICAgICAgICAgICAgZmlsZVN0b3JlLmluc2VydCgwLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBhZGRlZEVudHJ5LFxuICAgICAgICAgICAgICAgICAgICBuYW1lICAgIDogYWRkZWRFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG51bGxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1vZGlmaWVkRW50cnkgb2YgdHJlZURlbHRhLm1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgbmV3SXRlbSA9IGF3YWl0IGxlZ2l0RnMucmVhZEZpbGUocGF0aCArICcvJyArIGFkZGVkRW50cnksICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyB1cGRhdGUgaXRlbSBpbiB0cmVlIHN0b3JlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01PRElGSUVEIEZyb20gVHJlZTonICsgbW9kaWZpZWRFbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmN1cnJlbnRUcmVlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIG1lLnJ1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbk1vZGVsID0gbWUuZ2V0UmVmZXJlbmNlKCdmaWxlcy10cmVlJykuc2VsZWN0aW9uTW9kZWw7XG5cbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uTW9kZWwuaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5zZWxlY3RBdCgwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydENvbnRyb2xsZXIpO1xuIiwiaW1wb3J0IENvbW1pdFN0b3JlIGZyb20gJy4uL3N0b3JlL0NvbW1pdHMubWpzJztcbmltcG9ydCBGaWxlU3RvcmUgICBmcm9tICcuLi9zdG9yZS9GaWxlcy5tanMnO1xuaW1wb3J0IFByb3ZpZGVyICAgIGZyb20gJy4uLy4uLy4uL3NyYy9zdGF0ZS9Qcm92aWRlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBMZWdpdC52aWV3LlZpZXdwb3J0U3RhdGVQcm92aWRlclxuICogQGV4dGVuZHMgTmVvLnN0YXRlLlByb3ZpZGVyXG4gKi9cbmNsYXNzIFZpZXdwb3J0U3RhdGVQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0xlZ2l0LnZpZXcuVmlld3BvcnRTdGF0ZVByb3ZpZGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdMZWdpdC52aWV3LlZpZXdwb3J0U3RhdGVQcm92aWRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRhdGEuY3VycmVudEZpbGU9bnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdXJyZW50RmlsZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdG9yZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0b3Jlczoge1xuICAgICAgICAgICAgY29tbWl0U3RvcmU6IENvbW1pdFN0b3JlLFxuICAgICAgICAgICAgZmlsZVN0b3JlICA6IEZpbGVTdG9yZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydFN0YXRlUHJvdmlkZXIpOyIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGEgbGFiZWwgd2l0aCBhIHRleHRcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkxhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTGFiZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5MYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5MYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0YWc9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiAnbGFiZWwnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMYWJlbCk7XG4iLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IFRvb2xiYXIgICBmcm9tICcuLi90b29sYmFyL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBbiBleHRlbmRlZCBDb250YWluZXIgc3VwcG9ydGluZyBtdWx0aXBsZSBkb2NrZWQgaGVhZGVyIHRvb2xiYXJzXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5QYW5lbFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFBhbmVsIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuUGFuZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuUGFuZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGFuZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGFuZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tcGFuZWwnLCduZW8tY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXBhbmVsJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY29udGFpbmVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaGVhZGVyRGVmYXVsdHM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyRGVmYXVsdHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gaGVhZGVycz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtcz17bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBfbGF5b3V0OiB7XG4gICAgICAgICAgICBudHlwZTogJ3Zib3gnLFxuICAgICAgICAgICAgYWxpZ246ICdzdHJldGNoJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdmVydGljYWxIZWFkZXJzRmlyc3Q9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHZlcnRpY2FsSGVhZGVyc0ZpcnN0OiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmhhc0hlYWRlcnMoKSAmJiBtZS52ZXJ0aWNhbEhlYWRlcnNGaXJzdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWUubGF5b3V0ID0ge1xuICAgICAgICAgICAgICAgIG50eXBlOiAnaGJveCcsXG4gICAgICAgICAgICAgICAgYWxpZ246ICdzdHJldGNoJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXIgdGhlIGhlYWRlciBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSB7XG4gICAgICAgIGlmIChOZW8udHlwZU9mKGhlYWRlcikgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICAgICAgZmxleDogJzAgMSBhdXRvJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghaGVhZGVyLm1vZHVsZSAmJiAhaGVhZGVyLm50eXBlKSB7XG4gICAgICAgICAgICBjb25maWcuY2xzICAgPSBbJ25lby1wYW5lbC1oZWFkZXItdG9vbGJhcicsICduZW8tdG9vbGJhciddO1xuICAgICAgICAgICAgY29uZmlnLm50eXBlID0gJ3Rvb2xiYXInO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlYWRlci50ZXh0KSB7XG4gICAgICAgICAgICBjb25maWcuaXRlbXMgPSBbe1xuICAgICAgICAgICAgICAgIG50eXBlOiAnbGFiZWwnLFxuICAgICAgICAgICAgICAgIGNscyAgOiBbJ25lby1wYW5lbC1oZWFkZXItdGV4dCcsICduZW8tbGFiZWwnXSxcbiAgICAgICAgICAgICAgICB0ZXh0IDogaGVhZGVyLnRleHRcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBkZWxldGUgaGVhZGVyLnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhc3N1bWluZyBhbGwgbGFiZWxzIGluc2lkZSBhIFBhbmVsIEhlYWRlciBhcmUgbWVhbnQgdG8gYmUgdGl0bGVzIC0+IGxvb2sgdGhlIHNhbWUgd2F5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlci5pdGVtcykpIHtcbiAgICAgICAgICAgIGhlYWRlci5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLm50eXBlID09PSAnbGFiZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2xzID0gWyduZW8tcGFuZWwtaGVhZGVyLXRleHQnLCAnbmVvLWxhYmVsJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gey4uLmNvbmZpZywgLi4uaGVhZGVyfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29udGFpbmVyQ29uZmlnID0gbWUuY29udGFpbmVyQ29uZmlnO1xuXG4gICAgICAgIGlmICghbWUuaGFzSGVhZGVycygpKSB7XG4gICAgICAgICAgICBjb250YWluZXJDb25maWcgJiYgbWUuc2V0KGNvbnRhaW5lckNvbmZpZyk7XG4gICAgICAgICAgICBzdXBlci5jcmVhdGVJdGVtcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGhmICAgICAgICAgICAgICAgICAgID0gbWUudmVydGljYWxIZWFkZXJzRmlyc3QgPT09IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMgICAgICAgICAgICAgID0gbWUuaGVhZGVycyB8fCBbXSxcbiAgICAgICAgICAgICAgICBib3R0b21IZWFkZXJzICAgICAgICA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7cmV0dXJuIGhlYWRlci5kb2NrID09PSAoaGYgPydib3R0b20nOiAncmlnaHQnKX0pLFxuICAgICAgICAgICAgICAgIGxlZnRIZWFkZXJzICAgICAgICAgID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtyZXR1cm4gaGVhZGVyLmRvY2sgPT09IChoZiA/J2xlZnQnICA6ICd0b3AnKX0pLFxuICAgICAgICAgICAgICAgIHJpZ2h0SGVhZGVycyAgICAgICAgID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtyZXR1cm4gaGVhZGVyLmRvY2sgPT09IChoZiA/J3JpZ2h0JyA6ICdib3R0b20nKX0pLFxuICAgICAgICAgICAgICAgIHRvcEhlYWRlcnMgICAgICAgICAgID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtyZXR1cm4gaGVhZGVyLmRvY2sgPT09IChoZiA/J3RvcCcgICA6ICdsZWZ0Jyl9KSxcbiAgICAgICAgICAgICAgICBoYXNIb3Jpem9udGFsSGVhZGVycyA9IGJvdHRvbUhlYWRlcnMubGVuZ3RoID4gMCB8fCB0b3BIZWFkZXJzICAubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICBoYXNWZXJ0aWNhbEhlYWRlcnMgICA9IGxlZnRIZWFkZXJzICAubGVuZ3RoID4gMCB8fCByaWdodEhlYWRlcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICB7aXRlbXN9ICAgICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcyAgICAgID0gW10sXG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcyAgICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBjb25maWc7XG5cbiAgICAgICAgICAgIHRvcEhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaGFzVmVydGljYWxIZWFkZXJzICYmIChoZiAmJiBoYXNIb3Jpem9udGFsSGVhZGVycyB8fCAhaGYgJiYgaGFzSG9yaXpvbnRhbEhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgbGVmdEhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgICAgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZmxleCAgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbURlZmF1bHRzOiBtZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMucHVzaCh7Li4ubWUuaGVhZGVyRGVmYXVsdHMsIC4uLmNvbmZpZ30pO1xuXG4gICAgICAgICAgICAgICAgcmlnaHRIZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zLnB1c2goUGFuZWwuY3JlYXRlSGVhZGVyQ29uZmlnKGhlYWRlcikpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICA6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyAgICA6IGhvcml6b250YWxJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ICAgOiB7bnR5cGU6IChoZiA/ICdoYm94JyA6ICd2Ym94JyksIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6ICdib2R5Q29udGFpbmVyJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgICAgIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGZsZXggICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EZWZhdWx0czogbWUuaXRlbURlZmF1bHRzLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgICA6ICdib2R5Q29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaCh7Li4ubWUuaGVhZGVyRGVmYXVsdHMsIC4uLmNvbmZpZ30pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdHRvbUhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IHZlcnRpY2FsSXRlbXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1EZWZhdWx0cyA9IG51bGw7XG5cbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0hlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuaGVhZGVycykgJiYgdGhpcy5oZWFkZXJzLmxlbmd0aCA+IDBcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBhbmVsKTtcbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBWaWV3cG9ydCBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udGFpbmVyLlZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udGFpbmVyLlZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3ZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3ZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyAnbmVvLWJvZHktdmlld3BvcnQnIHRvIHRoZSBkb2N1bWVudC5ib2R5XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFwcGx5Qm9keUNscz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWluZyB0aGF0IGEgVmlld3BvcnQgaXMgdGhlIHRvcCBsZXZlbCB2aWV3IG9mIHlvdXIgYXBwLCBhbmQgeW91IHdhbnQgdG8gbW91bnQgaXQgcmlnaHQgYXdheS5cbiAgICAgICAgICogQ291bGQgYmUgd2l0aG91dCBhbnkgaXRlbXMuIFVzZSBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby12aWV3cG9ydCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby12aWV3cG9ydCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzIGEgbWFpbi5hZGRvbi5SZXNpemVPYnNlcnZlciBhbmQgZmlyZXMgYSBjdXN0b20gcmVzaXplIGV2ZW50XG4gICAgICAgICAqIHdoaWNoIG90aGVyIGluc3RhbmNlcyBjYW4gc3Vic2NyaWJlIHRvLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb25pdG9yU2l6ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb25pdG9yU2l6ZV86IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUubW9uaXRvclNpemUpIHtcbiAgICAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbe3Jlc2l6ZTogbWUub25Eb21SZXNpemUsIHNjb3BlOiBtZX1dKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IHt3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuYXBwbHlCb2R5Q2xzICYmIE5lby5tYWluLkRvbUFjY2Vzcy5hcHBseUJvZHlDbHMoe1xuICAgICAgICAgICAgY2xzOiBbJ25lby1ib2R5LXZpZXdwb3J0J10sXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Eb21SZXNpemUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3Jlc2l6ZScsIGRhdGEpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQge3Jlc29sdmVDYWxsYmFja30gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkJhc2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udHJvbGxlci5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250cm9sbGVyLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb21wb25lbnQtY29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb21wb25lbnQtY29udHJvbGxlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHBhcmVudF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlZmVyZW5jZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZWZlcmVuY2VzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHdpbmRvd0lkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb21wb25lbnR9ID0gbWU7XG5cbiAgICAgICAgbWUucmVmZXJlbmNlcyA9IHt9O1xuXG4gICAgICAgIGlmIChjb21wb25lbnQuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnQub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHBhcmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYXJlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCB0aGlzLmdldFBhcmVudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gW2NvbXBvbmVudF1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fEJvb2xlYW58bnVsbH1cbiAgICAgKi9cbiAgICBnZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudH0gPSBtZSxcbiAgICAgICAgICAgIGhhbmRsZXJDYjtcblxuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciB0aHMgZnVuY3Rpb24gKm5hbWUqIGZpcnN0IGluIHRoZSBDb21wb25lbnQgaXRzZWxmLlxuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBpdCwgcmV0dXJuIHRydWUgc28gY2FsbGluZyBjb2RlIGtub3dzIG5vdCB0byBjb250aW51ZSB0byBzZWFyY2guXG4gICAgICAgICAgICBoYW5kbGVyQ2IgPSByZXNvbHZlQ2FsbGJhY2soaGFuZGxlck5hbWUsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZXIgZm4gaXMgcmVzb2x2ZWQgaW4gdGhlIENvbXBvbmVudCBvciBpdHMgb3duIHBhcmVudCBjaGFpbi5cbiAgICAgICAgICAgIC8vIFJldHVybiBhIHN0YXR1cyBpbmRpY2F0aW5nIHRoYXQgd2UgZG8gbm90IG5lZWQgYW4gZWFybHkgYmluZGluZ1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJDYi5mbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmVvLmlzRnVuY3Rpb24obWVbaGFuZGxlck5hbWVdKSA/XG4gICAgICAgICAgICBtZSA6IHBhcmVudD8uZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IGNvbnRyb2xsZXIgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnR9ID0gbWU7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLmNvbXBvbmVudC5wYXJlbnQ/LmdldENvbnRyb2xsZXIoKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9kbzogdXBkYXRlIGNoYW5nZWQgcmVmZXJlbmNlcyAoZS5nLiBjb250YWluZXIucmVtb3ZlKCkgdGhlbiBjb250YWluZXIuYWRkKCkgdXNpbmcgdGhlIHNhbWUga2V5KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5yZWZlcmVuY2VzW25hbWVdO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5jb21wb25lbnQuZG93bih7cmVmZXJlbmNlOiBuYW1lfSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZWZlcmVuY2VzW25hbWVdID0gY29tcG9uZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50IHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNhbWVMZXZlbE9ubHk9ZmFsc2Ugd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3Qgc3RhdGVQcm92aWRlciBpbnNpZGUgdGhlIGNvbXBvbmVudCBwYXJlbnQgdHJlZSxcbiAgICAgKiBpbiBjYXNlIHRoZXJlIGlzIG5vbmUgb24gdGhlIHNhbWUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2FtZUxldmVsT25seT1mYWxzZV1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZVByb3ZpZGVyKHNhbWVMZXZlbE9ubHk9ZmFsc2UpIHtcbiAgICAgICAgbGV0IHtjb21wb25lbnR9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNhbWVMZXZlbE9ubHkgPyBjb21wb25lbnQuc3RhdGVQcm92aWRlciA6IGNvbXBvbmVudC5nZXRTdGF0ZVByb3ZpZGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgYWNjZXNzaW5nIHN0YXRlLlByb3ZpZGVyIGJhc2VkIGRhdGEuU3RvcmVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKi9cbiAgICBnZXRTdG9yZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKGtleSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbnNpZGUgeW91ciB2aWV3IGNvbnRyb2xsZXJzIGFzIGEgc3RhcnRpbmcgcG9pbnQgaW4gY2FzZSB5b3UgbmVlZCByZWZlcmVuY2VzXG4gICAgICogKGluc3RlYWQgb2YgdXNpbmcgb25Db25zdHJ1Y3RlZCgpIGluc2lkZSB5b3VyIGNvbnRyb2xsZXIpXG4gICAgICovXG4gICAgb25Db21wb25lbnRDb25zdHJ1Y3RlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGdldCBjYWxsZWQgYnkgY29tcG9uZW50LkJhc2U6IGRlc3Ryb3koKSBpbiBjYXNlIHRoZSBjb21wb25lbnQgaGFzIGEgcmVmZXJlbmNlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3JlZmVyZW5jZXN9ID0gbWUsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gcmVmZXJlbmNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlZmVyZW5jZXNba2V5XTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0UGFyZW50KCk/LnJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHNldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuc2V0RGF0YSguLi5hcmdzKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBCdXR0b24gICAgZnJvbSAnLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMYWJlbCAgICAgZnJvbSAnLi4vY29tcG9uZW50L0xhYmVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRvb2xiYXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgZG9ja1xuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkb2NrUG9zaXRpb25zPVsndG9wJywncmlnaHQnLCdib3R0b20nLCdsZWZ0JywgbnVsbF1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRvY2tQb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsIG51bGxdXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50b29sYmFyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50b29sYmFyLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0b29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRvb2xiYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRvY2tfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkb2NrXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtudHlwZTonYnV0dG9uJ31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOidmbGV4Ym94JyxhbGlnbjonY2VudGVyJyxkaXJlY3Rpb246ICdyb3cnLCBwYWNrOidzdGFydCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICBudHlwZSAgICA6ICdmbGV4Ym94JyxcbiAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRvY2sgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiAhb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgZG9ja1Bvc2l0aW9ucyA9IG1lLmdldFN0YXRpY0NvbmZpZygnZG9ja1Bvc2l0aW9ucycpLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnICA9IG1lLmdldExheW91dENvbmZpZygpO1xuXG4gICAgICAgIGRvY2tQb3NpdGlvbnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5ICE9PSBudWxsICYmIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8tZG9jay0nICsga2V5LCBrZXkgPT09IHZhbHVlKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW1lLmxheW91dCkge1xuICAgICAgICAgICAgbGF5b3V0Q29uZmlnLm50eXBlID0gJ2ZsZXhib3gnO1xuICAgICAgICAgICAgbWUuc2V0KHtjbHMsIGxheW91dDogbGF5b3V0Q29uZmlnfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmxheW91dC5zZXQobGF5b3V0Q29uZmlnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IGRvY2sgcG9zaXRpb24gbWF0Y2hlcyBhIHZhbHVlIG9mIHRoZSBzdGF0aWMgZG9ja1Bvc2l0aW9ucyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZG9jaycsICdkb2NrUG9zaXRpb25zJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLl9pdGVtcztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF5b3V0IGNvbmZpZyBkZXBlbmRpbmcgb24gdGhpcy5kb2NrXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5b3V0Q29uZmlnXG4gICAgICovXG4gICAgZ2V0TGF5b3V0Q29uZmlnKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnO1xuXG4gICAgICAgIGlmIChtZS5kb2NrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1lLmRvY2spIHtcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdjb2x1bW4tcmV2ZXJzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5b3V0Q29uZmlnIHx8IG1lLmxheW91dFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gaXRlbSBvciBhcnJheSBvZiBpdGVtcyBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKi9cbiAgICBpbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ubWFwKGl0ZW0gPT4gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydChpbmRleCwgaXRlbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gaXRlbVxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9XG4gICAgICovXG4gICAgcmVwbGFjZVNwYWNlcihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtID09PSAnLT4nID8ge21vZHVsZTogQ29tcG9uZW50LCBmbGV4OiAxfSA6IGl0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgZG9jazogdGhpcy5kb2NrXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvb2xiYXIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==