"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_form_field_ComboBox_mjs"],{

/***/ "./src/form/field/ComboBox.mjs"
/*!*************************************!*\
  !*** ./src/form/field/ComboBox.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../list/Base.mjs */ "./src/list/Base.mjs");
/* harmony import */ var _Picker_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Picker.mjs */ "./src/form/field/Picker.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");








/**
 * @summary A highly configurable input field that provides a dropdown list for item selection, filtering, and autocompletion.
 *
 * The ComboBox is a powerful and flexible component that combines a text input with a dropdown list (picker).
 * It supports several key operational modes controlled by its configuration, making it adaptable to a wide range of use cases.
 *
 * ---
 * ### Core Features & Modes:
 *
 * 1.  **Editable vs. Non-Editable (`editable` config):**
 *     - `editable: true` (default): Users can type freely into the input field. A click focuses the field, and picker visibility is typically triggered by typing, arrow keys, or the trigger icon.
 *     - `editable: false`: The field behaves more like a traditional `<select>` element. The input is non-editable, and a click on either the field or the trigger icon opens the picker.
 *
 * 2.  **Type Ahead (`typeAhead` config):**
 *     - When `true`, the component displays a "hint" of the first matching record in a grayed-out overlay within the input field as the user types. This provides an immediate suggestion for autocompletion.
 *
 * 3.  **Force Selection (`forceSelection` config):**
 *     - When `true` (default), the component ensures that the field's final value corresponds to a valid record from the store.
 *     - On blur, if the user has typed partial text, the component will automatically select the "closest" match (the current typeahead suggestion) and fill the input with its full `displayField` value.
 *
 * 4.  **Filtering (`useFilter`, `filterOperator`, `triggerAction`):**
 *     - The dropdown list can be dynamically filtered as the user types.
 *     - The `triggerAction` config determines whether clicking the trigger icon shows all items or only the currently filtered items.
 *
 * ---
 * Conforms to ARIA accessibility standards outlined in https://www.w3.org/WAI/ARIA/apg/patterns/combobox/
 *
 * @class Neo.form.field.ComboBox
 * @extends Neo.form.field.Picker
 */
class ComboBox extends _Picker_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    /**
     * Valid values for triggerAction
     * @member {String[]} triggerActions=['all','filtered']
     * @protected
     * @static
     */
    static triggerActions = ['all', 'filtered']

    static config = {
        /**
         * @member {String} className='Neo.form.field.ComboBox'
         * @protected
         */
        className: 'Neo.form.field.ComboBox',
        /**
         * @member {String} ntype='combobox'
         * @protected
         */
        ntype: 'combobox',
        /**
         * @member {String|Number|null} activeRecordId=null
         */
        activeRecordId: null,
        /**
         * @member {String[]} baseCls=['neo-combobox','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-combobox', 'neo-pickerfield', 'neo-textfield'],
        /**
         * @member {String} displayField='name'
         */
        displayField: 'name',
        /**
         * The millisecond time to delay between input field mutation and applying the input field's
         * new value to the filter
         * @member {Number} filterDelay=50
         */
        filterDelay : 50,
        /**
         * @member {String} filterOperator_='like'
         * @reactive
         */
        filterOperator_: 'like',
        /**
         * True will only fire a change event, in case the TextField input value matches a record.
         * onFocusLeave() will try to select a hint record, if needed and possible.
         * @member {Boolean} forceSelection=true
         */
        forceSelection: true,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {
            Down  : 'onKeyDownDown',
            Escape: 'onKeyDownEscape'
        },
        /**
         * @member {String|null} lastManualInput=null
         * @protected
         */
        lastManualInput: null,
        /**
         * @member {Neo.list.Base} list=null
         * @protected
         */
        list: null,
        /**
         * @member {Object|null} listConfig_=null
         * @reactive
         */
        listConfig_: null,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerHeight=null
         */
        pickerHeight: null,
        /**
         * @member {String|null} role='combobox'
         * @reactive
         */
        role: 'combobox',
        /**
         * @member {Neo.data.Store|null} store_=null
         * @reactive
         */
        store_: null,
        /**
         * Showing the list via the down trigger can either show all list items or only show items which
         * match the filter string inside the input field.
         * Valid values: all, filtered
         * @member {String} triggerAction_='all'
         * @reactive
         */
        triggerAction_: 'all',
        /**
         * Display the first matching result while typing
         * @member {Boolean} typeAhead_=true
         * @reactive
         */
        typeAhead_: true,
        /**
         * Set this config to false, in case typing into the input field should not filter list items
         * @member {Boolean} useFilter_=true
         * @reactive
         */
        useFilter_: true,
        /**
         * This config should point to the store keyProperty or a different model field,
         * which you want to submit instead
         * @member {Number|String} valueField='id'
         */
        valueField: 'id',
        /**
         * Default width to prevent rendering issues.
         * @member {Number} width=150
         * @reactive
         */
        width: 150
    }

    /**
     * Internal flag to store the value, in case it was set before the store was loaded
     * @member {Number|String} preStoreLoadValue=null
     */
    preStoreLoadValue = null
    /**
     * Internal flag to not show a picker when non user-based input value changes happen
     * @member {Boolean} programmaticValueChange=false
     */
    programmaticValueChange = false

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // Create buffered function to respond to input field mutation
        me.filterOnInput = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.buffer)(me.filterOnInput, me, me.filterDelay);

        me.typeAhead && me.updateTypeAhead()
    }

    /**
     * Triggered after the inputValue config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetInputValue(value, oldValue) {
        super.afterSetInputValue(value, oldValue);
        this.updateTypeAheadValue(value)
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store} value
     * @param {Neo.data.Store} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me = this,
            filters;

        if (value) {
            if (me.useFilter) {
                filters = value.filters || [];

                filters.push({
                    includeEmptyValues: true,
                    operator          : me.filterOperator,
                    property          : me.displayField,
                    value             : value?.[me.displayField] || null
                });

                value.filters = filters
            }

            if (me.list) {
                me.list.store = value
            }

            value.on('load', me.onStoreLoad, me)
        }
    }

    /**
     * Triggered after the typeAhead config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetTypeAhead(value, oldValue) {
        this.vnodeInitialized && this.updateTypeAhead()
    }

    /**
     * Triggered after the value config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this;

        // input value changes (super call) need a flag to prevent showing the picker
        me.programmaticValueChange = true;
        super.afterSetValue(value, oldValue);
        me.programmaticValueChange = false;

        if (me._picker?.isVisible) {
            let selectionModel = me.list?.selectionModel;

            if (value) {
                selectionModel?.select(value)
            } else {
                selectionModel?.deselectAll()
            }
        }
    }

    /**
     * Triggered before the listConfig config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetListConfig(value, oldValue) {
        value && this.parseItemConfigs(value);
        return value
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store|null} value
     * @param {Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        let me                         = this,
            {displayField, valueField} = me;

        // Do not create a default store instance, in case there is a bound store to be created
        if (!value && me.bind?.store) {
            return null
        }

        oldValue?.destroy();

        // Promote an array of items to be a Store
        if (Array.isArray(value)) {
            value = {
                data: value.map((v, i) => {
                    // Simplest case is just picking string values.
                    if (typeof v === 'string') {
                        v = {
                            [displayField]: v,
                            [valueField]  : v
                        }
                    }

                    return v
                })
            }
        }

        // to reduce boilerplate code, a store config object without a defined model should default
        // to displayField & valueField defaults
        if (Neo.typeOf(value) === 'Object' && !value.model && !value.module && !value.ntype) {
            value.model = {
                fields: [
                    {name: displayField, type: 'String'},
                    {name: valueField,   type: 'String'}
                ]
            }
        }

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"])
    }

    /**
     * Triggered before the triggerAction config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTriggerAction(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'triggerAction')
    }

    /**
     * Triggered before the value config gets changed.
     * @param {Number|Object|String} value
     * @param {Number|Object|String} oldValue
     * @returns {Number|Object|String}
     * @protected
     */
    beforeSetValue(value, oldValue) {
        let me                    = this,
            {displayField, store} = me,
            record;

        // getting a record, nothing to do
        if (Neo.isRecord(value)) {
            return value
        }

        if (value === null) {
            return null
        }

        if (!store) { // We will (re)set the value once the store is created
            return value
        }

        // we can only match record ids or display values in case the store is loaded
        if (store.isLoaded) {
            record = store.isFiltered() ? store.allItems.get(value) : store.get(value);

            if (record) {
                return record
            }

            return store.find(displayField, value)[0] || null
        } else {
            // store not loaded yet
            me.preStoreLoadValue = value;
            return null
        }
    }

    /**
     * @returns {Neo.list.Base}
     */
    createPickerComponent() {
        let me         = this,
            {windowId} = me;

        me.list = Neo.create({
            module        : _list_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            appName       : me.appName,
            displayField  : me.displayField,
            itemRole      : 'option',
            itemsFocusable: false,
            keepFocusIndex: true,
            navigator     : {eventSource: me.getInputElId(), windowId},
            parentId      : me.id,
            role          : 'listbox',
            selectionModel: {stayInList: false},
            store         : me.store,
            windowId,
            ...me.listConfig
        });

        me.getInputEl()['aria-controls'] = me.list.id;

        me.list.addDomListeners({
            neonavigate: {
                fn   : me.onListItemNavigate,
                scope: me
            }
        });

        me.list.selectionModel.on({
            noChange       : me.onListItemSelectionNoChange,
            selectionChange: me.onListItemSelectionChange,
            scope          : me
        });

        return me.list
    }

    /**
     * All routes which expect to open the picker route through here. This updates the
     * filter and ensures that the picker is visible and reflecting the state of the filter.
     *
     * Input event processing passes the current input field value in as the filter value.
     *
     * Invocation of the expand trigger passes `null` so as to clear filtering.
     * @private
     * @param {String|null} value The value to filter the picker by
     */
    doFilter(value) {
        let me              = this,
            {picker, store} = me,
            record          = me.value,
            filter          = store.getFilter(me.displayField);

        if (filter) {
            filter.value = value
        }

        // Filter resulting in something to show
        if (store.getCount()) {
            me.showPicker();

            // List might not exist until the picker is created
            let {list}           = me,
                {selectionModel} = list,
                index            = store.indexOf(record);

            // On show, set the active item to be the current selected record or the first
            if (record) {
                // We do not want to hear back about our own selection
                selectionModel.suspendEvents = true;
                selectionModel.select(record);
                selectionModel.suspendEvents = false
            }

            list._focusIndex = -1; // silent update to ensure afterSetFocusIndex() always gets called
            list.focusIndex  = index > -1 ? index : 0
        }
        // Filtered down to nothing - hide picker if it has been created.
        else {
            picker?.hide()
        }
    }

    /**
     * @param {String} value
     */
    filterOnInput(value) {
        if (value) {
            this.doFilter(value)
        } else {
            this.picker?.hide()
        }
    }

    /**
     * Overrides form.field.Base
     * @param {*} value
     * @param {*} oldValue
     * @override
     */
    fireChangeEvent(value, oldValue) {
        let me            = this,
            FormContainer = Neo.form?.Container,
            params        = {component: me, oldValue, value};

        me.fire('change', params);

        if (!me.suspendEvents) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(me).forEach(parent => {
                if (FormContainer && parent instanceof FormContainer) {
                    parent.fire('fieldChange', params)
                }
            })
        }
    }

    /**
     * @returns {Object}
     */
    getInputHintEl() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].find(this.vdom, this.getInputHintId())?.vdom
    }

    /**
     * @returns {String}
     */
    getInputHintId() {
        return this.id + '__input-hint'
    }

    /**
     * Returns the first selected record or null
     * @returns {Object}
     */
    getRecord() {
        let {list}    = this,
            recordKey = list.selectionModel.getSelection()[0];

        return recordKey && this.store.get(list.getItemRecordId(recordKey)) || null
    }

    /**
     * @returns {Number|String}
     */
    getSubmitValue() {
        let me = this;

        return me.value?.[me.valueField] || me.emptyValue
    }

    /**
     *
     */
    onConstructed() {
        const inputEl = this.getInputEl();

        inputEl['aria-activedescendant'] = '';
        inputEl['aria-expanded']         = false;
        inputEl['aria-haspopup']         = 'listbox';

        super.onConstructed(...arguments)
    }

    /**
     * Handles the component losing focus. This is a critical method for `forceSelection` behavior.
     * If `forceSelection` is true and the user has typed partial text without explicitly selecting an item,
     * this method selects the current typeahead suggestion (`activeRecordId`) and sets it as the component's value.
     * It is also responsible for clearing the typeahead hint.
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @protected
     */
    onFocusLeave(data) {
        let me = this;

        /*
         * If we are leaving the field, using forceSelection=true and the field does not have a selected record,
         * we do want to pick the closest match => the focussed record (honoring filters).
         * If no record is found, we will clear the field instead.
         */
        if (me.forceSelection && !me.value) {
            me.programmaticValueChange = true;
            me.value                   = me.store.get(me.activeRecordId);
            me.programmaticValueChange = false;
        }

        me.updateTypeAheadValue(null);

        super.onFocusLeave(data)
    }

    /**
     * @param {Object} data
     * @protected
     */
    onKeyDownDown(data) {
        let me = this;

        if (!me.picker || me.picker?.hidden) {
            me.onPickerTriggerClick()
        }
    }

    /**
     * todo:
     * When we are using a `Collection` as our `valueCollection`, and that `Collection` is the
     * `items` of the List's `selectionModel`, then this will be `onValueCollectionChange`,
     * a `mutate` listener on our own `valueCollection` which backs our `value` field which
     * will be implemented by a getter which accesses `valueCollection`.
     * This will become important for implementing multiSelect
     * @param {Object} selectionChangeEvent
     * @param {Object[]} selectionChangeEvent.selection
     * @protected
     */
    async onListItemSelectionChange({selection}) {
        if (selection?.length) {
            let me       = this,
                selected = selection[0],
                record   = typeof selected === 'string' ? me.store.get(me.list.getItemRecordId(selected)) : selected;

            me.hintRecordId = null;

            me.updateTypeAheadValue(null, true);

            await me.hidePicker();

            me.preventFiltering = true;
            me.value            = record;
            me.preventFiltering = false;

            me.fire('select', {
                value: record
            })
        }
    }

    /**
     * Selection was attempted to be changed but resulted in no action.
     * For example clicking on already selected list item.
     */
    onListItemSelectionNoChange() {
        this.hidePicker()
    }

    /**
     * Handles virtual focus navigation within the picker list (e.g., via arrow keys).
     * This method updates the `activeRecord` and `activeRecordId` to track the focused list item.
     * It then calls `updateTypeAheadValue` to ensure the typeahead hint is reset, preventing a mismatch
     * between the navigated item and the original typed-text suggestion.
     * @param {Object} data The neonavigate event data from the list.
     * @protected
     */
    onListItemNavigate(data) {
        let {activeIndex} = data;

        if (activeIndex >= 0) {
            let me      = this,
                {store} = me;

            me.activeRecord   = data.record || store.getAt(activeIndex);
            me.activeRecordId = me.activeRecord[store.getKeyProperty()];

            // Update typeahead hint (which updates DOM), or update DOM
            me.typeAhead ? me.updateTypeAheadValue(me.lastManualInput) : me.update()
        }
    }

    /**
     * @param {Object} data
     */
    onPickerHiddenChange({ value }) {
        const inputEl = this.getInputEl();

        super.onPickerHiddenChange(...arguments);

        if (value) {
            inputEl['aria-activedescendant'] = ''
        }

        inputEl['aria-expanded'] = !value;
        this.update()
    }

    /**
     * Selecting a record, if required
     * @param {Object[]} items
     */
    onStoreLoad(items) {
        let me    = this,
            value = me.preStoreLoadValue;

        if (value !== null) {
            me._value = undefined; // silent update
            me.value  = value
        }
    }

    /**
     *
     */
    selectFirstListItem() {
        this.selectListItem(0)
    }

    /**
     *
     */
    selectLastListItem() {
        this.selectListItem(this.store.getCount() -1)
    }

    /**
     * If no index is passed, the index matching to the field input will get used (0 if none)
     * @param {Number} [index]
     */
    selectListItem(index) {
        let me = this;

        if (!Neo.isNumber(index)) {
            if (me.activeRecordId) {
                index = me.store.indexOfKey(me.activeRecordId)
            } else {
                index = 0
            }
        }

        me.list.selectItem(index)
    }

    /**
     * @override
     */
    togglePicker() {
        let me       = this,
            {picker} = me;

        if (picker?.hidden === false) {
            picker.hidden = true
        } else if (!me.disabled && !me.readOnly) {
            me.doFilter(null)
        }
    }

    /**
     * Override this method as needed inside class extensions.
     * @param {*} value
     * @protected
     */
    updateInputValueFromValue(value) {
        let inputValue = null;

        if (Neo.isObject(value) || Neo.isRecord(value)) {
            inputValue = value[this.displayField]
        }

        this.inputValue = inputValue
    }

    /**
     * @param {Boolean} [silent=false]
     * @protected
     */
    updateTypeAhead(silent=false) {
        let me      = this,
            inputEl = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].find(me.vdom, {flag: 'neo-real-input'});

        if (me.typeAhead) {
            inputEl.parentNode.cn[inputEl.index] = {
                tag: 'span',
                cls: ['neo-input-field-wrapper'],
                cn : [{
                    tag         : 'input',
                    autocomplete: 'no', // while "off" is the correct value, browser vendors ignore it. Arbitrary strings do the trick.
                    autocorrect : 'off',
                    cls         : ['neo-textfield-input', 'neo-typeahead-input'],
                    disabled    : true,
                    id          : me.getInputHintId(),
                    spellcheck  : 'false'
                }, inputEl.vdom]
            }
        } else {
            _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].replaceVdomChild(me.vdom, inputEl.parentNode.id, inputEl.vdom)
        }

        !silent && me.update()
    }

    /**
     * Manages the typeahead hint overlay.
     * When a user types, this method searches for the first matching record in the store. If a match is found,
     * it populates a secondary, grayed-out input field with the remainder of the suggested term.
     * This method is also responsible for setting the `activeRecordId`, which is used by `forceSelection` on blur.
     * @param {String|null} value=this.lastManualInput The text to search for.
     * @param {Boolean} silent=false True to prevent a VDOM update.
     * @protected
     */
    updateTypeAheadValue(value=this.lastManualInput, silent=false) {
        let me                    = this,
            match                 = false,
            inputHintEl           = me.getInputHintEl(),
            {displayField, store} = me;

        if (me.typeAhead) {
            if (!me.value && value?.length > 0) {
                const search = value.toLocaleLowerCase();

                for (let i = 0; i < store.count; i++) {
                    const r = store.getAt(i);
                    if (r[displayField]?.toLowerCase?.()?.startsWith(search)) {
                        match = r;
                        break;
                    }
                }

                if (match && inputHintEl) {
                    inputHintEl.value = value + match[displayField].substr(value.length);
                    me.activeRecord   = match;
                    me.activeRecordId = match[store.getKeyProperty()]
                }
            }

            if (!match && inputHintEl) {
                inputHintEl.value = me.activeRecord = me.activeRecordId = null;
            }

            !silent && me.update()
        }
    }
    /**
     * @param {String} inputValue
     * @protected
     */
    updateValueFromInputValue(inputValue) {
        let me = this;

        me.lastManualInput = inputValue;

        if (!me.programmaticValueChange) {
            // changing the input => silent record reset
            me._value = null;
            me.list?.selectionModel.deselectAll();

            me.filterOnInput(inputValue)
        }
    }
}

/**
 * The select event fires when a list item gets selected
 * @event select
 * @param {Object} record
 * @param {value} record[store.getKeyProperty()]
 * @returns {Object}
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ComboBox));


/***/ },

/***/ "./src/form/field/Picker.mjs"
/*!***********************************!*\
  !*** ./src/form/field/Picker.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _trigger_Picker_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trigger/Picker.mjs */ "./src/form/field/trigger/Picker.mjs");
/* harmony import */ var _Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Text.mjs */ "./src/form/field/Text.mjs");





/**
 * The abstract picker field provides an arrow down trigger which opens a floating container to provide
 * more data selection options
 * @class Neo.form.field.Picker
 * @extends Neo.form.field.Text
 * @abstract
 */
class Picker extends _Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Picker'
         * @protected
         */
        className: 'Neo.form.field.Picker',
        /**
         * @member {String} ntype='pickerfield'
         * @protected
         */
        ntype: 'pickerfield',
        /**
         * @member {String[]} baseCls=['neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-pickerfield', 'neo-textfield'],
        /**
         * Stores the data from the getBoundingClientRect() call (picker & body DomRects)
         * @member {Array} clientRects=null
         * @protected
         */
        clientRects: null,
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {
            Enter : 'onKeyDownEnter',
            Escape: 'onKeyDownEscape'
        },
        /**
         * @member {Neo.container.Base|null} picker=null
         * @protected
         */
        picker: null,
        /**
         * Configs to pass to the picker container
         * @member {Object|null} pickerConfig=null
         */
        pickerConfig: null,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerHeight=100
         */
        pickerHeight: 100,
        /**
         * @member {Boolean} pickerIsMounted_=false
         * @protected
         * @reactive
         */
        pickerIsMounted_: false,
        /**
         * The height of the picker container. Defaults to px.
         * @member {Number|null} pickerMaxHeight=200
         */
        pickerMaxHeight: 200,
        /**
         * The width of the picker container. Defaults to px.
         * By default, the width of the picker matches the width of the input wrap element.
         * @member {Number|null} pickerWidth=null
         */
        pickerWidth: null,
        /**
         * @member {Boolean} showPickerOnFocus=false
         * @protected
         */
        showPickerOnFocus: false,
        /**
         * @member {Object|Object[]} triggers=[]
         * @protected
         * @reactive
         */
        triggers: [{
            module: _trigger_Picker_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]
        }]
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            click: me.onInputClick,
            scope: me
        })
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (value === false && oldValue && this.pickerIsMounted) {
            this.picker.hide()
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        if (this.picker) {
            this.picker.theme = value
        }
    }

    /**
     * @returns {Neo.container.Base}
     */
    createPicker() {
        const
            me              = this,
            {pickerWidth}   = me,
            pickerComponent = me.createPickerComponent();

        me.picker =  Neo.create({
            module   : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            parentId : 'document.body',
            floating : true,
            align    : {
                edgeAlign : pickerWidth ? 't0-b0' : 't-b',
                matchSize : !pickerWidth,
                axisLock  : true,
                target    : me.getInputWrapperId()
            },
            appName  : me.appName,
            cls      : ['neo-picker-container', 'neo-container'],
            height   : me.pickerHeight,
            hidden   : true,
            id       : me.getPickerId(),
            items    : pickerComponent ? [pickerComponent] : [],
            maxHeight: me.pickerMaxHeight,
            theme    : me.theme,
            width    : pickerWidth,
            windowId : me.windowId,
            ...me.pickerConfig,

            // scoped to the field instance
            onFocusLeave: data => {
                let insideField = false,
                    item;

                for (item of data.oldPath) {
                    if (item.id === me.id) {
                        insideField = true;
                        break
                    }
                }

                if (!insideField) {
                    me.hidePicker();
                    super.onFocusLeave(data)
                }
            }
        });

        me.picker.on('hiddenChange', me.onPickerHiddenChange, me);

        return me.picker
    }

    /**
     * Override this method to create your picker content as needed
     * @returns {Neo.component.Base|null}
     */
    createPickerComponent() {
        return null
    }

    /**
     * @param args
     */
    destroy(...args) {
        let {picker} = this;

        if (picker?.hidden === false) {
            picker.unmount()
        }

        picker?.destroy();
        super.destroy(...args)
    }

    /**
     * Returns the picker instance and creates it in case it does not exist yet
     * @returns {Neo.container.Base}
     */
    getPicker() {
        return this.picker || this.createPicker()
    }

    /**
     * @returns {String}
     */
    getPickerId() {
        return `${this.id}__picker`
    }

    /**
     *
     */
    async hidePicker() {
        if (this.picker) {
            this.picker.hidden = true
        }
    }

    /**
     * @param {Object} data
     * @protected
     */
    onFocusEnter(data) {
        super.onFocusEnter(data);

        let me = this;

        me.showPickerOnFocus && me.showPicker()
    }

    /**
     * @param {Object} data
     * @protected
     */
    onFocusLeave(data) {
        let me           = this,
            insidePicker = false,
            item;

        for (item of data.oldPath) {
            if (item.id === me.getPickerId()) {
                insidePicker = true;
                break
            }
        }

        if (!insidePicker) {
            me.hidePicker();
            super.onFocusLeave(data)
        }
    }

    /**
     * @param {Object} data
     */
    onInputClick(data) {
        !this.editable && this.togglePicker()
    }

    /**
     * @param {Object} data
     * @param {Function} [callback]
     * @param {Object} [callbackScope]
     * @protected
     */
    onKeyDownEnter(data, callback, callbackScope) {
        !this.pickerIsMounted && this.showPicker(callback, callbackScope)
    }

    /**
     * @param {Object} data
     * @protected
     */
    onKeyDownEscape(data) {
        if (this.pickerIsMounted) {
            this.hidePicker();

            // We processed this event, and it should not proceed to ancestor components
            data.cancelBubble = true;

            // And no further listeners should be notified
            return false
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.id
     * @param {Boolean} data.oldValue
     * @param {Boolean} data.value
     * @protected
     */
    onPickerHiddenChange(data) {
        this.pickerIsMounted = !data.value
    }

    /**
     * Called by form.field.trigger.Picker
     * @protected
     */
    onPickerTriggerClick() {
        this.togglePicker()
    }

    /**
     *
     */
    showPicker() {
        this.getPicker().hidden = false
    }

    /**
     *
     */
    togglePicker() {
        let picker = this.getPicker();
        picker.hidden = !picker.hidden
    }

    /**
     * Serializes the field into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            clientRects      : me.clientRects,
            picker           : me.picker?.toJSON(),
            pickerConfig     : me.serializeConfig(me.pickerConfig),
            pickerHeight     : me.pickerHeight,
            pickerIsMounted  : me.pickerIsMounted,
            pickerMaxHeight  : me.pickerMaxHeight,
            pickerWidth      : me.pickerWidth,
            showPickerOnFocus: me.showPickerOnFocus
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Picker));


/***/ },

/***/ "./src/form/field/trigger/Picker.mjs"
/*!*******************************************!*\
  !*** ./src/form/field/trigger/Picker.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/form/field/trigger/Base.mjs");


/**
 * Used by form.field.Picker
 * @class Neo.form.field.trigger.Picker
 * @extends Neo.form.field.trigger.Base
 */
class Picker extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.trigger.Picker'
         * @protected
         */
        className: 'Neo.form.field.trigger.Picker',
        /**
         * @member {String} ntype='trigger-picker'
         * @protected
         */
        ntype: 'trigger-picker',
        /**
         * @member {String|null} iconCls='fa fa-caret-down'
         * @reactive
         */
        iconCls: 'fa fa-caret-down',
        /**
         * Internal flag used by field.getTrigger()
         * @member {String} type='picker'
         * @protected
         */
        type: 'picker'
    }

    /**
     * @param {Object} data
     */
    onTriggerClick(data) {
        this.field.onPickerTriggerClick()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Picker));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mb3JtX2ZpZWxkX0NvbWJvQm94X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNHO0FBQ0M7QUFDUjtBQUNQO0FBQ1E7QUFDRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFNO0FBQzdCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsV1I7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQUk7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9Db21ib0JveC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL1BpY2tlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mb3JtL2ZpZWxkL3RyaWdnZXIvUGlja2VyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2J1ZmZlcn0gICAgICAgICBmcm9tICcuLi8uLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi8uLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IExpc3QgICAgICAgICAgICAgZnJvbSAnLi4vLi4vbGlzdC9CYXNlLm1qcyc7XG5pbXBvcnQgUGlja2VyICAgICAgICAgICBmcm9tICcuL1BpY2tlci5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICAgZnJvbSAnLi4vLi4vZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgQSBoaWdobHkgY29uZmlndXJhYmxlIGlucHV0IGZpZWxkIHRoYXQgcHJvdmlkZXMgYSBkcm9wZG93biBsaXN0IGZvciBpdGVtIHNlbGVjdGlvbiwgZmlsdGVyaW5nLCBhbmQgYXV0b2NvbXBsZXRpb24uXG4gKlxuICogVGhlIENvbWJvQm94IGlzIGEgcG93ZXJmdWwgYW5kIGZsZXhpYmxlIGNvbXBvbmVudCB0aGF0IGNvbWJpbmVzIGEgdGV4dCBpbnB1dCB3aXRoIGEgZHJvcGRvd24gbGlzdCAocGlja2VyKS5cbiAqIEl0IHN1cHBvcnRzIHNldmVyYWwga2V5IG9wZXJhdGlvbmFsIG1vZGVzIGNvbnRyb2xsZWQgYnkgaXRzIGNvbmZpZ3VyYXRpb24sIG1ha2luZyBpdCBhZGFwdGFibGUgdG8gYSB3aWRlIHJhbmdlIG9mIHVzZSBjYXNlcy5cbiAqXG4gKiAtLS1cbiAqICMjIyBDb3JlIEZlYXR1cmVzICYgTW9kZXM6XG4gKlxuICogMS4gICoqRWRpdGFibGUgdnMuIE5vbi1FZGl0YWJsZSAoYGVkaXRhYmxlYCBjb25maWcpOioqXG4gKiAgICAgLSBgZWRpdGFibGU6IHRydWVgIChkZWZhdWx0KTogVXNlcnMgY2FuIHR5cGUgZnJlZWx5IGludG8gdGhlIGlucHV0IGZpZWxkLiBBIGNsaWNrIGZvY3VzZXMgdGhlIGZpZWxkLCBhbmQgcGlja2VyIHZpc2liaWxpdHkgaXMgdHlwaWNhbGx5IHRyaWdnZXJlZCBieSB0eXBpbmcsIGFycm93IGtleXMsIG9yIHRoZSB0cmlnZ2VyIGljb24uXG4gKiAgICAgLSBgZWRpdGFibGU6IGZhbHNlYDogVGhlIGZpZWxkIGJlaGF2ZXMgbW9yZSBsaWtlIGEgdHJhZGl0aW9uYWwgYDxzZWxlY3Q+YCBlbGVtZW50LiBUaGUgaW5wdXQgaXMgbm9uLWVkaXRhYmxlLCBhbmQgYSBjbGljayBvbiBlaXRoZXIgdGhlIGZpZWxkIG9yIHRoZSB0cmlnZ2VyIGljb24gb3BlbnMgdGhlIHBpY2tlci5cbiAqXG4gKiAyLiAgKipUeXBlIEFoZWFkIChgdHlwZUFoZWFkYCBjb25maWcpOioqXG4gKiAgICAgLSBXaGVuIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBkaXNwbGF5cyBhIFwiaGludFwiIG9mIHRoZSBmaXJzdCBtYXRjaGluZyByZWNvcmQgaW4gYSBncmF5ZWQtb3V0IG92ZXJsYXkgd2l0aGluIHRoZSBpbnB1dCBmaWVsZCBhcyB0aGUgdXNlciB0eXBlcy4gVGhpcyBwcm92aWRlcyBhbiBpbW1lZGlhdGUgc3VnZ2VzdGlvbiBmb3IgYXV0b2NvbXBsZXRpb24uXG4gKlxuICogMy4gICoqRm9yY2UgU2VsZWN0aW9uIChgZm9yY2VTZWxlY3Rpb25gIGNvbmZpZyk6KipcbiAqICAgICAtIFdoZW4gYHRydWVgIChkZWZhdWx0KSwgdGhlIGNvbXBvbmVudCBlbnN1cmVzIHRoYXQgdGhlIGZpZWxkJ3MgZmluYWwgdmFsdWUgY29ycmVzcG9uZHMgdG8gYSB2YWxpZCByZWNvcmQgZnJvbSB0aGUgc3RvcmUuXG4gKiAgICAgLSBPbiBibHVyLCBpZiB0aGUgdXNlciBoYXMgdHlwZWQgcGFydGlhbCB0ZXh0LCB0aGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSBzZWxlY3QgdGhlIFwiY2xvc2VzdFwiIG1hdGNoICh0aGUgY3VycmVudCB0eXBlYWhlYWQgc3VnZ2VzdGlvbikgYW5kIGZpbGwgdGhlIGlucHV0IHdpdGggaXRzIGZ1bGwgYGRpc3BsYXlGaWVsZGAgdmFsdWUuXG4gKlxuICogNC4gICoqRmlsdGVyaW5nIChgdXNlRmlsdGVyYCwgYGZpbHRlck9wZXJhdG9yYCwgYHRyaWdnZXJBY3Rpb25gKToqKlxuICogICAgIC0gVGhlIGRyb3Bkb3duIGxpc3QgY2FuIGJlIGR5bmFtaWNhbGx5IGZpbHRlcmVkIGFzIHRoZSB1c2VyIHR5cGVzLlxuICogICAgIC0gVGhlIGB0cmlnZ2VyQWN0aW9uYCBjb25maWcgZGV0ZXJtaW5lcyB3aGV0aGVyIGNsaWNraW5nIHRoZSB0cmlnZ2VyIGljb24gc2hvd3MgYWxsIGl0ZW1zIG9yIG9ubHkgdGhlIGN1cnJlbnRseSBmaWx0ZXJlZCBpdGVtcy5cbiAqXG4gKiAtLS1cbiAqIENvbmZvcm1zIHRvIEFSSUEgYWNjZXNzaWJpbGl0eSBzdGFuZGFyZHMgb3V0bGluZWQgaW4gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9jb21ib2JveC9cbiAqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQ29tYm9Cb3hcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLlBpY2tlclxuICovXG5jbGFzcyBDb21ib0JveCBleHRlbmRzIFBpY2tlciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciB0cmlnZ2VyQWN0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHRyaWdnZXJBY3Rpb25zPVsnYWxsJywnZmlsdGVyZWQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHRyaWdnZXJBY3Rpb25zID0gWydhbGwnLCAnZmlsdGVyZWQnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5Db21ib0JveCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuQ29tYm9Cb3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tYm9ib3gnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tYm9ib3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfE51bWJlcnxudWxsfSBhY3RpdmVSZWNvcmRJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVSZWNvcmRJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvbWJvYm94JywnbmVvLXBpY2tlcmZpZWxkJywnbmVvLXRleHRmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb21ib2JveCcsICduZW8tcGlja2VyZmllbGQnLCAnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkaXNwbGF5RmllbGQ9J25hbWUnXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwbGF5RmllbGQ6ICduYW1lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaWxsaXNlY29uZCB0aW1lIHRvIGRlbGF5IGJldHdlZW4gaW5wdXQgZmllbGQgbXV0YXRpb24gYW5kIGFwcGx5aW5nIHRoZSBpbnB1dCBmaWVsZCdzXG4gICAgICAgICAqIG5ldyB2YWx1ZSB0byB0aGUgZmlsdGVyXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZmlsdGVyRGVsYXk9NTBcbiAgICAgICAgICovXG4gICAgICAgIGZpbHRlckRlbGF5IDogNTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGZpbHRlck9wZXJhdG9yXz0nbGlrZSdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJPcGVyYXRvcl86ICdsaWtlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgd2lsbCBvbmx5IGZpcmUgYSBjaGFuZ2UgZXZlbnQsIGluIGNhc2UgdGhlIFRleHRGaWVsZCBpbnB1dCB2YWx1ZSBtYXRjaGVzIGEgcmVjb3JkLlxuICAgICAgICAgKiBvbkZvY3VzTGVhdmUoKSB3aWxsIHRyeSB0byBzZWxlY3QgYSBoaW50IHJlY29yZCwgaWYgbmVlZGVkIGFuZCBwb3NzaWJsZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZm9yY2VTZWxlY3Rpb249dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9yY2VTZWxlY3Rpb246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHVzZWQga2V5cyBmb3IgdGhlIHNlbGVjdGlvbiBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGtleXNcbiAgICAgICAgICovXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICAgIERvd24gIDogJ29uS2V5RG93bkRvd24nLFxuICAgICAgICAgICAgRXNjYXBlOiAnb25LZXlEb3duRXNjYXBlJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGxhc3RNYW51YWxJbnB1dD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxhc3RNYW51YWxJbnB1dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5saXN0LkJhc2V9IGxpc3Q9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxpc3RDb25maWdfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0Q29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHBpY2tlciBjb250YWluZXIuIERlZmF1bHRzIHRvIHB4LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gcGlja2VySGVpZ2h0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBpY2tlckhlaWdodDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSByb2xlPSdjb21ib2JveCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb2xlOiAnY29tYm9ib3gnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93aW5nIHRoZSBsaXN0IHZpYSB0aGUgZG93biB0cmlnZ2VyIGNhbiBlaXRoZXIgc2hvdyBhbGwgbGlzdCBpdGVtcyBvciBvbmx5IHNob3cgaXRlbXMgd2hpY2hcbiAgICAgICAgICogbWF0Y2ggdGhlIGZpbHRlciBzdHJpbmcgaW5zaWRlIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiBhbGwsIGZpbHRlcmVkXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHJpZ2dlckFjdGlvbl89J2FsbCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyQWN0aW9uXzogJ2FsbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5IHRoZSBmaXJzdCBtYXRjaGluZyByZXN1bHQgd2hpbGUgdHlwaW5nXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHR5cGVBaGVhZF89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHR5cGVBaGVhZF86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gZmFsc2UsIGluIGNhc2UgdHlwaW5nIGludG8gdGhlIGlucHV0IGZpZWxkIHNob3VsZCBub3QgZmlsdGVyIGxpc3QgaXRlbXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlRmlsdGVyXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlRmlsdGVyXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY29uZmlnIHNob3VsZCBwb2ludCB0byB0aGUgc3RvcmUga2V5UHJvcGVydHkgb3IgYSBkaWZmZXJlbnQgbW9kZWwgZmllbGQsXG4gICAgICAgICAqIHdoaWNoIHlvdSB3YW50IHRvIHN1Ym1pdCBpbnN0ZWFkXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IHZhbHVlRmllbGQ9J2lkJ1xuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVGaWVsZDogJ2lkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgd2lkdGggdG8gcHJldmVudCByZW5kZXJpbmcgaXNzdWVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHdpZHRoPTE1MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpZHRoOiAxNTBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIHN0b3JlIHRoZSB2YWx1ZSwgaW4gY2FzZSBpdCB3YXMgc2V0IGJlZm9yZSB0aGUgc3RvcmUgd2FzIGxvYWRlZFxuICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd9IHByZVN0b3JlTG9hZFZhbHVlPW51bGxcbiAgICAgKi9cbiAgICBwcmVTdG9yZUxvYWRWYWx1ZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIG5vdCBzaG93IGEgcGlja2VyIHdoZW4gbm9uIHVzZXItYmFzZWQgaW5wdXQgdmFsdWUgY2hhbmdlcyBoYXBwZW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBwcm9ncmFtbWF0aWNWYWx1ZUNoYW5nZT1mYWxzZVxuICAgICAqL1xuICAgIHByb2dyYW1tYXRpY1ZhbHVlQ2hhbmdlID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGJ1ZmZlcmVkIGZ1bmN0aW9uIHRvIHJlc3BvbmQgdG8gaW5wdXQgZmllbGQgbXV0YXRpb25cbiAgICAgICAgbWUuZmlsdGVyT25JbnB1dCA9IGJ1ZmZlcihtZS5maWx0ZXJPbklucHV0LCBtZSwgbWUuZmlsdGVyRGVsYXkpO1xuXG4gICAgICAgIG1lLnR5cGVBaGVhZCAmJiBtZS51cGRhdGVUeXBlQWhlYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW5wdXRWYWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW5wdXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRJbnB1dFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlVHlwZUFoZWFkVmFsdWUodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBmaWx0ZXJzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1lLnVzZUZpbHRlcikge1xuICAgICAgICAgICAgICAgIGZpbHRlcnMgPSB2YWx1ZS5maWx0ZXJzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUVtcHR5VmFsdWVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciAgICAgICAgICA6IG1lLmZpbHRlck9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgICAgICAgICA6IG1lLmRpc3BsYXlGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgOiB2YWx1ZT8uW21lLmRpc3BsYXlGaWVsZF0gfHwgbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVycyA9IGZpbHRlcnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLmxpc3QpIHtcbiAgICAgICAgICAgICAgICBtZS5saXN0LnN0b3JlID0gdmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUub24oJ2xvYWQnLCBtZS5vblN0b3JlTG9hZCwgbWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHR5cGVBaGVhZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFR5cGVBaGVhZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52bm9kZUluaXRpYWxpemVkICYmIHRoaXMudXBkYXRlVHlwZUFoZWFkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIGlucHV0IHZhbHVlIGNoYW5nZXMgKHN1cGVyIGNhbGwpIG5lZWQgYSBmbGFnIHRvIHByZXZlbnQgc2hvd2luZyB0aGUgcGlja2VyXG4gICAgICAgIG1lLnByb2dyYW1tYXRpY1ZhbHVlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICBtZS5wcm9ncmFtbWF0aWNWYWx1ZUNoYW5nZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChtZS5fcGlja2VyPy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25Nb2RlbCA9IG1lLmxpc3Q/LnNlbGVjdGlvbk1vZGVsO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uc2VsZWN0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbD8uZGVzZWxlY3RBbGwoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbGlzdENvbmZpZyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldExpc3RDb25maWcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMucGFyc2VJdGVtQ29uZmlncyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0b3JlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuU3RvcmV8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZGlzcGxheUZpZWxkLCB2YWx1ZUZpZWxkfSA9IG1lO1xuXG4gICAgICAgIC8vIERvIG5vdCBjcmVhdGUgYSBkZWZhdWx0IHN0b3JlIGluc3RhbmNlLCBpbiBjYXNlIHRoZXJlIGlzIGEgYm91bmQgc3RvcmUgdG8gYmUgY3JlYXRlZFxuICAgICAgICBpZiAoIXZhbHVlICYmIG1lLmJpbmQ/LnN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICAvLyBQcm9tb3RlIGFuIGFycmF5IG9mIGl0ZW1zIHRvIGJlIGEgU3RvcmVcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZS5tYXAoKHYsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGxlc3QgY2FzZSBpcyBqdXN0IHBpY2tpbmcgc3RyaW5nIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzcGxheUZpZWxkXTogdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVGaWVsZF0gIDogdlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG8gcmVkdWNlIGJvaWxlcnBsYXRlIGNvZGUsIGEgc3RvcmUgY29uZmlnIG9iamVjdCB3aXRob3V0IGEgZGVmaW5lZCBtb2RlbCBzaG91bGQgZGVmYXVsdFxuICAgICAgICAvLyB0byBkaXNwbGF5RmllbGQgJiB2YWx1ZUZpZWxkIGRlZmF1bHRzXG4gICAgICAgIGlmIChOZW8udHlwZU9mKHZhbHVlKSA9PT0gJ09iamVjdCcgJiYgIXZhbHVlLm1vZGVsICYmICF2YWx1ZS5tb2R1bGUgJiYgIXZhbHVlLm50eXBlKSB7XG4gICAgICAgICAgICB2YWx1ZS5tb2RlbCA9IHtcbiAgICAgICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6IGRpc3BsYXlGaWVsZCwgdHlwZTogJ1N0cmluZyd9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTogdmFsdWVGaWVsZCwgICB0eXBlOiAnU3RyaW5nJ31cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBTdG9yZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB0cmlnZ2VyQWN0aW9uIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VHJpZ2dlckFjdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3RyaWdnZXJBY3Rpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHZhbHVlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8T2JqZWN0fFN0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Rpc3BsYXlGaWVsZCwgc3RvcmV9ID0gbWUsXG4gICAgICAgICAgICByZWNvcmQ7XG5cbiAgICAgICAgLy8gZ2V0dGluZyBhIHJlY29yZCwgbm90aGluZyB0byBkb1xuICAgICAgICBpZiAoTmVvLmlzUmVjb3JkKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0b3JlKSB7IC8vIFdlIHdpbGwgKHJlKXNldCB0aGUgdmFsdWUgb25jZSB0aGUgc3RvcmUgaXMgY3JlYXRlZFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBjYW4gb25seSBtYXRjaCByZWNvcmQgaWRzIG9yIGRpc3BsYXkgdmFsdWVzIGluIGNhc2UgdGhlIHN0b3JlIGlzIGxvYWRlZFxuICAgICAgICBpZiAoc3RvcmUuaXNMb2FkZWQpIHtcbiAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmlzRmlsdGVyZWQoKSA/IHN0b3JlLmFsbEl0ZW1zLmdldCh2YWx1ZSkgOiBzdG9yZS5nZXQodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RvcmUuZmluZChkaXNwbGF5RmllbGQsIHZhbHVlKVswXSB8fCBudWxsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9yZSBub3QgbG9hZGVkIHlldFxuICAgICAgICAgICAgbWUucHJlU3RvcmVMb2FkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TmVvLmxpc3QuQmFzZX1cbiAgICAgKi9cbiAgICBjcmVhdGVQaWNrZXJDb21wb25lbnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gPSBtZTtcblxuICAgICAgICBtZS5saXN0ID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogTGlzdCxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgZGlzcGxheUZpZWxkICA6IG1lLmRpc3BsYXlGaWVsZCxcbiAgICAgICAgICAgIGl0ZW1Sb2xlICAgICAgOiAnb3B0aW9uJyxcbiAgICAgICAgICAgIGl0ZW1zRm9jdXNhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBGb2N1c0luZGV4OiB0cnVlLFxuICAgICAgICAgICAgbmF2aWdhdG9yICAgICA6IHtldmVudFNvdXJjZTogbWUuZ2V0SW5wdXRFbElkKCksIHdpbmRvd0lkfSxcbiAgICAgICAgICAgIHBhcmVudElkICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIHJvbGUgICAgICAgICAgOiAnbGlzdGJveCcsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbDoge3N0YXlJbkxpc3Q6IGZhbHNlfSxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICAgOiBtZS5zdG9yZSxcbiAgICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICAgICAgLi4ubWUubGlzdENvbmZpZ1xuICAgICAgICB9KTtcblxuICAgICAgICBtZS5nZXRJbnB1dEVsKClbJ2FyaWEtY29udHJvbHMnXSA9IG1lLmxpc3QuaWQ7XG5cbiAgICAgICAgbWUubGlzdC5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgbmVvbmF2aWdhdGU6IHtcbiAgICAgICAgICAgICAgICBmbiAgIDogbWUub25MaXN0SXRlbU5hdmlnYXRlLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5saXN0LnNlbGVjdGlvbk1vZGVsLm9uKHtcbiAgICAgICAgICAgIG5vQ2hhbmdlICAgICAgIDogbWUub25MaXN0SXRlbVNlbGVjdGlvbk5vQ2hhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlOiBtZS5vbkxpc3RJdGVtU2VsZWN0aW9uQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWUubGlzdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCByb3V0ZXMgd2hpY2ggZXhwZWN0IHRvIG9wZW4gdGhlIHBpY2tlciByb3V0ZSB0aHJvdWdoIGhlcmUuIFRoaXMgdXBkYXRlcyB0aGVcbiAgICAgKiBmaWx0ZXIgYW5kIGVuc3VyZXMgdGhhdCB0aGUgcGlja2VyIGlzIHZpc2libGUgYW5kIHJlZmxlY3RpbmcgdGhlIHN0YXRlIG9mIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBJbnB1dCBldmVudCBwcm9jZXNzaW5nIHBhc3NlcyB0aGUgY3VycmVudCBpbnB1dCBmaWVsZCB2YWx1ZSBpbiBhcyB0aGUgZmlsdGVyIHZhbHVlLlxuICAgICAqXG4gICAgICogSW52b2NhdGlvbiBvZiB0aGUgZXhwYW5kIHRyaWdnZXIgcGFzc2VzIGBudWxsYCBzbyBhcyB0byBjbGVhciBmaWx0ZXJpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsdGVyIHRoZSBwaWNrZXIgYnlcbiAgICAgKi9cbiAgICBkb0ZpbHRlcih2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwaWNrZXIsIHN0b3JlfSA9IG1lLFxuICAgICAgICAgICAgcmVjb3JkICAgICAgICAgID0gbWUudmFsdWUsXG4gICAgICAgICAgICBmaWx0ZXIgICAgICAgICAgPSBzdG9yZS5nZXRGaWx0ZXIobWUuZGlzcGxheUZpZWxkKTtcblxuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBmaWx0ZXIudmFsdWUgPSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlsdGVyIHJlc3VsdGluZyBpbiBzb21ldGhpbmcgdG8gc2hvd1xuICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSkge1xuICAgICAgICAgICAgbWUuc2hvd1BpY2tlcigpO1xuXG4gICAgICAgICAgICAvLyBMaXN0IG1pZ2h0IG5vdCBleGlzdCB1bnRpbCB0aGUgcGlja2VyIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgIGxldCB7bGlzdH0gICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAge3NlbGVjdGlvbk1vZGVsfSA9IGxpc3QsXG4gICAgICAgICAgICAgICAgaW5kZXggICAgICAgICAgICA9IHN0b3JlLmluZGV4T2YocmVjb3JkKTtcblxuICAgICAgICAgICAgLy8gT24gc2hvdywgc2V0IHRoZSBhY3RpdmUgaXRlbSB0byBiZSB0aGUgY3VycmVudCBzZWxlY3RlZCByZWNvcmQgb3IgdGhlIGZpcnN0XG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gaGVhciBiYWNrIGFib3V0IG91ciBvd24gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc3VzcGVuZEV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHJlY29yZCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc3VzcGVuZEV2ZW50cyA9IGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3QuX2ZvY3VzSW5kZXggPSAtMTsgLy8gc2lsZW50IHVwZGF0ZSB0byBlbnN1cmUgYWZ0ZXJTZXRGb2N1c0luZGV4KCkgYWx3YXlzIGdldHMgY2FsbGVkXG4gICAgICAgICAgICBsaXN0LmZvY3VzSW5kZXggID0gaW5kZXggPiAtMSA/IGluZGV4IDogMFxuICAgICAgICB9XG4gICAgICAgIC8vIEZpbHRlcmVkIGRvd24gdG8gbm90aGluZyAtIGhpZGUgcGlja2VyIGlmIGl0IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGlja2VyPy5oaWRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGZpbHRlck9uSW5wdXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRvRmlsdGVyKHZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5waWNrZXI/LmhpZGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGZvcm0uZmllbGQuQmFzZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBGb3JtQ29udGFpbmVyID0gTmVvLmZvcm0/LkNvbnRhaW5lcixcbiAgICAgICAgICAgIHBhcmFtcyAgICAgICAgPSB7Y29tcG9uZW50OiBtZSwgb2xkVmFsdWUsIHZhbHVlfTtcblxuICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCBwYXJhbXMpO1xuXG4gICAgICAgIGlmICghbWUuc3VzcGVuZEV2ZW50cykge1xuICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKG1lKS5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEZvcm1Db250YWluZXIgJiYgcGFyZW50IGluc3RhbmNlb2YgRm9ybUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZmlyZSgnZmllbGRDaGFuZ2UnLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0SW5wdXRIaW50RWwoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kKHRoaXMudmRvbSwgdGhpcy5nZXRJbnB1dEhpbnRJZCgpKT8udmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SW5wdXRIaW50SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJ19faW5wdXQtaGludCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBzZWxlY3RlZCByZWNvcmQgb3IgbnVsbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0UmVjb3JkKCkge1xuICAgICAgICBsZXQge2xpc3R9ICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZEtleSA9IGxpc3Quc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9uKClbMF07XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZEtleSAmJiB0aGlzLnN0b3JlLmdldChsaXN0LmdldEl0ZW1SZWNvcmRJZChyZWNvcmRLZXkpKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3VibWl0VmFsdWUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLnZhbHVlPy5bbWUudmFsdWVGaWVsZF0gfHwgbWUuZW1wdHlWYWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgY29uc3QgaW5wdXRFbCA9IHRoaXMuZ2V0SW5wdXRFbCgpO1xuXG4gICAgICAgIGlucHV0RWxbJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCddID0gJyc7XG4gICAgICAgIGlucHV0RWxbJ2FyaWEtZXhwYW5kZWQnXSAgICAgICAgID0gZmFsc2U7XG4gICAgICAgIGlucHV0RWxbJ2FyaWEtaGFzcG9wdXAnXSAgICAgICAgID0gJ2xpc3Rib3gnO1xuXG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoLi4uYXJndW1lbnRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGNvbXBvbmVudCBsb3NpbmcgZm9jdXMuIFRoaXMgaXMgYSBjcml0aWNhbCBtZXRob2QgZm9yIGBmb3JjZVNlbGVjdGlvbmAgYmVoYXZpb3IuXG4gICAgICogSWYgYGZvcmNlU2VsZWN0aW9uYCBpcyB0cnVlIGFuZCB0aGUgdXNlciBoYXMgdHlwZWQgcGFydGlhbCB0ZXh0IHdpdGhvdXQgZXhwbGljaXRseSBzZWxlY3RpbmcgYW4gaXRlbSxcbiAgICAgKiB0aGlzIG1ldGhvZCBzZWxlY3RzIHRoZSBjdXJyZW50IHR5cGVhaGVhZCBzdWdnZXN0aW9uIChgYWN0aXZlUmVjb3JkSWRgKSBhbmQgc2V0cyBpdCBhcyB0aGUgY29tcG9uZW50J3MgdmFsdWUuXG4gICAgICogSXQgaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgY2xlYXJpbmcgdGhlIHR5cGVhaGVhZCBoaW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogSWYgd2UgYXJlIGxlYXZpbmcgdGhlIGZpZWxkLCB1c2luZyBmb3JjZVNlbGVjdGlvbj10cnVlIGFuZCB0aGUgZmllbGQgZG9lcyBub3QgaGF2ZSBhIHNlbGVjdGVkIHJlY29yZCxcbiAgICAgICAgICogd2UgZG8gd2FudCB0byBwaWNrIHRoZSBjbG9zZXN0IG1hdGNoID0+IHRoZSBmb2N1c3NlZCByZWNvcmQgKGhvbm9yaW5nIGZpbHRlcnMpLlxuICAgICAgICAgKiBJZiBubyByZWNvcmQgaXMgZm91bmQsIHdlIHdpbGwgY2xlYXIgdGhlIGZpZWxkIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobWUuZm9yY2VTZWxlY3Rpb24gJiYgIW1lLnZhbHVlKSB7XG4gICAgICAgICAgICBtZS5wcm9ncmFtbWF0aWNWYWx1ZUNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBtZS52YWx1ZSAgICAgICAgICAgICAgICAgICA9IG1lLnN0b3JlLmdldChtZS5hY3RpdmVSZWNvcmRJZCk7XG4gICAgICAgICAgICBtZS5wcm9ncmFtbWF0aWNWYWx1ZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlVHlwZUFoZWFkVmFsdWUobnVsbCk7XG5cbiAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25LZXlEb3duRG93bihkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5waWNrZXIgfHwgbWUucGlja2VyPy5oaWRkZW4pIHtcbiAgICAgICAgICAgIG1lLm9uUGlja2VyVHJpZ2dlckNsaWNrKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86XG4gICAgICogV2hlbiB3ZSBhcmUgdXNpbmcgYSBgQ29sbGVjdGlvbmAgYXMgb3VyIGB2YWx1ZUNvbGxlY3Rpb25gLCBhbmQgdGhhdCBgQ29sbGVjdGlvbmAgaXMgdGhlXG4gICAgICogYGl0ZW1zYCBvZiB0aGUgTGlzdCdzIGBzZWxlY3Rpb25Nb2RlbGAsIHRoZW4gdGhpcyB3aWxsIGJlIGBvblZhbHVlQ29sbGVjdGlvbkNoYW5nZWAsXG4gICAgICogYSBgbXV0YXRlYCBsaXN0ZW5lciBvbiBvdXIgb3duIGB2YWx1ZUNvbGxlY3Rpb25gIHdoaWNoIGJhY2tzIG91ciBgdmFsdWVgIGZpZWxkIHdoaWNoXG4gICAgICogd2lsbCBiZSBpbXBsZW1lbnRlZCBieSBhIGdldHRlciB3aGljaCBhY2Nlc3NlcyBgdmFsdWVDb2xsZWN0aW9uYC5cbiAgICAgKiBUaGlzIHdpbGwgYmVjb21lIGltcG9ydGFudCBmb3IgaW1wbGVtZW50aW5nIG11bHRpU2VsZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGlvbkNoYW5nZUV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gc2VsZWN0aW9uQ2hhbmdlRXZlbnQuc2VsZWN0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIG9uTGlzdEl0ZW1TZWxlY3Rpb25DaGFuZ2Uoe3NlbGVjdGlvbn0pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbj8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gc2VsZWN0aW9uWzBdLFxuICAgICAgICAgICAgICAgIHJlY29yZCAgID0gdHlwZW9mIHNlbGVjdGVkID09PSAnc3RyaW5nJyA/IG1lLnN0b3JlLmdldChtZS5saXN0LmdldEl0ZW1SZWNvcmRJZChzZWxlY3RlZCkpIDogc2VsZWN0ZWQ7XG5cbiAgICAgICAgICAgIG1lLmhpbnRSZWNvcmRJZCA9IG51bGw7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZVR5cGVBaGVhZFZhbHVlKG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS5oaWRlUGlja2VyKCk7XG5cbiAgICAgICAgICAgIG1lLnByZXZlbnRGaWx0ZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbWUudmFsdWUgICAgICAgICAgICA9IHJlY29yZDtcbiAgICAgICAgICAgIG1lLnByZXZlbnRGaWx0ZXJpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0Jywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZWNvcmRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Rpb24gd2FzIGF0dGVtcHRlZCB0byBiZSBjaGFuZ2VkIGJ1dCByZXN1bHRlZCBpbiBubyBhY3Rpb24uXG4gICAgICogRm9yIGV4YW1wbGUgY2xpY2tpbmcgb24gYWxyZWFkeSBzZWxlY3RlZCBsaXN0IGl0ZW0uXG4gICAgICovXG4gICAgb25MaXN0SXRlbVNlbGVjdGlvbk5vQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmhpZGVQaWNrZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdmlydHVhbCBmb2N1cyBuYXZpZ2F0aW9uIHdpdGhpbiB0aGUgcGlja2VyIGxpc3QgKGUuZy4sIHZpYSBhcnJvdyBrZXlzKS5cbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBgYWN0aXZlUmVjb3JkYCBhbmQgYGFjdGl2ZVJlY29yZElkYCB0byB0cmFjayB0aGUgZm9jdXNlZCBsaXN0IGl0ZW0uXG4gICAgICogSXQgdGhlbiBjYWxscyBgdXBkYXRlVHlwZUFoZWFkVmFsdWVgIHRvIGVuc3VyZSB0aGUgdHlwZWFoZWFkIGhpbnQgaXMgcmVzZXQsIHByZXZlbnRpbmcgYSBtaXNtYXRjaFxuICAgICAqIGJldHdlZW4gdGhlIG5hdmlnYXRlZCBpdGVtIGFuZCB0aGUgb3JpZ2luYWwgdHlwZWQtdGV4dCBzdWdnZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBuZW9uYXZpZ2F0ZSBldmVudCBkYXRhIGZyb20gdGhlIGxpc3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uTGlzdEl0ZW1OYXZpZ2F0ZShkYXRhKSB7XG4gICAgICAgIGxldCB7YWN0aXZlSW5kZXh9ID0gZGF0YTtcblxuICAgICAgICBpZiAoYWN0aXZlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtzdG9yZX0gPSBtZTtcblxuICAgICAgICAgICAgbWUuYWN0aXZlUmVjb3JkICAgPSBkYXRhLnJlY29yZCB8fCBzdG9yZS5nZXRBdChhY3RpdmVJbmRleCk7XG4gICAgICAgICAgICBtZS5hY3RpdmVSZWNvcmRJZCA9IG1lLmFjdGl2ZVJlY29yZFtzdG9yZS5nZXRLZXlQcm9wZXJ0eSgpXTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHR5cGVhaGVhZCBoaW50ICh3aGljaCB1cGRhdGVzIERPTSksIG9yIHVwZGF0ZSBET01cbiAgICAgICAgICAgIG1lLnR5cGVBaGVhZCA/IG1lLnVwZGF0ZVR5cGVBaGVhZFZhbHVlKG1lLmxhc3RNYW51YWxJbnB1dCkgOiBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblBpY2tlckhpZGRlbkNoYW5nZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgaW5wdXRFbCA9IHRoaXMuZ2V0SW5wdXRFbCgpO1xuXG4gICAgICAgIHN1cGVyLm9uUGlja2VySGlkZGVuQ2hhbmdlKC4uLmFyZ3VtZW50cyk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnB1dEVsWydhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnXSA9ICcnXG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dEVsWydhcmlhLWV4cGFuZGVkJ10gPSAhdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RpbmcgYSByZWNvcmQsIGlmIHJlcXVpcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgKi9cbiAgICBvblN0b3JlTG9hZChpdGVtcykge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmFsdWUgPSBtZS5wcmVTdG9yZUxvYWRWYWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lLl92YWx1ZSA9IHVuZGVmaW5lZDsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgbWUudmFsdWUgID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0Rmlyc3RMaXN0SXRlbSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RMaXN0SXRlbSgwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0TGFzdExpc3RJdGVtKCkge1xuICAgICAgICB0aGlzLnNlbGVjdExpc3RJdGVtKHRoaXMuc3RvcmUuZ2V0Q291bnQoKSAtMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBubyBpbmRleCBpcyBwYXNzZWQsIHRoZSBpbmRleCBtYXRjaGluZyB0byB0aGUgZmllbGQgaW5wdXQgd2lsbCBnZXQgdXNlZCAoMCBpZiBub25lKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdXG4gICAgICovXG4gICAgc2VsZWN0TGlzdEl0ZW0oaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIU5lby5pc051bWJlcihpbmRleCkpIHtcbiAgICAgICAgICAgIGlmIChtZS5hY3RpdmVSZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbWUuc3RvcmUuaW5kZXhPZktleShtZS5hY3RpdmVSZWNvcmRJZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5saXN0LnNlbGVjdEl0ZW0oaW5kZXgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgdG9nZ2xlUGlja2VyKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BpY2tlcn0gPSBtZTtcblxuICAgICAgICBpZiAocGlja2VyPy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwaWNrZXIuaGlkZGVuID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKCFtZS5kaXNhYmxlZCAmJiAhbWUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIG1lLmRvRmlsdGVyKG51bGwpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBhcyBuZWVkZWQgaW5zaWRlIGNsYXNzIGV4dGVuc2lvbnMuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVJbnB1dFZhbHVlRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGxldCBpbnB1dFZhbHVlID0gbnVsbDtcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSB8fCBOZW8uaXNSZWNvcmQodmFsdWUpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gdmFsdWVbdGhpcy5kaXNwbGF5RmllbGRdXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSBpbnB1dFZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVUeXBlQWhlYWQoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0RWwgPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIHtmbGFnOiAnbmVvLXJlYWwtaW5wdXQnfSk7XG5cbiAgICAgICAgaWYgKG1lLnR5cGVBaGVhZCkge1xuICAgICAgICAgICAgaW5wdXRFbC5wYXJlbnROb2RlLmNuW2lucHV0RWwuaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICAgICAgICAgIGNsczogWyduZW8taW5wdXQtZmllbGQtd3JhcHBlciddLFxuICAgICAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgICAgOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6ICdubycsIC8vIHdoaWxlIFwib2ZmXCIgaXMgdGhlIGNvcnJlY3QgdmFsdWUsIGJyb3dzZXIgdmVuZG9ycyBpZ25vcmUgaXQuIEFyYml0cmFyeSBzdHJpbmdzIGRvIHRoZSB0cmljay5cbiAgICAgICAgICAgICAgICAgICAgYXV0b2NvcnJlY3QgOiAnb2ZmJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgICAgOiBbJ25lby10ZXh0ZmllbGQtaW5wdXQnLCAnbmVvLXR5cGVhaGVhZC1pbnB1dCddLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICAgIDogbWUuZ2V0SW5wdXRIaW50SWQoKSxcbiAgICAgICAgICAgICAgICAgICAgc3BlbGxjaGVjayAgOiAnZmFsc2UnXG4gICAgICAgICAgICAgICAgfSwgaW5wdXRFbC52ZG9tXVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVkRvbVV0aWwucmVwbGFjZVZkb21DaGlsZChtZS52ZG9tLCBpbnB1dEVsLnBhcmVudE5vZGUuaWQsIGlucHV0RWwudmRvbSlcbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSB0eXBlYWhlYWQgaGludCBvdmVybGF5LlxuICAgICAqIFdoZW4gYSB1c2VyIHR5cGVzLCB0aGlzIG1ldGhvZCBzZWFyY2hlcyBmb3IgdGhlIGZpcnN0IG1hdGNoaW5nIHJlY29yZCBpbiB0aGUgc3RvcmUuIElmIGEgbWF0Y2ggaXMgZm91bmQsXG4gICAgICogaXQgcG9wdWxhdGVzIGEgc2Vjb25kYXJ5LCBncmF5ZWQtb3V0IGlucHV0IGZpZWxkIHdpdGggdGhlIHJlbWFpbmRlciBvZiB0aGUgc3VnZ2VzdGVkIHRlcm0uXG4gICAgICogVGhpcyBtZXRob2QgaXMgYWxzbyByZXNwb25zaWJsZSBmb3Igc2V0dGluZyB0aGUgYGFjdGl2ZVJlY29yZElkYCwgd2hpY2ggaXMgdXNlZCBieSBgZm9yY2VTZWxlY3Rpb25gIG9uIGJsdXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWU9dGhpcy5sYXN0TWFudWFsSW5wdXQgVGhlIHRleHQgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZSBUcnVlIHRvIHByZXZlbnQgYSBWRE9NIHVwZGF0ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlVHlwZUFoZWFkVmFsdWUodmFsdWU9dGhpcy5sYXN0TWFudWFsSW5wdXQsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1hdGNoICAgICAgICAgICAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgaW5wdXRIaW50RWwgICAgICAgICAgID0gbWUuZ2V0SW5wdXRIaW50RWwoKSxcbiAgICAgICAgICAgIHtkaXNwbGF5RmllbGQsIHN0b3JlfSA9IG1lO1xuXG4gICAgICAgIGlmIChtZS50eXBlQWhlYWQpIHtcbiAgICAgICAgICAgIGlmICghbWUudmFsdWUgJiYgdmFsdWU/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2ggPSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9yZS5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBzdG9yZS5nZXRBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJbZGlzcGxheUZpZWxkXT8udG9Mb3dlckNhc2U/LigpPy5zdGFydHNXaXRoKHNlYXJjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIGlucHV0SGludEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0SGludEVsLnZhbHVlID0gdmFsdWUgKyBtYXRjaFtkaXNwbGF5RmllbGRdLnN1YnN0cih2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBtZS5hY3RpdmVSZWNvcmQgICA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICBtZS5hY3RpdmVSZWNvcmRJZCA9IG1hdGNoW3N0b3JlLmdldEtleVByb3BlcnR5KCldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hdGNoICYmIGlucHV0SGludEVsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRIaW50RWwudmFsdWUgPSBtZS5hY3RpdmVSZWNvcmQgPSBtZS5hY3RpdmVSZWNvcmRJZCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVWYWx1ZUZyb21JbnB1dFZhbHVlKGlucHV0VmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5sYXN0TWFudWFsSW5wdXQgPSBpbnB1dFZhbHVlO1xuXG4gICAgICAgIGlmICghbWUucHJvZ3JhbW1hdGljVmFsdWVDaGFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGNoYW5naW5nIHRoZSBpbnB1dCA9PiBzaWxlbnQgcmVjb3JkIHJlc2V0XG4gICAgICAgICAgICBtZS5fdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgbWUubGlzdD8uc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3RBbGwoKTtcblxuICAgICAgICAgICAgbWUuZmlsdGVyT25JbnB1dChpbnB1dFZhbHVlKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBzZWxlY3QgZXZlbnQgZmlyZXMgd2hlbiBhIGxpc3QgaXRlbSBnZXRzIHNlbGVjdGVkXG4gKiBAZXZlbnQgc2VsZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gKiBAcGFyYW0ge3ZhbHVlfSByZWNvcmRbc3RvcmUuZ2V0S2V5UHJvcGVydHkoKV1cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tYm9Cb3gpO1xuIiwiaW1wb3J0IENvbnRhaW5lciAgICAgZnJvbSAnLi4vLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBQaWNrZXJUcmlnZ2VyIGZyb20gJy4vdHJpZ2dlci9QaWNrZXIubWpzJztcbmltcG9ydCBUZXh0ICAgICAgICAgIGZyb20gJy4vVGV4dC5tanMnO1xuXG4vKipcbiAqIFRoZSBhYnN0cmFjdCBwaWNrZXIgZmllbGQgcHJvdmlkZXMgYW4gYXJyb3cgZG93biB0cmlnZ2VyIHdoaWNoIG9wZW5zIGEgZmxvYXRpbmcgY29udGFpbmVyIHRvIHByb3ZpZGVcbiAqIG1vcmUgZGF0YSBzZWxlY3Rpb24gb3B0aW9uc1xuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLlBpY2tlclxuICogQGV4dGVuZHMgTmVvLmZvcm0uZmllbGQuVGV4dFxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFBpY2tlciBleHRlbmRzIFRleHQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuUGlja2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5QaWNrZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGlja2VyZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGlja2VyZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tcGlja2VyZmllbGQnLCduZW8tdGV4dGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXBpY2tlcmZpZWxkJywgJ25lby10ZXh0ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgZGF0YSBmcm9tIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBjYWxsIChwaWNrZXIgJiBib2R5IERvbVJlY3RzKVxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gY2xpZW50UmVjdHM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGllbnRSZWN0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgdXNlZCBrZXlzIGZvciB0aGUgc2VsZWN0aW9uIG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0ga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAga2V5czoge1xuICAgICAgICAgICAgRW50ZXIgOiAnb25LZXlEb3duRW50ZXInLFxuICAgICAgICAgICAgRXNjYXBlOiAnb25LZXlEb3duRXNjYXBlJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRhaW5lci5CYXNlfG51bGx9IHBpY2tlcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHBpY2tlcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3MgdG8gcGFzcyB0byB0aGUgcGlja2VyIGNvbnRhaW5lclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gcGlja2VyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBpY2tlckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHBpY2tlciBjb250YWluZXIuIERlZmF1bHRzIHRvIHB4LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gcGlja2VySGVpZ2h0PTEwMFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VySGVpZ2h0OiAxMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBwaWNrZXJJc01vdW50ZWRfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwaWNrZXJJc01vdW50ZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHBpY2tlciBjb250YWluZXIuIERlZmF1bHRzIHRvIHB4LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gcGlja2VyTWF4SGVpZ2h0PTIwMFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VyTWF4SGVpZ2h0OiAyMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHBpY2tlciBjb250YWluZXIuIERlZmF1bHRzIHRvIHB4LlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgd2lkdGggb2YgdGhlIHBpY2tlciBtYXRjaGVzIHRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgd3JhcCBlbGVtZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gcGlja2VyV2lkdGg9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGlja2VyV2lkdGg6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93UGlja2VyT25Gb2N1cz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaG93UGlja2VyT25Gb2N1czogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8T2JqZWN0W119IHRyaWdnZXJzPVtdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0cmlnZ2VyczogW3tcbiAgICAgICAgICAgIG1vZHVsZTogUGlja2VyVHJpZ2dlclxuICAgICAgICB9XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGNsaWNrOiBtZS5vbklucHV0Q2xpY2ssXG4gICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlICYmIG9sZFZhbHVlICYmIHRoaXMucGlja2VySXNNb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlci5oaWRlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aGVtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5waWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLnRoZW1lID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udGFpbmVyLkJhc2V9XG4gICAgICovXG4gICAgY3JlYXRlUGlja2VyKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwaWNrZXJXaWR0aH0gICA9IG1lLFxuICAgICAgICAgICAgcGlja2VyQ29tcG9uZW50ID0gbWUuY3JlYXRlUGlja2VyQ29tcG9uZW50KCk7XG5cbiAgICAgICAgbWUucGlja2VyID0gIE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDb250YWluZXIsXG4gICAgICAgICAgICBwYXJlbnRJZCA6ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgICAgIGZsb2F0aW5nIDogdHJ1ZSxcbiAgICAgICAgICAgIGFsaWduICAgIDoge1xuICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IHBpY2tlcldpZHRoID8gJ3QwLWIwJyA6ICd0LWInLFxuICAgICAgICAgICAgICAgIG1hdGNoU2l6ZSA6ICFwaWNrZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBheGlzTG9jayAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICA6IG1lLmdldElucHV0V3JhcHBlcklkKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLXBpY2tlci1jb250YWluZXInLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAgICAgaGVpZ2h0ICAgOiBtZS5waWNrZXJIZWlnaHQsXG4gICAgICAgICAgICBoaWRkZW4gICA6IHRydWUsXG4gICAgICAgICAgICBpZCAgICAgICA6IG1lLmdldFBpY2tlcklkKCksXG4gICAgICAgICAgICBpdGVtcyAgICA6IHBpY2tlckNvbXBvbmVudCA/IFtwaWNrZXJDb21wb25lbnRdIDogW10sXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IG1lLnBpY2tlck1heEhlaWdodCxcbiAgICAgICAgICAgIHRoZW1lICAgIDogbWUudGhlbWUsXG4gICAgICAgICAgICB3aWR0aCAgICA6IHBpY2tlcldpZHRoLFxuICAgICAgICAgICAgd2luZG93SWQgOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgIC4uLm1lLnBpY2tlckNvbmZpZyxcblxuICAgICAgICAgICAgLy8gc2NvcGVkIHRvIHRoZSBmaWVsZCBpbnN0YW5jZVxuICAgICAgICAgICAgb25Gb2N1c0xlYXZlOiBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlRmllbGQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICAgICAgICAgIGZvciAoaXRlbSBvZiBkYXRhLm9sZFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT09IG1lLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVGaWVsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnNpZGVGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5oaWRlUGlja2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLm9uRm9jdXNMZWF2ZShkYXRhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUucGlja2VyLm9uKCdoaWRkZW5DaGFuZ2UnLCBtZS5vblBpY2tlckhpZGRlbkNoYW5nZSwgbWUpO1xuXG4gICAgICAgIHJldHVybiBtZS5waWNrZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgeW91ciBwaWNrZXIgY29udGVudCBhcyBuZWVkZWRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgY3JlYXRlUGlja2VyQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCB7cGlja2VyfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHBpY2tlcj8uaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcGlja2VyLnVubW91bnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgcGlja2VyPy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwaWNrZXIgaW5zdGFuY2UgYW5kIGNyZWF0ZXMgaXQgaW4gY2FzZSBpdCBkb2VzIG5vdCBleGlzdCB5ZXRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRhaW5lci5CYXNlfVxuICAgICAqL1xuICAgIGdldFBpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyIHx8IHRoaXMuY3JlYXRlUGlja2VyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFBpY2tlcklkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fX3BpY2tlcmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGhpZGVQaWNrZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5waWNrZXIuaGlkZGVuID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0VudGVyKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Gb2N1c0VudGVyKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2hvd1BpY2tlck9uRm9jdXMgJiYgbWUuc2hvd1BpY2tlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnNpZGVQaWNrZXIgPSBmYWxzZSxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgZm9yIChpdGVtIG9mIGRhdGEub2xkUGF0aCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT09IG1lLmdldFBpY2tlcklkKCkpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGVQaWNrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluc2lkZVBpY2tlcikge1xuICAgICAgICAgICAgbWUuaGlkZVBpY2tlcigpO1xuICAgICAgICAgICAgc3VwZXIub25Gb2N1c0xlYXZlKGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSW5wdXRDbGljayhkYXRhKSB7XG4gICAgICAgICF0aGlzLmVkaXRhYmxlICYmIHRoaXMudG9nZ2xlUGlja2VyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrU2NvcGVdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uS2V5RG93bkVudGVyKGRhdGEsIGNhbGxiYWNrLCBjYWxsYmFja1Njb3BlKSB7XG4gICAgICAgICF0aGlzLnBpY2tlcklzTW91bnRlZCAmJiB0aGlzLnNob3dQaWNrZXIoY2FsbGJhY2ssIGNhbGxiYWNrU2NvcGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25LZXlEb3duRXNjYXBlKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2VySXNNb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVQaWNrZXIoKTtcblxuICAgICAgICAgICAgLy8gV2UgcHJvY2Vzc2VkIHRoaXMgZXZlbnQsIGFuZCBpdCBzaG91bGQgbm90IHByb2NlZWQgdG8gYW5jZXN0b3IgY29tcG9uZW50c1xuICAgICAgICAgICAgZGF0YS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBbmQgbm8gZnVydGhlciBsaXN0ZW5lcnMgc2hvdWxkIGJlIG5vdGlmaWVkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEub2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEudmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25QaWNrZXJIaWRkZW5DaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnBpY2tlcklzTW91bnRlZCA9ICFkYXRhLnZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGZvcm0uZmllbGQudHJpZ2dlci5QaWNrZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25QaWNrZXJUcmlnZ2VyQ2xpY2soKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlUGlja2VyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dQaWNrZXIoKSB7XG4gICAgICAgIHRoaXMuZ2V0UGlja2VyKCkuaGlkZGVuID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZVBpY2tlcigpIHtcbiAgICAgICAgbGV0IHBpY2tlciA9IHRoaXMuZ2V0UGlja2VyKCk7XG4gICAgICAgIHBpY2tlci5oaWRkZW4gPSAhcGlja2VyLmhpZGRlblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGZpZWxkIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGNsaWVudFJlY3RzICAgICAgOiBtZS5jbGllbnRSZWN0cyxcbiAgICAgICAgICAgIHBpY2tlciAgICAgICAgICAgOiBtZS5waWNrZXI/LnRvSlNPTigpLFxuICAgICAgICAgICAgcGlja2VyQ29uZmlnICAgICA6IG1lLnNlcmlhbGl6ZUNvbmZpZyhtZS5waWNrZXJDb25maWcpLFxuICAgICAgICAgICAgcGlja2VySGVpZ2h0ICAgICA6IG1lLnBpY2tlckhlaWdodCxcbiAgICAgICAgICAgIHBpY2tlcklzTW91bnRlZCAgOiBtZS5waWNrZXJJc01vdW50ZWQsXG4gICAgICAgICAgICBwaWNrZXJNYXhIZWlnaHQgIDogbWUucGlja2VyTWF4SGVpZ2h0LFxuICAgICAgICAgICAgcGlja2VyV2lkdGggICAgICA6IG1lLnBpY2tlcldpZHRoLFxuICAgICAgICAgICAgc2hvd1BpY2tlck9uRm9jdXM6IG1lLnNob3dQaWNrZXJPbkZvY3VzXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBpY2tlcik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBVc2VkIGJ5IGZvcm0uZmllbGQuUGlja2VyXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQudHJpZ2dlci5QaWNrZXJcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuQmFzZVxuICovXG5jbGFzcyBQaWNrZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLmZpZWxkLnRyaWdnZXIuUGlja2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC50cmlnZ2VyLlBpY2tlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0cmlnZ2VyLXBpY2tlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0cmlnZ2VyLXBpY2tlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaWNvbkNscz0nZmEgZmEtY2FyZXQtZG93bidcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY2FyZXQtZG93bicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHVzZWQgYnkgZmllbGQuZ2V0VHJpZ2dlcigpXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdHlwZT0ncGlja2VyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAncGlja2VyJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25UcmlnZ2VyQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmZpZWxkLm9uUGlja2VyVHJpZ2dlckNsaWNrKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBpY2tlcik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9