"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_code_LivePreview_mjs"],{

/***/ "./src/code/LivePreview.mjs":
/*!**********************************!*\
  !*** ./src/code/LivePreview.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/wrapper/MonacoEditor.mjs */ "./src/component/wrapper/MonacoEditor.mjs");
/* harmony import */ var _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tab/Container.mjs */ "./src/tab/Container.mjs");




const
    classNameRegex = /className\s*:\s*['\"]([^'\"]+)['\"]/g,
    exportRegex    = /export\s+(?:default\s+)?(?:const|let|var|class|function|async\s+function|generator\s+function|async\s+generator\s+function|(\{[\s\S]*?\}))/g,
    importRegex    = /import\s+(?:([\w-]+)|\{([^}]+)\})\s+from\s+['\"]([^'\"]+)['\"]/;

/**
 * @class Neo.code.LivePreview
 * @extends Neo.container.Base
 */
class LivePreview extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for iconPosition
     * @member {String[]} activeViews=['preview','source']
     * @protected
     * @static
     */
    static activeViews = ['preview', 'source']

    static config = {
        /**
         * @member {String} className='Neo.code.LivePreview'
         * @protected
         */
        className: 'Neo.code.LivePreview',
        /**
         * @member {String} ntype='live-preview'
         * @protected
         */
        ntype: 'live-preview',
        /**
         * Valid values are 'preview' and 'source'
         * @member {String} activeView_='source'
         * @reactive
         */
        activeView_: 'source',
        /**
         * @member {String[]} baseCls=['neo-code-live-preview']
         */
        baseCls: ['neo-code-live-preview'],
        /**
         * @member {Boolean} disableRunSource=false
         */
        disableRunSource: false,
        /**
         * @member {Boolean} enableFullscreen=true
         */
        enableFullscreen: true,
        /**
         * @member {Object|String} layout='fit'
         * @reactive
         */
        layout: 'fit',
        /**
         * @member {Object[]} items
         */
        items: [{
            module             : _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            cls                : ['live-preview-container'],
            reference          : 'tab-container',
            removeInactiveCards: false,

            items: [{
                module   : _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                header   : {text: 'Source'},
                hideLabel: true,
                listeners: {editorChange: 'up.onEditorChange'},
                style    : {height: '100%'},
                reference: 'editor'
            }, {
                module   : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                header   : {text: 'Preview'},
                reference: 'preview'
            }]
        }],
        /**
         * The code to display inside the Monaco editor
         * @member {String|null} value_=null
         * @reactive
         */
        value_: null,
    }

    /**
     * Link the preview output to different targets
     * @member {Neo.component.Base} previewContainer=null
     */
    previewContainer = null

    /**
     * @returns {Neo.component.Base|null}
     */
    get tabContainer() {
        return this.getItem('tab-container')
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        this.tabContainer.activeIndex = value === 'source' ? 0 : 1
    }

    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        if (value) {
            this.getItem('editor').value = value?.trim()
        }
    }

    /**
     * Triggered before the activeView config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView')
    }

    /**
     * @param {Object} data
     */
    async collapseExpand(data) {
        let me       = this,
            button   = data.component,
            collapse = button.iconCls === 'fas fa-compress',
            {vdom}   = me,
            rect;

        if (collapse) {
            button.iconCls = 'fas fa-expand';

            rect = me.collapseRect;

            delete me.collapseRect;

            Object.assign(vdom.style, {
                height  : rect.height + 'px',
                left    : rect.x      + 'px',
                top     : rect.y      + 'px',
                width   : rect.width  + 'px'
            });

            me.update();

            await me.timeout(300);

            Object.assign(vdom.style, {
                position: null,
                zIndex  : null
            })
        } else {
            button.iconCls = 'fas fa-compress';

            rect = await me.getDomRect();

            me.collapseRect = rect;

            vdom.style = vdom.style || {};

            Object.assign(vdom.style, {
                height  : rect.height + 'px',
                left    : rect.x      + 'px',
                position: 'fixed',
                top     : rect.y      + 'px',
                width   : rect.width  + 'px',
                zIndex  : 103
            });

            me.update();

            await me.timeout(50);

            Object.assign(vdom.style, {
                height: '100%',
                left  : 0,
                top   : 0,
                width : '100%'
            })
        }

        me.update()
    }

    /**
     *
     */
    async createPopupWindow() {
        let me      = this,
            winData = await Neo.Main.getWindowData(),
            rect    = await me.getDomRect(me.getReference('preview').id);

        let {height, left, top, width} = rect;

        height -= 50; // popup header in Chrome
        left   += winData.screenLeft;
        top    += (winData.outerHeight - winData.innerHeight + winData.screenTop);

        Neo.Main.windowOpen({
            url           : `./childapps/preview/index.html?id=${me.id}`,
            windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
            windowName    : me.id
        })
    }

    /**
     *
     */
    doRunSource() {
        if (this.disableRunSource) {
            return
        }

        let me                = this,
            {environment}     = Neo.config,
            container         = me.getPreviewContainer(),
            source            = me.editorValue || me.value,
            className         = me.findMainClassName(source),
            cleanLines        = [],
            moduleNameAndPath = [],
            params            = [],
            vars              = [],
            codeString, module, promises;

        source.split('\n').forEach(line => {
            let importMatch = line.match(importRegex);

            if (importMatch) {
                let defaultImport = importMatch[1],
                    namedImports  = importMatch[2]?.split(',').map(name => name.trim()),
                    path          = importMatch[3],
                    index;

                // We want the non-minified version for code which can not get bundled.
                if (environment === 'dist/development') {
                    index = path.lastIndexOf('../');

                    if (index === 0) {
                        path = '../../../../src/' + path.slice(index + 3)
                    } else {
                        path = path.slice(0, index) + '../../../' + path.slice(index + 3)
                    }
                }

                // We want the minified version of the code which can not get bundled.
                else if (environment === 'dist/production') {
                    index = path.lastIndexOf('../');

                    if (index === 0) {
                        path = '../../../esm/src/' + path.slice(index + 3)
                    } else {
                        path = path.slice(0, index) + '../../esm/' + path.slice(index + 3)
                    }
                }

                moduleNameAndPath.push({defaultImport, namedImports, path})
            } else if (line.match(exportRegex)) {
                // Skip export statements
            } else {
                cleanLines.push(`    ${line}`)
            }
        });

        // Figure out the parts of the source we'll be running.
        // * The promises/import() corresponding to the user's import statements
        // * The vars holding the name of the imported module based on the module name for each import
        // * The rest of the user-provided source
        // It'll end up looking like this:
        // Promise.all([
        //     import('../../../node_modules/neo.mjs/src/container/Base.mjs'),
        //     import('../../../node_modules/neo.mjs/src/button/Base.mjs')
        //   ]).then(([BaseModule, ButtonModule]) => {
        //       const Base = BaseModule.default;
        //       const Button = ButtonModule.default;
        //       // Class declaration goes here...
        //   });
        // Making the promise part of the eval seems weird, but it made it easier to
        // set up the import vars.
        promises = moduleNameAndPath.map((item, i) => {
            let moduleAlias = `Module${i}`;
            params.push(moduleAlias);
            if (item.defaultImport) {
                vars.push(`    const ${item.defaultImport} = ${moduleAlias}.default;`);
            }
            if (item.namedImports) {
                vars.push(`    const {${item.namedImports.join(', ')}} = ${moduleAlias};`);
            }
            return `import('${item.path}')`
        });

        codeString = [
            'Promise.all([',
            `    ${promises.join(',\n')}`,
            `]).then(([${params.join(', ')}]) => {`,
            `${vars.join('\n')}`,
            `    ${cleanLines.join('\n')}`,
            '',
            `    module = Neo.ns('${className}');`,
            '',
            `    if (module && (`,
            `        Neo.component.Base.isPrototypeOf(module) ||`,
            `        Neo.functional.component.Base.isPrototypeOf(module)`,
            `    )) {`,
            `        container.add({module})`,
            '    }',
            '})',
            '.catch(error => {',
            '    console.warn("LivePreview Error:", error);',
            '    container.add({ntype:\'component\', html:error.message});',
            '})'
        ].join('\n')

        container.removeAll();

        // We must ensure that classes inside the editor won't get cached, since this disables run-time changes
        // See: https://github.com/neomjs/neo/issues/5863
        me.findClassNames(codeString).forEach(item => {
            let nsArray   = item.split('.'),
                className = nsArray.pop(),
                ns        = Neo.ns(nsArray);

            if (ns) {
                delete ns[className]
            }
        });

        try {
            new Function('container', 'module', codeString)(container, module);
        } catch (error) {
            container.add({
                ntype: 'component',
                html : error.message
            })
        }
    }

    /**
     * @param {String} sourceCode
     * @returns {String[]}
     */
    findClassNames(sourceCode) {
        let classNames = [],
            match;

        while ((match = classNameRegex.exec(sourceCode)) !== null) {
            classNames.push(match[1])
        }

        return classNames
    }

    /**
     * @param {String} sourceCode
     * @returns {String|null}
     */
    findMainClassName(sourceCode) {
        let classNames = this.findClassNames(sourceCode),
            mainName   = null,
            prioNames  = ['MainContainer', 'MainComponent', 'MainView', 'Main'];

        if (classNames.length > 0) {
            for (const name of prioNames) {
                mainName = classNames.find(className => className.endsWith(name));
                if (mainName) {
                    break
                }
            }

            if (!mainName) {
                mainName = classNames[classNames.length - 1]
            }
        }

        return mainName
    }

    

    /**
     * @returns {Neo.component.Base|null}
     */
    getPreviewContainer() {
        let me = this;

        if (me.previewContainer) {
            return me.previewContainer
        }

        return me.getReference('preview')
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.item
     * @param {Number} data.oldValue
     * @param {String} data.source
     * @param {Number} data.value
     */
    onActiveIndexChange(data) {
        let me        = this,
            isPreview = data.value === 1;

        if (data.item.reference === 'preview') {
            me.doRunSource()
        }
        // Navigating to the source view should destroy the app, in case the preview view is not popped out
        else if (!isPreview && !me.previewContainer) {
            me.getReference('preview').removeAll()
        }

        me.getReference('popout-window-button').hidden = !isPreview
        me.disableRunSource = false;
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me             = this,
            items          = [],
            {tabContainer} = me;

        if (me.enableFullscreen) {
            items.push({
                handler: me.collapseExpand.bind(me),
                iconCls: 'fas fa-expand',
                ui     : 'ghost'
            })
        }

        items.push({
            handler  : me.popoutPreview.bind(me),
            hidden   : tabContainer.activeIndex !== 1,
            iconCls  : 'far fa-window-maximize',
            reference: 'popout-window-button',
            ui       : 'ghost'
        });

        items.unshift('->');

        // we want to add a normal (non-header) button
        tabContainer.getTabBar().add(items);

        tabContainer.getTabBar().update();

        tabContainer.on('activeIndexChange', me.onActiveIndexChange, me);

        // changing the activeView initially will not trigger our onActiveIndexChange() logic
        me.activeView === 'preview' && me.doRunSource()
    }

    /**
     * @param {Object} data
     */
    onEditorChange(data) {
        let me = this;

        me.editorValue = data.value;

        // We are not using getPreviewContainer(), since we only want to update the LivePreview in case it is visible.
        if (me.previewContainer) {
            me.doRunSource()
        }
    }

    /**
     * @param {Object} data
     */
    async popoutPreview(data) {
        let me = this;

        data.component.disabled = true;
        await me.createPopupWindow();

        // this component requires a view controller to manage connected apps
        me.getController('viewport-controller')?.connectedApps.push(me.id)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(LivePreview));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb2RlX0xpdmVQcmV2aWV3X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEI7O0FBRWhEO0FBQ0E7QUFDQSxvSkFBb0osVUFBVTtBQUM5Siw2Q0FBNkMsSUFBSSxLQUFLOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBUztBQUNuQztBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFZO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwyRUFBWTtBQUN2Qyw0QkFBNEIsZUFBZTtBQUMzQztBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQSxhQUFhO0FBQ2IsMkJBQTJCLDJEQUFTO0FBQ3BDLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDBCQUEwQjs7QUFFdkMsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RSxzQ0FBc0MsT0FBTyxRQUFRLEtBQUssT0FBTyxJQUFJLFNBQVMsTUFBTTtBQUNwRjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGtDQUFrQztBQUMxRSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2QsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRTtBQUN6QztBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQixJQUFJLFlBQVksU0FBUztBQUNwRjtBQUNBO0FBQ0Esc0NBQXNDLEVBQUUsK0JBQStCLElBQUksYUFBYTtBQUN4RjtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEMseUJBQXlCLGtCQUFrQixPQUFPO0FBQ2xELGVBQWUsZ0JBQWdCO0FBQy9CLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQSxvQ0FBb0MsVUFBVSxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9DQUFvQyxPQUFPO0FBQzNDLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsOEJBQThCO0FBQzlCLDJEQUEyRDtBQUMzRCxnQ0FBZ0Msd0NBQXdDLEVBQUU7QUFDMUUsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29kZS9MaXZlUHJldmlldy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbnRhaW5lciAgICBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IE1vbmFjb0VkaXRvciBmcm9tICcuLi9jb21wb25lbnQvd3JhcHBlci9Nb25hY29FZGl0b3IubWpzJ1xuaW1wb3J0IFRhYkNvbnRhaW5lciBmcm9tICcuLi90YWIvQ29udGFpbmVyLm1qcyc7XG5cbmNvbnN0XG4gICAgY2xhc3NOYW1lUmVnZXggPSAvY2xhc3NOYW1lXFxzKjpcXHMqWydcXFwiXShbXidcXFwiXSspWydcXFwiXS9nLFxuICAgIGV4cG9ydFJlZ2V4ICAgID0gL2V4cG9ydFxccysoPzpkZWZhdWx0XFxzKyk/KD86Y29uc3R8bGV0fHZhcnxjbGFzc3xmdW5jdGlvbnxhc3luY1xccytmdW5jdGlvbnxnZW5lcmF0b3JcXHMrZnVuY3Rpb258YXN5bmNcXHMrZ2VuZXJhdG9yXFxzK2Z1bmN0aW9ufChcXHtbXFxzXFxTXSo/XFx9KSkvZyxcbiAgICBpbXBvcnRSZWdleCAgICA9IC9pbXBvcnRcXHMrKD86KFtcXHctXSspfFxceyhbXn1dKylcXH0pXFxzK2Zyb21cXHMrWydcXFwiXShbXidcXFwiXSspWydcXFwiXS87XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb2RlLkxpdmVQcmV2aWV3XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgTGl2ZVByZXZpZXcgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaWNvblBvc2l0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGFjdGl2ZVZpZXdzPVsncHJldmlldycsJ3NvdXJjZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgYWN0aXZlVmlld3MgPSBbJ3ByZXZpZXcnLCAnc291cmNlJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvZGUuTGl2ZVByZXZpZXcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb2RlLkxpdmVQcmV2aWV3JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xpdmUtcHJldmlldydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsaXZlLXByZXZpZXcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZSAncHJldmlldycgYW5kICdzb3VyY2UnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYWN0aXZlVmlld189J3NvdXJjZSdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVWaWV3XzogJ3NvdXJjZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jb2RlLWxpdmUtcHJldmlldyddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb2RlLWxpdmUtcHJldmlldyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGlzYWJsZVJ1blNvdXJjZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZVJ1blNvdXJjZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVGdWxsc2NyZWVuPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZUZ1bGxzY3JlZW46IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfSBsYXlvdXQ9J2ZpdCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6ICdmaXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IFRhYkNvbnRhaW5lcixcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgICA6IFsnbGl2ZS1wcmV2aWV3LWNvbnRhaW5lciddLFxuICAgICAgICAgICAgcmVmZXJlbmNlICAgICAgICAgIDogJ3RhYi1jb250YWluZXInLFxuICAgICAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogZmFsc2UsXG5cbiAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogTW9uYWNvRWRpdG9yLFxuICAgICAgICAgICAgICAgIGhlYWRlciAgIDoge3RleHQ6ICdTb3VyY2UnfSxcbiAgICAgICAgICAgICAgICBoaWRlTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7ZWRpdG9yQ2hhbmdlOiAndXAub25FZGl0b3JDaGFuZ2UnfSxcbiAgICAgICAgICAgICAgICBzdHlsZSAgICA6IHtoZWlnaHQ6ICcxMDAlJ30sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAnZWRpdG9yJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGhlYWRlciAgIDoge3RleHQ6ICdQcmV2aWV3J30sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAncHJldmlldydcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvZGUgdG8gZGlzcGxheSBpbnNpZGUgdGhlIE1vbmFjbyBlZGl0b3JcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHZhbHVlXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWVfOiBudWxsLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpbmsgdGhlIHByZXZpZXcgb3V0cHV0IHRvIGRpZmZlcmVudCB0YXJnZXRzXG4gICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfSBwcmV2aWV3Q29udGFpbmVyPW51bGxcbiAgICAgKi9cbiAgICBwcmV2aWV3Q29udGFpbmVyID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldCB0YWJDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oJ3RhYi1jb250YWluZXInKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYWN0aXZlVmlldyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBY3RpdmVWaWV3KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnRhYkNvbnRhaW5lci5hY3RpdmVJbmRleCA9IHZhbHVlID09PSAnc291cmNlJyA/IDAgOiAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5nZXRJdGVtKCdlZGl0b3InKS52YWx1ZSA9IHZhbHVlPy50cmltKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGFjdGl2ZVZpZXcgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEFjdGl2ZVZpZXcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdhY3RpdmVWaWV3JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIGNvbGxhcHNlRXhwYW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJ1dHRvbiAgID0gZGF0YS5jb21wb25lbnQsXG4gICAgICAgICAgICBjb2xsYXBzZSA9IGJ1dHRvbi5pY29uQ2xzID09PSAnZmFzIGZhLWNvbXByZXNzJyxcbiAgICAgICAgICAgIHt2ZG9tfSAgID0gbWUsXG4gICAgICAgICAgICByZWN0O1xuXG4gICAgICAgIGlmIChjb2xsYXBzZSkge1xuICAgICAgICAgICAgYnV0dG9uLmljb25DbHMgPSAnZmFzIGZhLWV4cGFuZCc7XG5cbiAgICAgICAgICAgIHJlY3QgPSBtZS5jb2xsYXBzZVJlY3Q7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZS5jb2xsYXBzZVJlY3Q7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgOiByZWN0LmhlaWdodCArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdCAgICA6IHJlY3QueCAgICAgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0b3AgICAgIDogcmVjdC55ICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgOiByZWN0LndpZHRoICArICdweCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgzMDApO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHZkb20uc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICB6SW5kZXggIDogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1dHRvbi5pY29uQ2xzID0gJ2ZhcyBmYS1jb21wcmVzcyc7XG5cbiAgICAgICAgICAgIHJlY3QgPSBhd2FpdCBtZS5nZXREb21SZWN0KCk7XG5cbiAgICAgICAgICAgIG1lLmNvbGxhcHNlUmVjdCA9IHJlY3Q7XG5cbiAgICAgICAgICAgIHZkb20uc3R5bGUgPSB2ZG9tLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHZkb20uc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgIDogcmVjdC5oZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgOiByZWN0LnggICAgICArICdweCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgdG9wICAgICA6IHJlY3QueSAgICAgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB3aWR0aCAgIDogcmVjdC53aWR0aCAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHpJbmRleCAgOiAxMDNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1MCk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGxlZnQgIDogMCxcbiAgICAgICAgICAgICAgICB0b3AgICA6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGggOiAnMTAwJSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUG9wdXBXaW5kb3coKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHdpbkRhdGEgPSBhd2FpdCBOZW8uTWFpbi5nZXRXaW5kb3dEYXRhKCksXG4gICAgICAgICAgICByZWN0ICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChtZS5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKS5pZCk7XG5cbiAgICAgICAgbGV0IHtoZWlnaHQsIGxlZnQsIHRvcCwgd2lkdGh9ID0gcmVjdDtcblxuICAgICAgICBoZWlnaHQgLT0gNTA7IC8vIHBvcHVwIGhlYWRlciBpbiBDaHJvbWVcbiAgICAgICAgbGVmdCAgICs9IHdpbkRhdGEuc2NyZWVuTGVmdDtcbiAgICAgICAgdG9wICAgICs9ICh3aW5EYXRhLm91dGVySGVpZ2h0IC0gd2luRGF0YS5pbm5lckhlaWdodCArIHdpbkRhdGEuc2NyZWVuVG9wKTtcblxuICAgICAgICBOZW8uTWFpbi53aW5kb3dPcGVuKHtcbiAgICAgICAgICAgIHVybCAgICAgICAgICAgOiBgLi9jaGlsZGFwcHMvcHJldmlldy9pbmRleC5odG1sP2lkPSR7bWUuaWR9YCxcbiAgICAgICAgICAgIHdpbmRvd0ZlYXR1cmVzOiBgaGVpZ2h0PSR7aGVpZ2h0fSxsZWZ0PSR7bGVmdH0sdG9wPSR7dG9wfSx3aWR0aD0ke3dpZHRofWAsXG4gICAgICAgICAgICB3aW5kb3dOYW1lICAgIDogbWUuaWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRvUnVuU291cmNlKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlUnVuU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZW52aXJvbm1lbnR9ICAgICA9IE5lby5jb25maWcsXG4gICAgICAgICAgICBjb250YWluZXIgICAgICAgICA9IG1lLmdldFByZXZpZXdDb250YWluZXIoKSxcbiAgICAgICAgICAgIHNvdXJjZSAgICAgICAgICAgID0gbWUuZWRpdG9yVmFsdWUgfHwgbWUudmFsdWUsXG4gICAgICAgICAgICBjbGFzc05hbWUgICAgICAgICA9IG1lLmZpbmRNYWluQ2xhc3NOYW1lKHNvdXJjZSksXG4gICAgICAgICAgICBjbGVhbkxpbmVzICAgICAgICA9IFtdLFxuICAgICAgICAgICAgbW9kdWxlTmFtZUFuZFBhdGggPSBbXSxcbiAgICAgICAgICAgIHBhcmFtcyAgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICB2YXJzICAgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgY29kZVN0cmluZywgbW9kdWxlLCBwcm9taXNlcztcblxuICAgICAgICBzb3VyY2Uuc3BsaXQoJ1xcbicpLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICBsZXQgaW1wb3J0TWF0Y2ggPSBsaW5lLm1hdGNoKGltcG9ydFJlZ2V4KTtcblxuICAgICAgICAgICAgaWYgKGltcG9ydE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZmF1bHRJbXBvcnQgPSBpbXBvcnRNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZWRJbXBvcnRzICA9IGltcG9ydE1hdGNoWzJdPy5zcGxpdCgnLCcpLm1hcChuYW1lID0+IG5hbWUudHJpbSgpKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCAgICAgICAgICA9IGltcG9ydE1hdGNoWzNdLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIG5vbi1taW5pZmllZCB2ZXJzaW9uIGZvciBjb2RlIHdoaWNoIGNhbiBub3QgZ2V0IGJ1bmRsZWQuXG4gICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50ID09PSAnZGlzdC9kZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcuLi8nKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSAnLi4vLi4vLi4vLi4vc3JjLycgKyBwYXRoLnNsaWNlKGluZGV4ICsgMylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGluZGV4KSArICcuLi8uLi8uLi8nICsgcGF0aC5zbGljZShpbmRleCArIDMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRoZSBtaW5pZmllZCB2ZXJzaW9uIG9mIHRoZSBjb2RlIHdoaWNoIGNhbiBub3QgZ2V0IGJ1bmRsZWQuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZW52aXJvbm1lbnQgPT09ICdkaXN0L3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLi4vJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gJy4uLy4uLy4uL2VzbS9zcmMvJyArIHBhdGguc2xpY2UoaW5kZXggKyAzKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaW5kZXgpICsgJy4uLy4uL2VzbS8nICsgcGF0aC5zbGljZShpbmRleCArIDMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lQW5kUGF0aC5wdXNoKHtkZWZhdWx0SW1wb3J0LCBuYW1lZEltcG9ydHMsIHBhdGh9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKGV4cG9ydFJlZ2V4KSkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgZXhwb3J0IHN0YXRlbWVudHNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW5MaW5lcy5wdXNoKGAgICAgJHtsaW5lfWApXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHBhcnRzIG9mIHRoZSBzb3VyY2Ugd2UnbGwgYmUgcnVubmluZy5cbiAgICAgICAgLy8gKiBUaGUgcHJvbWlzZXMvaW1wb3J0KCkgY29ycmVzcG9uZGluZyB0byB0aGUgdXNlcidzIGltcG9ydCBzdGF0ZW1lbnRzXG4gICAgICAgIC8vICogVGhlIHZhcnMgaG9sZGluZyB0aGUgbmFtZSBvZiB0aGUgaW1wb3J0ZWQgbW9kdWxlIGJhc2VkIG9uIHRoZSBtb2R1bGUgbmFtZSBmb3IgZWFjaCBpbXBvcnRcbiAgICAgICAgLy8gKiBUaGUgcmVzdCBvZiB0aGUgdXNlci1wcm92aWRlZCBzb3VyY2VcbiAgICAgICAgLy8gSXQnbGwgZW5kIHVwIGxvb2tpbmcgbGlrZSB0aGlzOlxuICAgICAgICAvLyBQcm9taXNlLmFsbChbXG4gICAgICAgIC8vICAgICBpbXBvcnQoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZW8ubWpzL3NyYy9jb250YWluZXIvQmFzZS5tanMnKSxcbiAgICAgICAgLy8gICAgIGltcG9ydCgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL2J1dHRvbi9CYXNlLm1qcycpXG4gICAgICAgIC8vICAgXSkudGhlbigoW0Jhc2VNb2R1bGUsIEJ1dHRvbk1vZHVsZV0pID0+IHtcbiAgICAgICAgLy8gICAgICAgY29uc3QgQmFzZSA9IEJhc2VNb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgLy8gICAgICAgY29uc3QgQnV0dG9uID0gQnV0dG9uTW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgIC8vICAgICAgIC8vIENsYXNzIGRlY2xhcmF0aW9uIGdvZXMgaGVyZS4uLlxuICAgICAgICAvLyAgIH0pO1xuICAgICAgICAvLyBNYWtpbmcgdGhlIHByb21pc2UgcGFydCBvZiB0aGUgZXZhbCBzZWVtcyB3ZWlyZCwgYnV0IGl0IG1hZGUgaXQgZWFzaWVyIHRvXG4gICAgICAgIC8vIHNldCB1cCB0aGUgaW1wb3J0IHZhcnMuXG4gICAgICAgIHByb21pc2VzID0gbW9kdWxlTmFtZUFuZFBhdGgubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbW9kdWxlQWxpYXMgPSBgTW9kdWxlJHtpfWA7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChtb2R1bGVBbGlhcyk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kZWZhdWx0SW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgdmFycy5wdXNoKGAgICAgY29uc3QgJHtpdGVtLmRlZmF1bHRJbXBvcnR9ID0gJHttb2R1bGVBbGlhc30uZGVmYXVsdDtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLm5hbWVkSW1wb3J0cykge1xuICAgICAgICAgICAgICAgIHZhcnMucHVzaChgICAgIGNvbnN0IHske2l0ZW0ubmFtZWRJbXBvcnRzLmpvaW4oJywgJyl9fSA9ICR7bW9kdWxlQWxpYXN9O2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGBpbXBvcnQoJyR7aXRlbS5wYXRofScpYFxuICAgICAgICB9KTtcblxuICAgICAgICBjb2RlU3RyaW5nID0gW1xuICAgICAgICAgICAgJ1Byb21pc2UuYWxsKFsnLFxuICAgICAgICAgICAgYCAgICAke3Byb21pc2VzLmpvaW4oJyxcXG4nKX1gLFxuICAgICAgICAgICAgYF0pLnRoZW4oKFske3BhcmFtcy5qb2luKCcsICcpfV0pID0+IHtgLFxuICAgICAgICAgICAgYCR7dmFycy5qb2luKCdcXG4nKX1gLFxuICAgICAgICAgICAgYCAgICAke2NsZWFuTGluZXMuam9pbignXFxuJyl9YCxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgYCAgICBtb2R1bGUgPSBOZW8ubnMoJyR7Y2xhc3NOYW1lfScpO2AsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIGAgICAgaWYgKG1vZHVsZSAmJiAoYCxcbiAgICAgICAgICAgIGAgICAgICAgIE5lby5jb21wb25lbnQuQmFzZS5pc1Byb3RvdHlwZU9mKG1vZHVsZSkgfHxgLFxuICAgICAgICAgICAgYCAgICAgICAgTmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2UuaXNQcm90b3R5cGVPZihtb2R1bGUpYCxcbiAgICAgICAgICAgIGAgICAgKSkge2AsXG4gICAgICAgICAgICBgICAgICAgICBjb250YWluZXIuYWRkKHttb2R1bGV9KWAsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJ30pJyxcbiAgICAgICAgICAgICcuY2F0Y2goZXJyb3IgPT4geycsXG4gICAgICAgICAgICAnICAgIGNvbnNvbGUud2FybihcIkxpdmVQcmV2aWV3IEVycm9yOlwiLCBlcnJvcik7JyxcbiAgICAgICAgICAgICcgICAgY29udGFpbmVyLmFkZCh7bnR5cGU6XFwnY29tcG9uZW50XFwnLCBodG1sOmVycm9yLm1lc3NhZ2V9KTsnLFxuICAgICAgICAgICAgJ30pJ1xuICAgICAgICBdLmpvaW4oJ1xcbicpXG5cbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgIC8vIFdlIG11c3QgZW5zdXJlIHRoYXQgY2xhc3NlcyBpbnNpZGUgdGhlIGVkaXRvciB3b24ndCBnZXQgY2FjaGVkLCBzaW5jZSB0aGlzIGRpc2FibGVzIHJ1bi10aW1lIGNoYW5nZXNcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvNTg2M1xuICAgICAgICBtZS5maW5kQ2xhc3NOYW1lcyhjb2RlU3RyaW5nKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbGV0IG5zQXJyYXkgICA9IGl0ZW0uc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBuc0FycmF5LnBvcCgpLFxuICAgICAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhuc0FycmF5KTtcblxuICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5zW2NsYXNzTmFtZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbignY29udGFpbmVyJywgJ21vZHVsZScsIGNvZGVTdHJpbmcpKGNvbnRhaW5lciwgbW9kdWxlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGQoe1xuICAgICAgICAgICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICBodG1sIDogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2VDb2RlXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGZpbmRDbGFzc05hbWVzKHNvdXJjZUNvZGUpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXSxcbiAgICAgICAgICAgIG1hdGNoO1xuXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBjbGFzc05hbWVSZWdleC5leGVjKHNvdXJjZUNvZGUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKG1hdGNoWzFdKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlQ29kZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kTWFpbkNsYXNzTmFtZShzb3VyY2VDb2RlKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gdGhpcy5maW5kQ2xhc3NOYW1lcyhzb3VyY2VDb2RlKSxcbiAgICAgICAgICAgIG1haW5OYW1lICAgPSBudWxsLFxuICAgICAgICAgICAgcHJpb05hbWVzICA9IFsnTWFpbkNvbnRhaW5lcicsICdNYWluQ29tcG9uZW50JywgJ01haW5WaWV3JywgJ01haW4nXTtcblxuICAgICAgICBpZiAoY2xhc3NOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcHJpb05hbWVzKSB7XG4gICAgICAgICAgICAgICAgbWFpbk5hbWUgPSBjbGFzc05hbWVzLmZpbmQoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5lbmRzV2l0aChuYW1lKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1haW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1haW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgbWFpbk5hbWUgPSBjbGFzc05hbWVzW2NsYXNzTmFtZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYWluTmFtZVxuICAgIH1cblxuICAgIFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldFByZXZpZXdDb250YWluZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnByZXZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5wcmV2aWV3Q29udGFpbmVyXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuZ2V0UmVmZXJlbmNlKCdwcmV2aWV3JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkYXRhLml0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnNvdXJjZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnZhbHVlXG4gICAgICovXG4gICAgb25BY3RpdmVJbmRleENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXNQcmV2aWV3ID0gZGF0YS52YWx1ZSA9PT0gMTtcblxuICAgICAgICBpZiAoZGF0YS5pdGVtLnJlZmVyZW5jZSA9PT0gJ3ByZXZpZXcnKSB7XG4gICAgICAgICAgICBtZS5kb1J1blNvdXJjZSgpXG4gICAgICAgIH1cbiAgICAgICAgLy8gTmF2aWdhdGluZyB0byB0aGUgc291cmNlIHZpZXcgc2hvdWxkIGRlc3Ryb3kgdGhlIGFwcCwgaW4gY2FzZSB0aGUgcHJldmlldyB2aWV3IGlzIG5vdCBwb3BwZWQgb3V0XG4gICAgICAgIGVsc2UgaWYgKCFpc1ByZXZpZXcgJiYgIW1lLnByZXZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIG1lLmdldFJlZmVyZW5jZSgncHJldmlldycpLnJlbW92ZUFsbCgpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRSZWZlcmVuY2UoJ3BvcG91dC13aW5kb3ctYnV0dG9uJykuaGlkZGVuID0gIWlzUHJldmlld1xuICAgICAgICBtZS5kaXNhYmxlUnVuU291cmNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICAgICAgICAgID0gW10sXG4gICAgICAgICAgICB7dGFiQ29udGFpbmVyfSA9IG1lO1xuXG4gICAgICAgIGlmIChtZS5lbmFibGVGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS5jb2xsYXBzZUV4cGFuZC5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmFzIGZhLWV4cGFuZCcsXG4gICAgICAgICAgICAgICAgdWkgICAgIDogJ2dob3N0J1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgaGFuZGxlciAgOiBtZS5wb3BvdXRQcmV2aWV3LmJpbmQobWUpLFxuICAgICAgICAgICAgaGlkZGVuICAgOiB0YWJDb250YWluZXIuYWN0aXZlSW5kZXggIT09IDEsXG4gICAgICAgICAgICBpY29uQ2xzICA6ICdmYXIgZmEtd2luZG93LW1heGltaXplJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ3BvcG91dC13aW5kb3ctYnV0dG9uJyxcbiAgICAgICAgICAgIHVpICAgICAgIDogJ2dob3N0J1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtcy51bnNoaWZ0KCctPicpO1xuXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gYWRkIGEgbm9ybWFsIChub24taGVhZGVyKSBidXR0b25cbiAgICAgICAgdGFiQ29udGFpbmVyLmdldFRhYkJhcigpLmFkZChpdGVtcyk7XG5cbiAgICAgICAgdGFiQ29udGFpbmVyLmdldFRhYkJhcigpLnVwZGF0ZSgpO1xuXG4gICAgICAgIHRhYkNvbnRhaW5lci5vbignYWN0aXZlSW5kZXhDaGFuZ2UnLCBtZS5vbkFjdGl2ZUluZGV4Q2hhbmdlLCBtZSk7XG5cbiAgICAgICAgLy8gY2hhbmdpbmcgdGhlIGFjdGl2ZVZpZXcgaW5pdGlhbGx5IHdpbGwgbm90IHRyaWdnZXIgb3VyIG9uQWN0aXZlSW5kZXhDaGFuZ2UoKSBsb2dpY1xuICAgICAgICBtZS5hY3RpdmVWaWV3ID09PSAncHJldmlldycgJiYgbWUuZG9SdW5Tb3VyY2UoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FZGl0b3JDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmVkaXRvclZhbHVlID0gZGF0YS52YWx1ZTtcblxuICAgICAgICAvLyBXZSBhcmUgbm90IHVzaW5nIGdldFByZXZpZXdDb250YWluZXIoKSwgc2luY2Ugd2Ugb25seSB3YW50IHRvIHVwZGF0ZSB0aGUgTGl2ZVByZXZpZXcgaW4gY2FzZSBpdCBpcyB2aXNpYmxlLlxuICAgICAgICBpZiAobWUucHJldmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgbWUuZG9SdW5Tb3VyY2UoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBwb3BvdXRQcmV2aWV3KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBkYXRhLmNvbXBvbmVudC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IG1lLmNyZWF0ZVBvcHVwV2luZG93KCk7XG5cbiAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgcmVxdWlyZXMgYSB2aWV3IGNvbnRyb2xsZXIgdG8gbWFuYWdlIGNvbm5lY3RlZCBhcHBzXG4gICAgICAgIG1lLmdldENvbnRyb2xsZXIoJ3ZpZXdwb3J0LWNvbnRyb2xsZXInKT8uY29ubmVjdGVkQXBwcy5wdXNoKG1lLmlkKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTGl2ZVByZXZpZXcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9