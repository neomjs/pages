"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_code_LivePreview_mjs"],{

/***/ "./src/code/LivePreview.mjs":
/*!**********************************!*\
  !*** ./src/code/LivePreview.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/wrapper/MonacoEditor.mjs */ "./src/component/wrapper/MonacoEditor.mjs");
/* harmony import */ var _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tab/Container.mjs */ "./src/tab/Container.mjs");




const
    classDeclarationRegex = /class\s+([a-zA-Z$_][a-zA-Z0-9$_]*)\s*(?:extends\s+[a-zA-Z$_][a-zA-Z0-9$_]*)?\s*{[\s\S]*?}/g,
    classNameRegex        = /className\s*:\s*['"]([^'"]+)['"]/g,
    exportRegex           = /export\s+(?:default\s+)?(?:const|let|var|class|function|async\s+function|generator\s+function|async\s+generator\s+function|(\{[\s\S]*?\}))/g,
    importRegex           = /import\s+([\w-]+)\s+from\s+['"]([^'"]+)['"]/;

/**
 * @class Neo.code.LivePreview
 * @extends Neo.container.Base
 */
class LivePreview extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for iconPosition
     * @member {String[]} activeViews=['preview','source']
     * @protected
     * @static
     */
    static activeViews = ['preview', 'source']

    static config = {
        /**
         * @member {String} className='Neo.code.LivePreview'
         * @protected
         */
        className: 'Neo.code.LivePreview',
        /**
         * @member {String} ntype='live-preview'
         * @protected
         */
        ntype: 'live-preview',
        /**
         * Valid values are 'preview' and 'source'
         * @member {String} activeView_='source'
         */
        activeView_: 'source',
        /**
         * @member {String[]} baseCls=['neo-code-live-preview']
         */
        baseCls: ['neo-code-live-preview'],
        /**
         * @member {Boolean} disableRunSource=false
         */
        disableRunSource: false,
        /**
         * @member {Boolean} enableFullscreen=true
         */
        enableFullscreen: true,
        /**
         * @member {Object|String} layout='fit'
         */
        layout: 'fit',
        /**
         * @member {Object[]} items
         */
        items: [{
            module             : _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            cls                : ['live-preview-container'],
            reference          : 'tab-container',
            removeInactiveCards: false,

            items: [{
                module   : _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                header   : {text: 'Source'},
                hideLabel: true,
                listeners: {editorChange: 'up.onEditorChange'},
                style    : {height: '100%'},
                reference: 'editor'
            }, {
                module   : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                header   : {text: 'Preview'},
                reference: 'preview'
            }]
        }],
        /**
         * The code to display inside the Monaco editor
         * @member {String|null} value_=null
         */
        value_: null,
    }

    /**
     * Link the preview output to different targets
     * @member {Neo.component.Base} previewContainer=null
     */
    previewContainer = null

    /**
     * @returns {Neo.component.Base|null}
     */
    get tabContainer() {
        return this.getItem('tab-container')
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        this.tabContainer.activeIndex = value === 'source' ? 0 : 1
    }

    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        if (value) {
            this.getItem('editor').value = value?.trim()
        }
    }

    /**
     * Triggered before the activeView config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView')
    }

    /**
     * @param {Object} data
     */
    async collapseExpand(data) {
        let me       = this,
            button   = data.component,
            collapse = button.iconCls === 'fas fa-compress',
            {vdom}   = me,
            rect;

        if (collapse) {
            button.iconCls = 'fas fa-expand';

            rect = me.collapseRect;

            delete me.collapseRect;

            Object.assign(vdom.style, {
                height  : rect.height + 'px',
                left    : rect.x      + 'px',
                top     : rect.y      + 'px',
                width   : rect.width  + 'px'
            });

            me.update();

            await me.timeout(300);

            Object.assign(vdom.style, {
                position: null,
                zIndex  : null
            })
        } else {
            button.iconCls = 'fas fa-compress';

            rect = await me.getDomRect();

            me.collapseRect = rect;

            vdom.style = vdom.style || {};

            Object.assign(vdom.style, {
                height  : rect.height + 'px',
                left    : rect.x      + 'px',
                position: 'fixed',
                top     : rect.y      + 'px',
                width   : rect.width  + 'px',
                zIndex  : 103
            });

            me.update();

            await me.timeout(50);

            Object.assign(vdom.style, {
                height: '100%',
                left  : 0,
                top   : 0,
                width : '100%'
            })
        }

        me.update()
    }

    /**
     *
     */
    async createPopupWindow() {
        let me      = this,
            winData = await Neo.Main.getWindowData(),
            rect    = await me.getDomRect(me.getReference('preview').id);

        let {height, left, top, width} = rect;

        height -= 50; // popup header in Chrome
        left   += winData.screenLeft;
        top    += (winData.outerHeight - winData.innerHeight + winData.screenTop);

        Neo.Main.windowOpen({
            url           : `./childapps/preview/index.html?id=${me.id}`,
            windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
            windowName    : me.id
        })
    }

    /**
     *
     */
    doRunSource() {
        if (this.disableRunSource) {
            return
        }

        let me                = this,
            {environment}     = Neo.config,
            container         = me.getPreviewContainer(),
            source            = me.editorValue || me.value,
            className         = me.findLastClassName(source),
            cleanLines        = [],
            moduleNameAndPath = [],
            params            = [],
            vars              = [],
            codeString, promises;

        source.split('\n').forEach(line => {
            let importMatch = line.match(importRegex);

            if (importMatch) {
                let moduleName = importMatch[1],
                    path       = importMatch[2],
                    index;

                // We want the non-minified version for code which can not get bundled.
                if (environment === 'dist/development') {
                    index = path.lastIndexOf('../');

                    if (index === 0) {
                        path = '../../../../src/' + path.slice(index + 3)
                    } else {
                        path = path.slice(0, index) + '../../../' + path.slice(index + 3)
                    }
                }

                // We want the minified version of the code which can not get bundled.
                else if (environment === 'dist/production') {
                    index = path.lastIndexOf('../');

                    if (index === 0) {
                        path = '../../../esm/src/' + path.slice(index + 3)
                    } else {
                        path = path.slice(0, index) + '../../esm/' + path.slice(index + 3)
                    }
                }

                moduleNameAndPath.push({moduleName, path})
            } else if (line.match(exportRegex)) {
                // Skip export statements
            } else {
                cleanLines.push(`    ${line}`)
            }
        });

        // Figure out the parts of the source we'll be running.
        // * The promises/import() corresponding to the user's import statements
        // * The vars holding the name of the imported module based on the module name for each import
        // * The rest of the user-provided source
        // It'll end up looking like this:
        // Promise.all([
        //     import('../../../node_modules/neo.mjs/src/container/Base.mjs'),
        //     import('../../../node_modules/neo.mjs/src/button/Base.mjs')
        //   ]).then(([BaseModule, ButtonModule]) => {
        //       const Base = BaseModule.default;
        //       const Button = ButtonModule.default;
        //       // Class declaration goes here...
        //   });
        // Making the promise part of the eval seems weird, but it made it easier to
        // set up the import vars.
        promises = moduleNameAndPath.map(item => {
            params.push(`${item.moduleName}Module`);
            vars.push(`    const ${item.moduleName} = ${item.moduleName}Module.default;`);
            return `import('${item.path}')`
        });

        codeString = [
            'Promise.all([',
            `    ${promises.join(',\n')}`,
            `]).then(([${params.join(', ')}]) => {`,
            `${vars.join('\n')}`,
            `    ${cleanLines.join('\n')}`,
            '',
            `    if (${className} && Neo.component.Base.isPrototypeOf(${className})) {`,
            `        container.add({module:${className}})`,
            '    }',
            '})',
            '.catch(error => container.add({ntype:\'component\', html:error.message}));'
        ].join('\n')

        container.removeAll();

        // We must ensure that classes inside the editor won't get cached, since this disables run-time changes
        // See: https://github.com/neomjs/neo/issues/5863
        me.findClassNames(codeString).forEach(item => {
            let nsArray   = item.split('.'),
                className = nsArray.pop(),
                ns        = Neo.ns(nsArray);

            if (ns) {
                delete ns[className]
            }
        });

        try {
            new Function('container', codeString)(container);
        } catch (error) {
            container.add({
                ntype: 'component',
                html : error.message
            })
        }
    }

    /**
     * @param {String} sourceCode
     * @returns {String[]}
     */
    findClassNames(sourceCode) {
        let classNames = [],
            match;

        while ((match = classNameRegex.exec(sourceCode)) !== null) {
            classNames.push(match[1])
        }

        return classNames
    }

    /**
     * @param {String} sourceCode
     * @returns {String|null}
     */
    findLastClassName(sourceCode) {
        let lastClassName = null,
            match;

        while ((match = classDeclarationRegex.exec(sourceCode)) !== null) {
            // Update the last class name found
            lastClassName = match[1]
        }

        return lastClassName
    }

    /**
     * @returns {Neo.component.Base|null}
     */
    getPreviewContainer() {
        let me = this;

        if (me.previewContainer) {
            return me.previewContainer
        }

        return me.getReference('preview')
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.item
     * @param {Number} data.oldValue
     * @param {String} data.source
     * @param {Number} data.value
     */
    onActiveIndexChange(data) {
        let me        = this,
            isPreview = data.value === 1;

        if (data.item.reference === 'preview') {
            me.doRunSource()
        }
        // Navigating to the source view should destroy the app, in case the preview view is not popped out
        else if (!isPreview && !me.previewContainer) {
            me.getReference('preview').removeAll()
        }

        me.getReference('popout-window-button').hidden = !isPreview
        me.disableRunSource = false;
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me             = this,
            items          = [],
            {tabContainer} = me;

        if (me.enableFullscreen) {
            items.push({
                handler: me.collapseExpand.bind(me),
                iconCls: 'fas fa-expand',
                ui     : 'ghost'
            })
        }

        items.push({
            handler  : me.popoutPreview.bind(me),
            hidden   : tabContainer.activeIndex !== 1,
            iconCls  : 'far fa-window-maximize',
            reference: 'popout-window-button',
            ui       : 'ghost'
        });

        items.unshift('->');

        // we want to add a normal (non-header) button
        tabContainer.getTabBar().add(items);

        tabContainer.getTabBar().update();

        tabContainer.on('activeIndexChange', me.onActiveIndexChange, me);

        // changing the activeView initially will not trigger our onActiveIndexChange() logic
        me.activeView === 'preview' && me.doRunSource()
    }

    /**
     * @param {Object} data
     */
    onEditorChange(data) {
        let me = this;

        me.editorValue = data.value;

        // We are not using getPreviewContainer(), since we only want to update the LivePreview in case it is visible.
        if (me.previewContainer) {
            me.doRunSource()
        }
    }

    /**
     * @param {Object} data
     */
    async popoutPreview(data) {
        let me = this;

        data.component.disabled = true;
        await me.createPopupWindow();

        // this component requires a view controller to manage connected apps
        me.getController('viewport-controller')?.connectedApps.push(me.id)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(LivePreview));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb2RlX0xpdmVQcmV2aWV3X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEI7O0FBRWhEO0FBQ0EsNkdBQTZHLFNBQVM7QUFDdEg7QUFDQSwySkFBMkosVUFBVTtBQUNySzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBUztBQUNuQztBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQSxpQ0FBaUMsMERBQVk7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLDJFQUFZO0FBQ3ZDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RCw0QkFBNEIsZUFBZTtBQUMzQztBQUNBLGFBQWE7QUFDYiwyQkFBMkIsMkRBQVM7QUFDcEMsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxR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LFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDJCQUEyQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb2RlL0xpdmVQcmV2aWV3Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGFpbmVyICAgIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgTW9uYWNvRWRpdG9yIGZyb20gJy4uL2NvbXBvbmVudC93cmFwcGVyL01vbmFjb0VkaXRvci5tanMnXG5pbXBvcnQgVGFiQ29udGFpbmVyIGZyb20gJy4uL3RhYi9Db250YWluZXIubWpzJztcblxuY29uc3RcbiAgICBjbGFzc0RlY2xhcmF0aW9uUmVnZXggPSAvY2xhc3NcXHMrKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcXHMqKD86ZXh0ZW5kc1xccytbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopP1xccyp7W1xcc1xcU10qP30vZyxcbiAgICBjbGFzc05hbWVSZWdleCAgICAgICAgPSAvY2xhc3NOYW1lXFxzKjpcXHMqWydcIl0oW14nXCJdKylbJ1wiXS9nLFxuICAgIGV4cG9ydFJlZ2V4ICAgICAgICAgICA9IC9leHBvcnRcXHMrKD86ZGVmYXVsdFxccyspPyg/OmNvbnN0fGxldHx2YXJ8Y2xhc3N8ZnVuY3Rpb258YXN5bmNcXHMrZnVuY3Rpb258Z2VuZXJhdG9yXFxzK2Z1bmN0aW9ufGFzeW5jXFxzK2dlbmVyYXRvclxccytmdW5jdGlvbnwoXFx7W1xcc1xcU10qP1xcfSkpL2csXG4gICAgaW1wb3J0UmVnZXggICAgICAgICAgID0gL2ltcG9ydFxccysoW1xcdy1dKylcXHMrZnJvbVxccytbJ1wiXShbXidcIl0rKVsnXCJdLztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvZGUuTGl2ZVByZXZpZXdcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBMaXZlUHJldmlldyBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBpY29uUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYWN0aXZlVmlld3M9WydwcmV2aWV3Jywnc291cmNlJ11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBhY3RpdmVWaWV3cyA9IFsncHJldmlldycsICdzb3VyY2UnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29kZS5MaXZlUHJldmlldydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvZGUuTGl2ZVByZXZpZXcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGl2ZS1wcmV2aWV3J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xpdmUtcHJldmlldycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXMgYXJlICdwcmV2aWV3JyBhbmQgJ3NvdXJjZSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhY3RpdmVWaWV3Xz0nc291cmNlJ1xuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlVmlld186ICdzb3VyY2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY29kZS1saXZlLXByZXZpZXcnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY29kZS1saXZlLXByZXZpZXcnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVSdW5Tb3VyY2U9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVSdW5Tb3VyY2U6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZW5hYmxlRnVsbHNjcmVlbj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGVGdWxsc2NyZWVuOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ30gbGF5b3V0PSdmaXQnXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6ICdmaXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IFRhYkNvbnRhaW5lcixcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgICA6IFsnbGl2ZS1wcmV2aWV3LWNvbnRhaW5lciddLFxuICAgICAgICAgICAgcmVmZXJlbmNlICAgICAgICAgIDogJ3RhYi1jb250YWluZXInLFxuICAgICAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogZmFsc2UsXG5cbiAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogTW9uYWNvRWRpdG9yLFxuICAgICAgICAgICAgICAgIGhlYWRlciAgIDoge3RleHQ6ICdTb3VyY2UnfSxcbiAgICAgICAgICAgICAgICBoaWRlTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7ZWRpdG9yQ2hhbmdlOiAndXAub25FZGl0b3JDaGFuZ2UnfSxcbiAgICAgICAgICAgICAgICBzdHlsZSAgICA6IHtoZWlnaHQ6ICcxMDAlJ30sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAnZWRpdG9yJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIGhlYWRlciAgIDoge3RleHQ6ICdQcmV2aWV3J30sXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAncHJldmlldydcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvZGUgdG8gZGlzcGxheSBpbnNpZGUgdGhlIE1vbmFjbyBlZGl0b3JcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHZhbHVlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGwsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGluayB0aGUgcHJldmlldyBvdXRwdXQgdG8gZGlmZmVyZW50IHRhcmdldHNcbiAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V9IHByZXZpZXdDb250YWluZXI9bnVsbFxuICAgICAqL1xuICAgIHByZXZpZXdDb250YWluZXIgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0IHRhYkNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbSgndGFiLWNvbnRhaW5lcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhY3RpdmVWaWV3IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFjdGl2ZVZpZXcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudGFiQ29udGFpbmVyLmFjdGl2ZUluZGV4ID0gdmFsdWUgPT09ICdzb3VyY2UnID8gMCA6IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmdldEl0ZW0oJ2VkaXRvcicpLnZhbHVlID0gdmFsdWU/LnRyaW0oKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgYWN0aXZlVmlldyBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0QWN0aXZlVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2FjdGl2ZVZpZXcnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgY29sbGFwc2VFeHBhbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYnV0dG9uICAgPSBkYXRhLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGNvbGxhcHNlID0gYnV0dG9uLmljb25DbHMgPT09ICdmYXMgZmEtY29tcHJlc3MnLFxuICAgICAgICAgICAge3Zkb219ICAgPSBtZSxcbiAgICAgICAgICAgIHJlY3Q7XG5cbiAgICAgICAgaWYgKGNvbGxhcHNlKSB7XG4gICAgICAgICAgICBidXR0b24uaWNvbkNscyA9ICdmYXMgZmEtZXhwYW5kJztcblxuICAgICAgICAgICAgcmVjdCA9IG1lLmNvbGxhcHNlUmVjdDtcblxuICAgICAgICAgICAgZGVsZXRlIG1lLmNvbGxhcHNlUmVjdDtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICA6IHJlY3QuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgIDogcmVjdC54ICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgOiByZWN0LnkgICAgICArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IHJlY3Qud2lkdGggICsgJ3B4J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwMCk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIHpJbmRleCAgOiBudWxsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnV0dG9uLmljb25DbHMgPSAnZmFzIGZhLWNvbXByZXNzJztcblxuICAgICAgICAgICAgcmVjdCA9IGF3YWl0IG1lLmdldERvbVJlY3QoKTtcblxuICAgICAgICAgICAgbWUuY29sbGFwc2VSZWN0ID0gcmVjdDtcblxuICAgICAgICAgICAgdmRvbS5zdHlsZSA9IHZkb20uc3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgOiByZWN0LmhlaWdodCArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdCAgICA6IHJlY3QueCAgICAgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICB0b3AgICAgIDogcmVjdC55ICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgOiByZWN0LndpZHRoICArICdweCcsXG4gICAgICAgICAgICAgICAgekluZGV4ICA6IDEwM1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUwKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiAwLFxuICAgICAgICAgICAgICAgIHRvcCAgIDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aCA6ICcxMDAlJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQb3B1cFdpbmRvdygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgd2luRGF0YSA9IGF3YWl0IE5lby5NYWluLmdldFdpbmRvd0RhdGEoKSxcbiAgICAgICAgICAgIHJlY3QgICAgPSBhd2FpdCBtZS5nZXREb21SZWN0KG1lLmdldFJlZmVyZW5jZSgncHJldmlldycpLmlkKTtcblxuICAgICAgICBsZXQge2hlaWdodCwgbGVmdCwgdG9wLCB3aWR0aH0gPSByZWN0O1xuXG4gICAgICAgIGhlaWdodCAtPSA1MDsgLy8gcG9wdXAgaGVhZGVyIGluIENocm9tZVxuICAgICAgICBsZWZ0ICAgKz0gd2luRGF0YS5zY3JlZW5MZWZ0O1xuICAgICAgICB0b3AgICAgKz0gKHdpbkRhdGEub3V0ZXJIZWlnaHQgLSB3aW5EYXRhLmlubmVySGVpZ2h0ICsgd2luRGF0YS5zY3JlZW5Ub3ApO1xuXG4gICAgICAgIE5lby5NYWluLndpbmRvd09wZW4oe1xuICAgICAgICAgICAgdXJsICAgICAgICAgICA6IGAuL2NoaWxkYXBwcy9wcmV2aWV3L2luZGV4Lmh0bWw/aWQ9JHttZS5pZH1gLFxuICAgICAgICAgICAgd2luZG93RmVhdHVyZXM6IGBoZWlnaHQ9JHtoZWlnaHR9LGxlZnQ9JHtsZWZ0fSx0b3A9JHt0b3B9LHdpZHRoPSR7d2lkdGh9YCxcbiAgICAgICAgICAgIHdpbmRvd05hbWUgICAgOiBtZS5pZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZG9SdW5Tb3VyY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVSdW5Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtlbnZpcm9ubWVudH0gICAgID0gTmVvLmNvbmZpZyxcbiAgICAgICAgICAgIGNvbnRhaW5lciAgICAgICAgID0gbWUuZ2V0UHJldmlld0NvbnRhaW5lcigpLFxuICAgICAgICAgICAgc291cmNlICAgICAgICAgICAgPSBtZS5lZGl0b3JWYWx1ZSB8fCBtZS52YWx1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSAgICAgICAgID0gbWUuZmluZExhc3RDbGFzc05hbWUoc291cmNlKSxcbiAgICAgICAgICAgIGNsZWFuTGluZXMgICAgICAgID0gW10sXG4gICAgICAgICAgICBtb2R1bGVOYW1lQW5kUGF0aCA9IFtdLFxuICAgICAgICAgICAgcGFyYW1zICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHZhcnMgICAgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICBjb2RlU3RyaW5nLCBwcm9taXNlcztcblxuICAgICAgICBzb3VyY2Uuc3BsaXQoJ1xcbicpLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICBsZXQgaW1wb3J0TWF0Y2ggPSBsaW5lLm1hdGNoKGltcG9ydFJlZ2V4KTtcblxuICAgICAgICAgICAgaWYgKGltcG9ydE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1vZHVsZU5hbWUgPSBpbXBvcnRNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCAgICAgICA9IGltcG9ydE1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIG5vbi1taW5pZmllZCB2ZXJzaW9uIGZvciBjb2RlIHdoaWNoIGNhbiBub3QgZ2V0IGJ1bmRsZWQuXG4gICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50ID09PSAnZGlzdC9kZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcuLi8nKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSAnLi4vLi4vLi4vLi4vc3JjLycgKyBwYXRoLnNsaWNlKGluZGV4ICsgMylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGluZGV4KSArICcuLi8uLi8uLi8nICsgcGF0aC5zbGljZShpbmRleCArIDMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRoZSBtaW5pZmllZCB2ZXJzaW9uIG9mIHRoZSBjb2RlIHdoaWNoIGNhbiBub3QgZ2V0IGJ1bmRsZWQuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZW52aXJvbm1lbnQgPT09ICdkaXN0L3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLi4vJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gJy4uLy4uLy4uL2VzbS9zcmMvJyArIHBhdGguc2xpY2UoaW5kZXggKyAzKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaW5kZXgpICsgJy4uLy4uL2VzbS8nICsgcGF0aC5zbGljZShpbmRleCArIDMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lQW5kUGF0aC5wdXNoKHttb2R1bGVOYW1lLCBwYXRofSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5tYXRjaChleHBvcnRSZWdleCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGV4cG9ydCBzdGF0ZW1lbnRzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFuTGluZXMucHVzaChgICAgICR7bGluZX1gKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBwYXJ0cyBvZiB0aGUgc291cmNlIHdlJ2xsIGJlIHJ1bm5pbmcuXG4gICAgICAgIC8vICogVGhlIHByb21pc2VzL2ltcG9ydCgpIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVzZXIncyBpbXBvcnQgc3RhdGVtZW50c1xuICAgICAgICAvLyAqIFRoZSB2YXJzIGhvbGRpbmcgdGhlIG5hbWUgb2YgdGhlIGltcG9ydGVkIG1vZHVsZSBiYXNlZCBvbiB0aGUgbW9kdWxlIG5hbWUgZm9yIGVhY2ggaW1wb3J0XG4gICAgICAgIC8vICogVGhlIHJlc3Qgb2YgdGhlIHVzZXItcHJvdmlkZWQgc291cmNlXG4gICAgICAgIC8vIEl0J2xsIGVuZCB1cCBsb29raW5nIGxpa2UgdGhpczpcbiAgICAgICAgLy8gUHJvbWlzZS5hbGwoW1xuICAgICAgICAvLyAgICAgaW1wb3J0KCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmVvLm1qcy9zcmMvY29udGFpbmVyL0Jhc2UubWpzJyksXG4gICAgICAgIC8vICAgICBpbXBvcnQoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZW8ubWpzL3NyYy9idXR0b24vQmFzZS5tanMnKVxuICAgICAgICAvLyAgIF0pLnRoZW4oKFtCYXNlTW9kdWxlLCBCdXR0b25Nb2R1bGVdKSA9PiB7XG4gICAgICAgIC8vICAgICAgIGNvbnN0IEJhc2UgPSBCYXNlTW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgIC8vICAgICAgIGNvbnN0IEJ1dHRvbiA9IEJ1dHRvbk1vZHVsZS5kZWZhdWx0O1xuICAgICAgICAvLyAgICAgICAvLyBDbGFzcyBkZWNsYXJhdGlvbiBnb2VzIGhlcmUuLi5cbiAgICAgICAgLy8gICB9KTtcbiAgICAgICAgLy8gTWFraW5nIHRoZSBwcm9taXNlIHBhcnQgb2YgdGhlIGV2YWwgc2VlbXMgd2VpcmQsIGJ1dCBpdCBtYWRlIGl0IGVhc2llciB0b1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGltcG9ydCB2YXJzLlxuICAgICAgICBwcm9taXNlcyA9IG1vZHVsZU5hbWVBbmRQYXRoLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGAke2l0ZW0ubW9kdWxlTmFtZX1Nb2R1bGVgKTtcbiAgICAgICAgICAgIHZhcnMucHVzaChgICAgIGNvbnN0ICR7aXRlbS5tb2R1bGVOYW1lfSA9ICR7aXRlbS5tb2R1bGVOYW1lfU1vZHVsZS5kZWZhdWx0O2ApO1xuICAgICAgICAgICAgcmV0dXJuIGBpbXBvcnQoJyR7aXRlbS5wYXRofScpYFxuICAgICAgICB9KTtcblxuICAgICAgICBjb2RlU3RyaW5nID0gW1xuICAgICAgICAgICAgJ1Byb21pc2UuYWxsKFsnLFxuICAgICAgICAgICAgYCAgICAke3Byb21pc2VzLmpvaW4oJyxcXG4nKX1gLFxuICAgICAgICAgICAgYF0pLnRoZW4oKFske3BhcmFtcy5qb2luKCcsICcpfV0pID0+IHtgLFxuICAgICAgICAgICAgYCR7dmFycy5qb2luKCdcXG4nKX1gLFxuICAgICAgICAgICAgYCAgICAke2NsZWFuTGluZXMuam9pbignXFxuJyl9YCxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgYCAgICBpZiAoJHtjbGFzc05hbWV9ICYmIE5lby5jb21wb25lbnQuQmFzZS5pc1Byb3RvdHlwZU9mKCR7Y2xhc3NOYW1lfSkpIHtgLFxuICAgICAgICAgICAgYCAgICAgICAgY29udGFpbmVyLmFkZCh7bW9kdWxlOiR7Y2xhc3NOYW1lfX0pYCxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnfSknLFxuICAgICAgICAgICAgJy5jYXRjaChlcnJvciA9PiBjb250YWluZXIuYWRkKHtudHlwZTpcXCdjb21wb25lbnRcXCcsIGh0bWw6ZXJyb3IubWVzc2FnZX0pKTsnXG4gICAgICAgIF0uam9pbignXFxuJylcblxuICAgICAgICBjb250YWluZXIucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgLy8gV2UgbXVzdCBlbnN1cmUgdGhhdCBjbGFzc2VzIGluc2lkZSB0aGUgZWRpdG9yIHdvbid0IGdldCBjYWNoZWQsIHNpbmNlIHRoaXMgZGlzYWJsZXMgcnVuLXRpbWUgY2hhbmdlc1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy81ODYzXG4gICAgICAgIG1lLmZpbmRDbGFzc05hbWVzKGNvZGVTdHJpbmcpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBsZXQgbnNBcnJheSAgID0gaXRlbS5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IG5zQXJyYXkucG9wKCksXG4gICAgICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKG5zQXJyYXkpO1xuXG4gICAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbnNbY2xhc3NOYW1lXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdjb250YWluZXInLCBjb2RlU3RyaW5nKShjb250YWluZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29udGFpbmVyLmFkZCh7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIGh0bWwgOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZUNvZGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZmluZENsYXNzTmFtZXMoc291cmNlQ29kZSkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtdLFxuICAgICAgICAgICAgbWF0Y2g7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGNsYXNzTmFtZVJlZ2V4LmV4ZWMoc291cmNlQ29kZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2gobWF0Y2hbMV0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2VDb2RlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGZpbmRMYXN0Q2xhc3NOYW1lKHNvdXJjZUNvZGUpIHtcbiAgICAgICAgbGV0IGxhc3RDbGFzc05hbWUgPSBudWxsLFxuICAgICAgICAgICAgbWF0Y2g7XG5cbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGNsYXNzRGVjbGFyYXRpb25SZWdleC5leGVjKHNvdXJjZUNvZGUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNsYXNzIG5hbWUgZm91bmRcbiAgICAgICAgICAgIGxhc3RDbGFzc05hbWUgPSBtYXRjaFsxXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhc3RDbGFzc05hbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0UHJldmlld0NvbnRhaW5lcigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucHJldmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnByZXZpZXdDb250YWluZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuc291cmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEudmFsdWVcbiAgICAgKi9cbiAgICBvbkFjdGl2ZUluZGV4Q2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpc1ByZXZpZXcgPSBkYXRhLnZhbHVlID09PSAxO1xuXG4gICAgICAgIGlmIChkYXRhLml0ZW0ucmVmZXJlbmNlID09PSAncHJldmlldycpIHtcbiAgICAgICAgICAgIG1lLmRvUnVuU291cmNlKClcbiAgICAgICAgfVxuICAgICAgICAvLyBOYXZpZ2F0aW5nIHRvIHRoZSBzb3VyY2UgdmlldyBzaG91bGQgZGVzdHJveSB0aGUgYXBwLCBpbiBjYXNlIHRoZSBwcmV2aWV3IHZpZXcgaXMgbm90IHBvcHBlZCBvdXRcbiAgICAgICAgZWxzZSBpZiAoIWlzUHJldmlldyAmJiAhbWUucHJldmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgbWUuZ2V0UmVmZXJlbmNlKCdwcmV2aWV3JykucmVtb3ZlQWxsKClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmdldFJlZmVyZW5jZSgncG9wb3V0LXdpbmRvdy1idXR0b24nKS5oaWRkZW4gPSAhaXNQcmV2aWV3XG4gICAgICAgIG1lLmRpc2FibGVSdW5Tb3VyY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHt0YWJDb250YWluZXJ9ID0gbWU7XG5cbiAgICAgICAgaWYgKG1lLmVuYWJsZUZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLmNvbGxhcHNlRXhwYW5kLmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYXMgZmEtZXhwYW5kJyxcbiAgICAgICAgICAgICAgICB1aSAgICAgOiAnZ2hvc3QnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICBoYW5kbGVyICA6IG1lLnBvcG91dFByZXZpZXcuYmluZChtZSksXG4gICAgICAgICAgICBoaWRkZW4gICA6IHRhYkNvbnRhaW5lci5hY3RpdmVJbmRleCAhPT0gMSxcbiAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhciBmYS13aW5kb3ctbWF4aW1pemUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAncG9wb3V0LXdpbmRvdy1idXR0b24nLFxuICAgICAgICAgICAgdWkgICAgICAgOiAnZ2hvc3QnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW1zLnVuc2hpZnQoJy0+Jyk7XG5cbiAgICAgICAgLy8gd2Ugd2FudCB0byBhZGQgYSBub3JtYWwgKG5vbi1oZWFkZXIpIGJ1dHRvblxuICAgICAgICB0YWJDb250YWluZXIuZ2V0VGFiQmFyKCkuYWRkKGl0ZW1zKTtcblxuICAgICAgICB0YWJDb250YWluZXIuZ2V0VGFiQmFyKCkudXBkYXRlKCk7XG5cbiAgICAgICAgdGFiQ29udGFpbmVyLm9uKCdhY3RpdmVJbmRleENoYW5nZScsIG1lLm9uQWN0aXZlSW5kZXhDaGFuZ2UsIG1lKTtcblxuICAgICAgICAvLyBjaGFuZ2luZyB0aGUgYWN0aXZlVmlldyBpbml0aWFsbHkgd2lsbCBub3QgdHJpZ2dlciBvdXIgb25BY3RpdmVJbmRleENoYW5nZSgpIGxvZ2ljXG4gICAgICAgIG1lLmFjdGl2ZVZpZXcgPT09ICdwcmV2aWV3JyAmJiBtZS5kb1J1blNvdXJjZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkVkaXRvckNoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZWRpdG9yVmFsdWUgPSBkYXRhLnZhbHVlO1xuXG4gICAgICAgIC8vIFdlIGFyZSBub3QgdXNpbmcgZ2V0UHJldmlld0NvbnRhaW5lcigpLCBzaW5jZSB3ZSBvbmx5IHdhbnQgdG8gdXBkYXRlIHRoZSBMaXZlUHJldmlldyBpbiBjYXNlIGl0IGlzIHZpc2libGUuXG4gICAgICAgIGlmIChtZS5wcmV2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBtZS5kb1J1blNvdXJjZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIHBvcG91dFByZXZpZXcoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGRhdGEuY29tcG9uZW50LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgbWUuY3JlYXRlUG9wdXBXaW5kb3coKTtcblxuICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCByZXF1aXJlcyBhIHZpZXcgY29udHJvbGxlciB0byBtYW5hZ2UgY29ubmVjdGVkIGFwcHNcbiAgICAgICAgbWUuZ2V0Q29udHJvbGxlcigndmlld3BvcnQtY29udHJvbGxlcicpPy5jb25uZWN0ZWRBcHBzLnB1c2gobWUuaWQpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMaXZlUHJldmlldyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=