export const __webpack_esm_id__ = "vendors-src_code_LivePreview_mjs";
export const __webpack_esm_ids__ = ["vendors-src_code_LivePreview_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/code/LivePreview.mjs"
/*!**********************************!*\
  !*** ./src/code/LivePreview.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/wrapper/MonacoEditor.mjs */ "./src/component/wrapper/MonacoEditor.mjs");
/* harmony import */ var _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tab/Container.mjs */ "./src/tab/Container.mjs");




const configSymbol = Symbol.for('configSymbol');

/**
 * @summary A split-view component for real-time code editing and execution.
 *
 * This class provides a robust environment for editing source code and viewing the results in real-time.
 * It integrates the **Monaco Editor** for a rich editing experience and supports multiple languages and execution modes.
 *
 * Key features:
 * - **Multi-Language Support**: Supports 'neomjs' (JS execution) and 'markdown' (rendering).
 * - **Dynamic Imports**: Utilizes `import()` to lazy-load the Markdown component or Code Executor, optimizing initial load performance.
 * - **Sandboxed Execution**: Executes Neo.mjs code within a controlled context using `new Function`.
 * - **Responsive Layout**: collapsible, pop-out support, and configurable views (source vs. preview).
 *
 * This component is central to the Neo.mjs learning experience and documentation portal.
 *
 * @class Neo.code.LivePreview
 * @extends Neo.container.Base
 * @see Neo.code.executor.Neo
 * @see Neo.component.Markdown
 * @see Neo.component.wrapper.MonacoEditor
 */
class LivePreview extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for activeView
     * @member {String[]} activeViews=['preview','source']
     * @protected
     * @static
     */
    static activeViews = ['preview', 'source']
    /**
     * Valid values for language
     * @member {String[]} languages=['markdown','neomjs']
     * @protected
     * @static
     */
    static languages = ['markdown', 'neomjs']

    static config = {
        /**
         * @member {String} className='Neo.code.LivePreview'
         * @protected
         */
        className: 'Neo.code.LivePreview',
        /**
         * @member {String} ntype='live-preview'
         * @protected
         */
        ntype: 'live-preview',
        /**
         * Valid values are 'preview' and 'source'
         * @member {String} activeView_='source'
         * @reactive
         */
        activeView_: 'source',
        /**
         * @member {String[]} baseCls=['neo-code-live-preview']
         */
        baseCls: ['neo-code-live-preview'],
        /**
         * @member {Boolean} disableRunSource=false
         */
        disableRunSource: false,
        /**
         * @member {Boolean} enableFullscreen=true
         */
        enableFullscreen: true,
        /**
         * @member {String} language_='neomjs'
         * @reactive
         */
        language_: 'neomjs',
        /**
         * @member {Object|String} layout='fit'
         * @reactive
         */
        layout: 'fit',
        /**
         * @member {Object[]} items
         */
        items: [{
            module             : _tab_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            cls                : ['live-preview-container'],
            reference          : 'tab-container',
            removeInactiveCards: false,

            items: [{
                module   : _component_wrapper_MonacoEditor_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                header   : {text: 'Source'},
                hideLabel: true,
                listeners: {editorChange: 'up.onEditorChange'},
                style    : {height: '100%'},
                reference: 'editor'
            }, {
                module   : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                header   : {text: 'Preview'},
                reference: 'preview'
            }]
        }],
        /**
         * The code to display inside the Monaco editor
         * @member {String|null} value_=null
         * @reactive
         */
        value_: null,
        /**
         * The url for the child app to use for the popout window
         * @member {String} windowUrl_='./childapps/preview/index.html'
         * @reactive
         */
        windowUrl_: './childapps/preview/index.html'
    }

    /**
     * @member {Number|null} connectedWindowId=null
     */
    connectedWindowId = null
    /**
     * @member {Neo.component.Markdown|null} markdownComponent=null
     */
    markdownComponent = null
    /**
     * @member {Class|null} markdownComponentClass=null
     */
    markdownComponentClass = null
    /**
     * @member {Neo.code.executor.Neo|null} neoExecutor=null
     */
    neoExecutor = null
    /**
     * Link the preview output to different targets
     * @member {Neo.component.Base} previewContainer=null
     */
    previewContainer = null

    /**
     * @returns {Neo.component.Base|null}
     */
    get tabContainer() {
        return this.getItem('tab-container')
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        this.tabContainer.activeIndex = value === 'source' ? 0 : 1
    }

    /**
     * Triggered after the language config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLanguage(value, oldValue) {
        let me = this;

        if (value !== 'markdown') {
            me.markdownComponent = null
        }

        me.getItem('editor').language = value === 'neomjs' ? 'javascript' : value;

        // If there is a new pending value for the value config, it will run trigger doRunSource().
        // This can happen when calling: this.set({language, value})
        if (oldValue && !Object.hasOwn(me[configSymbol], 'value')) {
            me.doRunSource()
        }
    }


    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        if (value) {
            this.getItem('editor').value = value?.trim()
        }
    }

    /**
     * Triggered before the activeView config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView')
    }

    /**
     * Triggered before the language config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetLanguage(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'language')
    }

    /**
     * Triggered before the language config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetWindowUrl(value, oldValue) {
        if (value.startsWith('./')) {
            let appPath = Neo.config.appPath.split('/');
            appPath.pop()

            return new URL(Neo.config.basePath + appPath.join('/') + value.substring(1), location.href).href
        }

        return value
    }

    /**
     * @param {Object} data
     */
    async collapseExpand(data) {
        let me       = this,
            button   = data.component,
            collapse = button.iconCls === 'fas fa-compress',
            {vdom}   = me,
            rect;

        if (collapse) {
            button.iconCls = 'fas fa-expand';

            rect = me.collapseRect;

            delete me.collapseRect;

            Object.assign(vdom.style, {
                height  : rect.height + 'px',
                left    : rect.x      + 'px',
                top     : rect.y      + 'px',
                width   : rect.width  + 'px'
            });

            me.update();

            await me.timeout(300);

            Object.assign(vdom.style, {
                position: null,
                zIndex  : null
            })
        } else {
            button.iconCls = 'fas fa-compress';

            rect = await me.getDomRect();

            me.collapseRect = rect;

            vdom.style = vdom.style || {};

            Object.assign(vdom.style, {
                height  : rect.height + 'px',
                left    : rect.x      + 'px',
                position: 'fixed',
                top     : rect.y      + 'px',
                width   : rect.width  + 'px',
                zIndex  : 103
            });

            me.update();

            await me.timeout(50);

            Object.assign(vdom.style, {
                height: '100%',
                left  : 0,
                top   : 0,
                width : '100%'
            })
        }

        me.update()
    }

    /**
     *
     */
    async createPopupWindow() {
        let me         = this,
            {windowId} = me,
            winData    = await Neo.Main.getWindowData({windowId}),
            rect       = await me.getDomRect(me.getReference('preview').id);

        let {height, left, top, width} = rect;

        left += winData.screenLeft;
        top  += (winData.outerHeight - winData.innerHeight + winData.screenTop);

        Neo.Main.windowOpen({
            url           : `${me.windowUrl}?id=${me.id}`,
            windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
            windowId,
            windowName    : me.id
        })
    }

    /**
     * @param {...*} args
     */
    destroy(...args) {
        if (this.connectedWindowId) {
            Neo.Main.windowClose({names: [this.id], windowId: this.windowId})
        }

        super.destroy(...args)
    }

    /**
     * Executes the current source code.
     *
     * This method acts as the **execution trigger**. It orchestrates the process by:
     * 1.  **Validation**: Ensuring source code exists.
     * 2.  **Execution**:
     *     - For **Markdown**: Clears the container and adds a new `Neo.component.Markdown` instance.
     *     - For **Neo.mjs**: Delegates execution to the `Neo.code.executor.Neo` instance.
     *
     * @returns {Promise<void>}
     */
    async doRunSource() {
        if (this.disableRunSource) {
            return
        }

        let me        = this,
            container = me.getPreviewContainer(),
            source    = me.editorValue || me.value; // Use current editor value or initial value

        if (!source) return;

        if (me.language === 'markdown') {
            if (!me.markdownComponentClass) {
                const module = await __webpack_require__.e(/*! import() */ "vendors-src_component_Markdown_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../component/Markdown.mjs */ "./src/component/Markdown.mjs"));
                me.markdownComponentClass = module.default;
            }

            if (me.markdownComponent && !me.markdownComponent.isDestroyed) {
                me.markdownComponent.value = source
            } else {
                // destroy, silent => merge changes into one update cycle
                container.removeAll(true, true);

                me.markdownComponent = container.add({
                    module   : me.markdownComponentClass,
                    style    : {height: '100%', overflow: 'auto'},
                    value    : source,
                    windowUrl: me.windowUrl
                })
            }
        } else {
            if (!me.neoExecutor) {
                const module = await __webpack_require__.e(/*! import() */ "src_code_executor_Neo_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./executor/Neo.mjs */ "./src/code/executor/Neo.mjs"));
                me.neoExecutor = Neo.create(module.default);
            }

            await me.neoExecutor.execute({code: source, container})
        }
    }

    /**
     * @returns {Neo.component.Base|null}
     */
    getPreviewContainer() {
        let me = this;

        if (me.previewContainer) {
            return me.previewContainer
        }

        return me.getReference('preview')
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.item
     * @param {Number} data.oldValue
     * @param {String} data.source
     * @param {Number} data.value
     */
    onActiveIndexChange(data) {
        let me        = this,
            isPreview = data.value === 1;

        if (data.item.reference === 'preview') {
            me.doRunSource()
        }
        // Navigating to the source view should destroy the app, in case the preview view is not popped out
        else if (!isPreview && !me.previewContainer) {
            me.getReference('preview').removeAll()
        }

        me.getReference('popout-window-button').hidden = !isPreview
        me.disableRunSource = false;
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me             = this,
            items          = [],
            {tabContainer} = me;

        me.editor

        if (me.enableFullscreen) {
            items.push({
                handler: me.collapseExpand.bind(me),
                iconCls: 'fas fa-expand',
                ui     : 'ghost'
            })
        }

        // Only add the popout window button in case we are using shared workers
        if (Neo.config.useSharedWorkers) {
            items.push({
                handler  : me.popoutPreview.bind(me),
                hidden   : tabContainer.activeIndex !== 1,
                iconCls  : 'far fa-window-maximize',
                reference: 'popout-window-button',
                ui       : 'ghost'
            });

            Neo.currentWorker.on({
                connect   : me.onWindowConnect,
                disconnect: me.onWindowDisconnect,
                scope     : me
            })
        }

        items.unshift('->');

        // we want to add a normal (non-header) button
        tabContainer.getTabBar().add(items);

        tabContainer.getTabBar().update();

        tabContainer.on('activeIndexChange', me.onActiveIndexChange, me);

        // changing the activeView initially will not trigger our onActiveIndexChange() logic
        me.activeView === 'preview' && me.doRunSource()
    }

    /**
     * @param {Object} data
     * @param {String} data.value
     */
    onEditorChange({value}) {
        let me = this;

        me._value = value;

        me.editorValue = value;

        me.fire('editorChange', {value});

        me.doRunSource()
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Number} data.windowId
     */
    async onWindowConnect(data) {
        let me           = this,
            searchString = await Neo.Main.getByPath({path: 'location.search', windowId: data.windowId}),
            params       = new URLSearchParams(searchString),
            id           = params.get('id');

        if (id === me.id) {
            me.connectedWindowId = data.windowId;

            let app              = Neo.apps[data.windowId],
                mainView         = app.mainView,
                previewContainer = me.getReference('preview'),
                {tabContainer}   = me,
                previewView      = previewContainer.removeAt(0, false);

            me.previewContainer = mainView;
            mainView.add(previewView);

            tabContainer.activeIndex = 0; // switch to the source view

            tabContainer.getTabAtIndex(1).disabled = true
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Number} data.windowId
     */
    async onWindowDisconnect(data) {
        let me = this;

        if (data.windowId === me.connectedWindowId) {
            let app              = Neo.apps[data.windowId],
                mainView         = app.mainView,
                previewContainer = me.getReference('preview'),
                {tabContainer}   = me,
                previewView      = mainView.removeAt(0, false);

            me.previewContainer = null;
            previewContainer.add(previewView);

            me.disableRunSource = true; // will get reset after the next activeIndex change (async)
            tabContainer.activeIndex = 1;        // switch to the source view

            me.getReference('popout-window-button').disabled = false;
            tabContainer.getTabAtIndex(1).disabled = false;

            me.connectedWindowId = null
        }
    }

    /**
     * @param {Object} data
     */
    async popoutPreview(data) {
        let me = this;

        data.component.disabled = true;
        await me.createPopupWindow()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(LivePreview));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb2RlX0xpdmVQcmV2aWV3X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNlO0FBQ2hCOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFTO0FBQ25DO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBLGlDQUFpQywwREFBWTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsMkVBQVk7QUFDdkMsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlELDRCQUE0QixlQUFlO0FBQzNDO0FBQ0EsYUFBYTtBQUNiLDJCQUEyQiwyREFBUztBQUNwQyw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29kZS9MaXZlUHJldmlldy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbnRhaW5lciAgICBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IE1vbmFjb0VkaXRvciBmcm9tICcuLi9jb21wb25lbnQvd3JhcHBlci9Nb25hY29FZGl0b3IubWpzJ1xuaW1wb3J0IFRhYkNvbnRhaW5lciBmcm9tICcuLi90YWIvQ29udGFpbmVyLm1qcyc7XG5cbmNvbnN0IGNvbmZpZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ2NvbmZpZ1N5bWJvbCcpO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEEgc3BsaXQtdmlldyBjb21wb25lbnQgZm9yIHJlYWwtdGltZSBjb2RlIGVkaXRpbmcgYW5kIGV4ZWN1dGlvbi5cbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGEgcm9idXN0IGVudmlyb25tZW50IGZvciBlZGl0aW5nIHNvdXJjZSBjb2RlIGFuZCB2aWV3aW5nIHRoZSByZXN1bHRzIGluIHJlYWwtdGltZS5cbiAqIEl0IGludGVncmF0ZXMgdGhlICoqTW9uYWNvIEVkaXRvcioqIGZvciBhIHJpY2ggZWRpdGluZyBleHBlcmllbmNlIGFuZCBzdXBwb3J0cyBtdWx0aXBsZSBsYW5ndWFnZXMgYW5kIGV4ZWN1dGlvbiBtb2Rlcy5cbiAqXG4gKiBLZXkgZmVhdHVyZXM6XG4gKiAtICoqTXVsdGktTGFuZ3VhZ2UgU3VwcG9ydCoqOiBTdXBwb3J0cyAnbmVvbWpzJyAoSlMgZXhlY3V0aW9uKSBhbmQgJ21hcmtkb3duJyAocmVuZGVyaW5nKS5cbiAqIC0gKipEeW5hbWljIEltcG9ydHMqKjogVXRpbGl6ZXMgYGltcG9ydCgpYCB0byBsYXp5LWxvYWQgdGhlIE1hcmtkb3duIGNvbXBvbmVudCBvciBDb2RlIEV4ZWN1dG9yLCBvcHRpbWl6aW5nIGluaXRpYWwgbG9hZCBwZXJmb3JtYW5jZS5cbiAqIC0gKipTYW5kYm94ZWQgRXhlY3V0aW9uKio6IEV4ZWN1dGVzIE5lby5tanMgY29kZSB3aXRoaW4gYSBjb250cm9sbGVkIGNvbnRleHQgdXNpbmcgYG5ldyBGdW5jdGlvbmAuXG4gKiAtICoqUmVzcG9uc2l2ZSBMYXlvdXQqKjogY29sbGFwc2libGUsIHBvcC1vdXQgc3VwcG9ydCwgYW5kIGNvbmZpZ3VyYWJsZSB2aWV3cyAoc291cmNlIHZzLiBwcmV2aWV3KS5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyBjZW50cmFsIHRvIHRoZSBOZW8ubWpzIGxlYXJuaW5nIGV4cGVyaWVuY2UgYW5kIGRvY3VtZW50YXRpb24gcG9ydGFsLlxuICpcbiAqIEBjbGFzcyBOZW8uY29kZS5MaXZlUHJldmlld1xuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKiBAc2VlIE5lby5jb2RlLmV4ZWN1dG9yLk5lb1xuICogQHNlZSBOZW8uY29tcG9uZW50Lk1hcmtkb3duXG4gKiBAc2VlIE5lby5jb21wb25lbnQud3JhcHBlci5Nb25hY29FZGl0b3JcbiAqL1xuY2xhc3MgTGl2ZVByZXZpZXcgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgYWN0aXZlVmlld1xuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBhY3RpdmVWaWV3cz1bJ3ByZXZpZXcnLCdzb3VyY2UnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGFjdGl2ZVZpZXdzID0gWydwcmV2aWV3JywgJ3NvdXJjZSddXG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBsYW5ndWFnZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBsYW5ndWFnZXM9WydtYXJrZG93bicsJ25lb21qcyddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgbGFuZ3VhZ2VzID0gWydtYXJrZG93bicsICduZW9tanMnXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29kZS5MaXZlUHJldmlldydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvZGUuTGl2ZVByZXZpZXcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGl2ZS1wcmV2aWV3J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xpdmUtcHJldmlldycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXMgYXJlICdwcmV2aWV3JyBhbmQgJ3NvdXJjZSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBhY3RpdmVWaWV3Xz0nc291cmNlJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZVZpZXdfOiAnc291cmNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNvZGUtbGl2ZS1wcmV2aWV3J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNvZGUtbGl2ZS1wcmV2aWV3J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlUnVuU291cmNlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlUnVuU291cmNlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZUZ1bGxzY3JlZW49dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlRnVsbHNjcmVlbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbGFuZ3VhZ2VfPSduZW9tanMnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGFuZ3VhZ2VfOiAnbmVvbWpzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd9IGxheW91dD0nZml0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogJ2ZpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogVGFiQ29udGFpbmVyLFxuICAgICAgICAgICAgY2xzICAgICAgICAgICAgICAgIDogWydsaXZlLXByZXZpZXctY29udGFpbmVyJ10sXG4gICAgICAgICAgICByZWZlcmVuY2UgICAgICAgICAgOiAndGFiLWNvbnRhaW5lcicsXG4gICAgICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiBmYWxzZSxcblxuICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgOiBNb25hY29FZGl0b3IsXG4gICAgICAgICAgICAgICAgaGVhZGVyICAgOiB7dGV4dDogJ1NvdXJjZSd9LFxuICAgICAgICAgICAgICAgIGhpZGVMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtlZGl0b3JDaGFuZ2U6ICd1cC5vbkVkaXRvckNoYW5nZSd9LFxuICAgICAgICAgICAgICAgIHN0eWxlICAgIDoge2hlaWdodDogJzEwMCUnfSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6ICdlZGl0b3InXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgOiBDb250YWluZXIsXG4gICAgICAgICAgICAgICAgaGVhZGVyICAgOiB7dGV4dDogJ1ByZXZpZXcnfSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6ICdwcmV2aWV3J1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29kZSB0byBkaXNwbGF5IGluc2lkZSB0aGUgTW9uYWNvIGVkaXRvclxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdmFsdWVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXJsIGZvciB0aGUgY2hpbGQgYXBwIHRvIHVzZSBmb3IgdGhlIHBvcG91dCB3aW5kb3dcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB3aW5kb3dVcmxfPScuL2NoaWxkYXBwcy9wcmV2aWV3L2luZGV4Lmh0bWwnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93VXJsXzogJy4vY2hpbGRhcHBzL3ByZXZpZXcvaW5kZXguaHRtbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gY29ubmVjdGVkV2luZG93SWQ9bnVsbFxuICAgICAqL1xuICAgIGNvbm5lY3RlZFdpbmRvd0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuTWFya2Rvd258bnVsbH0gbWFya2Rvd25Db21wb25lbnQ9bnVsbFxuICAgICAqL1xuICAgIG1hcmtkb3duQ29tcG9uZW50ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0NsYXNzfG51bGx9IG1hcmtkb3duQ29tcG9uZW50Q2xhc3M9bnVsbFxuICAgICAqL1xuICAgIG1hcmtkb3duQ29tcG9uZW50Q2xhc3MgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmNvZGUuZXhlY3V0b3IuTmVvfG51bGx9IG5lb0V4ZWN1dG9yPW51bGxcbiAgICAgKi9cbiAgICBuZW9FeGVjdXRvciA9IG51bGxcbiAgICAvKipcbiAgICAgKiBMaW5rIHRoZSBwcmV2aWV3IG91dHB1dCB0byBkaWZmZXJlbnQgdGFyZ2V0c1xuICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gcHJldmlld0NvbnRhaW5lcj1udWxsXG4gICAgICovXG4gICAgcHJldmlld0NvbnRhaW5lciA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgdGFiQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKCd0YWItY29udGFpbmVyJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFjdGl2ZVZpZXcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWN0aXZlVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy50YWJDb250YWluZXIuYWN0aXZlSW5kZXggPSB2YWx1ZSA9PT0gJ3NvdXJjZScgPyAwIDogMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFuZ3VhZ2UgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFuZ3VhZ2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAnbWFya2Rvd24nKSB7XG4gICAgICAgICAgICBtZS5tYXJrZG93bkNvbXBvbmVudCA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmdldEl0ZW0oJ2VkaXRvcicpLmxhbmd1YWdlID0gdmFsdWUgPT09ICduZW9tanMnID8gJ2phdmFzY3JpcHQnIDogdmFsdWU7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBuZXcgcGVuZGluZyB2YWx1ZSBmb3IgdGhlIHZhbHVlIGNvbmZpZywgaXQgd2lsbCBydW4gdHJpZ2dlciBkb1J1blNvdXJjZSgpLlxuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBjYWxsaW5nOiB0aGlzLnNldCh7bGFuZ3VhZ2UsIHZhbHVlfSlcbiAgICAgICAgaWYgKG9sZFZhbHVlICYmICFPYmplY3QuaGFzT3duKG1lW2NvbmZpZ1N5bWJvbF0sICd2YWx1ZScpKSB7XG4gICAgICAgICAgICBtZS5kb1J1blNvdXJjZSgpXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdmFsdWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0SXRlbSgnZWRpdG9yJykudmFsdWUgPSB2YWx1ZT8udHJpbSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhY3RpdmVWaWV3IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBY3RpdmVWaWV3KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnYWN0aXZlVmlldycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbGFuZ3VhZ2UgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldExhbmd1YWdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnbGFuZ3VhZ2UnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGxhbmd1YWdlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRXaW5kb3dVcmwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICAgICAgICBsZXQgYXBwUGF0aCA9IE5lby5jb25maWcuYXBwUGF0aC5zcGxpdCgnLycpO1xuICAgICAgICAgICAgYXBwUGF0aC5wb3AoKVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTChOZW8uY29uZmlnLmJhc2VQYXRoICsgYXBwUGF0aC5qb2luKCcvJykgKyB2YWx1ZS5zdWJzdHJpbmcoMSksIGxvY2F0aW9uLmhyZWYpLmhyZWZcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgY29sbGFwc2VFeHBhbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYnV0dG9uICAgPSBkYXRhLmNvbXBvbmVudCxcbiAgICAgICAgICAgIGNvbGxhcHNlID0gYnV0dG9uLmljb25DbHMgPT09ICdmYXMgZmEtY29tcHJlc3MnLFxuICAgICAgICAgICAge3Zkb219ICAgPSBtZSxcbiAgICAgICAgICAgIHJlY3Q7XG5cbiAgICAgICAgaWYgKGNvbGxhcHNlKSB7XG4gICAgICAgICAgICBidXR0b24uaWNvbkNscyA9ICdmYXMgZmEtZXhwYW5kJztcblxuICAgICAgICAgICAgcmVjdCA9IG1lLmNvbGxhcHNlUmVjdDtcblxuICAgICAgICAgICAgZGVsZXRlIG1lLmNvbGxhcHNlUmVjdDtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICA6IHJlY3QuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgIDogcmVjdC54ICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgOiByZWN0LnkgICAgICArICdweCcsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IHJlY3Qud2lkdGggICsgJ3B4J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwMCk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIHpJbmRleCAgOiBudWxsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnV0dG9uLmljb25DbHMgPSAnZmFzIGZhLWNvbXByZXNzJztcblxuICAgICAgICAgICAgcmVjdCA9IGF3YWl0IG1lLmdldERvbVJlY3QoKTtcblxuICAgICAgICAgICAgbWUuY29sbGFwc2VSZWN0ID0gcmVjdDtcblxuICAgICAgICAgICAgdmRvbS5zdHlsZSA9IHZkb20uc3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgOiByZWN0LmhlaWdodCArICdweCcsXG4gICAgICAgICAgICAgICAgbGVmdCAgICA6IHJlY3QueCAgICAgICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICB0b3AgICAgIDogcmVjdC55ICAgICAgKyAncHgnLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgOiByZWN0LndpZHRoICArICdweCcsXG4gICAgICAgICAgICAgICAgekluZGV4ICA6IDEwM1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUwKTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiAwLFxuICAgICAgICAgICAgICAgIHRvcCAgIDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aCA6ICcxMDAlJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQb3B1cFdpbmRvdygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1lLFxuICAgICAgICAgICAgd2luRGF0YSAgICA9IGF3YWl0IE5lby5NYWluLmdldFdpbmRvd0RhdGEoe3dpbmRvd0lkfSksXG4gICAgICAgICAgICByZWN0ICAgICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChtZS5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKS5pZCk7XG5cbiAgICAgICAgbGV0IHtoZWlnaHQsIGxlZnQsIHRvcCwgd2lkdGh9ID0gcmVjdDtcblxuICAgICAgICBsZWZ0ICs9IHdpbkRhdGEuc2NyZWVuTGVmdDtcbiAgICAgICAgdG9wICArPSAod2luRGF0YS5vdXRlckhlaWdodCAtIHdpbkRhdGEuaW5uZXJIZWlnaHQgKyB3aW5EYXRhLnNjcmVlblRvcCk7XG5cbiAgICAgICAgTmVvLk1haW4ud2luZG93T3Blbih7XG4gICAgICAgICAgICB1cmwgICAgICAgICAgIDogYCR7bWUud2luZG93VXJsfT9pZD0ke21lLmlkfWAsXG4gICAgICAgICAgICB3aW5kb3dGZWF0dXJlczogYGhlaWdodD0ke2hlaWdodH0sbGVmdD0ke2xlZnR9LHRvcD0ke3RvcH0sd2lkdGg9JHt3aWR0aH1gLFxuICAgICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgICB3aW5kb3dOYW1lICAgIDogbWUuaWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkV2luZG93SWQpIHtcbiAgICAgICAgICAgIE5lby5NYWluLndpbmRvd0Nsb3NlKHtuYW1lczogW3RoaXMuaWRdLCB3aW5kb3dJZDogdGhpcy53aW5kb3dJZH0pXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGN1cnJlbnQgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhY3RzIGFzIHRoZSAqKmV4ZWN1dGlvbiB0cmlnZ2VyKiouIEl0IG9yY2hlc3RyYXRlcyB0aGUgcHJvY2VzcyBieTpcbiAgICAgKiAxLiAgKipWYWxpZGF0aW9uKio6IEVuc3VyaW5nIHNvdXJjZSBjb2RlIGV4aXN0cy5cbiAgICAgKiAyLiAgKipFeGVjdXRpb24qKjpcbiAgICAgKiAgICAgLSBGb3IgKipNYXJrZG93bioqOiBDbGVhcnMgdGhlIGNvbnRhaW5lciBhbmQgYWRkcyBhIG5ldyBgTmVvLmNvbXBvbmVudC5NYXJrZG93bmAgaW5zdGFuY2UuXG4gICAgICogICAgIC0gRm9yICoqTmVvLm1qcyoqOiBEZWxlZ2F0ZXMgZXhlY3V0aW9uIHRvIHRoZSBgTmVvLmNvZGUuZXhlY3V0b3IuTmVvYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGRvUnVuU291cmNlKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlUnVuU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29udGFpbmVyID0gbWUuZ2V0UHJldmlld0NvbnRhaW5lcigpLFxuICAgICAgICAgICAgc291cmNlICAgID0gbWUuZWRpdG9yVmFsdWUgfHwgbWUudmFsdWU7IC8vIFVzZSBjdXJyZW50IGVkaXRvciB2YWx1ZSBvciBpbml0aWFsIHZhbHVlXG5cbiAgICAgICAgaWYgKCFzb3VyY2UpIHJldHVybjtcblxuICAgICAgICBpZiAobWUubGFuZ3VhZ2UgPT09ICdtYXJrZG93bicpIHtcbiAgICAgICAgICAgIGlmICghbWUubWFya2Rvd25Db21wb25lbnRDbGFzcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGF3YWl0IGltcG9ydCgnLi4vY29tcG9uZW50L01hcmtkb3duLm1qcycpO1xuICAgICAgICAgICAgICAgIG1lLm1hcmtkb3duQ29tcG9uZW50Q2xhc3MgPSBtb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLm1hcmtkb3duQ29tcG9uZW50ICYmICFtZS5tYXJrZG93bkNvbXBvbmVudC5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIG1lLm1hcmtkb3duQ29tcG9uZW50LnZhbHVlID0gc291cmNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlc3Ryb3ksIHNpbGVudCA9PiBtZXJnZSBjaGFuZ2VzIGludG8gb25lIHVwZGF0ZSBjeWNsZVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBbGwodHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBtZS5tYXJrZG93bkNvbXBvbmVudCA9IGNvbnRhaW5lci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICA6IG1lLm1hcmtkb3duQ29tcG9uZW50Q2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlICAgIDoge2hlaWdodDogJzEwMCUnLCBvdmVyZmxvdzogJ2F1dG8nfSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd1VybDogbWUud2luZG93VXJsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbWUubmVvRXhlY3V0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4vZXhlY3V0b3IvTmVvLm1qcycpO1xuICAgICAgICAgICAgICAgIG1lLm5lb0V4ZWN1dG9yID0gTmVvLmNyZWF0ZShtb2R1bGUuZGVmYXVsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLm5lb0V4ZWN1dG9yLmV4ZWN1dGUoe2NvZGU6IHNvdXJjZSwgY29udGFpbmVyfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQcmV2aWV3Q29udGFpbmVyKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5wcmV2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWUucHJldmlld0NvbnRhaW5lclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLmdldFJlZmVyZW5jZSgncHJldmlldycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5pdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEub2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5zb3VyY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIG9uQWN0aXZlSW5kZXhDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlzUHJldmlldyA9IGRhdGEudmFsdWUgPT09IDE7XG5cbiAgICAgICAgaWYgKGRhdGEuaXRlbS5yZWZlcmVuY2UgPT09ICdwcmV2aWV3Jykge1xuICAgICAgICAgICAgbWUuZG9SdW5Tb3VyY2UoKVxuICAgICAgICB9XG4gICAgICAgIC8vIE5hdmlnYXRpbmcgdG8gdGhlIHNvdXJjZSB2aWV3IHNob3VsZCBkZXN0cm95IHRoZSBhcHAsIGluIGNhc2UgdGhlIHByZXZpZXcgdmlldyBpcyBub3QgcG9wcGVkIG91dFxuICAgICAgICBlbHNlIGlmICghaXNQcmV2aWV3ICYmICFtZS5wcmV2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBtZS5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKS5yZW1vdmVBbGwoKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0UmVmZXJlbmNlKCdwb3BvdXQtd2luZG93LWJ1dHRvbicpLmhpZGRlbiA9ICFpc1ByZXZpZXdcbiAgICAgICAgbWUuZGlzYWJsZVJ1blNvdXJjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAge3RhYkNvbnRhaW5lcn0gPSBtZTtcblxuICAgICAgICBtZS5lZGl0b3JcblxuICAgICAgICBpZiAobWUuZW5hYmxlRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUuY29sbGFwc2VFeHBhbmQuYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhcyBmYS1leHBhbmQnLFxuICAgICAgICAgICAgICAgIHVpICAgICA6ICdnaG9zdCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGFkZCB0aGUgcG9wb3V0IHdpbmRvdyBidXR0b24gaW4gY2FzZSB3ZSBhcmUgdXNpbmcgc2hhcmVkIHdvcmtlcnNcbiAgICAgICAgaWYgKE5lby5jb25maWcudXNlU2hhcmVkV29ya2Vycykge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaGFuZGxlciAgOiBtZS5wb3BvdXRQcmV2aWV3LmJpbmQobWUpLFxuICAgICAgICAgICAgICAgIGhpZGRlbiAgIDogdGFiQ29udGFpbmVyLmFjdGl2ZUluZGV4ICE9PSAxLFxuICAgICAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhciBmYS13aW5kb3ctbWF4aW1pemUnLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogJ3BvcG91dC13aW5kb3ctYnV0dG9uJyxcbiAgICAgICAgICAgICAgICB1aSAgICAgICA6ICdnaG9zdCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5vbih7XG4gICAgICAgICAgICAgICAgY29ubmVjdCAgIDogbWUub25XaW5kb3dDb25uZWN0LFxuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uV2luZG93RGlzY29ubmVjdCxcbiAgICAgICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLnVuc2hpZnQoJy0+Jyk7XG5cbiAgICAgICAgLy8gd2Ugd2FudCB0byBhZGQgYSBub3JtYWwgKG5vbi1oZWFkZXIpIGJ1dHRvblxuICAgICAgICB0YWJDb250YWluZXIuZ2V0VGFiQmFyKCkuYWRkKGl0ZW1zKTtcblxuICAgICAgICB0YWJDb250YWluZXIuZ2V0VGFiQmFyKCkudXBkYXRlKCk7XG5cbiAgICAgICAgdGFiQ29udGFpbmVyLm9uKCdhY3RpdmVJbmRleENoYW5nZScsIG1lLm9uQWN0aXZlSW5kZXhDaGFuZ2UsIG1lKTtcblxuICAgICAgICAvLyBjaGFuZ2luZyB0aGUgYWN0aXZlVmlldyBpbml0aWFsbHkgd2lsbCBub3QgdHJpZ2dlciBvdXIgb25BY3RpdmVJbmRleENoYW5nZSgpIGxvZ2ljXG4gICAgICAgIG1lLmFjdGl2ZVZpZXcgPT09ICdwcmV2aWV3JyAmJiBtZS5kb1J1blNvdXJjZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS52YWx1ZVxuICAgICAqL1xuICAgIG9uRWRpdG9yQ2hhbmdlKHt2YWx1ZX0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBtZS5lZGl0b3JWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIG1lLmZpcmUoJ2VkaXRvckNoYW5nZScsIHt2YWx1ZX0pO1xuXG4gICAgICAgIG1lLmRvUnVuU291cmNlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIGFzeW5jIG9uV2luZG93Q29ubmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc2VhcmNoU3RyaW5nID0gYXdhaXQgTmVvLk1haW4uZ2V0QnlQYXRoKHtwYXRoOiAnbG9jYXRpb24uc2VhcmNoJywgd2luZG93SWQ6IGRhdGEud2luZG93SWR9KSxcbiAgICAgICAgICAgIHBhcmFtcyAgICAgICA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoU3RyaW5nKSxcbiAgICAgICAgICAgIGlkICAgICAgICAgICA9IHBhcmFtcy5nZXQoJ2lkJyk7XG5cbiAgICAgICAgaWYgKGlkID09PSBtZS5pZCkge1xuICAgICAgICAgICAgbWUuY29ubmVjdGVkV2luZG93SWQgPSBkYXRhLndpbmRvd0lkO1xuXG4gICAgICAgICAgICBsZXQgYXBwICAgICAgICAgICAgICA9IE5lby5hcHBzW2RhdGEud2luZG93SWRdLFxuICAgICAgICAgICAgICAgIG1haW5WaWV3ICAgICAgICAgPSBhcHAubWFpblZpZXcsXG4gICAgICAgICAgICAgICAgcHJldmlld0NvbnRhaW5lciA9IG1lLmdldFJlZmVyZW5jZSgncHJldmlldycpLFxuICAgICAgICAgICAgICAgIHt0YWJDb250YWluZXJ9ICAgPSBtZSxcbiAgICAgICAgICAgICAgICBwcmV2aWV3VmlldyAgICAgID0gcHJldmlld0NvbnRhaW5lci5yZW1vdmVBdCgwLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIG1lLnByZXZpZXdDb250YWluZXIgPSBtYWluVmlldztcbiAgICAgICAgICAgIG1haW5WaWV3LmFkZChwcmV2aWV3Vmlldyk7XG5cbiAgICAgICAgICAgIHRhYkNvbnRhaW5lci5hY3RpdmVJbmRleCA9IDA7IC8vIHN3aXRjaCB0byB0aGUgc291cmNlIHZpZXdcblxuICAgICAgICAgICAgdGFiQ29udGFpbmVyLmdldFRhYkF0SW5kZXgoMSkuZGlzYWJsZWQgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIGFzeW5jIG9uV2luZG93RGlzY29ubmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEud2luZG93SWQgPT09IG1lLmNvbm5lY3RlZFdpbmRvd0lkKSB7XG4gICAgICAgICAgICBsZXQgYXBwICAgICAgICAgICAgICA9IE5lby5hcHBzW2RhdGEud2luZG93SWRdLFxuICAgICAgICAgICAgICAgIG1haW5WaWV3ICAgICAgICAgPSBhcHAubWFpblZpZXcsXG4gICAgICAgICAgICAgICAgcHJldmlld0NvbnRhaW5lciA9IG1lLmdldFJlZmVyZW5jZSgncHJldmlldycpLFxuICAgICAgICAgICAgICAgIHt0YWJDb250YWluZXJ9ICAgPSBtZSxcbiAgICAgICAgICAgICAgICBwcmV2aWV3VmlldyAgICAgID0gbWFpblZpZXcucmVtb3ZlQXQoMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICBtZS5wcmV2aWV3Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZpZXdDb250YWluZXIuYWRkKHByZXZpZXdWaWV3KTtcblxuICAgICAgICAgICAgbWUuZGlzYWJsZVJ1blNvdXJjZSA9IHRydWU7IC8vIHdpbGwgZ2V0IHJlc2V0IGFmdGVyIHRoZSBuZXh0IGFjdGl2ZUluZGV4IGNoYW5nZSAoYXN5bmMpXG4gICAgICAgICAgICB0YWJDb250YWluZXIuYWN0aXZlSW5kZXggPSAxOyAgICAgICAgLy8gc3dpdGNoIHRvIHRoZSBzb3VyY2Ugdmlld1xuXG4gICAgICAgICAgICBtZS5nZXRSZWZlcmVuY2UoJ3BvcG91dC13aW5kb3ctYnV0dG9uJykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRhYkNvbnRhaW5lci5nZXRUYWJBdEluZGV4KDEpLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIG1lLmNvbm5lY3RlZFdpbmRvd0lkID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBwb3BvdXRQcmV2aWV3KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBkYXRhLmNvbXBvbmVudC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IG1lLmNyZWF0ZVBvcHVwV2luZG93KClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExpdmVQcmV2aWV3KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==