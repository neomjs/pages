"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_component_carousel_app_mjs"],{

/***/ "./examples/component/carousel/MainContainer.mjs":
/*!*******************************************************!*\
  !*** ./examples/component/carousel/MainContainer.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _src_component_Carousel_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/component/Carousel.mjs */ "./src/component/Carousel.mjs");
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_form_field_Range_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/field/Range.mjs */ "./src/form/field/Range.mjs");





/**
 * @class Neo.examples.component.carousel.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        className: 'Neo.examples.component.carousel.MainContainer',
        layout   : {ntype: 'hbox', align: 'stretch'}
    }

    createConfigurationComponents() {
        let me = this;

        return [{
            module   : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            checked  : me.exampleComponent.autoRun,
            labelText: 'autoRun',
            listeners: {change: me.onConfigChange.bind(me, 'autoRun')}
        }, {
            module   : _src_form_field_Range_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            labelText: 'height',
            listeners: {change: me.onConfigChange.bind(me, 'height')},
            maxValue : 800,
            minValue : 200,
            stepSize : 1,
            value    : me.exampleComponent.height
        }, {
            module   : _src_form_field_Range_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            labelText: 'width',
            listeners: {change: me.onConfigChange.bind(me, 'width')},
            maxValue : 800,
            minValue : 200,
            stepSize : 1,
            value    : me.exampleComponent.width
        }];
    }

    createExampleComponent() {
        return Neo.create(_src_component_Carousel_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], {
            height: 500,
            width : 500,
            // will automatically change to the next extry every 5500 ms
            // if not set or 0, this will show arrows to navigate
            // cannot be changed after created
            autoRun: 5500,
            store  : {
                model: {
                    fields: [
                        // @formatter:off
                        {name: 'quote',      type: 'String'},
                        {name: 'publisher',  type: 'String'},
                        {name: 'date',       type: 'String'}
                        // @formatter:on
                    ]
                },
                data : [{
                    quote    : 'We love the German inspired dishes on the menu',
                    publisher: 'Trip Advisor',
                    date     : 'Dezember 2020'
                }, {
                    quote    : 'Everything about this place was excellent, from start to finish',
                    publisher: 'Trip Advisor',
                    date     : 'Dezember 2021'
                }, {
                    quote    : 'We had three courses and everything was great',
                    publisher: 'Trip Advisor',
                    date     : 'September 2020'
                }, {
                    quote    : 'Excellent Food, Wine and Service',
                    publisher: 'Best Food',
                    date     : 'August 2020'
                }]
            },
            // custom item cls
            itemCls: 'example-carousel-item',
            // each item will be created like the itemTpl structure
            itemTpl: data => [{
                cls : 'example-quote',
                html: data.quote
            }, {
                cls : 'example-details',
                html: `${data.publisher} - ${data.date}`
            }]
        });
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./examples/component/carousel/app.mjs":
/*!*********************************************!*\
  !*** ./examples/component/carousel/app.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/carousel/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.carousel'
});


/***/ }),

/***/ "./src/component/Carousel.mjs":
/*!************************************!*\
  !*** ./src/component/Carousel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _manager_Task_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/Task.mjs */ "./src/manager/Task.mjs");





/**
 * @class Neo.component.Carousel
 * @extends Neo.component.Base
 */
class Carousel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Defines the currently visible item in the middle
     * This gets updated everytime a button is clicked to reflect the current order
     * @member {Number} itemIndex=1
     */
    itemIndex = 1
    /**
     * Defines the order of the item in the carousel
     * This gets updated everytime a button is clicked to reflect the current order
     * @member {String[]} positionArray
     */
    positionArray = ['neo-carousel--translate-x-full', 'neo-carousel-translate-x-0', 'neo-carousel-translate-x-full']
    /**
     * keeps track of the data for the onClickEvent
     * @member {Object} itemData={}
     */
    itemData = {}

    static config = {
        /**
         * @member {String} className='Neo.component.Carousel'
         * @protected
         */
        className: 'Neo.component.Carousel',
        /**
         * @member {String} ntype='carousel'
         * @protected
         */
        ntype: 'carousel',
        /**
         * autoRun allows to run through the all items timebased
         * 0 means it is turned off. Other values are the timer in ms,
         * which will hide the arrows.
         *
         * @member {int} autoRun=0
         */
        autoRun_: 0,
        /**
         * @member {String[]} baseCls=['neo-carousel']
         */
        baseCls: ['neo-carousel'],
        /**
         * Custom cls added to each item
         * This is only a single string
         *
         * @member {String|null} itemCls=null
         */
        itemCls: null,
        /**
         * Template for each item
         * The format is the same as for literals,
         * but it is a string instead of surrounding "`"
         * @member {String|null} tpl=null
         * @example
         *      record = {foo: ... , bar: ...}
         *      data => [{
         *          cls: 'css-foo-class',
         *          html: data.foo
         *      },
         *      {
         *          html: data.baa
         *      }]"
         */
        itemTpl_: null,
        /**
         * Store to be used.
         *
         * @member {Neo.data.Store|null} store=null
         */
        store_: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {cls: ['neo-carousel'], cn: [
                {cls: ['neo-carousel-btn-bar'], cn: [
                    {tag: 'a', 'data-carouselaction': 'back',    cls: ['neo-carousel-btn', 'fa', 'fa-chevron-left']},
                    {tag: 'a', 'data-carouselaction': 'forward', cls: ['neo-carousel-btn', 'fa', 'fa-chevron-right']}
                ]},
                {cls: ['neo-carousel-inner'], cn: []}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {click: me.onCarouselBtnClick, delegate: '.neo-carousel-btn',  scope: me},
            {click: me.onClick,            delegate: '.neo-carousel-item', scope: me}
        ])
    }

    /**
     * Triggered after autoRun config got changed
     * @param {Boolean|Number} value
     * @param {Boolean|Number} oldValue
     * @protected
     */
    afterSetAutoRun(value, oldValue) {
        if (value) {
            let me = this;

            _manager_Task_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].start({
                id      : me.id,
                interval: value,

                run() {
                    me.onCarouselBtnClick('forward');
                }
            });

            me.vdom.cn[0].cn[0].removeDom = true;
            me.update()
        }
    }

    /**
     * Triggered after the store config got changed
     * @param {Neo.data.Store|Object|null} value
     * @param {Neo.data.Store|null} oldValue
     * @protected
     */
    afterSetStore(value, oldValue) {
        let me = this;

        value?.on({
            load : 'onStoreLoad',
            scope: me
        })

        value?.getCount() > 0 && me.onStoreLoad()
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Neo.data.Store|Object|null} value
     * @param {Neo.data.Store|null} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        oldValue?.destroy();
        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Create the initial three items and add them to the vdom
     */
    createBaseItems() {
        let me       = this,
            itemRoot = me.#getItemRoot(),
            items    = [],
            i        = 0;

        for (i; i < 3; i++) {
            items.push(me.createItem(i, i))
        }

        itemRoot.cn = items;
        me.update()
    }

    /**
     * Everytime we rotate we create items
     * @param {Number} recordIndex   - index inside store
     * @param {Number} positionIndex - based on positionArray
     * @returns {Object}
     */
    createItem(recordIndex, positionIndex) {
        let me                              = this,
            {itemCls, positionArray, store} = me,
            data                            = store.getAt(recordIndex),
            cn                              = me.itemTpl(data),

        newItem = {
            cls: [positionArray[positionIndex], 'neo-carousel-item'],
            cn,
            recordIndex
        };

        itemCls && newItem.cls.push(itemCls);

        me.itemData[positionIndex] = data;

        return newItem
    }

    /**
     * Rotate the three items and fill in a new record
     * @param {Object} event
     * @param {Object} event.target - clicked button
     */
    onCarouselBtnClick(event) {
        let me                     = this,
            action                 = Neo.isString(event) ? event : event.target.data.carouselaction,
            {positionArray, store} = me,
            countItems             = store.getCount(),
            index                  = me.itemIndex,
            root                   = me.#getItemRoot(),
            newRecordIndex, positionCls, recordIndex, vdomCls;

        if (action === 'forward') {
            vdomCls        = 'neo-carousel-translate-x-full';
            index          = index + 2
            newRecordIndex = index % countItems;

            me.itemIndex = newRecordIndex - 1;
            positionArray = me.#arrayRotate(positionArray, -1)
        } else {
            vdomCls        = 'neo-carousel--translate-x-full';
            index          = index - 2;
            newRecordIndex = index < 0 ? (countItems + index) : index;

            me.itemIndex = newRecordIndex + 1;
            positionArray = me.#arrayRotate(positionArray, 1)
        }

        me.positionArray = positionArray;

        root.cn = root.cn.map(function(cn, mappingIndex) {
            positionCls = positionArray[mappingIndex];
            recordIndex = cn.recordIndex;

            cn.cls.shift();
            cn.cls.unshift(positionCls);

            // Update new Record
            if (positionCls === vdomCls) {
                recordIndex = newRecordIndex;
                cn          = me.createItem(recordIndex, mappingIndex)
            }

            return cn
        })

        me.update()
    }

    /**
     * Check if the user clicked an item or the container
     * @param data
     */
    onClick(data) {
        let me = this,
            item;

        if (data.path[0].id === me.id) {
            me.onContainerClick(data)
        } else {
            for (item of data.path) {
                if (item.cls.includes(me.itemCls)) {
                    me.onItemClick(item, data);
                    break
                }
            }
        }
    }

    /**
     * If the user wants to listen for the container click
     * @param {Object} data
     */
    onContainerClick(data){}

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me = this;

        /**
         * The itemClick event fires when a click occurs on a list item
         * @event itemClick
         * @param {String} id the record matching the list item
         * @returns {Object}
         */
        me.fire('itemClick', me.itemData[me.itemIndex])
    }

    /**
     * As soon as the store is loaded we want to
     * - create the three items
     * - fill the first three records
     */
    onStoreLoad() {
        this.createBaseItems()
    }

    /**
     * HELPERS
     */
    #getItemRoot() {
        return this.vdom.cn[0].cn[1]
    }

    #arrayRotate(arr, n) {
        return n ? [...arr.slice(n, arr.length), ...arr.slice(0, n)] : arr
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Carousel));


/***/ }),

/***/ "./src/form/field/Range.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Range.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Number_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Number.mjs */ "./src/form/field/Number.mjs");


/**
 * @class Neo.form.field.Range
 * @extends Neo.form.field.Number
 */
class Range extends _Number_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Removing the debounce for range fields
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {}

    static config = {
        /**
         * @member {String} className='Neo.form.field.Range'
         * @protected
         */
        className: 'Neo.form.field.Range',
        /**
         * @member {String} ntype='rangefield'
         * @protected
         */
        ntype: 'rangefield',
        /**
         * @member {String[]} baseCls=['neo-rangefield','neo-textfield']
         */
        baseCls: ['neo-rangefield', 'neo-textfield'],
        /**
         * True shows a clear trigger in case the field has a non empty value.
         * @member {Boolean} clearable=false
         */
        clearable: false,
        /**
         * Value for the inputType_ textfield config
         * @member {String} inputType='range'
         */
        inputType: 'range',
        /**
         * If true, shows the result of the slider in the label
         * @member {Boolean} showResultInLabel=false
         */
        showResultInLabel: false,
        /**
         * @member {Array} tickmarks_=[]
         */
        tickmarks_: [],
        /**
         * @member {Boolean} useInputEvent=false
         */
        useInputEvent: false,
        /**
         * Disables the field.Number buttons
         * @member {Boolean} useInputEvent=false
         */
        useSpinButtons: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            inputEl = me.vdom.cn[2];

        if (me.useInputEvent) {
            me.addDomListeners({
                input: {
                    fn   : me.onInputValueChange,
                    id   : me.vdom.cn[2].id,
                    scope: me
                }
            });
        }

        inputEl.cls = ['neo-rangefield-input']; // replace neo-textfield-input

        me.addValueToLabel()
    }

    /**
     * Triggered after the tickmarks config got changed
     * @param {Array} value
     * @param {Array} oldValue
     * @protected
     */
    afterSetTickmarks(value, oldValue) {
        // todo
    }

    /**
     * Triggered after the value config got changed
     * @param {Number} value
     * @param {Number} oldValue
     */
    afterSetValue(value, oldValue) {
        this.addValueToLabel();
        super.afterSetValue(value, oldValue)
    }

    /**
     * Update label with value
     */
    addValueToLabel() {
        let me = this;

        if (me.showResultInLabel) {
            me.getLabelEl().innerHTML = `[${me.value}] ` + me.labelText
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Range));


/***/ }),

/***/ "./src/manager/Task.mjs":
/*!******************************!*\
  !*** ./src/manager/Task.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.Task
 * @extends Neo.manager.Base
 * @singleton
 *
 * @example
 *     import TaskManager from '../../../node_modules/neo.mjs/src/manager/Task.mjs';
 *
 *     task = {
 *         args: [clockDom],           // arguments passed into the run fn
 *         addCountToArgs: true,       // adds the count to the arguments
 *         fireOnStart: false          // run before the first interval
 *         id: 'clockcounter',         // id for the task or autocreated
 *         interval: 1000,             // in ms
 *         onError: function(){},      // runs in case an error occurred
 *         repeat: 10,                 // stopAfterTenTimes
 *         run: function(clock) {      // function to run
 *             clock.setHtml(new Date());
 *         },
 *         scope: this                 // scope of the function
 *     };
 *
 *     TaskManager.start(task); // or taskId if exists
 *     TaskManager.stop('clockcounter', remove); // false to not remove it from the TaskManager
 *     TaskManager.stopAll(remove);
 *
 *     TaskManager.createTask(task);
 *     TaskManager.remove(taskId);
 *
 *     TaskManager.run(taskId);
 *     TaskManager.get(taskId).repeat = 20;
 */
class Task extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Task'
         * @protected
         */
        className: 'Neo.manager.Task',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Adds a task to collection.
     * Typically used via `start(task)`
     * @param {Object} task
     * @returns {Object}
     */
    createTask(task) {
        let me = this;

        if (!task.id) {
            task.id = Neo.core.IdGenerator.getId('task')
        }

        task.scope          && task.run.bind(task.scope);
        task.addCountToArgs && task.args.push(0);

        task = {
            args      : [],
            isRunning : false,
            onError   : Neo.emptyFn,
            runCount  : 0,
            runner    : null,
            runOnStart: false,
            ...task
        };

        me.register(task);

        return task
    }

    /**
     * Removes a task from collection.
     * @param {String} taskId
     */
    removeTask(taskId) {
        this.unregister(taskId)
    }

    /**
     * Runs a task from collection.
     * @param {String} taskId
     */
    run(taskId) {
        let me   = this,
            task = me.get(taskId);

        if (task.isRunning) {
            Neo.logError('[Neo.util.TaskManager] Task is already running');
            return task
        }

        try {
            let fn = function(task) {
                task.runCount++;

                if (task.addCountToArgs) {
                    task.args[task.args.length - 1] = task.runCount
                }

                if (task.repeat && task.runCount === task.repeat) {
                    me.stop(task.id)
                }

                task.run(...task.args)
            };

            task.isRunning = true;
            task.runner    = setInterval(fn, task.interval, task)
        } catch (taskError) {
            Neo.logError('[Neo.util.TaskManager] Error while running task ' + task.id);
            task.onError(taskError);
            task.isRunning = false
        }
    }

    /**
     * Adds a task and runs it.
     * @param {Object|String} task or taskId
     * @returns {Object}
     */
    start(task) {
        let me = this;

        if (Neo.isString(task)) {
            task = me.get(task);
            !task && Neo.logError('[Neo.util.TaskManager] You passed a taskId which does not exits')
        } else if (!task.id || !me.get(task.id)) {
            task = me.createTask(task)
        }

        if (task.isRunning) {
            Neo.logError('[Neo.util.TaskManager] Task is already running');
            return task
        }

        if (task.runOnStart) {
            task.runCount++;
            task.run(...task.args)
        }

        me.run(task.id);

        return task
    }

    /**
     * Stops a task and resets configs.
     * If remove is true it will remove the task from the collection
     * @param {String} taskId
     * @param {Boolean} remove
     */
    stop(taskId, remove) {
        let task = this.get(taskId);

        task.isRunning && clearInterval(task.runner);

        if (remove) {
            this.removeTask(task)
        } else {
            task.isRunning = false;
            task.runCount  = 0;
            task.runner    = null;

            if (task.addCountToArgs) {
                task.args[task.args.length - 1] = 0
            }
        }
    }

    /**
     * Stops all running tasks from collection.
     * If remove is true, it will remove all tasks from Manager
     * @param {Boolean} remove
     */
    stopAll(remove) {
        Object.keys(this.map).forEach(key => {
            this.stop(key, remove)
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Task));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9jYXJvdXNlbF9hcHBfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlFO0FBQ0Q7QUFDSjtBQUNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBcUI7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG9FQUFRO0FBQy9CO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNULHVCQUF1QixpRUFBVTtBQUNqQztBQUNBLHdCQUF3Qiw2Q0FBNkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLGlFQUFVO0FBQ2pDO0FBQ0Esd0JBQXdCLDRDQUE0QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDBCQUEwQixtRUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQseUJBQXlCLG1DQUFtQztBQUM1RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EseUJBQXlCLGdCQUFnQixJQUFJLFVBQVU7QUFDdkQsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUZHOztBQUV6QztBQUNQLGNBQWMsMERBQWE7QUFDM0I7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7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VjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvY2Fyb3VzZWwvTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NvbXBvbmVudC9jYXJvdXNlbC9hcHAubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L0Nhcm91c2VsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvUmFuZ2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9UYXNrLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hlY2tCb3ggICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NoZWNrQm94Lm1qcyc7XG5pbXBvcnQgQ2Fyb3VzZWwgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvQ2Fyb3VzZWwubWpzJztcbmltcG9ydCBDb25maWd1cmF0aW9uVmlld3BvcnQgZnJvbSAnLi4vLi4vQ29uZmlndXJhdGlvblZpZXdwb3J0Lm1qcyc7XG5pbXBvcnQgUmFuZ2VGaWVsZCAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL1JhbmdlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy5jb21wb25lbnQuY2Fyb3VzZWwuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmV4YW1wbGVzLkNvbmZpZ3VyYXRpb25WaWV3cG9ydFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgQ29uZmlndXJhdGlvblZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZXhhbXBsZXMuY29tcG9uZW50LmNhcm91c2VsLk1haW5Db250YWluZXInLFxuICAgICAgICBsYXlvdXQgICA6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgIH1cblxuICAgIGNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnRzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDaGVja0JveCxcbiAgICAgICAgICAgIGNoZWNrZWQgIDogbWUuZXhhbXBsZUNvbXBvbmVudC5hdXRvUnVuLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnYXV0b1J1bicsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdhdXRvUnVuJyl9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogUmFuZ2VGaWVsZCxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ2hlaWdodCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdoZWlnaHQnKX0sXG4gICAgICAgICAgICBtYXhWYWx1ZSA6IDgwMCxcbiAgICAgICAgICAgIG1pblZhbHVlIDogMjAwLFxuICAgICAgICAgICAgc3RlcFNpemUgOiAxLFxuICAgICAgICAgICAgdmFsdWUgICAgOiBtZS5leGFtcGxlQ29tcG9uZW50LmhlaWdodFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFJhbmdlRmllbGQsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICd3aWR0aCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICd3aWR0aCcpfSxcbiAgICAgICAgICAgIG1heFZhbHVlIDogODAwLFxuICAgICAgICAgICAgbWluVmFsdWUgOiAyMDAsXG4gICAgICAgICAgICBzdGVwU2l6ZSA6IDEsXG4gICAgICAgICAgICB2YWx1ZSAgICA6IG1lLmV4YW1wbGVDb21wb25lbnQud2lkdGhcbiAgICAgICAgfV07XG4gICAgfVxuXG4gICAgY3JlYXRlRXhhbXBsZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIE5lby5jcmVhdGUoQ2Fyb3VzZWwsIHtcbiAgICAgICAgICAgIGhlaWdodDogNTAwLFxuICAgICAgICAgICAgd2lkdGggOiA1MDAsXG4gICAgICAgICAgICAvLyB3aWxsIGF1dG9tYXRpY2FsbHkgY2hhbmdlIHRvIHRoZSBuZXh0IGV4dHJ5IGV2ZXJ5IDU1MDAgbXNcbiAgICAgICAgICAgIC8vIGlmIG5vdCBzZXQgb3IgMCwgdGhpcyB3aWxsIHNob3cgYXJyb3dzIHRvIG5hdmlnYXRlXG4gICAgICAgICAgICAvLyBjYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGVkXG4gICAgICAgICAgICBhdXRvUnVuOiA1NTAwLFxuICAgICAgICAgICAgc3RvcmUgIDoge1xuICAgICAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQGZvcm1hdHRlcjpvZmZcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncXVvdGUnLCAgICAgIHR5cGU6ICdTdHJpbmcnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncHVibGlzaGVyJywgIHR5cGU6ICdTdHJpbmcnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnZGF0ZScsICAgICAgIHR5cGU6ICdTdHJpbmcnfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQGZvcm1hdHRlcjpvblxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhIDogW3tcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgICAgOiAnV2UgbG92ZSB0aGUgR2VybWFuIGluc3BpcmVkIGRpc2hlcyBvbiB0aGUgbWVudScsXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlcjogJ1RyaXAgQWR2aXNvcicsXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgICAgIDogJ0RlemVtYmVyIDIwMjAnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSAgICA6ICdFdmVyeXRoaW5nIGFib3V0IHRoaXMgcGxhY2Ugd2FzIGV4Y2VsbGVudCwgZnJvbSBzdGFydCB0byBmaW5pc2gnLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXI6ICdUcmlwIEFkdmlzb3InLFxuICAgICAgICAgICAgICAgICAgICBkYXRlICAgICA6ICdEZXplbWJlciAyMDIxJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgICAgOiAnV2UgaGFkIHRocmVlIGNvdXJzZXMgYW5kIGV2ZXJ5dGhpbmcgd2FzIGdyZWF0JyxcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVyOiAnVHJpcCBBZHZpc29yJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSAgICAgOiAnU2VwdGVtYmVyIDIwMjAnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSAgICA6ICdFeGNlbGxlbnQgRm9vZCwgV2luZSBhbmQgU2VydmljZScsXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlcjogJ0Jlc3QgRm9vZCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgICAgIDogJ0F1Z3VzdCAyMDIwJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gY3VzdG9tIGl0ZW0gY2xzXG4gICAgICAgICAgICBpdGVtQ2xzOiAnZXhhbXBsZS1jYXJvdXNlbC1pdGVtJyxcbiAgICAgICAgICAgIC8vIGVhY2ggaXRlbSB3aWxsIGJlIGNyZWF0ZWQgbGlrZSB0aGUgaXRlbVRwbCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGl0ZW1UcGw6IGRhdGEgPT4gW3tcbiAgICAgICAgICAgICAgICBjbHMgOiAnZXhhbXBsZS1xdW90ZScsXG4gICAgICAgICAgICAgICAgaHRtbDogZGF0YS5xdW90ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNscyA6ICdleGFtcGxlLWRldGFpbHMnLFxuICAgICAgICAgICAgICAgIGh0bWw6IGAke2RhdGEucHVibGlzaGVyfSAtICR7ZGF0YS5kYXRlfWBcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL01haW5Db250YWluZXIubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogTWFpbkNvbnRhaW5lcixcbiAgICBuYW1lICAgIDogJ05lby5leGFtcGxlcy5jb21wb25lbnQuY2Fyb3VzZWwnXG59KTtcbiIsImltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBTdG9yZSAgICAgICAgICAgZnJvbSAnLi4vZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFRhc2tNYW5hZ2VyICAgICBmcm9tICcuLi9tYW5hZ2VyL1Rhc2subWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5DYXJvdXNlbFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIENhcm91c2VsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBpdGVtIGluIHRoZSBtaWRkbGVcbiAgICAgKiBUaGlzIGdldHMgdXBkYXRlZCBldmVyeXRpbWUgYSBidXR0b24gaXMgY2xpY2tlZCB0byByZWZsZWN0IHRoZSBjdXJyZW50IG9yZGVyXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBpdGVtSW5kZXg9MVxuICAgICAqL1xuICAgIGl0ZW1JbmRleCA9IDFcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBvcmRlciBvZiB0aGUgaXRlbSBpbiB0aGUgY2Fyb3VzZWxcbiAgICAgKiBUaGlzIGdldHMgdXBkYXRlZCBldmVyeXRpbWUgYSBidXR0b24gaXMgY2xpY2tlZCB0byByZWZsZWN0IHRoZSBjdXJyZW50IG9yZGVyXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHBvc2l0aW9uQXJyYXlcbiAgICAgKi9cbiAgICBwb3NpdGlvbkFycmF5ID0gWyduZW8tY2Fyb3VzZWwtLXRyYW5zbGF0ZS14LWZ1bGwnLCAnbmVvLWNhcm91c2VsLXRyYW5zbGF0ZS14LTAnLCAnbmVvLWNhcm91c2VsLXRyYW5zbGF0ZS14LWZ1bGwnXVxuICAgIC8qKlxuICAgICAqIGtlZXBzIHRyYWNrIG9mIHRoZSBkYXRhIGZvciB0aGUgb25DbGlja0V2ZW50XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGF0YT17fVxuICAgICAqL1xuICAgIGl0ZW1EYXRhID0ge31cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5DYXJvdXNlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5DYXJvdXNlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjYXJvdXNlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjYXJvdXNlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhdXRvUnVuIGFsbG93cyB0byBydW4gdGhyb3VnaCB0aGUgYWxsIGl0ZW1zIHRpbWViYXNlZFxuICAgICAgICAgKiAwIG1lYW5zIGl0IGlzIHR1cm5lZCBvZmYuIE90aGVyIHZhbHVlcyBhcmUgdGhlIHRpbWVyIGluIG1zLFxuICAgICAgICAgKiB3aGljaCB3aWxsIGhpZGUgdGhlIGFycm93cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7aW50fSBhdXRvUnVuPTBcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9SdW5fOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2Fyb3VzZWwnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2Fyb3VzZWwnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBjbHMgYWRkZWQgdG8gZWFjaCBpdGVtXG4gICAgICAgICAqIFRoaXMgaXMgb25seSBhIHNpbmdsZSBzdHJpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGl0ZW1DbHM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUNsczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbXBsYXRlIGZvciBlYWNoIGl0ZW1cbiAgICAgICAgICogVGhlIGZvcm1hdCBpcyB0aGUgc2FtZSBhcyBmb3IgbGl0ZXJhbHMsXG4gICAgICAgICAqIGJ1dCBpdCBpcyBhIHN0cmluZyBpbnN0ZWFkIG9mIHN1cnJvdW5kaW5nIFwiYFwiXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0cGw9bnVsbFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgIHJlY29yZCA9IHtmb286IC4uLiAsIGJhcjogLi4ufVxuICAgICAgICAgKiAgICAgIGRhdGEgPT4gW3tcbiAgICAgICAgICogICAgICAgICAgY2xzOiAnY3NzLWZvby1jbGFzcycsXG4gICAgICAgICAqICAgICAgICAgIGh0bWw6IGRhdGEuZm9vXG4gICAgICAgICAqICAgICAgfSxcbiAgICAgICAgICogICAgICB7XG4gICAgICAgICAqICAgICAgICAgIGh0bWw6IGRhdGEuYmFhXG4gICAgICAgICAqICAgICAgfV1cIlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVRwbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZSB0byBiZSB1c2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBzdG9yZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1jYXJvdXNlbCddLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNhcm91c2VsLWJ0bi1iYXInXSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge3RhZzogJ2EnLCAnZGF0YS1jYXJvdXNlbGFjdGlvbic6ICdiYWNrJywgICAgY2xzOiBbJ25lby1jYXJvdXNlbC1idG4nLCAnZmEnLCAnZmEtY2hldnJvbi1sZWZ0J119LFxuICAgICAgICAgICAgICAgICAgICB7dGFnOiAnYScsICdkYXRhLWNhcm91c2VsYWN0aW9uJzogJ2ZvcndhcmQnLCBjbHM6IFsnbmVvLWNhcm91c2VsLWJ0bicsICdmYScsICdmYS1jaGV2cm9uLXJpZ2h0J119XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tY2Fyb3VzZWwtaW5uZXInXSwgY246IFtdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7Y2xpY2s6IG1lLm9uQ2Fyb3VzZWxCdG5DbGljaywgZGVsZWdhdGU6ICcubmVvLWNhcm91c2VsLWJ0bicsICBzY29wZTogbWV9LFxuICAgICAgICAgICAge2NsaWNrOiBtZS5vbkNsaWNrLCAgICAgICAgICAgIGRlbGVnYXRlOiAnLm5lby1jYXJvdXNlbC1pdGVtJywgc2NvcGU6IG1lfVxuICAgICAgICBdKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciBhdXRvUnVuIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBdXRvUnVuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIFRhc2tNYW5hZ2VyLnN0YXJ0KHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IHZhbHVlLFxuXG4gICAgICAgICAgICAgICAgcnVuKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vbkNhcm91c2VsQnRuQ2xpY2soJ2ZvcndhcmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUudmRvbS5jblswXS5jblswXS5yZW1vdmVEb20gPSB0cnVlO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZXxPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgdmFsdWU/Lm9uKHtcbiAgICAgICAgICAgIGxvYWQgOiAnb25TdG9yZUxvYWQnLFxuICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgIH0pXG5cbiAgICAgICAgdmFsdWU/LmdldENvdW50KCkgPiAwICYmIG1lLm9uU3RvcmVMb2FkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV8T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFN0b3JlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgaW5pdGlhbCB0aHJlZSBpdGVtcyBhbmQgYWRkIHRoZW0gdG8gdGhlIHZkb21cbiAgICAgKi9cbiAgICBjcmVhdGVCYXNlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtUm9vdCA9IG1lLiNnZXRJdGVtUm9vdCgpLFxuICAgICAgICAgICAgaXRlbXMgICAgPSBbXSxcbiAgICAgICAgICAgIGkgICAgICAgID0gMDtcblxuICAgICAgICBmb3IgKGk7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2gobWUuY3JlYXRlSXRlbShpLCBpKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1Sb290LmNuID0gaXRlbXM7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlcnl0aW1lIHdlIHJvdGF0ZSB3ZSBjcmVhdGUgaXRlbXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVjb3JkSW5kZXggICAtIGluZGV4IGluc2lkZSBzdG9yZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbkluZGV4IC0gYmFzZWQgb24gcG9zaXRpb25BcnJheVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlSXRlbShyZWNvcmRJbmRleCwgcG9zaXRpb25JbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aXRlbUNscywgcG9zaXRpb25BcnJheSwgc3RvcmV9ID0gbWUsXG4gICAgICAgICAgICBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gc3RvcmUuZ2V0QXQocmVjb3JkSW5kZXgpLFxuICAgICAgICAgICAgY24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IG1lLml0ZW1UcGwoZGF0YSksXG5cbiAgICAgICAgbmV3SXRlbSA9IHtcbiAgICAgICAgICAgIGNsczogW3Bvc2l0aW9uQXJyYXlbcG9zaXRpb25JbmRleF0sICduZW8tY2Fyb3VzZWwtaXRlbSddLFxuICAgICAgICAgICAgY24sXG4gICAgICAgICAgICByZWNvcmRJbmRleFxuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1DbHMgJiYgbmV3SXRlbS5jbHMucHVzaChpdGVtQ2xzKTtcblxuICAgICAgICBtZS5pdGVtRGF0YVtwb3NpdGlvbkluZGV4XSA9IGRhdGE7XG5cbiAgICAgICAgcmV0dXJuIG5ld0l0ZW1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgdGhlIHRocmVlIGl0ZW1zIGFuZCBmaWxsIGluIGEgbmV3IHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQgLSBjbGlja2VkIGJ1dHRvblxuICAgICAqL1xuICAgIG9uQ2Fyb3VzZWxCdG5DbGljayhldmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhY3Rpb24gICAgICAgICAgICAgICAgID0gTmVvLmlzU3RyaW5nKGV2ZW50KSA/IGV2ZW50IDogZXZlbnQudGFyZ2V0LmRhdGEuY2Fyb3VzZWxhY3Rpb24sXG4gICAgICAgICAgICB7cG9zaXRpb25BcnJheSwgc3RvcmV9ID0gbWUsXG4gICAgICAgICAgICBjb3VudEl0ZW1zICAgICAgICAgICAgID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGluZGV4ICAgICAgICAgICAgICAgICAgPSBtZS5pdGVtSW5kZXgsXG4gICAgICAgICAgICByb290ICAgICAgICAgICAgICAgICAgID0gbWUuI2dldEl0ZW1Sb290KCksXG4gICAgICAgICAgICBuZXdSZWNvcmRJbmRleCwgcG9zaXRpb25DbHMsIHJlY29yZEluZGV4LCB2ZG9tQ2xzO1xuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgdmRvbUNscyAgICAgICAgPSAnbmVvLWNhcm91c2VsLXRyYW5zbGF0ZS14LWZ1bGwnO1xuICAgICAgICAgICAgaW5kZXggICAgICAgICAgPSBpbmRleCArIDJcbiAgICAgICAgICAgIG5ld1JlY29yZEluZGV4ID0gaW5kZXggJSBjb3VudEl0ZW1zO1xuXG4gICAgICAgICAgICBtZS5pdGVtSW5kZXggPSBuZXdSZWNvcmRJbmRleCAtIDE7XG4gICAgICAgICAgICBwb3NpdGlvbkFycmF5ID0gbWUuI2FycmF5Um90YXRlKHBvc2l0aW9uQXJyYXksIC0xKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmRvbUNscyAgICAgICAgPSAnbmVvLWNhcm91c2VsLS10cmFuc2xhdGUteC1mdWxsJztcbiAgICAgICAgICAgIGluZGV4ICAgICAgICAgID0gaW5kZXggLSAyO1xuICAgICAgICAgICAgbmV3UmVjb3JkSW5kZXggPSBpbmRleCA8IDAgPyAoY291bnRJdGVtcyArIGluZGV4KSA6IGluZGV4O1xuXG4gICAgICAgICAgICBtZS5pdGVtSW5kZXggPSBuZXdSZWNvcmRJbmRleCArIDE7XG4gICAgICAgICAgICBwb3NpdGlvbkFycmF5ID0gbWUuI2FycmF5Um90YXRlKHBvc2l0aW9uQXJyYXksIDEpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5wb3NpdGlvbkFycmF5ID0gcG9zaXRpb25BcnJheTtcblxuICAgICAgICByb290LmNuID0gcm9vdC5jbi5tYXAoZnVuY3Rpb24oY24sIG1hcHBpbmdJbmRleCkge1xuICAgICAgICAgICAgcG9zaXRpb25DbHMgPSBwb3NpdGlvbkFycmF5W21hcHBpbmdJbmRleF07XG4gICAgICAgICAgICByZWNvcmRJbmRleCA9IGNuLnJlY29yZEluZGV4O1xuXG4gICAgICAgICAgICBjbi5jbHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNuLmNscy51bnNoaWZ0KHBvc2l0aW9uQ2xzKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIG5ldyBSZWNvcmRcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkNscyA9PT0gdmRvbUNscykge1xuICAgICAgICAgICAgICAgIHJlY29yZEluZGV4ID0gbmV3UmVjb3JkSW5kZXg7XG4gICAgICAgICAgICAgICAgY24gICAgICAgICAgPSBtZS5jcmVhdGVJdGVtKHJlY29yZEluZGV4LCBtYXBwaW5nSW5kZXgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjblxuICAgICAgICB9KVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHVzZXIgY2xpY2tlZCBhbiBpdGVtIG9yIHRoZSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBpZiAoZGF0YS5wYXRoWzBdLmlkID09PSBtZS5pZCkge1xuICAgICAgICAgICAgbWUub25Db250YWluZXJDbGljayhkYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpdGVtIG9mIGRhdGEucGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNscy5pbmNsdWRlcyhtZS5pdGVtQ2xzKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vbkl0ZW1DbGljayhpdGVtLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXNlciB3YW50cyB0byBsaXN0ZW4gZm9yIHRoZSBjb250YWluZXIgY2xpY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29udGFpbmVyQ2xpY2soZGF0YSl7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGl0ZW1DbGljayBldmVudCBmaXJlcyB3aGVuIGEgY2xpY2sgb2NjdXJzIG9uIGEgbGlzdCBpdGVtXG4gICAgICAgICAqIEBldmVudCBpdGVtQ2xpY2tcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSByZWNvcmQgbWF0Y2hpbmcgdGhlIGxpc3QgaXRlbVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbWUuZmlyZSgnaXRlbUNsaWNrJywgbWUuaXRlbURhdGFbbWUuaXRlbUluZGV4XSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcyBzb29uIGFzIHRoZSBzdG9yZSBpcyBsb2FkZWQgd2Ugd2FudCB0b1xuICAgICAqIC0gY3JlYXRlIHRoZSB0aHJlZSBpdGVtc1xuICAgICAqIC0gZmlsbCB0aGUgZmlyc3QgdGhyZWUgcmVjb3Jkc1xuICAgICAqL1xuICAgIG9uU3RvcmVMb2FkKCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUJhc2VJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSEVMUEVSU1xuICAgICAqL1xuICAgICNnZXRJdGVtUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXS5jblsxXVxuICAgIH1cblxuICAgICNhcnJheVJvdGF0ZShhcnIsIG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPyBbLi4uYXJyLnNsaWNlKG4sIGFyci5sZW5ndGgpLCAuLi5hcnIuc2xpY2UoMCwgbildIDogYXJyXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDYXJvdXNlbCk7XG4iLCJpbXBvcnQgTnVtYmVyIGZyb20gJy4vTnVtYmVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLlJhbmdlXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5OdW1iZXJcbiAqL1xuY2xhc3MgUmFuZ2UgZXh0ZW5kcyBOdW1iZXIge1xuICAgIC8qKlxuICAgICAqIFJlbW92aW5nIHRoZSBkZWJvdW5jZSBmb3IgcmFuZ2UgZmllbGRzXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7fVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZm9ybS5maWVsZC5SYW5nZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZvcm0uZmllbGQuUmFuZ2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncmFuZ2VmaWVsZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdyYW5nZWZpZWxkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXJhbmdlZmllbGQnLCduZW8tdGV4dGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXJhbmdlZmllbGQnLCAnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBzaG93cyBhIGNsZWFyIHRyaWdnZXIgaW4gY2FzZSB0aGUgZmllbGQgaGFzIGEgbm9uIGVtcHR5IHZhbHVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjbGVhcmFibGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyYWJsZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBmb3IgdGhlIGlucHV0VHlwZV8gdGV4dGZpZWxkIGNvbmZpZ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlucHV0VHlwZT0ncmFuZ2UnXG4gICAgICAgICAqL1xuICAgICAgICBpbnB1dFR5cGU6ICdyYW5nZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBzaG93cyB0aGUgcmVzdWx0IG9mIHRoZSBzbGlkZXIgaW4gdGhlIGxhYmVsXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dSZXN1bHRJbkxhYmVsPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93UmVzdWx0SW5MYWJlbDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gdGlja21hcmtzXz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgdGlja21hcmtzXzogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VJbnB1dEV2ZW50PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VJbnB1dEV2ZW50OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBmaWVsZC5OdW1iZXIgYnV0dG9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VJbnB1dEV2ZW50PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VTcGluQnV0dG9uczogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnB1dEVsID0gbWUudmRvbS5jblsyXTtcblxuICAgICAgICBpZiAobWUudXNlSW5wdXRFdmVudCkge1xuICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgICAgICBmbiAgIDogbWUub25JbnB1dFZhbHVlQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICBpZCAgIDogbWUudmRvbS5jblsyXS5pZCxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dEVsLmNscyA9IFsnbmVvLXJhbmdlZmllbGQtaW5wdXQnXTsgLy8gcmVwbGFjZSBuZW8tdGV4dGZpZWxkLWlucHV0XG5cbiAgICAgICAgbWUuYWRkVmFsdWVUb0xhYmVsKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRpY2ttYXJrcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGlja21hcmtzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyB0b2RvXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmFkZFZhbHVlVG9MYWJlbCgpO1xuICAgICAgICBzdXBlci5hZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgbGFiZWwgd2l0aCB2YWx1ZVxuICAgICAqL1xuICAgIGFkZFZhbHVlVG9MYWJlbCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2hvd1Jlc3VsdEluTGFiZWwpIHtcbiAgICAgICAgICAgIG1lLmdldExhYmVsRWwoKS5pbm5lckhUTUwgPSBgWyR7bWUudmFsdWV9XSBgICsgbWUubGFiZWxUZXh0XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFJhbmdlKTtcbiIsImltcG9ydCBNYW5hZ2VyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5UYXNrXG4gKiBAZXh0ZW5kcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBpbXBvcnQgVGFza01hbmFnZXIgZnJvbSAnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL21hbmFnZXIvVGFzay5tanMnO1xuICpcbiAqICAgICB0YXNrID0ge1xuICogICAgICAgICBhcmdzOiBbY2xvY2tEb21dLCAgICAgICAgICAgLy8gYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBydW4gZm5cbiAqICAgICAgICAgYWRkQ291bnRUb0FyZ3M6IHRydWUsICAgICAgIC8vIGFkZHMgdGhlIGNvdW50IHRvIHRoZSBhcmd1bWVudHNcbiAqICAgICAgICAgZmlyZU9uU3RhcnQ6IGZhbHNlICAgICAgICAgIC8vIHJ1biBiZWZvcmUgdGhlIGZpcnN0IGludGVydmFsXG4gKiAgICAgICAgIGlkOiAnY2xvY2tjb3VudGVyJywgICAgICAgICAvLyBpZCBmb3IgdGhlIHRhc2sgb3IgYXV0b2NyZWF0ZWRcbiAqICAgICAgICAgaW50ZXJ2YWw6IDEwMDAsICAgICAgICAgICAgIC8vIGluIG1zXG4gKiAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uKCl7fSwgICAgICAvLyBydW5zIGluIGNhc2UgYW4gZXJyb3Igb2NjdXJyZWRcbiAqICAgICAgICAgcmVwZWF0OiAxMCwgICAgICAgICAgICAgICAgIC8vIHN0b3BBZnRlclRlblRpbWVzXG4gKiAgICAgICAgIHJ1bjogZnVuY3Rpb24oY2xvY2spIHsgICAgICAvLyBmdW5jdGlvbiB0byBydW5cbiAqICAgICAgICAgICAgIGNsb2NrLnNldEh0bWwobmV3IERhdGUoKSk7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHNjb3BlOiB0aGlzICAgICAgICAgICAgICAgICAvLyBzY29wZSBvZiB0aGUgZnVuY3Rpb25cbiAqICAgICB9O1xuICpcbiAqICAgICBUYXNrTWFuYWdlci5zdGFydCh0YXNrKTsgLy8gb3IgdGFza0lkIGlmIGV4aXN0c1xuICogICAgIFRhc2tNYW5hZ2VyLnN0b3AoJ2Nsb2NrY291bnRlcicsIHJlbW92ZSk7IC8vIGZhbHNlIHRvIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgVGFza01hbmFnZXJcbiAqICAgICBUYXNrTWFuYWdlci5zdG9wQWxsKHJlbW92ZSk7XG4gKlxuICogICAgIFRhc2tNYW5hZ2VyLmNyZWF0ZVRhc2sodGFzayk7XG4gKiAgICAgVGFza01hbmFnZXIucmVtb3ZlKHRhc2tJZCk7XG4gKlxuICogICAgIFRhc2tNYW5hZ2VyLnJ1bih0YXNrSWQpO1xuICogICAgIFRhc2tNYW5hZ2VyLmdldCh0YXNrSWQpLnJlcGVhdCA9IDIwO1xuICovXG5jbGFzcyBUYXNrIGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5UYXNrJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5UYXNrJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0YXNrIHRvIGNvbGxlY3Rpb24uXG4gICAgICogVHlwaWNhbGx5IHVzZWQgdmlhIGBzdGFydCh0YXNrKWBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFza1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlVGFzayh0YXNrKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0YXNrLmlkKSB7XG4gICAgICAgICAgICB0YXNrLmlkID0gTmVvLmNvcmUuSWRHZW5lcmF0b3IuZ2V0SWQoJ3Rhc2snKVxuICAgICAgICB9XG5cbiAgICAgICAgdGFzay5zY29wZSAgICAgICAgICAmJiB0YXNrLnJ1bi5iaW5kKHRhc2suc2NvcGUpO1xuICAgICAgICB0YXNrLmFkZENvdW50VG9BcmdzICYmIHRhc2suYXJncy5wdXNoKDApO1xuXG4gICAgICAgIHRhc2sgPSB7XG4gICAgICAgICAgICBhcmdzICAgICAgOiBbXSxcbiAgICAgICAgICAgIGlzUnVubmluZyA6IGZhbHNlLFxuICAgICAgICAgICAgb25FcnJvciAgIDogTmVvLmVtcHR5Rm4sXG4gICAgICAgICAgICBydW5Db3VudCAgOiAwLFxuICAgICAgICAgICAgcnVubmVyICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJ1bk9uU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgLi4udGFza1xuICAgICAgICB9O1xuXG4gICAgICAgIG1lLnJlZ2lzdGVyKHRhc2spO1xuXG4gICAgICAgIHJldHVybiB0YXNrXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHRhc2sgZnJvbSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXNrSWRcbiAgICAgKi9cbiAgICByZW1vdmVUYXNrKHRhc2tJZCkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIodGFza0lkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSB0YXNrIGZyb20gY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFza0lkXG4gICAgICovXG4gICAgcnVuKHRhc2tJZCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICB0YXNrID0gbWUuZ2V0KHRhc2tJZCk7XG5cbiAgICAgICAgaWYgKHRhc2suaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ1tOZW8udXRpbC5UYXNrTWFuYWdlcl0gVGFzayBpcyBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0YXNrXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGZuID0gZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgIHRhc2sucnVuQ291bnQrKztcblxuICAgICAgICAgICAgICAgIGlmICh0YXNrLmFkZENvdW50VG9BcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suYXJnc1t0YXNrLmFyZ3MubGVuZ3RoIC0gMV0gPSB0YXNrLnJ1bkNvdW50XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhc2sucmVwZWF0ICYmIHRhc2sucnVuQ291bnQgPT09IHRhc2sucmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnN0b3AodGFzay5pZClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXNrLnJ1biguLi50YXNrLmFyZ3MpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0YXNrLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICB0YXNrLnJ1bm5lciAgICA9IHNldEludGVydmFsKGZuLCB0YXNrLmludGVydmFsLCB0YXNrKVxuICAgICAgICB9IGNhdGNoICh0YXNrRXJyb3IpIHtcbiAgICAgICAgICAgIE5lby5sb2dFcnJvcignW05lby51dGlsLlRhc2tNYW5hZ2VyXSBFcnJvciB3aGlsZSBydW5uaW5nIHRhc2sgJyArIHRhc2suaWQpO1xuICAgICAgICAgICAgdGFzay5vbkVycm9yKHRhc2tFcnJvcik7XG4gICAgICAgICAgICB0YXNrLmlzUnVubmluZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGFzayBhbmQgcnVucyBpdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHRhc2sgb3IgdGFza0lkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGFydCh0YXNrKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyh0YXNrKSkge1xuICAgICAgICAgICAgdGFzayA9IG1lLmdldCh0YXNrKTtcbiAgICAgICAgICAgICF0YXNrICYmIE5lby5sb2dFcnJvcignW05lby51dGlsLlRhc2tNYW5hZ2VyXSBZb3UgcGFzc2VkIGEgdGFza0lkIHdoaWNoIGRvZXMgbm90IGV4aXRzJylcbiAgICAgICAgfSBlbHNlIGlmICghdGFzay5pZCB8fCAhbWUuZ2V0KHRhc2suaWQpKSB7XG4gICAgICAgICAgICB0YXNrID0gbWUuY3JlYXRlVGFzayh0YXNrKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhc2suaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICBOZW8ubG9nRXJyb3IoJ1tOZW8udXRpbC5UYXNrTWFuYWdlcl0gVGFzayBpcyBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0YXNrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFzay5ydW5PblN0YXJ0KSB7XG4gICAgICAgICAgICB0YXNrLnJ1bkNvdW50Kys7XG4gICAgICAgICAgICB0YXNrLnJ1biguLi50YXNrLmFyZ3MpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5ydW4odGFzay5pZCk7XG5cbiAgICAgICAgcmV0dXJuIHRhc2tcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhIHRhc2sgYW5kIHJlc2V0cyBjb25maWdzLlxuICAgICAqIElmIHJlbW92ZSBpcyB0cnVlIGl0IHdpbGwgcmVtb3ZlIHRoZSB0YXNrIGZyb20gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFza0lkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmVcbiAgICAgKi9cbiAgICBzdG9wKHRhc2tJZCwgcmVtb3ZlKSB7XG4gICAgICAgIGxldCB0YXNrID0gdGhpcy5nZXQodGFza0lkKTtcblxuICAgICAgICB0YXNrLmlzUnVubmluZyAmJiBjbGVhckludGVydmFsKHRhc2sucnVubmVyKTtcblxuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRhc2sodGFzaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhc2suaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0YXNrLnJ1bkNvdW50ICA9IDA7XG4gICAgICAgICAgICB0YXNrLnJ1bm5lciAgICA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0YXNrLmFkZENvdW50VG9BcmdzKSB7XG4gICAgICAgICAgICAgICAgdGFzay5hcmdzW3Rhc2suYXJncy5sZW5ndGggLSAxXSA9IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFsbCBydW5uaW5nIHRhc2tzIGZyb20gY29sbGVjdGlvbi5cbiAgICAgKiBJZiByZW1vdmUgaXMgdHJ1ZSwgaXQgd2lsbCByZW1vdmUgYWxsIHRhc2tzIGZyb20gTWFuYWdlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlXG4gICAgICovXG4gICAgc3RvcEFsbChyZW1vdmUpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5tYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcChrZXksIHJlbW92ZSlcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRhc2spO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9