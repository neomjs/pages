"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_wrapper_MonacoEditor_mjs"],{

/***/ "./src/component/wrapper/MonacoEditor.mjs":
/*!************************************************!*\
  !*** ./src/component/wrapper/MonacoEditor.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * Using this wrapper component requires to import the related main thread addon: Neo.main.addon.MonacoEditor
 * @class Neo.component.wrapper.MonacoEditor
 * @extends Neo.component.Base
 */
class MonacoEditor extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for cursorBlinking
     * @member {String[]} cursorBlinkings=['blink','expand','phase','smooth','solid']
     * @protected
     * @static
     */
    static cursorBlinkings = ['blink', 'expand', 'phase', 'smooth', 'solid']
    /**
     * @member {Object} delayable
     * @protected
     * @static
     */
    static delayable = {
        layoutEditor: {type: 'buffer', timer: 50}
    }
    /**
     * Valid values for editorTheme
     * @member {String[]} editorThemes=['hc-black','hc-light','vs','vs-dark']
     * @protected
     * @static
     */
    static editorThemes = ['hc-black', 'hc-light', 'vs', 'vs-dark']

    static config = {
        /**
         * @member {String} className='Neo.component.wrapper.MonacoEditor'
         * @protected
         */
        className: 'Neo.component.wrapper.MonacoEditor',
        /**
         * @member {String} ntype='monaco-editor'
         * @protected
         */
        ntype: 'monaco-editor',
        /**
         * @member {String[]} baseCls=['neo-monaco-editor']
         * @protected
         */
        baseCls: ['neo-monaco-editor'],
        /**
         * @member {Boolean} contextmenu_=false
         */
        contextmenu_: false,
        /**
         * Options are: 'blink', 'expand', 'phase', 'smooth', 'solid'
         * @member {String} cursorBlinking_='blink'
         */
        cursorBlinking_: 'blink',
        /**
         * additional property to only use in combination with readOnly === true.
         * domReadOnly additionally sets the readonly attribute to the underlying textarea.
         * @member {Boolean} domReadOnly_=false
         */
        domReadOnly_: false,
        /**
         * Options are: 'vs', 'vs-dark', 'hc-black', 'hc-light'
         * @member {String} editorTheme_='vs'
         */
        editorTheme_: 'vs',
        /**
         * @member {Number} fontSize_=14
         */
        fontSize_: 14,
        /**
         * @member {String} language_='javascript'
         */
        language_: 'javascript',
        /**
         * @member {Object} minimap_={enabled: false}
         */
        minimap_: {enabled: false},
        /**
         * A generic config which allows changing all editor options which are not exposed as configs here.
         * For a full list of available options see:
         * https://microsoft.github.io/monaco-editor/typedoc/interfaces/editor.IEditorOptions.html
         *
         * For initial options this config will win over related class configs.
         * However, run-time changes of related class configs will dynamically change their option values.
         * @member {Object} options_={}
         */
        options_: {},
        /**
         * @member {Boolean} readOnly_=false
         */
        readOnly_: false,
        /**
         * @member {Boolean} scrollBeyondLastLine_=false
         */
        scrollBeyondLastLine_: false,
        /**
         * @member {Boolean} showLineNumbers_=true
         */
        showLineNumbers_: true,
        /**
         * @member {String|String[]} value_=''
         */
        value_: ''
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            editorChange: me.onContentChange,
            resize      : me.layoutEditor,
            scope       : me
        })
    }

    /**
     * Triggered after the contextmenu config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetContextmenu(value, oldValue) {
        this.updateOptions({contextmenu: value})
    }

    /**
     * Triggered after the cursorBlinking config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetCursorBlinking(value, oldValue) {
        this.updateOptions({cursorBlinking: value})
    }

    /**
     * Triggered after the domReadOnly config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDomReadOnly(value, oldValue) {
        this.updateOptions({domReadOnly: value})
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        value && me.timeout(150).then(() => {
            Neo.main.addon.MonacoEditor.createInstance(me.getInitialOptions()).then(() => {
                // use this custom method as needed inside your class extensions
                me.onEditorMounted?.()
            })
        })
    }

    /**
     * Triggered after the editorTheme config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetEditorTheme(value, oldValue) {
        let me = this;

        if (me.mounted) {
            Neo.main.addon.MonacoEditor.setTheme({
                id      : me.id,
                value,
                windowId: me.windowId
            })
        }
    }

    /**
     * Triggered after the fontSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetFontSize(value, oldValue) {
        this.updateOptions({fontSize: value})
    }

    /**
     * Triggered after the language config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLanguage(value, oldValue) {
        let me = this;

        if (me.mounted) {
            Neo.main.addon.MonacoEditor.setLanguage({
                id      : me.id,
                value,
                windowId: me.windowId
            })
        }
    }

    /**
     * Triggered after the minimap config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetMinimap(value, oldValue) {
        this.updateOptions({minimap: value})
    }

    /**
     * Triggered after the options config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetOptions(value, oldValue) {
        this.updateOptions(value)
    }

    /**
     * Triggered after the readOnly config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetReadOnly(value, oldValue) {
        this.updateOptions({readOnly: value})
    }

    /**
     * Triggered after the scrollBeyondLastLine config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetScrollBeyondLastLine(value, oldValue) {
        this.updateOptions({scrollBeyondLastLine: value})
    }

    /**
     * Triggered after the showLineNumbers config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowLineNumbers(value, oldValue) {
        this.updateOptions({lineNumbers: value ? 'on' : 'off'})
    }

    /**
     * Triggered after the value config got changed
     * @param {String|String[]} value
     * @param {String|String[]} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this;

        if (me.mounted) {
            Neo.main.addon.MonacoEditor.setValue({
                id      : me.id,
                value   : me.stringifyValue(me.value),
                windowId: me.windowId
            })
        }
    }

    /**
     * Triggered before the cursorBlinking config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetCursorBlinking(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'cursorBlinking')
    }

    /**
     * Triggered before the editorTheme config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetEditorTheme(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'editorTheme')
    }

    /**
     * @param args
     */
    destroy(...args) {
        let me = this;

        me.mounted && Neo.main.addon.ResizeObserver.unregister({
            id      : me.id,
            windowId: me.windowId
        });

        Neo.main.addon.MonacoEditor.destroyInstance({
            id      : me.id,
            windowId: me.windowId
        });

        super.destroy(...args)
    }

    /**
     * Fetches the current value from the editor instance
     * @returns {Promise<*>}
     */
    async getEditorValue() {
        let me = this;

        return Neo.main.addon.MonacoEditor.getValue({
            id      : me.id,
            windowId: me.windowId
        })
    }

    /**
     * Override this method as needed inside your own class extensions
     * @returns {Object}
     */
    getInitialOptions() {
        let me = this;

        return {
            appName             : me.appName,
            contextmenu         : me.contextmenu,
            cursorBlinking      : me.cursorBlinking,
            domReadOnly         : me.domReadOnly,
            id                  : me.id,
            fontSize            : me.fontSize,
            language            : me.language,
            lineNumbers         : me.showLineNumbers ? 'on' : 'off',
            minimap             : me.minimap,
            readOnly            : me.readOnly,
            scrollBeyondLastLine: me.scrollBeyondLastLine,
            theme               : me.editorTheme,
            value               : me.stringifyValue(me.value),
            ...me.options
        }
    }

    /**
     *
     */
    layoutEditor() {
        let me = this;

        if (me.mounted) {
            Neo.main.addon.MonacoEditor.layoutEditor({
                id      : me.id,
                windowId: me.windowId
            })
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.event
     * @param {String} data.id
     * @param {String} data.value
     */
    onContentChange(data) {
        this.fire('editorChange', data)
    }

    /**
     *
     * @param {String|String[]} value
     * @returns {String}
     */
    stringifyValue(value) {
        if (Array.isArray(value)) {
            value = value.join('\n')
        }

        return value
    }

    /**
     * @param {Object} options
     */
    updateOptions(options) {
        let me = this;

        if (me.mounted) {
            Neo.main.addon.MonacoEditor.updateOptions({
                id      : me.id,
                windowId: me.windowId,
                options
            })
        }
    }
}

Neo.setupClass(MonacoEditor);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MonacoEditor);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfd3JhcHBlcl9Nb25hY29FZGl0b3JfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFJO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsVUFBVTtBQUN0QztBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlC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LFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFlLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L3dyYXBwZXIvTW9uYWNvRWRpdG9yLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIFVzaW5nIHRoaXMgd3JhcHBlciBjb21wb25lbnQgcmVxdWlyZXMgdG8gaW1wb3J0IHRoZSByZWxhdGVkIG1haW4gdGhyZWFkIGFkZG9uOiBOZW8ubWFpbi5hZGRvbi5Nb25hY29FZGl0b3JcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LndyYXBwZXIuTW9uYWNvRWRpdG9yXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTW9uYWNvRWRpdG9yIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBjdXJzb3JCbGlua2luZ1xuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjdXJzb3JCbGlua2luZ3M9WydibGluaycsJ2V4cGFuZCcsJ3BoYXNlJywnc21vb3RoJywnc29saWQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGN1cnNvckJsaW5raW5ncyA9IFsnYmxpbmsnLCAnZXhwYW5kJywgJ3BoYXNlJywgJ3Ntb290aCcsICdzb2xpZCddXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7XG4gICAgICAgIGxheW91dEVkaXRvcjoge3R5cGU6ICdidWZmZXInLCB0aW1lcjogNTB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgZWRpdG9yVGhlbWVcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gZWRpdG9yVGhlbWVzPVsnaGMtYmxhY2snLCdoYy1saWdodCcsJ3ZzJywndnMtZGFyayddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZWRpdG9yVGhlbWVzID0gWydoYy1ibGFjaycsICdoYy1saWdodCcsICd2cycsICd2cy1kYXJrJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC53cmFwcGVyLk1vbmFjb0VkaXRvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC53cmFwcGVyLk1vbmFjb0VkaXRvcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdtb25hY28tZWRpdG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21vbmFjby1lZGl0b3InLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tbW9uYWNvLWVkaXRvciddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLW1vbmFjby1lZGl0b3InXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGNvbnRleHRtZW51Xz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGV4dG1lbnVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbnMgYXJlOiAnYmxpbmsnLCAnZXhwYW5kJywgJ3BoYXNlJywgJ3Ntb290aCcsICdzb2xpZCdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjdXJzb3JCbGlua2luZ189J2JsaW5rJ1xuICAgICAgICAgKi9cbiAgICAgICAgY3Vyc29yQmxpbmtpbmdfOiAnYmxpbmsnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYWRkaXRpb25hbCBwcm9wZXJ0eSB0byBvbmx5IHVzZSBpbiBjb21iaW5hdGlvbiB3aXRoIHJlYWRPbmx5ID09PSB0cnVlLlxuICAgICAgICAgKiBkb21SZWFkT25seSBhZGRpdGlvbmFsbHkgc2V0cyB0aGUgcmVhZG9ubHkgYXR0cmlidXRlIHRvIHRoZSB1bmRlcmx5aW5nIHRleHRhcmVhLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkb21SZWFkT25seV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRvbVJlYWRPbmx5XzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zIGFyZTogJ3ZzJywgJ3ZzLWRhcmsnLCAnaGMtYmxhY2snLCAnaGMtbGlnaHQnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZWRpdG9yVGhlbWVfPSd2cydcbiAgICAgICAgICovXG4gICAgICAgIGVkaXRvclRoZW1lXzogJ3ZzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZm9udFNpemVfPTE0XG4gICAgICAgICAqL1xuICAgICAgICBmb250U2l6ZV86IDE0LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsYW5ndWFnZV89J2phdmFzY3JpcHQnXG4gICAgICAgICAqL1xuICAgICAgICBsYW5ndWFnZV86ICdqYXZhc2NyaXB0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbWluaW1hcF89e2VuYWJsZWQ6IGZhbHNlfVxuICAgICAgICAgKi9cbiAgICAgICAgbWluaW1hcF86IHtlbmFibGVkOiBmYWxzZX0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGdlbmVyaWMgY29uZmlnIHdoaWNoIGFsbG93cyBjaGFuZ2luZyBhbGwgZWRpdG9yIG9wdGlvbnMgd2hpY2ggYXJlIG5vdCBleHBvc2VkIGFzIGNvbmZpZ3MgaGVyZS5cbiAgICAgICAgICogRm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zIHNlZTpcbiAgICAgICAgICogaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL21vbmFjby1lZGl0b3IvdHlwZWRvYy9pbnRlcmZhY2VzL2VkaXRvci5JRWRpdG9yT3B0aW9ucy5odG1sXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBpbml0aWFsIG9wdGlvbnMgdGhpcyBjb25maWcgd2lsbCB3aW4gb3ZlciByZWxhdGVkIGNsYXNzIGNvbmZpZ3MuXG4gICAgICAgICAqIEhvd2V2ZXIsIHJ1bi10aW1lIGNoYW5nZXMgb2YgcmVsYXRlZCBjbGFzcyBjb25maWdzIHdpbGwgZHluYW1pY2FsbHkgY2hhbmdlIHRoZWlyIG9wdGlvbiB2YWx1ZXMuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gb3B0aW9uc189e31cbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnNfOiB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlYWRPbmx5Xz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZE9ubHlfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNjcm9sbEJleW9uZExhc3RMaW5lXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsQmV5b25kTGFzdExpbmVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dMaW5lTnVtYmVyc189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0xpbmVOdW1iZXJzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xTdHJpbmdbXX0gdmFsdWVfPScnXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86ICcnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgZWRpdG9yQ2hhbmdlOiBtZS5vbkNvbnRlbnRDaGFuZ2UsXG4gICAgICAgICAgICByZXNpemUgICAgICA6IG1lLmxheW91dEVkaXRvcixcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbnRleHRtZW51IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29udGV4dG1lbnUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucyh7Y29udGV4dG1lbnU6IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGN1cnNvckJsaW5raW5nIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnNvckJsaW5raW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoe2N1cnNvckJsaW5raW5nOiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkb21SZWFkT25seSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERvbVJlYWRPbmx5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoe2RvbVJlYWRPbmx5OiB2YWx1ZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICB2YWx1ZSAmJiBtZS50aW1lb3V0KDE1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5Nb25hY29FZGl0b3IuY3JlYXRlSW5zdGFuY2UobWUuZ2V0SW5pdGlhbE9wdGlvbnMoKSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoaXMgY3VzdG9tIG1ldGhvZCBhcyBuZWVkZWQgaW5zaWRlIHlvdXIgY2xhc3MgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIG1lLm9uRWRpdG9yTW91bnRlZD8uKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlZGl0b3JUaGVtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFZGl0b3JUaGVtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uTW9uYWNvRWRpdG9yLnNldFRoZW1lKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmb250U2l6ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGb250U2l6ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKHtmb250U2l6ZTogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbGFuZ3VhZ2UgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TGFuZ3VhZ2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLk1vbmFjb0VkaXRvci5zZXRMYW5ndWFnZSh7XG4gICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluaW1hcCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNaW5pbWFwKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoe21pbmltYXA6IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG9wdGlvbnMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0T3B0aW9ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVhZE9ubHkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWFkT25seSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKHtyZWFkT25seTogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2Nyb2xsQmV5b25kTGFzdExpbmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTY3JvbGxCZXlvbmRMYXN0TGluZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKHtzY3JvbGxCZXlvbmRMYXN0TGluZTogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0xpbmVOdW1iZXJzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0xpbmVOdW1iZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoe2xpbmVOdW1iZXJzOiB2YWx1ZSA/ICdvbicgOiAnb2ZmJ30pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2YWx1ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uTW9uYWNvRWRpdG9yLnNldFZhbHVlKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgdmFsdWUgICA6IG1lLnN0cmluZ2lmeVZhbHVlKG1lLnZhbHVlKSxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjdXJzb3JCbGlua2luZyBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q3Vyc29yQmxpbmtpbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdjdXJzb3JCbGlua2luZycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZWRpdG9yVGhlbWUgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEVkaXRvclRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZWRpdG9yVGhlbWUnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUubW91bnRlZCAmJiBOZW8ubWFpbi5hZGRvbi5SZXNpemVPYnNlcnZlci51bnJlZ2lzdGVyKHtcbiAgICAgICAgICAgIGlkICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICB9KTtcblxuICAgICAgICBOZW8ubWFpbi5hZGRvbi5Nb25hY29FZGl0b3IuZGVzdHJveUluc3RhbmNlKHtcbiAgICAgICAgICAgIGlkICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIHRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRFZGl0b3JWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4gTmVvLm1haW4uYWRkb24uTW9uYWNvRWRpdG9yLmdldFZhbHVlKHtcbiAgICAgICAgICAgIGlkICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIG5lZWRlZCBpbnNpZGUgeW91ciBvd24gY2xhc3MgZXh0ZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0SW5pdGlhbE9wdGlvbnMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgY29udGV4dG1lbnUgICAgICAgICA6IG1lLmNvbnRleHRtZW51LFxuICAgICAgICAgICAgY3Vyc29yQmxpbmtpbmcgICAgICA6IG1lLmN1cnNvckJsaW5raW5nLFxuICAgICAgICAgICAgZG9tUmVhZE9ubHkgICAgICAgICA6IG1lLmRvbVJlYWRPbmx5LFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgZm9udFNpemUgICAgICAgICAgICA6IG1lLmZvbnRTaXplLFxuICAgICAgICAgICAgbGFuZ3VhZ2UgICAgICAgICAgICA6IG1lLmxhbmd1YWdlLFxuICAgICAgICAgICAgbGluZU51bWJlcnMgICAgICAgICA6IG1lLnNob3dMaW5lTnVtYmVycyA/ICdvbicgOiAnb2ZmJyxcbiAgICAgICAgICAgIG1pbmltYXAgICAgICAgICAgICAgOiBtZS5taW5pbWFwLFxuICAgICAgICAgICAgcmVhZE9ubHkgICAgICAgICAgICA6IG1lLnJlYWRPbmx5LFxuICAgICAgICAgICAgc2Nyb2xsQmV5b25kTGFzdExpbmU6IG1lLnNjcm9sbEJleW9uZExhc3RMaW5lLFxuICAgICAgICAgICAgdGhlbWUgICAgICAgICAgICAgICA6IG1lLmVkaXRvclRoZW1lLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA6IG1lLnN0cmluZ2lmeVZhbHVlKG1lLnZhbHVlKSxcbiAgICAgICAgICAgIC4uLm1lLm9wdGlvbnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbGF5b3V0RWRpdG9yKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5Nb25hY29FZGl0b3IubGF5b3V0RWRpdG9yKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5ldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudmFsdWVcbiAgICAgKi9cbiAgICBvbkNvbnRlbnRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ2VkaXRvckNoYW5nZScsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHN0cmluZ2lmeVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKCdcXG4nKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uTW9uYWNvRWRpdG9yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGlkICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTmVvLnNldHVwQ2xhc3MoTW9uYWNvRWRpdG9yKTtcblxuZXhwb3J0IGRlZmF1bHQgTW9uYWNvRWRpdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9