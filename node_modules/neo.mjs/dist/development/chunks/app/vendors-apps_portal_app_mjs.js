"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_portal_app_mjs"],{

/***/ "./apps/portal/Overwrites.mjs":
/*!************************************!*\
  !*** ./apps/portal/Overwrites.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
Neo.overwrites = {
    Neo: {
        button: {
            Base: {
                editRoute: false
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.overwrites);


/***/ }),

/***/ "./apps/portal/Util.mjs":
/*!******************************!*\
  !*** ./apps/portal/Util.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSearchParams: () => (/* binding */ getSearchParams)
/* harmony export */ });
/**
 * @param {String|null} searchString
 * @returns {Function}
 */
function getSearchParams(searchString) {
    if (searchString?.startsWith('?')) {
        searchString = searchString.substring(1)
    }

    return searchString ? JSON.parse(`{"${decodeURI(searchString.replace(/&/g, "\",\"").replace(/=/g, "\":\""))}"}`) : {}
}


/***/ }),

/***/ "./apps/portal/app.mjs":
/*!*****************************!*\
  !*** ./apps/portal/app.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _Overwrites_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Overwrites.mjs */ "./apps/portal/Overwrites.mjs");
/* harmony import */ var _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view/Viewport.mjs */ "./apps/portal/view/Viewport.mjs");



const onStart = () => Neo.app({
    mainView: _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
    name    : 'Portal'
})


/***/ }),

/***/ "./apps/portal/service/Seo.mjs":
/*!*************************************!*\
  !*** ./apps/portal/service/Seo.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @summary Manages SEO metadata for the Portal application, fetching it from a JSON file
 * and intelligently updating the document head based on route changes.
 *
 * This singleton service is responsible for centralizing all SEO-related logic.
 * It fetches route-specific title and description metadata from `apps/portal/resources/data/seo.json`
 * during its asynchronous initialization. It then provides a mechanism for the `ViewportController`
 * to notify it of route changes. The service ensures that the document's `<title>` and `<meta name="description">`
 * tags are updated only when the service is fully ready and with the most recent route hash,
 * preventing race conditions on slow network connections.
 *
 * This class demonstrates the use of asynchronous initialization (`initAsync`), reactive config hooks (`afterSetIsReady`),
 * and private class fields to manage internal state and ensure robust behavior.
 *
 * @class Portal.service.Seo
 * @extends Neo.core.Base
 * @singleton
 * @see Portal.view.ViewportController
 */
class Seo extends _src_core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.service.Seo'
         * @protected
         */
        className: 'Portal.service.Seo',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Stores the most recent route hash received from `onRouteChanged()`.
     * This is used to process a pending route update if the service becomes ready after a route change occurred.
     * @member {String|null} #lastRouteHash=null
     * @private
     */
    #lastRouteHash = null
    /**
     * Caches the SEO metadata fetched from `apps/portal/resources/data/seo.json`.
     * This object maps route hash strings to their corresponding title and description.
     * @member {Object|null} #metadata=null
     * @private
     */
    #metadata = null

    /**
     * Hook that fires after the `isReady` config changes. If the service becomes ready (`value` is true)
     * and there's a pending route hash (`#lastRouteHash` is not null), it triggers an update
     * of the document head with the metadata for that route.
     * @param {Boolean} value The new value of the `isReady` config.
     * @param {Boolean} oldValue The old value of the `isReady` config.
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        if (value && this.#lastRouteHash) {
            this.#updateDocumentHeadIfNeeded(this.#lastRouteHash)
        }
    }

    /**
     * Retrieves the SEO metadata (title and description) for a given route hash.
     * @param {String} route The route hash string (e.g., '/home', '/blog').
     * @returns {Object|null} An object containing `title` and `description` for the route, or `null` if not found.
     */
    getMetadata(route) {
        return this.#metadata?.[route] || null
    }

    /**
     * Asynchronously initializes the SEO service by fetching the `seo.json` file.
     * This method simulates an API call to retrieve SEO data, making the service ready
     * to provide metadata. It ensures that the service is fully loaded before processing
     * any route-related document head updates.
     * @returns {Promise<void>} A promise that resolves when the metadata has been fetched and parsed.
     */
    async initAsync() {
        await super.initAsync();

        try {
            const response = await fetch('../../apps/portal/resources/data/seo.json');
            if (!response.ok) {
                throw new Error(`HTTP error with status: ${response.status}`)
            }
            this.#metadata = await response.json();
        } catch (error) {
            console.error('Error fetching SEO metadata:', error)
        }
    }

    /**
     * Called by the `ViewportController` when the application's route changes.
     * This method stores the new route hash and attempts to update the document head.
     * If the service is not yet ready (i.e., `initAsync` is still running), the update
     * is deferred until `isReady` becomes true.
     * @param {String} hash The new route hash string.
     */
    onRouteChanged(hash) {
        this.#lastRouteHash = hash;
        this.#updateDocumentHeadIfNeeded(hash)
    }

    /**
     * This private method calls the `DocumentHead` main thread addon to update the document's
     * title and meta-description for SEO purposes. It is the actual mechanism for applying
     * the SEO changes to the browser's DOM.
     * @param {Object} config The configuration object containing `description` and `title`.
     * @param {String} config.description The new meta-description for the document.
     * @param {String} config.title The new title for the document.
     * @private
     */
    async #updateDocumentHead({description, title}) {
        let {windowId}   = this,
            DocumentHead = await Neo.currentWorker.getAddon('DocumentHead', windowId);

        await DocumentHead.update({description, title, windowId})
    }

    /**
     * A private helper method that conditionally updates the document head.
     * It checks if the service is `isReady` before attempting to retrieve metadata
     * and call `#updateDocumentHead`. If an update occurs, it clears `#lastRouteHash`.
     * This prevents multiple updates for the same route if `onRouteChanged` is called
     * before `initAsync` completes.
     * @param {String} hash The route hash for which to update the document head.
     * @private
     */
    #updateDocumentHeadIfNeeded(hash) {
        let me = this;

        if (me.isReady) {
            let metadata = me.getMetadata(hash);

            if (metadata) {
                me.#updateDocumentHead(metadata);
                me.#lastRouteHash = null
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Seo));


/***/ }),

/***/ "./apps/portal/view/HeaderToolbar.mjs":
/*!********************************************!*\
  !*** ./apps/portal/view/HeaderToolbar.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Portal.view.HeaderToolbar
 * @extends Neo.container.Base
 */
class HeaderToolbar extends _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.HeaderToolbar'
         * @protected
         */
        className: 'Portal.view.HeaderToolbar',
        /**
         * @member {String[]} cls=['portal-header-toolbar']
         * @reactive
         */
        cls: ['portal-header-toolbar'],
        /**
         * @member {Object} itemDefaults
         */
        itemDefaults: {
            ntype: 'button',
            ui   : 'ghost'
        },
        /**
         * @member {Object[]} items
         */
        items: [{
            cls     : ['logo'],
            iconCls : 'neo-logo-blue',
            minWidth: 60,
            route   : '/home',
            text    : 'Neo.mjs'
        }, '->', {
            text : 'Learn',
            route: '/learn'
        }, {
            text     : 'Blog',
            reference: 'blog-header-button',
            route    : '/blog'
        }, {
            text : 'Examples',
            route: '/examples'
        }, {
            text : 'Services',
            route: '/services'
        }, {
            ntype    : 'container',
            layout   : 'hbox',
            reference: 'header-social-icons',

            itemDefaults: {
                ntype: 'button',
                ui   : 'ghost'
            },

            items: [{
                iconCls: 'fa-brands fa-github',
                url    : 'https://github.com/neomjs/neo',
                tooltip: {
                    text     : 'GitHub',
                    showDelay: 0,
                    hideDelay: 0
                }
            }, {
                iconCls: 'fa-brands fa-slack',
                url    : 'https://join.slack.com/t/neomjs/shared_invite/zt-6c50ueeu-3E1~M4T9xkNnb~M_prEEOA',
                tooltip: {
                    text     : 'Join Slack',
                    showDelay: 0,
                    hideDelay: 0
                }
            }, {
                iconCls: 'fa-brands fa-discord',
                url    : 'https://discord.gg/6p8paPq',
                tooltip: {
                    text     : 'Join Discord',
                    showDelay: 0,
                    hideDelay: 0
                }
            }]
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HeaderToolbar));


/***/ }),

/***/ "./apps/portal/view/Viewport.mjs":
/*!***************************************!*\
  !*** ./apps/portal/view/Viewport.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _HeaderToolbar_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HeaderToolbar.mjs */ "./apps/portal/view/HeaderToolbar.mjs");
/* harmony import */ var _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ViewportController.mjs */ "./apps/portal/view/ViewportController.mjs");
/* harmony import */ var _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewportStateProvider.mjs */ "./apps/portal/view/ViewportStateProvider.mjs");







/**
 * @class Portal.view.Viewport
 * @extends Neo.container.Viewport
 */
class Viewport extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for size
     * @member {String[]} sizes=['large','medium','small','x-small',null]
     * @protected
     * @static
     */
    static sizes = ['large', 'medium', 'small', 'x-small', null]

    static config = {
        /**
         * @member {String} className='Portal.view.Viewport'
         * @protected
         */
        className: 'Portal.view.Viewport',
        /**
         * @member {Neo.controller.Component} controller=ViewportController
         * @reactive
         */
        controller: _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @reactive
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _HeaderToolbar_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            flex  : 'none'
        }, {
            module   : _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            cls      : ['portal-main-content'],
            reference: 'main-content',

            // The layout will get assigned inside ViewportController

            items: [
                {module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_tab_Container_mjs"), __webpack_require__.e("vendors-src_component_wrapper_MonacoEditor_mjs"), __webpack_require__.e("vendors-src_component_MagicMoveText_mjs"), __webpack_require__.e("vendors-src_code_LivePreview_mjs"), __webpack_require__.e("vendors-apps_portal_view_home_MainContainer_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./home/MainContainer.mjs */ "./apps/portal/view/home/MainContainer.mjs"))},
                {module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_data_Store_mjs"), __webpack_require__.e("vendors-src_list_Base_mjs"), __webpack_require__.e("vendors-src_tab_Container_mjs"), __webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_selection_Model_mjs-src_tree_List_mjs"), __webpack_require__.e("vendors-src_component_wrapper_MonacoEditor_mjs"), __webpack_require__.e("vendors-src_code_LivePreview_mjs"), __webpack_require__.e("vendors-apps_portal_view_learn_MainContainer_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./learn/MainContainer.mjs */ "./apps/portal/view/learn/MainContainer.mjs"))},
                {module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_form_field_Text_mjs"), __webpack_require__.e("vendors-src_form_field_Base_mjs"), __webpack_require__.e("vendors-src_data_Store_mjs"), __webpack_require__.e("vendors-src_list_Base_mjs"), __webpack_require__.e("vendors-apps_portal_view_blog_Container_mjs-src_selection_Model_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./blog/Container.mjs */ "./apps/portal/view/blog/Container.mjs"))},
                {module: () => __webpack_require__.e(/*! import() */ "apps_portal_view_services_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./services/Component.mjs */ "./apps/portal/view/services/Component.mjs"))},
                {module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_data_Store_mjs"), __webpack_require__.e("vendors-src_list_Base_mjs"), __webpack_require__.e("vendors-src_tab_Container_mjs"), __webpack_require__.e("vendors-apps_portal_view_examples_TabContainer_mjs-src_selection_Model_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./examples/TabContainer.mjs */ "./apps/portal/view/examples/TabContainer.mjs"))},
                {module: () => __webpack_require__.e(/*! import() */ "apps_portal_view_about_Container_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./about/Container.mjs */ "./apps/portal/view/about/Container.mjs"))},
                {module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_form_field_Text_mjs"), __webpack_require__.e("vendors-src_form_field_Base_mjs"), __webpack_require__.e("vendors-src_data_Store_mjs"), __webpack_require__.e("vendors-src_list_Base_mjs"), __webpack_require__.e("vendors-src_tab_Container_mjs"), __webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_selection_Model_mjs-src_tree_List_mjs"), __webpack_require__.e("vendors-docs_app_view_MainContainer_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../../../docs/app/view/MainContainer.mjs */ "./docs/app/view/MainContainer.mjs"))}
            ]
        }],
        /**
         * @member {Boolean} monitorSize=true
         * @reactive
         */
        monitorSize: true,
        /**
         * Values are: large, medium, small, xSmall
         * @member {String|null} size_=null
         * @reactive
         */
        size_: null,
        /**
         * @member {Neo.state.Provider} stateProvider=ViewportStateProvider
         * @reactive
         */
        stateProvider: _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.on('resize', me.onResize, me)
    }

    /**
     * Triggered after the size config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetSize(value, oldValue) {
        if (value) {
            let me  = this,
                cls = me.cls;

            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(cls, 'portal-size-' + oldValue);
            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(   cls, 'portal-size-' + value);
            me.cls = cls;

            me.stateProvider.setData({size: value});

            me.controller.size = value
        }
    }

    /**
     * Triggered before the size config gets changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @returns {String|null}
     * @protected
     */
    beforeSetSize(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'size')
    }

    /**
     * @param {Number} width
     * @returns {String}
     */
    getSize(width) {
        if (width <=  640) return 'x-small';
        if (width <= 1024) return 'small';
        if (width <= 1296) return 'medium';
        return 'large'
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        let me = this;

        if (me.id === data.id) {
            me.size = me.getSize(data.borderBoxSize.inlineSize)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ }),

/***/ "./apps/portal/view/ViewportController.mjs":
/*!*************************************************!*\
  !*** ./apps/portal/view/ViewportController.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _src_layout_Cube_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/layout/Cube.mjs */ "./src/layout/Cube.mjs");
/* harmony import */ var _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _service_Seo_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../service/Seo.mjs */ "./apps/portal/service/Seo.mjs");
/* harmony import */ var _Util_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Util.mjs */ "./apps/portal/Util.mjs");






/**
 * @summary The main controller for the portal's viewport.
 *
 * This controller is the central hub for the portal application. It is responsible for:
 * - **Top-Level Routing:** It uses the `routes` config to map the main URL hash changes (e.g., /home, /learn, /blog) to specific methods, which in turn control which main view is active. It's important to note that while this controller handles the top-level navigation, child views can implement their own nested routing logic (see `Portal.view.learn.MainContainerController` for an example).
 * - **Layout Management:** It manages the main content area's layout, including the "mixed" mode which uses a CubeLayout for slick transitions between views.
 * - **SEO:** It coordinates with the `DocumentHead` main thread addon to update the document's title and meta tags on each route change, ensuring the application is SEO-friendly.
 * - **Multi-Window Coordination:** It handles the connection and disconnection of child windows, such as the live code example previews.
 *
 * @class Portal.view.ViewportController
 * @extends Neo.controller.Component
 */
class ViewportController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for mainContentLayout
     * @member {String[]} mainContentLayouts=['card','cube','mixed']
     * @protected
     * @static
     */
    static mainContentLayouts = ['card', 'cube', 'mixed']

    static config = {
        /**
         * @member {String} className='Portal.view.ViewportController'
         * @protected
         */
        className: 'Portal.view.ViewportController',
        /**
         * @member {String} ntype='viewport-controller'
         * @protected
         */
        ntype: 'viewport-controller',
        /**
         * @member {Number|null} activeIndex_=null
         * @reactive
         */
        activeIndex_: null,
        /**
         * @member {String|null} defaultHash='/home'
         */
        defaultHash: '/home',
        /**
         * @member {String} mainContentLayout_='card'
         * @reactive
         */
        mainContentLayout_: 'card',
        /**
         * @member {Object} routes
         */
        routes: {
            '/about-us'         : 'onAboutUsRoute',
            '/blog'             : 'onBlogRoute',
            '/docs'             : 'onDocsRoute',
            '/examples'         : 'onExamplesRoute',
            '/examples/{itemId}': 'onExamplesRoute',
            '/home'             : 'onHomeRoute',
            '/learn'            : 'onLearnRoute',
            '/learn/{*itemId}'  : 'onLearnRoute',
            '/services'         : 'onServicesRoute'
        },
        /**
         * Values are: large, medium, small, xSmall
         * @member {String|null} size_=null
         * @reactive
         */
        size_: null
    }

    /**
     * @member {String[]} connectedApps=[]
     */
    connectedApps = []
    /**
     * Internal flag to store the amount of main navigation changes
     * @member {Number} #transitionId=0
     * @private
     */
    #transitionId = 0

    /**
     * Triggered after the size activeIndex got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetActiveIndex(value, oldValue) {
        value !== null && this.updateHeaderToolbar()
    }

    /**
     * Triggered after the mainContentLayout config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetMainContentLayout(value, oldValue) {
        let me                      = this,
            {activeIndex, windowId} = me,
            container               = me.component.getItem('main-content'); // happens before instantiation

        if (oldValue === undefined) {
            // We can not turn this method itself into async and await the addon response,
            // since the container needs its layout right away
            Neo.main.addon.LocalStorage.readLocalStorageItem({
                key: 'mainContentLayout',
                windowId
            }).then(({value}) => {
                if (value && value !== 'card') {
                    me.mainContentLayout = value
                }
            })
        }

        if (value === 'cube') {
            container.layout = {ntype: 'cube', activeIndex, fitContainer: true, hideInactiveCardsOnDestroy: true}
        } else {
            container.layout = {ntype: 'card', activeIndex}
        }

        Neo.main.addon.LocalStorage.updateLocalStorageItem({key: 'mainContentLayout', value, windowId})
    }

    /**
     * Triggered after the size config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetSize(value, oldValue) {
        value && this.updateHeaderToolbar()
    }

    /**
     * Triggered before the mainContentLayout config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetMainContentLayout(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'mainContentLayout')
    }

    /**
     * The route handlers (e.g., onAboutUsRoute, onBlogRoute) are now only responsible for
     * setting the main content index. The logic for updating the document head is centralized
     * in the onHashChange method.
     * @param {Object} params
     * @param {Object} value
     * @param {Object} oldValue
     */
    onAboutUsRoute(params, value, oldValue) {
        this.setMainContentIndex(5)
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Number} data.windowId
     */
    async onAppConnect(data) {
        let {appName, windowId} = data,
            app                 = Neo.apps[appName],
            mainView            = app.mainView;

        if (appName === 'PortalPreview') {
            let searchString    = await Neo.Main.getByPath({path: 'location.search', windowId}),
                livePreviewId   = (0,_Util_mjs__WEBPACK_IMPORTED_MODULE_4__.getSearchParams)(searchString).id,
                livePreview     = Neo.getComponent(livePreviewId),
                sourceContainer = livePreview.getReference('preview'),
                {tabContainer}  = livePreview,
                sourceView      = sourceContainer.removeAt(0, false);

            livePreview.previewContainer = mainView;
            mainView.add(sourceView);

            tabContainer.activeIndex = 0; // switch to the source view

            tabContainer.getTabAtIndex(1).disabled = true
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Number} data.windowId
     */
    async onAppDisconnect(data) {
        let {appName, windowId} = data,
            app                 = Neo.apps[appName],
            mainView            = app.mainView;

        // Closing a code preview window needs to drop the preview back into the related main app
        if (appName === 'PortalPreview') {
            let searchString    = await Neo.Main.getByPath({path: 'location.search', windowId}),
                livePreviewId   = (0,_Util_mjs__WEBPACK_IMPORTED_MODULE_4__.getSearchParams)(searchString).id,
                livePreview     = Neo.getComponent(livePreviewId),
                sourceContainer = livePreview.getReference('preview'),
                {tabContainer}  = livePreview,
                sourceView      = mainView.removeAt(0, false);

            livePreview.previewContainer = null;
            sourceContainer.add(sourceView);

            livePreview.disableRunSource = true; // will get reset after the next activeIndex change (async)
            tabContainer.activeIndex = 1;        // switch to the source view

            livePreview.getReference('popout-window-button').disabled = false;
            tabContainer.getTabAtIndex(1).disabled = false
        }
        // Close popup windows when closing or reloading the main window
        else if (appName === 'Portal') {
            Neo.Main.windowCloseAll({windowId})
        }
    }

    /**
     * @param {Object[]} records
     */
    onBlogPostStoreLoad(records) {
        this.getReference('blog-header-button').badgeText = records.length + ''
    }

    /**
     * @param {Object} params
     * @param {Object} value
     * @param {Object} oldValue
     */
    onBlogRoute(params, value, oldValue) {
        this.setMainContentIndex(2)
    }

    /**
     * @param {Object} data
     */
    onBlogSearchFieldChange(data) {
        this.getReference('blog-list').filterItems(data)
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onAppConnect,
            disconnect: me.onAppDisconnect,
            scope     : me
        })
    }

    /**
     * @param {Object} params
     * @param {Object} value
     * @param {Object} oldValue
     */
    onDocsRoute(params, value, oldValue) {
        this.setMainContentIndex(6)
    }

    /**
     * @param {Object} params
     * @param {Object} value
     * @param {Object} oldValue
     */
    onExamplesRoute(params, value, oldValue) {
        this.setMainContentIndex(4)
    }

    /**
     * This is the central handler for all route changes. It is now responsible for delegating
     * the document's head metadata (title and description) updates to the `Portal.service.Seo` service.
     * @param {Object} value               The new route object.
     * @param {String} value.hashString    The new hash string.
     * @param {Object} oldValue            The previous route object.
     * @param {String} oldValue.hashString The previous hash string.
     * @returns {Promise<void>}
     */
    async onHashChange(value, oldValue) {
        await super.onHashChange(value, oldValue);
        _service_Seo_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].onRouteChanged(value?.hashString)
    }

    /**
     * @param {Object} params
     * @param {Object} value
     * @param {Object} oldValue
     */
    onHomeRoute(params, value, oldValue) {
        this.setMainContentIndex(0)
    }

    /**
     * @param {Object} params
     * @param {Object} value
     * @param {Object} oldValue
     */
    onLearnRoute(params, value, oldValue) {
        this.setMainContentIndex(1)
    }

    /**
     * @param {Object} params
     * @param {Object} value
     * @param {Object} oldValue
     */
    onServicesRoute(params, value, oldValue) {
        this.setMainContentIndex(3)
    }

    /**
     * This method orchestrates the visual transition between the main content cards.
     * It uses a "mixed" layout mode, which temporarily switches to a CubeLayout for
     * a 3D transition effect, and then back to a CardLayout for performance.
     * @param {Number} index
     */
    async setMainContentIndex(index) {
        let me                               = this,
            {activeIndex, mainContentLayout} = me,
            container                        = me.getReference('main-content'),
            updateLayout                     = true,
            transitionId;

        if (index !== activeIndex) {
            me.activeIndex = index;

            if (
                mainContentLayout === 'mixed' &&
                // skip the initial layout-switch, since we do not need a transition
                Neo.isNumber(activeIndex) &&
                // also skip the layout switch in case the index >= 6, since a cube only has 6 faces
                index < 6 &&
                // also skip the layout switch in case we navigate back from a non-cube item
                activeIndex < 6
            ) {
                me.#transitionId++;

                transitionId = me.#transitionId;
                updateLayout = false;

                // enable "fast clicking" on main nav items => do not replace a cube layout with a new instance of cube
                if (container.layout.ntype !== 'layout-cube') {
                    await container.set({
                        layout: {ntype: 'cube', activeIndex, fitContainer: true, hideInactiveCardsOnDestroy: true}
                    });
                    await me.timeout(20)
                }

                container.layout.activeIndex = index;

                await me.timeout(1100);

                if (transitionId === me.#transitionId) {
                    await container.set({
                        layout: {ntype: 'card', activeIndex: index}
                    });
                    await me.timeout(20)
                }
            }

            if (updateLayout) {
                container.layout.activeIndex = index
            }
        }
    }

    /**
     * This method calls the DocumentHead main thread addon to update the document's
     * title and meta description for SEO purposes.
     * @param {Object} config
     * @param {String} config.description
     * @param {String} config.title
     */
    async updateHeaderToolbar() {
        let me                  = this,
            {activeIndex, size} = me;

        if (Neo.isNumber(activeIndex) && size) {
            let headerSocialIcons = me.getReference('header-social-icons'),
                {cls}             = headerSocialIcons,
                vertical          = size === 'x-small',
                hidden            = activeIndex !== 0 && vertical;

            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'hide-sidebar', hidden);

            if (!hidden) {
                _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].toggle(cls, 'separate-bar', vertical)
            }

            headerSocialIcons.cls = cls;


            if (hidden && vertical) {
                await me.timeout(200)
            }

            headerSocialIcons.hidden = hidden
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportController));


/***/ }),

/***/ "./apps/portal/view/ViewportStateProvider.mjs":
/*!****************************************************!*\
  !*** ./apps/portal/view/ViewportStateProvider.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");


/**
 * @class Portal.view.ViewportStateProvider
 * @extends Neo.state.Provider
 */
class ViewportStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.ViewportStateProvider'
         * @protected
         */
        className: 'Portal.view.ViewportStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * Values are: large, medium, small, xSmall, null
             * @member {String|null} size
             */
            size: null
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportStateProvider));


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ }),

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {appName, windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName,
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         * @reactive
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    windowId           : me.windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (this.sortZone) {
            this.sortZone.windowId = value
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfcG9ydGFsX2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxjQUFjLEVBQUM7Ozs7Ozs7Ozs7Ozs7OztBQ1Y5QjtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsR0FBRyxzRUFBc0UsRUFBRTtBQUNsSDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWMEM7QUFDRzs7QUFFdEM7QUFDUCxjQUFjLDBEQUFRO0FBQ3RCO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ042Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQUk7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMz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Lm1qcy8uL2FwcHMvcG9ydGFsL092ZXJ3cml0ZXMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9VdGlsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvc2VydmljZS9TZW8ubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L0hlYWRlclRvb2xiYXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L1ZpZXdwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9WaWV3cG9ydENvbnRyb2xsZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L1ZpZXdwb3J0U3RhdGVQcm92aWRlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTGFiZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3Rvb2xiYXIvQmFzZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiTmVvLm92ZXJ3cml0ZXMgPSB7XG4gICAgTmVvOiB7XG4gICAgICAgIGJ1dHRvbjoge1xuICAgICAgICAgICAgQmFzZToge1xuICAgICAgICAgICAgICAgIGVkaXRSb3V0ZTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLm92ZXJ3cml0ZXM7XG4iLCIvKipcbiAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHNlYXJjaFN0cmluZ1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VhcmNoUGFyYW1zKHNlYXJjaFN0cmluZykge1xuICAgIGlmIChzZWFyY2hTdHJpbmc/LnN0YXJ0c1dpdGgoJz8nKSkge1xuICAgICAgICBzZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmcuc3Vic3RyaW5nKDEpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaFN0cmluZyA/IEpTT04ucGFyc2UoYHtcIiR7ZGVjb2RlVVJJKHNlYXJjaFN0cmluZy5yZXBsYWNlKC8mL2csIFwiXFxcIixcXFwiXCIpLnJlcGxhY2UoLz0vZywgXCJcXFwiOlxcXCJcIikpfVwifWApIDoge31cbn1cbiIsImltcG9ydCBPdmVyd3JpdGVzIGZyb20gJy4vT3ZlcndyaXRlcy5tanMnO1xuaW1wb3J0IFZpZXdwb3J0ICAgZnJvbSAnLi92aWV3L1ZpZXdwb3J0Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvblN0YXJ0ID0gKCkgPT4gTmVvLmFwcCh7XG4gICAgbWFpblZpZXc6IFZpZXdwb3J0LFxuICAgIG5hbWUgICAgOiAnUG9ydGFsJ1xufSlcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uLy4uLy4uL3NyYy9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBNYW5hZ2VzIFNFTyBtZXRhZGF0YSBmb3IgdGhlIFBvcnRhbCBhcHBsaWNhdGlvbiwgZmV0Y2hpbmcgaXQgZnJvbSBhIEpTT04gZmlsZVxuICogYW5kIGludGVsbGlnZW50bHkgdXBkYXRpbmcgdGhlIGRvY3VtZW50IGhlYWQgYmFzZWQgb24gcm91dGUgY2hhbmdlcy5cbiAqXG4gKiBUaGlzIHNpbmdsZXRvbiBzZXJ2aWNlIGlzIHJlc3BvbnNpYmxlIGZvciBjZW50cmFsaXppbmcgYWxsIFNFTy1yZWxhdGVkIGxvZ2ljLlxuICogSXQgZmV0Y2hlcyByb3V0ZS1zcGVjaWZpYyB0aXRsZSBhbmQgZGVzY3JpcHRpb24gbWV0YWRhdGEgZnJvbSBgYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvc2VvLmpzb25gXG4gKiBkdXJpbmcgaXRzIGFzeW5jaHJvbm91cyBpbml0aWFsaXphdGlvbi4gSXQgdGhlbiBwcm92aWRlcyBhIG1lY2hhbmlzbSBmb3IgdGhlIGBWaWV3cG9ydENvbnRyb2xsZXJgXG4gKiB0byBub3RpZnkgaXQgb2Ygcm91dGUgY2hhbmdlcy4gVGhlIHNlcnZpY2UgZW5zdXJlcyB0aGF0IHRoZSBkb2N1bWVudCdzIGA8dGl0bGU+YCBhbmQgYDxtZXRhIG5hbWU9XCJkZXNjcmlwdGlvblwiPmBcbiAqIHRhZ3MgYXJlIHVwZGF0ZWQgb25seSB3aGVuIHRoZSBzZXJ2aWNlIGlzIGZ1bGx5IHJlYWR5IGFuZCB3aXRoIHRoZSBtb3N0IHJlY2VudCByb3V0ZSBoYXNoLFxuICogcHJldmVudGluZyByYWNlIGNvbmRpdGlvbnMgb24gc2xvdyBuZXR3b3JrIGNvbm5lY3Rpb25zLlxuICpcbiAqIFRoaXMgY2xhc3MgZGVtb25zdHJhdGVzIHRoZSB1c2Ugb2YgYXN5bmNocm9ub3VzIGluaXRpYWxpemF0aW9uIChgaW5pdEFzeW5jYCksIHJlYWN0aXZlIGNvbmZpZyBob29rcyAoYGFmdGVyU2V0SXNSZWFkeWApLFxuICogYW5kIHByaXZhdGUgY2xhc3MgZmllbGRzIHRvIG1hbmFnZSBpbnRlcm5hbCBzdGF0ZSBhbmQgZW5zdXJlIHJvYnVzdCBiZWhhdmlvci5cbiAqXG4gKiBAY2xhc3MgUG9ydGFsLnNlcnZpY2UuU2VvXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKiBAc2VlIFBvcnRhbC52aWV3LlZpZXdwb3J0Q29udHJvbGxlclxuICovXG5jbGFzcyBTZW8gZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5zZXJ2aWNlLlNlbydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnNlcnZpY2UuU2VvJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgbW9zdCByZWNlbnQgcm91dGUgaGFzaCByZWNlaXZlZCBmcm9tIGBvblJvdXRlQ2hhbmdlZCgpYC5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gcHJvY2VzcyBhIHBlbmRpbmcgcm91dGUgdXBkYXRlIGlmIHRoZSBzZXJ2aWNlIGJlY29tZXMgcmVhZHkgYWZ0ZXIgYSByb3V0ZSBjaGFuZ2Ugb2NjdXJyZWQuXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9ICNsYXN0Um91dGVIYXNoPW51bGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNsYXN0Um91dGVIYXNoID0gbnVsbFxuICAgIC8qKlxuICAgICAqIENhY2hlcyB0aGUgU0VPIG1ldGFkYXRhIGZldGNoZWQgZnJvbSBgYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvc2VvLmpzb25gLlxuICAgICAqIFRoaXMgb2JqZWN0IG1hcHMgcm91dGUgaGFzaCBzdHJpbmdzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgdGl0bGUgYW5kIGRlc2NyaXB0aW9uLlxuICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSAjbWV0YWRhdGE9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI21ldGFkYXRhID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogSG9vayB0aGF0IGZpcmVzIGFmdGVyIHRoZSBgaXNSZWFkeWAgY29uZmlnIGNoYW5nZXMuIElmIHRoZSBzZXJ2aWNlIGJlY29tZXMgcmVhZHkgKGB2YWx1ZWAgaXMgdHJ1ZSlcbiAgICAgKiBhbmQgdGhlcmUncyBhIHBlbmRpbmcgcm91dGUgaGFzaCAoYCNsYXN0Um91dGVIYXNoYCBpcyBub3QgbnVsbCksIGl0IHRyaWdnZXJzIGFuIHVwZGF0ZVxuICAgICAqIG9mIHRoZSBkb2N1bWVudCBoZWFkIHdpdGggdGhlIG1ldGFkYXRhIGZvciB0aGF0IHJvdXRlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYGlzUmVhZHlgIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGBpc1JlYWR5YCBjb25maWcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNSZWFkeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuI2xhc3RSb3V0ZUhhc2gpIHtcbiAgICAgICAgICAgIHRoaXMuI3VwZGF0ZURvY3VtZW50SGVhZElmTmVlZGVkKHRoaXMuI2xhc3RSb3V0ZUhhc2gpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIFNFTyBtZXRhZGF0YSAodGl0bGUgYW5kIGRlc2NyaXB0aW9uKSBmb3IgYSBnaXZlbiByb3V0ZSBoYXNoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb3V0ZSBUaGUgcm91dGUgaGFzaCBzdHJpbmcgKGUuZy4sICcvaG9tZScsICcvYmxvZycpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYHRpdGxlYCBhbmQgYGRlc2NyaXB0aW9uYCBmb3IgdGhlIHJvdXRlLCBvciBgbnVsbGAgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGdldE1ldGFkYXRhKHJvdXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YT8uW3JvdXRlXSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgaW5pdGlhbGl6ZXMgdGhlIFNFTyBzZXJ2aWNlIGJ5IGZldGNoaW5nIHRoZSBgc2VvLmpzb25gIGZpbGUuXG4gICAgICogVGhpcyBtZXRob2Qgc2ltdWxhdGVzIGFuIEFQSSBjYWxsIHRvIHJldHJpZXZlIFNFTyBkYXRhLCBtYWtpbmcgdGhlIHNlcnZpY2UgcmVhZHlcbiAgICAgKiB0byBwcm92aWRlIG1ldGFkYXRhLiBJdCBlbnN1cmVzIHRoYXQgdGhlIHNlcnZpY2UgaXMgZnVsbHkgbG9hZGVkIGJlZm9yZSBwcm9jZXNzaW5nXG4gICAgICogYW55IHJvdXRlLXJlbGF0ZWQgZG9jdW1lbnQgaGVhZCB1cGRhdGVzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtZXRhZGF0YSBoYXMgYmVlbiBmZXRjaGVkIGFuZCBwYXJzZWQuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdEFzeW5jKCkge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0QXN5bmMoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnLi4vLi4vYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvc2VvLmpzb24nKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3Igd2l0aCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNtZXRhZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIFNFTyBtZXRhZGF0YTonLCBlcnJvcilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSB0aGUgYFZpZXdwb3J0Q29udHJvbGxlcmAgd2hlbiB0aGUgYXBwbGljYXRpb24ncyByb3V0ZSBjaGFuZ2VzLlxuICAgICAqIFRoaXMgbWV0aG9kIHN0b3JlcyB0aGUgbmV3IHJvdXRlIGhhc2ggYW5kIGF0dGVtcHRzIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQgaGVhZC5cbiAgICAgKiBJZiB0aGUgc2VydmljZSBpcyBub3QgeWV0IHJlYWR5IChpLmUuLCBgaW5pdEFzeW5jYCBpcyBzdGlsbCBydW5uaW5nKSwgdGhlIHVwZGF0ZVxuICAgICAqIGlzIGRlZmVycmVkIHVudGlsIGBpc1JlYWR5YCBiZWNvbWVzIHRydWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhc2ggVGhlIG5ldyByb3V0ZSBoYXNoIHN0cmluZy5cbiAgICAgKi9cbiAgICBvblJvdXRlQ2hhbmdlZChoYXNoKSB7XG4gICAgICAgIHRoaXMuI2xhc3RSb3V0ZUhhc2ggPSBoYXNoO1xuICAgICAgICB0aGlzLiN1cGRhdGVEb2N1bWVudEhlYWRJZk5lZWRlZChoYXNoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJpdmF0ZSBtZXRob2QgY2FsbHMgdGhlIGBEb2N1bWVudEhlYWRgIG1haW4gdGhyZWFkIGFkZG9uIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQnc1xuICAgICAqIHRpdGxlIGFuZCBtZXRhLWRlc2NyaXB0aW9uIGZvciBTRU8gcHVycG9zZXMuIEl0IGlzIHRoZSBhY3R1YWwgbWVjaGFuaXNtIGZvciBhcHBseWluZ1xuICAgICAqIHRoZSBTRU8gY2hhbmdlcyB0byB0aGUgYnJvd3NlcidzIERPTS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBjb250YWluaW5nIGBkZXNjcmlwdGlvbmAgYW5kIGB0aXRsZWAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kZXNjcmlwdGlvbiBUaGUgbmV3IG1ldGEtZGVzY3JpcHRpb24gZm9yIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnRpdGxlIFRoZSBuZXcgdGl0bGUgZm9yIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jICN1cGRhdGVEb2N1bWVudEhlYWQoe2Rlc2NyaXB0aW9uLCB0aXRsZX0pIHtcbiAgICAgICAgbGV0IHt3aW5kb3dJZH0gICA9IHRoaXMsXG4gICAgICAgICAgICBEb2N1bWVudEhlYWQgPSBhd2FpdCBOZW8uY3VycmVudFdvcmtlci5nZXRBZGRvbignRG9jdW1lbnRIZWFkJywgd2luZG93SWQpO1xuXG4gICAgICAgIGF3YWl0IERvY3VtZW50SGVhZC51cGRhdGUoe2Rlc2NyaXB0aW9uLCB0aXRsZSwgd2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcHJpdmF0ZSBoZWxwZXIgbWV0aG9kIHRoYXQgY29uZGl0aW9uYWxseSB1cGRhdGVzIHRoZSBkb2N1bWVudCBoZWFkLlxuICAgICAqIEl0IGNoZWNrcyBpZiB0aGUgc2VydmljZSBpcyBgaXNSZWFkeWAgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmV0cmlldmUgbWV0YWRhdGFcbiAgICAgKiBhbmQgY2FsbCBgI3VwZGF0ZURvY3VtZW50SGVhZGAuIElmIGFuIHVwZGF0ZSBvY2N1cnMsIGl0IGNsZWFycyBgI2xhc3RSb3V0ZUhhc2hgLlxuICAgICAqIFRoaXMgcHJldmVudHMgbXVsdGlwbGUgdXBkYXRlcyBmb3IgdGhlIHNhbWUgcm91dGUgaWYgYG9uUm91dGVDaGFuZ2VkYCBpcyBjYWxsZWRcbiAgICAgKiBiZWZvcmUgYGluaXRBc3luY2AgY29tcGxldGVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoIFRoZSByb3V0ZSBoYXNoIGZvciB3aGljaCB0byB1cGRhdGUgdGhlIGRvY3VtZW50IGhlYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjdXBkYXRlRG9jdW1lbnRIZWFkSWZOZWVkZWQoaGFzaCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSBtZS5nZXRNZXRhZGF0YShoYXNoKTtcblxuICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgbWUuI3VwZGF0ZURvY3VtZW50SGVhZChtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgbWUuI2xhc3RSb3V0ZUhhc2ggPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNlbyk7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi8uLi8uLi9zcmMvdG9vbGJhci9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3LkhlYWRlclRvb2xiYXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBIZWFkZXJUb29sYmFyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5IZWFkZXJUb29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5IZWFkZXJUb29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydwb3J0YWwtaGVhZGVyLXRvb2xiYXInXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNsczogWydwb3J0YWwtaGVhZGVyLXRvb2xiYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgIHVpICAgOiAnZ2hvc3QnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgY2xzICAgICA6IFsnbG9nbyddLFxuICAgICAgICAgICAgaWNvbkNscyA6ICduZW8tbG9nby1ibHVlJyxcbiAgICAgICAgICAgIG1pbldpZHRoOiA2MCxcbiAgICAgICAgICAgIHJvdXRlICAgOiAnL2hvbWUnLFxuICAgICAgICAgICAgdGV4dCAgICA6ICdOZW8ubWpzJ1xuICAgICAgICB9LCAnLT4nLCB7XG4gICAgICAgICAgICB0ZXh0IDogJ0xlYXJuJyxcbiAgICAgICAgICAgIHJvdXRlOiAnL2xlYXJuJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0ZXh0ICAgICA6ICdCbG9nJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ2Jsb2ctaGVhZGVyLWJ1dHRvbicsXG4gICAgICAgICAgICByb3V0ZSAgICA6ICcvYmxvZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdGV4dCA6ICdFeGFtcGxlcycsXG4gICAgICAgICAgICByb3V0ZTogJy9leGFtcGxlcydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdGV4dCA6ICdTZXJ2aWNlcycsXG4gICAgICAgICAgICByb3V0ZTogJy9zZXJ2aWNlcydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbnR5cGUgICAgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgIGxheW91dCAgIDogJ2hib3gnLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnaGVhZGVyLXNvY2lhbC1pY29ucycsXG5cbiAgICAgICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgICB1aSAgIDogJ2dob3N0J1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhLWJyYW5kcyBmYS1naXRodWInLFxuICAgICAgICAgICAgICAgIHVybCAgICA6ICdodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lbycsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgICA6ICdHaXRIdWInLFxuICAgICAgICAgICAgICAgICAgICBzaG93RGVsYXk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVEZWxheTogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEtYnJhbmRzIGZhLXNsYWNrJyxcbiAgICAgICAgICAgICAgICB1cmwgICAgOiAnaHR0cHM6Ly9qb2luLnNsYWNrLmNvbS90L25lb21qcy9zaGFyZWRfaW52aXRlL3p0LTZjNTB1ZWV1LTNFMX5NNFQ5eGtObmJ+TV9wckVFT0EnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCAgICAgOiAnSm9pbiBTbGFjaycsXG4gICAgICAgICAgICAgICAgICAgIHNob3dEZWxheTogMCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZURlbGF5OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYS1icmFuZHMgZmEtZGlzY29yZCcsXG4gICAgICAgICAgICAgICAgdXJsICAgIDogJ2h0dHBzOi8vZGlzY29yZC5nZy82cDhwYVBxJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgICAgIDogJ0pvaW4gRGlzY29yZCcsXG4gICAgICAgICAgICAgICAgICAgIHNob3dEZWxheTogMCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZURlbGF5OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEhlYWRlclRvb2xiYXIpO1xuIiwiaW1wb3J0IEJhc2VWaWV3cG9ydCAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyc7XG5pbXBvcnQgQ29udGFpbmVyICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IEhlYWRlclRvb2xiYXIgICAgICAgICBmcm9tICcuL0hlYWRlclRvb2xiYXIubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWaWV3cG9ydENvbnRyb2xsZXIgICAgZnJvbSAnLi9WaWV3cG9ydENvbnRyb2xsZXIubWpzJztcbmltcG9ydCBWaWV3cG9ydFN0YXRlUHJvdmlkZXIgZnJvbSAnLi9WaWV3cG9ydFN0YXRlUHJvdmlkZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcuVmlld3BvcnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqL1xuY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBCYXNlVmlld3BvcnQge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3Igc2l6ZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBzaXplcz1bJ2xhcmdlJywnbWVkaXVtJywnc21hbGwnLCd4LXNtYWxsJyxudWxsXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHNpemVzID0gWydsYXJnZScsICdtZWRpdW0nLCAnc21hbGwnLCAneC1zbWFsbCcsIG51bGxdXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3LlZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5WaWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR9IGNvbnRyb2xsZXI9Vmlld3BvcnRDb250cm9sbGVyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbGxlcjogVmlld3BvcnRDb250cm9sbGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOid2Ym94JyxhbGlnbjonc3RyZXRjaCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBIZWFkZXJUb29sYmFyLFxuICAgICAgICAgICAgZmxleCAgOiAnbm9uZSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBDb250YWluZXIsXG4gICAgICAgICAgICBjbHMgICAgICA6IFsncG9ydGFsLW1haW4tY29udGVudCddLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnbWFpbi1jb250ZW50JyxcblxuICAgICAgICAgICAgLy8gVGhlIGxheW91dCB3aWxsIGdldCBhc3NpZ25lZCBpbnNpZGUgVmlld3BvcnRDb250cm9sbGVyXG5cbiAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAge21vZHVsZTogKCkgPT4gaW1wb3J0KCcuL2hvbWUvTWFpbkNvbnRhaW5lci5tanMnKX0sXG4gICAgICAgICAgICAgICAge21vZHVsZTogKCkgPT4gaW1wb3J0KCcuL2xlYXJuL01haW5Db250YWluZXIubWpzJyl9LFxuICAgICAgICAgICAgICAgIHttb2R1bGU6ICgpID0+IGltcG9ydCgnLi9ibG9nL0NvbnRhaW5lci5tanMnKX0sXG4gICAgICAgICAgICAgICAge21vZHVsZTogKCkgPT4gaW1wb3J0KCcuL3NlcnZpY2VzL0NvbXBvbmVudC5tanMnKX0sXG4gICAgICAgICAgICAgICAge21vZHVsZTogKCkgPT4gaW1wb3J0KCcuL2V4YW1wbGVzL1RhYkNvbnRhaW5lci5tanMnKX0sXG4gICAgICAgICAgICAgICAge21vZHVsZTogKCkgPT4gaW1wb3J0KCcuL2Fib3V0L0NvbnRhaW5lci5tanMnKX0sXG4gICAgICAgICAgICAgICAge21vZHVsZTogKCkgPT4gaW1wb3J0KCcuLi8uLi8uLi9kb2NzL2FwcC92aWV3L01haW5Db250YWluZXIubWpzJyl9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1dLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9uaXRvclNpemU9dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vbml0b3JTaXplOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVzIGFyZTogbGFyZ2UsIG1lZGl1bSwgc21hbGwsIHhTbWFsbFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc2l6ZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNpemVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnN0YXRlLlByb3ZpZGVyfSBzdGF0ZVByb3ZpZGVyPVZpZXdwb3J0U3RhdGVQcm92aWRlclxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlUHJvdmlkZXI6IFZpZXdwb3J0U3RhdGVQcm92aWRlclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUub24oJ3Jlc2l6ZScsIG1lLm9uUmVzaXplLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNpemUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNpemUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAncG9ydGFsLXNpemUtJyArIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZCggICBjbHMsICdwb3J0YWwtc2l6ZS0nICsgdmFsdWUpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICBtZS5zdGF0ZVByb3ZpZGVyLnNldERhdGEoe3NpemU6IHZhbHVlfSk7XG5cbiAgICAgICAgICAgIG1lLmNvbnRyb2xsZXIuc2l6ZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzaXplIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnc2l6ZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTaXplKHdpZHRoKSB7XG4gICAgICAgIGlmICh3aWR0aCA8PSAgNjQwKSByZXR1cm4gJ3gtc21hbGwnO1xuICAgICAgICBpZiAod2lkdGggPD0gMTAyNCkgcmV0dXJuICdzbWFsbCc7XG4gICAgICAgIGlmICh3aWR0aCA8PSAxMjk2KSByZXR1cm4gJ21lZGl1bSc7XG4gICAgICAgIHJldHVybiAnbGFyZ2UnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJlc2l6ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlkID09PSBkYXRhLmlkKSB7XG4gICAgICAgICAgICBtZS5zaXplID0gbWUuZ2V0U2l6ZShkYXRhLmJvcmRlckJveFNpemUuaW5saW5lU2l6ZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmlld3BvcnQpO1xuIiwiaW1wb3J0IENvbnRyb2xsZXIgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IEN1YmVMYXlvdXQgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9sYXlvdXQvQ3ViZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgU2VvU2VydmljZSAgICAgICAgZnJvbSAnLi4vc2VydmljZS9TZW8ubWpzJztcbmltcG9ydCB7Z2V0U2VhcmNoUGFyYW1zfSBmcm9tICcuLi9VdGlsLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIG1haW4gY29udHJvbGxlciBmb3IgdGhlIHBvcnRhbCdzIHZpZXdwb3J0LlxuICpcbiAqIFRoaXMgY29udHJvbGxlciBpcyB0aGUgY2VudHJhbCBodWIgZm9yIHRoZSBwb3J0YWwgYXBwbGljYXRpb24uIEl0IGlzIHJlc3BvbnNpYmxlIGZvcjpcbiAqIC0gKipUb3AtTGV2ZWwgUm91dGluZzoqKiBJdCB1c2VzIHRoZSBgcm91dGVzYCBjb25maWcgdG8gbWFwIHRoZSBtYWluIFVSTCBoYXNoIGNoYW5nZXMgKGUuZy4sIC9ob21lLCAvbGVhcm4sIC9ibG9nKSB0byBzcGVjaWZpYyBtZXRob2RzLCB3aGljaCBpbiB0dXJuIGNvbnRyb2wgd2hpY2ggbWFpbiB2aWV3IGlzIGFjdGl2ZS4gSXQncyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IHdoaWxlIHRoaXMgY29udHJvbGxlciBoYW5kbGVzIHRoZSB0b3AtbGV2ZWwgbmF2aWdhdGlvbiwgY2hpbGQgdmlld3MgY2FuIGltcGxlbWVudCB0aGVpciBvd24gbmVzdGVkIHJvdXRpbmcgbG9naWMgKHNlZSBgUG9ydGFsLnZpZXcubGVhcm4uTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJgIGZvciBhbiBleGFtcGxlKS5cbiAqIC0gKipMYXlvdXQgTWFuYWdlbWVudDoqKiBJdCBtYW5hZ2VzIHRoZSBtYWluIGNvbnRlbnQgYXJlYSdzIGxheW91dCwgaW5jbHVkaW5nIHRoZSBcIm1peGVkXCIgbW9kZSB3aGljaCB1c2VzIGEgQ3ViZUxheW91dCBmb3Igc2xpY2sgdHJhbnNpdGlvbnMgYmV0d2VlbiB2aWV3cy5cbiAqIC0gKipTRU86KiogSXQgY29vcmRpbmF0ZXMgd2l0aCB0aGUgYERvY3VtZW50SGVhZGAgbWFpbiB0aHJlYWQgYWRkb24gdG8gdXBkYXRlIHRoZSBkb2N1bWVudCdzIHRpdGxlIGFuZCBtZXRhIHRhZ3Mgb24gZWFjaCByb3V0ZSBjaGFuZ2UsIGVuc3VyaW5nIHRoZSBhcHBsaWNhdGlvbiBpcyBTRU8tZnJpZW5kbHkuXG4gKiAtICoqTXVsdGktV2luZG93IENvb3JkaW5hdGlvbjoqKiBJdCBoYW5kbGVzIHRoZSBjb25uZWN0aW9uIGFuZCBkaXNjb25uZWN0aW9uIG9mIGNoaWxkIHdpbmRvd3MsIHN1Y2ggYXMgdGhlIGxpdmUgY29kZSBleGFtcGxlIHByZXZpZXdzLlxuICpcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5WaWV3cG9ydENvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBWaWV3cG9ydENvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIG1haW5Db250ZW50TGF5b3V0XG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IG1haW5Db250ZW50TGF5b3V0cz1bJ2NhcmQnLCdjdWJlJywnbWl4ZWQnXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG1haW5Db250ZW50TGF5b3V0cyA9IFsnY2FyZCcsICdjdWJlJywgJ21peGVkJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcuVmlld3BvcnRDb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5WaWV3cG9ydENvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndmlld3BvcnQtY29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd2aWV3cG9ydC1jb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBhY3RpdmVJbmRleF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZUluZGV4XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBkZWZhdWx0SGFzaD0nL2hvbWUnXG4gICAgICAgICAqL1xuICAgICAgICBkZWZhdWx0SGFzaDogJy9ob21lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbWFpbkNvbnRlbnRMYXlvdXRfPSdjYXJkJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1haW5Db250ZW50TGF5b3V0XzogJ2NhcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByb3V0ZXNcbiAgICAgICAgICovXG4gICAgICAgIHJvdXRlczoge1xuICAgICAgICAgICAgJy9hYm91dC11cycgICAgICAgICA6ICdvbkFib3V0VXNSb3V0ZScsXG4gICAgICAgICAgICAnL2Jsb2cnICAgICAgICAgICAgIDogJ29uQmxvZ1JvdXRlJyxcbiAgICAgICAgICAgICcvZG9jcycgICAgICAgICAgICAgOiAnb25Eb2NzUm91dGUnLFxuICAgICAgICAgICAgJy9leGFtcGxlcycgICAgICAgICA6ICdvbkV4YW1wbGVzUm91dGUnLFxuICAgICAgICAgICAgJy9leGFtcGxlcy97aXRlbUlkfSc6ICdvbkV4YW1wbGVzUm91dGUnLFxuICAgICAgICAgICAgJy9ob21lJyAgICAgICAgICAgICA6ICdvbkhvbWVSb3V0ZScsXG4gICAgICAgICAgICAnL2xlYXJuJyAgICAgICAgICAgIDogJ29uTGVhcm5Sb3V0ZScsXG4gICAgICAgICAgICAnL2xlYXJuL3sqaXRlbUlkfScgIDogJ29uTGVhcm5Sb3V0ZScsXG4gICAgICAgICAgICAnL3NlcnZpY2VzJyAgICAgICAgIDogJ29uU2VydmljZXNSb3V0ZSdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlcyBhcmU6IGxhcmdlLCBtZWRpdW0sIHNtYWxsLCB4U21hbGxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNpemVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaXplXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjb25uZWN0ZWRBcHBzPVtdXG4gICAgICovXG4gICAgY29ubmVjdGVkQXBwcyA9IFtdXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZmxhZyB0byBzdG9yZSB0aGUgYW1vdW50IG9mIG1haW4gbmF2aWdhdGlvbiBjaGFuZ2VzXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSAjdHJhbnNpdGlvbklkPTBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICN0cmFuc2l0aW9uSWQgPSAwXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNpemUgYWN0aXZlSW5kZXggZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWN0aXZlSW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmIHRoaXMudXBkYXRlSGVhZGVyVG9vbGJhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYWluQ29udGVudExheW91dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYWluQ29udGVudExheW91dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthY3RpdmVJbmRleCwgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICBjb250YWluZXIgICAgICAgICAgICAgICA9IG1lLmNvbXBvbmVudC5nZXRJdGVtKCdtYWluLWNvbnRlbnQnKTsgLy8gaGFwcGVucyBiZWZvcmUgaW5zdGFudGlhdGlvblxuXG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gbm90IHR1cm4gdGhpcyBtZXRob2QgaXRzZWxmIGludG8gYXN5bmMgYW5kIGF3YWl0IHRoZSBhZGRvbiByZXNwb25zZSxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjb250YWluZXIgbmVlZHMgaXRzIGxheW91dCByaWdodCBhd2F5XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5Mb2NhbFN0b3JhZ2UucmVhZExvY2FsU3RvcmFnZUl0ZW0oe1xuICAgICAgICAgICAgICAgIGtleTogJ21haW5Db250ZW50TGF5b3V0JyxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgfSkudGhlbigoe3ZhbHVlfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ2NhcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1haW5Db250ZW50TGF5b3V0ID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnY3ViZScpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5sYXlvdXQgPSB7bnR5cGU6ICdjdWJlJywgYWN0aXZlSW5kZXgsIGZpdENvbnRhaW5lcjogdHJ1ZSwgaGlkZUluYWN0aXZlQ2FyZHNPbkRlc3Ryb3k6IHRydWV9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIubGF5b3V0ID0ge250eXBlOiAnY2FyZCcsIGFjdGl2ZUluZGV4fVxuICAgICAgICB9XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uTG9jYWxTdG9yYWdlLnVwZGF0ZUxvY2FsU3RvcmFnZUl0ZW0oe2tleTogJ21haW5Db250ZW50TGF5b3V0JywgdmFsdWUsIHdpbmRvd0lkfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNpemUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNpemUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMudXBkYXRlSGVhZGVyVG9vbGJhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgbWFpbkNvbnRlbnRMYXlvdXQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNYWluQ29udGVudExheW91dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ21haW5Db250ZW50TGF5b3V0JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm91dGUgaGFuZGxlcnMgKGUuZy4sIG9uQWJvdXRVc1JvdXRlLCBvbkJsb2dSb3V0ZSkgYXJlIG5vdyBvbmx5IHJlc3BvbnNpYmxlIGZvclxuICAgICAqIHNldHRpbmcgdGhlIG1haW4gY29udGVudCBpbmRleC4gVGhlIGxvZ2ljIGZvciB1cGRhdGluZyB0aGUgZG9jdW1lbnQgaGVhZCBpcyBjZW50cmFsaXplZFxuICAgICAqIGluIHRoZSBvbkhhc2hDaGFuZ2UgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkFib3V0VXNSb3V0ZShwYXJhbXMsIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnNldE1haW5Db250ZW50SW5kZXgoNSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIGFzeW5jIG9uQXBwQ29ubmVjdChkYXRhKSB7XG4gICAgICAgIGxldCB7YXBwTmFtZSwgd2luZG93SWR9ID0gZGF0YSxcbiAgICAgICAgICAgIGFwcCAgICAgICAgICAgICAgICAgPSBOZW8uYXBwc1thcHBOYW1lXSxcbiAgICAgICAgICAgIG1haW5WaWV3ICAgICAgICAgICAgPSBhcHAubWFpblZpZXc7XG5cbiAgICAgICAgaWYgKGFwcE5hbWUgPT09ICdQb3J0YWxQcmV2aWV3Jykge1xuICAgICAgICAgICAgbGV0IHNlYXJjaFN0cmluZyAgICA9IGF3YWl0IE5lby5NYWluLmdldEJ5UGF0aCh7cGF0aDogJ2xvY2F0aW9uLnNlYXJjaCcsIHdpbmRvd0lkfSksXG4gICAgICAgICAgICAgICAgbGl2ZVByZXZpZXdJZCAgID0gZ2V0U2VhcmNoUGFyYW1zKHNlYXJjaFN0cmluZykuaWQsXG4gICAgICAgICAgICAgICAgbGl2ZVByZXZpZXcgICAgID0gTmVvLmdldENvbXBvbmVudChsaXZlUHJldmlld0lkKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VDb250YWluZXIgPSBsaXZlUHJldmlldy5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKSxcbiAgICAgICAgICAgICAgICB7dGFiQ29udGFpbmVyfSAgPSBsaXZlUHJldmlldyxcbiAgICAgICAgICAgICAgICBzb3VyY2VWaWV3ICAgICAgPSBzb3VyY2VDb250YWluZXIucmVtb3ZlQXQoMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICBsaXZlUHJldmlldy5wcmV2aWV3Q29udGFpbmVyID0gbWFpblZpZXc7XG4gICAgICAgICAgICBtYWluVmlldy5hZGQoc291cmNlVmlldyk7XG5cbiAgICAgICAgICAgIHRhYkNvbnRhaW5lci5hY3RpdmVJbmRleCA9IDA7IC8vIHN3aXRjaCB0byB0aGUgc291cmNlIHZpZXdcblxuICAgICAgICAgICAgdGFiQ29udGFpbmVyLmdldFRhYkF0SW5kZXgoMSkuZGlzYWJsZWQgPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIGFzeW5jIG9uQXBwRGlzY29ubmVjdChkYXRhKSB7XG4gICAgICAgIGxldCB7YXBwTmFtZSwgd2luZG93SWR9ID0gZGF0YSxcbiAgICAgICAgICAgIGFwcCAgICAgICAgICAgICAgICAgPSBOZW8uYXBwc1thcHBOYW1lXSxcbiAgICAgICAgICAgIG1haW5WaWV3ICAgICAgICAgICAgPSBhcHAubWFpblZpZXc7XG5cbiAgICAgICAgLy8gQ2xvc2luZyBhIGNvZGUgcHJldmlldyB3aW5kb3cgbmVlZHMgdG8gZHJvcCB0aGUgcHJldmlldyBiYWNrIGludG8gdGhlIHJlbGF0ZWQgbWFpbiBhcHBcbiAgICAgICAgaWYgKGFwcE5hbWUgPT09ICdQb3J0YWxQcmV2aWV3Jykge1xuICAgICAgICAgICAgbGV0IHNlYXJjaFN0cmluZyAgICA9IGF3YWl0IE5lby5NYWluLmdldEJ5UGF0aCh7cGF0aDogJ2xvY2F0aW9uLnNlYXJjaCcsIHdpbmRvd0lkfSksXG4gICAgICAgICAgICAgICAgbGl2ZVByZXZpZXdJZCAgID0gZ2V0U2VhcmNoUGFyYW1zKHNlYXJjaFN0cmluZykuaWQsXG4gICAgICAgICAgICAgICAgbGl2ZVByZXZpZXcgICAgID0gTmVvLmdldENvbXBvbmVudChsaXZlUHJldmlld0lkKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VDb250YWluZXIgPSBsaXZlUHJldmlldy5nZXRSZWZlcmVuY2UoJ3ByZXZpZXcnKSxcbiAgICAgICAgICAgICAgICB7dGFiQ29udGFpbmVyfSAgPSBsaXZlUHJldmlldyxcbiAgICAgICAgICAgICAgICBzb3VyY2VWaWV3ICAgICAgPSBtYWluVmlldy5yZW1vdmVBdCgwLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGxpdmVQcmV2aWV3LnByZXZpZXdDb250YWluZXIgPSBudWxsO1xuICAgICAgICAgICAgc291cmNlQ29udGFpbmVyLmFkZChzb3VyY2VWaWV3KTtcblxuICAgICAgICAgICAgbGl2ZVByZXZpZXcuZGlzYWJsZVJ1blNvdXJjZSA9IHRydWU7IC8vIHdpbGwgZ2V0IHJlc2V0IGFmdGVyIHRoZSBuZXh0IGFjdGl2ZUluZGV4IGNoYW5nZSAoYXN5bmMpXG4gICAgICAgICAgICB0YWJDb250YWluZXIuYWN0aXZlSW5kZXggPSAxOyAgICAgICAgLy8gc3dpdGNoIHRvIHRoZSBzb3VyY2Ugdmlld1xuXG4gICAgICAgICAgICBsaXZlUHJldmlldy5nZXRSZWZlcmVuY2UoJ3BvcG91dC13aW5kb3ctYnV0dG9uJykuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRhYkNvbnRhaW5lci5nZXRUYWJBdEluZGV4KDEpLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9zZSBwb3B1cCB3aW5kb3dzIHdoZW4gY2xvc2luZyBvciByZWxvYWRpbmcgdGhlIG1haW4gd2luZG93XG4gICAgICAgIGVsc2UgaWYgKGFwcE5hbWUgPT09ICdQb3J0YWwnKSB7XG4gICAgICAgICAgICBOZW8uTWFpbi53aW5kb3dDbG9zZUFsbCh7d2luZG93SWR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gcmVjb3Jkc1xuICAgICAqL1xuICAgIG9uQmxvZ1Bvc3RTdG9yZUxvYWQocmVjb3Jkcykge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgnYmxvZy1oZWFkZXItYnV0dG9uJykuYmFkZ2VUZXh0ID0gcmVjb3Jkcy5sZW5ndGggKyAnJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkJsb2dSb3V0ZShwYXJhbXMsIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnNldE1haW5Db250ZW50SW5kZXgoMilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQmxvZ1NlYXJjaEZpZWxkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5nZXRSZWZlcmVuY2UoJ2Jsb2ctbGlzdCcpLmZpbHRlckl0ZW1zKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5vbih7XG4gICAgICAgICAgICBjb25uZWN0ICAgOiBtZS5vbkFwcENvbm5lY3QsXG4gICAgICAgICAgICBkaXNjb25uZWN0OiBtZS5vbkFwcERpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkRvY3NSb3V0ZShwYXJhbXMsIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnNldE1haW5Db250ZW50SW5kZXgoNilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICovXG4gICAgb25FeGFtcGxlc1JvdXRlKHBhcmFtcywgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0TWFpbkNvbnRlbnRJbmRleCg0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGNlbnRyYWwgaGFuZGxlciBmb3IgYWxsIHJvdXRlIGNoYW5nZXMuIEl0IGlzIG5vdyByZXNwb25zaWJsZSBmb3IgZGVsZWdhdGluZ1xuICAgICAqIHRoZSBkb2N1bWVudCdzIGhlYWQgbWV0YWRhdGEgKHRpdGxlIGFuZCBkZXNjcmlwdGlvbikgdXBkYXRlcyB0byB0aGUgYFBvcnRhbC5zZXJ2aWNlLlNlb2Agc2VydmljZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgICAgICAgICAgICAgICBUaGUgbmV3IHJvdXRlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUuaGFzaFN0cmluZyAgICBUaGUgbmV3IGhhc2ggc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZSAgICAgICAgICAgIFRoZSBwcmV2aW91cyByb3V0ZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlLmhhc2hTdHJpbmcgVGhlIHByZXZpb3VzIGhhc2ggc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG9uSGFzaENoYW5nZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgYXdhaXQgc3VwZXIub25IYXNoQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIFNlb1NlcnZpY2Uub25Sb3V0ZUNoYW5nZWQodmFsdWU/Lmhhc2hTdHJpbmcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uSG9tZVJvdXRlKHBhcmFtcywgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0TWFpbkNvbnRlbnRJbmRleCgwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkxlYXJuUm91dGUocGFyYW1zLCB2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRNYWluQ29udGVudEluZGV4KDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uU2VydmljZXNSb3V0ZShwYXJhbXMsIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnNldE1haW5Db250ZW50SW5kZXgoMylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBvcmNoZXN0cmF0ZXMgdGhlIHZpc3VhbCB0cmFuc2l0aW9uIGJldHdlZW4gdGhlIG1haW4gY29udGVudCBjYXJkcy5cbiAgICAgKiBJdCB1c2VzIGEgXCJtaXhlZFwiIGxheW91dCBtb2RlLCB3aGljaCB0ZW1wb3JhcmlseSBzd2l0Y2hlcyB0byBhIEN1YmVMYXlvdXQgZm9yXG4gICAgICogYSAzRCB0cmFuc2l0aW9uIGVmZmVjdCwgYW5kIHRoZW4gYmFjayB0byBhIENhcmRMYXlvdXQgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqL1xuICAgIGFzeW5jIHNldE1haW5Db250ZW50SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthY3RpdmVJbmRleCwgbWFpbkNvbnRlbnRMYXlvdXR9ID0gbWUsXG4gICAgICAgICAgICBjb250YWluZXIgICAgICAgICAgICAgICAgICAgICAgICA9IG1lLmdldFJlZmVyZW5jZSgnbWFpbi1jb250ZW50JyksXG4gICAgICAgICAgICB1cGRhdGVMYXlvdXQgICAgICAgICAgICAgICAgICAgICA9IHRydWUsXG4gICAgICAgICAgICB0cmFuc2l0aW9uSWQ7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSBhY3RpdmVJbmRleCkge1xuICAgICAgICAgICAgbWUuYWN0aXZlSW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG1haW5Db250ZW50TGF5b3V0ID09PSAnbWl4ZWQnICYmXG4gICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgaW5pdGlhbCBsYXlvdXQtc3dpdGNoLCBzaW5jZSB3ZSBkbyBub3QgbmVlZCBhIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICBOZW8uaXNOdW1iZXIoYWN0aXZlSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBza2lwIHRoZSBsYXlvdXQgc3dpdGNoIGluIGNhc2UgdGhlIGluZGV4ID49IDYsIHNpbmNlIGEgY3ViZSBvbmx5IGhhcyA2IGZhY2VzXG4gICAgICAgICAgICAgICAgaW5kZXggPCA2ICYmXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBza2lwIHRoZSBsYXlvdXQgc3dpdGNoIGluIGNhc2Ugd2UgbmF2aWdhdGUgYmFjayBmcm9tIGEgbm9uLWN1YmUgaXRlbVxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4IDwgNlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWUuI3RyYW5zaXRpb25JZCsrO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbklkID0gbWUuI3RyYW5zaXRpb25JZDtcbiAgICAgICAgICAgICAgICB1cGRhdGVMYXlvdXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIGVuYWJsZSBcImZhc3QgY2xpY2tpbmdcIiBvbiBtYWluIG5hdiBpdGVtcyA9PiBkbyBub3QgcmVwbGFjZSBhIGN1YmUgbGF5b3V0IHdpdGggYSBuZXcgaW5zdGFuY2Ugb2YgY3ViZVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIubGF5b3V0Lm50eXBlICE9PSAnbGF5b3V0LWN1YmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbnRhaW5lci5zZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICdjdWJlJywgYWN0aXZlSW5kZXgsIGZpdENvbnRhaW5lcjogdHJ1ZSwgaGlkZUluYWN0aXZlQ2FyZHNPbkRlc3Ryb3k6IHRydWV9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5sYXlvdXQuYWN0aXZlSW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMTEwMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNpdGlvbklkID09PSBtZS4jdHJhbnNpdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbnRhaW5lci5zZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICdjYXJkJywgYWN0aXZlSW5kZXg6IGluZGV4fVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1cGRhdGVMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubGF5b3V0LmFjdGl2ZUluZGV4ID0gaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBEb2N1bWVudEhlYWQgbWFpbiB0aHJlYWQgYWRkb24gdG8gdXBkYXRlIHRoZSBkb2N1bWVudCdzXG4gICAgICogdGl0bGUgYW5kIG1ldGEgZGVzY3JpcHRpb24gZm9yIFNFTyBwdXJwb3Nlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGl0bGVcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVIZWFkZXJUb29sYmFyKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YWN0aXZlSW5kZXgsIHNpemV9ID0gbWU7XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcihhY3RpdmVJbmRleCkgJiYgc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGhlYWRlclNvY2lhbEljb25zID0gbWUuZ2V0UmVmZXJlbmNlKCdoZWFkZXItc29jaWFsLWljb25zJyksXG4gICAgICAgICAgICAgICAge2Nsc30gICAgICAgICAgICAgPSBoZWFkZXJTb2NpYWxJY29ucyxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbCAgICAgICAgICA9IHNpemUgPT09ICd4LXNtYWxsJyxcbiAgICAgICAgICAgICAgICBoaWRkZW4gICAgICAgICAgICA9IGFjdGl2ZUluZGV4ICE9PSAwICYmIHZlcnRpY2FsO1xuXG4gICAgICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnaGlkZS1zaWRlYmFyJywgaGlkZGVuKTtcblxuICAgICAgICAgICAgaWYgKCFoaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnc2VwYXJhdGUtYmFyJywgdmVydGljYWwpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlclNvY2lhbEljb25zLmNscyA9IGNscztcblxuXG4gICAgICAgICAgICBpZiAoaGlkZGVuICYmIHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMDApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlclNvY2lhbEljb25zLmhpZGRlbiA9IGhpZGRlblxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydENvbnRyb2xsZXIpO1xuIiwiaW1wb3J0IFN0YXRlUHJvdmlkZXIgZnJvbSAnLi4vLi4vLi4vc3JjL3N0YXRlL1Byb3ZpZGVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3LlZpZXdwb3J0U3RhdGVQcm92aWRlclxuICogQGV4dGVuZHMgTmVvLnN0YXRlLlByb3ZpZGVyXG4gKi9cbmNsYXNzIFZpZXdwb3J0U3RhdGVQcm92aWRlciBleHRlbmRzIFN0YXRlUHJvdmlkZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcuVmlld3BvcnRTdGF0ZVByb3ZpZGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5WaWV3cG9ydFN0YXRlUHJvdmlkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZhbHVlcyBhcmU6IGxhcmdlLCBtZWRpdW0sIHNtYWxsLCB4U21hbGwsIG51bGxcbiAgICAgICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzaXplXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNpemU6IG51bGxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmlld3BvcnRTdGF0ZVByb3ZpZGVyKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGEgbGFiZWwgd2l0aCBhIHRleHRcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkxhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTGFiZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5MYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5MYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0YWc9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiAnbGFiZWwnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMYWJlbCk7XG4iLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5WaWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5WaWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd2aWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd2aWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgJ25lby1ib2R5LXZpZXdwb3J0JyB0byB0aGUgZG9jdW1lbnQuYm9keVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhcHBseUJvZHlDbHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlCb2R5Q2xzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzdW1pbmcgdGhhdCBhIFZpZXdwb3J0IGlzIHRoZSB0b3AgbGV2ZWwgdmlldyBvZiB5b3VyIGFwcCwgYW5kIHlvdSB3YW50IHRvIG1vdW50IGl0IHJpZ2h0IGF3YXkuXG4gICAgICAgICAqIENvdWxkIGJlIHdpdGhvdXQgYW55IGl0ZW1zLiBVc2UgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdmlld3BvcnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdmlld3BvcnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyBhIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIgYW5kIGZpcmVzIGEgY3VzdG9tIHJlc2l6ZSBldmVudFxuICAgICAgICAgKiB3aGljaCBvdGhlciBpbnN0YW5jZXMgY2FuIHN1YnNjcmliZSB0by5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9uaXRvclNpemVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9uaXRvclNpemVfOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLm1vbml0b3JTaXplKSB7XG4gICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tyZXNpemU6IG1lLm9uRG9tUmVzaXplLCBzY29wZTogbWV9XSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCB7YXBwTmFtZSwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICB0aGlzLmFwcGx5Qm9keUNscyAmJiBOZW8ubWFpbi5Eb21BY2Nlc3MuYXBwbHlCb2R5Q2xzKHtcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICBjbHM6IFsnbmVvLWJvZHktdmlld3BvcnQnXSxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRvbVJlc2l6ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVzaXplJywgZGF0YSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXdwb3J0KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1jb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1jb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVmZXJlbmNlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlZmVyZW5jZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gd2luZG93SWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWQ6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbXBvbmVudH0gPSBtZTtcblxuICAgICAgICBtZS5yZWZlcmVuY2VzID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFBhcmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlck5hbWVcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBbY29tcG9uZW50XVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8Qm9vbGVhbnxudWxsfVxuICAgICAqL1xuICAgIGdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lLFxuICAgICAgICAgICAgaGFuZGxlckNiO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIHRocyBmdW5jdGlvbiAqbmFtZSogZmlyc3QgaW4gdGhlIENvbXBvbmVudCBpdHNlbGYuXG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGl0LCByZXR1cm4gdHJ1ZSBzbyBjYWxsaW5nIGNvZGUga25vd3Mgbm90IHRvIGNvbnRpbnVlIHRvIHNlYXJjaC5cbiAgICAgICAgICAgIGhhbmRsZXJDYiA9IHJlc29sdmVDYWxsYmFjayhoYW5kbGVyTmFtZSwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBmbiBpcyByZXNvbHZlZCBpbiB0aGUgQ29tcG9uZW50IG9yIGl0cyBvd24gcGFyZW50IGNoYWluLlxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3RhdHVzIGluZGljYXRpbmcgdGhhdCB3ZSBkbyBub3QgbmVlZCBhbiBlYXJseSBiaW5kaW5nXG4gICAgICAgICAgICBpZiAoaGFuZGxlckNiLmZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZW8uaXNGdW5jdGlvbihtZVtoYW5kbGVyTmFtZV0pID9cbiAgICAgICAgICAgIG1lIDogcGFyZW50Py5nZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsb3Nlc3QgY29udHJvbGxlciBpbnNpZGUgdGhlIGNvbXBvbmVudHMgcGFyZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudH0gPSBtZTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuY29tcG9uZW50LnBhcmVudD8uZ2V0Q29udHJvbGxlcigpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiB1cGRhdGUgY2hhbmdlZCByZWZlcmVuY2VzIChlLmcuIGNvbnRhaW5lci5yZW1vdmUoKSB0aGVuIGNvbnRhaW5lci5hZGQoKSB1c2luZyB0aGUgc2FtZSBrZXkpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSZWZlcmVuY2UobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLnJlZmVyZW5jZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLmNvbXBvbmVudC5kb3duKHtyZWZlcmVuY2U6IG5hbWV9KTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIG1lLnJlZmVyZW5jZXNbbmFtZV0gPSBjb21wb25lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb25lbnQgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2FtZUxldmVsT25seT1mYWxzZSB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBzdGF0ZVByb3ZpZGVyIGluc2lkZSB0aGUgY29tcG9uZW50IHBhcmVudCB0cmVlLFxuICAgICAqIGluIGNhc2UgdGhlcmUgaXMgbm9uZSBvbiB0aGUgc2FtZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW1lTGV2ZWxPbmx5PWZhbHNlXVxuICAgICAqL1xuICAgIGdldFN0YXRlUHJvdmlkZXIoc2FtZUxldmVsT25seT1mYWxzZSkge1xuICAgICAgICBsZXQge2NvbXBvbmVudH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2FtZUxldmVsT25seSA/IGNvbXBvbmVudC5zdGF0ZVByb3ZpZGVyIDogY29tcG9uZW50LmdldFN0YXRlUHJvdmlkZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBhY2Nlc3Npbmcgc3RhdGUuUHJvdmlkZXIgYmFzZWQgZGF0YS5TdG9yZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge05lby5kYXRhLlN0b3JlfVxuICAgICAqL1xuICAgIGdldFN0b3JlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluc2lkZSB5b3VyIHZpZXcgY29udHJvbGxlcnMgYXMgYSBzdGFydGluZyBwb2ludCBpbiBjYXNlIHlvdSBuZWVkIHJlZmVyZW5jZXNcbiAgICAgKiAoaW5zdGVhZCBvZiB1c2luZyBvbkNvbnN0cnVjdGVkKCkgaW5zaWRlIHlvdXIgY29udHJvbGxlcilcbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudENvbnN0cnVjdGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFdpbGwgZ2V0IGNhbGxlZCBieSBjb21wb25lbnQuQmFzZTogZGVzdHJveSgpIGluIGNhc2UgdGhlIGNvbXBvbmVudCBoYXMgYSByZWZlcmVuY2UgY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVmZXJlbmNlc30gPSBtZSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSByZWZlcmVuY2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVmZXJlbmNlc1trZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRQYXJlbnQoKT8ucmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgc2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5zZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExhYmVsICAgICBmcm9tICcuLi9jb21wb25lbnQvTGFiZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udG9vbGJhci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBkb2NrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRvY2tQb3NpdGlvbnM9Wyd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnLCBudWxsXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9ja1Bvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2xiYXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2xiYXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZG9ja189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHM9e250eXBlOididXR0b24nfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2ZsZXhib3gnLGFsaWduOidjZW50ZXInLGRpcmVjdGlvbjogJ3JvdycsIHBhY2s6J3N0YXJ0J31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlICAgIDogJ2ZsZXhib3gnLFxuICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmV8bnVsbH0gc29ydFpvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHNvcnRab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lQ29uZmlnOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS5hcHBOYW1lID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZG9jayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlICYmICFvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICBkb2NrUG9zaXRpb25zID0gbWUuZ2V0U3RhdGljQ29uZmlnKCdkb2NrUG9zaXRpb25zJyksXG4gICAgICAgICAgICBsYXlvdXRDb25maWcgID0gbWUuZ2V0TGF5b3V0Q29uZmlnKCk7XG5cbiAgICAgICAgZG9ja1Bvc2l0aW9ucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBrZXkgIT09IG51bGwgJiYgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1kb2NrLScgKyBrZXksIGtleSA9PT0gdmFsdWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWUubGF5b3V0KSB7XG4gICAgICAgICAgICBsYXlvdXRDb25maWcubnR5cGUgPSAnZmxleGJveCc7XG4gICAgICAgICAgICBtZS5zZXQoe2NscywgbGF5b3V0OiBsYXlvdXRDb25maWd9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUubGF5b3V0LnNldChsYXlvdXRDb25maWcpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5zb3J0Wm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyBkb2NrIHBvc2l0aW9uIG1hdGNoZXMgYSB2YWx1ZSBvZiB0aGUgc3RhdGljIGRvY2tQb3NpdGlvbnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RvY2snLCAnZG9ja1Bvc2l0aW9ucycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxheW91dCBjb25maWcgZGVwZW5kaW5nIG9uIHRoaXMuZG9ja1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGxheW91dENvbmZpZ1xuICAgICAqL1xuICAgIGdldExheW91dENvbmZpZygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGxheW91dENvbmZpZztcblxuICAgICAgICBpZiAobWUuZG9jaykge1xuICAgICAgICAgICAgc3dpdGNoIChtZS5kb2NrKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uLXJldmVyc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheW91dENvbmZpZyB8fCBtZS5sYXlvdXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICovXG4gICAgaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLm1hcChpdGVtID0+IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5pbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fVxuICAgICAqL1xuICAgIHJlcGxhY2VTcGFjZXIoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gJy0+JyA/IHttb2R1bGU6IENvbXBvbmVudCwgZmxleDogMX0gOiBpdGVtXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUb29sYmFyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==