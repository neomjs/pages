export const __webpack_esm_id__ = "vendors-src_container_Viewport_mjs-src_dashboard_Container_mjs";
export const __webpack_esm_ids__ = ["vendors-src_container_Viewport_mjs-src_dashboard_Container_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/container/Viewport.mjs"
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ },

/***/ "./src/dashboard/Container.mjs"
/*!*************************************!*\
  !*** ./src/dashboard/Container.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _draggable_DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../draggable/DragProxyContainer.mjs */ "./src/draggable/DragProxyContainer.mjs");



/**
 * @summary A container that manages a dynamic layout of sortable items, with built-in support for detaching items into separate browser windows.
 *
 * This class extends `Neo.container.Base` to provide a drag-and-drop dashboard experience. Its most powerful feature is the
 * **"Detach to Window"** capability. When a user drags a dashboard item outside the container's boundary, this class automatically:
 * 1.  Opens a new browser popup window (app shell) based on the item's or container's `popupUrl`.
 * 2.  Moves the item's component instance into the new window's component tree.
 * 3.  Maintains a link between the detached item and its original dashboard slot.
 *
 * **Re-integration:**
 * If the user drags the detached window back over the original dashboard, this class detects the re-entry, closes the popup,
 * and seamlessly re-inserts the item into its previous position (or a new sort index).
 *
 * **Architecture:**
 * This class leverages the `Neo.worker.App`'s shared nature. It listens for global `connect` and `disconnect` events to track
 * the lifecycle of detached windows. It uses a robust `windowId` mapping to ensure that even if a window is closed manually by the user,
 * the widget is correctly reclaimed and restored to the dashboard, preventing data loss or "zombie" widgets.
 *
 * @class Neo.dashboard.Container
 * @extends Neo.container.Base
 * @see Neo.dashboard.Panel
 * @see Neo.draggable.container.SortZone
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.dashboard.Container'
         * @protected
         */
        className: 'Neo.dashboard.Container',
        /**
         * @member {String} ntype='dashboard'
         * @protected
         */
        ntype: 'dashboard',
        /**
         * @member {String[]} baseCls=['neo-dashboard','neo-container']
         * @protected
         */
        baseCls: ['neo-dashboard', 'neo-container'],
        /**
         * @member {Map} detachedItems=new Map()
         * @protected
         */
        detachedItems: new Map(),
        /**
         * @member {Boolean} detachToNewWindow=true
         */
        detachToNewWindow: true,
        /**
         * Add extra CSS selectors to the drag proxy root.
         * @member {String[]} dragProxyExtraCls=[]
         */
        dragProxyExtraCls: [],
        /**
         * @member {Boolean} dragResortable=true
         * @reactive
         */
        dragResortable: true,
        /**
         * @member {Object|null} popupConfig=null
         */
        popupConfig: null,
        /**
         * @member {Function|String|null} popupUrl=null
         */
        popupUrl: null,
        /**
         * @member {String|null} sortGroup=null
         */
        sortGroup: null
    }

    /**
     * @member {Boolean} #isReintegrating=false
     * @private
     */
    #isReintegrating = false
    /**
     * @member {Boolean} #isWindowDragging=false
     * @private
     */
    #isWindowDragging = false

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.detachedItems = new Map();

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * @param {Object} config
     */
    createSortZone(config) {
        let me = this;

        Neo.merge(config, {
            allowOverdrag     : true,
            dragProxyConfig   : {module: _draggable_DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], ...me.dragProxyConfig},
            dragProxyExtraCls : me.dragProxyExtraCls,
            enableProxyToPopup: me.detachToNewWindow,
            listeners         : {
                dragBoundaryEntry: data => me.onDragBoundaryEntry(data),
                dragBoundaryExit : data => me.onDragBoundaryExit(data),
                dragEnd          : data => me.fire('dragEnd',           data)
            },
            sortGroup: me.sortGroup
        })

        super.createSortZone(config)
    }

    /**
     * @param {Neo.component.Base} item
     * @returns {String}
     */
    getPopupUrl(item) {
        let me  = this,
            url = item.popupUrl || me.popupUrl;

        if (Neo.isFunction(url)) {
            return url(item)
        }

        return url
    }

    /**
     * @returns {Promise<any>}
     */
    loadSortZoneModule() {
        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("vendors-src_draggable_dashboard_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/dashboard/SortZone.mjs */ "./src/draggable/dashboard/SortZone.mjs"))
    }

    /**
     * @param {Object} data
     */
    async onDragBoundaryEntry(data) {
        let me            = this,
            {windowId}    = me,
            {sortZone}    = data,
            widget        = data.draggedItem,
            widgetName    = widget.reference || widget.id;

        me.#isReintegrating = true;

        console.log('onDragBoundaryEntry', me.id, widget);

        sortZone.dragProxy.add(widget, true); // Silent add

        me.detachedItems.delete(widgetName);

        await Neo.Main.windowClose({names: widgetName, windowId});

        me.#isReintegrating  = false;
        me.#isWindowDragging = false;

        sortZone.isWindowDragging = false;
        sortZone.dragProxy.style  = {opacity: 1};

        Neo.main.addon.DragDrop.setConfigs({isWindowDragging: false, windowId});

        me.fire('dragBoundaryEntry', data)
    }

    /**
     * @param {Object} data
     */
    async onDragBoundaryExit(data) {
        let me = this,
            {draggedItem, proxyRect, sortZone} = data,
            popupData;

        me.#isWindowDragging = true;

        // Prohibit the size reduction inside #openWidgetInPopup().
        proxyRect.height += 50; // Adjust for header

        popupData = await me.openWidgetInPopup(draggedItem, proxyRect);

        sortZone.startWindowDrag({
            dragData: data,
            ...popupData
        });

        me.fire('dragBoundaryExit', data)
    }

    /**
     * @param {Neo.component.Base} widget
     * @param {DOMRect} rect
     * @returns {Promise<Object>}
     */
    async openWidgetInPopup(widget, rect) {
        let me              = this,
            {windowId}      = me,
            {windowConfigs} = Neo,
            firstWindowId   = Object.keys(windowConfigs)[0],
            {basePath}      = windowConfigs[firstWindowId],
            widgetName      = widget.reference || widget.id,
            url             = me.getPopupUrl(widget);

        if (!url) {
            console.error('No popupUrl defined for dashboard item', widget);
            return
        }

        if (!url.startsWith('http')) {
            url = basePath + url
        }

        // Append identification params
        url += `${url.includes('?') ? '&' : '?'}name=${widgetName}&dashboardId=${me.id}`;

        let winData               = await Neo.Main.getWindowData({windowId}),
            {height, width, x, y} = rect,
            popupHeight           = height - 50, // popup header adjustment
            popupLeft             = x + winData.screenLeft,
            popupTop              = y + (winData.outerHeight - winData.innerHeight + winData.screenTop),
            windowName            = widgetName;

        me.detachedItems.set(widgetName, {
            index : me.items.indexOf(widget),
            widget: widget
        });

        await Neo.Main.windowOpen({
            url,
            windowId,
            windowFeatures: `height=${popupHeight},left=${popupLeft},top=${popupTop},width=${width}`,
            windowName
        });

        return {popupHeight, popupLeft, popupTop, popupWidth: width, windowName}
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {String} data.windowId
     */
    async onWindowConnect(data) {
        let me         = this,
            app        = Neo.apps[data.windowId],
            mainView   = app.mainView,
            {windowId} = data,
            url        = await Neo.Main.getByPath({path: 'document.URL', windowId}),
            params     = new URL(url).searchParams,
            dashboardId= params.get('dashboardId'),
            widgetName = params.get('name');

        if (dashboardId === me.id) {
            let detachedItem = me.detachedItems.get(widgetName);

            if (detachedItem) {
                detachedItem.windowId = windowId;

                detachedItem.widget.wrapperStyle = {};
                // Add the widget to the popup window
                mainView.add(detachedItem.widget, false, !me.#isWindowDragging)
            }
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {String} data.windowId
     */
    async onWindowDisconnect(data) {
        let me = this;

        if (me.#isWindowDragging || me.#isReintegrating) {
            me.#isWindowDragging = false;
            return
        }

        let {windowId} = data;

        for (const [widgetName, detachedItem] of me.detachedItems.entries()) {
            if (detachedItem.windowId === windowId) {
                console.log('onWindowDisconnect: Re-integrating widget', me.id, widgetName);
                let {index, widget} = detachedItem;

                me.insert(index, widget);
                me.detachedItems.delete(widgetName);
                break
            }
        }
    }

    /**
     * Re-opens the popup window and resumes the window drag operation.
     * Called by the DragCoordinator when a remote drag leaves a target dashboard back into the void.
     * @param {String} widgetName
     * @param {DOMRect} proxyRect
     */
    async resumeWindowDrag(widgetName, proxyRect) {
        let me           = this,
            detachedItem = me.detachedItems.get(widgetName),
            popupData;

        if (detachedItem) {
            me.#isWindowDragging = true;

            popupData = await me.openWidgetInPopup(detachedItem.widget, proxyRect);

            // We need to tell the DragDrop addon to resume window dragging
            Neo.main.addon.DragDrop.startWindowDrag({
                popupHeight: popupData.popupHeight,
                popupName  : popupData.windowName,
                popupWidth : popupData.popupWidth,
                windowId   : me.windowId
            });
        }
    }

    /**
     * Closes the popup window and suspends the window drag operation.
     * Called by the DragCoordinator when a remote drag enters a target dashboard.
     * @param {String} widgetName
     */
    async suspendWindowDrag(widgetName) {
        let me = this;

        // Prevent onWindowDisconnect from auto-reintegrating
        me.#isWindowDragging = true;

        // Break the parent chain to prevent circular config lookups during handover
        let detachedItem = me.detachedItems.get(widgetName);

        console.log('suspendWindowDrag', me.id, widgetName, detachedItem);

        if (detachedItem?.widget) {
            detachedItem.widget.parentId = null
        }

        await Neo.Main.windowClose({names: [widgetName], windowId: me.windowId});

        Neo.main.addon.DragDrop.setConfigs({isWindowDragging: false, windowId: me.windowId})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ },

/***/ "./src/draggable/DragProxyComponent.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyComponent));


/***/ },

/***/ "./src/draggable/DragProxyContainer.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyContainer.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");



/**
 * @class Neo.draggable.DragProxyContainer
 * @extends Neo.container.Base
 */
class DragProxyContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyContainer'
         * @protected
         */
        className: 'Neo.draggable.DragProxyContainer',
        /**
         * @member {String} ntype='dragproxycontainer'
         * @protected
         */
        ntype: 'dragproxycontainer',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Object} layout='fit'
         * @reactive
         */
        layout: 'fit',
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        // We want to reuse the styling of the DragProxyComponent, since both use the same baseCls.
        // Instead of duplicating the scss file, we are forcing the ThemeEngine to load the component file.
        if (value) {
            Neo.currentWorker.insertThemeFiles(value, _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype)
        }
    }

    /**
     * We do NOT want to destroy child items, since they get re-used.
     * @param {...*} args
     */
    destroy(...args) {
        this.items = [];
        super.destroy(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyContainer));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb250YWluZXJfVmlld3BvcnRfbWpzLXNyY19kYXNoYm9hcmRfQ29udGFpbmVyX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFTO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxVQUFVOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRmU7QUFDYzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBYTtBQUNyQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtB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Q0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUJBQXVCOztBQUV4Qyx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtEQUFrQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGtDQUFrQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZGFzaGJvYXJkL0NvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kcmFnZ2FibGUvRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9EcmFnUHJveHlDb250YWluZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBWaWV3cG9ydCBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udGFpbmVyLlZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udGFpbmVyLlZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3ZpZXdwb3J0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3ZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyAnbmVvLWJvZHktdmlld3BvcnQnIHRvIHRoZSBkb2N1bWVudC5ib2R5XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFwcGx5Qm9keUNscz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseUJvZHlDbHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWluZyB0aGF0IGEgVmlld3BvcnQgaXMgdGhlIHRvcCBsZXZlbCB2aWV3IG9mIHlvdXIgYXBwLCBhbmQgeW91IHdhbnQgdG8gbW91bnQgaXQgcmlnaHQgYXdheS5cbiAgICAgICAgICogQ291bGQgYmUgd2l0aG91dCBhbnkgaXRlbXMuIFVzZSBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby12aWV3cG9ydCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby12aWV3cG9ydCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzIGEgbWFpbi5hZGRvbi5SZXNpemVPYnNlcnZlciBhbmQgZmlyZXMgYSBjdXN0b20gcmVzaXplIGV2ZW50XG4gICAgICAgICAqIHdoaWNoIG90aGVyIGluc3RhbmNlcyBjYW4gc3Vic2NyaWJlIHRvLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb25pdG9yU2l6ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb25pdG9yU2l6ZV86IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUubW9uaXRvclNpemUpIHtcbiAgICAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbe3Jlc2l6ZTogbWUub25Eb21SZXNpemUsIHNjb3BlOiBtZX1dKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IHt3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuYXBwbHlCb2R5Q2xzICYmIE5lby5tYWluLkRvbUFjY2Vzcy5hcHBseUJvZHlDbHMoe1xuICAgICAgICAgICAgY2xzOiBbJ25lby1ib2R5LXZpZXdwb3J0J10sXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Eb21SZXNpemUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3Jlc2l6ZScsIGRhdGEpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydCk7XG4iLCJpbXBvcnQgQmFzZUNvbnRhaW5lciAgICAgIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29udGFpbmVyIGZyb20gJy4uL2RyYWdnYWJsZS9EcmFnUHJveHlDb250YWluZXIubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBBIGNvbnRhaW5lciB0aGF0IG1hbmFnZXMgYSBkeW5hbWljIGxheW91dCBvZiBzb3J0YWJsZSBpdGVtcywgd2l0aCBidWlsdC1pbiBzdXBwb3J0IGZvciBkZXRhY2hpbmcgaXRlbXMgaW50byBzZXBhcmF0ZSBicm93c2VyIHdpbmRvd3MuXG4gKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIGBOZW8uY29udGFpbmVyLkJhc2VgIHRvIHByb3ZpZGUgYSBkcmFnLWFuZC1kcm9wIGRhc2hib2FyZCBleHBlcmllbmNlLiBJdHMgbW9zdCBwb3dlcmZ1bCBmZWF0dXJlIGlzIHRoZVxuICogKipcIkRldGFjaCB0byBXaW5kb3dcIioqIGNhcGFiaWxpdHkuIFdoZW4gYSB1c2VyIGRyYWdzIGEgZGFzaGJvYXJkIGl0ZW0gb3V0c2lkZSB0aGUgY29udGFpbmVyJ3MgYm91bmRhcnksIHRoaXMgY2xhc3MgYXV0b21hdGljYWxseTpcbiAqIDEuICBPcGVucyBhIG5ldyBicm93c2VyIHBvcHVwIHdpbmRvdyAoYXBwIHNoZWxsKSBiYXNlZCBvbiB0aGUgaXRlbSdzIG9yIGNvbnRhaW5lcidzIGBwb3B1cFVybGAuXG4gKiAyLiAgTW92ZXMgdGhlIGl0ZW0ncyBjb21wb25lbnQgaW5zdGFuY2UgaW50byB0aGUgbmV3IHdpbmRvdydzIGNvbXBvbmVudCB0cmVlLlxuICogMy4gIE1haW50YWlucyBhIGxpbmsgYmV0d2VlbiB0aGUgZGV0YWNoZWQgaXRlbSBhbmQgaXRzIG9yaWdpbmFsIGRhc2hib2FyZCBzbG90LlxuICpcbiAqICoqUmUtaW50ZWdyYXRpb246KipcbiAqIElmIHRoZSB1c2VyIGRyYWdzIHRoZSBkZXRhY2hlZCB3aW5kb3cgYmFjayBvdmVyIHRoZSBvcmlnaW5hbCBkYXNoYm9hcmQsIHRoaXMgY2xhc3MgZGV0ZWN0cyB0aGUgcmUtZW50cnksIGNsb3NlcyB0aGUgcG9wdXAsXG4gKiBhbmQgc2VhbWxlc3NseSByZS1pbnNlcnRzIHRoZSBpdGVtIGludG8gaXRzIHByZXZpb3VzIHBvc2l0aW9uIChvciBhIG5ldyBzb3J0IGluZGV4KS5cbiAqXG4gKiAqKkFyY2hpdGVjdHVyZToqKlxuICogVGhpcyBjbGFzcyBsZXZlcmFnZXMgdGhlIGBOZW8ud29ya2VyLkFwcGAncyBzaGFyZWQgbmF0dXJlLiBJdCBsaXN0ZW5zIGZvciBnbG9iYWwgYGNvbm5lY3RgIGFuZCBgZGlzY29ubmVjdGAgZXZlbnRzIHRvIHRyYWNrXG4gKiB0aGUgbGlmZWN5Y2xlIG9mIGRldGFjaGVkIHdpbmRvd3MuIEl0IHVzZXMgYSByb2J1c3QgYHdpbmRvd0lkYCBtYXBwaW5nIHRvIGVuc3VyZSB0aGF0IGV2ZW4gaWYgYSB3aW5kb3cgaXMgY2xvc2VkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLFxuICogdGhlIHdpZGdldCBpcyBjb3JyZWN0bHkgcmVjbGFpbWVkIGFuZCByZXN0b3JlZCB0byB0aGUgZGFzaGJvYXJkLCBwcmV2ZW50aW5nIGRhdGEgbG9zcyBvciBcInpvbWJpZVwiIHdpZGdldHMuXG4gKlxuICogQGNsYXNzIE5lby5kYXNoYm9hcmQuQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqIEBzZWUgTmVvLmRhc2hib2FyZC5QYW5lbFxuICogQHNlZSBOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZVxuICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXNoYm9hcmQuQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGFzaGJvYXJkLkNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkYXNoYm9hcmQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZGFzaGJvYXJkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWRhc2hib2FyZCcsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1kYXNoYm9hcmQnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TWFwfSBkZXRhY2hlZEl0ZW1zPW5ldyBNYXAoKVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZXRhY2hlZEl0ZW1zOiBuZXcgTWFwKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkZXRhY2hUb05ld1dpbmRvdz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBkZXRhY2hUb05ld1dpbmRvdzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBleHRyYSBDU1Mgc2VsZWN0b3JzIHRvIHRoZSBkcmFnIHByb3h5IHJvb3QuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkcmFnUHJveHlFeHRyYUNscz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5RXh0cmFDbHM6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ1Jlc29ydGFibGU9dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdSZXNvcnRhYmxlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHBvcHVwQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBvcHVwQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb258U3RyaW5nfG51bGx9IHBvcHVwVXJsPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBvcHVwVXJsOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNvcnRHcm91cD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0R3JvdXA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSAjaXNSZWludGVncmF0aW5nPWZhbHNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjaXNSZWludGVncmF0aW5nID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSAjaXNXaW5kb3dEcmFnZ2luZz1mYWxzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2lzV2luZG93RHJhZ2dpbmcgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kZXRhY2hlZEl0ZW1zID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uV2luZG93Q29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uV2luZG93RGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNyZWF0ZVNvcnRab25lKGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5tZXJnZShjb25maWcsIHtcbiAgICAgICAgICAgIGFsbG93T3ZlcmRyYWcgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRyYWdQcm94eUNvbmZpZyAgIDoge21vZHVsZTogRHJhZ1Byb3h5Q29udGFpbmVyLCAuLi5tZS5kcmFnUHJveHlDb25maWd9LFxuICAgICAgICAgICAgZHJhZ1Byb3h5RXh0cmFDbHMgOiBtZS5kcmFnUHJveHlFeHRyYUNscyxcbiAgICAgICAgICAgIGVuYWJsZVByb3h5VG9Qb3B1cDogbWUuZGV0YWNoVG9OZXdXaW5kb3csXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBkcmFnQm91bmRhcnlFbnRyeTogZGF0YSA9PiBtZS5vbkRyYWdCb3VuZGFyeUVudHJ5KGRhdGEpLFxuICAgICAgICAgICAgICAgIGRyYWdCb3VuZGFyeUV4aXQgOiBkYXRhID0+IG1lLm9uRHJhZ0JvdW5kYXJ5RXhpdChkYXRhKSxcbiAgICAgICAgICAgICAgICBkcmFnRW5kICAgICAgICAgIDogZGF0YSA9PiBtZS5maXJlKCdkcmFnRW5kJywgICAgICAgICAgIGRhdGEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc29ydEdyb3VwOiBtZS5zb3J0R3JvdXBcbiAgICAgICAgfSlcblxuICAgICAgICBzdXBlci5jcmVhdGVTb3J0Wm9uZShjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFBvcHVwVXJsKGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICB1cmwgPSBpdGVtLnBvcHVwVXJsIHx8IG1lLnBvcHVwVXJsO1xuXG4gICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbih1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBsb2FkU29ydFpvbmVNb2R1bGUoKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnQoJy4uL2RyYWdnYWJsZS9kYXNoYm9hcmQvU29ydFpvbmUubWpzJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ0JvdW5kYXJ5RW50cnkoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7d2luZG93SWR9ICAgID0gbWUsXG4gICAgICAgICAgICB7c29ydFpvbmV9ICAgID0gZGF0YSxcbiAgICAgICAgICAgIHdpZGdldCAgICAgICAgPSBkYXRhLmRyYWdnZWRJdGVtLFxuICAgICAgICAgICAgd2lkZ2V0TmFtZSAgICA9IHdpZGdldC5yZWZlcmVuY2UgfHwgd2lkZ2V0LmlkO1xuXG4gICAgICAgIG1lLiNpc1JlaW50ZWdyYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkRyYWdCb3VuZGFyeUVudHJ5JywgbWUuaWQsIHdpZGdldCk7XG5cbiAgICAgICAgc29ydFpvbmUuZHJhZ1Byb3h5LmFkZCh3aWRnZXQsIHRydWUpOyAvLyBTaWxlbnQgYWRkXG5cbiAgICAgICAgbWUuZGV0YWNoZWRJdGVtcy5kZWxldGUod2lkZ2V0TmFtZSk7XG5cbiAgICAgICAgYXdhaXQgTmVvLk1haW4ud2luZG93Q2xvc2Uoe25hbWVzOiB3aWRnZXROYW1lLCB3aW5kb3dJZH0pO1xuXG4gICAgICAgIG1lLiNpc1JlaW50ZWdyYXRpbmcgID0gZmFsc2U7XG4gICAgICAgIG1lLiNpc1dpbmRvd0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgc29ydFpvbmUuaXNXaW5kb3dEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBzb3J0Wm9uZS5kcmFnUHJveHkuc3R5bGUgID0ge29wYWNpdHk6IDF9O1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldENvbmZpZ3Moe2lzV2luZG93RHJhZ2dpbmc6IGZhbHNlLCB3aW5kb3dJZH0pO1xuXG4gICAgICAgIG1lLmZpcmUoJ2RyYWdCb3VuZGFyeUVudHJ5JywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ0JvdW5kYXJ5RXhpdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7ZHJhZ2dlZEl0ZW0sIHByb3h5UmVjdCwgc29ydFpvbmV9ID0gZGF0YSxcbiAgICAgICAgICAgIHBvcHVwRGF0YTtcblxuICAgICAgICBtZS4jaXNXaW5kb3dEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLy8gUHJvaGliaXQgdGhlIHNpemUgcmVkdWN0aW9uIGluc2lkZSAjb3BlbldpZGdldEluUG9wdXAoKS5cbiAgICAgICAgcHJveHlSZWN0LmhlaWdodCArPSA1MDsgLy8gQWRqdXN0IGZvciBoZWFkZXJcblxuICAgICAgICBwb3B1cERhdGEgPSBhd2FpdCBtZS5vcGVuV2lkZ2V0SW5Qb3B1cChkcmFnZ2VkSXRlbSwgcHJveHlSZWN0KTtcblxuICAgICAgICBzb3J0Wm9uZS5zdGFydFdpbmRvd0RyYWcoe1xuICAgICAgICAgICAgZHJhZ0RhdGE6IGRhdGEsXG4gICAgICAgICAgICAuLi5wb3B1cERhdGFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZmlyZSgnZHJhZ0JvdW5kYXJ5RXhpdCcsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IHdpZGdldFxuICAgICAqIEBwYXJhbSB7RE9NUmVjdH0gcmVjdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gICAgICovXG4gICAgYXN5bmMgb3BlbldpZGdldEluUG9wdXAod2lkZ2V0LCByZWN0KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSAgICAgID0gbWUsXG4gICAgICAgICAgICB7d2luZG93Q29uZmlnc30gPSBOZW8sXG4gICAgICAgICAgICBmaXJzdFdpbmRvd0lkICAgPSBPYmplY3Qua2V5cyh3aW5kb3dDb25maWdzKVswXSxcbiAgICAgICAgICAgIHtiYXNlUGF0aH0gICAgICA9IHdpbmRvd0NvbmZpZ3NbZmlyc3RXaW5kb3dJZF0sXG4gICAgICAgICAgICB3aWRnZXROYW1lICAgICAgPSB3aWRnZXQucmVmZXJlbmNlIHx8IHdpZGdldC5pZCxcbiAgICAgICAgICAgIHVybCAgICAgICAgICAgICA9IG1lLmdldFBvcHVwVXJsKHdpZGdldCk7XG5cbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHBvcHVwVXJsIGRlZmluZWQgZm9yIGRhc2hib2FyZCBpdGVtJywgd2lkZ2V0KTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICB1cmwgPSBiYXNlUGF0aCArIHVybFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIGlkZW50aWZpY2F0aW9uIHBhcmFtc1xuICAgICAgICB1cmwgKz0gYCR7dXJsLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyd9bmFtZT0ke3dpZGdldE5hbWV9JmRhc2hib2FyZElkPSR7bWUuaWR9YDtcblxuICAgICAgICBsZXQgd2luRGF0YSAgICAgICAgICAgICAgID0gYXdhaXQgTmVvLk1haW4uZ2V0V2luZG93RGF0YSh7d2luZG93SWR9KSxcbiAgICAgICAgICAgIHtoZWlnaHQsIHdpZHRoLCB4LCB5fSA9IHJlY3QsXG4gICAgICAgICAgICBwb3B1cEhlaWdodCAgICAgICAgICAgPSBoZWlnaHQgLSA1MCwgLy8gcG9wdXAgaGVhZGVyIGFkanVzdG1lbnRcbiAgICAgICAgICAgIHBvcHVwTGVmdCAgICAgICAgICAgICA9IHggKyB3aW5EYXRhLnNjcmVlbkxlZnQsXG4gICAgICAgICAgICBwb3B1cFRvcCAgICAgICAgICAgICAgPSB5ICsgKHdpbkRhdGEub3V0ZXJIZWlnaHQgLSB3aW5EYXRhLmlubmVySGVpZ2h0ICsgd2luRGF0YS5zY3JlZW5Ub3ApLFxuICAgICAgICAgICAgd2luZG93TmFtZSAgICAgICAgICAgID0gd2lkZ2V0TmFtZTtcblxuICAgICAgICBtZS5kZXRhY2hlZEl0ZW1zLnNldCh3aWRnZXROYW1lLCB7XG4gICAgICAgICAgICBpbmRleCA6IG1lLml0ZW1zLmluZGV4T2Yod2lkZ2V0KSxcbiAgICAgICAgICAgIHdpZGdldDogd2lkZ2V0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IE5lby5NYWluLndpbmRvd09wZW4oe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgICB3aW5kb3dGZWF0dXJlczogYGhlaWdodD0ke3BvcHVwSGVpZ2h0fSxsZWZ0PSR7cG9wdXBMZWZ0fSx0b3A9JHtwb3B1cFRvcH0sd2lkdGg9JHt3aWR0aH1gLFxuICAgICAgICAgICAgd2luZG93TmFtZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge3BvcHVwSGVpZ2h0LCBwb3B1cExlZnQsIHBvcHVwVG9wLCBwb3B1cFdpZHRoOiB3aWR0aCwgd2luZG93TmFtZX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIGFzeW5jIG9uV2luZG93Q29ubmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFwcCAgICAgICAgPSBOZW8uYXBwc1tkYXRhLndpbmRvd0lkXSxcbiAgICAgICAgICAgIG1haW5WaWV3ICAgPSBhcHAubWFpblZpZXcsXG4gICAgICAgICAgICB7d2luZG93SWR9ID0gZGF0YSxcbiAgICAgICAgICAgIHVybCAgICAgICAgPSBhd2FpdCBOZW8uTWFpbi5nZXRCeVBhdGgoe3BhdGg6ICdkb2N1bWVudC5VUkwnLCB3aW5kb3dJZH0pLFxuICAgICAgICAgICAgcGFyYW1zICAgICA9IG5ldyBVUkwodXJsKS5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICBkYXNoYm9hcmRJZD0gcGFyYW1zLmdldCgnZGFzaGJvYXJkSWQnKSxcbiAgICAgICAgICAgIHdpZGdldE5hbWUgPSBwYXJhbXMuZ2V0KCduYW1lJyk7XG5cbiAgICAgICAgaWYgKGRhc2hib2FyZElkID09PSBtZS5pZCkge1xuICAgICAgICAgICAgbGV0IGRldGFjaGVkSXRlbSA9IG1lLmRldGFjaGVkSXRlbXMuZ2V0KHdpZGdldE5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZGV0YWNoZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWRJdGVtLndpbmRvd0lkID0gd2luZG93SWQ7XG5cbiAgICAgICAgICAgICAgICBkZXRhY2hlZEl0ZW0ud2lkZ2V0LndyYXBwZXJTdHlsZSA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgd2lkZ2V0IHRvIHRoZSBwb3B1cCB3aW5kb3dcbiAgICAgICAgICAgICAgICBtYWluVmlldy5hZGQoZGV0YWNoZWRJdGVtLndpZGdldCwgZmFsc2UsICFtZS4jaXNXaW5kb3dEcmFnZ2luZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgYXN5bmMgb25XaW5kb3dEaXNjb25uZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuI2lzV2luZG93RHJhZ2dpbmcgfHwgbWUuI2lzUmVpbnRlZ3JhdGluZykge1xuICAgICAgICAgICAgbWUuI2lzV2luZG93RHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHt3aW5kb3dJZH0gPSBkYXRhO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3dpZGdldE5hbWUsIGRldGFjaGVkSXRlbV0gb2YgbWUuZGV0YWNoZWRJdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChkZXRhY2hlZEl0ZW0ud2luZG93SWQgPT09IHdpbmRvd0lkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29uV2luZG93RGlzY29ubmVjdDogUmUtaW50ZWdyYXRpbmcgd2lkZ2V0JywgbWUuaWQsIHdpZGdldE5hbWUpO1xuICAgICAgICAgICAgICAgIGxldCB7aW5kZXgsIHdpZGdldH0gPSBkZXRhY2hlZEl0ZW07XG5cbiAgICAgICAgICAgICAgICBtZS5pbnNlcnQoaW5kZXgsIHdpZGdldCk7XG4gICAgICAgICAgICAgICAgbWUuZGV0YWNoZWRJdGVtcy5kZWxldGUod2lkZ2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlLW9wZW5zIHRoZSBwb3B1cCB3aW5kb3cgYW5kIHJlc3VtZXMgdGhlIHdpbmRvdyBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBDYWxsZWQgYnkgdGhlIERyYWdDb29yZGluYXRvciB3aGVuIGEgcmVtb3RlIGRyYWcgbGVhdmVzIGEgdGFyZ2V0IGRhc2hib2FyZCBiYWNrIGludG8gdGhlIHZvaWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdpZGdldE5hbWVcbiAgICAgKiBAcGFyYW0ge0RPTVJlY3R9IHByb3h5UmVjdFxuICAgICAqL1xuICAgIGFzeW5jIHJlc3VtZVdpbmRvd0RyYWcod2lkZ2V0TmFtZSwgcHJveHlSZWN0KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGV0YWNoZWRJdGVtID0gbWUuZGV0YWNoZWRJdGVtcy5nZXQod2lkZ2V0TmFtZSksXG4gICAgICAgICAgICBwb3B1cERhdGE7XG5cbiAgICAgICAgaWYgKGRldGFjaGVkSXRlbSkge1xuICAgICAgICAgICAgbWUuI2lzV2luZG93RHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBwb3B1cERhdGEgPSBhd2FpdCBtZS5vcGVuV2lkZ2V0SW5Qb3B1cChkZXRhY2hlZEl0ZW0ud2lkZ2V0LCBwcm94eVJlY3QpO1xuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRlbGwgdGhlIERyYWdEcm9wIGFkZG9uIHRvIHJlc3VtZSB3aW5kb3cgZHJhZ2dpbmdcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnN0YXJ0V2luZG93RHJhZyh7XG4gICAgICAgICAgICAgICAgcG9wdXBIZWlnaHQ6IHBvcHVwRGF0YS5wb3B1cEhlaWdodCxcbiAgICAgICAgICAgICAgICBwb3B1cE5hbWUgIDogcG9wdXBEYXRhLndpbmRvd05hbWUsXG4gICAgICAgICAgICAgICAgcG9wdXBXaWR0aCA6IHBvcHVwRGF0YS5wb3B1cFdpZHRoLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHBvcHVwIHdpbmRvdyBhbmQgc3VzcGVuZHMgdGhlIHdpbmRvdyBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBDYWxsZWQgYnkgdGhlIERyYWdDb29yZGluYXRvciB3aGVuIGEgcmVtb3RlIGRyYWcgZW50ZXJzIGEgdGFyZ2V0IGRhc2hib2FyZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2lkZ2V0TmFtZVxuICAgICAqL1xuICAgIGFzeW5jIHN1c3BlbmRXaW5kb3dEcmFnKHdpZGdldE5hbWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBQcmV2ZW50IG9uV2luZG93RGlzY29ubmVjdCBmcm9tIGF1dG8tcmVpbnRlZ3JhdGluZ1xuICAgICAgICBtZS4jaXNXaW5kb3dEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLy8gQnJlYWsgdGhlIHBhcmVudCBjaGFpbiB0byBwcmV2ZW50IGNpcmN1bGFyIGNvbmZpZyBsb29rdXBzIGR1cmluZyBoYW5kb3ZlclxuICAgICAgICBsZXQgZGV0YWNoZWRJdGVtID0gbWUuZGV0YWNoZWRJdGVtcy5nZXQod2lkZ2V0TmFtZSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ3N1c3BlbmRXaW5kb3dEcmFnJywgbWUuaWQsIHdpZGdldE5hbWUsIGRldGFjaGVkSXRlbSk7XG5cbiAgICAgICAgaWYgKGRldGFjaGVkSXRlbT8ud2lkZ2V0KSB7XG4gICAgICAgICAgICBkZXRhY2hlZEl0ZW0ud2lkZ2V0LnBhcmVudElkID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgTmVvLk1haW4ud2luZG93Q2xvc2Uoe25hbWVzOiBbd2lkZ2V0TmFtZV0sIHdpbmRvd0lkOiBtZS53aW5kb3dJZH0pO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldENvbmZpZ3Moe2lzV2luZG93RHJhZ2dpbmc6IGZhbHNlLCB3aW5kb3dJZDogbWUud2luZG93SWR9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29udGFpbmVyKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1Byb3h5Q29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZHJhZ3Byb3h5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RyYWdwcm94eScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvSW5pdFZub2RlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0Vm5vZGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZHJhZ3Byb3h5J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRyYWdwcm94eSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMubW92ZUluTWFpblRocmVhZCkge1xuICAgICAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0RHJhZ1Byb3h5RWxlbWVudCh7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1Byb3h5Q29tcG9uZW50KTtcbiIsImltcG9ydCBCYXNlQ29udGFpbmVyICAgICAgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb21wb25lbnQgZnJvbSAnLi9EcmFnUHJveHlDb21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBEcmFnUHJveHlDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFncHJveHljb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZHJhZ3Byb3h5Y29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Jbml0Vm5vZGU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0luaXRWbm9kZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1kcmFncHJveHknXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZHJhZ3Byb3h5J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD0nZml0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogJ2ZpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5tb3ZlSW5NYWluVGhyZWFkKSB7XG4gICAgICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5zZXREcmFnUHJveHlFbGVtZW50KHthcHBOYW1lLCBpZCwgd2luZG93SWR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICAvLyBXZSB3YW50IHRvIHJldXNlIHRoZSBzdHlsaW5nIG9mIHRoZSBEcmFnUHJveHlDb21wb25lbnQsIHNpbmNlIGJvdGggdXNlIHRoZSBzYW1lIGJhc2VDbHMuXG4gICAgICAgIC8vIEluc3RlYWQgb2YgZHVwbGljYXRpbmcgdGhlIHNjc3MgZmlsZSwgd2UgYXJlIGZvcmNpbmcgdGhlIFRoZW1lRW5naW5lIHRvIGxvYWQgdGhlIGNvbXBvbmVudCBmaWxlLlxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIERyYWdQcm94eUNvbXBvbmVudC5wcm90b3R5cGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBkbyBOT1Qgd2FudCB0byBkZXN0cm95IGNoaWxkIGl0ZW1zLCBzaW5jZSB0aGV5IGdldCByZS11c2VkLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERyYWdQcm94eUNvbnRhaW5lcik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=