"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_container_Viewport_mjs-src_dashboard_Container_mjs"],{

/***/ "./src/container/Viewport.mjs"
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ },

/***/ "./src/dashboard/Container.mjs"
/*!*************************************!*\
  !*** ./src/dashboard/Container.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _draggable_DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../draggable/DragProxyContainer.mjs */ "./src/draggable/DragProxyContainer.mjs");



/**
 * @summary A container that manages a dynamic layout of sortable items, with built-in support for detaching items into separate browser windows.
 *
 * This class extends `Neo.container.Base` to provide a drag-and-drop dashboard experience. Its most powerful feature is the
 * **"Detach to Window"** capability. When a user drags a dashboard item outside the container's boundary, this class automatically:
 * 1.  Opens a new browser popup window (app shell) based on the item's or container's `popupUrl`.
 * 2.  Moves the item's component instance into the new window's component tree.
 * 3.  Maintains a link between the detached item and its original dashboard slot.
 *
 * **Re-integration:**
 * If the user drags the detached window back over the original dashboard, this class detects the re-entry, closes the popup,
 * and seamlessly re-inserts the item into its previous position (or a new sort index).
 *
 * **Architecture:**
 * This class leverages the `Neo.worker.App`'s shared nature. It listens for global `connect` and `disconnect` events to track
 * the lifecycle of detached windows. It uses a robust `windowId` mapping to ensure that even if a window is closed manually by the user,
 * the widget is correctly reclaimed and restored to the dashboard, preventing data loss or "zombie" widgets.
 *
 * @class Neo.dashboard.Container
 * @extends Neo.container.Base
 * @see Neo.dashboard.Panel
 * @see Neo.draggable.container.SortZone
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.dashboard.Container'
         * @protected
         */
        className: 'Neo.dashboard.Container',
        /**
         * @member {String} ntype='dashboard'
         * @protected
         */
        ntype: 'dashboard',
        /**
         * @member {String[]} baseCls=['neo-dashboard','neo-container']
         * @protected
         */
        baseCls: ['neo-dashboard', 'neo-container'],
        /**
         * @member {Map} detachedItems=new Map()
         * @protected
         */
        detachedItems: new Map(),
        /**
         * @member {Boolean} detachToNewWindow=true
         */
        detachToNewWindow: true,
        /**
         * Add extra CSS selectors to the drag proxy root.
         * @member {String[]} dragProxyExtraCls=[]
         */
        dragProxyExtraCls: [],
        /**
         * @member {Boolean} dragResortable=true
         * @reactive
         */
        dragResortable: true,
        /**
         * @member {Object|null} popupConfig=null
         */
        popupConfig: null,
        /**
         * @member {Function|String|null} popupUrl=null
         */
        popupUrl: null,
        /**
         * @member {String|null} sortGroup=null
         */
        sortGroup: null
    }

    /**
     * @member {Boolean} #isReintegrating=false
     * @private
     */
    #isReintegrating = false
    /**
     * @member {Boolean} #isWindowDragging=false
     * @private
     */
    #isWindowDragging = false

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.detachedItems = new Map();

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * @param {Object} config
     */
    createSortZone(config) {
        let me = this;

        Neo.merge(config, {
            allowOverdrag     : true,
            dragProxyConfig   : {module: _draggable_DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], ...me.dragProxyConfig},
            dragProxyExtraCls : me.dragProxyExtraCls,
            enableProxyToPopup: me.detachToNewWindow,
            listeners         : {
                dragBoundaryEntry: data => me.onDragBoundaryEntry(data),
                dragBoundaryExit : data => me.onDragBoundaryExit(data),
                dragEnd          : data => me.fire('dragEnd',           data)
            },
            sortGroup: me.sortGroup
        })

        super.createSortZone(config)
    }

    /**
     * @param {Neo.component.Base} item
     * @returns {String}
     */
    getPopupUrl(item) {
        let me  = this,
            url = item.popupUrl || me.popupUrl;

        if (Neo.isFunction(url)) {
            return url(item)
        }

        return url
    }

    /**
     * @returns {Promise<any>}
     */
    loadSortZoneModule() {
        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("vendors-src_draggable_dashboard_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/dashboard/SortZone.mjs */ "./src/draggable/dashboard/SortZone.mjs"))
    }

    /**
     * @param {Object} data
     */
    async onDragBoundaryEntry(data) {
        let me            = this,
            {windowId}    = me,
            {sortZone}    = data,
            widget        = data.draggedItem,
            widgetName    = widget.reference || widget.id;

        me.#isReintegrating = true;

        console.log('onDragBoundaryEntry', me.id, widget);

        sortZone.dragProxy.add(widget, true); // Silent add

        me.detachedItems.delete(widgetName);

        await Neo.Main.windowClose({names: widgetName, windowId});

        me.#isReintegrating  = false;
        me.#isWindowDragging = false;

        sortZone.isWindowDragging = false;
        sortZone.dragProxy.style  = {opacity: 1};

        Neo.main.addon.DragDrop.setConfigs({isWindowDragging: false, windowId});

        me.fire('dragBoundaryEntry', data)
    }

    /**
     * @param {Object} data
     */
    async onDragBoundaryExit(data) {
        let me = this,
            {draggedItem, proxyRect, sortZone} = data,
            popupData;

        me.#isWindowDragging = true;

        // Prohibit the size reduction inside #openWidgetInPopup().
        proxyRect.height += 50; // Adjust for header

        popupData = await me.openWidgetInPopup(draggedItem, proxyRect);

        sortZone.startWindowDrag({
            dragData: data,
            ...popupData
        });

        me.fire('dragBoundaryExit', data)
    }

    /**
     * @param {Neo.component.Base} widget
     * @param {DOMRect} rect
     * @returns {Promise<Object>}
     */
    async openWidgetInPopup(widget, rect) {
        let me              = this,
            {windowId}      = me,
            {windowConfigs} = Neo,
            firstWindowId   = Object.keys(windowConfigs)[0],
            {basePath}      = windowConfigs[firstWindowId],
            widgetName      = widget.reference || widget.id,
            url             = me.getPopupUrl(widget);

        if (!url) {
            console.error('No popupUrl defined for dashboard item', widget);
            return
        }

        if (!url.startsWith('http')) {
            url = basePath + url
        }

        // Append identification params
        url += `${url.includes('?') ? '&' : '?'}name=${widgetName}&dashboardId=${me.id}`;

        let winData               = await Neo.Main.getWindowData({windowId}),
            {height, width, x, y} = rect,
            popupHeight           = height - 50, // popup header adjustment
            popupLeft             = x + winData.screenLeft,
            popupTop              = y + (winData.outerHeight - winData.innerHeight + winData.screenTop),
            windowName            = widgetName;

        me.detachedItems.set(widgetName, {
            index : me.items.indexOf(widget),
            widget: widget
        });

        await Neo.Main.windowOpen({
            url,
            windowId,
            windowFeatures: `height=${popupHeight},left=${popupLeft},top=${popupTop},width=${width}`,
            windowName
        });

        return {popupHeight, popupLeft, popupTop, popupWidth: width, windowName}
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {String} data.windowId
     */
    async onWindowConnect(data) {
        let me         = this,
            app        = Neo.apps[data.windowId],
            mainView   = app.mainView,
            {windowId} = data,
            url        = await Neo.Main.getByPath({path: 'document.URL', windowId}),
            params     = new URL(url).searchParams,
            dashboardId= params.get('dashboardId'),
            widgetName = params.get('name');

        if (dashboardId === me.id) {
            let detachedItem = me.detachedItems.get(widgetName);

            if (detachedItem) {
                detachedItem.windowId = windowId;

                detachedItem.widget.wrapperStyle = {};
                // Add the widget to the popup window
                mainView.add(detachedItem.widget, false, !me.#isWindowDragging)
            }
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {String} data.windowId
     */
    async onWindowDisconnect(data) {
        let me = this;

        if (me.#isWindowDragging || me.#isReintegrating) {
            me.#isWindowDragging = false;
            return
        }

        let {windowId} = data;

        for (const [widgetName, detachedItem] of me.detachedItems.entries()) {
            if (detachedItem.windowId === windowId) {
                console.log('onWindowDisconnect: Re-integrating widget', me.id, widgetName);
                let {index, widget} = detachedItem;

                me.insert(index, widget);
                me.detachedItems.delete(widgetName);
                break
            }
        }
    }

    /**
     * Re-opens the popup window and resumes the window drag operation.
     * Called by the DragCoordinator when a remote drag leaves a target dashboard back into the void.
     * @param {String} widgetName
     * @param {DOMRect} proxyRect
     */
    async resumeWindowDrag(widgetName, proxyRect) {
        let me           = this,
            detachedItem = me.detachedItems.get(widgetName),
            popupData;

        if (detachedItem) {
            me.#isWindowDragging = true;

            popupData = await me.openWidgetInPopup(detachedItem.widget, proxyRect);

            // We need to tell the DragDrop addon to resume window dragging
            Neo.main.addon.DragDrop.startWindowDrag({
                popupHeight: popupData.popupHeight,
                popupName  : popupData.windowName,
                popupWidth : popupData.popupWidth,
                windowId   : me.windowId
            });
        }
    }

    /**
     * Closes the popup window and suspends the window drag operation.
     * Called by the DragCoordinator when a remote drag enters a target dashboard.
     * @param {String} widgetName
     */
    async suspendWindowDrag(widgetName) {
        let me = this;

        // Prevent onWindowDisconnect from auto-reintegrating
        me.#isWindowDragging = true;

        // Break the parent chain to prevent circular config lookups during handover
        let detachedItem = me.detachedItems.get(widgetName);

        console.log('suspendWindowDrag', me.id, widgetName, detachedItem);

        if (detachedItem?.widget) {
            detachedItem.widget.parentId = null
        }

        await Neo.Main.windowClose({names: [widgetName], windowId: me.windowId});

        Neo.main.addon.DragDrop.setConfigs({isWindowDragging: false, windowId: me.windowId})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ },

/***/ "./src/draggable/DragProxyComponent.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyComponent));


/***/ },

/***/ "./src/draggable/DragProxyContainer.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyContainer.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");



/**
 * @class Neo.draggable.DragProxyContainer
 * @extends Neo.container.Base
 */
class DragProxyContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyContainer'
         * @protected
         */
        className: 'Neo.draggable.DragProxyContainer',
        /**
         * @member {String} ntype='dragproxycontainer'
         * @protected
         */
        ntype: 'dragproxycontainer',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Object} layout='fit'
         * @reactive
         */
        layout: 'fit',
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        // We want to reuse the styling of the DragProxyComponent, since both use the same baseCls.
        // Instead of duplicating the scss file, we are forcing the ThemeEngine to load the component file.
        if (value) {
            Neo.currentWorker.insertThemeFiles(value, _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype)
        }
    }

    /**
     * We do NOT want to destroy child items, since they get re-used.
     * @param {...*} args
     */
    destroy(...args) {
        this.items = [];
        super.destroy(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyContainer));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb250YWluZXJfVmlld3BvcnRfbWpzLXNyY19kYXNoYm9hcmRfQ29udGFpbmVyX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQVM7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFVBQVU7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHdCQUF3QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hGZTtBQUNjOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFhO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FB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QTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7O0FBRXhDLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0RBQWtCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsa0NBQWtDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXNoYm9hcmQvQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9EcmFnUHJveHlDb21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL0RyYWdQcm94eUNvbnRhaW5lci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzICduZW8tYm9keS12aWV3cG9ydCcgdG8gdGhlIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXBwbHlCb2R5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc3VtaW5nIHRoYXQgYSBWaWV3cG9ydCBpcyB0aGUgdG9wIGxldmVsIHZpZXcgb2YgeW91ciBhcHAsIGFuZCB5b3Ugd2FudCB0byBtb3VudCBpdCByaWdodCBhd2F5LlxuICAgICAgICAgKiBDb3VsZCBiZSB3aXRob3V0IGFueSBpdGVtcy4gVXNlIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXZpZXdwb3J0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXZpZXdwb3J0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgYSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyIGFuZCBmaXJlcyBhIGN1c3RvbSByZXNpemUgZXZlbnRcbiAgICAgICAgICogd2hpY2ggb3RoZXIgaW5zdGFuY2VzIGNhbiBzdWJzY3JpYmUgdG8uXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vbml0b3JTaXplXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vbml0b3JTaXplXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5tb25pdG9yU2l6ZSkge1xuICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFt7cmVzaXplOiBtZS5vbkRvbVJlc2l6ZSwgc2NvcGU6IG1lfV0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQge3dpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5hcHBseUJvZHlDbHMgJiYgTmVvLm1haW4uRG9tQWNjZXNzLmFwcGx5Qm9keUNscyh7XG4gICAgICAgICAgICBjbHM6IFsnbmVvLWJvZHktdmlld3BvcnQnXSxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRvbVJlc2l6ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVzaXplJywgZGF0YSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXdwb3J0KTtcbiIsImltcG9ydCBCYXNlQ29udGFpbmVyICAgICAgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb250YWluZXIgZnJvbSAnLi4vZHJhZ2dhYmxlL0RyYWdQcm94eUNvbnRhaW5lci5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEEgY29udGFpbmVyIHRoYXQgbWFuYWdlcyBhIGR5bmFtaWMgbGF5b3V0IG9mIHNvcnRhYmxlIGl0ZW1zLCB3aXRoIGJ1aWx0LWluIHN1cHBvcnQgZm9yIGRldGFjaGluZyBpdGVtcyBpbnRvIHNlcGFyYXRlIGJyb3dzZXIgd2luZG93cy5cbiAqXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMgYE5lby5jb250YWluZXIuQmFzZWAgdG8gcHJvdmlkZSBhIGRyYWctYW5kLWRyb3AgZGFzaGJvYXJkIGV4cGVyaWVuY2UuIEl0cyBtb3N0IHBvd2VyZnVsIGZlYXR1cmUgaXMgdGhlXG4gKiAqKlwiRGV0YWNoIHRvIFdpbmRvd1wiKiogY2FwYWJpbGl0eS4gV2hlbiBhIHVzZXIgZHJhZ3MgYSBkYXNoYm9hcmQgaXRlbSBvdXRzaWRlIHRoZSBjb250YWluZXIncyBib3VuZGFyeSwgdGhpcyBjbGFzcyBhdXRvbWF0aWNhbGx5OlxuICogMS4gIE9wZW5zIGEgbmV3IGJyb3dzZXIgcG9wdXAgd2luZG93IChhcHAgc2hlbGwpIGJhc2VkIG9uIHRoZSBpdGVtJ3Mgb3IgY29udGFpbmVyJ3MgYHBvcHVwVXJsYC5cbiAqIDIuICBNb3ZlcyB0aGUgaXRlbSdzIGNvbXBvbmVudCBpbnN0YW5jZSBpbnRvIHRoZSBuZXcgd2luZG93J3MgY29tcG9uZW50IHRyZWUuXG4gKiAzLiAgTWFpbnRhaW5zIGEgbGluayBiZXR3ZWVuIHRoZSBkZXRhY2hlZCBpdGVtIGFuZCBpdHMgb3JpZ2luYWwgZGFzaGJvYXJkIHNsb3QuXG4gKlxuICogKipSZS1pbnRlZ3JhdGlvbjoqKlxuICogSWYgdGhlIHVzZXIgZHJhZ3MgdGhlIGRldGFjaGVkIHdpbmRvdyBiYWNrIG92ZXIgdGhlIG9yaWdpbmFsIGRhc2hib2FyZCwgdGhpcyBjbGFzcyBkZXRlY3RzIHRoZSByZS1lbnRyeSwgY2xvc2VzIHRoZSBwb3B1cCxcbiAqIGFuZCBzZWFtbGVzc2x5IHJlLWluc2VydHMgdGhlIGl0ZW0gaW50byBpdHMgcHJldmlvdXMgcG9zaXRpb24gKG9yIGEgbmV3IHNvcnQgaW5kZXgpLlxuICpcbiAqICoqQXJjaGl0ZWN0dXJlOioqXG4gKiBUaGlzIGNsYXNzIGxldmVyYWdlcyB0aGUgYE5lby53b3JrZXIuQXBwYCdzIHNoYXJlZCBuYXR1cmUuIEl0IGxpc3RlbnMgZm9yIGdsb2JhbCBgY29ubmVjdGAgYW5kIGBkaXNjb25uZWN0YCBldmVudHMgdG8gdHJhY2tcbiAqIHRoZSBsaWZlY3ljbGUgb2YgZGV0YWNoZWQgd2luZG93cy4gSXQgdXNlcyBhIHJvYnVzdCBgd2luZG93SWRgIG1hcHBpbmcgdG8gZW5zdXJlIHRoYXQgZXZlbiBpZiBhIHdpbmRvdyBpcyBjbG9zZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIsXG4gKiB0aGUgd2lkZ2V0IGlzIGNvcnJlY3RseSByZWNsYWltZWQgYW5kIHJlc3RvcmVkIHRvIHRoZSBkYXNoYm9hcmQsIHByZXZlbnRpbmcgZGF0YSBsb3NzIG9yIFwiem9tYmllXCIgd2lkZ2V0cy5cbiAqXG4gKiBAY2xhc3MgTmVvLmRhc2hib2FyZC5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICogQHNlZSBOZW8uZGFzaGJvYXJkLlBhbmVsXG4gKiBAc2VlIE5lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lXG4gKi9cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIEJhc2VDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhc2hib2FyZC5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXNoYm9hcmQuQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Rhc2hib2FyZCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkYXNoYm9hcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZGFzaGJvYXJkJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRhc2hib2FyZCcsICduZW8tY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtNYXB9IGRldGFjaGVkSXRlbXM9bmV3IE1hcCgpXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRldGFjaGVkSXRlbXM6IG5ldyBNYXAoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRldGFjaFRvTmV3V2luZG93PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGRldGFjaFRvTmV3V2luZG93OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGV4dHJhIENTUyBzZWxlY3RvcnMgdG8gdGhlIGRyYWcgcHJveHkgcm9vdC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGRyYWdQcm94eUV4dHJhQ2xzPVtdXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHlFeHRyYUNsczogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnUmVzb3J0YWJsZT10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Jlc29ydGFibGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gcG9wdXBDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxTdHJpbmd8bnVsbH0gcG9wdXBVcmw9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcG9wdXBVcmw6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc29ydEdyb3VwPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRHcm91cDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59ICNpc1JlaW50ZWdyYXRpbmc9ZmFsc2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNpc1JlaW50ZWdyYXRpbmcgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59ICNpc1dpbmRvd0RyYWdnaW5nPWZhbHNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjaXNXaW5kb3dEcmFnZ2luZyA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmRldGFjaGVkSXRlbXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIub24oe1xuICAgICAgICAgICAgY29ubmVjdCAgIDogbWUub25XaW5kb3dDb25uZWN0LFxuICAgICAgICAgICAgZGlzY29ubmVjdDogbWUub25XaW5kb3dEaXNjb25uZWN0LFxuICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY3JlYXRlU29ydFpvbmUoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLm1lcmdlKGNvbmZpZywge1xuICAgICAgICAgICAgYWxsb3dPdmVyZHJhZyAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZHJhZ1Byb3h5Q29uZmlnICAgOiB7bW9kdWxlOiBEcmFnUHJveHlDb250YWluZXIsIC4uLm1lLmRyYWdQcm94eUNvbmZpZ30sXG4gICAgICAgICAgICBkcmFnUHJveHlFeHRyYUNscyA6IG1lLmRyYWdQcm94eUV4dHJhQ2xzLFxuICAgICAgICAgICAgZW5hYmxlUHJveHlUb1BvcHVwOiBtZS5kZXRhY2hUb05ld1dpbmRvdyxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGRyYWdCb3VuZGFyeUVudHJ5OiBkYXRhID0+IG1lLm9uRHJhZ0JvdW5kYXJ5RW50cnkoZGF0YSksXG4gICAgICAgICAgICAgICAgZHJhZ0JvdW5kYXJ5RXhpdCA6IGRhdGEgPT4gbWUub25EcmFnQm91bmRhcnlFeGl0KGRhdGEpLFxuICAgICAgICAgICAgICAgIGRyYWdFbmQgICAgICAgICAgOiBkYXRhID0+IG1lLmZpcmUoJ2RyYWdFbmQnLCAgICAgICAgICAgZGF0YSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0R3JvdXA6IG1lLnNvcnRHcm91cFxuICAgICAgICB9KVxuXG4gICAgICAgIHN1cGVyLmNyZWF0ZVNvcnRab25lKGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0UG9wdXBVcmwoaXRlbSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIHVybCA9IGl0ZW0ucG9wdXBVcmwgfHwgbWUucG9wdXBVcmw7XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKHVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwoaXRlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGxvYWRTb3J0Wm9uZU1vZHVsZSgpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydCgnLi4vZHJhZ2dhYmxlL2Rhc2hib2FyZC9Tb3J0Wm9uZS5tanMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnQm91bmRhcnlFbnRyeShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gICAgPSBtZSxcbiAgICAgICAgICAgIHtzb3J0Wm9uZX0gICAgPSBkYXRhLFxuICAgICAgICAgICAgd2lkZ2V0ICAgICAgICA9IGRhdGEuZHJhZ2dlZEl0ZW0sXG4gICAgICAgICAgICB3aWRnZXROYW1lICAgID0gd2lkZ2V0LnJlZmVyZW5jZSB8fCB3aWRnZXQuaWQ7XG5cbiAgICAgICAgbWUuI2lzUmVpbnRlZ3JhdGluZyA9IHRydWU7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ29uRHJhZ0JvdW5kYXJ5RW50cnknLCBtZS5pZCwgd2lkZ2V0KTtcblxuICAgICAgICBzb3J0Wm9uZS5kcmFnUHJveHkuYWRkKHdpZGdldCwgdHJ1ZSk7IC8vIFNpbGVudCBhZGRcblxuICAgICAgICBtZS5kZXRhY2hlZEl0ZW1zLmRlbGV0ZSh3aWRnZXROYW1lKTtcblxuICAgICAgICBhd2FpdCBOZW8uTWFpbi53aW5kb3dDbG9zZSh7bmFtZXM6IHdpZGdldE5hbWUsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgbWUuI2lzUmVpbnRlZ3JhdGluZyAgPSBmYWxzZTtcbiAgICAgICAgbWUuI2lzV2luZG93RHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICBzb3J0Wm9uZS5pc1dpbmRvd0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHNvcnRab25lLmRyYWdQcm94eS5zdHlsZSAgPSB7b3BhY2l0eTogMX07XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0Q29uZmlncyh7aXNXaW5kb3dEcmFnZ2luZzogZmFsc2UsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgbWUuZmlyZSgnZHJhZ0JvdW5kYXJ5RW50cnknLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnQm91bmRhcnlFeGl0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHtkcmFnZ2VkSXRlbSwgcHJveHlSZWN0LCBzb3J0Wm9uZX0gPSBkYXRhLFxuICAgICAgICAgICAgcG9wdXBEYXRhO1xuXG4gICAgICAgIG1lLiNpc1dpbmRvd0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBQcm9oaWJpdCB0aGUgc2l6ZSByZWR1Y3Rpb24gaW5zaWRlICNvcGVuV2lkZ2V0SW5Qb3B1cCgpLlxuICAgICAgICBwcm94eVJlY3QuaGVpZ2h0ICs9IDUwOyAvLyBBZGp1c3QgZm9yIGhlYWRlclxuXG4gICAgICAgIHBvcHVwRGF0YSA9IGF3YWl0IG1lLm9wZW5XaWRnZXRJblBvcHVwKGRyYWdnZWRJdGVtLCBwcm94eVJlY3QpO1xuXG4gICAgICAgIHNvcnRab25lLnN0YXJ0V2luZG93RHJhZyh7XG4gICAgICAgICAgICBkcmFnRGF0YTogZGF0YSxcbiAgICAgICAgICAgIC4uLnBvcHVwRGF0YVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5maXJlKCdkcmFnQm91bmRhcnlFeGl0JywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gd2lkZ2V0XG4gICAgICogQHBhcmFtIHtET01SZWN0fSByZWN0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBhc3luYyBvcGVuV2lkZ2V0SW5Qb3B1cCh3aWRnZXQsIHJlY3QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7d2luZG93SWR9ICAgICAgPSBtZSxcbiAgICAgICAgICAgIHt3aW5kb3dDb25maWdzfSA9IE5lbyxcbiAgICAgICAgICAgIGZpcnN0V2luZG93SWQgICA9IE9iamVjdC5rZXlzKHdpbmRvd0NvbmZpZ3MpWzBdLFxuICAgICAgICAgICAge2Jhc2VQYXRofSAgICAgID0gd2luZG93Q29uZmlnc1tmaXJzdFdpbmRvd0lkXSxcbiAgICAgICAgICAgIHdpZGdldE5hbWUgICAgICA9IHdpZGdldC5yZWZlcmVuY2UgfHwgd2lkZ2V0LmlkLFxuICAgICAgICAgICAgdXJsICAgICAgICAgICAgID0gbWUuZ2V0UG9wdXBVcmwod2lkZ2V0KTtcblxuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gcG9wdXBVcmwgZGVmaW5lZCBmb3IgZGFzaGJvYXJkIGl0ZW0nLCB3aWRnZXQpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgIHVybCA9IGJhc2VQYXRoICsgdXJsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgaWRlbnRpZmljYXRpb24gcGFyYW1zXG4gICAgICAgIHVybCArPSBgJHt1cmwuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/J31uYW1lPSR7d2lkZ2V0TmFtZX0mZGFzaGJvYXJkSWQ9JHttZS5pZH1gO1xuXG4gICAgICAgIGxldCB3aW5EYXRhICAgICAgICAgICAgICAgPSBhd2FpdCBOZW8uTWFpbi5nZXRXaW5kb3dEYXRhKHt3aW5kb3dJZH0pLFxuICAgICAgICAgICAge2hlaWdodCwgd2lkdGgsIHgsIHl9ID0gcmVjdCxcbiAgICAgICAgICAgIHBvcHVwSGVpZ2h0ICAgICAgICAgICA9IGhlaWdodCAtIDUwLCAvLyBwb3B1cCBoZWFkZXIgYWRqdXN0bWVudFxuICAgICAgICAgICAgcG9wdXBMZWZ0ICAgICAgICAgICAgID0geCArIHdpbkRhdGEuc2NyZWVuTGVmdCxcbiAgICAgICAgICAgIHBvcHVwVG9wICAgICAgICAgICAgICA9IHkgKyAod2luRGF0YS5vdXRlckhlaWdodCAtIHdpbkRhdGEuaW5uZXJIZWlnaHQgKyB3aW5EYXRhLnNjcmVlblRvcCksXG4gICAgICAgICAgICB3aW5kb3dOYW1lICAgICAgICAgICAgPSB3aWRnZXROYW1lO1xuXG4gICAgICAgIG1lLmRldGFjaGVkSXRlbXMuc2V0KHdpZGdldE5hbWUsIHtcbiAgICAgICAgICAgIGluZGV4IDogbWUuaXRlbXMuaW5kZXhPZih3aWRnZXQpLFxuICAgICAgICAgICAgd2lkZ2V0OiB3aWRnZXRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgTmVvLk1haW4ud2luZG93T3Blbih7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICB3aW5kb3dJZCxcbiAgICAgICAgICAgIHdpbmRvd0ZlYXR1cmVzOiBgaGVpZ2h0PSR7cG9wdXBIZWlnaHR9LGxlZnQ9JHtwb3B1cExlZnR9LHRvcD0ke3BvcHVwVG9wfSx3aWR0aD0ke3dpZHRofWAsXG4gICAgICAgICAgICB3aW5kb3dOYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7cG9wdXBIZWlnaHQsIHBvcHVwTGVmdCwgcG9wdXBUb3AsIHBvcHVwV2lkdGg6IHdpZHRoLCB3aW5kb3dOYW1lfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgYXN5bmMgb25XaW5kb3dDb25uZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYXBwICAgICAgICA9IE5lby5hcHBzW2RhdGEud2luZG93SWRdLFxuICAgICAgICAgICAgbWFpblZpZXcgICA9IGFwcC5tYWluVmlldyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gPSBkYXRhLFxuICAgICAgICAgICAgdXJsICAgICAgICA9IGF3YWl0IE5lby5NYWluLmdldEJ5UGF0aCh7cGF0aDogJ2RvY3VtZW50LlVSTCcsIHdpbmRvd0lkfSksXG4gICAgICAgICAgICBwYXJhbXMgICAgID0gbmV3IFVSTCh1cmwpLnNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIGRhc2hib2FyZElkPSBwYXJhbXMuZ2V0KCdkYXNoYm9hcmRJZCcpLFxuICAgICAgICAgICAgd2lkZ2V0TmFtZSA9IHBhcmFtcy5nZXQoJ25hbWUnKTtcblxuICAgICAgICBpZiAoZGFzaGJvYXJkSWQgPT09IG1lLmlkKSB7XG4gICAgICAgICAgICBsZXQgZGV0YWNoZWRJdGVtID0gbWUuZGV0YWNoZWRJdGVtcy5nZXQod2lkZ2V0TmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChkZXRhY2hlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBkZXRhY2hlZEl0ZW0ud2luZG93SWQgPSB3aW5kb3dJZDtcblxuICAgICAgICAgICAgICAgIGRldGFjaGVkSXRlbS53aWRnZXQud3JhcHBlclN0eWxlID0ge307XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB3aWRnZXQgdG8gdGhlIHBvcHVwIHdpbmRvd1xuICAgICAgICAgICAgICAgIG1haW5WaWV3LmFkZChkZXRhY2hlZEl0ZW0ud2lkZ2V0LCBmYWxzZSwgIW1lLiNpc1dpbmRvd0RyYWdnaW5nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBhc3luYyBvbldpbmRvd0Rpc2Nvbm5lY3QoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS4jaXNXaW5kb3dEcmFnZ2luZyB8fCBtZS4jaXNSZWludGVncmF0aW5nKSB7XG4gICAgICAgICAgICBtZS4jaXNXaW5kb3dEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQge3dpbmRvd0lkfSA9IGRhdGE7XG5cbiAgICAgICAgZm9yIChjb25zdCBbd2lkZ2V0TmFtZSwgZGV0YWNoZWRJdGVtXSBvZiBtZS5kZXRhY2hlZEl0ZW1zLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKGRldGFjaGVkSXRlbS53aW5kb3dJZCA9PT0gd2luZG93SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb25XaW5kb3dEaXNjb25uZWN0OiBSZS1pbnRlZ3JhdGluZyB3aWRnZXQnLCBtZS5pZCwgd2lkZ2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgbGV0IHtpbmRleCwgd2lkZ2V0fSA9IGRldGFjaGVkSXRlbTtcblxuICAgICAgICAgICAgICAgIG1lLmluc2VydChpbmRleCwgd2lkZ2V0KTtcbiAgICAgICAgICAgICAgICBtZS5kZXRhY2hlZEl0ZW1zLmRlbGV0ZSh3aWRnZXROYW1lKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmUtb3BlbnMgdGhlIHBvcHVwIHdpbmRvdyBhbmQgcmVzdW1lcyB0aGUgd2luZG93IGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIENhbGxlZCBieSB0aGUgRHJhZ0Nvb3JkaW5hdG9yIHdoZW4gYSByZW1vdGUgZHJhZyBsZWF2ZXMgYSB0YXJnZXQgZGFzaGJvYXJkIGJhY2sgaW50byB0aGUgdm9pZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2lkZ2V0TmFtZVxuICAgICAqIEBwYXJhbSB7RE9NUmVjdH0gcHJveHlSZWN0XG4gICAgICovXG4gICAgYXN5bmMgcmVzdW1lV2luZG93RHJhZyh3aWRnZXROYW1lLCBwcm94eVJlY3QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkZXRhY2hlZEl0ZW0gPSBtZS5kZXRhY2hlZEl0ZW1zLmdldCh3aWRnZXROYW1lKSxcbiAgICAgICAgICAgIHBvcHVwRGF0YTtcblxuICAgICAgICBpZiAoZGV0YWNoZWRJdGVtKSB7XG4gICAgICAgICAgICBtZS4jaXNXaW5kb3dEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHBvcHVwRGF0YSA9IGF3YWl0IG1lLm9wZW5XaWRnZXRJblBvcHVwKGRldGFjaGVkSXRlbS53aWRnZXQsIHByb3h5UmVjdCk7XG5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdGVsbCB0aGUgRHJhZ0Ryb3AgYWRkb24gdG8gcmVzdW1lIHdpbmRvdyBkcmFnZ2luZ1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc3RhcnRXaW5kb3dEcmFnKHtcbiAgICAgICAgICAgICAgICBwb3B1cEhlaWdodDogcG9wdXBEYXRhLnBvcHVwSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHBvcHVwTmFtZSAgOiBwb3B1cERhdGEud2luZG93TmFtZSxcbiAgICAgICAgICAgICAgICBwb3B1cFdpZHRoIDogcG9wdXBEYXRhLnBvcHVwV2lkdGgsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgcG9wdXAgd2luZG93IGFuZCBzdXNwZW5kcyB0aGUgd2luZG93IGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIENhbGxlZCBieSB0aGUgRHJhZ0Nvb3JkaW5hdG9yIHdoZW4gYSByZW1vdGUgZHJhZyBlbnRlcnMgYSB0YXJnZXQgZGFzaGJvYXJkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aWRnZXROYW1lXG4gICAgICovXG4gICAgYXN5bmMgc3VzcGVuZFdpbmRvd0RyYWcod2lkZ2V0TmFtZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIFByZXZlbnQgb25XaW5kb3dEaXNjb25uZWN0IGZyb20gYXV0by1yZWludGVncmF0aW5nXG4gICAgICAgIG1lLiNpc1dpbmRvd0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgcGFyZW50IGNoYWluIHRvIHByZXZlbnQgY2lyY3VsYXIgY29uZmlnIGxvb2t1cHMgZHVyaW5nIGhhbmRvdmVyXG4gICAgICAgIGxldCBkZXRhY2hlZEl0ZW0gPSBtZS5kZXRhY2hlZEl0ZW1zLmdldCh3aWRnZXROYW1lKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnc3VzcGVuZFdpbmRvd0RyYWcnLCBtZS5pZCwgd2lkZ2V0TmFtZSwgZGV0YWNoZWRJdGVtKTtcblxuICAgICAgICBpZiAoZGV0YWNoZWRJdGVtPy53aWRnZXQpIHtcbiAgICAgICAgICAgIGRldGFjaGVkSXRlbS53aWRnZXQucGFyZW50SWQgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBOZW8uTWFpbi53aW5kb3dDbG9zZSh7bmFtZXM6IFt3aWRnZXROYW1lXSwgd2luZG93SWQ6IG1lLndpbmRvd0lkfSk7XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0Q29uZmlncyh7aXNXaW5kb3dEcmFnZ2luZzogZmFsc2UsIHdpbmRvd0lkOiBtZS53aW5kb3dJZH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb250YWluZXIpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBEcmFnUHJveHlDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFncHJveHknXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZHJhZ3Byb3h5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Jbml0Vm5vZGU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0luaXRWbm9kZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1kcmFncHJveHknXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZHJhZ3Byb3h5J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5tb3ZlSW5NYWluVGhyZWFkKSB7XG4gICAgICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5zZXREcmFnUHJveHlFbGVtZW50KHthcHBOYW1lLCBpZCwgd2luZG93SWR9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEcmFnUHJveHlDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJhc2VDb250YWluZXIgICAgICBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IERyYWdQcm94eUNvbXBvbmVudCBmcm9tICcuL0RyYWdQcm94eUNvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIERyYWdQcm94eUNvbnRhaW5lciBleHRlbmRzIEJhc2VDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2RyYWdwcm94eWNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFncHJveHljb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0luaXRWbm9kZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvSW5pdFZub2RlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWRyYWdwcm94eSddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1kcmFncHJveHknXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PSdmaXQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiAnZml0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVJbk1haW5UaHJlYWQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUluTWFpblRocmVhZDogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLm1vdmVJbk1haW5UaHJlYWQpIHtcbiAgICAgICAgICAgIGxldCB7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldERyYWdQcm94eUVsZW1lbnQoe2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcmV1c2UgdGhlIHN0eWxpbmcgb2YgdGhlIERyYWdQcm94eUNvbXBvbmVudCwgc2luY2UgYm90aCB1c2UgdGhlIHNhbWUgYmFzZUNscy5cbiAgICAgICAgLy8gSW5zdGVhZCBvZiBkdXBsaWNhdGluZyB0aGUgc2NzcyBmaWxlLCB3ZSBhcmUgZm9yY2luZyB0aGUgVGhlbWVFbmdpbmUgdG8gbG9hZCB0aGUgY29tcG9uZW50IGZpbGUuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgRHJhZ1Byb3h5Q29tcG9uZW50LnByb3RvdHlwZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIGRvIE5PVCB3YW50IHRvIGRlc3Ryb3kgY2hpbGQgaXRlbXMsIHNpbmNlIHRoZXkgZ2V0IHJlLXVzZWQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1Byb3h5Q29udGFpbmVyKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=