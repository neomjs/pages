"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_layout_Cube_mjs"],{

/***/ "./src/layout/Cube.mjs"
/*!*****************************!*\
  !*** ./src/layout/Cube.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Card_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Card.mjs */ "./src/layout/Card.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



const configSymbol = Symbol.for('configSymbol');

/**
 * See: examples/layout.Cube for a demo.
 * Strongly inspired by https://www.mobzystems.com/code/3d-css-and-custom-properties/
 * @class Neo.layout.Cube
 * @extends Neo.layout.Card
 */
class Cube extends _Card_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} faces
     * @static
     */
    static faces = {
        front : [  0,   0, 0],
        back  : [  0, 180, 0],
        left  : [  0,  90, 0],
        right : [  0, 270, 0],
        top   : [270,   0, 0],
        bottom: [ 90,   0, 0]
    }

    static config = {
        /**
         * @member {String} className='Neo.layout.Cube'
         * @protected
         */
        className: 'Neo.layout.Cube',
        /**
         * @member {String} ntype='layout-cube'
         * @protected
         */
        ntype: 'layout-cube',
        /**
         * @member {String|null} activeFace_=null
         * @reactive
         */
        activeFace_: null,
        /**
         * @member {Number|null} activeIndex=null
         */
        activeIndex: null,
        /**
         * @member {String|null} containerCls='neo-layout-fit'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-cube',
        /**
         * Updates the cube size to fit the owner container dimensions
         * @member {Boolean} fitContainer_=false
         * @reactive
         */
        fitContainer_: false,
        /**
         * Important for dynamically switching from a cube to a card layout
         * @member {Boolean} hideInactiveCardsOnDestroy=false
         */
        hideInactiveCardsOnDestroy: false,
        /**
         * @member {Number} perspective_=600
         * @reactive
         */
        perspective_: 600,
        /**
         * @member {Number} rotateX_=0
         * @reactive
         */
        rotateX_: 0,
        /**
         * @member {Number} rotateY_=0
         * @reactive
         */
        rotateY_: 0,
        /**
         * @member {Number} rotateZ_=0
         * @reactive
         */
        rotateZ_: 0,
        /**
         * @member {Number} sideX_=300
         * @reactive
         */
        sideX_: 300,
        /**
         * @member {Number} sideY_=300
         * @reactive
         */
        sideY_: 300,
        /**
         * @member {Number} sideZ_=300
         * @reactive
         */
        sideZ_: 300
    }

    /**
     * @member {Function|null} #cachedVdomItemsRoot=null
     * @private
     */
    #cachedVdomItemsRoot = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {container} = me;

        me.nestVdom();

        me.observeConfig(container, 'mounted', value => {
            value && container.addCls('neo-animate')
        })

        if (container.mounted) {
            container.promiseUpdate().then(() => {
                container.addCls('neo-animate')
            })
        }
    }

    /**
     * Triggered after the activeFace config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetActiveFace(value, oldValue) {
        if (value) {
            this.activeIndex = Object.keys(Cube.faces).indexOf(value)
        }
    }

    /**
     * Triggered after the activeIndex config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    async afterSetActiveIndex(value, oldValue) {
        if (Neo.isNumber(value) && value < 6) {
            let me          = this,
                {container} = me,
                item        = container.items[value];

            // Since activeFace & activeIndex are optional, we need to clear out default values
            if (!Neo.isNumber(oldValue)) {
                delete me[configSymbol].rotateX;
                delete me[configSymbol].rotateY;
                delete me[configSymbol].rotateZ;
            }

            if (Neo.typeOf(item.module) === 'Function') {
                await me.loadModule(item, value);
                container.updateDepth = -1;
                container.update();

                await me.timeout(100) // wait for the view to get painted first
            }

            this.rotateTo(...Object.values(Cube.faces)[value])
        }
    }

    /**
     * Triggered after the fitContainer config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetFitContainer(value, oldValue) {
        if (value) {
            let me          = this,
                {container} = me;

            if (container.mounted) {
                me.updateContainerSize()
            } else {
                container.on('mounted', () => {
                    me.timeout(50).then(() => {
                        me.updateContainerSize()
                    })
                })
            }
        }
    }

    /**
     * Triggered after the perspective config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPerspective(value, oldValue) {
        this.updateContainerCssVar('--perspective', value + 'px')
    }

    /**
     * Triggered after the rotateX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateX(value, oldValue) {
        this.rotateTo(value)
    }

    /**
     * Triggered after the rotateY config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateY(value, oldValue) {
        this.rotateTo(null, value)
    }

    /**
     * Triggered after the rotateZ config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateZ(value, oldValue) {
        this.rotateTo(null, null, value)
    }

    /**
     * Triggered after the sideX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetSideX(value, oldValue) {
        this.updateContainerCssVar('--side-x', value + 'px')
    }

    /**
     * Triggered after the sideX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetSideY(value, oldValue) {
        this.updateContainerCssVar('--side-y', value + 'px')
    }

    /**
     * Triggered after the sideX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetSideZ(value, oldValue) {
        this.updateContainerCssVar('--side-z', value + 'px')
    }

    /**
     * Initially sets the CSS classes of the container items this layout is bound to.
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        let {wrapperCls} = item;

        if (index < 6) {
            wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(wrapperCls, 'neo-face', Object.keys(Cube.faces)[index]);

            switch (index) {
                case 0:
                case 1:
                    wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(wrapperCls, 'neo-face-z');
                    break;
                case 2:
                case 3:
                    wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(wrapperCls, 'neo-face-x');
                    break;
                case 4:
                case 5:
                    wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(wrapperCls, 'neo-face-y');
                    break;
            }

            item.wrapperCls = wrapperCls
        }
    }

    /**
     * @protected
     */
    applyRenderAttributes() {
        this.container.updateDepth = -1;
        super.applyRenderAttributes()
    }

    /**
     * @returns {String}
     */
    getPlaneId() {
        return this.id + '__plane'
    }

    /**
     *
     */
    nestVdom() {
        let me          = this,
            {container} = me,
            {vdom}      = container,
            {cn}        = vdom;

        vdom.cn = [
            {cls: ['neo-plane'], id: me.getPlaneId(), cn: [
                {cls: ['neo-box'], cn}
            ]}
        ];

        // Cache the original method for run-time container layout changes
        me.#cachedVdomItemsRoot = container.getVdomItemsRoot;

        // Override
        container.getVdomItemsRoot = function() {
            return this.vdom.cn[0].cn[0]
        }

        me.timeout(50).then(() => {
            // Important when switching from a card layout to this one
            container.items.forEach((item, index) => {
                if (index < 6) {
                    delete item.vdom.removeDom
                }
            });

            container.updateDepth = -1;
            container.update()
        })
    }

    /**
     * Removes all CSS rules from a container item this layout is bound to.
     * Gets called when switching to a different layout.
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    removeChildAttributes(item, index) {
        let {wrapperCls} = item;

        if (index < 6) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, ['neo-face', Object.keys(Cube.faces)[index]]);

            switch (index) {
                case 0:
                case 1:
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-face-z');
                    break;
                case 2:
                case 3:
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-face-x');
                    break;
                case 4:
                case 5:
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-face-y');
                    break;
            }

            item.wrapperCls = wrapperCls
        }
    }

    /**
     * @protected
     */
    removeRenderAttributes() {
        super.removeRenderAttributes();

        let me                 = this,
            {container}        = me,
            {cls, style, vdom} = container;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-animate');

        Object.assign(style, {
            '--perspective': null,
            '--rot-x'      : null,
            '--rot-y'      : null,
            '--rot-z'      : null,
            '--side-x'     : null,
            '--side-y'     : null,
            '--side-z'     : null
        });

        container.set({cls, style});

        vdom.cn = container.getVdomItemsRoot().cn;

        if (me.hideInactiveCardsOnDestroy) {
            container.items.forEach((item, index) => {
                if (index < 6 && index !== me.activeIndex) {
                    item.vdom.removeDom = true
                }
            })
        }

        // override
        container.getVdomItemsRoot = me.#cachedVdomItemsRoot;

        container.updateDepth = -1;
        container.update();
    }

    /**
     * @param {Number|null} [x]
     * @param {Number|null} [y]
     * @param {Number|null} [z]
     */
    rotateTo(x, y, z) {
        let me          = this,
            {container} = me,
            {style}     = container;

        if (Neo.isNumber(x)) {me._rotateX = x; style['--rot-x'] = x + 'deg'}
        if (Neo.isNumber(y)) {me._rotateY = y; style['--rot-y'] = y + 'deg'}
        if (Neo.isNumber(z)) {me._rotateZ = z; style['--rot-z'] = z + 'deg'}

        container.style = style
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            activeFace                : me.activeFace,
            activeIndex               : me.activeIndex,
            fitContainer              : me.fitContainer,
            hideInactiveCardsOnDestroy: me.hideInactiveCardsOnDestroy,
            perspective               : me.perspective,
            rotateX                   : me.rotateX,
            rotateY                   : me.rotateY,
            rotateZ                   : me.rotateZ,
            sideX                     : me.sideX,
            sideY                     : me.sideY,
            sideZ                     : me.sideZ
        }
    }

    /**
     * @param {String} name
     * @param {String} value
     */
    updateContainerCssVar(name, value) {
        let {container} = this,
            {style}     = container;

        style[name] = value;

        container.style = style
    }

    /**
     *
     */
    async updateContainerSize() {
        let {container}     = this,
            {height, width} = await container.getDomRect(container.id);

        this.set({
            sideX: width,
            sideY: height,
            sideZ: width
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Cube));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19sYXlvdXRfQ3ViZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ087O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBSTtBQUN2QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxXQUFXOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0Es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QUFDQSxTQUFTOztBQUVULHVCQUF1QixXQUFXOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsV0FBVzs7QUFFeEIsOEJBQThCLGlCQUFpQjtBQUMvQyw4QkFBOEIsaUJBQWlCO0FBQy9DLDhCQUE4QixpQkFBaUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsV0FBVzs7QUFFeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLGVBQWU7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2xheW91dC9DdWJlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FyZCAgICAgZnJvbSAnLi9DYXJkLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG5jb25zdCBjb25maWdTeW1ib2wgPSBTeW1ib2wuZm9yKCdjb25maWdTeW1ib2wnKTtcblxuLyoqXG4gKiBTZWU6IGV4YW1wbGVzL2xheW91dC5DdWJlIGZvciBhIGRlbW8uXG4gKiBTdHJvbmdseSBpbnNwaXJlZCBieSBodHRwczovL3d3dy5tb2J6eXN0ZW1zLmNvbS9jb2RlLzNkLWNzcy1hbmQtY3VzdG9tLXByb3BlcnRpZXMvXG4gKiBAY2xhc3MgTmVvLmxheW91dC5DdWJlXG4gKiBAZXh0ZW5kcyBOZW8ubGF5b3V0LkNhcmRcbiAqL1xuY2xhc3MgQ3ViZSBleHRlbmRzIENhcmQge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZmFjZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGZhY2VzID0ge1xuICAgICAgICBmcm9udCA6IFsgIDAsICAgMCwgMF0sXG4gICAgICAgIGJhY2sgIDogWyAgMCwgMTgwLCAwXSxcbiAgICAgICAgbGVmdCAgOiBbICAwLCAgOTAsIDBdLFxuICAgICAgICByaWdodCA6IFsgIDAsIDI3MCwgMF0sXG4gICAgICAgIHRvcCAgIDogWzI3MCwgICAwLCAwXSxcbiAgICAgICAgYm90dG9tOiBbIDkwLCAgIDAsIDBdXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubGF5b3V0LkN1YmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5sYXlvdXQuQ3ViZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYXlvdXQtY3ViZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYXlvdXQtY3ViZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYWN0aXZlRmFjZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZUZhY2VfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFjdGl2ZUluZGV4PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZUluZGV4OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbnRhaW5lckNscz0nbmVvLWxheW91dC1maXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluZXJDbHM6ICduZW8tbGF5b3V0LWN1YmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgY3ViZSBzaXplIHRvIGZpdCB0aGUgb3duZXIgY29udGFpbmVyIGRpbWVuc2lvbnNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZml0Q29udGFpbmVyXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGZpdENvbnRhaW5lcl86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wb3J0YW50IGZvciBkeW5hbWljYWxseSBzd2l0Y2hpbmcgZnJvbSBhIGN1YmUgdG8gYSBjYXJkIGxheW91dFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWRlSW5hY3RpdmVDYXJkc09uRGVzdHJveT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUluYWN0aXZlQ2FyZHNPbkRlc3Ryb3k6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBwZXJzcGVjdGl2ZV89NjAwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGVyc3BlY3RpdmVfOiA2MDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvdGF0ZVhfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVYXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm90YXRlWV89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZVlfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3RhdGVaXz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlWl86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNpZGVYXz0zMDBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaWRlWF86IDMwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2lkZVlfPTMwMFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNpZGVZXzogMzAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzaWRlWl89MzAwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lkZVpfOiAzMDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSAjY2FjaGVkVmRvbUl0ZW1zUm9vdD1udWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjY2FjaGVkVmRvbUl0ZW1zUm9vdCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyfSA9IG1lO1xuXG4gICAgICAgIG1lLm5lc3RWZG9tKCk7XG5cbiAgICAgICAgbWUub2JzZXJ2ZUNvbmZpZyhjb250YWluZXIsICdtb3VudGVkJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgdmFsdWUgJiYgY29udGFpbmVyLmFkZENscygnbmVvLWFuaW1hdGUnKVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChjb250YWluZXIubW91bnRlZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYWRkQ2xzKCduZW8tYW5pbWF0ZScpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhY3RpdmVGYWNlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBY3RpdmVGYWNlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBPYmplY3Qua2V5cyhDdWJlLmZhY2VzKS5pbmRleE9mKHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhY3RpdmVJbmRleCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0QWN0aXZlSW5kZXgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlIDwgNikge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7Y29udGFpbmVyfSA9IG1lLFxuICAgICAgICAgICAgICAgIGl0ZW0gICAgICAgID0gY29udGFpbmVyLml0ZW1zW3ZhbHVlXTtcblxuICAgICAgICAgICAgLy8gU2luY2UgYWN0aXZlRmFjZSAmIGFjdGl2ZUluZGV4IGFyZSBvcHRpb25hbCwgd2UgbmVlZCB0byBjbGVhciBvdXQgZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICghTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdLnJvdGF0ZVg7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lW2NvbmZpZ1N5bWJvbF0ucm90YXRlWTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWVbY29uZmlnU3ltYm9sXS5yb3RhdGVaO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTmVvLnR5cGVPZihpdGVtLm1vZHVsZSkgPT09ICdGdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5sb2FkTW9kdWxlKGl0ZW0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDEwMCkgLy8gd2FpdCBmb3IgdGhlIHZpZXcgdG8gZ2V0IHBhaW50ZWQgZmlyc3RcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yb3RhdGVUbyguLi5PYmplY3QudmFsdWVzKEN1YmUuZmFjZXMpW3ZhbHVlXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZml0Q29udGFpbmVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Rml0Q29udGFpbmVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2NvbnRhaW5lcn0gPSBtZTtcblxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlQ29udGFpbmVyU2l6ZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5vbignbW91bnRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDb250YWluZXJTaXplKClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBwZXJzcGVjdGl2ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQZXJzcGVjdGl2ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb250YWluZXJDc3NWYXIoJy0tcGVyc3BlY3RpdmUnLCB2YWx1ZSArICdweCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3RhdGVYIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvdGF0ZVgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMucm90YXRlVG8odmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3RhdGVZIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvdGF0ZVkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMucm90YXRlVG8obnVsbCwgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3RhdGVaIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvdGF0ZVoodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMucm90YXRlVG8obnVsbCwgbnVsbCwgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaWRlWCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaWRlWCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb250YWluZXJDc3NWYXIoJy0tc2lkZS14JywgdmFsdWUgKyAncHgnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2lkZVggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2lkZVkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyQ3NzVmFyKCctLXNpZGUteScsIHZhbHVlICsgJ3B4JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNpZGVYIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNpZGVaKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lckNzc1ZhcignLS1zaWRlLXonLCB2YWx1ZSArICdweCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGx5IHNldHMgdGhlIENTUyBjbGFzc2VzIG9mIHRoZSBjb250YWluZXIgaXRlbXMgdGhpcyBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKi9cbiAgICBhcHBseUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCkge1xuICAgICAgICBsZXQge3dyYXBwZXJDbHN9ID0gaXRlbTtcblxuICAgICAgICBpZiAoaW5kZXggPCA2KSB7XG4gICAgICAgICAgICB3cmFwcGVyQ2xzID0gTmVvQXJyYXkudW5pb24od3JhcHBlckNscywgJ25lby1mYWNlJywgT2JqZWN0LmtleXMoQ3ViZS5mYWNlcylbaW5kZXhdKTtcblxuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJDbHMgPSBOZW9BcnJheS51bmlvbih3cmFwcGVyQ2xzLCAnbmVvLWZhY2UteicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyQ2xzID0gTmVvQXJyYXkudW5pb24od3JhcHBlckNscywgJ25lby1mYWNlLXgnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlckNscyA9IE5lb0FycmF5LnVuaW9uKHdyYXBwZXJDbHMsICduZW8tZmFjZS15Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXBwbHlSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci51cGRhdGVEZXB0aCA9IC0xO1xuICAgICAgICBzdXBlci5hcHBseVJlbmRlckF0dHJpYnV0ZXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0UGxhbmVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyAnX19wbGFuZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG5lc3RWZG9tKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbnRhaW5lcn0gPSBtZSxcbiAgICAgICAgICAgIHt2ZG9tfSAgICAgID0gY29udGFpbmVyLFxuICAgICAgICAgICAge2NufSAgICAgICAgPSB2ZG9tO1xuXG4gICAgICAgIHZkb20uY24gPSBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1wbGFuZSddLCBpZDogbWUuZ2V0UGxhbmVJZCgpLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWJveCddLCBjbn1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIG9yaWdpbmFsIG1ldGhvZCBmb3IgcnVuLXRpbWUgY29udGFpbmVyIGxheW91dCBjaGFuZ2VzXG4gICAgICAgIG1lLiNjYWNoZWRWZG9tSXRlbXNSb290ID0gY29udGFpbmVyLmdldFZkb21JdGVtc1Jvb3Q7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGVcbiAgICAgICAgY29udGFpbmVyLmdldFZkb21JdGVtc1Jvb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gSW1wb3J0YW50IHdoZW4gc3dpdGNoaW5nIGZyb20gYSBjYXJkIGxheW91dCB0byB0aGlzIG9uZVxuICAgICAgICAgICAgY29udGFpbmVyLml0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgNikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS52ZG9tLnJlbW92ZURvbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250YWluZXIudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgICAgIGNvbnRhaW5lci51cGRhdGUoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIENTUyBydWxlcyBmcm9tIGEgY29udGFpbmVyIGl0ZW0gdGhpcyBsYXlvdXQgaXMgYm91bmQgdG8uXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiBzd2l0Y2hpbmcgdG8gYSBkaWZmZXJlbnQgbGF5b3V0LlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkQXR0cmlidXRlcyhpdGVtLCBpbmRleCkge1xuICAgICAgICBsZXQge3dyYXBwZXJDbHN9ID0gaXRlbTtcblxuICAgICAgICBpZiAoaW5kZXggPCA2KSB7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUod3JhcHBlckNscywgWyduZW8tZmFjZScsIE9iamVjdC5rZXlzKEN1YmUuZmFjZXMpW2luZGV4XV0pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsICduZW8tZmFjZS16Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCAnbmVvLWZhY2UteCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUod3JhcHBlckNscywgJ25lby1mYWNlLXknKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVSZW5kZXJBdHRyaWJ1dGVzKCkge1xuICAgICAgICBzdXBlci5yZW1vdmVSZW5kZXJBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyfSAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIHtjbHMsIHN0eWxlLCB2ZG9tfSA9IGNvbnRhaW5lcjtcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCAnbmVvLWFuaW1hdGUnKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgICAgICAnLS1wZXJzcGVjdGl2ZSc6IG51bGwsXG4gICAgICAgICAgICAnLS1yb3QteCcgICAgICA6IG51bGwsXG4gICAgICAgICAgICAnLS1yb3QteScgICAgICA6IG51bGwsXG4gICAgICAgICAgICAnLS1yb3QteicgICAgICA6IG51bGwsXG4gICAgICAgICAgICAnLS1zaWRlLXgnICAgICA6IG51bGwsXG4gICAgICAgICAgICAnLS1zaWRlLXknICAgICA6IG51bGwsXG4gICAgICAgICAgICAnLS1zaWRlLXonICAgICA6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29udGFpbmVyLnNldCh7Y2xzLCBzdHlsZX0pO1xuXG4gICAgICAgIHZkb20uY24gPSBjb250YWluZXIuZ2V0VmRvbUl0ZW1zUm9vdCgpLmNuO1xuXG4gICAgICAgIGlmIChtZS5oaWRlSW5hY3RpdmVDYXJkc09uRGVzdHJveSkge1xuICAgICAgICAgICAgY29udGFpbmVyLml0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgNiAmJiBpbmRleCAhPT0gbWUuYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52ZG9tLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3ZlcnJpZGVcbiAgICAgICAgY29udGFpbmVyLmdldFZkb21JdGVtc1Jvb3QgPSBtZS4jY2FjaGVkVmRvbUl0ZW1zUm9vdDtcblxuICAgICAgICBjb250YWluZXIudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgY29udGFpbmVyLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt4XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt6XVxuICAgICAqL1xuICAgIHJvdGF0ZVRvKHgsIHksIHopIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXJ9ID0gbWUsXG4gICAgICAgICAgICB7c3R5bGV9ICAgICA9IGNvbnRhaW5lcjtcblxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHgpKSB7bWUuX3JvdGF0ZVggPSB4OyBzdHlsZVsnLS1yb3QteCddID0geCArICdkZWcnfVxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHkpKSB7bWUuX3JvdGF0ZVkgPSB5OyBzdHlsZVsnLS1yb3QteSddID0geSArICdkZWcnfVxuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHopKSB7bWUuX3JvdGF0ZVogPSB6OyBzdHlsZVsnLS1yb3QteiddID0geiArICdkZWcnfVxuXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZSA9IHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBhY3RpdmVGYWNlICAgICAgICAgICAgICAgIDogbWUuYWN0aXZlRmFjZSxcbiAgICAgICAgICAgIGFjdGl2ZUluZGV4ICAgICAgICAgICAgICAgOiBtZS5hY3RpdmVJbmRleCxcbiAgICAgICAgICAgIGZpdENvbnRhaW5lciAgICAgICAgICAgICAgOiBtZS5maXRDb250YWluZXIsXG4gICAgICAgICAgICBoaWRlSW5hY3RpdmVDYXJkc09uRGVzdHJveTogbWUuaGlkZUluYWN0aXZlQ2FyZHNPbkRlc3Ryb3ksXG4gICAgICAgICAgICBwZXJzcGVjdGl2ZSAgICAgICAgICAgICAgIDogbWUucGVyc3BlY3RpdmUsXG4gICAgICAgICAgICByb3RhdGVYICAgICAgICAgICAgICAgICAgIDogbWUucm90YXRlWCxcbiAgICAgICAgICAgIHJvdGF0ZVkgICAgICAgICAgICAgICAgICAgOiBtZS5yb3RhdGVZLFxuICAgICAgICAgICAgcm90YXRlWiAgICAgICAgICAgICAgICAgICA6IG1lLnJvdGF0ZVosXG4gICAgICAgICAgICBzaWRlWCAgICAgICAgICAgICAgICAgICAgIDogbWUuc2lkZVgsXG4gICAgICAgICAgICBzaWRlWSAgICAgICAgICAgICAgICAgICAgIDogbWUuc2lkZVksXG4gICAgICAgICAgICBzaWRlWiAgICAgICAgICAgICAgICAgICAgIDogbWUuc2lkZVpcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlQ29udGFpbmVyQ3NzVmFyKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCB7Y29udGFpbmVyfSA9IHRoaXMsXG4gICAgICAgICAgICB7c3R5bGV9ICAgICA9IGNvbnRhaW5lcjtcblxuICAgICAgICBzdHlsZVtuYW1lXSA9IHZhbHVlO1xuXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZSA9IHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVDb250YWluZXJTaXplKCkge1xuICAgICAgICBsZXQge2NvbnRhaW5lcn0gICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtoZWlnaHQsIHdpZHRofSA9IGF3YWl0IGNvbnRhaW5lci5nZXREb21SZWN0KGNvbnRhaW5lci5pZCk7XG5cbiAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgICAgc2lkZVg6IHdpZHRoLFxuICAgICAgICAgICAgc2lkZVk6IGhlaWdodCxcbiAgICAgICAgICAgIHNpZGVaOiB3aWR0aFxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ3ViZSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9