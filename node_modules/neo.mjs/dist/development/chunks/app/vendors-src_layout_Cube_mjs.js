export const __webpack_esm_id__ = "vendors-src_layout_Cube_mjs";
export const __webpack_esm_ids__ = ["vendors-src_layout_Cube_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/layout/Cube.mjs"
/*!*****************************!*\
  !*** ./src/layout/Cube.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Card_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Card.mjs */ "./src/layout/Card.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



const configSymbol = Symbol.for('configSymbol');

/**
 * See: examples/layout.Cube for a demo.
 * Strongly inspired by https://www.mobzystems.com/code/3d-css-and-custom-properties/
 * @class Neo.layout.Cube
 * @extends Neo.layout.Card
 */
class Cube extends _Card_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} faces
     * @static
     */
    static faces = {
        front : [  0,   0, 0],
        back  : [  0, 180, 0],
        left  : [  0,  90, 0],
        right : [  0, 270, 0],
        top   : [270,   0, 0],
        bottom: [ 90,   0, 0]
    }

    static config = {
        /**
         * @member {String} className='Neo.layout.Cube'
         * @protected
         */
        className: 'Neo.layout.Cube',
        /**
         * @member {String} ntype='layout-cube'
         * @protected
         */
        ntype: 'layout-cube',
        /**
         * @member {String|null} activeFace_=null
         * @reactive
         */
        activeFace_: null,
        /**
         * @member {Number|null} activeIndex=null
         */
        activeIndex: null,
        /**
         * @member {String|null} containerCls='neo-layout-fit'
         * @protected
         * @reactive
         */
        containerCls: 'neo-layout-cube',
        /**
         * Updates the cube size to fit the owner container dimensions
         * @member {Boolean} fitContainer_=false
         * @reactive
         */
        fitContainer_: false,
        /**
         * Important for dynamically switching from a cube to a card layout
         * @member {Boolean} hideInactiveCardsOnDestroy=false
         */
        hideInactiveCardsOnDestroy: false,
        /**
         * @member {Number} perspective_=600
         * @reactive
         */
        perspective_: 600,
        /**
         * @member {Number} rotateX_=0
         * @reactive
         */
        rotateX_: 0,
        /**
         * @member {Number} rotateY_=0
         * @reactive
         */
        rotateY_: 0,
        /**
         * @member {Number} rotateZ_=0
         * @reactive
         */
        rotateZ_: 0,
        /**
         * @member {Number} sideX_=300
         * @reactive
         */
        sideX_: 300,
        /**
         * @member {Number} sideY_=300
         * @reactive
         */
        sideY_: 300,
        /**
         * @member {Number} sideZ_=300
         * @reactive
         */
        sideZ_: 300
    }

    /**
     * @member {Function|null} #cachedVdomItemsRoot=null
     * @private
     */
    #cachedVdomItemsRoot = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {container} = me;

        me.nestVdom();

        me.observeConfig(container, 'mounted', value => {
            value && container.addCls('neo-animate')
        })

        if (container.mounted) {
            container.promiseUpdate().then(() => {
                container.addCls('neo-animate')
            })
        }
    }

    /**
     * Triggered after the activeFace config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetActiveFace(value, oldValue) {
        if (value) {
            this.activeIndex = Object.keys(Cube.faces).indexOf(value)
        }
    }

    /**
     * Triggered after the activeIndex config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    async afterSetActiveIndex(value, oldValue) {
        if (Neo.isNumber(value) && value < 6) {
            let me          = this,
                {container} = me,
                item        = container.items[value];

            // Since activeFace & activeIndex are optional, we need to clear out default values
            if (!Neo.isNumber(oldValue)) {
                delete me[configSymbol].rotateX;
                delete me[configSymbol].rotateY;
                delete me[configSymbol].rotateZ;
            }

            if (Neo.typeOf(item.module) === 'Function') {
                await me.loadModule(item, value);
                container.updateDepth = -1;
                container.update();

                await me.timeout(100) // wait for the view to get painted first
            }

            this.rotateTo(...Object.values(Cube.faces)[value])
        }
    }

    /**
     * Triggered after the fitContainer config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetFitContainer(value, oldValue) {
        if (value) {
            let me          = this,
                {container} = me;

            if (container.mounted) {
                me.updateContainerSize()
            } else {
                container.on('mounted', () => {
                    me.timeout(50).then(() => {
                        me.updateContainerSize()
                    })
                })
            }
        }
    }

    /**
     * Triggered after the perspective config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPerspective(value, oldValue) {
        this.updateContainerCssVar('--perspective', value + 'px')
    }

    /**
     * Triggered after the rotateX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateX(value, oldValue) {
        this.rotateTo(value)
    }

    /**
     * Triggered after the rotateY config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateY(value, oldValue) {
        this.rotateTo(null, value)
    }

    /**
     * Triggered after the rotateZ config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRotateZ(value, oldValue) {
        this.rotateTo(null, null, value)
    }

    /**
     * Triggered after the sideX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetSideX(value, oldValue) {
        this.updateContainerCssVar('--side-x', value + 'px')
    }

    /**
     * Triggered after the sideX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetSideY(value, oldValue) {
        this.updateContainerCssVar('--side-y', value + 'px')
    }

    /**
     * Triggered after the sideX config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetSideZ(value, oldValue) {
        this.updateContainerCssVar('--side-z', value + 'px')
    }

    /**
     * Initially sets the CSS classes of the container items this layout is bound to.
     * @param {Neo.component.Base} item
     * @param {Number} index
     */
    applyChildAttributes(item, index) {
        let {wrapperCls} = item;

        if (index < 6) {
            wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(wrapperCls, 'neo-face', Object.keys(Cube.faces)[index]);

            switch (index) {
                case 0:
                case 1:
                    wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(wrapperCls, 'neo-face-z');
                    break;
                case 2:
                case 3:
                    wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(wrapperCls, 'neo-face-x');
                    break;
                case 4:
                case 5:
                    wrapperCls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].union(wrapperCls, 'neo-face-y');
                    break;
            }

            item.wrapperCls = wrapperCls
        }
    }

    /**
     * @protected
     */
    applyRenderAttributes() {
        this.container.updateDepth = -1;
        super.applyRenderAttributes()
    }

    /**
     * @returns {String}
     */
    getPlaneId() {
        return this.id + '__plane'
    }

    /**
     *
     */
    nestVdom() {
        let me          = this,
            {container} = me,
            {vdom}      = container,
            {cn}        = vdom;

        vdom.cn = [
            {cls: ['neo-plane'], id: me.getPlaneId(), cn: [
                {cls: ['neo-box'], cn}
            ]}
        ];

        // Cache the original method for run-time container layout changes
        me.#cachedVdomItemsRoot = container.getVdomItemsRoot;

        // Override
        container.getVdomItemsRoot = function() {
            return this.vdom.cn[0].cn[0]
        }

        me.timeout(50).then(() => {
            // Important when switching from a card layout to this one
            container.items.forEach((item, index) => {
                if (index < 6) {
                    delete item.vdom.removeDom
                }
            });

            container.updateDepth = -1;
            container.update()
        })
    }

    /**
     * Removes all CSS rules from a container item this layout is bound to.
     * Gets called when switching to a different layout.
     * @param {Neo.component.Base} item
     * @param {Number} index
     * @protected
     */
    removeChildAttributes(item, index) {
        let {wrapperCls} = item;

        if (index < 6) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, ['neo-face', Object.keys(Cube.faces)[index]]);

            switch (index) {
                case 0:
                case 1:
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-face-z');
                    break;
                case 2:
                case 3:
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-face-x');
                    break;
                case 4:
                case 5:
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(wrapperCls, 'neo-face-y');
                    break;
            }

            item.wrapperCls = wrapperCls
        }
    }

    /**
     * @protected
     */
    removeRenderAttributes() {
        super.removeRenderAttributes();

        let me                 = this,
            {container}        = me,
            {cls, style, vdom} = container;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(cls, 'neo-animate');

        Object.assign(style, {
            '--perspective': null,
            '--rot-x'      : null,
            '--rot-y'      : null,
            '--rot-z'      : null,
            '--side-x'     : null,
            '--side-y'     : null,
            '--side-z'     : null
        });

        container.set({cls, style});

        vdom.cn = container.getVdomItemsRoot().cn;

        if (me.hideInactiveCardsOnDestroy) {
            container.items.forEach((item, index) => {
                if (index < 6 && index !== me.activeIndex) {
                    item.vdom.removeDom = true
                }
            })
        }

        // override
        container.getVdomItemsRoot = me.#cachedVdomItemsRoot;

        container.updateDepth = -1;
        container.update();
    }

    /**
     * @param {Number|null} [x]
     * @param {Number|null} [y]
     * @param {Number|null} [z]
     */
    rotateTo(x, y, z) {
        let me          = this,
            {container} = me,
            {style}     = container;

        if (Neo.isNumber(x)) {me._rotateX = x; style['--rot-x'] = x + 'deg'}
        if (Neo.isNumber(y)) {me._rotateY = y; style['--rot-y'] = y + 'deg'}
        if (Neo.isNumber(z)) {me._rotateZ = z; style['--rot-z'] = z + 'deg'}

        container.style = style
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            activeFace                : me.activeFace,
            activeIndex               : me.activeIndex,
            fitContainer              : me.fitContainer,
            hideInactiveCardsOnDestroy: me.hideInactiveCardsOnDestroy,
            perspective               : me.perspective,
            rotateX                   : me.rotateX,
            rotateY                   : me.rotateY,
            rotateZ                   : me.rotateZ,
            sideX                     : me.sideX,
            sideY                     : me.sideY,
            sideZ                     : me.sideZ
        }
    }

    /**
     * @param {String} name
     * @param {String} value
     */
    updateContainerCssVar(name, value) {
        let {container} = this,
            {style}     = container;

        style[name] = value;

        container.style = style
    }

    /**
     *
     */
    async updateContainerSize() {
        let {container}     = this,
            {height, width} = await container.getDomRect(container.id);

        this.set({
            sideX: width,
            sideY: height,
            sideZ: width
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Cube));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19sYXlvdXRfQ3ViZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNPOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQUk7QUFDdkI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsV0FBVzs7QUFFeEI7O0FBRUE7QUFDQTtBQUNB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O0FBQ0EsU0FBUzs7QUFFVCx1QkFBdUIsV0FBVzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFdBQVc7O0FBRXhCLDhCQUE4QixpQkFBaUI7QUFDL0MsOEJBQThCLGlCQUFpQjtBQUMvQyw4QkFBOEIsaUJBQWlCOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFdBQVc7O0FBRXhCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxlQUFlOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9sYXlvdXQvQ3ViZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcmQgICAgIGZyb20gJy4vQ2FyZC5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuY29uc3QgY29uZmlnU3ltYm9sID0gU3ltYm9sLmZvcignY29uZmlnU3ltYm9sJyk7XG5cbi8qKlxuICogU2VlOiBleGFtcGxlcy9sYXlvdXQuQ3ViZSBmb3IgYSBkZW1vLlxuICogU3Ryb25nbHkgaW5zcGlyZWQgYnkgaHR0cHM6Ly93d3cubW9ienlzdGVtcy5jb20vY29kZS8zZC1jc3MtYW5kLWN1c3RvbS1wcm9wZXJ0aWVzL1xuICogQGNsYXNzIE5lby5sYXlvdXQuQ3ViZVxuICogQGV4dGVuZHMgTmVvLmxheW91dC5DYXJkXG4gKi9cbmNsYXNzIEN1YmUgZXh0ZW5kcyBDYXJkIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGZhY2VzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBmYWNlcyA9IHtcbiAgICAgICAgZnJvbnQgOiBbICAwLCAgIDAsIDBdLFxuICAgICAgICBiYWNrICA6IFsgIDAsIDE4MCwgMF0sXG4gICAgICAgIGxlZnQgIDogWyAgMCwgIDkwLCAwXSxcbiAgICAgICAgcmlnaHQgOiBbICAwLCAyNzAsIDBdLFxuICAgICAgICB0b3AgICA6IFsyNzAsICAgMCwgMF0sXG4gICAgICAgIGJvdHRvbTogWyA5MCwgICAwLCAwXVxuICAgIH1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmxheW91dC5DdWJlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubGF5b3V0LkN1YmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbGF5b3V0LWN1YmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbGF5b3V0LWN1YmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFjdGl2ZUZhY2VfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVGYWNlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBhY3RpdmVJbmRleD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVJbmRleDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb250YWluZXJDbHM9J25lby1sYXlvdXQtZml0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ2xzOiAnbmVvLWxheW91dC1jdWJlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGN1YmUgc2l6ZSB0byBmaXQgdGhlIG93bmVyIGNvbnRhaW5lciBkaW1lbnNpb25zXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGZpdENvbnRhaW5lcl89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBmaXRDb250YWluZXJfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcG9ydGFudCBmb3IgZHluYW1pY2FsbHkgc3dpdGNoaW5nIGZyb20gYSBjdWJlIHRvIGEgY2FyZCBsYXlvdXRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGlkZUluYWN0aXZlQ2FyZHNPbkRlc3Ryb3k9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVJbmFjdGl2ZUNhcmRzT25EZXN0cm95OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcGVyc3BlY3RpdmVfPTYwMFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBlcnNwZWN0aXZlXzogNjAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSByb3RhdGVYXz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlWF86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvdGF0ZVlfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVZXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gcm90YXRlWl89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZVpfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzaWRlWF89MzAwXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lkZVhfOiAzMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNpZGVZXz0zMDBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaWRlWV86IDMwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2lkZVpfPTMwMFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNpZGVaXzogMzAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb258bnVsbH0gI2NhY2hlZFZkb21JdGVtc1Jvb3Q9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2NhY2hlZFZkb21JdGVtc1Jvb3QgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbnRhaW5lcn0gPSBtZTtcblxuICAgICAgICBtZS5uZXN0VmRvbSgpO1xuXG4gICAgICAgIG1lLm9ic2VydmVDb25maWcoY29udGFpbmVyLCAnbW91bnRlZCcsIHZhbHVlID0+IHtcbiAgICAgICAgICAgIHZhbHVlICYmIGNvbnRhaW5lci5hZGRDbHMoJ25lby1hbmltYXRlJylcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoY29udGFpbmVyLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wcm9taXNlVXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFkZENscygnbmVvLWFuaW1hdGUnKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYWN0aXZlRmFjZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWN0aXZlRmFjZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gT2JqZWN0LmtleXMoQ3ViZS5mYWNlcykuaW5kZXhPZih2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYWN0aXZlSW5kZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldEFjdGl2ZUluZGV4KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA8IDYpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2NvbnRhaW5lcn0gPSBtZSxcbiAgICAgICAgICAgICAgICBpdGVtICAgICAgICA9IGNvbnRhaW5lci5pdGVtc1t2YWx1ZV07XG5cbiAgICAgICAgICAgIC8vIFNpbmNlIGFjdGl2ZUZhY2UgJiBhY3RpdmVJbmRleCBhcmUgb3B0aW9uYWwsIHdlIG5lZWQgdG8gY2xlYXIgb3V0IGRlZmF1bHQgdmFsdWVzXG4gICAgICAgICAgICBpZiAoIU5lby5pc051bWJlcihvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWVbY29uZmlnU3ltYm9sXS5yb3RhdGVYO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZVtjb25maWdTeW1ib2xdLnJvdGF0ZVk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lW2NvbmZpZ1N5bWJvbF0ucm90YXRlWjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoaXRlbS5tb2R1bGUpID09PSAnRnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUubG9hZE1vZHVsZShpdGVtLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMDApIC8vIHdhaXQgZm9yIHRoZSB2aWV3IHRvIGdldCBwYWludGVkIGZpcnN0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm90YXRlVG8oLi4uT2JqZWN0LnZhbHVlcyhDdWJlLmZhY2VzKVt2YWx1ZV0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZpdENvbnRhaW5lciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpdENvbnRhaW5lcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtjb250YWluZXJ9ID0gbWU7XG5cbiAgICAgICAgICAgIGlmIChjb250YWluZXIubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUNvbnRhaW5lclNpemUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIub24oJ21vdW50ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlQ29udGFpbmVyU2l6ZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcGVyc3BlY3RpdmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UGVyc3BlY3RpdmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyQ3NzVmFyKCctLXBlcnNwZWN0aXZlJywgdmFsdWUgKyAncHgnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRlWCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGVYKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVRvKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRlWSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGVZKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVRvKG51bGwsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm90YXRlWiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb3RhdGVaKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVRvKG51bGwsIG51bGwsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2lkZVggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2lkZVgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyQ3NzVmFyKCctLXNpZGUteCcsIHZhbHVlICsgJ3B4JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNpZGVYIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNpZGVZKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lckNzc1ZhcignLS1zaWRlLXknLCB2YWx1ZSArICdweCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaWRlWCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaWRlWih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb250YWluZXJDc3NWYXIoJy0tc2lkZS16JywgdmFsdWUgKyAncHgnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxseSBzZXRzIHRoZSBDU1MgY2xhc3NlcyBvZiB0aGUgY29udGFpbmVyIGl0ZW1zIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBpdGVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICovXG4gICAgYXBwbHlDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHt3cmFwcGVyQ2xzfSA9IGl0ZW07XG5cbiAgICAgICAgaWYgKGluZGV4IDwgNikge1xuICAgICAgICAgICAgd3JhcHBlckNscyA9IE5lb0FycmF5LnVuaW9uKHdyYXBwZXJDbHMsICduZW8tZmFjZScsIE9iamVjdC5rZXlzKEN1YmUuZmFjZXMpW2luZGV4XSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyQ2xzID0gTmVvQXJyYXkudW5pb24od3JhcHBlckNscywgJ25lby1mYWNlLXonKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlckNscyA9IE5lb0FycmF5LnVuaW9uKHdyYXBwZXJDbHMsICduZW8tZmFjZS14Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJDbHMgPSBOZW9BcnJheS51bmlvbih3cmFwcGVyQ2xzLCAnbmVvLWZhY2UteScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFwcGx5UmVuZGVyQXR0cmlidXRlcygpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgc3VwZXIuYXBwbHlSZW5kZXJBdHRyaWJ1dGVzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFBsYW5lSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJ19fcGxhbmUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBuZXN0VmRvbSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb250YWluZXJ9ID0gbWUsXG4gICAgICAgICAgICB7dmRvbX0gICAgICA9IGNvbnRhaW5lcixcbiAgICAgICAgICAgIHtjbn0gICAgICAgID0gdmRvbTtcblxuICAgICAgICB2ZG9tLmNuID0gW1xuICAgICAgICAgICAge2NsczogWyduZW8tcGxhbmUnXSwgaWQ6IG1lLmdldFBsYW5lSWQoKSwgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1ib3gnXSwgY259XG4gICAgICAgICAgICBdfVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSBvcmlnaW5hbCBtZXRob2QgZm9yIHJ1bi10aW1lIGNvbnRhaW5lciBsYXlvdXQgY2hhbmdlc1xuICAgICAgICBtZS4jY2FjaGVkVmRvbUl0ZW1zUm9vdCA9IGNvbnRhaW5lci5nZXRWZG9tSXRlbXNSb290O1xuXG4gICAgICAgIC8vIE92ZXJyaWRlXG4gICAgICAgIGNvbnRhaW5lci5nZXRWZG9tSXRlbXNSb290ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzBdXG4gICAgICAgIH1cblxuICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEltcG9ydGFudCB3aGVuIHN3aXRjaGluZyBmcm9tIGEgY2FyZCBsYXlvdXQgdG8gdGhpcyBvbmVcbiAgICAgICAgICAgIGNvbnRhaW5lci5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0udmRvbS5yZW1vdmVEb21cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG4gICAgICAgICAgICBjb250YWluZXIudXBkYXRlKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBDU1MgcnVsZXMgZnJvbSBhIGNvbnRhaW5lciBpdGVtIHRoaXMgbGF5b3V0IGlzIGJvdW5kIHRvLlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gc3dpdGNoaW5nIHRvIGEgZGlmZmVyZW50IGxheW91dC5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gaXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZEF0dHJpYnV0ZXMoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHt3cmFwcGVyQ2xzfSA9IGl0ZW07XG5cbiAgICAgICAgaWYgKGluZGV4IDwgNikge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsIFsnbmVvLWZhY2UnLCBPYmplY3Qua2V5cyhDdWJlLmZhY2VzKVtpbmRleF1dKTtcblxuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZSh3cmFwcGVyQ2xzLCAnbmVvLWZhY2UteicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUod3JhcHBlckNscywgJ25lby1mYWNlLXgnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKHdyYXBwZXJDbHMsICduZW8tZmFjZS15Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlUmVuZGVyQXR0cmlidXRlcygpIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlUmVuZGVyQXR0cmlidXRlcygpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbnRhaW5lcn0gICAgICAgID0gbWUsXG4gICAgICAgICAgICB7Y2xzLCBzdHlsZSwgdmRvbX0gPSBjb250YWluZXI7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1hbmltYXRlJyk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgICAgJy0tcGVyc3BlY3RpdmUnOiBudWxsLFxuICAgICAgICAgICAgJy0tcm90LXgnICAgICAgOiBudWxsLFxuICAgICAgICAgICAgJy0tcm90LXknICAgICAgOiBudWxsLFxuICAgICAgICAgICAgJy0tcm90LXonICAgICAgOiBudWxsLFxuICAgICAgICAgICAgJy0tc2lkZS14JyAgICAgOiBudWxsLFxuICAgICAgICAgICAgJy0tc2lkZS15JyAgICAgOiBudWxsLFxuICAgICAgICAgICAgJy0tc2lkZS16JyAgICAgOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRhaW5lci5zZXQoe2Nscywgc3R5bGV9KTtcblxuICAgICAgICB2ZG9tLmNuID0gY29udGFpbmVyLmdldFZkb21JdGVtc1Jvb3QoKS5jbjtcblxuICAgICAgICBpZiAobWUuaGlkZUluYWN0aXZlQ2FyZHNPbkRlc3Ryb3kpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDYgJiYgaW5kZXggIT09IG1lLmFjdGl2ZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udmRvbS5yZW1vdmVEb20gPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIGNvbnRhaW5lci5nZXRWZG9tSXRlbXNSb290ID0gbWUuI2NhY2hlZFZkb21JdGVtc1Jvb3Q7XG5cbiAgICAgICAgY29udGFpbmVyLnVwZGF0ZURlcHRoID0gLTE7XG4gICAgICAgIGNvbnRhaW5lci51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeF1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeV1cbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbel1cbiAgICAgKi9cbiAgICByb3RhdGVUbyh4LCB5LCB6KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29udGFpbmVyfSA9IG1lLFxuICAgICAgICAgICAge3N0eWxlfSAgICAgPSBjb250YWluZXI7XG5cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih4KSkge21lLl9yb3RhdGVYID0geDsgc3R5bGVbJy0tcm90LXgnXSA9IHggKyAnZGVnJ31cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih5KSkge21lLl9yb3RhdGVZID0geTsgc3R5bGVbJy0tcm90LXknXSA9IHkgKyAnZGVnJ31cbiAgICAgICAgaWYgKE5lby5pc051bWJlcih6KSkge21lLl9yb3RhdGVaID0gejsgc3R5bGVbJy0tcm90LXonXSA9IHogKyAnZGVnJ31cblxuICAgICAgICBjb250YWluZXIuc3R5bGUgPSBzdHlsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYWN0aXZlRmFjZSAgICAgICAgICAgICAgICA6IG1lLmFjdGl2ZUZhY2UsXG4gICAgICAgICAgICBhY3RpdmVJbmRleCAgICAgICAgICAgICAgIDogbWUuYWN0aXZlSW5kZXgsXG4gICAgICAgICAgICBmaXRDb250YWluZXIgICAgICAgICAgICAgIDogbWUuZml0Q29udGFpbmVyLFxuICAgICAgICAgICAgaGlkZUluYWN0aXZlQ2FyZHNPbkRlc3Ryb3k6IG1lLmhpZGVJbmFjdGl2ZUNhcmRzT25EZXN0cm95LFxuICAgICAgICAgICAgcGVyc3BlY3RpdmUgICAgICAgICAgICAgICA6IG1lLnBlcnNwZWN0aXZlLFxuICAgICAgICAgICAgcm90YXRlWCAgICAgICAgICAgICAgICAgICA6IG1lLnJvdGF0ZVgsXG4gICAgICAgICAgICByb3RhdGVZICAgICAgICAgICAgICAgICAgIDogbWUucm90YXRlWSxcbiAgICAgICAgICAgIHJvdGF0ZVogICAgICAgICAgICAgICAgICAgOiBtZS5yb3RhdGVaLFxuICAgICAgICAgICAgc2lkZVggICAgICAgICAgICAgICAgICAgICA6IG1lLnNpZGVYLFxuICAgICAgICAgICAgc2lkZVkgICAgICAgICAgICAgICAgICAgICA6IG1lLnNpZGVZLFxuICAgICAgICAgICAgc2lkZVogICAgICAgICAgICAgICAgICAgICA6IG1lLnNpZGVaXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZUNvbnRhaW5lckNzc1ZhcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQge2NvbnRhaW5lcn0gPSB0aGlzLFxuICAgICAgICAgICAge3N0eWxlfSAgICAgPSBjb250YWluZXI7XG5cbiAgICAgICAgc3R5bGVbbmFtZV0gPSB2YWx1ZTtcblxuICAgICAgICBjb250YWluZXIuc3R5bGUgPSBzdHlsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ29udGFpbmVyU2l6ZSgpIHtcbiAgICAgICAgbGV0IHtjb250YWluZXJ9ICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aGVpZ2h0LCB3aWR0aH0gPSBhd2FpdCBjb250YWluZXIuZ2V0RG9tUmVjdChjb250YWluZXIuaWQpO1xuXG4gICAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgICAgIHNpZGVYOiB3aWR0aCxcbiAgICAgICAgICAgIHNpZGVZOiBoZWlnaHQsXG4gICAgICAgICAgICBzaWRlWjogd2lkdGhcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEN1YmUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9