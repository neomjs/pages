export const __webpack_esm_id__ = "vendors-apps_portal_view_news_tickets_MainContainer_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_view_news_tickets_MainContainer_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/model/ContentSection.mjs"
/*!**********************************************!*\
  !*** ./apps/portal/model/ContentSection.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.ContentSection
 * @extends Neo.data.Model
 */
class ContentSection extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.ContentSection'
         * @protected
         */
        className: 'Portal.model.ContentSection',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'id',
            type: 'String'
        }, {
            name: 'name',
            type: 'String'
        }, {
            name: 'tag',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ContentSection));


/***/ },

/***/ "./apps/portal/model/Ticket.mjs"
/*!**************************************!*\
  !*** ./apps/portal/model/Ticket.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.Ticket
 * @extends Neo.data.Model
 */
class Ticket extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.Ticket'
         * @protected
         */
        className: 'Portal.model.Ticket',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name        : 'collapsed',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name: 'id',
            type: 'String'
        }, {
            name        : 'isLeaf',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name        : 'parentId',
            type        : 'String',
            defaultValue: null
        }, {
            name: 'path', // "resources/content/issues/issue-1234.md"
            type: 'String'
        }, {
            name: 'title', // "Fix elusive bug in Grid"
            type: 'String'
        }, {
            // Computed field for TreeList display
            name: 'treeNodeName',
            type: 'html',
            /**
             * @param {Object}  data
             * @param {String}  data.id
             * @param {Boolean} data.isLeaf
             * @param {String}  data.title
             * @returns {String}
             */
            calculate({id, isLeaf, title}) {
                return isLeaf ? `<b>${id}</b> <span class="ticket-title">${title}</span>` : id
            }
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Ticket));


/***/ },

/***/ "./apps/portal/model/TicketLabel.mjs"
/*!*******************************************!*\
  !*** ./apps/portal/model/TicketLabel.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.TicketLabel
 * @extends Neo.data.Model
 */
class TicketLabel extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketLabel'
         * @protected
         */
        className: 'Portal.model.TicketLabel',
        /**
         * @member {Object[]} fields
         * @protected
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'description',
            type: 'String'
        }, {
            name: 'name',
            type: 'String'
        }, {
            name: 'textColor',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabel));


/***/ },

/***/ "./apps/portal/model/TicketTimelineSection.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/model/TicketTimelineSection.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSection.mjs */ "./apps/portal/model/ContentSection.mjs");


/**
 * @class Portal.model.TicketTimelineSection
 * @extends Portal.model.ContentSection
 */
class TicketTimelineSection extends _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketTimelineSection'
         * @protected
         */
        className: 'Portal.model.TicketTimelineSection',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'icon',
            type: 'String'
        }, {
            name: 'image',
            type: 'String'
        }, {
            name: 'sourceId',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSection));


/***/ },

/***/ "./apps/portal/store/ContentSections.mjs"
/*!***********************************************!*\
  !*** ./apps/portal/store/ContentSections.mjs ***!
  \***********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/ContentSection.mjs */ "./apps/portal/model/ContentSection.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Portal.store.ContentSections
 * @extends Neo.data.Store
 */
class ContentSections extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.ContentSections'
         * @protected
         */
        className: 'Portal.store.ContentSections',
        /**
         * @member {Neo.data.Model} model=ContentSectionModel
         * @reactive
         */
        model: _model_ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ContentSections));


/***/ },

/***/ "./apps/portal/store/TicketLabels.mjs"
/*!********************************************!*\
  !*** ./apps/portal/store/TicketLabels.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/TicketLabel.mjs */ "./apps/portal/model/TicketLabel.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Portal.store.TicketLabels
 * @extends Neo.data.Store
 */
class TicketLabels extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketLabels'
         * @protected
         */
        className: 'Portal.store.TicketLabels',
        /**
         * @member {String} keyProperty='name'
         * @protected
         */
        keyProperty: 'name',
        /**
         * @member {Neo.data.Model} model=TicketLabel
         * @protected
         */
        model: _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/labels.json'
         * @protected
         */
        url: '../../apps/portal/resources/data/labels.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabels));


/***/ },

/***/ "./apps/portal/store/TicketTimelineSections.mjs"
/*!******************************************************!*\
  !*** ./apps/portal/store/TicketTimelineSections.mjs ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSections.mjs */ "./apps/portal/store/ContentSections.mjs");
/* harmony import */ var _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/TicketTimelineSection.mjs */ "./apps/portal/model/TicketTimelineSection.mjs");



/**
 * @class Portal.store.TicketTimelineSections
 * @extends Portal.store.ContentSections
 */
class TicketTimelineSections extends _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketTimelineSections'
         * @protected
         */
        className: 'Portal.store.TicketTimelineSections',
        /**
         * @member {Neo.data.Model} model=TicketTimelineSection
         * @reactive
         */
        model: _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSections));


/***/ },

/***/ "./apps/portal/store/Tickets.mjs"
/*!***************************************!*\
  !*** ./apps/portal/store/Tickets.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Ticket.mjs */ "./apps/portal/model/Ticket.mjs");



/**
 * @class Portal.store.Tickets
 * @extends Neo.data.Store
 */
class Tickets extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.Tickets'
         * @protected
         */
        className: 'Portal.store.Tickets',
        /**
         * @member {Neo.data.Model} model=TicketModel
         * @reactive
         */
        model: _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/tickets.json'
         */
        url: '../../apps/portal/resources/data/tickets.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tickets));


/***/ },

/***/ "./apps/portal/view/news/tickets/CanvasWrapper.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/CanvasWrapper.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./apps/portal/view/news/tickets/Component.mjs");
/* harmony import */ var _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TimelineCanvas.mjs */ "./apps/portal/view/news/tickets/TimelineCanvas.mjs");




/**
 * @class Portal.view.news.tickets.CanvasWrapper
 * @extends Neo.container.Base
 */
class CanvasWrapper extends _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.CanvasWrapper'
         * @protected
         */
        className: 'Portal.view.news.tickets.CanvasWrapper',
        /**
         * @member {String[]} cls=['portal-canvas-wrapper']
         */
        cls: ['portal-canvas-wrapper'],
        /**
         * @member {Neo.component.Base|null} contentComponent=ContentComponent
         */
        contentComponent: _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={overflow:'visible',paddingBottom:'20px',position:'relative'}
         */
        style: {overflow: 'visible', paddingBottom: '20px', position: 'relative'}
    }

    construct(config) {
        let me = this;

        config.items = [{
            module   : _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            reference: 'timeline-canvas',
            style : {
                position     : 'absolute',
                top          : 0,
                left         : 0,
                width        : '100%',
                height       : '100%',
                zIndex       : 2,
                pointerEvents: 'none'
            }
        }, {
            module: config.contentComponent || me.contentComponent,
            style : {
                position: 'relative',
                zIndex  : 1
            },
            listeners: {
                toggleSummary: me.onToggleSummary,
                scope        : me
            }
        }];

        super.construct(config);
    }

    /**
     *
     */
    onToggleSummary() {
        let canvas = this.getReference('timeline-canvas');

        if (canvas?.lastRecords) {
            canvas.onTimelineDataLoad(canvas.lastRecords, true)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CanvasWrapper));


/***/ },

/***/ "./apps/portal/view/news/tickets/Component.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/view/news/tickets/Component.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_app_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/app/content/Component.mjs */ "./src/app/content/Component.mjs");
/* harmony import */ var _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../node_modules/marked/lib/marked.esm.js */ "./node_modules/marked/lib/marked.esm.js");



const
    regexFrontMatter   = /^---\n([\s\S]*?)\n---\n/,
    regexH1            = /(<h1[^>]*>.*?<\/h1>)/,
    regexTicketLink    = /(\d{4,})/,
    regexTimeline      = /## Timeline\s*\n([\s\S]*)/,
    regexTimelineEvent = /^- ([\dTZ:.-]+) @(\w+) (.*)$/,
    regexCommit        = /\b([0-9a-f]{7,40})\b/g;

/**
 * @summary The "Markdown Transformer" for GitHub Tickets.
 *
 * This component extends the standard ContentComponent to provide specialized rendering for GitHub Issues.
 * Its primary responsibility is to parse the raw Markdown content (which includes custom Frontmatter and
 * a pre-generated Timeline section) and transform it into a rich, interactive HTML structure.
 *
 * **Key Responsibilities:**
 * 1. **Parsing Pipeline**: Extracts Frontmatter, Body, and the custom "Timeline" section from the raw Markdown.
 * 2. **Rich Rendering**: Generates HTML for Status Badges, Labels, Commit Links, and User Mentions.
 * 3. **Data Extraction**: As a side effect of rendering, it extracts structured data (`me.timelineData`)
 *    representing every timeline event (comment, label change, close, etc.). This data is then
 *    pushed to the `sections` store to drive the `TimelineCanvas` visualization.
 *
 * @class Portal.view.news.tickets.Component
 * @extends Neo.app.content.Component
 */
class Component extends _src_app_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.Component'
         * @protected
         */
        className: 'Portal.view.news.tickets.Component',
        /**
         * @member {String[]} cls=['portal-news-tickets-component']
         */
        cls: ['portal-news-tickets-component'],
        /**
         * @member {String} commitsUrl='https://github.com/neomjs/neo/commit/'
         */
        commitsUrl: 'https://github.com/neomjs/neo/commit/',
        /**
         * @member {Object} domListeners
         */
        domListeners: {
            resize: 'onResize'
        },
        /**
         * @member {String} repoUserUrl='https://github.com/'
         */
        repoUserUrl: 'https://github.com/',
        /**
         * @member {Boolean} updateSectionsStore=false
         */
        updateSectionsStore: false
    }

    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatHistory=null
     */
    #dateTimeFormatHistory = null
    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatToday=null
     */
    #dateTimeFormatToday = null
    /**
     * Temporary storage for the structured timeline data extracted during the parsing phase.
     * This array is populated by `renderTimeline` and `modifyMarkdown` and then assigned
     * to the `sections` store to drive the Canvas visualization.
     * @member {Object[]} timelineData=null
     * @private
     */
    timelineData = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.getStateProvider().setData('contentComponentId', this.id)
    }

    /**
     * @param {String} isoString
     * @returns {String}
     */
    formatTimestamp(isoString) {
        if (!isoString) return '';

        let me      = this,
            date    = new Date(isoString),
            now     = new Date(),
            isToday = date.toDateString() === now.toDateString();

        if (isToday) {
            if (!me.#dateTimeFormatToday) {
                me.#dateTimeFormatToday = new Intl.DateTimeFormat('default', {
                    hour  : 'numeric',
                    minute: 'numeric'
                })
            }

            return me.#dateTimeFormatToday.format(date)
        }

        if (!me.#dateTimeFormatHistory) {
            me.#dateTimeFormatHistory = new Intl.DateTimeFormat('default', {
                day   : 'numeric',
                hour  : 'numeric',
                minute: 'numeric',
                month : 'short',
                year  : 'numeric'
            })
        }

        return me.#dateTimeFormatHistory.format(date)
    }

    /**
     * @param {Object} data
     * @returns {String}
     */
    frontMatterToHtml(data) {
        let me   = this,
            html = '<table class="neo-frontmatter-table"><tbody>';

        Object.entries(data).forEach(([key, value]) => {
            let renderedValue;

            if (key === 'subIssues' && Array.isArray(value)) {
                renderedValue = value.map(issue => {
                    return `<div class="neo-sub-issue">${issue
                        .replace(regexTicketLink, '<a href="#/news/tickets/$1">$1</a>')
                        .replace('[x]', '<i class="fa-solid fa-circle-check"></i>')
                        .replace('[ ]', '<i class="fa-regular fa-circle"></i>')}</div>`
                }).join('')
            } else if (key === 'author') {
                renderedValue = `<a href="${me.repoUserUrl}${value}" target="_blank">${value}</a>`
            } else if (key === 'createdAt' || key === 'closedAt' || key === 'updatedAt') {
                renderedValue = me.formatTimestamp(value)
            } else if (key === 'labels' && Array.isArray(value)) {
                renderedValue = me.getBadgesHtml(value)
            } else if (key === 'state') {
                renderedValue = me.getStateBadgeHtml(value)
            } else {
                renderedValue = me.formatFrontMatterValue(value)
            }

            html += `<tr><td>${key}</td><td>${renderedValue}</td></tr>`
        });

        html += '</tbody></table>';

        if (me.useFrontmatterDetails) {
            return `<details id="neo-ticket-summary-details-${me.id}"><summary>Frontmatter</summary>${html}</details>`
        }

        return html
    }

    /**
     * @param {String[]} labels
     * @returns {String}
     */
    getBadgesHtml(labels) {
        if (!labels || labels.length === 0) return '';

        let me         = this,
            badgesHtml = '<div class="neo-ticket-labels">';

        labels.forEach(label => {
            badgesHtml += me.getLabelBadgeHtml(label)
        });

        badgesHtml += '</div>';

        return badgesHtml
    }

    /**
     * @param {Object} record
     * @returns {Promise<void>}
     */
    async doFetchContent(record) {
        let me         = this,
            {windowId} = me,
            content, data, path;

        path = me.getContentPath(record);

        if (record.isLeaf && path) {
            data    = await fetch(path);
            content = await data.text();

            me.value = content;

            me.toggleCls('lab', record.name?.startsWith('Lab:'));

            Neo.main.addon.IntersectionObserver.observe({
                disconnect: true,
                id        : me.id,
                observe   : ['.neo-timeline-item[data-record-id]'],
                windowId
            })
        }
    }

    /**
     * @param {Object} record
     * @param {String} record.path
     * @returns {String|null}
     */
    getContentPath({path}) {
        return path ? Neo.config.basePath + path : null
    }

    /**
     * @param {String} label
     * @returns {String}
     */
    getLabelBadgeHtml(label) {
        let store  = this.getStateProvider().getStore('labels'),
            record = store.get(label);

        if (record) {
            return `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
        }

        return `<span class="neo-badge">${label}</span>`
    }

    /**
     * @param {String} state
     * @returns {String}
     */
    getStateBadgeHtml(state) {
        if (!state) return '';

        let cls  = 'neo-badge neo-state-badge',
            icon = 'fa-circle-dot';

        if (state.toUpperCase() === 'CLOSED') {
            cls  += ' neo-state-closed';
            icon  = 'fa-circle-check'
        } else {
            cls += ' neo-state-open'
        }

        return `<span class="${cls}"><i class="fa-regular ${icon}"></i>${Neo.capitalize(state.toLowerCase())}</span>`
    }

    /**
     * The Main Parsing Pipeline.
     *
     * This method intercepts the raw markdown content before it is rendered and performs a multi-pass transformation:
     * 1. **Extract Timeline**: Pulls out the raw `## Timeline` section to process it separately.
     * 2. **Process Frontmatter**: Extracts metadata (labels, state, author) and removes the YAML block.
     * 3. **Render Body**: Uses the superclass (marked.js) to convert the main issue body to HTML.
     * 4. **Inject Title IDs**: Adds IDs to H1 tags for navigation.
     * 5. **Generate Badges**: Creates HTML for Status/Label badges based on extracted metadata.
     * 6. **Wrap Body**: Wraps the main issue body in a `timeline-item` structure so it appears as the first item.
     * 7. **Re-Assemble**: Concatenates Frontmatter + Title + Timeline (with Body injected) into the final HTML.
     *
     * **Side Effect**: Populates `me.timelineData` and updates the `sections` store.
     *
     * @param {String} content
     * @returns {String}
     */
    modifyMarkdown(content) {
        let me           = this,
            {parentId}   = me.record,
            author       = null,
            createdAt    = null,
            labels       = [],
            state        = null,
            match        = content.match(regexFrontMatter),
            timelineHtml = '',
            badgesHtml   = '';

        me.timelineData = [];

        if (match) {
            let data = me.parseFrontMatter(match[1]);

            if (data.author)    {author    = data.author}
            if (data.createdAt) {createdAt = me.formatTimestamp(data.createdAt)}
            if (data.labels)    {labels    = data.labels}
            if (data.state)     {state     = data.state}
        }

        // 1. Extract and process timeline from RAW markdown
        let timelineMatch = content.match(regexTimeline);
        if (timelineMatch) {
            timelineHtml = me.renderTimeline(timelineMatch[1]);
            content      = content.replace(regexTimeline, ''); // Remove raw timeline
        }

        // 2. Render Frontmatter Manually & Strip it
        // We want it at the very top, outside the body bubble.
        let frontMatterHtml = '';
        if (match) {
            let data        = me.parseFrontMatter(match[1]);
            frontMatterHtml = me.frontMatterToHtml(data);
            content         = content.replace(regexFrontMatter, '');
        }

        // 3. Convert Body + Title to HTML using super
        let fullHtml = super.modifyMarkdown(content);

        // 4. Extract H1 Title from the generated HTML
        let titleHtml = '';
        fullHtml      = fullHtml.replace(regexH1, (match) => {
            // Inject ID into H1 tag
            titleHtml = match.replace('<h1', `<h1 id="ticket-title-${me.id}"`);
            return ''; // Remove title from body
        });

        // 5. Construct Badges
        if (labels.length > 0 || state || (parentId && parentId !== 'Backlog')) {
            badgesHtml = '<div class="neo-ticket-labels">';

            if (state) {
                badgesHtml += me.getStateBadgeHtml(state)
            }

            if (parentId && parentId !== 'Backlog') {
                badgesHtml += `
                    <a class="neo-badge neo-release-badge" href="#/news/releases/${parentId.substring(1)}">
                        <i class="fa-solid fa-code-branch"></i> ${parentId}
                    </a>`
            }

            if (labels.length > 0) {
                let store = me.getStateProvider().getStore('labels'),
                    record;

                labels.forEach(label => {
                    record = store.get(label);

                    if (record) {
                        badgesHtml += `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
                    } else {
                        badgesHtml += `<span class="neo-badge">${label}</span>`
                    }
                });
            }

            badgesHtml += '</div>';
            titleHtml  += badgesHtml;
        }

        // 6. Wrap the remaining HTML (Body) in the Timeline Item structure
        let bodyId = `timeline-${me.record.id}-0`;

        me.timelineData.unshift({
            id   : bodyId,
            image: me.repoUserUrl + author + '.png',
            name : 'Description',
            tag  : 'body'
        });

        let bodyItemHtml = `
            <div id="${bodyId}" class="neo-timeline-item comment body-item" data-record-id="${bodyId}">
                <div id="${bodyId}-target" class="neo-timeline-avatar">
                    <img src="${me.repoUserUrl}${author}.png" alt="${author}">
                </div>
                <div class="neo-timeline-content">
                    <div class="neo-timeline-header">
                        <a class="neo-timeline-user" href="${me.repoUserUrl}${author}" target="_blank">${author}</a>
                        <span class="neo-timeline-date">commented on ${createdAt}</span>
                    </div>
                    <div class="neo-timeline-body">${fullHtml}</div>
                </div>
            </div>`;

        // 7. Inject Body Item at the start of the Timeline
        let timelineId = `ticket-timeline-${me.id}`;

        if (timelineHtml) {
            timelineHtml = timelineHtml.replace(
                '<div class="neo-ticket-timeline">',
                `<div id="${timelineId}" class="neo-ticket-timeline">` + bodyItemHtml
            )
        } else {
            timelineHtml = `<div id="${timelineId}" class="neo-ticket-timeline">${bodyItemHtml}</div>`
        }

        me.getStateProvider().getStore('sections').data = me.timelineData;
        me.timelineData = null;

        // Return: Frontmatter + Title + Timeline
        return frontMatterHtml + titleHtml + timelineHtml
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        this.fire('toggleSummary')
    }

    /**
     * Parses the custom "Timeline" markdown section.
     *
     * Expects a line-based format generated by the build process:
     * - Events: `- YYYY-MM-DDTHH:mm:ss @user action text...`
     * - Comments: `### @user - YYYY-MM-DDTHH:mm:ss` followed by comment body.
     *
     * This method converts these lines into structured `timeline-item` HTML blocks
     * and simultaneously populates `me.timelineData` with semantic data (color, icon, type)
     * for each event.
     *
     * @param {String} content
     * @returns {String}
     */
    renderTimeline(content) {
        let me          = this,
            {commitsUrl, repoUserUrl} = me,
            html        = '<div class="neo-ticket-timeline">',
            lines       = content.split('\n'),
            commentBuf  = [],
            currentUser = null,
            currentDate = null,
            i           = 0,
            len         = lines.length,
            id, line, match, icon, actionCls;

        const flushComment = () => {
            if (commentBuf.length > 0) {
                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                me.timelineData.push({
                    id   : id,
                    image: repoUserUrl + currentUser + '.png',
                    name : `Comment (${currentUser})`,
                    tag  : 'comment'
                });

                let body = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parse(commentBuf.join('\n'));
                html += `
                    <div id="${id}" class="neo-timeline-item comment" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-avatar">
                            <img src="${repoUserUrl}${currentUser}.png" alt="${currentUser}">
                        </div>
                        <div class="neo-timeline-content">
                            <div class="neo-timeline-header">
                                <a class="neo-timeline-user" href="${repoUserUrl}${currentUser}" target="_blank">${currentUser}</a>
                                <span class="neo-timeline-date">${me.formatTimestamp(currentDate)}</span>
                            </div>
                            <div class="neo-timeline-body">${body}</div>
                        </div>
                    </div>`;
                commentBuf  = [];
                currentUser = null;
                currentDate = null
            }
        };

        for (; i < len; i++) {
            line = lines[i];

            // Event Line: - 2026-01-11T... @user action...
            if ((match = line.match(regexTimelineEvent))) {
                flushComment();
                let [_, date, user, action] = match;

                icon      = 'fa-circle-dot'; // Default
                actionCls = '';

                const eventType = [
                    {key: 'added the `',      icon: 'fa-tag'},
                    {key: 'removed the `',    icon: 'fa-tag'},
                    {key: 'assigned',         icon: 'fa-user-pen'},
                    {key: 'closed',           icon: 'fa-circle-check', color: '#8250df'}, // GitHub Purple
                    {key: 'reopened',         icon: 'fa-circle-dot',   color: '#2da44e'}, // GitHub Green
                    {key: 'referenced',       icon: 'fa-link'},
                    {key: 'cross-referenced', icon: 'fa-link'},
                    {key: 'milestoned',       icon: 'fa-sign-post'},
                    {key: 'sub-issue',        icon: 'fa-diagram-project'}
                ].find(e => action.includes(e.key));

                let color = null;

                if (eventType) {
                    icon = eventType.icon;
                    if (eventType.color) color = eventType.color
                }

                // Clean up markdown in action text (e.g. `code` to <code>)
                let cleanAction = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parseInline(action);

                if (icon === 'fa-tag') {
                    cleanAction = cleanAction.replace(/<code>(.*?)<\/code>/g, (match, label) => me.getLabelBadgeHtml(label));

                    // Try to resolve color from label
                    let labelMatch = action.match(/`([^`]+)`/);
                    if (labelMatch) {
                        let labelName = labelMatch[1];
                        let labelRec  = me.getStateProvider().getStore('labels').get(labelName);
                        if (labelRec) {
                            color = labelRec.color;
                        }
                    }
                }

                // Linkify Commit Hashes
                cleanAction = cleanAction.replace(regexCommit, `<a href="${commitsUrl}$1" target="_blank">$1</a>`);

                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                // Extract a short action name for the list
                let shortAction = action.split(' ')[0]; // 'added', 'closed', etc.
                let entryName;

                if (shortAction === 'added' || shortAction === 'removed') {
                    if (action.includes('sub-issue')) {
                        let subIssueMatch = action.match(/#(\d+)/);
                        if (subIssueMatch) {
                            entryName = `${Neo.capitalize(shortAction)} sub-issue #${subIssueMatch[1]}`
                        } else {
                            entryName = `${Neo.capitalize(shortAction)} sub-issue`
                        }
                    } else {
                        let labelMatch = action.match(/`([^`]+)`/);
                        shortAction = labelMatch ? labelMatch[1] : 'Label';
                        entryName = `${Neo.capitalize(shortAction)} (${user})`
                    }
                } else {
                    entryName = `${Neo.capitalize(shortAction)} (${user})`
                }

                me.timelineData.push({
                    color: color, // Pass resolved hex color
                    icon : icon,
                    id   : id,
                    name : entryName,
                    tag  : 'event'
                });

                // Apply color style if present, otherwise default
                let style = color ? `style="color: ${color}"` : '';

                html += `
                    <div id="${id}" class="neo-timeline-item event" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-badge" ${style}><i class="fa-solid ${icon}"></i></div>
                        <div class="neo-timeline-body">
                            <a class="neo-timeline-user" href="${repoUserUrl}${user}" target="_blank">${user}</a> ${cleanAction} <span class="neo-timeline-date">on ${me.formatTimestamp(date)}</span>
                        </div>
                    </div>`;
            }
            // Comment Header: ### @user - 2026-01-11T...
            else if (line.startsWith('### @')) {
                // Captures "user" and "2026-01-11T..." (ISO timestamp)
                let headerMatch = line.match(/^### @(\w+) - ([\dTZ:.-]+)$/);
                if (headerMatch) {
                    flushComment();
                    currentUser = headerMatch[1];
                    currentDate = headerMatch[2]
                } else {
                    // Fallback for weird headers? treat as text
                    if (currentUser) commentBuf.push(line)
                }
            }
            else {
                if (currentUser) {
                    commentBuf.push(line)
                }
            }
        }

        flushComment(); // Flush last comment

        html += '</div>';
        return html
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasWrapper.mjs */ "./apps/portal/view/news/tickets/CanvasWrapper.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/portal/view/news/tickets/MainContainerController.mjs");
/* harmony import */ var _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PageContainer.mjs */ "./apps/portal/view/news/tickets/PageContainer.mjs");
/* harmony import */ var _src_app_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../src/app/content/Container.mjs */ "./src/app/content/Container.mjs");
/* harmony import */ var _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MainContainerStateProvider.mjs */ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs");






/**
 * @class Portal.view.news.tickets.MainContainer
 * @extends Neo.app.content.Container
 */
class MainContainer extends _src_app_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainer',
        /**
         * @member {String[]} cls=['portal-tickets-maincontainer']
         * @reactive
         */
        cls: ['portal-tickets-maincontainer'],
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         * @reactive
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} pageContainerConfig
         */
        pageContainerConfig: {
            module         : _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            buttonTextField: 'id',
            contentConfig  : {
                module: _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            }
        },
        /**
         * @member {Neo.state.Provider} stateProvider=MainContainerStateProvider
         * @reactive
         */
        stateProvider: _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
        /**
         * @member {Object} treeConfig={displayField:'treeNodeName'}
         */
        treeConfig: {
            displayField: 'treeNodeName'
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerController.mjs"
/*!*******************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerController.mjs ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Portal.view.news.tickets.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerController'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerController',
        /**
         * @member {Object} routes
         */
        routes: {
            '/news/tickets'          : 'onRouteDefault',
            '/news/tickets/{*itemId}': 'onRouteItem'
        }
    }

    /**
     * @param {String} item
     */
    navigateTo(item) {
        Neo.Main.setRoute({
            value   : `/news/tickets/${item}`,
            windowId: this.component.windowId
        })
    }

    /**
     * @param {Object} data
     */
    onIntersect(data) {
        let panel    = this.getReference('page-sections-container'),
            list     = panel.list,
            recordId = data.data.recordId,
            record;

        if (recordId && !list.isAnimating) {
            record = list.store.get(recordId);

            if (record) {
                list.selectionModel.select(record)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onNextPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('nextPageRecord').id)
    }

    /**
     * @param {Object} data
     */
    onPageSectionsToggleButtonClick(data) {
        this.getReference('page-sections-container').toggleCls('neo-expanded')
    }

    /**
     * @param {Object} data
     */
    onPreviousPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('previousPageRecord').id)
    }

    /**
     * @returns {String}
     */
    getDefaultRouteId() {
        let store     = this.getStateProvider().getStore('tree'),
            rootCount = 0,
            i         = 0,
            len       = store.getCount(),
            record;

        for (; i < len; i++) {
            record = store.getAt(i);

            if (record.parentId === null) {
                rootCount++;

                if (rootCount === 2) {
                    return store.getAt(i + 1)?.id
                }
            }
        }

        return store.getAt(1)?.id
    }

    /**
     * @param {Object} data
     */
    onRouteDefault(data) {
        let me    = this,
            store = me.getStateProvider().getStore('tree');

        if (store.getCount() > 0) {
            me.navigateTo(me.getDefaultRouteId())
        } else {
            store.on({
                load : () => me.navigateTo(me.getDefaultRouteId()),
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.itemId
     * @param {Object} value
     * @param {Object} oldValue
     */
    async onRouteItem({itemId}, value, oldValue) {
        let me            = this,
            stateProvider = me.getStateProvider(),
            store         = stateProvider.getStore('tree'),
            tree          = me.getReference('tree');

        // Ensure the tree has the correct route prefix for this controller context
        if (tree.routePrefix !== '/news/tickets') {
            tree.routePrefix = '/news/tickets'
        }

        const select = async () => {
            stateProvider.data.currentPageRecord = store.get(itemId);

            if (!oldValue?.hashString?.startsWith('/news/tickets')) {
                await tree.expandAndScrollToItem(itemId)
            } else {
                tree.expandParents(itemId)
            }
        };

        if (store.getCount() > 0) {
            await select()
        } else {
            store.on({
                load : select,
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     */
    onSideNavToggleButtonClick(data) {
        this.getReference('sidenav-container').toggleCls('neo-expanded')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs"
/*!**********************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerStateProvider.mjs ***!
  \**********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../store/TicketLabels.mjs */ "./apps/portal/store/TicketLabels.mjs");
/* harmony import */ var _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../store/TicketTimelineSections.mjs */ "./apps/portal/store/TicketTimelineSections.mjs");
/* harmony import */ var _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../store/Tickets.mjs */ "./apps/portal/store/Tickets.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");





/**
 * @class Portal.view.news.tickets.MainContainerStateProvider
 * @extends Neo.state.Provider
 */
class MainContainerStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerStateProvider'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {Number|null} data.countPages=null
             */
            countPages: null,
            /**
             * @member {Number|null} data.countPages=null
             */
            countSections: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.currentRecord=null
             */
            currentPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.nextPageRecord=null
             */
            nextPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.previousPageRecord=null
             */
            previousPageRecord: null
        },
        /**
         * @member {Object} stores
         */
        stores: {
            labels: {
                autoLoad: true,
                module  : _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            },
            sections: {
                module: _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
            },
            tree: {
                autoLoad: true,
                module  : _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]
            }
        }
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        super.onDataPropertyChange(key, value, oldValue);

        let me = this;

        switch (key) {
            case 'countSections': {
                if (value < 1) {
                    me.component.getReference('page-sections-container')?.toggleCls('neo-expanded', false)
                }

                break
            }

            case 'currentPageRecord': {
                let {data}             = me,
                    {countPages}       = data,
                    store              = me.getStore('tree'),
                    index              = store.indexOf(value),
                    nextPageRecord     = null,
                    previousPageRecord = null,
                    i, record;

                // the logic assumes that the tree store is sorted
                for (i=index-1; i >= 0; i--) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        previousPageRecord = record;
                        break
                    }
                }

                me.setData({previousPageRecord});

                // the logic assumes that the tree store is sorted
                for (i=index+1; i < countPages; i++) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        nextPageRecord = record;
                        break
                    }
                }

                me.setData({nextPageRecord});

                me.component.getReference('sidenav-container')?.toggleCls('neo-expanded', false)

                break
            }
        }
    }

    /**
     * We need to check the parent-node chain inside the tree.
     * => Any hidden parent-node results in a hidden record.
     * @param {Object} record
     * @param {Neo.data.Store} store
     * @returns {Boolean}
     */
    recordIsHidden(record, store) {
        if (record.hidden) {
            return true
        }

        if (record.parentId !== null) {
            return this.recordIsHidden(store.get(record.parentId), store)
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerStateProvider));


/***/ },

/***/ "./apps/portal/view/news/tickets/PageContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/PageContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_app_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/app/content/PageContainer.mjs */ "./src/app/content/PageContainer.mjs");


/**
 * @class Portal.view.news.tickets.PageContainer
 * @extends Neo.app.content.PageContainer
 */
class TicketPageContainer extends _src_app_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.PageContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.PageContainer',
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={flex:1,overflowY:'auto',position:'relative'}
         */
        style: {flex: 1, overflowY: 'auto', position: 'relative'}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketPageContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/TimelineCanvas.mjs"
/*!**********************************************************!*\
  !*** ./apps/portal/view/news/tickets/TimelineCanvas.mjs ***!
  \**********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_app_SharedCanvas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/app/SharedCanvas.mjs */ "./src/app/SharedCanvas.mjs");


/**
 * @summary The "Coordinator" component for the Neural Timeline, bridging the App Worker and Canvas Worker.
 *
 * This component renders a transparent canvas overlay on top of the Ticket List. It is responsible for:
 * 1. **Data Bridge**: Listening to the `sections` store and passing ticket data to the `TicketCanvas` (SharedWorker).
 * 2. **Visual Alignment**: Calculating the precise DOM positions of Ticket Avatars/Badges to ensure the
 *    canvas nodes align perfectly with the HTML content.
 * 3. **Lifecycle Management**: initializing the offscreen canvas transfer and handling resize events.
 *
 * It uses the `Portal.canvas.TicketCanvas` singleton (via Remote Method Access) to drive the actual animation.
 *
 * @class Portal.view.news.tickets.TimelineCanvas
 * @extends Neo.app.SharedCanvas
 */
class TimelineCanvas extends _src_app_SharedCanvas_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     */
    static delayable = {
        ensureFinalAlignment: {
            type : 'debounce',
            timer: 300
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.TimelineCanvas'
         * @protected
         */
        className: 'Portal.view.news.tickets.TimelineCanvas',
        /**
         * @member {String} rendererClassName='Portal.canvas.TicketCanvas'
         */
        rendererClassName: 'Portal.canvas.TicketCanvas',
        /**
         * @member {String} rendererImportPath='apps/portal/canvas/TicketCanvas.mjs'
         */
        rendererImportPath: 'apps/portal/canvas/TicketCanvas.mjs',
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'div', cls: ['neo-ticket-timeline-wrapper'], style: {width: '100%', height: '100%'}, cn: [
            {tag: 'canvas', style: {width: '100%', height: '100%'}}
        ]}
    }

    /**
     * @member {Object[]} lastRecords=null
     */
    lastRecords = null

    /**
     *
     */
    ensureFinalAlignment() {
        let me = this;

        if (me.lastRecords) {
            me.onTimelineDataLoad(me.lastRecords, true)
        }
    }

    /**
     * Lifecycle hook that runs once the `OffscreenCanvas` has been transferred to the Canvas Worker.
     *
     * This method:
     * 1. Imports the `TicketCanvas` logic into the Canvas Worker context.
     * 2. Initializes the graph in the worker via Remote Method Access (`initGraph`).
     * 3. Sets up a `ResizeObserver` to keep the canvas size synced with the DOM.
     * 4. Triggers the initial data load if store data is available.
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetOffscreenRegistered(value, oldValue) {
        let me = this;

        await super.afterSetOffscreenRegistered(value, oldValue);

        if (value) {
            // Initial load check
            let store = me.getStateProvider().getStore('sections');

            if (store.getCount() > 0) {
                me.onTimelineDataLoad(store.items)
            }
        }
    }

    /**
     * Override to return the inner canvas ID
     */
    getCanvasId() {
        let me = this;

        if (!me.canvasId) {
            me.canvasId = me.vdom.cn[0].id
        }
        return me.canvasId
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me    = this,
            store = me.getStateProvider().getStore('sections');

        store.on('load', me.onTimelineDataLoad, me)
    }

    /**
     * @param {Object} data
     */
    async onResize(data) {
        let me = this;

        // Update the canvas size in the worker
        await me.updateSize(data.contentRect);

        // If we have cached records, re-calculate node positions
        // because the container dimensions (and likely relative positions) have changed.
        if (me.lastRecords) {
            // We don't need to re-fetch rects instantly, but it's safer to do so
            // to ensure alignment with the new layout.
            await me.onTimelineDataLoad(me.lastRecords, true);

            // Debounced check to ensure the canvas is aligned after any transitions settle
            me.ensureFinalAlignment()
        }
    }

    /**
     * The core "Alignment Engine" of the timeline.
     *
     * This method synchronizes the Canvas nodes with the DOM elements (Avatars/Badges).
     *
     * **Strategy:**
     * 1. **Targeting**: It uses the `-target` ID suffix to find the specific DOM elements (Avatars) within the ticket list.
     * 2. **Measurement**: It fetches the `DOMRect` for every target to get its exact screen position.
     * 3. **Translation**: It converts these screen coordinates into Canvas-local coordinates.
     * 4. **Handoff**: It packages this geometric data (x, y, radius, color) and sends it to the
     *    `TicketCanvas` worker to update the physics simulation.
     *
     * @param {Object[]|Object} records Array of records or Store load event object {items: [...]}
     * @param {Boolean} [isResize=false]
     */
    async onTimelineDataLoad(records, isResize = false) {
        let me = this;

        // Handle Store 'load' event signature: fire('load', {items: [...]})
        if (records && !Array.isArray(records) && records.items) {
            records = records.items
        }

        if (!Array.isArray(records)) {
            // Safety check if records is still invalid
            return
        }

        if (!me.isCanvasReady) {
            return
        }

        let reset = !isResize;

        // Smart Check: If it's a store load (reset=true) BUT the ticket ID is the same,
        // it's a data refresh (e.g. comment added), so we should NOT reset the animation.
        if (reset && me.lastRecords && records[0]?.id === me.lastRecords[0]?.id) {
            reset = false
        }

        me.lastRecords = records;

        let ids = records.map(r => `${r.id}-target`),
            rects;

        try {
            // Fetch DOM rects for the MARKERS (Avatars/Badges), not the containers
            rects = await me.waitForDomRect({
                attempts: 20,
                delay   : 50,
                id      : ids
            });

            if (me.lastRecords !== records) {
                return
            }

            // Check if we got valid rects (at least one)
            let hasRects = rects && rects.some(r => r);

            if (!hasRects) {
                return
            }

            // On first valid data load (not resize), ensure size is synced
            // because content might have pushed the container height.
            if (!isResize) {
                await me.updateSize()
            }

            let canvasRect = await me.getDomRect(me.getCanvasId()),
                nodes      = [],
                startY     = 0;

            ids.forEach((targetId, index) => {
                let rect   = rects[index],
                    record = records[index];

                if (rect) {
                    // PRECISE CENTERING
                    // Now 'rect' is the actual avatar/badge.
                    let offset = rect.height / 2,
                        nodeY  = rect.y - canvasRect.y + offset,
                        nodeX  = rect.x - canvasRect.x + (rect.width / 2),
                        // Distinct padding for Orbit effect
                        // Avatars (~40px) get more breathing room than Badges (~28px)
                        padding = rect.height > 32 ? 6 : 3;

                    nodes.push({
                        color : record.color, // Pass Hex Color (e.g. #ff0000)
                        id    : record.id,
                        radius: offset + padding,
                        y     : nodeY,
                        x     : nodeX
                    });

                    // Set the startY of the line to the first node
                    if (index === 0) {
                        startY = nodeY
                    }
                }
            });

            await me.renderer.updateGraphData({nodes, reset, startY})
        } catch (e) {
            console.error('TimelineCanvas update failed', e)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TimelineCanvas));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfcG9ydGFsX3ZpZXdfbmV3c190aWNrZXRzX01haW5Db250YWluZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkRBQUs7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsOEJBQThCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkU7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFLO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLHVCQUF1QixTQUFTO0FBQ2hDLHVCQUF1QixTQUFTO0FBQ2hDLHVCQUF1QixTQUFTO0FBQ2hDLHlCQUF5QjtBQUN6QjtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekMsc0NBQXNDLEdBQUcsa0NBQWtDLE1BQU07QUFDakY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZEVTs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQUs7QUFDL0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLDJCQUEyQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDakNPOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyREFBYztBQUNsRDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLHFDQUFxQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDUztBQUNBOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyREFBSztBQUNuQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxlQUFlLGlFQUFtQjtBQUNsQztBQUNBOztBQUVBLGlFQUFlLCtCQUErQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCSTtBQUNIOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyREFBSztBQUNoQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLGVBQWUsOERBQVc7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDRCQUE0QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDYTtBQUNjOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0REFBZTtBQUNwRDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxlQUFlLHdFQUFxQjtBQUNwQztBQUNBOztBQUVBLGlFQUFlLHNDQUFzQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNSOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBSztBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxlQUFlLHlEQUFXO0FBQzFCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsdUJBQXVCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCOEI7QUFDdEI7QUFDSzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQVM7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBLDBCQUEwQixzREFBZ0I7QUFDMUM7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxPQUFPO0FBQ25DO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMkRBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNFK0I7QUFDUTs7QUFFcEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEdBQUc7QUFDakM7QUFDQTtBQUNBLHNDQUFzQyxLQUFLOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFnQjtBQUN4QztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEYsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCw0Q0FBNEMsZUFBZSxFQUFFLE1BQU0sb0JBQW9CLE1BQU07QUFDN0YsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUEsK0JBQStCLElBQUksV0FBVyxjQUFjO0FBQzVELFNBQVM7O0FBRVQ7O0FBRUE7QUFDQSw4REFBOEQsTUFBTSxrQ0FBa0MsS0FBSztBQUMzRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UsY0FBYyxRQUFRLGlCQUFpQixJQUFJLE1BQU07QUFDdkg7O0FBRUEsMENBQTBDLE1BQU07QUFDaEQ7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLCtCQUErQixJQUFJLHlCQUF5QixLQUFLLFFBQVEsb0NBQW9DO0FBQzdHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsTUFBTTtBQUMzRSx1QkFBdUI7QUFDdkIsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRkFBbUYsc0JBQXNCO0FBQ3pHLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUZBQXlGLGNBQWMsUUFBUSxpQkFBaUIsSUFBSSxNQUFNO0FBQzFJLHNCQUFzQjtBQUN0QixpRUFBaUUsTUFBTTtBQUN2RTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsYUFBYTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSx1QkFBdUIsT0FBTyxnRUFBZ0UsT0FBTztBQUNyRywyQkFBMkIsT0FBTztBQUNsQyxnQ0FBZ0MsZUFBZSxFQUFFLE9BQU8sYUFBYSxPQUFPO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlLEVBQUUsT0FBTyxvQkFBb0IsT0FBTztBQUNoSCx1RUFBdUUsVUFBVTtBQUNqRjtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsTUFBTTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxVQUFVO0FBQ1YsdUNBQXVDLFdBQVcsZ0NBQWdDLGFBQWE7QUFDL0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsR0FBRywyQkFBMkI7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0EsaUJBQWlCOztBQUVqQiwyQkFBMkIsMEVBQU07QUFDakM7QUFDQSwrQkFBK0IsR0FBRyxzREFBc0QsR0FBRztBQUMzRixtQ0FBbUMsR0FBRztBQUN0Qyx3Q0FBd0MsWUFBWSxFQUFFLFlBQVksYUFBYSxZQUFZO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxZQUFZLEVBQUUsWUFBWSxvQkFBb0IsWUFBWTtBQUMvSCxrRUFBa0UsZ0NBQWdDO0FBQ2xHO0FBQ0EsNkRBQTZELEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBLHFCQUFxQix3Q0FBd0M7QUFDN0QscUJBQXFCLHdDQUF3QztBQUM3RCxxQkFBcUIsNkNBQTZDO0FBQ2xFLHFCQUFxQixtRUFBbUU7QUFDeEYscUJBQXFCLG1FQUFtRTtBQUN4RixxQkFBcUIseUNBQXlDO0FBQzlELHFCQUFxQix5Q0FBeUM7QUFDOUQscUJBQXFCLDhDQUE4QztBQUNuRSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsMEVBQU07O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsV0FBVzs7QUFFdEYsaUNBQWlDLGFBQWEsR0FBRywyQkFBMkI7O0FBRTVFO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDZCQUE2QixhQUFhLGlCQUFpQjtBQUN0RywwQkFBMEI7QUFDMUIsMkNBQTJDLDZCQUE2QjtBQUN4RTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsdUNBQXVDLDZCQUE2QixHQUFHLEtBQUs7QUFDNUU7QUFDQSxrQkFBa0I7QUFDbEIsbUNBQW1DLDZCQUE2QixHQUFHLEtBQUs7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLHFEQUFxRCxNQUFNOztBQUUzRDtBQUNBLCtCQUErQixHQUFHLG9EQUFvRCxHQUFHO0FBQ3pGLG1DQUFtQyxHQUFHLHNDQUFzQyxNQUFNLHNCQUFzQixLQUFLO0FBQzdHO0FBQ0EsaUVBQWlFLFlBQVksRUFBRSxLQUFLLG9CQUFvQixLQUFLLE9BQU8sYUFBYSxxQ0FBcUMseUJBQXlCO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx5QkFBeUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNua0JVO0FBQ1U7QUFDVjtBQUN5QjtBQUNaOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzRUFBZTtBQUMzQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLG9CQUFvQixvRUFBVTtBQUM5QjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkIsMERBQWE7QUFDMUM7QUFDQTtBQUNBLHdCQUF3QiwwREFBYTtBQUNyQztBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLHVCQUF1Qix1RUFBYTtBQUNwQztBQUNBLG9CQUFvQixRQUFRLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDZCQUE2QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDbkR3Qjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUVBQVU7QUFDaEQ7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHVDQUF1QyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEtrQjtBQUNZO0FBQ2Y7QUFDVzs7QUFFakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0RBQWE7QUFDdEQ7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFpQjtBQUMzQyxhQUFhO0FBQ2I7QUFDQSx3QkFBd0IseUVBQTJCO0FBQ25ELGFBQWE7QUFDYjtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFZO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGVBQWU7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDBDQUEwQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDN0ltQjs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEVBQWE7QUFDL0M7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsT0FBTztBQUNuQztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBLGlFQUFlLG1DQUFtQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDeEJnQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBWTtBQUN6QztBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxTQUFTLDBEQUEwRCw4QkFBOEI7QUFDakcsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUIscURBQXFEO0FBQ3JGLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxLQUFLO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYiwrQ0FBK0MscUJBQXFCO0FBQ3BFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSw4QkFBOEIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9tb2RlbC9Db250ZW50U2VjdGlvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL21vZGVsL1RpY2tldC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL21vZGVsL1RpY2tldExhYmVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvbW9kZWwvVGlja2V0VGltZWxpbmVTZWN0aW9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvc3RvcmUvQ29udGVudFNlY3Rpb25zLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvc3RvcmUvVGlja2V0TGFiZWxzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvc3RvcmUvVGlja2V0VGltZWxpbmVTZWN0aW9ucy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3N0b3JlL1RpY2tldHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9DYW52YXNXcmFwcGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL01haW5Db250YWluZXJDb250cm9sbGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9QYWdlQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvVGltZWxpbmVDYW52YXMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwubW9kZWwuQ29udGVudFNlY3Rpb25cbiAqIEBleHRlbmRzIE5lby5kYXRhLk1vZGVsXG4gKi9cbmNsYXNzIENvbnRlbnRTZWN0aW9uIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLm1vZGVsLkNvbnRlbnRTZWN0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwubW9kZWwuQ29udGVudFNlY3Rpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGZpZWxkc1xuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICd0YWcnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbnRlbnRTZWN0aW9uKTtcbiIsImltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwubW9kZWwuVGlja2V0XG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5Nb2RlbFxuICovXG5jbGFzcyBUaWNrZXQgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwubW9kZWwuVGlja2V0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwubW9kZWwuVGlja2V0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgIG5hbWUgICAgICAgIDogJ2NvbGxhcHNlZCcsXG4gICAgICAgICAgICB0eXBlICAgICAgICA6ICdCb29sZWFuJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZSAgICAgICAgOiAnaXNMZWFmJyxcbiAgICAgICAgICAgIHR5cGUgICAgICAgIDogJ0Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWUgICAgICAgIDogJ3BhcmVudElkJyxcbiAgICAgICAgICAgIHR5cGUgICAgICAgIDogJ1N0cmluZycsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ3BhdGgnLCAvLyBcInJlc291cmNlcy9jb250ZW50L2lzc3Vlcy9pc3N1ZS0xMjM0Lm1kXCJcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICd0aXRsZScsIC8vIFwiRml4IGVsdXNpdmUgYnVnIGluIEdyaWRcIlxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZWQgZmllbGQgZm9yIFRyZWVMaXN0IGRpc3BsYXlcbiAgICAgICAgICAgIG5hbWU6ICd0cmVlTm9kZU5hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS5pZFxuICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLmlzTGVhZlxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICBkYXRhLnRpdGxlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxjdWxhdGUoe2lkLCBpc0xlYWYsIHRpdGxlfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xlYWYgPyBgPGI+JHtpZH08L2I+IDxzcGFuIGNsYXNzPVwidGlja2V0LXRpdGxlXCI+JHt0aXRsZX08L3NwYW4+YCA6IGlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXQpO1xuIiwiaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5tb2RlbC5UaWNrZXRMYWJlbFxuICogQGV4dGVuZHMgTmVvLmRhdGEuTW9kZWxcbiAqL1xuY2xhc3MgVGlja2V0TGFiZWwgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwubW9kZWwuVGlja2V0TGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5tb2RlbC5UaWNrZXRMYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdjb2xvcicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ3RleHRDb2xvcicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0TGFiZWwpO1xuIiwiaW1wb3J0IENvbnRlbnRTZWN0aW9uIGZyb20gJy4vQ29udGVudFNlY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLm1vZGVsLlRpY2tldFRpbWVsaW5lU2VjdGlvblxuICogQGV4dGVuZHMgUG9ydGFsLm1vZGVsLkNvbnRlbnRTZWN0aW9uXG4gKi9cbmNsYXNzIFRpY2tldFRpbWVsaW5lU2VjdGlvbiBleHRlbmRzIENvbnRlbnRTZWN0aW9uIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5tb2RlbC5UaWNrZXRUaW1lbGluZVNlY3Rpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5tb2RlbC5UaWNrZXRUaW1lbGluZVNlY3Rpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGZpZWxkc1xuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2NvbG9yJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdpY29uJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdpbWFnZScsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnc291cmNlSWQnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldFRpbWVsaW5lU2VjdGlvbik7XG4iLCJpbXBvcnQgQ29udGVudFNlY3Rpb25Nb2RlbCBmcm9tICcuLi9tb2RlbC9Db250ZW50U2VjdGlvbi5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnN0b3JlLkNvbnRlbnRTZWN0aW9uc1xuICogQGV4dGVuZHMgTmVvLmRhdGEuU3RvcmVcbiAqL1xuY2xhc3MgQ29udGVudFNlY3Rpb25zIGV4dGVuZHMgU3RvcmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnN0b3JlLkNvbnRlbnRTZWN0aW9ucydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnN0b3JlLkNvbnRlbnRTZWN0aW9ucycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9Q29udGVudFNlY3Rpb25Nb2RlbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBDb250ZW50U2VjdGlvbk1vZGVsXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb250ZW50U2VjdGlvbnMpO1xuIiwiaW1wb3J0IFRpY2tldExhYmVsIGZyb20gJy4uL21vZGVsL1RpY2tldExhYmVsLm1qcyc7XG5pbXBvcnQgU3RvcmUgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnN0b3JlLlRpY2tldExhYmVsc1xuICogQGV4dGVuZHMgTmVvLmRhdGEuU3RvcmVcbiAqL1xuY2xhc3MgVGlja2V0TGFiZWxzIGV4dGVuZHMgU3RvcmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnN0b3JlLlRpY2tldExhYmVscydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnN0b3JlLlRpY2tldExhYmVscycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGtleVByb3BlcnR5PSduYW1lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBrZXlQcm9wZXJ0eTogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsPVRpY2tldExhYmVsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBUaWNrZXRMYWJlbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdXJsPScuLi8uLi9hcHBzL3BvcnRhbC9yZXNvdXJjZXMvZGF0YS9sYWJlbHMuanNvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdXJsOiAnLi4vLi4vYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvbGFiZWxzLmpzb24nXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRMYWJlbHMpO1xuIiwiaW1wb3J0IENvbnRlbnRTZWN0aW9ucyAgICAgIGZyb20gJy4vQ29udGVudFNlY3Rpb25zLm1qcyc7XG5pbXBvcnQgVGlja2V0VGltZWxpbmVTZWN0aW9uIGZyb20gJy4uL21vZGVsL1RpY2tldFRpbWVsaW5lU2VjdGlvbi5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwuc3RvcmUuVGlja2V0VGltZWxpbmVTZWN0aW9uc1xuICogQGV4dGVuZHMgUG9ydGFsLnN0b3JlLkNvbnRlbnRTZWN0aW9uc1xuICovXG5jbGFzcyBUaWNrZXRUaW1lbGluZVNlY3Rpb25zIGV4dGVuZHMgQ29udGVudFNlY3Rpb25zIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5zdG9yZS5UaWNrZXRUaW1lbGluZVNlY3Rpb25zJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuc3RvcmUuVGlja2V0VGltZWxpbmVTZWN0aW9ucycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9VGlja2V0VGltZWxpbmVTZWN0aW9uXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IFRpY2tldFRpbWVsaW5lU2VjdGlvblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0VGltZWxpbmVTZWN0aW9ucyk7XG4iLCJpbXBvcnQgU3RvcmUgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcbmltcG9ydCBUaWNrZXRNb2RlbCBmcm9tICcuLi9tb2RlbC9UaWNrZXQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnN0b3JlLlRpY2tldHNcbiAqIEBleHRlbmRzIE5lby5kYXRhLlN0b3JlXG4gKi9cbmNsYXNzIFRpY2tldHMgZXh0ZW5kcyBTdG9yZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuc3RvcmUuVGlja2V0cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnN0b3JlLlRpY2tldHMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsPVRpY2tldE1vZGVsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IFRpY2tldE1vZGVsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB1cmw9Jy4uLy4uL2FwcHMvcG9ydGFsL3Jlc291cmNlcy9kYXRhL3RpY2tldHMuanNvbidcbiAgICAgICAgICovXG4gICAgICAgIHVybDogJy4uLy4uL2FwcHMvcG9ydGFsL3Jlc291cmNlcy9kYXRhL3RpY2tldHMuanNvbidcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldHMpO1xuIiwiaW1wb3J0IENvbnRhaW5lciAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ29udGVudENvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IFRpbWVsaW5lQ2FudmFzICAgZnJvbSAnLi9UaW1lbGluZUNhbnZhcy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ2FudmFzV3JhcHBlclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIENhbnZhc1dyYXBwZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNhbnZhc1dyYXBwZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5DYW52YXNXcmFwcGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydwb3J0YWwtY2FudmFzLXdyYXBwZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ3BvcnRhbC1jYW52YXMtd3JhcHBlciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbnRlbnRDb21wb25lbnQ9Q29udGVudENvbXBvbmVudFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudENvbXBvbmVudDogQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3R5bGU9e292ZXJmbG93Oid2aXNpYmxlJyxwYWRkaW5nQm90dG9tOicyMHB4Jyxwb3NpdGlvbjoncmVsYXRpdmUnfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IHtvdmVyZmxvdzogJ3Zpc2libGUnLCBwYWRkaW5nQm90dG9tOiAnMjBweCcsIHBvc2l0aW9uOiAncmVsYXRpdmUnfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBjb25maWcuaXRlbXMgPSBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBUaW1lbGluZUNhbnZhcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ3RpbWVsaW5lLWNhbnZhcycsXG4gICAgICAgICAgICBzdHlsZSA6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiAgICAgOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgbGVmdCAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgIDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIHpJbmRleCAgICAgICA6IDIsXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZTogY29uZmlnLmNvbnRlbnRDb21wb25lbnQgfHwgbWUuY29udGVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHN0eWxlIDoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIHpJbmRleCAgOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlU3VtbWFyeTogbWUub25Ub2dnbGVTdW1tYXJ5LFxuICAgICAgICAgICAgICAgIHNjb3BlICAgICAgICA6IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dO1xuXG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Ub2dnbGVTdW1tYXJ5KCkge1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5nZXRSZWZlcmVuY2UoJ3RpbWVsaW5lLWNhbnZhcycpO1xuXG4gICAgICAgIGlmIChjYW52YXM/Lmxhc3RSZWNvcmRzKSB7XG4gICAgICAgICAgICBjYW52YXMub25UaW1lbGluZURhdGFMb2FkKGNhbnZhcy5sYXN0UmVjb3JkcywgdHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FudmFzV3JhcHBlcik7XG4iLCJpbXBvcnQgQ29udGVudENvbXBvbmVudCBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvYXBwL2NvbnRlbnQvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQge21hcmtlZH0gICAgICAgICBmcm9tICcuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzJztcblxuY29uc3RcbiAgICByZWdleEZyb250TWF0dGVyICAgPSAvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLVxcbi8sXG4gICAgcmVnZXhIMSAgICAgICAgICAgID0gLyg8aDFbXj5dKj4uKj88XFwvaDE+KS8sXG4gICAgcmVnZXhUaWNrZXRMaW5rICAgID0gLyhcXGR7NCx9KS8sXG4gICAgcmVnZXhUaW1lbGluZSAgICAgID0gLyMjIFRpbWVsaW5lXFxzKlxcbihbXFxzXFxTXSopLyxcbiAgICByZWdleFRpbWVsaW5lRXZlbnQgPSAvXi0gKFtcXGRUWjouLV0rKSBAKFxcdyspICguKikkLyxcbiAgICByZWdleENvbW1pdCAgICAgICAgPSAvXFxiKFswLTlhLWZdezcsNDB9KVxcYi9nO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFRoZSBcIk1hcmtkb3duIFRyYW5zZm9ybWVyXCIgZm9yIEdpdEh1YiBUaWNrZXRzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGV4dGVuZHMgdGhlIHN0YW5kYXJkIENvbnRlbnRDb21wb25lbnQgdG8gcHJvdmlkZSBzcGVjaWFsaXplZCByZW5kZXJpbmcgZm9yIEdpdEh1YiBJc3N1ZXMuXG4gKiBJdHMgcHJpbWFyeSByZXNwb25zaWJpbGl0eSBpcyB0byBwYXJzZSB0aGUgcmF3IE1hcmtkb3duIGNvbnRlbnQgKHdoaWNoIGluY2x1ZGVzIGN1c3RvbSBGcm9udG1hdHRlciBhbmRcbiAqIGEgcHJlLWdlbmVyYXRlZCBUaW1lbGluZSBzZWN0aW9uKSBhbmQgdHJhbnNmb3JtIGl0IGludG8gYSByaWNoLCBpbnRlcmFjdGl2ZSBIVE1MIHN0cnVjdHVyZS5cbiAqXG4gKiAqKktleSBSZXNwb25zaWJpbGl0aWVzOioqXG4gKiAxLiAqKlBhcnNpbmcgUGlwZWxpbmUqKjogRXh0cmFjdHMgRnJvbnRtYXR0ZXIsIEJvZHksIGFuZCB0aGUgY3VzdG9tIFwiVGltZWxpbmVcIiBzZWN0aW9uIGZyb20gdGhlIHJhdyBNYXJrZG93bi5cbiAqIDIuICoqUmljaCBSZW5kZXJpbmcqKjogR2VuZXJhdGVzIEhUTUwgZm9yIFN0YXR1cyBCYWRnZXMsIExhYmVscywgQ29tbWl0IExpbmtzLCBhbmQgVXNlciBNZW50aW9ucy5cbiAqIDMuICoqRGF0YSBFeHRyYWN0aW9uKio6IEFzIGEgc2lkZSBlZmZlY3Qgb2YgcmVuZGVyaW5nLCBpdCBleHRyYWN0cyBzdHJ1Y3R1cmVkIGRhdGEgKGBtZS50aW1lbGluZURhdGFgKVxuICogICAgcmVwcmVzZW50aW5nIGV2ZXJ5IHRpbWVsaW5lIGV2ZW50IChjb21tZW50LCBsYWJlbCBjaGFuZ2UsIGNsb3NlLCBldGMuKS4gVGhpcyBkYXRhIGlzIHRoZW5cbiAqICAgIHB1c2hlZCB0byB0aGUgYHNlY3Rpb25zYCBzdG9yZSB0byBkcml2ZSB0aGUgYFRpbWVsaW5lQ2FudmFzYCB2aXN1YWxpemF0aW9uLlxuICpcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uYXBwLmNvbnRlbnQuQ29tcG9uZW50XG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIENvbnRlbnRDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsncG9ydGFsLW5ld3MtdGlja2V0cy1jb21wb25lbnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ3BvcnRhbC1uZXdzLXRpY2tldHMtY29tcG9uZW50J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbW1pdHNVcmw9J2h0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2NvbW1pdC8nXG4gICAgICAgICAqL1xuICAgICAgICBjb21taXRzVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vY29tbWl0LycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRvbUxpc3RlbmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZG9tTGlzdGVuZXJzOiB7XG4gICAgICAgICAgICByZXNpemU6ICdvblJlc2l6ZSdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVwb1VzZXJVcmw9J2h0dHBzOi8vZ2l0aHViLmNvbS8nXG4gICAgICAgICAqL1xuICAgICAgICByZXBvVXNlclVybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXBkYXRlU2VjdGlvbnNTdG9yZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlU2VjdGlvbnNTdG9yZTogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9ICNkYXRlVGltZUZvcm1hdEhpc3Rvcnk9bnVsbFxuICAgICAqL1xuICAgICNkYXRlVGltZUZvcm1hdEhpc3RvcnkgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSAjZGF0ZVRpbWVGb3JtYXRUb2RheT1udWxsXG4gICAgICovXG4gICAgI2RhdGVUaW1lRm9ybWF0VG9kYXkgPSBudWxsXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIHRoZSBzdHJ1Y3R1cmVkIHRpbWVsaW5lIGRhdGEgZXh0cmFjdGVkIGR1cmluZyB0aGUgcGFyc2luZyBwaGFzZS5cbiAgICAgKiBUaGlzIGFycmF5IGlzIHBvcHVsYXRlZCBieSBgcmVuZGVyVGltZWxpbmVgIGFuZCBgbW9kaWZ5TWFya2Rvd25gIGFuZCB0aGVuIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGBzZWN0aW9uc2Agc3RvcmUgdG8gZHJpdmUgdGhlIENhbnZhcyB2aXN1YWxpemF0aW9uLlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSB0aW1lbGluZURhdGE9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGltZWxpbmVEYXRhID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoJ2NvbnRlbnRDb21wb25lbnRJZCcsIHRoaXMuaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlzb1N0cmluZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VGltZXN0YW1wKGlzb1N0cmluZykge1xuICAgICAgICBpZiAoIWlzb1N0cmluZykgcmV0dXJuICcnO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGUgICAgPSBuZXcgRGF0ZShpc29TdHJpbmcpLFxuICAgICAgICAgICAgbm93ICAgICA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBpc1RvZGF5ID0gZGF0ZS50b0RhdGVTdHJpbmcoKSA9PT0gbm93LnRvRGF0ZVN0cmluZygpO1xuXG4gICAgICAgIGlmIChpc1RvZGF5KSB7XG4gICAgICAgICAgICBpZiAoIW1lLiNkYXRlVGltZUZvcm1hdFRvZGF5KSB7XG4gICAgICAgICAgICAgICAgbWUuI2RhdGVUaW1lRm9ybWF0VG9kYXkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZGVmYXVsdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaG91ciAgOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1lLiNkYXRlVGltZUZvcm1hdFRvZGF5LmZvcm1hdChkYXRlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS4jZGF0ZVRpbWVGb3JtYXRIaXN0b3J5KSB7XG4gICAgICAgICAgICBtZS4jZGF0ZVRpbWVGb3JtYXRIaXN0b3J5ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2RlZmF1bHQnLCB7XG4gICAgICAgICAgICAgICAgZGF5ICAgOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgaG91ciAgOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgbW9udGggOiAnc2hvcnQnLFxuICAgICAgICAgICAgICAgIHllYXIgIDogJ251bWVyaWMnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLiNkYXRlVGltZUZvcm1hdEhpc3RvcnkuZm9ybWF0KGRhdGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGZyb250TWF0dGVyVG9IdG1sKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaHRtbCA9ICc8dGFibGUgY2xhc3M9XCJuZW8tZnJvbnRtYXR0ZXItdGFibGVcIj48dGJvZHk+JztcblxuICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGxldCByZW5kZXJlZFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc3ViSXNzdWVzJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSB2YWx1ZS5tYXAoaXNzdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJuZW8tc3ViLWlzc3VlXCI+JHtpc3N1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocmVnZXhUaWNrZXRMaW5rLCAnPGEgaHJlZj1cIiMvbmV3cy90aWNrZXRzLyQxXCI+JDE8L2E+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdbeF0nLCAnPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1jaXJjbGUtY2hlY2tcIj48L2k+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdbIF0nLCAnPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLWNpcmNsZVwiPjwvaT4nKX08L2Rpdj5gXG4gICAgICAgICAgICAgICAgfSkuam9pbignJylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnYXV0aG9yJykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSBgPGEgaHJlZj1cIiR7bWUucmVwb1VzZXJVcmx9JHt2YWx1ZX1cIiB0YXJnZXQ9XCJfYmxhbmtcIj4ke3ZhbHVlfTwvYT5gXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NyZWF0ZWRBdCcgfHwga2V5ID09PSAnY2xvc2VkQXQnIHx8IGtleSA9PT0gJ3VwZGF0ZWRBdCcpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gbWUuZm9ybWF0VGltZXN0YW1wKHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdsYWJlbHMnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IG1lLmdldEJhZGdlc0h0bWwodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSBtZS5nZXRTdGF0ZUJhZGdlSHRtbCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IG1lLmZvcm1hdEZyb250TWF0dGVyVmFsdWUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgKz0gYDx0cj48dGQ+JHtrZXl9PC90ZD48dGQ+JHtyZW5kZXJlZFZhbHVlfTwvdGQ+PC90cj5gXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGh0bWwgKz0gJzwvdGJvZHk+PC90YWJsZT4nO1xuXG4gICAgICAgIGlmIChtZS51c2VGcm9udG1hdHRlckRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBgPGRldGFpbHMgaWQ9XCJuZW8tdGlja2V0LXN1bW1hcnktZGV0YWlscy0ke21lLmlkfVwiPjxzdW1tYXJ5PkZyb250bWF0dGVyPC9zdW1tYXJ5PiR7aHRtbH08L2RldGFpbHM+YFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBsYWJlbHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEJhZGdlc0h0bWwobGFiZWxzKSB7XG4gICAgICAgIGlmICghbGFiZWxzIHx8IGxhYmVscy5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBiYWRnZXNIdG1sID0gJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LWxhYmVsc1wiPic7XG5cbiAgICAgICAgbGFiZWxzLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICAgICAgYmFkZ2VzSHRtbCArPSBtZS5nZXRMYWJlbEJhZGdlSHRtbChsYWJlbClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmFkZ2VzSHRtbCArPSAnPC9kaXY+JztcblxuICAgICAgICByZXR1cm4gYmFkZ2VzSHRtbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBkb0ZldGNoQ29udGVudChyZWNvcmQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1lLFxuICAgICAgICAgICAgY29udGVudCwgZGF0YSwgcGF0aDtcblxuICAgICAgICBwYXRoID0gbWUuZ2V0Q29udGVudFBhdGgocmVjb3JkKTtcblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiAmJiBwYXRoKSB7XG4gICAgICAgICAgICBkYXRhICAgID0gYXdhaXQgZmV0Y2gocGF0aCk7XG4gICAgICAgICAgICBjb250ZW50ID0gYXdhaXQgZGF0YS50ZXh0KCk7XG5cbiAgICAgICAgICAgIG1lLnZhbHVlID0gY29udGVudDtcblxuICAgICAgICAgICAgbWUudG9nZ2xlQ2xzKCdsYWInLCByZWNvcmQubmFtZT8uc3RhcnRzV2l0aCgnTGFiOicpKTtcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uSW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBvYnNlcnZlICAgOiBbJy5uZW8tdGltZWxpbmUtaXRlbVtkYXRhLXJlY29yZC1pZF0nXSxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVjb3JkLnBhdGhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29udGVudFBhdGgoe3BhdGh9KSB7XG4gICAgICAgIHJldHVybiBwYXRoID8gTmVvLmNvbmZpZy5iYXNlUGF0aCArIHBhdGggOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRMYWJlbEJhZGdlSHRtbChsYWJlbCkge1xuICAgICAgICBsZXQgc3RvcmUgID0gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ2xhYmVscycpLFxuICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0KGxhYmVsKTtcblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwibmVvLWJhZGdlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiR7cmVjb3JkLmNvbG9yfTtjb2xvcjoke3JlY29yZC50ZXh0Q29sb3J9XCI+JHtsYWJlbH08L3NwYW4+YFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGA8c3BhbiBjbGFzcz1cIm5lby1iYWRnZVwiPiR7bGFiZWx9PC9zcGFuPmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN0YXRlQmFkZ2VIdG1sKHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RhdGUpIHJldHVybiAnJztcblxuICAgICAgICBsZXQgY2xzICA9ICduZW8tYmFkZ2UgbmVvLXN0YXRlLWJhZGdlJyxcbiAgICAgICAgICAgIGljb24gPSAnZmEtY2lyY2xlLWRvdCc7XG5cbiAgICAgICAgaWYgKHN0YXRlLnRvVXBwZXJDYXNlKCkgPT09ICdDTE9TRUQnKSB7XG4gICAgICAgICAgICBjbHMgICs9ICcgbmVvLXN0YXRlLWNsb3NlZCc7XG4gICAgICAgICAgICBpY29uICA9ICdmYS1jaXJjbGUtY2hlY2snXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHMgKz0gJyBuZW8tc3RhdGUtb3BlbidcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCIke2Nsc31cIj48aSBjbGFzcz1cImZhLXJlZ3VsYXIgJHtpY29ufVwiPjwvaT4ke05lby5jYXBpdGFsaXplKHN0YXRlLnRvTG93ZXJDYXNlKCkpfTwvc3Bhbj5gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIE1haW4gUGFyc2luZyBQaXBlbGluZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGludGVyY2VwdHMgdGhlIHJhdyBtYXJrZG93biBjb250ZW50IGJlZm9yZSBpdCBpcyByZW5kZXJlZCBhbmQgcGVyZm9ybXMgYSBtdWx0aS1wYXNzIHRyYW5zZm9ybWF0aW9uOlxuICAgICAqIDEuICoqRXh0cmFjdCBUaW1lbGluZSoqOiBQdWxscyBvdXQgdGhlIHJhdyBgIyMgVGltZWxpbmVgIHNlY3Rpb24gdG8gcHJvY2VzcyBpdCBzZXBhcmF0ZWx5LlxuICAgICAqIDIuICoqUHJvY2VzcyBGcm9udG1hdHRlcioqOiBFeHRyYWN0cyBtZXRhZGF0YSAobGFiZWxzLCBzdGF0ZSwgYXV0aG9yKSBhbmQgcmVtb3ZlcyB0aGUgWUFNTCBibG9jay5cbiAgICAgKiAzLiAqKlJlbmRlciBCb2R5Kio6IFVzZXMgdGhlIHN1cGVyY2xhc3MgKG1hcmtlZC5qcykgdG8gY29udmVydCB0aGUgbWFpbiBpc3N1ZSBib2R5IHRvIEhUTUwuXG4gICAgICogNC4gKipJbmplY3QgVGl0bGUgSURzKio6IEFkZHMgSURzIHRvIEgxIHRhZ3MgZm9yIG5hdmlnYXRpb24uXG4gICAgICogNS4gKipHZW5lcmF0ZSBCYWRnZXMqKjogQ3JlYXRlcyBIVE1MIGZvciBTdGF0dXMvTGFiZWwgYmFkZ2VzIGJhc2VkIG9uIGV4dHJhY3RlZCBtZXRhZGF0YS5cbiAgICAgKiA2LiAqKldyYXAgQm9keSoqOiBXcmFwcyB0aGUgbWFpbiBpc3N1ZSBib2R5IGluIGEgYHRpbWVsaW5lLWl0ZW1gIHN0cnVjdHVyZSBzbyBpdCBhcHBlYXJzIGFzIHRoZSBmaXJzdCBpdGVtLlxuICAgICAqIDcuICoqUmUtQXNzZW1ibGUqKjogQ29uY2F0ZW5hdGVzIEZyb250bWF0dGVyICsgVGl0bGUgKyBUaW1lbGluZSAod2l0aCBCb2R5IGluamVjdGVkKSBpbnRvIHRoZSBmaW5hbCBIVE1MLlxuICAgICAqXG4gICAgICogKipTaWRlIEVmZmVjdCoqOiBQb3B1bGF0ZXMgYG1lLnRpbWVsaW5lRGF0YWAgYW5kIHVwZGF0ZXMgdGhlIGBzZWN0aW9uc2Agc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgbW9kaWZ5TWFya2Rvd24oY29udGVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnRJZH0gICA9IG1lLnJlY29yZCxcbiAgICAgICAgICAgIGF1dGhvciAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBjcmVhdGVkQXQgICAgPSBudWxsLFxuICAgICAgICAgICAgbGFiZWxzICAgICAgID0gW10sXG4gICAgICAgICAgICBzdGF0ZSAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgbWF0Y2ggICAgICAgID0gY29udGVudC5tYXRjaChyZWdleEZyb250TWF0dGVyKSxcbiAgICAgICAgICAgIHRpbWVsaW5lSHRtbCA9ICcnLFxuICAgICAgICAgICAgYmFkZ2VzSHRtbCAgID0gJyc7XG5cbiAgICAgICAgbWUudGltZWxpbmVEYXRhID0gW107XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG1lLnBhcnNlRnJvbnRNYXR0ZXIobWF0Y2hbMV0pO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5hdXRob3IpICAgIHthdXRob3IgICAgPSBkYXRhLmF1dGhvcn1cbiAgICAgICAgICAgIGlmIChkYXRhLmNyZWF0ZWRBdCkge2NyZWF0ZWRBdCA9IG1lLmZvcm1hdFRpbWVzdGFtcChkYXRhLmNyZWF0ZWRBdCl9XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMpICAgIHtsYWJlbHMgICAgPSBkYXRhLmxhYmVsc31cbiAgICAgICAgICAgIGlmIChkYXRhLnN0YXRlKSAgICAge3N0YXRlICAgICA9IGRhdGEuc3RhdGV9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAxLiBFeHRyYWN0IGFuZCBwcm9jZXNzIHRpbWVsaW5lIGZyb20gUkFXIG1hcmtkb3duXG4gICAgICAgIGxldCB0aW1lbGluZU1hdGNoID0gY29udGVudC5tYXRjaChyZWdleFRpbWVsaW5lKTtcbiAgICAgICAgaWYgKHRpbWVsaW5lTWF0Y2gpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lSHRtbCA9IG1lLnJlbmRlclRpbWVsaW5lKHRpbWVsaW5lTWF0Y2hbMV0pO1xuICAgICAgICAgICAgY29udGVudCAgICAgID0gY29udGVudC5yZXBsYWNlKHJlZ2V4VGltZWxpbmUsICcnKTsgLy8gUmVtb3ZlIHJhdyB0aW1lbGluZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gUmVuZGVyIEZyb250bWF0dGVyIE1hbnVhbGx5ICYgU3RyaXAgaXRcbiAgICAgICAgLy8gV2Ugd2FudCBpdCBhdCB0aGUgdmVyeSB0b3AsIG91dHNpZGUgdGhlIGJvZHkgYnViYmxlLlxuICAgICAgICBsZXQgZnJvbnRNYXR0ZXJIdG1sID0gJyc7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgICAgICAgID0gbWUucGFyc2VGcm9udE1hdHRlcihtYXRjaFsxXSk7XG4gICAgICAgICAgICBmcm9udE1hdHRlckh0bWwgPSBtZS5mcm9udE1hdHRlclRvSHRtbChkYXRhKTtcbiAgICAgICAgICAgIGNvbnRlbnQgICAgICAgICA9IGNvbnRlbnQucmVwbGFjZShyZWdleEZyb250TWF0dGVyLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBDb252ZXJ0IEJvZHkgKyBUaXRsZSB0byBIVE1MIHVzaW5nIHN1cGVyXG4gICAgICAgIGxldCBmdWxsSHRtbCA9IHN1cGVyLm1vZGlmeU1hcmtkb3duKGNvbnRlbnQpO1xuXG4gICAgICAgIC8vIDQuIEV4dHJhY3QgSDEgVGl0bGUgZnJvbSB0aGUgZ2VuZXJhdGVkIEhUTUxcbiAgICAgICAgbGV0IHRpdGxlSHRtbCA9ICcnO1xuICAgICAgICBmdWxsSHRtbCAgICAgID0gZnVsbEh0bWwucmVwbGFjZShyZWdleEgxLCAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIC8vIEluamVjdCBJRCBpbnRvIEgxIHRhZ1xuICAgICAgICAgICAgdGl0bGVIdG1sID0gbWF0Y2gucmVwbGFjZSgnPGgxJywgYDxoMSBpZD1cInRpY2tldC10aXRsZS0ke21lLmlkfVwiYCk7XG4gICAgICAgICAgICByZXR1cm4gJyc7IC8vIFJlbW92ZSB0aXRsZSBmcm9tIGJvZHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gNS4gQ29uc3RydWN0IEJhZGdlc1xuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA+IDAgfHwgc3RhdGUgfHwgKHBhcmVudElkICYmIHBhcmVudElkICE9PSAnQmFja2xvZycpKSB7XG4gICAgICAgICAgICBiYWRnZXNIdG1sID0gJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LWxhYmVsc1wiPic7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gbWUuZ2V0U3RhdGVCYWRnZUh0bWwoc3RhdGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCAmJiBwYXJlbnRJZCAhPT0gJ0JhY2tsb2cnKSB7XG4gICAgICAgICAgICAgICAgYmFkZ2VzSHRtbCArPSBgXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwibmVvLWJhZGdlIG5lby1yZWxlYXNlLWJhZGdlXCIgaHJlZj1cIiMvbmV3cy9yZWxlYXNlcy8ke3BhcmVudElkLnN1YnN0cmluZygxKX1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEtc29saWQgZmEtY29kZS1icmFuY2hcIj48L2k+ICR7cGFyZW50SWR9XG4gICAgICAgICAgICAgICAgICAgIDwvYT5gXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBzdG9yZSA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgnbGFiZWxzJyksXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICAgICAgICAgIGxhYmVscy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0KGxhYmVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWRnZXNIdG1sICs9IGA8c3BhbiBjbGFzcz1cIm5lby1iYWRnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjoke3JlY29yZC5jb2xvcn07Y29sb3I6JHtyZWNvcmQudGV4dENvbG9yfVwiPiR7bGFiZWx9PC9zcGFuPmBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gYDxzcGFuIGNsYXNzPVwibmVvLWJhZGdlXCI+JHtsYWJlbH08L3NwYW4+YFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICB0aXRsZUh0bWwgICs9IGJhZGdlc0h0bWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA2LiBXcmFwIHRoZSByZW1haW5pbmcgSFRNTCAoQm9keSkgaW4gdGhlIFRpbWVsaW5lIEl0ZW0gc3RydWN0dXJlXG4gICAgICAgIGxldCBib2R5SWQgPSBgdGltZWxpbmUtJHttZS5yZWNvcmQuaWR9LTBgO1xuXG4gICAgICAgIG1lLnRpbWVsaW5lRGF0YS51bnNoaWZ0KHtcbiAgICAgICAgICAgIGlkICAgOiBib2R5SWQsXG4gICAgICAgICAgICBpbWFnZTogbWUucmVwb1VzZXJVcmwgKyBhdXRob3IgKyAnLnBuZycsXG4gICAgICAgICAgICBuYW1lIDogJ0Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgIHRhZyAgOiAnYm9keSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGJvZHlJdGVtSHRtbCA9IGBcbiAgICAgICAgICAgIDxkaXYgaWQ9XCIke2JvZHlJZH1cIiBjbGFzcz1cIm5lby10aW1lbGluZS1pdGVtIGNvbW1lbnQgYm9keS1pdGVtXCIgZGF0YS1yZWNvcmQtaWQ9XCIke2JvZHlJZH1cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtib2R5SWR9LXRhcmdldFwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWF2YXRhclwiPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIiR7bWUucmVwb1VzZXJVcmx9JHthdXRob3J9LnBuZ1wiIGFsdD1cIiR7YXV0aG9yfVwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuZW8tdGltZWxpbmUtdXNlclwiIGhyZWY9XCIke21lLnJlcG9Vc2VyVXJsfSR7YXV0aG9yfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7YXV0aG9yfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibmVvLXRpbWVsaW5lLWRhdGVcIj5jb21tZW50ZWQgb24gJHtjcmVhdGVkQXR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1ib2R5XCI+JHtmdWxsSHRtbH08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmA7XG5cbiAgICAgICAgLy8gNy4gSW5qZWN0IEJvZHkgSXRlbSBhdCB0aGUgc3RhcnQgb2YgdGhlIFRpbWVsaW5lXG4gICAgICAgIGxldCB0aW1lbGluZUlkID0gYHRpY2tldC10aW1lbGluZS0ke21lLmlkfWA7XG5cbiAgICAgICAgaWYgKHRpbWVsaW5lSHRtbCkge1xuICAgICAgICAgICAgdGltZWxpbmVIdG1sID0gdGltZWxpbmVIdG1sLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LXRpbWVsaW5lXCI+JyxcbiAgICAgICAgICAgICAgICBgPGRpdiBpZD1cIiR7dGltZWxpbmVJZH1cIiBjbGFzcz1cIm5lby10aWNrZXQtdGltZWxpbmVcIj5gICsgYm9keUl0ZW1IdG1sXG4gICAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZUh0bWwgPSBgPGRpdiBpZD1cIiR7dGltZWxpbmVJZH1cIiBjbGFzcz1cIm5lby10aWNrZXQtdGltZWxpbmVcIj4ke2JvZHlJdGVtSHRtbH08L2Rpdj5gXG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3NlY3Rpb25zJykuZGF0YSA9IG1lLnRpbWVsaW5lRGF0YTtcbiAgICAgICAgbWUudGltZWxpbmVEYXRhID0gbnVsbDtcblxuICAgICAgICAvLyBSZXR1cm46IEZyb250bWF0dGVyICsgVGl0bGUgKyBUaW1lbGluZVxuICAgICAgICByZXR1cm4gZnJvbnRNYXR0ZXJIdG1sICsgdGl0bGVIdG1sICsgdGltZWxpbmVIdG1sXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJlc2l6ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgndG9nZ2xlU3VtbWFyeScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBjdXN0b20gXCJUaW1lbGluZVwiIG1hcmtkb3duIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBFeHBlY3RzIGEgbGluZS1iYXNlZCBmb3JtYXQgZ2VuZXJhdGVkIGJ5IHRoZSBidWlsZCBwcm9jZXNzOlxuICAgICAqIC0gRXZlbnRzOiBgLSBZWVlZLU1NLUREVEhIOm1tOnNzIEB1c2VyIGFjdGlvbiB0ZXh0Li4uYFxuICAgICAqIC0gQ29tbWVudHM6IGAjIyMgQHVzZXIgLSBZWVlZLU1NLUREVEhIOm1tOnNzYCBmb2xsb3dlZCBieSBjb21tZW50IGJvZHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjb252ZXJ0cyB0aGVzZSBsaW5lcyBpbnRvIHN0cnVjdHVyZWQgYHRpbWVsaW5lLWl0ZW1gIEhUTUwgYmxvY2tzXG4gICAgICogYW5kIHNpbXVsdGFuZW91c2x5IHBvcHVsYXRlcyBgbWUudGltZWxpbmVEYXRhYCB3aXRoIHNlbWFudGljIGRhdGEgKGNvbG9yLCBpY29uLCB0eXBlKVxuICAgICAqIGZvciBlYWNoIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJlbmRlclRpbWVsaW5lKGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb21taXRzVXJsLCByZXBvVXNlclVybH0gPSBtZSxcbiAgICAgICAgICAgIGh0bWwgICAgICAgID0gJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LXRpbWVsaW5lXCI+JyxcbiAgICAgICAgICAgIGxpbmVzICAgICAgID0gY29udGVudC5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgICBjb21tZW50QnVmICA9IFtdLFxuICAgICAgICAgICAgY3VycmVudFVzZXIgPSBudWxsLFxuICAgICAgICAgICAgY3VycmVudERhdGUgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgPSBsaW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBpZCwgbGluZSwgbWF0Y2gsIGljb24sIGFjdGlvbkNscztcblxuICAgICAgICBjb25zdCBmbHVzaENvbW1lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29tbWVudEJ1Zi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBgdGltZWxpbmUtJHttZS5yZWNvcmQuaWR9LSR7bWUudGltZWxpbmVEYXRhLmxlbmd0aCArIDF9YDtcblxuICAgICAgICAgICAgICAgIG1lLnRpbWVsaW5lRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogcmVwb1VzZXJVcmwgKyBjdXJyZW50VXNlciArICcucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA6IGBDb21tZW50ICgke2N1cnJlbnRVc2VyfSlgLFxuICAgICAgICAgICAgICAgICAgICB0YWcgIDogJ2NvbW1lbnQnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IG1hcmtlZC5wYXJzZShjb21tZW50QnVmLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICBodG1sICs9IGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7aWR9XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtaXRlbSBjb21tZW50XCIgZGF0YS1yZWNvcmQtaWQ9XCIke2lkfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7aWR9LXRhcmdldFwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWF2YXRhclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiJHtyZXBvVXNlclVybH0ke2N1cnJlbnRVc2VyfS5wbmdcIiBhbHQ9XCIke2N1cnJlbnRVc2VyfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5lby10aW1lbGluZS11c2VyXCIgaHJlZj1cIiR7cmVwb1VzZXJVcmx9JHtjdXJyZW50VXNlcn1cIiB0YXJnZXQ9XCJfYmxhbmtcIj4ke2N1cnJlbnRVc2VyfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJuZW8tdGltZWxpbmUtZGF0ZVwiPiR7bWUuZm9ybWF0VGltZXN0YW1wKGN1cnJlbnREYXRlKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1ib2R5XCI+JHtib2R5fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgICAgICAgICAgY29tbWVudEJ1ZiAgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXNlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgICAgICAvLyBFdmVudCBMaW5lOiAtIDIwMjYtMDEtMTFULi4uIEB1c2VyIGFjdGlvbi4uLlxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2gocmVnZXhUaW1lbGluZUV2ZW50KSkpIHtcbiAgICAgICAgICAgICAgICBmbHVzaENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICBsZXQgW18sIGRhdGUsIHVzZXIsIGFjdGlvbl0gPSBtYXRjaDtcblxuICAgICAgICAgICAgICAgIGljb24gICAgICA9ICdmYS1jaXJjbGUtZG90JzsgLy8gRGVmYXVsdFxuICAgICAgICAgICAgICAgIGFjdGlvbkNscyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gW1xuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnYWRkZWQgdGhlIGAnLCAgICAgIGljb246ICdmYS10YWcnfSxcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ3JlbW92ZWQgdGhlIGAnLCAgICBpY29uOiAnZmEtdGFnJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdhc3NpZ25lZCcsICAgICAgICAgaWNvbjogJ2ZhLXVzZXItcGVuJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdjbG9zZWQnLCAgICAgICAgICAgaWNvbjogJ2ZhLWNpcmNsZS1jaGVjaycsIGNvbG9yOiAnIzgyNTBkZid9LCAvLyBHaXRIdWIgUHVycGxlXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdyZW9wZW5lZCcsICAgICAgICAgaWNvbjogJ2ZhLWNpcmNsZS1kb3QnLCAgIGNvbG9yOiAnIzJkYTQ0ZSd9LCAvLyBHaXRIdWIgR3JlZW5cbiAgICAgICAgICAgICAgICAgICAge2tleTogJ3JlZmVyZW5jZWQnLCAgICAgICBpY29uOiAnZmEtbGluayd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnY3Jvc3MtcmVmZXJlbmNlZCcsIGljb246ICdmYS1saW5rJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdtaWxlc3RvbmVkJywgICAgICAgaWNvbjogJ2ZhLXNpZ24tcG9zdCd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnc3ViLWlzc3VlJywgICAgICAgIGljb246ICdmYS1kaWFncmFtLXByb2plY3QnfVxuICAgICAgICAgICAgICAgIF0uZmluZChlID0+IGFjdGlvbi5pbmNsdWRlcyhlLmtleSkpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbiA9IGV2ZW50VHlwZS5pY29uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlLmNvbG9yKSBjb2xvciA9IGV2ZW50VHlwZS5jb2xvclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIG1hcmtkb3duIGluIGFjdGlvbiB0ZXh0IChlLmcuIGBjb2RlYCB0byA8Y29kZT4pXG4gICAgICAgICAgICAgICAgbGV0IGNsZWFuQWN0aW9uID0gbWFya2VkLnBhcnNlSW5saW5lKGFjdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWNvbiA9PT0gJ2ZhLXRhZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5BY3Rpb24gPSBjbGVhbkFjdGlvbi5yZXBsYWNlKC88Y29kZT4oLio/KTxcXC9jb2RlPi9nLCAobWF0Y2gsIGxhYmVsKSA9PiBtZS5nZXRMYWJlbEJhZGdlSHRtbChsYWJlbCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZXNvbHZlIGNvbG9yIGZyb20gbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTWF0Y2ggPSBhY3Rpb24ubWF0Y2goL2AoW15gXSspYC8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTmFtZSA9IGxhYmVsTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxSZWMgID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdsYWJlbHMnKS5nZXQobGFiZWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFJlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbGFiZWxSZWMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMaW5raWZ5IENvbW1pdCBIYXNoZXNcbiAgICAgICAgICAgICAgICBjbGVhbkFjdGlvbiA9IGNsZWFuQWN0aW9uLnJlcGxhY2UocmVnZXhDb21taXQsIGA8YSBocmVmPVwiJHtjb21taXRzVXJsfSQxXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JDE8L2E+YCk7XG5cbiAgICAgICAgICAgICAgICBpZCA9IGB0aW1lbGluZS0ke21lLnJlY29yZC5pZH0tJHttZS50aW1lbGluZURhdGEubGVuZ3RoICsgMX1gO1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBhIHNob3J0IGFjdGlvbiBuYW1lIGZvciB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGxldCBzaG9ydEFjdGlvbiA9IGFjdGlvbi5zcGxpdCgnICcpWzBdOyAvLyAnYWRkZWQnLCAnY2xvc2VkJywgZXRjLlxuICAgICAgICAgICAgICAgIGxldCBlbnRyeU5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvcnRBY3Rpb24gPT09ICdhZGRlZCcgfHwgc2hvcnRBY3Rpb24gPT09ICdyZW1vdmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmluY2x1ZGVzKCdzdWItaXNzdWUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1Yklzc3VlTWF0Y2ggPSBhY3Rpb24ubWF0Y2goLyMoXFxkKykvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJJc3N1ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlOYW1lID0gYCR7TmVvLmNhcGl0YWxpemUoc2hvcnRBY3Rpb24pfSBzdWItaXNzdWUgIyR7c3ViSXNzdWVNYXRjaFsxXX1gXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5TmFtZSA9IGAke05lby5jYXBpdGFsaXplKHNob3J0QWN0aW9uKX0gc3ViLWlzc3VlYFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTWF0Y2ggPSBhY3Rpb24ubWF0Y2goL2AoW15gXSspYC8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnRBY3Rpb24gPSBsYWJlbE1hdGNoID8gbGFiZWxNYXRjaFsxXSA6ICdMYWJlbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUgPSBgJHtOZW8uY2FwaXRhbGl6ZShzaG9ydEFjdGlvbil9ICgke3VzZXJ9KWBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5TmFtZSA9IGAke05lby5jYXBpdGFsaXplKHNob3J0QWN0aW9uKX0gKCR7dXNlcn0pYFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnRpbWVsaW5lRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLCAvLyBQYXNzIHJlc29sdmVkIGhleCBjb2xvclxuICAgICAgICAgICAgICAgICAgICBpY29uIDogaWNvbixcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lIDogZW50cnlOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWcgIDogJ2V2ZW50J1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgY29sb3Igc3R5bGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSBjb2xvciA/IGBzdHlsZT1cImNvbG9yOiAke2NvbG9yfVwiYCA6ICcnO1xuXG4gICAgICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2lkfVwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWl0ZW0gZXZlbnRcIiBkYXRhLXJlY29yZC1pZD1cIiR7aWR9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtpZH0tdGFyZ2V0XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtYmFkZ2VcIiAke3N0eWxlfT48aSBjbGFzcz1cImZhLXNvbGlkICR7aWNvbn1cIj48L2k+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5lby10aW1lbGluZS11c2VyXCIgaHJlZj1cIiR7cmVwb1VzZXJVcmx9JHt1c2VyfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7dXNlcn08L2E+ICR7Y2xlYW5BY3Rpb259IDxzcGFuIGNsYXNzPVwibmVvLXRpbWVsaW5lLWRhdGVcIj5vbiAke21lLmZvcm1hdFRpbWVzdGFtcChkYXRlKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbW1lbnQgSGVhZGVyOiAjIyMgQHVzZXIgLSAyMDI2LTAxLTExVC4uLlxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKCcjIyMgQCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZXMgXCJ1c2VyXCIgYW5kIFwiMjAyNi0wMS0xMVQuLi5cIiAoSVNPIHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGVyTWF0Y2ggPSBsaW5lLm1hdGNoKC9eIyMjIEAoXFx3KykgLSAoW1xcZFRaOi4tXSspJC8pO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXIgPSBoZWFkZXJNYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBoZWFkZXJNYXRjaFsyXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciB3ZWlyZCBoZWFkZXJzPyB0cmVhdCBhcyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXNlcikgY29tbWVudEJ1Zi5wdXNoKGxpbmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRCdWYucHVzaChsaW5lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoQ29tbWVudCgpOyAvLyBGbHVzaCBsYXN0IGNvbW1lbnRcblxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICByZXR1cm4gaHRtbFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBDYW52YXNXcmFwcGVyICAgIGZyb20gJy4vQ2FudmFzV3JhcHBlci5tanMnO1xuaW1wb3J0IENvbnRyb2xsZXIgICAgICAgZnJvbSAnLi9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMnO1xuaW1wb3J0IFBhZ2VDb250YWluZXIgICAgZnJvbSAnLi9QYWdlQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgU2hhcmVkQ29udGFpbmVyICBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvYXBwL2NvbnRlbnQvQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgU3RhdGVQcm92aWRlciAgICBmcm9tICcuL01haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uYXBwLmNvbnRlbnQuQ29udGFpbmVyXG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBTaGFyZWRDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydwb3J0YWwtdGlja2V0cy1tYWluY29udGFpbmVyJ11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsncG9ydGFsLXRpY2tldHMtbWFpbmNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fSBjb250cm9sbGVyPU1haW5Db250YWluZXJDb250cm9sbGVyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbGxlcjogQ29udHJvbGxlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcGFnZUNvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgcGFnZUNvbnRhaW5lckNvbmZpZzoge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBQYWdlQ29udGFpbmVyLFxuICAgICAgICAgICAgYnV0dG9uVGV4dEZpZWxkOiAnaWQnLFxuICAgICAgICAgICAgY29udGVudENvbmZpZyAgOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBDYW52YXNXcmFwcGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IHN0YXRlUHJvdmlkZXI9TWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXJcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0ZVByb3ZpZGVyOiBTdGF0ZVByb3ZpZGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB0cmVlQ29uZmlnPXtkaXNwbGF5RmllbGQ6J3RyZWVOb2RlTmFtZSd9XG4gICAgICAgICAqL1xuICAgICAgICB0cmVlQ29uZmlnOiB7XG4gICAgICAgICAgICBkaXNwbGF5RmllbGQ6ICd0cmVlTm9kZU5hbWUnXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXIpO1xuIiwiaW1wb3J0IENvbnRyb2xsZXIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXJDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyQ29udHJvbGxlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJvdXRlc1xuICAgICAgICAgKi9cbiAgICAgICAgcm91dGVzOiB7XG4gICAgICAgICAgICAnL25ld3MvdGlja2V0cycgICAgICAgICAgOiAnb25Sb3V0ZURlZmF1bHQnLFxuICAgICAgICAgICAgJy9uZXdzL3RpY2tldHMveyppdGVtSWR9JzogJ29uUm91dGVJdGVtJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1cbiAgICAgKi9cbiAgICBuYXZpZ2F0ZVRvKGl0ZW0pIHtcbiAgICAgICAgTmVvLk1haW4uc2V0Um91dGUoe1xuICAgICAgICAgICAgdmFsdWUgICA6IGAvbmV3cy90aWNrZXRzLyR7aXRlbX1gLFxuICAgICAgICAgICAgd2luZG93SWQ6IHRoaXMuY29tcG9uZW50LndpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkludGVyc2VjdChkYXRhKSB7XG4gICAgICAgIGxldCBwYW5lbCAgICA9IHRoaXMuZ2V0UmVmZXJlbmNlKCdwYWdlLXNlY3Rpb25zLWNvbnRhaW5lcicpLFxuICAgICAgICAgICAgbGlzdCAgICAgPSBwYW5lbC5saXN0LFxuICAgICAgICAgICAgcmVjb3JkSWQgPSBkYXRhLmRhdGEucmVjb3JkSWQsXG4gICAgICAgICAgICByZWNvcmQ7XG5cbiAgICAgICAgaWYgKHJlY29yZElkICYmICFsaXN0LmlzQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBsaXN0LnN0b3JlLmdldChyZWNvcmRJZCk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnNlbGVjdGlvbk1vZGVsLnNlbGVjdChyZWNvcmQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTmV4dFBhZ2VCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGVUbyh0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXREYXRhKCduZXh0UGFnZVJlY29yZCcpLmlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25QYWdlU2VjdGlvbnNUb2dnbGVCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZ2V0UmVmZXJlbmNlKCdwYWdlLXNlY3Rpb25zLWNvbnRhaW5lcicpLnRvZ2dsZUNscygnbmVvLWV4cGFuZGVkJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUHJldmlvdXNQYWdlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRlVG8odGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSgncHJldmlvdXNQYWdlUmVjb3JkJykuaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0Um91dGVJZCgpIHtcbiAgICAgICAgbGV0IHN0b3JlICAgICA9IHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCd0cmVlJyksXG4gICAgICAgICAgICByb290Q291bnQgPSAwLFxuICAgICAgICAgICAgaSAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICA9IHN0b3JlLmdldENvdW50KCksXG4gICAgICAgICAgICByZWNvcmQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQoaSk7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmQucGFyZW50SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb290Q291bnQrKztcblxuICAgICAgICAgICAgICAgIGlmIChyb290Q291bnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmdldEF0KGkgKyAxKT8uaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0QXQoMSk/LmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJvdXRlRGVmYXVsdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdG9yZSA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgndHJlZScpO1xuXG4gICAgICAgIGlmIChzdG9yZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgbWUubmF2aWdhdGVUbyhtZS5nZXREZWZhdWx0Um91dGVJZCgpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcmUub24oe1xuICAgICAgICAgICAgICAgIGxvYWQgOiAoKSA9PiBtZS5uYXZpZ2F0ZVRvKG1lLmdldERlZmF1bHRSb3V0ZUlkKCkpLFxuICAgICAgICAgICAgICAgIGRlbGF5OiAxMCxcbiAgICAgICAgICAgICAgICBvbmNlIDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaXRlbUlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYXN5bmMgb25Sb3V0ZUl0ZW0oe2l0ZW1JZH0sIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdGF0ZVByb3ZpZGVyID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICA9IHN0YXRlUHJvdmlkZXIuZ2V0U3RvcmUoJ3RyZWUnKSxcbiAgICAgICAgICAgIHRyZWUgICAgICAgICAgPSBtZS5nZXRSZWZlcmVuY2UoJ3RyZWUnKTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhlIHRyZWUgaGFzIHRoZSBjb3JyZWN0IHJvdXRlIHByZWZpeCBmb3IgdGhpcyBjb250cm9sbGVyIGNvbnRleHRcbiAgICAgICAgaWYgKHRyZWUucm91dGVQcmVmaXggIT09ICcvbmV3cy90aWNrZXRzJykge1xuICAgICAgICAgICAgdHJlZS5yb3V0ZVByZWZpeCA9ICcvbmV3cy90aWNrZXRzJ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGVQcm92aWRlci5kYXRhLmN1cnJlbnRQYWdlUmVjb3JkID0gc3RvcmUuZ2V0KGl0ZW1JZCk7XG5cbiAgICAgICAgICAgIGlmICghb2xkVmFsdWU/Lmhhc2hTdHJpbmc/LnN0YXJ0c1dpdGgoJy9uZXdzL3RpY2tldHMnKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRyZWUuZXhwYW5kQW5kU2Nyb2xsVG9JdGVtKGl0ZW1JZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJlZS5leHBhbmRQYXJlbnRzKGl0ZW1JZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHNlbGVjdCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9yZS5vbih7XG4gICAgICAgICAgICAgICAgbG9hZCA6IHNlbGVjdCxcbiAgICAgICAgICAgICAgICBkZWxheTogMTAsXG4gICAgICAgICAgICAgICAgb25jZSA6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU2lkZU5hdlRvZ2dsZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5nZXRSZWZlcmVuY2UoJ3NpZGVuYXYtY29udGFpbmVyJykudG9nZ2xlQ2xzKCduZW8tZXhwYW5kZWQnKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIpO1xuIiwiaW1wb3J0IFRpY2tldExhYmVsc1N0b3JlICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3N0b3JlL1RpY2tldExhYmVscy5tanMnO1xuaW1wb3J0IFRpY2tldFRpbWVsaW5lU2VjdGlvbnNTdG9yZSAgZnJvbSAnLi4vLi4vLi4vc3RvcmUvVGlja2V0VGltZWxpbmVTZWN0aW9ucy5tanMnO1xuaW1wb3J0IFRpY2tldHNTdG9yZSAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3RvcmUvVGlja2V0cy5tanMnO1xuaW1wb3J0IFN0YXRlUHJvdmlkZXIgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL3N0YXRlL1Byb3ZpZGVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlclxuICogQGV4dGVuZHMgTmVvLnN0YXRlLlByb3ZpZGVyXG4gKi9cbmNsYXNzIE1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyIGV4dGVuZHMgU3RhdGVQcm92aWRlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGRhdGEuY291bnRQYWdlcz1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvdW50UGFnZXM6IG51bGwsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBkYXRhLmNvdW50UGFnZXM9bnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb3VudFNlY3Rpb25zOiBudWxsLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcmVjb3JkIHdoaWNoIGdldHMgc2hvd24gYXMgdGhlIGNvbnRlbnQgcGFnZVxuICAgICAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhLmN1cnJlbnRSZWNvcmQ9bnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdXJyZW50UGFnZVJlY29yZDogbnVsbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHJlY29yZCB3aGljaCBnZXRzIHNob3duIGFzIHRoZSBjb250ZW50IHBhZ2VcbiAgICAgICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YS5uZXh0UGFnZVJlY29yZD1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG5leHRQYWdlUmVjb3JkOiBudWxsLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcmVjb3JkIHdoaWNoIGdldHMgc2hvd24gYXMgdGhlIGNvbnRlbnQgcGFnZVxuICAgICAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhLnByZXZpb3VzUGFnZVJlY29yZD1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHByZXZpb3VzUGFnZVJlY29yZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdG9yZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0b3Jlczoge1xuICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbW9kdWxlICA6IFRpY2tldExhYmVsc1N0b3JlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6IFRpY2tldFRpbWVsaW5lU2VjdGlvbnNTdG9yZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyZWU6IHtcbiAgICAgICAgICAgICAgICBhdXRvTG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtb2R1bGUgIDogVGlja2V0c1N0b3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkRhdGFQcm9wZXJ0eUNoYW5nZShrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5vbkRhdGFQcm9wZXJ0eUNoYW5nZShrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnY291bnRTZWN0aW9ucyc6IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNvbXBvbmVudC5nZXRSZWZlcmVuY2UoJ3BhZ2Utc2VjdGlvbnMtY29udGFpbmVyJyk/LnRvZ2dsZUNscygnbmVvLWV4cGFuZGVkJywgZmFsc2UpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY3VycmVudFBhZ2VSZWNvcmQnOiB7XG4gICAgICAgICAgICAgICAgbGV0IHtkYXRhfSAgICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgICAgICB7Y291bnRQYWdlc30gICAgICAgPSBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSAgICAgICAgICAgICAgPSBtZS5nZXRTdG9yZSgndHJlZScpLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCAgICAgICAgICAgICAgPSBzdG9yZS5pbmRleE9mKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBhZ2VSZWNvcmQgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNQYWdlUmVjb3JkID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaSwgcmVjb3JkO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxvZ2ljIGFzc3VtZXMgdGhhdCB0aGUgdHJlZSBzdG9yZSBpcyBzb3J0ZWRcbiAgICAgICAgICAgICAgICBmb3IgKGk9aW5kZXgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgJiYgIW1lLnJlY29yZElzSGlkZGVuKHJlY29yZCwgc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2VSZWNvcmQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuc2V0RGF0YSh7cHJldmlvdXNQYWdlUmVjb3JkfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9naWMgYXNzdW1lcyB0aGF0IHRoZSB0cmVlIHN0b3JlIGlzIHNvcnRlZFxuICAgICAgICAgICAgICAgIGZvciAoaT1pbmRleCsxOyBpIDwgY291bnRQYWdlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldEF0KGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaXNMZWFmICYmICFtZS5yZWNvcmRJc0hpZGRlbihyZWNvcmQsIHN0b3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBhZ2VSZWNvcmQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuc2V0RGF0YSh7bmV4dFBhZ2VSZWNvcmR9KTtcblxuICAgICAgICAgICAgICAgIG1lLmNvbXBvbmVudC5nZXRSZWZlcmVuY2UoJ3NpZGVuYXYtY29udGFpbmVyJyk/LnRvZ2dsZUNscygnbmVvLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBjaGVjayB0aGUgcGFyZW50LW5vZGUgY2hhaW4gaW5zaWRlIHRoZSB0cmVlLlxuICAgICAqID0+IEFueSBoaWRkZW4gcGFyZW50LW5vZGUgcmVzdWx0cyBpbiBhIGhpZGRlbiByZWNvcmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IHN0b3JlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgcmVjb3JkSXNIaWRkZW4ocmVjb3JkLCBzdG9yZSkge1xuICAgICAgICBpZiAocmVjb3JkLmhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQucGFyZW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY29yZElzSGlkZGVuKHN0b3JlLmdldChyZWNvcmQucGFyZW50SWQpLCBzdG9yZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIpO1xuIiwiaW1wb3J0IFBhZ2VDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2FwcC9jb250ZW50L1BhZ2VDb250YWluZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlBhZ2VDb250YWluZXJcbiAqIEBleHRlbmRzIE5lby5hcHAuY29udGVudC5QYWdlQ29udGFpbmVyXG4gKi9cbmNsYXNzIFRpY2tldFBhZ2VDb250YWluZXIgZXh0ZW5kcyBQYWdlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5QYWdlQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuUGFnZUNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlPXtmbGV4OjEsb3ZlcmZsb3dZOidhdXRvJyxwb3NpdGlvbjoncmVsYXRpdmUnfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IHtmbGV4OiAxLCBvdmVyZmxvd1k6ICdhdXRvJywgcG9zaXRpb246ICdyZWxhdGl2ZSd9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRQYWdlQ29udGFpbmVyKTtcbiIsImltcG9ydCBTaGFyZWRDYW52YXMgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2FwcC9TaGFyZWRDYW52YXMubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBUaGUgXCJDb29yZGluYXRvclwiIGNvbXBvbmVudCBmb3IgdGhlIE5ldXJhbCBUaW1lbGluZSwgYnJpZGdpbmcgdGhlIEFwcCBXb3JrZXIgYW5kIENhbnZhcyBXb3JrZXIuXG4gKlxuICogVGhpcyBjb21wb25lbnQgcmVuZGVycyBhIHRyYW5zcGFyZW50IGNhbnZhcyBvdmVybGF5IG9uIHRvcCBvZiB0aGUgVGlja2V0IExpc3QuIEl0IGlzIHJlc3BvbnNpYmxlIGZvcjpcbiAqIDEuICoqRGF0YSBCcmlkZ2UqKjogTGlzdGVuaW5nIHRvIHRoZSBgc2VjdGlvbnNgIHN0b3JlIGFuZCBwYXNzaW5nIHRpY2tldCBkYXRhIHRvIHRoZSBgVGlja2V0Q2FudmFzYCAoU2hhcmVkV29ya2VyKS5cbiAqIDIuICoqVmlzdWFsIEFsaWdubWVudCoqOiBDYWxjdWxhdGluZyB0aGUgcHJlY2lzZSBET00gcG9zaXRpb25zIG9mIFRpY2tldCBBdmF0YXJzL0JhZGdlcyB0byBlbnN1cmUgdGhlXG4gKiAgICBjYW52YXMgbm9kZXMgYWxpZ24gcGVyZmVjdGx5IHdpdGggdGhlIEhUTUwgY29udGVudC5cbiAqIDMuICoqTGlmZWN5Y2xlIE1hbmFnZW1lbnQqKjogaW5pdGlhbGl6aW5nIHRoZSBvZmZzY3JlZW4gY2FudmFzIHRyYW5zZmVyIGFuZCBoYW5kbGluZyByZXNpemUgZXZlbnRzLlxuICpcbiAqIEl0IHVzZXMgdGhlIGBQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhc2Agc2luZ2xldG9uICh2aWEgUmVtb3RlIE1ldGhvZCBBY2Nlc3MpIHRvIGRyaXZlIHRoZSBhY3R1YWwgYW5pbWF0aW9uLlxuICpcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuVGltZWxpbmVDYW52YXNcbiAqIEBleHRlbmRzIE5lby5hcHAuU2hhcmVkQ2FudmFzXG4gKi9cbmNsYXNzIFRpbWVsaW5lQ2FudmFzIGV4dGVuZHMgU2hhcmVkQ2FudmFzIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRlbGF5YWJsZVxuICAgICAqL1xuICAgIHN0YXRpYyBkZWxheWFibGUgPSB7XG4gICAgICAgIGVuc3VyZUZpbmFsQWxpZ25tZW50OiB7XG4gICAgICAgICAgICB0eXBlIDogJ2RlYm91bmNlJyxcbiAgICAgICAgICAgIHRpbWVyOiAzMDBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlRpbWVsaW5lQ2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuVGltZWxpbmVDYW52YXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZW5kZXJlckNsYXNzTmFtZT0nUG9ydGFsLmNhbnZhcy5UaWNrZXRDYW52YXMnXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJlckNsYXNzTmFtZTogJ1BvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVuZGVyZXJJbXBvcnRQYXRoPSdhcHBzL3BvcnRhbC9jYW52YXMvVGlja2V0Q2FudmFzLm1qcydcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVySW1wb3J0UGF0aDogJ2FwcHMvcG9ydGFsL2NhbnZhcy9UaWNrZXRDYW52YXMubWpzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAnZGl2JywgY2xzOiBbJ25lby10aWNrZXQtdGltZWxpbmUtd3JhcHBlciddLCBzdHlsZToge3dpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnfSwgY246IFtcbiAgICAgICAgICAgIHt0YWc6ICdjYW52YXMnLCBzdHlsZToge3dpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnfX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gbGFzdFJlY29yZHM9bnVsbFxuICAgICAqL1xuICAgIGxhc3RSZWNvcmRzID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBlbnN1cmVGaW5hbEFsaWdubWVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUubGFzdFJlY29yZHMpIHtcbiAgICAgICAgICAgIG1lLm9uVGltZWxpbmVEYXRhTG9hZChtZS5sYXN0UmVjb3JkcywgdHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBob29rIHRoYXQgcnVucyBvbmNlIHRoZSBgT2Zmc2NyZWVuQ2FudmFzYCBoYXMgYmVlbiB0cmFuc2ZlcnJlZCB0byB0aGUgQ2FudmFzIFdvcmtlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kOlxuICAgICAqIDEuIEltcG9ydHMgdGhlIGBUaWNrZXRDYW52YXNgIGxvZ2ljIGludG8gdGhlIENhbnZhcyBXb3JrZXIgY29udGV4dC5cbiAgICAgKiAyLiBJbml0aWFsaXplcyB0aGUgZ3JhcGggaW4gdGhlIHdvcmtlciB2aWEgUmVtb3RlIE1ldGhvZCBBY2Nlc3MgKGBpbml0R3JhcGhgKS5cbiAgICAgKiAzLiBTZXRzIHVwIGEgYFJlc2l6ZU9ic2VydmVyYCB0byBrZWVwIHRoZSBjYW52YXMgc2l6ZSBzeW5jZWQgd2l0aCB0aGUgRE9NLlxuICAgICAqIDQuIFRyaWdnZXJzIHRoZSBpbml0aWFsIGRhdGEgbG9hZCBpZiBzdG9yZSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0T2Zmc2NyZWVuUmVnaXN0ZXJlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBhd2FpdCBzdXBlci5hZnRlclNldE9mZnNjcmVlblJlZ2lzdGVyZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWwgbG9hZCBjaGVja1xuICAgICAgICAgICAgbGV0IHN0b3JlID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdzZWN0aW9ucycpO1xuXG4gICAgICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5vblRpbWVsaW5lRGF0YUxvYWQoc3RvcmUuaXRlbXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0byByZXR1cm4gdGhlIGlubmVyIGNhbnZhcyBJRFxuICAgICAqL1xuICAgIGdldENhbnZhc0lkKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuY2FudmFzSWQpIHtcbiAgICAgICAgICAgIG1lLmNhbnZhc0lkID0gbWUudmRvbS5jblswXS5pZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZS5jYW52YXNJZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdG9yZSA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgnc2VjdGlvbnMnKTtcblxuICAgICAgICBzdG9yZS5vbignbG9hZCcsIG1lLm9uVGltZWxpbmVEYXRhTG9hZCwgbWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvblJlc2l6ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjYW52YXMgc2l6ZSBpbiB0aGUgd29ya2VyXG4gICAgICAgIGF3YWl0IG1lLnVwZGF0ZVNpemUoZGF0YS5jb250ZW50UmVjdCk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBjYWNoZWQgcmVjb3JkcywgcmUtY2FsY3VsYXRlIG5vZGUgcG9zaXRpb25zXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbnRhaW5lciBkaW1lbnNpb25zIChhbmQgbGlrZWx5IHJlbGF0aXZlIHBvc2l0aW9ucykgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICBpZiAobWUubGFzdFJlY29yZHMpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtZmV0Y2ggcmVjdHMgaW5zdGFudGx5LCBidXQgaXQncyBzYWZlciB0byBkbyBzb1xuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIGFsaWdubWVudCB3aXRoIHRoZSBuZXcgbGF5b3V0LlxuICAgICAgICAgICAgYXdhaXQgbWUub25UaW1lbGluZURhdGFMb2FkKG1lLmxhc3RSZWNvcmRzLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gRGVib3VuY2VkIGNoZWNrIHRvIGVuc3VyZSB0aGUgY2FudmFzIGlzIGFsaWduZWQgYWZ0ZXIgYW55IHRyYW5zaXRpb25zIHNldHRsZVxuICAgICAgICAgICAgbWUuZW5zdXJlRmluYWxBbGlnbm1lbnQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvcmUgXCJBbGlnbm1lbnQgRW5naW5lXCIgb2YgdGhlIHRpbWVsaW5lLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgc3luY2hyb25pemVzIHRoZSBDYW52YXMgbm9kZXMgd2l0aCB0aGUgRE9NIGVsZW1lbnRzIChBdmF0YXJzL0JhZGdlcykuXG4gICAgICpcbiAgICAgKiAqKlN0cmF0ZWd5OioqXG4gICAgICogMS4gKipUYXJnZXRpbmcqKjogSXQgdXNlcyB0aGUgYC10YXJnZXRgIElEIHN1ZmZpeCB0byBmaW5kIHRoZSBzcGVjaWZpYyBET00gZWxlbWVudHMgKEF2YXRhcnMpIHdpdGhpbiB0aGUgdGlja2V0IGxpc3QuXG4gICAgICogMi4gKipNZWFzdXJlbWVudCoqOiBJdCBmZXRjaGVzIHRoZSBgRE9NUmVjdGAgZm9yIGV2ZXJ5IHRhcmdldCB0byBnZXQgaXRzIGV4YWN0IHNjcmVlbiBwb3NpdGlvbi5cbiAgICAgKiAzLiAqKlRyYW5zbGF0aW9uKio6IEl0IGNvbnZlcnRzIHRoZXNlIHNjcmVlbiBjb29yZGluYXRlcyBpbnRvIENhbnZhcy1sb2NhbCBjb29yZGluYXRlcy5cbiAgICAgKiA0LiAqKkhhbmRvZmYqKjogSXQgcGFja2FnZXMgdGhpcyBnZW9tZXRyaWMgZGF0YSAoeCwgeSwgcmFkaXVzLCBjb2xvcikgYW5kIHNlbmRzIGl0IHRvIHRoZVxuICAgICAqICAgIGBUaWNrZXRDYW52YXNgIHdvcmtlciB0byB1cGRhdGUgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118T2JqZWN0fSByZWNvcmRzIEFycmF5IG9mIHJlY29yZHMgb3IgU3RvcmUgbG9hZCBldmVudCBvYmplY3Qge2l0ZW1zOiBbLi4uXX1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1Jlc2l6ZT1mYWxzZV1cbiAgICAgKi9cbiAgICBhc3luYyBvblRpbWVsaW5lRGF0YUxvYWQocmVjb3JkcywgaXNSZXNpemUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIEhhbmRsZSBTdG9yZSAnbG9hZCcgZXZlbnQgc2lnbmF0dXJlOiBmaXJlKCdsb2FkJywge2l0ZW1zOiBbLi4uXX0pXG4gICAgICAgIGlmIChyZWNvcmRzICYmICFBcnJheS5pc0FycmF5KHJlY29yZHMpICYmIHJlY29yZHMuaXRlbXMpIHtcbiAgICAgICAgICAgIHJlY29yZHMgPSByZWNvcmRzLml0ZW1zXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVjb3JkcykpIHtcbiAgICAgICAgICAgIC8vIFNhZmV0eSBjaGVjayBpZiByZWNvcmRzIGlzIHN0aWxsIGludmFsaWRcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5pc0NhbnZhc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXNldCA9ICFpc1Jlc2l6ZTtcblxuICAgICAgICAvLyBTbWFydCBDaGVjazogSWYgaXQncyBhIHN0b3JlIGxvYWQgKHJlc2V0PXRydWUpIEJVVCB0aGUgdGlja2V0IElEIGlzIHRoZSBzYW1lLFxuICAgICAgICAvLyBpdCdzIGEgZGF0YSByZWZyZXNoIChlLmcuIGNvbW1lbnQgYWRkZWQpLCBzbyB3ZSBzaG91bGQgTk9UIHJlc2V0IHRoZSBhbmltYXRpb24uXG4gICAgICAgIGlmIChyZXNldCAmJiBtZS5sYXN0UmVjb3JkcyAmJiByZWNvcmRzWzBdPy5pZCA9PT0gbWUubGFzdFJlY29yZHNbMF0/LmlkKSB7XG4gICAgICAgICAgICByZXNldCA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBtZS5sYXN0UmVjb3JkcyA9IHJlY29yZHM7XG5cbiAgICAgICAgbGV0IGlkcyA9IHJlY29yZHMubWFwKHIgPT4gYCR7ci5pZH0tdGFyZ2V0YCksXG4gICAgICAgICAgICByZWN0cztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggRE9NIHJlY3RzIGZvciB0aGUgTUFSS0VSUyAoQXZhdGFycy9CYWRnZXMpLCBub3QgdGhlIGNvbnRhaW5lcnNcbiAgICAgICAgICAgIHJlY3RzID0gYXdhaXQgbWUud2FpdEZvckRvbVJlY3Qoe1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzOiAyMCxcbiAgICAgICAgICAgICAgICBkZWxheSAgIDogNTAsXG4gICAgICAgICAgICAgICAgaWQgICAgICA6IGlkc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChtZS5sYXN0UmVjb3JkcyAhPT0gcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBnb3QgdmFsaWQgcmVjdHMgKGF0IGxlYXN0IG9uZSlcbiAgICAgICAgICAgIGxldCBoYXNSZWN0cyA9IHJlY3RzICYmIHJlY3RzLnNvbWUociA9PiByKTtcblxuICAgICAgICAgICAgaWYgKCFoYXNSZWN0cykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbiBmaXJzdCB2YWxpZCBkYXRhIGxvYWQgKG5vdCByZXNpemUpLCBlbnN1cmUgc2l6ZSBpcyBzeW5jZWRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgY29udGVudCBtaWdodCBoYXZlIHB1c2hlZCB0aGUgY29udGFpbmVyIGhlaWdodC5cbiAgICAgICAgICAgIGlmICghaXNSZXNpemUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS51cGRhdGVTaXplKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNhbnZhc1JlY3QgPSBhd2FpdCBtZS5nZXREb21SZWN0KG1lLmdldENhbnZhc0lkKCkpLFxuICAgICAgICAgICAgICAgIG5vZGVzICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBzdGFydFkgICAgID0gMDtcblxuICAgICAgICAgICAgaWRzLmZvckVhY2goKHRhcmdldElkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWN0ICAgPSByZWN0c1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZHNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUFJFQ0lTRSBDRU5URVJJTkdcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93ICdyZWN0JyBpcyB0aGUgYWN0dWFsIGF2YXRhci9iYWRnZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlY3QuaGVpZ2h0IC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVZICA9IHJlY3QueSAtIGNhbnZhc1JlY3QueSArIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVYICA9IHJlY3QueCAtIGNhbnZhc1JlY3QueCArIChyZWN0LndpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXN0aW5jdCBwYWRkaW5nIGZvciBPcmJpdCBlZmZlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2YXRhcnMgKH40MHB4KSBnZXQgbW9yZSBicmVhdGhpbmcgcm9vbSB0aGFuIEJhZGdlcyAofjI4cHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gcmVjdC5oZWlnaHQgPiAzMiA/IDYgOiAzO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgOiByZWNvcmQuY29sb3IsIC8vIFBhc3MgSGV4IENvbG9yIChlLmcuICNmZjAwMDApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgICA6IHJlY29yZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogb2Zmc2V0ICsgcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgICAgIDogbm9kZVksXG4gICAgICAgICAgICAgICAgICAgICAgICB4ICAgICA6IG5vZGVYXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgc3RhcnRZIG9mIHRoZSBsaW5lIHRvIHRoZSBmaXJzdCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRZID0gbm9kZVlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS5yZW5kZXJlci51cGRhdGVHcmFwaERhdGEoe25vZGVzLCByZXNldCwgc3RhcnRZfSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGltZWxpbmVDYW52YXMgdXBkYXRlIGZhaWxlZCcsIGUpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpbWVsaW5lQ2FudmFzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==