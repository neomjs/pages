"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_portal_view_news_tickets_MainContainer_mjs"],{

/***/ "./apps/portal/model/Ticket.mjs"
/*!**************************************!*\
  !*** ./apps/portal/model/Ticket.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.Ticket
 * @extends Neo.data.Model
 */
class Ticket extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.Ticket'
         * @protected
         */
        className: 'Portal.model.Ticket',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name        : 'collapsed',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name: 'id',
            type: 'String'
        }, {
            name        : 'isLeaf',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name        : 'parentId',
            type        : 'String',
            defaultValue: null
        }, {
            name: 'path', // "resources/content/issues/issue-1234.md"
            type: 'String'
        }, {
            name: 'title', // "Fix elusive bug in Grid"
            type: 'String'
        }, {
            // Computed field for TreeList display
            name: 'treeNodeName',
            type: 'html',
            /**
             * @param {Object}  data
             * @param {String}  data.id
             * @param {Boolean} data.isLeaf
             * @param {String}  data.title
             * @returns {String}
             */
            calculate({id, isLeaf, title}) {
                return isLeaf ? `<b>${id}</b> ${title}` : id
            }
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Ticket));


/***/ },

/***/ "./apps/portal/model/TicketLabel.mjs"
/*!*******************************************!*\
  !*** ./apps/portal/model/TicketLabel.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.TicketLabel
 * @extends Neo.data.Model
 */
class TicketLabel extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketLabel'
         * @protected
         */
        className: 'Portal.model.TicketLabel',
        /**
         * @member {Object[]} fields
         * @protected
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'description',
            type: 'String'
        }, {
            name: 'name',
            type: 'String'
        }, {
            name: 'textColor',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabel));


/***/ },

/***/ "./apps/portal/model/TicketTimelineSection.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/model/TicketTimelineSection.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSection.mjs */ "./apps/portal/model/ContentSection.mjs");


/**
 * @class Portal.model.TicketTimelineSection
 * @extends Portal.model.ContentSection
 */
class TicketTimelineSection extends _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketTimelineSection'
         * @protected
         */
        className: 'Portal.model.TicketTimelineSection',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'icon',
            type: 'String'
        }, {
            name: 'image',
            type: 'String'
        }, {
            name: 'sourceId',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSection));


/***/ },

/***/ "./apps/portal/store/TicketLabels.mjs"
/*!********************************************!*\
  !*** ./apps/portal/store/TicketLabels.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/TicketLabel.mjs */ "./apps/portal/model/TicketLabel.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Portal.store.TicketLabels
 * @extends Neo.data.Store
 */
class TicketLabels extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketLabels'
         * @protected
         */
        className: 'Portal.store.TicketLabels',
        /**
         * @member {String} keyProperty='name'
         * @protected
         */
        keyProperty: 'name',
        /**
         * @member {Neo.data.Model} model=TicketLabel
         * @protected
         */
        model: _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/labels.json'
         * @protected
         */
        url: '../../apps/portal/resources/data/labels.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabels));


/***/ },

/***/ "./apps/portal/store/TicketTimelineSections.mjs"
/*!******************************************************!*\
  !*** ./apps/portal/store/TicketTimelineSections.mjs ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSections.mjs */ "./apps/portal/store/ContentSections.mjs");
/* harmony import */ var _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/TicketTimelineSection.mjs */ "./apps/portal/model/TicketTimelineSection.mjs");



/**
 * @class Portal.store.TicketTimelineSections
 * @extends Portal.store.ContentSections
 */
class TicketTimelineSections extends _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketTimelineSections'
         * @protected
         */
        className: 'Portal.store.TicketTimelineSections',
        /**
         * @member {Neo.data.Model} model=TicketTimelineSection
         * @reactive
         */
        model: _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSections));


/***/ },

/***/ "./apps/portal/store/Tickets.mjs"
/*!***************************************!*\
  !*** ./apps/portal/store/Tickets.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Ticket.mjs */ "./apps/portal/model/Ticket.mjs");



/**
 * @class Portal.store.Tickets
 * @extends Neo.data.Store
 */
class Tickets extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.Tickets'
         * @protected
         */
        className: 'Portal.store.Tickets',
        /**
         * @member {Neo.data.Model} model=TicketModel
         * @reactive
         */
        model: _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/tickets.json'
         */
        url: '../../apps/portal/resources/data/tickets.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tickets));


/***/ },

/***/ "./apps/portal/view/news/tickets/CanvasWrapper.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/CanvasWrapper.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./apps/portal/view/news/tickets/Component.mjs");
/* harmony import */ var _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TimelineCanvas.mjs */ "./apps/portal/view/news/tickets/TimelineCanvas.mjs");




/**
 * @class Portal.view.news.tickets.CanvasWrapper
 * @extends Neo.container.Base
 */
class CanvasWrapper extends _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.CanvasWrapper'
         * @protected
         */
        className: 'Portal.view.news.tickets.CanvasWrapper',
        /**
         * @member {String[]} cls=['portal-canvas-wrapper']
         */
        cls: ['portal-canvas-wrapper'],
        /**
         * @member {Neo.component.Base|null} contentComponent=ContentComponent
         */
        contentComponent: _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={minHeight:'100%',overflow:'visible',position:'relative'}
         */
        style: {minHeight: '100%', overflow: 'visible', position: 'relative'}
    }

    construct(config) {
        let me = this;

        config.items = [{
            module   : _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            reference: 'timeline-canvas',
            style : {
                position     : 'absolute',
                top          : 0,
                left         : 0,
                width        : '100%',
                height       : '100%',
                zIndex       : 2,
                pointerEvents: 'none'
            }
        }, {
            module: config.contentComponent || me.contentComponent,
            style : {
                position: 'relative',
                zIndex  : 1
            },
            listeners: {
                toggleSummary: me.onToggleSummary,
                scope        : me
            }
        }];

        super.construct(config);
    }

    /**
     *
     */
    onToggleSummary() {
        let canvas = this.getReference('timeline-canvas');

        if (canvas?.lastRecords) {
            canvas.onTimelineDataLoad(canvas.lastRecords, true)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CanvasWrapper));


/***/ },

/***/ "./apps/portal/view/news/tickets/Component.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/view/news/tickets/Component.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/content/Component.mjs */ "./apps/portal/view/shared/content/Component.mjs");
/* harmony import */ var _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../node_modules/marked/lib/marked.esm.js */ "./node_modules/marked/lib/marked.esm.js");



const
    regexFrontMatter   = /^---\n([\s\S]*?)\n---\n/,
    regexH1            = /(<h1[^>]*>.*?<\/h1>)/,
    regexTicketLink    = /(\d{4,})/,
    regexTimeline      = /## Timeline\s*\n([\s\S]*)/,
    regexTimelineEvent = /^- ([\dTZ:.-]+) @(\w+) (.*)$/,
    regexCommit        = /\b([0-9a-f]{7,40})\b/g;

/**
 * @summary The "Markdown Transformer" for GitHub Tickets.
 *
 * This component extends the standard ContentComponent to provide specialized rendering for GitHub Issues.
 * Its primary responsibility is to parse the raw Markdown content (which includes custom Frontmatter and
 * a pre-generated Timeline section) and transform it into a rich, interactive HTML structure.
 *
 * **Key Responsibilities:**
 * 1. **Parsing Pipeline**: Extracts Frontmatter, Body, and the custom "Timeline" section from the raw Markdown.
 * 2. **Rich Rendering**: Generates HTML for Status Badges, Labels, Commit Links, and User Mentions.
 * 3. **Data Extraction**: As a side effect of rendering, it extracts structured data (`me.timelineData`)
 *    representing every timeline event (comment, label change, close, etc.). This data is then
 *    pushed to the `sections` store to drive the `TimelineCanvas` visualization.
 *
 * @class Portal.view.news.tickets.Component
 * @extends Portal.view.shared.content.Component
 */
class Component extends _shared_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.Component'
         * @protected
         */
        className: 'Portal.view.news.tickets.Component',
        /**
         * @member {String[]} cls=['portal-news-tickets-component']
         */
        cls: ['portal-news-tickets-component'],
        /**
         * @member {String} commitsUrl='https://github.com/neomjs/neo/commit/'
         */
        commitsUrl: 'https://github.com/neomjs/neo/commit/',
        /**
         * @member {Object} domListeners
         */
        domListeners: {
            resize: 'onResize'
        },
        /**
         * @member {String} repoUserUrl='https://github.com/'
         */
        repoUserUrl: 'https://github.com/',
        /**
         * @member {Boolean} updateSectionsStore=false
         */
        updateSectionsStore: false
    }

    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatHistory=null
     */
    #dateTimeFormatHistory = null
    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatToday=null
     */
    #dateTimeFormatToday = null
    /**
     * Temporary storage for the structured timeline data extracted during the parsing phase.
     * This array is populated by `renderTimeline` and `modifyMarkdown` and then assigned
     * to the `sections` store to drive the Canvas visualization.
     * @member {Object[]} timelineData=null
     * @private
     */
    timelineData = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.getStateProvider().setData('contentComponentId', this.id)
    }

    /**
     * @param {String} isoString
     * @returns {String}
     */
    formatTimestamp(isoString) {
        if (!isoString) return '';

        let me      = this,
            date    = new Date(isoString),
            now     = new Date(),
            isToday = date.toDateString() === now.toDateString();

        if (isToday) {
            if (!me.#dateTimeFormatToday) {
                me.#dateTimeFormatToday = new Intl.DateTimeFormat('default', {
                    hour  : 'numeric',
                    minute: 'numeric'
                })
            }

            return me.#dateTimeFormatToday.format(date)
        }

        if (!me.#dateTimeFormatHistory) {
            me.#dateTimeFormatHistory = new Intl.DateTimeFormat('default', {
                day   : 'numeric',
                hour  : 'numeric',
                minute: 'numeric',
                month : 'short',
                year  : 'numeric'
            })
        }

        return me.#dateTimeFormatHistory.format(date)
    }

    /**
     * @param {Object} data
     * @returns {String}
     */
    frontMatterToHtml(data) {
        let me   = this,
            html = '<table class="neo-frontmatter-table"><tbody>';

        Object.entries(data).forEach(([key, value]) => {
            let renderedValue;

            if (key === 'subIssues' && Array.isArray(value)) {
                renderedValue = value.map(issue => {
                    return `<div class="neo-sub-issue">${issue
                        .replace(regexTicketLink, '<a href="#/news/tickets/$1">$1</a>')
                        .replace('[x]', '<i class="fa-solid fa-circle-check"></i>')
                        .replace('[ ]', '<i class="fa-regular fa-circle"></i>')}</div>`
                }).join('')
            } else if (key === 'author') {
                renderedValue = `<a href="${me.repoUserUrl}${value}" target="_blank">${value}</a>`
            } else if (key === 'createdAt' || key === 'closedAt' || key === 'updatedAt') {
                renderedValue = me.formatTimestamp(value)
            } else if (key === 'labels' && Array.isArray(value)) {
                renderedValue = me.getBadgesHtml(value)
            } else if (key === 'state') {
                renderedValue = me.getStateBadgeHtml(value)
            } else {
                renderedValue = me.formatFrontMatterValue(value)
            }

            html += `<tr><td>${key}</td><td>${renderedValue}</td></tr>`
        });

        html += '</tbody></table>';

        if (me.useFrontmatterDetails) {
            return `<details id="neo-ticket-summary-details-${me.id}"><summary>Frontmatter</summary>${html}</details>`
        }

        return html
    }

    /**
     * @param {String[]} labels
     * @returns {String}
     */
    getBadgesHtml(labels) {
        if (!labels || labels.length === 0) return '';

        let me         = this,
            badgesHtml = '<div class="neo-ticket-labels">';

        labels.forEach(label => {
            badgesHtml += me.getLabelBadgeHtml(label)
        });

        badgesHtml += '</div>';

        return badgesHtml
    }

    /**
     * @param {Object} record
     * @returns {Promise<void>}
     */
    async doFetchContent(record) {
        let me         = this,
            {windowId} = me,
            content, data, path;

        path = me.getContentPath(record);

        if (record.isLeaf && path) {
            data    = await fetch(path);
            content = await data.text();

            me.value = content;

            me.toggleCls('lab', record.name?.startsWith('Lab:'));

            Neo.main.addon.IntersectionObserver.observe({
                disconnect: true,
                id        : me.id,
                observe   : ['.neo-timeline-item[data-record-id]'],
                windowId
            })
        }
    }

    /**
     * @param {Object} record
     * @param {String} record.path
     * @returns {String|null}
     */
    getContentPath({path}) {
        return path ? Neo.config.basePath + path : null
    }

    /**
     * @param {String} label
     * @returns {String}
     */
    getLabelBadgeHtml(label) {
        let store  = this.getStateProvider().getStore('labels'),
            record = store.get(label);

        if (record) {
            return `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
        }

        return `<span class="neo-badge">${label}</span>`
    }

    /**
     * @param {String} state
     * @returns {String}
     */
    getStateBadgeHtml(state) {
        if (!state) return '';

        let cls  = 'neo-badge neo-state-badge',
            icon = 'fa-circle-dot';

        if (state.toUpperCase() === 'CLOSED') {
            cls  += ' neo-state-closed';
            icon  = 'fa-circle-check'
        } else {
            cls += ' neo-state-open'
        }

        return `<span class="${cls}"><i class="fa-regular ${icon}"></i>${Neo.capitalize(state.toLowerCase())}</span>`
    }

    /**
     * The Main Parsing Pipeline.
     *
     * This method intercepts the raw markdown content before it is rendered and performs a multi-pass transformation:
     * 1. **Extract Timeline**: Pulls out the raw `## Timeline` section to process it separately.
     * 2. **Process Frontmatter**: Extracts metadata (labels, state, author) and removes the YAML block.
     * 3. **Render Body**: Uses the superclass (marked.js) to convert the main issue body to HTML.
     * 4. **Inject Title IDs**: Adds IDs to H1 tags for navigation.
     * 5. **Generate Badges**: Creates HTML for Status/Label badges based on extracted metadata.
     * 6. **Wrap Body**: Wraps the main issue body in a `timeline-item` structure so it appears as the first item.
     * 7. **Re-Assemble**: Concatenates Frontmatter + Title + Timeline (with Body injected) into the final HTML.
     *
     * **Side Effect**: Populates `me.timelineData` and updates the `sections` store.
     *
     * @param {String} content
     * @returns {String}
     */
    modifyMarkdown(content) {
        let me           = this,
            {parentId}   = me.record,
            author       = null,
            createdAt    = null,
            labels       = [],
            state        = null,
            match        = content.match(regexFrontMatter),
            timelineHtml = '',
            badgesHtml   = '';

        me.timelineData = [];

        if (match) {
            let data = me.parseFrontMatter(match[1]);

            if (data.author)    {author    = data.author}
            if (data.createdAt) {createdAt = me.formatTimestamp(data.createdAt)}
            if (data.labels)    {labels    = data.labels}
            if (data.state)     {state     = data.state}
        }

        // 1. Extract and process timeline from RAW markdown
        let timelineMatch = content.match(regexTimeline);
        if (timelineMatch) {
            timelineHtml = me.renderTimeline(timelineMatch[1]);
            content      = content.replace(regexTimeline, ''); // Remove raw timeline
        }

        // 2. Render Frontmatter Manually & Strip it
        // We want it at the very top, outside the body bubble.
        let frontMatterHtml = '';
        if (match) {
            let data        = me.parseFrontMatter(match[1]);
            frontMatterHtml = me.frontMatterToHtml(data);
            content         = content.replace(regexFrontMatter, '');
        }

        // 3. Convert Body + Title to HTML using super
        let fullHtml = super.modifyMarkdown(content);

        // 4. Extract H1 Title from the generated HTML
        let titleHtml = '';
        fullHtml      = fullHtml.replace(regexH1, (match) => {
            // Inject ID into H1 tag
            titleHtml = match.replace('<h1', `<h1 id="ticket-title-${me.id}"`);
            return ''; // Remove title from body
        });

        // 5. Construct Badges
        if (labels.length > 0 || state || (parentId && parentId !== 'Backlog')) {
            badgesHtml = '<div class="neo-ticket-labels">';

            if (state) {
                badgesHtml += me.getStateBadgeHtml(state)
            }

            if (parentId && parentId !== 'Backlog') {
                badgesHtml += `
                    <a class="neo-badge neo-release-badge" href="#/news/releases/${parentId.substring(1)}">
                        <i class="fa-solid fa-code-branch"></i> ${parentId}
                    </a>`
            }

            if (labels.length > 0) {
                let store = me.getStateProvider().getStore('labels'),
                    record;

                labels.forEach(label => {
                    record = store.get(label);

                    if (record) {
                        badgesHtml += `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
                    } else {
                        badgesHtml += `<span class="neo-badge">${label}</span>`
                    }
                });
            }

            badgesHtml += '</div>';
            titleHtml  += badgesHtml;
        }

        // 6. Wrap the remaining HTML (Body) in the Timeline Item structure
        let bodyId = `timeline-${me.record.id}-0`;

        me.timelineData.unshift({
            id   : bodyId,
            image: me.repoUserUrl + author + '.png',
            name : 'Description',
            tag  : 'body'
        });

        let bodyItemHtml = `
            <div id="${bodyId}" class="neo-timeline-item comment body-item" data-record-id="${bodyId}">
                <div id="${bodyId}-target" class="neo-timeline-avatar">
                    <img src="${me.repoUserUrl}${author}.png" alt="${author}">
                </div>
                <div class="neo-timeline-content">
                    <div class="neo-timeline-header">
                        <a class="neo-timeline-user" href="${me.repoUserUrl}${author}" target="_blank">${author}</a>
                        <span class="neo-timeline-date">commented on ${createdAt}</span>
                    </div>
                    <div class="neo-timeline-body">${fullHtml}</div>
                </div>
            </div>`;

        // 7. Inject Body Item at the start of the Timeline
        let timelineId = `ticket-timeline-${me.id}`;

        if (timelineHtml) {
            timelineHtml = timelineHtml.replace(
                '<div class="neo-ticket-timeline">',
                `<div id="${timelineId}" class="neo-ticket-timeline">` + bodyItemHtml
            )
        } else {
            timelineHtml = `<div id="${timelineId}" class="neo-ticket-timeline">${bodyItemHtml}</div>`
        }

        me.getStateProvider().getStore('sections').data = me.timelineData;
        me.timelineData = null;

        // Return: Frontmatter + Title + Timeline
        return frontMatterHtml + titleHtml + timelineHtml
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        this.fire('toggleSummary')
    }

    /**
     * Parses the custom "Timeline" markdown section.
     *
     * Expects a line-based format generated by the build process:
     * - Events: `- YYYY-MM-DDTHH:mm:ss @user action text...`
     * - Comments: `### @user - YYYY-MM-DDTHH:mm:ss` followed by comment body.
     *
     * This method converts these lines into structured `timeline-item` HTML blocks
     * and simultaneously populates `me.timelineData` with semantic data (color, icon, type)
     * for each event.
     *
     * @param {String} content
     * @returns {String}
     */
    renderTimeline(content) {
        let me          = this,
            {commitsUrl, repoUserUrl} = me,
            html        = '<div class="neo-ticket-timeline">',
            lines       = content.split('\n'),
            commentBuf  = [],
            currentUser = null,
            currentDate = null,
            i           = 0,
            len         = lines.length,
            id, line, match, icon, actionCls;

        const flushComment = () => {
            if (commentBuf.length > 0) {
                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                me.timelineData.push({
                    id   : id,
                    image: repoUserUrl + currentUser + '.png',
                    name : `Comment (${currentUser})`,
                    tag  : 'comment'
                });

                let body = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parse(commentBuf.join('\n'));
                html += `
                    <div id="${id}" class="neo-timeline-item comment" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-avatar">
                            <img src="${repoUserUrl}${currentUser}.png" alt="${currentUser}">
                        </div>
                        <div class="neo-timeline-content">
                            <div class="neo-timeline-header">
                                <a class="neo-timeline-user" href="${repoUserUrl}${currentUser}" target="_blank">${currentUser}</a>
                                <span class="neo-timeline-date">${me.formatTimestamp(currentDate)}</span>
                            </div>
                            <div class="neo-timeline-body">${body}</div>
                        </div>
                    </div>`;
                commentBuf  = [];
                currentUser = null;
                currentDate = null
            }
        };

        for (; i < len; i++) {
            line = lines[i];

            // Event Line: - 2026-01-11T... @user action...
            if ((match = line.match(regexTimelineEvent))) {
                flushComment();
                let [_, date, user, action] = match;

                icon      = 'fa-circle-dot'; // Default
                actionCls = '';

                const eventType = [
                    {key: 'added the `',      icon: 'fa-tag'},
                    {key: 'removed the `',    icon: 'fa-tag'},
                    {key: 'assigned',         icon: 'fa-user-pen'},
                    {key: 'closed',           icon: 'fa-circle-check', color: '#8250df'}, // GitHub Purple
                    {key: 'reopened',         icon: 'fa-circle-dot',   color: '#2da44e'}, // GitHub Green
                    {key: 'referenced',       icon: 'fa-link'},
                    {key: 'cross-referenced', icon: 'fa-link'},
                    {key: 'milestoned',       icon: 'fa-sign-post'},
                    {key: 'sub-issue',        icon: 'fa-diagram-project'}
                ].find(e => action.includes(e.key));

                let color = null;

                if (eventType) {
                    icon = eventType.icon;
                    if (eventType.color) color = eventType.color
                }

                // Clean up markdown in action text (e.g. `code` to <code>)
                let cleanAction = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parseInline(action);

                if (icon === 'fa-tag') {
                    cleanAction = cleanAction.replace(/<code>(.*?)<\/code>/g, (match, label) => me.getLabelBadgeHtml(label));

                    // Try to resolve color from label
                    let labelMatch = action.match(/`([^`]+)`/);
                    if (labelMatch) {
                        let labelName = labelMatch[1];
                        let labelRec  = me.getStateProvider().getStore('labels').get(labelName);
                        if (labelRec) {
                            color = labelRec.color;
                        }
                    }
                }

                // Linkify Commit Hashes
                cleanAction = cleanAction.replace(regexCommit, `<a href="${commitsUrl}$1" target="_blank">$1</a>`);

                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                // Extract a short action name for the list
                let shortAction = action.split(' ')[0]; // 'added', 'closed', etc.
                let entryName;

                if (shortAction === 'added' || shortAction === 'removed') {
                    if (action.includes('sub-issue')) {
                        let subIssueMatch = action.match(/#(\d+)/);
                        if (subIssueMatch) {
                            entryName = `${Neo.capitalize(shortAction)} sub-issue #${subIssueMatch[1]}`
                        } else {
                            entryName = `${Neo.capitalize(shortAction)} sub-issue`
                        }
                    } else {
                        let labelMatch = action.match(/`([^`]+)`/);
                        shortAction = labelMatch ? labelMatch[1] : 'Label';
                        entryName = `${Neo.capitalize(shortAction)} (${user})`
                    }
                } else {
                    entryName = `${Neo.capitalize(shortAction)} (${user})`
                }

                me.timelineData.push({
                    color: color, // Pass resolved hex color
                    icon : icon,
                    id   : id,
                    name : entryName,
                    tag  : 'event'
                });

                // Apply color style if present, otherwise default
                let style = color ? `style="color: ${color}"` : '';

                html += `
                    <div id="${id}" class="neo-timeline-item event" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-badge" ${style}><i class="fa-solid ${icon}"></i></div>
                        <div class="neo-timeline-body">
                            <a class="neo-timeline-user" href="${repoUserUrl}${user}" target="_blank">${user}</a> ${cleanAction} <span class="neo-timeline-date">on ${me.formatTimestamp(date)}</span>
                        </div>
                    </div>`;
            }
            // Comment Header: ### @user - 2026-01-11T...
            else if (line.startsWith('### @')) {
                // Captures "user" and "2026-01-11T..." (ISO timestamp)
                let headerMatch = line.match(/^### @(\w+) - ([\dTZ:.-]+)$/);
                if (headerMatch) {
                    flushComment();
                    currentUser = headerMatch[1];
                    currentDate = headerMatch[2]
                } else {
                    // Fallback for weird headers? treat as text
                    if (currentUser) commentBuf.push(line)
                }
            }
            else {
                if (currentUser) {
                    commentBuf.push(line)
                }
            }
        }

        flushComment(); // Flush last comment

        html += '</div>';
        return html
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasWrapper.mjs */ "./apps/portal/view/news/tickets/CanvasWrapper.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/portal/view/news/tickets/MainContainerController.mjs");
/* harmony import */ var _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PageContainer.mjs */ "./apps/portal/view/news/tickets/PageContainer.mjs");
/* harmony import */ var _shared_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/content/Container.mjs */ "./apps/portal/view/shared/content/Container.mjs");
/* harmony import */ var _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MainContainerStateProvider.mjs */ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs");






/**
 * @class Portal.view.news.tickets.MainContainer
 * @extends Portal.view.shared.content.Container
 */
class MainContainer extends _shared_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainer',
        /**
         * @member {String[]} cls=['portal-tickets-maincontainer']
         * @reactive
         */
        cls: ['portal-tickets-maincontainer'],
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         * @reactive
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} pageContainerConfig
         */
        pageContainerConfig: {
            module         : _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            buttonTextField: 'id',
            contentConfig  : {
                module: _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            }
        },
        /**
         * @member {Neo.state.Provider} stateProvider=MainContainerStateProvider
         * @reactive
         */
        stateProvider: _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
        /**
         * @member {Object} treeConfig={displayField:'treeNodeName'}
         */
        treeConfig: {
            displayField: 'treeNodeName'
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerController.mjs"
/*!*******************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerController.mjs ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Portal.view.news.tickets.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerController'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerController',
        /**
         * @member {Object} routes
         */
        routes: {
            '/news/tickets'          : 'onRouteDefault',
            '/news/tickets/{*itemId}': 'onRouteItem'
        }
    }

    /**
     * @param {String} item
     */
    navigateTo(item) {
        Neo.Main.setRoute({
            value   : `/news/tickets/${item}`,
            windowId: this.component.windowId
        })
    }

    /**
     * @param {Object} data
     */
    onIntersect(data) {
        let panel    = this.getReference('page-sections-container'),
            list     = panel.list,
            recordId = data.data.recordId,
            record;

        if (recordId && !list.isAnimating) {
            record = list.store.get(recordId);

            if (record) {
                list.selectionModel.select(record)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onNextPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('nextPageRecord').id)
    }

    /**
     * @param {Object} data
     */
    onPageSectionsToggleButtonClick(data) {
        this.getReference('page-sections-container').toggleCls('neo-expanded')
    }

    /**
     * @param {Object} data
     */
    onPreviousPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('previousPageRecord').id)
    }

    /**
     * @returns {String}
     */
    getDefaultRouteId() {
        let store     = this.getStateProvider().getStore('tree'),
            rootCount = 0,
            i         = 0,
            len       = store.getCount(),
            record;

        for (; i < len; i++) {
            record = store.getAt(i);

            if (record.parentId === null) {
                rootCount++;

                if (rootCount === 2) {
                    return store.getAt(i + 1)?.id
                }
            }
        }

        return store.getAt(1)?.id
    }

    /**
     * @param {Object} data
     */
    onRouteDefault(data) {
        let me    = this,
            store = me.getStateProvider().getStore('tree');

        if (store.getCount() > 0) {
            me.navigateTo(me.getDefaultRouteId())
        } else {
            store.on({
                load : () => me.navigateTo(me.getDefaultRouteId()),
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.itemId
     * @param {Object} value
     * @param {Object} oldValue
     */
    async onRouteItem({itemId}, value, oldValue) {
        let me            = this,
            stateProvider = me.getStateProvider(),
            store         = stateProvider.getStore('tree'),
            tree          = me.getReference('tree');

        // Ensure the tree has the correct route prefix for this controller context
        if (tree.routePrefix !== '/news/tickets') {
            tree.routePrefix = '/news/tickets'
        }

        const select = async () => {
            stateProvider.data.currentPageRecord = store.get(itemId);

            if (!oldValue?.hashString?.startsWith('/news/tickets')) {
                await tree.expandAndScrollToItem(itemId)
            } else {
                tree.expandParents(itemId)
            }
        };

        if (store.getCount() > 0) {
            await select()
        } else {
            store.on({
                load : select,
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     */
    onSideNavToggleButtonClick(data) {
        this.getReference('sidenav-container').toggleCls('neo-expanded')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs"
/*!**********************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerStateProvider.mjs ***!
  \**********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../store/TicketLabels.mjs */ "./apps/portal/store/TicketLabels.mjs");
/* harmony import */ var _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../store/TicketTimelineSections.mjs */ "./apps/portal/store/TicketTimelineSections.mjs");
/* harmony import */ var _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../store/Tickets.mjs */ "./apps/portal/store/Tickets.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");





/**
 * @class Portal.view.news.tickets.MainContainerStateProvider
 * @extends Neo.state.Provider
 */
class MainContainerStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerStateProvider'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {Number|null} data.countPages=null
             */
            countPages: null,
            /**
             * @member {Number|null} data.countPages=null
             */
            countSections: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.currentRecord=null
             */
            currentPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.nextPageRecord=null
             */
            nextPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.previousPageRecord=null
             */
            previousPageRecord: null
        },
        /**
         * @member {Object} stores
         */
        stores: {
            labels: {
                autoLoad: true,
                module  : _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            },
            sections: {
                module: _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
            },
            tree: {
                autoLoad: true,
                module  : _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]
            }
        }
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        super.onDataPropertyChange(key, value, oldValue);

        let me = this;

        switch (key) {
            case 'countSections': {
                if (value < 1) {
                    me.component.getReference('page-sections-container')?.toggleCls('neo-expanded', false)
                }

                break
            }

            case 'currentPageRecord': {
                let {data}             = me,
                    {countPages}       = data,
                    store              = me.getStore('tree'),
                    index              = store.indexOf(value),
                    nextPageRecord     = null,
                    previousPageRecord = null,
                    i, record;

                // the logic assumes that the tree store is sorted
                for (i=index-1; i >= 0; i--) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        previousPageRecord = record;
                        break
                    }
                }

                me.setData({previousPageRecord});

                // the logic assumes that the tree store is sorted
                for (i=index+1; i < countPages; i++) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        nextPageRecord = record;
                        break
                    }
                }

                me.setData({nextPageRecord});

                me.component.getReference('sidenav-container')?.toggleCls('neo-expanded', false)

                break
            }
        }
    }

    /**
     * We need to check the parent-node chain inside the tree.
     * => Any hidden parent-node results in a hidden record.
     * @param {Object} record
     * @param {Neo.data.Store} store
     * @returns {Boolean}
     */
    recordIsHidden(record, store) {
        if (record.hidden) {
            return true
        }

        if (record.parentId !== null) {
            return this.recordIsHidden(store.get(record.parentId), store)
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerStateProvider));


/***/ },

/***/ "./apps/portal/view/news/tickets/PageContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/PageContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/content/PageContainer.mjs */ "./apps/portal/view/shared/content/PageContainer.mjs");


/**
 * @class Portal.view.news.tickets.PageContainer
 * @extends Portal.view.shared.content.PageContainer
 */
class TicketPageContainer extends _shared_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.PageContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.PageContainer',
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={flex:1,overflowY:'auto',position:'relative'}
         */
        style: {flex: 1, overflowY: 'auto', position: 'relative'}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketPageContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/TimelineCanvas.mjs"
/*!**********************************************************!*\
  !*** ./apps/portal/view/news/tickets/TimelineCanvas.mjs ***!
  \**********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/component/Canvas.mjs */ "./src/component/Canvas.mjs");


/**
 * @summary The "Coordinator" component for the Neural Timeline, bridging the App Worker and Canvas Worker.
 *
 * This component renders a transparent canvas overlay on top of the Ticket List. It is responsible for:
 * 1. **Data Bridge**: Listening to the `sections` store and passing ticket data to the `TicketCanvas` (SharedWorker).
 * 2. **Visual Alignment**: Calculating the precise DOM positions of Ticket Avatars/Badges to ensure the
 *    canvas nodes align perfectly with the HTML content.
 * 3. **Lifecycle Management**: initializing the offscreen canvas transfer and handling resize events.
 *
 * It uses the `Portal.canvas.TicketCanvas` singleton (via Remote Method Access) to drive the actual animation.
 *
 * @class Portal.view.news.tickets.TimelineCanvas
 * @extends Neo.component.Canvas
 */
class TimelineCanvas extends _src_component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     */
    static delayable = {
        ensureFinalAlignment: {
            type : 'debounce',
            timer: 300
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.TimelineCanvas'
         * @protected
         */
        className: 'Portal.view.news.tickets.TimelineCanvas',
        /**
         * @member {Object} listeners
         */
        listeners: {
            resize: 'onResize'
        },
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'div', cls: ['neo-ticket-timeline-wrapper'], style: {width: '100%', height: '100%'}, cn: [
            {tag: 'canvas', style: {width: '100%', height: '100%'}}
        ]}
    }

    /**
     * @member {String} canvasId=null
     */
    canvasId = null
    /**
     * @member {Boolean} isCanvasReady=false
     */
    isCanvasReady = false
    /**
     * @member {Object[]} lastRecords=null
     */
    lastRecords = null

    /**
     *
     */
    ensureFinalAlignment() {
        let me = this;

        if (me.lastRecords) {
            me.onTimelineDataLoad(me.lastRecords, true)
        }
    }

    /**
     * Lifecycle hook that runs once the `OffscreenCanvas` has been transferred to the Canvas Worker.
     *
     * This method:
     * 1. Imports the `TicketCanvas` logic into the Canvas Worker context.
     * 2. Initializes the graph in the worker via Remote Method Access (`initGraph`).
     * 3. Sets up a `ResizeObserver` to keep the canvas size synced with the DOM.
     * 4. Triggers the initial data load if store data is available.
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetOffscreenRegistered(value, oldValue) {
        let me = this;

        if (value) {
            // Ensure the logic is loaded in the worker
            await Portal.canvas.Helper.importTicketCanvas();

            // Direct Remote Method Access call
            await Portal.canvas.TicketCanvas.initGraph({canvasId: me.getCanvasId(), windowId: me.windowId});

            me.isCanvasReady = true;

            // Register ResizeObserver for the canvas wrapper (me.id)
            Neo.main.addon.ResizeObserver.register({
                id      : me.id,
                windowId: me.windowId
            });

            // Initial sizing
            await me.updateSize();

            // Initial load check
            let store = me.getStateProvider().getStore('sections');

            if (store.getCount() > 0) {
                me.onTimelineDataLoad(store.items)
            }
        } else if (oldValue) {
            me.isCanvasReady = false;
            // Stop the worker loop to prevent "Zombie Canvas" CPU usage
            await Portal.canvas.TicketCanvas.clearGraph()
        }
    }

    /**
     * Override to return the inner canvas ID
     */
    getCanvasId() {
        let me = this;

        if (!me.canvasId) {
            me.canvasId = me.vdom.cn[0].id
        }
        return me.canvasId
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me    = this,
            store = me.getStateProvider().getStore('sections');

        store.on('load', me.onTimelineDataLoad, me)
    }

    /**
     * @param {Object} data
     */
    async onResize(data) {
        let me = this;

        // Update the canvas size in the worker
        await me.updateSize(data.contentRect);

        // If we have cached records, re-calculate node positions
        // because the container dimensions (and likely relative positions) have changed.
        if (me.lastRecords) {
            // We don't need to re-fetch rects instantly, but it's safer to do so
            // to ensure alignment with the new layout.
            await me.onTimelineDataLoad(me.lastRecords, true);

            // Debounced check to ensure the canvas is aligned after any transitions settle
            me.ensureFinalAlignment()
        }
    }

    /**
     * The core "Alignment Engine" of the timeline.
     *
     * This method synchronizes the Canvas nodes with the DOM elements (Avatars/Badges).
     *
     * **Strategy:**
     * 1. **Targeting**: It uses the `-target` ID suffix to find the specific DOM elements (Avatars) within the ticket list.
     * 2. **Measurement**: It fetches the `DOMRect` for every target to get its exact screen position.
     * 3. **Translation**: It converts these screen coordinates into Canvas-local coordinates.
     * 4. **Handoff**: It packages this geometric data (x, y, radius, color) and sends it to the
     *    `TicketCanvas` worker to update the physics simulation.
     *
     * @param {Object[]|Object} records Array of records or Store load event object {items: [...]}
     * @param {Boolean} [isResize=false]
     */
    async onTimelineDataLoad(records, isResize = false) {
        let me = this;

        // Handle Store 'load' event signature: fire('load', {items: [...]})
        if (records && !Array.isArray(records) && records.items) {
            records = records.items
        }

        if (!Array.isArray(records)) {
            // Safety check if records is still invalid
            return
        }

        if (!me.isCanvasReady) {
            return
        }

        let reset = !isResize;

        // Smart Check: If it's a store load (reset=true) BUT the ticket ID is the same,
        // it's a data refresh (e.g. comment added), so we should NOT reset the animation.
        if (reset && me.lastRecords && records[0]?.id === me.lastRecords[0]?.id) {
            reset = false
        }

        me.lastRecords = records;

        let ids = records.map(r => `${r.id}-target`),
            rects;

        try {
            // Fetch DOM rects for the MARKERS (Avatars/Badges), not the containers
            rects = await me.waitForDomRect({
                attempts: 20,
                delay   : 50,
                id      : ids
            });

            if (me.lastRecords !== records) {
                return
            }

            // Check if we got valid rects (at least one)
            let hasRects = rects && rects.some(r => r);

            if (!hasRects) {
                return
            }

            // On first valid data load (not resize), ensure size is synced
            // because content might have pushed the container height.
            if (!isResize) {
                await me.updateSize()
            }

            let canvasRect = await me.getDomRect(me.getCanvasId()),
                nodes      = [],
                startY     = 0;

            ids.forEach((targetId, index) => {
                let rect   = rects[index],
                    record = records[index];

                if (rect) {
                    // PRECISE CENTERING
                    // Now 'rect' is the actual avatar/badge.
                    let offset = rect.height / 2,
                        nodeY  = rect.y - canvasRect.y + offset,
                        nodeX  = rect.x - canvasRect.x + (rect.width / 2),
                        // Distinct padding for Orbit effect
                        // Avatars (~40px) get more breathing room than Badges (~28px)
                        padding = rect.height > 32 ? 6 : 3;

                    nodes.push({
                        color : record.color, // Pass Hex Color (e.g. #ff0000)
                        id    : record.id,
                        radius: offset + padding,
                        y     : nodeY,
                        x     : nodeX
                    });

                    // Set the startY of the line to the first node
                    if (index === 0) {
                        startY = nodeY
                    }
                }
            });

            await Portal.canvas.TicketCanvas.updateGraphData({nodes, reset, startY})
        } catch (e) {
            console.error('TimelineCanvas update failed', e)
        }
    }

    /**
     * @param {Object|null} rect
     * @returns {Promise<void>}
     */
    async updateSize(rect) {
        let me = this;

        if (!rect || rect.width === 0 || rect.height === 0) {
            rect = await me.waitForDomRect({id: me.getCanvasId()})
        }

        await Portal.canvas.TicketCanvas.updateSize({width: rect.width, height: rect.height})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TimelineCanvas));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfcG9ydGFsX3ZpZXdfbmV3c190aWNrZXRzX01haW5Db250YWluZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBSztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx5QkFBeUI7QUFDekI7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDLHNDQUFzQyxHQUFHLE9BQU8sTUFBTTtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkRVOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBSztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsMkJBQTJCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ087O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJEQUFj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bkYsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRTs7QUFFQSxxREFBcUQsdUNBQXVDO0FBQzVGO0FBQ0E7O0FBRUEsaUVBQWUsOEJBQThCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvbW9kZWwvVGlja2V0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvbW9kZWwvVGlja2V0TGFiZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9tb2RlbC9UaWNrZXRUaW1lbGluZVNlY3Rpb24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9zdG9yZS9UaWNrZXRMYWJlbHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9zdG9yZS9UaWNrZXRUaW1lbGluZVNlY3Rpb25zLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvc3RvcmUvVGlja2V0cy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL0NhbnZhc1dyYXBwZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL1BhZ2VDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9UaW1lbGluZUNhbnZhcy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5tb2RlbC5UaWNrZXRcbiAqIEBleHRlbmRzIE5lby5kYXRhLk1vZGVsXG4gKi9cbmNsYXNzIFRpY2tldCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5tb2RlbC5UaWNrZXQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5tb2RlbC5UaWNrZXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGZpZWxkc1xuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzOiBbe1xuICAgICAgICAgICAgbmFtZSAgICAgICAgOiAnY29sbGFwc2VkJyxcbiAgICAgICAgICAgIHR5cGUgICAgICAgIDogJ0Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdpZCcsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lICAgICAgICA6ICdpc0xlYWYnLFxuICAgICAgICAgICAgdHlwZSAgICAgICAgOiAnQm9vbGVhbicsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZSAgICAgICAgOiAncGFyZW50SWQnLFxuICAgICAgICAgICAgdHlwZSAgICAgICAgOiAnU3RyaW5nJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAncGF0aCcsIC8vIFwicmVzb3VyY2VzL2NvbnRlbnQvaXNzdWVzL2lzc3VlLTEyMzQubWRcIlxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ3RpdGxlJywgLy8gXCJGaXggZWx1c2l2ZSBidWcgaW4gR3JpZFwiXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICAvLyBDb21wdXRlZCBmaWVsZCBmb3IgVHJlZUxpc3QgZGlzcGxheVxuICAgICAgICAgICAgbmFtZTogJ3RyZWVOb2RlTmFtZScsXG4gICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YVxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICBkYXRhLmlkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuaXNMZWFmXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEudGl0bGVcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGN1bGF0ZSh7aWQsIGlzTGVhZiwgdGl0bGV9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTGVhZiA/IGA8Yj4ke2lkfTwvYj4gJHt0aXRsZX1gIDogaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldCk7XG4iLCJpbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLm1vZGVsLlRpY2tldExhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5Nb2RlbFxuICovXG5jbGFzcyBUaWNrZXRMYWJlbCBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5tb2RlbC5UaWNrZXRMYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLm1vZGVsLlRpY2tldExhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBmaWVsZHNcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2NvbG9yJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdkZXNjcmlwdGlvbicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnbmFtZScsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAndGV4dENvbG9yJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRMYWJlbCk7XG4iLCJpbXBvcnQgQ29udGVudFNlY3Rpb24gZnJvbSAnLi9Db250ZW50U2VjdGlvbi5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwubW9kZWwuVGlja2V0VGltZWxpbmVTZWN0aW9uXG4gKiBAZXh0ZW5kcyBQb3J0YWwubW9kZWwuQ29udGVudFNlY3Rpb25cbiAqL1xuY2xhc3MgVGlja2V0VGltZWxpbmVTZWN0aW9uIGV4dGVuZHMgQ29udGVudFNlY3Rpb24ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLm1vZGVsLlRpY2tldFRpbWVsaW5lU2VjdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLm1vZGVsLlRpY2tldFRpbWVsaW5lU2VjdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZHM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnY29sb3InLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2ljb24nLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2ltYWdlJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdzb3VyY2VJZCcsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0VGltZWxpbmVTZWN0aW9uKTtcbiIsImltcG9ydCBUaWNrZXRMYWJlbCBmcm9tICcuLi9tb2RlbC9UaWNrZXRMYWJlbC5tanMnO1xuaW1wb3J0IFN0b3JlIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5zdG9yZS5UaWNrZXRMYWJlbHNcbiAqIEBleHRlbmRzIE5lby5kYXRhLlN0b3JlXG4gKi9cbmNsYXNzIFRpY2tldExhYmVscyBleHRlbmRzIFN0b3JlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5zdG9yZS5UaWNrZXRMYWJlbHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5zdG9yZS5UaWNrZXRMYWJlbHMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBrZXlQcm9wZXJ0eT0nbmFtZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHk6ICduYW1lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLk1vZGVsfSBtb2RlbD1UaWNrZXRMYWJlbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDogVGlja2V0TGFiZWwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHVybD0nLi4vLi4vYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvbGFiZWxzLmpzb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVybDogJy4uLy4uL2FwcHMvcG9ydGFsL3Jlc291cmNlcy9kYXRhL2xhYmVscy5qc29uJ1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0TGFiZWxzKTtcbiIsImltcG9ydCBDb250ZW50U2VjdGlvbnMgICAgICBmcm9tICcuL0NvbnRlbnRTZWN0aW9ucy5tanMnO1xuaW1wb3J0IFRpY2tldFRpbWVsaW5lU2VjdGlvbiBmcm9tICcuLi9tb2RlbC9UaWNrZXRUaW1lbGluZVNlY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnN0b3JlLlRpY2tldFRpbWVsaW5lU2VjdGlvbnNcbiAqIEBleHRlbmRzIFBvcnRhbC5zdG9yZS5Db250ZW50U2VjdGlvbnNcbiAqL1xuY2xhc3MgVGlja2V0VGltZWxpbmVTZWN0aW9ucyBleHRlbmRzIENvbnRlbnRTZWN0aW9ucyB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuc3RvcmUuVGlja2V0VGltZWxpbmVTZWN0aW9ucydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnN0b3JlLlRpY2tldFRpbWVsaW5lU2VjdGlvbnMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsPVRpY2tldFRpbWVsaW5lU2VjdGlvblxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBUaWNrZXRUaW1lbGluZVNlY3Rpb25cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldFRpbWVsaW5lU2VjdGlvbnMpO1xuIiwiaW1wb3J0IFN0b3JlICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL1N0b3JlLm1qcyc7XG5pbXBvcnQgVGlja2V0TW9kZWwgZnJvbSAnLi4vbW9kZWwvVGlja2V0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5zdG9yZS5UaWNrZXRzXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5TdG9yZVxuICovXG5jbGFzcyBUaWNrZXRzIGV4dGVuZHMgU3RvcmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnN0b3JlLlRpY2tldHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5zdG9yZS5UaWNrZXRzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLk1vZGVsfSBtb2RlbD1UaWNrZXRNb2RlbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBUaWNrZXRNb2RlbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdXJsPScuLi8uLi9hcHBzL3BvcnRhbC9yZXNvdXJjZXMvZGF0YS90aWNrZXRzLmpzb24nXG4gICAgICAgICAqL1xuICAgICAgICB1cmw6ICcuLi8uLi9hcHBzL3BvcnRhbC9yZXNvdXJjZXMvZGF0YS90aWNrZXRzLmpzb24nXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRzKTtcbiIsImltcG9ydCBDb250YWluZXIgICAgICAgIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NyYy9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRlbnRDb21wb25lbnQgZnJvbSAnLi9Db21wb25lbnQubWpzJztcbmltcG9ydCBUaW1lbGluZUNhbnZhcyAgIGZyb20gJy4vVGltZWxpbmVDYW52YXMubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNhbnZhc1dyYXBwZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBDYW52YXNXcmFwcGVyIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5DYW52YXNXcmFwcGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ2FudmFzV3JhcHBlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsncG9ydGFsLWNhbnZhcy13cmFwcGVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWydwb3J0YWwtY2FudmFzLXdyYXBwZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb250ZW50Q29tcG9uZW50PUNvbnRlbnRDb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRlbnRDb21wb25lbnQ6IENvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlPXttaW5IZWlnaHQ6JzEwMCUnLG92ZXJmbG93Oid2aXNpYmxlJyxwb3NpdGlvbjoncmVsYXRpdmUnfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IHttaW5IZWlnaHQ6ICcxMDAlJywgb3ZlcmZsb3c6ICd2aXNpYmxlJywgcG9zaXRpb246ICdyZWxhdGl2ZSd9XG4gICAgfVxuXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGNvbmZpZy5pdGVtcyA9IFt7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFRpbWVsaW5lQ2FudmFzLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAndGltZWxpbmUtY2FudmFzJyxcbiAgICAgICAgICAgIHN0eWxlIDoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICAgICA6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgdG9wICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICA6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgICAgICAgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgekluZGV4ICAgICAgIDogMixcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlOiBjb25maWcuY29udGVudENvbXBvbmVudCB8fCBtZS5jb250ZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgc3R5bGUgOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgekluZGV4ICA6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICB0b2dnbGVTdW1tYXJ5OiBtZS5vblRvZ2dsZVN1bW1hcnksXG4gICAgICAgICAgICAgICAgc2NvcGUgICAgICAgIDogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV07XG5cbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvblRvZ2dsZVN1bW1hcnkoKSB7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLmdldFJlZmVyZW5jZSgndGltZWxpbmUtY2FudmFzJyk7XG5cbiAgICAgICAgaWYgKGNhbnZhcz8ubGFzdFJlY29yZHMpIHtcbiAgICAgICAgICAgIGNhbnZhcy5vblRpbWVsaW5lRGF0YUxvYWQoY2FudmFzLmxhc3RSZWNvcmRzLCB0cnVlKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDYW52YXNXcmFwcGVyKTtcbiIsImltcG9ydCBDb250ZW50Q29tcG9uZW50IGZyb20gJy4uLy4uL3NoYXJlZC9jb250ZW50L0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IHttYXJrZWR9ICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21hcmtlZC9saWIvbWFya2VkLmVzbS5qcyc7XG5cbmNvbnN0XG4gICAgcmVnZXhGcm9udE1hdHRlciAgID0gL14tLS1cXG4oW1xcc1xcU10qPylcXG4tLS1cXG4vLFxuICAgIHJlZ2V4SDEgICAgICAgICAgICA9IC8oPGgxW14+XSo+Lio/PFxcL2gxPikvLFxuICAgIHJlZ2V4VGlja2V0TGluayAgICA9IC8oXFxkezQsfSkvLFxuICAgIHJlZ2V4VGltZWxpbmUgICAgICA9IC8jIyBUaW1lbGluZVxccypcXG4oW1xcc1xcU10qKS8sXG4gICAgcmVnZXhUaW1lbGluZUV2ZW50ID0gL14tIChbXFxkVFo6Li1dKykgQChcXHcrKSAoLiopJC8sXG4gICAgcmVnZXhDb21taXQgICAgICAgID0gL1xcYihbMC05YS1mXXs3LDQwfSlcXGIvZztcblxuLyoqXG4gKiBAc3VtbWFyeSBUaGUgXCJNYXJrZG93biBUcmFuc2Zvcm1lclwiIGZvciBHaXRIdWIgVGlja2V0cy5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBleHRlbmRzIHRoZSBzdGFuZGFyZCBDb250ZW50Q29tcG9uZW50IHRvIHByb3ZpZGUgc3BlY2lhbGl6ZWQgcmVuZGVyaW5nIGZvciBHaXRIdWIgSXNzdWVzLlxuICogSXRzIHByaW1hcnkgcmVzcG9uc2liaWxpdHkgaXMgdG8gcGFyc2UgdGhlIHJhdyBNYXJrZG93biBjb250ZW50ICh3aGljaCBpbmNsdWRlcyBjdXN0b20gRnJvbnRtYXR0ZXIgYW5kXG4gKiBhIHByZS1nZW5lcmF0ZWQgVGltZWxpbmUgc2VjdGlvbikgYW5kIHRyYW5zZm9ybSBpdCBpbnRvIGEgcmljaCwgaW50ZXJhY3RpdmUgSFRNTCBzdHJ1Y3R1cmUuXG4gKlxuICogKipLZXkgUmVzcG9uc2liaWxpdGllczoqKlxuICogMS4gKipQYXJzaW5nIFBpcGVsaW5lKio6IEV4dHJhY3RzIEZyb250bWF0dGVyLCBCb2R5LCBhbmQgdGhlIGN1c3RvbSBcIlRpbWVsaW5lXCIgc2VjdGlvbiBmcm9tIHRoZSByYXcgTWFya2Rvd24uXG4gKiAyLiAqKlJpY2ggUmVuZGVyaW5nKio6IEdlbmVyYXRlcyBIVE1MIGZvciBTdGF0dXMgQmFkZ2VzLCBMYWJlbHMsIENvbW1pdCBMaW5rcywgYW5kIFVzZXIgTWVudGlvbnMuXG4gKiAzLiAqKkRhdGEgRXh0cmFjdGlvbioqOiBBcyBhIHNpZGUgZWZmZWN0IG9mIHJlbmRlcmluZywgaXQgZXh0cmFjdHMgc3RydWN0dXJlZCBkYXRhIChgbWUudGltZWxpbmVEYXRhYClcbiAqICAgIHJlcHJlc2VudGluZyBldmVyeSB0aW1lbGluZSBldmVudCAoY29tbWVudCwgbGFiZWwgY2hhbmdlLCBjbG9zZSwgZXRjLikuIFRoaXMgZGF0YSBpcyB0aGVuXG4gKiAgICBwdXNoZWQgdG8gdGhlIGBzZWN0aW9uc2Agc3RvcmUgdG8gZHJpdmUgdGhlIGBUaW1lbGluZUNhbnZhc2AgdmlzdWFsaXphdGlvbi5cbiAqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNvbXBvbmVudFxuICogQGV4dGVuZHMgUG9ydGFsLnZpZXcuc2hhcmVkLmNvbnRlbnQuQ29tcG9uZW50XG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIENvbnRlbnRDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsncG9ydGFsLW5ld3MtdGlja2V0cy1jb21wb25lbnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ3BvcnRhbC1uZXdzLXRpY2tldHMtY29tcG9uZW50J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNvbW1pdHNVcmw9J2h0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2NvbW1pdC8nXG4gICAgICAgICAqL1xuICAgICAgICBjb21taXRzVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vY29tbWl0LycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRvbUxpc3RlbmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZG9tTGlzdGVuZXJzOiB7XG4gICAgICAgICAgICByZXNpemU6ICdvblJlc2l6ZSdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVwb1VzZXJVcmw9J2h0dHBzOi8vZ2l0aHViLmNvbS8nXG4gICAgICAgICAqL1xuICAgICAgICByZXBvVXNlclVybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXBkYXRlU2VjdGlvbnNTdG9yZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlU2VjdGlvbnNTdG9yZTogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9ICNkYXRlVGltZUZvcm1hdEhpc3Rvcnk9bnVsbFxuICAgICAqL1xuICAgICNkYXRlVGltZUZvcm1hdEhpc3RvcnkgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSAjZGF0ZVRpbWVGb3JtYXRUb2RheT1udWxsXG4gICAgICovXG4gICAgI2RhdGVUaW1lRm9ybWF0VG9kYXkgPSBudWxsXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIHRoZSBzdHJ1Y3R1cmVkIHRpbWVsaW5lIGRhdGEgZXh0cmFjdGVkIGR1cmluZyB0aGUgcGFyc2luZyBwaGFzZS5cbiAgICAgKiBUaGlzIGFycmF5IGlzIHBvcHVsYXRlZCBieSBgcmVuZGVyVGltZWxpbmVgIGFuZCBgbW9kaWZ5TWFya2Rvd25gIGFuZCB0aGVuIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGBzZWN0aW9uc2Agc3RvcmUgdG8gZHJpdmUgdGhlIENhbnZhcyB2aXN1YWxpemF0aW9uLlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSB0aW1lbGluZURhdGE9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGltZWxpbmVEYXRhID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoJ2NvbnRlbnRDb21wb25lbnRJZCcsIHRoaXMuaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlzb1N0cmluZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VGltZXN0YW1wKGlzb1N0cmluZykge1xuICAgICAgICBpZiAoIWlzb1N0cmluZykgcmV0dXJuICcnO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGUgICAgPSBuZXcgRGF0ZShpc29TdHJpbmcpLFxuICAgICAgICAgICAgbm93ICAgICA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBpc1RvZGF5ID0gZGF0ZS50b0RhdGVTdHJpbmcoKSA9PT0gbm93LnRvRGF0ZVN0cmluZygpO1xuXG4gICAgICAgIGlmIChpc1RvZGF5KSB7XG4gICAgICAgICAgICBpZiAoIW1lLiNkYXRlVGltZUZvcm1hdFRvZGF5KSB7XG4gICAgICAgICAgICAgICAgbWUuI2RhdGVUaW1lRm9ybWF0VG9kYXkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZGVmYXVsdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaG91ciAgOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1lLiNkYXRlVGltZUZvcm1hdFRvZGF5LmZvcm1hdChkYXRlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS4jZGF0ZVRpbWVGb3JtYXRIaXN0b3J5KSB7XG4gICAgICAgICAgICBtZS4jZGF0ZVRpbWVGb3JtYXRIaXN0b3J5ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2RlZmF1bHQnLCB7XG4gICAgICAgICAgICAgICAgZGF5ICAgOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgaG91ciAgOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgbW9udGggOiAnc2hvcnQnLFxuICAgICAgICAgICAgICAgIHllYXIgIDogJ251bWVyaWMnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLiNkYXRlVGltZUZvcm1hdEhpc3RvcnkuZm9ybWF0KGRhdGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGZyb250TWF0dGVyVG9IdG1sKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaHRtbCA9ICc8dGFibGUgY2xhc3M9XCJuZW8tZnJvbnRtYXR0ZXItdGFibGVcIj48dGJvZHk+JztcblxuICAgICAgICBPYmplY3QuZW50cmllcyhkYXRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGxldCByZW5kZXJlZFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc3ViSXNzdWVzJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSB2YWx1ZS5tYXAoaXNzdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJuZW8tc3ViLWlzc3VlXCI+JHtpc3N1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocmVnZXhUaWNrZXRMaW5rLCAnPGEgaHJlZj1cIiMvbmV3cy90aWNrZXRzLyQxXCI+JDE8L2E+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdbeF0nLCAnPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1jaXJjbGUtY2hlY2tcIj48L2k+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdbIF0nLCAnPGkgY2xhc3M9XCJmYS1yZWd1bGFyIGZhLWNpcmNsZVwiPjwvaT4nKX08L2Rpdj5gXG4gICAgICAgICAgICAgICAgfSkuam9pbignJylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnYXV0aG9yJykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSBgPGEgaHJlZj1cIiR7bWUucmVwb1VzZXJVcmx9JHt2YWx1ZX1cIiB0YXJnZXQ9XCJfYmxhbmtcIj4ke3ZhbHVlfTwvYT5gXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NyZWF0ZWRBdCcgfHwga2V5ID09PSAnY2xvc2VkQXQnIHx8IGtleSA9PT0gJ3VwZGF0ZWRBdCcpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gbWUuZm9ybWF0VGltZXN0YW1wKHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdsYWJlbHMnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IG1lLmdldEJhZGdlc0h0bWwodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSBtZS5nZXRTdGF0ZUJhZGdlSHRtbCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IG1lLmZvcm1hdEZyb250TWF0dGVyVmFsdWUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGh0bWwgKz0gYDx0cj48dGQ+JHtrZXl9PC90ZD48dGQ+JHtyZW5kZXJlZFZhbHVlfTwvdGQ+PC90cj5gXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGh0bWwgKz0gJzwvdGJvZHk+PC90YWJsZT4nO1xuXG4gICAgICAgIGlmIChtZS51c2VGcm9udG1hdHRlckRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBgPGRldGFpbHMgaWQ9XCJuZW8tdGlja2V0LXN1bW1hcnktZGV0YWlscy0ke21lLmlkfVwiPjxzdW1tYXJ5PkZyb250bWF0dGVyPC9zdW1tYXJ5PiR7aHRtbH08L2RldGFpbHM+YFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBsYWJlbHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEJhZGdlc0h0bWwobGFiZWxzKSB7XG4gICAgICAgIGlmICghbGFiZWxzIHx8IGxhYmVscy5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBiYWRnZXNIdG1sID0gJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LWxhYmVsc1wiPic7XG5cbiAgICAgICAgbGFiZWxzLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICAgICAgYmFkZ2VzSHRtbCArPSBtZS5nZXRMYWJlbEJhZGdlSHRtbChsYWJlbClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmFkZ2VzSHRtbCArPSAnPC9kaXY+JztcblxuICAgICAgICByZXR1cm4gYmFkZ2VzSHRtbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBkb0ZldGNoQ29udGVudChyZWNvcmQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1lLFxuICAgICAgICAgICAgY29udGVudCwgZGF0YSwgcGF0aDtcblxuICAgICAgICBwYXRoID0gbWUuZ2V0Q29udGVudFBhdGgocmVjb3JkKTtcblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiAmJiBwYXRoKSB7XG4gICAgICAgICAgICBkYXRhICAgID0gYXdhaXQgZmV0Y2gocGF0aCk7XG4gICAgICAgICAgICBjb250ZW50ID0gYXdhaXQgZGF0YS50ZXh0KCk7XG5cbiAgICAgICAgICAgIG1lLnZhbHVlID0gY29udGVudDtcblxuICAgICAgICAgICAgbWUudG9nZ2xlQ2xzKCdsYWInLCByZWNvcmQubmFtZT8uc3RhcnRzV2l0aCgnTGFiOicpKTtcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uSW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBvYnNlcnZlICAgOiBbJy5uZW8tdGltZWxpbmUtaXRlbVtkYXRhLXJlY29yZC1pZF0nXSxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVjb3JkLnBhdGhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29udGVudFBhdGgoe3BhdGh9KSB7XG4gICAgICAgIHJldHVybiBwYXRoID8gTmVvLmNvbmZpZy5iYXNlUGF0aCArIHBhdGggOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRMYWJlbEJhZGdlSHRtbChsYWJlbCkge1xuICAgICAgICBsZXQgc3RvcmUgID0gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ2xhYmVscycpLFxuICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0KGxhYmVsKTtcblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwibmVvLWJhZGdlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiR7cmVjb3JkLmNvbG9yfTtjb2xvcjoke3JlY29yZC50ZXh0Q29sb3J9XCI+JHtsYWJlbH08L3NwYW4+YFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGA8c3BhbiBjbGFzcz1cIm5lby1iYWRnZVwiPiR7bGFiZWx9PC9zcGFuPmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN0YXRlQmFkZ2VIdG1sKHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RhdGUpIHJldHVybiAnJztcblxuICAgICAgICBsZXQgY2xzICA9ICduZW8tYmFkZ2UgbmVvLXN0YXRlLWJhZGdlJyxcbiAgICAgICAgICAgIGljb24gPSAnZmEtY2lyY2xlLWRvdCc7XG5cbiAgICAgICAgaWYgKHN0YXRlLnRvVXBwZXJDYXNlKCkgPT09ICdDTE9TRUQnKSB7XG4gICAgICAgICAgICBjbHMgICs9ICcgbmVvLXN0YXRlLWNsb3NlZCc7XG4gICAgICAgICAgICBpY29uICA9ICdmYS1jaXJjbGUtY2hlY2snXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHMgKz0gJyBuZW8tc3RhdGUtb3BlbidcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCIke2Nsc31cIj48aSBjbGFzcz1cImZhLXJlZ3VsYXIgJHtpY29ufVwiPjwvaT4ke05lby5jYXBpdGFsaXplKHN0YXRlLnRvTG93ZXJDYXNlKCkpfTwvc3Bhbj5gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIE1haW4gUGFyc2luZyBQaXBlbGluZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGludGVyY2VwdHMgdGhlIHJhdyBtYXJrZG93biBjb250ZW50IGJlZm9yZSBpdCBpcyByZW5kZXJlZCBhbmQgcGVyZm9ybXMgYSBtdWx0aS1wYXNzIHRyYW5zZm9ybWF0aW9uOlxuICAgICAqIDEuICoqRXh0cmFjdCBUaW1lbGluZSoqOiBQdWxscyBvdXQgdGhlIHJhdyBgIyMgVGltZWxpbmVgIHNlY3Rpb24gdG8gcHJvY2VzcyBpdCBzZXBhcmF0ZWx5LlxuICAgICAqIDIuICoqUHJvY2VzcyBGcm9udG1hdHRlcioqOiBFeHRyYWN0cyBtZXRhZGF0YSAobGFiZWxzLCBzdGF0ZSwgYXV0aG9yKSBhbmQgcmVtb3ZlcyB0aGUgWUFNTCBibG9jay5cbiAgICAgKiAzLiAqKlJlbmRlciBCb2R5Kio6IFVzZXMgdGhlIHN1cGVyY2xhc3MgKG1hcmtlZC5qcykgdG8gY29udmVydCB0aGUgbWFpbiBpc3N1ZSBib2R5IHRvIEhUTUwuXG4gICAgICogNC4gKipJbmplY3QgVGl0bGUgSURzKio6IEFkZHMgSURzIHRvIEgxIHRhZ3MgZm9yIG5hdmlnYXRpb24uXG4gICAgICogNS4gKipHZW5lcmF0ZSBCYWRnZXMqKjogQ3JlYXRlcyBIVE1MIGZvciBTdGF0dXMvTGFiZWwgYmFkZ2VzIGJhc2VkIG9uIGV4dHJhY3RlZCBtZXRhZGF0YS5cbiAgICAgKiA2LiAqKldyYXAgQm9keSoqOiBXcmFwcyB0aGUgbWFpbiBpc3N1ZSBib2R5IGluIGEgYHRpbWVsaW5lLWl0ZW1gIHN0cnVjdHVyZSBzbyBpdCBhcHBlYXJzIGFzIHRoZSBmaXJzdCBpdGVtLlxuICAgICAqIDcuICoqUmUtQXNzZW1ibGUqKjogQ29uY2F0ZW5hdGVzIEZyb250bWF0dGVyICsgVGl0bGUgKyBUaW1lbGluZSAod2l0aCBCb2R5IGluamVjdGVkKSBpbnRvIHRoZSBmaW5hbCBIVE1MLlxuICAgICAqXG4gICAgICogKipTaWRlIEVmZmVjdCoqOiBQb3B1bGF0ZXMgYG1lLnRpbWVsaW5lRGF0YWAgYW5kIHVwZGF0ZXMgdGhlIGBzZWN0aW9uc2Agc3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgbW9kaWZ5TWFya2Rvd24oY29udGVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnRJZH0gICA9IG1lLnJlY29yZCxcbiAgICAgICAgICAgIGF1dGhvciAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBjcmVhdGVkQXQgICAgPSBudWxsLFxuICAgICAgICAgICAgbGFiZWxzICAgICAgID0gW10sXG4gICAgICAgICAgICBzdGF0ZSAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgbWF0Y2ggICAgICAgID0gY29udGVudC5tYXRjaChyZWdleEZyb250TWF0dGVyKSxcbiAgICAgICAgICAgIHRpbWVsaW5lSHRtbCA9ICcnLFxuICAgICAgICAgICAgYmFkZ2VzSHRtbCAgID0gJyc7XG5cbiAgICAgICAgbWUudGltZWxpbmVEYXRhID0gW107XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG1lLnBhcnNlRnJvbnRNYXR0ZXIobWF0Y2hbMV0pO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5hdXRob3IpICAgIHthdXRob3IgICAgPSBkYXRhLmF1dGhvcn1cbiAgICAgICAgICAgIGlmIChkYXRhLmNyZWF0ZWRBdCkge2NyZWF0ZWRBdCA9IG1lLmZvcm1hdFRpbWVzdGFtcChkYXRhLmNyZWF0ZWRBdCl9XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMpICAgIHtsYWJlbHMgICAgPSBkYXRhLmxhYmVsc31cbiAgICAgICAgICAgIGlmIChkYXRhLnN0YXRlKSAgICAge3N0YXRlICAgICA9IGRhdGEuc3RhdGV9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAxLiBFeHRyYWN0IGFuZCBwcm9jZXNzIHRpbWVsaW5lIGZyb20gUkFXIG1hcmtkb3duXG4gICAgICAgIGxldCB0aW1lbGluZU1hdGNoID0gY29udGVudC5tYXRjaChyZWdleFRpbWVsaW5lKTtcbiAgICAgICAgaWYgKHRpbWVsaW5lTWF0Y2gpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lSHRtbCA9IG1lLnJlbmRlclRpbWVsaW5lKHRpbWVsaW5lTWF0Y2hbMV0pO1xuICAgICAgICAgICAgY29udGVudCAgICAgID0gY29udGVudC5yZXBsYWNlKHJlZ2V4VGltZWxpbmUsICcnKTsgLy8gUmVtb3ZlIHJhdyB0aW1lbGluZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gUmVuZGVyIEZyb250bWF0dGVyIE1hbnVhbGx5ICYgU3RyaXAgaXRcbiAgICAgICAgLy8gV2Ugd2FudCBpdCBhdCB0aGUgdmVyeSB0b3AsIG91dHNpZGUgdGhlIGJvZHkgYnViYmxlLlxuICAgICAgICBsZXQgZnJvbnRNYXR0ZXJIdG1sID0gJyc7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgICAgICAgID0gbWUucGFyc2VGcm9udE1hdHRlcihtYXRjaFsxXSk7XG4gICAgICAgICAgICBmcm9udE1hdHRlckh0bWwgPSBtZS5mcm9udE1hdHRlclRvSHRtbChkYXRhKTtcbiAgICAgICAgICAgIGNvbnRlbnQgICAgICAgICA9IGNvbnRlbnQucmVwbGFjZShyZWdleEZyb250TWF0dGVyLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBDb252ZXJ0IEJvZHkgKyBUaXRsZSB0byBIVE1MIHVzaW5nIHN1cGVyXG4gICAgICAgIGxldCBmdWxsSHRtbCA9IHN1cGVyLm1vZGlmeU1hcmtkb3duKGNvbnRlbnQpO1xuXG4gICAgICAgIC8vIDQuIEV4dHJhY3QgSDEgVGl0bGUgZnJvbSB0aGUgZ2VuZXJhdGVkIEhUTUxcbiAgICAgICAgbGV0IHRpdGxlSHRtbCA9ICcnO1xuICAgICAgICBmdWxsSHRtbCAgICAgID0gZnVsbEh0bWwucmVwbGFjZShyZWdleEgxLCAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIC8vIEluamVjdCBJRCBpbnRvIEgxIHRhZ1xuICAgICAgICAgICAgdGl0bGVIdG1sID0gbWF0Y2gucmVwbGFjZSgnPGgxJywgYDxoMSBpZD1cInRpY2tldC10aXRsZS0ke21lLmlkfVwiYCk7XG4gICAgICAgICAgICByZXR1cm4gJyc7IC8vIFJlbW92ZSB0aXRsZSBmcm9tIGJvZHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gNS4gQ29uc3RydWN0IEJhZGdlc1xuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA+IDAgfHwgc3RhdGUgfHwgKHBhcmVudElkICYmIHBhcmVudElkICE9PSAnQmFja2xvZycpKSB7XG4gICAgICAgICAgICBiYWRnZXNIdG1sID0gJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LWxhYmVsc1wiPic7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gbWUuZ2V0U3RhdGVCYWRnZUh0bWwoc3RhdGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCAmJiBwYXJlbnRJZCAhPT0gJ0JhY2tsb2cnKSB7XG4gICAgICAgICAgICAgICAgYmFkZ2VzSHRtbCArPSBgXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwibmVvLWJhZGdlIG5lby1yZWxlYXNlLWJhZGdlXCIgaHJlZj1cIiMvbmV3cy9yZWxlYXNlcy8ke3BhcmVudElkLnN1YnN0cmluZygxKX1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEtc29saWQgZmEtY29kZS1icmFuY2hcIj48L2k+ICR7cGFyZW50SWR9XG4gICAgICAgICAgICAgICAgICAgIDwvYT5gXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBzdG9yZSA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgnbGFiZWxzJyksXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICAgICAgICAgIGxhYmVscy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0KGxhYmVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWRnZXNIdG1sICs9IGA8c3BhbiBjbGFzcz1cIm5lby1iYWRnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjoke3JlY29yZC5jb2xvcn07Y29sb3I6JHtyZWNvcmQudGV4dENvbG9yfVwiPiR7bGFiZWx9PC9zcGFuPmBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gYDxzcGFuIGNsYXNzPVwibmVvLWJhZGdlXCI+JHtsYWJlbH08L3NwYW4+YFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICB0aXRsZUh0bWwgICs9IGJhZGdlc0h0bWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA2LiBXcmFwIHRoZSByZW1haW5pbmcgSFRNTCAoQm9keSkgaW4gdGhlIFRpbWVsaW5lIEl0ZW0gc3RydWN0dXJlXG4gICAgICAgIGxldCBib2R5SWQgPSBgdGltZWxpbmUtJHttZS5yZWNvcmQuaWR9LTBgO1xuXG4gICAgICAgIG1lLnRpbWVsaW5lRGF0YS51bnNoaWZ0KHtcbiAgICAgICAgICAgIGlkICAgOiBib2R5SWQsXG4gICAgICAgICAgICBpbWFnZTogbWUucmVwb1VzZXJVcmwgKyBhdXRob3IgKyAnLnBuZycsXG4gICAgICAgICAgICBuYW1lIDogJ0Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgIHRhZyAgOiAnYm9keSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGJvZHlJdGVtSHRtbCA9IGBcbiAgICAgICAgICAgIDxkaXYgaWQ9XCIke2JvZHlJZH1cIiBjbGFzcz1cIm5lby10aW1lbGluZS1pdGVtIGNvbW1lbnQgYm9keS1pdGVtXCIgZGF0YS1yZWNvcmQtaWQ9XCIke2JvZHlJZH1cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtib2R5SWR9LXRhcmdldFwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWF2YXRhclwiPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIiR7bWUucmVwb1VzZXJVcmx9JHthdXRob3J9LnBuZ1wiIGFsdD1cIiR7YXV0aG9yfVwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuZW8tdGltZWxpbmUtdXNlclwiIGhyZWY9XCIke21lLnJlcG9Vc2VyVXJsfSR7YXV0aG9yfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7YXV0aG9yfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibmVvLXRpbWVsaW5lLWRhdGVcIj5jb21tZW50ZWQgb24gJHtjcmVhdGVkQXR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1ib2R5XCI+JHtmdWxsSHRtbH08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmA7XG5cbiAgICAgICAgLy8gNy4gSW5qZWN0IEJvZHkgSXRlbSBhdCB0aGUgc3RhcnQgb2YgdGhlIFRpbWVsaW5lXG4gICAgICAgIGxldCB0aW1lbGluZUlkID0gYHRpY2tldC10aW1lbGluZS0ke21lLmlkfWA7XG5cbiAgICAgICAgaWYgKHRpbWVsaW5lSHRtbCkge1xuICAgICAgICAgICAgdGltZWxpbmVIdG1sID0gdGltZWxpbmVIdG1sLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LXRpbWVsaW5lXCI+JyxcbiAgICAgICAgICAgICAgICBgPGRpdiBpZD1cIiR7dGltZWxpbmVJZH1cIiBjbGFzcz1cIm5lby10aWNrZXQtdGltZWxpbmVcIj5gICsgYm9keUl0ZW1IdG1sXG4gICAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZUh0bWwgPSBgPGRpdiBpZD1cIiR7dGltZWxpbmVJZH1cIiBjbGFzcz1cIm5lby10aWNrZXQtdGltZWxpbmVcIj4ke2JvZHlJdGVtSHRtbH08L2Rpdj5gXG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3NlY3Rpb25zJykuZGF0YSA9IG1lLnRpbWVsaW5lRGF0YTtcbiAgICAgICAgbWUudGltZWxpbmVEYXRhID0gbnVsbDtcblxuICAgICAgICAvLyBSZXR1cm46IEZyb250bWF0dGVyICsgVGl0bGUgKyBUaW1lbGluZVxuICAgICAgICByZXR1cm4gZnJvbnRNYXR0ZXJIdG1sICsgdGl0bGVIdG1sICsgdGltZWxpbmVIdG1sXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJlc2l6ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgndG9nZ2xlU3VtbWFyeScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBjdXN0b20gXCJUaW1lbGluZVwiIG1hcmtkb3duIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBFeHBlY3RzIGEgbGluZS1iYXNlZCBmb3JtYXQgZ2VuZXJhdGVkIGJ5IHRoZSBidWlsZCBwcm9jZXNzOlxuICAgICAqIC0gRXZlbnRzOiBgLSBZWVlZLU1NLUREVEhIOm1tOnNzIEB1c2VyIGFjdGlvbiB0ZXh0Li4uYFxuICAgICAqIC0gQ29tbWVudHM6IGAjIyMgQHVzZXIgLSBZWVlZLU1NLUREVEhIOm1tOnNzYCBmb2xsb3dlZCBieSBjb21tZW50IGJvZHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjb252ZXJ0cyB0aGVzZSBsaW5lcyBpbnRvIHN0cnVjdHVyZWQgYHRpbWVsaW5lLWl0ZW1gIEhUTUwgYmxvY2tzXG4gICAgICogYW5kIHNpbXVsdGFuZW91c2x5IHBvcHVsYXRlcyBgbWUudGltZWxpbmVEYXRhYCB3aXRoIHNlbWFudGljIGRhdGEgKGNvbG9yLCBpY29uLCB0eXBlKVxuICAgICAqIGZvciBlYWNoIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJlbmRlclRpbWVsaW5lKGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb21taXRzVXJsLCByZXBvVXNlclVybH0gPSBtZSxcbiAgICAgICAgICAgIGh0bWwgICAgICAgID0gJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LXRpbWVsaW5lXCI+JyxcbiAgICAgICAgICAgIGxpbmVzICAgICAgID0gY29udGVudC5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgICBjb21tZW50QnVmICA9IFtdLFxuICAgICAgICAgICAgY3VycmVudFVzZXIgPSBudWxsLFxuICAgICAgICAgICAgY3VycmVudERhdGUgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgPSBsaW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBpZCwgbGluZSwgbWF0Y2gsIGljb24sIGFjdGlvbkNscztcblxuICAgICAgICBjb25zdCBmbHVzaENvbW1lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29tbWVudEJ1Zi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBgdGltZWxpbmUtJHttZS5yZWNvcmQuaWR9LSR7bWUudGltZWxpbmVEYXRhLmxlbmd0aCArIDF9YDtcblxuICAgICAgICAgICAgICAgIG1lLnRpbWVsaW5lRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogcmVwb1VzZXJVcmwgKyBjdXJyZW50VXNlciArICcucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA6IGBDb21tZW50ICgke2N1cnJlbnRVc2VyfSlgLFxuICAgICAgICAgICAgICAgICAgICB0YWcgIDogJ2NvbW1lbnQnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IG1hcmtlZC5wYXJzZShjb21tZW50QnVmLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICBodG1sICs9IGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7aWR9XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtaXRlbSBjb21tZW50XCIgZGF0YS1yZWNvcmQtaWQ9XCIke2lkfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7aWR9LXRhcmdldFwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWF2YXRhclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiJHtyZXBvVXNlclVybH0ke2N1cnJlbnRVc2VyfS5wbmdcIiBhbHQ9XCIke2N1cnJlbnRVc2VyfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5lby10aW1lbGluZS11c2VyXCIgaHJlZj1cIiR7cmVwb1VzZXJVcmx9JHtjdXJyZW50VXNlcn1cIiB0YXJnZXQ9XCJfYmxhbmtcIj4ke2N1cnJlbnRVc2VyfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJuZW8tdGltZWxpbmUtZGF0ZVwiPiR7bWUuZm9ybWF0VGltZXN0YW1wKGN1cnJlbnREYXRlKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1ib2R5XCI+JHtib2R5fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgICAgICAgICAgY29tbWVudEJ1ZiAgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXNlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgICAgICAvLyBFdmVudCBMaW5lOiAtIDIwMjYtMDEtMTFULi4uIEB1c2VyIGFjdGlvbi4uLlxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2gocmVnZXhUaW1lbGluZUV2ZW50KSkpIHtcbiAgICAgICAgICAgICAgICBmbHVzaENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICBsZXQgW18sIGRhdGUsIHVzZXIsIGFjdGlvbl0gPSBtYXRjaDtcblxuICAgICAgICAgICAgICAgIGljb24gICAgICA9ICdmYS1jaXJjbGUtZG90JzsgLy8gRGVmYXVsdFxuICAgICAgICAgICAgICAgIGFjdGlvbkNscyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gW1xuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnYWRkZWQgdGhlIGAnLCAgICAgIGljb246ICdmYS10YWcnfSxcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ3JlbW92ZWQgdGhlIGAnLCAgICBpY29uOiAnZmEtdGFnJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdhc3NpZ25lZCcsICAgICAgICAgaWNvbjogJ2ZhLXVzZXItcGVuJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdjbG9zZWQnLCAgICAgICAgICAgaWNvbjogJ2ZhLWNpcmNsZS1jaGVjaycsIGNvbG9yOiAnIzgyNTBkZid9LCAvLyBHaXRIdWIgUHVycGxlXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdyZW9wZW5lZCcsICAgICAgICAgaWNvbjogJ2ZhLWNpcmNsZS1kb3QnLCAgIGNvbG9yOiAnIzJkYTQ0ZSd9LCAvLyBHaXRIdWIgR3JlZW5cbiAgICAgICAgICAgICAgICAgICAge2tleTogJ3JlZmVyZW5jZWQnLCAgICAgICBpY29uOiAnZmEtbGluayd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnY3Jvc3MtcmVmZXJlbmNlZCcsIGljb246ICdmYS1saW5rJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdtaWxlc3RvbmVkJywgICAgICAgaWNvbjogJ2ZhLXNpZ24tcG9zdCd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnc3ViLWlzc3VlJywgICAgICAgIGljb246ICdmYS1kaWFncmFtLXByb2plY3QnfVxuICAgICAgICAgICAgICAgIF0uZmluZChlID0+IGFjdGlvbi5pbmNsdWRlcyhlLmtleSkpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbiA9IGV2ZW50VHlwZS5pY29uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlLmNvbG9yKSBjb2xvciA9IGV2ZW50VHlwZS5jb2xvclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIG1hcmtkb3duIGluIGFjdGlvbiB0ZXh0IChlLmcuIGBjb2RlYCB0byA8Y29kZT4pXG4gICAgICAgICAgICAgICAgbGV0IGNsZWFuQWN0aW9uID0gbWFya2VkLnBhcnNlSW5saW5lKGFjdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWNvbiA9PT0gJ2ZhLXRhZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5BY3Rpb24gPSBjbGVhbkFjdGlvbi5yZXBsYWNlKC88Y29kZT4oLio/KTxcXC9jb2RlPi9nLCAobWF0Y2gsIGxhYmVsKSA9PiBtZS5nZXRMYWJlbEJhZGdlSHRtbChsYWJlbCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZXNvbHZlIGNvbG9yIGZyb20gbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTWF0Y2ggPSBhY3Rpb24ubWF0Y2goL2AoW15gXSspYC8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTmFtZSA9IGxhYmVsTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxSZWMgID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdsYWJlbHMnKS5nZXQobGFiZWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFJlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbGFiZWxSZWMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMaW5raWZ5IENvbW1pdCBIYXNoZXNcbiAgICAgICAgICAgICAgICBjbGVhbkFjdGlvbiA9IGNsZWFuQWN0aW9uLnJlcGxhY2UocmVnZXhDb21taXQsIGA8YSBocmVmPVwiJHtjb21taXRzVXJsfSQxXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JDE8L2E+YCk7XG5cbiAgICAgICAgICAgICAgICBpZCA9IGB0aW1lbGluZS0ke21lLnJlY29yZC5pZH0tJHttZS50aW1lbGluZURhdGEubGVuZ3RoICsgMX1gO1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBhIHNob3J0IGFjdGlvbiBuYW1lIGZvciB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGxldCBzaG9ydEFjdGlvbiA9IGFjdGlvbi5zcGxpdCgnICcpWzBdOyAvLyAnYWRkZWQnLCAnY2xvc2VkJywgZXRjLlxuICAgICAgICAgICAgICAgIGxldCBlbnRyeU5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvcnRBY3Rpb24gPT09ICdhZGRlZCcgfHwgc2hvcnRBY3Rpb24gPT09ICdyZW1vdmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmluY2x1ZGVzKCdzdWItaXNzdWUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1Yklzc3VlTWF0Y2ggPSBhY3Rpb24ubWF0Y2goLyMoXFxkKykvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJJc3N1ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlOYW1lID0gYCR7TmVvLmNhcGl0YWxpemUoc2hvcnRBY3Rpb24pfSBzdWItaXNzdWUgIyR7c3ViSXNzdWVNYXRjaFsxXX1gXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5TmFtZSA9IGAke05lby5jYXBpdGFsaXplKHNob3J0QWN0aW9uKX0gc3ViLWlzc3VlYFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTWF0Y2ggPSBhY3Rpb24ubWF0Y2goL2AoW15gXSspYC8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnRBY3Rpb24gPSBsYWJlbE1hdGNoID8gbGFiZWxNYXRjaFsxXSA6ICdMYWJlbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUgPSBgJHtOZW8uY2FwaXRhbGl6ZShzaG9ydEFjdGlvbil9ICgke3VzZXJ9KWBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5TmFtZSA9IGAke05lby5jYXBpdGFsaXplKHNob3J0QWN0aW9uKX0gKCR7dXNlcn0pYFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnRpbWVsaW5lRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLCAvLyBQYXNzIHJlc29sdmVkIGhleCBjb2xvclxuICAgICAgICAgICAgICAgICAgICBpY29uIDogaWNvbixcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lIDogZW50cnlOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0YWcgIDogJ2V2ZW50J1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgY29sb3Igc3R5bGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSBjb2xvciA/IGBzdHlsZT1cImNvbG9yOiAke2NvbG9yfVwiYCA6ICcnO1xuXG4gICAgICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2lkfVwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWl0ZW0gZXZlbnRcIiBkYXRhLXJlY29yZC1pZD1cIiR7aWR9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtpZH0tdGFyZ2V0XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtYmFkZ2VcIiAke3N0eWxlfT48aSBjbGFzcz1cImZhLXNvbGlkICR7aWNvbn1cIj48L2k+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5lby10aW1lbGluZS11c2VyXCIgaHJlZj1cIiR7cmVwb1VzZXJVcmx9JHt1c2VyfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7dXNlcn08L2E+ICR7Y2xlYW5BY3Rpb259IDxzcGFuIGNsYXNzPVwibmVvLXRpbWVsaW5lLWRhdGVcIj5vbiAke21lLmZvcm1hdFRpbWVzdGFtcChkYXRlKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbW1lbnQgSGVhZGVyOiAjIyMgQHVzZXIgLSAyMDI2LTAxLTExVC4uLlxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKCcjIyMgQCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZXMgXCJ1c2VyXCIgYW5kIFwiMjAyNi0wMS0xMVQuLi5cIiAoSVNPIHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGVyTWF0Y2ggPSBsaW5lLm1hdGNoKC9eIyMjIEAoXFx3KykgLSAoW1xcZFRaOi4tXSspJC8pO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXIgPSBoZWFkZXJNYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBoZWFkZXJNYXRjaFsyXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciB3ZWlyZCBoZWFkZXJzPyB0cmVhdCBhcyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXNlcikgY29tbWVudEJ1Zi5wdXNoKGxpbmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRCdWYucHVzaChsaW5lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoQ29tbWVudCgpOyAvLyBGbHVzaCBsYXN0IGNvbW1lbnRcblxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICByZXR1cm4gaHRtbFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBDYW52YXNXcmFwcGVyICAgIGZyb20gJy4vQ2FudmFzV3JhcHBlci5tanMnO1xuaW1wb3J0IENvbnRyb2xsZXIgICAgICAgZnJvbSAnLi9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMnO1xuaW1wb3J0IFBhZ2VDb250YWluZXIgICAgZnJvbSAnLi9QYWdlQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgU2hhcmVkQ29udGFpbmVyICBmcm9tICcuLi8uLi9zaGFyZWQvY29udGVudC9Db250YWluZXIubWpzJztcbmltcG9ydCBTdGF0ZVByb3ZpZGVyICAgIGZyb20gJy4vTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIFBvcnRhbC52aWV3LnNoYXJlZC5jb250ZW50LkNvbnRhaW5lclxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgU2hhcmVkQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsncG9ydGFsLXRpY2tldHMtbWFpbmNvbnRhaW5lciddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ3BvcnRhbC10aWNrZXRzLW1haW5jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudH0gY29udHJvbGxlcj1NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRyb2xsZXI6IENvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHBhZ2VDb250YWluZXJDb25maWdcbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VDb250YWluZXJDb25maWc6IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgIDogUGFnZUNvbnRhaW5lcixcbiAgICAgICAgICAgIGJ1dHRvblRleHRGaWVsZDogJ2lkJyxcbiAgICAgICAgICAgIGNvbnRlbnRDb25maWcgIDoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogQ2FudmFzV3JhcHBlclxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnN0YXRlLlByb3ZpZGVyfSBzdGF0ZVByb3ZpZGVyPU1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGVQcm92aWRlcjogU3RhdGVQcm92aWRlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdHJlZUNvbmZpZz17ZGlzcGxheUZpZWxkOid0cmVlTm9kZU5hbWUnfVxuICAgICAgICAgKi9cbiAgICAgICAgdHJlZUNvbmZpZzoge1xuICAgICAgICAgICAgZGlzcGxheUZpZWxkOiAndHJlZU5vZGVOYW1lJ1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyKTtcbiIsImltcG9ydCBDb250cm9sbGVyIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJDb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByb3V0ZXNcbiAgICAgICAgICovXG4gICAgICAgIHJvdXRlczoge1xuICAgICAgICAgICAgJy9uZXdzL3RpY2tldHMnICAgICAgICAgIDogJ29uUm91dGVEZWZhdWx0JyxcbiAgICAgICAgICAgICcvbmV3cy90aWNrZXRzL3sqaXRlbUlkfSc6ICdvblJvdXRlSXRlbSdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtXG4gICAgICovXG4gICAgbmF2aWdhdGVUbyhpdGVtKSB7XG4gICAgICAgIE5lby5NYWluLnNldFJvdXRlKHtcbiAgICAgICAgICAgIHZhbHVlICAgOiBgL25ld3MvdGlja2V0cy8ke2l0ZW19YCxcbiAgICAgICAgICAgIHdpbmRvd0lkOiB0aGlzLmNvbXBvbmVudC53aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25JbnRlcnNlY3QoZGF0YSkge1xuICAgICAgICBsZXQgcGFuZWwgICAgPSB0aGlzLmdldFJlZmVyZW5jZSgncGFnZS1zZWN0aW9ucy1jb250YWluZXInKSxcbiAgICAgICAgICAgIGxpc3QgICAgID0gcGFuZWwubGlzdCxcbiAgICAgICAgICAgIHJlY29yZElkID0gZGF0YS5kYXRhLnJlY29yZElkLFxuICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgIGlmIChyZWNvcmRJZCAmJiAhbGlzdC5pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgcmVjb3JkID0gbGlzdC5zdG9yZS5nZXQocmVjb3JkSWQpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zZWxlY3Rpb25Nb2RlbC5zZWxlY3QocmVjb3JkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk5leHRQYWdlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRlVG8odGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSgnbmV4dFBhZ2VSZWNvcmQnKS5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUGFnZVNlY3Rpb25zVG9nZ2xlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgncGFnZS1zZWN0aW9ucy1jb250YWluZXInKS50b2dnbGVDbHMoJ25lby1leHBhbmRlZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblByZXZpb3VzUGFnZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvKHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoJ3ByZXZpb3VzUGFnZVJlY29yZCcpLmlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFJvdXRlSWQoKSB7XG4gICAgICAgIGxldCBzdG9yZSAgICAgPSB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgndHJlZScpLFxuICAgICAgICAgICAgcm9vdENvdW50ID0gMCxcbiAgICAgICAgICAgIGkgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgPSBzdG9yZS5nZXRDb3VudCgpLFxuICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldEF0KGkpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkLnBhcmVudElkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm9vdENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICBpZiAocm9vdENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5nZXRBdChpICsgMSk/LmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldEF0KDEpPy5pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3V0ZURlZmF1bHQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RvcmUgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3RyZWUnKTtcblxuICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIG1lLm5hdmlnYXRlVG8obWUuZ2V0RGVmYXVsdFJvdXRlSWQoKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JlLm9uKHtcbiAgICAgICAgICAgICAgICBsb2FkIDogKCkgPT4gbWUubmF2aWdhdGVUbyhtZS5nZXREZWZhdWx0Um91dGVJZCgpKSxcbiAgICAgICAgICAgICAgICBkZWxheTogMTAsXG4gICAgICAgICAgICAgICAgb25jZSA6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLml0ZW1JZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFzeW5jIG9uUm91dGVJdGVtKHtpdGVtSWR9LCB2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RhdGVQcm92aWRlciA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKSxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICAgPSBzdGF0ZVByb3ZpZGVyLmdldFN0b3JlKCd0cmVlJyksXG4gICAgICAgICAgICB0cmVlICAgICAgICAgID0gbWUuZ2V0UmVmZXJlbmNlKCd0cmVlJyk7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZSB0cmVlIGhhcyB0aGUgY29ycmVjdCByb3V0ZSBwcmVmaXggZm9yIHRoaXMgY29udHJvbGxlciBjb250ZXh0XG4gICAgICAgIGlmICh0cmVlLnJvdXRlUHJlZml4ICE9PSAnL25ld3MvdGlja2V0cycpIHtcbiAgICAgICAgICAgIHRyZWUucm91dGVQcmVmaXggPSAnL25ld3MvdGlja2V0cydcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlUHJvdmlkZXIuZGF0YS5jdXJyZW50UGFnZVJlY29yZCA9IHN0b3JlLmdldChpdGVtSWQpO1xuXG4gICAgICAgICAgICBpZiAoIW9sZFZhbHVlPy5oYXNoU3RyaW5nPy5zdGFydHNXaXRoKCcvbmV3cy90aWNrZXRzJykpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0cmVlLmV4cGFuZEFuZFNjcm9sbFRvSXRlbShpdGVtSWQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyZWUuZXhwYW5kUGFyZW50cyhpdGVtSWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0b3JlLmdldENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBzZWxlY3QoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcmUub24oe1xuICAgICAgICAgICAgICAgIGxvYWQgOiBzZWxlY3QsXG4gICAgICAgICAgICAgICAgZGVsYXk6IDEwLFxuICAgICAgICAgICAgICAgIG9uY2UgOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblNpZGVOYXZUb2dnbGVCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZ2V0UmVmZXJlbmNlKCdzaWRlbmF2LWNvbnRhaW5lcicpLnRvZ2dsZUNscygnbmVvLWV4cGFuZGVkJylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXJDb250cm9sbGVyKTtcbiIsImltcG9ydCBUaWNrZXRMYWJlbHNTdG9yZSAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zdG9yZS9UaWNrZXRMYWJlbHMubWpzJztcbmltcG9ydCBUaWNrZXRUaW1lbGluZVNlY3Rpb25zU3RvcmUgIGZyb20gJy4uLy4uLy4uL3N0b3JlL1RpY2tldFRpbWVsaW5lU2VjdGlvbnMubWpzJztcbmltcG9ydCBUaWNrZXRzU3RvcmUgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3N0b3JlL1RpY2tldHMubWpzJztcbmltcG9ydCBTdGF0ZVByb3ZpZGVyICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NyYy9zdGF0ZS9Qcm92aWRlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXJcbiAqIEBleHRlbmRzIE5lby5zdGF0ZS5Qcm92aWRlclxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyU3RhdGVQcm92aWRlciBleHRlbmRzIFN0YXRlUHJvdmlkZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBkYXRhLmNvdW50UGFnZXM9bnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb3VudFBhZ2VzOiBudWxsLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gZGF0YS5jb3VudFBhZ2VzPW51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY291bnRTZWN0aW9uczogbnVsbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHJlY29yZCB3aGljaCBnZXRzIHNob3duIGFzIHRoZSBjb250ZW50IHBhZ2VcbiAgICAgICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YS5jdXJyZW50UmVjb3JkPW51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY3VycmVudFBhZ2VSZWNvcmQ6IG51bGwsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByZWNvcmQgd2hpY2ggZ2V0cyBzaG93biBhcyB0aGUgY29udGVudCBwYWdlXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGEubmV4dFBhZ2VSZWNvcmQ9bnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBuZXh0UGFnZVJlY29yZDogbnVsbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHJlY29yZCB3aGljaCBnZXRzIHNob3duIGFzIHRoZSBjb250ZW50IHBhZ2VcbiAgICAgICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YS5wcmV2aW91c1BhZ2VSZWNvcmQ9bnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcmV2aW91c1BhZ2VSZWNvcmQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3RvcmVzXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZXM6IHtcbiAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgIGF1dG9Mb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBUaWNrZXRMYWJlbHNTdG9yZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBUaWNrZXRUaW1lbGluZVNlY3Rpb25zU3RvcmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmVlOiB7XG4gICAgICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbW9kdWxlICA6IFRpY2tldHNTdG9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgb25EYXRhUHJvcGVydHlDaGFuZ2Uoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIub25EYXRhUHJvcGVydHlDaGFuZ2Uoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NvdW50U2VjdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5jb21wb25lbnQuZ2V0UmVmZXJlbmNlKCdwYWdlLXNlY3Rpb25zLWNvbnRhaW5lcicpPy50b2dnbGVDbHMoJ25lby1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbnRQYWdlUmVjb3JkJzoge1xuICAgICAgICAgICAgICAgIGxldCB7ZGF0YX0gICAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgICAgICAgICAge2NvdW50UGFnZXN9ICAgICAgID0gZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUgICAgICAgICAgICAgID0gbWUuZ2V0U3RvcmUoJ3RyZWUnKSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggICAgICAgICAgICAgID0gc3RvcmUuaW5kZXhPZih2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIG5leHRQYWdlUmVjb3JkICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUGFnZVJlY29yZCA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGksIHJlY29yZDtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBsb2dpYyBhc3N1bWVzIHRoYXQgdGhlIHRyZWUgc3RvcmUgaXMgc29ydGVkXG4gICAgICAgICAgICAgICAgZm9yIChpPWluZGV4LTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldEF0KGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaXNMZWFmICYmICFtZS5yZWNvcmRJc0hpZGRlbihyZWNvcmQsIHN0b3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNQYWdlUmVjb3JkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnNldERhdGEoe3ByZXZpb3VzUGFnZVJlY29yZH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxvZ2ljIGFzc3VtZXMgdGhhdCB0aGUgdHJlZSBzdG9yZSBpcyBzb3J0ZWRcbiAgICAgICAgICAgICAgICBmb3IgKGk9aW5kZXgrMTsgaSA8IGNvdW50UGFnZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXRBdChpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiAmJiAhbWUucmVjb3JkSXNIaWRkZW4ocmVjb3JkLCBzdG9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQYWdlUmVjb3JkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnNldERhdGEoe25leHRQYWdlUmVjb3JkfSk7XG5cbiAgICAgICAgICAgICAgICBtZS5jb21wb25lbnQuZ2V0UmVmZXJlbmNlKCdzaWRlbmF2LWNvbnRhaW5lcicpPy50b2dnbGVDbHMoJ25lby1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gY2hlY2sgdGhlIHBhcmVudC1ub2RlIGNoYWluIGluc2lkZSB0aGUgdHJlZS5cbiAgICAgKiA9PiBBbnkgaGlkZGVuIHBhcmVudC1ub2RlIHJlc3VsdHMgaW4gYSBoaWRkZW4gcmVjb3JkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLlN0b3JlfSBzdG9yZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHJlY29yZElzSGlkZGVuKHJlY29yZCwgc3RvcmUpIHtcbiAgICAgICAgaWYgKHJlY29yZC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLnBhcmVudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRJc0hpZGRlbihzdG9yZS5nZXQocmVjb3JkLnBhcmVudElkKSwgc3RvcmUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyKTtcbiIsImltcG9ydCBQYWdlQ29udGFpbmVyIGZyb20gJy4uLy4uL3NoYXJlZC9jb250ZW50L1BhZ2VDb250YWluZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlBhZ2VDb250YWluZXJcbiAqIEBleHRlbmRzIFBvcnRhbC52aWV3LnNoYXJlZC5jb250ZW50LlBhZ2VDb250YWluZXJcbiAqL1xuY2xhc3MgVGlja2V0UGFnZUNvbnRhaW5lciBleHRlbmRzIFBhZ2VDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlBhZ2VDb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5QYWdlQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3R5bGU9e2ZsZXg6MSxvdmVyZmxvd1k6J2F1dG8nLHBvc2l0aW9uOidyZWxhdGl2ZSd9XG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZToge2ZsZXg6IDEsIG92ZXJmbG93WTogJ2F1dG8nLCBwb3NpdGlvbjogJ3JlbGF0aXZlJ31cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldFBhZ2VDb250YWluZXIpO1xuIiwiaW1wb3J0IENhbnZhcyBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50L0NhbnZhcy5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFRoZSBcIkNvb3JkaW5hdG9yXCIgY29tcG9uZW50IGZvciB0aGUgTmV1cmFsIFRpbWVsaW5lLCBicmlkZ2luZyB0aGUgQXBwIFdvcmtlciBhbmQgQ2FudmFzIFdvcmtlci5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGEgdHJhbnNwYXJlbnQgY2FudmFzIG92ZXJsYXkgb24gdG9wIG9mIHRoZSBUaWNrZXQgTGlzdC4gSXQgaXMgcmVzcG9uc2libGUgZm9yOlxuICogMS4gKipEYXRhIEJyaWRnZSoqOiBMaXN0ZW5pbmcgdG8gdGhlIGBzZWN0aW9uc2Agc3RvcmUgYW5kIHBhc3NpbmcgdGlja2V0IGRhdGEgdG8gdGhlIGBUaWNrZXRDYW52YXNgIChTaGFyZWRXb3JrZXIpLlxuICogMi4gKipWaXN1YWwgQWxpZ25tZW50Kio6IENhbGN1bGF0aW5nIHRoZSBwcmVjaXNlIERPTSBwb3NpdGlvbnMgb2YgVGlja2V0IEF2YXRhcnMvQmFkZ2VzIHRvIGVuc3VyZSB0aGVcbiAqICAgIGNhbnZhcyBub2RlcyBhbGlnbiBwZXJmZWN0bHkgd2l0aCB0aGUgSFRNTCBjb250ZW50LlxuICogMy4gKipMaWZlY3ljbGUgTWFuYWdlbWVudCoqOiBpbml0aWFsaXppbmcgdGhlIG9mZnNjcmVlbiBjYW52YXMgdHJhbnNmZXIgYW5kIGhhbmRsaW5nIHJlc2l6ZSBldmVudHMuXG4gKlxuICogSXQgdXNlcyB0aGUgYFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzYCBzaW5nbGV0b24gKHZpYSBSZW1vdGUgTWV0aG9kIEFjY2VzcykgdG8gZHJpdmUgdGhlIGFjdHVhbCBhbmltYXRpb24uXG4gKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5UaW1lbGluZUNhbnZhc1xuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5DYW52YXNcbiAqL1xuY2xhc3MgVGltZWxpbmVDYW52YXMgZXh0ZW5kcyBDYW52YXMge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVsYXlhYmxlXG4gICAgICovXG4gICAgc3RhdGljIGRlbGF5YWJsZSA9IHtcbiAgICAgICAgZW5zdXJlRmluYWxBbGlnbm1lbnQ6IHtcbiAgICAgICAgICAgIHR5cGUgOiAnZGVib3VuY2UnLFxuICAgICAgICAgICAgdGltZXI6IDMwMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuVGltZWxpbmVDYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5UaW1lbGluZUNhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxpc3RlbmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICByZXNpemU6ICdvblJlc2l6ZSdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7dGFnOiAnZGl2JywgY2xzOiBbJ25lby10aWNrZXQtdGltZWxpbmUtd3JhcHBlciddLCBzdHlsZToge3dpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnfSwgY246IFtcbiAgICAgICAgICAgIHt0YWc6ICdjYW52YXMnLCBzdHlsZToge3dpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnfX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNhbnZhc0lkPW51bGxcbiAgICAgKi9cbiAgICBjYW52YXNJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0NhbnZhc1JlYWR5PWZhbHNlXG4gICAgICovXG4gICAgaXNDYW52YXNSZWFkeSA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IGxhc3RSZWNvcmRzPW51bGxcbiAgICAgKi9cbiAgICBsYXN0UmVjb3JkcyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZW5zdXJlRmluYWxBbGlnbm1lbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmxhc3RSZWNvcmRzKSB7XG4gICAgICAgICAgICBtZS5vblRpbWVsaW5lRGF0YUxvYWQobWUubGFzdFJlY29yZHMsIHRydWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgaG9vayB0aGF0IHJ1bnMgb25jZSB0aGUgYE9mZnNjcmVlbkNhbnZhc2AgaGFzIGJlZW4gdHJhbnNmZXJyZWQgdG8gdGhlIENhbnZhcyBXb3JrZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZDpcbiAgICAgKiAxLiBJbXBvcnRzIHRoZSBgVGlja2V0Q2FudmFzYCBsb2dpYyBpbnRvIHRoZSBDYW52YXMgV29ya2VyIGNvbnRleHQuXG4gICAgICogMi4gSW5pdGlhbGl6ZXMgdGhlIGdyYXBoIGluIHRoZSB3b3JrZXIgdmlhIFJlbW90ZSBNZXRob2QgQWNjZXNzIChgaW5pdEdyYXBoYCkuXG4gICAgICogMy4gU2V0cyB1cCBhIGBSZXNpemVPYnNlcnZlcmAgdG8ga2VlcCB0aGUgY2FudmFzIHNpemUgc3luY2VkIHdpdGggdGhlIERPTS5cbiAgICAgKiA0LiBUcmlnZ2VycyB0aGUgaW5pdGlhbCBkYXRhIGxvYWQgaWYgc3RvcmUgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldE9mZnNjcmVlblJlZ2lzdGVyZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGxvZ2ljIGlzIGxvYWRlZCBpbiB0aGUgd29ya2VyXG4gICAgICAgICAgICBhd2FpdCBQb3J0YWwuY2FudmFzLkhlbHBlci5pbXBvcnRUaWNrZXRDYW52YXMoKTtcblxuICAgICAgICAgICAgLy8gRGlyZWN0IFJlbW90ZSBNZXRob2QgQWNjZXNzIGNhbGxcbiAgICAgICAgICAgIGF3YWl0IFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzLmluaXRHcmFwaCh7Y2FudmFzSWQ6IG1lLmdldENhbnZhc0lkKCksIHdpbmRvd0lkOiBtZS53aW5kb3dJZH0pO1xuXG4gICAgICAgICAgICBtZS5pc0NhbnZhc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gUmVnaXN0ZXIgUmVzaXplT2JzZXJ2ZXIgZm9yIHRoZSBjYW52YXMgd3JhcHBlciAobWUuaWQpXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5SZXNpemVPYnNlcnZlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWwgc2l6aW5nXG4gICAgICAgICAgICBhd2FpdCBtZS51cGRhdGVTaXplKCk7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWwgbG9hZCBjaGVja1xuICAgICAgICAgICAgbGV0IHN0b3JlID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdzZWN0aW9ucycpO1xuXG4gICAgICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5vblRpbWVsaW5lRGF0YUxvYWQoc3RvcmUuaXRlbXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmlzQ2FudmFzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFN0b3AgdGhlIHdvcmtlciBsb29wIHRvIHByZXZlbnQgXCJab21iaWUgQ2FudmFzXCIgQ1BVIHVzYWdlXG4gICAgICAgICAgICBhd2FpdCBQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhcy5jbGVhckdyYXBoKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIHJldHVybiB0aGUgaW5uZXIgY2FudmFzIElEXG4gICAgICovXG4gICAgZ2V0Q2FudmFzSWQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jYW52YXNJZCkge1xuICAgICAgICAgICAgbWUuY2FudmFzSWQgPSBtZS52ZG9tLmNuWzBdLmlkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLmNhbnZhc0lkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0b3JlID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdzZWN0aW9ucycpO1xuXG4gICAgICAgIHN0b3JlLm9uKCdsb2FkJywgbWUub25UaW1lbGluZURhdGFMb2FkLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uUmVzaXplKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNhbnZhcyBzaXplIGluIHRoZSB3b3JrZXJcbiAgICAgICAgYXdhaXQgbWUudXBkYXRlU2l6ZShkYXRhLmNvbnRlbnRSZWN0KTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGNhY2hlZCByZWNvcmRzLCByZS1jYWxjdWxhdGUgbm9kZSBwb3NpdGlvbnNcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29udGFpbmVyIGRpbWVuc2lvbnMgKGFuZCBsaWtlbHkgcmVsYXRpdmUgcG9zaXRpb25zKSBoYXZlIGNoYW5nZWQuXG4gICAgICAgIGlmIChtZS5sYXN0UmVjb3Jkcykge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1mZXRjaCByZWN0cyBpbnN0YW50bHksIGJ1dCBpdCdzIHNhZmVyIHRvIGRvIHNvXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgYWxpZ25tZW50IHdpdGggdGhlIG5ldyBsYXlvdXQuXG4gICAgICAgICAgICBhd2FpdCBtZS5vblRpbWVsaW5lRGF0YUxvYWQobWUubGFzdFJlY29yZHMsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBEZWJvdW5jZWQgY2hlY2sgdG8gZW5zdXJlIHRoZSBjYW52YXMgaXMgYWxpZ25lZCBhZnRlciBhbnkgdHJhbnNpdGlvbnMgc2V0dGxlXG4gICAgICAgICAgICBtZS5lbnN1cmVGaW5hbEFsaWdubWVudCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29yZSBcIkFsaWdubWVudCBFbmdpbmVcIiBvZiB0aGUgdGltZWxpbmUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBzeW5jaHJvbml6ZXMgdGhlIENhbnZhcyBub2RlcyB3aXRoIHRoZSBET00gZWxlbWVudHMgKEF2YXRhcnMvQmFkZ2VzKS5cbiAgICAgKlxuICAgICAqICoqU3RyYXRlZ3k6KipcbiAgICAgKiAxLiAqKlRhcmdldGluZyoqOiBJdCB1c2VzIHRoZSBgLXRhcmdldGAgSUQgc3VmZml4IHRvIGZpbmQgdGhlIHNwZWNpZmljIERPTSBlbGVtZW50cyAoQXZhdGFycykgd2l0aGluIHRoZSB0aWNrZXQgbGlzdC5cbiAgICAgKiAyLiAqKk1lYXN1cmVtZW50Kio6IEl0IGZldGNoZXMgdGhlIGBET01SZWN0YCBmb3IgZXZlcnkgdGFyZ2V0IHRvIGdldCBpdHMgZXhhY3Qgc2NyZWVuIHBvc2l0aW9uLlxuICAgICAqIDMuICoqVHJhbnNsYXRpb24qKjogSXQgY29udmVydHMgdGhlc2Ugc2NyZWVuIGNvb3JkaW5hdGVzIGludG8gQ2FudmFzLWxvY2FsIGNvb3JkaW5hdGVzLlxuICAgICAqIDQuICoqSGFuZG9mZioqOiBJdCBwYWNrYWdlcyB0aGlzIGdlb21ldHJpYyBkYXRhICh4LCB5LCByYWRpdXMsIGNvbG9yKSBhbmQgc2VuZHMgaXQgdG8gdGhlXG4gICAgICogICAgYFRpY2tldENhbnZhc2Agd29ya2VyIHRvIHVwZGF0ZSB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxPYmplY3R9IHJlY29yZHMgQXJyYXkgb2YgcmVjb3JkcyBvciBTdG9yZSBsb2FkIGV2ZW50IG9iamVjdCB7aXRlbXM6IFsuLi5dfVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUmVzaXplPWZhbHNlXVxuICAgICAqL1xuICAgIGFzeW5jIG9uVGltZWxpbmVEYXRhTG9hZChyZWNvcmRzLCBpc1Jlc2l6ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gSGFuZGxlIFN0b3JlICdsb2FkJyBldmVudCBzaWduYXR1cmU6IGZpcmUoJ2xvYWQnLCB7aXRlbXM6IFsuLi5dfSlcbiAgICAgICAgaWYgKHJlY29yZHMgJiYgIUFycmF5LmlzQXJyYXkocmVjb3JkcykgJiYgcmVjb3Jkcy5pdGVtcykge1xuICAgICAgICAgICAgcmVjb3JkcyA9IHJlY29yZHMuaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWNvcmRzKSkge1xuICAgICAgICAgICAgLy8gU2FmZXR5IGNoZWNrIGlmIHJlY29yZHMgaXMgc3RpbGwgaW52YWxpZFxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLmlzQ2FudmFzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc2V0ID0gIWlzUmVzaXplO1xuXG4gICAgICAgIC8vIFNtYXJ0IENoZWNrOiBJZiBpdCdzIGEgc3RvcmUgbG9hZCAocmVzZXQ9dHJ1ZSkgQlVUIHRoZSB0aWNrZXQgSUQgaXMgdGhlIHNhbWUsXG4gICAgICAgIC8vIGl0J3MgYSBkYXRhIHJlZnJlc2ggKGUuZy4gY29tbWVudCBhZGRlZCksIHNvIHdlIHNob3VsZCBOT1QgcmVzZXQgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgaWYgKHJlc2V0ICYmIG1lLmxhc3RSZWNvcmRzICYmIHJlY29yZHNbMF0/LmlkID09PSBtZS5sYXN0UmVjb3Jkc1swXT8uaWQpIHtcbiAgICAgICAgICAgIHJlc2V0ID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmxhc3RSZWNvcmRzID0gcmVjb3JkcztcblxuICAgICAgICBsZXQgaWRzID0gcmVjb3Jkcy5tYXAociA9PiBgJHtyLmlkfS10YXJnZXRgKSxcbiAgICAgICAgICAgIHJlY3RzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGZXRjaCBET00gcmVjdHMgZm9yIHRoZSBNQVJLRVJTIChBdmF0YXJzL0JhZGdlcyksIG5vdCB0aGUgY29udGFpbmVyc1xuICAgICAgICAgICAgcmVjdHMgPSBhd2FpdCBtZS53YWl0Rm9yRG9tUmVjdCh7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHM6IDIwLFxuICAgICAgICAgICAgICAgIGRlbGF5ICAgOiA1MCxcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogaWRzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1lLmxhc3RSZWNvcmRzICE9PSByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGdvdCB2YWxpZCByZWN0cyAoYXQgbGVhc3Qgb25lKVxuICAgICAgICAgICAgbGV0IGhhc1JlY3RzID0gcmVjdHMgJiYgcmVjdHMuc29tZShyID0+IHIpO1xuXG4gICAgICAgICAgICBpZiAoIWhhc1JlY3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uIGZpcnN0IHZhbGlkIGRhdGEgbG9hZCAobm90IHJlc2l6ZSksIGVuc3VyZSBzaXplIGlzIHN5bmNlZFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBjb250ZW50IG1pZ2h0IGhhdmUgcHVzaGVkIHRoZSBjb250YWluZXIgaGVpZ2h0LlxuICAgICAgICAgICAgaWYgKCFpc1Jlc2l6ZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnVwZGF0ZVNpemUoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY2FudmFzUmVjdCA9IGF3YWl0IG1lLmdldERvbVJlY3QobWUuZ2V0Q2FudmFzSWQoKSksXG4gICAgICAgICAgICAgICAgbm9kZXMgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0WSAgICAgPSAwO1xuXG4gICAgICAgICAgICBpZHMuZm9yRWFjaCgodGFyZ2V0SWQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgICA9IHJlY3RzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gcmVjb3Jkc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQUkVDSVNFIENFTlRFUklOR1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgJ3JlY3QnIGlzIHRoZSBhY3R1YWwgYXZhdGFyL2JhZGdlLlxuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmVjdC5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVkgID0gcmVjdC55IC0gY2FudmFzUmVjdC55ICsgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVggID0gcmVjdC54IC0gY2FudmFzUmVjdC54ICsgKHJlY3Qud2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc3RpbmN0IHBhZGRpbmcgZm9yIE9yYml0IGVmZmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZhdGFycyAofjQwcHgpIGdldCBtb3JlIGJyZWF0aGluZyByb29tIHRoYW4gQmFkZ2VzICh+MjhweClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSByZWN0LmhlaWdodCA+IDMyID8gNiA6IDM7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA6IHJlY29yZC5jb2xvciwgLy8gUGFzcyBIZXggQ29sb3IgKGUuZy4gI2ZmMDAwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgIDogcmVjb3JkLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBvZmZzZXQgKyBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgeSAgICAgOiBub2RlWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHggICAgIDogbm9kZVhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBzdGFydFkgb2YgdGhlIGxpbmUgdG8gdGhlIGZpcnN0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFkgPSBub2RlWVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzLnVwZGF0ZUdyYXBoRGF0YSh7bm9kZXMsIHJlc2V0LCBzdGFydFl9KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaW1lbGluZUNhbnZhcyB1cGRhdGUgZmFpbGVkJywgZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHJlY3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTaXplKHJlY3QpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC53aWR0aCA9PT0gMCB8fCByZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmVjdCA9IGF3YWl0IG1lLndhaXRGb3JEb21SZWN0KHtpZDogbWUuZ2V0Q2FudmFzSWQoKX0pXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhcy51cGRhdGVTaXplKHt3aWR0aDogcmVjdC53aWR0aCwgaGVpZ2h0OiByZWN0LmhlaWdodH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaW1lbGluZUNhbnZhcyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9