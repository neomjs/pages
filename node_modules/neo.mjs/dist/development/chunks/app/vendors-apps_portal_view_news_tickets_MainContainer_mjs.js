"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_portal_view_news_tickets_MainContainer_mjs"],{

/***/ "./apps/portal/model/Ticket.mjs"
/*!**************************************!*\
  !*** ./apps/portal/model/Ticket.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.Ticket
 * @extends Neo.data.Model
 */
class Ticket extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.Ticket'
         * @protected
         */
        className: 'Portal.model.Ticket',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name        : 'collapsed',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name: 'id',
            type: 'String'
        }, {
            name        : 'isLeaf',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name        : 'parentId',
            type        : 'String',
            defaultValue: null
        }, {
            name: 'path', // "resources/content/issues/issue-1234.md"
            type: 'String'
        }, {
            name: 'title', // "Fix elusive bug in Grid"
            type: 'String'
        }, {
            // Computed field for TreeList display
            name: 'treeNodeName',
            type: 'html',
            /**
             * @param {Object}  data
             * @param {String}  data.id
             * @param {Boolean} data.isLeaf
             * @param {String}  data.title
             * @returns {String}
             */
            calculate({id, isLeaf, title}) {
                return isLeaf ? `<b>${id}</b> ${title}` : id
            }
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Ticket));


/***/ },

/***/ "./apps/portal/model/TicketLabel.mjs"
/*!*******************************************!*\
  !*** ./apps/portal/model/TicketLabel.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.TicketLabel
 * @extends Neo.data.Model
 */
class TicketLabel extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketLabel'
         * @protected
         */
        className: 'Portal.model.TicketLabel',
        /**
         * @member {Object[]} fields
         * @protected
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'description',
            type: 'String'
        }, {
            name: 'name',
            type: 'String'
        }, {
            name: 'textColor',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabel));


/***/ },

/***/ "./apps/portal/model/TicketTimelineSection.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/model/TicketTimelineSection.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSection.mjs */ "./apps/portal/model/ContentSection.mjs");


/**
 * @class Portal.model.TicketTimelineSection
 * @extends Portal.model.ContentSection
 */
class TicketTimelineSection extends _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketTimelineSection'
         * @protected
         */
        className: 'Portal.model.TicketTimelineSection',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'icon',
            type: 'String'
        }, {
            name: 'image',
            type: 'String'
        }, {
            name: 'sourceId',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSection));


/***/ },

/***/ "./apps/portal/store/TicketLabels.mjs"
/*!********************************************!*\
  !*** ./apps/portal/store/TicketLabels.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/TicketLabel.mjs */ "./apps/portal/model/TicketLabel.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Portal.store.TicketLabels
 * @extends Neo.data.Store
 */
class TicketLabels extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketLabels'
         * @protected
         */
        className: 'Portal.store.TicketLabels',
        /**
         * @member {String} keyProperty='name'
         * @protected
         */
        keyProperty: 'name',
        /**
         * @member {Neo.data.Model} model=TicketLabel
         * @protected
         */
        model: _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/labels.json'
         * @protected
         */
        url: '../../apps/portal/resources/data/labels.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabels));


/***/ },

/***/ "./apps/portal/store/TicketTimelineSections.mjs"
/*!******************************************************!*\
  !*** ./apps/portal/store/TicketTimelineSections.mjs ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSections.mjs */ "./apps/portal/store/ContentSections.mjs");
/* harmony import */ var _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/TicketTimelineSection.mjs */ "./apps/portal/model/TicketTimelineSection.mjs");



/**
 * @class Portal.store.TicketTimelineSections
 * @extends Portal.store.ContentSections
 */
class TicketTimelineSections extends _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketTimelineSections'
         * @protected
         */
        className: 'Portal.store.TicketTimelineSections',
        /**
         * @member {Neo.data.Model} model=TicketTimelineSection
         * @reactive
         */
        model: _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSections));


/***/ },

/***/ "./apps/portal/store/Tickets.mjs"
/*!***************************************!*\
  !*** ./apps/portal/store/Tickets.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Ticket.mjs */ "./apps/portal/model/Ticket.mjs");



/**
 * @class Portal.store.Tickets
 * @extends Neo.data.Store
 */
class Tickets extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.Tickets'
         * @protected
         */
        className: 'Portal.store.Tickets',
        /**
         * @member {Neo.data.Model} model=TicketModel
         * @reactive
         */
        model: _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/tickets.json'
         */
        url: '../../apps/portal/resources/data/tickets.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tickets));


/***/ },

/***/ "./apps/portal/view/news/tickets/CanvasWrapper.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/CanvasWrapper.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./apps/portal/view/news/tickets/Component.mjs");
/* harmony import */ var _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TimelineCanvas.mjs */ "./apps/portal/view/news/tickets/TimelineCanvas.mjs");




/**
 * @class Portal.view.news.tickets.CanvasWrapper
 * @extends Neo.container.Base
 */
class CanvasWrapper extends _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.CanvasWrapper'
         * @protected
         */
        className: 'Portal.view.news.tickets.CanvasWrapper',
        /**
         * @member {String[]} cls=['portal-canvas-wrapper']
         */
        cls: ['portal-canvas-wrapper'],
        /**
         * @member {Neo.component.Base|null} contentComponent=ContentComponent
         */
        contentComponent: _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={minHeight:'100%',overflow:'visible',position:'relative'}
         */
        style: {minHeight: '100%', overflow: 'visible', position: 'relative'}
    }

    construct(config) {
        let me = this;

        config.items = [{
            module   : _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            reference: 'timeline-canvas',
            style : {
                position     : 'absolute',
                top          : 0,
                left         : 0,
                width        : '100%',
                height       : '100%',
                zIndex       : 2,
                pointerEvents: 'none'
            }
        }, {
            module: config.contentComponent || me.contentComponent,
            style : {
                position: 'relative',
                zIndex  : 1
            },
            listeners: {
                toggleSummary: me.onToggleSummary,
                scope        : me
            }
        }];

        super.construct(config);
    }

    /**
     *
     */
    onToggleSummary() {
        let canvas = this.getReference('timeline-canvas');

        if (canvas?.lastRecords) {
            canvas.onTimelineDataLoad(canvas.lastRecords, true)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CanvasWrapper));


/***/ },

/***/ "./apps/portal/view/news/tickets/Component.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/view/news/tickets/Component.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/content/Component.mjs */ "./apps/portal/view/shared/content/Component.mjs");
/* harmony import */ var _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../node_modules/marked/lib/marked.esm.js */ "./node_modules/marked/lib/marked.esm.js");



const
    regexFrontMatter   = /^---\n([\s\S]*?)\n---\n/,
    regexH1            = /(<h1[^>]*>.*?<\/h1>)/,
    regexTicketLink    = /(\d{4,})/,
    regexTimeline      = /## Timeline\s*\n([\s\S]*)/,
    regexTimelineEvent = /^- ([\dTZ:.-]+) @(\w+) (.*)$/,
    regexCommit        = /\b([0-9a-f]{7,40})\b/g;

/**
 * @summary The "Markdown Transformer" for GitHub Tickets.
 *
 * This component extends the standard ContentComponent to provide specialized rendering for GitHub Issues.
 * Its primary responsibility is to parse the raw Markdown content (which includes custom Frontmatter and
 * a pre-generated Timeline section) and transform it into a rich, interactive HTML structure.
 *
 * **Key Responsibilities:**
 * 1. **Parsing Pipeline**: Extracts Frontmatter, Body, and the custom "Timeline" section from the raw Markdown.
 * 2. **Rich Rendering**: Generates HTML for Status Badges, Labels, Commit Links, and User Mentions.
 * 3. **Data Extraction**: As a side effect of rendering, it extracts structured data (`me.timelineData`)
 *    representing every timeline event (comment, label change, close, etc.). This data is then
 *    pushed to the `sections` store to drive the `TimelineCanvas` visualization.
 *
 * @class Portal.view.news.tickets.Component
 * @extends Portal.view.shared.content.Component
 */
class Component extends _shared_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.Component'
         * @protected
         */
        className: 'Portal.view.news.tickets.Component',
        /**
         * @member {String[]} cls=['portal-news-tickets-component']
         */
        cls: ['portal-news-tickets-component'],
        /**
         * @member {String} commitsUrl='https://github.com/neomjs/neo/commit/'
         */
        commitsUrl: 'https://github.com/neomjs/neo/commit/',
        /**
         * @member {Object} domListeners
         */
        domListeners: {
            resize: 'onResize'
        },
        /**
         * @member {String} repoUserUrl='https://github.com/'
         */
        repoUserUrl: 'https://github.com/',
        /**
         * @member {Boolean} updateSectionsStore=false
         */
        updateSectionsStore: false
    }

    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatHistory=null
     */
    #dateTimeFormatHistory = null
    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatToday=null
     */
    #dateTimeFormatToday = null
    /**
     * Temporary storage for the structured timeline data extracted during the parsing phase.
     * This array is populated by `renderTimeline` and `modifyMarkdown` and then assigned
     * to the `sections` store to drive the Canvas visualization.
     * @member {Object[]} timelineData=null
     * @private
     */
    timelineData = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.getStateProvider().setData('contentComponentId', this.id)
    }

    /**
     * @param {String} isoString
     * @returns {String}
     */
    formatTimestamp(isoString) {
        if (!isoString) return '';

        let me      = this,
            date    = new Date(isoString),
            now     = new Date(),
            isToday = date.toDateString() === now.toDateString();

        if (isToday) {
            if (!me.#dateTimeFormatToday) {
                me.#dateTimeFormatToday = new Intl.DateTimeFormat('default', {
                    hour  : 'numeric',
                    minute: 'numeric'
                })
            }

            return me.#dateTimeFormatToday.format(date)
        }

        if (!me.#dateTimeFormatHistory) {
            me.#dateTimeFormatHistory = new Intl.DateTimeFormat('default', {
                day   : 'numeric',
                hour  : 'numeric',
                minute: 'numeric',
                month : 'short',
                year  : 'numeric'
            })
        }

        return me.#dateTimeFormatHistory.format(date)
    }

    /**
     * @param {Object} data
     * @returns {String}
     */
    frontMatterToHtml(data) {
        let me   = this,
            html = '<table class="neo-frontmatter-table"><tbody>';

        Object.entries(data).forEach(([key, value]) => {
            let renderedValue;

            if (key === 'subIssues' && Array.isArray(value)) {
                renderedValue = value.map(issue => {
                    return `<div class="neo-sub-issue">${issue
                        .replace(regexTicketLink, '<a href="#/news/tickets/$1">$1</a>')
                        .replace('[x]', '<i class="fa-solid fa-circle-check"></i>')
                        .replace('[ ]', '<i class="fa-regular fa-circle"></i>')}</div>`
                }).join('')
            } else if (key === 'author') {
                renderedValue = `<a href="${me.repoUserUrl}${value}" target="_blank">${value}</a>`
            } else if (key === 'createdAt' || key === 'closedAt' || key === 'updatedAt') {
                renderedValue = me.formatTimestamp(value)
            } else if (key === 'labels' && Array.isArray(value)) {
                renderedValue = me.getBadgesHtml(value)
            } else if (key === 'state') {
                renderedValue = me.getStateBadgeHtml(value)
            } else {
                renderedValue = me.formatFrontMatterValue(value)
            }

            html += `<tr><td>${key}</td><td>${renderedValue}</td></tr>`
        });

        html += '</tbody></table>';

        if (me.useFrontmatterDetails) {
            return `<details id="neo-ticket-summary-details-${me.id}"><summary>Frontmatter</summary>${html}</details>`
        }

        return html
    }

    /**
     * @param {String[]} labels
     * @returns {String}
     */
    getBadgesHtml(labels) {
        if (!labels || labels.length === 0) return '';

        let me         = this,
            badgesHtml = '<div class="neo-ticket-labels">';

        labels.forEach(label => {
            badgesHtml += me.getLabelBadgeHtml(label)
        });

        badgesHtml += '</div>';

        return badgesHtml
    }

    /**
     * @param {Object} record
     * @returns {Promise<void>}
     */
    async doFetchContent(record) {
        let me         = this,
            {windowId} = me,
            content, data, path;

        path = me.getContentPath(record);

        if (record.isLeaf && path) {
            data    = await fetch(path);
            content = await data.text();

            me.value = content;

            me.toggleCls('lab', record.name?.startsWith('Lab:'));

            Neo.main.addon.IntersectionObserver.observe({
                disconnect: true,
                id        : me.id,
                observe   : ['.neo-timeline-item[data-record-id]'],
                windowId
            })
        }
    }

    /**
     * @param {Object} record
     * @param {String} record.path
     * @returns {String|null}
     */
    getContentPath({path}) {
        return path ? Neo.config.basePath + path : null
    }

    /**
     * @param {String} label
     * @returns {String}
     */
    getLabelBadgeHtml(label) {
        let store  = this.getStateProvider().getStore('labels'),
            record = store.get(label);

        if (record) {
            return `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
        }

        return `<span class="neo-badge">${label}</span>`
    }

    /**
     * @param {String} state
     * @returns {String}
     */
    getStateBadgeHtml(state) {
        if (!state) return '';

        let cls  = 'neo-badge neo-state-badge',
            icon = 'fa-circle-dot';

        if (state.toUpperCase() === 'CLOSED') {
            cls  += ' neo-state-closed';
            icon  = 'fa-circle-check'
        } else {
            cls += ' neo-state-open'
        }

        return `<span class="${cls}"><i class="fa-regular ${icon}"></i>${Neo.capitalize(state.toLowerCase())}</span>`
    }

    /**
     * The Main Parsing Pipeline.
     *
     * This method intercepts the raw markdown content before it is rendered and performs a multi-pass transformation:
     * 1. **Extract Timeline**: Pulls out the raw `## Timeline` section to process it separately.
     * 2. **Process Frontmatter**: Extracts metadata (labels, state, author) and removes the YAML block.
     * 3. **Render Body**: Uses the superclass (marked.js) to convert the main issue body to HTML.
     * 4. **Inject Title IDs**: Adds IDs to H1 tags for navigation.
     * 5. **Generate Badges**: Creates HTML for Status/Label badges based on extracted metadata.
     * 6. **Wrap Body**: Wraps the main issue body in a `timeline-item` structure so it appears as the first item.
     * 7. **Re-Assemble**: Concatenates Frontmatter + Title + Timeline (with Body injected) into the final HTML.
     *
     * **Side Effect**: Populates `me.timelineData` and updates the `sections` store.
     *
     * @param {String} content
     * @returns {String}
     */
    modifyMarkdown(content) {
        let me           = this,
            {parentId}   = me.record,
            author       = null,
            createdAt    = null,
            labels       = [],
            state        = null,
            match        = content.match(regexFrontMatter),
            timelineHtml = '',
            badgesHtml   = '';

        me.timelineData = [];

        if (match) {
            let data = me.parseFrontMatter(match[1]);

            if (data.author)    {author    = data.author}
            if (data.createdAt) {createdAt = me.formatTimestamp(data.createdAt)}
            if (data.labels)    {labels    = data.labels}
            if (data.state)     {state     = data.state}
        }

        // 1. Extract and process timeline from RAW markdown
        let timelineMatch = content.match(regexTimeline);
        if (timelineMatch) {
            timelineHtml = me.renderTimeline(timelineMatch[1]);
            content      = content.replace(regexTimeline, ''); // Remove raw timeline
        }

        // 2. Render Frontmatter Manually & Strip it
        // We want it at the very top, outside the body bubble.
        let frontMatterHtml = '';
        if (match) {
            let data        = me.parseFrontMatter(match[1]);
            frontMatterHtml = me.frontMatterToHtml(data);
            content         = content.replace(regexFrontMatter, '');
        }

        // 3. Convert Body + Title to HTML using super
        let fullHtml = super.modifyMarkdown(content);

        // 4. Extract H1 Title from the generated HTML
        let titleHtml = '';
        fullHtml      = fullHtml.replace(regexH1, (match) => {
            // Inject ID into H1 tag
            titleHtml = match.replace('<h1', `<h1 id="ticket-title-${me.id}"`);
            return ''; // Remove title from body
        });

        // 5. Construct Badges
        if (labels.length > 0 || state || (parentId && parentId !== 'Latest')) {
            badgesHtml = '<div class="neo-ticket-labels">';

            if (state) {
                badgesHtml += me.getStateBadgeHtml(state)
            }

            if (parentId && parentId !== 'Latest') {
                badgesHtml += `
                    <a class="neo-badge neo-release-badge" href="#/news/releases/${parentId.substring(1)}">
                        <i class="fa-solid fa-code-branch"></i> ${parentId}
                    </a>`
            }

            if (labels.length > 0) {
                let store = me.getStateProvider().getStore('labels'),
                    record;

                labels.forEach(label => {
                    record = store.get(label);

                    if (record) {
                        badgesHtml += `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
                    } else {
                        badgesHtml += `<span class="neo-badge">${label}</span>`
                    }
                });
            }

            badgesHtml += '</div>';
            titleHtml  += badgesHtml;
        }

        // 6. Wrap the remaining HTML (Body) in the Timeline Item structure
        let bodyId = `timeline-${me.record.id}-0`;

        me.timelineData.unshift({
            id   : bodyId,
            image: me.repoUserUrl + author + '.png',
            name : 'Description',
            tag  : 'body'
        });

        let bodyItemHtml = `
            <div id="${bodyId}" class="neo-timeline-item comment body-item" data-record-id="${bodyId}">
                <div id="${bodyId}-target" class="neo-timeline-avatar">
                    <img src="${me.repoUserUrl}${author}.png" alt="${author}">
                </div>
                <div class="neo-timeline-content">
                    <div class="neo-timeline-header">
                        <a class="neo-timeline-user" href="${me.repoUserUrl}${author}" target="_blank">${author}</a>
                        <span class="neo-timeline-date">commented on ${createdAt}</span>
                    </div>
                    <div class="neo-timeline-body">${fullHtml}</div>
                </div>
            </div>`;

        // 7. Inject Body Item at the start of the Timeline
        let timelineId = `ticket-timeline-${me.id}`;

        if (timelineHtml) {
            timelineHtml = timelineHtml.replace(
                '<div class="neo-ticket-timeline">',
                `<div id="${timelineId}" class="neo-ticket-timeline">` + bodyItemHtml
            )
        } else {
            timelineHtml = `<div id="${timelineId}" class="neo-ticket-timeline">${bodyItemHtml}</div>`
        }

        me.getStateProvider().getStore('sections').data = me.timelineData;
        me.timelineData = null;

        // Return: Frontmatter + Title + Timeline
        return frontMatterHtml + titleHtml + timelineHtml
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        this.fire('toggleSummary')
    }

    /**
     * Parses the custom "Timeline" markdown section.
     *
     * Expects a line-based format generated by the build process:
     * - Events: `- YYYY-MM-DDTHH:mm:ss @user action text...`
     * - Comments: `### @user - YYYY-MM-DDTHH:mm:ss` followed by comment body.
     *
     * This method converts these lines into structured `timeline-item` HTML blocks
     * and simultaneously populates `me.timelineData` with semantic data (color, icon, type)
     * for each event.
     *
     * @param {String} content
     * @returns {String}
     */
    renderTimeline(content) {
        let me          = this,
            {commitsUrl, repoUserUrl} = me,
            html        = '<div class="neo-ticket-timeline">',
            lines       = content.split('\n'),
            commentBuf  = [],
            currentUser = null,
            currentDate = null,
            i           = 0,
            len         = lines.length,
            id, line, match, icon, actionCls;

        const flushComment = () => {
            if (commentBuf.length > 0) {
                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                me.timelineData.push({
                    id   : id,
                    image: repoUserUrl + currentUser + '.png',
                    name : `Comment (${currentUser})`,
                    tag  : 'comment'
                });

                let body = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parse(commentBuf.join('\n'));
                html += `
                    <div id="${id}" class="neo-timeline-item comment" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-avatar">
                            <img src="${repoUserUrl}${currentUser}.png" alt="${currentUser}">
                        </div>
                        <div class="neo-timeline-content">
                            <div class="neo-timeline-header">
                                <a class="neo-timeline-user" href="${repoUserUrl}${currentUser}" target="_blank">${currentUser}</a>
                                <span class="neo-timeline-date">${me.formatTimestamp(currentDate)}</span>
                            </div>
                            <div class="neo-timeline-body">${body}</div>
                        </div>
                    </div>`;
                commentBuf  = [];
                currentUser = null;
                currentDate = null
            }
        };

        for (; i < len; i++) {
            line = lines[i];

            // Event Line: - 2026-01-11T... @user action...
            if ((match = line.match(regexTimelineEvent))) {
                flushComment();
                let [_, date, user, action] = match;

                icon      = 'fa-circle-dot'; // Default
                actionCls = '';

                const eventType = [
                    {key: 'added the `',      icon: 'fa-tag'},
                    {key: 'removed the `',    icon: 'fa-tag'},
                    {key: 'assigned',         icon: 'fa-user-pen'},
                    {key: 'closed',           icon: 'fa-circle-check', color: '#8250df'}, // GitHub Purple
                    {key: 'reopened',         icon: 'fa-circle-dot',   color: '#2da44e'}, // GitHub Green
                    {key: 'referenced',       icon: 'fa-link'},
                    {key: 'cross-referenced', icon: 'fa-link'},
                    {key: 'milestoned',       icon: 'fa-sign-post'},
                    {key: 'sub-issue',        icon: 'fa-diagram-project'}
                ].find(e => action.includes(e.key));

                let color = null;

                if (eventType) {
                    icon = eventType.icon;
                    if (eventType.color) color = eventType.color
                }

                // Clean up markdown in action text (e.g. `code` to <code>)
                let cleanAction = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parseInline(action);

                if (icon === 'fa-tag') {
                    cleanAction = cleanAction.replace(/<code>(.*?)<\/code>/g, (match, label) => me.getLabelBadgeHtml(label));

                    // Try to resolve color from label
                    let labelMatch = action.match(/`([^`]+)`/);
                    if (labelMatch) {
                        let labelName = labelMatch[1];
                        let labelRec  = me.getStateProvider().getStore('labels').get(labelName);
                        if (labelRec) {
                            color = labelRec.color;
                        }
                    }
                }

                // Linkify Commit Hashes
                cleanAction = cleanAction.replace(regexCommit, `<a href="${commitsUrl}$1" target="_blank">$1</a>`);

                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                // Extract a short action name for the list
                let shortAction = action.split(' ')[0]; // 'added', 'closed', etc.

                if (shortAction === 'added' || shortAction === 'removed') {
                    let labelMatch = action.match(/`([^`]+)`/);
                    shortAction = labelMatch ? labelMatch[1] : 'Label'
                }

                me.timelineData.push({
                    color: color, // Pass resolved hex color
                    icon : icon,
                    id   : id,
                    name : `${Neo.capitalize(shortAction)} (${user})`,
                    tag  : 'event'
                });

                // Apply color style if present, otherwise default
                let style = color ? `style="color: ${color}"` : '';

                html += `
                    <div id="${id}" class="neo-timeline-item event" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-badge" ${style}><i class="fa-solid ${icon}"></i></div>
                        <div class="neo-timeline-body">
                            <a class="neo-timeline-user" href="${repoUserUrl}${user}" target="_blank">${user}</a> ${cleanAction} <span class="neo-timeline-date">on ${me.formatTimestamp(date)}</span>
                        </div>
                    </div>`;
            }
            // Comment Header: ### @user - 2026-01-11T...
            else if (line.startsWith('### @')) {
                // Captures "user" and "2026-01-11T..." (ISO timestamp)
                let headerMatch = line.match(/^### @(\w+) - ([\dTZ:.-]+)$/);
                if (headerMatch) {
                    flushComment();
                    currentUser = headerMatch[1];
                    currentDate = headerMatch[2]
                } else {
                    // Fallback for weird headers? treat as text
                    if (currentUser) commentBuf.push(line)
                }
            }
            else {
                if (currentUser) {
                    commentBuf.push(line)
                }
            }
        }

        flushComment(); // Flush last comment

        html += '</div>';
        return html
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasWrapper.mjs */ "./apps/portal/view/news/tickets/CanvasWrapper.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/portal/view/news/tickets/MainContainerController.mjs");
/* harmony import */ var _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PageContainer.mjs */ "./apps/portal/view/news/tickets/PageContainer.mjs");
/* harmony import */ var _shared_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/content/Container.mjs */ "./apps/portal/view/shared/content/Container.mjs");
/* harmony import */ var _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MainContainerStateProvider.mjs */ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs");






/**
 * @class Portal.view.news.tickets.MainContainer
 * @extends Portal.view.shared.content.Container
 */
class MainContainer extends _shared_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainer',
        /**
         * @member {String[]} cls=['portal-tickets-maincontainer']
         * @reactive
         */
        cls: ['portal-tickets-maincontainer'],
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         * @reactive
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} pageContainerConfig
         */
        pageContainerConfig: {
            module         : _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            buttonTextField: 'id',
            contentConfig  : {
                module: _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            }
        },
        /**
         * @member {Neo.state.Provider} stateProvider=MainContainerStateProvider
         * @reactive
         */
        stateProvider: _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
        /**
         * @member {Object} treeConfig={displayField:'treeNodeName'}
         */
        treeConfig: {
            displayField: 'treeNodeName'
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerController.mjs"
/*!*******************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerController.mjs ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Portal.view.news.tickets.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerController'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerController',
        /**
         * @member {Object} routes
         */
        routes: {
            '/news/tickets'          : 'onRouteDefault',
            '/news/tickets/{*itemId}': 'onRouteItem'
        }
    }

    /**
     * @param {String} item
     */
    navigateTo(item) {
        Neo.Main.setRoute({
            value   : `/news/tickets/${item}`,
            windowId: this.component.windowId
        })
    }

    /**
     * @param {Object} data
     */
    onIntersect(data) {
        let panel    = this.getReference('page-sections-container'),
            list     = panel.list,
            recordId = data.data.recordId,
            record;

        if (recordId && !list.isAnimating) {
            record = list.store.get(recordId);

            if (record) {
                list.selectionModel.select(record)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onNextPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('nextPageRecord').id)
    }

    /**
     * @param {Object} data
     */
    onPageSectionsToggleButtonClick(data) {
        this.getReference('page-sections-container').toggleCls('neo-expanded')
    }

    /**
     * @param {Object} data
     */
    onPreviousPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('previousPageRecord').id)
    }

    /**
     * @param {Object} data
     */
    onRouteDefault(data) {
        let me    = this,
            store = me.getStateProvider().getStore('tree');

        if (store.getCount() > 0) {
            me.navigateTo(store.getAt(1).id)
        } else {
            store.on({
                load : () => me.navigateTo(store.getAt(1).id),
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.itemId
     * @param {Object} value
     * @param {Object} oldValue
     */
    async onRouteItem({itemId}, value, oldValue) {
        let me            = this,
            stateProvider = me.getStateProvider(),
            store         = stateProvider.getStore('tree'),
            tree          = me.getReference('tree');

        // Ensure the tree has the correct route prefix for this controller context
        if (tree.routePrefix !== '/news/tickets') {
            tree.routePrefix = '/news/tickets'
        }

        const select = async () => {
            stateProvider.data.currentPageRecord = store.get(itemId);

            if (!oldValue?.hashString?.startsWith('/news/tickets')) {
                await tree.expandAndScrollToItem(itemId)
            } else {
                tree.expandParents(itemId)
            }
        };

        if (store.getCount() > 0) {
            await select()
        } else {
            store.on({
                load : select,
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     */
    onSideNavToggleButtonClick(data) {
        this.getReference('sidenav-container').toggleCls('neo-expanded')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs"
/*!**********************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerStateProvider.mjs ***!
  \**********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../store/TicketLabels.mjs */ "./apps/portal/store/TicketLabels.mjs");
/* harmony import */ var _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../store/TicketTimelineSections.mjs */ "./apps/portal/store/TicketTimelineSections.mjs");
/* harmony import */ var _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../store/Tickets.mjs */ "./apps/portal/store/Tickets.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");





/**
 * @class Portal.view.news.tickets.MainContainerStateProvider
 * @extends Neo.state.Provider
 */
class MainContainerStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerStateProvider'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {Number|null} data.countPages=null
             */
            countPages: null,
            /**
             * @member {Number|null} data.countPages=null
             */
            countSections: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.currentRecord=null
             */
            currentPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.nextPageRecord=null
             */
            nextPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.previousPageRecord=null
             */
            previousPageRecord: null
        },
        /**
         * @member {Object} stores
         */
        stores: {
            labels: {
                autoLoad: true,
                module  : _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            },
            sections: {
                module: _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
            },
            tree: {
                autoLoad: true,
                module  : _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]
            }
        }
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        super.onDataPropertyChange(key, value, oldValue);

        let me = this;

        switch (key) {
            case 'countSections': {
                if (value < 1) {
                    me.component.getReference('page-sections-container')?.toggleCls('neo-expanded', false)
                }

                break
            }

            case 'currentPageRecord': {
                let {data}             = me,
                    {countPages}       = data,
                    store              = me.getStore('tree'),
                    index              = store.indexOf(value),
                    nextPageRecord     = null,
                    previousPageRecord = null,
                    i, record;

                // the logic assumes that the tree store is sorted
                for (i=index-1; i >= 0; i--) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        previousPageRecord = record;
                        break
                    }
                }

                me.setData({previousPageRecord});

                // the logic assumes that the tree store is sorted
                for (i=index+1; i < countPages; i++) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        nextPageRecord = record;
                        break
                    }
                }

                me.setData({nextPageRecord});

                me.component.getReference('sidenav-container')?.toggleCls('neo-expanded', false)

                break
            }
        }
    }

    /**
     * We need to check the parent-node chain inside the tree.
     * => Any hidden parent-node results in a hidden record.
     * @param {Object} record
     * @param {Neo.data.Store} store
     * @returns {Boolean}
     */
    recordIsHidden(record, store) {
        if (record.hidden) {
            return true
        }

        if (record.parentId !== null) {
            return this.recordIsHidden(store.get(record.parentId), store)
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerStateProvider));


/***/ },

/***/ "./apps/portal/view/news/tickets/PageContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/PageContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/content/PageContainer.mjs */ "./apps/portal/view/shared/content/PageContainer.mjs");


/**
 * @class Portal.view.news.tickets.PageContainer
 * @extends Portal.view.shared.content.PageContainer
 */
class TicketPageContainer extends _shared_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.PageContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.PageContainer',
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={flex:1,overflowY:'auto',position:'relative'}
         */
        style: {flex: 1, overflowY: 'auto', position: 'relative'}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketPageContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/TimelineCanvas.mjs"
/*!**********************************************************!*\
  !*** ./apps/portal/view/news/tickets/TimelineCanvas.mjs ***!
  \**********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/component/Canvas.mjs */ "./src/component/Canvas.mjs");


/**
 * @summary The "Coordinator" component for the Neural Timeline, bridging the App Worker and Canvas Worker.
 *
 * This component renders a transparent canvas overlay on top of the Ticket List. It is responsible for:
 * 1. **Data Bridge**: Listening to the `sections` store and passing ticket data to the `TicketCanvas` (SharedWorker).
 * 2. **Visual Alignment**: Calculating the precise DOM positions of Ticket Avatars/Badges to ensure the
 *    canvas nodes align perfectly with the HTML content.
 * 3. **Lifecycle Management**: initializing the offscreen canvas transfer and handling resize events.
 *
 * It uses the `Portal.canvas.TicketCanvas` singleton (via Remote Method Access) to drive the actual animation.
 *
 * @class Portal.view.news.tickets.TimelineCanvas
 * @extends Neo.component.Canvas
 */
class TimelineCanvas extends _src_component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     */
    static delayable = {
        ensureFinalAlignment: {
            type : 'debounce',
            timer: 300
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.TimelineCanvas'
         * @protected
         */
        className: 'Portal.view.news.tickets.TimelineCanvas',
        /**
         * @member {Object} listeners
         */
        listeners: {
            resize: 'onResize'
        },
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'div', cls: ['neo-ticket-timeline-wrapper'], style: {width: '100%', height: '100%'}, cn: [
            {tag: 'canvas', style: {width: '100%', height: '100%'}}
        ]}
    }

    /**
     * @member {String} canvasId=null
     */
    canvasId = null
    /**
     * @member {Boolean} isCanvasReady=false
     */
    isCanvasReady = false
    /**
     * @member {Object[]} lastRecords=null
     */
    lastRecords = null

    /**
     *
     */
    ensureFinalAlignment() {
        let me = this;

        if (me.lastRecords) {
            me.onTimelineDataLoad(me.lastRecords, true)
        }
    }

    /**
     * Lifecycle hook that runs once the `OffscreenCanvas` has been transferred to the Canvas Worker.
     *
     * This method:
     * 1. Imports the `TicketCanvas` logic into the Canvas Worker context.
     * 2. Initializes the graph in the worker via Remote Method Access (`initGraph`).
     * 3. Sets up a `ResizeObserver` to keep the canvas size synced with the DOM.
     * 4. Triggers the initial data load if store data is available.
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetOffscreenRegistered(value, oldValue) {
        let me = this;

        if (value) {
            // Ensure the logic is loaded in the worker
            await Portal.canvas.Helper.importTicketCanvas();

            // Direct Remote Method Access call
            await Portal.canvas.TicketCanvas.initGraph({canvasId: me.getCanvasId(), windowId: me.windowId});

            me.isCanvasReady = true;

            // Register ResizeObserver for the canvas wrapper (me.id)
            Neo.main.addon.ResizeObserver.register({
                id      : me.id,
                windowId: me.windowId
            });

            // Initial sizing
            await me.updateSize();

            // Initial load check
            let store = me.getStateProvider().getStore('sections');

            if (store.getCount() > 0) {
                me.onTimelineDataLoad(store.items)
            }
        } else if (oldValue) {
            me.isCanvasReady = false;
            // Stop the worker loop to prevent "Zombie Canvas" CPU usage
            await Portal.canvas.TicketCanvas.clearGraph()
        }
    }

    /**
     * Override to return the inner canvas ID
     */
    getCanvasId() {
        let me = this;

        if (!me.canvasId) {
            me.canvasId = me.vdom.cn[0].id
        }
        return me.canvasId
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me    = this,
            store = me.getStateProvider().getStore('sections');

        store.on('load', me.onTimelineDataLoad, me)
    }

    /**
     * @param {Object} data
     */
    async onResize(data) {
        let me = this;

        // Update the canvas size in the worker
        await me.updateSize(data.contentRect);

        // If we have cached records, re-calculate node positions
        // because the container dimensions (and likely relative positions) have changed.
        if (me.lastRecords) {
            // We don't need to re-fetch rects instantly, but it's safer to do so
            // to ensure alignment with the new layout.
            await me.onTimelineDataLoad(me.lastRecords, true);

            // Debounced check to ensure the canvas is aligned after any transitions settle
            me.ensureFinalAlignment()
        }
    }

    /**
     * The core "Alignment Engine" of the timeline.
     *
     * This method synchronizes the Canvas nodes with the DOM elements (Avatars/Badges).
     *
     * **Strategy:**
     * 1. **Targeting**: It uses the `-target` ID suffix to find the specific DOM elements (Avatars) within the ticket list.
     * 2. **Measurement**: It fetches the `DOMRect` for every target to get its exact screen position.
     * 3. **Translation**: It converts these screen coordinates into Canvas-local coordinates.
     * 4. **Handoff**: It packages this geometric data (x, y, radius, color) and sends it to the
     *    `TicketCanvas` worker to update the physics simulation.
     *
     * @param {Object[]|Object} records Array of records or Store load event object {items: [...]}
     * @param {Boolean} [isResize=false]
     */
    async onTimelineDataLoad(records, isResize = false) {
        let me = this;

        // Handle Store 'load' event signature: fire('load', {items: [...]})
        if (records && !Array.isArray(records) && records.items) {
            records = records.items
        }

        if (!Array.isArray(records)) {
            // Safety check if records is still invalid
            return
        }

        if (!me.isCanvasReady) {
            return
        }

        let reset = !isResize;

        // Smart Check: If it's a store load (reset=true) BUT the ticket ID is the same,
        // it's a data refresh (e.g. comment added), so we should NOT reset the animation.
        if (reset && me.lastRecords && records[0]?.id === me.lastRecords[0]?.id) {
            reset = false
        }

        me.lastRecords = records;

        let ids = records.map(r => `${r.id}-target`),
            rects;

        try {
            // Fetch DOM rects for the MARKERS (Avatars/Badges), not the containers
            rects = await me.waitForDomRect({
                attempts: 20,
                delay   : 50,
                id      : ids
            });

            if (me.lastRecords !== records) {
                return
            }

            // Check if we got valid rects (at least one)
            let hasRects = rects && rects.some(r => r);

            if (!hasRects) {
                return
            }

            // On first valid data load (not resize), ensure size is synced
            // because content might have pushed the container height.
            if (!isResize) {
                await me.updateSize()
            }

            let canvasRect = await me.getDomRect(me.getCanvasId()),
                nodes      = [],
                startY     = 0;

            ids.forEach((targetId, index) => {
                let rect   = rects[index],
                    record = records[index];

                if (rect) {
                    // PRECISE CENTERING
                    // Now 'rect' is the actual avatar/badge.
                    let offset = rect.height / 2,
                        nodeY  = rect.y - canvasRect.y + offset,
                        nodeX  = rect.x - canvasRect.x + (rect.width / 2),
                        // Distinct padding for Orbit effect
                        // Avatars (~40px) get more breathing room than Badges (~28px)
                        padding = rect.height > 32 ? 6 : 3;

                    nodes.push({
                        color : record.color, // Pass Hex Color (e.g. #ff0000)
                        id    : record.id,
                        radius: offset + padding,
                        y     : nodeY,
                        x     : nodeX
                    });

                    // Set the startY of the line to the first node
                    if (index === 0) {
                        startY = nodeY
                    }
                }
            });

            await Portal.canvas.TicketCanvas.updateGraphData({nodes, reset, startY})
        } catch (e) {
            console.error('TimelineCanvas update failed', e)
        }
    }

    /**
     * @param {Object|null} rect
     * @returns {Promise<void>}
     */
    async updateSize(rect) {
        let me = this;

        if (!rect || rect.width === 0 || rect.height === 0) {
            rect = await me.waitForDomRect({id: me.getCanvasId()})
        }

        await Portal.canvas.TicketCanvas.updateSize({width: rect.width, height: rect.height})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TimelineCanvas));


/***/ },

/***/ "./src/component/Canvas.mjs"
/*!**********************************!*\
  !*** ./src/component/Canvas.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.component.Canvas
 * @extends Neo.component.Base
 */
class Canvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Canvas'
         * @protected
         */
        className: 'Neo.component.Canvas',
        /**
         * @member {String} ntype='canvas'
         * @protected
         */
        ntype: 'canvas',
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=true
         * @reactive
         */
        monitorSize_: true,
        /**
         * @member {Boolean} offscreen=true
         */
        offscreen: true,
        /**
         * Only applicable if offscreen === true.
         * true once the ownership of the canvas node got transferred to worker.Canvas.
         * @member {Boolean} offscreenRegistered_=false
         * @reactive
         */
        offscreenRegistered_: false,
        /**
         * @member {Object} _vdom={tag: 'canvas'}
         */
        _vdom:
        {tag: 'canvas'}
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me          = this,
            id          = me.getCanvasId(),
            {offscreen} = me;

        if (value) {
            await me.timeout(30); // next rAF tick

            if (me.monitorSize) {
                me.addDomListeners([{
                    delegate: `#${me.getCanvasId()}`,
                    resize  : me.onDomResize,
                    scope   : me
                }])
            }

            if (offscreen) {
                const data = await Neo.main.DomAccess.getOffscreenCanvas({
                    nodeId  : id,
                    windowId: me.windowId
                });

                if (data.offscreen) {
                    await Neo.worker.Canvas.registerCanvas({
                        node    : data.offscreen,
                        nodeId  : id,
                        windowId: me.windowId
                    }, [data.offscreen]);

                    me.offscreenRegistered = true
                } else if (data.transferred) {
                    if (Neo.config.useSharedWorkers) {
                        let retrieveData = await Neo.worker.Canvas.retrieveCanvas({
                            nodeId  : id,
                            windowId: me.windowId
                        });

                        if (retrieveData.hasCanvas) {
                            me.offscreenRegistered = true
                        }
                    }
                }
            }
        } else if (offscreen) {
            me.offscreenRegistered = false
        }
    }


    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        if (oldValue) {
            this.offscreenRegistered = false
        }
    }

    /**
     * Override this method when using wrappers (e.g. D3)
     * @returns {String}
     */
    getCanvasId() {
        return this.id
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Canvas));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfcG9ydGFsX3ZpZXdfbmV3c190aWNrZXRzX01haW5Db250YWluZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBSztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx5QkFBeUI7QUFDekI7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDLHNDQUFzQyxHQUFHLE9BQU8sTUFBTTtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkRVOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBSztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsMkJBQTJCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ087O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJEQUFj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LFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxPQUFPO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVzs7QUFFeEI7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvbW9kZWwvVGlja2V0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvbW9kZWwvVGlja2V0TGFiZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9tb2RlbC9UaWNrZXRUaW1lbGluZVNlY3Rpb24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9zdG9yZS9UaWNrZXRMYWJlbHMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9zdG9yZS9UaWNrZXRUaW1lbGluZVNlY3Rpb25zLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvc3RvcmUvVGlja2V0cy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL0NhbnZhc1dyYXBwZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9NYWluQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL1BhZ2VDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9UaW1lbGluZUNhbnZhcy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvQ2FudmFzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLm1vZGVsLlRpY2tldFxuICogQGV4dGVuZHMgTmVvLmRhdGEuTW9kZWxcbiAqL1xuY2xhc3MgVGlja2V0IGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLm1vZGVsLlRpY2tldCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLm1vZGVsLlRpY2tldCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZHM6IFt7XG4gICAgICAgICAgICBuYW1lICAgICAgICA6ICdjb2xsYXBzZWQnLFxuICAgICAgICAgICAgdHlwZSAgICAgICAgOiAnQm9vbGVhbicsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWUgICAgICAgIDogJ2lzTGVhZicsXG4gICAgICAgICAgICB0eXBlICAgICAgICA6ICdCb29sZWFuJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lICAgICAgICA6ICdwYXJlbnRJZCcsXG4gICAgICAgICAgICB0eXBlICAgICAgICA6ICdTdHJpbmcnLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdwYXRoJywgLy8gXCJyZXNvdXJjZXMvY29udGVudC9pc3N1ZXMvaXNzdWUtMTIzNC5tZFwiXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAndGl0bGUnLCAvLyBcIkZpeCBlbHVzaXZlIGJ1ZyBpbiBHcmlkXCJcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGVkIGZpZWxkIGZvciBUcmVlTGlzdCBkaXNwbGF5XG4gICAgICAgICAgICBuYW1lOiAndHJlZU5vZGVOYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEuaWRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5pc0xlYWZcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS50aXRsZVxuICAgICAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FsY3VsYXRlKHtpZCwgaXNMZWFmLCB0aXRsZX0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMZWFmID8gYDxiPiR7aWR9PC9iPiAke3RpdGxlfWAgOiBpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0KTtcbiIsImltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwubW9kZWwuVGlja2V0TGFiZWxcbiAqIEBleHRlbmRzIE5lby5kYXRhLk1vZGVsXG4gKi9cbmNsYXNzIFRpY2tldExhYmVsIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLm1vZGVsLlRpY2tldExhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwubW9kZWwuVGlja2V0TGFiZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGZpZWxkc1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZHM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnY29sb3InLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICd0ZXh0Q29sb3InLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldExhYmVsKTtcbiIsImltcG9ydCBDb250ZW50U2VjdGlvbiBmcm9tICcuL0NvbnRlbnRTZWN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5tb2RlbC5UaWNrZXRUaW1lbGluZVNlY3Rpb25cbiAqIEBleHRlbmRzIFBvcnRhbC5tb2RlbC5Db250ZW50U2VjdGlvblxuICovXG5jbGFzcyBUaWNrZXRUaW1lbGluZVNlY3Rpb24gZXh0ZW5kcyBDb250ZW50U2VjdGlvbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwubW9kZWwuVGlja2V0VGltZWxpbmVTZWN0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwubW9kZWwuVGlja2V0VGltZWxpbmVTZWN0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdjb2xvcicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaWNvbicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaW1hZ2UnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ3NvdXJjZUlkJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRUaW1lbGluZVNlY3Rpb24pO1xuIiwiaW1wb3J0IFRpY2tldExhYmVsIGZyb20gJy4uL21vZGVsL1RpY2tldExhYmVsLm1qcyc7XG5pbXBvcnQgU3RvcmUgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnN0b3JlLlRpY2tldExhYmVsc1xuICogQGV4dGVuZHMgTmVvLmRhdGEuU3RvcmVcbiAqL1xuY2xhc3MgVGlja2V0TGFiZWxzIGV4dGVuZHMgU3RvcmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnN0b3JlLlRpY2tldExhYmVscydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnN0b3JlLlRpY2tldExhYmVscycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGtleVByb3BlcnR5PSduYW1lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBrZXlQcm9wZXJ0eTogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsPVRpY2tldExhYmVsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBUaWNrZXRMYWJlbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdXJsPScuLi8uLi9hcHBzL3BvcnRhbC9yZXNvdXJjZXMvZGF0YS9sYWJlbHMuanNvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdXJsOiAnLi4vLi4vYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvbGFiZWxzLmpzb24nXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRMYWJlbHMpO1xuIiwiaW1wb3J0IENvbnRlbnRTZWN0aW9ucyAgICAgIGZyb20gJy4vQ29udGVudFNlY3Rpb25zLm1qcyc7XG5pbXBvcnQgVGlja2V0VGltZWxpbmVTZWN0aW9uIGZyb20gJy4uL21vZGVsL1RpY2tldFRpbWVsaW5lU2VjdGlvbi5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwuc3RvcmUuVGlja2V0VGltZWxpbmVTZWN0aW9uc1xuICogQGV4dGVuZHMgUG9ydGFsLnN0b3JlLkNvbnRlbnRTZWN0aW9uc1xuICovXG5jbGFzcyBUaWNrZXRUaW1lbGluZVNlY3Rpb25zIGV4dGVuZHMgQ29udGVudFNlY3Rpb25zIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5zdG9yZS5UaWNrZXRUaW1lbGluZVNlY3Rpb25zJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuc3RvcmUuVGlja2V0VGltZWxpbmVTZWN0aW9ucycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9VGlja2V0VGltZWxpbmVTZWN0aW9uXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IFRpY2tldFRpbWVsaW5lU2VjdGlvblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0VGltZWxpbmVTZWN0aW9ucyk7XG4iLCJpbXBvcnQgU3RvcmUgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcbmltcG9ydCBUaWNrZXRNb2RlbCBmcm9tICcuLi9tb2RlbC9UaWNrZXQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnN0b3JlLlRpY2tldHNcbiAqIEBleHRlbmRzIE5lby5kYXRhLlN0b3JlXG4gKi9cbmNsYXNzIFRpY2tldHMgZXh0ZW5kcyBTdG9yZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuc3RvcmUuVGlja2V0cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnN0b3JlLlRpY2tldHMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsPVRpY2tldE1vZGVsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IFRpY2tldE1vZGVsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB1cmw9Jy4uLy4uL2FwcHMvcG9ydGFsL3Jlc291cmNlcy9kYXRhL3RpY2tldHMuanNvbidcbiAgICAgICAgICovXG4gICAgICAgIHVybDogJy4uLy4uL2FwcHMvcG9ydGFsL3Jlc291cmNlcy9kYXRhL3RpY2tldHMuanNvbidcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldHMpO1xuIiwiaW1wb3J0IENvbnRhaW5lciAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ29udGVudENvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IFRpbWVsaW5lQ2FudmFzICAgZnJvbSAnLi9UaW1lbGluZUNhbnZhcy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ2FudmFzV3JhcHBlclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIENhbnZhc1dyYXBwZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNhbnZhc1dyYXBwZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5DYW52YXNXcmFwcGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydwb3J0YWwtY2FudmFzLXdyYXBwZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ3BvcnRhbC1jYW52YXMtd3JhcHBlciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbnRlbnRDb21wb25lbnQ9Q29udGVudENvbXBvbmVudFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudENvbXBvbmVudDogQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3R5bGU9e21pbkhlaWdodDonMTAwJScsb3ZlcmZsb3c6J3Zpc2libGUnLHBvc2l0aW9uOidyZWxhdGl2ZSd9XG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZToge21pbkhlaWdodDogJzEwMCUnLCBvdmVyZmxvdzogJ3Zpc2libGUnLCBwb3NpdGlvbjogJ3JlbGF0aXZlJ31cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgY29uZmlnLml0ZW1zID0gW3tcbiAgICAgICAgICAgIG1vZHVsZSAgIDogVGltZWxpbmVDYW52YXMsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICd0aW1lbGluZS1jYW52YXMnLFxuICAgICAgICAgICAgc3R5bGUgOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gICAgIDogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICB0b3AgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgIDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodCAgICAgICA6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICB6SW5kZXggICAgICAgOiAyLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGU6IGNvbmZpZy5jb250ZW50Q29tcG9uZW50IHx8IG1lLmNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBzdHlsZSA6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICB6SW5kZXggIDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgIHRvZ2dsZVN1bW1hcnk6IG1lLm9uVG9nZ2xlU3VtbWFyeSxcbiAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XTtcblxuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uVG9nZ2xlU3VtbWFyeSgpIHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuZ2V0UmVmZXJlbmNlKCd0aW1lbGluZS1jYW52YXMnKTtcblxuICAgICAgICBpZiAoY2FudmFzPy5sYXN0UmVjb3Jkcykge1xuICAgICAgICAgICAgY2FudmFzLm9uVGltZWxpbmVEYXRhTG9hZChjYW52YXMubGFzdFJlY29yZHMsIHRydWUpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENhbnZhc1dyYXBwZXIpO1xuIiwiaW1wb3J0IENvbnRlbnRDb21wb25lbnQgZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnRlbnQvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQge21hcmtlZH0gICAgICAgICBmcm9tICcuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzJztcblxuY29uc3RcbiAgICByZWdleEZyb250TWF0dGVyICAgPSAvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLVxcbi8sXG4gICAgcmVnZXhIMSAgICAgICAgICAgID0gLyg8aDFbXj5dKj4uKj88XFwvaDE+KS8sXG4gICAgcmVnZXhUaWNrZXRMaW5rICAgID0gLyhcXGR7NCx9KS8sXG4gICAgcmVnZXhUaW1lbGluZSAgICAgID0gLyMjIFRpbWVsaW5lXFxzKlxcbihbXFxzXFxTXSopLyxcbiAgICByZWdleFRpbWVsaW5lRXZlbnQgPSAvXi0gKFtcXGRUWjouLV0rKSBAKFxcdyspICguKikkLyxcbiAgICByZWdleENvbW1pdCAgICAgICAgPSAvXFxiKFswLTlhLWZdezcsNDB9KVxcYi9nO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFRoZSBcIk1hcmtkb3duIFRyYW5zZm9ybWVyXCIgZm9yIEdpdEh1YiBUaWNrZXRzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGV4dGVuZHMgdGhlIHN0YW5kYXJkIENvbnRlbnRDb21wb25lbnQgdG8gcHJvdmlkZSBzcGVjaWFsaXplZCByZW5kZXJpbmcgZm9yIEdpdEh1YiBJc3N1ZXMuXG4gKiBJdHMgcHJpbWFyeSByZXNwb25zaWJpbGl0eSBpcyB0byBwYXJzZSB0aGUgcmF3IE1hcmtkb3duIGNvbnRlbnQgKHdoaWNoIGluY2x1ZGVzIGN1c3RvbSBGcm9udG1hdHRlciBhbmRcbiAqIGEgcHJlLWdlbmVyYXRlZCBUaW1lbGluZSBzZWN0aW9uKSBhbmQgdHJhbnNmb3JtIGl0IGludG8gYSByaWNoLCBpbnRlcmFjdGl2ZSBIVE1MIHN0cnVjdHVyZS5cbiAqXG4gKiAqKktleSBSZXNwb25zaWJpbGl0aWVzOioqXG4gKiAxLiAqKlBhcnNpbmcgUGlwZWxpbmUqKjogRXh0cmFjdHMgRnJvbnRtYXR0ZXIsIEJvZHksIGFuZCB0aGUgY3VzdG9tIFwiVGltZWxpbmVcIiBzZWN0aW9uIGZyb20gdGhlIHJhdyBNYXJrZG93bi5cbiAqIDIuICoqUmljaCBSZW5kZXJpbmcqKjogR2VuZXJhdGVzIEhUTUwgZm9yIFN0YXR1cyBCYWRnZXMsIExhYmVscywgQ29tbWl0IExpbmtzLCBhbmQgVXNlciBNZW50aW9ucy5cbiAqIDMuICoqRGF0YSBFeHRyYWN0aW9uKio6IEFzIGEgc2lkZSBlZmZlY3Qgb2YgcmVuZGVyaW5nLCBpdCBleHRyYWN0cyBzdHJ1Y3R1cmVkIGRhdGEgKGBtZS50aW1lbGluZURhdGFgKVxuICogICAgcmVwcmVzZW50aW5nIGV2ZXJ5IHRpbWVsaW5lIGV2ZW50IChjb21tZW50LCBsYWJlbCBjaGFuZ2UsIGNsb3NlLCBldGMuKS4gVGhpcyBkYXRhIGlzIHRoZW5cbiAqICAgIHB1c2hlZCB0byB0aGUgYHNlY3Rpb25zYCBzdG9yZSB0byBkcml2ZSB0aGUgYFRpbWVsaW5lQ2FudmFzYCB2aXN1YWxpemF0aW9uLlxuICpcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBQb3J0YWwudmlldy5zaGFyZWQuY29udGVudC5Db21wb25lbnRcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQ29udGVudENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydwb3J0YWwtbmV3cy10aWNrZXRzLWNvbXBvbmVudCddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsncG9ydGFsLW5ld3MtdGlja2V0cy1jb21wb25lbnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY29tbWl0c1VybD0naHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vY29tbWl0LydcbiAgICAgICAgICovXG4gICAgICAgIGNvbW1pdHNVcmw6ICdodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9jb21taXQvJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZG9tTGlzdGVuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBkb21MaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIHJlc2l6ZTogJ29uUmVzaXplJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZXBvVXNlclVybD0naHR0cHM6Ly9naXRodWIuY29tLydcbiAgICAgICAgICovXG4gICAgICAgIHJlcG9Vc2VyVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tLycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1cGRhdGVTZWN0aW9uc1N0b3JlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVTZWN0aW9uc1N0b3JlOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gI2RhdGVUaW1lRm9ybWF0SGlzdG9yeT1udWxsXG4gICAgICovXG4gICAgI2RhdGVUaW1lRm9ybWF0SGlzdG9yeSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9ICNkYXRlVGltZUZvcm1hdFRvZGF5PW51bGxcbiAgICAgKi9cbiAgICAjZGF0ZVRpbWVGb3JtYXRUb2RheSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBUZW1wb3Jhcnkgc3RvcmFnZSBmb3IgdGhlIHN0cnVjdHVyZWQgdGltZWxpbmUgZGF0YSBleHRyYWN0ZWQgZHVyaW5nIHRoZSBwYXJzaW5nIHBoYXNlLlxuICAgICAqIFRoaXMgYXJyYXkgaXMgcG9wdWxhdGVkIGJ5IGByZW5kZXJUaW1lbGluZWAgYW5kIGBtb2RpZnlNYXJrZG93bmAgYW5kIHRoZW4gYXNzaWduZWRcbiAgICAgKiB0byB0aGUgYHNlY3Rpb25zYCBzdG9yZSB0byBkcml2ZSB0aGUgQ2FudmFzIHZpc3VhbGl6YXRpb24uXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHRpbWVsaW5lRGF0YT1udWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aW1lbGluZURhdGEgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuc2V0RGF0YSgnY29udGVudENvbXBvbmVudElkJywgdGhpcy5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXNvU3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtYXRUaW1lc3RhbXAoaXNvU3RyaW5nKSB7XG4gICAgICAgIGlmICghaXNvU3RyaW5nKSByZXR1cm4gJyc7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0ZSAgICA9IG5ldyBEYXRlKGlzb1N0cmluZyksXG4gICAgICAgICAgICBub3cgICAgID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGlzVG9kYXkgPSBkYXRlLnRvRGF0ZVN0cmluZygpID09PSBub3cudG9EYXRlU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGlzVG9kYXkpIHtcbiAgICAgICAgICAgIGlmICghbWUuI2RhdGVUaW1lRm9ybWF0VG9kYXkpIHtcbiAgICAgICAgICAgICAgICBtZS4jZGF0ZVRpbWVGb3JtYXRUb2RheSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdkZWZhdWx0Jywge1xuICAgICAgICAgICAgICAgICAgICBob3VyICA6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYydcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWUuI2RhdGVUaW1lRm9ybWF0VG9kYXkuZm9ybWF0KGRhdGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLiNkYXRlVGltZUZvcm1hdEhpc3RvcnkpIHtcbiAgICAgICAgICAgIG1lLiNkYXRlVGltZUZvcm1hdEhpc3RvcnkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZGVmYXVsdCcsIHtcbiAgICAgICAgICAgICAgICBkYXkgICA6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBob3VyICA6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtb250aCA6ICdzaG9ydCcsXG4gICAgICAgICAgICAgICAgeWVhciAgOiAnbnVtZXJpYydcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuI2RhdGVUaW1lRm9ybWF0SGlzdG9yeS5mb3JtYXQoZGF0ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZnJvbnRNYXR0ZXJUb0h0bWwoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBodG1sID0gJzx0YWJsZSBjbGFzcz1cIm5lby1mcm9udG1hdHRlci10YWJsZVwiPjx0Ym9keT4nO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlbmRlcmVkVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzdWJJc3N1ZXMnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IHZhbHVlLm1hcChpc3N1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIm5lby1zdWItaXNzdWVcIj4ke2lzc3VlXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyZWdleFRpY2tldExpbmssICc8YSBocmVmPVwiIy9uZXdzL3RpY2tldHMvJDFcIj4kMTwvYT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1t4XScsICc8aSBjbGFzcz1cImZhLXNvbGlkIGZhLWNpcmNsZS1jaGVja1wiPjwvaT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1sgXScsICc8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtY2lyY2xlXCI+PC9pPicpfTwvZGl2PmBcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcnKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdhdXRob3InKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IGA8YSBocmVmPVwiJHttZS5yZXBvVXNlclVybH0ke3ZhbHVlfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7dmFsdWV9PC9hPmBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY3JlYXRlZEF0JyB8fCBrZXkgPT09ICdjbG9zZWRBdCcgfHwga2V5ID09PSAndXBkYXRlZEF0Jykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSBtZS5mb3JtYXRUaW1lc3RhbXAodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xhYmVscycgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gbWUuZ2V0QmFkZ2VzSHRtbCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IG1lLmdldFN0YXRlQmFkZ2VIdG1sKHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gbWUuZm9ybWF0RnJvbnRNYXR0ZXJWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaHRtbCArPSBgPHRyPjx0ZD4ke2tleX08L3RkPjx0ZD4ke3JlbmRlcmVkVmFsdWV9PC90ZD48L3RyPmBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaHRtbCArPSAnPC90Ym9keT48L3RhYmxlPic7XG5cbiAgICAgICAgaWYgKG1lLnVzZUZyb250bWF0dGVyRGV0YWlscykge1xuICAgICAgICAgICAgcmV0dXJuIGA8ZGV0YWlscyBpZD1cIm5lby10aWNrZXQtc3VtbWFyeS1kZXRhaWxzLSR7bWUuaWR9XCI+PHN1bW1hcnk+RnJvbnRtYXR0ZXI8L3N1bW1hcnk+JHtodG1sfTwvZGV0YWlscz5gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGxhYmVsc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0QmFkZ2VzSHRtbChsYWJlbHMpIHtcbiAgICAgICAgaWYgKCFsYWJlbHMgfHwgbGFiZWxzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGJhZGdlc0h0bWwgPSAnPGRpdiBjbGFzcz1cIm5lby10aWNrZXQtbGFiZWxzXCI+JztcblxuICAgICAgICBsYWJlbHMuZm9yRWFjaChsYWJlbCA9PiB7XG4gICAgICAgICAgICBiYWRnZXNIdG1sICs9IG1lLmdldExhYmVsQmFkZ2VIdG1sKGxhYmVsKVxuICAgICAgICB9KTtcblxuICAgICAgICBiYWRnZXNIdG1sICs9ICc8L2Rpdj4nO1xuXG4gICAgICAgIHJldHVybiBiYWRnZXNIdG1sXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGRvRmV0Y2hDb250ZW50KHJlY29yZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7d2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICBjb250ZW50LCBkYXRhLCBwYXRoO1xuXG4gICAgICAgIHBhdGggPSBtZS5nZXRDb250ZW50UGF0aChyZWNvcmQpO1xuXG4gICAgICAgIGlmIChyZWNvcmQuaXNMZWFmICYmIHBhdGgpIHtcbiAgICAgICAgICAgIGRhdGEgICAgPSBhd2FpdCBmZXRjaChwYXRoKTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBhd2FpdCBkYXRhLnRleHQoKTtcblxuICAgICAgICAgICAgbWUudmFsdWUgPSBjb250ZW50O1xuXG4gICAgICAgICAgICBtZS50b2dnbGVDbHMoJ2xhYicsIHJlY29yZC5uYW1lPy5zdGFydHNXaXRoKCdMYWI6JykpO1xuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5JbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGlkICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIG9ic2VydmUgICA6IFsnLm5lby10aW1lbGluZS1pdGVtW2RhdGEtcmVjb3JkLWlkXSddLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWNvcmQucGF0aFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250ZW50UGF0aCh7cGF0aH0pIHtcbiAgICAgICAgcmV0dXJuIHBhdGggPyBOZW8uY29uZmlnLmJhc2VQYXRoICsgcGF0aCA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGFiZWxcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldExhYmVsQmFkZ2VIdG1sKGxhYmVsKSB7XG4gICAgICAgIGxldCBzdG9yZSAgPSB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgnbGFiZWxzJyksXG4gICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXQobGFiZWwpO1xuXG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCJuZW8tYmFkZ2VcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JHtyZWNvcmQuY29sb3J9O2NvbG9yOiR7cmVjb3JkLnRleHRDb2xvcn1cIj4ke2xhYmVsfTwvc3Bhbj5gXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwibmVvLWJhZGdlXCI+JHtsYWJlbH08L3NwYW4+YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3RhdGVCYWRnZUh0bWwoc3RhdGUpIHtcbiAgICAgICAgaWYgKCFzdGF0ZSkgcmV0dXJuICcnO1xuXG4gICAgICAgIGxldCBjbHMgID0gJ25lby1iYWRnZSBuZW8tc3RhdGUtYmFkZ2UnLFxuICAgICAgICAgICAgaWNvbiA9ICdmYS1jaXJjbGUtZG90JztcblxuICAgICAgICBpZiAoc3RhdGUudG9VcHBlckNhc2UoKSA9PT0gJ0NMT1NFRCcpIHtcbiAgICAgICAgICAgIGNscyAgKz0gJyBuZW8tc3RhdGUtY2xvc2VkJztcbiAgICAgICAgICAgIGljb24gID0gJ2ZhLWNpcmNsZS1jaGVjaydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNscyArPSAnIG5lby1zdGF0ZS1vcGVuJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGA8c3BhbiBjbGFzcz1cIiR7Y2xzfVwiPjxpIGNsYXNzPVwiZmEtcmVndWxhciAke2ljb259XCI+PC9pPiR7TmVvLmNhcGl0YWxpemUoc3RhdGUudG9Mb3dlckNhc2UoKSl9PC9zcGFuPmBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgTWFpbiBQYXJzaW5nIFBpcGVsaW5lLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaW50ZXJjZXB0cyB0aGUgcmF3IG1hcmtkb3duIGNvbnRlbnQgYmVmb3JlIGl0IGlzIHJlbmRlcmVkIGFuZCBwZXJmb3JtcyBhIG11bHRpLXBhc3MgdHJhbnNmb3JtYXRpb246XG4gICAgICogMS4gKipFeHRyYWN0IFRpbWVsaW5lKio6IFB1bGxzIG91dCB0aGUgcmF3IGAjIyBUaW1lbGluZWAgc2VjdGlvbiB0byBwcm9jZXNzIGl0IHNlcGFyYXRlbHkuXG4gICAgICogMi4gKipQcm9jZXNzIEZyb250bWF0dGVyKio6IEV4dHJhY3RzIG1ldGFkYXRhIChsYWJlbHMsIHN0YXRlLCBhdXRob3IpIGFuZCByZW1vdmVzIHRoZSBZQU1MIGJsb2NrLlxuICAgICAqIDMuICoqUmVuZGVyIEJvZHkqKjogVXNlcyB0aGUgc3VwZXJjbGFzcyAobWFya2VkLmpzKSB0byBjb252ZXJ0IHRoZSBtYWluIGlzc3VlIGJvZHkgdG8gSFRNTC5cbiAgICAgKiA0LiAqKkluamVjdCBUaXRsZSBJRHMqKjogQWRkcyBJRHMgdG8gSDEgdGFncyBmb3IgbmF2aWdhdGlvbi5cbiAgICAgKiA1LiAqKkdlbmVyYXRlIEJhZGdlcyoqOiBDcmVhdGVzIEhUTUwgZm9yIFN0YXR1cy9MYWJlbCBiYWRnZXMgYmFzZWQgb24gZXh0cmFjdGVkIG1ldGFkYXRhLlxuICAgICAqIDYuICoqV3JhcCBCb2R5Kio6IFdyYXBzIHRoZSBtYWluIGlzc3VlIGJvZHkgaW4gYSBgdGltZWxpbmUtaXRlbWAgc3RydWN0dXJlIHNvIGl0IGFwcGVhcnMgYXMgdGhlIGZpcnN0IGl0ZW0uXG4gICAgICogNy4gKipSZS1Bc3NlbWJsZSoqOiBDb25jYXRlbmF0ZXMgRnJvbnRtYXR0ZXIgKyBUaXRsZSArIFRpbWVsaW5lICh3aXRoIEJvZHkgaW5qZWN0ZWQpIGludG8gdGhlIGZpbmFsIEhUTUwuXG4gICAgICpcbiAgICAgKiAqKlNpZGUgRWZmZWN0Kio6IFBvcHVsYXRlcyBgbWUudGltZWxpbmVEYXRhYCBhbmQgdXBkYXRlcyB0aGUgYHNlY3Rpb25zYCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBtb2RpZnlNYXJrZG93bihjb250ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudElkfSAgID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgYXV0aG9yICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdCAgICA9IG51bGwsXG4gICAgICAgICAgICBsYWJlbHMgICAgICAgPSBbXSxcbiAgICAgICAgICAgIHN0YXRlICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBtYXRjaCAgICAgICAgPSBjb250ZW50Lm1hdGNoKHJlZ2V4RnJvbnRNYXR0ZXIpLFxuICAgICAgICAgICAgdGltZWxpbmVIdG1sID0gJycsXG4gICAgICAgICAgICBiYWRnZXNIdG1sICAgPSAnJztcblxuICAgICAgICBtZS50aW1lbGluZURhdGEgPSBbXTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gbWUucGFyc2VGcm9udE1hdHRlcihtYXRjaFsxXSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmF1dGhvcikgICAge2F1dGhvciAgICA9IGRhdGEuYXV0aG9yfVxuICAgICAgICAgICAgaWYgKGRhdGEuY3JlYXRlZEF0KSB7Y3JlYXRlZEF0ID0gbWUuZm9ybWF0VGltZXN0YW1wKGRhdGEuY3JlYXRlZEF0KX1cbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscykgICAge2xhYmVscyAgICA9IGRhdGEubGFiZWxzfVxuICAgICAgICAgICAgaWYgKGRhdGEuc3RhdGUpICAgICB7c3RhdGUgICAgID0gZGF0YS5zdGF0ZX1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDEuIEV4dHJhY3QgYW5kIHByb2Nlc3MgdGltZWxpbmUgZnJvbSBSQVcgbWFya2Rvd25cbiAgICAgICAgbGV0IHRpbWVsaW5lTWF0Y2ggPSBjb250ZW50Lm1hdGNoKHJlZ2V4VGltZWxpbmUpO1xuICAgICAgICBpZiAodGltZWxpbmVNYXRjaCkge1xuICAgICAgICAgICAgdGltZWxpbmVIdG1sID0gbWUucmVuZGVyVGltZWxpbmUodGltZWxpbmVNYXRjaFsxXSk7XG4gICAgICAgICAgICBjb250ZW50ICAgICAgPSBjb250ZW50LnJlcGxhY2UocmVnZXhUaW1lbGluZSwgJycpOyAvLyBSZW1vdmUgcmF3IHRpbWVsaW5lXG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBSZW5kZXIgRnJvbnRtYXR0ZXIgTWFudWFsbHkgJiBTdHJpcCBpdFxuICAgICAgICAvLyBXZSB3YW50IGl0IGF0IHRoZSB2ZXJ5IHRvcCwgb3V0c2lkZSB0aGUgYm9keSBidWJibGUuXG4gICAgICAgIGxldCBmcm9udE1hdHRlckh0bWwgPSAnJztcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSAgICAgICAgPSBtZS5wYXJzZUZyb250TWF0dGVyKG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGZyb250TWF0dGVySHRtbCA9IG1lLmZyb250TWF0dGVyVG9IdG1sKGRhdGEpO1xuICAgICAgICAgICAgY29udGVudCAgICAgICAgID0gY29udGVudC5yZXBsYWNlKHJlZ2V4RnJvbnRNYXR0ZXIsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIENvbnZlcnQgQm9keSArIFRpdGxlIHRvIEhUTUwgdXNpbmcgc3VwZXJcbiAgICAgICAgbGV0IGZ1bGxIdG1sID0gc3VwZXIubW9kaWZ5TWFya2Rvd24oY29udGVudCk7XG5cbiAgICAgICAgLy8gNC4gRXh0cmFjdCBIMSBUaXRsZSBmcm9tIHRoZSBnZW5lcmF0ZWQgSFRNTFxuICAgICAgICBsZXQgdGl0bGVIdG1sID0gJyc7XG4gICAgICAgIGZ1bGxIdG1sICAgICAgPSBmdWxsSHRtbC5yZXBsYWNlKHJlZ2V4SDEsIChtYXRjaCkgPT4ge1xuICAgICAgICAgICAgLy8gSW5qZWN0IElEIGludG8gSDEgdGFnXG4gICAgICAgICAgICB0aXRsZUh0bWwgPSBtYXRjaC5yZXBsYWNlKCc8aDEnLCBgPGgxIGlkPVwidGlja2V0LXRpdGxlLSR7bWUuaWR9XCJgKTtcbiAgICAgICAgICAgIHJldHVybiAnJzsgLy8gUmVtb3ZlIHRpdGxlIGZyb20gYm9keVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyA1LiBDb25zdHJ1Y3QgQmFkZ2VzXG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMCB8fCBzdGF0ZSB8fCAocGFyZW50SWQgJiYgcGFyZW50SWQgIT09ICdMYXRlc3QnKSkge1xuICAgICAgICAgICAgYmFkZ2VzSHRtbCA9ICc8ZGl2IGNsYXNzPVwibmVvLXRpY2tldC1sYWJlbHNcIj4nO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBiYWRnZXNIdG1sICs9IG1lLmdldFN0YXRlQmFkZ2VIdG1sKHN0YXRlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50SWQgJiYgcGFyZW50SWQgIT09ICdMYXRlc3QnKSB7XG4gICAgICAgICAgICAgICAgYmFkZ2VzSHRtbCArPSBgXG4gICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwibmVvLWJhZGdlIG5lby1yZWxlYXNlLWJhZGdlXCIgaHJlZj1cIiMvbmV3cy9yZWxlYXNlcy8ke3BhcmVudElkLnN1YnN0cmluZygxKX1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEtc29saWQgZmEtY29kZS1icmFuY2hcIj48L2k+ICR7cGFyZW50SWR9XG4gICAgICAgICAgICAgICAgICAgIDwvYT5gXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBzdG9yZSA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgnbGFiZWxzJyksXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICAgICAgICAgIGxhYmVscy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0KGxhYmVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWRnZXNIdG1sICs9IGA8c3BhbiBjbGFzcz1cIm5lby1iYWRnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjoke3JlY29yZC5jb2xvcn07Y29sb3I6JHtyZWNvcmQudGV4dENvbG9yfVwiPiR7bGFiZWx9PC9zcGFuPmBcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gYDxzcGFuIGNsYXNzPVwibmVvLWJhZGdlXCI+JHtsYWJlbH08L3NwYW4+YFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICB0aXRsZUh0bWwgICs9IGJhZGdlc0h0bWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA2LiBXcmFwIHRoZSByZW1haW5pbmcgSFRNTCAoQm9keSkgaW4gdGhlIFRpbWVsaW5lIEl0ZW0gc3RydWN0dXJlXG4gICAgICAgIGxldCBib2R5SWQgPSBgdGltZWxpbmUtJHttZS5yZWNvcmQuaWR9LTBgO1xuXG4gICAgICAgIG1lLnRpbWVsaW5lRGF0YS51bnNoaWZ0KHtcbiAgICAgICAgICAgIGlkICAgOiBib2R5SWQsXG4gICAgICAgICAgICBpbWFnZTogbWUucmVwb1VzZXJVcmwgKyBhdXRob3IgKyAnLnBuZycsXG4gICAgICAgICAgICBuYW1lIDogJ0Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgIHRhZyAgOiAnYm9keSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGJvZHlJdGVtSHRtbCA9IGBcbiAgICAgICAgICAgIDxkaXYgaWQ9XCIke2JvZHlJZH1cIiBjbGFzcz1cIm5lby10aW1lbGluZS1pdGVtIGNvbW1lbnQgYm9keS1pdGVtXCIgZGF0YS1yZWNvcmQtaWQ9XCIke2JvZHlJZH1cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtib2R5SWR9LXRhcmdldFwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWF2YXRhclwiPlxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIiR7bWUucmVwb1VzZXJVcmx9JHthdXRob3J9LnBuZ1wiIGFsdD1cIiR7YXV0aG9yfVwiPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuZW8tdGltZWxpbmUtdXNlclwiIGhyZWY9XCIke21lLnJlcG9Vc2VyVXJsfSR7YXV0aG9yfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7YXV0aG9yfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibmVvLXRpbWVsaW5lLWRhdGVcIj5jb21tZW50ZWQgb24gJHtjcmVhdGVkQXR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1ib2R5XCI+JHtmdWxsSHRtbH08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmA7XG5cbiAgICAgICAgLy8gNy4gSW5qZWN0IEJvZHkgSXRlbSBhdCB0aGUgc3RhcnQgb2YgdGhlIFRpbWVsaW5lXG4gICAgICAgIGxldCB0aW1lbGluZUlkID0gYHRpY2tldC10aW1lbGluZS0ke21lLmlkfWA7XG5cbiAgICAgICAgaWYgKHRpbWVsaW5lSHRtbCkge1xuICAgICAgICAgICAgdGltZWxpbmVIdG1sID0gdGltZWxpbmVIdG1sLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LXRpbWVsaW5lXCI+JyxcbiAgICAgICAgICAgICAgICBgPGRpdiBpZD1cIiR7dGltZWxpbmVJZH1cIiBjbGFzcz1cIm5lby10aWNrZXQtdGltZWxpbmVcIj5gICsgYm9keUl0ZW1IdG1sXG4gICAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZUh0bWwgPSBgPGRpdiBpZD1cIiR7dGltZWxpbmVJZH1cIiBjbGFzcz1cIm5lby10aWNrZXQtdGltZWxpbmVcIj4ke2JvZHlJdGVtSHRtbH08L2Rpdj5gXG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3NlY3Rpb25zJykuZGF0YSA9IG1lLnRpbWVsaW5lRGF0YTtcbiAgICAgICAgbWUudGltZWxpbmVEYXRhID0gbnVsbDtcblxuICAgICAgICAvLyBSZXR1cm46IEZyb250bWF0dGVyICsgVGl0bGUgKyBUaW1lbGluZVxuICAgICAgICByZXR1cm4gZnJvbnRNYXR0ZXJIdG1sICsgdGl0bGVIdG1sICsgdGltZWxpbmVIdG1sXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblJlc2l6ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgndG9nZ2xlU3VtbWFyeScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBjdXN0b20gXCJUaW1lbGluZVwiIG1hcmtkb3duIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBFeHBlY3RzIGEgbGluZS1iYXNlZCBmb3JtYXQgZ2VuZXJhdGVkIGJ5IHRoZSBidWlsZCBwcm9jZXNzOlxuICAgICAqIC0gRXZlbnRzOiBgLSBZWVlZLU1NLUREVEhIOm1tOnNzIEB1c2VyIGFjdGlvbiB0ZXh0Li4uYFxuICAgICAqIC0gQ29tbWVudHM6IGAjIyMgQHVzZXIgLSBZWVlZLU1NLUREVEhIOm1tOnNzYCBmb2xsb3dlZCBieSBjb21tZW50IGJvZHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjb252ZXJ0cyB0aGVzZSBsaW5lcyBpbnRvIHN0cnVjdHVyZWQgYHRpbWVsaW5lLWl0ZW1gIEhUTUwgYmxvY2tzXG4gICAgICogYW5kIHNpbXVsdGFuZW91c2x5IHBvcHVsYXRlcyBgbWUudGltZWxpbmVEYXRhYCB3aXRoIHNlbWFudGljIGRhdGEgKGNvbG9yLCBpY29uLCB0eXBlKVxuICAgICAqIGZvciBlYWNoIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJlbmRlclRpbWVsaW5lKGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb21taXRzVXJsLCByZXBvVXNlclVybH0gPSBtZSxcbiAgICAgICAgICAgIGh0bWwgICAgICAgID0gJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LXRpbWVsaW5lXCI+JyxcbiAgICAgICAgICAgIGxpbmVzICAgICAgID0gY29udGVudC5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgICBjb21tZW50QnVmICA9IFtdLFxuICAgICAgICAgICAgY3VycmVudFVzZXIgPSBudWxsLFxuICAgICAgICAgICAgY3VycmVudERhdGUgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgPSBsaW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBpZCwgbGluZSwgbWF0Y2gsIGljb24sIGFjdGlvbkNscztcblxuICAgICAgICBjb25zdCBmbHVzaENvbW1lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29tbWVudEJ1Zi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBgdGltZWxpbmUtJHttZS5yZWNvcmQuaWR9LSR7bWUudGltZWxpbmVEYXRhLmxlbmd0aCArIDF9YDtcblxuICAgICAgICAgICAgICAgIG1lLnRpbWVsaW5lRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogcmVwb1VzZXJVcmwgKyBjdXJyZW50VXNlciArICcucG5nJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA6IGBDb21tZW50ICgke2N1cnJlbnRVc2VyfSlgLFxuICAgICAgICAgICAgICAgICAgICB0YWcgIDogJ2NvbW1lbnQnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IG1hcmtlZC5wYXJzZShjb21tZW50QnVmLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICBodG1sICs9IGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7aWR9XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtaXRlbSBjb21tZW50XCIgZGF0YS1yZWNvcmQtaWQ9XCIke2lkfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7aWR9LXRhcmdldFwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWF2YXRhclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiJHtyZXBvVXNlclVybH0ke2N1cnJlbnRVc2VyfS5wbmdcIiBhbHQ9XCIke2N1cnJlbnRVc2VyfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5lby10aW1lbGluZS11c2VyXCIgaHJlZj1cIiR7cmVwb1VzZXJVcmx9JHtjdXJyZW50VXNlcn1cIiB0YXJnZXQ9XCJfYmxhbmtcIj4ke2N1cnJlbnRVc2VyfTwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJuZW8tdGltZWxpbmUtZGF0ZVwiPiR7bWUuZm9ybWF0VGltZXN0YW1wKGN1cnJlbnREYXRlKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1ib2R5XCI+JHtib2R5fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgICAgICAgICAgY29tbWVudEJ1ZiAgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXNlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgICAgICAvLyBFdmVudCBMaW5lOiAtIDIwMjYtMDEtMTFULi4uIEB1c2VyIGFjdGlvbi4uLlxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2gocmVnZXhUaW1lbGluZUV2ZW50KSkpIHtcbiAgICAgICAgICAgICAgICBmbHVzaENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICBsZXQgW18sIGRhdGUsIHVzZXIsIGFjdGlvbl0gPSBtYXRjaDtcblxuICAgICAgICAgICAgICAgIGljb24gICAgICA9ICdmYS1jaXJjbGUtZG90JzsgLy8gRGVmYXVsdFxuICAgICAgICAgICAgICAgIGFjdGlvbkNscyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gW1xuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnYWRkZWQgdGhlIGAnLCAgICAgIGljb246ICdmYS10YWcnfSxcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ3JlbW92ZWQgdGhlIGAnLCAgICBpY29uOiAnZmEtdGFnJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdhc3NpZ25lZCcsICAgICAgICAgaWNvbjogJ2ZhLXVzZXItcGVuJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdjbG9zZWQnLCAgICAgICAgICAgaWNvbjogJ2ZhLWNpcmNsZS1jaGVjaycsIGNvbG9yOiAnIzgyNTBkZid9LCAvLyBHaXRIdWIgUHVycGxlXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdyZW9wZW5lZCcsICAgICAgICAgaWNvbjogJ2ZhLWNpcmNsZS1kb3QnLCAgIGNvbG9yOiAnIzJkYTQ0ZSd9LCAvLyBHaXRIdWIgR3JlZW5cbiAgICAgICAgICAgICAgICAgICAge2tleTogJ3JlZmVyZW5jZWQnLCAgICAgICBpY29uOiAnZmEtbGluayd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnY3Jvc3MtcmVmZXJlbmNlZCcsIGljb246ICdmYS1saW5rJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdtaWxlc3RvbmVkJywgICAgICAgaWNvbjogJ2ZhLXNpZ24tcG9zdCd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnc3ViLWlzc3VlJywgICAgICAgIGljb246ICdmYS1kaWFncmFtLXByb2plY3QnfVxuICAgICAgICAgICAgICAgIF0uZmluZChlID0+IGFjdGlvbi5pbmNsdWRlcyhlLmtleSkpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbiA9IGV2ZW50VHlwZS5pY29uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlLmNvbG9yKSBjb2xvciA9IGV2ZW50VHlwZS5jb2xvclxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIG1hcmtkb3duIGluIGFjdGlvbiB0ZXh0IChlLmcuIGBjb2RlYCB0byA8Y29kZT4pXG4gICAgICAgICAgICAgICAgbGV0IGNsZWFuQWN0aW9uID0gbWFya2VkLnBhcnNlSW5saW5lKGFjdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWNvbiA9PT0gJ2ZhLXRhZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5BY3Rpb24gPSBjbGVhbkFjdGlvbi5yZXBsYWNlKC88Y29kZT4oLio/KTxcXC9jb2RlPi9nLCAobWF0Y2gsIGxhYmVsKSA9PiBtZS5nZXRMYWJlbEJhZGdlSHRtbChsYWJlbCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZXNvbHZlIGNvbG9yIGZyb20gbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTWF0Y2ggPSBhY3Rpb24ubWF0Y2goL2AoW15gXSspYC8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTmFtZSA9IGxhYmVsTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxSZWMgID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdsYWJlbHMnKS5nZXQobGFiZWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFJlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbGFiZWxSZWMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMaW5raWZ5IENvbW1pdCBIYXNoZXNcbiAgICAgICAgICAgICAgICBjbGVhbkFjdGlvbiA9IGNsZWFuQWN0aW9uLnJlcGxhY2UocmVnZXhDb21taXQsIGA8YSBocmVmPVwiJHtjb21taXRzVXJsfSQxXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JDE8L2E+YCk7XG5cbiAgICAgICAgICAgICAgICBpZCA9IGB0aW1lbGluZS0ke21lLnJlY29yZC5pZH0tJHttZS50aW1lbGluZURhdGEubGVuZ3RoICsgMX1gO1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBhIHNob3J0IGFjdGlvbiBuYW1lIGZvciB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGxldCBzaG9ydEFjdGlvbiA9IGFjdGlvbi5zcGxpdCgnICcpWzBdOyAvLyAnYWRkZWQnLCAnY2xvc2VkJywgZXRjLlxuXG4gICAgICAgICAgICAgICAgaWYgKHNob3J0QWN0aW9uID09PSAnYWRkZWQnIHx8IHNob3J0QWN0aW9uID09PSAncmVtb3ZlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsTWF0Y2ggPSBhY3Rpb24ubWF0Y2goL2AoW15gXSspYC8pO1xuICAgICAgICAgICAgICAgICAgICBzaG9ydEFjdGlvbiA9IGxhYmVsTWF0Y2ggPyBsYWJlbE1hdGNoWzFdIDogJ0xhYmVsJ1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnRpbWVsaW5lRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLCAvLyBQYXNzIHJlc29sdmVkIGhleCBjb2xvclxuICAgICAgICAgICAgICAgICAgICBpY29uIDogaWNvbixcbiAgICAgICAgICAgICAgICAgICAgaWQgICA6IGlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lIDogYCR7TmVvLmNhcGl0YWxpemUoc2hvcnRBY3Rpb24pfSAoJHt1c2VyfSlgLFxuICAgICAgICAgICAgICAgICAgICB0YWcgIDogJ2V2ZW50J1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgY29sb3Igc3R5bGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSBjb2xvciA/IGBzdHlsZT1cImNvbG9yOiAke2NvbG9yfVwiYCA6ICcnO1xuXG4gICAgICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2lkfVwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWl0ZW0gZXZlbnRcIiBkYXRhLXJlY29yZC1pZD1cIiR7aWR9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtpZH0tdGFyZ2V0XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtYmFkZ2VcIiAke3N0eWxlfT48aSBjbGFzcz1cImZhLXNvbGlkICR7aWNvbn1cIj48L2k+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5lby10aW1lbGluZS11c2VyXCIgaHJlZj1cIiR7cmVwb1VzZXJVcmx9JHt1c2VyfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7dXNlcn08L2E+ICR7Y2xlYW5BY3Rpb259IDxzcGFuIGNsYXNzPVwibmVvLXRpbWVsaW5lLWRhdGVcIj5vbiAke21lLmZvcm1hdFRpbWVzdGFtcChkYXRlKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbW1lbnQgSGVhZGVyOiAjIyMgQHVzZXIgLSAyMDI2LTAxLTExVC4uLlxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKCcjIyMgQCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZXMgXCJ1c2VyXCIgYW5kIFwiMjAyNi0wMS0xMVQuLi5cIiAoSVNPIHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGVyTWF0Y2ggPSBsaW5lLm1hdGNoKC9eIyMjIEAoXFx3KykgLSAoW1xcZFRaOi4tXSspJC8pO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaENvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFVzZXIgPSBoZWFkZXJNYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBoZWFkZXJNYXRjaFsyXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciB3ZWlyZCBoZWFkZXJzPyB0cmVhdCBhcyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXNlcikgY29tbWVudEJ1Zi5wdXNoKGxpbmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRCdWYucHVzaChsaW5lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoQ29tbWVudCgpOyAvLyBGbHVzaCBsYXN0IGNvbW1lbnRcblxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICByZXR1cm4gaHRtbFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBDYW52YXNXcmFwcGVyICAgIGZyb20gJy4vQ2FudmFzV3JhcHBlci5tanMnO1xuaW1wb3J0IENvbnRyb2xsZXIgICAgICAgZnJvbSAnLi9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMnO1xuaW1wb3J0IFBhZ2VDb250YWluZXIgICAgZnJvbSAnLi9QYWdlQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgU2hhcmVkQ29udGFpbmVyICBmcm9tICcuLi8uLi9zaGFyZWQvY29udGVudC9Db250YWluZXIubWpzJztcbmltcG9ydCBTdGF0ZVByb3ZpZGVyICAgIGZyb20gJy4vTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIFBvcnRhbC52aWV3LnNoYXJlZC5jb250ZW50LkNvbnRhaW5lclxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgU2hhcmVkQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsncG9ydGFsLXRpY2tldHMtbWFpbmNvbnRhaW5lciddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ3BvcnRhbC10aWNrZXRzLW1haW5jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudH0gY29udHJvbGxlcj1NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRyb2xsZXI6IENvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHBhZ2VDb250YWluZXJDb25maWdcbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VDb250YWluZXJDb25maWc6IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgIDogUGFnZUNvbnRhaW5lcixcbiAgICAgICAgICAgIGJ1dHRvblRleHRGaWVsZDogJ2lkJyxcbiAgICAgICAgICAgIGNvbnRlbnRDb25maWcgIDoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogQ2FudmFzV3JhcHBlclxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnN0YXRlLlByb3ZpZGVyfSBzdGF0ZVByb3ZpZGVyPU1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGVQcm92aWRlcjogU3RhdGVQcm92aWRlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdHJlZUNvbmZpZz17ZGlzcGxheUZpZWxkOid0cmVlTm9kZU5hbWUnfVxuICAgICAgICAgKi9cbiAgICAgICAgdHJlZUNvbmZpZzoge1xuICAgICAgICAgICAgZGlzcGxheUZpZWxkOiAndHJlZU5vZGVOYW1lJ1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyKTtcbiIsImltcG9ydCBDb250cm9sbGVyIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJDb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByb3V0ZXNcbiAgICAgICAgICovXG4gICAgICAgIHJvdXRlczoge1xuICAgICAgICAgICAgJy9uZXdzL3RpY2tldHMnICAgICAgICAgIDogJ29uUm91dGVEZWZhdWx0JyxcbiAgICAgICAgICAgICcvbmV3cy90aWNrZXRzL3sqaXRlbUlkfSc6ICdvblJvdXRlSXRlbSdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtXG4gICAgICovXG4gICAgbmF2aWdhdGVUbyhpdGVtKSB7XG4gICAgICAgIE5lby5NYWluLnNldFJvdXRlKHtcbiAgICAgICAgICAgIHZhbHVlICAgOiBgL25ld3MvdGlja2V0cy8ke2l0ZW19YCxcbiAgICAgICAgICAgIHdpbmRvd0lkOiB0aGlzLmNvbXBvbmVudC53aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25JbnRlcnNlY3QoZGF0YSkge1xuICAgICAgICBsZXQgcGFuZWwgICAgPSB0aGlzLmdldFJlZmVyZW5jZSgncGFnZS1zZWN0aW9ucy1jb250YWluZXInKSxcbiAgICAgICAgICAgIGxpc3QgICAgID0gcGFuZWwubGlzdCxcbiAgICAgICAgICAgIHJlY29yZElkID0gZGF0YS5kYXRhLnJlY29yZElkLFxuICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgIGlmIChyZWNvcmRJZCAmJiAhbGlzdC5pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgcmVjb3JkID0gbGlzdC5zdG9yZS5nZXQocmVjb3JkSWQpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zZWxlY3Rpb25Nb2RlbC5zZWxlY3QocmVjb3JkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk5leHRQYWdlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRlVG8odGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSgnbmV4dFBhZ2VSZWNvcmQnKS5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUGFnZVNlY3Rpb25zVG9nZ2xlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgncGFnZS1zZWN0aW9ucy1jb250YWluZXInKS50b2dnbGVDbHMoJ25lby1leHBhbmRlZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblByZXZpb3VzUGFnZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvKHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoJ3ByZXZpb3VzUGFnZVJlY29yZCcpLmlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3V0ZURlZmF1bHQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RvcmUgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3RyZWUnKTtcblxuICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIG1lLm5hdmlnYXRlVG8oc3RvcmUuZ2V0QXQoMSkuaWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9yZS5vbih7XG4gICAgICAgICAgICAgICAgbG9hZCA6ICgpID0+IG1lLm5hdmlnYXRlVG8oc3RvcmUuZ2V0QXQoMSkuaWQpLFxuICAgICAgICAgICAgICAgIGRlbGF5OiAxMCxcbiAgICAgICAgICAgICAgICBvbmNlIDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaXRlbUlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYXN5bmMgb25Sb3V0ZUl0ZW0oe2l0ZW1JZH0sIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdGF0ZVByb3ZpZGVyID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICA9IHN0YXRlUHJvdmlkZXIuZ2V0U3RvcmUoJ3RyZWUnKSxcbiAgICAgICAgICAgIHRyZWUgICAgICAgICAgPSBtZS5nZXRSZWZlcmVuY2UoJ3RyZWUnKTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhlIHRyZWUgaGFzIHRoZSBjb3JyZWN0IHJvdXRlIHByZWZpeCBmb3IgdGhpcyBjb250cm9sbGVyIGNvbnRleHRcbiAgICAgICAgaWYgKHRyZWUucm91dGVQcmVmaXggIT09ICcvbmV3cy90aWNrZXRzJykge1xuICAgICAgICAgICAgdHJlZS5yb3V0ZVByZWZpeCA9ICcvbmV3cy90aWNrZXRzJ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGVQcm92aWRlci5kYXRhLmN1cnJlbnRQYWdlUmVjb3JkID0gc3RvcmUuZ2V0KGl0ZW1JZCk7XG5cbiAgICAgICAgICAgIGlmICghb2xkVmFsdWU/Lmhhc2hTdHJpbmc/LnN0YXJ0c1dpdGgoJy9uZXdzL3RpY2tldHMnKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRyZWUuZXhwYW5kQW5kU2Nyb2xsVG9JdGVtKGl0ZW1JZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJlZS5leHBhbmRQYXJlbnRzKGl0ZW1JZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHNlbGVjdCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9yZS5vbih7XG4gICAgICAgICAgICAgICAgbG9hZCA6IHNlbGVjdCxcbiAgICAgICAgICAgICAgICBkZWxheTogMTAsXG4gICAgICAgICAgICAgICAgb25jZSA6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU2lkZU5hdlRvZ2dsZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5nZXRSZWZlcmVuY2UoJ3NpZGVuYXYtY29udGFpbmVyJykudG9nZ2xlQ2xzKCduZW8tZXhwYW5kZWQnKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIpO1xuIiwiaW1wb3J0IFRpY2tldExhYmVsc1N0b3JlICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3N0b3JlL1RpY2tldExhYmVscy5tanMnO1xuaW1wb3J0IFRpY2tldFRpbWVsaW5lU2VjdGlvbnNTdG9yZSAgZnJvbSAnLi4vLi4vLi4vc3RvcmUvVGlja2V0VGltZWxpbmVTZWN0aW9ucy5tanMnO1xuaW1wb3J0IFRpY2tldHNTdG9yZSAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3RvcmUvVGlja2V0cy5tanMnO1xuaW1wb3J0IFN0YXRlUHJvdmlkZXIgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL3N0YXRlL1Byb3ZpZGVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlclxuICogQGV4dGVuZHMgTmVvLnN0YXRlLlByb3ZpZGVyXG4gKi9cbmNsYXNzIE1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyIGV4dGVuZHMgU3RhdGVQcm92aWRlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGRhdGEuY291bnRQYWdlcz1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvdW50UGFnZXM6IG51bGwsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBkYXRhLmNvdW50UGFnZXM9bnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb3VudFNlY3Rpb25zOiBudWxsLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcmVjb3JkIHdoaWNoIGdldHMgc2hvd24gYXMgdGhlIGNvbnRlbnQgcGFnZVxuICAgICAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhLmN1cnJlbnRSZWNvcmQ9bnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdXJyZW50UGFnZVJlY29yZDogbnVsbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHJlY29yZCB3aGljaCBnZXRzIHNob3duIGFzIHRoZSBjb250ZW50IHBhZ2VcbiAgICAgICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YS5uZXh0UGFnZVJlY29yZD1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG5leHRQYWdlUmVjb3JkOiBudWxsLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcmVjb3JkIHdoaWNoIGdldHMgc2hvd24gYXMgdGhlIGNvbnRlbnQgcGFnZVxuICAgICAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhLnByZXZpb3VzUGFnZVJlY29yZD1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHByZXZpb3VzUGFnZVJlY29yZDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdG9yZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0b3Jlczoge1xuICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbW9kdWxlICA6IFRpY2tldExhYmVsc1N0b3JlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6IFRpY2tldFRpbWVsaW5lU2VjdGlvbnNTdG9yZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyZWU6IHtcbiAgICAgICAgICAgICAgICBhdXRvTG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtb2R1bGUgIDogVGlja2V0c1N0b3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkRhdGFQcm9wZXJ0eUNoYW5nZShrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5vbkRhdGFQcm9wZXJ0eUNoYW5nZShrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnY291bnRTZWN0aW9ucyc6IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNvbXBvbmVudC5nZXRSZWZlcmVuY2UoJ3BhZ2Utc2VjdGlvbnMtY29udGFpbmVyJyk/LnRvZ2dsZUNscygnbmVvLWV4cGFuZGVkJywgZmFsc2UpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnY3VycmVudFBhZ2VSZWNvcmQnOiB7XG4gICAgICAgICAgICAgICAgbGV0IHtkYXRhfSAgICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgICAgICB7Y291bnRQYWdlc30gICAgICAgPSBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSAgICAgICAgICAgICAgPSBtZS5nZXRTdG9yZSgndHJlZScpLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCAgICAgICAgICAgICAgPSBzdG9yZS5pbmRleE9mKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBhZ2VSZWNvcmQgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNQYWdlUmVjb3JkID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaSwgcmVjb3JkO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxvZ2ljIGFzc3VtZXMgdGhhdCB0aGUgdHJlZSBzdG9yZSBpcyBzb3J0ZWRcbiAgICAgICAgICAgICAgICBmb3IgKGk9aW5kZXgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgJiYgIW1lLnJlY29yZElzSGlkZGVuKHJlY29yZCwgc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2VSZWNvcmQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuc2V0RGF0YSh7cHJldmlvdXNQYWdlUmVjb3JkfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9naWMgYXNzdW1lcyB0aGF0IHRoZSB0cmVlIHN0b3JlIGlzIHNvcnRlZFxuICAgICAgICAgICAgICAgIGZvciAoaT1pbmRleCsxOyBpIDwgY291bnRQYWdlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldEF0KGkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaXNMZWFmICYmICFtZS5yZWNvcmRJc0hpZGRlbihyZWNvcmQsIHN0b3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBhZ2VSZWNvcmQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuc2V0RGF0YSh7bmV4dFBhZ2VSZWNvcmR9KTtcblxuICAgICAgICAgICAgICAgIG1lLmNvbXBvbmVudC5nZXRSZWZlcmVuY2UoJ3NpZGVuYXYtY29udGFpbmVyJyk/LnRvZ2dsZUNscygnbmVvLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBjaGVjayB0aGUgcGFyZW50LW5vZGUgY2hhaW4gaW5zaWRlIHRoZSB0cmVlLlxuICAgICAqID0+IEFueSBoaWRkZW4gcGFyZW50LW5vZGUgcmVzdWx0cyBpbiBhIGhpZGRlbiByZWNvcmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IHN0b3JlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgcmVjb3JkSXNIaWRkZW4ocmVjb3JkLCBzdG9yZSkge1xuICAgICAgICBpZiAocmVjb3JkLmhpZGRlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQucGFyZW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY29yZElzSGlkZGVuKHN0b3JlLmdldChyZWNvcmQucGFyZW50SWQpLCBzdG9yZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIpO1xuIiwiaW1wb3J0IFBhZ2VDb250YWluZXIgZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnRlbnQvUGFnZUNvbnRhaW5lci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuUGFnZUNvbnRhaW5lclxuICogQGV4dGVuZHMgUG9ydGFsLnZpZXcuc2hhcmVkLmNvbnRlbnQuUGFnZUNvbnRhaW5lclxuICovXG5jbGFzcyBUaWNrZXRQYWdlQ29udGFpbmVyIGV4dGVuZHMgUGFnZUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuUGFnZUNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlBhZ2VDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdHlsZT17ZmxleDoxLG92ZXJmbG93WTonYXV0bycscG9zaXRpb246J3JlbGF0aXZlJ31cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiB7ZmxleDogMSwgb3ZlcmZsb3dZOiAnYXV0bycsIHBvc2l0aW9uOiAncmVsYXRpdmUnfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0UGFnZUNvbnRhaW5lcik7XG4iLCJpbXBvcnQgQ2FudmFzIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnQvQ2FudmFzLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIFwiQ29vcmRpbmF0b3JcIiBjb21wb25lbnQgZm9yIHRoZSBOZXVyYWwgVGltZWxpbmUsIGJyaWRnaW5nIHRoZSBBcHAgV29ya2VyIGFuZCBDYW52YXMgV29ya2VyLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IHJlbmRlcnMgYSB0cmFuc3BhcmVudCBjYW52YXMgb3ZlcmxheSBvbiB0b3Agb2YgdGhlIFRpY2tldCBMaXN0LiBJdCBpcyByZXNwb25zaWJsZSBmb3I6XG4gKiAxLiAqKkRhdGEgQnJpZGdlKio6IExpc3RlbmluZyB0byB0aGUgYHNlY3Rpb25zYCBzdG9yZSBhbmQgcGFzc2luZyB0aWNrZXQgZGF0YSB0byB0aGUgYFRpY2tldENhbnZhc2AgKFNoYXJlZFdvcmtlcikuXG4gKiAyLiAqKlZpc3VhbCBBbGlnbm1lbnQqKjogQ2FsY3VsYXRpbmcgdGhlIHByZWNpc2UgRE9NIHBvc2l0aW9ucyBvZiBUaWNrZXQgQXZhdGFycy9CYWRnZXMgdG8gZW5zdXJlIHRoZVxuICogICAgY2FudmFzIG5vZGVzIGFsaWduIHBlcmZlY3RseSB3aXRoIHRoZSBIVE1MIGNvbnRlbnQuXG4gKiAzLiAqKkxpZmVjeWNsZSBNYW5hZ2VtZW50Kio6IGluaXRpYWxpemluZyB0aGUgb2Zmc2NyZWVuIGNhbnZhcyB0cmFuc2ZlciBhbmQgaGFuZGxpbmcgcmVzaXplIGV2ZW50cy5cbiAqXG4gKiBJdCB1c2VzIHRoZSBgUG9ydGFsLmNhbnZhcy5UaWNrZXRDYW52YXNgIHNpbmdsZXRvbiAodmlhIFJlbW90ZSBNZXRob2QgQWNjZXNzKSB0byBkcml2ZSB0aGUgYWN0dWFsIGFuaW1hdGlvbi5cbiAqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlRpbWVsaW5lQ2FudmFzXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkNhbnZhc1xuICovXG5jbGFzcyBUaW1lbGluZUNhbnZhcyBleHRlbmRzIENhbnZhcyB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsYXlhYmxlID0ge1xuICAgICAgICBlbnN1cmVGaW5hbEFsaWdubWVudDoge1xuICAgICAgICAgICAgdHlwZSA6ICdkZWJvdW5jZScsXG4gICAgICAgICAgICB0aW1lcjogMzAwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5UaW1lbGluZUNhbnZhcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlRpbWVsaW5lQ2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGlzdGVuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIHJlc2l6ZTogJ29uUmVzaXplJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdkaXYnLCBjbHM6IFsnbmVvLXRpY2tldC10aW1lbGluZS13cmFwcGVyJ10sIHN0eWxlOiB7d2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSd9LCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ2NhbnZhcycsIHN0eWxlOiB7d2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSd9fVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2FudmFzSWQ9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQ2FudmFzUmVhZHk9ZmFsc2VcbiAgICAgKi9cbiAgICBpc0NhbnZhc1JlYWR5ID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gbGFzdFJlY29yZHM9bnVsbFxuICAgICAqL1xuICAgIGxhc3RSZWNvcmRzID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBlbnN1cmVGaW5hbEFsaWdubWVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUubGFzdFJlY29yZHMpIHtcbiAgICAgICAgICAgIG1lLm9uVGltZWxpbmVEYXRhTG9hZChtZS5sYXN0UmVjb3JkcywgdHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBob29rIHRoYXQgcnVucyBvbmNlIHRoZSBgT2Zmc2NyZWVuQ2FudmFzYCBoYXMgYmVlbiB0cmFuc2ZlcnJlZCB0byB0aGUgQ2FudmFzIFdvcmtlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kOlxuICAgICAqIDEuIEltcG9ydHMgdGhlIGBUaWNrZXRDYW52YXNgIGxvZ2ljIGludG8gdGhlIENhbnZhcyBXb3JrZXIgY29udGV4dC5cbiAgICAgKiAyLiBJbml0aWFsaXplcyB0aGUgZ3JhcGggaW4gdGhlIHdvcmtlciB2aWEgUmVtb3RlIE1ldGhvZCBBY2Nlc3MgKGBpbml0R3JhcGhgKS5cbiAgICAgKiAzLiBTZXRzIHVwIGEgYFJlc2l6ZU9ic2VydmVyYCB0byBrZWVwIHRoZSBjYW52YXMgc2l6ZSBzeW5jZWQgd2l0aCB0aGUgRE9NLlxuICAgICAqIDQuIFRyaWdnZXJzIHRoZSBpbml0aWFsIGRhdGEgbG9hZCBpZiBzdG9yZSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0T2Zmc2NyZWVuUmVnaXN0ZXJlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgbG9naWMgaXMgbG9hZGVkIGluIHRoZSB3b3JrZXJcbiAgICAgICAgICAgIGF3YWl0IFBvcnRhbC5jYW52YXMuSGVscGVyLmltcG9ydFRpY2tldENhbnZhcygpO1xuXG4gICAgICAgICAgICAvLyBEaXJlY3QgUmVtb3RlIE1ldGhvZCBBY2Nlc3MgY2FsbFxuICAgICAgICAgICAgYXdhaXQgUG9ydGFsLmNhbnZhcy5UaWNrZXRDYW52YXMuaW5pdEdyYXBoKHtjYW52YXNJZDogbWUuZ2V0Q2FudmFzSWQoKSwgd2luZG93SWQ6IG1lLndpbmRvd0lkfSk7XG5cbiAgICAgICAgICAgIG1lLmlzQ2FudmFzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBSZWdpc3RlciBSZXNpemVPYnNlcnZlciBmb3IgdGhlIGNhbnZhcyB3cmFwcGVyIChtZS5pZClcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbCBzaXppbmdcbiAgICAgICAgICAgIGF3YWl0IG1lLnVwZGF0ZVNpemUoKTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbCBsb2FkIGNoZWNrXG4gICAgICAgICAgICBsZXQgc3RvcmUgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3NlY3Rpb25zJyk7XG5cbiAgICAgICAgICAgIGlmIChzdG9yZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgIG1lLm9uVGltZWxpbmVEYXRhTG9hZChzdG9yZS5pdGVtcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUuaXNDYW52YXNSZWFkeSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gU3RvcCB0aGUgd29ya2VyIGxvb3AgdG8gcHJldmVudCBcIlpvbWJpZSBDYW52YXNcIiBDUFUgdXNhZ2VcbiAgICAgICAgICAgIGF3YWl0IFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzLmNsZWFyR3JhcGgoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gcmV0dXJuIHRoZSBpbm5lciBjYW52YXMgSURcbiAgICAgKi9cbiAgICBnZXRDYW52YXNJZCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmNhbnZhc0lkKSB7XG4gICAgICAgICAgICBtZS5jYW52YXNJZCA9IG1lLnZkb20uY25bMF0uaWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWUuY2FudmFzSWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RvcmUgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3NlY3Rpb25zJyk7XG5cbiAgICAgICAgc3RvcmUub24oJ2xvYWQnLCBtZS5vblRpbWVsaW5lRGF0YUxvYWQsIG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25SZXNpemUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY2FudmFzIHNpemUgaW4gdGhlIHdvcmtlclxuICAgICAgICBhd2FpdCBtZS51cGRhdGVTaXplKGRhdGEuY29udGVudFJlY3QpO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgY2FjaGVkIHJlY29yZHMsIHJlLWNhbGN1bGF0ZSBub2RlIHBvc2l0aW9uc1xuICAgICAgICAvLyBiZWNhdXNlIHRoZSBjb250YWluZXIgZGltZW5zaW9ucyAoYW5kIGxpa2VseSByZWxhdGl2ZSBwb3NpdGlvbnMpIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgaWYgKG1lLmxhc3RSZWNvcmRzKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWZldGNoIHJlY3RzIGluc3RhbnRseSwgYnV0IGl0J3Mgc2FmZXIgdG8gZG8gc29cbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBhbGlnbm1lbnQgd2l0aCB0aGUgbmV3IGxheW91dC5cbiAgICAgICAgICAgIGF3YWl0IG1lLm9uVGltZWxpbmVEYXRhTG9hZChtZS5sYXN0UmVjb3JkcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIERlYm91bmNlZCBjaGVjayB0byBlbnN1cmUgdGhlIGNhbnZhcyBpcyBhbGlnbmVkIGFmdGVyIGFueSB0cmFuc2l0aW9ucyBzZXR0bGVcbiAgICAgICAgICAgIG1lLmVuc3VyZUZpbmFsQWxpZ25tZW50KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb3JlIFwiQWxpZ25tZW50IEVuZ2luZVwiIG9mIHRoZSB0aW1lbGluZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHN5bmNocm9uaXplcyB0aGUgQ2FudmFzIG5vZGVzIHdpdGggdGhlIERPTSBlbGVtZW50cyAoQXZhdGFycy9CYWRnZXMpLlxuICAgICAqXG4gICAgICogKipTdHJhdGVneToqKlxuICAgICAqIDEuICoqVGFyZ2V0aW5nKio6IEl0IHVzZXMgdGhlIGAtdGFyZ2V0YCBJRCBzdWZmaXggdG8gZmluZCB0aGUgc3BlY2lmaWMgRE9NIGVsZW1lbnRzIChBdmF0YXJzKSB3aXRoaW4gdGhlIHRpY2tldCBsaXN0LlxuICAgICAqIDIuICoqTWVhc3VyZW1lbnQqKjogSXQgZmV0Y2hlcyB0aGUgYERPTVJlY3RgIGZvciBldmVyeSB0YXJnZXQgdG8gZ2V0IGl0cyBleGFjdCBzY3JlZW4gcG9zaXRpb24uXG4gICAgICogMy4gKipUcmFuc2xhdGlvbioqOiBJdCBjb252ZXJ0cyB0aGVzZSBzY3JlZW4gY29vcmRpbmF0ZXMgaW50byBDYW52YXMtbG9jYWwgY29vcmRpbmF0ZXMuXG4gICAgICogNC4gKipIYW5kb2ZmKio6IEl0IHBhY2thZ2VzIHRoaXMgZ2VvbWV0cmljIGRhdGEgKHgsIHksIHJhZGl1cywgY29sb3IpIGFuZCBzZW5kcyBpdCB0byB0aGVcbiAgICAgKiAgICBgVGlja2V0Q2FudmFzYCB3b3JrZXIgdG8gdXBkYXRlIHRoZSBwaHlzaWNzIHNpbXVsYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfE9iamVjdH0gcmVjb3JkcyBBcnJheSBvZiByZWNvcmRzIG9yIFN0b3JlIGxvYWQgZXZlbnQgb2JqZWN0IHtpdGVtczogWy4uLl19XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNSZXNpemU9ZmFsc2VdXG4gICAgICovXG4gICAgYXN5bmMgb25UaW1lbGluZURhdGFMb2FkKHJlY29yZHMsIGlzUmVzaXplID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBIYW5kbGUgU3RvcmUgJ2xvYWQnIGV2ZW50IHNpZ25hdHVyZTogZmlyZSgnbG9hZCcsIHtpdGVtczogWy4uLl19KVxuICAgICAgICBpZiAocmVjb3JkcyAmJiAhQXJyYXkuaXNBcnJheShyZWNvcmRzKSAmJiByZWNvcmRzLml0ZW1zKSB7XG4gICAgICAgICAgICByZWNvcmRzID0gcmVjb3Jkcy5pdGVtc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlY29yZHMpKSB7XG4gICAgICAgICAgICAvLyBTYWZldHkgY2hlY2sgaWYgcmVjb3JkcyBpcyBzdGlsbCBpbnZhbGlkXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUuaXNDYW52YXNSZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzZXQgPSAhaXNSZXNpemU7XG5cbiAgICAgICAgLy8gU21hcnQgQ2hlY2s6IElmIGl0J3MgYSBzdG9yZSBsb2FkIChyZXNldD10cnVlKSBCVVQgdGhlIHRpY2tldCBJRCBpcyB0aGUgc2FtZSxcbiAgICAgICAgLy8gaXQncyBhIGRhdGEgcmVmcmVzaCAoZS5nLiBjb21tZW50IGFkZGVkKSwgc28gd2Ugc2hvdWxkIE5PVCByZXNldCB0aGUgYW5pbWF0aW9uLlxuICAgICAgICBpZiAocmVzZXQgJiYgbWUubGFzdFJlY29yZHMgJiYgcmVjb3Jkc1swXT8uaWQgPT09IG1lLmxhc3RSZWNvcmRzWzBdPy5pZCkge1xuICAgICAgICAgICAgcmVzZXQgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUubGFzdFJlY29yZHMgPSByZWNvcmRzO1xuXG4gICAgICAgIGxldCBpZHMgPSByZWNvcmRzLm1hcChyID0+IGAke3IuaWR9LXRhcmdldGApLFxuICAgICAgICAgICAgcmVjdHM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZldGNoIERPTSByZWN0cyBmb3IgdGhlIE1BUktFUlMgKEF2YXRhcnMvQmFkZ2VzKSwgbm90IHRoZSBjb250YWluZXJzXG4gICAgICAgICAgICByZWN0cyA9IGF3YWl0IG1lLndhaXRGb3JEb21SZWN0KHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0czogMjAsXG4gICAgICAgICAgICAgICAgZGVsYXkgICA6IDUwLFxuICAgICAgICAgICAgICAgIGlkICAgICAgOiBpZHNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWUubGFzdFJlY29yZHMgIT09IHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgZ290IHZhbGlkIHJlY3RzIChhdCBsZWFzdCBvbmUpXG4gICAgICAgICAgICBsZXQgaGFzUmVjdHMgPSByZWN0cyAmJiByZWN0cy5zb21lKHIgPT4gcik7XG5cbiAgICAgICAgICAgIGlmICghaGFzUmVjdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT24gZmlyc3QgdmFsaWQgZGF0YSBsb2FkIChub3QgcmVzaXplKSwgZW5zdXJlIHNpemUgaXMgc3luY2VkXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNvbnRlbnQgbWlnaHQgaGF2ZSBwdXNoZWQgdGhlIGNvbnRhaW5lciBoZWlnaHQuXG4gICAgICAgICAgICBpZiAoIWlzUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUudXBkYXRlU2l6ZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjYW52YXNSZWN0ID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChtZS5nZXRDYW52YXNJZCgpKSxcbiAgICAgICAgICAgICAgICBub2RlcyAgICAgID0gW10sXG4gICAgICAgICAgICAgICAgc3RhcnRZICAgICA9IDA7XG5cbiAgICAgICAgICAgIGlkcy5mb3JFYWNoKCh0YXJnZXRJZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCAgID0gcmVjdHNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSByZWNvcmRzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBSRUNJU0UgQ0VOVEVSSU5HXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyAncmVjdCcgaXMgdGhlIGFjdHVhbCBhdmF0YXIvYmFkZ2UuXG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSByZWN0LmhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWSAgPSByZWN0LnkgLSBjYW52YXNSZWN0LnkgKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWCAgPSByZWN0LnggLSBjYW52YXNSZWN0LnggKyAocmVjdC53aWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzdGluY3QgcGFkZGluZyBmb3IgT3JiaXQgZWZmZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdmF0YXJzICh+NDBweCkgZ2V0IG1vcmUgYnJlYXRoaW5nIHJvb20gdGhhbiBCYWRnZXMgKH4yOHB4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHJlY3QuaGVpZ2h0ID4gMzIgPyA2IDogMztcblxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yIDogcmVjb3JkLmNvbG9yLCAvLyBQYXNzIEhleCBDb2xvciAoZS5nLiAjZmYwMDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgOiByZWNvcmQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IG9mZnNldCArIHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICAgICA6IG5vZGVZLFxuICAgICAgICAgICAgICAgICAgICAgICAgeCAgICAgOiBub2RlWFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0WSBvZiB0aGUgbGluZSB0byB0aGUgZmlyc3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IG5vZGVZXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgUG9ydGFsLmNhbnZhcy5UaWNrZXRDYW52YXMudXBkYXRlR3JhcGhEYXRhKHtub2RlcywgcmVzZXQsIHN0YXJ0WX0pXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RpbWVsaW5lQ2FudmFzIHVwZGF0ZSBmYWlsZWQnLCBlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gcmVjdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVNpemUocmVjdCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LndpZHRoID09PSAwIHx8IHJlY3QuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZWN0ID0gYXdhaXQgbWUud2FpdEZvckRvbVJlY3Qoe2lkOiBtZS5nZXRDYW52YXNJZCgpfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzLnVwZGF0ZVNpemUoe3dpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0fSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpbWVsaW5lQ2FudmFzKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQ2FudmFzXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQ2FudmFzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuQ2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkNhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyBhIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIgYW5kIGZpcmVzIGEgY3VzdG9tIHJlc2l6ZSBldmVudFxuICAgICAgICAgKiB3aGljaCBvdGhlciBpbnN0YW5jZXMgY2FuIHN1YnNjcmliZSB0by5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9uaXRvclNpemVfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb25pdG9yU2l6ZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvZmZzY3JlZW49dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2NyZWVuOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBhcHBsaWNhYmxlIGlmIG9mZnNjcmVlbiA9PT0gdHJ1ZS5cbiAgICAgICAgICogdHJ1ZSBvbmNlIHRoZSBvd25lcnNoaXAgb2YgdGhlIGNhbnZhcyBub2RlIGdvdCB0cmFuc2ZlcnJlZCB0byB3b3JrZXIuQ2FudmFzLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvZmZzY3JlZW5SZWdpc3RlcmVkXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNjcmVlblJlZ2lzdGVyZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb209e3RhZzogJ2NhbnZhcyd9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ2NhbnZhcyd9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlkICAgICAgICAgID0gbWUuZ2V0Q2FudmFzSWQoKSxcbiAgICAgICAgICAgIHtvZmZzY3JlZW59ID0gbWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTsgLy8gbmV4dCByQUYgdGlja1xuXG4gICAgICAgICAgICBpZiAobWUubW9uaXRvclNpemUpIHtcbiAgICAgICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGU6IGAjJHttZS5nZXRDYW52YXNJZCgpfWAsXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZSAgOiBtZS5vbkRvbVJlc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgICA6IG1lXG4gICAgICAgICAgICAgICAgfV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLmdldE9mZnNjcmVlbkNhbnZhcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCAgOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5vZmZzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgTmVvLndvcmtlci5DYW52YXMucmVnaXN0ZXJDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSAgICA6IGRhdGEub2Zmc2NyZWVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkICA6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICAgICAgICAgIH0sIFtkYXRhLm9mZnNjcmVlbl0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnRyYW5zZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8uY29uZmlnLnVzZVNoYXJlZFdvcmtlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXRyaWV2ZURhdGEgPSBhd2FpdCBOZW8ud29ya2VyLkNhbnZhcy5yZXRyaWV2ZUNhbnZhcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkICA6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyaWV2ZURhdGEuaGFzQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUub2Zmc2NyZWVuUmVnaXN0ZXJlZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZzY3JlZW4pIHtcbiAgICAgICAgICAgIG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNjcmVlblJlZ2lzdGVyZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2Qgd2hlbiB1c2luZyB3cmFwcGVycyAoZS5nLiBEMylcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENhbnZhc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Eb21SZXNpemUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3Jlc2l6ZScsIGRhdGEpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDYW52YXMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==