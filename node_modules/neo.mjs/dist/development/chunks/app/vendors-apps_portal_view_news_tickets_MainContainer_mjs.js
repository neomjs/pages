"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_portal_view_news_tickets_MainContainer_mjs"],{

/***/ "./apps/portal/model/Ticket.mjs"
/*!**************************************!*\
  !*** ./apps/portal/model/Ticket.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.Ticket
 * @extends Neo.data.Model
 */
class Ticket extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.Ticket'
         * @protected
         */
        className: 'Portal.model.Ticket',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name        : 'collapsed',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name: 'id',
            type: 'String'
        }, {
            name        : 'isLeaf',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name        : 'parentId',
            type        : 'String',
            defaultValue: null
        }, {
            name: 'path', // "resources/content/issues/issue-1234.md"
            type: 'String'
        }, {
            name: 'title', // "Fix elusive bug in Grid"
            type: 'String'
        }, {
            // Computed field for TreeList display
            name: 'treeNodeName',
            type: 'html',
            /**
             * @param {Object}  data
             * @param {String}  data.id
             * @param {Boolean} data.isLeaf
             * @param {String}  data.title
             * @returns {String}
             */
            calculate({id, isLeaf, title}) {
                return isLeaf ? `<b>${id}</b> ${title}` : id
            }
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Ticket));


/***/ },

/***/ "./apps/portal/model/TicketLabel.mjs"
/*!*******************************************!*\
  !*** ./apps/portal/model/TicketLabel.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.TicketLabel
 * @extends Neo.data.Model
 */
class TicketLabel extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketLabel'
         * @protected
         */
        className: 'Portal.model.TicketLabel',
        /**
         * @member {Object[]} fields
         * @protected
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'description',
            type: 'String'
        }, {
            name: 'name',
            type: 'String'
        }, {
            name: 'textColor',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabel));


/***/ },

/***/ "./apps/portal/model/TicketTimelineSection.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/model/TicketTimelineSection.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSection.mjs */ "./apps/portal/model/ContentSection.mjs");


/**
 * @class Portal.model.TicketTimelineSection
 * @extends Portal.model.ContentSection
 */
class TicketTimelineSection extends _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketTimelineSection'
         * @protected
         */
        className: 'Portal.model.TicketTimelineSection',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'icon',
            type: 'String'
        }, {
            name: 'image',
            type: 'String'
        }, {
            name: 'sourceId',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSection));


/***/ },

/***/ "./apps/portal/store/TicketLabels.mjs"
/*!********************************************!*\
  !*** ./apps/portal/store/TicketLabels.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/TicketLabel.mjs */ "./apps/portal/model/TicketLabel.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Portal.store.TicketLabels
 * @extends Neo.data.Store
 */
class TicketLabels extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketLabels'
         * @protected
         */
        className: 'Portal.store.TicketLabels',
        /**
         * @member {String} keyProperty='name'
         * @protected
         */
        keyProperty: 'name',
        /**
         * @member {Neo.data.Model} model=TicketLabel
         * @protected
         */
        model: _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/labels.json'
         * @protected
         */
        url: '../../apps/portal/resources/data/labels.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabels));


/***/ },

/***/ "./apps/portal/store/TicketTimelineSections.mjs"
/*!******************************************************!*\
  !*** ./apps/portal/store/TicketTimelineSections.mjs ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSections.mjs */ "./apps/portal/store/ContentSections.mjs");
/* harmony import */ var _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/TicketTimelineSection.mjs */ "./apps/portal/model/TicketTimelineSection.mjs");



/**
 * @class Portal.store.TicketTimelineSections
 * @extends Portal.store.ContentSections
 */
class TicketTimelineSections extends _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketTimelineSections'
         * @protected
         */
        className: 'Portal.store.TicketTimelineSections',
        /**
         * @member {Neo.data.Model} model=TicketTimelineSection
         * @reactive
         */
        model: _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSections));


/***/ },

/***/ "./apps/portal/store/Tickets.mjs"
/*!***************************************!*\
  !*** ./apps/portal/store/Tickets.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Ticket.mjs */ "./apps/portal/model/Ticket.mjs");



/**
 * @class Portal.store.Tickets
 * @extends Neo.data.Store
 */
class Tickets extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.Tickets'
         * @protected
         */
        className: 'Portal.store.Tickets',
        /**
         * @member {Neo.data.Model} model=TicketModel
         * @reactive
         */
        model: _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/tickets.json'
         */
        url: '../../apps/portal/resources/data/tickets.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tickets));


/***/ },

/***/ "./apps/portal/view/news/tickets/CanvasWrapper.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/CanvasWrapper.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./apps/portal/view/news/tickets/Component.mjs");
/* harmony import */ var _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TimelineCanvas.mjs */ "./apps/portal/view/news/tickets/TimelineCanvas.mjs");




/**
 * @class Portal.view.news.tickets.CanvasWrapper
 * @extends Neo.container.Base
 */
class CanvasWrapper extends _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.CanvasWrapper'
         * @protected
         */
        className: 'Portal.view.news.tickets.CanvasWrapper',
        /**
         * @member {String[]} cls=['portal-canvas-wrapper']
         */
        cls: ['portal-canvas-wrapper'],
        /**
         * @member {Neo.component.Base|null} contentComponent=ContentComponent
         */
        contentComponent: _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={minHeight:'100%',overflow:'visible',position:'relative'}
         */
        style: {minHeight: '100%', overflow: 'visible', position: 'relative'}
    }

    construct(config) {
        let me = this;

        config.items = [{
            module: _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            style : {
                position     : 'absolute',
                top          : 0,
                left         : 0,
                width        : '100%',
                height       : '100%',
                zIndex       : 2,
                pointerEvents: 'none'
            }
        }, {
            module: config.contentComponent || me.contentComponent,
            style : {
                position: 'relative',
                zIndex  : 1
            },
            listeners: {
                edit   : me.onContentEdit,
                refresh: me.onContentRefresh,
                scope  : me
            }
        }];

        super.construct(config);
    }

    /**
     * @param {Object} data
     */
    onContentEdit(data) {
        this.fire('edit', data)
    }

    /**
     * @param {Object} data
     */
    onContentRefresh(data) {
        this.fire('refresh', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CanvasWrapper));


/***/ },

/***/ "./apps/portal/view/news/tickets/Component.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/view/news/tickets/Component.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/content/Component.mjs */ "./apps/portal/view/shared/content/Component.mjs");
/* harmony import */ var _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../node_modules/marked/lib/marked.esm.js */ "./node_modules/marked/lib/marked.esm.js");



const
    regexFrontMatter   = /^---\n([\s\S]*?)\n---\n/,
    regexH1            = /(<h1[^>]*>.*?<\/h1>)/,
    regexTicketLink    = /(\d{4,})/,
    regexTimeline      = /## Timeline\s*\n([\s\S]*)/,
    regexTimelineEvent = /^- ([\dTZ:.-]+) @(\w+) (.*)$/,
    regexCommit        = /\b([0-9a-f]{7,40})\b/g;

/**
 * @summary The "Markdown Transformer" for GitHub Tickets.
 *
 * This component extends the standard ContentComponent to provide specialized rendering for GitHub Issues.
 * Its primary responsibility is to parse the raw Markdown content (which includes custom Frontmatter and
 * a pre-generated Timeline section) and transform it into a rich, interactive HTML structure.
 *
 * **Key Responsibilities:**
 * 1. **Parsing Pipeline**: Extracts Frontmatter, Body, and the custom "Timeline" section from the raw Markdown.
 * 2. **Rich Rendering**: Generates HTML for Status Badges, Labels, Commit Links, and User Mentions.
 * 3. **Data Extraction**: As a side effect of rendering, it extracts structured data (`me.timelineData`)
 *    representing every timeline event (comment, label change, close, etc.). This data is then
 *    pushed to the `sections` store to drive the `TimelineCanvas` visualization.
 *
 * @class Portal.view.news.tickets.Component
 * @extends Portal.view.shared.content.Component
 */
class Component extends _shared_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.Component'
         * @protected
         */
        className: 'Portal.view.news.tickets.Component',
        /**
         * @member {String[]} cls=['portal-news-tickets-component']
         */
        cls: ['portal-news-tickets-component'],
        /**
         * @member {String} commitsUrl='https://github.com/neomjs/neo/commit/'
         */
        commitsUrl: 'https://github.com/neomjs/neo/commit/',
        /**
         * @member {String} repoUserUrl='https://github.com/'
         */
        repoUserUrl: 'https://github.com/',
        /**
         * @member {Boolean} updateSectionsStore=false
         */
        updateSectionsStore: false
    }

    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatHistory=null
     */
    #dateTimeFormatHistory = null
    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatToday=null
     */
    #dateTimeFormatToday = null
    /**
     * Temporary storage for the structured timeline data extracted during the parsing phase.
     * This array is populated by `renderTimeline` and `modifyMarkdown` and then assigned
     * to the `sections` store to drive the Canvas visualization.
     * @member {Object[]} timelineData=null
     * @private
     */
    timelineData = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.getStateProvider().setData('contentComponentId', this.id)
    }

    /**
     * @param {String} isoString
     * @returns {String}
     */
    formatTimestamp(isoString) {
        if (!isoString) return '';

        let me      = this,
            date    = new Date(isoString),
            now     = new Date(),
            isToday = date.toDateString() === now.toDateString();

        if (isToday) {
            if (!me.#dateTimeFormatToday) {
                me.#dateTimeFormatToday = new Intl.DateTimeFormat('default', {
                    hour  : 'numeric',
                    minute: 'numeric'
                })
            }

            return me.#dateTimeFormatToday.format(date)
        }

        if (!me.#dateTimeFormatHistory) {
            me.#dateTimeFormatHistory = new Intl.DateTimeFormat('default', {
                day   : 'numeric',
                hour  : 'numeric',
                minute: 'numeric',
                month : 'short',
                year  : 'numeric'
            })
        }

        return me.#dateTimeFormatHistory.format(date)
    }

    /**
     * @param {Object} data
     * @returns {String}
     */
    frontMatterToHtml(data) {
        let me   = this,
            html = '<table class="neo-frontmatter-table"><tbody>';

        Object.entries(data).forEach(([key, value]) => {
            let renderedValue;

            if (key === 'subIssues' && Array.isArray(value)) {
                renderedValue = value.map(issue => {
                    return `<div class="neo-sub-issue">${issue
                        .replace(regexTicketLink, '<a href="#/news/tickets/$1">$1</a>')
                        .replace('[x]', '<i class="fa-solid fa-circle-check"></i>')
                        .replace('[ ]', '<i class="fa-regular fa-circle"></i>')}</div>`
                }).join('')
            } else if (key === 'author') {
                renderedValue = `<a href="${me.repoUserUrl}${value}" target="_blank">${value}</a>`
            } else if (key === 'createdAt' || key === 'closedAt' || key === 'updatedAt') {
                renderedValue = me.formatTimestamp(value)
            } else if (key === 'labels' && Array.isArray(value)) {
                renderedValue = me.getBadgesHtml(value)
            } else if (key === 'state') {
                renderedValue = me.getStateBadgeHtml(value)
            } else {
                renderedValue = me.formatFrontMatterValue(value)
            }

            html += `<tr><td>${key}</td><td>${renderedValue}</td></tr>`
        });

        html += '</tbody></table>';

        if (me.useFrontmatterDetails) {
            return `<details><summary>Frontmatter</summary>${html}</details>`
        }

        return html
    }

    /**
     * @param {String[]} labels
     * @returns {String}
     */
    getBadgesHtml(labels) {
        if (!labels || labels.length === 0) return '';

        let me         = this,
            badgesHtml = '<div class="neo-ticket-labels">';

        labels.forEach(label => {
            badgesHtml += me.getLabelBadgeHtml(label)
        });

        badgesHtml += '</div>';

        return badgesHtml
    }

    /**
     * @param {Object} record
     * @returns {Promise<void>}
     */
    async doFetchContent(record) {
        let me         = this,
            {windowId} = me,
            content, data, path;

        path = me.getContentPath(record);

        if (record.isLeaf && path) {
            data    = await fetch(path);
            content = await data.text();

            me.value = content;

            me.toggleCls('lab', record.name?.startsWith('Lab:'));

            Neo.main.addon.IntersectionObserver.observe({
                disconnect: true,
                id        : me.id,
                observe   : ['.neo-timeline-item[data-record-id]'],
                windowId
            })
        }
    }

    /**
     * @param {Object} record
     * @param {String} record.path
     * @returns {String|null}
     */
    getContentPath({path}) {
        return path ? Neo.config.basePath + path : null
    }

    /**
     * @param {String} label
     * @returns {String}
     */
    getLabelBadgeHtml(label) {
        let store  = this.getStateProvider().getStore('labels'),
            record = store.get(label);

        if (record) {
            return `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
        }

        return `<span class="neo-badge">${label}</span>`
    }

    /**
     * @param {String} state
     * @returns {String}
     */
    getStateBadgeHtml(state) {
        if (!state) return '';

        let cls  = 'neo-badge neo-state-badge',
            icon = 'fa-circle-dot';

        if (state.toUpperCase() === 'CLOSED') {
            cls  += ' neo-state-closed';
            icon  = 'fa-circle-check'
        } else {
            cls += ' neo-state-open'
        }

        return `<span class="${cls}"><i class="fa-regular ${icon}"></i>${Neo.capitalize(state.toLowerCase())}</span>`
    }

    /**
     * The Main Parsing Pipeline.
     *
     * This method intercepts the raw markdown content before it is rendered and performs a multi-pass transformation:
     * 1. **Extract Timeline**: Pulls out the raw `## Timeline` section to process it separately.
     * 2. **Process Frontmatter**: Extracts metadata (labels, state, author) and removes the YAML block.
     * 3. **Render Body**: Uses the superclass (marked.js) to convert the main issue body to HTML.
     * 4. **Inject Title IDs**: Adds IDs to H1 tags for navigation.
     * 5. **Generate Badges**: Creates HTML for Status/Label badges based on extracted metadata.
     * 6. **Wrap Body**: Wraps the main issue body in a `timeline-item` structure so it appears as the first item.
     * 7. **Re-Assemble**: Concatenates Frontmatter + Title + Timeline (with Body injected) into the final HTML.
     *
     * **Side Effect**: Populates `me.timelineData` and updates the `sections` store.
     *
     * @param {String} content
     * @returns {String}
     */
    modifyMarkdown(content) {
        let me           = this,
            {parentId}   = me.record,
            author       = null,
            createdAt    = null,
            labels       = [],
            state        = null,
            match        = content.match(regexFrontMatter),
            timelineHtml = '',
            badgesHtml   = '';

        me.timelineData = [];

        if (match) {
            let data = me.parseFrontMatter(match[1]);

            if (data.author)    {author    = data.author}
            if (data.createdAt) {createdAt = me.formatTimestamp(data.createdAt)}
            if (data.labels)    {labels    = data.labels}
            if (data.state)     {state     = data.state}
        }

        // 1. Extract and process timeline from RAW markdown
        let timelineMatch = content.match(regexTimeline);
        if (timelineMatch) {
            timelineHtml = me.renderTimeline(timelineMatch[1]);
            content      = content.replace(regexTimeline, ''); // Remove raw timeline
        }

        // 2. Render Frontmatter Manually & Strip it
        // We want it at the very top, outside the body bubble.
        let frontMatterHtml = '';
        if (match) {
            let data        = me.parseFrontMatter(match[1]);
            frontMatterHtml = me.frontMatterToHtml(data);
            content         = content.replace(regexFrontMatter, '');
        }

        // 3. Convert Body + Title to HTML using super
        let fullHtml = super.modifyMarkdown(content);

        // 4. Extract H1 Title from the generated HTML
        let titleHtml = '';
        fullHtml      = fullHtml.replace(regexH1, (match) => {
            // Inject ID into H1 tag
            titleHtml = match.replace('<h1', `<h1 id="ticket-title-${me.id}"`);
            return ''; // Remove title from body
        });

        // 5. Construct Badges
        if (labels.length > 0 || state || (parentId && parentId !== 'Latest')) {
            badgesHtml = '<div class="neo-ticket-labels">';

            if (state) {
                badgesHtml += me.getStateBadgeHtml(state)
            }

            if (parentId && parentId !== 'Latest') {
                badgesHtml += `
                    <a class="neo-badge neo-release-badge" href="#/news/releases/${parentId.substring(1)}">
                        <i class="fa-solid fa-code-branch"></i> ${parentId}
                    </a>`
            }

            if (labels.length > 0) {
                let store = me.getStateProvider().getStore('labels'),
                    record;

                labels.forEach(label => {
                    record = store.get(label);

                    if (record) {
                        badgesHtml += `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
                    } else {
                        badgesHtml += `<span class="neo-badge">${label}</span>`
                    }
                });
            }

            badgesHtml += '</div>';
            titleHtml  += badgesHtml;
        }

        // 6. Wrap the remaining HTML (Body) in the Timeline Item structure
        let bodyId = `timeline-${me.record.id}-0`;

        me.timelineData.unshift({
            id   : bodyId,
            image: me.repoUserUrl + author + '.png',
            name : 'Description',
            tag  : 'body'
        });

        let bodyItemHtml = `
            <div id="${bodyId}" class="neo-timeline-item comment body-item" data-record-id="${bodyId}">
                <div id="${bodyId}-target" class="neo-timeline-avatar">
                    <img src="${me.repoUserUrl}${author}.png" alt="${author}">
                </div>
                <div class="neo-timeline-content">
                    <div class="neo-timeline-header">
                        <a class="neo-timeline-user" href="${me.repoUserUrl}${author}" target="_blank">${author}</a>
                        <span class="neo-timeline-date">commented on ${createdAt}</span>
                    </div>
                    <div class="neo-timeline-body">${fullHtml}</div>
                </div>
            </div>`;

        // 7. Inject Body Item at the start of the Timeline
        let timelineId = `ticket-timeline-${me.id}`;

        if (timelineHtml) {
            timelineHtml = timelineHtml.replace(
                '<div class="neo-ticket-timeline">',
                `<div id="${timelineId}" class="neo-ticket-timeline">` + bodyItemHtml
            )
        } else {
            timelineHtml = `<div id="${timelineId}" class="neo-ticket-timeline">${bodyItemHtml}</div>`
        }

        me.getStateProvider().getStore('sections').data = me.timelineData;
        me.timelineData = null;

        // Return: Frontmatter + Title + Timeline
        return frontMatterHtml + titleHtml + timelineHtml
    }

    /**
     * Parses the custom "Timeline" markdown section.
     *
     * Expects a line-based format generated by the build process:
     * - Events: `- YYYY-MM-DDTHH:mm:ss @user action text...`
     * - Comments: `### @user - YYYY-MM-DDTHH:mm:ss` followed by comment body.
     *
     * This method converts these lines into structured `timeline-item` HTML blocks
     * and simultaneously populates `me.timelineData` with semantic data (color, icon, type)
     * for each event.
     *
     * @param {String} content
     * @returns {String}
     */
    renderTimeline(content) {
        let me          = this,
            {commitsUrl, repoUserUrl} = me,
            html        = '<div class="neo-ticket-timeline">',
            lines       = content.split('\n'),
            commentBuf  = [],
            currentUser = null,
            currentDate = null,
            i           = 0,
            len         = lines.length,
            id, line, match, icon, actionCls;

        const flushComment = () => {
            if (commentBuf.length > 0) {
                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                me.timelineData.push({
                    id   : id,
                    image: repoUserUrl + currentUser + '.png',
                    name : `Comment (${currentUser})`,
                    tag  : 'comment'
                });

                let body = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parse(commentBuf.join('\n'));
                html += `
                    <div id="${id}" class="neo-timeline-item comment" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-avatar">
                            <img src="${repoUserUrl}${currentUser}.png" alt="${currentUser}">
                        </div>
                        <div class="neo-timeline-content">
                            <div class="neo-timeline-header">
                                <a class="neo-timeline-user" href="${repoUserUrl}${currentUser}" target="_blank">${currentUser}</a>
                                <span class="neo-timeline-date">${me.formatTimestamp(currentDate)}</span>
                            </div>
                            <div class="neo-timeline-body">${body}</div>
                        </div>
                    </div>`;
                commentBuf  = [];
                currentUser = null;
                currentDate = null
            }
        };

        for (; i < len; i++) {
            line = lines[i];

            // Event Line: - 2026-01-11T... @user action...
            if ((match = line.match(regexTimelineEvent))) {
                flushComment();
                let [_, date, user, action] = match;

                icon      = 'fa-circle-dot'; // Default
                actionCls = '';

                const eventType = [
                    {key: 'added the `',      icon: 'fa-tag'},
                    {key: 'removed the `',    icon: 'fa-tag'},
                    {key: 'assigned',         icon: 'fa-user-pen'},
                    {key: 'closed',           icon: 'fa-circle-check', color: '#8250df'}, // GitHub Purple
                    {key: 'reopened',         icon: 'fa-circle-dot',   color: '#2da44e'}, // GitHub Green
                    {key: 'referenced',       icon: 'fa-link'},
                    {key: 'cross-referenced', icon: 'fa-link'},
                    {key: 'milestoned',       icon: 'fa-sign-post'},
                    {key: 'sub-issue',        icon: 'fa-diagram-project'}
                ].find(e => action.includes(e.key));

                let color = null;

                if (eventType) {
                    icon = eventType.icon;
                    if (eventType.color) color = eventType.color
                }

                // Clean up markdown in action text (e.g. `code` to <code>)
                let cleanAction = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parseInline(action);

                if (icon === 'fa-tag') {
                    cleanAction = cleanAction.replace(/<code>(.*?)<\/code>/g, (match, label) => me.getLabelBadgeHtml(label));

                    // Try to resolve color from label
                    let labelMatch = action.match(/`([^`]+)`/);
                    if (labelMatch) {
                        let labelName = labelMatch[1];
                        let labelRec  = me.getStateProvider().getStore('labels').get(labelName);
                        if (labelRec) {
                            color = labelRec.color;
                        }
                    }
                }

                // Linkify Commit Hashes
                cleanAction = cleanAction.replace(regexCommit, `<a href="${commitsUrl}$1" target="_blank">$1</a>`);

                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                // Extract a short action name for the list
                let shortAction = action.split(' ')[0]; // 'added', 'closed', etc.

                if (shortAction === 'added' || shortAction === 'removed') {
                    let labelMatch = action.match(/`([^`]+)`/);
                    shortAction = labelMatch ? labelMatch[1] : 'Label'
                }

                me.timelineData.push({
                    color: color, // Pass resolved hex color
                    icon : icon,
                    id   : id,
                    name : `${Neo.capitalize(shortAction)} (${user})`,
                    tag  : 'event'
                });

                // Apply color style if present, otherwise default
                let style = color ? `style="color: ${color}"` : '';

                html += `
                    <div id="${id}" class="neo-timeline-item event" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-badge" ${style}><i class="fa-solid ${icon}"></i></div>
                        <div class="neo-timeline-body">
                            <a class="neo-timeline-user" href="${repoUserUrl}${user}" target="_blank">${user}</a> ${cleanAction} <span class="neo-timeline-date">on ${me.formatTimestamp(date)}</span>
                        </div>
                    </div>`;
            }
            // Comment Header: ### @user - 2026-01-11T...
            else if (line.startsWith('### @')) {
                // Captures "user" and "2026-01-11T..." (ISO timestamp)
                let headerMatch = line.match(/^### @(\w+) - ([\dTZ:.-]+)$/);
                if (headerMatch) {
                    flushComment();
                    currentUser = headerMatch[1];
                    currentDate = headerMatch[2]
                } else {
                    // Fallback for weird headers? treat as text
                    if (currentUser) commentBuf.push(line)
                }
            }
            else {
                if (currentUser) {
                    commentBuf.push(line)
                }
            }
        }

        flushComment(); // Flush last comment

        html += '</div>';
        return html
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasWrapper.mjs */ "./apps/portal/view/news/tickets/CanvasWrapper.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/portal/view/news/tickets/MainContainerController.mjs");
/* harmony import */ var _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PageContainer.mjs */ "./apps/portal/view/news/tickets/PageContainer.mjs");
/* harmony import */ var _shared_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/content/Container.mjs */ "./apps/portal/view/shared/content/Container.mjs");
/* harmony import */ var _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MainContainerStateProvider.mjs */ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs");






/**
 * @class Portal.view.news.tickets.MainContainer
 * @extends Portal.view.shared.content.Container
 */
class MainContainer extends _shared_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainer',
        /**
         * @member {String[]} cls=['portal-tickets-maincontainer']
         * @reactive
         */
        cls: ['portal-tickets-maincontainer'],
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         * @reactive
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} pageContainerConfig
         */
        pageContainerConfig: {
            module         : _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            buttonTextField: 'id',
            contentConfig  : {
                module: _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            }
        },
        /**
         * @member {Neo.state.Provider} stateProvider=MainContainerStateProvider
         * @reactive
         */
        stateProvider: _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
        /**
         * @member {Object} treeConfig={displayField:'treeNodeName'}
         */
        treeConfig: {
            displayField: 'treeNodeName'
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerController.mjs"
/*!*******************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerController.mjs ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Portal.view.news.tickets.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerController'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerController',
        /**
         * @member {Object} routes
         */
        routes: {
            '/news/tickets'          : 'onRouteDefault',
            '/news/tickets/{*itemId}': 'onRouteItem'
        }
    }

    /**
     * @param {String} item
     */
    navigateTo(item) {
        Neo.Main.setRoute({
            value   : `/news/tickets/${item}`,
            windowId: this.component.windowId
        })
    }

    /**
     * @param {Object} data
     */
    onContentEdit(data) {
        // No-op for tickets
    }

    /**
     * @param {Object} data
     */
    onContentRefresh(data) {
        this.getReference('tree').doFetchContent(data.record)
    }

    /**
     * @param {Object} data
     */
    onIntersect(data) {
        let panel    = this.getReference('page-sections-container'),
            list     = panel.list,
            recordId = data.data.recordId,
            record;

        if (recordId && !list.isAnimating) {
            record = list.store.get(recordId);

            if (record) {
                list.selectionModel.select(record)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onNextPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('nextPageRecord').id)
    }

    /**
     * @param {Object} data
     */
    onPageSectionsToggleButtonClick(data) {
        this.getReference('page-sections-container').toggleCls('neo-expanded')
    }

    /**
     * @param {Object} data
     */
    onPreviousPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('previousPageRecord').id)
    }

    /**
     * @param {Object} data
     */
    onRouteDefault(data) {
        let me    = this,
            store = me.getStateProvider().getStore('tree');

        if (store.getCount() > 0) {
            me.navigateTo(store.getAt(1).id)
        } else {
            store.on({
                load : () => me.navigateTo(store.getAt(1).id),
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.itemId
     * @param {Object} value
     * @param {Object} oldValue
     */
    async onRouteItem({itemId}, value, oldValue) {
        let me            = this,
            stateProvider = me.getStateProvider(),
            store         = stateProvider.getStore('tree'),
            tree          = me.getReference('tree');

        // Ensure the tree has the correct route prefix for this controller context
        if (tree.routePrefix !== '/news/tickets') {
            tree.routePrefix = '/news/tickets'
        }

        const select = async () => {
            stateProvider.data.currentPageRecord = store.get(itemId);
            tree.expandParents(itemId);

            if (!oldValue?.hashString?.startsWith('/news/tickets')) {
                // Wait for the expansion VDOM update to be applied and the item to be visible in the DOM
                const id   = tree.getItemId(itemId),
                      rect = await tree.waitForDomRect({id, attempts: 20, delay: 20});

                if (rect) {
                    tree.scrollToItem(itemId)
                }
            }
        };

        if (store.getCount() > 0) {
            await select()
        } else {
            store.on({
                load : select,
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     */
    onSideNavToggleButtonClick(data) {
        this.getReference('sidenav-container').toggleCls('neo-expanded')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs"
/*!**********************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerStateProvider.mjs ***!
  \**********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../store/TicketLabels.mjs */ "./apps/portal/store/TicketLabels.mjs");
/* harmony import */ var _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../store/TicketTimelineSections.mjs */ "./apps/portal/store/TicketTimelineSections.mjs");
/* harmony import */ var _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../store/Tickets.mjs */ "./apps/portal/store/Tickets.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");





/**
 * @class Portal.view.news.tickets.MainContainerStateProvider
 * @extends Neo.state.Provider
 */
class MainContainerStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerStateProvider'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {Number|null} data.countPages=null
             */
            countPages: null,
            /**
             * @member {Number|null} data.countPages=null
             */
            countSections: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.currentRecord=null
             */
            currentPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.nextPageRecord=null
             */
            nextPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.previousPageRecord=null
             */
            previousPageRecord: null
        },
        /**
         * @member {Object} stores
         */
        stores: {
            labels: {
                autoLoad: true,
                module  : _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            },
            sections: {
                module: _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
            },
            tree: {
                autoLoad: true,
                module  : _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]
            }
        }
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        super.onDataPropertyChange(key, value, oldValue);

        let me = this;

        switch (key) {
            case 'countSections': {
                if (value < 1) {
                    me.component.getReference('page-sections-container')?.toggleCls('neo-expanded', false)
                }

                break
            }

            case 'currentPageRecord': {
                let {data}             = me,
                    {countPages}       = data,
                    store              = me.getStore('tree'),
                    index              = store.indexOf(value),
                    nextPageRecord     = null,
                    previousPageRecord = null,
                    i, record;

                // the logic assumes that the tree store is sorted
                for (i=index-1; i >= 0; i--) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        previousPageRecord = record;
                        break
                    }
                }

                me.setData({previousPageRecord});

                // the logic assumes that the tree store is sorted
                for (i=index+1; i < countPages; i++) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        nextPageRecord = record;
                        break
                    }
                }

                me.setData({nextPageRecord});

                me.component.getReference('sidenav-container')?.toggleCls('neo-expanded', false)

                break
            }
        }
    }

    /**
     * We need to check the parent-node chain inside the tree.
     * => Any hidden parent-node results in a hidden record.
     * @param {Object} record
     * @param {Neo.data.Store} store
     * @returns {Boolean}
     */
    recordIsHidden(record, store) {
        if (record.hidden) {
            return true
        }

        if (record.parentId !== null) {
            return this.recordIsHidden(store.get(record.parentId), store)
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerStateProvider));


/***/ },

/***/ "./apps/portal/view/news/tickets/PageContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/PageContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/content/PageContainer.mjs */ "./apps/portal/view/shared/content/PageContainer.mjs");


/**
 * @class Portal.view.news.tickets.PageContainer
 * @extends Portal.view.shared.content.PageContainer
 */
class TicketPageContainer extends _shared_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.PageContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.PageContainer',
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={flex:1,overflowY:'auto',position:'relative'}
         */
        style: {flex: 1, overflowY: 'auto', position: 'relative'}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketPageContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/TimelineCanvas.mjs"
/*!**********************************************************!*\
  !*** ./apps/portal/view/news/tickets/TimelineCanvas.mjs ***!
  \**********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/component/Canvas.mjs */ "./src/component/Canvas.mjs");


/**
 * @summary The "Coordinator" component for the Neural Timeline, bridging the App Worker and Canvas Worker.
 *
 * This component renders a transparent canvas overlay on top of the Ticket List. It is responsible for:
 * 1. **Data Bridge**: Listening to the `sections` store and passing ticket data to the `TicketCanvas` (SharedWorker).
 * 2. **Visual Alignment**: Calculating the precise DOM positions of Ticket Avatars/Badges to ensure the
 *    canvas nodes align perfectly with the HTML content.
 * 3. **Lifecycle Management**: initializing the offscreen canvas transfer and handling resize events.
 *
 * It uses the `Portal.canvas.TicketCanvas` singleton (via Remote Method Access) to drive the actual animation.
 *
 * @class Portal.view.news.tickets.TimelineCanvas
 * @extends Neo.component.Canvas
 */
class TimelineCanvas extends _src_component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.TimelineCanvas'
         * @protected
         */
        className: 'Portal.view.news.tickets.TimelineCanvas',
        /**
         * @member {Object} listeners
         */
        listeners: {
            resize: 'onResize'
        },
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'div', cls: ['neo-ticket-timeline-wrapper'], style: {width: '100%', height: '100%'}, cn: [
            {tag: 'canvas', style: {width: '100%', height: '100%'}}
        ]}
    }

    /**
     * @member {String} canvasId=null
     */
    canvasId = null
    /**
     * @member {Boolean} isCanvasReady=false
     */
    isCanvasReady = false
    /**
     * @member {Object[]} lastRecords=null
     */
    lastRecords = null

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me    = this,
            store = me.getStateProvider().getStore('sections');

        store.on('load', me.onTimelineDataLoad, me)
    }

    /**
     * Lifecycle hook that runs once the `OffscreenCanvas` has been transferred to the Canvas Worker.
     *
     * This method:
     * 1. Imports the `TicketCanvas` logic into the Canvas Worker context.
     * 2. Initializes the graph in the worker via Remote Method Access (`initGraph`).
     * 3. Sets up a `ResizeObserver` to keep the canvas size synced with the DOM.
     * 4. Triggers the initial data load if store data is available.
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetOffscreenRegistered(value, oldValue) {
        let me = this;

        if (value) {
            // Ensure the logic is loaded in the worker
            await Portal.canvas.Helper.importTicketCanvas();

            // Direct Remote Method Access call
            await Portal.canvas.TicketCanvas.initGraph({canvasId: me.getCanvasId(), windowId: me.windowId});

            me.isCanvasReady = true;

            // Register ResizeObserver for the canvas wrapper (me.id)
            Neo.main.addon.ResizeObserver.register({
                id      : me.id,
                windowId: me.windowId
            });

            // Initial sizing
            await me.updateSize();

            // Initial load check
            let store = me.getStateProvider().getStore('sections');

            if (store.getCount() > 0) {
                me.onTimelineDataLoad(store.items)
            }
        } else if (oldValue) {
            me.isCanvasReady = false;
            // Stop the worker loop to prevent "Zombie Canvas" CPU usage
            await Portal.canvas.TicketCanvas.clearGraph()
        }
    }

    /**
     * Override to return the inner canvas ID
     */
    getCanvasId() {
        let me = this;

        if (!me.canvasId) {
            me.canvasId = me.vdom.cn[0].id
        }
        return me.canvasId
    }

    /**
     * @param {Object} data
     */
    async onResize(data) {
        let me = this;

        // Update the canvas size in the worker
        await me.updateSize(data.contentRect);

        // If we have cached records, re-calculate node positions
        // because the container dimensions (and likely relative positions) have changed.
        if (me.lastRecords) {
            // We don't need to re-fetch rects instantly, but it's safer to do so
            // to ensure alignment with the new layout.
            me.onTimelineDataLoad(me.lastRecords, true)
        }
    }

    /**
     * The core "Alignment Engine" of the timeline.
     *
     * This method synchronizes the Canvas nodes with the DOM elements (Avatars/Badges).
     *
     * **Strategy:**
     * 1. **Targeting**: It uses the `-target` ID suffix to find the specific DOM elements (Avatars) within the ticket list.
     * 2. **Measurement**: It fetches the `DOMRect` for every target to get its exact screen position.
     * 3. **Translation**: It converts these screen coordinates into Canvas-local coordinates.
     * 4. **Handoff**: It packages this geometric data (x, y, radius, color) and sends it to the
     *    `TicketCanvas` worker to update the physics simulation.
     *
     * @param {Object[]|Object} records Array of records or Store load event object {items: [...]}
     * @param {Boolean} [isResize=false]
     */
    async onTimelineDataLoad(records, isResize = false) {
        let me = this;

        // Handle Store 'load' event signature: fire('load', {items: [...]})
        if (records && !Array.isArray(records) && records.items) {
            records = records.items
        }

        if (!Array.isArray(records)) {
            // Safety check if records is still invalid
            return
        }

        if (!me.isCanvasReady) {
            return
        }

        me.lastRecords = records;

        let ids         = records.map(r => `${r.id}-target`),
            componentId = me.getStateProvider().getData('contentComponentId'),
            timelineId  = `ticket-timeline-${componentId}`,
            rects, timelineRect;

        try {
            // Fetch DOM rects for the MARKERS (Avatars/Badges), not the containers
            rects = await me.waitForDomRect({
                attempts: 20,
                delay   : 50,
                id      : ids
            });

            if (me.lastRecords !== records) {
                return
            }

            // Fetch timeline container rect (optional, fallback)
            if (componentId) {
                timelineRect = await me.getDomRect(timelineId)
            }

            // Check if we got valid rects (at least one)
            let hasRects = rects && rects.some(r => r);

            if (!hasRects) {
                return
            }

            // On first valid data load (not resize), ensure size is synced
            // because content might have pushed the container height.
            if (!isResize) {
                await me.updateSize()
            }

            let canvasRect = await me.getDomRect(me.getCanvasId()),
                nodes      = [],
                startY     = 0;

            ids.forEach((targetId, index) => {
                let rect   = rects[index],
                    record = records[index];

                if (rect) {
                    // PRECISE CENTERING
                    // Now 'rect' is the actual avatar/badge.
                    let offset = rect.height / 2,
                        nodeY  = rect.y - canvasRect.y + offset,
                        nodeX  = rect.x - canvasRect.x + (rect.width / 2),
                        // Distinct padding for Orbit effect
                        // Avatars (~40px) get more breathing room than Badges (~28px)
                        padding = rect.height > 32 ? 6 : 3;

                    nodes.push({
                        color : record.color, // Pass Hex Color (e.g. #ff0000)
                        id    : record.id,
                        radius: offset + padding,
                        y     : nodeY,
                        x     : nodeX
                    });

                    // Set the startY of the line to the first node
                    if (index === 0) {
                        startY = nodeY
                    }
                }
            });

            await Portal.canvas.TicketCanvas.updateGraphData({nodes, reset: !isResize, startY})
        } catch (e) {
            console.error('TimelineCanvas update failed', e)
        }
    }

    /**
     *
     * @param rect
     * @returns {Promise<void>}
     */
    async updateSize(rect) {
        let me = this;

        if (!rect || rect.width === 0 || rect.height === 0) {
            rect = await me.waitForDomRect({id: me.getCanvasId()})
        }

        await Portal.canvas.TicketCanvas.updateSize({width: rect.width, height: rect.height})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TimelineCanvas));


/***/ },

/***/ "./src/component/Canvas.mjs"
/*!**********************************!*\
  !*** ./src/component/Canvas.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.component.Canvas
 * @extends Neo.component.Base
 */
class Canvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Canvas'
         * @protected
         */
        className: 'Neo.component.Canvas',
        /**
         * @member {String} ntype='canvas'
         * @protected
         */
        ntype: 'canvas',
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=true
         * @reactive
         */
        monitorSize_: true,
        /**
         * @member {Boolean} offscreen=true
         */
        offscreen: true,
        /**
         * Only applicable if offscreen === true.
         * true once the ownership of the canvas node got transferred to worker.Canvas.
         * @member {Boolean} offscreenRegistered_=false
         * @reactive
         */
        offscreenRegistered_: false,
        /**
         * @member {Object} _vdom={tag: 'canvas'}
         */
        _vdom:
        {tag: 'canvas'}
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me          = this,
            id          = me.getCanvasId(),
            {offscreen} = me;

        if (value) {
            await me.timeout(30); // next rAF tick

            if (me.monitorSize) {
                me.addDomListeners([{
                    delegate: `#${me.getCanvasId()}`,
                    resize  : me.onDomResize,
                    scope   : me
                }])
            }

            if (offscreen) {
                const data = await Neo.main.DomAccess.getOffscreenCanvas({
                    nodeId  : id,
                    windowId: me.windowId
                });

                if (data.offscreen) {
                    await Neo.worker.Canvas.registerCanvas({
                        node    : data.offscreen,
                        nodeId  : id,
                        windowId: me.windowId
                    }, [data.offscreen]);

                    me.offscreenRegistered = true
                } else if (data.transferred) {
                    if (Neo.config.useSharedWorkers) {
                        let retrieveData = await Neo.worker.Canvas.retrieveCanvas({
                            nodeId  : id,
                            windowId: me.windowId
                        });

                        if (retrieveData.hasCanvas) {
                            me.offscreenRegistered = true
                        }
                    }
                }
            }
        } else if (offscreen) {
            me.offscreenRegistered = false
        }
    }


    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        if (oldValue) {
            this.offscreenRegistered = false
        }
    }

    /**
     * Override this method when using wrappers (e.g. D3)
     * @returns {String}
     */
    getCanvasId() {
        return this.id
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Canvas));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfcG9ydGFsX3ZpZXdfbmV3c190aWNrZXRzX01haW5Db250YWluZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBSztBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQyx5QkFBeUI7QUFDekI7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDLHNDQUFzQyxHQUFHLE9BQU8sTUFBTTtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkRVOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBSztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsMkJBQTJCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ087O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJEQUFj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QUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLE9BQU87QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXOztBQUV4QjtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9tb2RlbC9UaWNrZXQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9tb2RlbC9UaWNrZXRMYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL21vZGVsL1RpY2tldFRpbWVsaW5lU2VjdGlvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3N0b3JlL1RpY2tldExhYmVscy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3N0b3JlL1RpY2tldFRpbWVsaW5lU2VjdGlvbnMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9zdG9yZS9UaWNrZXRzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvQ2FudmFzV3JhcHBlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL01haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvUGFnZUNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL1RpbWVsaW5lQ2FudmFzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9DYW52YXMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwubW9kZWwuVGlja2V0XG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5Nb2RlbFxuICovXG5jbGFzcyBUaWNrZXQgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwubW9kZWwuVGlja2V0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwubW9kZWwuVGlja2V0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgIG5hbWUgICAgICAgIDogJ2NvbGxhcHNlZCcsXG4gICAgICAgICAgICB0eXBlICAgICAgICA6ICdCb29sZWFuJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZSAgICAgICAgOiAnaXNMZWFmJyxcbiAgICAgICAgICAgIHR5cGUgICAgICAgIDogJ0Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWUgICAgICAgIDogJ3BhcmVudElkJyxcbiAgICAgICAgICAgIHR5cGUgICAgICAgIDogJ1N0cmluZycsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ3BhdGgnLCAvLyBcInJlc291cmNlcy9jb250ZW50L2lzc3Vlcy9pc3N1ZS0xMjM0Lm1kXCJcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICd0aXRsZScsIC8vIFwiRml4IGVsdXNpdmUgYnVnIGluIEdyaWRcIlxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZWQgZmllbGQgZm9yIFRyZWVMaXN0IGRpc3BsYXlcbiAgICAgICAgICAgIG5hbWU6ICd0cmVlTm9kZU5hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS5pZFxuICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBkYXRhLmlzTGVhZlxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICBkYXRhLnRpdGxlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxjdWxhdGUoe2lkLCBpc0xlYWYsIHRpdGxlfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0xlYWYgPyBgPGI+JHtpZH08L2I+ICR7dGl0bGV9YCA6IGlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXQpO1xuIiwiaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5tb2RlbC5UaWNrZXRMYWJlbFxuICogQGV4dGVuZHMgTmVvLmRhdGEuTW9kZWxcbiAqL1xuY2xhc3MgVGlja2V0TGFiZWwgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwubW9kZWwuVGlja2V0TGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5tb2RlbC5UaWNrZXRMYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdjb2xvcicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ3RleHRDb2xvcicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0TGFiZWwpO1xuIiwiaW1wb3J0IENvbnRlbnRTZWN0aW9uIGZyb20gJy4vQ29udGVudFNlY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLm1vZGVsLlRpY2tldFRpbWVsaW5lU2VjdGlvblxuICogQGV4dGVuZHMgUG9ydGFsLm1vZGVsLkNvbnRlbnRTZWN0aW9uXG4gKi9cbmNsYXNzIFRpY2tldFRpbWVsaW5lU2VjdGlvbiBleHRlbmRzIENvbnRlbnRTZWN0aW9uIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5tb2RlbC5UaWNrZXRUaW1lbGluZVNlY3Rpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5tb2RlbC5UaWNrZXRUaW1lbGluZVNlY3Rpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGZpZWxkc1xuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2NvbG9yJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdpY29uJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdpbWFnZScsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnc291cmNlSWQnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldFRpbWVsaW5lU2VjdGlvbik7XG4iLCJpbXBvcnQgVGlja2V0TGFiZWwgZnJvbSAnLi4vbW9kZWwvVGlja2V0TGFiZWwubWpzJztcbmltcG9ydCBTdG9yZSBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9TdG9yZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwuc3RvcmUuVGlja2V0TGFiZWxzXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5TdG9yZVxuICovXG5jbGFzcyBUaWNrZXRMYWJlbHMgZXh0ZW5kcyBTdG9yZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuc3RvcmUuVGlja2V0TGFiZWxzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuc3RvcmUuVGlja2V0TGFiZWxzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHk9J25hbWUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGtleVByb3BlcnR5OiAnbmFtZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9VGlja2V0TGFiZWxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IFRpY2tldExhYmVsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB1cmw9Jy4uLy4uL2FwcHMvcG9ydGFsL3Jlc291cmNlcy9kYXRhL2xhYmVscy5qc29uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB1cmw6ICcuLi8uLi9hcHBzL3BvcnRhbC9yZXNvdXJjZXMvZGF0YS9sYWJlbHMuanNvbidcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldExhYmVscyk7XG4iLCJpbXBvcnQgQ29udGVudFNlY3Rpb25zICAgICAgZnJvbSAnLi9Db250ZW50U2VjdGlvbnMubWpzJztcbmltcG9ydCBUaWNrZXRUaW1lbGluZVNlY3Rpb24gZnJvbSAnLi4vbW9kZWwvVGlja2V0VGltZWxpbmVTZWN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5zdG9yZS5UaWNrZXRUaW1lbGluZVNlY3Rpb25zXG4gKiBAZXh0ZW5kcyBQb3J0YWwuc3RvcmUuQ29udGVudFNlY3Rpb25zXG4gKi9cbmNsYXNzIFRpY2tldFRpbWVsaW5lU2VjdGlvbnMgZXh0ZW5kcyBDb250ZW50U2VjdGlvbnMge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnN0b3JlLlRpY2tldFRpbWVsaW5lU2VjdGlvbnMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC5zdG9yZS5UaWNrZXRUaW1lbGluZVNlY3Rpb25zJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLk1vZGVsfSBtb2RlbD1UaWNrZXRUaW1lbGluZVNlY3Rpb25cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDogVGlja2V0VGltZWxpbmVTZWN0aW9uXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRUaW1lbGluZVNlY3Rpb25zKTtcbiIsImltcG9ydCBTdG9yZSAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9TdG9yZS5tanMnO1xuaW1wb3J0IFRpY2tldE1vZGVsIGZyb20gJy4uL21vZGVsL1RpY2tldC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwuc3RvcmUuVGlja2V0c1xuICogQGV4dGVuZHMgTmVvLmRhdGEuU3RvcmVcbiAqL1xuY2xhc3MgVGlja2V0cyBleHRlbmRzIFN0b3JlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5zdG9yZS5UaWNrZXRzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuc3RvcmUuVGlja2V0cycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9VGlja2V0TW9kZWxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDogVGlja2V0TW9kZWwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHVybD0nLi4vLi4vYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvdGlja2V0cy5qc29uJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXJsOiAnLi4vLi4vYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvdGlja2V0cy5qc29uJ1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0cyk7XG4iLCJpbXBvcnQgQ29udGFpbmVyICAgICAgICBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBDb250ZW50Q29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgVGltZWxpbmVDYW52YXMgICBmcm9tICcuL1RpbWVsaW5lQ2FudmFzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5DYW52YXNXcmFwcGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQ2FudmFzV3JhcHBlciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ2FudmFzV3JhcHBlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNhbnZhc1dyYXBwZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ3BvcnRhbC1jYW52YXMtd3JhcHBlciddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsncG9ydGFsLWNhbnZhcy13cmFwcGVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29udGVudENvbXBvbmVudD1Db250ZW50Q29tcG9uZW50XG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Q29tcG9uZW50OiBDb250ZW50Q29tcG9uZW50LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdHlsZT17bWluSGVpZ2h0OicxMDAlJyxvdmVyZmxvdzondmlzaWJsZScscG9zaXRpb246J3JlbGF0aXZlJ31cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiB7bWluSGVpZ2h0OiAnMTAwJScsIG92ZXJmbG93OiAndmlzaWJsZScsIHBvc2l0aW9uOiAncmVsYXRpdmUnfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBjb25maWcuaXRlbXMgPSBbe1xuICAgICAgICAgICAgbW9kdWxlOiBUaW1lbGluZUNhbnZhcyxcbiAgICAgICAgICAgIHN0eWxlIDoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICAgICA6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgdG9wICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICA6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgICAgICAgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgekluZGV4ICAgICAgIDogMixcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlOiBjb25maWcuY29udGVudENvbXBvbmVudCB8fCBtZS5jb250ZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgc3R5bGUgOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgekluZGV4ICA6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICBlZGl0ICAgOiBtZS5vbkNvbnRlbnRFZGl0LFxuICAgICAgICAgICAgICAgIHJlZnJlc2g6IG1lLm9uQ29udGVudFJlZnJlc2gsXG4gICAgICAgICAgICAgICAgc2NvcGUgIDogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV07XG5cbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbnRlbnRFZGl0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdlZGl0JywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29udGVudFJlZnJlc2goZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3JlZnJlc2gnLCBkYXRhKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FudmFzV3JhcHBlcik7XG4iLCJpbXBvcnQgQ29udGVudENvbXBvbmVudCBmcm9tICcuLi8uLi9zaGFyZWQvY29udGVudC9Db21wb25lbnQubWpzJztcbmltcG9ydCB7bWFya2VkfSAgICAgICAgIGZyb20gJy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanMnO1xuXG5jb25zdFxuICAgIHJlZ2V4RnJvbnRNYXR0ZXIgICA9IC9eLS0tXFxuKFtcXHNcXFNdKj8pXFxuLS0tXFxuLyxcbiAgICByZWdleEgxICAgICAgICAgICAgPSAvKDxoMVtePl0qPi4qPzxcXC9oMT4pLyxcbiAgICByZWdleFRpY2tldExpbmsgICAgPSAvKFxcZHs0LH0pLyxcbiAgICByZWdleFRpbWVsaW5lICAgICAgPSAvIyMgVGltZWxpbmVcXHMqXFxuKFtcXHNcXFNdKikvLFxuICAgIHJlZ2V4VGltZWxpbmVFdmVudCA9IC9eLSAoW1xcZFRaOi4tXSspIEAoXFx3KykgKC4qKSQvLFxuICAgIHJlZ2V4Q29tbWl0ICAgICAgICA9IC9cXGIoWzAtOWEtZl17Nyw0MH0pXFxiL2c7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIFwiTWFya2Rvd24gVHJhbnNmb3JtZXJcIiBmb3IgR2l0SHViIFRpY2tldHMuXG4gKlxuICogVGhpcyBjb21wb25lbnQgZXh0ZW5kcyB0aGUgc3RhbmRhcmQgQ29udGVudENvbXBvbmVudCB0byBwcm92aWRlIHNwZWNpYWxpemVkIHJlbmRlcmluZyBmb3IgR2l0SHViIElzc3Vlcy5cbiAqIEl0cyBwcmltYXJ5IHJlc3BvbnNpYmlsaXR5IGlzIHRvIHBhcnNlIHRoZSByYXcgTWFya2Rvd24gY29udGVudCAod2hpY2ggaW5jbHVkZXMgY3VzdG9tIEZyb250bWF0dGVyIGFuZFxuICogYSBwcmUtZ2VuZXJhdGVkIFRpbWVsaW5lIHNlY3Rpb24pIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIHJpY2gsIGludGVyYWN0aXZlIEhUTUwgc3RydWN0dXJlLlxuICpcbiAqICoqS2V5IFJlc3BvbnNpYmlsaXRpZXM6KipcbiAqIDEuICoqUGFyc2luZyBQaXBlbGluZSoqOiBFeHRyYWN0cyBGcm9udG1hdHRlciwgQm9keSwgYW5kIHRoZSBjdXN0b20gXCJUaW1lbGluZVwiIHNlY3Rpb24gZnJvbSB0aGUgcmF3IE1hcmtkb3duLlxuICogMi4gKipSaWNoIFJlbmRlcmluZyoqOiBHZW5lcmF0ZXMgSFRNTCBmb3IgU3RhdHVzIEJhZGdlcywgTGFiZWxzLCBDb21taXQgTGlua3MsIGFuZCBVc2VyIE1lbnRpb25zLlxuICogMy4gKipEYXRhIEV4dHJhY3Rpb24qKjogQXMgYSBzaWRlIGVmZmVjdCBvZiByZW5kZXJpbmcsIGl0IGV4dHJhY3RzIHN0cnVjdHVyZWQgZGF0YSAoYG1lLnRpbWVsaW5lRGF0YWApXG4gKiAgICByZXByZXNlbnRpbmcgZXZlcnkgdGltZWxpbmUgZXZlbnQgKGNvbW1lbnQsIGxhYmVsIGNoYW5nZSwgY2xvc2UsIGV0Yy4pLiBUaGlzIGRhdGEgaXMgdGhlblxuICogICAgcHVzaGVkIHRvIHRoZSBgc2VjdGlvbnNgIHN0b3JlIHRvIGRyaXZlIHRoZSBgVGltZWxpbmVDYW52YXNgIHZpc3VhbGl6YXRpb24uXG4gKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5Db21wb25lbnRcbiAqIEBleHRlbmRzIFBvcnRhbC52aWV3LnNoYXJlZC5jb250ZW50LkNvbXBvbmVudFxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBDb250ZW50Q29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ3BvcnRhbC1uZXdzLXRpY2tldHMtY29tcG9uZW50J11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWydwb3J0YWwtbmV3cy10aWNrZXRzLWNvbXBvbmVudCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb21taXRzVXJsPSdodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9jb21taXQvJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29tbWl0c1VybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2NvbW1pdC8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZXBvVXNlclVybD0naHR0cHM6Ly9naXRodWIuY29tLydcbiAgICAgICAgICovXG4gICAgICAgIHJlcG9Vc2VyVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tLycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1cGRhdGVTZWN0aW9uc1N0b3JlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVTZWN0aW9uc1N0b3JlOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gI2RhdGVUaW1lRm9ybWF0SGlzdG9yeT1udWxsXG4gICAgICovXG4gICAgI2RhdGVUaW1lRm9ybWF0SGlzdG9yeSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9ICNkYXRlVGltZUZvcm1hdFRvZGF5PW51bGxcbiAgICAgKi9cbiAgICAjZGF0ZVRpbWVGb3JtYXRUb2RheSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBUZW1wb3Jhcnkgc3RvcmFnZSBmb3IgdGhlIHN0cnVjdHVyZWQgdGltZWxpbmUgZGF0YSBleHRyYWN0ZWQgZHVyaW5nIHRoZSBwYXJzaW5nIHBoYXNlLlxuICAgICAqIFRoaXMgYXJyYXkgaXMgcG9wdWxhdGVkIGJ5IGByZW5kZXJUaW1lbGluZWAgYW5kIGBtb2RpZnlNYXJrZG93bmAgYW5kIHRoZW4gYXNzaWduZWRcbiAgICAgKiB0byB0aGUgYHNlY3Rpb25zYCBzdG9yZSB0byBkcml2ZSB0aGUgQ2FudmFzIHZpc3VhbGl6YXRpb24uXG4gICAgICogQG1lbWJlciB7T2JqZWN0W119IHRpbWVsaW5lRGF0YT1udWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aW1lbGluZURhdGEgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuc2V0RGF0YSgnY29udGVudENvbXBvbmVudElkJywgdGhpcy5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXNvU3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtYXRUaW1lc3RhbXAoaXNvU3RyaW5nKSB7XG4gICAgICAgIGlmICghaXNvU3RyaW5nKSByZXR1cm4gJyc7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGF0ZSAgICA9IG5ldyBEYXRlKGlzb1N0cmluZyksXG4gICAgICAgICAgICBub3cgICAgID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGlzVG9kYXkgPSBkYXRlLnRvRGF0ZVN0cmluZygpID09PSBub3cudG9EYXRlU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGlzVG9kYXkpIHtcbiAgICAgICAgICAgIGlmICghbWUuI2RhdGVUaW1lRm9ybWF0VG9kYXkpIHtcbiAgICAgICAgICAgICAgICBtZS4jZGF0ZVRpbWVGb3JtYXRUb2RheSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdkZWZhdWx0Jywge1xuICAgICAgICAgICAgICAgICAgICBob3VyICA6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYydcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWUuI2RhdGVUaW1lRm9ybWF0VG9kYXkuZm9ybWF0KGRhdGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLiNkYXRlVGltZUZvcm1hdEhpc3RvcnkpIHtcbiAgICAgICAgICAgIG1lLiNkYXRlVGltZUZvcm1hdEhpc3RvcnkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZGVmYXVsdCcsIHtcbiAgICAgICAgICAgICAgICBkYXkgICA6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBob3VyICA6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtb250aCA6ICdzaG9ydCcsXG4gICAgICAgICAgICAgICAgeWVhciAgOiAnbnVtZXJpYydcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuI2RhdGVUaW1lRm9ybWF0SGlzdG9yeS5mb3JtYXQoZGF0ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZnJvbnRNYXR0ZXJUb0h0bWwoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBodG1sID0gJzx0YWJsZSBjbGFzcz1cIm5lby1mcm9udG1hdHRlci10YWJsZVwiPjx0Ym9keT4nO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlbmRlcmVkVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzdWJJc3N1ZXMnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IHZhbHVlLm1hcChpc3N1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIm5lby1zdWItaXNzdWVcIj4ke2lzc3VlXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyZWdleFRpY2tldExpbmssICc8YSBocmVmPVwiIy9uZXdzL3RpY2tldHMvJDFcIj4kMTwvYT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1t4XScsICc8aSBjbGFzcz1cImZhLXNvbGlkIGZhLWNpcmNsZS1jaGVja1wiPjwvaT4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1sgXScsICc8aSBjbGFzcz1cImZhLXJlZ3VsYXIgZmEtY2lyY2xlXCI+PC9pPicpfTwvZGl2PmBcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcnKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdhdXRob3InKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IGA8YSBocmVmPVwiJHttZS5yZXBvVXNlclVybH0ke3ZhbHVlfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7dmFsdWV9PC9hPmBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY3JlYXRlZEF0JyB8fCBrZXkgPT09ICdjbG9zZWRBdCcgfHwga2V5ID09PSAndXBkYXRlZEF0Jykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSBtZS5mb3JtYXRUaW1lc3RhbXAodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xhYmVscycgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gbWUuZ2V0QmFkZ2VzSHRtbCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IG1lLmdldFN0YXRlQmFkZ2VIdG1sKHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gbWUuZm9ybWF0RnJvbnRNYXR0ZXJWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaHRtbCArPSBgPHRyPjx0ZD4ke2tleX08L3RkPjx0ZD4ke3JlbmRlcmVkVmFsdWV9PC90ZD48L3RyPmBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaHRtbCArPSAnPC90Ym9keT48L3RhYmxlPic7XG5cbiAgICAgICAgaWYgKG1lLnVzZUZyb250bWF0dGVyRGV0YWlscykge1xuICAgICAgICAgICAgcmV0dXJuIGA8ZGV0YWlscz48c3VtbWFyeT5Gcm9udG1hdHRlcjwvc3VtbWFyeT4ke2h0bWx9PC9kZXRhaWxzPmBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gbGFiZWxzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCYWRnZXNIdG1sKGxhYmVscykge1xuICAgICAgICBpZiAoIWxhYmVscyB8fCBsYWJlbHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYmFkZ2VzSHRtbCA9ICc8ZGl2IGNsYXNzPVwibmVvLXRpY2tldC1sYWJlbHNcIj4nO1xuXG4gICAgICAgIGxhYmVscy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gbWUuZ2V0TGFiZWxCYWRnZUh0bWwobGFiZWwpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJhZGdlc0h0bWwgKz0gJzwvZGl2Pic7XG5cbiAgICAgICAgcmV0dXJuIGJhZGdlc0h0bWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgZG9GZXRjaENvbnRlbnQocmVjb3JkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIGNvbnRlbnQsIGRhdGEsIHBhdGg7XG5cbiAgICAgICAgcGF0aCA9IG1lLmdldENvbnRlbnRQYXRoKHJlY29yZCk7XG5cbiAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgJiYgcGF0aCkge1xuICAgICAgICAgICAgZGF0YSAgICA9IGF3YWl0IGZldGNoKHBhdGgpO1xuICAgICAgICAgICAgY29udGVudCA9IGF3YWl0IGRhdGEudGV4dCgpO1xuXG4gICAgICAgICAgICBtZS52YWx1ZSA9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIG1lLnRvZ2dsZUNscygnbGFiJywgcmVjb3JkLm5hbWU/LnN0YXJ0c1dpdGgoJ0xhYjonKSk7XG5cbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoe1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZSAgIDogWycubmVvLXRpbWVsaW5lLWl0ZW1bZGF0YS1yZWNvcmQtaWRdJ10sXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlY29yZC5wYXRoXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldENvbnRlbnRQYXRoKHtwYXRofSkge1xuICAgICAgICByZXR1cm4gcGF0aCA/IE5lby5jb25maWcuYmFzZVBhdGggKyBwYXRoIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TGFiZWxCYWRnZUh0bWwobGFiZWwpIHtcbiAgICAgICAgbGV0IHN0b3JlICA9IHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdsYWJlbHMnKSxcbiAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldChsYWJlbCk7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGA8c3BhbiBjbGFzcz1cIm5lby1iYWRnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjoke3JlY29yZC5jb2xvcn07Y29sb3I6JHtyZWNvcmQudGV4dENvbG9yfVwiPiR7bGFiZWx9PC9zcGFuPmBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCJuZW8tYmFkZ2VcIj4ke2xhYmVsfTwvc3Bhbj5gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdGF0ZUJhZGdlSHRtbChzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0YXRlKSByZXR1cm4gJyc7XG5cbiAgICAgICAgbGV0IGNscyAgPSAnbmVvLWJhZGdlIG5lby1zdGF0ZS1iYWRnZScsXG4gICAgICAgICAgICBpY29uID0gJ2ZhLWNpcmNsZS1kb3QnO1xuXG4gICAgICAgIGlmIChzdGF0ZS50b1VwcGVyQ2FzZSgpID09PSAnQ0xPU0VEJykge1xuICAgICAgICAgICAgY2xzICArPSAnIG5lby1zdGF0ZS1jbG9zZWQnO1xuICAgICAgICAgICAgaWNvbiAgPSAnZmEtY2lyY2xlLWNoZWNrJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xzICs9ICcgbmVvLXN0YXRlLW9wZW4nXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwiJHtjbHN9XCI+PGkgY2xhc3M9XCJmYS1yZWd1bGFyICR7aWNvbn1cIj48L2k+JHtOZW8uY2FwaXRhbGl6ZShzdGF0ZS50b0xvd2VyQ2FzZSgpKX08L3NwYW4+YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBNYWluIFBhcnNpbmcgUGlwZWxpbmUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnRlcmNlcHRzIHRoZSByYXcgbWFya2Rvd24gY29udGVudCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgYW5kIHBlcmZvcm1zIGEgbXVsdGktcGFzcyB0cmFuc2Zvcm1hdGlvbjpcbiAgICAgKiAxLiAqKkV4dHJhY3QgVGltZWxpbmUqKjogUHVsbHMgb3V0IHRoZSByYXcgYCMjIFRpbWVsaW5lYCBzZWN0aW9uIHRvIHByb2Nlc3MgaXQgc2VwYXJhdGVseS5cbiAgICAgKiAyLiAqKlByb2Nlc3MgRnJvbnRtYXR0ZXIqKjogRXh0cmFjdHMgbWV0YWRhdGEgKGxhYmVscywgc3RhdGUsIGF1dGhvcikgYW5kIHJlbW92ZXMgdGhlIFlBTUwgYmxvY2suXG4gICAgICogMy4gKipSZW5kZXIgQm9keSoqOiBVc2VzIHRoZSBzdXBlcmNsYXNzIChtYXJrZWQuanMpIHRvIGNvbnZlcnQgdGhlIG1haW4gaXNzdWUgYm9keSB0byBIVE1MLlxuICAgICAqIDQuICoqSW5qZWN0IFRpdGxlIElEcyoqOiBBZGRzIElEcyB0byBIMSB0YWdzIGZvciBuYXZpZ2F0aW9uLlxuICAgICAqIDUuICoqR2VuZXJhdGUgQmFkZ2VzKio6IENyZWF0ZXMgSFRNTCBmb3IgU3RhdHVzL0xhYmVsIGJhZGdlcyBiYXNlZCBvbiBleHRyYWN0ZWQgbWV0YWRhdGEuXG4gICAgICogNi4gKipXcmFwIEJvZHkqKjogV3JhcHMgdGhlIG1haW4gaXNzdWUgYm9keSBpbiBhIGB0aW1lbGluZS1pdGVtYCBzdHJ1Y3R1cmUgc28gaXQgYXBwZWFycyBhcyB0aGUgZmlyc3QgaXRlbS5cbiAgICAgKiA3LiAqKlJlLUFzc2VtYmxlKio6IENvbmNhdGVuYXRlcyBGcm9udG1hdHRlciArIFRpdGxlICsgVGltZWxpbmUgKHdpdGggQm9keSBpbmplY3RlZCkgaW50byB0aGUgZmluYWwgSFRNTC5cbiAgICAgKlxuICAgICAqICoqU2lkZSBFZmZlY3QqKjogUG9wdWxhdGVzIGBtZS50aW1lbGluZURhdGFgIGFuZCB1cGRhdGVzIHRoZSBgc2VjdGlvbnNgIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIG1vZGlmeU1hcmtkb3duKGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50SWR9ICAgPSBtZS5yZWNvcmQsXG4gICAgICAgICAgICBhdXRob3IgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgY3JlYXRlZEF0ICAgID0gbnVsbCxcbiAgICAgICAgICAgIGxhYmVscyAgICAgICA9IFtdLFxuICAgICAgICAgICAgc3RhdGUgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIG1hdGNoICAgICAgICA9IGNvbnRlbnQubWF0Y2gocmVnZXhGcm9udE1hdHRlciksXG4gICAgICAgICAgICB0aW1lbGluZUh0bWwgPSAnJyxcbiAgICAgICAgICAgIGJhZGdlc0h0bWwgICA9ICcnO1xuXG4gICAgICAgIG1lLnRpbWVsaW5lRGF0YSA9IFtdO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBtZS5wYXJzZUZyb250TWF0dGVyKG1hdGNoWzFdKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuYXV0aG9yKSAgICB7YXV0aG9yICAgID0gZGF0YS5hdXRob3J9XG4gICAgICAgICAgICBpZiAoZGF0YS5jcmVhdGVkQXQpIHtjcmVhdGVkQXQgPSBtZS5mb3JtYXRUaW1lc3RhbXAoZGF0YS5jcmVhdGVkQXQpfVxuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzKSAgICB7bGFiZWxzICAgID0gZGF0YS5sYWJlbHN9XG4gICAgICAgICAgICBpZiAoZGF0YS5zdGF0ZSkgICAgIHtzdGF0ZSAgICAgPSBkYXRhLnN0YXRlfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gRXh0cmFjdCBhbmQgcHJvY2VzcyB0aW1lbGluZSBmcm9tIFJBVyBtYXJrZG93blxuICAgICAgICBsZXQgdGltZWxpbmVNYXRjaCA9IGNvbnRlbnQubWF0Y2gocmVnZXhUaW1lbGluZSk7XG4gICAgICAgIGlmICh0aW1lbGluZU1hdGNoKSB7XG4gICAgICAgICAgICB0aW1lbGluZUh0bWwgPSBtZS5yZW5kZXJUaW1lbGluZSh0aW1lbGluZU1hdGNoWzFdKTtcbiAgICAgICAgICAgIGNvbnRlbnQgICAgICA9IGNvbnRlbnQucmVwbGFjZShyZWdleFRpbWVsaW5lLCAnJyk7IC8vIFJlbW92ZSByYXcgdGltZWxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIFJlbmRlciBGcm9udG1hdHRlciBNYW51YWxseSAmIFN0cmlwIGl0XG4gICAgICAgIC8vIFdlIHdhbnQgaXQgYXQgdGhlIHZlcnkgdG9wLCBvdXRzaWRlIHRoZSBib2R5IGJ1YmJsZS5cbiAgICAgICAgbGV0IGZyb250TWF0dGVySHRtbCA9ICcnO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBkYXRhICAgICAgICA9IG1lLnBhcnNlRnJvbnRNYXR0ZXIobWF0Y2hbMV0pO1xuICAgICAgICAgICAgZnJvbnRNYXR0ZXJIdG1sID0gbWUuZnJvbnRNYXR0ZXJUb0h0bWwoZGF0YSk7XG4gICAgICAgICAgICBjb250ZW50ICAgICAgICAgPSBjb250ZW50LnJlcGxhY2UocmVnZXhGcm9udE1hdHRlciwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQ29udmVydCBCb2R5ICsgVGl0bGUgdG8gSFRNTCB1c2luZyBzdXBlclxuICAgICAgICBsZXQgZnVsbEh0bWwgPSBzdXBlci5tb2RpZnlNYXJrZG93bihjb250ZW50KTtcblxuICAgICAgICAvLyA0LiBFeHRyYWN0IEgxIFRpdGxlIGZyb20gdGhlIGdlbmVyYXRlZCBIVE1MXG4gICAgICAgIGxldCB0aXRsZUh0bWwgPSAnJztcbiAgICAgICAgZnVsbEh0bWwgICAgICA9IGZ1bGxIdG1sLnJlcGxhY2UocmVnZXhIMSwgKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICAvLyBJbmplY3QgSUQgaW50byBIMSB0YWdcbiAgICAgICAgICAgIHRpdGxlSHRtbCA9IG1hdGNoLnJlcGxhY2UoJzxoMScsIGA8aDEgaWQ9XCJ0aWNrZXQtdGl0bGUtJHttZS5pZH1cImApO1xuICAgICAgICAgICAgcmV0dXJuICcnOyAvLyBSZW1vdmUgdGl0bGUgZnJvbSBib2R5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIDUuIENvbnN0cnVjdCBCYWRnZXNcbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAwIHx8IHN0YXRlIHx8IChwYXJlbnRJZCAmJiBwYXJlbnRJZCAhPT0gJ0xhdGVzdCcpKSB7XG4gICAgICAgICAgICBiYWRnZXNIdG1sID0gJzxkaXYgY2xhc3M9XCJuZW8tdGlja2V0LWxhYmVsc1wiPic7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gbWUuZ2V0U3RhdGVCYWRnZUh0bWwoc3RhdGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCAmJiBwYXJlbnRJZCAhPT0gJ0xhdGVzdCcpIHtcbiAgICAgICAgICAgICAgICBiYWRnZXNIdG1sICs9IGBcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuZW8tYmFkZ2UgbmVvLXJlbGVhc2UtYmFkZ2VcIiBocmVmPVwiIy9uZXdzL3JlbGVhc2VzLyR7cGFyZW50SWQuc3Vic3RyaW5nKDEpfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYS1zb2xpZCBmYS1jb2RlLWJyYW5jaFwiPjwvaT4gJHtwYXJlbnRJZH1cbiAgICAgICAgICAgICAgICAgICAgPC9hPmBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0b3JlID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdsYWJlbHMnKSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgICAgICAgICAgbGFiZWxzLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXQobGFiZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gYDxzcGFuIGNsYXNzPVwibmVvLWJhZGdlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiR7cmVjb3JkLmNvbG9yfTtjb2xvcjoke3JlY29yZC50ZXh0Q29sb3J9XCI+JHtsYWJlbH08L3NwYW4+YFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFkZ2VzSHRtbCArPSBgPHNwYW4gY2xhc3M9XCJuZW8tYmFkZ2VcIj4ke2xhYmVsfTwvc3Bhbj5gXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFkZ2VzSHRtbCArPSAnPC9kaXY+JztcbiAgICAgICAgICAgIHRpdGxlSHRtbCAgKz0gYmFkZ2VzSHRtbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIFdyYXAgdGhlIHJlbWFpbmluZyBIVE1MIChCb2R5KSBpbiB0aGUgVGltZWxpbmUgSXRlbSBzdHJ1Y3R1cmVcbiAgICAgICAgbGV0IGJvZHlJZCA9IGB0aW1lbGluZS0ke21lLnJlY29yZC5pZH0tMGA7XG5cbiAgICAgICAgbWUudGltZWxpbmVEYXRhLnVuc2hpZnQoe1xuICAgICAgICAgICAgaWQgICA6IGJvZHlJZCxcbiAgICAgICAgICAgIGltYWdlOiBtZS5yZXBvVXNlclVybCArIGF1dGhvciArICcucG5nJyxcbiAgICAgICAgICAgIG5hbWUgOiAnRGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgdGFnICA6ICdib2R5J1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgYm9keUl0ZW1IdG1sID0gYFxuICAgICAgICAgICAgPGRpdiBpZD1cIiR7Ym9keUlkfVwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWl0ZW0gY29tbWVudCBib2R5LWl0ZW1cIiBkYXRhLXJlY29yZC1pZD1cIiR7Ym9keUlkfVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2JvZHlJZH0tdGFyZ2V0XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtYXZhdGFyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiJHttZS5yZXBvVXNlclVybH0ke2F1dGhvcn0ucG5nXCIgYWx0PVwiJHthdXRob3J9XCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5lby10aW1lbGluZS11c2VyXCIgaHJlZj1cIiR7bWUucmVwb1VzZXJVcmx9JHthdXRob3J9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+JHthdXRob3J9PC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJuZW8tdGltZWxpbmUtZGF0ZVwiPmNvbW1lbnRlZCBvbiAke2NyZWF0ZWRBdH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWJvZHlcIj4ke2Z1bGxIdG1sfTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+YDtcblxuICAgICAgICAvLyA3LiBJbmplY3QgQm9keSBJdGVtIGF0IHRoZSBzdGFydCBvZiB0aGUgVGltZWxpbmVcbiAgICAgICAgbGV0IHRpbWVsaW5lSWQgPSBgdGlja2V0LXRpbWVsaW5lLSR7bWUuaWR9YDtcblxuICAgICAgICBpZiAodGltZWxpbmVIdG1sKSB7XG4gICAgICAgICAgICB0aW1lbGluZUh0bWwgPSB0aW1lbGluZUh0bWwucmVwbGFjZShcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIm5lby10aWNrZXQtdGltZWxpbmVcIj4nLFxuICAgICAgICAgICAgICAgIGA8ZGl2IGlkPVwiJHt0aW1lbGluZUlkfVwiIGNsYXNzPVwibmVvLXRpY2tldC10aW1lbGluZVwiPmAgKyBib2R5SXRlbUh0bWxcbiAgICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVsaW5lSHRtbCA9IGA8ZGl2IGlkPVwiJHt0aW1lbGluZUlkfVwiIGNsYXNzPVwibmVvLXRpY2tldC10aW1lbGluZVwiPiR7Ym9keUl0ZW1IdG1sfTwvZGl2PmBcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgnc2VjdGlvbnMnKS5kYXRhID0gbWUudGltZWxpbmVEYXRhO1xuICAgICAgICBtZS50aW1lbGluZURhdGEgPSBudWxsO1xuXG4gICAgICAgIC8vIFJldHVybjogRnJvbnRtYXR0ZXIgKyBUaXRsZSArIFRpbWVsaW5lXG4gICAgICAgIHJldHVybiBmcm9udE1hdHRlckh0bWwgKyB0aXRsZUh0bWwgKyB0aW1lbGluZUh0bWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGN1c3RvbSBcIlRpbWVsaW5lXCIgbWFya2Rvd24gc2VjdGlvbi5cbiAgICAgKlxuICAgICAqIEV4cGVjdHMgYSBsaW5lLWJhc2VkIGZvcm1hdCBnZW5lcmF0ZWQgYnkgdGhlIGJ1aWxkIHByb2Nlc3M6XG4gICAgICogLSBFdmVudHM6IGAtIFlZWVktTU0tRERUSEg6bW06c3MgQHVzZXIgYWN0aW9uIHRleHQuLi5gXG4gICAgICogLSBDb21tZW50czogYCMjIyBAdXNlciAtIFlZWVktTU0tRERUSEg6bW06c3NgIGZvbGxvd2VkIGJ5IGNvbW1lbnQgYm9keS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZXNlIGxpbmVzIGludG8gc3RydWN0dXJlZCBgdGltZWxpbmUtaXRlbWAgSFRNTCBibG9ja3NcbiAgICAgKiBhbmQgc2ltdWx0YW5lb3VzbHkgcG9wdWxhdGVzIGBtZS50aW1lbGluZURhdGFgIHdpdGggc2VtYW50aWMgZGF0YSAoY29sb3IsIGljb24sIHR5cGUpXG4gICAgICogZm9yIGVhY2ggZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVuZGVyVGltZWxpbmUoY29udGVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbW1pdHNVcmwsIHJlcG9Vc2VyVXJsfSA9IG1lLFxuICAgICAgICAgICAgaHRtbCAgICAgICAgPSAnPGRpdiBjbGFzcz1cIm5lby10aWNrZXQtdGltZWxpbmVcIj4nLFxuICAgICAgICAgICAgbGluZXMgICAgICAgPSBjb250ZW50LnNwbGl0KCdcXG4nKSxcbiAgICAgICAgICAgIGNvbW1lbnRCdWYgID0gW10sXG4gICAgICAgICAgICBjdXJyZW50VXNlciA9IG51bGwsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IG51bGwsXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICA9IGxpbmVzLmxlbmd0aCxcbiAgICAgICAgICAgIGlkLCBsaW5lLCBtYXRjaCwgaWNvbiwgYWN0aW9uQ2xzO1xuXG4gICAgICAgIGNvbnN0IGZsdXNoQ29tbWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb21tZW50QnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZCA9IGB0aW1lbGluZS0ke21lLnJlY29yZC5pZH0tJHttZS50aW1lbGluZURhdGEubGVuZ3RoICsgMX1gO1xuXG4gICAgICAgICAgICAgICAgbWUudGltZWxpbmVEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCAgIDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiByZXBvVXNlclVybCArIGN1cnJlbnRVc2VyICsgJy5wbmcnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lIDogYENvbW1lbnQgKCR7Y3VycmVudFVzZXJ9KWAsXG4gICAgICAgICAgICAgICAgICAgIHRhZyAgOiAnY29tbWVudCdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxldCBib2R5ID0gbWFya2VkLnBhcnNlKGNvbW1lbnRCdWYuam9pbignXFxuJykpO1xuICAgICAgICAgICAgICAgIGh0bWwgKz0gYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtpZH1cIiBjbGFzcz1cIm5lby10aW1lbGluZS1pdGVtIGNvbW1lbnRcIiBkYXRhLXJlY29yZC1pZD1cIiR7aWR9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtpZH0tdGFyZ2V0XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtYXZhdGFyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIke3JlcG9Vc2VyVXJsfSR7Y3VycmVudFVzZXJ9LnBuZ1wiIGFsdD1cIiR7Y3VycmVudFVzZXJ9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwibmVvLXRpbWVsaW5lLXVzZXJcIiBocmVmPVwiJHtyZXBvVXNlclVybH0ke2N1cnJlbnRVc2VyfVwiIHRhcmdldD1cIl9ibGFua1wiPiR7Y3VycmVudFVzZXJ9PC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm5lby10aW1lbGluZS1kYXRlXCI+JHttZS5mb3JtYXRUaW1lc3RhbXAoY3VycmVudERhdGUpfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWJvZHlcIj4ke2JvZHl9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+YDtcbiAgICAgICAgICAgICAgICBjb21tZW50QnVmICA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgICAgIC8vIEV2ZW50IExpbmU6IC0gMjAyNi0wMS0xMVQuLi4gQHVzZXIgYWN0aW9uLi4uXG4gICAgICAgICAgICBpZiAoKG1hdGNoID0gbGluZS5tYXRjaChyZWdleFRpbWVsaW5lRXZlbnQpKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgIGxldCBbXywgZGF0ZSwgdXNlciwgYWN0aW9uXSA9IG1hdGNoO1xuXG4gICAgICAgICAgICAgICAgaWNvbiAgICAgID0gJ2ZhLWNpcmNsZS1kb3QnOyAvLyBEZWZhdWx0XG4gICAgICAgICAgICAgICAgYWN0aW9uQ2xzID0gJyc7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBldmVudFR5cGUgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdhZGRlZCB0aGUgYCcsICAgICAgaWNvbjogJ2ZhLXRhZyd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAncmVtb3ZlZCB0aGUgYCcsICAgIGljb246ICdmYS10YWcnfSxcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ2Fzc2lnbmVkJywgICAgICAgICBpY29uOiAnZmEtdXNlci1wZW4nfSxcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ2Nsb3NlZCcsICAgICAgICAgICBpY29uOiAnZmEtY2lyY2xlLWNoZWNrJywgY29sb3I6ICcjODI1MGRmJ30sIC8vIEdpdEh1YiBQdXJwbGVcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ3Jlb3BlbmVkJywgICAgICAgICBpY29uOiAnZmEtY2lyY2xlLWRvdCcsICAgY29sb3I6ICcjMmRhNDRlJ30sIC8vIEdpdEh1YiBHcmVlblxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAncmVmZXJlbmNlZCcsICAgICAgIGljb246ICdmYS1saW5rJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdjcm9zcy1yZWZlcmVuY2VkJywgaWNvbjogJ2ZhLWxpbmsnfSxcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ21pbGVzdG9uZWQnLCAgICAgICBpY29uOiAnZmEtc2lnbi1wb3N0J30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdzdWItaXNzdWUnLCAgICAgICAgaWNvbjogJ2ZhLWRpYWdyYW0tcHJvamVjdCd9XG4gICAgICAgICAgICAgICAgXS5maW5kKGUgPT4gYWN0aW9uLmluY2x1ZGVzKGUua2V5KSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpY29uID0gZXZlbnRUeXBlLmljb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUuY29sb3IpIGNvbG9yID0gZXZlbnRUeXBlLmNvbG9yXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgbWFya2Rvd24gaW4gYWN0aW9uIHRleHQgKGUuZy4gYGNvZGVgIHRvIDxjb2RlPilcbiAgICAgICAgICAgICAgICBsZXQgY2xlYW5BY3Rpb24gPSBtYXJrZWQucGFyc2VJbmxpbmUoYWN0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmIChpY29uID09PSAnZmEtdGFnJykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbkFjdGlvbiA9IGNsZWFuQWN0aW9uLnJlcGxhY2UoLzxjb2RlPiguKj8pPFxcL2NvZGU+L2csIChtYXRjaCwgbGFiZWwpID0+IG1lLmdldExhYmVsQmFkZ2VIdG1sKGxhYmVsKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlc29sdmUgY29sb3IgZnJvbSBsYWJlbFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxNYXRjaCA9IGFjdGlvbi5tYXRjaCgvYChbXmBdKylgLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxOYW1lID0gbGFiZWxNYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbFJlYyAgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ2xhYmVscycpLmdldChsYWJlbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsUmVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBsYWJlbFJlYy5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExpbmtpZnkgQ29tbWl0IEhhc2hlc1xuICAgICAgICAgICAgICAgIGNsZWFuQWN0aW9uID0gY2xlYW5BY3Rpb24ucmVwbGFjZShyZWdleENvbW1pdCwgYDxhIGhyZWY9XCIke2NvbW1pdHNVcmx9JDFcIiB0YXJnZXQ9XCJfYmxhbmtcIj4kMTwvYT5gKTtcblxuICAgICAgICAgICAgICAgIGlkID0gYHRpbWVsaW5lLSR7bWUucmVjb3JkLmlkfS0ke21lLnRpbWVsaW5lRGF0YS5sZW5ndGggKyAxfWA7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGEgc2hvcnQgYWN0aW9uIG5hbWUgZm9yIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgbGV0IHNob3J0QWN0aW9uID0gYWN0aW9uLnNwbGl0KCcgJylbMF07IC8vICdhZGRlZCcsICdjbG9zZWQnLCBldGMuXG5cbiAgICAgICAgICAgICAgICBpZiAoc2hvcnRBY3Rpb24gPT09ICdhZGRlZCcgfHwgc2hvcnRBY3Rpb24gPT09ICdyZW1vdmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxNYXRjaCA9IGFjdGlvbi5tYXRjaCgvYChbXmBdKylgLyk7XG4gICAgICAgICAgICAgICAgICAgIHNob3J0QWN0aW9uID0gbGFiZWxNYXRjaCA/IGxhYmVsTWF0Y2hbMV0gOiAnTGFiZWwnXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUudGltZWxpbmVEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsIC8vIFBhc3MgcmVzb2x2ZWQgaGV4IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGljb24gOiBpY29uLFxuICAgICAgICAgICAgICAgICAgICBpZCAgIDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgOiBgJHtOZW8uY2FwaXRhbGl6ZShzaG9ydEFjdGlvbil9ICgke3VzZXJ9KWAsXG4gICAgICAgICAgICAgICAgICAgIHRhZyAgOiAnZXZlbnQnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBjb2xvciBzdHlsZSBpZiBwcmVzZW50LCBvdGhlcndpc2UgZGVmYXVsdFxuICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IGNvbG9yID8gYHN0eWxlPVwiY29sb3I6ICR7Y29sb3J9XCJgIDogJyc7XG5cbiAgICAgICAgICAgICAgICBodG1sICs9IGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7aWR9XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtaXRlbSBldmVudFwiIGRhdGEtcmVjb3JkLWlkPVwiJHtpZH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2lkfS10YXJnZXRcIiBjbGFzcz1cIm5lby10aW1lbGluZS1iYWRnZVwiICR7c3R5bGV9PjxpIGNsYXNzPVwiZmEtc29saWQgJHtpY29ufVwiPjwvaT48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwibmVvLXRpbWVsaW5lLXVzZXJcIiBocmVmPVwiJHtyZXBvVXNlclVybH0ke3VzZXJ9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+JHt1c2VyfTwvYT4gJHtjbGVhbkFjdGlvbn0gPHNwYW4gY2xhc3M9XCJuZW8tdGltZWxpbmUtZGF0ZVwiPm9uICR7bWUuZm9ybWF0VGltZXN0YW1wKGRhdGUpfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tbWVudCBIZWFkZXI6ICMjIyBAdXNlciAtIDIwMjYtMDEtMTFULi4uXG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoJyMjIyBAJykpIHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlcyBcInVzZXJcIiBhbmQgXCIyMDI2LTAxLTExVC4uLlwiIChJU08gdGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIGxldCBoZWFkZXJNYXRjaCA9IGxpbmUubWF0Y2goL14jIyMgQChcXHcrKSAtIChbXFxkVFo6Li1dKykkLyk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlck1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlciA9IGhlYWRlck1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGhlYWRlck1hdGNoWzJdXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIHdlaXJkIGhlYWRlcnM/IHRyZWF0IGFzIHRleHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSBjb21tZW50QnVmLnB1c2gobGluZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudEJ1Zi5wdXNoKGxpbmUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hDb21tZW50KCk7IC8vIEZsdXNoIGxhc3QgY29tbWVudFxuXG4gICAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XG4gICAgICAgIHJldHVybiBodG1sXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IENhbnZhc1dyYXBwZXIgICAgZnJvbSAnLi9DYW52YXNXcmFwcGVyLm1qcyc7XG5pbXBvcnQgQ29udHJvbGxlciAgICAgICBmcm9tICcuL01haW5Db250YWluZXJDb250cm9sbGVyLm1qcyc7XG5pbXBvcnQgUGFnZUNvbnRhaW5lciAgICBmcm9tICcuL1BhZ2VDb250YWluZXIubWpzJztcbmltcG9ydCBTaGFyZWRDb250YWluZXIgIGZyb20gJy4uLy4uL3NoYXJlZC9jb250ZW50L0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IFN0YXRlUHJvdmlkZXIgICAgZnJvbSAnLi9NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgUG9ydGFsLnZpZXcuc2hhcmVkLmNvbnRlbnQuQ29udGFpbmVyXG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBTaGFyZWRDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydwb3J0YWwtdGlja2V0cy1tYWluY29udGFpbmVyJ11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsncG9ydGFsLXRpY2tldHMtbWFpbmNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fSBjb250cm9sbGVyPU1haW5Db250YWluZXJDb250cm9sbGVyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbGxlcjogQ29udHJvbGxlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcGFnZUNvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgcGFnZUNvbnRhaW5lckNvbmZpZzoge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgOiBQYWdlQ29udGFpbmVyLFxuICAgICAgICAgICAgYnV0dG9uVGV4dEZpZWxkOiAnaWQnLFxuICAgICAgICAgICAgY29udGVudENvbmZpZyAgOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBDYW52YXNXcmFwcGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IHN0YXRlUHJvdmlkZXI9TWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXJcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0ZVByb3ZpZGVyOiBTdGF0ZVByb3ZpZGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB0cmVlQ29uZmlnPXtkaXNwbGF5RmllbGQ6J3RyZWVOb2RlTmFtZSd9XG4gICAgICAgICAqL1xuICAgICAgICB0cmVlQ29uZmlnOiB7XG4gICAgICAgICAgICBkaXNwbGF5RmllbGQ6ICd0cmVlTm9kZU5hbWUnXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXIpO1xuIiwiaW1wb3J0IENvbnRyb2xsZXIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXJDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyQ29udHJvbGxlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJvdXRlc1xuICAgICAgICAgKi9cbiAgICAgICAgcm91dGVzOiB7XG4gICAgICAgICAgICAnL25ld3MvdGlja2V0cycgICAgICAgICAgOiAnb25Sb3V0ZURlZmF1bHQnLFxuICAgICAgICAgICAgJy9uZXdzL3RpY2tldHMveyppdGVtSWR9JzogJ29uUm91dGVJdGVtJ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1cbiAgICAgKi9cbiAgICBuYXZpZ2F0ZVRvKGl0ZW0pIHtcbiAgICAgICAgTmVvLk1haW4uc2V0Um91dGUoe1xuICAgICAgICAgICAgdmFsdWUgICA6IGAvbmV3cy90aWNrZXRzLyR7aXRlbX1gLFxuICAgICAgICAgICAgd2luZG93SWQ6IHRoaXMuY29tcG9uZW50LndpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbnRlbnRFZGl0KGRhdGEpIHtcbiAgICAgICAgLy8gTm8tb3AgZm9yIHRpY2tldHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29udGVudFJlZnJlc2goZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgndHJlZScpLmRvRmV0Y2hDb250ZW50KGRhdGEucmVjb3JkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25JbnRlcnNlY3QoZGF0YSkge1xuICAgICAgICBsZXQgcGFuZWwgICAgPSB0aGlzLmdldFJlZmVyZW5jZSgncGFnZS1zZWN0aW9ucy1jb250YWluZXInKSxcbiAgICAgICAgICAgIGxpc3QgICAgID0gcGFuZWwubGlzdCxcbiAgICAgICAgICAgIHJlY29yZElkID0gZGF0YS5kYXRhLnJlY29yZElkLFxuICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgIGlmIChyZWNvcmRJZCAmJiAhbGlzdC5pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgcmVjb3JkID0gbGlzdC5zdG9yZS5nZXQocmVjb3JkSWQpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zZWxlY3Rpb25Nb2RlbC5zZWxlY3QocmVjb3JkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk5leHRQYWdlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLm5hdmlnYXRlVG8odGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSgnbmV4dFBhZ2VSZWNvcmQnKS5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUGFnZVNlY3Rpb25zVG9nZ2xlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgncGFnZS1zZWN0aW9ucy1jb250YWluZXInKS50b2dnbGVDbHMoJ25lby1leHBhbmRlZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblByZXZpb3VzUGFnZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvKHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoJ3ByZXZpb3VzUGFnZVJlY29yZCcpLmlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Sb3V0ZURlZmF1bHQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RvcmUgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3RyZWUnKTtcblxuICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIG1lLm5hdmlnYXRlVG8oc3RvcmUuZ2V0QXQoMSkuaWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9yZS5vbih7XG4gICAgICAgICAgICAgICAgbG9hZCA6ICgpID0+IG1lLm5hdmlnYXRlVG8oc3RvcmUuZ2V0QXQoMSkuaWQpLFxuICAgICAgICAgICAgICAgIGRlbGF5OiAxMCxcbiAgICAgICAgICAgICAgICBvbmNlIDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaXRlbUlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYXN5bmMgb25Sb3V0ZUl0ZW0oe2l0ZW1JZH0sIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdGF0ZVByb3ZpZGVyID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgICA9IHN0YXRlUHJvdmlkZXIuZ2V0U3RvcmUoJ3RyZWUnKSxcbiAgICAgICAgICAgIHRyZWUgICAgICAgICAgPSBtZS5nZXRSZWZlcmVuY2UoJ3RyZWUnKTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhlIHRyZWUgaGFzIHRoZSBjb3JyZWN0IHJvdXRlIHByZWZpeCBmb3IgdGhpcyBjb250cm9sbGVyIGNvbnRleHRcbiAgICAgICAgaWYgKHRyZWUucm91dGVQcmVmaXggIT09ICcvbmV3cy90aWNrZXRzJykge1xuICAgICAgICAgICAgdHJlZS5yb3V0ZVByZWZpeCA9ICcvbmV3cy90aWNrZXRzJ1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGVQcm92aWRlci5kYXRhLmN1cnJlbnRQYWdlUmVjb3JkID0gc3RvcmUuZ2V0KGl0ZW1JZCk7XG4gICAgICAgICAgICB0cmVlLmV4cGFuZFBhcmVudHMoaXRlbUlkKTtcblxuICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZT8uaGFzaFN0cmluZz8uc3RhcnRzV2l0aCgnL25ld3MvdGlja2V0cycpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGV4cGFuc2lvbiBWRE9NIHVwZGF0ZSB0byBiZSBhcHBsaWVkIGFuZCB0aGUgaXRlbSB0byBiZSB2aXNpYmxlIGluIHRoZSBET01cbiAgICAgICAgICAgICAgICBjb25zdCBpZCAgID0gdHJlZS5nZXRJdGVtSWQoaXRlbUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICByZWN0ID0gYXdhaXQgdHJlZS53YWl0Rm9yRG9tUmVjdCh7aWQsIGF0dGVtcHRzOiAyMCwgZGVsYXk6IDIwfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0cmVlLnNjcm9sbFRvSXRlbShpdGVtSWQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzdG9yZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgc2VsZWN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JlLm9uKHtcbiAgICAgICAgICAgICAgICBsb2FkIDogc2VsZWN0LFxuICAgICAgICAgICAgICAgIGRlbGF5OiAxMCxcbiAgICAgICAgICAgICAgICBvbmNlIDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TaWRlTmF2VG9nZ2xlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgnc2lkZW5hdi1jb250YWluZXInKS50b2dnbGVDbHMoJ25lby1leHBhbmRlZCcpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyQ29udHJvbGxlcik7XG4iLCJpbXBvcnQgVGlja2V0TGFiZWxzU3RvcmUgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3RvcmUvVGlja2V0TGFiZWxzLm1qcyc7XG5pbXBvcnQgVGlja2V0VGltZWxpbmVTZWN0aW9uc1N0b3JlICBmcm9tICcuLi8uLi8uLi9zdG9yZS9UaWNrZXRUaW1lbGluZVNlY3Rpb25zLm1qcyc7XG5pbXBvcnQgVGlja2V0c1N0b3JlICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zdG9yZS9UaWNrZXRzLm1qcyc7XG5pbXBvcnQgU3RhdGVQcm92aWRlciAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvc3RhdGUvUHJvdmlkZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyXG4gKiBAZXh0ZW5kcyBOZW8uc3RhdGUuUHJvdmlkZXJcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIgZXh0ZW5kcyBTdGF0ZVByb3ZpZGVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gZGF0YS5jb3VudFBhZ2VzPW51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY291bnRQYWdlczogbnVsbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGRhdGEuY291bnRQYWdlcz1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvdW50U2VjdGlvbnM6IG51bGwsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByZWNvcmQgd2hpY2ggZ2V0cyBzaG93biBhcyB0aGUgY29udGVudCBwYWdlXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGEuY3VycmVudFJlY29yZD1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUmVjb3JkOiBudWxsLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcmVjb3JkIHdoaWNoIGdldHMgc2hvd24gYXMgdGhlIGNvbnRlbnQgcGFnZVxuICAgICAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhLm5leHRQYWdlUmVjb3JkPW51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbmV4dFBhZ2VSZWNvcmQ6IG51bGwsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByZWNvcmQgd2hpY2ggZ2V0cyBzaG93biBhcyB0aGUgY29udGVudCBwYWdlXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGEucHJldmlvdXNQYWdlUmVjb3JkPW51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHJldmlvdXNQYWdlUmVjb3JkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0b3Jlc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVzOiB7XG4gICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICBhdXRvTG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtb2R1bGUgIDogVGlja2V0TGFiZWxzU3RvcmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogVGlja2V0VGltZWxpbmVTZWN0aW9uc1N0b3JlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJlZToge1xuICAgICAgICAgICAgICAgIGF1dG9Mb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBUaWNrZXRzU3RvcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uRGF0YVByb3BlcnR5Q2hhbmdlKGtleSwgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLm9uRGF0YVByb3BlcnR5Q2hhbmdlKGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdjb3VudFNlY3Rpb25zJzoge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY29tcG9uZW50LmdldFJlZmVyZW5jZSgncGFnZS1zZWN0aW9ucy1jb250YWluZXInKT8udG9nZ2xlQ2xzKCduZW8tZXhwYW5kZWQnLCBmYWxzZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjdXJyZW50UGFnZVJlY29yZCc6IHtcbiAgICAgICAgICAgICAgICBsZXQge2RhdGF9ICAgICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgICAgIHtjb3VudFBhZ2VzfSAgICAgICA9IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlICAgICAgICAgICAgICA9IG1lLmdldFN0b3JlKCd0cmVlJyksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgICAgICA9IHN0b3JlLmluZGV4T2YodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UGFnZVJlY29yZCAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2VSZWNvcmQgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpLCByZWNvcmQ7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9naWMgYXNzdW1lcyB0aGF0IHRoZSB0cmVlIHN0b3JlIGlzIHNvcnRlZFxuICAgICAgICAgICAgICAgIGZvciAoaT1pbmRleC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXRBdChpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiAmJiAhbWUucmVjb3JkSXNIaWRkZW4ocmVjb3JkLCBzdG9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUGFnZVJlY29yZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5zZXREYXRhKHtwcmV2aW91c1BhZ2VSZWNvcmR9KTtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBsb2dpYyBhc3N1bWVzIHRoYXQgdGhlIHRyZWUgc3RvcmUgaXMgc29ydGVkXG4gICAgICAgICAgICAgICAgZm9yIChpPWluZGV4KzE7IGkgPCBjb3VudFBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgJiYgIW1lLnJlY29yZElzSGlkZGVuKHJlY29yZCwgc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UGFnZVJlY29yZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5zZXREYXRhKHtuZXh0UGFnZVJlY29yZH0pO1xuXG4gICAgICAgICAgICAgICAgbWUuY29tcG9uZW50LmdldFJlZmVyZW5jZSgnc2lkZW5hdi1jb250YWluZXInKT8udG9nZ2xlQ2xzKCduZW8tZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIGNoZWNrIHRoZSBwYXJlbnQtbm9kZSBjaGFpbiBpbnNpZGUgdGhlIHRyZWUuXG4gICAgICogPT4gQW55IGhpZGRlbiBwYXJlbnQtbm9kZSByZXN1bHRzIGluIGEgaGlkZGVuIHJlY29yZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gc3RvcmVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICByZWNvcmRJc0hpZGRlbihyZWNvcmQsIHN0b3JlKSB7XG4gICAgICAgIGlmIChyZWNvcmQuaGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY29yZC5wYXJlbnRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkSXNIaWRkZW4oc3RvcmUuZ2V0KHJlY29yZC5wYXJlbnRJZCksIHN0b3JlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyU3RhdGVQcm92aWRlcik7XG4iLCJpbXBvcnQgUGFnZUNvbnRhaW5lciBmcm9tICcuLi8uLi9zaGFyZWQvY29udGVudC9QYWdlQ29udGFpbmVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5QYWdlQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBQb3J0YWwudmlldy5zaGFyZWQuY29udGVudC5QYWdlQ29udGFpbmVyXG4gKi9cbmNsYXNzIFRpY2tldFBhZ2VDb250YWluZXIgZXh0ZW5kcyBQYWdlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5QYWdlQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuUGFnZUNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlPXtmbGV4OjEsb3ZlcmZsb3dZOidhdXRvJyxwb3NpdGlvbjoncmVsYXRpdmUnfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IHtmbGV4OiAxLCBvdmVyZmxvd1k6ICdhdXRvJywgcG9zaXRpb246ICdyZWxhdGl2ZSd9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRQYWdlQ29udGFpbmVyKTtcbiIsImltcG9ydCBDYW52YXMgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudC9DYW52YXMubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBUaGUgXCJDb29yZGluYXRvclwiIGNvbXBvbmVudCBmb3IgdGhlIE5ldXJhbCBUaW1lbGluZSwgYnJpZGdpbmcgdGhlIEFwcCBXb3JrZXIgYW5kIENhbnZhcyBXb3JrZXIuXG4gKlxuICogVGhpcyBjb21wb25lbnQgcmVuZGVycyBhIHRyYW5zcGFyZW50IGNhbnZhcyBvdmVybGF5IG9uIHRvcCBvZiB0aGUgVGlja2V0IExpc3QuIEl0IGlzIHJlc3BvbnNpYmxlIGZvcjpcbiAqIDEuICoqRGF0YSBCcmlkZ2UqKjogTGlzdGVuaW5nIHRvIHRoZSBgc2VjdGlvbnNgIHN0b3JlIGFuZCBwYXNzaW5nIHRpY2tldCBkYXRhIHRvIHRoZSBgVGlja2V0Q2FudmFzYCAoU2hhcmVkV29ya2VyKS5cbiAqIDIuICoqVmlzdWFsIEFsaWdubWVudCoqOiBDYWxjdWxhdGluZyB0aGUgcHJlY2lzZSBET00gcG9zaXRpb25zIG9mIFRpY2tldCBBdmF0YXJzL0JhZGdlcyB0byBlbnN1cmUgdGhlXG4gKiAgICBjYW52YXMgbm9kZXMgYWxpZ24gcGVyZmVjdGx5IHdpdGggdGhlIEhUTUwgY29udGVudC5cbiAqIDMuICoqTGlmZWN5Y2xlIE1hbmFnZW1lbnQqKjogaW5pdGlhbGl6aW5nIHRoZSBvZmZzY3JlZW4gY2FudmFzIHRyYW5zZmVyIGFuZCBoYW5kbGluZyByZXNpemUgZXZlbnRzLlxuICpcbiAqIEl0IHVzZXMgdGhlIGBQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhc2Agc2luZ2xldG9uICh2aWEgUmVtb3RlIE1ldGhvZCBBY2Nlc3MpIHRvIGRyaXZlIHRoZSBhY3R1YWwgYW5pbWF0aW9uLlxuICpcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuVGltZWxpbmVDYW52YXNcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQ2FudmFzXG4gKi9cbmNsYXNzIFRpbWVsaW5lQ2FudmFzIGV4dGVuZHMgQ2FudmFzIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5UaW1lbGluZUNhbnZhcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlRpbWVsaW5lQ2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGlzdGVuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIHJlc2l6ZTogJ29uUmVzaXplJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdkaXYnLCBjbHM6IFsnbmVvLXRpY2tldC10aW1lbGluZS13cmFwcGVyJ10sIHN0eWxlOiB7d2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSd9LCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ2NhbnZhcycsIHN0eWxlOiB7d2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSd9fVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2FudmFzSWQ9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQ2FudmFzUmVhZHk9ZmFsc2VcbiAgICAgKi9cbiAgICBpc0NhbnZhc1JlYWR5ID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gbGFzdFJlY29yZHM9bnVsbFxuICAgICAqL1xuICAgIGxhc3RSZWNvcmRzID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0b3JlID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdzZWN0aW9ucycpO1xuXG4gICAgICAgIHN0b3JlLm9uKCdsb2FkJywgbWUub25UaW1lbGluZURhdGFMb2FkLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgaG9vayB0aGF0IHJ1bnMgb25jZSB0aGUgYE9mZnNjcmVlbkNhbnZhc2AgaGFzIGJlZW4gdHJhbnNmZXJyZWQgdG8gdGhlIENhbnZhcyBXb3JrZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZDpcbiAgICAgKiAxLiBJbXBvcnRzIHRoZSBgVGlja2V0Q2FudmFzYCBsb2dpYyBpbnRvIHRoZSBDYW52YXMgV29ya2VyIGNvbnRleHQuXG4gICAgICogMi4gSW5pdGlhbGl6ZXMgdGhlIGdyYXBoIGluIHRoZSB3b3JrZXIgdmlhIFJlbW90ZSBNZXRob2QgQWNjZXNzIChgaW5pdEdyYXBoYCkuXG4gICAgICogMy4gU2V0cyB1cCBhIGBSZXNpemVPYnNlcnZlcmAgdG8ga2VlcCB0aGUgY2FudmFzIHNpemUgc3luY2VkIHdpdGggdGhlIERPTS5cbiAgICAgKiA0LiBUcmlnZ2VycyB0aGUgaW5pdGlhbCBkYXRhIGxvYWQgaWYgc3RvcmUgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldE9mZnNjcmVlblJlZ2lzdGVyZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGxvZ2ljIGlzIGxvYWRlZCBpbiB0aGUgd29ya2VyXG4gICAgICAgICAgICBhd2FpdCBQb3J0YWwuY2FudmFzLkhlbHBlci5pbXBvcnRUaWNrZXRDYW52YXMoKTtcblxuICAgICAgICAgICAgLy8gRGlyZWN0IFJlbW90ZSBNZXRob2QgQWNjZXNzIGNhbGxcbiAgICAgICAgICAgIGF3YWl0IFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzLmluaXRHcmFwaCh7Y2FudmFzSWQ6IG1lLmdldENhbnZhc0lkKCksIHdpbmRvd0lkOiBtZS53aW5kb3dJZH0pO1xuXG4gICAgICAgICAgICBtZS5pc0NhbnZhc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gUmVnaXN0ZXIgUmVzaXplT2JzZXJ2ZXIgZm9yIHRoZSBjYW52YXMgd3JhcHBlciAobWUuaWQpXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5SZXNpemVPYnNlcnZlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWwgc2l6aW5nXG4gICAgICAgICAgICBhd2FpdCBtZS51cGRhdGVTaXplKCk7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWwgbG9hZCBjaGVja1xuICAgICAgICAgICAgbGV0IHN0b3JlID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdzZWN0aW9ucycpO1xuXG4gICAgICAgICAgICBpZiAoc3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5vblRpbWVsaW5lRGF0YUxvYWQoc3RvcmUuaXRlbXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmlzQ2FudmFzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFN0b3AgdGhlIHdvcmtlciBsb29wIHRvIHByZXZlbnQgXCJab21iaWUgQ2FudmFzXCIgQ1BVIHVzYWdlXG4gICAgICAgICAgICBhd2FpdCBQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhcy5jbGVhckdyYXBoKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIHJldHVybiB0aGUgaW5uZXIgY2FudmFzIElEXG4gICAgICovXG4gICAgZ2V0Q2FudmFzSWQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jYW52YXNJZCkge1xuICAgICAgICAgICAgbWUuY2FudmFzSWQgPSBtZS52ZG9tLmNuWzBdLmlkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLmNhbnZhc0lkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvblJlc2l6ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjYW52YXMgc2l6ZSBpbiB0aGUgd29ya2VyXG4gICAgICAgIGF3YWl0IG1lLnVwZGF0ZVNpemUoZGF0YS5jb250ZW50UmVjdCk7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBjYWNoZWQgcmVjb3JkcywgcmUtY2FsY3VsYXRlIG5vZGUgcG9zaXRpb25zXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbnRhaW5lciBkaW1lbnNpb25zIChhbmQgbGlrZWx5IHJlbGF0aXZlIHBvc2l0aW9ucykgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICBpZiAobWUubGFzdFJlY29yZHMpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtZmV0Y2ggcmVjdHMgaW5zdGFudGx5LCBidXQgaXQncyBzYWZlciB0byBkbyBzb1xuICAgICAgICAgICAgLy8gdG8gZW5zdXJlIGFsaWdubWVudCB3aXRoIHRoZSBuZXcgbGF5b3V0LlxuICAgICAgICAgICAgbWUub25UaW1lbGluZURhdGFMb2FkKG1lLmxhc3RSZWNvcmRzLCB0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvcmUgXCJBbGlnbm1lbnQgRW5naW5lXCIgb2YgdGhlIHRpbWVsaW5lLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgc3luY2hyb25pemVzIHRoZSBDYW52YXMgbm9kZXMgd2l0aCB0aGUgRE9NIGVsZW1lbnRzIChBdmF0YXJzL0JhZGdlcykuXG4gICAgICpcbiAgICAgKiAqKlN0cmF0ZWd5OioqXG4gICAgICogMS4gKipUYXJnZXRpbmcqKjogSXQgdXNlcyB0aGUgYC10YXJnZXRgIElEIHN1ZmZpeCB0byBmaW5kIHRoZSBzcGVjaWZpYyBET00gZWxlbWVudHMgKEF2YXRhcnMpIHdpdGhpbiB0aGUgdGlja2V0IGxpc3QuXG4gICAgICogMi4gKipNZWFzdXJlbWVudCoqOiBJdCBmZXRjaGVzIHRoZSBgRE9NUmVjdGAgZm9yIGV2ZXJ5IHRhcmdldCB0byBnZXQgaXRzIGV4YWN0IHNjcmVlbiBwb3NpdGlvbi5cbiAgICAgKiAzLiAqKlRyYW5zbGF0aW9uKio6IEl0IGNvbnZlcnRzIHRoZXNlIHNjcmVlbiBjb29yZGluYXRlcyBpbnRvIENhbnZhcy1sb2NhbCBjb29yZGluYXRlcy5cbiAgICAgKiA0LiAqKkhhbmRvZmYqKjogSXQgcGFja2FnZXMgdGhpcyBnZW9tZXRyaWMgZGF0YSAoeCwgeSwgcmFkaXVzLCBjb2xvcikgYW5kIHNlbmRzIGl0IHRvIHRoZVxuICAgICAqICAgIGBUaWNrZXRDYW52YXNgIHdvcmtlciB0byB1cGRhdGUgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118T2JqZWN0fSByZWNvcmRzIEFycmF5IG9mIHJlY29yZHMgb3IgU3RvcmUgbG9hZCBldmVudCBvYmplY3Qge2l0ZW1zOiBbLi4uXX1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1Jlc2l6ZT1mYWxzZV1cbiAgICAgKi9cbiAgICBhc3luYyBvblRpbWVsaW5lRGF0YUxvYWQocmVjb3JkcywgaXNSZXNpemUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIEhhbmRsZSBTdG9yZSAnbG9hZCcgZXZlbnQgc2lnbmF0dXJlOiBmaXJlKCdsb2FkJywge2l0ZW1zOiBbLi4uXX0pXG4gICAgICAgIGlmIChyZWNvcmRzICYmICFBcnJheS5pc0FycmF5KHJlY29yZHMpICYmIHJlY29yZHMuaXRlbXMpIHtcbiAgICAgICAgICAgIHJlY29yZHMgPSByZWNvcmRzLml0ZW1zXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVjb3JkcykpIHtcbiAgICAgICAgICAgIC8vIFNhZmV0eSBjaGVjayBpZiByZWNvcmRzIGlzIHN0aWxsIGludmFsaWRcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5pc0NhbnZhc1JlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmxhc3RSZWNvcmRzID0gcmVjb3JkcztcblxuICAgICAgICBsZXQgaWRzICAgICAgICAgPSByZWNvcmRzLm1hcChyID0+IGAke3IuaWR9LXRhcmdldGApLFxuICAgICAgICAgICAgY29tcG9uZW50SWQgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSgnY29udGVudENvbXBvbmVudElkJyksXG4gICAgICAgICAgICB0aW1lbGluZUlkICA9IGB0aWNrZXQtdGltZWxpbmUtJHtjb21wb25lbnRJZH1gLFxuICAgICAgICAgICAgcmVjdHMsIHRpbWVsaW5lUmVjdDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggRE9NIHJlY3RzIGZvciB0aGUgTUFSS0VSUyAoQXZhdGFycy9CYWRnZXMpLCBub3QgdGhlIGNvbnRhaW5lcnNcbiAgICAgICAgICAgIHJlY3RzID0gYXdhaXQgbWUud2FpdEZvckRvbVJlY3Qoe1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzOiAyMCxcbiAgICAgICAgICAgICAgICBkZWxheSAgIDogNTAsXG4gICAgICAgICAgICAgICAgaWQgICAgICA6IGlkc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChtZS5sYXN0UmVjb3JkcyAhPT0gcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGZXRjaCB0aW1lbGluZSBjb250YWluZXIgcmVjdCAob3B0aW9uYWwsIGZhbGxiYWNrKVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgdGltZWxpbmVSZWN0ID0gYXdhaXQgbWUuZ2V0RG9tUmVjdCh0aW1lbGluZUlkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBnb3QgdmFsaWQgcmVjdHMgKGF0IGxlYXN0IG9uZSlcbiAgICAgICAgICAgIGxldCBoYXNSZWN0cyA9IHJlY3RzICYmIHJlY3RzLnNvbWUociA9PiByKTtcblxuICAgICAgICAgICAgaWYgKCFoYXNSZWN0cykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbiBmaXJzdCB2YWxpZCBkYXRhIGxvYWQgKG5vdCByZXNpemUpLCBlbnN1cmUgc2l6ZSBpcyBzeW5jZWRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgY29udGVudCBtaWdodCBoYXZlIHB1c2hlZCB0aGUgY29udGFpbmVyIGhlaWdodC5cbiAgICAgICAgICAgIGlmICghaXNSZXNpemUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS51cGRhdGVTaXplKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNhbnZhc1JlY3QgPSBhd2FpdCBtZS5nZXREb21SZWN0KG1lLmdldENhbnZhc0lkKCkpLFxuICAgICAgICAgICAgICAgIG5vZGVzICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBzdGFydFkgICAgID0gMDtcblxuICAgICAgICAgICAgaWRzLmZvckVhY2goKHRhcmdldElkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWN0ICAgPSByZWN0c1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZHNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUFJFQ0lTRSBDRU5URVJJTkdcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93ICdyZWN0JyBpcyB0aGUgYWN0dWFsIGF2YXRhci9iYWRnZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlY3QuaGVpZ2h0IC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVZICA9IHJlY3QueSAtIGNhbnZhc1JlY3QueSArIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVYICA9IHJlY3QueCAtIGNhbnZhc1JlY3QueCArIChyZWN0LndpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXN0aW5jdCBwYWRkaW5nIGZvciBPcmJpdCBlZmZlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2YXRhcnMgKH40MHB4KSBnZXQgbW9yZSBicmVhdGhpbmcgcm9vbSB0aGFuIEJhZGdlcyAofjI4cHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gcmVjdC5oZWlnaHQgPiAzMiA/IDYgOiAzO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgOiByZWNvcmQuY29sb3IsIC8vIFBhc3MgSGV4IENvbG9yIChlLmcuICNmZjAwMDApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgICA6IHJlY29yZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogb2Zmc2V0ICsgcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgICAgIDogbm9kZVksXG4gICAgICAgICAgICAgICAgICAgICAgICB4ICAgICA6IG5vZGVYXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgc3RhcnRZIG9mIHRoZSBsaW5lIHRvIHRoZSBmaXJzdCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRZID0gbm9kZVlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhcy51cGRhdGVHcmFwaERhdGEoe25vZGVzLCByZXNldDogIWlzUmVzaXplLCBzdGFydFl9KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaW1lbGluZUNhbnZhcyB1cGRhdGUgZmFpbGVkJywgZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlY3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTaXplKHJlY3QpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC53aWR0aCA9PT0gMCB8fCByZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmVjdCA9IGF3YWl0IG1lLndhaXRGb3JEb21SZWN0KHtpZDogbWUuZ2V0Q2FudmFzSWQoKX0pXG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhcy51cGRhdGVTaXplKHt3aWR0aDogcmVjdC53aWR0aCwgaGVpZ2h0OiByZWN0LmhlaWdodH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaW1lbGluZUNhbnZhcyk7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkNhbnZhc1xuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIENhbnZhcyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkNhbnZhcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5DYW52YXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgYSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyIGFuZCBmaXJlcyBhIGN1c3RvbSByZXNpemUgZXZlbnRcbiAgICAgICAgICogd2hpY2ggb3RoZXIgaW5zdGFuY2VzIGNhbiBzdWJzY3JpYmUgdG8uXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vbml0b3JTaXplXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9uaXRvclNpemVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2Zmc2NyZWVuPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNjcmVlbjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgYXBwbGljYWJsZSBpZiBvZmZzY3JlZW4gPT09IHRydWUuXG4gICAgICAgICAqIHRydWUgb25jZSB0aGUgb3duZXJzaGlwIG9mIHRoZSBjYW52YXMgbm9kZSBnb3QgdHJhbnNmZXJyZWQgdG8gd29ya2VyLkNhbnZhcy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2Zmc2NyZWVuUmVnaXN0ZXJlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzY3JlZW5SZWdpc3RlcmVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt0YWc6ICdjYW52YXMnfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdjYW52YXMnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICAgICA9IG1lLmdldENhbnZhc0lkKCksXG4gICAgICAgICAgICB7b2Zmc2NyZWVufSA9IG1lO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgzMCk7IC8vIG5leHQgckFGIHRpY2tcblxuICAgICAgICAgICAgaWYgKG1lLm1vbml0b3JTaXplKSB7XG4gICAgICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFt7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlOiBgIyR7bWUuZ2V0Q2FudmFzSWQoKX1gLFxuICAgICAgICAgICAgICAgICAgICByZXNpemUgIDogbWUub25Eb21SZXNpemUsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICAgICAgICAgIH1dKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IE5lby5tYWluLkRvbUFjY2Vzcy5nZXRPZmZzY3JlZW5DYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQgIDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEub2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IE5lby53b3JrZXIuQ2FudmFzLnJlZ2lzdGVyQ2FudmFzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgICAgOiBkYXRhLm9mZnNjcmVlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCAgOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgICAgICAgICB9LCBbZGF0YS5vZmZzY3JlZW5dKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5vZmZzY3JlZW5SZWdpc3RlcmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50cmFuc2ZlcnJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmNvbmZpZy51c2VTaGFyZWRXb3JrZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0cmlldmVEYXRhID0gYXdhaXQgTmVvLndvcmtlci5DYW52YXMucmV0cmlldmVDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCAgOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0cmlldmVEYXRhLmhhc0NhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICBtZS5vZmZzY3JlZW5SZWdpc3RlcmVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vZmZzY3JlZW5SZWdpc3RlcmVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHdoZW4gdXNpbmcgd3JhcHBlcnMgKGUuZy4gRDMpXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDYW52YXNJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRG9tUmVzaXplKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdyZXNpemUnLCBkYXRhKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FudmFzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=