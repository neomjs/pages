export const __webpack_esm_id__ = "vendors-apps_portal_view_news_tickets_MainContainer_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_portal_view_news_tickets_MainContainer_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/portal/model/Ticket.mjs"
/*!**************************************!*\
  !*** ./apps/portal/model/Ticket.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.Ticket
 * @extends Neo.data.Model
 */
class Ticket extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.Ticket'
         * @protected
         */
        className: 'Portal.model.Ticket',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name        : 'collapsed',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name: 'id',
            type: 'String'
        }, {
            name        : 'isLeaf',
            type        : 'Boolean',
            defaultValue: true
        }, {
            name        : 'parentId',
            type        : 'String',
            defaultValue: null
        }, {
            name: 'path', // "resources/content/issues/issue-1234.md"
            type: 'String'
        }, {
            name: 'title', // "Fix elusive bug in Grid"
            type: 'String'
        }, {
            // Computed field for TreeList display
            name: 'treeNodeName',
            type: 'html',
            /**
             * @param {Object}  data
             * @param {String}  data.id
             * @param {Boolean} data.isLeaf
             * @param {String}  data.title
             * @returns {String}
             */
            calculate({id, isLeaf, title}) {
                return isLeaf ? `<b>${id}</b> <span class="ticket-title">${title}</span>` : id
            }
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Ticket));


/***/ },

/***/ "./apps/portal/model/TicketLabel.mjs"
/*!*******************************************!*\
  !*** ./apps/portal/model/TicketLabel.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Portal.model.TicketLabel
 * @extends Neo.data.Model
 */
class TicketLabel extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketLabel'
         * @protected
         */
        className: 'Portal.model.TicketLabel',
        /**
         * @member {Object[]} fields
         * @protected
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'description',
            type: 'String'
        }, {
            name: 'name',
            type: 'String'
        }, {
            name: 'textColor',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabel));


/***/ },

/***/ "./apps/portal/model/TicketTimelineSection.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/model/TicketTimelineSection.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSection.mjs */ "./apps/portal/model/ContentSection.mjs");


/**
 * @class Portal.model.TicketTimelineSection
 * @extends Portal.model.ContentSection
 */
class TicketTimelineSection extends _ContentSection_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.model.TicketTimelineSection'
         * @protected
         */
        className: 'Portal.model.TicketTimelineSection',
        /**
         * @member {Object[]} fields
         */
        fields: [{
            name: 'color',
            type: 'String'
        }, {
            name: 'icon',
            type: 'String'
        }, {
            name: 'image',
            type: 'String'
        }, {
            name: 'sourceId',
            type: 'String'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSection));


/***/ },

/***/ "./apps/portal/store/TicketLabels.mjs"
/*!********************************************!*\
  !*** ./apps/portal/store/TicketLabels.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/TicketLabel.mjs */ "./apps/portal/model/TicketLabel.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Portal.store.TicketLabels
 * @extends Neo.data.Store
 */
class TicketLabels extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketLabels'
         * @protected
         */
        className: 'Portal.store.TicketLabels',
        /**
         * @member {String} keyProperty='name'
         * @protected
         */
        keyProperty: 'name',
        /**
         * @member {Neo.data.Model} model=TicketLabel
         * @protected
         */
        model: _model_TicketLabel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/labels.json'
         * @protected
         */
        url: '../../apps/portal/resources/data/labels.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketLabels));


/***/ },

/***/ "./apps/portal/store/TicketTimelineSections.mjs"
/*!******************************************************!*\
  !*** ./apps/portal/store/TicketTimelineSections.mjs ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentSections.mjs */ "./apps/portal/store/ContentSections.mjs");
/* harmony import */ var _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/TicketTimelineSection.mjs */ "./apps/portal/model/TicketTimelineSection.mjs");



/**
 * @class Portal.store.TicketTimelineSections
 * @extends Portal.store.ContentSections
 */
class TicketTimelineSections extends _ContentSections_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.TicketTimelineSections'
         * @protected
         */
        className: 'Portal.store.TicketTimelineSections',
        /**
         * @member {Neo.data.Model} model=TicketTimelineSection
         * @reactive
         */
        model: _model_TicketTimelineSection_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketTimelineSections));


/***/ },

/***/ "./apps/portal/store/Tickets.mjs"
/*!***************************************!*\
  !*** ./apps/portal/store/Tickets.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Ticket.mjs */ "./apps/portal/model/Ticket.mjs");



/**
 * @class Portal.store.Tickets
 * @extends Neo.data.Store
 */
class Tickets extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.store.Tickets'
         * @protected
         */
        className: 'Portal.store.Tickets',
        /**
         * @member {Neo.data.Model} model=TicketModel
         * @reactive
         */
        model: _model_Ticket_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {String} url='../../apps/portal/resources/data/tickets.json'
         */
        url: '../../apps/portal/resources/data/tickets.json'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tickets));


/***/ },

/***/ "./apps/portal/view/news/tickets/CanvasWrapper.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/CanvasWrapper.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.mjs */ "./apps/portal/view/news/tickets/Component.mjs");
/* harmony import */ var _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TimelineCanvas.mjs */ "./apps/portal/view/news/tickets/TimelineCanvas.mjs");




/**
 * @class Portal.view.news.tickets.CanvasWrapper
 * @extends Neo.container.Base
 */
class CanvasWrapper extends _src_container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.CanvasWrapper'
         * @protected
         */
        className: 'Portal.view.news.tickets.CanvasWrapper',
        /**
         * @member {String[]} cls=['portal-canvas-wrapper']
         */
        cls: ['portal-canvas-wrapper'],
        /**
         * @member {Neo.component.Base|null} contentComponent=ContentComponent
         */
        contentComponent: _Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={overflow:'visible',paddingBottom:'20px',position:'relative'}
         */
        style: {overflow: 'visible', paddingBottom: '20px', position: 'relative'}
    }

    construct(config) {
        let me = this;

        config.items = [{
            module   : _TimelineCanvas_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            reference: 'timeline-canvas',
            style : {
                position     : 'absolute',
                top          : 0,
                left         : 0,
                width        : '100%',
                height       : '100%',
                zIndex       : 2,
                pointerEvents: 'none'
            }
        }, {
            module: config.contentComponent || me.contentComponent,
            style : {
                position: 'relative',
                zIndex  : 1
            },
            listeners: {
                toggleSummary: me.onToggleSummary,
                scope        : me
            }
        }];

        super.construct(config);
    }

    /**
     *
     */
    onToggleSummary() {
        let canvas = this.getReference('timeline-canvas');

        if (canvas?.lastRecords) {
            canvas.onTimelineDataLoad(canvas.lastRecords, true)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CanvasWrapper));


/***/ },

/***/ "./apps/portal/view/news/tickets/Component.mjs"
/*!*****************************************************!*\
  !*** ./apps/portal/view/news/tickets/Component.mjs ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/content/Component.mjs */ "./apps/portal/view/shared/content/Component.mjs");
/* harmony import */ var _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../node_modules/marked/lib/marked.esm.js */ "./node_modules/marked/lib/marked.esm.js");



const
    regexFrontMatter   = /^---\n([\s\S]*?)\n---\n/,
    regexH1            = /(<h1[^>]*>.*?<\/h1>)/,
    regexTicketLink    = /(\d{4,})/,
    regexTimeline      = /## Timeline\s*\n([\s\S]*)/,
    regexTimelineEvent = /^- ([\dTZ:.-]+) @(\w+) (.*)$/,
    regexCommit        = /\b([0-9a-f]{7,40})\b/g;

/**
 * @summary The "Markdown Transformer" for GitHub Tickets.
 *
 * This component extends the standard ContentComponent to provide specialized rendering for GitHub Issues.
 * Its primary responsibility is to parse the raw Markdown content (which includes custom Frontmatter and
 * a pre-generated Timeline section) and transform it into a rich, interactive HTML structure.
 *
 * **Key Responsibilities:**
 * 1. **Parsing Pipeline**: Extracts Frontmatter, Body, and the custom "Timeline" section from the raw Markdown.
 * 2. **Rich Rendering**: Generates HTML for Status Badges, Labels, Commit Links, and User Mentions.
 * 3. **Data Extraction**: As a side effect of rendering, it extracts structured data (`me.timelineData`)
 *    representing every timeline event (comment, label change, close, etc.). This data is then
 *    pushed to the `sections` store to drive the `TimelineCanvas` visualization.
 *
 * @class Portal.view.news.tickets.Component
 * @extends Portal.view.shared.content.Component
 */
class Component extends _shared_content_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.Component'
         * @protected
         */
        className: 'Portal.view.news.tickets.Component',
        /**
         * @member {String[]} cls=['portal-news-tickets-component']
         */
        cls: ['portal-news-tickets-component'],
        /**
         * @member {String} commitsUrl='https://github.com/neomjs/neo/commit/'
         */
        commitsUrl: 'https://github.com/neomjs/neo/commit/',
        /**
         * @member {Object} domListeners
         */
        domListeners: {
            resize: 'onResize'
        },
        /**
         * @member {String} repoUserUrl='https://github.com/'
         */
        repoUserUrl: 'https://github.com/',
        /**
         * @member {Boolean} updateSectionsStore=false
         */
        updateSectionsStore: false
    }

    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatHistory=null
     */
    #dateTimeFormatHistory = null
    /**
     * @member {Intl.DateTimeFormat|null} #dateTimeFormatToday=null
     */
    #dateTimeFormatToday = null
    /**
     * Temporary storage for the structured timeline data extracted during the parsing phase.
     * This array is populated by `renderTimeline` and `modifyMarkdown` and then assigned
     * to the `sections` store to drive the Canvas visualization.
     * @member {Object[]} timelineData=null
     * @private
     */
    timelineData = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.getStateProvider().setData('contentComponentId', this.id)
    }

    /**
     * @param {String} isoString
     * @returns {String}
     */
    formatTimestamp(isoString) {
        if (!isoString) return '';

        let me      = this,
            date    = new Date(isoString),
            now     = new Date(),
            isToday = date.toDateString() === now.toDateString();

        if (isToday) {
            if (!me.#dateTimeFormatToday) {
                me.#dateTimeFormatToday = new Intl.DateTimeFormat('default', {
                    hour  : 'numeric',
                    minute: 'numeric'
                })
            }

            return me.#dateTimeFormatToday.format(date)
        }

        if (!me.#dateTimeFormatHistory) {
            me.#dateTimeFormatHistory = new Intl.DateTimeFormat('default', {
                day   : 'numeric',
                hour  : 'numeric',
                minute: 'numeric',
                month : 'short',
                year  : 'numeric'
            })
        }

        return me.#dateTimeFormatHistory.format(date)
    }

    /**
     * @param {Object} data
     * @returns {String}
     */
    frontMatterToHtml(data) {
        let me   = this,
            html = '<table class="neo-frontmatter-table"><tbody>';

        Object.entries(data).forEach(([key, value]) => {
            let renderedValue;

            if (key === 'subIssues' && Array.isArray(value)) {
                renderedValue = value.map(issue => {
                    return `<div class="neo-sub-issue">${issue
                        .replace(regexTicketLink, '<a href="#/news/tickets/$1">$1</a>')
                        .replace('[x]', '<i class="fa-solid fa-circle-check"></i>')
                        .replace('[ ]', '<i class="fa-regular fa-circle"></i>')}</div>`
                }).join('')
            } else if (key === 'author') {
                renderedValue = `<a href="${me.repoUserUrl}${value}" target="_blank">${value}</a>`
            } else if (key === 'createdAt' || key === 'closedAt' || key === 'updatedAt') {
                renderedValue = me.formatTimestamp(value)
            } else if (key === 'labels' && Array.isArray(value)) {
                renderedValue = me.getBadgesHtml(value)
            } else if (key === 'state') {
                renderedValue = me.getStateBadgeHtml(value)
            } else {
                renderedValue = me.formatFrontMatterValue(value)
            }

            html += `<tr><td>${key}</td><td>${renderedValue}</td></tr>`
        });

        html += '</tbody></table>';

        if (me.useFrontmatterDetails) {
            return `<details id="neo-ticket-summary-details-${me.id}"><summary>Frontmatter</summary>${html}</details>`
        }

        return html
    }

    /**
     * @param {String[]} labels
     * @returns {String}
     */
    getBadgesHtml(labels) {
        if (!labels || labels.length === 0) return '';

        let me         = this,
            badgesHtml = '<div class="neo-ticket-labels">';

        labels.forEach(label => {
            badgesHtml += me.getLabelBadgeHtml(label)
        });

        badgesHtml += '</div>';

        return badgesHtml
    }

    /**
     * @param {Object} record
     * @returns {Promise<void>}
     */
    async doFetchContent(record) {
        let me         = this,
            {windowId} = me,
            content, data, path;

        path = me.getContentPath(record);

        if (record.isLeaf && path) {
            data    = await fetch(path);
            content = await data.text();

            me.value = content;

            me.toggleCls('lab', record.name?.startsWith('Lab:'));

            Neo.main.addon.IntersectionObserver.observe({
                disconnect: true,
                id        : me.id,
                observe   : ['.neo-timeline-item[data-record-id]'],
                windowId
            })
        }
    }

    /**
     * @param {Object} record
     * @param {String} record.path
     * @returns {String|null}
     */
    getContentPath({path}) {
        return path ? Neo.config.basePath + path : null
    }

    /**
     * @param {String} label
     * @returns {String}
     */
    getLabelBadgeHtml(label) {
        let store  = this.getStateProvider().getStore('labels'),
            record = store.get(label);

        if (record) {
            return `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
        }

        return `<span class="neo-badge">${label}</span>`
    }

    /**
     * @param {String} state
     * @returns {String}
     */
    getStateBadgeHtml(state) {
        if (!state) return '';

        let cls  = 'neo-badge neo-state-badge',
            icon = 'fa-circle-dot';

        if (state.toUpperCase() === 'CLOSED') {
            cls  += ' neo-state-closed';
            icon  = 'fa-circle-check'
        } else {
            cls += ' neo-state-open'
        }

        return `<span class="${cls}"><i class="fa-regular ${icon}"></i>${Neo.capitalize(state.toLowerCase())}</span>`
    }

    /**
     * The Main Parsing Pipeline.
     *
     * This method intercepts the raw markdown content before it is rendered and performs a multi-pass transformation:
     * 1. **Extract Timeline**: Pulls out the raw `## Timeline` section to process it separately.
     * 2. **Process Frontmatter**: Extracts metadata (labels, state, author) and removes the YAML block.
     * 3. **Render Body**: Uses the superclass (marked.js) to convert the main issue body to HTML.
     * 4. **Inject Title IDs**: Adds IDs to H1 tags for navigation.
     * 5. **Generate Badges**: Creates HTML for Status/Label badges based on extracted metadata.
     * 6. **Wrap Body**: Wraps the main issue body in a `timeline-item` structure so it appears as the first item.
     * 7. **Re-Assemble**: Concatenates Frontmatter + Title + Timeline (with Body injected) into the final HTML.
     *
     * **Side Effect**: Populates `me.timelineData` and updates the `sections` store.
     *
     * @param {String} content
     * @returns {String}
     */
    modifyMarkdown(content) {
        let me           = this,
            {parentId}   = me.record,
            author       = null,
            createdAt    = null,
            labels       = [],
            state        = null,
            match        = content.match(regexFrontMatter),
            timelineHtml = '',
            badgesHtml   = '';

        me.timelineData = [];

        if (match) {
            let data = me.parseFrontMatter(match[1]);

            if (data.author)    {author    = data.author}
            if (data.createdAt) {createdAt = me.formatTimestamp(data.createdAt)}
            if (data.labels)    {labels    = data.labels}
            if (data.state)     {state     = data.state}
        }

        // 1. Extract and process timeline from RAW markdown
        let timelineMatch = content.match(regexTimeline);
        if (timelineMatch) {
            timelineHtml = me.renderTimeline(timelineMatch[1]);
            content      = content.replace(regexTimeline, ''); // Remove raw timeline
        }

        // 2. Render Frontmatter Manually & Strip it
        // We want it at the very top, outside the body bubble.
        let frontMatterHtml = '';
        if (match) {
            let data        = me.parseFrontMatter(match[1]);
            frontMatterHtml = me.frontMatterToHtml(data);
            content         = content.replace(regexFrontMatter, '');
        }

        // 3. Convert Body + Title to HTML using super
        let fullHtml = super.modifyMarkdown(content);

        // 4. Extract H1 Title from the generated HTML
        let titleHtml = '';
        fullHtml      = fullHtml.replace(regexH1, (match) => {
            // Inject ID into H1 tag
            titleHtml = match.replace('<h1', `<h1 id="ticket-title-${me.id}"`);
            return ''; // Remove title from body
        });

        // 5. Construct Badges
        if (labels.length > 0 || state || (parentId && parentId !== 'Backlog')) {
            badgesHtml = '<div class="neo-ticket-labels">';

            if (state) {
                badgesHtml += me.getStateBadgeHtml(state)
            }

            if (parentId && parentId !== 'Backlog') {
                badgesHtml += `
                    <a class="neo-badge neo-release-badge" href="#/news/releases/${parentId.substring(1)}">
                        <i class="fa-solid fa-code-branch"></i> ${parentId}
                    </a>`
            }

            if (labels.length > 0) {
                let store = me.getStateProvider().getStore('labels'),
                    record;

                labels.forEach(label => {
                    record = store.get(label);

                    if (record) {
                        badgesHtml += `<span class="neo-badge" style="background-color:${record.color};color:${record.textColor}">${label}</span>`
                    } else {
                        badgesHtml += `<span class="neo-badge">${label}</span>`
                    }
                });
            }

            badgesHtml += '</div>';
            titleHtml  += badgesHtml;
        }

        // 6. Wrap the remaining HTML (Body) in the Timeline Item structure
        let bodyId = `timeline-${me.record.id}-0`;

        me.timelineData.unshift({
            id   : bodyId,
            image: me.repoUserUrl + author + '.png',
            name : 'Description',
            tag  : 'body'
        });

        let bodyItemHtml = `
            <div id="${bodyId}" class="neo-timeline-item comment body-item" data-record-id="${bodyId}">
                <div id="${bodyId}-target" class="neo-timeline-avatar">
                    <img src="${me.repoUserUrl}${author}.png" alt="${author}">
                </div>
                <div class="neo-timeline-content">
                    <div class="neo-timeline-header">
                        <a class="neo-timeline-user" href="${me.repoUserUrl}${author}" target="_blank">${author}</a>
                        <span class="neo-timeline-date">commented on ${createdAt}</span>
                    </div>
                    <div class="neo-timeline-body">${fullHtml}</div>
                </div>
            </div>`;

        // 7. Inject Body Item at the start of the Timeline
        let timelineId = `ticket-timeline-${me.id}`;

        if (timelineHtml) {
            timelineHtml = timelineHtml.replace(
                '<div class="neo-ticket-timeline">',
                `<div id="${timelineId}" class="neo-ticket-timeline">` + bodyItemHtml
            )
        } else {
            timelineHtml = `<div id="${timelineId}" class="neo-ticket-timeline">${bodyItemHtml}</div>`
        }

        me.getStateProvider().getStore('sections').data = me.timelineData;
        me.timelineData = null;

        // Return: Frontmatter + Title + Timeline
        return frontMatterHtml + titleHtml + timelineHtml
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        this.fire('toggleSummary')
    }

    /**
     * Parses the custom "Timeline" markdown section.
     *
     * Expects a line-based format generated by the build process:
     * - Events: `- YYYY-MM-DDTHH:mm:ss @user action text...`
     * - Comments: `### @user - YYYY-MM-DDTHH:mm:ss` followed by comment body.
     *
     * This method converts these lines into structured `timeline-item` HTML blocks
     * and simultaneously populates `me.timelineData` with semantic data (color, icon, type)
     * for each event.
     *
     * @param {String} content
     * @returns {String}
     */
    renderTimeline(content) {
        let me          = this,
            {commitsUrl, repoUserUrl} = me,
            html        = '<div class="neo-ticket-timeline">',
            lines       = content.split('\n'),
            commentBuf  = [],
            currentUser = null,
            currentDate = null,
            i           = 0,
            len         = lines.length,
            id, line, match, icon, actionCls;

        const flushComment = () => {
            if (commentBuf.length > 0) {
                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                me.timelineData.push({
                    id   : id,
                    image: repoUserUrl + currentUser + '.png',
                    name : `Comment (${currentUser})`,
                    tag  : 'comment'
                });

                let body = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parse(commentBuf.join('\n'));
                html += `
                    <div id="${id}" class="neo-timeline-item comment" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-avatar">
                            <img src="${repoUserUrl}${currentUser}.png" alt="${currentUser}">
                        </div>
                        <div class="neo-timeline-content">
                            <div class="neo-timeline-header">
                                <a class="neo-timeline-user" href="${repoUserUrl}${currentUser}" target="_blank">${currentUser}</a>
                                <span class="neo-timeline-date">${me.formatTimestamp(currentDate)}</span>
                            </div>
                            <div class="neo-timeline-body">${body}</div>
                        </div>
                    </div>`;
                commentBuf  = [];
                currentUser = null;
                currentDate = null
            }
        };

        for (; i < len; i++) {
            line = lines[i];

            // Event Line: - 2026-01-11T... @user action...
            if ((match = line.match(regexTimelineEvent))) {
                flushComment();
                let [_, date, user, action] = match;

                icon      = 'fa-circle-dot'; // Default
                actionCls = '';

                const eventType = [
                    {key: 'added the `',      icon: 'fa-tag'},
                    {key: 'removed the `',    icon: 'fa-tag'},
                    {key: 'assigned',         icon: 'fa-user-pen'},
                    {key: 'closed',           icon: 'fa-circle-check', color: '#8250df'}, // GitHub Purple
                    {key: 'reopened',         icon: 'fa-circle-dot',   color: '#2da44e'}, // GitHub Green
                    {key: 'referenced',       icon: 'fa-link'},
                    {key: 'cross-referenced', icon: 'fa-link'},
                    {key: 'milestoned',       icon: 'fa-sign-post'},
                    {key: 'sub-issue',        icon: 'fa-diagram-project'}
                ].find(e => action.includes(e.key));

                let color = null;

                if (eventType) {
                    icon = eventType.icon;
                    if (eventType.color) color = eventType.color
                }

                // Clean up markdown in action text (e.g. `code` to <code>)
                let cleanAction = _node_modules_marked_lib_marked_esm_js__WEBPACK_IMPORTED_MODULE_1__.marked.parseInline(action);

                if (icon === 'fa-tag') {
                    cleanAction = cleanAction.replace(/<code>(.*?)<\/code>/g, (match, label) => me.getLabelBadgeHtml(label));

                    // Try to resolve color from label
                    let labelMatch = action.match(/`([^`]+)`/);
                    if (labelMatch) {
                        let labelName = labelMatch[1];
                        let labelRec  = me.getStateProvider().getStore('labels').get(labelName);
                        if (labelRec) {
                            color = labelRec.color;
                        }
                    }
                }

                // Linkify Commit Hashes
                cleanAction = cleanAction.replace(regexCommit, `<a href="${commitsUrl}$1" target="_blank">$1</a>`);

                id = `timeline-${me.record.id}-${me.timelineData.length + 1}`;

                // Extract a short action name for the list
                let shortAction = action.split(' ')[0]; // 'added', 'closed', etc.
                let entryName;

                if (shortAction === 'added' || shortAction === 'removed') {
                    if (action.includes('sub-issue')) {
                        let subIssueMatch = action.match(/#(\d+)/);
                        if (subIssueMatch) {
                            entryName = `${Neo.capitalize(shortAction)} sub-issue #${subIssueMatch[1]}`
                        } else {
                            entryName = `${Neo.capitalize(shortAction)} sub-issue`
                        }
                    } else {
                        let labelMatch = action.match(/`([^`]+)`/);
                        shortAction = labelMatch ? labelMatch[1] : 'Label';
                        entryName = `${Neo.capitalize(shortAction)} (${user})`
                    }
                } else {
                    entryName = `${Neo.capitalize(shortAction)} (${user})`
                }

                me.timelineData.push({
                    color: color, // Pass resolved hex color
                    icon : icon,
                    id   : id,
                    name : entryName,
                    tag  : 'event'
                });

                // Apply color style if present, otherwise default
                let style = color ? `style="color: ${color}"` : '';

                html += `
                    <div id="${id}" class="neo-timeline-item event" data-record-id="${id}">
                        <div id="${id}-target" class="neo-timeline-badge" ${style}><i class="fa-solid ${icon}"></i></div>
                        <div class="neo-timeline-body">
                            <a class="neo-timeline-user" href="${repoUserUrl}${user}" target="_blank">${user}</a> ${cleanAction} <span class="neo-timeline-date">on ${me.formatTimestamp(date)}</span>
                        </div>
                    </div>`;
            }
            // Comment Header: ### @user - 2026-01-11T...
            else if (line.startsWith('### @')) {
                // Captures "user" and "2026-01-11T..." (ISO timestamp)
                let headerMatch = line.match(/^### @(\w+) - ([\dTZ:.-]+)$/);
                if (headerMatch) {
                    flushComment();
                    currentUser = headerMatch[1];
                    currentDate = headerMatch[2]
                } else {
                    // Fallback for weird headers? treat as text
                    if (currentUser) commentBuf.push(line)
                }
            }
            else {
                if (currentUser) {
                    commentBuf.push(line)
                }
            }
        }

        flushComment(); // Flush last comment

        html += '</div>';
        return html
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasWrapper.mjs */ "./apps/portal/view/news/tickets/CanvasWrapper.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/portal/view/news/tickets/MainContainerController.mjs");
/* harmony import */ var _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PageContainer.mjs */ "./apps/portal/view/news/tickets/PageContainer.mjs");
/* harmony import */ var _shared_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/content/Container.mjs */ "./apps/portal/view/shared/content/Container.mjs");
/* harmony import */ var _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MainContainerStateProvider.mjs */ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs");






/**
 * @class Portal.view.news.tickets.MainContainer
 * @extends Portal.view.shared.content.Container
 */
class MainContainer extends _shared_content_Container_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainer',
        /**
         * @member {String[]} cls=['portal-tickets-maincontainer']
         * @reactive
         */
        cls: ['portal-tickets-maincontainer'],
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         * @reactive
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
        /**
         * @member {Object} pageContainerConfig
         */
        pageContainerConfig: {
            module         : _PageContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            buttonTextField: 'id',
            contentConfig  : {
                module: _CanvasWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            }
        },
        /**
         * @member {Neo.state.Provider} stateProvider=MainContainerStateProvider
         * @reactive
         */
        stateProvider: _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
        /**
         * @member {Object} treeConfig={displayField:'treeNodeName'}
         */
        treeConfig: {
            displayField: 'treeNodeName'
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerController.mjs"
/*!*******************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerController.mjs ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Portal.view.news.tickets.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerController'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerController',
        /**
         * @member {Object} routes
         */
        routes: {
            '/news/tickets'          : 'onRouteDefault',
            '/news/tickets/{*itemId}': 'onRouteItem'
        }
    }

    /**
     * @param {String} item
     */
    navigateTo(item) {
        Neo.Main.setRoute({
            value   : `/news/tickets/${item}`,
            windowId: this.component.windowId
        })
    }

    /**
     * @param {Object} data
     */
    onIntersect(data) {
        let panel    = this.getReference('page-sections-container'),
            list     = panel.list,
            recordId = data.data.recordId,
            record;

        if (recordId && !list.isAnimating) {
            record = list.store.get(recordId);

            if (record) {
                list.selectionModel.select(record)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onNextPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('nextPageRecord').id)
    }

    /**
     * @param {Object} data
     */
    onPageSectionsToggleButtonClick(data) {
        this.getReference('page-sections-container').toggleCls('neo-expanded')
    }

    /**
     * @param {Object} data
     */
    onPreviousPageButtonClick(data) {
        this.navigateTo(this.getStateProvider().getData('previousPageRecord').id)
    }

    /**
     * @returns {String}
     */
    getDefaultRouteId() {
        let store     = this.getStateProvider().getStore('tree'),
            rootCount = 0,
            i         = 0,
            len       = store.getCount(),
            record;

        for (; i < len; i++) {
            record = store.getAt(i);

            if (record.parentId === null) {
                rootCount++;

                if (rootCount === 2) {
                    return store.getAt(i + 1)?.id
                }
            }
        }

        return store.getAt(1)?.id
    }

    /**
     * @param {Object} data
     */
    onRouteDefault(data) {
        let me    = this,
            store = me.getStateProvider().getStore('tree');

        if (store.getCount() > 0) {
            me.navigateTo(me.getDefaultRouteId())
        } else {
            store.on({
                load : () => me.navigateTo(me.getDefaultRouteId()),
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.itemId
     * @param {Object} value
     * @param {Object} oldValue
     */
    async onRouteItem({itemId}, value, oldValue) {
        let me            = this,
            stateProvider = me.getStateProvider(),
            store         = stateProvider.getStore('tree'),
            tree          = me.getReference('tree');

        // Ensure the tree has the correct route prefix for this controller context
        if (tree.routePrefix !== '/news/tickets') {
            tree.routePrefix = '/news/tickets'
        }

        const select = async () => {
            stateProvider.data.currentPageRecord = store.get(itemId);

            if (!oldValue?.hashString?.startsWith('/news/tickets')) {
                await tree.expandAndScrollToItem(itemId)
            } else {
                tree.expandParents(itemId)
            }
        };

        if (store.getCount() > 0) {
            await select()
        } else {
            store.on({
                load : select,
                delay: 10,
                once : true
            })
        }
    }

    /**
     * @param {Object} data
     */
    onSideNavToggleButtonClick(data) {
        this.getReference('sidenav-container').toggleCls('neo-expanded')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ },

/***/ "./apps/portal/view/news/tickets/MainContainerStateProvider.mjs"
/*!**********************************************************************!*\
  !*** ./apps/portal/view/news/tickets/MainContainerStateProvider.mjs ***!
  \**********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../store/TicketLabels.mjs */ "./apps/portal/store/TicketLabels.mjs");
/* harmony import */ var _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../store/TicketTimelineSections.mjs */ "./apps/portal/store/TicketTimelineSections.mjs");
/* harmony import */ var _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../store/Tickets.mjs */ "./apps/portal/store/Tickets.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");





/**
 * @class Portal.view.news.tickets.MainContainerStateProvider
 * @extends Neo.state.Provider
 */
class MainContainerStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.MainContainerStateProvider'
         * @protected
         */
        className: 'Portal.view.news.tickets.MainContainerStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {Number|null} data.countPages=null
             */
            countPages: null,
            /**
             * @member {Number|null} data.countPages=null
             */
            countSections: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.currentRecord=null
             */
            currentPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.nextPageRecord=null
             */
            nextPageRecord: null,
            /**
             * The record which gets shown as the content page
             * @member {Object} data.previousPageRecord=null
             */
            previousPageRecord: null
        },
        /**
         * @member {Object} stores
         */
        stores: {
            labels: {
                autoLoad: true,
                module  : _store_TicketLabels_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            },
            sections: {
                module: _store_TicketTimelineSections_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]
            },
            tree: {
                autoLoad: true,
                module  : _store_Tickets_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]
            }
        }
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        super.onDataPropertyChange(key, value, oldValue);

        let me = this;

        switch (key) {
            case 'countSections': {
                if (value < 1) {
                    me.component.getReference('page-sections-container')?.toggleCls('neo-expanded', false)
                }

                break
            }

            case 'currentPageRecord': {
                let {data}             = me,
                    {countPages}       = data,
                    store              = me.getStore('tree'),
                    index              = store.indexOf(value),
                    nextPageRecord     = null,
                    previousPageRecord = null,
                    i, record;

                // the logic assumes that the tree store is sorted
                for (i=index-1; i >= 0; i--) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        previousPageRecord = record;
                        break
                    }
                }

                me.setData({previousPageRecord});

                // the logic assumes that the tree store is sorted
                for (i=index+1; i < countPages; i++) {
                    record = store.getAt(i);

                    if (record.isLeaf && !me.recordIsHidden(record, store)) {
                        nextPageRecord = record;
                        break
                    }
                }

                me.setData({nextPageRecord});

                me.component.getReference('sidenav-container')?.toggleCls('neo-expanded', false)

                break
            }
        }
    }

    /**
     * We need to check the parent-node chain inside the tree.
     * => Any hidden parent-node results in a hidden record.
     * @param {Object} record
     * @param {Neo.data.Store} store
     * @returns {Boolean}
     */
    recordIsHidden(record, store) {
        if (record.hidden) {
            return true
        }

        if (record.parentId !== null) {
            return this.recordIsHidden(store.get(record.parentId), store)
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerStateProvider));


/***/ },

/***/ "./apps/portal/view/news/tickets/PageContainer.mjs"
/*!*********************************************************!*\
  !*** ./apps/portal/view/news/tickets/PageContainer.mjs ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/content/PageContainer.mjs */ "./apps/portal/view/shared/content/PageContainer.mjs");


/**
 * @class Portal.view.news.tickets.PageContainer
 * @extends Portal.view.shared.content.PageContainer
 */
class TicketPageContainer extends _shared_content_PageContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.PageContainer'
         * @protected
         */
        className: 'Portal.view.news.tickets.PageContainer',
        /**
         * @member {Object} layout=null
         */
        layout: null,
        /**
         * @member {Object} style={flex:1,overflowY:'auto',position:'relative'}
         */
        style: {flex: 1, overflowY: 'auto', position: 'relative'}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TicketPageContainer));


/***/ },

/***/ "./apps/portal/view/news/tickets/TimelineCanvas.mjs"
/*!**********************************************************!*\
  !*** ./apps/portal/view/news/tickets/TimelineCanvas.mjs ***!
  \**********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shared_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/Canvas.mjs */ "./apps/portal/view/shared/Canvas.mjs");


/**
 * @summary The "Coordinator" component for the Neural Timeline, bridging the App Worker and Canvas Worker.
 *
 * This component renders a transparent canvas overlay on top of the Ticket List. It is responsible for:
 * 1. **Data Bridge**: Listening to the `sections` store and passing ticket data to the `TicketCanvas` (SharedWorker).
 * 2. **Visual Alignment**: Calculating the precise DOM positions of Ticket Avatars/Badges to ensure the
 *    canvas nodes align perfectly with the HTML content.
 * 3. **Lifecycle Management**: initializing the offscreen canvas transfer and handling resize events.
 *
 * It uses the `Portal.canvas.TicketCanvas` singleton (via Remote Method Access) to drive the actual animation.
 *
 * @class Portal.view.news.tickets.TimelineCanvas
 * @extends Portal.view.shared.Canvas
 */
class TimelineCanvas extends _shared_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} delayable
     */
    static delayable = {
        ensureFinalAlignment: {
            type : 'debounce',
            timer: 300
        }
    }

    static config = {
        /**
         * @member {String} className='Portal.view.news.tickets.TimelineCanvas'
         * @protected
         */
        className: 'Portal.view.news.tickets.TimelineCanvas',
        /**
         * @member {String} importMethodName='importTicketCanvas'
         */
        importMethodName: 'importTicketCanvas',
        /**
         * @member {String} rendererClassName='Portal.canvas.TicketCanvas'
         */
        rendererClassName: 'Portal.canvas.TicketCanvas',
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'div', cls: ['neo-ticket-timeline-wrapper'], style: {width: '100%', height: '100%'}, cn: [
            {tag: 'canvas', style: {width: '100%', height: '100%'}}
        ]}
    }

    /**
     * @member {Object[]} lastRecords=null
     */
    lastRecords = null

    /**
     *
     */
    ensureFinalAlignment() {
        let me = this;

        if (me.lastRecords) {
            me.onTimelineDataLoad(me.lastRecords, true)
        }
    }

    /**
     * Lifecycle hook that runs once the `OffscreenCanvas` has been transferred to the Canvas Worker.
     *
     * This method:
     * 1. Imports the `TicketCanvas` logic into the Canvas Worker context.
     * 2. Initializes the graph in the worker via Remote Method Access (`initGraph`).
     * 3. Sets up a `ResizeObserver` to keep the canvas size synced with the DOM.
     * 4. Triggers the initial data load if store data is available.
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetOffscreenRegistered(value, oldValue) {
        let me = this;

        await super.afterSetOffscreenRegistered(value, oldValue);

        if (value) {
            // Initial load check
            let store = me.getStateProvider().getStore('sections');

            if (store.getCount() > 0) {
                me.onTimelineDataLoad(store.items)
            }
        }
    }

    /**
     * Override to return the inner canvas ID
     */
    getCanvasId() {
        let me = this;

        if (!me.canvasId) {
            me.canvasId = me.vdom.cn[0].id
        }
        return me.canvasId
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me    = this,
            store = me.getStateProvider().getStore('sections');

        store.on('load', me.onTimelineDataLoad, me)
    }

    /**
     * @param {Object} data
     */
    async onResize(data) {
        let me = this;

        // Update the canvas size in the worker
        await me.updateSize(data.contentRect);

        // If we have cached records, re-calculate node positions
        // because the container dimensions (and likely relative positions) have changed.
        if (me.lastRecords) {
            // We don't need to re-fetch rects instantly, but it's safer to do so
            // to ensure alignment with the new layout.
            await me.onTimelineDataLoad(me.lastRecords, true);

            // Debounced check to ensure the canvas is aligned after any transitions settle
            me.ensureFinalAlignment()
        }
    }

    /**
     * The core "Alignment Engine" of the timeline.
     *
     * This method synchronizes the Canvas nodes with the DOM elements (Avatars/Badges).
     *
     * **Strategy:**
     * 1. **Targeting**: It uses the `-target` ID suffix to find the specific DOM elements (Avatars) within the ticket list.
     * 2. **Measurement**: It fetches the `DOMRect` for every target to get its exact screen position.
     * 3. **Translation**: It converts these screen coordinates into Canvas-local coordinates.
     * 4. **Handoff**: It packages this geometric data (x, y, radius, color) and sends it to the
     *    `TicketCanvas` worker to update the physics simulation.
     *
     * @param {Object[]|Object} records Array of records or Store load event object {items: [...]}
     * @param {Boolean} [isResize=false]
     */
    async onTimelineDataLoad(records, isResize = false) {
        let me = this;

        // Handle Store 'load' event signature: fire('load', {items: [...]})
        if (records && !Array.isArray(records) && records.items) {
            records = records.items
        }

        if (!Array.isArray(records)) {
            // Safety check if records is still invalid
            return
        }

        if (!me.isCanvasReady) {
            return
        }

        let reset = !isResize;

        // Smart Check: If it's a store load (reset=true) BUT the ticket ID is the same,
        // it's a data refresh (e.g. comment added), so we should NOT reset the animation.
        if (reset && me.lastRecords && records[0]?.id === me.lastRecords[0]?.id) {
            reset = false
        }

        me.lastRecords = records;

        let ids = records.map(r => `${r.id}-target`),
            rects;

        try {
            // Fetch DOM rects for the MARKERS (Avatars/Badges), not the containers
            rects = await me.waitForDomRect({
                attempts: 20,
                delay   : 50,
                id      : ids
            });

            if (me.lastRecords !== records) {
                return
            }

            // Check if we got valid rects (at least one)
            let hasRects = rects && rects.some(r => r);

            if (!hasRects) {
                return
            }

            // On first valid data load (not resize), ensure size is synced
            // because content might have pushed the container height.
            if (!isResize) {
                await me.updateSize()
            }

            let canvasRect = await me.getDomRect(me.getCanvasId()),
                nodes      = [],
                startY     = 0;

            ids.forEach((targetId, index) => {
                let rect   = rects[index],
                    record = records[index];

                if (rect) {
                    // PRECISE CENTERING
                    // Now 'rect' is the actual avatar/badge.
                    let offset = rect.height / 2,
                        nodeY  = rect.y - canvasRect.y + offset,
                        nodeX  = rect.x - canvasRect.x + (rect.width / 2),
                        // Distinct padding for Orbit effect
                        // Avatars (~40px) get more breathing room than Badges (~28px)
                        padding = rect.height > 32 ? 6 : 3;

                    nodes.push({
                        color : record.color, // Pass Hex Color (e.g. #ff0000)
                        id    : record.id,
                        radius: offset + padding,
                        y     : nodeY,
                        x     : nodeX
                    });

                    // Set the startY of the line to the first node
                    if (index === 0) {
                        startY = nodeY
                    }
                }
            });

            await me.renderer.updateGraphData({nodes, reset, startY})
        } catch (e) {
            console.error('TimelineCanvas update failed', e)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TimelineCanvas));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfcG9ydGFsX3ZpZXdfbmV3c190aWNrZXRzX01haW5Db250YWluZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQUs7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsdUJBQXVCLFNBQVM7QUFDaEMsdUJBQXVCLFNBQVM7QUFDaEMsdUJBQXVCLFNBQVM7QUFDaEMseUJBQXlCO0FBQ3pCO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QyxzQ0FBc0MsR0FBRyxrQ0FBa0MsTUFBTTtBQUNqRjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkRVOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBSztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsMkJBQTJCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ087O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJE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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUIscURBQXFEO0FBQ3JGLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQyxLQUFLO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYiwrQ0FBK0MscUJBQXFCO0FBQ3BFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSw4QkFBOEIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9tb2RlbC9UaWNrZXQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9tb2RlbC9UaWNrZXRMYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL21vZGVsL1RpY2tldFRpbWVsaW5lU2VjdGlvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3N0b3JlL1RpY2tldExhYmVscy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3N0b3JlL1RpY2tldFRpbWVsaW5lU2VjdGlvbnMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC9zdG9yZS9UaWNrZXRzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvQ2FudmFzV3JhcHBlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3BvcnRhbC92aWV3L25ld3MvdGlja2V0cy9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL01haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9wb3J0YWwvdmlldy9uZXdzL3RpY2tldHMvUGFnZUNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvcG9ydGFsL3ZpZXcvbmV3cy90aWNrZXRzL1RpbWVsaW5lQ2FudmFzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLm1vZGVsLlRpY2tldFxuICogQGV4dGVuZHMgTmVvLmRhdGEuTW9kZWxcbiAqL1xuY2xhc3MgVGlja2V0IGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLm1vZGVsLlRpY2tldCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLm1vZGVsLlRpY2tldCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZHM6IFt7XG4gICAgICAgICAgICBuYW1lICAgICAgICA6ICdjb2xsYXBzZWQnLFxuICAgICAgICAgICAgdHlwZSAgICAgICAgOiAnQm9vbGVhbicsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWUgICAgICAgIDogJ2lzTGVhZicsXG4gICAgICAgICAgICB0eXBlICAgICAgICA6ICdCb29sZWFuJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lICAgICAgICA6ICdwYXJlbnRJZCcsXG4gICAgICAgICAgICB0eXBlICAgICAgICA6ICdTdHJpbmcnLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdwYXRoJywgLy8gXCJyZXNvdXJjZXMvY29udGVudC9pc3N1ZXMvaXNzdWUtMTIzNC5tZFwiXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAndGl0bGUnLCAvLyBcIkZpeCBlbHVzaXZlIGJ1ZyBpbiBHcmlkXCJcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGVkIGZpZWxkIGZvciBUcmVlTGlzdCBkaXNwbGF5XG4gICAgICAgICAgICBuYW1lOiAndHJlZU5vZGVOYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGRhdGEuaWRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGF0YS5pc0xlYWZcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgZGF0YS50aXRsZVxuICAgICAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FsY3VsYXRlKHtpZCwgaXNMZWFmLCB0aXRsZX0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMZWFmID8gYDxiPiR7aWR9PC9iPiA8c3BhbiBjbGFzcz1cInRpY2tldC10aXRsZVwiPiR7dGl0bGV9PC9zcGFuPmAgOiBpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0KTtcbiIsImltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwubW9kZWwuVGlja2V0TGFiZWxcbiAqIEBleHRlbmRzIE5lby5kYXRhLk1vZGVsXG4gKi9cbmNsYXNzIFRpY2tldExhYmVsIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLm1vZGVsLlRpY2tldExhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwubW9kZWwuVGlja2V0TGFiZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGZpZWxkc1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZHM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnY29sb3InLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICd0ZXh0Q29sb3InLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldExhYmVsKTtcbiIsImltcG9ydCBDb250ZW50U2VjdGlvbiBmcm9tICcuL0NvbnRlbnRTZWN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC5tb2RlbC5UaWNrZXRUaW1lbGluZVNlY3Rpb25cbiAqIEBleHRlbmRzIFBvcnRhbC5tb2RlbC5Db250ZW50U2VjdGlvblxuICovXG5jbGFzcyBUaWNrZXRUaW1lbGluZVNlY3Rpb24gZXh0ZW5kcyBDb250ZW50U2VjdGlvbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwubW9kZWwuVGlja2V0VGltZWxpbmVTZWN0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwubW9kZWwuVGlja2V0VGltZWxpbmVTZWN0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBmaWVsZHNcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgIG5hbWU6ICdjb2xvcicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaWNvbicsXG4gICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnaW1hZ2UnLFxuICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ3NvdXJjZUlkJyxcbiAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRUaW1lbGluZVNlY3Rpb24pO1xuIiwiaW1wb3J0IFRpY2tldExhYmVsIGZyb20gJy4uL21vZGVsL1RpY2tldExhYmVsLm1qcyc7XG5pbXBvcnQgU3RvcmUgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnN0b3JlLlRpY2tldExhYmVsc1xuICogQGV4dGVuZHMgTmVvLmRhdGEuU3RvcmVcbiAqL1xuY2xhc3MgVGlja2V0TGFiZWxzIGV4dGVuZHMgU3RvcmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnN0b3JlLlRpY2tldExhYmVscydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnN0b3JlLlRpY2tldExhYmVscycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGtleVByb3BlcnR5PSduYW1lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBrZXlQcm9wZXJ0eTogJ25hbWUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsPVRpY2tldExhYmVsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBUaWNrZXRMYWJlbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdXJsPScuLi8uLi9hcHBzL3BvcnRhbC9yZXNvdXJjZXMvZGF0YS9sYWJlbHMuanNvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdXJsOiAnLi4vLi4vYXBwcy9wb3J0YWwvcmVzb3VyY2VzL2RhdGEvbGFiZWxzLmpzb24nXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRMYWJlbHMpO1xuIiwiaW1wb3J0IENvbnRlbnRTZWN0aW9ucyAgICAgIGZyb20gJy4vQ29udGVudFNlY3Rpb25zLm1qcyc7XG5pbXBvcnQgVGlja2V0VGltZWxpbmVTZWN0aW9uIGZyb20gJy4uL21vZGVsL1RpY2tldFRpbWVsaW5lU2VjdGlvbi5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwuc3RvcmUuVGlja2V0VGltZWxpbmVTZWN0aW9uc1xuICogQGV4dGVuZHMgUG9ydGFsLnN0b3JlLkNvbnRlbnRTZWN0aW9uc1xuICovXG5jbGFzcyBUaWNrZXRUaW1lbGluZVNlY3Rpb25zIGV4dGVuZHMgQ29udGVudFNlY3Rpb25zIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC5zdG9yZS5UaWNrZXRUaW1lbGluZVNlY3Rpb25zJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwuc3RvcmUuVGlja2V0VGltZWxpbmVTZWN0aW9ucycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9VGlja2V0VGltZWxpbmVTZWN0aW9uXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IFRpY2tldFRpbWVsaW5lU2VjdGlvblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGlja2V0VGltZWxpbmVTZWN0aW9ucyk7XG4iLCJpbXBvcnQgU3RvcmUgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcbmltcG9ydCBUaWNrZXRNb2RlbCBmcm9tICcuLi9tb2RlbC9UaWNrZXQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnN0b3JlLlRpY2tldHNcbiAqIEBleHRlbmRzIE5lby5kYXRhLlN0b3JlXG4gKi9cbmNsYXNzIFRpY2tldHMgZXh0ZW5kcyBTdG9yZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwuc3RvcmUuVGlja2V0cydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnN0b3JlLlRpY2tldHMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsPVRpY2tldE1vZGVsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWw6IFRpY2tldE1vZGVsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB1cmw9Jy4uLy4uL2FwcHMvcG9ydGFsL3Jlc291cmNlcy9kYXRhL3RpY2tldHMuanNvbidcbiAgICAgICAgICovXG4gICAgICAgIHVybDogJy4uLy4uL2FwcHMvcG9ydGFsL3Jlc291cmNlcy9kYXRhL3RpY2tldHMuanNvbidcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpY2tldHMpO1xuIiwiaW1wb3J0IENvbnRhaW5lciAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgQ29udGVudENvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IFRpbWVsaW5lQ2FudmFzICAgZnJvbSAnLi9UaW1lbGluZUNhbnZhcy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuQ2FudmFzV3JhcHBlclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIENhbnZhc1dyYXBwZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLkNhbnZhc1dyYXBwZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5DYW52YXNXcmFwcGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydwb3J0YWwtY2FudmFzLXdyYXBwZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ3BvcnRhbC1jYW52YXMtd3JhcHBlciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbnRlbnRDb21wb25lbnQ9Q29udGVudENvbXBvbmVudFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudENvbXBvbmVudDogQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3R5bGU9e292ZXJmbG93Oid2aXNpYmxlJyxwYWRkaW5nQm90dG9tOicyMHB4Jyxwb3NpdGlvbjoncmVsYXRpdmUnfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IHtvdmVyZmxvdzogJ3Zpc2libGUnLCBwYWRkaW5nQm90dG9tOiAnMjBweCcsIHBvc2l0aW9uOiAncmVsYXRpdmUnfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBjb25maWcuaXRlbXMgPSBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBUaW1lbGluZUNhbnZhcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ3RpbWVsaW5lLWNhbnZhcycsXG4gICAgICAgICAgICBzdHlsZSA6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiAgICAgOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgbGVmdCAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgIDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIHpJbmRleCAgICAgICA6IDIsXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZTogY29uZmlnLmNvbnRlbnRDb21wb25lbnQgfHwgbWUuY29udGVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHN0eWxlIDoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIHpJbmRleCAgOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlU3VtbWFyeTogbWUub25Ub2dnbGVTdW1tYXJ5LFxuICAgICAgICAgICAgICAgIHNjb3BlICAgICAgICA6IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dO1xuXG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Ub2dnbGVTdW1tYXJ5KCkge1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5nZXRSZWZlcmVuY2UoJ3RpbWVsaW5lLWNhbnZhcycpO1xuXG4gICAgICAgIGlmIChjYW52YXM/Lmxhc3RSZWNvcmRzKSB7XG4gICAgICAgICAgICBjYW52YXMub25UaW1lbGluZURhdGFMb2FkKGNhbnZhcy5sYXN0UmVjb3JkcywgdHJ1ZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FudmFzV3JhcHBlcik7XG4iLCJpbXBvcnQgQ29udGVudENvbXBvbmVudCBmcm9tICcuLi8uLi9zaGFyZWQvY29udGVudC9Db21wb25lbnQubWpzJztcbmltcG9ydCB7bWFya2VkfSAgICAgICAgIGZyb20gJy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanMnO1xuXG5jb25zdFxuICAgIHJlZ2V4RnJvbnRNYXR0ZXIgICA9IC9eLS0tXFxuKFtcXHNcXFNdKj8pXFxuLS0tXFxuLyxcbiAgICByZWdleEgxICAgICAgICAgICAgPSAvKDxoMVtePl0qPi4qPzxcXC9oMT4pLyxcbiAgICByZWdleFRpY2tldExpbmsgICAgPSAvKFxcZHs0LH0pLyxcbiAgICByZWdleFRpbWVsaW5lICAgICAgPSAvIyMgVGltZWxpbmVcXHMqXFxuKFtcXHNcXFNdKikvLFxuICAgIHJlZ2V4VGltZWxpbmVFdmVudCA9IC9eLSAoW1xcZFRaOi4tXSspIEAoXFx3KykgKC4qKSQvLFxuICAgIHJlZ2V4Q29tbWl0ICAgICAgICA9IC9cXGIoWzAtOWEtZl17Nyw0MH0pXFxiL2c7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIFwiTWFya2Rvd24gVHJhbnNmb3JtZXJcIiBmb3IgR2l0SHViIFRpY2tldHMuXG4gKlxuICogVGhpcyBjb21wb25lbnQgZXh0ZW5kcyB0aGUgc3RhbmRhcmQgQ29udGVudENvbXBvbmVudCB0byBwcm92aWRlIHNwZWNpYWxpemVkIHJlbmRlcmluZyBmb3IgR2l0SHViIElzc3Vlcy5cbiAqIEl0cyBwcmltYXJ5IHJlc3BvbnNpYmlsaXR5IGlzIHRvIHBhcnNlIHRoZSByYXcgTWFya2Rvd24gY29udGVudCAod2hpY2ggaW5jbHVkZXMgY3VzdG9tIEZyb250bWF0dGVyIGFuZFxuICogYSBwcmUtZ2VuZXJhdGVkIFRpbWVsaW5lIHNlY3Rpb24pIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIHJpY2gsIGludGVyYWN0aXZlIEhUTUwgc3RydWN0dXJlLlxuICpcbiAqICoqS2V5IFJlc3BvbnNpYmlsaXRpZXM6KipcbiAqIDEuICoqUGFyc2luZyBQaXBlbGluZSoqOiBFeHRyYWN0cyBGcm9udG1hdHRlciwgQm9keSwgYW5kIHRoZSBjdXN0b20gXCJUaW1lbGluZVwiIHNlY3Rpb24gZnJvbSB0aGUgcmF3IE1hcmtkb3duLlxuICogMi4gKipSaWNoIFJlbmRlcmluZyoqOiBHZW5lcmF0ZXMgSFRNTCBmb3IgU3RhdHVzIEJhZGdlcywgTGFiZWxzLCBDb21taXQgTGlua3MsIGFuZCBVc2VyIE1lbnRpb25zLlxuICogMy4gKipEYXRhIEV4dHJhY3Rpb24qKjogQXMgYSBzaWRlIGVmZmVjdCBvZiByZW5kZXJpbmcsIGl0IGV4dHJhY3RzIHN0cnVjdHVyZWQgZGF0YSAoYG1lLnRpbWVsaW5lRGF0YWApXG4gKiAgICByZXByZXNlbnRpbmcgZXZlcnkgdGltZWxpbmUgZXZlbnQgKGNvbW1lbnQsIGxhYmVsIGNoYW5nZSwgY2xvc2UsIGV0Yy4pLiBUaGlzIGRhdGEgaXMgdGhlblxuICogICAgcHVzaGVkIHRvIHRoZSBgc2VjdGlvbnNgIHN0b3JlIHRvIGRyaXZlIHRoZSBgVGltZWxpbmVDYW52YXNgIHZpc3VhbGl6YXRpb24uXG4gKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5Db21wb25lbnRcbiAqIEBleHRlbmRzIFBvcnRhbC52aWV3LnNoYXJlZC5jb250ZW50LkNvbXBvbmVudFxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBDb250ZW50Q29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ3BvcnRhbC1uZXdzLXRpY2tldHMtY29tcG9uZW50J11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWydwb3J0YWwtbmV3cy10aWNrZXRzLWNvbXBvbmVudCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjb21taXRzVXJsPSdodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9jb21taXQvJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29tbWl0c1VybDogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2NvbW1pdC8nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkb21MaXN0ZW5lcnNcbiAgICAgICAgICovXG4gICAgICAgIGRvbUxpc3RlbmVyczoge1xuICAgICAgICAgICAgcmVzaXplOiAnb25SZXNpemUnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlcG9Vc2VyVXJsPSdodHRwczovL2dpdGh1Yi5jb20vJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVwb1VzZXJVcmw6ICdodHRwczovL2dpdGh1Yi5jb20vJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVwZGF0ZVNlY3Rpb25zU3RvcmU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVNlY3Rpb25zU3RvcmU6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSAjZGF0ZVRpbWVGb3JtYXRIaXN0b3J5PW51bGxcbiAgICAgKi9cbiAgICAjZGF0ZVRpbWVGb3JtYXRIaXN0b3J5ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gI2RhdGVUaW1lRm9ybWF0VG9kYXk9bnVsbFxuICAgICAqL1xuICAgICNkYXRlVGltZUZvcm1hdFRvZGF5ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyeSBzdG9yYWdlIGZvciB0aGUgc3RydWN0dXJlZCB0aW1lbGluZSBkYXRhIGV4dHJhY3RlZCBkdXJpbmcgdGhlIHBhcnNpbmcgcGhhc2UuXG4gICAgICogVGhpcyBhcnJheSBpcyBwb3B1bGF0ZWQgYnkgYHJlbmRlclRpbWVsaW5lYCBhbmQgYG1vZGlmeU1hcmtkb3duYCBhbmQgdGhlbiBhc3NpZ25lZFxuICAgICAqIHRvIHRoZSBgc2VjdGlvbnNgIHN0b3JlIHRvIGRyaXZlIHRoZSBDYW52YXMgdmlzdWFsaXphdGlvbi5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gdGltZWxpbmVEYXRhPW51bGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRpbWVsaW5lRGF0YSA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5zZXREYXRhKCdjb250ZW50Q29tcG9uZW50SWQnLCB0aGlzLmlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpc29TdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1hdFRpbWVzdGFtcChpc29TdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpc29TdHJpbmcpIHJldHVybiAnJztcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRlICAgID0gbmV3IERhdGUoaXNvU3RyaW5nKSxcbiAgICAgICAgICAgIG5vdyAgICAgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgaXNUb2RheSA9IGRhdGUudG9EYXRlU3RyaW5nKCkgPT09IG5vdy50b0RhdGVTdHJpbmcoKTtcblxuICAgICAgICBpZiAoaXNUb2RheSkge1xuICAgICAgICAgICAgaWYgKCFtZS4jZGF0ZVRpbWVGb3JtYXRUb2RheSkge1xuICAgICAgICAgICAgICAgIG1lLiNkYXRlVGltZUZvcm1hdFRvZGF5ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2RlZmF1bHQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXIgIDogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGU6ICdudW1lcmljJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtZS4jZGF0ZVRpbWVGb3JtYXRUb2RheS5mb3JtYXQoZGF0ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUuI2RhdGVUaW1lRm9ybWF0SGlzdG9yeSkge1xuICAgICAgICAgICAgbWUuI2RhdGVUaW1lRm9ybWF0SGlzdG9yeSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdkZWZhdWx0Jywge1xuICAgICAgICAgICAgICAgIGRheSAgIDogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIGhvdXIgIDogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIG1vbnRoIDogJ3Nob3J0JyxcbiAgICAgICAgICAgICAgICB5ZWFyICA6ICdudW1lcmljJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS4jZGF0ZVRpbWVGb3JtYXRIaXN0b3J5LmZvcm1hdChkYXRlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmcm9udE1hdHRlclRvSHRtbChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGh0bWwgPSAnPHRhYmxlIGNsYXNzPVwibmVvLWZyb250bWF0dGVyLXRhYmxlXCI+PHRib2R5Pic7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyZWRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3N1Yklzc3VlcycgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gdmFsdWUubWFwKGlzc3VlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwibmVvLXN1Yi1pc3N1ZVwiPiR7aXNzdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJlZ2V4VGlja2V0TGluaywgJzxhIGhyZWY9XCIjL25ld3MvdGlja2V0cy8kMVwiPiQxPC9hPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnW3hdJywgJzxpIGNsYXNzPVwiZmEtc29saWQgZmEtY2lyY2xlLWNoZWNrXCI+PC9pPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWyBdJywgJzxpIGNsYXNzPVwiZmEtcmVndWxhciBmYS1jaXJjbGVcIj48L2k+Jyl9PC9kaXY+YFxuICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2F1dGhvcicpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gYDxhIGhyZWY9XCIke21lLnJlcG9Vc2VyVXJsfSR7dmFsdWV9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+JHt2YWx1ZX08L2E+YFxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdjcmVhdGVkQXQnIHx8IGtleSA9PT0gJ2Nsb3NlZEF0JyB8fCBrZXkgPT09ICd1cGRhdGVkQXQnKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRWYWx1ZSA9IG1lLmZvcm1hdFRpbWVzdGFtcCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbGFiZWxzJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSBtZS5nZXRCYWRnZXNIdG1sKHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzdGF0ZScpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlID0gbWUuZ2V0U3RhdGVCYWRnZUh0bWwodmFsdWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVmFsdWUgPSBtZS5mb3JtYXRGcm9udE1hdHRlclZhbHVlKHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBodG1sICs9IGA8dHI+PHRkPiR7a2V5fTwvdGQ+PHRkPiR7cmVuZGVyZWRWYWx1ZX08L3RkPjwvdHI+YFxuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9ICc8L3Rib2R5PjwvdGFibGU+JztcblxuICAgICAgICBpZiAobWUudXNlRnJvbnRtYXR0ZXJEZXRhaWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxkZXRhaWxzIGlkPVwibmVvLXRpY2tldC1zdW1tYXJ5LWRldGFpbHMtJHttZS5pZH1cIj48c3VtbWFyeT5Gcm9udG1hdHRlcjwvc3VtbWFyeT4ke2h0bWx9PC9kZXRhaWxzPmBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gbGFiZWxzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCYWRnZXNIdG1sKGxhYmVscykge1xuICAgICAgICBpZiAoIWxhYmVscyB8fCBsYWJlbHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYmFkZ2VzSHRtbCA9ICc8ZGl2IGNsYXNzPVwibmVvLXRpY2tldC1sYWJlbHNcIj4nO1xuXG4gICAgICAgIGxhYmVscy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gbWUuZ2V0TGFiZWxCYWRnZUh0bWwobGFiZWwpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJhZGdlc0h0bWwgKz0gJzwvZGl2Pic7XG5cbiAgICAgICAgcmV0dXJuIGJhZGdlc0h0bWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgZG9GZXRjaENvbnRlbnQocmVjb3JkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIGNvbnRlbnQsIGRhdGEsIHBhdGg7XG5cbiAgICAgICAgcGF0aCA9IG1lLmdldENvbnRlbnRQYXRoKHJlY29yZCk7XG5cbiAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgJiYgcGF0aCkge1xuICAgICAgICAgICAgZGF0YSAgICA9IGF3YWl0IGZldGNoKHBhdGgpO1xuICAgICAgICAgICAgY29udGVudCA9IGF3YWl0IGRhdGEudGV4dCgpO1xuXG4gICAgICAgICAgICBtZS52YWx1ZSA9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIG1lLnRvZ2dsZUNscygnbGFiJywgcmVjb3JkLm5hbWU/LnN0YXJ0c1dpdGgoJ0xhYjonKSk7XG5cbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoe1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZSAgIDogWycubmVvLXRpbWVsaW5lLWl0ZW1bZGF0YS1yZWNvcmQtaWRdJ10sXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlY29yZC5wYXRoXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldENvbnRlbnRQYXRoKHtwYXRofSkge1xuICAgICAgICByZXR1cm4gcGF0aCA/IE5lby5jb25maWcuYmFzZVBhdGggKyBwYXRoIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TGFiZWxCYWRnZUh0bWwobGFiZWwpIHtcbiAgICAgICAgbGV0IHN0b3JlICA9IHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdsYWJlbHMnKSxcbiAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldChsYWJlbCk7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGA8c3BhbiBjbGFzcz1cIm5lby1iYWRnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjoke3JlY29yZC5jb2xvcn07Y29sb3I6JHtyZWNvcmQudGV4dENvbG9yfVwiPiR7bGFiZWx9PC9zcGFuPmBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCJuZW8tYmFkZ2VcIj4ke2xhYmVsfTwvc3Bhbj5gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdGF0ZUJhZGdlSHRtbChzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0YXRlKSByZXR1cm4gJyc7XG5cbiAgICAgICAgbGV0IGNscyAgPSAnbmVvLWJhZGdlIG5lby1zdGF0ZS1iYWRnZScsXG4gICAgICAgICAgICBpY29uID0gJ2ZhLWNpcmNsZS1kb3QnO1xuXG4gICAgICAgIGlmIChzdGF0ZS50b1VwcGVyQ2FzZSgpID09PSAnQ0xPU0VEJykge1xuICAgICAgICAgICAgY2xzICArPSAnIG5lby1zdGF0ZS1jbG9zZWQnO1xuICAgICAgICAgICAgaWNvbiAgPSAnZmEtY2lyY2xlLWNoZWNrJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xzICs9ICcgbmVvLXN0YXRlLW9wZW4nXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwiJHtjbHN9XCI+PGkgY2xhc3M9XCJmYS1yZWd1bGFyICR7aWNvbn1cIj48L2k+JHtOZW8uY2FwaXRhbGl6ZShzdGF0ZS50b0xvd2VyQ2FzZSgpKX08L3NwYW4+YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBNYWluIFBhcnNpbmcgUGlwZWxpbmUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnRlcmNlcHRzIHRoZSByYXcgbWFya2Rvd24gY29udGVudCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgYW5kIHBlcmZvcm1zIGEgbXVsdGktcGFzcyB0cmFuc2Zvcm1hdGlvbjpcbiAgICAgKiAxLiAqKkV4dHJhY3QgVGltZWxpbmUqKjogUHVsbHMgb3V0IHRoZSByYXcgYCMjIFRpbWVsaW5lYCBzZWN0aW9uIHRvIHByb2Nlc3MgaXQgc2VwYXJhdGVseS5cbiAgICAgKiAyLiAqKlByb2Nlc3MgRnJvbnRtYXR0ZXIqKjogRXh0cmFjdHMgbWV0YWRhdGEgKGxhYmVscywgc3RhdGUsIGF1dGhvcikgYW5kIHJlbW92ZXMgdGhlIFlBTUwgYmxvY2suXG4gICAgICogMy4gKipSZW5kZXIgQm9keSoqOiBVc2VzIHRoZSBzdXBlcmNsYXNzIChtYXJrZWQuanMpIHRvIGNvbnZlcnQgdGhlIG1haW4gaXNzdWUgYm9keSB0byBIVE1MLlxuICAgICAqIDQuICoqSW5qZWN0IFRpdGxlIElEcyoqOiBBZGRzIElEcyB0byBIMSB0YWdzIGZvciBuYXZpZ2F0aW9uLlxuICAgICAqIDUuICoqR2VuZXJhdGUgQmFkZ2VzKio6IENyZWF0ZXMgSFRNTCBmb3IgU3RhdHVzL0xhYmVsIGJhZGdlcyBiYXNlZCBvbiBleHRyYWN0ZWQgbWV0YWRhdGEuXG4gICAgICogNi4gKipXcmFwIEJvZHkqKjogV3JhcHMgdGhlIG1haW4gaXNzdWUgYm9keSBpbiBhIGB0aW1lbGluZS1pdGVtYCBzdHJ1Y3R1cmUgc28gaXQgYXBwZWFycyBhcyB0aGUgZmlyc3QgaXRlbS5cbiAgICAgKiA3LiAqKlJlLUFzc2VtYmxlKio6IENvbmNhdGVuYXRlcyBGcm9udG1hdHRlciArIFRpdGxlICsgVGltZWxpbmUgKHdpdGggQm9keSBpbmplY3RlZCkgaW50byB0aGUgZmluYWwgSFRNTC5cbiAgICAgKlxuICAgICAqICoqU2lkZSBFZmZlY3QqKjogUG9wdWxhdGVzIGBtZS50aW1lbGluZURhdGFgIGFuZCB1cGRhdGVzIHRoZSBgc2VjdGlvbnNgIHN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIG1vZGlmeU1hcmtkb3duKGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50SWR9ICAgPSBtZS5yZWNvcmQsXG4gICAgICAgICAgICBhdXRob3IgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgY3JlYXRlZEF0ICAgID0gbnVsbCxcbiAgICAgICAgICAgIGxhYmVscyAgICAgICA9IFtdLFxuICAgICAgICAgICAgc3RhdGUgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIG1hdGNoICAgICAgICA9IGNvbnRlbnQubWF0Y2gocmVnZXhGcm9udE1hdHRlciksXG4gICAgICAgICAgICB0aW1lbGluZUh0bWwgPSAnJyxcbiAgICAgICAgICAgIGJhZGdlc0h0bWwgICA9ICcnO1xuXG4gICAgICAgIG1lLnRpbWVsaW5lRGF0YSA9IFtdO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBtZS5wYXJzZUZyb250TWF0dGVyKG1hdGNoWzFdKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuYXV0aG9yKSAgICB7YXV0aG9yICAgID0gZGF0YS5hdXRob3J9XG4gICAgICAgICAgICBpZiAoZGF0YS5jcmVhdGVkQXQpIHtjcmVhdGVkQXQgPSBtZS5mb3JtYXRUaW1lc3RhbXAoZGF0YS5jcmVhdGVkQXQpfVxuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzKSAgICB7bGFiZWxzICAgID0gZGF0YS5sYWJlbHN9XG4gICAgICAgICAgICBpZiAoZGF0YS5zdGF0ZSkgICAgIHtzdGF0ZSAgICAgPSBkYXRhLnN0YXRlfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gRXh0cmFjdCBhbmQgcHJvY2VzcyB0aW1lbGluZSBmcm9tIFJBVyBtYXJrZG93blxuICAgICAgICBsZXQgdGltZWxpbmVNYXRjaCA9IGNvbnRlbnQubWF0Y2gocmVnZXhUaW1lbGluZSk7XG4gICAgICAgIGlmICh0aW1lbGluZU1hdGNoKSB7XG4gICAgICAgICAgICB0aW1lbGluZUh0bWwgPSBtZS5yZW5kZXJUaW1lbGluZSh0aW1lbGluZU1hdGNoWzFdKTtcbiAgICAgICAgICAgIGNvbnRlbnQgICAgICA9IGNvbnRlbnQucmVwbGFjZShyZWdleFRpbWVsaW5lLCAnJyk7IC8vIFJlbW92ZSByYXcgdGltZWxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIFJlbmRlciBGcm9udG1hdHRlciBNYW51YWxseSAmIFN0cmlwIGl0XG4gICAgICAgIC8vIFdlIHdhbnQgaXQgYXQgdGhlIHZlcnkgdG9wLCBvdXRzaWRlIHRoZSBib2R5IGJ1YmJsZS5cbiAgICAgICAgbGV0IGZyb250TWF0dGVySHRtbCA9ICcnO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBkYXRhICAgICAgICA9IG1lLnBhcnNlRnJvbnRNYXR0ZXIobWF0Y2hbMV0pO1xuICAgICAgICAgICAgZnJvbnRNYXR0ZXJIdG1sID0gbWUuZnJvbnRNYXR0ZXJUb0h0bWwoZGF0YSk7XG4gICAgICAgICAgICBjb250ZW50ICAgICAgICAgPSBjb250ZW50LnJlcGxhY2UocmVnZXhGcm9udE1hdHRlciwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQ29udmVydCBCb2R5ICsgVGl0bGUgdG8gSFRNTCB1c2luZyBzdXBlclxuICAgICAgICBsZXQgZnVsbEh0bWwgPSBzdXBlci5tb2RpZnlNYXJrZG93bihjb250ZW50KTtcblxuICAgICAgICAvLyA0LiBFeHRyYWN0IEgxIFRpdGxlIGZyb20gdGhlIGdlbmVyYXRlZCBIVE1MXG4gICAgICAgIGxldCB0aXRsZUh0bWwgPSAnJztcbiAgICAgICAgZnVsbEh0bWwgICAgICA9IGZ1bGxIdG1sLnJlcGxhY2UocmVnZXhIMSwgKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICAvLyBJbmplY3QgSUQgaW50byBIMSB0YWdcbiAgICAgICAgICAgIHRpdGxlSHRtbCA9IG1hdGNoLnJlcGxhY2UoJzxoMScsIGA8aDEgaWQ9XCJ0aWNrZXQtdGl0bGUtJHttZS5pZH1cImApO1xuICAgICAgICAgICAgcmV0dXJuICcnOyAvLyBSZW1vdmUgdGl0bGUgZnJvbSBib2R5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIDUuIENvbnN0cnVjdCBCYWRnZXNcbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAwIHx8IHN0YXRlIHx8IChwYXJlbnRJZCAmJiBwYXJlbnRJZCAhPT0gJ0JhY2tsb2cnKSkge1xuICAgICAgICAgICAgYmFkZ2VzSHRtbCA9ICc8ZGl2IGNsYXNzPVwibmVvLXRpY2tldC1sYWJlbHNcIj4nO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBiYWRnZXNIdG1sICs9IG1lLmdldFN0YXRlQmFkZ2VIdG1sKHN0YXRlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50SWQgJiYgcGFyZW50SWQgIT09ICdCYWNrbG9nJykge1xuICAgICAgICAgICAgICAgIGJhZGdlc0h0bWwgKz0gYFxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5lby1iYWRnZSBuZW8tcmVsZWFzZS1iYWRnZVwiIGhyZWY9XCIjL25ld3MvcmVsZWFzZXMvJHtwYXJlbnRJZC5zdWJzdHJpbmcoMSl9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhLXNvbGlkIGZhLWNvZGUtYnJhbmNoXCI+PC9pPiAke3BhcmVudElkfVxuICAgICAgICAgICAgICAgICAgICA8L2E+YFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RvcmUgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ2xhYmVscycpLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmQ7XG5cbiAgICAgICAgICAgICAgICBsYWJlbHMuZm9yRWFjaChsYWJlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHN0b3JlLmdldChsYWJlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFkZ2VzSHRtbCArPSBgPHNwYW4gY2xhc3M9XCJuZW8tYmFkZ2VcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JHtyZWNvcmQuY29sb3J9O2NvbG9yOiR7cmVjb3JkLnRleHRDb2xvcn1cIj4ke2xhYmVsfTwvc3Bhbj5gXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWRnZXNIdG1sICs9IGA8c3BhbiBjbGFzcz1cIm5lby1iYWRnZVwiPiR7bGFiZWx9PC9zcGFuPmBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYWRnZXNIdG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICAgICAgdGl0bGVIdG1sICArPSBiYWRnZXNIdG1sO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNi4gV3JhcCB0aGUgcmVtYWluaW5nIEhUTUwgKEJvZHkpIGluIHRoZSBUaW1lbGluZSBJdGVtIHN0cnVjdHVyZVxuICAgICAgICBsZXQgYm9keUlkID0gYHRpbWVsaW5lLSR7bWUucmVjb3JkLmlkfS0wYDtcblxuICAgICAgICBtZS50aW1lbGluZURhdGEudW5zaGlmdCh7XG4gICAgICAgICAgICBpZCAgIDogYm9keUlkLFxuICAgICAgICAgICAgaW1hZ2U6IG1lLnJlcG9Vc2VyVXJsICsgYXV0aG9yICsgJy5wbmcnLFxuICAgICAgICAgICAgbmFtZSA6ICdEZXNjcmlwdGlvbicsXG4gICAgICAgICAgICB0YWcgIDogJ2JvZHknXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBib2R5SXRlbUh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGlkPVwiJHtib2R5SWR9XCIgY2xhc3M9XCJuZW8tdGltZWxpbmUtaXRlbSBjb21tZW50IGJvZHktaXRlbVwiIGRhdGEtcmVjb3JkLWlkPVwiJHtib2R5SWR9XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7Ym9keUlkfS10YXJnZXRcIiBjbGFzcz1cIm5lby10aW1lbGluZS1hdmF0YXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIke21lLnJlcG9Vc2VyVXJsfSR7YXV0aG9yfS5wbmdcIiBhbHQ9XCIke2F1dGhvcn1cIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmVvLXRpbWVsaW5lLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwibmVvLXRpbWVsaW5lLXVzZXJcIiBocmVmPVwiJHttZS5yZXBvVXNlclVybH0ke2F1dGhvcn1cIiB0YXJnZXQ9XCJfYmxhbmtcIj4ke2F1dGhvcn08L2E+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm5lby10aW1lbGluZS1kYXRlXCI+Y29tbWVudGVkIG9uICR7Y3JlYXRlZEF0fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtYm9keVwiPiR7ZnVsbEh0bWx9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5gO1xuXG4gICAgICAgIC8vIDcuIEluamVjdCBCb2R5IEl0ZW0gYXQgdGhlIHN0YXJ0IG9mIHRoZSBUaW1lbGluZVxuICAgICAgICBsZXQgdGltZWxpbmVJZCA9IGB0aWNrZXQtdGltZWxpbmUtJHttZS5pZH1gO1xuXG4gICAgICAgIGlmICh0aW1lbGluZUh0bWwpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lSHRtbCA9IHRpbWVsaW5lSHRtbC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwibmVvLXRpY2tldC10aW1lbGluZVwiPicsXG4gICAgICAgICAgICAgICAgYDxkaXYgaWQ9XCIke3RpbWVsaW5lSWR9XCIgY2xhc3M9XCJuZW8tdGlja2V0LXRpbWVsaW5lXCI+YCArIGJvZHlJdGVtSHRtbFxuICAgICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZWxpbmVIdG1sID0gYDxkaXYgaWQ9XCIke3RpbWVsaW5lSWR9XCIgY2xhc3M9XCJuZW8tdGlja2V0LXRpbWVsaW5lXCI+JHtib2R5SXRlbUh0bWx9PC9kaXY+YFxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdzZWN0aW9ucycpLmRhdGEgPSBtZS50aW1lbGluZURhdGE7XG4gICAgICAgIG1lLnRpbWVsaW5lRGF0YSA9IG51bGw7XG5cbiAgICAgICAgLy8gUmV0dXJuOiBGcm9udG1hdHRlciArIFRpdGxlICsgVGltZWxpbmVcbiAgICAgICAgcmV0dXJuIGZyb250TWF0dGVySHRtbCArIHRpdGxlSHRtbCArIHRpbWVsaW5lSHRtbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25SZXNpemUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RvZ2dsZVN1bW1hcnknKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgY3VzdG9tIFwiVGltZWxpbmVcIiBtYXJrZG93biBzZWN0aW9uLlxuICAgICAqXG4gICAgICogRXhwZWN0cyBhIGxpbmUtYmFzZWQgZm9ybWF0IGdlbmVyYXRlZCBieSB0aGUgYnVpbGQgcHJvY2VzczpcbiAgICAgKiAtIEV2ZW50czogYC0gWVlZWS1NTS1ERFRISDptbTpzcyBAdXNlciBhY3Rpb24gdGV4dC4uLmBcbiAgICAgKiAtIENvbW1lbnRzOiBgIyMjIEB1c2VyIC0gWVlZWS1NTS1ERFRISDptbTpzc2AgZm9sbG93ZWQgYnkgY29tbWVudCBib2R5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgdGhlc2UgbGluZXMgaW50byBzdHJ1Y3R1cmVkIGB0aW1lbGluZS1pdGVtYCBIVE1MIGJsb2Nrc1xuICAgICAqIGFuZCBzaW11bHRhbmVvdXNseSBwb3B1bGF0ZXMgYG1lLnRpbWVsaW5lRGF0YWAgd2l0aCBzZW1hbnRpYyBkYXRhIChjb2xvciwgaWNvbiwgdHlwZSlcbiAgICAgKiBmb3IgZWFjaCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICByZW5kZXJUaW1lbGluZShjb250ZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29tbWl0c1VybCwgcmVwb1VzZXJVcmx9ID0gbWUsXG4gICAgICAgICAgICBodG1sICAgICAgICA9ICc8ZGl2IGNsYXNzPVwibmVvLXRpY2tldC10aW1lbGluZVwiPicsXG4gICAgICAgICAgICBsaW5lcyAgICAgICA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpLFxuICAgICAgICAgICAgY29tbWVudEJ1ZiAgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnRVc2VyID0gbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gbnVsbCxcbiAgICAgICAgICAgIGkgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgID0gbGluZXMubGVuZ3RoLFxuICAgICAgICAgICAgaWQsIGxpbmUsIG1hdGNoLCBpY29uLCBhY3Rpb25DbHM7XG5cbiAgICAgICAgY29uc3QgZmx1c2hDb21tZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRCdWYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlkID0gYHRpbWVsaW5lLSR7bWUucmVjb3JkLmlkfS0ke21lLnRpbWVsaW5lRGF0YS5sZW5ndGggKyAxfWA7XG5cbiAgICAgICAgICAgICAgICBtZS50aW1lbGluZURhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHJlcG9Vc2VyVXJsICsgY3VycmVudFVzZXIgKyAnLnBuZycsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgOiBgQ29tbWVudCAoJHtjdXJyZW50VXNlcn0pYCxcbiAgICAgICAgICAgICAgICAgICAgdGFnICA6ICdjb21tZW50J1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSBtYXJrZWQucGFyc2UoY29tbWVudEJ1Zi5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2lkfVwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWl0ZW0gY29tbWVudFwiIGRhdGEtcmVjb3JkLWlkPVwiJHtpZH1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2lkfS10YXJnZXRcIiBjbGFzcz1cIm5lby10aW1lbGluZS1hdmF0YXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIiR7cmVwb1VzZXJVcmx9JHtjdXJyZW50VXNlcn0ucG5nXCIgYWx0PVwiJHtjdXJyZW50VXNlcn1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuZW8tdGltZWxpbmUtdXNlclwiIGhyZWY9XCIke3JlcG9Vc2VyVXJsfSR7Y3VycmVudFVzZXJ9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+JHtjdXJyZW50VXNlcn08L2E+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibmVvLXRpbWVsaW5lLWRhdGVcIj4ke21lLmZvcm1hdFRpbWVzdGFtcChjdXJyZW50RGF0ZSl9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZW8tdGltZWxpbmUtYm9keVwiPiR7Ym9keX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5gO1xuICAgICAgICAgICAgICAgIGNvbW1lbnRCdWYgID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudFVzZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICAgICAgLy8gRXZlbnQgTGluZTogLSAyMDI2LTAxLTExVC4uLiBAdXNlciBhY3Rpb24uLi5cbiAgICAgICAgICAgIGlmICgobWF0Y2ggPSBsaW5lLm1hdGNoKHJlZ2V4VGltZWxpbmVFdmVudCkpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgbGV0IFtfLCBkYXRlLCB1c2VyLCBhY3Rpb25dID0gbWF0Y2g7XG5cbiAgICAgICAgICAgICAgICBpY29uICAgICAgPSAnZmEtY2lyY2xlLWRvdCc7IC8vIERlZmF1bHRcbiAgICAgICAgICAgICAgICBhY3Rpb25DbHMgPSAnJztcblxuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IFtcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ2FkZGVkIHRoZSBgJywgICAgICBpY29uOiAnZmEtdGFnJ30sXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdyZW1vdmVkIHRoZSBgJywgICAgaWNvbjogJ2ZhLXRhZyd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnYXNzaWduZWQnLCAgICAgICAgIGljb246ICdmYS11c2VyLXBlbid9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnY2xvc2VkJywgICAgICAgICAgIGljb246ICdmYS1jaXJjbGUtY2hlY2snLCBjb2xvcjogJyM4MjUwZGYnfSwgLy8gR2l0SHViIFB1cnBsZVxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAncmVvcGVuZWQnLCAgICAgICAgIGljb246ICdmYS1jaXJjbGUtZG90JywgICBjb2xvcjogJyMyZGE0NGUnfSwgLy8gR2l0SHViIEdyZWVuXG4gICAgICAgICAgICAgICAgICAgIHtrZXk6ICdyZWZlcmVuY2VkJywgICAgICAgaWNvbjogJ2ZhLWxpbmsnfSxcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ2Nyb3NzLXJlZmVyZW5jZWQnLCBpY29uOiAnZmEtbGluayd9LFxuICAgICAgICAgICAgICAgICAgICB7a2V5OiAnbWlsZXN0b25lZCcsICAgICAgIGljb246ICdmYS1zaWduLXBvc3QnfSxcbiAgICAgICAgICAgICAgICAgICAge2tleTogJ3N1Yi1pc3N1ZScsICAgICAgICBpY29uOiAnZmEtZGlhZ3JhbS1wcm9qZWN0J31cbiAgICAgICAgICAgICAgICBdLmZpbmQoZSA9PiBhY3Rpb24uaW5jbHVkZXMoZS5rZXkpKTtcblxuICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGljb24gPSBldmVudFR5cGUuaWNvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZS5jb2xvcikgY29sb3IgPSBldmVudFR5cGUuY29sb3JcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBtYXJrZG93biBpbiBhY3Rpb24gdGV4dCAoZS5nLiBgY29kZWAgdG8gPGNvZGU+KVxuICAgICAgICAgICAgICAgIGxldCBjbGVhbkFjdGlvbiA9IG1hcmtlZC5wYXJzZUlubGluZShhY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGljb24gPT09ICdmYS10YWcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuQWN0aW9uID0gY2xlYW5BY3Rpb24ucmVwbGFjZSgvPGNvZGU+KC4qPyk8XFwvY29kZT4vZywgKG1hdGNoLCBsYWJlbCkgPT4gbWUuZ2V0TGFiZWxCYWRnZUh0bWwobGFiZWwpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcmVzb2x2ZSBjb2xvciBmcm9tIGxhYmVsXG4gICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbE1hdGNoID0gYWN0aW9uLm1hdGNoKC9gKFteYF0rKWAvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbE5hbWUgPSBsYWJlbE1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsUmVjICA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgnbGFiZWxzJykuZ2V0KGxhYmVsTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxSZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGxhYmVsUmVjLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTGlua2lmeSBDb21taXQgSGFzaGVzXG4gICAgICAgICAgICAgICAgY2xlYW5BY3Rpb24gPSBjbGVhbkFjdGlvbi5yZXBsYWNlKHJlZ2V4Q29tbWl0LCBgPGEgaHJlZj1cIiR7Y29tbWl0c1VybH0kMVwiIHRhcmdldD1cIl9ibGFua1wiPiQxPC9hPmApO1xuXG4gICAgICAgICAgICAgICAgaWQgPSBgdGltZWxpbmUtJHttZS5yZWNvcmQuaWR9LSR7bWUudGltZWxpbmVEYXRhLmxlbmd0aCArIDF9YDtcblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgYSBzaG9ydCBhY3Rpb24gbmFtZSBmb3IgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBsZXQgc2hvcnRBY3Rpb24gPSBhY3Rpb24uc3BsaXQoJyAnKVswXTsgLy8gJ2FkZGVkJywgJ2Nsb3NlZCcsIGV0Yy5cbiAgICAgICAgICAgICAgICBsZXQgZW50cnlOYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNob3J0QWN0aW9uID09PSAnYWRkZWQnIHx8IHNob3J0QWN0aW9uID09PSAncmVtb3ZlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5pbmNsdWRlcygnc3ViLWlzc3VlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJJc3N1ZU1hdGNoID0gYWN0aW9uLm1hdGNoKC8jKFxcZCspLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViSXNzdWVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5TmFtZSA9IGAke05lby5jYXBpdGFsaXplKHNob3J0QWN0aW9uKX0gc3ViLWlzc3VlICMke3N1Yklzc3VlTWF0Y2hbMV19YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUgPSBgJHtOZW8uY2FwaXRhbGl6ZShzaG9ydEFjdGlvbil9IHN1Yi1pc3N1ZWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbE1hdGNoID0gYWN0aW9uLm1hdGNoKC9gKFteYF0rKWAvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0QWN0aW9uID0gbGFiZWxNYXRjaCA/IGxhYmVsTWF0Y2hbMV0gOiAnTGFiZWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlOYW1lID0gYCR7TmVvLmNhcGl0YWxpemUoc2hvcnRBY3Rpb24pfSAoJHt1c2VyfSlgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeU5hbWUgPSBgJHtOZW8uY2FwaXRhbGl6ZShzaG9ydEFjdGlvbil9ICgke3VzZXJ9KWBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS50aW1lbGluZURhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciwgLy8gUGFzcyByZXNvbHZlZCBoZXggY29sb3JcbiAgICAgICAgICAgICAgICAgICAgaWNvbiA6IGljb24sXG4gICAgICAgICAgICAgICAgICAgIGlkICAgOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA6IGVudHJ5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnICA6ICdldmVudCdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNvbG9yIHN0eWxlIGlmIHByZXNlbnQsIG90aGVyd2lzZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gY29sb3IgPyBgc3R5bGU9XCJjb2xvcjogJHtjb2xvcn1cImAgOiAnJztcblxuICAgICAgICAgICAgICAgIGh0bWwgKz0gYFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiJHtpZH1cIiBjbGFzcz1cIm5lby10aW1lbGluZS1pdGVtIGV2ZW50XCIgZGF0YS1yZWNvcmQtaWQ9XCIke2lkfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7aWR9LXRhcmdldFwiIGNsYXNzPVwibmVvLXRpbWVsaW5lLWJhZGdlXCIgJHtzdHlsZX0+PGkgY2xhc3M9XCJmYS1zb2xpZCAke2ljb259XCI+PC9pPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5lby10aW1lbGluZS1ib2R5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuZW8tdGltZWxpbmUtdXNlclwiIGhyZWY9XCIke3JlcG9Vc2VyVXJsfSR7dXNlcn1cIiB0YXJnZXQ9XCJfYmxhbmtcIj4ke3VzZXJ9PC9hPiAke2NsZWFuQWN0aW9ufSA8c3BhbiBjbGFzcz1cIm5lby10aW1lbGluZS1kYXRlXCI+b24gJHttZS5mb3JtYXRUaW1lc3RhbXAoZGF0ZSl9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21tZW50IEhlYWRlcjogIyMjIEB1c2VyIC0gMjAyNi0wMS0xMVQuLi5cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aCgnIyMjIEAnKSkge1xuICAgICAgICAgICAgICAgIC8vIENhcHR1cmVzIFwidXNlclwiIGFuZCBcIjIwMjYtMDEtMTFULi4uXCIgKElTTyB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlck1hdGNoID0gbGluZS5tYXRjaCgvXiMjIyBAKFxcdyspIC0gKFtcXGRUWjouLV0rKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVc2VyID0gaGVhZGVyTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlID0gaGVhZGVyTWF0Y2hbMl1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3Igd2VpcmQgaGVhZGVycz8gdHJlYXQgYXMgdGV4dFxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFVzZXIpIGNvbW1lbnRCdWYucHVzaChsaW5lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXNlcikge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50QnVmLnB1c2gobGluZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaENvbW1lbnQoKTsgLy8gRmx1c2ggbGFzdCBjb21tZW50XG5cbiAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcbiAgICAgICAgcmV0dXJuIGh0bWxcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQ2FudmFzV3JhcHBlciAgICBmcm9tICcuL0NhbnZhc1dyYXBwZXIubWpzJztcbmltcG9ydCBDb250cm9sbGVyICAgICAgIGZyb20gJy4vTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzJztcbmltcG9ydCBQYWdlQ29udGFpbmVyICAgIGZyb20gJy4vUGFnZUNvbnRhaW5lci5tanMnO1xuaW1wb3J0IFNoYXJlZENvbnRhaW5lciAgZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnRlbnQvQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgU3RhdGVQcm92aWRlciAgICBmcm9tICcuL01haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBQb3J0YWwudmlldy5zaGFyZWQuY29udGVudC5Db250YWluZXJcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIFNoYXJlZENvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuTWFpbkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ3BvcnRhbC10aWNrZXRzLW1haW5jb250YWluZXInXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNsczogWydwb3J0YWwtdGlja2V0cy1tYWluY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR9IGNvbnRyb2xsZXI9TWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sbGVyOiBDb250cm9sbGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBwYWdlQ29udGFpbmVyQ29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBwYWdlQ29udGFpbmVyQ29uZmlnOiB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgICA6IFBhZ2VDb250YWluZXIsXG4gICAgICAgICAgICBidXR0b25UZXh0RmllbGQ6ICdpZCcsXG4gICAgICAgICAgICBjb250ZW50Q29uZmlnICA6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6IENhbnZhc1dyYXBwZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5zdGF0ZS5Qcm92aWRlcn0gc3RhdGVQcm92aWRlcj1NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlclxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlUHJvdmlkZXI6IFN0YXRlUHJvdmlkZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHRyZWVDb25maWc9e2Rpc3BsYXlGaWVsZDondHJlZU5vZGVOYW1lJ31cbiAgICAgICAgICovXG4gICAgICAgIHRyZWVDb25maWc6IHtcbiAgICAgICAgICAgIGRpc3BsYXlGaWVsZDogJ3RyZWVOb2RlTmFtZSdcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgQ29udHJvbGxlciBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJDb250cm9sbGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyQ29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJDb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcm91dGVzXG4gICAgICAgICAqL1xuICAgICAgICByb3V0ZXM6IHtcbiAgICAgICAgICAgICcvbmV3cy90aWNrZXRzJyAgICAgICAgICA6ICdvblJvdXRlRGVmYXVsdCcsXG4gICAgICAgICAgICAnL25ld3MvdGlja2V0cy97Kml0ZW1JZH0nOiAnb25Sb3V0ZUl0ZW0nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbVxuICAgICAqL1xuICAgIG5hdmlnYXRlVG8oaXRlbSkge1xuICAgICAgICBOZW8uTWFpbi5zZXRSb3V0ZSh7XG4gICAgICAgICAgICB2YWx1ZSAgIDogYC9uZXdzL3RpY2tldHMvJHtpdGVtfWAsXG4gICAgICAgICAgICB3aW5kb3dJZDogdGhpcy5jb21wb25lbnQud2luZG93SWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IHBhbmVsICAgID0gdGhpcy5nZXRSZWZlcmVuY2UoJ3BhZ2Utc2VjdGlvbnMtY29udGFpbmVyJyksXG4gICAgICAgICAgICBsaXN0ICAgICA9IHBhbmVsLmxpc3QsXG4gICAgICAgICAgICByZWNvcmRJZCA9IGRhdGEuZGF0YS5yZWNvcmRJZCxcbiAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICBpZiAocmVjb3JkSWQgJiYgIWxpc3QuaXNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgIHJlY29yZCA9IGxpc3Quc3RvcmUuZ2V0KHJlY29yZElkKTtcblxuICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIGxpc3Quc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHJlY29yZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25OZXh0UGFnZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvKHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoJ25leHRQYWdlUmVjb3JkJykuaWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblBhZ2VTZWN0aW9uc1RvZ2dsZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5nZXRSZWZlcmVuY2UoJ3BhZ2Utc2VjdGlvbnMtY29udGFpbmVyJykudG9nZ2xlQ2xzKCduZW8tZXhwYW5kZWQnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25QcmV2aW91c1BhZ2VCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGVUbyh0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXREYXRhKCdwcmV2aW91c1BhZ2VSZWNvcmQnKS5pZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldERlZmF1bHRSb3V0ZUlkKCkge1xuICAgICAgICBsZXQgc3RvcmUgICAgID0gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3RyZWUnKSxcbiAgICAgICAgICAgIHJvb3RDb3VudCA9IDAsXG4gICAgICAgICAgICBpICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXRBdChpKTtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC5wYXJlbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvb3RDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RDb3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuZ2V0QXQoaSArIDEpPy5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdG9yZS5nZXRBdCgxKT8uaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUm91dGVEZWZhdWx0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0b3JlID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCd0cmVlJyk7XG5cbiAgICAgICAgaWYgKHN0b3JlLmdldENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBtZS5uYXZpZ2F0ZVRvKG1lLmdldERlZmF1bHRSb3V0ZUlkKCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9yZS5vbih7XG4gICAgICAgICAgICAgICAgbG9hZCA6ICgpID0+IG1lLm5hdmlnYXRlVG8obWUuZ2V0RGVmYXVsdFJvdXRlSWQoKSksXG4gICAgICAgICAgICAgICAgZGVsYXk6IDEwLFxuICAgICAgICAgICAgICAgIG9uY2UgOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5pdGVtSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhc3luYyBvblJvdXRlSXRlbSh7aXRlbUlkfSwgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlUHJvdmlkZXIgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCksXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgID0gc3RhdGVQcm92aWRlci5nZXRTdG9yZSgndHJlZScpLFxuICAgICAgICAgICAgdHJlZSAgICAgICAgICA9IG1lLmdldFJlZmVyZW5jZSgndHJlZScpO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgdHJlZSBoYXMgdGhlIGNvcnJlY3Qgcm91dGUgcHJlZml4IGZvciB0aGlzIGNvbnRyb2xsZXIgY29udGV4dFxuICAgICAgICBpZiAodHJlZS5yb3V0ZVByZWZpeCAhPT0gJy9uZXdzL3RpY2tldHMnKSB7XG4gICAgICAgICAgICB0cmVlLnJvdXRlUHJlZml4ID0gJy9uZXdzL3RpY2tldHMnXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWxlY3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZVByb3ZpZGVyLmRhdGEuY3VycmVudFBhZ2VSZWNvcmQgPSBzdG9yZS5nZXQoaXRlbUlkKTtcblxuICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZT8uaGFzaFN0cmluZz8uc3RhcnRzV2l0aCgnL25ld3MvdGlja2V0cycpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdHJlZS5leHBhbmRBbmRTY3JvbGxUb0l0ZW0oaXRlbUlkKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmVlLmV4cGFuZFBhcmVudHMoaXRlbUlkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzdG9yZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgc2VsZWN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JlLm9uKHtcbiAgICAgICAgICAgICAgICBsb2FkIDogc2VsZWN0LFxuICAgICAgICAgICAgICAgIGRlbGF5OiAxMCxcbiAgICAgICAgICAgICAgICBvbmNlIDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TaWRlTmF2VG9nZ2xlQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgnc2lkZW5hdi1jb250YWluZXInKS50b2dnbGVDbHMoJ25lby1leHBhbmRlZCcpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyQ29udHJvbGxlcik7XG4iLCJpbXBvcnQgVGlja2V0TGFiZWxzU3RvcmUgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3RvcmUvVGlja2V0TGFiZWxzLm1qcyc7XG5pbXBvcnQgVGlja2V0VGltZWxpbmVTZWN0aW9uc1N0b3JlICBmcm9tICcuLi8uLi8uLi9zdG9yZS9UaWNrZXRUaW1lbGluZVNlY3Rpb25zLm1qcyc7XG5pbXBvcnQgVGlja2V0c1N0b3JlICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zdG9yZS9UaWNrZXRzLm1qcyc7XG5pbXBvcnQgU3RhdGVQcm92aWRlciAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi8uLi8uLi9zcmMvc3RhdGUvUHJvdmlkZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyXG4gKiBAZXh0ZW5kcyBOZW8uc3RhdGUuUHJvdmlkZXJcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lclN0YXRlUHJvdmlkZXIgZXh0ZW5kcyBTdGF0ZVByb3ZpZGVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLk1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gZGF0YS5jb3VudFBhZ2VzPW51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY291bnRQYWdlczogbnVsbCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGRhdGEuY291bnRQYWdlcz1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvdW50U2VjdGlvbnM6IG51bGwsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByZWNvcmQgd2hpY2ggZ2V0cyBzaG93biBhcyB0aGUgY29udGVudCBwYWdlXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGEuY3VycmVudFJlY29yZD1udWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUmVjb3JkOiBudWxsLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcmVjb3JkIHdoaWNoIGdldHMgc2hvd24gYXMgdGhlIGNvbnRlbnQgcGFnZVxuICAgICAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhLm5leHRQYWdlUmVjb3JkPW51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbmV4dFBhZ2VSZWNvcmQ6IG51bGwsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByZWNvcmQgd2hpY2ggZ2V0cyBzaG93biBhcyB0aGUgY29udGVudCBwYWdlXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGEucHJldmlvdXNQYWdlUmVjb3JkPW51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHJldmlvdXNQYWdlUmVjb3JkOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0b3Jlc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVzOiB7XG4gICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICBhdXRvTG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtb2R1bGUgIDogVGlja2V0TGFiZWxzU3RvcmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogVGlja2V0VGltZWxpbmVTZWN0aW9uc1N0b3JlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJlZToge1xuICAgICAgICAgICAgICAgIGF1dG9Mb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBUaWNrZXRzU3RvcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uRGF0YVByb3BlcnR5Q2hhbmdlKGtleSwgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLm9uRGF0YVByb3BlcnR5Q2hhbmdlKGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdjb3VudFNlY3Rpb25zJzoge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY29tcG9uZW50LmdldFJlZmVyZW5jZSgncGFnZS1zZWN0aW9ucy1jb250YWluZXInKT8udG9nZ2xlQ2xzKCduZW8tZXhwYW5kZWQnLCBmYWxzZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICdjdXJyZW50UGFnZVJlY29yZCc6IHtcbiAgICAgICAgICAgICAgICBsZXQge2RhdGF9ICAgICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgICAgIHtjb3VudFBhZ2VzfSAgICAgICA9IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlICAgICAgICAgICAgICA9IG1lLmdldFN0b3JlKCd0cmVlJyksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgICAgICA9IHN0b3JlLmluZGV4T2YodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UGFnZVJlY29yZCAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1BhZ2VSZWNvcmQgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpLCByZWNvcmQ7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9naWMgYXNzdW1lcyB0aGF0IHRoZSB0cmVlIHN0b3JlIGlzIHNvcnRlZFxuICAgICAgICAgICAgICAgIGZvciAoaT1pbmRleC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBzdG9yZS5nZXRBdChpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiAmJiAhbWUucmVjb3JkSXNIaWRkZW4ocmVjb3JkLCBzdG9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUGFnZVJlY29yZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5zZXREYXRhKHtwcmV2aW91c1BhZ2VSZWNvcmR9KTtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBsb2dpYyBhc3N1bWVzIHRoYXQgdGhlIHRyZWUgc3RvcmUgaXMgc29ydGVkXG4gICAgICAgICAgICAgICAgZm9yIChpPWluZGV4KzE7IGkgPCBjb3VudFBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQoaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYgJiYgIW1lLnJlY29yZElzSGlkZGVuKHJlY29yZCwgc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UGFnZVJlY29yZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5zZXREYXRhKHtuZXh0UGFnZVJlY29yZH0pO1xuXG4gICAgICAgICAgICAgICAgbWUuY29tcG9uZW50LmdldFJlZmVyZW5jZSgnc2lkZW5hdi1jb250YWluZXInKT8udG9nZ2xlQ2xzKCduZW8tZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIGNoZWNrIHRoZSBwYXJlbnQtbm9kZSBjaGFpbiBpbnNpZGUgdGhlIHRyZWUuXG4gICAgICogPT4gQW55IGhpZGRlbiBwYXJlbnQtbm9kZSByZXN1bHRzIGluIGEgaGlkZGVuIHJlY29yZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZX0gc3RvcmVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICByZWNvcmRJc0hpZGRlbihyZWNvcmQsIHN0b3JlKSB7XG4gICAgICAgIGlmIChyZWNvcmQuaGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY29yZC5wYXJlbnRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkSXNIaWRkZW4oc3RvcmUuZ2V0KHJlY29yZC5wYXJlbnRJZCksIHN0b3JlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyU3RhdGVQcm92aWRlcik7XG4iLCJpbXBvcnQgUGFnZUNvbnRhaW5lciBmcm9tICcuLi8uLi9zaGFyZWQvY29udGVudC9QYWdlQ29udGFpbmVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5QYWdlQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBQb3J0YWwudmlldy5zaGFyZWQuY29udGVudC5QYWdlQ29udGFpbmVyXG4gKi9cbmNsYXNzIFRpY2tldFBhZ2VDb250YWluZXIgZXh0ZW5kcyBQYWdlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5QYWdlQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdQb3J0YWwudmlldy5uZXdzLnRpY2tldHMuUGFnZUNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlPXtmbGV4OjEsb3ZlcmZsb3dZOidhdXRvJyxwb3NpdGlvbjoncmVsYXRpdmUnfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGU6IHtmbGV4OiAxLCBvdmVyZmxvd1k6ICdhdXRvJywgcG9zaXRpb246ICdyZWxhdGl2ZSd9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaWNrZXRQYWdlQ29udGFpbmVyKTtcbiIsImltcG9ydCBTaGFyZWRDYW52YXMgZnJvbSAnLi4vLi4vc2hhcmVkL0NhbnZhcy5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFRoZSBcIkNvb3JkaW5hdG9yXCIgY29tcG9uZW50IGZvciB0aGUgTmV1cmFsIFRpbWVsaW5lLCBicmlkZ2luZyB0aGUgQXBwIFdvcmtlciBhbmQgQ2FudmFzIFdvcmtlci5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGEgdHJhbnNwYXJlbnQgY2FudmFzIG92ZXJsYXkgb24gdG9wIG9mIHRoZSBUaWNrZXQgTGlzdC4gSXQgaXMgcmVzcG9uc2libGUgZm9yOlxuICogMS4gKipEYXRhIEJyaWRnZSoqOiBMaXN0ZW5pbmcgdG8gdGhlIGBzZWN0aW9uc2Agc3RvcmUgYW5kIHBhc3NpbmcgdGlja2V0IGRhdGEgdG8gdGhlIGBUaWNrZXRDYW52YXNgIChTaGFyZWRXb3JrZXIpLlxuICogMi4gKipWaXN1YWwgQWxpZ25tZW50Kio6IENhbGN1bGF0aW5nIHRoZSBwcmVjaXNlIERPTSBwb3NpdGlvbnMgb2YgVGlja2V0IEF2YXRhcnMvQmFkZ2VzIHRvIGVuc3VyZSB0aGVcbiAqICAgIGNhbnZhcyBub2RlcyBhbGlnbiBwZXJmZWN0bHkgd2l0aCB0aGUgSFRNTCBjb250ZW50LlxuICogMy4gKipMaWZlY3ljbGUgTWFuYWdlbWVudCoqOiBpbml0aWFsaXppbmcgdGhlIG9mZnNjcmVlbiBjYW52YXMgdHJhbnNmZXIgYW5kIGhhbmRsaW5nIHJlc2l6ZSBldmVudHMuXG4gKlxuICogSXQgdXNlcyB0aGUgYFBvcnRhbC5jYW52YXMuVGlja2V0Q2FudmFzYCBzaW5nbGV0b24gKHZpYSBSZW1vdGUgTWV0aG9kIEFjY2VzcykgdG8gZHJpdmUgdGhlIGFjdHVhbCBhbmltYXRpb24uXG4gKlxuICogQGNsYXNzIFBvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5UaW1lbGluZUNhbnZhc1xuICogQGV4dGVuZHMgUG9ydGFsLnZpZXcuc2hhcmVkLkNhbnZhc1xuICovXG5jbGFzcyBUaW1lbGluZUNhbnZhcyBleHRlbmRzIFNoYXJlZENhbnZhcyB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWxheWFibGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsYXlhYmxlID0ge1xuICAgICAgICBlbnN1cmVGaW5hbEFsaWdubWVudDoge1xuICAgICAgICAgICAgdHlwZSA6ICdkZWJvdW5jZScsXG4gICAgICAgICAgICB0aW1lcjogMzAwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1BvcnRhbC52aWV3Lm5ld3MudGlja2V0cy5UaW1lbGluZUNhbnZhcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnUG9ydGFsLnZpZXcubmV3cy50aWNrZXRzLlRpbWVsaW5lQ2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaW1wb3J0TWV0aG9kTmFtZT0naW1wb3J0VGlja2V0Q2FudmFzJ1xuICAgICAgICAgKi9cbiAgICAgICAgaW1wb3J0TWV0aG9kTmFtZTogJ2ltcG9ydFRpY2tldENhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlbmRlcmVyQ2xhc3NOYW1lPSdQb3J0YWwuY2FudmFzLlRpY2tldENhbnZhcydcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyQ2xhc3NOYW1lOiAnUG9ydGFsLmNhbnZhcy5UaWNrZXRDYW52YXMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdkaXYnLCBjbHM6IFsnbmVvLXRpY2tldC10aW1lbGluZS13cmFwcGVyJ10sIHN0eWxlOiB7d2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSd9LCBjbjogW1xuICAgICAgICAgICAge3RhZzogJ2NhbnZhcycsIHN0eWxlOiB7d2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSd9fVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBsYXN0UmVjb3Jkcz1udWxsXG4gICAgICovXG4gICAgbGFzdFJlY29yZHMgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGVuc3VyZUZpbmFsQWxpZ25tZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5sYXN0UmVjb3Jkcykge1xuICAgICAgICAgICAgbWUub25UaW1lbGluZURhdGFMb2FkKG1lLmxhc3RSZWNvcmRzLCB0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIGhvb2sgdGhhdCBydW5zIG9uY2UgdGhlIGBPZmZzY3JlZW5DYW52YXNgIGhhcyBiZWVuIHRyYW5zZmVycmVkIHRvIHRoZSBDYW52YXMgV29ya2VyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Q6XG4gICAgICogMS4gSW1wb3J0cyB0aGUgYFRpY2tldENhbnZhc2AgbG9naWMgaW50byB0aGUgQ2FudmFzIFdvcmtlciBjb250ZXh0LlxuICAgICAqIDIuIEluaXRpYWxpemVzIHRoZSBncmFwaCBpbiB0aGUgd29ya2VyIHZpYSBSZW1vdGUgTWV0aG9kIEFjY2VzcyAoYGluaXRHcmFwaGApLlxuICAgICAqIDMuIFNldHMgdXAgYSBgUmVzaXplT2JzZXJ2ZXJgIHRvIGtlZXAgdGhlIGNhbnZhcyBzaXplIHN5bmNlZCB3aXRoIHRoZSBET00uXG4gICAgICogNC4gVHJpZ2dlcnMgdGhlIGluaXRpYWwgZGF0YSBsb2FkIGlmIHN0b3JlIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRPZmZzY3JlZW5SZWdpc3RlcmVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGF3YWl0IHN1cGVyLmFmdGVyU2V0T2Zmc2NyZWVuUmVnaXN0ZXJlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbCBsb2FkIGNoZWNrXG4gICAgICAgICAgICBsZXQgc3RvcmUgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ3NlY3Rpb25zJyk7XG5cbiAgICAgICAgICAgIGlmIChzdG9yZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgIG1lLm9uVGltZWxpbmVEYXRhTG9hZChzdG9yZS5pdGVtcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIHJldHVybiB0aGUgaW5uZXIgY2FudmFzIElEXG4gICAgICovXG4gICAgZ2V0Q2FudmFzSWQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jYW52YXNJZCkge1xuICAgICAgICAgICAgbWUuY2FudmFzSWQgPSBtZS52ZG9tLmNuWzBdLmlkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLmNhbnZhc0lkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0b3JlID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdzZWN0aW9ucycpO1xuXG4gICAgICAgIHN0b3JlLm9uKCdsb2FkJywgbWUub25UaW1lbGluZURhdGFMb2FkLCBtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uUmVzaXplKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNhbnZhcyBzaXplIGluIHRoZSB3b3JrZXJcbiAgICAgICAgYXdhaXQgbWUudXBkYXRlU2l6ZShkYXRhLmNvbnRlbnRSZWN0KTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGNhY2hlZCByZWNvcmRzLCByZS1jYWxjdWxhdGUgbm9kZSBwb3NpdGlvbnNcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29udGFpbmVyIGRpbWVuc2lvbnMgKGFuZCBsaWtlbHkgcmVsYXRpdmUgcG9zaXRpb25zKSBoYXZlIGNoYW5nZWQuXG4gICAgICAgIGlmIChtZS5sYXN0UmVjb3Jkcykge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1mZXRjaCByZWN0cyBpbnN0YW50bHksIGJ1dCBpdCdzIHNhZmVyIHRvIGRvIHNvXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgYWxpZ25tZW50IHdpdGggdGhlIG5ldyBsYXlvdXQuXG4gICAgICAgICAgICBhd2FpdCBtZS5vblRpbWVsaW5lRGF0YUxvYWQobWUubGFzdFJlY29yZHMsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBEZWJvdW5jZWQgY2hlY2sgdG8gZW5zdXJlIHRoZSBjYW52YXMgaXMgYWxpZ25lZCBhZnRlciBhbnkgdHJhbnNpdGlvbnMgc2V0dGxlXG4gICAgICAgICAgICBtZS5lbnN1cmVGaW5hbEFsaWdubWVudCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29yZSBcIkFsaWdubWVudCBFbmdpbmVcIiBvZiB0aGUgdGltZWxpbmUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBzeW5jaHJvbml6ZXMgdGhlIENhbnZhcyBub2RlcyB3aXRoIHRoZSBET00gZWxlbWVudHMgKEF2YXRhcnMvQmFkZ2VzKS5cbiAgICAgKlxuICAgICAqICoqU3RyYXRlZ3k6KipcbiAgICAgKiAxLiAqKlRhcmdldGluZyoqOiBJdCB1c2VzIHRoZSBgLXRhcmdldGAgSUQgc3VmZml4IHRvIGZpbmQgdGhlIHNwZWNpZmljIERPTSBlbGVtZW50cyAoQXZhdGFycykgd2l0aGluIHRoZSB0aWNrZXQgbGlzdC5cbiAgICAgKiAyLiAqKk1lYXN1cmVtZW50Kio6IEl0IGZldGNoZXMgdGhlIGBET01SZWN0YCBmb3IgZXZlcnkgdGFyZ2V0IHRvIGdldCBpdHMgZXhhY3Qgc2NyZWVuIHBvc2l0aW9uLlxuICAgICAqIDMuICoqVHJhbnNsYXRpb24qKjogSXQgY29udmVydHMgdGhlc2Ugc2NyZWVuIGNvb3JkaW5hdGVzIGludG8gQ2FudmFzLWxvY2FsIGNvb3JkaW5hdGVzLlxuICAgICAqIDQuICoqSGFuZG9mZioqOiBJdCBwYWNrYWdlcyB0aGlzIGdlb21ldHJpYyBkYXRhICh4LCB5LCByYWRpdXMsIGNvbG9yKSBhbmQgc2VuZHMgaXQgdG8gdGhlXG4gICAgICogICAgYFRpY2tldENhbnZhc2Agd29ya2VyIHRvIHVwZGF0ZSB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxPYmplY3R9IHJlY29yZHMgQXJyYXkgb2YgcmVjb3JkcyBvciBTdG9yZSBsb2FkIGV2ZW50IG9iamVjdCB7aXRlbXM6IFsuLi5dfVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUmVzaXplPWZhbHNlXVxuICAgICAqL1xuICAgIGFzeW5jIG9uVGltZWxpbmVEYXRhTG9hZChyZWNvcmRzLCBpc1Jlc2l6ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gSGFuZGxlIFN0b3JlICdsb2FkJyBldmVudCBzaWduYXR1cmU6IGZpcmUoJ2xvYWQnLCB7aXRlbXM6IFsuLi5dfSlcbiAgICAgICAgaWYgKHJlY29yZHMgJiYgIUFycmF5LmlzQXJyYXkocmVjb3JkcykgJiYgcmVjb3Jkcy5pdGVtcykge1xuICAgICAgICAgICAgcmVjb3JkcyA9IHJlY29yZHMuaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWNvcmRzKSkge1xuICAgICAgICAgICAgLy8gU2FmZXR5IGNoZWNrIGlmIHJlY29yZHMgaXMgc3RpbGwgaW52YWxpZFxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1lLmlzQ2FudmFzUmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc2V0ID0gIWlzUmVzaXplO1xuXG4gICAgICAgIC8vIFNtYXJ0IENoZWNrOiBJZiBpdCdzIGEgc3RvcmUgbG9hZCAocmVzZXQ9dHJ1ZSkgQlVUIHRoZSB0aWNrZXQgSUQgaXMgdGhlIHNhbWUsXG4gICAgICAgIC8vIGl0J3MgYSBkYXRhIHJlZnJlc2ggKGUuZy4gY29tbWVudCBhZGRlZCksIHNvIHdlIHNob3VsZCBOT1QgcmVzZXQgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgaWYgKHJlc2V0ICYmIG1lLmxhc3RSZWNvcmRzICYmIHJlY29yZHNbMF0/LmlkID09PSBtZS5sYXN0UmVjb3Jkc1swXT8uaWQpIHtcbiAgICAgICAgICAgIHJlc2V0ID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmxhc3RSZWNvcmRzID0gcmVjb3JkcztcblxuICAgICAgICBsZXQgaWRzID0gcmVjb3Jkcy5tYXAociA9PiBgJHtyLmlkfS10YXJnZXRgKSxcbiAgICAgICAgICAgIHJlY3RzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGZXRjaCBET00gcmVjdHMgZm9yIHRoZSBNQVJLRVJTIChBdmF0YXJzL0JhZGdlcyksIG5vdCB0aGUgY29udGFpbmVyc1xuICAgICAgICAgICAgcmVjdHMgPSBhd2FpdCBtZS53YWl0Rm9yRG9tUmVjdCh7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHM6IDIwLFxuICAgICAgICAgICAgICAgIGRlbGF5ICAgOiA1MCxcbiAgICAgICAgICAgICAgICBpZCAgICAgIDogaWRzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1lLmxhc3RSZWNvcmRzICE9PSByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGdvdCB2YWxpZCByZWN0cyAoYXQgbGVhc3Qgb25lKVxuICAgICAgICAgICAgbGV0IGhhc1JlY3RzID0gcmVjdHMgJiYgcmVjdHMuc29tZShyID0+IHIpO1xuXG4gICAgICAgICAgICBpZiAoIWhhc1JlY3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9uIGZpcnN0IHZhbGlkIGRhdGEgbG9hZCAobm90IHJlc2l6ZSksIGVuc3VyZSBzaXplIGlzIHN5bmNlZFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBjb250ZW50IG1pZ2h0IGhhdmUgcHVzaGVkIHRoZSBjb250YWluZXIgaGVpZ2h0LlxuICAgICAgICAgICAgaWYgKCFpc1Jlc2l6ZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnVwZGF0ZVNpemUoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY2FudmFzUmVjdCA9IGF3YWl0IG1lLmdldERvbVJlY3QobWUuZ2V0Q2FudmFzSWQoKSksXG4gICAgICAgICAgICAgICAgbm9kZXMgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0WSAgICAgPSAwO1xuXG4gICAgICAgICAgICBpZHMuZm9yRWFjaCgodGFyZ2V0SWQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgICA9IHJlY3RzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gcmVjb3Jkc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQUkVDSVNFIENFTlRFUklOR1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgJ3JlY3QnIGlzIHRoZSBhY3R1YWwgYXZhdGFyL2JhZGdlLlxuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmVjdC5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVkgID0gcmVjdC55IC0gY2FudmFzUmVjdC55ICsgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVggID0gcmVjdC54IC0gY2FudmFzUmVjdC54ICsgKHJlY3Qud2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc3RpbmN0IHBhZGRpbmcgZm9yIE9yYml0IGVmZmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZhdGFycyAofjQwcHgpIGdldCBtb3JlIGJyZWF0aGluZyByb29tIHRoYW4gQmFkZ2VzICh+MjhweClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSByZWN0LmhlaWdodCA+IDMyID8gNiA6IDM7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA6IHJlY29yZC5jb2xvciwgLy8gUGFzcyBIZXggQ29sb3IgKGUuZy4gI2ZmMDAwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgIDogcmVjb3JkLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBvZmZzZXQgKyBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgeSAgICAgOiBub2RlWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHggICAgIDogbm9kZVhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBzdGFydFkgb2YgdGhlIGxpbmUgdG8gdGhlIGZpcnN0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFkgPSBub2RlWVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnJlbmRlcmVyLnVwZGF0ZUdyYXBoRGF0YSh7bm9kZXMsIHJlc2V0LCBzdGFydFl9KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaW1lbGluZUNhbnZhcyB1cGRhdGUgZmFpbGVkJywgZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVGltZWxpbmVDYW52YXMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==