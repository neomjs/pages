"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_vdom_util_StringFromVnode_mjs"],{

/***/ "./src/vdom/util/StringFromVnode.mjs"
/*!*******************************************!*\
  !*** ./src/vdom/util/StringFromVnode.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domConstants.mjs */ "./src/vdom/domConstants.mjs");



/**
 * @summary Utility to convert VNode trees into HTML strings.
 *
 * This singleton provides the core logic for the string-based rendering path. It traverses
 * a VNode tree and generates the corresponding `outerHTML` string. This is used when the
 * `Neo.config.useDomApiRenderer` is set to false, or for server-side rendering (SSR) scenarios.
 *
 * In addition to string generation, it acts as a visitor to collect nodes that require
 * special handling after being mounted to the DOM (e.g., restoring scroll state), as these
 * properties cannot be set via HTML attributes.
 *
 * @class Neo.vdom.util.StringFromVnode
 * @singleton
 */
const StringFromVnode = {
    /**
     * @param {Object} vnode
     * @returns {String}
     * @protected
     */
    createCloseTag(vnode) {
        return _domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__.voidElements.has(vnode.nodeName) ? '' : '</' + vnode.nodeName + '>'
    },

    /**
     * @param {Object} vnode
     * @returns {String}
     * @protected
     */
    createOpenTag(vnode) {
        let string       = '<' + vnode.nodeName,
            {attributes} = vnode,
            cls          = vnode.className,
            style;

        if (vnode.style) {
            style = Neo.createStyles(vnode.style);

            if (style !== '') {
                string += ` style="${style}"`
            }
        }

        if (cls) {
            if (Array.isArray(cls)) {
                cls = cls.join(' ')
            }

            if (cls !== '') {
                string += ` class="${cls}"`
            }
        }

        if (vnode.id) {
            if (Neo.config.useDomIds) {
                string += ` id="${vnode.id}"`
            } else {
                string += ` data-neo-id="${vnode.id}"`
            }
        }

        Object.entries(attributes).forEach(([key, value]) => {
            if (_domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__.voidAttributes.has(key)) {
                if (value === 'true') { // vnode attribute values get converted into strings
                    string += ` ${key}`
                }
            } else if (key !== 'removeDom') {
                if (key === 'value') {
                    value = _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].escapeHtml(value)
                }

                string += ` ${key}="${value?.replaceAll?.('"', '&quot;') ?? value}"`
            }
        });

        return string + '>'
    },

    /**
     * Creates an HTML string from a VNode tree.
     * Skips nodes present in the optional movedNodes map.
     *
     * Uses a visitor pattern to collect `postMountUpdates`:
     * As it traverses the tree to build the string, it identifies nodes with properties
     * that cannot be represented in HTML (like `scrollTop` and `scrollLeft`).
     * These are pushed into the passed `postMountUpdates` array, allowing the main thread
     * renderer to apply them after the HTML has been inserted into the document.
     *
     * @param {Neo.vdom.VNode} vnode
     * @param {Map}            [movedNodes]
     * @param {Object[]}       [postMountUpdates=[]]
     * @returns {String}
     */
    create(vnode, movedNodes, postMountUpdates=[]) {
        let me = this,
            id = vnode?.id;

        // If a content node will get moved by a delta update OP, there is no need to regenerate it. Opt out.
        if (id && movedNodes?.get(id)) {
            return ''
        }

        switch (vnode.vtype) {
            case 'root':
                return me.create(vnode.childNodes[0], movedNodes, postMountUpdates)
            case 'text':
                // For text VNodes, `vnode.textContent` holds the HTML-escaped content.
                // Add the comment wrappers here for string output, aligning with main.mixin.DeltaUpdates.createDomTree().
                // `vnode.textContent || ''` ensures robustness in case vnode.textContent is not a string (e.g., a number or null).
                return `<!-- ${vnode.id} -->${vnode.textContent}<!-- /neo-vtext -->`
            case 'vnode':
                if (vnode.nodeName === 'fragment') {
                    return `<!-- ${vnode.id}-start -->` + me.createTagContent(vnode, movedNodes, postMountUpdates) + `<!-- ${vnode.id}-end -->`
                }

                if (vnode.scrollTop || vnode.scrollLeft) {
                    let update = {id};

                    if (vnode.scrollLeft) {update.scrollLeft = vnode.scrollLeft}
                    if (vnode.scrollTop)  {update.scrollTop  = vnode.scrollTop}

                    postMountUpdates.push(update)
                }

                return me.createOpenTag(vnode) + me.createTagContent(vnode, movedNodes, postMountUpdates) + me.createCloseTag(vnode)
            default:
                return ''
        }
    },

    /**
     * Creates the inner HTML content for a VNode tag.
     * @param {Neo.vdom.VNode} vnode
     * @param {Map}            [movedNodes]
     * @param {Object[]}       [postMountUpdates]
     * @returns {String}
     * @protected
     */
    createTagContent(vnode, movedNodes, postMountUpdates) {
        const hasContent = vnode.innerHTML || vnode.textContent;

        if (hasContent) {
            return hasContent
        }

        let string = '',
            len    = vnode.childNodes ? vnode.childNodes.length : 0,
            i      = 0,
            childNode;

        for (; i < len; i++) {
            childNode = vnode.childNodes[i];
            string += this.create(childNode, movedNodes, postMountUpdates)
        }

        return string
    }
};

const ns = Neo.ns('Neo.vdom.util', true);
ns.StringFromVnode = StringFromVnode;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringFromVnode);


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfdmRvbV91dGlsX1N0cmluZ0Zyb21Wbm9kZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ0Y7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFZO0FBQzNCLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQyxjQUFjO0FBQ2QsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiw2REFBYztBQUM5Qix3Q0FBd0M7QUFDeEMsa0NBQWtDLElBQUk7QUFDdEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0QkFBNEIsd0RBQVM7QUFDckM7O0FBRUEsOEJBQThCLElBQUksSUFBSSxnQ0FBZ0MsWUFBWTtBQUNsRjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVUsS0FBSyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBLG1DQUFtQyxTQUFTLGlGQUFpRixTQUFTO0FBQ3RJOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQywyQ0FBMkM7QUFDM0MsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLGVBQWUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvdmRvbS91dGlsL1N0cmluZ0Zyb21Wbm9kZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5lb1N0cmluZyAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi91dGlsL1N0cmluZy5tanMnO1xuaW1wb3J0IHt2b2lkQXR0cmlidXRlcywgdm9pZEVsZW1lbnRzfSBmcm9tICcuLi9kb21Db25zdGFudHMubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBVdGlsaXR5IHRvIGNvbnZlcnQgVk5vZGUgdHJlZXMgaW50byBIVE1MIHN0cmluZ3MuXG4gKlxuICogVGhpcyBzaW5nbGV0b24gcHJvdmlkZXMgdGhlIGNvcmUgbG9naWMgZm9yIHRoZSBzdHJpbmctYmFzZWQgcmVuZGVyaW5nIHBhdGguIEl0IHRyYXZlcnNlc1xuICogYSBWTm9kZSB0cmVlIGFuZCBnZW5lcmF0ZXMgdGhlIGNvcnJlc3BvbmRpbmcgYG91dGVySFRNTGAgc3RyaW5nLiBUaGlzIGlzIHVzZWQgd2hlbiB0aGVcbiAqIGBOZW8uY29uZmlnLnVzZURvbUFwaVJlbmRlcmVyYCBpcyBzZXQgdG8gZmFsc2UsIG9yIGZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgKFNTUikgc2NlbmFyaW9zLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHN0cmluZyBnZW5lcmF0aW9uLCBpdCBhY3RzIGFzIGEgdmlzaXRvciB0byBjb2xsZWN0IG5vZGVzIHRoYXQgcmVxdWlyZVxuICogc3BlY2lhbCBoYW5kbGluZyBhZnRlciBiZWluZyBtb3VudGVkIHRvIHRoZSBET00gKGUuZy4sIHJlc3RvcmluZyBzY3JvbGwgc3RhdGUpLCBhcyB0aGVzZVxuICogcHJvcGVydGllcyBjYW5ub3QgYmUgc2V0IHZpYSBIVE1MIGF0dHJpYnV0ZXMuXG4gKlxuICogQGNsYXNzIE5lby52ZG9tLnV0aWwuU3RyaW5nRnJvbVZub2RlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNvbnN0IFN0cmluZ0Zyb21Wbm9kZSA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDbG9zZVRhZyh2bm9kZSkge1xuICAgICAgICByZXR1cm4gdm9pZEVsZW1lbnRzLmhhcyh2bm9kZS5ub2RlTmFtZSkgPyAnJyA6ICc8LycgKyB2bm9kZS5ub2RlTmFtZSArICc+J1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVPcGVuVGFnKHZub2RlKSB7XG4gICAgICAgIGxldCBzdHJpbmcgICAgICAgPSAnPCcgKyB2bm9kZS5ub2RlTmFtZSxcbiAgICAgICAgICAgIHthdHRyaWJ1dGVzfSA9IHZub2RlLFxuICAgICAgICAgICAgY2xzICAgICAgICAgID0gdm5vZGUuY2xhc3NOYW1lLFxuICAgICAgICAgICAgc3R5bGU7XG5cbiAgICAgICAgaWYgKHZub2RlLnN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZSA9IE5lby5jcmVhdGVTdHlsZXModm5vZGUuc3R5bGUpO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGAgc3R5bGU9XCIke3N0eWxlfVwiYFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNscykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2xzKSkge1xuICAgICAgICAgICAgICAgIGNscyA9IGNscy5qb2luKCcgJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNscyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gYCBjbGFzcz1cIiR7Y2xzfVwiYFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZub2RlLmlkKSB7XG4gICAgICAgICAgICBpZiAoTmVvLmNvbmZpZy51c2VEb21JZHMpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gYCBpZD1cIiR7dm5vZGUuaWR9XCJgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBgIGRhdGEtbmVvLWlkPVwiJHt2bm9kZS5pZH1cImBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZvaWRBdHRyaWJ1dGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHsgLy8gdm5vZGUgYXR0cmlidXRlIHZhbHVlcyBnZXQgY29udmVydGVkIGludG8gc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gYCAke2tleX1gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09ICdyZW1vdmVEb20nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE5lb1N0cmluZy5lc2NhcGVIdG1sKHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0cmluZyArPSBgICR7a2V5fT1cIiR7dmFsdWU/LnJlcGxhY2VBbGw/LignXCInLCAnJnF1b3Q7JykgPz8gdmFsdWV9XCJgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdHJpbmcgKyAnPidcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBIVE1MIHN0cmluZyBmcm9tIGEgVk5vZGUgdHJlZS5cbiAgICAgKiBTa2lwcyBub2RlcyBwcmVzZW50IGluIHRoZSBvcHRpb25hbCBtb3ZlZE5vZGVzIG1hcC5cbiAgICAgKlxuICAgICAqIFVzZXMgYSB2aXNpdG9yIHBhdHRlcm4gdG8gY29sbGVjdCBgcG9zdE1vdW50VXBkYXRlc2A6XG4gICAgICogQXMgaXQgdHJhdmVyc2VzIHRoZSB0cmVlIHRvIGJ1aWxkIHRoZSBzdHJpbmcsIGl0IGlkZW50aWZpZXMgbm9kZXMgd2l0aCBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSFRNTCAobGlrZSBgc2Nyb2xsVG9wYCBhbmQgYHNjcm9sbExlZnRgKS5cbiAgICAgKiBUaGVzZSBhcmUgcHVzaGVkIGludG8gdGhlIHBhc3NlZCBgcG9zdE1vdW50VXBkYXRlc2AgYXJyYXksIGFsbG93aW5nIHRoZSBtYWluIHRocmVhZFxuICAgICAqIHJlbmRlcmVyIHRvIGFwcGx5IHRoZW0gYWZ0ZXIgdGhlIEhUTUwgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZVxuICAgICAqIEBwYXJhbSB7TWFwfSAgICAgICAgICAgIFttb3ZlZE5vZGVzXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgICAgIFtwb3N0TW91bnRVcGRhdGVzPVtdXVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3JlYXRlKHZub2RlLCBtb3ZlZE5vZGVzLCBwb3N0TW91bnRVcGRhdGVzPVtdKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpZCA9IHZub2RlPy5pZDtcblxuICAgICAgICAvLyBJZiBhIGNvbnRlbnQgbm9kZSB3aWxsIGdldCBtb3ZlZCBieSBhIGRlbHRhIHVwZGF0ZSBPUCwgdGhlcmUgaXMgbm8gbmVlZCB0byByZWdlbmVyYXRlIGl0LiBPcHQgb3V0LlxuICAgICAgICBpZiAoaWQgJiYgbW92ZWROb2Rlcz8uZ2V0KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHZub2RlLnZ0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUuY3JlYXRlKHZub2RlLmNoaWxkTm9kZXNbMF0sIG1vdmVkTm9kZXMsIHBvc3RNb3VudFVwZGF0ZXMpXG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dCBWTm9kZXMsIGB2bm9kZS50ZXh0Q29udGVudGAgaG9sZHMgdGhlIEhUTUwtZXNjYXBlZCBjb250ZW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29tbWVudCB3cmFwcGVycyBoZXJlIGZvciBzdHJpbmcgb3V0cHV0LCBhbGlnbmluZyB3aXRoIG1haW4ubWl4aW4uRGVsdGFVcGRhdGVzLmNyZWF0ZURvbVRyZWUoKS5cbiAgICAgICAgICAgICAgICAvLyBgdm5vZGUudGV4dENvbnRlbnQgfHwgJydgIGVuc3VyZXMgcm9idXN0bmVzcyBpbiBjYXNlIHZub2RlLnRleHRDb250ZW50IGlzIG5vdCBhIHN0cmluZyAoZS5nLiwgYSBudW1iZXIgb3IgbnVsbCkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGA8IS0tICR7dm5vZGUuaWR9IC0tPiR7dm5vZGUudGV4dENvbnRlbnR9PCEtLSAvbmVvLXZ0ZXh0IC0tPmBcbiAgICAgICAgICAgIGNhc2UgJ3Zub2RlJzpcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUubm9kZU5hbWUgPT09ICdmcmFnbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA8IS0tICR7dm5vZGUuaWR9LXN0YXJ0IC0tPmAgKyBtZS5jcmVhdGVUYWdDb250ZW50KHZub2RlLCBtb3ZlZE5vZGVzLCBwb3N0TW91bnRVcGRhdGVzKSArIGA8IS0tICR7dm5vZGUuaWR9LWVuZCAtLT5gXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnNjcm9sbFRvcCB8fCB2bm9kZS5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGUgPSB7aWR9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2bm9kZS5zY3JvbGxMZWZ0KSB7dXBkYXRlLnNjcm9sbExlZnQgPSB2bm9kZS5zY3JvbGxMZWZ0fVxuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuc2Nyb2xsVG9wKSAge3VwZGF0ZS5zY3JvbGxUb3AgID0gdm5vZGUuc2Nyb2xsVG9wfVxuXG4gICAgICAgICAgICAgICAgICAgIHBvc3RNb3VudFVwZGF0ZXMucHVzaCh1cGRhdGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLmNyZWF0ZU9wZW5UYWcodm5vZGUpICsgbWUuY3JlYXRlVGFnQ29udGVudCh2bm9kZSwgbW92ZWROb2RlcywgcG9zdE1vdW50VXBkYXRlcykgKyBtZS5jcmVhdGVDbG9zZVRhZyh2bm9kZSlcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgaW5uZXIgSFRNTCBjb250ZW50IGZvciBhIFZOb2RlIHRhZy5cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZVxuICAgICAqIEBwYXJhbSB7TWFwfSAgICAgICAgICAgIFttb3ZlZE5vZGVzXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgICAgIFtwb3N0TW91bnRVcGRhdGVzXVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZVRhZ0NvbnRlbnQodm5vZGUsIG1vdmVkTm9kZXMsIHBvc3RNb3VudFVwZGF0ZXMpIHtcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHZub2RlLmlubmVySFRNTCB8fCB2bm9kZS50ZXh0Q29udGVudDtcblxuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc0NvbnRlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIGxlbiAgICA9IHZub2RlLmNoaWxkTm9kZXMgPyB2bm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IHZub2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5jcmVhdGUoY2hpbGROb2RlLCBtb3ZlZE5vZGVzLCBwb3N0TW91bnRVcGRhdGVzKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cbn07XG5cbmNvbnN0IG5zID0gTmVvLm5zKCdOZW8udmRvbS51dGlsJywgdHJ1ZSk7XG5ucy5TdHJpbmdGcm9tVm5vZGUgPSBTdHJpbmdGcm9tVm5vZGU7XG5cbmV4cG9ydCBkZWZhdWx0IFN0cmluZ0Zyb21Wbm9kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=