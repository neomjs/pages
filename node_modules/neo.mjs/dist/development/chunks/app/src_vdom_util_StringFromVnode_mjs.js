"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_vdom_util_StringFromVnode_mjs"],{

/***/ "./src/vdom/util/StringFromVnode.mjs"
/*!*******************************************!*\
  !*** ./src/vdom/util/StringFromVnode.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domConstants.mjs */ "./src/vdom/domConstants.mjs");



/**
 * @summary Utility to convert VNode trees into HTML strings.
 *
 * This singleton provides the core logic for the string-based rendering path. It traverses
 * a VNode tree and generates the corresponding `outerHTML` string. This is used when the
 * `Neo.config.useDomApiRenderer` is set to false, or for server-side rendering (SSR) scenarios.
 *
 * In addition to string generation, it acts as a visitor to collect nodes that require
 * special handling after being mounted to the DOM (e.g., restoring scroll state), as these
 * properties cannot be set via HTML attributes.
 *
 * @class Neo.vdom.util.StringFromVnode
 * @singleton
 */
const StringFromVnode = {
    /**
     * @param {Object} vnode
     * @returns {String}
     * @protected
     */
    createCloseTag(vnode) {
        return _domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__.voidElements.has(vnode.nodeName) ? '' : '</' + vnode.nodeName + '>'
    },

    /**
     * @param {Object} vnode
     * @returns {String}
     * @protected
     */
    createOpenTag(vnode) {
        let string       = '<' + vnode.nodeName,
            {attributes} = vnode,
            cls          = vnode.className,
            style;

        if (vnode.style) {
            style = Neo.createStyles(vnode.style);

            if (style !== '') {
                string += ` style="${style}"`
            }
        }

        if (cls) {
            if (Array.isArray(cls)) {
                cls = cls.join(' ')
            }

            if (cls !== '') {
                string += ` class="${cls}"`
            }
        }

        if (vnode.id) {
            if (Neo.config.useDomIds) {
                string += ` id="${vnode.id}"`
            } else {
                string += ` data-neo-id="${vnode.id}"`
            }
        }

        Object.entries(attributes).forEach(([key, value]) => {
            if (_domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__.voidAttributes.has(key)) {
                if (value === 'true') { // vnode attribute values get converted into strings
                    string += ` ${key}`
                }
            } else if (key !== 'removeDom') {
                if (key === 'value') {
                    value = _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].escapeHtml(value)
                }

                string += ` ${key}="${value?.replaceAll?.('"', '&quot;') ?? value}"`
            }
        });

        return string + '>'
    },

    /**
     * Creates an HTML string from a VNode tree.
     * Skips nodes present in the optional movedNodes map.
     *
     * Uses a visitor pattern to collect `postMountUpdates`:
     * As it traverses the tree to build the string, it identifies nodes with properties
     * that cannot be represented in HTML (like `scrollTop` and `scrollLeft`).
     * These are pushed into the passed `postMountUpdates` array, allowing the main thread
     * renderer to apply them after the HTML has been inserted into the document.
     *
     * @param {Neo.vdom.VNode} vnode
     * @param {Map}            [movedNodes]
     * @param {Object[]}       [postMountUpdates=[]]
     * @returns {String}
     */
    create(vnode, movedNodes, postMountUpdates=[]) {
        let me = this,
            id = vnode?.id;

        // If a content node will get moved by a delta update OP, there is no need to regenerate it. Opt out.
        if (id && movedNodes?.get(id)) {
            return ''
        }

        switch (vnode.vtype) {
            case 'root':
                return me.create(vnode.childNodes[0], movedNodes, postMountUpdates)
            case 'text':
                // For text VNodes, `vnode.textContent` holds the HTML-escaped content.
                // Add the comment wrappers here for string output, aligning with main.mixin.DeltaUpdates.createDomTree().
                // `vnode.textContent || ''` ensures robustness in case vnode.textContent is not a string (e.g., a number or null).
                return `<!-- ${vnode.id} -->${vnode.textContent}<!-- /neo-vtext -->`
            case 'vnode':
                if (vnode.scrollTop || vnode.scrollLeft) {
                    let update = {id};

                    if (vnode.scrollLeft) {update.scrollLeft = vnode.scrollLeft}
                    if (vnode.scrollTop)  {update.scrollTop  = vnode.scrollTop}

                    postMountUpdates.push(update)
                }

                return me.createOpenTag(vnode) + me.createTagContent(vnode, movedNodes, postMountUpdates) + me.createCloseTag(vnode)
            default:
                return ''
        }
    },

    /**
     * Creates the inner HTML content for a VNode tag.
     * @param {Neo.vdom.VNode} vnode
     * @param {Map}            [movedNodes]
     * @param {Object[]}       [postMountUpdates]
     * @returns {String}
     * @protected
     */
    createTagContent(vnode, movedNodes, postMountUpdates) {
        const hasContent = vnode.innerHTML || vnode.textContent;

        if (hasContent) {
            return hasContent
        }

        let string = '',
            len    = vnode.childNodes ? vnode.childNodes.length : 0,
            i      = 0,
            childNode;

        for (; i < len; i++) {
            childNode = vnode.childNodes[i];
            string += this.create(childNode, movedNodes, postMountUpdates)
        }

        return string
    }
};

const ns = Neo.ns('Neo.vdom.util', true);
ns.StringFromVnode = StringFromVnode;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringFromVnode);


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfdmRvbV91dGlsX1N0cmluZ0Zyb21Wbm9kZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ0Y7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFZO0FBQzNCLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQyxjQUFjO0FBQ2QsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiw2REFBYztBQUM5Qix3Q0FBd0M7QUFDeEMsa0NBQWtDLElBQUk7QUFDdEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0QkFBNEIsd0RBQVM7QUFDckM7O0FBRUEsOEJBQThCLElBQUksSUFBSSxnQ0FBZ0MsWUFBWTtBQUNsRjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVUsS0FBSyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEMsMkNBQTJDO0FBQzNDLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxlQUFlLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3Zkb20vdXRpbC9TdHJpbmdGcm9tVm5vZGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBOZW9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9TdHJpbmcubWpzJztcbmltcG9ydCB7dm9pZEF0dHJpYnV0ZXMsIHZvaWRFbGVtZW50c30gZnJvbSAnLi4vZG9tQ29uc3RhbnRzLm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgVXRpbGl0eSB0byBjb252ZXJ0IFZOb2RlIHRyZWVzIGludG8gSFRNTCBzdHJpbmdzLlxuICpcbiAqIFRoaXMgc2luZ2xldG9uIHByb3ZpZGVzIHRoZSBjb3JlIGxvZ2ljIGZvciB0aGUgc3RyaW5nLWJhc2VkIHJlbmRlcmluZyBwYXRoLiBJdCB0cmF2ZXJzZXNcbiAqIGEgVk5vZGUgdHJlZSBhbmQgZ2VuZXJhdGVzIHRoZSBjb3JyZXNwb25kaW5nIGBvdXRlckhUTUxgIHN0cmluZy4gVGhpcyBpcyB1c2VkIHdoZW4gdGhlXG4gKiBgTmVvLmNvbmZpZy51c2VEb21BcGlSZW5kZXJlcmAgaXMgc2V0IHRvIGZhbHNlLCBvciBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nIChTU1IpIHNjZW5hcmlvcy5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBzdHJpbmcgZ2VuZXJhdGlvbiwgaXQgYWN0cyBhcyBhIHZpc2l0b3IgdG8gY29sbGVjdCBub2RlcyB0aGF0IHJlcXVpcmVcbiAqIHNwZWNpYWwgaGFuZGxpbmcgYWZ0ZXIgYmVpbmcgbW91bnRlZCB0byB0aGUgRE9NIChlLmcuLCByZXN0b3Jpbmcgc2Nyb2xsIHN0YXRlKSwgYXMgdGhlc2VcbiAqIHByb3BlcnRpZXMgY2Fubm90IGJlIHNldCB2aWEgSFRNTCBhdHRyaWJ1dGVzLlxuICpcbiAqIEBjbGFzcyBOZW8udmRvbS51dGlsLlN0cmluZ0Zyb21Wbm9kZVxuICogQHNpbmdsZXRvblxuICovXG5jb25zdCBTdHJpbmdGcm9tVm5vZGUgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2xvc2VUYWcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHZvaWRFbGVtZW50cy5oYXModm5vZGUubm9kZU5hbWUpID8gJycgOiAnPC8nICsgdm5vZGUubm9kZU5hbWUgKyAnPidcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlT3BlblRhZyh2bm9kZSkge1xuICAgICAgICBsZXQgc3RyaW5nICAgICAgID0gJzwnICsgdm5vZGUubm9kZU5hbWUsXG4gICAgICAgICAgICB7YXR0cmlidXRlc30gPSB2bm9kZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgICA9IHZub2RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlO1xuXG4gICAgICAgIGlmICh2bm9kZS5zdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUgPSBOZW8uY3JlYXRlU3R5bGVzKHZub2RlLnN0eWxlKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBgIHN0eWxlPVwiJHtzdHlsZX1cImBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNscykpIHtcbiAgICAgICAgICAgICAgICBjbHMgPSBjbHMuam9pbignICcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjbHMgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGAgY2xhc3M9XCIke2Nsc31cImBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2bm9kZS5pZCkge1xuICAgICAgICAgICAgaWYgKE5lby5jb25maWcudXNlRG9tSWRzKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGAgaWQ9XCIke3Zub2RlLmlkfVwiYFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gYCBkYXRhLW5lby1pZD1cIiR7dm5vZGUuaWR9XCJgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2b2lkQXR0cmlidXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7IC8vIHZub2RlIGF0dHJpYnV0ZSB2YWx1ZXMgZ2V0IGNvbnZlcnRlZCBpbnRvIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGAgJHtrZXl9YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBOZW9TdHJpbmcuZXNjYXBlSHRtbCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gYCAke2tleX09XCIke3ZhbHVlPy5yZXBsYWNlQWxsPy4oJ1wiJywgJyZxdW90OycpID8/IHZhbHVlfVwiYFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RyaW5nICsgJz4nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gSFRNTCBzdHJpbmcgZnJvbSBhIFZOb2RlIHRyZWUuXG4gICAgICogU2tpcHMgbm9kZXMgcHJlc2VudCBpbiB0aGUgb3B0aW9uYWwgbW92ZWROb2RlcyBtYXAuXG4gICAgICpcbiAgICAgKiBVc2VzIGEgdmlzaXRvciBwYXR0ZXJuIHRvIGNvbGxlY3QgYHBvc3RNb3VudFVwZGF0ZXNgOlxuICAgICAqIEFzIGl0IHRyYXZlcnNlcyB0aGUgdHJlZSB0byBidWlsZCB0aGUgc3RyaW5nLCBpdCBpZGVudGlmaWVzIG5vZGVzIHdpdGggcHJvcGVydGllc1xuICAgICAqIHRoYXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEhUTUwgKGxpa2UgYHNjcm9sbFRvcGAgYW5kIGBzY3JvbGxMZWZ0YCkuXG4gICAgICogVGhlc2UgYXJlIHB1c2hlZCBpbnRvIHRoZSBwYXNzZWQgYHBvc3RNb3VudFVwZGF0ZXNgIGFycmF5LCBhbGxvd2luZyB0aGUgbWFpbiB0aHJlYWRcbiAgICAgKiByZW5kZXJlciB0byBhcHBseSB0aGVtIGFmdGVyIHRoZSBIVE1MIGhhcyBiZWVuIGluc2VydGVkIGludG8gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBbbW92ZWROb2Rlc11cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSAgICAgICBbcG9zdE1vdW50VXBkYXRlcz1bXV1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZSh2bm9kZSwgbW92ZWROb2RlcywgcG9zdE1vdW50VXBkYXRlcz1bXSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaWQgPSB2bm9kZT8uaWQ7XG5cbiAgICAgICAgLy8gSWYgYSBjb250ZW50IG5vZGUgd2lsbCBnZXQgbW92ZWQgYnkgYSBkZWx0YSB1cGRhdGUgT1AsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVnZW5lcmF0ZSBpdC4gT3B0IG91dC5cbiAgICAgICAgaWYgKGlkICYmIG1vdmVkTm9kZXM/LmdldChpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh2bm9kZS52dHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLmNyZWF0ZSh2bm9kZS5jaGlsZE5vZGVzWzBdLCBtb3ZlZE5vZGVzLCBwb3N0TW91bnRVcGRhdGVzKVxuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgLy8gRm9yIHRleHQgVk5vZGVzLCBgdm5vZGUudGV4dENvbnRlbnRgIGhvbGRzIHRoZSBIVE1MLWVzY2FwZWQgY29udGVudC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbW1lbnQgd3JhcHBlcnMgaGVyZSBmb3Igc3RyaW5nIG91dHB1dCwgYWxpZ25pbmcgd2l0aCBtYWluLm1peGluLkRlbHRhVXBkYXRlcy5jcmVhdGVEb21UcmVlKCkuXG4gICAgICAgICAgICAgICAgLy8gYHZub2RlLnRleHRDb250ZW50IHx8ICcnYCBlbnN1cmVzIHJvYnVzdG5lc3MgaW4gY2FzZSB2bm9kZS50ZXh0Q29udGVudCBpcyBub3QgYSBzdHJpbmcgKGUuZy4sIGEgbnVtYmVyIG9yIG51bGwpLlxuICAgICAgICAgICAgICAgIHJldHVybiBgPCEtLSAke3Zub2RlLmlkfSAtLT4ke3Zub2RlLnRleHRDb250ZW50fTwhLS0gL25lby12dGV4dCAtLT5gXG4gICAgICAgICAgICBjYXNlICd2bm9kZSc6XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnNjcm9sbFRvcCB8fCB2bm9kZS5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGUgPSB7aWR9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2bm9kZS5zY3JvbGxMZWZ0KSB7dXBkYXRlLnNjcm9sbExlZnQgPSB2bm9kZS5zY3JvbGxMZWZ0fVxuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuc2Nyb2xsVG9wKSAge3VwZGF0ZS5zY3JvbGxUb3AgID0gdm5vZGUuc2Nyb2xsVG9wfVxuXG4gICAgICAgICAgICAgICAgICAgIHBvc3RNb3VudFVwZGF0ZXMucHVzaCh1cGRhdGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLmNyZWF0ZU9wZW5UYWcodm5vZGUpICsgbWUuY3JlYXRlVGFnQ29udGVudCh2bm9kZSwgbW92ZWROb2RlcywgcG9zdE1vdW50VXBkYXRlcykgKyBtZS5jcmVhdGVDbG9zZVRhZyh2bm9kZSlcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgaW5uZXIgSFRNTCBjb250ZW50IGZvciBhIFZOb2RlIHRhZy5cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZVxuICAgICAqIEBwYXJhbSB7TWFwfSAgICAgICAgICAgIFttb3ZlZE5vZGVzXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgICAgIFtwb3N0TW91bnRVcGRhdGVzXVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZVRhZ0NvbnRlbnQodm5vZGUsIG1vdmVkTm9kZXMsIHBvc3RNb3VudFVwZGF0ZXMpIHtcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHZub2RlLmlubmVySFRNTCB8fCB2bm9kZS50ZXh0Q29udGVudDtcblxuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc0NvbnRlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIGxlbiAgICA9IHZub2RlLmNoaWxkTm9kZXMgPyB2bm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgY2hpbGROb2RlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IHZub2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5jcmVhdGUoY2hpbGROb2RlLCBtb3ZlZE5vZGVzLCBwb3N0TW91bnRVcGRhdGVzKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cbn07XG5cbmNvbnN0IG5zID0gTmVvLm5zKCdOZW8udmRvbS51dGlsJywgdHJ1ZSk7XG5ucy5TdHJpbmdGcm9tVm5vZGUgPSBTdHJpbmdGcm9tVm5vZGU7XG5cbmV4cG9ydCBkZWZhdWx0IFN0cmluZ0Zyb21Wbm9kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=