"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_vdom_util_StringFromVnode_mjs"],{

/***/ "./src/vdom/util/StringFromVnode.mjs":
/*!*******************************************!*\
  !*** ./src/vdom/util/StringFromVnode.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/String.mjs */ "./src/util/String.mjs");
/* harmony import */ var _domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domConstants.mjs */ "./src/vdom/domConstants.mjs");



const StringFromVnode = {
    /**
     * @param {Object} vnode
     * @protected
     */
    createCloseTag(vnode) {
        return _domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__.voidElements.has(vnode.nodeName) ? '' : '</' + vnode.nodeName + '>'
    },

    /**
     * @param {Object} vnode
     * @protected
     */
    createOpenTag(vnode) {
        let string       = '<' + vnode.nodeName,
            {attributes} = vnode,
            cls          = vnode.className,
            style;

        if (vnode.style) {
            style = Neo.createStyles(vnode.style);

            if (style !== '') {
                string += ` style="${style}"`
            }
        }

        if (cls) {
            if (Array.isArray(cls)) {
                cls = cls.join(' ')
            }

            if (cls !== '') {
                string += ` class="${cls}"`
            }
        }

        if (vnode.id) {
            if (Neo.config.useDomIds) {
                string += ` id="${vnode.id}"`
            } else {
                string += ` data-neo-id="${vnode.id}"`
            }
        }

        Object.entries(attributes).forEach(([key, value]) => {
            if (_domConstants_mjs__WEBPACK_IMPORTED_MODULE_1__.voidAttributes.has(key)) {
                if (value === 'true') { // vnode attribute values get converted into strings
                    string += ` ${key}`
                }
            } else if (key !== 'removeDom') {
                if (key === 'value') {
                    value = _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].escapeHtml(value)
                }

                string += ` ${key}="${value?.replaceAll?.('"', '&quot;') ?? value}"`
            }
        });

        return string + '>'
    },

    /**
     * @param {Neo.vdom.VNode} vnode
     * @param {Map}            [movedNodes]
     */
    create(vnode, movedNodes) {
        let me = this,
            id = vnode?.id;

        // If a content node will get moved by a delta update OP, there is no need to regenerate it. Opt out.
        if (id && movedNodes?.get(id)) {
            return ''
        }

        switch (vnode.vtype) {
            case 'root':
                return me.create(vnode.childNodes[0], movedNodes)
            case 'text':
                // For text VNodes, `vnode.textContent` holds the HTML-escaped content.
                // Add the comment wrappers here for string output, aligning with main.mixin.DeltaUpdates.createDomTree().
                // `vnode.textContent || ''` ensures robustness in case vnode.textContent is not a string (e.g., a number or null).
                return `<!-- ${vnode.id} -->${vnode.textContent}<!-- /neo-vtext -->`
            case 'vnode':
                return me.createOpenTag(vnode) + me.createTagContent(vnode, movedNodes) + me.createCloseTag(vnode)
            default:
                return ''
        }
    },

    /**
     * @param {Neo.vdom.VNode} vnode
     * @param {Map}            [movedNodes]
     * @protected
     */
    createTagContent(vnode, movedNodes) {
        const hasContent = vnode.innerHTML || vnode.textContent;

        if (hasContent) {
            return hasContent
        }

        let string = '',
            len    = vnode.childNodes ? vnode.childNodes.length : 0,
            i      = 0,
            childNode;

        for (; i < len; i++) {
            childNode = vnode.childNodes[i];
            string += this.create(childNode, movedNodes)
        }

        return string
    }
};

const ns = Neo.ns('Neo.vdom.util', true);
ns.StringFromVnode = StringFromVnode;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringFromVnode);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfdmRvbV91dGlsX1N0cmluZ0Zyb21Wbm9kZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ0Y7O0FBRWpFO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBWTtBQUMzQixLQUFLOztBQUVMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQyxjQUFjO0FBQ2QsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiw2REFBYztBQUM5Qix3Q0FBd0M7QUFDeEMsa0NBQWtDLElBQUk7QUFDdEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0QkFBNEIsd0RBQVM7QUFDckM7O0FBRUEsOEJBQThCLElBQUksSUFBSSxnQ0FBZ0MsWUFBWTtBQUNsRjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVSxLQUFLLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLGVBQWUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvdmRvbS91dGlsL1N0cmluZ0Zyb21Wbm9kZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5lb1N0cmluZyAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi91dGlsL1N0cmluZy5tanMnO1xuaW1wb3J0IHt2b2lkQXR0cmlidXRlcywgdm9pZEVsZW1lbnRzfSBmcm9tICcuLi9kb21Db25zdGFudHMubWpzJztcblxuY29uc3QgU3RyaW5nRnJvbVZub2RlID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDbG9zZVRhZyh2bm9kZSkge1xuICAgICAgICByZXR1cm4gdm9pZEVsZW1lbnRzLmhhcyh2bm9kZS5ub2RlTmFtZSkgPyAnJyA6ICc8LycgKyB2bm9kZS5ub2RlTmFtZSArICc+J1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlT3BlblRhZyh2bm9kZSkge1xuICAgICAgICBsZXQgc3RyaW5nICAgICAgID0gJzwnICsgdm5vZGUubm9kZU5hbWUsXG4gICAgICAgICAgICB7YXR0cmlidXRlc30gPSB2bm9kZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgICA9IHZub2RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlO1xuXG4gICAgICAgIGlmICh2bm9kZS5zdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUgPSBOZW8uY3JlYXRlU3R5bGVzKHZub2RlLnN0eWxlKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBgIHN0eWxlPVwiJHtzdHlsZX1cImBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNscykpIHtcbiAgICAgICAgICAgICAgICBjbHMgPSBjbHMuam9pbignICcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjbHMgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGAgY2xhc3M9XCIke2Nsc31cImBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2bm9kZS5pZCkge1xuICAgICAgICAgICAgaWYgKE5lby5jb25maWcudXNlRG9tSWRzKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGAgaWQ9XCIke3Zub2RlLmlkfVwiYFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gYCBkYXRhLW5lby1pZD1cIiR7dm5vZGUuaWR9XCJgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2b2lkQXR0cmlidXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7IC8vIHZub2RlIGF0dHJpYnV0ZSB2YWx1ZXMgZ2V0IGNvbnZlcnRlZCBpbnRvIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGAgJHtrZXl9YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBOZW9TdHJpbmcuZXNjYXBlSHRtbCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gYCAke2tleX09XCIke3ZhbHVlPy5yZXBsYWNlQWxsPy4oJ1wiJywgJyZxdW90OycpID8/IHZhbHVlfVwiYFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RyaW5nICsgJz4nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IHZub2RlXG4gICAgICogQHBhcmFtIHtNYXB9ICAgICAgICAgICAgW21vdmVkTm9kZXNdXG4gICAgICovXG4gICAgY3JlYXRlKHZub2RlLCBtb3ZlZE5vZGVzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpZCA9IHZub2RlPy5pZDtcblxuICAgICAgICAvLyBJZiBhIGNvbnRlbnQgbm9kZSB3aWxsIGdldCBtb3ZlZCBieSBhIGRlbHRhIHVwZGF0ZSBPUCwgdGhlcmUgaXMgbm8gbmVlZCB0byByZWdlbmVyYXRlIGl0LiBPcHQgb3V0LlxuICAgICAgICBpZiAoaWQgJiYgbW92ZWROb2Rlcz8uZ2V0KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHZub2RlLnZ0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUuY3JlYXRlKHZub2RlLmNoaWxkTm9kZXNbMF0sIG1vdmVkTm9kZXMpXG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dCBWTm9kZXMsIGB2bm9kZS50ZXh0Q29udGVudGAgaG9sZHMgdGhlIEhUTUwtZXNjYXBlZCBjb250ZW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29tbWVudCB3cmFwcGVycyBoZXJlIGZvciBzdHJpbmcgb3V0cHV0LCBhbGlnbmluZyB3aXRoIG1haW4ubWl4aW4uRGVsdGFVcGRhdGVzLmNyZWF0ZURvbVRyZWUoKS5cbiAgICAgICAgICAgICAgICAvLyBgdm5vZGUudGV4dENvbnRlbnQgfHwgJydgIGVuc3VyZXMgcm9idXN0bmVzcyBpbiBjYXNlIHZub2RlLnRleHRDb250ZW50IGlzIG5vdCBhIHN0cmluZyAoZS5nLiwgYSBudW1iZXIgb3IgbnVsbCkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGA8IS0tICR7dm5vZGUuaWR9IC0tPiR7dm5vZGUudGV4dENvbnRlbnR9PCEtLSAvbmVvLXZ0ZXh0IC0tPmBcbiAgICAgICAgICAgIGNhc2UgJ3Zub2RlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWUuY3JlYXRlT3BlblRhZyh2bm9kZSkgKyBtZS5jcmVhdGVUYWdDb250ZW50KHZub2RlLCBtb3ZlZE5vZGVzKSArIG1lLmNyZWF0ZUNsb3NlVGFnKHZub2RlKVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZVxuICAgICAqIEBwYXJhbSB7TWFwfSAgICAgICAgICAgIFttb3ZlZE5vZGVzXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVUYWdDb250ZW50KHZub2RlLCBtb3ZlZE5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnQgPSB2bm9kZS5pbm5lckhUTUwgfHwgdm5vZGUudGV4dENvbnRlbnQ7XG5cbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNDb250ZW50XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyaW5nID0gJycsXG4gICAgICAgICAgICBsZW4gICAgPSB2bm9kZS5jaGlsZE5vZGVzID8gdm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggOiAwLFxuICAgICAgICAgICAgaSAgICAgID0gMCxcbiAgICAgICAgICAgIGNoaWxkTm9kZTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSB2bm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgc3RyaW5nICs9IHRoaXMuY3JlYXRlKGNoaWxkTm9kZSwgbW92ZWROb2RlcylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJpbmdcbiAgICB9XG59O1xuXG5jb25zdCBucyA9IE5lby5ucygnTmVvLnZkb20udXRpbCcsIHRydWUpO1xubnMuU3RyaW5nRnJvbVZub2RlID0gU3RyaW5nRnJvbVZub2RlO1xuXG5leHBvcnQgZGVmYXVsdCBTdHJpbmdGcm9tVm5vZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=