export const __webpack_esm_id__ = "vendors-src_app_header_Toolbar_mjs-src_container_Viewport_mjs";
export const __webpack_esm_ids__ = ["vendors-src_app_header_Toolbar_mjs-src_container_Viewport_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/app/SharedCanvas.mjs"
/*!**********************************!*\
  !*** ./src/app/SharedCanvas.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Canvas.mjs */ "./src/component/Canvas.mjs");


/**
 * @summary Abstract base class for SharedWorker Canvas components.
 *
 * This class abstracts the common logic for connecting an App Worker component to a
 * SharedWorker canvas renderer. It handles:
 * 1.  **Lifecycle**: Initializing the graph when offscreen canvas is ready.
 * 2.  **Sizing**: Syncing DOM size to the worker via ResizeObserver.
 * 3.  **Interaction**: Bridging mouse events (move, click, leave) to the worker.
 * 4.  **Theming**: Syncing the component's theme to the worker.
 *
 * Subclasses must define:
 * - `rendererClassName`: String name of the SharedWorker singleton (e.g. 'Neo.canvas.Header')
 * - `rendererImportPath`: Import path for the renderer module (e.g. 'src/canvas/Header.mjs')
 *
 * @class Neo.app.SharedCanvas
 * @extends Neo.component.Canvas
 */
class SharedCanvas extends _component_Canvas_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.app.SharedCanvas'
         * @protected
         */
        className: 'Neo.app.SharedCanvas',
        /**
         * @member {Boolean} isCanvasReady_=false
         */
        isCanvasReady_: false,
        /**
         * The full class name of the SharedWorker singleton.
         * @member {String|null} rendererClassName=null
         */
        rendererClassName: null,
        /**
         * The import path for the renderer module.
         * @member {String|null} rendererImportPath=null
         */
        rendererImportPath: null,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {tag: 'canvas'}
    }

    /**
     * @member {String|null} canvasId=null
     */
    canvasId = null
    /**
     * @member {Object|null} canvasRect=null
     */
    canvasRect = null

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetIsCanvasReady(value, oldValue) {
        if (value) {
            let mode = this.theme?.includes('dark') ? 'dark' : 'light';
            this.renderer?.setTheme(mode);
            this.fire('canvasReady')
        }
    }

    /**
     * Lifecycle hook triggered when the mounted config gets changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        let me = this;

        if (value) {
            await me.ready()
        } else if (me.offscreenRegistered) {
            me.renderer?.clearGraph()
        }

        super.afterSetMounted(value, oldValue)
    }

    /**
     * Lifecycle hook triggered when the canvas is registered offscreen.
     * Initializes the Shared Worker graph and sets up resize observation.
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetOffscreenRegistered(value, oldValue) {
        let me = this;

        if (value) {
            await me.ready();

            if (!me.rendererClassName) {
                throw new Error('Canvas component missing rendererClassName config')
            }

            await me.renderer.initGraph({canvasId: me.getCanvasId(), windowId: me.windowId});

            me.isCanvasReady = true;

            await me.updateSize()
        } else if (oldValue) {
            me.isCanvasReady = false;
            await me.renderer.clearGraph()
        }
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        if (value && this.isCanvasReady) {
            let mode = value.includes('dark') ? 'dark' : 'light';
            this.renderer.setTheme(mode)
        }
    }

    /**
     * @returns {String}
     */
    getCanvasId() {
        let me = this;

        if (!me.canvasId) {
            me.canvasId = me.id
        }

        return me.canvasId
    }

    /**
     * Resolves the SharedWorker singleton instance from the rendererClassName config.
     * @returns {Object} The renderer singleton
     */
    get renderer() {
        return this.rendererClassName ? Neo.ns(this.rendererClassName) : null
    }

    /**
     * @param {...*} args
     */
    destroy(...args) {
        this.renderer?.clearGraph();
        super.destroy(...args)
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        let me = this;

        if (me.rendererImportPath) {
             // Ensure Canvas Worker is running
            await Neo.worker.Manager.startWorker({
                name    : 'canvas',
                windowId: me.windowId
            });

            // Wait for the Canvas Worker remote to be available.
            let i = 0;

            while (!Neo.ns('Neo.worker.Canvas.loadModule') && i < 40) {
                await me.timeout(50);
                i++
            }

            if (Neo.ns('Neo.worker.Canvas.loadModule')) {
                // Load the specific renderer module for this component
                await Neo.worker.Canvas.loadModule({
                    path: me.rendererImportPath
                });

                // Wait for the remote stub to be created
                let j = 0;
                while (!me.renderer && j < 40) {
                    await me.timeout(50);
                    j++
                }

                if (!me.renderer) {
                     console.error('Renderer Remote Stub not found:', me.rendererClassName)
                }
            } else {
                console.error('Neo.component.CanvasShared: Canvas Worker failed to register remote methods.')
            }
        }
    }

    /**
     * Forwards click events to the Shared Worker.
     * @param {Object} data
     */
    onClick(data) {
        let me = this;

        if (me.isCanvasReady && me.canvasRect) {
            me.renderer.updateMouseState({
                click: true,
                x    : data.clientX - me.canvasRect.left,
                y    : data.clientY - me.canvasRect.top
            })
        }
    }

    /**
     * Pauses the Shared Worker render loop.
     */
    pause() {
        if (this.isCanvasReady) {
            this.renderer.pause()
        }
    }

    /**
     * Resets the mouse state in the Shared Worker when the cursor leaves the canvas.
     * @param {Object} data
     */
    onMouseLeave(data) {
        if (this.isCanvasReady) {
            this.renderer.updateMouseState({leave: true})
        }
    }

    /**
     * Forwards mouse coordinates to the Shared Worker.
     * @param {Object} data
     */
    onMouseMove(data) {
        let me = this;

        if (me.isCanvasReady) {
            if (me.canvasRect) {
                me.renderer.updateMouseState({
                    x: data.clientX - me.canvasRect.left,
                    y: data.clientY - me.canvasRect.top
                })
            }
        }
    }

    /**
     * Updates the canvas size in the Shared Worker when the DOM element resizes.
     * @param {Object} data
     */
    async onDomResize(data) {
        super.onDomResize(data);
        await this.updateSize(data.contentRect)
    }

    /**
     * Resumes the Shared Worker render loop.
     */
    resume() {
        if (this.isCanvasReady) {
            this.renderer.resume()
        }
    }

    /**
     * Pushes the new dimensions to the Shared Worker and caches the bounding rect.
     * @param {Object|null} [rect]
     */
    async updateSize(rect) {
        let me = this;

        await me.ready();

        if (!rect || rect.width === 0 || rect.height === 0) {
            rect = await me.getDomRect(me.id)
        }

        if (rect) {
            me.canvasRect = rect;
            await me.renderer?.updateSize({width: rect.width, height: rect.height})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SharedCanvas));


/***/ },

/***/ "./src/app/header/Canvas.mjs"
/*!***********************************!*\
  !*** ./src/app/header/Canvas.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _SharedCanvas_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../SharedCanvas.mjs */ "./src/app/SharedCanvas.mjs");



/**
 * @summary The App Worker component for the HeaderToolbar canvas overlay.
 *
 * This component coordinates the OffscreenCanvas transfer and lifecycle management.
 * It serves as the App Worker's handle for the visual effect, responsible for:
 *
 * 1. **Lifecycle Management:** Instantiating and destroying the rendering graph in the `Canvas SharedWorker`.
 * 2. **DOM Synchronization:** Tracking the size/position of the canvas and navigation buttons, forwarding these to the renderer.
 * 3. **Input Bridging:** Capturing user interactions (mouse move, click) and forwarding coordinates to the renderer.
 *
 * The actual rendering loop and physics simulation happen in `Neo.canvas.Header` (SharedWorker),
 * ensuring the main thread and App Worker remain unblocked.
 *
 * @class Neo.app.header.Canvas
 * @extends Neo.app.SharedCanvas
 * @see Neo.canvas.Header
 */
class Canvas extends _SharedCanvas_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.app.header.Canvas'
         * @protected
         */
        className: 'Neo.app.header.Canvas',
        /**
         * @member {String|null} activeId_=null
         * @reactive
         */
        activeId_: null,
        /**
         * @member {String[]} cls=['app-header-canvas']
         */
        cls: ['app-header-canvas'],
        /**
         * @member {String|null} hoverId_=null
         * @reactive
         */
        hoverId_: null,
        /**
         * @member {String} rendererClassName='Neo.canvas.Header'
         */
        rendererClassName: 'Neo.canvas.Header',
        /**
         * @member {String} rendererImportPath='src/canvas/Header.mjs'
         */
        rendererImportPath: 'src/canvas/Header.mjs'
    }

    /**
     * @member {Object[]} navRects=null
     */
    navRects = null

    /**
     * @member {Number|null} navRectsTimeoutId=null
     */
    navRectsTimeoutId = null

    /**
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetIsCanvasReady(value, oldValue) {
        super.afterSetIsCanvasReady(value, oldValue);

        let me = this;

        if (value && me.activeId) {
            me.renderer.updateActiveId({id: me.activeId})
        }
    }

    /**
     * Lifecycle hook triggered when the canvas is registered offscreen.
     * Initializes the Shared Worker graph and sets up resize observation.
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetOffscreenRegistered(value, oldValue) {
        await super.afterSetOffscreenRegistered(value, oldValue);

        let me = this;

        if (value) {
            let parent  = Neo.get(me.parentId),
                buttons = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].down(parent, 'button', false);

            buttons.forEach(button => {
                button.addDomListeners({
                    resize: me.onButtonResize,
                    scope : me
                })
            });

            await me.updateNavRects()
        }
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    async afterSetActiveId(value, oldValue) {
        if (this.isCanvasReady) {
            await this.renderer.updateActiveId({id: value})
        }
    }

    /**
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    async afterSetHoverId(value, oldValue) {
        if (this.isCanvasReady) {
            await this.renderer.updateHoverId({id: value})
        }
    }

    /**
     * @returns {String}
     */
    getMonitorTargetId() {
        return this.parentId
    }

    /**
     * @param {Object} data
     */
    onButtonResize(data) {
        this.updateNavRects()
    }

    /**
     * Updates the canvas size and re-calculates navigation rects on resize.
     * @param {Object} data
     */
    async onDomResize(data) {
        this.fire('resize', data);
        await this.updateNavRects()
    }

    /**
     * @member {Boolean} isUpdatingNavRects=false
     * @protected
     */
    isUpdatingNavRects = false
    /**
     * @member {Boolean} pendingNavRectsUpdate=false
     * @protected
     */
    pendingNavRectsUpdate = false

    /**
     * Synchronizes the positions of the navigation buttons with the Shared Worker.
     * This allows the physics engine to "divert" the energy streams around the buttons.
     *
     * @param {Boolean} [isFallback=false]
     * @returns {Promise<void>}
     */
    async updateNavRects(isFallback=false) {
        let me = this;

        if (!me.isCanvasReady) return;

        if (!isFallback) {
            if (me.navRectsTimeoutId) {
                clearTimeout(me.navRectsTimeoutId)
            }

            me.navRectsTimeoutId = setTimeout(() => {
                me.navRectsTimeoutId = null;
                me.updateNavRects(true)
            }, 1000)
        }

        if (me.isUpdatingNavRects) {
            me.pendingNavRectsUpdate = true;
            return
        }

        me.isUpdatingNavRects = true;
        me.pendingNavRectsUpdate = false;

        let parent  = Neo.get(me.parentId),
            buttons = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].down(parent, 'button', false),
            ids     = buttons.map(button => button.id);

        if (ids.length > 0) {
            let allIds = [...ids, me.id],
                rects  = await me.getDomRect(allIds);

            if (rects) {
                let canvasRect = rects.pop();

                me.canvasRect = canvasRect; // Cache for mouse events

                if (canvasRect) {
                    me.navRects = rects.map((r, index) => {
                        if (!r) return null;
                        return {
                            id    : ids[index],
                            x     : r.x - canvasRect.x,
                            y     : r.y - canvasRect.y,
                            width : r.width,
                            height: r.height
                        }
                    }).filter(Boolean);

                    me.renderer.updateNavRects({
                        height: canvasRect.height,
                        rects : me.navRects,
                        width : canvasRect.width
                    })
                }
            }
        }

        me.isUpdatingNavRects = false;

        if (me.pendingNavRectsUpdate) {
            me.updateNavRects()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Canvas));


/***/ },

/***/ "./src/app/header/Toolbar.mjs"
/*!************************************!*\
  !*** ./src/app/header/Toolbar.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _Canvas_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Canvas.mjs */ "./src/app/header/Canvas.mjs");
/* harmony import */ var _ToolbarController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ToolbarController.mjs */ "./src/app/header/ToolbarController.mjs");




/**
 * @class Neo.app.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.app.header.Toolbar'
         * @protected
         */
        className: 'Neo.app.header.Toolbar',
        /**
         * @member {String[]} cls=['neo-header-toolbar']
         * @reactive
         */
        cls: ['neo-header-toolbar'],
        /**
         * @member {Neo.controller.Component} controller=Controller
         */
        controller: _ToolbarController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        /**
         * @member {Object[]} domListeners
         */
        domListeners: [{
            click     : 'onButtonClick',
            mouseleave: 'onMouseLeave',
            mousemove : {fn: 'onMouseMove', local: true}
        }, {
            mouseenter: 'onButtonMouseEnter',
            mouseleave: 'onButtonMouseLeave',
            delegate  : '.neo-button'
        }],
        /**
         * @member {Object} itemDefaults
         */
        itemDefaults: {
            handler: 'onButtonClick',
            ntype  : 'button',
            ui     : 'ghost'
        },
        /**
         * @member {Object} style={position: 'relative'}
         */
        style: {position: 'relative'}
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        this.add({
            module   : _Canvas_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            listeners: {canvasReady: 'onCanvasReady', scope: this},
            reference: 'header-canvas'
        })
    }

    /**
     * Empty template method, override in subclasses if needed
     */
    onCanvasReady() {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ },

/***/ "./src/app/header/ToolbarController.mjs"
/*!**********************************************!*\
  !*** ./src/app/header/ToolbarController.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Neo.app.header.ToolbarController
 * @extends Neo.controller.Component
 */
class ToolbarController extends _controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.app.header.ToolbarController'
         * @protected
         */
        className: 'Neo.app.header.ToolbarController'
    }

    /**
     * @param {Object} data
     */
    onButtonClick(data) {
        this.getReference('header-canvas')?.onClick(data)
    }

    /**
     * @param {Object} data
     */
    onButtonMouseEnter(data) {
        let headerCanvas = this.getReference('header-canvas');

        if (headerCanvas) {
            headerCanvas.hoverId = data.path[0].id
        }
    }

    /**
     * @param {Object} data
     */
    onButtonMouseLeave(data) {
        let headerCanvas = this.getReference('header-canvas');

        if (headerCanvas) {
            headerCanvas.hoverId = null
        }
    }

    /**
     * @param {Object} data
     */
    onMouseLeave(data) {
        this.getReference('header-canvas')?.onMouseLeave(data)
    }

    /**
     * @param {Object} data
     */
    onMouseMove(data) {
        this.getReference('header-canvas')?.onMouseMove(data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ToolbarController));


/***/ },

/***/ "./src/component/Canvas.mjs"
/*!**********************************!*\
  !*** ./src/component/Canvas.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.component.Canvas
 * @extends Neo.component.Base
 */
class Canvas extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Canvas'
         * @protected
         */
        className: 'Neo.component.Canvas',
        /**
         * @member {String} ntype='canvas'
         * @protected
         */
        ntype: 'canvas',
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=true
         * @reactive
         */
        monitorSize_: true,
        /**
         * @member {Boolean} offscreen=true
         */
        offscreen: true,
        /**
         * Only applicable if offscreen === true.
         * true once the ownership of the canvas node got transferred to worker.Canvas.
         * @member {Boolean} offscreenRegistered_=false
         * @reactive
         */
        offscreenRegistered_: false,
        /**
         * @member {Object} _vdom={tag: 'canvas'}
         */
        _vdom:
        {tag: 'canvas'}
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me                    = this,
            id                    = me.getCanvasId(),
            {offscreen, windowId} = me;

        if (value) {
            await me.timeout(30); // next rAF tick

            if (me.monitorSize) {
                me.addDomListeners([{
                    delegate: `#${me.getMonitorTargetId()}`,
                    resize  : me.onDomResize,
                    scope   : me
                }])
            }

            if (offscreen) {
                let data,
                    delay = 50;

                while (me.mounted && !me.offscreenRegistered && !me.isDestroyed) {
                    data = await Neo.main.DomAccess.getOffscreenCanvas({
                        nodeId: id,
                        windowId
                    });

                    if (data.offscreen) {
                        await Neo.worker.Canvas.registerCanvas({
                            node  : data.offscreen,
                            nodeId: id,
                            windowId
                        }, [data.offscreen]);

                        me.offscreenRegistered = true;
                        break
                    } else if (data.transferred) {
                        if (Neo.config.useSharedWorkers) {
                            let retrieveData = await Neo.worker.Canvas.retrieveCanvas({
                                nodeId: id,
                                windowId
                            });

                            if (retrieveData.hasCanvas) {
                                me.offscreenRegistered = true;
                                break
                            }
                        }
                    }

                    await me.timeout(delay);

                    if (delay < 1000) {
                        delay *= 2
                    }
                }
            }
        } else if (offscreen) {
            if (me.offscreenRegistered) {
                Neo.worker.Canvas.unregisterCanvas({
                    nodeId: id
                })
            }

            me.offscreenRegistered = false
        }
    }


    /**
     * Triggered after the windowId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (oldValue) {
            this.offscreenRegistered = false
        }
    }

    /**
     * @param {...*} args
     */
    destroy(...args) {
        if (this.offscreenRegistered) {
            Neo.worker.Canvas.unregisterCanvas({
                nodeId: this.id
            })
        }

        super.destroy(...args)
    }

    /**
     * Override this method when using wrappers (e.g. D3)
     * @returns {String}
     */
    getCanvasId() {
        return this.id
    }

    /**
     * The DOM node ID that should trigger the canvas resize updates.
     * By default, this is the component's top-level wrapper ID.
     * Subclasses can override this to observe a different node (e.g. a parent container).
     * @returns {String}
     */
    getMonitorTargetId() {
        return this.vdom.id
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Canvas));


/***/ },

/***/ "./src/component/Label.mjs"
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ },

/***/ "./src/container/Viewport.mjs"
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ },

/***/ "./src/controller/Component.mjs"
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {String|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/toolbar/Base.mjs"
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            dock: this.dock
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19hcHBfaGVhZGVyX1Rvb2xiYXJfbWpzLXNyY19jb250YWluZXJfVmlld3BvcnRfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2REFBTTtBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxrREFBa0Q7O0FBRTNGOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QztBQUNsRjtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNEJBQTRCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcFNlO0FBQ1I7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseURBQVk7QUFDakM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsOERBQWdCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDhEQUFnQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdE9VO0FBQ1Y7QUFDVzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseURBQUk7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0Esb0JBQW9CLDhEQUFVO0FBQzlCO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsUUFBUSxPQUFPO0FBQ25DO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsbURBQU07QUFDN0Isd0JBQXdCLDBDQUEwQztBQUNsRTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHVCQUF1QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDckVpQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUVBQVU7QUFDMUM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxpQ0FBaUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQzNEZDs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQVM7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxPQUFPO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUJBQXFCOztBQUVsQztBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1S0g7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVM7QUFDN0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUscUJBQXFCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ0Y7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFTO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxVQUFVOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRkc7QUFDVTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQUk7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsV0FBVzs7QUFFeEI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYSxPQUFPLFdBQVc7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHlCQUF5QjtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsZ0JBQWdCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHlCQUF5QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pNRTtBQUNHO0FBQ0E7QUFDQztBQUNMOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBUztBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFFBQVEsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsdURBQVE7QUFDcEMsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLDJEQUFTLFdBQVc7QUFDNUQ7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvYXBwL1NoYXJlZENhbnZhcy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9hcHAvaGVhZGVyL0NhbnZhcy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9hcHAvaGVhZGVyL1Rvb2xiYXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvYXBwL2hlYWRlci9Ub29sYmFyQ29udHJvbGxlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvQ2FudmFzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9MYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdG9vbGJhci9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FudmFzIGZyb20gJy4uL2NvbXBvbmVudC9DYW52YXMubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBTaGFyZWRXb3JrZXIgQ2FudmFzIGNvbXBvbmVudHMuXG4gKlxuICogVGhpcyBjbGFzcyBhYnN0cmFjdHMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhbiBBcHAgV29ya2VyIGNvbXBvbmVudCB0byBhXG4gKiBTaGFyZWRXb3JrZXIgY2FudmFzIHJlbmRlcmVyLiBJdCBoYW5kbGVzOlxuICogMS4gICoqTGlmZWN5Y2xlKio6IEluaXRpYWxpemluZyB0aGUgZ3JhcGggd2hlbiBvZmZzY3JlZW4gY2FudmFzIGlzIHJlYWR5LlxuICogMi4gICoqU2l6aW5nKio6IFN5bmNpbmcgRE9NIHNpemUgdG8gdGhlIHdvcmtlciB2aWEgUmVzaXplT2JzZXJ2ZXIuXG4gKiAzLiAgKipJbnRlcmFjdGlvbioqOiBCcmlkZ2luZyBtb3VzZSBldmVudHMgKG1vdmUsIGNsaWNrLCBsZWF2ZSkgdG8gdGhlIHdvcmtlci5cbiAqIDQuICAqKlRoZW1pbmcqKjogU3luY2luZyB0aGUgY29tcG9uZW50J3MgdGhlbWUgdG8gdGhlIHdvcmtlci5cbiAqXG4gKiBTdWJjbGFzc2VzIG11c3QgZGVmaW5lOlxuICogLSBgcmVuZGVyZXJDbGFzc05hbWVgOiBTdHJpbmcgbmFtZSBvZiB0aGUgU2hhcmVkV29ya2VyIHNpbmdsZXRvbiAoZS5nLiAnTmVvLmNhbnZhcy5IZWFkZXInKVxuICogLSBgcmVuZGVyZXJJbXBvcnRQYXRoYDogSW1wb3J0IHBhdGggZm9yIHRoZSByZW5kZXJlciBtb2R1bGUgKGUuZy4gJ3NyYy9jYW52YXMvSGVhZGVyLm1qcycpXG4gKlxuICogQGNsYXNzIE5lby5hcHAuU2hhcmVkQ2FudmFzXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkNhbnZhc1xuICovXG5jbGFzcyBTaGFyZWRDYW52YXMgZXh0ZW5kcyBDYW52YXMge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFwcC5TaGFyZWRDYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5hcHAuU2hhcmVkQ2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQ2FudmFzUmVhZHlfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0NhbnZhc1JlYWR5XzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZnVsbCBjbGFzcyBuYW1lIG9mIHRoZSBTaGFyZWRXb3JrZXIgc2luZ2xldG9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcmVuZGVyZXJDbGFzc05hbWU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXJDbGFzc05hbWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW1wb3J0IHBhdGggZm9yIHRoZSByZW5kZXJlciBtb2R1bGUuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSByZW5kZXJlckltcG9ydFBhdGg9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXJJbXBvcnRQYXRoOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICdjYW52YXMnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjYW52YXNJZD1udWxsXG4gICAgICovXG4gICAgY2FudmFzSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbnZhc1JlY3Q9bnVsbFxuICAgICAqL1xuICAgIGNhbnZhc1JlY3QgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNDYW52YXNSZWFkeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbW9kZSA9IHRoaXMudGhlbWU/LmluY2x1ZGVzKCdkYXJrJykgPyAnZGFyaycgOiAnbGlnaHQnO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlcj8uc2V0VGhlbWUobW9kZSk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2NhbnZhc1JlYWR5JylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBob29rIHRyaWdnZXJlZCB3aGVuIHRoZSBtb3VudGVkIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS5yZWFkeSgpXG4gICAgICAgIH0gZWxzZSBpZiAobWUub2Zmc2NyZWVuUmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgbWUucmVuZGVyZXI/LmNsZWFyR3JhcGgoKVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgaG9vayB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlZ2lzdGVyZWQgb2Zmc2NyZWVuLlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBTaGFyZWQgV29ya2VyIGdyYXBoIGFuZCBzZXRzIHVwIHJlc2l6ZSBvYnNlcnZhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0T2Zmc2NyZWVuUmVnaXN0ZXJlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnJlYWR5KCk7XG5cbiAgICAgICAgICAgIGlmICghbWUucmVuZGVyZXJDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyBjb21wb25lbnQgbWlzc2luZyByZW5kZXJlckNsYXNzTmFtZSBjb25maWcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCBtZS5yZW5kZXJlci5pbml0R3JhcGgoe2NhbnZhc0lkOiBtZS5nZXRDYW52YXNJZCgpLCB3aW5kb3dJZDogbWUud2luZG93SWR9KTtcblxuICAgICAgICAgICAgbWUuaXNDYW52YXNSZWFkeSA9IHRydWU7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnVwZGF0ZVNpemUoKVxuICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5pc0NhbnZhc1JlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICBhd2FpdCBtZS5yZW5kZXJlci5jbGVhckdyYXBoKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuaXNDYW52YXNSZWFkeSkge1xuICAgICAgICAgICAgbGV0IG1vZGUgPSB2YWx1ZS5pbmNsdWRlcygnZGFyaycpID8gJ2RhcmsnIDogJ2xpZ2h0JztcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0VGhlbWUobW9kZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2FudmFzSWQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5jYW52YXNJZCkge1xuICAgICAgICAgICAgbWUuY2FudmFzSWQgPSBtZS5pZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLmNhbnZhc0lkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIFNoYXJlZFdvcmtlciBzaW5nbGV0b24gaW5zdGFuY2UgZnJvbSB0aGUgcmVuZGVyZXJDbGFzc05hbWUgY29uZmlnLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZW5kZXJlciBzaW5nbGV0b25cbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyQ2xhc3NOYW1lID8gTmVvLm5zKHRoaXMucmVuZGVyZXJDbGFzc05hbWUpIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyPy5jbGVhckdyYXBoKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBpbml0QXN5bmMoKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRBc3luYygpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnJlbmRlcmVySW1wb3J0UGF0aCkge1xuICAgICAgICAgICAgIC8vIEVuc3VyZSBDYW52YXMgV29ya2VyIGlzIHJ1bm5pbmdcbiAgICAgICAgICAgIGF3YWl0IE5lby53b3JrZXIuTWFuYWdlci5zdGFydFdvcmtlcih7XG4gICAgICAgICAgICAgICAgbmFtZSAgICA6ICdjYW52YXMnLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBDYW52YXMgV29ya2VyIHJlbW90ZSB0byBiZSBhdmFpbGFibGUuXG4gICAgICAgICAgICBsZXQgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICghTmVvLm5zKCdOZW8ud29ya2VyLkNhbnZhcy5sb2FkTW9kdWxlJykgJiYgaSA8IDQwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1MCk7XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChOZW8ubnMoJ05lby53b3JrZXIuQ2FudmFzLmxvYWRNb2R1bGUnKSkge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIHNwZWNpZmljIHJlbmRlcmVyIG1vZHVsZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBhd2FpdCBOZW8ud29ya2VyLkNhbnZhcy5sb2FkTW9kdWxlKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogbWUucmVuZGVyZXJJbXBvcnRQYXRoXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgcmVtb3RlIHN0dWIgdG8gYmUgY3JlYXRlZFxuICAgICAgICAgICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIW1lLnJlbmRlcmVyICYmIGogPCA0MCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUwKTtcbiAgICAgICAgICAgICAgICAgICAgaisrXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmVuZGVyZXIgUmVtb3RlIFN0dWIgbm90IGZvdW5kOicsIG1lLnJlbmRlcmVyQ2xhc3NOYW1lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTmVvLmNvbXBvbmVudC5DYW52YXNTaGFyZWQ6IENhbnZhcyBXb3JrZXIgZmFpbGVkIHRvIHJlZ2lzdGVyIHJlbW90ZSBtZXRob2RzLicpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkcyBjbGljayBldmVudHMgdG8gdGhlIFNoYXJlZCBXb3JrZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNDYW52YXNSZWFkeSAmJiBtZS5jYW52YXNSZWN0KSB7XG4gICAgICAgICAgICBtZS5yZW5kZXJlci51cGRhdGVNb3VzZVN0YXRlKHtcbiAgICAgICAgICAgICAgICBjbGljazogdHJ1ZSxcbiAgICAgICAgICAgICAgICB4ICAgIDogZGF0YS5jbGllbnRYIC0gbWUuY2FudmFzUmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIHkgICAgOiBkYXRhLmNsaWVudFkgLSBtZS5jYW52YXNSZWN0LnRvcFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgU2hhcmVkIFdvcmtlciByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW52YXNSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5wYXVzZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG1vdXNlIHN0YXRlIGluIHRoZSBTaGFyZWQgV29ya2VyIHdoZW4gdGhlIGN1cnNvciBsZWF2ZXMgdGhlIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VMZWF2ZShkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FudmFzUmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlTW91c2VTdGF0ZSh7bGVhdmU6IHRydWV9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yd2FyZHMgbW91c2UgY29vcmRpbmF0ZXMgdG8gdGhlIFNoYXJlZCBXb3JrZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzQ2FudmFzUmVhZHkpIHtcbiAgICAgICAgICAgIGlmIChtZS5jYW52YXNSZWN0KSB7XG4gICAgICAgICAgICAgICAgbWUucmVuZGVyZXIudXBkYXRlTW91c2VTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGRhdGEuY2xpZW50WCAtIG1lLmNhbnZhc1JlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgeTogZGF0YS5jbGllbnRZIC0gbWUuY2FudmFzUmVjdC50b3BcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2FudmFzIHNpemUgaW4gdGhlIFNoYXJlZCBXb3JrZXIgd2hlbiB0aGUgRE9NIGVsZW1lbnQgcmVzaXplcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRG9tUmVzaXplKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25Eb21SZXNpemUoZGF0YSk7XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlU2l6ZShkYXRhLmNvbnRlbnRSZWN0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgdGhlIFNoYXJlZCBXb3JrZXIgcmVuZGVyIGxvb3AuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy5pc0NhbnZhc1JlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgdGhlIG5ldyBkaW1lbnNpb25zIHRvIHRoZSBTaGFyZWQgV29ya2VyIGFuZCBjYWNoZXMgdGhlIGJvdW5kaW5nIHJlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gW3JlY3RdXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlU2l6ZShyZWN0KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgYXdhaXQgbWUucmVhZHkoKTtcblxuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC53aWR0aCA9PT0gMCB8fCByZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmVjdCA9IGF3YWl0IG1lLmdldERvbVJlY3QobWUuaWQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgbWUuY2FudmFzUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICBhd2FpdCBtZS5yZW5kZXJlcj8udXBkYXRlU2l6ZSh7d2lkdGg6IHJlY3Qud2lkdGgsIGhlaWdodDogcmVjdC5oZWlnaHR9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTaGFyZWRDYW52YXMpO1xuIiwiaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBTaGFyZWRDYW52YXMgICAgIGZyb20gJy4uL1NoYXJlZENhbnZhcy5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFRoZSBBcHAgV29ya2VyIGNvbXBvbmVudCBmb3IgdGhlIEhlYWRlclRvb2xiYXIgY2FudmFzIG92ZXJsYXkuXG4gKlxuICogVGhpcyBjb21wb25lbnQgY29vcmRpbmF0ZXMgdGhlIE9mZnNjcmVlbkNhbnZhcyB0cmFuc2ZlciBhbmQgbGlmZWN5Y2xlIG1hbmFnZW1lbnQuXG4gKiBJdCBzZXJ2ZXMgYXMgdGhlIEFwcCBXb3JrZXIncyBoYW5kbGUgZm9yIHRoZSB2aXN1YWwgZWZmZWN0LCByZXNwb25zaWJsZSBmb3I6XG4gKlxuICogMS4gKipMaWZlY3ljbGUgTWFuYWdlbWVudDoqKiBJbnN0YW50aWF0aW5nIGFuZCBkZXN0cm95aW5nIHRoZSByZW5kZXJpbmcgZ3JhcGggaW4gdGhlIGBDYW52YXMgU2hhcmVkV29ya2VyYC5cbiAqIDIuICoqRE9NIFN5bmNocm9uaXphdGlvbjoqKiBUcmFja2luZyB0aGUgc2l6ZS9wb3NpdGlvbiBvZiB0aGUgY2FudmFzIGFuZCBuYXZpZ2F0aW9uIGJ1dHRvbnMsIGZvcndhcmRpbmcgdGhlc2UgdG8gdGhlIHJlbmRlcmVyLlxuICogMy4gKipJbnB1dCBCcmlkZ2luZzoqKiBDYXB0dXJpbmcgdXNlciBpbnRlcmFjdGlvbnMgKG1vdXNlIG1vdmUsIGNsaWNrKSBhbmQgZm9yd2FyZGluZyBjb29yZGluYXRlcyB0byB0aGUgcmVuZGVyZXIuXG4gKlxuICogVGhlIGFjdHVhbCByZW5kZXJpbmcgbG9vcCBhbmQgcGh5c2ljcyBzaW11bGF0aW9uIGhhcHBlbiBpbiBgTmVvLmNhbnZhcy5IZWFkZXJgIChTaGFyZWRXb3JrZXIpLFxuICogZW5zdXJpbmcgdGhlIG1haW4gdGhyZWFkIGFuZCBBcHAgV29ya2VyIHJlbWFpbiB1bmJsb2NrZWQuXG4gKlxuICogQGNsYXNzIE5lby5hcHAuaGVhZGVyLkNhbnZhc1xuICogQGV4dGVuZHMgTmVvLmFwcC5TaGFyZWRDYW52YXNcbiAqIEBzZWUgTmVvLmNhbnZhcy5IZWFkZXJcbiAqL1xuY2xhc3MgQ2FudmFzIGV4dGVuZHMgU2hhcmVkQ2FudmFzIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5hcHAuaGVhZGVyLkNhbnZhcydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmFwcC5oZWFkZXIuQ2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhY3RpdmVJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZUlkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WydhcHAtaGVhZGVyLWNhbnZhcyddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnYXBwLWhlYWRlci1jYW52YXMnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBob3ZlcklkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaG92ZXJJZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlbmRlcmVyQ2xhc3NOYW1lPSdOZW8uY2FudmFzLkhlYWRlcidcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVyQ2xhc3NOYW1lOiAnTmVvLmNhbnZhcy5IZWFkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZW5kZXJlckltcG9ydFBhdGg9J3NyYy9jYW52YXMvSGVhZGVyLm1qcydcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmVySW1wb3J0UGF0aDogJ3NyYy9jYW52YXMvSGVhZGVyLm1qcydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gbmF2UmVjdHM9bnVsbFxuICAgICAqL1xuICAgIG5hdlJlY3RzID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG5hdlJlY3RzVGltZW91dElkPW51bGxcbiAgICAgKi9cbiAgICBuYXZSZWN0c1RpbWVvdXRJZCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc0NhbnZhc1JlYWR5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldElzQ2FudmFzUmVhZHkodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5hY3RpdmVJZCkge1xuICAgICAgICAgICAgbWUucmVuZGVyZXIudXBkYXRlQWN0aXZlSWQoe2lkOiBtZS5hY3RpdmVJZH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgaG9vayB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlZ2lzdGVyZWQgb2Zmc2NyZWVuLlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBTaGFyZWQgV29ya2VyIGdyYXBoIGFuZCBzZXRzIHVwIHJlc2l6ZSBvYnNlcnZhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0T2Zmc2NyZWVuUmVnaXN0ZXJlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgYXdhaXQgc3VwZXIuYWZ0ZXJTZXRPZmZzY3JlZW5SZWdpc3RlcmVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgID0gTmVvLmdldChtZS5wYXJlbnRJZCksXG4gICAgICAgICAgICAgICAgYnV0dG9ucyA9IENvbXBvbmVudE1hbmFnZXIuZG93bihwYXJlbnQsICdidXR0b24nLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgICAgICByZXNpemU6IG1lLm9uQnV0dG9uUmVzaXplLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS51cGRhdGVOYXZSZWN0cygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRBY3RpdmVJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW52YXNSZWFkeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJlci51cGRhdGVBY3RpdmVJZCh7aWQ6IHZhbHVlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldEhvdmVySWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FudmFzUmVhZHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyZXIudXBkYXRlSG92ZXJJZCh7aWQ6IHZhbHVlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TW9uaXRvclRhcmdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRJZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25CdXR0b25SZXNpemUoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZU5hdlJlY3RzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYW52YXMgc2l6ZSBhbmQgcmUtY2FsY3VsYXRlcyBuYXZpZ2F0aW9uIHJlY3RzIG9uIHJlc2l6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRG9tUmVzaXplKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdyZXNpemUnLCBkYXRhKTtcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVOYXZSZWN0cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNVcGRhdGluZ05hdlJlY3RzPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzVXBkYXRpbmdOYXZSZWN0cyA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcGVuZGluZ05hdlJlY3RzVXBkYXRlPWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHBlbmRpbmdOYXZSZWN0c1VwZGF0ZSA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbml6ZXMgdGhlIHBvc2l0aW9ucyBvZiB0aGUgbmF2aWdhdGlvbiBidXR0b25zIHdpdGggdGhlIFNoYXJlZCBXb3JrZXIuXG4gICAgICogVGhpcyBhbGxvd3MgdGhlIHBoeXNpY3MgZW5naW5lIHRvIFwiZGl2ZXJ0XCIgdGhlIGVuZXJneSBzdHJlYW1zIGFyb3VuZCB0aGUgYnV0dG9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzRmFsbGJhY2s9ZmFsc2VdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlTmF2UmVjdHMoaXNGYWxsYmFjaz1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuaXNDYW52YXNSZWFkeSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghaXNGYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKG1lLm5hdlJlY3RzVGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1lLm5hdlJlY3RzVGltZW91dElkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5uYXZSZWN0c1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm5hdlJlY3RzVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVOYXZSZWN0cyh0cnVlKVxuICAgICAgICAgICAgfSwgMTAwMClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5pc1VwZGF0aW5nTmF2UmVjdHMpIHtcbiAgICAgICAgICAgIG1lLnBlbmRpbmdOYXZSZWN0c1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzVXBkYXRpbmdOYXZSZWN0cyA9IHRydWU7XG4gICAgICAgIG1lLnBlbmRpbmdOYXZSZWN0c1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGxldCBwYXJlbnQgID0gTmVvLmdldChtZS5wYXJlbnRJZCksXG4gICAgICAgICAgICBidXR0b25zID0gQ29tcG9uZW50TWFuYWdlci5kb3duKHBhcmVudCwgJ2J1dHRvbicsIGZhbHNlKSxcbiAgICAgICAgICAgIGlkcyAgICAgPSBidXR0b25zLm1hcChidXR0b24gPT4gYnV0dG9uLmlkKTtcblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBhbGxJZHMgPSBbLi4uaWRzLCBtZS5pZF0sXG4gICAgICAgICAgICAgICAgcmVjdHMgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChhbGxJZHMpO1xuXG4gICAgICAgICAgICBpZiAocmVjdHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FudmFzUmVjdCA9IHJlY3RzLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgbWUuY2FudmFzUmVjdCA9IGNhbnZhc1JlY3Q7IC8vIENhY2hlIGZvciBtb3VzZSBldmVudHNcblxuICAgICAgICAgICAgICAgIGlmIChjYW52YXNSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm5hdlJlY3RzID0gcmVjdHMubWFwKChyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgOiBpZHNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggICAgIDogci54IC0gY2FudmFzUmVjdC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgICAgIDogci55IC0gY2FudmFzUmVjdC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5yZW5kZXJlci51cGRhdGVOYXZSZWN0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNhbnZhc1JlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdHMgOiBtZS5uYXZSZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogY2FudmFzUmVjdC53aWR0aFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzVXBkYXRpbmdOYXZSZWN0cyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChtZS5wZW5kaW5nTmF2UmVjdHNVcGRhdGUpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZU5hdlJlY3RzKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FudmFzKTtcbiIsImltcG9ydCBCYXNlICAgICAgIGZyb20gJy4uLy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuaW1wb3J0IENhbnZhcyAgICAgZnJvbSAnLi9DYW52YXMubWpzJztcbmltcG9ydCBDb250cm9sbGVyIGZyb20gJy4vVG9vbGJhckNvbnRyb2xsZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmFwcC5oZWFkZXIuVG9vbGJhclxuICogQGV4dGVuZHMgTmVvLnRvb2xiYXIuQmFzZVxuICovXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uYXBwLmhlYWRlci5Ub29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uYXBwLmhlYWRlci5Ub29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WyduZW8taGVhZGVyLXRvb2xiYXInXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyduZW8taGVhZGVyLXRvb2xiYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudH0gY29udHJvbGxlcj1Db250cm9sbGVyXG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sbGVyOiBDb250cm9sbGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGRvbUxpc3RlbmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZG9tTGlzdGVuZXJzOiBbe1xuICAgICAgICAgICAgY2xpY2sgICAgIDogJ29uQnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgbW91c2VsZWF2ZTogJ29uTW91c2VMZWF2ZScsXG4gICAgICAgICAgICBtb3VzZW1vdmUgOiB7Zm46ICdvbk1vdXNlTW92ZScsIGxvY2FsOiB0cnVlfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb3VzZWVudGVyOiAnb25CdXR0b25Nb3VzZUVudGVyJyxcbiAgICAgICAgICAgIG1vdXNlbGVhdmU6ICdvbkJ1dHRvbk1vdXNlTGVhdmUnLFxuICAgICAgICAgICAgZGVsZWdhdGUgIDogJy5uZW8tYnV0dG9uJ1xuICAgICAgICB9XSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIGhhbmRsZXI6ICdvbkJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgIG50eXBlICA6ICdidXR0b24nLFxuICAgICAgICAgICAgdWkgICAgIDogJ2dob3N0J1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdHlsZT17cG9zaXRpb246ICdyZWxhdGl2ZSd9XG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZToge3Bvc2l0aW9uOiAncmVsYXRpdmUnfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIHRoaXMuYWRkKHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogQ2FudmFzLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2FudmFzUmVhZHk6ICdvbkNhbnZhc1JlYWR5Jywgc2NvcGU6IHRoaXN9LFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnaGVhZGVyLWNhbnZhcydcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbXB0eSB0ZW1wbGF0ZSBtZXRob2QsIG92ZXJyaWRlIGluIHN1YmNsYXNzZXMgaWYgbmVlZGVkXG4gICAgICovXG4gICAgb25DYW52YXNSZWFkeSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvb2xiYXIpO1xuIiwiaW1wb3J0IENvbnRyb2xsZXIgZnJvbSAnLi4vLi4vY29udHJvbGxlci9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmFwcC5oZWFkZXIuVG9vbGJhckNvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBUb29sYmFyQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmFwcC5oZWFkZXIuVG9vbGJhckNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5hcHAuaGVhZGVyLlRvb2xiYXJDb250cm9sbGVyJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25CdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZ2V0UmVmZXJlbmNlKCdoZWFkZXItY2FudmFzJyk/Lm9uQ2xpY2soZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQnV0dG9uTW91c2VFbnRlcihkYXRhKSB7XG4gICAgICAgIGxldCBoZWFkZXJDYW52YXMgPSB0aGlzLmdldFJlZmVyZW5jZSgnaGVhZGVyLWNhbnZhcycpO1xuXG4gICAgICAgIGlmIChoZWFkZXJDYW52YXMpIHtcbiAgICAgICAgICAgIGhlYWRlckNhbnZhcy5ob3ZlcklkID0gZGF0YS5wYXRoWzBdLmlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQnV0dG9uTW91c2VMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBoZWFkZXJDYW52YXMgPSB0aGlzLmdldFJlZmVyZW5jZSgnaGVhZGVyLWNhbnZhcycpO1xuXG4gICAgICAgIGlmIChoZWFkZXJDYW52YXMpIHtcbiAgICAgICAgICAgIGhlYWRlckNhbnZhcy5ob3ZlcklkID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTGVhdmUoZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgnaGVhZGVyLWNhbnZhcycpPy5vbk1vdXNlTGVhdmUoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5nZXRSZWZlcmVuY2UoJ2hlYWRlci1jYW52YXMnKT8ub25Nb3VzZU1vdmUoZGF0YSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvb2xiYXJDb250cm9sbGVyKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQ2FudmFzXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgQ2FudmFzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuQ2FudmFzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkNhbnZhcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjYW52YXMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2FudmFzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyBhIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIgYW5kIGZpcmVzIGEgY3VzdG9tIHJlc2l6ZSBldmVudFxuICAgICAgICAgKiB3aGljaCBvdGhlciBpbnN0YW5jZXMgY2FuIHN1YnNjcmliZSB0by5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9uaXRvclNpemVfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb25pdG9yU2l6ZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvZmZzY3JlZW49dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2NyZWVuOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBhcHBsaWNhYmxlIGlmIG9mZnNjcmVlbiA9PT0gdHJ1ZS5cbiAgICAgICAgICogdHJ1ZSBvbmNlIHRoZSBvd25lcnNoaXAgb2YgdGhlIGNhbnZhcyBub2RlIGdvdCB0cmFuc2ZlcnJlZCB0byB3b3JrZXIuQ2FudmFzLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvZmZzY3JlZW5SZWdpc3RlcmVkXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNjcmVlblJlZ2lzdGVyZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb209e3RhZzogJ2NhbnZhcyd9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ2NhbnZhcyd9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpZCAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXRDYW52YXNJZCgpLFxuICAgICAgICAgICAge29mZnNjcmVlbiwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTsgLy8gbmV4dCByQUYgdGlja1xuXG4gICAgICAgICAgICBpZiAobWUubW9uaXRvclNpemUpIHtcbiAgICAgICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGU6IGAjJHttZS5nZXRNb25pdG9yVGFyZ2V0SWQoKX1gLFxuICAgICAgICAgICAgICAgICAgICByZXNpemUgIDogbWUub25Eb21SZXNpemUsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlICAgOiBtZVxuICAgICAgICAgICAgICAgIH1dKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gNTA7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAobWUubW91bnRlZCAmJiAhbWUub2Zmc2NyZWVuUmVnaXN0ZXJlZCAmJiAhbWUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IE5lby5tYWluLkRvbUFjY2Vzcy5nZXRPZmZzY3JlZW5DYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm9mZnNjcmVlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgTmVvLndvcmtlci5DYW52YXMucmVnaXN0ZXJDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgIDogZGF0YS5vZmZzY3JlZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW2RhdGEub2Zmc2NyZWVuXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnRyYW5zZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmNvbmZpZy51c2VTaGFyZWRXb3JrZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHJpZXZlRGF0YSA9IGF3YWl0IE5lby53b3JrZXIuQ2FudmFzLnJldHJpZXZlQ2FudmFzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyaWV2ZURhdGEuaGFzQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9mZnNjcmVlblJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoZGVsYXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxheSA8IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ICo9IDJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZzY3JlZW4pIHtcbiAgICAgICAgICAgIGlmIChtZS5vZmZzY3JlZW5SZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICAgICAgTmVvLndvcmtlci5DYW52YXMudW5yZWdpc3RlckNhbnZhcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZDogaWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5vZmZzY3JlZW5SZWdpc3RlcmVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2NyZWVuUmVnaXN0ZXJlZCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2NyZWVuUmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgTmVvLndvcmtlci5DYW52YXMudW5yZWdpc3RlckNhbnZhcyh7XG4gICAgICAgICAgICAgICAgbm9kZUlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHdoZW4gdXNpbmcgd3JhcHBlcnMgKGUuZy4gRDMpXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDYW52YXNJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRE9NIG5vZGUgSUQgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgY2FudmFzIHJlc2l6ZSB1cGRhdGVzLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdGhlIGNvbXBvbmVudCdzIHRvcC1sZXZlbCB3cmFwcGVyIElELlxuICAgICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gb2JzZXJ2ZSBhIGRpZmZlcmVudCBub2RlIChlLmcuIGEgcGFyZW50IGNvbnRhaW5lcikuXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRNb25pdG9yVGFyZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uaWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRG9tUmVzaXplKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdyZXNpemUnLCBkYXRhKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ2FudmFzKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGEgbGFiZWwgd2l0aCBhIHRleHRcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkxhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTGFiZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5MYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5MYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0YWc9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiAnbGFiZWwnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMYWJlbCk7XG4iLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5WaWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5WaWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd2aWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd2aWV3cG9ydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgJ25lby1ib2R5LXZpZXdwb3J0JyB0byB0aGUgZG9jdW1lbnQuYm9keVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhcHBseUJvZHlDbHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlCb2R5Q2xzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzdW1pbmcgdGhhdCBhIFZpZXdwb3J0IGlzIHRoZSB0b3AgbGV2ZWwgdmlldyBvZiB5b3VyIGFwcCwgYW5kIHlvdSB3YW50IHRvIG1vdW50IGl0IHJpZ2h0IGF3YXkuXG4gICAgICAgICAqIENvdWxkIGJlIHdpdGhvdXQgYW55IGl0ZW1zLiBVc2UgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdmlld3BvcnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdmlld3BvcnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgYXBwbGllcyBhIG1haW4uYWRkb24uUmVzaXplT2JzZXJ2ZXIgYW5kIGZpcmVzIGEgY3VzdG9tIHJlc2l6ZSBldmVudFxuICAgICAgICAgKiB3aGljaCBvdGhlciBpbnN0YW5jZXMgY2FuIHN1YnNjcmliZSB0by5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9uaXRvclNpemVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9uaXRvclNpemVfOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLm1vbml0b3JTaXplKSB7XG4gICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tyZXNpemU6IG1lLm9uRG9tUmVzaXplLCBzY29wZTogbWV9XSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCB7d2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICB0aGlzLmFwcGx5Qm9keUNscyAmJiBOZW8ubWFpbi5Eb21BY2Nlc3MuYXBwbHlCb2R5Q2xzKHtcbiAgICAgICAgICAgIGNsczogWyduZW8tYm9keS12aWV3cG9ydCddLFxuICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRG9tUmVzaXplKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdyZXNpemUnLCBkYXRhKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmlld3BvcnQpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IHtyZXNvbHZlQ2FsbGJhY2t9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udHJvbGxlci5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LWNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LWNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZWZlcmVuY2VzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB3aW5kb3dJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29tcG9uZW50fSA9IG1lO1xuXG4gICAgICAgIG1lLnJlZmVyZW5jZXMgPSB7fTtcblxuICAgICAgICBpZiAoY29tcG9uZW50LmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50Lm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwYXJlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGFyZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgdGhpcy5nZXRQYXJlbnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVyTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFtjb21wb25lbnRdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxCb29sZWFufG51bGx9XG4gICAgICovXG4gICAgZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnR9ID0gbWUsXG4gICAgICAgICAgICBoYW5kbGVyQ2I7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhzIGZ1bmN0aW9uICpuYW1lKiBmaXJzdCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZi5cbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgaXQsIHJldHVybiB0cnVlIHNvIGNhbGxpbmcgY29kZSBrbm93cyBub3QgdG8gY29udGludWUgdG8gc2VhcmNoLlxuICAgICAgICAgICAgaGFuZGxlckNiID0gcmVzb2x2ZUNhbGxiYWNrKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyIGZuIGlzIHJlc29sdmVkIGluIHRoZSBDb21wb25lbnQgb3IgaXRzIG93biBwYXJlbnQgY2hhaW4uXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBzdGF0dXMgaW5kaWNhdGluZyB0aGF0IHdlIGRvIG5vdCBuZWVkIGFuIGVhcmx5IGJpbmRpbmdcbiAgICAgICAgICAgIGlmIChoYW5kbGVyQ2IuZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5pc0Z1bmN0aW9uKG1lW2hhbmRsZXJOYW1lXSkgP1xuICAgICAgICAgICAgbWUgOiBwYXJlbnQ/LmdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBjb250cm9sbGVyIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5jb21wb25lbnQucGFyZW50Py5nZXRDb250cm9sbGVyKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHVwZGF0ZSBjaGFuZ2VkIHJlZmVyZW5jZXMgKGUuZy4gY29udGFpbmVyLnJlbW92ZSgpIHRoZW4gY29udGFpbmVyLmFkZCgpIHVzaW5nIHRoZSBzYW1lIGtleSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUucmVmZXJlbmNlc1tuYW1lXTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LmRvd24oe3JlZmVyZW5jZTogbmFtZX0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tuYW1lXSA9IGNvbXBvbmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudCB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYW1lTGV2ZWxPbmx5PWZhbHNlIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgaW5zaWRlIHRoZSBjb21wb25lbnQgcGFyZW50IHRyZWUsXG4gICAgICogaW4gY2FzZSB0aGVyZSBpcyBub25lIG9uIHRoZSBzYW1lIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NhbWVMZXZlbE9ubHk9ZmFsc2VdXG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihzYW1lTGV2ZWxPbmx5PWZhbHNlKSB7XG4gICAgICAgIGxldCB7Y29tcG9uZW50fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzYW1lTGV2ZWxPbmx5ID8gY29tcG9uZW50LnN0YXRlUHJvdmlkZXIgOiBjb21wb25lbnQuZ2V0U3RhdGVQcm92aWRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIGFjY2Vzc2luZyBzdGF0ZS5Qcm92aWRlciBiYXNlZCBkYXRhLlN0b3Jlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZShrZXkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW5zaWRlIHlvdXIgdmlldyBjb250cm9sbGVycyBhcyBhIHN0YXJ0aW5nIHBvaW50IGluIGNhc2UgeW91IG5lZWQgcmVmZXJlbmNlc1xuICAgICAqIChpbnN0ZWFkIG9mIHVzaW5nIG9uQ29uc3RydWN0ZWQoKSBpbnNpZGUgeW91ciBjb250cm9sbGVyKVxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogV2lsbCBnZXQgY2FsbGVkIGJ5IGNvbXBvbmVudC5CYXNlOiBkZXN0cm95KCkgaW4gY2FzZSB0aGUgY29tcG9uZW50IGhhcyBhIHJlZmVyZW5jZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWZlcmVuY2VzfSA9IG1lLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT09IHJlZmVyZW5jZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZWZlcmVuY2VzW2tleV07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmdldFBhcmVudCgpPy5yZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBzZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoLi4uYXJncylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQnV0dG9uICAgIGZyb20gJy4uL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgTGFiZWwgICAgIGZyb20gJy4uL2NvbXBvbmVudC9MYWJlbC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby50b29sYmFyLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGRvY2tcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gZG9ja1Bvc2l0aW9ucz1bJ3RvcCcsJ3JpZ2h0JywnYm90dG9tJywnbGVmdCcsIG51bGxdXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBkb2NrUG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnLCBudWxsXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udG9vbGJhci5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udG9vbGJhci5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3Rvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10b29sYmFyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRvb2xiYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBkb2NrXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZG9ja186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1EZWZhdWx0cz17bnR5cGU6J2J1dHRvbid9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbURlZmF1bHRzOiB7XG4gICAgICAgICAgICBudHlwZTogJ2J1dHRvbidcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0PXtudHlwZTonZmxleGJveCcsYWxpZ246J2NlbnRlcicsZGlyZWN0aW9uOiAncm93JywgcGFjazonc3RhcnQnfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgbnR5cGUgICAgOiAnZmxleGJveCcsXG4gICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkb2NrIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERvY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgIW9sZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIGRvY2tQb3NpdGlvbnMgPSBtZS5nZXRTdGF0aWNDb25maWcoJ2RvY2tQb3NpdGlvbnMnKSxcbiAgICAgICAgICAgIGxheW91dENvbmZpZyAgPSBtZS5nZXRMYXlvdXRDb25maWcoKTtcblxuICAgICAgICBkb2NrUG9zaXRpb25zLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGtleSAhPT0gbnVsbCAmJiBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLWRvY2stJyArIGtleSwga2V5ID09PSB2YWx1ZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFtZS5sYXlvdXQpIHtcbiAgICAgICAgICAgIGxheW91dENvbmZpZy5udHlwZSA9ICdmbGV4Ym94JztcbiAgICAgICAgICAgIG1lLnNldCh7Y2xzLCBsYXlvdXQ6IGxheW91dENvbmZpZ30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5sYXlvdXQuc2V0KGxheW91dENvbmZpZyk7XG4gICAgICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyBkb2NrIHBvc2l0aW9uIG1hdGNoZXMgYSB2YWx1ZSBvZiB0aGUgc3RhdGljIGRvY2tQb3NpdGlvbnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RvY2snLCAnZG9ja1Bvc2l0aW9ucycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxheW91dCBjb25maWcgZGVwZW5kaW5nIG9uIHRoaXMuZG9ja1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGxheW91dENvbmZpZ1xuICAgICAqL1xuICAgIGdldExheW91dENvbmZpZygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGxheW91dENvbmZpZztcblxuICAgICAgICBpZiAobWUuZG9jaykge1xuICAgICAgICAgICAgc3dpdGNoIChtZS5kb2NrKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uLXJldmVyc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheW91dENvbmZpZyB8fCBtZS5sYXlvdXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICovXG4gICAgaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLm1hcChpdGVtID0+IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5pbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fVxuICAgICAqL1xuICAgIHJlcGxhY2VTcGFjZXIoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gJy0+JyA/IHttb2R1bGU6IENvbXBvbmVudCwgZmxleDogMX0gOiBpdGVtXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGRvY2s6IHRoaXMuZG9ja1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUb29sYmFyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==