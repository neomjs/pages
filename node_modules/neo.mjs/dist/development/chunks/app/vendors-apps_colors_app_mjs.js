"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_colors_app_mjs"],{

/***/ "./apps/colors/app.mjs":
/*!*****************************!*\
  !*** ./apps/colors/app.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/Viewport.mjs */ "./apps/colors/view/Viewport.mjs");


const onStart = () => Neo.app({
    mainView: _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Colors'
});


/***/ }),

/***/ "./apps/colors/model/Color.mjs":
/*!*************************************!*\
  !*** ./apps/colors/model/Color.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Colors.model.Color
 * @extends Neo.data.Model
 */
class Color extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.model.Color'
         * @protected
         */
        className: 'Colors.model.Color'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let startCharCode = 'A'.charCodeAt(0),
            i             = 0,
            len           = 26, // amount of chars inside the ISO basic latin alphabet
            fields        = [{
                name: 'id',
                type: 'String'
            }];

        for (; i < len; i++) {
            fields.push({
                name: 'column' + String.fromCharCode(startCharCode + i),
                type: 'String'
            })
        }

        this.fields = fields
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ }),

/***/ "./apps/colors/store/Colors.mjs":
/*!**************************************!*\
  !*** ./apps/colors/store/Colors.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/Color.mjs */ "./apps/colors/model/Color.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Colors.store.Colors
 * @extends Neo.data.Store
 */
class Colors extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.store.Colors'
         * @protected
         */
        className: 'Colors.store.Colors',
        /**
         * @member {Neo.data.Model} model=ColorModel
         */
        model: _model_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Colors));


/***/ }),

/***/ "./apps/colors/view/BarChartComponent.mjs":
/*!************************************************!*\
  !*** ./apps/colors/view/BarChartComponent.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/component/wrapper/AmChart.mjs */ "./src/component/wrapper/AmChart.mjs");


/**
 * @class Colors.view.BarChartComponent
 * @extends Neo.component.wrapper.AmChart
 */
class BarChartComponent extends _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.BarChartComponent'
         * @protected
         */
        className: 'Colors.view.BarChartComponent',
        /**
         * @member {String[]} baseCls=['colors-bar-chart']
         */
        baseCls: ['colors-bar-chart'],
        /**
         * @member {String} chartType='PieChart'
         */
        chartType: 'XYChart',
        /**
         * @member {Object} chartConfig
         */
        chartConfig: {
            series: [{
                type: 'ColumnSeries',

                columns: {
                    propertyFields: {
                        fill  : 'color',
                        stroke: 'color'
                    }
                },

                dataFields: {
                    categoryX: 'color',
                    valueY   : 'count'
                }
            }],
            xAxes: [{
                type: 'CategoryAxis',

                dataFields: {
                    category: 'color',
                    title: {
                        text: 'Colors'
                    }
                }
            }],
            yAxes: [{
                type: 'ValueAxis',

                title: {
                    text: 'Occurrences in grid cells'
                }
            }]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BarChartComponent));


/***/ }),

/***/ "./apps/colors/view/GridContainer.mjs":
/*!********************************************!*\
  !*** ./apps/colors/view/GridContainer.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_grid_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/grid/Container.mjs */ "./src/grid/Container.mjs");


/**
 * @class Colors.view.GridContainer
 * @extends Neo.grid.Container
 */
class GridContainer extends _src_grid_Container_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.GridContainer'
         * @protected
         */
        className: 'Colors.view.GridContainer',
        /**
         * @member {Number|null} amountColumns_=null
         */
        amountColumns_: null,
        /**
         * @member {Number|null} amountRows_=null
         */
        amountRows_: null,
        /**
         * @member {Object} bind
         */
        bind: {
            amountColumns: data => data.amountColumns,
            amountRows   : data => data.amountRows,
            store        : 'stores.colors'
        },
        /**
         * @member {String[]} cls=['colors-grid-container']
         */
        cls: ['colors-grid-container']
    }

    /**
     * Triggered after the amountColumns config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetAmountColumns(value, oldValue) {
        if (Neo.isNumber(value)) {
            let startCharCode = 'A'.charCodeAt(0),
                i             = 0,
                columns       = [{
                    cellAlign: 'right',
                    dataField: 'id',
                    text     : '#',
                    type     : 'index',
                    width    : 40
                }],
                currentChar;

            for (; i < value; i++) {
                currentChar = String.fromCharCode(startCharCode + i);

                columns.push({
                    dataField: 'column' + currentChar,
                    renderer : 'up.colorRenderer',
                    text     : currentChar
                })
            }

            this.columns = columns
        }
    }

    /**
     * Triggered after the amountRows config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetAmountRows(value, oldValue) {
        this.store?.clear()
    }

    /**
     * @param {Object} data
     * @returns {Object}
     */
    colorRenderer({value}) {
        return {cls: ['color-' + value], html: ' '}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridContainer));


/***/ }),

/***/ "./apps/colors/view/HeaderToolbar.mjs":
/*!********************************************!*\
  !*** ./apps/colors/view/HeaderToolbar.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");





/**
 * @class Colors.view.HeaderToolbar
 * @extends Neo.toolbar.Base
 */
class HeaderToolbar extends _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.HeaderToolbar'
         * @protected
         */
        className: 'Colors.view.HeaderToolbar',
        /**
         * @member {String[]} cls=['colors-header-toolbar']
         */
        cls: ['colors-header-toolbar'],
        /**
         * @member {Object} layout={ntype:'hbox',align:'stretch',wrap:'wrap'}
         */
        layout: {ntype: 'hbox', align: 'center', pack: 'start', wrap: 'wrap'},
        /**
         * @member {Object[]} items
         */
        items: [{
            bind   : {disabled: data => data.isUpdating},
            handler: 'onStartButtonClick',
            text   : 'Start'
        }, {
            bind   : {disabled: data => !data.isUpdating},
            handler: 'onStopButtonClick',
            text   : 'Stop'
        }, {
            module       : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            bind         : {value: data => data.amountColors},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Colors',
            listeners    : {change: 'onChangeAmountColors'},
            maxValue     : 10,
            minValue     : 3,
            width        : 90
        }, {
            module       : _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            bind         : {value: data => String(data.amountColumns)},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Columns',
            listeners    : {change: 'onChangeAmountColumns'},
            store        : ['5', '10', '15', '20', '26'],
            width        : 90
        }, {
            module       : _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            bind         : {value: data => String(data.amountRows)},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Rows',
            listeners    : {change: 'onChangeAmountRows'},
            store        : ['5', '10', '15', '20'],
            width        : 90
        }, {
            ntype: 'component',
            cls  : ['header-spacer'],
            flex : 1
        }, {
            handler  : 'onDetachGridButtonClick',
            iconCls  : 'fas fa-table',
            reference: 'detach-grid-button',
            text     : 'Grid'
        }, {
            handler  : 'onDetachPieChartButtonClick',
            iconCls  : 'fas fa-chart-pie',
            reference: 'detach-pie-chart-button',
            text     : 'Pie Chart'
        }, {
            handler  : 'onDetachBarChartButtonClick',
            iconCls  : 'fas fa-chart-column',
            reference: 'detach-bar-chart-button',
            text     : 'Bar Chart'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            bind          : {checked: data => data.openWidgetsAsPopups},
            hideLabel     : true,
            listeners     : {change: 'onChangeOpenWidgetsAsPopups'},
            showValueLabel: true,
            valueLabelText: 'Popups'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HeaderToolbar));


/***/ }),

/***/ "./apps/colors/view/PieChartComponent.mjs":
/*!************************************************!*\
  !*** ./apps/colors/view/PieChartComponent.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/component/wrapper/AmChart.mjs */ "./src/component/wrapper/AmChart.mjs");


/**
 * @class Colors.view.PieChartComponent
 * @extends Neo.component.wrapper.AmChart
 */
class PieChartComponent extends _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.PieChartComponent'
         * @protected
         */
        className: 'Colors.view.PieChartComponent',
        /**
         * @member {String[]} baseCls=['colors-pie-chart']
         */
        baseCls: ['colors-pie-chart'],
        /**
         * @member {String} chartType='PieChart'
         */
        chartType: 'PieChart',
        /**
         * @member {Object} _vdom
         */
        /**
         * @member {Object} chartConfig
         */
        chartConfig: {
            series: [{
                type: 'PieSeries',

                colors: {
                    list: [
                        '#1c60a0',
                        '#206db6',
                        '#247acb',
                        '#2e87da',
                        '#4493de',
                        '#59a0e2',
                        '#6face6',
                        '#85b9ea',
                        '#9bc5ed',
                        '#b0d2f1'
                    ]
                },

                dataFields: {
                    category: 'color',
                    value   : 'count'
                }
            }]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(PieChartComponent));


/***/ }),

/***/ "./apps/colors/view/Viewport.mjs":
/*!***************************************!*\
  !*** ./apps/colors/view/Viewport.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");
/* harmony import */ var _BarChartComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BarChartComponent.mjs */ "./apps/colors/view/BarChartComponent.mjs");
/* harmony import */ var _HeaderToolbar_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HeaderToolbar.mjs */ "./apps/colors/view/HeaderToolbar.mjs");
/* harmony import */ var _PieChartComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PieChartComponent.mjs */ "./apps/colors/view/PieChartComponent.mjs");
/* harmony import */ var _GridContainer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GridContainer.mjs */ "./apps/colors/view/GridContainer.mjs");
/* harmony import */ var _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewportController.mjs */ "./apps/colors/view/ViewportController.mjs");
/* harmony import */ var _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ViewportStateProvider.mjs */ "./apps/colors/view/ViewportStateProvider.mjs");








/**
 * @class Colors.view.Viewport
 * @extends Neo.container.Viewport
 */
class Viewport extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.Viewport'
         * @protected
         */
        className: 'Colors.view.Viewport',
        /**
         * @member {String[]} cls=['colors-viewport']
         */
        cls: ['colors-viewport'],
        /**
         * @member {Neo.controller.Component} controller=ViewportController
         */
        controller: _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
        /**
         * @member {Object} layout
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _HeaderToolbar_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            flex  : 'none'
        }, {
            module   : _GridContainer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            reference: 'grid'
        }, {
            module   : _PieChartComponent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex     : 1.3,
            reference: 'pie-chart'
        }, {
            module   : _BarChartComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 1.3,
            reference: 'bar-chart'
        }],
        /**
         * @member {Neo.state.Provider} stateProvider=ViewportStateProvider
         */
        stateProvider: _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ }),

/***/ "./apps/colors/view/ViewportController.mjs":
/*!*************************************************!*\
  !*** ./apps/colors/view/ViewportController.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Colors.view.ViewportController
 * @extends Neo.controller.Component
 */
class ViewportController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.ViewportController'
         * @protected
         */
        className: 'Colors.view.ViewportController'
    }

    /**
     * @member {String[]} connectedApps=[]
     */
    connectedApps = []
    /**
     * @member {Number|null} intervalId
     */
    intervalId = null
    /**
     * @member {Object} widgetIndexMap
     */
    widgetIndexMap = {
        'bar-chart': 3,
        'pie-chart': 2,
        grid       : 1
    }

    /**
     * @param {String} name The name of the reference
     */
    async createBrowserWindow(name) {
        let me                      = this,
            {windowId}              = me,
            {config, windowConfigs} = Neo,
            {environment}           = config,
            firstWindowId           = parseInt(Object.keys(windowConfigs)[0]),
            {basePath}              = windowConfigs[firstWindowId],
            url;

        if (environment !== 'development') {
            basePath = `${basePath + environment}/`
        }

        url = `${basePath}apps/colors/childapps/widget/index.html?name=${name}`;

        if (me.getStateProvider().getData('openWidgetsAsPopups')) {
            let widget                     = me.getReference(name),
                winData                    = await Neo.Main.getWindowData({windowId} ),
                rect                       = await me.component.getDomRect(widget.vdom.id), // using the vdom id to always get the top-level node
                {height, left, top, width} = rect;

            height -= 50; // popup header in Chrome
            left   += winData.screenLeft;
            top    += (winData.outerHeight - winData.innerHeight + winData.screenTop);

            await Neo.Main.windowOpen({
                url,
                windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
                windowName    : name
            })
        } else {
            await Neo.Main.windowOpen({url, windowName: '_blank'})
        }
    }

    /**
     * @param args
     */
    destroy(...args) {
        this.intervalId && clearInterval(this.intervalId);
        super.destroy(...args)
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Number} data.windowId
     */
    async onAppConnect(data) {
        if (data.appName === 'ColorsWidget') {
            let me           = this,
                app          = Neo.apps[data.appName],
                mainView     = app.mainView,
                {windowId}   = data,
                url          = await Neo.Main.getByPath({path: 'document.URL', windowId}),
                widgetName   = new URL(url).searchParams.get('name'),
                widget       = me.getReference(widgetName),
                widgetParent = widget.up();

            me.connectedApps.push(widgetName);

            me.getReference(`detach-${widgetName}-button`).disabled = true;

            widgetParent.remove(widget, false);
            mainView.add(widget)
        }
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Number} data.windowId
     */
    async onAppDisconnect(data) {
        let me                  = this,
            {appName, windowId} = data,
            url                 = await Neo.Main.getByPath({path: 'document.URL', windowId}),
            widgetName          = new URL(url).searchParams.get('name'),
            widget              = me.getReference(widgetName),
            widgetParent        = widget.up();

        // Closing a non-main app needs to move the widget back into its original position & re-enable the show button
        if (appName === 'ColorsWidget') {
            widgetParent.remove(widget, false);
            me.component.insert(me.widgetIndexMap[widgetName], widget);

            me.getReference(`detach-${widgetName}-button`).disabled = false
        }
        // Close popup windows when closing or reloading the main window
        else if (appName === 'Colors') {
            Neo.Main.windowClose({names: me.connectedApps, windowId})
        }
    }

    /**
     * @param {Object} data
     */
    onChangeAmountColors(data) {
        this.updateDataProperty(data, 'amountColors',  data.value)
    }

    /**
     * @param {Object} data
     */
    onChangeAmountColumns(data) {
        this.updateDataProperty(data, 'amountColumns',  parseInt(data.value.name))
    }

    /**
     * @param {Object} data
     */
    onChangeAmountRows(data) {
        this.updateDataProperty(data, 'amountRows',  parseInt(data.value.name))
    }

    /**
     * @param {Object} data
     */
    onChangeOpenWidgetsAsPopups(data) {
        this.setState('openWidgetsAsPopups', data.value)
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onAppConnect,
            disconnect: me.onAppDisconnect,
            scope     : me
        })
    }

    /**
     *
     */
    onComponentConstructed() {
        super.onComponentConstructed();
        this.updateWidgets()
    }

    /**
     * @param {Object} data
     */
    async onDetachBarChartButtonClick(data) {
        await this.createBrowserWindow('bar-chart')
    }

    /**
     * @param {Object} data
     */
    async onDetachGridButtonClick(data) {
        await this.createBrowserWindow('grid')
    }

    /**
     * @param {Object} data
     */
    async onDetachPieChartButtonClick(data) {
        await this.createBrowserWindow('pie-chart')
    }

    /**
     * @param {Object} data
     */
    onStartButtonClick(data) {
        let me           = this,
            intervalTime = 1000 / 60; // assuming 60 FPS

        me.setState({isUpdating: true});

        if (!me.intervalId) {
            me.intervalId = setInterval(() => {
                me.updateWidgets()
            }, intervalTime)
        }
    }

    /**
     * @param {Object} data
     */
    onStopButtonClick(data) {
        let me = this;

        me.setState({isUpdating: false});

        if (me.intervalId) {
            clearInterval(me.intervalId);
            me.intervalId = null
        }
    }

    /**
     * @param {Object} data
     */
    updateCharts(data) {
        this.getReference('bar-chart').chartData = data;
        this.getReference('pie-chart').chartData = data
    }

    /**
     * If the WebSocket stream is not running, we need to pull new data once to see the new setting visually
     * @param {Object} data The change event data
     * @param {String} name The VM data property name
     * @param {Number|Object|null} value The new VM data property value
     */
    updateDataProperty(data, name, value) {
        let stateProvider = this.getStateProvider();

        stateProvider.setData(name, value);

        if (data.oldValue !== null && !stateProvider.getData('isUpdating')) {
            this.updateWidgets()
        }
    }

    /**
     * @param {Object[]} records
     */
    updateGrid(records) {
        let grid    = this.getReference('grid'),
            {store} = grid;

        if (store.getCount()) {
            grid.bulkUpdateRecords(records)
        } else {
            // Depending on the delay of the Socket Connection,
            // the next data package could still contain the old settings
            if (this.getStateProvider().getData('amountRows') === records.length) {
                store.data = records
            }
        }
    }

    /**
     *
     */
    async updateWidgets() {
        let me            = this,
            stateProvider = me.getStateProvider(),
            response;

        // Timing issue inside dist/development => the namespace might not be registered yet
        if (!Colors.backend) {
            await me.timeout(50);
            me.updateWidgets()
        } else {
            response = await Colors.backend.ColorService.read({
                amountColors : stateProvider.getData('amountColors'),
                amountColumns: stateProvider.getData('amountColumns'),
                amountRows   : stateProvider.getData('amountRows')
            });

            if (!me.isDestroyed) {
                let {data} = response;

                me.updateGrid(data.tableData);
                me.updateCharts(data.summaryData)
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportController));


/***/ }),

/***/ "./apps/colors/view/ViewportStateProvider.mjs":
/*!****************************************************!*\
  !*** ./apps/colors/view/ViewportStateProvider.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_Colors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/Colors.mjs */ "./apps/colors/store/Colors.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");



/**
 * @class Colors.view.ViewportStateProvider
 * @extends Neo.state.Provider
 */
class ViewportStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.ViewportStateProvider'
         * @protected
         */
        className: 'Colors.view.ViewportStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {Number} data.amountColors=10
             */
            amountColors: 10,
            /**
             * @member {Number} data.amountColumns=10
             */
            amountColumns: 10,
            /**
             * @member {Number} data.amountRows=10
             */
            amountRows: 10,
            /**
             * @member {Boolean} data.isUpdating=false
             */
            isUpdating: false,
            /**
             * @member {Boolean} data.openWidgetsAsPopups=true
             */
            openWidgetsAsPopups: true
        },
        /**
         * @member {Object} stores
         */
        stores: {
            colors: {
                module: _store_Colors_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportStateProvider));


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} text_=''
         */
        text_: '',
        /**
         * @member {Object} _vdom={tag: 'label'}
         */
        _vdom:
        {tag: 'label', draggable: false}
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        this.vdom.html = value;
        this.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ }),

/***/ "./src/component/wrapper/AmChart.mjs":
/*!*******************************************!*\
  !*** ./src/component/wrapper/AmChart.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render an amChart
 * Requires setting Neo.config.useAmCharts to true (or manually include the lib)
 * @class Neo.component.wrapper.AmChart
 * @extends Neo.component.Base
 */
class AmChart extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.wrapper.AmChart'
         * @protected
         */
        className: 'Neo.component.wrapper.AmChart',
        /**
         * @member {String} ntype='am-chart'
         * @protected
         */
        ntype: 'am-chart',
        /**
         * See: https://www.amcharts.com/docs/v4/
         * @member {Object} chartConfig_=null
         */
        chartConfig_: null,
        /**
         * Stores the chart data
         * @member {Array|null} chartData_=null
         */
        chartData_: null,
        /**
         * @member {String} chartType='XYChart'
         */
        chartType: 'XYChart',
        /**
         * It is not possible to define adapters via json, so we pass a flag to main instead
         * @member {Boolean} combineSeriesTooltip=false
         */
        combineSeriesTooltip: false,
        /**
         * Charts & maps can have different targets to apply the data to. E.g.:
         * myChart.data = data; // => ''
         * myChart.series.values[0].data = data; // => 'series.values.0'
         * Use a Neo.ns() conform syntax with dots between props
         * @member {String} dataPath=''
         */
        dataPath: '',
        /**
         * am4charts, am4maps
         * @member {String} package='am4charts'
         */
        package: 'am4charts',
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {style: {position: 'relative'}, cn: [
            {style: {position: 'absolute', height: '100%', width: '100%'}, cn: [
                {style: {color:'red',height: '100%'}}
            ]}
        ]}
    }

    /**
     * Triggered after the chartData config got changed
     * @param {Array|null} value
     * @param {Array|null} oldValue
     * @protected
     */
    afterSetChartData(value, oldValue) {
        let me = this,
            {appName, dataPath, id, windowId} = me;

        if (value) {
            Neo.main.addon.AmCharts.updateData({
                appName,
                data: value,
                dataPath,
                id,
                windowId
            })
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        let me                      = this,
            {appName, id, windowId} = me,
            opts                    = {appName, id, windowId};

        if (value === false && oldValue !== undefined) {
            Neo.main.addon.AmCharts.destroy(opts)
        }

        super.afterSetMounted(value, oldValue);

        if (value) {
            opts = {
                ...opts,
                combineSeriesTooltip: me.combineSeriesTooltip,
                config              : me.chartConfig,
                package             : me.package,
                type                : me.chartType
            };

            if (me.chartData) {
                opts.data     = me.chartData;
                opts.dataPath = me.dataPath;
            }

            me.timeout(50).then(() => {
                Neo.main.addon.AmCharts.create(opts).then(me.onChartMounted)
            })
        }
    }

    /**
     * Triggered before the chartConfig config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetChartConfig(value, oldValue) {
        if (!value) {
            console.error('wrapper.AmChart defined without a chartConfig', this.id)
        }

        this.parseItemConfigs(value);
        return value
    }

    destroy(...args) {
        let {appName, id, windowId} = this;

        Neo.main.addon.AmCharts.destroy({appName, id, windowId})

        super.destroy(...args)
    }

    /**
     *
     */
    getVdomRoot() {
        return this.vdom.cn[0].cn[0]
    }

    /**
     *
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0].childNodes[0]
    }

    /**
     * Override this method to trigger logic after the chart got mounted into the dom
     */
    onChartMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AmChart));


/***/ }),

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {appName, windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName,
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");




/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            const handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me = this,
            {handler, listeners, reference, renderer, validator} = component,
            eventHandler, handlerScope;

        if (handler && Neo.isString(handler)) {
            handlerScope = me.getHandlerScope(handler, component);

            // If the handler name was not resolved in the Component itself, bind it
            if (handlerScope !== true) {
                component.handler = handlerScope[handler].bind(component.handlerScope || handlerScope);
            }
        }

        listeners && Object.entries(listeners).forEach(([key, value]) => {
            if (key !== 'scope' && key !== 'delegate') {
                if (Neo.isString(value)) {
                    eventHandler = value;
                    handlerScope = me.getHandlerScope(eventHandler, component);

                    if (!handlerScope) {
                        _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].logError('Unknown event handler for', eventHandler, component)
                    } else if (handlerScope !== true) {
                        listeners[key] = {};
                        listeners[key].fn = handlerScope[eventHandler].bind(handlerScope)
                    }
                } else {
                    value?.forEach?.(listener => {
                        if (Neo.isObject(listener) && listener.hasOwnProperty('fn') && Neo.isString(listener.fn)) {
                            eventHandler = listener.fn;
                            handlerScope = me.getHandlerScope(eventHandler, component);

                            if (!handlerScope) {
                                console.error('Unknown event handler for', eventHandler, component)
                            } else if (handlerScope !== true) {
                                listener.fn = handlerScope[eventHandler].bind(handlerScope)
                            }
                        }
                    })
                }
            }
        });

        if (renderer && Neo.isString(renderer)) {
            handlerScope = me.getHandlerScope(renderer);

            if (handlerScope) {
                component.renderer = handlerScope[renderer].bind(handlerScope)
            }
        }

        if (validator && Neo.isString(validator)) {
            handlerScope = me.getHandlerScope(validator);

            if (!handlerScope) {
                _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].logError('Unknown validator for', component.id, component)
            } else {
                component.validator = handlerScope[validator].bind(handlerScope)
            }
        }

        if (reference) {
            me.references[reference] = component
        }
    }

    /**
     * @param {Neo.component.Base} component=this.component
     */
    parseDomListeners(component=this.component) {
        let me             = this,
            {domListeners} = component,
            eventHandler, scope;

        domListeners?.forEach(domListener => {
            Object.entries(domListener).forEach(([key, value]) => {
                eventHandler = null;

                if (key !== 'scope' && key !== 'delegate') {
                    if (Neo.isString(value)) {
                        eventHandler = value;
                    } else if (Neo.isObject(value) && value.hasOwnProperty('fn') && Neo.isString(value.fn)) {
                        eventHandler = value.fn;
                    }

                    if (eventHandler) {
                        scope = me.getHandlerScope(eventHandler);

                        // There can be string based listeners like 'up.onClick', which will resolved inside manager.DomEvents
                        // => Do nothing in case there is no match inside the controller hierarchy.
                        if (scope) {
                            domListener[key] = scope[eventHandler].bind(scope)
                        }
                    }
                }
            })
        })
    }

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    windowId           : me.windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (this.sortZone) {
            this.sortZone.windowId = value
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch(me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfY29sb3JzX2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7O0FBRXBDO0FBQ1AsY0FBYywwREFBUTtBQUN0QjtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMK0M7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFLO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q087QUFDUzs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQUs7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLGVBQWUsd0RBQVU7QUFDekI7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCb0M7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBFQUFnQjtBQUNoRDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztB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ZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUSwyREFBUyxXQUFXO0FBQzVEO0FBQ0E7O0FBRUEsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvbW9kZWwvQ29sb3IubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy9zdG9yZS9Db2xvcnMubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy92aWV3L0JhckNoYXJ0Q29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvdmlldy9HcmlkQ29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvdmlldy9IZWFkZXJUb29sYmFyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvdmlldy9QaWVDaGFydENvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL3ZpZXcvVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy92aWV3L1ZpZXdwb3J0Q29udHJvbGxlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL3ZpZXcvVmlld3BvcnRTdGF0ZVByb3ZpZGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9MYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvd3JhcHBlci9BbUNoYXJ0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90b29sYmFyL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWaWV3cG9ydCBmcm9tICcuL3ZpZXcvVmlld3BvcnQubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogVmlld3BvcnQsXG4gICAgbmFtZSAgICA6ICdDb2xvcnMnXG59KTtcbiIsImltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9Nb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMubW9kZWwuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5kYXRhLk1vZGVsXG4gKi9cbmNsYXNzIENvbG9yIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLm1vZGVsLkNvbG9yJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdDb2xvcnMubW9kZWwuQ29sb3InXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IHN0YXJ0Q2hhckNvZGUgPSAnQScuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICA9IDI2LCAvLyBhbW91bnQgb2YgY2hhcnMgaW5zaWRlIHRoZSBJU08gYmFzaWMgbGF0aW4gYWxwaGFiZXRcbiAgICAgICAgICAgIGZpZWxkcyAgICAgICAgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdpZCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29sdW1uJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnRDaGFyQ29kZSArIGkpLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHNcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbG9yKTtcbiIsImltcG9ydCBDb2xvck1vZGVsIGZyb20gJy4uL21vZGVsL0NvbG9yLm1qcyc7XG5pbXBvcnQgU3RvcmUgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZGF0YS9TdG9yZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMuc3RvcmUuQ29sb3JzXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5TdG9yZVxuICovXG5jbGFzcyBDb2xvcnMgZXh0ZW5kcyBTdG9yZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMuc3RvcmUuQ29sb3JzJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdDb2xvcnMuc3RvcmUuQ29sb3JzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLk1vZGVsfSBtb2RlbD1Db2xvck1vZGVsXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDogQ29sb3JNb2RlbFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29sb3JzKTtcbiIsImltcG9ydCBBbUNoYXJ0Q29tcG9uZW50IGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvd3JhcHBlci9BbUNoYXJ0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIENvbG9ycy52aWV3LkJhckNoYXJ0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LndyYXBwZXIuQW1DaGFydFxuICovXG5jbGFzcyBCYXJDaGFydENvbXBvbmVudCBleHRlbmRzIEFtQ2hhcnRDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnZpZXcuQmFyQ2hhcnRDb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LkJhckNoYXJ0Q29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnY29sb3JzLWJhci1jaGFydCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ2NvbG9ycy1iYXItY2hhcnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2hhcnRUeXBlPSdQaWVDaGFydCdcbiAgICAgICAgICovXG4gICAgICAgIGNoYXJ0VHlwZTogJ1hZQ2hhcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjaGFydENvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnRDb25maWc6IHtcbiAgICAgICAgICAgIHNlcmllczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ29sdW1uU2VyaWVzJyxcblxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwgIDogJ2NvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ2NvbG9yJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlYOiAnY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVkgICA6ICdjb3VudCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHhBeGVzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDYXRlZ29yeUF4aXMnLFxuXG4gICAgICAgICAgICAgICAgZGF0YUZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ2NvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdDb2xvcnMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdWYWx1ZUF4aXMnLFxuXG4gICAgICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ09jY3VycmVuY2VzIGluIGdyaWQgY2VsbHMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFyQ2hhcnRDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJhc2VHcmlkQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uL3NyYy9ncmlkL0NvbnRhaW5lci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMudmlldy5HcmlkQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5Db250YWluZXJcbiAqL1xuY2xhc3MgR3JpZENvbnRhaW5lciBleHRlbmRzIEJhc2VHcmlkQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0NvbG9ycy52aWV3LkdyaWRDb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LkdyaWRDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFtb3VudENvbHVtbnNfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFtb3VudENvbHVtbnNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFtb3VudFJvd3NfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFtb3VudFJvd3NfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBhbW91bnRDb2x1bW5zOiBkYXRhID0+IGRhdGEuYW1vdW50Q29sdW1ucyxcbiAgICAgICAgICAgIGFtb3VudFJvd3MgICA6IGRhdGEgPT4gZGF0YS5hbW91bnRSb3dzLFxuICAgICAgICAgICAgc3RvcmUgICAgICAgIDogJ3N0b3Jlcy5jb2xvcnMnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsnY29sb3JzLWdyaWQtY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWydjb2xvcnMtZ3JpZC1jb250YWluZXInXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYW1vdW50Q29sdW1ucyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QW1vdW50Q29sdW1ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdGFydENoYXJDb2RlID0gJ0EnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgY29sdW1ucyAgICAgICA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxBbGlnbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZpZWxkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgICA6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAgICAgOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgICA6IDQwXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgY3VycmVudENoYXI7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgdmFsdWU7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydENoYXJDb2RlICsgaSk7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhRmllbGQ6ICdjb2x1bW4nICsgY3VycmVudENoYXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyIDogJ3VwLmNvbG9yUmVuZGVyZXInLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgICA6IGN1cnJlbnRDaGFyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1uc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhbW91bnRSb3dzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBbW91bnRSb3dzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnN0b3JlPy5jbGVhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNvbG9yUmVuZGVyZXIoe3ZhbHVlfSkge1xuICAgICAgICByZXR1cm4ge2NsczogWydjb2xvci0nICsgdmFsdWVdLCBodG1sOiAnICd9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhHcmlkQ29udGFpbmVyKTtcbiIsImltcG9ydCBDaGVja0JveCAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9DaGVja0JveC5tanMnO1xuaW1wb3J0IENvbWJvQm94ICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NvbWJvQm94Lm1qcyc7XG5pbXBvcnQgTnVtYmVyRmllbGQgZnJvbSAnLi4vLi4vLi4vc3JjL2Zvcm0vZmllbGQvTnVtYmVyLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMudmlldy5IZWFkZXJUb29sYmFyXG4gKiBAZXh0ZW5kcyBOZW8udG9vbGJhci5CYXNlXG4gKi9cbmNsYXNzIEhlYWRlclRvb2xiYXIgZXh0ZW5kcyBUb29sYmFyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0NvbG9ycy52aWV3LkhlYWRlclRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LkhlYWRlclRvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ2NvbG9ycy1oZWFkZXItdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnY29sb3JzLWhlYWRlci10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2hib3gnLGFsaWduOidzdHJldGNoJyx3cmFwOid3cmFwJ31cbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnY2VudGVyJywgcGFjazogJ3N0YXJ0Jywgd3JhcDogJ3dyYXAnfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBpdGVtc1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICBiaW5kICAgOiB7ZGlzYWJsZWQ6IGRhdGEgPT4gZGF0YS5pc1VwZGF0aW5nfSxcbiAgICAgICAgICAgIGhhbmRsZXI6ICdvblN0YXJ0QnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgdGV4dCAgIDogJ1N0YXJ0J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBiaW5kICAgOiB7ZGlzYWJsZWQ6IGRhdGEgPT4gIWRhdGEuaXNVcGRhdGluZ30sXG4gICAgICAgICAgICBoYW5kbGVyOiAnb25TdG9wQnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgdGV4dCAgIDogJ1N0b3AnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IE51bWJlckZpZWxkLFxuICAgICAgICAgICAgYmluZCAgICAgICAgIDoge3ZhbHVlOiBkYXRhID0+IGRhdGEuYW1vdW50Q29sb3JzfSxcbiAgICAgICAgICAgIGNsZWFyYWJsZSAgICA6IGZhbHNlLFxuICAgICAgICAgICAgZWRpdGFibGUgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiAnaW5saW5lJyxcbiAgICAgICAgICAgIGxhYmVsVGV4dCAgICA6ICcjIENvbG9ycycsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgOiB7Y2hhbmdlOiAnb25DaGFuZ2VBbW91bnRDb2xvcnMnfSxcbiAgICAgICAgICAgIG1heFZhbHVlICAgICA6IDEwLFxuICAgICAgICAgICAgbWluVmFsdWUgICAgIDogMyxcbiAgICAgICAgICAgIHdpZHRoICAgICAgICA6IDkwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IENvbWJvQm94LFxuICAgICAgICAgICAgYmluZCAgICAgICAgIDoge3ZhbHVlOiBkYXRhID0+IFN0cmluZyhkYXRhLmFtb3VudENvbHVtbnMpfSxcbiAgICAgICAgICAgIGNsZWFyYWJsZSAgICA6IGZhbHNlLFxuICAgICAgICAgICAgZWRpdGFibGUgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiAnaW5saW5lJyxcbiAgICAgICAgICAgIGxhYmVsVGV4dCAgICA6ICcjIENvbHVtbnMnLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgIDoge2NoYW5nZTogJ29uQ2hhbmdlQW1vdW50Q29sdW1ucyd9LFxuICAgICAgICAgICAgc3RvcmUgICAgICAgIDogWyc1JywgJzEwJywgJzE1JywgJzIwJywgJzI2J10sXG4gICAgICAgICAgICB3aWR0aCAgICAgICAgOiA5MFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgOiBDb21ib0JveCxcbiAgICAgICAgICAgIGJpbmQgICAgICAgICA6IHt2YWx1ZTogZGF0YSA9PiBTdHJpbmcoZGF0YS5hbW91bnRSb3dzKX0sXG4gICAgICAgICAgICBjbGVhcmFibGUgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGVkaXRhYmxlICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogJ2lubGluZScsXG4gICAgICAgICAgICBsYWJlbFRleHQgICAgOiAnIyBSb3dzJyxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICA6IHtjaGFuZ2U6ICdvbkNoYW5nZUFtb3VudFJvd3MnfSxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICA6IFsnNScsICcxMCcsICcxNScsICcyMCddLFxuICAgICAgICAgICAgd2lkdGggICAgICAgIDogOTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbnR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgY2xzICA6IFsnaGVhZGVyLXNwYWNlciddLFxuICAgICAgICAgICAgZmxleCA6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaGFuZGxlciAgOiAnb25EZXRhY2hHcmlkQnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgaWNvbkNscyAgOiAnZmFzIGZhLXRhYmxlJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ2RldGFjaC1ncmlkLWJ1dHRvbicsXG4gICAgICAgICAgICB0ZXh0ICAgICA6ICdHcmlkJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBoYW5kbGVyICA6ICdvbkRldGFjaFBpZUNoYXJ0QnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgaWNvbkNscyAgOiAnZmFzIGZhLWNoYXJ0LXBpZScsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdkZXRhY2gtcGllLWNoYXJ0LWJ1dHRvbicsXG4gICAgICAgICAgICB0ZXh0ICAgICA6ICdQaWUgQ2hhcnQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGhhbmRsZXIgIDogJ29uRGV0YWNoQmFyQ2hhcnRCdXR0b25DbGljaycsXG4gICAgICAgICAgICBpY29uQ2xzICA6ICdmYXMgZmEtY2hhcnQtY29sdW1uJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ2RldGFjaC1iYXItY2hhcnQtYnV0dG9uJyxcbiAgICAgICAgICAgIHRleHQgICAgIDogJ0JhciBDaGFydCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IENoZWNrQm94LFxuICAgICAgICAgICAgYmluZCAgICAgICAgICA6IHtjaGVja2VkOiBkYXRhID0+IGRhdGEub3BlbldpZGdldHNBc1BvcHVwc30sXG4gICAgICAgICAgICBoaWRlTGFiZWwgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICAgOiB7Y2hhbmdlOiAnb25DaGFuZ2VPcGVuV2lkZ2V0c0FzUG9wdXBzJ30sXG4gICAgICAgICAgICBzaG93VmFsdWVMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlTGFiZWxUZXh0OiAnUG9wdXBzJ1xuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSGVhZGVyVG9vbGJhcik7XG4iLCJpbXBvcnQgQW1DaGFydENvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9zcmMvY29tcG9uZW50L3dyYXBwZXIvQW1DaGFydC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMudmlldy5QaWVDaGFydENvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC53cmFwcGVyLkFtQ2hhcnRcbiAqL1xuY2xhc3MgUGllQ2hhcnRDb21wb25lbnQgZXh0ZW5kcyBBbUNoYXJ0Q29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0NvbG9ycy52aWV3LlBpZUNoYXJ0Q29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdDb2xvcnMudmlldy5QaWVDaGFydENvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ2NvbG9ycy1waWUtY2hhcnQnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWydjb2xvcnMtcGllLWNoYXJ0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNoYXJ0VHlwZT0nUGllQ2hhcnQnXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydFR5cGU6ICdQaWVDaGFydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjaGFydENvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnRDb25maWc6IHtcbiAgICAgICAgICAgIHNlcmllczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiAnUGllU2VyaWVzJyxcblxuICAgICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgICAgICBsaXN0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzFjNjBhMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzIwNmRiNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzI0N2FjYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzJlODdkYScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzQ0OTNkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzU5YTBlMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzZmYWNlNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzg1YjllYScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIzliYzVlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnI2IwZDJmMSdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBkYXRhRmllbGRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAnY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgIDogJ2NvdW50J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBpZUNoYXJ0Q29tcG9uZW50KTtcbiIsImltcG9ydCBCYXNlVmlld3BvcnQgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMnO1xuaW1wb3J0IEJhckNoYXJ0Q29tcG9uZW50ICAgICBmcm9tICcuL0JhckNoYXJ0Q29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgSGVhZGVyVG9vbGJhciAgICAgICAgIGZyb20gJy4vSGVhZGVyVG9vbGJhci5tanMnO1xuaW1wb3J0IFBpZUNoYXJ0Q29tcG9uZW50ICAgICBmcm9tICcuL1BpZUNoYXJ0Q29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgR3JpZENvbnRhaW5lciAgICAgICAgIGZyb20gJy4vR3JpZENvbnRhaW5lci5tanMnO1xuaW1wb3J0IFZpZXdwb3J0Q29udHJvbGxlciAgICBmcm9tICcuL1ZpZXdwb3J0Q29udHJvbGxlci5tanMnO1xuaW1wb3J0IFZpZXdwb3J0U3RhdGVQcm92aWRlciBmcm9tICcuL1ZpZXdwb3J0U3RhdGVQcm92aWRlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMudmlldy5WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICovXG5jbGFzcyBWaWV3cG9ydCBleHRlbmRzIEJhc2VWaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMudmlldy5WaWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLnZpZXcuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ2NvbG9ycy12aWV3cG9ydCddXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnY29sb3JzLXZpZXdwb3J0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR9IGNvbnRyb2xsZXI9Vmlld3BvcnRDb250cm9sbGVyXG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sbGVyOiBWaWV3cG9ydENvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dFxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBIZWFkZXJUb29sYmFyLFxuICAgICAgICAgICAgZmxleCAgOiAnbm9uZSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBHcmlkQ29udGFpbmVyLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnZ3JpZCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBQaWVDaGFydENvbXBvbmVudCxcbiAgICAgICAgICAgIGZsZXggICAgIDogMS4zLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAncGllLWNoYXJ0J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IEJhckNoYXJ0Q29tcG9uZW50LFxuICAgICAgICAgICAgZmxleCAgICAgOiAxLjMsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdiYXItY2hhcnQnXG4gICAgICAgIH1dLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnN0YXRlLlByb3ZpZGVyfSBzdGF0ZVByb3ZpZGVyPVZpZXdwb3J0U3RhdGVQcm92aWRlclxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGVQcm92aWRlcjogVmlld3BvcnRTdGF0ZVByb3ZpZGVyXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydCk7XG4iLCJpbXBvcnQgQ29udHJvbGxlciBmcm9tICcuLi8uLi8uLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgQ29sb3JzLnZpZXcuVmlld3BvcnRDb250cm9sbGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqL1xuY2xhc3MgVmlld3BvcnRDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMudmlldy5WaWV3cG9ydENvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LlZpZXdwb3J0Q29udHJvbGxlcidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY29ubmVjdGVkQXBwcz1bXVxuICAgICAqL1xuICAgIGNvbm5lY3RlZEFwcHMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpbnRlcnZhbElkXG4gICAgICovXG4gICAgaW50ZXJ2YWxJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHdpZGdldEluZGV4TWFwXG4gICAgICovXG4gICAgd2lkZ2V0SW5kZXhNYXAgPSB7XG4gICAgICAgICdiYXItY2hhcnQnOiAzLFxuICAgICAgICAncGllLWNoYXJ0JzogMixcbiAgICAgICAgZ3JpZCAgICAgICA6IDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQnJvd3NlcldpbmRvdyhuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7d2luZG93SWR9ICAgICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAge2NvbmZpZywgd2luZG93Q29uZmlnc30gPSBOZW8sXG4gICAgICAgICAgICB7ZW52aXJvbm1lbnR9ICAgICAgICAgICA9IGNvbmZpZyxcbiAgICAgICAgICAgIGZpcnN0V2luZG93SWQgICAgICAgICAgID0gcGFyc2VJbnQoT2JqZWN0LmtleXMod2luZG93Q29uZmlncylbMF0pLFxuICAgICAgICAgICAge2Jhc2VQYXRofSAgICAgICAgICAgICAgPSB3aW5kb3dDb25maWdzW2ZpcnN0V2luZG93SWRdLFxuICAgICAgICAgICAgdXJsO1xuXG4gICAgICAgIGlmIChlbnZpcm9ubWVudCAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgYmFzZVBhdGggPSBgJHtiYXNlUGF0aCArIGVudmlyb25tZW50fS9gXG4gICAgICAgIH1cblxuICAgICAgICB1cmwgPSBgJHtiYXNlUGF0aH1hcHBzL2NvbG9ycy9jaGlsZGFwcHMvd2lkZ2V0L2luZGV4Lmh0bWw/bmFtZT0ke25hbWV9YDtcblxuICAgICAgICBpZiAobWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoJ29wZW5XaWRnZXRzQXNQb3B1cHMnKSkge1xuICAgICAgICAgICAgbGV0IHdpZGdldCAgICAgICAgICAgICAgICAgICAgID0gbWUuZ2V0UmVmZXJlbmNlKG5hbWUpLFxuICAgICAgICAgICAgICAgIHdpbkRhdGEgICAgICAgICAgICAgICAgICAgID0gYXdhaXQgTmVvLk1haW4uZ2V0V2luZG93RGF0YSh7d2luZG93SWR9ICksXG4gICAgICAgICAgICAgICAgcmVjdCAgICAgICAgICAgICAgICAgICAgICAgPSBhd2FpdCBtZS5jb21wb25lbnQuZ2V0RG9tUmVjdCh3aWRnZXQudmRvbS5pZCksIC8vIHVzaW5nIHRoZSB2ZG9tIGlkIHRvIGFsd2F5cyBnZXQgdGhlIHRvcC1sZXZlbCBub2RlXG4gICAgICAgICAgICAgICAge2hlaWdodCwgbGVmdCwgdG9wLCB3aWR0aH0gPSByZWN0O1xuXG4gICAgICAgICAgICBoZWlnaHQgLT0gNTA7IC8vIHBvcHVwIGhlYWRlciBpbiBDaHJvbWVcbiAgICAgICAgICAgIGxlZnQgICArPSB3aW5EYXRhLnNjcmVlbkxlZnQ7XG4gICAgICAgICAgICB0b3AgICAgKz0gKHdpbkRhdGEub3V0ZXJIZWlnaHQgLSB3aW5EYXRhLmlubmVySGVpZ2h0ICsgd2luRGF0YS5zY3JlZW5Ub3ApO1xuXG4gICAgICAgICAgICBhd2FpdCBOZW8uTWFpbi53aW5kb3dPcGVuKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgd2luZG93RmVhdHVyZXM6IGBoZWlnaHQ9JHtoZWlnaHR9LGxlZnQ9JHtsZWZ0fSx0b3A9JHt0b3B9LHdpZHRoPSR7d2lkdGh9YCxcbiAgICAgICAgICAgICAgICB3aW5kb3dOYW1lICAgIDogbmFtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IE5lby5NYWluLndpbmRvd09wZW4oe3VybCwgd2luZG93TmFtZTogJ19ibGFuayd9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElkICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgYXN5bmMgb25BcHBDb25uZWN0KGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuYXBwTmFtZSA9PT0gJ0NvbG9yc1dpZGdldCcpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFwcCAgICAgICAgICA9IE5lby5hcHBzW2RhdGEuYXBwTmFtZV0sXG4gICAgICAgICAgICAgICAgbWFpblZpZXcgICAgID0gYXBwLm1haW5WaWV3LFxuICAgICAgICAgICAgICAgIHt3aW5kb3dJZH0gICA9IGRhdGEsXG4gICAgICAgICAgICAgICAgdXJsICAgICAgICAgID0gYXdhaXQgTmVvLk1haW4uZ2V0QnlQYXRoKHtwYXRoOiAnZG9jdW1lbnQuVVJMJywgd2luZG93SWR9KSxcbiAgICAgICAgICAgICAgICB3aWRnZXROYW1lICAgPSBuZXcgVVJMKHVybCkuc2VhcmNoUGFyYW1zLmdldCgnbmFtZScpLFxuICAgICAgICAgICAgICAgIHdpZGdldCAgICAgICA9IG1lLmdldFJlZmVyZW5jZSh3aWRnZXROYW1lKSxcbiAgICAgICAgICAgICAgICB3aWRnZXRQYXJlbnQgPSB3aWRnZXQudXAoKTtcblxuICAgICAgICAgICAgbWUuY29ubmVjdGVkQXBwcy5wdXNoKHdpZGdldE5hbWUpO1xuXG4gICAgICAgICAgICBtZS5nZXRSZWZlcmVuY2UoYGRldGFjaC0ke3dpZGdldE5hbWV9LWJ1dHRvbmApLmRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgd2lkZ2V0UGFyZW50LnJlbW92ZSh3aWRnZXQsIGZhbHNlKTtcbiAgICAgICAgICAgIG1haW5WaWV3LmFkZCh3aWRnZXQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIGFzeW5jIG9uQXBwRGlzY29ubmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lLCB3aW5kb3dJZH0gPSBkYXRhLFxuICAgICAgICAgICAgdXJsICAgICAgICAgICAgICAgICA9IGF3YWl0IE5lby5NYWluLmdldEJ5UGF0aCh7cGF0aDogJ2RvY3VtZW50LlVSTCcsIHdpbmRvd0lkfSksXG4gICAgICAgICAgICB3aWRnZXROYW1lICAgICAgICAgID0gbmV3IFVSTCh1cmwpLnNlYXJjaFBhcmFtcy5nZXQoJ25hbWUnKSxcbiAgICAgICAgICAgIHdpZGdldCAgICAgICAgICAgICAgPSBtZS5nZXRSZWZlcmVuY2Uod2lkZ2V0TmFtZSksXG4gICAgICAgICAgICB3aWRnZXRQYXJlbnQgICAgICAgID0gd2lkZ2V0LnVwKCk7XG5cbiAgICAgICAgLy8gQ2xvc2luZyBhIG5vbi1tYWluIGFwcCBuZWVkcyB0byBtb3ZlIHRoZSB3aWRnZXQgYmFjayBpbnRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiAmIHJlLWVuYWJsZSB0aGUgc2hvdyBidXR0b25cbiAgICAgICAgaWYgKGFwcE5hbWUgPT09ICdDb2xvcnNXaWRnZXQnKSB7XG4gICAgICAgICAgICB3aWRnZXRQYXJlbnQucmVtb3ZlKHdpZGdldCwgZmFsc2UpO1xuICAgICAgICAgICAgbWUuY29tcG9uZW50Lmluc2VydChtZS53aWRnZXRJbmRleE1hcFt3aWRnZXROYW1lXSwgd2lkZ2V0KTtcblxuICAgICAgICAgICAgbWUuZ2V0UmVmZXJlbmNlKGBkZXRhY2gtJHt3aWRnZXROYW1lfS1idXR0b25gKS5kaXNhYmxlZCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvc2UgcG9wdXAgd2luZG93cyB3aGVuIGNsb3Npbmcgb3IgcmVsb2FkaW5nIHRoZSBtYWluIHdpbmRvd1xuICAgICAgICBlbHNlIGlmIChhcHBOYW1lID09PSAnQ29sb3JzJykge1xuICAgICAgICAgICAgTmVvLk1haW4ud2luZG93Q2xvc2Uoe25hbWVzOiBtZS5jb25uZWN0ZWRBcHBzLCB3aW5kb3dJZH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2hhbmdlQW1vdW50Q29sb3JzKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhUHJvcGVydHkoZGF0YSwgJ2Ftb3VudENvbG9ycycsICBkYXRhLnZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DaGFuZ2VBbW91bnRDb2x1bW5zKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhUHJvcGVydHkoZGF0YSwgJ2Ftb3VudENvbHVtbnMnLCAgcGFyc2VJbnQoZGF0YS52YWx1ZS5uYW1lKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2hhbmdlQW1vdW50Um93cyhkYXRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVByb3BlcnR5KGRhdGEsICdhbW91bnRSb3dzJywgIHBhcnNlSW50KGRhdGEudmFsdWUubmFtZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNoYW5nZU9wZW5XaWRnZXRzQXNQb3B1cHMoZGF0YSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCdvcGVuV2lkZ2V0c0FzUG9wdXBzJywgZGF0YS52YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uQXBwQ29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uQXBwRGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudENvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbXBvbmVudENvbnN0cnVjdGVkKCk7XG4gICAgICAgIHRoaXMudXBkYXRlV2lkZ2V0cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkRldGFjaEJhckNoYXJ0QnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUJyb3dzZXJXaW5kb3coJ2Jhci1jaGFydCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkRldGFjaEdyaWRCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlQnJvd3NlcldpbmRvdygnZ3JpZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkRldGFjaFBpZUNoYXJ0QnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUJyb3dzZXJXaW5kb3coJ3BpZS1jaGFydCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblN0YXJ0QnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGludGVydmFsVGltZSA9IDEwMDAgLyA2MDsgLy8gYXNzdW1pbmcgNjAgRlBTXG5cbiAgICAgICAgbWUuc2V0U3RhdGUoe2lzVXBkYXRpbmc6IHRydWV9KTtcblxuICAgICAgICBpZiAoIW1lLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIG1lLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlV2lkZ2V0cygpXG4gICAgICAgICAgICB9LCBpbnRlcnZhbFRpbWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU3RvcEJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zZXRTdGF0ZSh7aXNVcGRhdGluZzogZmFsc2V9KTtcblxuICAgICAgICBpZiAobWUuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChtZS5pbnRlcnZhbElkKTtcbiAgICAgICAgICAgIG1lLmludGVydmFsSWQgPSBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHVwZGF0ZUNoYXJ0cyhkYXRhKSB7XG4gICAgICAgIHRoaXMuZ2V0UmVmZXJlbmNlKCdiYXItY2hhcnQnKS5jaGFydERhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgncGllLWNoYXJ0JykuY2hhcnREYXRhID0gZGF0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBXZWJTb2NrZXQgc3RyZWFtIGlzIG5vdCBydW5uaW5nLCB3ZSBuZWVkIHRvIHB1bGwgbmV3IGRhdGEgb25jZSB0byBzZWUgdGhlIG5ldyBzZXR0aW5nIHZpc3VhbGx5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGNoYW5nZSBldmVudCBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIFZNIGRhdGEgcHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdHxudWxsfSB2YWx1ZSBUaGUgbmV3IFZNIGRhdGEgcHJvcGVydHkgdmFsdWVcbiAgICAgKi9cbiAgICB1cGRhdGVEYXRhUHJvcGVydHkoZGF0YSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHN0YXRlUHJvdmlkZXIgPSB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKTtcblxuICAgICAgICBzdGF0ZVByb3ZpZGVyLnNldERhdGEobmFtZSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChkYXRhLm9sZFZhbHVlICE9PSBudWxsICYmICFzdGF0ZVByb3ZpZGVyLmdldERhdGEoJ2lzVXBkYXRpbmcnKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVXaWRnZXRzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHJlY29yZHNcbiAgICAgKi9cbiAgICB1cGRhdGVHcmlkKHJlY29yZHMpIHtcbiAgICAgICAgbGV0IGdyaWQgICAgPSB0aGlzLmdldFJlZmVyZW5jZSgnZ3JpZCcpLFxuICAgICAgICAgICAge3N0b3JlfSA9IGdyaWQ7XG5cbiAgICAgICAgaWYgKHN0b3JlLmdldENvdW50KCkpIHtcbiAgICAgICAgICAgIGdyaWQuYnVsa1VwZGF0ZVJlY29yZHMocmVjb3JkcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgZGVsYXkgb2YgdGhlIFNvY2tldCBDb25uZWN0aW9uLFxuICAgICAgICAgICAgLy8gdGhlIG5leHQgZGF0YSBwYWNrYWdlIGNvdWxkIHN0aWxsIGNvbnRhaW4gdGhlIG9sZCBzZXR0aW5nc1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoJ2Ftb3VudFJvd3MnKSA9PT0gcmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5kYXRhID0gcmVjb3Jkc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVXaWRnZXRzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBzdGF0ZVByb3ZpZGVyID0gbWUuZ2V0U3RhdGVQcm92aWRlcigpLFxuICAgICAgICAgICAgcmVzcG9uc2U7XG5cbiAgICAgICAgLy8gVGltaW5nIGlzc3VlIGluc2lkZSBkaXN0L2RldmVsb3BtZW50ID0+IHRoZSBuYW1lc3BhY2UgbWlnaHQgbm90IGJlIHJlZ2lzdGVyZWQgeWV0XG4gICAgICAgIGlmICghQ29sb3JzLmJhY2tlbmQpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoNTApO1xuICAgICAgICAgICAgbWUudXBkYXRlV2lkZ2V0cygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IENvbG9ycy5iYWNrZW5kLkNvbG9yU2VydmljZS5yZWFkKHtcbiAgICAgICAgICAgICAgICBhbW91bnRDb2xvcnMgOiBzdGF0ZVByb3ZpZGVyLmdldERhdGEoJ2Ftb3VudENvbG9ycycpLFxuICAgICAgICAgICAgICAgIGFtb3VudENvbHVtbnM6IHN0YXRlUHJvdmlkZXIuZ2V0RGF0YSgnYW1vdW50Q29sdW1ucycpLFxuICAgICAgICAgICAgICAgIGFtb3VudFJvd3MgICA6IHN0YXRlUHJvdmlkZXIuZ2V0RGF0YSgnYW1vdW50Um93cycpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGxldCB7ZGF0YX0gPSByZXNwb25zZTtcblxuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUdyaWQoZGF0YS50YWJsZURhdGEpO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUNoYXJ0cyhkYXRhLnN1bW1hcnlEYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydENvbnRyb2xsZXIpO1xuIiwiaW1wb3J0IENvbG9yc1N0b3JlICAgZnJvbSAnLi4vc3RvcmUvQ29sb3JzLm1qcyc7XG5pbXBvcnQgU3RhdGVQcm92aWRlciBmcm9tICcuLi8uLi8uLi9zcmMvc3RhdGUvUHJvdmlkZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgQ29sb3JzLnZpZXcuVmlld3BvcnRTdGF0ZVByb3ZpZGVyXG4gKiBAZXh0ZW5kcyBOZW8uc3RhdGUuUHJvdmlkZXJcbiAqL1xuY2xhc3MgVmlld3BvcnRTdGF0ZVByb3ZpZGVyIGV4dGVuZHMgU3RhdGVQcm92aWRlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMudmlldy5WaWV3cG9ydFN0YXRlUHJvdmlkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LlZpZXdwb3J0U3RhdGVQcm92aWRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBkYXRhLmFtb3VudENvbG9ycz0xMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhbW91bnRDb2xvcnM6IDEwLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGRhdGEuYW1vdW50Q29sdW1ucz0xMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhbW91bnRDb2x1bW5zOiAxMCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBkYXRhLmFtb3VudFJvd3M9MTBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYW1vdW50Um93czogMTAsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRhdGEuaXNVcGRhdGluZz1mYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1VwZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGF0YS5vcGVuV2lkZ2V0c0FzUG9wdXBzPXRydWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb3BlbldpZGdldHNBc1BvcHVwczogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdG9yZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0b3Jlczoge1xuICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBDb2xvcnNTdG9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydFN0YXRlUHJvdmlkZXIpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjbGFzcyB0byByZW5kZXIgYSBsYWJlbCB3aXRoIGEgdGV4dFxuICogQGNsYXNzIE5lby5jb21wb25lbnQuTGFiZWxcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBMYWJlbCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkxhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkxhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWxhYmVsJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWxhYmVsJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRleHRfPScnXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0XzogJycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt0YWc6ICdsYWJlbCd9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3RhZzogJ2xhYmVsJywgZHJhZ2dhYmxlOiBmYWxzZX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRleHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLmh0bWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTGFiZWwpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGFuIGFtQ2hhcnRcbiAqIFJlcXVpcmVzIHNldHRpbmcgTmVvLmNvbmZpZy51c2VBbUNoYXJ0cyB0byB0cnVlIChvciBtYW51YWxseSBpbmNsdWRlIHRoZSBsaWIpXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC53cmFwcGVyLkFtQ2hhcnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBBbUNoYXJ0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQud3JhcHBlci5BbUNoYXJ0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LndyYXBwZXIuQW1DaGFydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdhbS1jaGFydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdhbS1jaGFydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWU6IGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y0L1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNoYXJ0Q29uZmlnXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydENvbmZpZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGNoYXJ0IGRhdGFcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gY2hhcnREYXRhXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydERhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjaGFydFR5cGU9J1hZQ2hhcnQnXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydFR5cGU6ICdYWUNoYXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZWZpbmUgYWRhcHRlcnMgdmlhIGpzb24sIHNvIHdlIHBhc3MgYSBmbGFnIHRvIG1haW4gaW5zdGVhZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjb21iaW5lU2VyaWVzVG9vbHRpcD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY29tYmluZVNlcmllc1Rvb2x0aXA6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhcnRzICYgbWFwcyBjYW4gaGF2ZSBkaWZmZXJlbnQgdGFyZ2V0cyB0byBhcHBseSB0aGUgZGF0YSB0by4gRS5nLjpcbiAgICAgICAgICogbXlDaGFydC5kYXRhID0gZGF0YTsgLy8gPT4gJydcbiAgICAgICAgICogbXlDaGFydC5zZXJpZXMudmFsdWVzWzBdLmRhdGEgPSBkYXRhOyAvLyA9PiAnc2VyaWVzLnZhbHVlcy4wJ1xuICAgICAgICAgKiBVc2UgYSBOZW8ubnMoKSBjb25mb3JtIHN5bnRheCB3aXRoIGRvdHMgYmV0d2VlbiBwcm9wc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGRhdGFQYXRoPScnXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhUGF0aDogJycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbTRjaGFydHMsIGFtNG1hcHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwYWNrYWdlPSdhbTRjaGFydHMnXG4gICAgICAgICAqL1xuICAgICAgICBwYWNrYWdlOiAnYW00Y2hhcnRzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7c3R5bGU6IHtwb3NpdGlvbjogJ3JlbGF0aXZlJ30sIGNuOiBbXG4gICAgICAgICAgICB7c3R5bGU6IHtwb3NpdGlvbjogJ2Fic29sdXRlJywgaGVpZ2h0OiAnMTAwJScsIHdpZHRoOiAnMTAwJSd9LCBjbjogW1xuICAgICAgICAgICAgICAgIHtzdHlsZToge2NvbG9yOidyZWQnLGhlaWdodDogJzEwMCUnfX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjaGFydERhdGEgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtBcnJheXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDaGFydERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZSwgZGF0YVBhdGgsIGlkLCB3aW5kb3dJZH0gPSBtZTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkFtQ2hhcnRzLnVwZGF0ZURhdGEoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YVBhdGgsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIG9wdHMgICAgICAgICAgICAgICAgICAgID0ge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH07XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSAmJiBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5BbUNoYXJ0cy5kZXN0cm95KG9wdHMpXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICBjb21iaW5lU2VyaWVzVG9vbHRpcDogbWUuY29tYmluZVNlcmllc1Rvb2x0aXAsXG4gICAgICAgICAgICAgICAgY29uZmlnICAgICAgICAgICAgICA6IG1lLmNoYXJ0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhY2thZ2UgICAgICAgICAgICAgOiBtZS5wYWNrYWdlLFxuICAgICAgICAgICAgICAgIHR5cGUgICAgICAgICAgICAgICAgOiBtZS5jaGFydFR5cGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChtZS5jaGFydERhdGEpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmRhdGEgICAgID0gbWUuY2hhcnREYXRhO1xuICAgICAgICAgICAgICAgIG9wdHMuZGF0YVBhdGggPSBtZS5kYXRhUGF0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uQW1DaGFydHMuY3JlYXRlKG9wdHMpLnRoZW4obWUub25DaGFydE1vdW50ZWQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2hhcnRDb25maWcgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDaGFydENvbmZpZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignd3JhcHBlci5BbUNoYXJ0IGRlZmluZWQgd2l0aG91dCBhIGNoYXJ0Q29uZmlnJywgdGhpcy5pZClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFyc2VJdGVtQ29uZmlncyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkFtQ2hhcnRzLmRlc3Ryb3koe2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0pXG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGUuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gdHJpZ2dlciBsb2dpYyBhZnRlciB0aGUgY2hhcnQgZ290IG1vdW50ZWQgaW50byB0aGUgZG9tXG4gICAgICovXG4gICAgb25DaGFydE1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEFtQ2hhcnQpO1xuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzICduZW8tYm9keS12aWV3cG9ydCcgdG8gdGhlIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXBwbHlCb2R5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc3VtaW5nIHRoYXQgYSBWaWV3cG9ydCBpcyB0aGUgdG9wIGxldmVsIHZpZXcgb2YgeW91ciBhcHAsIGFuZCB5b3Ugd2FudCB0byBtb3VudCBpdCByaWdodCBhd2F5LlxuICAgICAgICAgKiBDb3VsZCBiZSB3aXRob3V0IGFueSBpdGVtcy4gVXNlIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXZpZXdwb3J0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXZpZXdwb3J0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgYSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyIGFuZCBmaXJlcyBhIGN1c3RvbSByZXNpemUgZXZlbnRcbiAgICAgICAgICogd2hpY2ggb3RoZXIgaW5zdGFuY2VzIGNhbiBzdWJzY3JpYmUgdG8uXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vbml0b3JTaXplXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9uaXRvclNpemVfOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLm1vbml0b3JTaXplKSB7XG4gICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW3tyZXNpemU6IG1lLm9uRG9tUmVzaXplLCBzY29wZTogbWV9XSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCB7YXBwTmFtZSwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICB0aGlzLmFwcGx5Qm9keUNscyAmJiBOZW8ubWFpbi5Eb21BY2Nlc3MuYXBwbHlCb2R5Q2xzKHtcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICBjbHM6IFsnbmVvLWJvZHktdmlld3BvcnQnXSxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRvbVJlc2l6ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVzaXplJywgZGF0YSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXdwb3J0KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9Mb2dnZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udHJvbGxlci5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LWNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LWNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlZmVyZW5jZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZWZlcmVuY2VzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb21wb25lbnR9ID0gbWU7XG5cbiAgICAgICAgbWUucmVmZXJlbmNlcyA9IHt9O1xuXG4gICAgICAgIGlmIChjb21wb25lbnQuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnQub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHBhcmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYXJlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCB0aGlzLmdldFBhcmVudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IFtjb21wb25lbnRdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxCb29sZWFufG51bGx9XG4gICAgICovXG4gICAgZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnR9ID0gbWU7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhzIGZ1bmN0aW9uICpuYW1lKiBmaXJzdCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZi5cbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgaXQsIHJldHVybiB0cnVlIHNvIGNhbGxpbmcgY29kZSBrbm93cyBub3QgdG8gY29udGludWUgdG8gc2VhcmNoLlxuICAgICAgICAgICAgY29uc3QgaGFuZGxlckNiID0gcmVzb2x2ZUNhbGxiYWNrKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyIGZuIGlzIHJlc29sdmVkIGluIHRoZSBDb21wb25lbnQgb3IgaXRzIG93biBwYXJlbnQgY2hhaW4uXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBzdGF0dXMgaW5kaWNhdGluZyB0aGF0IHdlIGRvIG5vdCBuZWVkIGFuIGVhcmx5IGJpbmRpbmdcbiAgICAgICAgICAgIGlmIChoYW5kbGVyQ2IuZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5pc0Z1bmN0aW9uKG1lW2hhbmRsZXJOYW1lXSkgP1xuICAgICAgICAgICAgbWUgOiBwYXJlbnQ/LmdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBjb250cm9sbGVyIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5jb21wb25lbnQucGFyZW50Py5nZXRDb250cm9sbGVyKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHVwZGF0ZSBjaGFuZ2VkIHJlZmVyZW5jZXMgKGUuZy4gY29udGFpbmVyLnJlbW92ZSgpIHRoZW4gY29udGFpbmVyLmFkZCgpIHVzaW5nIHRoZSBzYW1lIGtleSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUucmVmZXJlbmNlc1tuYW1lXTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LmRvd24oe3JlZmVyZW5jZTogbmFtZX0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tuYW1lXSA9IGNvbXBvbmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudCB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYW1lTGV2ZWxPbmx5PWZhbHNlIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgaW5zaWRlIHRoZSBjb21wb25lbnQgcGFyZW50IHRyZWUsXG4gICAgICogaW4gY2FzZSB0aGVyZSBpcyBub25lIG9uIHRoZSBzYW1lIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NhbWVMZXZlbE9ubHk9ZmFsc2VdXG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihzYW1lTGV2ZWxPbmx5PWZhbHNlKSB7XG4gICAgICAgIGxldCB7Y29tcG9uZW50fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzYW1lTGV2ZWxPbmx5ID8gY29tcG9uZW50LnN0YXRlUHJvdmlkZXIgOiBjb21wb25lbnQuZ2V0U3RhdGVQcm92aWRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIGFjY2Vzc2luZyBzdGF0ZS5Qcm92aWRlciBiYXNlZCBkYXRhLlN0b3Jlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZShrZXkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW5zaWRlIHlvdXIgdmlldyBjb250cm9sbGVycyBhcyBhIHN0YXJ0aW5nIHBvaW50IGluIGNhc2UgeW91IG5lZWQgcmVmZXJlbmNlc1xuICAgICAqIChpbnN0ZWFkIG9mIHVzaW5nIG9uQ29uc3RydWN0ZWQoKSBpbnNpZGUgeW91ciBjb250cm9sbGVyKVxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudD10aGlzLmNvbXBvbmVudFxuICAgICAqL1xuICAgIHBhcnNlQ29uZmlnKGNvbXBvbmVudD10aGlzLmNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2hhbmRsZXIsIGxpc3RlbmVycywgcmVmZXJlbmNlLCByZW5kZXJlciwgdmFsaWRhdG9yfSA9IGNvbXBvbmVudCxcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlciwgaGFuZGxlclNjb3BlO1xuXG4gICAgICAgIGlmIChoYW5kbGVyICYmIE5lby5pc1N0cmluZyhoYW5kbGVyKSkge1xuICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXIsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIG5hbWUgd2FzIG5vdCByZXNvbHZlZCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZiwgYmluZCBpdFxuICAgICAgICAgICAgaWYgKGhhbmRsZXJTY29wZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5oYW5kbGVyID0gaGFuZGxlclNjb3BlW2hhbmRsZXJdLmJpbmQoY29tcG9uZW50LmhhbmRsZXJTY29wZSB8fCBoYW5kbGVyU2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXJzICYmIE9iamVjdC5lbnRyaWVzKGxpc3RlbmVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnc2NvcGUnICYmIGtleSAhPT0gJ2RlbGVnYXRlJykge1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyU2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUoZXZlbnRIYW5kbGVyLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nRXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBmb3InLCBldmVudEhhbmRsZXIsIGNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyU2NvcGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1trZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5mbiA9IGhhbmRsZXJTY29wZVtldmVudEhhbmRsZXJdLmJpbmQoaGFuZGxlclNjb3BlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU/LmZvckVhY2g/LihsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGxpc3RlbmVyKSAmJiBsaXN0ZW5lci5oYXNPd25Qcm9wZXJ0eSgnZm4nKSAmJiBOZW8uaXNTdHJpbmcobGlzdGVuZXIuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gbGlzdGVuZXIuZm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclNjb3BlID0gbWUuZ2V0SGFuZGxlclNjb3BlKGV2ZW50SGFuZGxlciwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBmb3InLCBldmVudEhhbmRsZXIsIGNvbXBvbmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXJTY29wZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5mbiA9IGhhbmRsZXJTY29wZVtldmVudEhhbmRsZXJdLmJpbmQoaGFuZGxlclNjb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW5kZXJlciAmJiBOZW8uaXNTdHJpbmcocmVuZGVyZXIpKSB7XG4gICAgICAgICAgICBoYW5kbGVyU2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUocmVuZGVyZXIpO1xuXG4gICAgICAgICAgICBpZiAoaGFuZGxlclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnJlbmRlcmVyID0gaGFuZGxlclNjb3BlW3JlbmRlcmVyXS5iaW5kKGhhbmRsZXJTY29wZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0b3IgJiYgTmVvLmlzU3RyaW5nKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICAgIGhhbmRsZXJTY29wZSA9IG1lLmdldEhhbmRsZXJTY29wZSh2YWxpZGF0b3IpO1xuXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXJTY29wZSkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5sb2dFcnJvcignVW5rbm93biB2YWxpZGF0b3IgZm9yJywgY29tcG9uZW50LmlkLCBjb21wb25lbnQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC52YWxpZGF0b3IgPSBoYW5kbGVyU2NvcGVbdmFsaWRhdG9yXS5iaW5kKGhhbmRsZXJTY29wZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIG1lLnJlZmVyZW5jZXNbcmVmZXJlbmNlXSA9IGNvbXBvbmVudFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudD10aGlzLmNvbXBvbmVudFxuICAgICAqL1xuICAgIHBhcnNlRG9tTGlzdGVuZXJzKGNvbXBvbmVudD10aGlzLmNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RvbUxpc3RlbmVyc30gPSBjb21wb25lbnQsXG4gICAgICAgICAgICBldmVudEhhbmRsZXIsIHNjb3BlO1xuXG4gICAgICAgIGRvbUxpc3RlbmVycz8uZm9yRWFjaChkb21MaXN0ZW5lciA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkb21MaXN0ZW5lcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdzY29wZScgJiYga2V5ICE9PSAnZGVsZWdhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdmbicpICYmIE5lby5pc1N0cmluZyh2YWx1ZS5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlciA9IHZhbHVlLmZuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBtZS5nZXRIYW5kbGVyU2NvcGUoZXZlbnRIYW5kbGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgY2FuIGJlIHN0cmluZyBiYXNlZCBsaXN0ZW5lcnMgbGlrZSAndXAub25DbGljaycsIHdoaWNoIHdpbGwgcmVzb2x2ZWQgaW5zaWRlIG1hbmFnZXIuRG9tRXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA9PiBEbyBub3RoaW5nIGluIGNhc2UgdGhlcmUgaXMgbm8gbWF0Y2ggaW5zaWRlIHRoZSBjb250cm9sbGVyIGhpZXJhcmNoeS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbUxpc3RlbmVyW2tleV0gPSBzY29wZVtldmVudEhhbmRsZXJdLmJpbmQoc2NvcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgZ2V0IGNhbGxlZCBieSBjb21wb25lbnQuQmFzZTogZGVzdHJveSgpIGluIGNhc2UgdGhlIGNvbXBvbmVudCBoYXMgYSByZWZlcmVuY2UgY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVmZXJlbmNlc30gPSBtZSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSByZWZlcmVuY2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVmZXJlbmNlc1trZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRQYXJlbnQoKT8ucmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgc2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5zZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExhYmVsICAgICBmcm9tICcuLi9jb21wb25lbnQvTGFiZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udG9vbGJhci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBkb2NrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRvY2tQb3NpdGlvbnM9Wyd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnLCBudWxsXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9ja1Bvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2xiYXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2xiYXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZG9ja189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZG9ja186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1EZWZhdWx0cz17bnR5cGU6J2J1dHRvbid9XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOidmbGV4Ym94JyxhbGlnbjonY2VudGVyJyxkaXJlY3Rpb246ICdyb3cnLCBwYWNrOidzdGFydCd9XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlICAgIDogJ2ZsZXhib3gnLFxuICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUudG9vbGJhci5Tb3J0Wm9uZXxudWxsfSBzb3J0Wm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc29ydFpvbmVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmVDb25maWc6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnNvcnRab25lKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRab25lLmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkb2NrIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERvY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgIW9sZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIGRvY2tQb3NpdGlvbnMgPSBtZS5nZXRTdGF0aWNDb25maWcoJ2RvY2tQb3NpdGlvbnMnKSxcbiAgICAgICAgICAgIGxheW91dENvbmZpZyAgPSBtZS5nZXRMYXlvdXRDb25maWcoKTtcblxuICAgICAgICBkb2NrUG9zaXRpb25zLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGtleSAhPT0gbnVsbCAmJiBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLWRvY2stJyArIGtleSwga2V5ID09PSB2YWx1ZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFtZS5sYXlvdXQpIHtcbiAgICAgICAgICAgIGxheW91dENvbmZpZy5udHlwZSA9ICdmbGV4Ym94JztcbiAgICAgICAgICAgIG1lLnNldCh7Y2xzLCBsYXlvdXQ6IGxheW91dENvbmZpZ30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5sYXlvdXQuc2V0KGxheW91dENvbmZpZyk7XG4gICAgICAgICAgICBtZS5jbHMgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNvcnRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFtZS5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvdG9vbGJhci9Tb3J0Wm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuc29ydFpvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQgICAgICAgICAgIDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLnNvcnRab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnNvcnRab25lKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRab25lLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IGRvY2sgcG9zaXRpb24gbWF0Y2hlcyBhIHZhbHVlIG9mIHRoZSBzdGF0aWMgZG9ja1Bvc2l0aW9ucyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZG9jaycsICdkb2NrUG9zaXRpb25zJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLl9pdGVtcztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF5b3V0IGNvbmZpZyBkZXBlbmRpbmcgb24gdGhpcy5kb2NrXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5b3V0Q29uZmlnXG4gICAgICovXG4gICAgZ2V0TGF5b3V0Q29uZmlnKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnO1xuXG4gICAgICAgIGlmIChtZS5kb2NrKSB7XG4gICAgICAgICAgICBzd2l0Y2gobWUuZG9jaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXlvdXRDb25maWcgfHwgbWUubGF5b3V0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5tYXAoaXRlbSA9PiB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBpdGVtXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH1cbiAgICAgKi9cbiAgICByZXBsYWNlU3BhY2VyKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09ICctPicgPyB7bW9kdWxlOiBDb21wb25lbnQsIGZsZXg6IDF9IDogaXRlbVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVG9vbGJhcik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=