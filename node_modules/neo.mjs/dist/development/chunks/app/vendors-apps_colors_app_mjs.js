"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_colors_app_mjs"],{

/***/ "./apps/colors/app.mjs":
/*!*****************************!*\
  !*** ./apps/colors/app.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/Viewport.mjs */ "./apps/colors/view/Viewport.mjs");


const onStart = () => Neo.app({
    mainView: _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Colors'
});


/***/ }),

/***/ "./apps/colors/model/Color.mjs":
/*!*************************************!*\
  !*** ./apps/colors/model/Color.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Colors.model.Color
 * @extends Neo.data.Model
 */
class Color extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.model.Color'
         * @protected
         */
        className: 'Colors.model.Color'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let startCharCode = 'A'.charCodeAt(0),
            i             = 0,
            len           = 26, // amount of chars inside the ISO basic latin alphabet
            fields        = [{
                name: 'id',
                type: 'String'
            }];

        for (; i < len; i++) {
            fields.push({
                name: 'column' + String.fromCharCode(startCharCode + i),
                type: 'String'
            })
        }

        this.fields = fields
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ }),

/***/ "./apps/colors/store/Colors.mjs":
/*!**************************************!*\
  !*** ./apps/colors/store/Colors.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/Color.mjs */ "./apps/colors/model/Color.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Colors.store.Colors
 * @extends Neo.data.Store
 */
class Colors extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.store.Colors'
         * @protected
         */
        className: 'Colors.store.Colors',
        /**
         * @member {Neo.data.Model} model=ColorModel
         * @reactive
         */
        model: _model_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Colors));


/***/ }),

/***/ "./apps/colors/view/BarChartComponent.mjs":
/*!************************************************!*\
  !*** ./apps/colors/view/BarChartComponent.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/component/wrapper/AmChart.mjs */ "./src/component/wrapper/AmChart.mjs");


/**
 * @class Colors.view.BarChartComponent
 * @extends Neo.component.wrapper.AmChart
 */
class BarChartComponent extends _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.BarChartComponent'
         * @protected
         */
        className: 'Colors.view.BarChartComponent',
        /**
         * @member {String[]} baseCls=['colors-bar-chart']
         */
        baseCls: ['colors-bar-chart'],
        /**
         * @member {String} chartType='PieChart'
         */
        chartType: 'XYChart',
        /**
         * @member {Object} chartConfig
         */
        chartConfig: {
            series: [{
                type: 'ColumnSeries',

                columns: {
                    propertyFields: {
                        fill  : 'color',
                        stroke: 'color'
                    }
                },

                dataFields: {
                    categoryX: 'color',
                    valueY   : 'count'
                }
            }],
            xAxes: [{
                type: 'CategoryAxis',

                dataFields: {
                    category: 'color',
                    title: {
                        text: 'Colors'
                    }
                }
            }],
            yAxes: [{
                type: 'ValueAxis',

                title: {
                    text: 'Occurrences in grid cells'
                }
            }]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BarChartComponent));


/***/ }),

/***/ "./apps/colors/view/GridContainer.mjs":
/*!********************************************!*\
  !*** ./apps/colors/view/GridContainer.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_grid_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/grid/Container.mjs */ "./src/grid/Container.mjs");


/**
 * @class Colors.view.GridContainer
 * @extends Neo.grid.Container
 */
class GridContainer extends _src_grid_Container_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.GridContainer'
         * @protected
         */
        className: 'Colors.view.GridContainer',
        /**
         * @member {Number|null} amountColumns_=null
         * @reactive
         */
        amountColumns_: null,
        /**
         * @member {Number|null} amountRows_=null
         * @reactive
         */
        amountRows_: null,
        /**
         * @member {Object} bind
         */
        bind: {
            amountColumns: data => data.amountColumns,
            amountRows   : data => data.amountRows,
            store        : 'stores.colors'
        },
        /**
         * @member {String[]} cls=['colors-grid-container']
         * @reactive
         */
        cls: ['colors-grid-container']
    }

    /**
     * Triggered after the amountColumns config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetAmountColumns(value, oldValue) {
        if (Neo.isNumber(value)) {
            let startCharCode = 'A'.charCodeAt(0),
                i             = 0,
                columns       = [{
                    cellAlign: 'right',
                    dataField: 'id',
                    text     : '#',
                    type     : 'index',
                    width    : 40
                }],
                currentChar;

            for (; i < value; i++) {
                currentChar = String.fromCharCode(startCharCode + i);

                columns.push({
                    dataField: 'column' + currentChar,
                    renderer : 'up.colorRenderer',
                    text     : currentChar
                })
            }

            this.columns = columns
        }
    }

    /**
     * Triggered after the amountRows config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetAmountRows(value, oldValue) {
        this.store?.clear()
    }

    /**
     * @param {Object} data
     * @returns {Object}
     */
    colorRenderer({value}) {
        return {cls: ['color-' + value], text: ' '}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridContainer));


/***/ }),

/***/ "./apps/colors/view/HeaderToolbar.mjs":
/*!********************************************!*\
  !*** ./apps/colors/view/HeaderToolbar.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");





/**
 * @class Colors.view.HeaderToolbar
 * @extends Neo.toolbar.Base
 */
class HeaderToolbar extends _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.HeaderToolbar'
         * @protected
         */
        className: 'Colors.view.HeaderToolbar',
        /**
         * @member {String[]} cls=['colors-header-toolbar']
         * @reactive
         */
        cls: ['colors-header-toolbar'],
        /**
         * @member {Object} layout={ntype:'hbox',align:'stretch',wrap:'wrap'}
         * @reactive
         */
        layout: {ntype: 'hbox', align: 'center', pack: 'start', wrap: 'wrap'},
        /**
         * @member {Object[]} items
         */
        items: [{
            bind   : {disabled: data => data.isUpdating},
            handler: 'onStartButtonClick',
            text   : 'Start'
        }, {
            bind   : {disabled: data => !data.isUpdating},
            handler: 'onStopButtonClick',
            text   : 'Stop'
        }, {
            module       : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            bind         : {value: data => data.amountColors},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Colors',
            listeners    : {change: 'onChangeAmountColors'},
            maxValue     : 10,
            minValue     : 3,
            width        : 90
        }, {
            module       : _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            bind         : {value: data => String(data.amountColumns)},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Columns',
            listeners    : {change: 'onChangeAmountColumns'},
            store        : ['5', '10', '15', '20', '26'],
            width        : 90
        }, {
            module       : _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            bind         : {value: data => String(data.amountRows)},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Rows',
            listeners    : {change: 'onChangeAmountRows'},
            store        : ['5', '10', '15', '20'],
            width        : 90
        }, {
            ntype: 'component',
            cls  : ['header-spacer'],
            flex : 1
        }, {
            handler  : 'onEnableWindowManagementClick',
            iconCls  : 'fa fa-window-restore',
            reference: 'window-management-button',
            text     : 'Enable Window Management'
        }, {
            handler  : 'onDetachGridButtonClick',
            iconCls  : 'fas fa-table',
            reference: 'detach-grid-button',
            text     : 'Grid'
        }, {
            handler  : 'onDetachPieChartButtonClick',
            iconCls  : 'fas fa-chart-pie',
            reference: 'detach-pie-chart-button',
            text     : 'Pie Chart'
        }, {
            handler  : 'onDetachBarChartButtonClick',
            iconCls  : 'fas fa-chart-column',
            reference: 'detach-bar-chart-button',
            text     : 'Bar Chart'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            bind          : {checked: data => data.openWidgetsAsPopups},
            hideLabel     : true,
            listeners     : {change: 'onChangeOpenWidgetsAsPopups'},
            showValueLabel: true,
            valueLabelText: 'Popups'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HeaderToolbar));


/***/ }),

/***/ "./apps/colors/view/PieChartComponent.mjs":
/*!************************************************!*\
  !*** ./apps/colors/view/PieChartComponent.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/component/wrapper/AmChart.mjs */ "./src/component/wrapper/AmChart.mjs");


/**
 * @class Colors.view.PieChartComponent
 * @extends Neo.component.wrapper.AmChart
 */
class PieChartComponent extends _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.PieChartComponent'
         * @protected
         */
        className: 'Colors.view.PieChartComponent',
        /**
         * @member {String[]} baseCls=['colors-pie-chart']
         */
        baseCls: ['colors-pie-chart'],
        /**
         * @member {String} chartType='PieChart'
         */
        chartType: 'PieChart',
        /**
         * @member {Object} _vdom
         */
        /**
         * @member {Object} chartConfig
         */
        chartConfig: {
            series: [{
                type: 'PieSeries',

                colors: {
                    list: [
                        '#1c60a0',
                        '#206db6',
                        '#247acb',
                        '#2e87da',
                        '#4493de',
                        '#59a0e2',
                        '#6face6',
                        '#85b9ea',
                        '#9bc5ed',
                        '#b0d2f1'
                    ]
                },

                dataFields: {
                    category: 'color',
                    value   : 'count'
                }
            }]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(PieChartComponent));


/***/ }),

/***/ "./apps/colors/view/Viewport.mjs":
/*!***************************************!*\
  !*** ./apps/colors/view/Viewport.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");
/* harmony import */ var _BarChartComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BarChartComponent.mjs */ "./apps/colors/view/BarChartComponent.mjs");
/* harmony import */ var _src_dashboard_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/dashboard/Container.mjs */ "./src/dashboard/Container.mjs");
/* harmony import */ var _HeaderToolbar_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HeaderToolbar.mjs */ "./apps/colors/view/HeaderToolbar.mjs");
/* harmony import */ var _PieChartComponent_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PieChartComponent.mjs */ "./apps/colors/view/PieChartComponent.mjs");
/* harmony import */ var _GridContainer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GridContainer.mjs */ "./apps/colors/view/GridContainer.mjs");
/* harmony import */ var _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../src/container/Panel.mjs */ "./src/container/Panel.mjs");
/* harmony import */ var _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ViewportController.mjs */ "./apps/colors/view/ViewportController.mjs");
/* harmony import */ var _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ViewportStateProvider.mjs */ "./apps/colors/view/ViewportStateProvider.mjs");










/**
 * @class Colors.view.Viewport
 * @extends Neo.container.Viewport
 */
class Viewport extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.Viewport'
         * @protected
         */
        className: 'Colors.view.Viewport',
        /**
         * @member {String[]} cls=['colors-viewport','neo-dashboard']
         * @reactive
         */
        cls: ['colors-viewport', 'neo-dashboard'],
        /**
         * @member {Neo.controller.Component} controller=ViewportController
         * @reactive
         */
        controller: _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
        /**
         * @member {Object} layout
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _HeaderToolbar_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex  : 'none'
        }, {
            module   : _src_dashboard_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            layout   : {ntype: 'vbox', align: 'stretch'},
            reference: 'dashboard',

            listeners: {
                dragBoundaryEntry: 'onDragBoundaryEntry',
                dragBoundaryExit : 'onDragBoundaryExit'
            },

            items: [{
                module: _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                flex  : 1,
                reference: 'grid-panel',
                headers: [{
                    dock: 'top',
                    cls : ['neo-draggable'],
                    text: 'Grid'
                }],
                items: [
                    {module: _GridContainer_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], reference: 'grid'}
                ]
            }, {
                module   : _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                flex     : 1.3,
                reference: 'pie-chart-panel',
                headers: [{
                    dock: 'top',
                    cls : ['neo-draggable'],
                    text: 'Pie Chart'
                }],
                items: [
                    {module: _PieChartComponent_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], reference: 'pie-chart'}
                ]
            }, {
                module   : _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                flex     : 1.3,
                reference: 'bar-chart-panel',
                headers: [{
                    dock: 'top',
                    cls : ['neo-draggable'],
                    text: 'Bar Chart'
                }],
                items: [
                    {module: _BarChartComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], reference: 'bar-chart'}
                ]
            }],
        }],
        /**
         * @member {Neo.state.Provider} stateProvider=ViewportStateProvider
         * @reactive
         */
        stateProvider: _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ }),

/***/ "./apps/colors/view/ViewportController.mjs":
/*!*************************************************!*\
  !*** ./apps/colors/view/ViewportController.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @summary The main controller for the Colors demo application.
 * @description This controller orchestrates the entire Colors application, managing the dashboard widgets (grid, pie chart, bar chart),
 * handling real-time data updates, and demonstrating some of Neo.mjs's most advanced features.
 * It serves as a central hub for state management, cross-window communication, and the seamless drag-to-popup functionality.
 * This class is a key example of how to build a complex, interactive, and multi-window application.
 * @class Colors.view.ViewportController
 * @extends Neo.controller.Component
 * @see Neo.draggable.container.SortZone
 */
class ViewportController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.ViewportController'
         * @protected
         */
        className: 'Colors.view.ViewportController'
    }

    /**
     * @summary Tracks the names of widgets currently open in separate windows.
     * @member {String[]} connectedApps=[]
     */
    connectedApps = []
    /**
     * @summary The ID for the `setInterval` used for real-time data updates.
     * @member {Number|null} intervalId
     */
    intervalId = null
    /**
     * @summary A private flag to track if a drag operation is in the process of moving a widget to a new window.
     * @member {Boolean} #isWindowDragging=false
     * @private
     */
    #isWindowDragging = false
    /**
     * @summary A map to get the original index of a widget in the dashboard's items array.
     * @description This is used to correctly re-insert a widget when its popup window is closed.
     * @member {Object} widgetIndexMap
     */
    widgetIndexMap = {
        'bar-chart': 2,
        'pie-chart': 1,
        grid       : 0
    }

    /**
     * @summary Factory method to open a widget in a new browser window or popup.
     * @description Determines whether to open a full browser window or a frameless popup based on the
     * `openWidgetsAsPopups` state. It calculates the correct URL and window features.
     * @param {String} name The reference name of the widget to open (e.g., 'grid').
     */
    async createBrowserWindow(name) {
        if (this.getStateProvider().getData('openWidgetsAsPopups')) {
            let widget = this.getReference(name),
                rect   = await this.component.getDomRect(widget.vdom.id); // using the vdom id to always get the top-level node

            await this.#openWidgetInPopup(name, rect)
        } else {
            let {config, windowConfigs} = Neo,
                {environment}           = config,
                firstWindowId           = parseInt(Object.keys(windowConfigs)[0]),
                {basePath}              = windowConfigs[firstWindowId],
                url;

            if (environment !== 'development') {
                basePath = `${basePath + environment}/`
            }

            url = `${basePath}apps/colors/childapps/widget/index.html?name=${name}`;

            await Neo.Main.windowOpen({url, windowName: '_blank'})
        }
    }

    /**
     * @summary Cleans up the real-time update interval when the controller is destroyed.
     * @param args
     */
    destroy(...args) {
        this.intervalId && clearInterval(this.intervalId);
        super.destroy(...args)
    }

    /**
     * @summary Handles the `connect` event fired by `Neo.currentWorker`.
     * @description This is triggered when a new child application (a detached widget window) connects to the shared worker.
     * It re-parents the widget component from the main app's component tree into the new child app's viewport.
     * @param {Object} data The event data from the worker.
     * @param {String} data.appName The name of the connecting application.
     * @param {Number} data.windowId The ID of the new window.
     */
    async onAppConnect(data) {
        if (data.appName === 'ColorsWidget') {
            let me           = this,
                app          = Neo.apps[data.appName],
                mainView     = app.mainView,
                {windowId}   = data,
                url          = await Neo.Main.getByPath({path: 'document.URL', windowId}),
                widgetName   = new URL(url).searchParams.get('name'),
                widget       = me.getReference(widgetName),
                parent       = widget.up('panel');

            if (!me.#isWindowDragging) {
                parent.hide()
            }

            me.connectedApps.push(widgetName);

            me.getReference(`detach-${widgetName}-button`).disabled = true;

            mainView.add(widget)
        }
    }

    /**
     * @summary Handles the `disconnect` event fired by `Neo.currentWorker`.
     * @description This is triggered when a child application window is closed. It moves the widget component
     * back into its original position in the main application's dashboard.
     * @param {Object} data The event data from the worker.
     * @param {String} data.appName The name of the disconnecting application.
     * @param {Number} data.windowId The ID of the closed window.
     */
    async onAppDisconnect(data) {
        let me = this;

        if (me.#isWindowDragging) {
            me.#isWindowDragging = false;
            return
        }

        let {appName, windowId} = data,
            dashboard           = me.getReference('dashboard'),
            url                 = await Neo.Main.getByPath({path: 'document.URL', windowId}),
            widgetName          = new URL(url).searchParams.get('name'),
            widget              = me.getReference(widgetName);

        // Closing a non-main app needs to move the widget back into its original position & re-enable the show button
        if (appName === 'ColorsWidget') {
            let itemPanel     = dashboard.items[me.widgetIndexMap[widgetName]],
                bodyContainer = itemPanel.getReference('bodyContainer');

            bodyContainer.add(widget);
            itemPanel.show(true);

            me.getReference(`detach-${widgetName}-button`).disabled = false
        }
        // Close popup windows when closing or reloading the main window
        else if (appName === 'Colors') {
            Neo.Main.windowClose({names: me.connectedApps, windowId})
        }
    }

    /**
     * @summary Handles the change event from the 'Amount of Colors' slider.
     * @param {Object} data The event data.
     */
    onChangeAmountColors(data) {
        this.updateDataProperty(data, 'amountColors',  data.value)
    }

    /**
     * @summary Handles the change event from the 'Amount of Columns' radiofield.
     * @param {Object} data The event data.
     */
    onChangeAmountColumns(data) {
        this.updateDataProperty(data, 'amountColumns',  parseInt(data.value.name))
    }

    /**
     * @summary Handles the change event from the 'Amount of Rows' radiofield.
     * @param {Object} data The event data.
     */
    onChangeAmountRows(data) {
        this.updateDataProperty(data, 'amountRows',  parseInt(data.value.name))
    }

    /**
     * @summary Handles the change event from the 'Open widgets as Popups' checkbox.
     * @param {Object} data The event data.
     */
    onChangeOpenWidgetsAsPopups(data) {
        this.setState('openWidgetsAsPopups', data.value)
    }

    /**
     * @summary Lifecycle method, called after the controller's constructor.
     * @description Sets up listeners for the shared worker's connect and disconnect events.
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onAppConnect,
            disconnect: me.onAppDisconnect,
            scope     : me
        })
    }

    /**
     * @summary Lifecycle method, called after the controller's component is constructed.
     * @description Triggers the initial data load for the widgets.
     */
    onComponentConstructed() {
        super.onComponentConstructed();
        this.updateWidgets()
    }

    /**
     * @summary Handles the click event for the 'Detach Bar Chart' button.
     * @param {Object} data The event data.
     */
    async onDetachBarChartButtonClick(data) {
        await this.createBrowserWindow('bar-chart')
    }

    /**
     * @summary Handles the click event for the 'Detach Grid' button.
     * @param {Object} data The event data.
     */
    async onDetachGridButtonClick(data) {
        await this.createBrowserWindow('grid')
    }

    /**
     * @summary Handles the click event for the 'Detach Pie Chart' button.
     * @param {Object} data The event data.
     */
    async onDetachPieChartButtonClick(data) {
        await this.createBrowserWindow('pie-chart')
    }

    /**
     * @summary Handles the `dragBoundaryEntry` event from the `SortZone`.
     * @description This is the core of the drag-to-re-dock feature. When a dragged window re-enters the main
     * application's boundary, this method closes the popup window and re-inserts the widget component
     * back into its original dashboard container, providing a seamless user experience.
     * @param {Object} data The event data from the SortZone.
     */
    async onDragBoundaryEntry(data) {
        let me            = this,
            {windowId}    = me,
            {sortZone}    = data,
            widgetName    = data.draggedItem.reference.replace('-panel', ''),
            widget        = me.getReference(widgetName),
            dashboard     = me.getReference('dashboard'),
            itemPanel     = dashboard.items[me.widgetIndexMap[widgetName]],
            bodyContainer = itemPanel.getReference('bodyContainer');

        await Neo.Main.windowClose({names: widgetName, windowId});

        bodyContainer.add(widget);

        me.#isWindowDragging = false;

        sortZone.isWindowDragging = false;
        sortZone.dragProxy.hidden = false;

        Neo.main.addon.DragDrop.setConfigs({isWindowDragging: false, windowId})
    }

    /**
     * @summary Handles the `dragBoundaryExit` event from the `SortZone`.
     * @description This is the core of the drag-to-popup feature. When a dragged component's proxy leaves
     * the boundary of its container, this method orchestrates the creation of a new popup window
     * and hands off the drag operation to the main thread's DragDrop addon to drag the OS-level window.
     * @param {Object} data The event data from the SortZone.
     */
    async onDragBoundaryExit(data) {
        let {draggedItem, proxyRect, sortZone} = data,
            widgetName                         = draggedItem.reference.replace('-panel', ''),
            popupData;

        this.#isWindowDragging = true;

        // Prohibit the size reduction inside #openWidgetInPopup().
        proxyRect.height += 50;

        popupData = await this.#openWidgetInPopup(widgetName, proxyRect);

        sortZone.startWindowDrag({
            dragData: data,
            ...popupData
        });
    }

    /**
     * @summary Handles the click event to request Window Management permissions.
     * @description The Window Management API is a new browser feature that allows web apps to control
     * the placement of windows, which is essential for the drag-to-popup feature.
     * @param {Object} data The event data.
     */
    async onEnableWindowManagementClick(data) {
        let me       = this,
            response = await Neo.main.addon.DragDrop.requestWindowManagementPermission(),
            button   = me.getReference('window-management-button');

        if (response.success) {
            button.text = 'W-M enabled';
            button.iconCls = 'fa fa-check-square';
            button.disabled = true;
        } else {
            button.text = 'W-M disabled';
            button.iconCls = 'fa fa-exclamation-triangle';
        }
    }

    /**
     * @summary Starts the real-time data update interval.
     * @param {Object} data The event data.
     */
    onStartButtonClick(data) {
        let me           = this,
            intervalTime = 1000 / 60; // assuming 60 FPS

        me.setState({isUpdating: true});

        if (!me.intervalId) {
            me.intervalId = setInterval(() => {
                me.updateWidgets()
            }, intervalTime)
        }
    }

    /**
     * @summary Stops the real-time data update interval.
     * @param {Object} data The event data.
     */
    onStopButtonClick(data) {
        let me = this;

        me.setState({isUpdating: false});

        if (me.intervalId) {
            clearInterval(me.intervalId);
            me.intervalId = null
        }
    }

    /**
     * @summary Private helper method to open a widget in a new popup window.
     * @description This method calculates the precise screen coordinates for the new window based on the main
     * window's position and the drag proxy's last known rectangle. It then calls the main thread
     * to open the new window with the correct URL and features.
     * @param {String} name The reference name of the widget.
     * @param {Object} rect The DOM rect of the drag proxy.
     * @returns {Promise<Object>} A promise that resolves with the new window's properties.
     * @private
     */
    async #openWidgetInPopup(name, rect) {
        let me                      = this,
            {windowId}              = me,
            {config, windowConfigs} = Neo,
            {environment}           = config,
            firstWindowId           = parseInt(Object.keys(windowConfigs)[0]),
            {basePath}              = windowConfigs[firstWindowId],
            url;

        if (environment !== 'development') {
            basePath = `${basePath + environment}/`
        }

        url = `${basePath}apps/colors/childapps/widget/index.html?name=${name}`;

        let winData               = await Neo.Main.getWindowData({windowId}),
            {height, width, x, y} = rect,
            popupHeight           = height - 50, // popup header in Chrome
            popupLeft             = x + winData.screenLeft,
            popupTop              = y + (winData.outerHeight - winData.innerHeight + winData.screenTop);

        await Neo.Main.windowOpen({
            url,
            windowFeatures: `height=${popupHeight},left=${popupLeft},top=${popupTop},width=${width}`,
            windowName    : name
        });

        return {popupHeight, popupLeft, popupTop, popupWidth: width, windowName: name}
    }

    /**
     * @summary Updates the chart components with new data.
     * @param {Object} data The data for the charts.
     */
    updateCharts(data) {
        this.getReference('bar-chart').chartData = data;
        this.getReference('pie-chart').chartData = data
    }

    /**
     * @summary A generic handler to update a property in the state provider.
     * @description Also triggers a manual widget update if real-time updates are not currently running.
     * @param {Object} data The change event data.
     * @param {String} name The name of the property to update in the state provider.
     * @param {Number|Object|null} value The new value for the property.
     */
    updateDataProperty(data, name, value) {
        let stateProvider = this.getStateProvider();

        stateProvider.setData(name, value);

        if (data.oldValue !== null && !stateProvider.getData('isUpdating')) {
            this.updateWidgets()
        }
    }

    /**
     * @summary Updates the data grid component with new records.
     * @description Uses `bulkUpdateRecords` for performance if the store already has data, otherwise sets the initial data.
     * @param {Object[]} records The array of new records for the grid.
     */
    updateGrid(records) {
        let grid    = this.getReference('grid'),
            {store} = grid;

        if (store.getCount()) {
            grid.bulkUpdateRecords(records)
        } else {
            // Depending on the delay of the Socket Connection,
            // the next data package could still contain the old settings
            if (this.getStateProvider().getData('amountRows') === records.length) {
                store.data = records
            }
        }
    }

    /**
     * @summary Fetches new data from the backend service and updates all widgets.
     * @description This is the main data refresh method. It reads the current settings from the state provider,
     * and then uses Neo.mjs's RPC layer to seamlessly call the backend `ColorService.read()` method.
     * This demonstrates remote method access, allowing the App Worker to invoke backend functionality
     * as if it were a local method. After receiving the response, it distributes the new data to the grid and charts.
     */
    async updateWidgets() {
        let me            = this,
            stateProvider = me.getStateProvider(),
            response;

        // Timing issue inside dist/development => the namespace might not be registered yet
        if (!Colors.backend) {
            await me.timeout(50);
            me.updateWidgets()
        } else {
            response = await Colors.backend.ColorService.read({
                amountColors : stateProvider.getData('amountColors'),
                amountColumns: stateProvider.getData('amountColumns'),
                amountRows   : stateProvider.getData('amountRows')
            });

            if (!me.isDestroyed) {
                let {data} = response;

                me.updateGrid(data.tableData);
                me.updateCharts(data.summaryData)
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportController));


/***/ }),

/***/ "./apps/colors/view/ViewportStateProvider.mjs":
/*!****************************************************!*\
  !*** ./apps/colors/view/ViewportStateProvider.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_Colors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/Colors.mjs */ "./apps/colors/store/Colors.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");



/**
 * @class Colors.view.ViewportStateProvider
 * @extends Neo.state.Provider
 */
class ViewportStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.ViewportStateProvider'
         * @protected
         */
        className: 'Colors.view.ViewportStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {Number} data.amountColors=10
             */
            amountColors: 10,
            /**
             * @member {Number} data.amountColumns=10
             */
            amountColumns: 10,
            /**
             * @member {Number} data.amountRows=10
             */
            amountRows: 10,
            /**
             * @member {Boolean} data.isUpdating=false
             */
            isUpdating: false,
            /**
             * @member {Boolean} data.openWidgetsAsPopups=true
             */
            openWidgetsAsPopups: true
        },
        /**
         * @member {Object} stores
         */
        stores: {
            colors: {
                module: _store_Colors_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportStateProvider));


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ }),

/***/ "./src/component/wrapper/AmChart.mjs":
/*!*******************************************!*\
  !*** ./src/component/wrapper/AmChart.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render an amChart
 * Requires setting Neo.config.useAmCharts to true (or manually include the lib)
 * @class Neo.component.wrapper.AmChart
 * @extends Neo.component.Base
 */
class AmChart extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.wrapper.AmChart'
         * @protected
         */
        className: 'Neo.component.wrapper.AmChart',
        /**
         * @member {String} ntype='am-chart'
         * @protected
         */
        ntype: 'am-chart',
        /**
         * See: https://www.amcharts.com/docs/v4/
         * @member {Object} chartConfig_=null
         * @reactive
         */
        chartConfig_: null,
        /**
         * Stores the chart data
         * @member {Array|null} chartData_=null
         * @reactive
         */
        chartData_: null,
        /**
         * @member {String} chartType='XYChart'
         */
        chartType: 'XYChart',
        /**
         * It is not possible to define adapters via json, so we pass a flag to main instead
         * @member {Boolean} combineSeriesTooltip=false
         */
        combineSeriesTooltip: false,
        /**
         * Charts & maps can have different targets to apply the data to. E.g.:
         * myChart.data = data; // => ''
         * myChart.series.values[0].data = data; // => 'series.values.0'
         * Use a Neo.ns() conform syntax with dots between props
         * @member {String} dataPath=''
         */
        dataPath: '',
        /**
         * am4charts, am4maps
         * @member {String} package='am4charts'
         */
        package: 'am4charts',
        style: {
            height: '100%'
        },
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {style: {position: 'relative'}, cn: [
            {style: {position: 'absolute', height: '100%', width: '100%'}, cn: [{}]}
        ]}
    }

    /**
     * Triggered after the chartData config got changed
     * @param {Array|null} value
     * @param {Array|null} oldValue
     * @protected
     */
    afterSetChartData(value, oldValue) {
        let me = this,
            {appName, dataPath, id, windowId} = me;

        if (value) {
            Neo.main.addon.AmCharts.updateData({
                appName,
                data: value,
                dataPath,
                id,
                windowId
            })
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        let me                      = this,
            {appName, id, windowId} = me,
            opts                    = {appName, id, windowId};

        if (value === false && oldValue !== undefined) {
            Neo.main.addon.AmCharts.destroy(opts)
        }

        super.afterSetMounted(value, oldValue);

        if (value) {
            opts = {
                ...opts,
                combineSeriesTooltip: me.combineSeriesTooltip,
                config              : me.chartConfig,
                package             : me.package,
                type                : me.chartType
            };

            if (me.chartData) {
                opts.data     = me.chartData;
                opts.dataPath = me.dataPath;
            }

            me.timeout(50).then(() => {
                Neo.main.addon.AmCharts.create(opts).then(me.onChartMounted)
            })
        }
    }

    /**
     * Triggered before the chartConfig config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetChartConfig(value, oldValue) {
        if (!value) {
            console.error('wrapper.AmChart defined without a chartConfig', this.id)
        }

        this.parseItemConfigs(value);
        return value
    }

    destroy(...args) {
        let {appName, id, windowId} = this;

        Neo.main.addon.AmCharts.destroy({appName, id, windowId})

        super.destroy(...args)
    }

    /**
     *
     */
    getVdomRoot() {
        return this.vdom.cn[0].cn[0]
    }

    /**
     *
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0].childNodes[0]
    }

    /**
     * Override this method to trigger logic after the chart got mounted into the dom
     */
    onChartMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AmChart));


/***/ }),

/***/ "./src/container/Panel.mjs":
/*!*********************************!*\
  !*** ./src/container/Panel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");



/**
 * An extended Container supporting multiple docked header toolbars
 * @class Neo.container.Panel
 * @extends Neo.container.Base
 */
class Panel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Panel'
         * @protected
         */
        className: 'Neo.container.Panel',
        /**
         * @member {String} ntype='panel'
         * @protected
         */
        ntype: 'panel',
        /**
         * @member {String[]} baseCls=['neo-panel','neo-container']
         */
        baseCls: ['neo-panel', 'neo-container'],
        /**
         * @member {Object} containerConfig=null
         */
        containerConfig: null,
        /**
         * @member {Object} headerDefaults=null
         */
        headerDefaults: null,
        /**
         * @member {Array} headers=null
         */
        headers: null,
        /**
         * @member {Object} items={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        _layout: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Boolean} verticalHeadersFirst=false
         */
        verticalHeadersFirst: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.hasHeaders() && me.verticalHeadersFirst === true) {
            me.layout = {
                ntype: 'hbox',
                align: 'stretch'
            };
        }
    }

    /**
     * @param {Object} header the header config
     * @returns {Object}
     */
    static createHeaderConfig(header) {
        if (Neo.typeOf(header) === 'NeoInstance') {
            return header;
        }

        let config = {
            flex: '0 1 auto'
        };

        if (!header.module && !header.ntype) {
            config.cls   = ['neo-panel-header-toolbar', 'neo-toolbar'];
            config.ntype = 'toolbar';
        }

        if (header.text) {
            config.items = [{
                ntype: 'label',
                cls  : ['neo-panel-header-text', 'neo-label'],
                text : header.text
            }];

            delete header.text;
        }

        // assuming all labels inside a Panel Header are meant to be titles -> look the same way
        if (Array.isArray(header.items)) {
            header.items.forEach(item => {
                if (item.ntype === 'label') {
                    item.cls = ['neo-panel-header-text', 'neo-label'];
                }
            });
        }

        return {...config, ...header}
    }

    /**
     *
     */
    createItems() {
        let me              = this,
            containerConfig = me.containerConfig;

        if (!me.hasHeaders()) {
            containerConfig && me.set(containerConfig);
            super.createItems();
        } else {
            let hf                   = me.verticalHeadersFirst === false,
                headers              = me.headers || [],
                bottomHeaders        = headers.filter(header => {return header.dock === (hf ?'bottom': 'right')}),
                leftHeaders          = headers.filter(header => {return header.dock === (hf ?'left'  : 'top')}),
                rightHeaders         = headers.filter(header => {return header.dock === (hf ?'right' : 'bottom')}),
                topHeaders           = headers.filter(header => {return header.dock === (hf ?'top'   : 'left')}),
                hasHorizontalHeaders = bottomHeaders.length > 0 || topHeaders  .length > 0,
                hasVerticalHeaders   = leftHeaders  .length > 0 || rightHeaders.length > 0,
                {items}              = me,
                horizontalItems      = [],
                verticalItems        = [],
                config;

            topHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            if (hasVerticalHeaders && (hf && hasHorizontalHeaders || !hf && hasHorizontalHeaders)) {
                leftHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                horizontalItems.push({...me.headerDefaults, ...config});

                rightHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                verticalItems.push({
                    ntype    : 'container',
                    items    : horizontalItems,
                    layout   : {ntype: (hf ? 'hbox' : 'vbox'), align: 'stretch'},
                    reference: 'bodyContainer'
                });
            } else {
                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    reference   : 'bodyContainer',
                    ...containerConfig
                };

                verticalItems.push({...me.headerDefaults, ...config})
            }

            bottomHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            me.items = verticalItems;

            me.itemDefaults = null;

            super.createItems()
        }
    }

    /**
     * @returns {Boolean}
     */
    hasHeaders() {
        return Array.isArray(this.headers) && this.headers.length > 0
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Panel));


/***/ }),

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {appName, windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName,
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/dashboard/Container.mjs":
/*!*************************************!*\
  !*** ./src/dashboard/Container.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.dashboard.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.dashboard.Container'
         * @protected
         */
        className: 'Neo.dashboard.Container',
        /**
         * @member {String} ntype='dashboard'
         * @protected
         */
        ntype: 'dashboard',
        /**
         * @member {String[]} baseCls=['neo-dashboard','neo-container']
         * @protected
         */
        baseCls: ['neo-dashboard', 'neo-container'],
        /**
         * @member {Boolean} sortable_=true
         * @reactive
         */
        sortable_: true
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("src_draggable_dashboard_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/dashboard/SortZone.mjs */ "./src/draggable/dashboard/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    allowOverdrag      : true,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    enableProxyToPopup : true,
                    owner              : me,
                    windowId           : me.windowId,
                    listeners          : {
                        dragBoundaryEntry: data => me.fire('dragBoundaryEntry', data),
                        dragBoundaryExit : data => me.fire('dragBoundaryExit',  data)
                    }
                })
            })
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         * @reactive
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    windowId           : me.windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (this.sortZone) {
            this.sortZone.windowId = value
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfY29sb3JzX2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7O0FBRXBDO0FBQ1AsY0FBYywwREFBUTtBQUN0QjtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMK0M7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFLO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q087QUFDUzs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQUs7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0EsZUFBZSx3REFBVTtBQUN6QjtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdEJvQzs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEVBQWdCO0FBQ2hEO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsMkRBQVMsV0FBVztBQUM1RDtBQUNBOztBQUVBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL2FwcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL21vZGVsL0NvbG9yLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvc3RvcmUvQ29sb3JzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvdmlldy9CYXJDaGFydENvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL3ZpZXcvR3JpZENvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL3ZpZXcvSGVhZGVyVG9vbGJhci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL3ZpZXcvUGllQ2hhcnRDb21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy92aWV3L1ZpZXdwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvdmlldy9WaWV3cG9ydENvbnRyb2xsZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy92aWV3L1ZpZXdwb3J0U3RhdGVQcm92aWRlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTGFiZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L3dyYXBwZXIvQW1DaGFydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvUGFuZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Rhc2hib2FyZC9Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdG9vbGJhci9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmlld3BvcnQgZnJvbSAnLi92aWV3L1ZpZXdwb3J0Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvblN0YXJ0ID0gKCkgPT4gTmVvLmFwcCh7XG4gICAgbWFpblZpZXc6IFZpZXdwb3J0LFxuICAgIG5hbWUgICAgOiAnQ29sb3JzJ1xufSk7XG4iLCJpbXBvcnQgTW9kZWwgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvTW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgQ29sb3JzLm1vZGVsLkNvbG9yXG4gKiBAZXh0ZW5kcyBOZW8uZGF0YS5Nb2RlbFxuICovXG5jbGFzcyBDb2xvciBleHRlbmRzIE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0NvbG9ycy5tb2RlbC5Db2xvcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLm1vZGVsLkNvbG9yJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBzdGFydENoYXJDb2RlID0gJ0EnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgICBpICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgPSAyNiwgLy8gYW1vdW50IG9mIGNoYXJzIGluc2lkZSB0aGUgSVNPIGJhc2ljIGxhdGluIGFscGhhYmV0XG4gICAgICAgICAgICBmaWVsZHMgICAgICAgID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnaWQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NvbHVtbicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0Q2hhckNvZGUgKyBpKSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb2xvcik7XG4iLCJpbXBvcnQgQ29sb3JNb2RlbCBmcm9tICcuLi9tb2RlbC9Db2xvci5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgQ29sb3JzLnN0b3JlLkNvbG9yc1xuICogQGV4dGVuZHMgTmVvLmRhdGEuU3RvcmVcbiAqL1xuY2xhc3MgQ29sb3JzIGV4dGVuZHMgU3RvcmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnN0b3JlLkNvbG9ycydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLnN0b3JlLkNvbG9ycycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWw9Q29sb3JNb2RlbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsOiBDb2xvck1vZGVsXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb2xvcnMpO1xuIiwiaW1wb3J0IEFtQ2hhcnRDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBvbmVudC93cmFwcGVyL0FtQ2hhcnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgQ29sb3JzLnZpZXcuQmFyQ2hhcnRDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQud3JhcHBlci5BbUNoYXJ0XG4gKi9cbmNsYXNzIEJhckNoYXJ0Q29tcG9uZW50IGV4dGVuZHMgQW1DaGFydENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMudmlldy5CYXJDaGFydENvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLnZpZXcuQmFyQ2hhcnRDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9Wydjb2xvcnMtYmFyLWNoYXJ0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnY29sb3JzLWJhci1jaGFydCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjaGFydFR5cGU9J1BpZUNoYXJ0J1xuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnRUeXBlOiAnWFlDaGFydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNoYXJ0Q29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydENvbmZpZzoge1xuICAgICAgICAgICAgc2VyaWVzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDb2x1bW5TZXJpZXMnLFxuXG4gICAgICAgICAgICAgICAgY29sdW1uczoge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbCAgOiAnY29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnY29sb3InXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZGF0YUZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVg6ICdjb2xvcicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWSAgIDogJ2NvdW50J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgeEF4ZXM6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0NhdGVnb3J5QXhpcycsXG5cbiAgICAgICAgICAgICAgICBkYXRhRmllbGRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAnY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0NvbG9ycydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgeUF4ZXM6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1ZhbHVlQXhpcycsXG5cbiAgICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnT2NjdXJyZW5jZXMgaW4gZ3JpZCBjZWxscydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhCYXJDaGFydENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQmFzZUdyaWRDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vc3JjL2dyaWQvQ29udGFpbmVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIENvbG9ycy52aWV3LkdyaWRDb250YWluZXJcbiAqIEBleHRlbmRzIE5lby5ncmlkLkNvbnRhaW5lclxuICovXG5jbGFzcyBHcmlkQ29udGFpbmVyIGV4dGVuZHMgQmFzZUdyaWRDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnZpZXcuR3JpZENvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLnZpZXcuR3JpZENvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gYW1vdW50Q29sdW1uc189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFtb3VudENvbHVtbnNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFtb3VudFJvd3NfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhbW91bnRSb3dzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgYW1vdW50Q29sdW1uczogZGF0YSA9PiBkYXRhLmFtb3VudENvbHVtbnMsXG4gICAgICAgICAgICBhbW91bnRSb3dzICAgOiBkYXRhID0+IGRhdGEuYW1vdW50Um93cyxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICA6ICdzdG9yZXMuY29sb3JzJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ2NvbG9ycy1ncmlkLWNvbnRhaW5lciddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ2NvbG9ycy1ncmlkLWNvbnRhaW5lciddXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhbW91bnRDb2x1bW5zIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBbW91bnRDb2x1bW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0Q2hhckNvZGUgPSAnQScuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBjb2x1bW5zICAgICAgID0gW3tcbiAgICAgICAgICAgICAgICAgICAgY2VsbEFsaWduOiAncmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhRmllbGQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgIHRleHQgICAgIDogJyMnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlICAgICA6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICAgIDogNDBcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hhcjtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCB2YWx1ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0Q2hhckNvZGUgKyBpKTtcblxuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogJ2NvbHVtbicgKyBjdXJyZW50Q2hhcixcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIgOiAndXAuY29sb3JSZW5kZXJlcicsXG4gICAgICAgICAgICAgICAgICAgIHRleHQgICAgIDogY3VycmVudENoYXJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFtb3VudFJvd3MgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFtb3VudFJvd3ModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcmU/LmNsZWFyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY29sb3JSZW5kZXJlcih7dmFsdWV9KSB7XG4gICAgICAgIHJldHVybiB7Y2xzOiBbJ2NvbG9yLScgKyB2YWx1ZV0sIHRleHQ6ICcgJ31cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEdyaWRDb250YWluZXIpO1xuIiwiaW1wb3J0IENoZWNrQm94ICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NoZWNrQm94Lm1qcyc7XG5pbXBvcnQgQ29tYm9Cb3ggICAgZnJvbSAnLi4vLi4vLi4vc3JjL2Zvcm0vZmllbGQvQ29tYm9Cb3gubWpzJztcbmltcG9ydCBOdW1iZXJGaWVsZCBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9OdW1iZXIubWpzJztcbmltcG9ydCBUb29sYmFyICAgICBmcm9tICcuLi8uLi8uLi9zcmMvdG9vbGJhci9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIENvbG9ycy52aWV3LkhlYWRlclRvb2xiYXJcbiAqIEBleHRlbmRzIE5lby50b29sYmFyLkJhc2VcbiAqL1xuY2xhc3MgSGVhZGVyVG9vbGJhciBleHRlbmRzIFRvb2xiYXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnZpZXcuSGVhZGVyVG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLnZpZXcuSGVhZGVyVG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzPVsnY29sb3JzLWhlYWRlci10b29sYmFyJ11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnY29sb3JzLWhlYWRlci10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2hib3gnLGFsaWduOidzdHJldGNoJyx3cmFwOid3cmFwJ31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ2NlbnRlcicsIHBhY2s6ICdzdGFydCcsIHdyYXA6ICd3cmFwJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgYmluZCAgIDoge2Rpc2FibGVkOiBkYXRhID0+IGRhdGEuaXNVcGRhdGluZ30sXG4gICAgICAgICAgICBoYW5kbGVyOiAnb25TdGFydEJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgIHRleHQgICA6ICdTdGFydCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgYmluZCAgIDoge2Rpc2FibGVkOiBkYXRhID0+ICFkYXRhLmlzVXBkYXRpbmd9LFxuICAgICAgICAgICAgaGFuZGxlcjogJ29uU3RvcEJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgIHRleHQgICA6ICdTdG9wJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgOiBOdW1iZXJGaWVsZCxcbiAgICAgICAgICAgIGJpbmQgICAgICAgICA6IHt2YWx1ZTogZGF0YSA9PiBkYXRhLmFtb3VudENvbG9yc30sXG4gICAgICAgICAgICBjbGVhcmFibGUgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGVkaXRhYmxlICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogJ2lubGluZScsXG4gICAgICAgICAgICBsYWJlbFRleHQgICAgOiAnIyBDb2xvcnMnLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgIDoge2NoYW5nZTogJ29uQ2hhbmdlQW1vdW50Q29sb3JzJ30sXG4gICAgICAgICAgICBtYXhWYWx1ZSAgICAgOiAxMCxcbiAgICAgICAgICAgIG1pblZhbHVlICAgICA6IDMsXG4gICAgICAgICAgICB3aWR0aCAgICAgICAgOiA5MFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgOiBDb21ib0JveCxcbiAgICAgICAgICAgIGJpbmQgICAgICAgICA6IHt2YWx1ZTogZGF0YSA9PiBTdHJpbmcoZGF0YS5hbW91bnRDb2x1bW5zKX0sXG4gICAgICAgICAgICBjbGVhcmFibGUgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGVkaXRhYmxlICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogJ2lubGluZScsXG4gICAgICAgICAgICBsYWJlbFRleHQgICAgOiAnIyBDb2x1bW5zJyxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICA6IHtjaGFuZ2U6ICdvbkNoYW5nZUFtb3VudENvbHVtbnMnfSxcbiAgICAgICAgICAgIHN0b3JlICAgICAgICA6IFsnNScsICcxMCcsICcxNScsICcyMCcsICcyNiddLFxuICAgICAgICAgICAgd2lkdGggICAgICAgIDogOTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgIDogQ29tYm9Cb3gsXG4gICAgICAgICAgICBiaW5kICAgICAgICAgOiB7dmFsdWU6IGRhdGEgPT4gU3RyaW5nKGRhdGEuYW1vdW50Um93cyl9LFxuICAgICAgICAgICAgY2xlYXJhYmxlICAgIDogZmFsc2UsXG4gICAgICAgICAgICBlZGl0YWJsZSAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb246ICdpbmxpbmUnLFxuICAgICAgICAgICAgbGFiZWxUZXh0ICAgIDogJyMgUm93cycsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgOiB7Y2hhbmdlOiAnb25DaGFuZ2VBbW91bnRSb3dzJ30sXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgOiBbJzUnLCAnMTAnLCAnMTUnLCAnMjAnXSxcbiAgICAgICAgICAgIHdpZHRoICAgICAgICA6IDkwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgIGNscyAgOiBbJ2hlYWRlci1zcGFjZXInXSxcbiAgICAgICAgICAgIGZsZXggOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGhhbmRsZXIgIDogJ29uRW5hYmxlV2luZG93TWFuYWdlbWVudENsaWNrJyxcbiAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhIGZhLXdpbmRvdy1yZXN0b3JlJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ3dpbmRvdy1tYW5hZ2VtZW50LWJ1dHRvbicsXG4gICAgICAgICAgICB0ZXh0ICAgICA6ICdFbmFibGUgV2luZG93IE1hbmFnZW1lbnQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGhhbmRsZXIgIDogJ29uRGV0YWNoR3JpZEJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhcyBmYS10YWJsZScsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdkZXRhY2gtZ3JpZC1idXR0b24nLFxuICAgICAgICAgICAgdGV4dCAgICAgOiAnR3JpZCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaGFuZGxlciAgOiAnb25EZXRhY2hQaWVDaGFydEJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhcyBmYS1jaGFydC1waWUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnZGV0YWNoLXBpZS1jaGFydC1idXR0b24nLFxuICAgICAgICAgICAgdGV4dCAgICAgOiAnUGllIENoYXJ0J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBoYW5kbGVyICA6ICdvbkRldGFjaEJhckNoYXJ0QnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgaWNvbkNscyAgOiAnZmFzIGZhLWNoYXJ0LWNvbHVtbicsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdkZXRhY2gtYmFyLWNoYXJ0LWJ1dHRvbicsXG4gICAgICAgICAgICB0ZXh0ICAgICA6ICdCYXIgQ2hhcnQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgOiBDaGVja0JveCxcbiAgICAgICAgICAgIGJpbmQgICAgICAgICAgOiB7Y2hlY2tlZDogZGF0YSA9PiBkYXRhLm9wZW5XaWRnZXRzQXNQb3B1cHN9LFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICA6IHRydWUsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgIDoge2NoYW5nZTogJ29uQ2hhbmdlT3BlbldpZGdldHNBc1BvcHVwcyd9LFxuICAgICAgICAgICAgc2hvd1ZhbHVlTGFiZWw6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogJ1BvcHVwcydcbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEhlYWRlclRvb2xiYXIpO1xuIiwiaW1wb3J0IEFtQ2hhcnRDb21wb25lbnQgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBvbmVudC93cmFwcGVyL0FtQ2hhcnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgQ29sb3JzLnZpZXcuUGllQ2hhcnRDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQud3JhcHBlci5BbUNoYXJ0XG4gKi9cbmNsYXNzIFBpZUNoYXJ0Q29tcG9uZW50IGV4dGVuZHMgQW1DaGFydENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMudmlldy5QaWVDaGFydENvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLnZpZXcuUGllQ2hhcnRDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9Wydjb2xvcnMtcGllLWNoYXJ0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnY29sb3JzLXBpZS1jaGFydCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjaGFydFR5cGU9J1BpZUNoYXJ0J1xuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnRUeXBlOiAnUGllQ2hhcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY2hhcnRDb25maWdcbiAgICAgICAgICovXG4gICAgICAgIGNoYXJ0Q29uZmlnOiB7XG4gICAgICAgICAgICBzZXJpZXM6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1BpZVNlcmllcycsXG5cbiAgICAgICAgICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJyMxYzYwYTAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyMyMDZkYjYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyMyNDdhY2InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyMyZTg3ZGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyM0NDkzZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyM1OWEwZTInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyM2ZmFjZTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyM4NWI5ZWEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyM5YmM1ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyNiMGQyZjEnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZGF0YUZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ2NvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICA6ICdjb3VudCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhQaWVDaGFydENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQmFzZVZpZXdwb3J0ICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzJztcbmltcG9ydCBCYXJDaGFydENvbXBvbmVudCAgICAgZnJvbSAnLi9CYXJDaGFydENvbXBvbmVudC5tanMnO1xuaW1wb3J0IERhc2hib2FyZCAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZGFzaGJvYXJkL0NvbnRhaW5lci5tanMnO1xuaW1wb3J0IEhlYWRlclRvb2xiYXIgICAgICAgICBmcm9tICcuL0hlYWRlclRvb2xiYXIubWpzJztcbmltcG9ydCBQaWVDaGFydENvbXBvbmVudCAgICAgZnJvbSAnLi9QaWVDaGFydENvbXBvbmVudC5tanMnO1xuaW1wb3J0IEdyaWRDb250YWluZXIgICAgICAgICBmcm9tICcuL0dyaWRDb250YWluZXIubWpzJztcbmltcG9ydCBQYW5lbCAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9QYW5lbC5tanMnO1xuaW1wb3J0IFZpZXdwb3J0Q29udHJvbGxlciAgICBmcm9tICcuL1ZpZXdwb3J0Q29udHJvbGxlci5tanMnO1xuaW1wb3J0IFZpZXdwb3J0U3RhdGVQcm92aWRlciBmcm9tICcuL1ZpZXdwb3J0U3RhdGVQcm92aWRlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMudmlldy5WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICovXG5jbGFzcyBWaWV3cG9ydCBleHRlbmRzIEJhc2VWaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMudmlldy5WaWV3cG9ydCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLnZpZXcuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ2NvbG9ycy12aWV3cG9ydCcsJ25lby1kYXNoYm9hcmQnXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNsczogWydjb2xvcnMtdmlld3BvcnQnLCAnbmVvLWRhc2hib2FyZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fSBjb250cm9sbGVyPVZpZXdwb3J0Q29udHJvbGxlclxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRyb2xsZXI6IFZpZXdwb3J0Q29udHJvbGxlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbGF5b3V0XG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBpdGVtc1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICBtb2R1bGU6IEhlYWRlclRvb2xiYXIsXG4gICAgICAgICAgICBmbGV4ICA6ICdub25lJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IERhc2hib2FyZCxcbiAgICAgICAgICAgIGxheW91dCAgIDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnZGFzaGJvYXJkJyxcblxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgZHJhZ0JvdW5kYXJ5RW50cnk6ICdvbkRyYWdCb3VuZGFyeUVudHJ5JyxcbiAgICAgICAgICAgICAgICBkcmFnQm91bmRhcnlFeGl0IDogJ29uRHJhZ0JvdW5kYXJ5RXhpdCdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZTogUGFuZWwsXG4gICAgICAgICAgICAgICAgZmxleCAgOiAxLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogJ2dyaWQtcGFuZWwnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIGRvY2s6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1kcmFnZ2FibGUnXSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0dyaWQnXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge21vZHVsZTogR3JpZENvbnRhaW5lciwgcmVmZXJlbmNlOiAnZ3JpZCd9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogUGFuZWwsXG4gICAgICAgICAgICAgICAgZmxleCAgICAgOiAxLjMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAncGllLWNoYXJ0LXBhbmVsJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICBkb2NrOiAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZHJhZ2dhYmxlJ10sXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdQaWUgQ2hhcnQnXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge21vZHVsZTogUGllQ2hhcnRDb21wb25lbnQsIHJlZmVyZW5jZTogJ3BpZS1jaGFydCd9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogUGFuZWwsXG4gICAgICAgICAgICAgICAgZmxleCAgICAgOiAxLjMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAnYmFyLWNoYXJ0LXBhbmVsJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICBkb2NrOiAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZHJhZ2dhYmxlJ10sXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdCYXIgQ2hhcnQnXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge21vZHVsZTogQmFyQ2hhcnRDb21wb25lbnQsIHJlZmVyZW5jZTogJ2Jhci1jaGFydCd9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfV0sXG4gICAgICAgIH1dLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnN0YXRlLlByb3ZpZGVyfSBzdGF0ZVByb3ZpZGVyPVZpZXdwb3J0U3RhdGVQcm92aWRlclxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlUHJvdmlkZXI6IFZpZXdwb3J0U3RhdGVQcm92aWRlclxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmlld3BvcnQpO1xuIiwiaW1wb3J0IENvbnRyb2xsZXIgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQHN1bW1hcnkgVGhlIG1haW4gY29udHJvbGxlciBmb3IgdGhlIENvbG9ycyBkZW1vIGFwcGxpY2F0aW9uLlxuICogQGRlc2NyaXB0aW9uIFRoaXMgY29udHJvbGxlciBvcmNoZXN0cmF0ZXMgdGhlIGVudGlyZSBDb2xvcnMgYXBwbGljYXRpb24sIG1hbmFnaW5nIHRoZSBkYXNoYm9hcmQgd2lkZ2V0cyAoZ3JpZCwgcGllIGNoYXJ0LCBiYXIgY2hhcnQpLFxuICogaGFuZGxpbmcgcmVhbC10aW1lIGRhdGEgdXBkYXRlcywgYW5kIGRlbW9uc3RyYXRpbmcgc29tZSBvZiBOZW8ubWpzJ3MgbW9zdCBhZHZhbmNlZCBmZWF0dXJlcy5cbiAqIEl0IHNlcnZlcyBhcyBhIGNlbnRyYWwgaHViIGZvciBzdGF0ZSBtYW5hZ2VtZW50LCBjcm9zcy13aW5kb3cgY29tbXVuaWNhdGlvbiwgYW5kIHRoZSBzZWFtbGVzcyBkcmFnLXRvLXBvcHVwIGZ1bmN0aW9uYWxpdHkuXG4gKiBUaGlzIGNsYXNzIGlzIGEga2V5IGV4YW1wbGUgb2YgaG93IHRvIGJ1aWxkIGEgY29tcGxleCwgaW50ZXJhY3RpdmUsIGFuZCBtdWx0aS13aW5kb3cgYXBwbGljYXRpb24uXG4gKiBAY2xhc3MgQ29sb3JzLnZpZXcuVmlld3BvcnRDb250cm9sbGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqIEBzZWUgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmVcbiAqL1xuY2xhc3MgVmlld3BvcnRDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMudmlldy5WaWV3cG9ydENvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LlZpZXdwb3J0Q29udHJvbGxlcidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUcmFja3MgdGhlIG5hbWVzIG9mIHdpZGdldHMgY3VycmVudGx5IG9wZW4gaW4gc2VwYXJhdGUgd2luZG93cy5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY29ubmVjdGVkQXBwcz1bXVxuICAgICAqL1xuICAgIGNvbm5lY3RlZEFwcHMgPSBbXVxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBJRCBmb3IgdGhlIGBzZXRJbnRlcnZhbGAgdXNlZCBmb3IgcmVhbC10aW1lIGRhdGEgdXBkYXRlcy5cbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gaW50ZXJ2YWxJZFxuICAgICAqL1xuICAgIGludGVydmFsSWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQSBwcml2YXRlIGZsYWcgdG8gdHJhY2sgaWYgYSBkcmFnIG9wZXJhdGlvbiBpcyBpbiB0aGUgcHJvY2VzcyBvZiBtb3ZpbmcgYSB3aWRnZXQgdG8gYSBuZXcgd2luZG93LlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59ICNpc1dpbmRvd0RyYWdnaW5nPWZhbHNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjaXNXaW5kb3dEcmFnZ2luZyA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQSBtYXAgdG8gZ2V0IHRoZSBvcmlnaW5hbCBpbmRleCBvZiBhIHdpZGdldCBpbiB0aGUgZGFzaGJvYXJkJ3MgaXRlbXMgYXJyYXkuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgdXNlZCB0byBjb3JyZWN0bHkgcmUtaW5zZXJ0IGEgd2lkZ2V0IHdoZW4gaXRzIHBvcHVwIHdpbmRvdyBpcyBjbG9zZWQuXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB3aWRnZXRJbmRleE1hcFxuICAgICAqL1xuICAgIHdpZGdldEluZGV4TWFwID0ge1xuICAgICAgICAnYmFyLWNoYXJ0JzogMixcbiAgICAgICAgJ3BpZS1jaGFydCc6IDEsXG4gICAgICAgIGdyaWQgICAgICAgOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRmFjdG9yeSBtZXRob2QgdG8gb3BlbiBhIHdpZGdldCBpbiBhIG5ldyBicm93c2VyIHdpbmRvdyBvciBwb3B1cC5cbiAgICAgKiBAZGVzY3JpcHRpb24gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIG9wZW4gYSBmdWxsIGJyb3dzZXIgd2luZG93IG9yIGEgZnJhbWVsZXNzIHBvcHVwIGJhc2VkIG9uIHRoZVxuICAgICAqIGBvcGVuV2lkZ2V0c0FzUG9wdXBzYCBzdGF0ZS4gSXQgY2FsY3VsYXRlcyB0aGUgY29ycmVjdCBVUkwgYW5kIHdpbmRvdyBmZWF0dXJlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgcmVmZXJlbmNlIG5hbWUgb2YgdGhlIHdpZGdldCB0byBvcGVuIChlLmcuLCAnZ3JpZCcpLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJyb3dzZXJXaW5kb3cobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSgnb3BlbldpZGdldHNBc1BvcHVwcycpKSB7XG4gICAgICAgICAgICBsZXQgd2lkZ2V0ID0gdGhpcy5nZXRSZWZlcmVuY2UobmFtZSksXG4gICAgICAgICAgICAgICAgcmVjdCAgID0gYXdhaXQgdGhpcy5jb21wb25lbnQuZ2V0RG9tUmVjdCh3aWRnZXQudmRvbS5pZCk7IC8vIHVzaW5nIHRoZSB2ZG9tIGlkIHRvIGFsd2F5cyBnZXQgdGhlIHRvcC1sZXZlbCBub2RlXG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI29wZW5XaWRnZXRJblBvcHVwKG5hbWUsIHJlY3QpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQge2NvbmZpZywgd2luZG93Q29uZmlnc30gPSBOZW8sXG4gICAgICAgICAgICAgICAge2Vudmlyb25tZW50fSAgICAgICAgICAgPSBjb25maWcsXG4gICAgICAgICAgICAgICAgZmlyc3RXaW5kb3dJZCAgICAgICAgICAgPSBwYXJzZUludChPYmplY3Qua2V5cyh3aW5kb3dDb25maWdzKVswXSksXG4gICAgICAgICAgICAgICAge2Jhc2VQYXRofSAgICAgICAgICAgICAgPSB3aW5kb3dDb25maWdzW2ZpcnN0V2luZG93SWRdLFxuICAgICAgICAgICAgICAgIHVybDtcblxuICAgICAgICAgICAgaWYgKGVudmlyb25tZW50ICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhdGggPSBgJHtiYXNlUGF0aCArIGVudmlyb25tZW50fS9gXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVybCA9IGAke2Jhc2VQYXRofWFwcHMvY29sb3JzL2NoaWxkYXBwcy93aWRnZXQvaW5kZXguaHRtbD9uYW1lPSR7bmFtZX1gO1xuXG4gICAgICAgICAgICBhd2FpdCBOZW8uTWFpbi53aW5kb3dPcGVuKHt1cmwsIHdpbmRvd05hbWU6ICdfYmxhbmsnfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENsZWFucyB1cCB0aGUgcmVhbC10aW1lIHVwZGF0ZSBpbnRlcnZhbCB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGRlc3Ryb3llZC5cbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLmludGVydmFsSWQgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0aGUgYGNvbm5lY3RgIGV2ZW50IGZpcmVkIGJ5IGBOZW8uY3VycmVudFdvcmtlcmAuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgdHJpZ2dlcmVkIHdoZW4gYSBuZXcgY2hpbGQgYXBwbGljYXRpb24gKGEgZGV0YWNoZWQgd2lkZ2V0IHdpbmRvdykgY29ubmVjdHMgdG8gdGhlIHNoYXJlZCB3b3JrZXIuXG4gICAgICogSXQgcmUtcGFyZW50cyB0aGUgd2lkZ2V0IGNvbXBvbmVudCBmcm9tIHRoZSBtYWluIGFwcCdzIGNvbXBvbmVudCB0cmVlIGludG8gdGhlIG5ldyBjaGlsZCBhcHAncyB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YSBmcm9tIHRoZSB3b3JrZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZSBUaGUgbmFtZSBvZiB0aGUgY29ubmVjdGluZyBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZCBUaGUgSUQgb2YgdGhlIG5ldyB3aW5kb3cuXG4gICAgICovXG4gICAgYXN5bmMgb25BcHBDb25uZWN0KGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuYXBwTmFtZSA9PT0gJ0NvbG9yc1dpZGdldCcpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFwcCAgICAgICAgICA9IE5lby5hcHBzW2RhdGEuYXBwTmFtZV0sXG4gICAgICAgICAgICAgICAgbWFpblZpZXcgICAgID0gYXBwLm1haW5WaWV3LFxuICAgICAgICAgICAgICAgIHt3aW5kb3dJZH0gICA9IGRhdGEsXG4gICAgICAgICAgICAgICAgdXJsICAgICAgICAgID0gYXdhaXQgTmVvLk1haW4uZ2V0QnlQYXRoKHtwYXRoOiAnZG9jdW1lbnQuVVJMJywgd2luZG93SWR9KSxcbiAgICAgICAgICAgICAgICB3aWRnZXROYW1lICAgPSBuZXcgVVJMKHVybCkuc2VhcmNoUGFyYW1zLmdldCgnbmFtZScpLFxuICAgICAgICAgICAgICAgIHdpZGdldCAgICAgICA9IG1lLmdldFJlZmVyZW5jZSh3aWRnZXROYW1lKSxcbiAgICAgICAgICAgICAgICBwYXJlbnQgICAgICAgPSB3aWRnZXQudXAoJ3BhbmVsJyk7XG5cbiAgICAgICAgICAgIGlmICghbWUuI2lzV2luZG93RHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaGlkZSgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmNvbm5lY3RlZEFwcHMucHVzaCh3aWRnZXROYW1lKTtcblxuICAgICAgICAgICAgbWUuZ2V0UmVmZXJlbmNlKGBkZXRhY2gtJHt3aWRnZXROYW1lfS1idXR0b25gKS5kaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIG1haW5WaWV3LmFkZCh3aWRnZXQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRoZSBgZGlzY29ubmVjdGAgZXZlbnQgZmlyZWQgYnkgYE5lby5jdXJyZW50V29ya2VyYC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyB0cmlnZ2VyZWQgd2hlbiBhIGNoaWxkIGFwcGxpY2F0aW9uIHdpbmRvdyBpcyBjbG9zZWQuIEl0IG1vdmVzIHRoZSB3aWRnZXQgY29tcG9uZW50XG4gICAgICogYmFjayBpbnRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiBpbiB0aGUgbWFpbiBhcHBsaWNhdGlvbidzIGRhc2hib2FyZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YSBmcm9tIHRoZSB3b3JrZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGlzY29ubmVjdGluZyBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS53aW5kb3dJZCBUaGUgSUQgb2YgdGhlIGNsb3NlZCB3aW5kb3cuXG4gICAgICovXG4gICAgYXN5bmMgb25BcHBEaXNjb25uZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuI2lzV2luZG93RHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIG1lLiNpc1dpbmRvd0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7YXBwTmFtZSwgd2luZG93SWR9ID0gZGF0YSxcbiAgICAgICAgICAgIGRhc2hib2FyZCAgICAgICAgICAgPSBtZS5nZXRSZWZlcmVuY2UoJ2Rhc2hib2FyZCcpLFxuICAgICAgICAgICAgdXJsICAgICAgICAgICAgICAgICA9IGF3YWl0IE5lby5NYWluLmdldEJ5UGF0aCh7cGF0aDogJ2RvY3VtZW50LlVSTCcsIHdpbmRvd0lkfSksXG4gICAgICAgICAgICB3aWRnZXROYW1lICAgICAgICAgID0gbmV3IFVSTCh1cmwpLnNlYXJjaFBhcmFtcy5nZXQoJ25hbWUnKSxcbiAgICAgICAgICAgIHdpZGdldCAgICAgICAgICAgICAgPSBtZS5nZXRSZWZlcmVuY2Uod2lkZ2V0TmFtZSk7XG5cbiAgICAgICAgLy8gQ2xvc2luZyBhIG5vbi1tYWluIGFwcCBuZWVkcyB0byBtb3ZlIHRoZSB3aWRnZXQgYmFjayBpbnRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiAmIHJlLWVuYWJsZSB0aGUgc2hvdyBidXR0b25cbiAgICAgICAgaWYgKGFwcE5hbWUgPT09ICdDb2xvcnNXaWRnZXQnKSB7XG4gICAgICAgICAgICBsZXQgaXRlbVBhbmVsICAgICA9IGRhc2hib2FyZC5pdGVtc1ttZS53aWRnZXRJbmRleE1hcFt3aWRnZXROYW1lXV0sXG4gICAgICAgICAgICAgICAgYm9keUNvbnRhaW5lciA9IGl0ZW1QYW5lbC5nZXRSZWZlcmVuY2UoJ2JvZHlDb250YWluZXInKTtcblxuICAgICAgICAgICAgYm9keUNvbnRhaW5lci5hZGQod2lkZ2V0KTtcbiAgICAgICAgICAgIGl0ZW1QYW5lbC5zaG93KHRydWUpO1xuXG4gICAgICAgICAgICBtZS5nZXRSZWZlcmVuY2UoYGRldGFjaC0ke3dpZGdldE5hbWV9LWJ1dHRvbmApLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9zZSBwb3B1cCB3aW5kb3dzIHdoZW4gY2xvc2luZyBvciByZWxvYWRpbmcgdGhlIG1haW4gd2luZG93XG4gICAgICAgIGVsc2UgaWYgKGFwcE5hbWUgPT09ICdDb2xvcnMnKSB7XG4gICAgICAgICAgICBOZW8uTWFpbi53aW5kb3dDbG9zZSh7bmFtZXM6IG1lLmNvbm5lY3RlZEFwcHMsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgdGhlIGNoYW5nZSBldmVudCBmcm9tIHRoZSAnQW1vdW50IG9mIENvbG9ycycgc2xpZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlQW1vdW50Q29sb3JzKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhUHJvcGVydHkoZGF0YSwgJ2Ftb3VudENvbG9ycycsICBkYXRhLnZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgdGhlIGNoYW5nZSBldmVudCBmcm9tIHRoZSAnQW1vdW50IG9mIENvbHVtbnMnIHJhZGlvZmllbGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgb25DaGFuZ2VBbW91bnRDb2x1bW5zKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhUHJvcGVydHkoZGF0YSwgJ2Ftb3VudENvbHVtbnMnLCAgcGFyc2VJbnQoZGF0YS52YWx1ZS5uYW1lKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRoZSBjaGFuZ2UgZXZlbnQgZnJvbSB0aGUgJ0Ftb3VudCBvZiBSb3dzJyByYWRpb2ZpZWxkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlQW1vdW50Um93cyhkYXRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVByb3BlcnR5KGRhdGEsICdhbW91bnRSb3dzJywgIHBhcnNlSW50KGRhdGEudmFsdWUubmFtZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0aGUgY2hhbmdlIGV2ZW50IGZyb20gdGhlICdPcGVuIHdpZGdldHMgYXMgUG9wdXBzJyBjaGVja2JveC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBvbkNoYW5nZU9wZW5XaWRnZXRzQXNQb3B1cHMoZGF0YSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCdvcGVuV2lkZ2V0c0FzUG9wdXBzJywgZGF0YS52YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMaWZlY3ljbGUgbWV0aG9kLCBjYWxsZWQgYWZ0ZXIgdGhlIGNvbnRyb2xsZXIncyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0cyB1cCBsaXN0ZW5lcnMgZm9yIHRoZSBzaGFyZWQgd29ya2VyJ3MgY29ubmVjdCBhbmQgZGlzY29ubmVjdCBldmVudHMuXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIub24oe1xuICAgICAgICAgICAgY29ubmVjdCAgIDogbWUub25BcHBDb25uZWN0LFxuICAgICAgICAgICAgZGlzY29ubmVjdDogbWUub25BcHBEaXNjb25uZWN0LFxuICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMaWZlY3ljbGUgbWV0aG9kLCBjYWxsZWQgYWZ0ZXIgdGhlIGNvbnRyb2xsZXIncyBjb21wb25lbnQgaXMgY29uc3RydWN0ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIFRyaWdnZXJzIHRoZSBpbml0aWFsIGRhdGEgbG9hZCBmb3IgdGhlIHdpZGdldHMuXG4gICAgICovXG4gICAgb25Db21wb25lbnRDb25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVdpZGdldHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgdGhlIGNsaWNrIGV2ZW50IGZvciB0aGUgJ0RldGFjaCBCYXIgQ2hhcnQnIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRldGFjaEJhckNoYXJ0QnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUJyb3dzZXJXaW5kb3coJ2Jhci1jaGFydCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0aGUgY2xpY2sgZXZlbnQgZm9yIHRoZSAnRGV0YWNoIEdyaWQnIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRldGFjaEdyaWRCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlQnJvd3NlcldpbmRvdygnZ3JpZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0aGUgY2xpY2sgZXZlbnQgZm9yIHRoZSAnRGV0YWNoIFBpZSBDaGFydCcgYnV0dG9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIG9uRGV0YWNoUGllQ2hhcnRCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlQnJvd3NlcldpbmRvdygncGllLWNoYXJ0JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRoZSBgZHJhZ0JvdW5kYXJ5RW50cnlgIGV2ZW50IGZyb20gdGhlIGBTb3J0Wm9uZWAuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgdGhlIGNvcmUgb2YgdGhlIGRyYWctdG8tcmUtZG9jayBmZWF0dXJlLiBXaGVuIGEgZHJhZ2dlZCB3aW5kb3cgcmUtZW50ZXJzIHRoZSBtYWluXG4gICAgICogYXBwbGljYXRpb24ncyBib3VuZGFyeSwgdGhpcyBtZXRob2QgY2xvc2VzIHRoZSBwb3B1cCB3aW5kb3cgYW5kIHJlLWluc2VydHMgdGhlIHdpZGdldCBjb21wb25lbnRcbiAgICAgKiBiYWNrIGludG8gaXRzIG9yaWdpbmFsIGRhc2hib2FyZCBjb250YWluZXIsIHByb3ZpZGluZyBhIHNlYW1sZXNzIHVzZXIgZXhwZXJpZW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YSBmcm9tIHRoZSBTb3J0Wm9uZS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdCb3VuZGFyeUVudHJ5KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSAgICA9IG1lLFxuICAgICAgICAgICAge3NvcnRab25lfSAgICA9IGRhdGEsXG4gICAgICAgICAgICB3aWRnZXROYW1lICAgID0gZGF0YS5kcmFnZ2VkSXRlbS5yZWZlcmVuY2UucmVwbGFjZSgnLXBhbmVsJywgJycpLFxuICAgICAgICAgICAgd2lkZ2V0ICAgICAgICA9IG1lLmdldFJlZmVyZW5jZSh3aWRnZXROYW1lKSxcbiAgICAgICAgICAgIGRhc2hib2FyZCAgICAgPSBtZS5nZXRSZWZlcmVuY2UoJ2Rhc2hib2FyZCcpLFxuICAgICAgICAgICAgaXRlbVBhbmVsICAgICA9IGRhc2hib2FyZC5pdGVtc1ttZS53aWRnZXRJbmRleE1hcFt3aWRnZXROYW1lXV0sXG4gICAgICAgICAgICBib2R5Q29udGFpbmVyID0gaXRlbVBhbmVsLmdldFJlZmVyZW5jZSgnYm9keUNvbnRhaW5lcicpO1xuXG4gICAgICAgIGF3YWl0IE5lby5NYWluLndpbmRvd0Nsb3NlKHtuYW1lczogd2lkZ2V0TmFtZSwgd2luZG93SWR9KTtcblxuICAgICAgICBib2R5Q29udGFpbmVyLmFkZCh3aWRnZXQpO1xuXG4gICAgICAgIG1lLiNpc1dpbmRvd0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgc29ydFpvbmUuaXNXaW5kb3dEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBzb3J0Wm9uZS5kcmFnUHJveHkuaGlkZGVuID0gZmFsc2U7XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0Q29uZmlncyh7aXNXaW5kb3dEcmFnZ2luZzogZmFsc2UsIHdpbmRvd0lkfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRoZSBgZHJhZ0JvdW5kYXJ5RXhpdGAgZXZlbnQgZnJvbSB0aGUgYFNvcnRab25lYC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyB0aGUgY29yZSBvZiB0aGUgZHJhZy10by1wb3B1cCBmZWF0dXJlLiBXaGVuIGEgZHJhZ2dlZCBjb21wb25lbnQncyBwcm94eSBsZWF2ZXNcbiAgICAgKiB0aGUgYm91bmRhcnkgb2YgaXRzIGNvbnRhaW5lciwgdGhpcyBtZXRob2Qgb3JjaGVzdHJhdGVzIHRoZSBjcmVhdGlvbiBvZiBhIG5ldyBwb3B1cCB3aW5kb3dcbiAgICAgKiBhbmQgaGFuZHMgb2ZmIHRoZSBkcmFnIG9wZXJhdGlvbiB0byB0aGUgbWFpbiB0aHJlYWQncyBEcmFnRHJvcCBhZGRvbiB0byBkcmFnIHRoZSBPUy1sZXZlbCB3aW5kb3cuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGV2ZW50IGRhdGEgZnJvbSB0aGUgU29ydFpvbmUuXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnQm91bmRhcnlFeGl0KGRhdGEpIHtcbiAgICAgICAgbGV0IHtkcmFnZ2VkSXRlbSwgcHJveHlSZWN0LCBzb3J0Wm9uZX0gPSBkYXRhLFxuICAgICAgICAgICAgd2lkZ2V0TmFtZSAgICAgICAgICAgICAgICAgICAgICAgICA9IGRyYWdnZWRJdGVtLnJlZmVyZW5jZS5yZXBsYWNlKCctcGFuZWwnLCAnJyksXG4gICAgICAgICAgICBwb3B1cERhdGE7XG5cbiAgICAgICAgdGhpcy4jaXNXaW5kb3dEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLy8gUHJvaGliaXQgdGhlIHNpemUgcmVkdWN0aW9uIGluc2lkZSAjb3BlbldpZGdldEluUG9wdXAoKS5cbiAgICAgICAgcHJveHlSZWN0LmhlaWdodCArPSA1MDtcblxuICAgICAgICBwb3B1cERhdGEgPSBhd2FpdCB0aGlzLiNvcGVuV2lkZ2V0SW5Qb3B1cCh3aWRnZXROYW1lLCBwcm94eVJlY3QpO1xuXG4gICAgICAgIHNvcnRab25lLnN0YXJ0V2luZG93RHJhZyh7XG4gICAgICAgICAgICBkcmFnRGF0YTogZGF0YSxcbiAgICAgICAgICAgIC4uLnBvcHVwRGF0YVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRoZSBjbGljayBldmVudCB0byByZXF1ZXN0IFdpbmRvdyBNYW5hZ2VtZW50IHBlcm1pc3Npb25zLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgV2luZG93IE1hbmFnZW1lbnQgQVBJIGlzIGEgbmV3IGJyb3dzZXIgZmVhdHVyZSB0aGF0IGFsbG93cyB3ZWIgYXBwcyB0byBjb250cm9sXG4gICAgICogdGhlIHBsYWNlbWVudCBvZiB3aW5kb3dzLCB3aGljaCBpcyBlc3NlbnRpYWwgZm9yIHRoZSBkcmFnLXRvLXBvcHVwIGZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgb25FbmFibGVXaW5kb3dNYW5hZ2VtZW50Q2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5yZXF1ZXN0V2luZG93TWFuYWdlbWVudFBlcm1pc3Npb24oKSxcbiAgICAgICAgICAgIGJ1dHRvbiAgID0gbWUuZ2V0UmVmZXJlbmNlKCd3aW5kb3ctbWFuYWdlbWVudC1idXR0b24nKTtcblxuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgYnV0dG9uLnRleHQgPSAnVy1NIGVuYWJsZWQnO1xuICAgICAgICAgICAgYnV0dG9uLmljb25DbHMgPSAnZmEgZmEtY2hlY2stc3F1YXJlJztcbiAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidXR0b24udGV4dCA9ICdXLU0gZGlzYWJsZWQnO1xuICAgICAgICAgICAgYnV0dG9uLmljb25DbHMgPSAnZmEgZmEtZXhjbGFtYXRpb24tdHJpYW5nbGUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU3RhcnRzIHRoZSByZWFsLXRpbWUgZGF0YSB1cGRhdGUgaW50ZXJ2YWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgb25TdGFydEJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbnRlcnZhbFRpbWUgPSAxMDAwIC8gNjA7IC8vIGFzc3VtaW5nIDYwIEZQU1xuXG4gICAgICAgIG1lLnNldFN0YXRlKHtpc1VwZGF0aW5nOiB0cnVlfSk7XG5cbiAgICAgICAgaWYgKCFtZS5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBtZS5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZVdpZGdldHMoKVxuICAgICAgICAgICAgfSwgaW50ZXJ2YWxUaW1lKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU3RvcHMgdGhlIHJlYWwtdGltZSBkYXRhIHVwZGF0ZSBpbnRlcnZhbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBvblN0b3BCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2V0U3RhdGUoe2lzVXBkYXRpbmc6IGZhbHNlfSk7XG5cbiAgICAgICAgaWYgKG1lLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobWUuaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICBtZS5pbnRlcnZhbElkID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUHJpdmF0ZSBoZWxwZXIgbWV0aG9kIHRvIG9wZW4gYSB3aWRnZXQgaW4gYSBuZXcgcG9wdXAgd2luZG93LlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBwcmVjaXNlIHNjcmVlbiBjb29yZGluYXRlcyBmb3IgdGhlIG5ldyB3aW5kb3cgYmFzZWQgb24gdGhlIG1haW5cbiAgICAgKiB3aW5kb3cncyBwb3NpdGlvbiBhbmQgdGhlIGRyYWcgcHJveHkncyBsYXN0IGtub3duIHJlY3RhbmdsZS4gSXQgdGhlbiBjYWxscyB0aGUgbWFpbiB0aHJlYWRcbiAgICAgKiB0byBvcGVuIHRoZSBuZXcgd2luZG93IHdpdGggdGhlIGNvcnJlY3QgVVJMIGFuZCBmZWF0dXJlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgcmVmZXJlbmNlIG5hbWUgb2YgdGhlIHdpZGdldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdCBUaGUgRE9NIHJlY3Qgb2YgdGhlIGRyYWcgcHJveHkuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbmV3IHdpbmRvdydzIHByb3BlcnRpZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyAjb3BlbldpZGdldEluUG9wdXAobmFtZSwgcmVjdCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSAgICAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIHtjb25maWcsIHdpbmRvd0NvbmZpZ3N9ID0gTmVvLFxuICAgICAgICAgICAge2Vudmlyb25tZW50fSAgICAgICAgICAgPSBjb25maWcsXG4gICAgICAgICAgICBmaXJzdFdpbmRvd0lkICAgICAgICAgICA9IHBhcnNlSW50KE9iamVjdC5rZXlzKHdpbmRvd0NvbmZpZ3MpWzBdKSxcbiAgICAgICAgICAgIHtiYXNlUGF0aH0gICAgICAgICAgICAgID0gd2luZG93Q29uZmlnc1tmaXJzdFdpbmRvd0lkXSxcbiAgICAgICAgICAgIHVybDtcblxuICAgICAgICBpZiAoZW52aXJvbm1lbnQgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gYCR7YmFzZVBhdGggKyBlbnZpcm9ubWVudH0vYFxuICAgICAgICB9XG5cbiAgICAgICAgdXJsID0gYCR7YmFzZVBhdGh9YXBwcy9jb2xvcnMvY2hpbGRhcHBzL3dpZGdldC9pbmRleC5odG1sP25hbWU9JHtuYW1lfWA7XG5cbiAgICAgICAgbGV0IHdpbkRhdGEgICAgICAgICAgICAgICA9IGF3YWl0IE5lby5NYWluLmdldFdpbmRvd0RhdGEoe3dpbmRvd0lkfSksXG4gICAgICAgICAgICB7aGVpZ2h0LCB3aWR0aCwgeCwgeX0gPSByZWN0LFxuICAgICAgICAgICAgcG9wdXBIZWlnaHQgICAgICAgICAgID0gaGVpZ2h0IC0gNTAsIC8vIHBvcHVwIGhlYWRlciBpbiBDaHJvbWVcbiAgICAgICAgICAgIHBvcHVwTGVmdCAgICAgICAgICAgICA9IHggKyB3aW5EYXRhLnNjcmVlbkxlZnQsXG4gICAgICAgICAgICBwb3B1cFRvcCAgICAgICAgICAgICAgPSB5ICsgKHdpbkRhdGEub3V0ZXJIZWlnaHQgLSB3aW5EYXRhLmlubmVySGVpZ2h0ICsgd2luRGF0YS5zY3JlZW5Ub3ApO1xuXG4gICAgICAgIGF3YWl0IE5lby5NYWluLndpbmRvd09wZW4oe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgd2luZG93RmVhdHVyZXM6IGBoZWlnaHQ9JHtwb3B1cEhlaWdodH0sbGVmdD0ke3BvcHVwTGVmdH0sdG9wPSR7cG9wdXBUb3B9LHdpZHRoPSR7d2lkdGh9YCxcbiAgICAgICAgICAgIHdpbmRvd05hbWUgICAgOiBuYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7cG9wdXBIZWlnaHQsIHBvcHVwTGVmdCwgcG9wdXBUb3AsIHBvcHVwV2lkdGg6IHdpZHRoLCB3aW5kb3dOYW1lOiBuYW1lfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZXMgdGhlIGNoYXJ0IGNvbXBvbmVudHMgd2l0aCBuZXcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIGNoYXJ0cy5cbiAgICAgKi9cbiAgICB1cGRhdGVDaGFydHMoZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgnYmFyLWNoYXJ0JykuY2hhcnREYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5nZXRSZWZlcmVuY2UoJ3BpZS1jaGFydCcpLmNoYXJ0RGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBIGdlbmVyaWMgaGFuZGxlciB0byB1cGRhdGUgYSBwcm9wZXJ0eSBpbiB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICogQGRlc2NyaXB0aW9uIEFsc28gdHJpZ2dlcnMgYSBtYW51YWwgd2lkZ2V0IHVwZGF0ZSBpZiByZWFsLXRpbWUgdXBkYXRlcyBhcmUgbm90IGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBjaGFuZ2UgZXZlbnQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlIGluIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R8bnVsbH0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHVwZGF0ZURhdGFQcm9wZXJ0eShkYXRhLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgc3RhdGVQcm92aWRlciA9IHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpO1xuXG4gICAgICAgIHN0YXRlUHJvdmlkZXIuc2V0RGF0YShuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGRhdGEub2xkVmFsdWUgIT09IG51bGwgJiYgIXN0YXRlUHJvdmlkZXIuZ2V0RGF0YSgnaXNVcGRhdGluZycpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdpZGdldHMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVXBkYXRlcyB0aGUgZGF0YSBncmlkIGNvbXBvbmVudCB3aXRoIG5ldyByZWNvcmRzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBVc2VzIGBidWxrVXBkYXRlUmVjb3Jkc2AgZm9yIHBlcmZvcm1hbmNlIGlmIHRoZSBzdG9yZSBhbHJlYWR5IGhhcyBkYXRhLCBvdGhlcndpc2Ugc2V0cyB0aGUgaW5pdGlhbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHJlY29yZHMgVGhlIGFycmF5IG9mIG5ldyByZWNvcmRzIGZvciB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICB1cGRhdGVHcmlkKHJlY29yZHMpIHtcbiAgICAgICAgbGV0IGdyaWQgICAgPSB0aGlzLmdldFJlZmVyZW5jZSgnZ3JpZCcpLFxuICAgICAgICAgICAge3N0b3JlfSA9IGdyaWQ7XG5cbiAgICAgICAgaWYgKHN0b3JlLmdldENvdW50KCkpIHtcbiAgICAgICAgICAgIGdyaWQuYnVsa1VwZGF0ZVJlY29yZHMocmVjb3JkcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgZGVsYXkgb2YgdGhlIFNvY2tldCBDb25uZWN0aW9uLFxuICAgICAgICAgICAgLy8gdGhlIG5leHQgZGF0YSBwYWNrYWdlIGNvdWxkIHN0aWxsIGNvbnRhaW4gdGhlIG9sZCBzZXR0aW5nc1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoJ2Ftb3VudFJvd3MnKSA9PT0gcmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5kYXRhID0gcmVjb3Jkc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRmV0Y2hlcyBuZXcgZGF0YSBmcm9tIHRoZSBiYWNrZW5kIHNlcnZpY2UgYW5kIHVwZGF0ZXMgYWxsIHdpZGdldHMuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgdGhlIG1haW4gZGF0YSByZWZyZXNoIG1ldGhvZC4gSXQgcmVhZHMgdGhlIGN1cnJlbnQgc2V0dGluZ3MgZnJvbSB0aGUgc3RhdGUgcHJvdmlkZXIsXG4gICAgICogYW5kIHRoZW4gdXNlcyBOZW8ubWpzJ3MgUlBDIGxheWVyIHRvIHNlYW1sZXNzbHkgY2FsbCB0aGUgYmFja2VuZCBgQ29sb3JTZXJ2aWNlLnJlYWQoKWAgbWV0aG9kLlxuICAgICAqIFRoaXMgZGVtb25zdHJhdGVzIHJlbW90ZSBtZXRob2QgYWNjZXNzLCBhbGxvd2luZyB0aGUgQXBwIFdvcmtlciB0byBpbnZva2UgYmFja2VuZCBmdW5jdGlvbmFsaXR5XG4gICAgICogYXMgaWYgaXQgd2VyZSBhIGxvY2FsIG1ldGhvZC4gQWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSwgaXQgZGlzdHJpYnV0ZXMgdGhlIG5ldyBkYXRhIHRvIHRoZSBncmlkIGFuZCBjaGFydHMuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlV2lkZ2V0cygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RhdGVQcm92aWRlciA9IG1lLmdldFN0YXRlUHJvdmlkZXIoKSxcbiAgICAgICAgICAgIHJlc3BvbnNlO1xuXG4gICAgICAgIC8vIFRpbWluZyBpc3N1ZSBpbnNpZGUgZGlzdC9kZXZlbG9wbWVudCA9PiB0aGUgbmFtZXNwYWNlIG1pZ2h0IG5vdCBiZSByZWdpc3RlcmVkIHlldFxuICAgICAgICBpZiAoIUNvbG9ycy5iYWNrZW5kKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUwKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZVdpZGdldHMoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBDb2xvcnMuYmFja2VuZC5Db2xvclNlcnZpY2UucmVhZCh7XG4gICAgICAgICAgICAgICAgYW1vdW50Q29sb3JzIDogc3RhdGVQcm92aWRlci5nZXREYXRhKCdhbW91bnRDb2xvcnMnKSxcbiAgICAgICAgICAgICAgICBhbW91bnRDb2x1bW5zOiBzdGF0ZVByb3ZpZGVyLmdldERhdGEoJ2Ftb3VudENvbHVtbnMnKSxcbiAgICAgICAgICAgICAgICBhbW91bnRSb3dzICAgOiBzdGF0ZVByb3ZpZGVyLmdldERhdGEoJ2Ftb3VudFJvd3MnKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghbWUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQge2RhdGF9ID0gcmVzcG9uc2U7XG5cbiAgICAgICAgICAgICAgICBtZS51cGRhdGVHcmlkKGRhdGEudGFibGVEYXRhKTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVDaGFydHMoZGF0YS5zdW1tYXJ5RGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmlld3BvcnRDb250cm9sbGVyKTtcbiIsImltcG9ydCBDb2xvcnNTdG9yZSAgIGZyb20gJy4uL3N0b3JlL0NvbG9ycy5tanMnO1xuaW1wb3J0IFN0YXRlUHJvdmlkZXIgZnJvbSAnLi4vLi4vLi4vc3JjL3N0YXRlL1Byb3ZpZGVyLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIENvbG9ycy52aWV3LlZpZXdwb3J0U3RhdGVQcm92aWRlclxuICogQGV4dGVuZHMgTmVvLnN0YXRlLlByb3ZpZGVyXG4gKi9cbmNsYXNzIFZpZXdwb3J0U3RhdGVQcm92aWRlciBleHRlbmRzIFN0YXRlUHJvdmlkZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnZpZXcuVmlld3BvcnRTdGF0ZVByb3ZpZGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdDb2xvcnMudmlldy5WaWV3cG9ydFN0YXRlUHJvdmlkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZGF0YS5hbW91bnRDb2xvcnM9MTBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYW1vdW50Q29sb3JzOiAxMCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBkYXRhLmFtb3VudENvbHVtbnM9MTBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYW1vdW50Q29sdW1uczogMTAsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZGF0YS5hbW91bnRSb3dzPTEwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFtb3VudFJvd3M6IDEwLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkYXRhLmlzVXBkYXRpbmc9ZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNVcGRhdGluZzogZmFsc2UsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRhdGEub3BlbldpZGdldHNBc1BvcHVwcz10cnVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9wZW5XaWRnZXRzQXNQb3B1cHM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3RvcmVzXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZXM6IHtcbiAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogQ29sb3JzU3RvcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmlld3BvcnRTdGF0ZVByb3ZpZGVyKTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGEgbGFiZWwgd2l0aCBhIHRleHRcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkxhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTGFiZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5MYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5MYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0YWc9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiAnbGFiZWwnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMYWJlbCk7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL0Jhc2UubWpzJztcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjbGFzcyB0byByZW5kZXIgYW4gYW1DaGFydFxuICogUmVxdWlyZXMgc2V0dGluZyBOZW8uY29uZmlnLnVzZUFtQ2hhcnRzIHRvIHRydWUgKG9yIG1hbnVhbGx5IGluY2x1ZGUgdGhlIGxpYilcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LndyYXBwZXIuQW1DaGFydFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEFtQ2hhcnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC53cmFwcGVyLkFtQ2hhcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQud3JhcHBlci5BbUNoYXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2FtLWNoYXJ0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2FtLWNoYXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZTogaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjQvXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY2hhcnRDb25maWdfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydENvbmZpZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGNoYXJ0IGRhdGFcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gY2hhcnREYXRhXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnREYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2hhcnRUeXBlPSdYWUNoYXJ0J1xuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnRUeXBlOiAnWFlDaGFydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdCBpcyBub3QgcG9zc2libGUgdG8gZGVmaW5lIGFkYXB0ZXJzIHZpYSBqc29uLCBzbyB3ZSBwYXNzIGEgZmxhZyB0byBtYWluIGluc3RlYWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY29tYmluZVNlcmllc1Rvb2x0aXA9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGNvbWJpbmVTZXJpZXNUb29sdGlwOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYXJ0cyAmIG1hcHMgY2FuIGhhdmUgZGlmZmVyZW50IHRhcmdldHMgdG8gYXBwbHkgdGhlIGRhdGEgdG8uIEUuZy46XG4gICAgICAgICAqIG15Q2hhcnQuZGF0YSA9IGRhdGE7IC8vID0+ICcnXG4gICAgICAgICAqIG15Q2hhcnQuc2VyaWVzLnZhbHVlc1swXS5kYXRhID0gZGF0YTsgLy8gPT4gJ3Nlcmllcy52YWx1ZXMuMCdcbiAgICAgICAgICogVXNlIGEgTmVvLm5zKCkgY29uZm9ybSBzeW50YXggd2l0aCBkb3RzIGJldHdlZW4gcHJvcHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkYXRhUGF0aD0nJ1xuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVBhdGg6ICcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYW00Y2hhcnRzLCBhbTRtYXBzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcGFja2FnZT0nYW00Y2hhcnRzJ1xuICAgICAgICAgKi9cbiAgICAgICAgcGFja2FnZTogJ2FtNGNoYXJ0cycsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtzdHlsZToge3Bvc2l0aW9uOiAncmVsYXRpdmUnfSwgY246IFtcbiAgICAgICAgICAgIHtzdHlsZToge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBoZWlnaHQ6ICcxMDAlJywgd2lkdGg6ICcxMDAlJ30sIGNuOiBbe31dfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2hhcnREYXRhIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q2hhcnREYXRhKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIGRhdGFQYXRoLCBpZCwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5BbUNoYXJ0cy51cGRhdGVEYXRhKHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGFQYXRoLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICBvcHRzICAgICAgICAgICAgICAgICAgICA9IHthcHBOYW1lLCBpZCwgd2luZG93SWR9O1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgJiYgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uQW1DaGFydHMuZGVzdHJveShvcHRzKVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICAgICAgY29tYmluZVNlcmllc1Rvb2x0aXA6IG1lLmNvbWJpbmVTZXJpZXNUb29sdGlwLFxuICAgICAgICAgICAgICAgIGNvbmZpZyAgICAgICAgICAgICAgOiBtZS5jaGFydENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYWNrYWdlICAgICAgICAgICAgIDogbWUucGFja2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlICAgICAgICAgICAgICAgIDogbWUuY2hhcnRUeXBlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobWUuY2hhcnREYXRhKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5kYXRhICAgICA9IG1lLmNoYXJ0RGF0YTtcbiAgICAgICAgICAgICAgICBvcHRzLmRhdGFQYXRoID0gbWUuZGF0YVBhdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkFtQ2hhcnRzLmNyZWF0ZShvcHRzKS50aGVuKG1lLm9uQ2hhcnRNb3VudGVkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGNoYXJ0Q29uZmlnIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2hhcnRDb25maWcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dyYXBwZXIuQW1DaGFydCBkZWZpbmVkIHdpdGhvdXQgYSBjaGFydENvbmZpZycsIHRoaXMuaWQpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcnNlSXRlbUNvbmZpZ3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICBOZW8ubWFpbi5hZGRvbi5BbUNoYXJ0cy5kZXN0cm95KHthcHBOYW1lLCBpZCwgd2luZG93SWR9KVxuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHRyaWdnZXIgbG9naWMgYWZ0ZXIgdGhlIGNoYXJ0IGdvdCBtb3VudGVkIGludG8gdGhlIGRvbVxuICAgICAqL1xuICAgIG9uQ2hhcnRNb3VudGVkKCkge1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBbUNoYXJ0KTtcbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgIGZyb20gJy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFuIGV4dGVuZGVkIENvbnRhaW5lciBzdXBwb3J0aW5nIG11bHRpcGxlIGRvY2tlZCBoZWFkZXIgdG9vbGJhcnNcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlBhbmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgUGFuZWwgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5QYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5QYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1wYW5lbCcsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjb250YWluZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBoZWFkZXJEZWZhdWx0cz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJEZWZhdWx0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBoZWFkZXJzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1zPXtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIF9sYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlOiAndmJveCcsXG4gICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB2ZXJ0aWNhbEhlYWRlcnNGaXJzdD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdmVydGljYWxIZWFkZXJzRmlyc3Q6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGFzSGVhZGVycygpICYmIG1lLnZlcnRpY2FsSGVhZGVyc0ZpcnN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZS5sYXlvdXQgPSB7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdoYm94JyxcbiAgICAgICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlciB0aGUgaGVhZGVyIGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpIHtcbiAgICAgICAgaWYgKE5lby50eXBlT2YoaGVhZGVyKSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgICAgICBmbGV4OiAnMCAxIGF1dG8nXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFoZWFkZXIubW9kdWxlICYmICFoZWFkZXIubnR5cGUpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMgICA9IFsnbmVvLXBhbmVsLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ107XG4gICAgICAgICAgICBjb25maWcubnR5cGUgPSAndG9vbGJhcic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhZGVyLnRleHQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5pdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLXBhbmVsLWhlYWRlci10ZXh0JywgJ25lby1sYWJlbCddLFxuICAgICAgICAgICAgICAgIHRleHQgOiBoZWFkZXIudGV4dFxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXIudGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc3VtaW5nIGFsbCBsYWJlbHMgaW5zaWRlIGEgUGFuZWwgSGVhZGVyIGFyZSBtZWFudCB0byBiZSB0aXRsZXMgLT4gbG9vayB0aGUgc2FtZSB3YXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyLml0ZW1zKSkge1xuICAgICAgICAgICAgaGVhZGVyLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ubnR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbHMgPSBbJ25lby1wYW5lbC1oZWFkZXItdGV4dCcsICduZW8tbGFiZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4uY29uZmlnLCAuLi5oZWFkZXJ9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb250YWluZXJDb25maWcgPSBtZS5jb250YWluZXJDb25maWc7XG5cbiAgICAgICAgaWYgKCFtZS5oYXNIZWFkZXJzKCkpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNvbmZpZyAmJiBtZS5zZXQoY29udGFpbmVyQ29uZmlnKTtcbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaGYgICAgICAgICAgICAgICAgICAgPSBtZS52ZXJ0aWNhbEhlYWRlcnNGaXJzdCA9PT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVycyAgICAgICAgICAgICAgPSBtZS5oZWFkZXJzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGJvdHRvbUhlYWRlcnMgICAgICAgID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtyZXR1cm4gaGVhZGVyLmRvY2sgPT09IChoZiA/J2JvdHRvbSc6ICdyaWdodCcpfSksXG4gICAgICAgICAgICAgICAgbGVmdEhlYWRlcnMgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8nbGVmdCcgIDogJ3RvcCcpfSksXG4gICAgICAgICAgICAgICAgcmlnaHRIZWFkZXJzICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ncmlnaHQnIDogJ2JvdHRvbScpfSksXG4gICAgICAgICAgICAgICAgdG9wSGVhZGVycyAgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ndG9wJyAgIDogJ2xlZnQnKX0pLFxuICAgICAgICAgICAgICAgIGhhc0hvcml6b250YWxIZWFkZXJzID0gYm90dG9tSGVhZGVycy5sZW5ndGggPiAwIHx8IHRvcEhlYWRlcnMgIC5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIGhhc1ZlcnRpY2FsSGVhZGVycyAgID0gbGVmdEhlYWRlcnMgIC5sZW5ndGggPiAwIHx8IHJpZ2h0SGVhZGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIHtpdGVtc30gICAgICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zICAgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIGNvbmZpZztcblxuICAgICAgICAgICAgdG9wSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNWZXJ0aWNhbEhlYWRlcnMgJiYgKGhmICYmIGhhc0hvcml6b250YWxIZWFkZXJzIHx8ICFoZiAmJiBoYXNIb3Jpem9udGFsSGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0SGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICAgICA6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICBmbGV4ICAgICAgICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IG1lLml0ZW1EZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKHsuLi5tZS5oZWFkZXJEZWZhdWx0cywgLi4uY29uZmlnfSk7XG5cbiAgICAgICAgICAgICAgICByaWdodEhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zICAgIDogaG9yaXpvbnRhbEl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQgICA6IHtudHlwZTogKGhmID8gJ2hib3gnIDogJ3Zib3gnKSwgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogJ2JvZHlDb250YWluZXInXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgICAgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZmxleCAgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbURlZmF1bHRzOiBtZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZSAgIDogJ2JvZHlDb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250YWluZXJDb25maWdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKHsuLi5tZS5oZWFkZXJEZWZhdWx0cywgLi4uY29uZmlnfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm90dG9tSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zID0gdmVydGljYWxJdGVtcztcblxuICAgICAgICAgICAgbWUuaXRlbURlZmF1bHRzID0gbnVsbDtcblxuICAgICAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzSGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5oZWFkZXJzKSAmJiB0aGlzLmhlYWRlcnMubGVuZ3RoID4gMFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUGFuZWwpO1xuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzICduZW8tYm9keS12aWV3cG9ydCcgdG8gdGhlIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXBwbHlCb2R5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc3VtaW5nIHRoYXQgYSBWaWV3cG9ydCBpcyB0aGUgdG9wIGxldmVsIHZpZXcgb2YgeW91ciBhcHAsIGFuZCB5b3Ugd2FudCB0byBtb3VudCBpdCByaWdodCBhd2F5LlxuICAgICAgICAgKiBDb3VsZCBiZSB3aXRob3V0IGFueSBpdGVtcy4gVXNlIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXZpZXdwb3J0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXZpZXdwb3J0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgYSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyIGFuZCBmaXJlcyBhIGN1c3RvbSByZXNpemUgZXZlbnRcbiAgICAgICAgICogd2hpY2ggb3RoZXIgaW5zdGFuY2VzIGNhbiBzdWJzY3JpYmUgdG8uXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vbml0b3JTaXplXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vbml0b3JTaXplXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5tb25pdG9yU2l6ZSkge1xuICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFt7cmVzaXplOiBtZS5vbkRvbVJlc2l6ZSwgc2NvcGU6IG1lfV0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQge2FwcE5hbWUsIHdpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5hcHBseUJvZHlDbHMgJiYgTmVvLm1haW4uRG9tQWNjZXNzLmFwcGx5Qm9keUNscyh7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgY2xzOiBbJ25lby1ib2R5LXZpZXdwb3J0J10sXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Eb21SZXNpemUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3Jlc2l6ZScsIGRhdGEpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQge3Jlc29sdmVDYWxsYmFja30gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkJhc2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udHJvbGxlci5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250cm9sbGVyLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb21wb25lbnQtY29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb21wb25lbnQtY29udHJvbGxlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHBhcmVudF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlZmVyZW5jZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZWZlcmVuY2VzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb21wb25lbnR9ID0gbWU7XG5cbiAgICAgICAgbWUucmVmZXJlbmNlcyA9IHt9O1xuXG4gICAgICAgIGlmIChjb21wb25lbnQuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnQub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHBhcmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYXJlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCB0aGlzLmdldFBhcmVudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gW2NvbXBvbmVudF1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fEJvb2xlYW58bnVsbH1cbiAgICAgKi9cbiAgICBnZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudH0gPSBtZSxcbiAgICAgICAgICAgIGhhbmRsZXJDYjtcblxuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciB0aHMgZnVuY3Rpb24gKm5hbWUqIGZpcnN0IGluIHRoZSBDb21wb25lbnQgaXRzZWxmLlxuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBpdCwgcmV0dXJuIHRydWUgc28gY2FsbGluZyBjb2RlIGtub3dzIG5vdCB0byBjb250aW51ZSB0byBzZWFyY2guXG4gICAgICAgICAgICBoYW5kbGVyQ2IgPSByZXNvbHZlQ2FsbGJhY2soaGFuZGxlck5hbWUsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZXIgZm4gaXMgcmVzb2x2ZWQgaW4gdGhlIENvbXBvbmVudCBvciBpdHMgb3duIHBhcmVudCBjaGFpbi5cbiAgICAgICAgICAgIC8vIFJldHVybiBhIHN0YXR1cyBpbmRpY2F0aW5nIHRoYXQgd2UgZG8gbm90IG5lZWQgYW4gZWFybHkgYmluZGluZ1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJDYi5mbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmVvLmlzRnVuY3Rpb24obWVbaGFuZGxlck5hbWVdKSA/XG4gICAgICAgICAgICBtZSA6IHBhcmVudD8uZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IGNvbnRyb2xsZXIgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnR9ID0gbWU7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLmNvbXBvbmVudC5wYXJlbnQ/LmdldENvbnRyb2xsZXIoKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9kbzogdXBkYXRlIGNoYW5nZWQgcmVmZXJlbmNlcyAoZS5nLiBjb250YWluZXIucmVtb3ZlKCkgdGhlbiBjb250YWluZXIuYWRkKCkgdXNpbmcgdGhlIHNhbWUga2V5KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5yZWZlcmVuY2VzW25hbWVdO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5jb21wb25lbnQuZG93bih7cmVmZXJlbmNlOiBuYW1lfSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZWZlcmVuY2VzW25hbWVdID0gY29tcG9uZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50IHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNhbWVMZXZlbE9ubHk9ZmFsc2Ugd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3Qgc3RhdGVQcm92aWRlciBpbnNpZGUgdGhlIGNvbXBvbmVudCBwYXJlbnQgdHJlZSxcbiAgICAgKiBpbiBjYXNlIHRoZXJlIGlzIG5vbmUgb24gdGhlIHNhbWUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2FtZUxldmVsT25seT1mYWxzZV1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZVByb3ZpZGVyKHNhbWVMZXZlbE9ubHk9ZmFsc2UpIHtcbiAgICAgICAgbGV0IHtjb21wb25lbnR9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNhbWVMZXZlbE9ubHkgPyBjb21wb25lbnQuc3RhdGVQcm92aWRlciA6IGNvbXBvbmVudC5nZXRTdGF0ZVByb3ZpZGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgYWNjZXNzaW5nIHN0YXRlLlByb3ZpZGVyIGJhc2VkIGRhdGEuU3RvcmVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKi9cbiAgICBnZXRTdG9yZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKGtleSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbnNpZGUgeW91ciB2aWV3IGNvbnRyb2xsZXJzIGFzIGEgc3RhcnRpbmcgcG9pbnQgaW4gY2FzZSB5b3UgbmVlZCByZWZlcmVuY2VzXG4gICAgICogKGluc3RlYWQgb2YgdXNpbmcgb25Db25zdHJ1Y3RlZCgpIGluc2lkZSB5b3VyIGNvbnRyb2xsZXIpXG4gICAgICovXG4gICAgb25Db21wb25lbnRDb25zdHJ1Y3RlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGdldCBjYWxsZWQgYnkgY29tcG9uZW50LkJhc2U6IGRlc3Ryb3koKSBpbiBjYXNlIHRoZSBjb21wb25lbnQgaGFzIGEgcmVmZXJlbmNlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3JlZmVyZW5jZXN9ID0gbWUsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gcmVmZXJlbmNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlZmVyZW5jZXNba2V5XTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0UGFyZW50KCk/LnJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHNldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuc2V0RGF0YSguLi5hcmdzKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBCYXNlQ29udGFpbmVyIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXNoYm9hcmQuQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGFzaGJvYXJkLkNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhc2hib2FyZC5Db250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZGFzaGJvYXJkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Rhc2hib2FyZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1kYXNoYm9hcmQnLCduZW8tY29udGFpbmVyJ11cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZGFzaGJvYXJkJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc29ydGFibGVfOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL2Rhc2hib2FyZC9Tb3J0Wm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuc29ydFpvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmRyYWcgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVQcm94eVRvUG9wdXAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQgICAgICAgICAgIDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdCb3VuZGFyeUVudHJ5OiBkYXRhID0+IG1lLmZpcmUoJ2RyYWdCb3VuZGFyeUVudHJ5JywgZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnQm91bmRhcnlFeGl0IDogZGF0YSA9PiBtZS5maXJlKCdkcmFnQm91bmRhcnlFeGl0JywgIGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29udGFpbmVyKTtcbiIsImltcG9ydCBCdXR0b24gICAgZnJvbSAnLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMYWJlbCAgICAgZnJvbSAnLi4vY29tcG9uZW50L0xhYmVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRvb2xiYXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgZG9ja1xuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkb2NrUG9zaXRpb25zPVsndG9wJywncmlnaHQnLCdib3R0b20nLCdsZWZ0JywgbnVsbF1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRvY2tQb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsIG51bGxdXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50b29sYmFyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50b29sYmFyLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0b29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRvb2xiYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRvY2tfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkb2NrXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtudHlwZTonYnV0dG9uJ31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOidmbGV4Ym94JyxhbGlnbjonY2VudGVyJyxkaXJlY3Rpb246ICdyb3cnLCBwYWNrOidzdGFydCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICBudHlwZSAgICA6ICdmbGV4Ym94JyxcbiAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzb3J0YWJsZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0YWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS50b29sYmFyLlNvcnRab25lfG51bGx9IHNvcnRab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzb3J0Wm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZUNvbmZpZzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXBwTmFtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXBwTmFtZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFpvbmUuYXBwTmFtZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRvY2sgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiAhb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgZG9ja1Bvc2l0aW9ucyA9IG1lLmdldFN0YXRpY0NvbmZpZygnZG9ja1Bvc2l0aW9ucycpLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnICA9IG1lLmdldExheW91dENvbmZpZygpO1xuXG4gICAgICAgIGRvY2tQb3NpdGlvbnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5ICE9PSBudWxsICYmIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8tZG9jay0nICsga2V5LCBrZXkgPT09IHZhbHVlKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW1lLmxheW91dCkge1xuICAgICAgICAgICAgbGF5b3V0Q29uZmlnLm50eXBlID0gJ2ZsZXhib3gnO1xuICAgICAgICAgICAgbWUuc2V0KHtjbHMsIGxheW91dDogbGF5b3V0Q29uZmlnfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmxheW91dC5zZXQobGF5b3V0Q29uZmlnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLnNvcnRab25lKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4uL2RyYWdnYWJsZS90b29sYmFyL1NvcnRab25lLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICBtZS5zb3J0Wm9uZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCAgICAgICAgICAgOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUuc29ydFpvbmVDb25maWdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFpvbmUud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBuZXcgZG9jayBwb3NpdGlvbiBtYXRjaGVzIGEgdmFsdWUgb2YgdGhlIHN0YXRpYyBkb2NrUG9zaXRpb25zIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERvY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkb2NrJywgJ2RvY2tQb3NpdGlvbnMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlSXRlbXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXlvdXQgY29uZmlnIGRlcGVuZGluZyBvbiB0aGlzLmRvY2tcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBsYXlvdXRDb25maWdcbiAgICAgKi9cbiAgICBnZXRMYXlvdXRDb25maWcoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBsYXlvdXRDb25maWc7XG5cbiAgICAgICAgaWYgKG1lLmRvY2spIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWUuZG9jaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXlvdXRDb25maWcgfHwgbWUubGF5b3V0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5tYXAoaXRlbSA9PiB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBpdGVtXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH1cbiAgICAgKi9cbiAgICByZXBsYWNlU3BhY2VyKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09ICctPicgPyB7bW9kdWxlOiBDb21wb25lbnQsIGZsZXg6IDF9IDogaXRlbVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVG9vbGJhcik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=