export const __webpack_esm_id__ = "vendors-apps_colors_app_mjs";
export const __webpack_esm_ids__ = ["vendors-apps_colors_app_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./apps/colors/app.mjs"
/*!*****************************!*\
  !*** ./apps/colors/app.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/Viewport.mjs */ "./apps/colors/view/Viewport.mjs");


const onStart = () => Neo.app({
    mainView: _view_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Colors'
});


/***/ },

/***/ "./apps/colors/model/Color.mjs"
/*!*************************************!*\
  !*** ./apps/colors/model/Color.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/data/Model.mjs */ "./src/data/Model.mjs");


/**
 * @class Colors.model.Color
 * @extends Neo.data.Model
 */
class Color extends _src_data_Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.model.Color'
         * @protected
         */
        className: 'Colors.model.Color'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let startCharCode = 'A'.charCodeAt(0),
            i             = 0,
            len           = 26, // amount of chars inside the ISO basic latin alphabet
            fields        = [{
                name: 'id',
                type: 'String'
            }];

        for (; i < len; i++) {
            fields.push({
                name: 'column' + String.fromCharCode(startCharCode + i),
                type: 'String'
            })
        }

        this.fields = fields
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ },

/***/ "./apps/colors/store/Colors.mjs"
/*!**************************************!*\
  !*** ./apps/colors/store/Colors.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _model_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/Color.mjs */ "./apps/colors/model/Color.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/data/Store.mjs */ "./src/data/Store.mjs");



/**
 * @class Colors.store.Colors
 * @extends Neo.data.Store
 */
class Colors extends _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.store.Colors'
         * @protected
         */
        className: 'Colors.store.Colors',
        /**
         * @member {Neo.data.Model} model=ColorModel
         * @reactive
         */
        model: _model_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Colors));


/***/ },

/***/ "./apps/colors/view/BarChartComponent.mjs"
/*!************************************************!*\
  !*** ./apps/colors/view/BarChartComponent.mjs ***!
  \************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/component/wrapper/AmChart.mjs */ "./src/component/wrapper/AmChart.mjs");


/**
 * @class Colors.view.BarChartComponent
 * @extends Neo.component.wrapper.AmChart
 */
class BarChartComponent extends _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.BarChartComponent'
         * @protected
         */
        className: 'Colors.view.BarChartComponent',
        /**
         * @member {String[]} baseCls=['colors-bar-chart']
         */
        baseCls: ['colors-bar-chart'],
        /**
         * @member {String} chartType='PieChart'
         */
        chartType: 'XYChart',
        /**
         * @member {Object} chartConfig
         */
        chartConfig: {
            series: [{
                type: 'ColumnSeries',

                columns: {
                    propertyFields: {
                        fill  : 'color',
                        stroke: 'color'
                    }
                },

                dataFields: {
                    categoryX: 'color',
                    valueY   : 'count'
                }
            }],
            xAxes: [{
                type: 'CategoryAxis',

                dataFields: {
                    category: 'color',
                    title: {
                        text: 'Colors'
                    }
                }
            }],
            yAxes: [{
                type: 'ValueAxis',

                title: {
                    text: 'Occurrences in grid cells'
                }
            }]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(BarChartComponent));


/***/ },

/***/ "./apps/colors/view/GridContainer.mjs"
/*!********************************************!*\
  !*** ./apps/colors/view/GridContainer.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_grid_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/grid/Container.mjs */ "./src/grid/Container.mjs");


/**
 * @class Colors.view.GridContainer
 * @extends Neo.grid.Container
 */
class GridContainer extends _src_grid_Container_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.GridContainer'
         * @protected
         */
        className: 'Colors.view.GridContainer',
        /**
         * @member {Number|null} amountColumns_=null
         * @reactive
         */
        amountColumns_: null,
        /**
         * @member {Number|null} amountRows_=null
         * @reactive
         */
        amountRows_: null,
        /**
         * @member {Object} bind
         */
        bind: {
            amountColumns: data => data.amountColumns,
            amountRows   : data => data.amountRows,
            store        : 'stores.colors'
        },
        /**
         * @member {String[]} cls=['colors-grid-container']
         * @reactive
         */
        cls: ['colors-grid-container']
    }

    /**
     * Triggered after the amountColumns config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetAmountColumns(value, oldValue) {
        if (Neo.isNumber(value)) {
            let startCharCode = 'A'.charCodeAt(0),
                i             = 0,
                columns       = [{
                    cellAlign: 'right',
                    dataField: 'id',
                    text     : '#',
                    type     : 'index',
                    width    : 40
                }],
                currentChar;

            for (; i < value; i++) {
                currentChar = String.fromCharCode(startCharCode + i);

                columns.push({
                    dataField: 'column' + currentChar,
                    renderer : 'up.colorRenderer',
                    text     : currentChar
                })
            }

            this.columns = columns
        }
    }

    /**
     * Triggered after the amountRows config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetAmountRows(value, oldValue) {
        this.store?.clear()
    }

    /**
     * @param {Object} data
     * @returns {Object}
     */
    colorRenderer({value}) {
        return {cls: ['color-' + value], text: ' '}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GridContainer));


/***/ },

/***/ "./apps/colors/view/HeaderToolbar.mjs"
/*!********************************************!*\
  !*** ./apps/colors/view/HeaderToolbar.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");





/**
 * @class Colors.view.HeaderToolbar
 * @extends Neo.toolbar.Base
 */
class HeaderToolbar extends _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.HeaderToolbar'
         * @protected
         */
        className: 'Colors.view.HeaderToolbar',
        /**
         * @member {String[]} cls=['colors-header-toolbar']
         * @reactive
         */
        cls: ['colors-header-toolbar'],
        /**
         * @member {Object} layout={ntype:'hbox',align:'stretch',wrap:'wrap'}
         * @reactive
         */
        layout: {ntype: 'hbox', align: 'center', pack: 'start', wrap: 'wrap'},
        /**
         * @member {Object[]} items
         */
        items: [{
            bind   : {disabled: data => data.isUpdating},
            handler: 'onStartButtonClick',
            text   : 'Start'
        }, {
            bind   : {disabled: data => !data.isUpdating},
            handler: 'onStopButtonClick',
            text   : 'Stop'
        }, {
            module       : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            bind         : {value: data => data.amountColors},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Colors',
            listeners    : {change: 'onChangeAmountColors'},
            maxValue     : 10,
            minValue     : 3,
            width        : 90
        }, {
            module       : _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            bind         : {value: data => String(data.amountColumns)},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Columns',
            listeners    : {change: 'onChangeAmountColumns'},
            store        : ['5', '10', '15', '20', '26'],
            width        : 90
        }, {
            module       : _src_form_field_ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            bind         : {value: data => String(data.amountRows)},
            clearable    : false,
            editable     : false,
            labelPosition: 'inline',
            labelText    : '# Rows',
            listeners    : {change: 'onChangeAmountRows'},
            store        : ['5', '10', '15', '20'],
            width        : 90
        }, {
            ntype: 'component',
            cls  : ['header-spacer'],
            flex : 1
        }, {
            handler  : 'onEnableWindowManagementClick',
            iconCls  : 'fa fa-window-restore',
            reference: 'window-management-button',
            text     : 'Enable Window Management'
        }, {
            handler  : 'onDetachGridButtonClick',
            iconCls  : 'fas fa-table',
            reference: 'detach-grid-button',
            text     : 'Grid'
        }, {
            handler  : 'onDetachPieChartButtonClick',
            iconCls  : 'fas fa-chart-pie',
            reference: 'detach-pie-chart-button',
            text     : 'Pie Chart'
        }, {
            handler  : 'onDetachBarChartButtonClick',
            iconCls  : 'fas fa-chart-column',
            reference: 'detach-bar-chart-button',
            text     : 'Bar Chart'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            bind          : {checked: data => data.openWidgetsAsPopups},
            hideLabel     : true,
            listeners     : {change: 'onChangeOpenWidgetsAsPopups'},
            showValueLabel: true,
            valueLabel    : 'Popups'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(HeaderToolbar));


/***/ },

/***/ "./apps/colors/view/PieChartComponent.mjs"
/*!************************************************!*\
  !*** ./apps/colors/view/PieChartComponent.mjs ***!
  \************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/component/wrapper/AmChart.mjs */ "./src/component/wrapper/AmChart.mjs");


/**
 * @class Colors.view.PieChartComponent
 * @extends Neo.component.wrapper.AmChart
 */
class PieChartComponent extends _src_component_wrapper_AmChart_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.PieChartComponent'
         * @protected
         */
        className: 'Colors.view.PieChartComponent',
        /**
         * @member {String[]} baseCls=['colors-pie-chart']
         */
        baseCls: ['colors-pie-chart'],
        /**
         * @member {String} chartType='PieChart'
         */
        chartType: 'PieChart',
        /**
         * @member {Object} _vdom
         */
        /**
         * @member {Object} chartConfig
         */
        chartConfig: {
            series: [{
                type: 'PieSeries',

                colors: {
                    list: [
                        '#1c60a0',
                        '#206db6',
                        '#247acb',
                        '#2e87da',
                        '#4493de',
                        '#59a0e2',
                        '#6face6',
                        '#85b9ea',
                        '#9bc5ed',
                        '#b0d2f1'
                    ]
                },

                dataFields: {
                    category: 'color',
                    value   : 'count'
                }
            }]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(PieChartComponent));


/***/ },

/***/ "./apps/colors/view/Viewport.mjs"
/*!***************************************!*\
  !*** ./apps/colors/view/Viewport.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");
/* harmony import */ var _BarChartComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BarChartComponent.mjs */ "./apps/colors/view/BarChartComponent.mjs");
/* harmony import */ var _src_dashboard_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/dashboard/Container.mjs */ "./src/dashboard/Container.mjs");
/* harmony import */ var _src_dashboard_Panel_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/dashboard/Panel.mjs */ "./src/dashboard/Panel.mjs");
/* harmony import */ var _HeaderToolbar_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HeaderToolbar.mjs */ "./apps/colors/view/HeaderToolbar.mjs");
/* harmony import */ var _PieChartComponent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PieChartComponent.mjs */ "./apps/colors/view/PieChartComponent.mjs");
/* harmony import */ var _GridContainer_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GridContainer.mjs */ "./apps/colors/view/GridContainer.mjs");
/* harmony import */ var _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ViewportController.mjs */ "./apps/colors/view/ViewportController.mjs");
/* harmony import */ var _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ViewportStateProvider.mjs */ "./apps/colors/view/ViewportStateProvider.mjs");










/**
 * @class Colors.view.Viewport
 * @extends Neo.container.Viewport
 */
class Viewport extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.Viewport'
         * @protected
         */
        className: 'Colors.view.Viewport',
        /**
         * @member {String[]} cls=['colors-viewport','neo-dashboard']
         * @reactive
         */
        cls: ['colors-viewport', 'neo-dashboard'],
        /**
         * @member {Neo.controller.Component} controller=ViewportController
         * @reactive
         */
        controller: _ViewportController_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
        /**
         * @member {Object} layout
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _HeaderToolbar_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            flex  : 'none'
        }, {
            module   : _src_dashboard_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            layout   : {ntype: 'vbox', align: 'stretch'},
            popupUrl : 'apps/colors/childapps/widget/index.html',
            reference: 'dashboard',
            sortGroup: 'neo-connected-dashboard',

            items: [{
                module   : _src_dashboard_Panel_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                flex     : 1,
                reference: 'grid-panel',
                headers  : [{
                    dock: 'top',
                    cls : ['neo-draggable'],
                    text: 'Grid'
                }],
                items: [
                    {module: _GridContainer_mjs__WEBPACK_IMPORTED_MODULE_6__["default"], reference: 'grid'}
                ]
            }, {
                module   : _src_dashboard_Panel_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                flex     : 1.3,
                reference: 'pie-chart-panel',
                headers  : [{
                    dock: 'top',
                    cls : ['neo-draggable'],
                    text: 'Pie Chart'
                }],
                items: [
                    {module: _PieChartComponent_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], reference: 'pie-chart'}
                ]
            }, {
                module   : _src_dashboard_Panel_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                flex     : 1.3,
                reference: 'bar-chart-panel',
                headers  : [{
                    dock: 'top',
                    cls : ['neo-draggable'],
                    text: 'Bar Chart'
                }],
                items: [
                    {module: _BarChartComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], reference: 'bar-chart'}
                ]
            }],
        }],
        /**
         * @member {Neo.state.Provider} stateProvider=ViewportStateProvider
         * @reactive
         */
        stateProvider: _ViewportStateProvider_mjs__WEBPACK_IMPORTED_MODULE_8__["default"]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ },

/***/ "./apps/colors/view/ViewportController.mjs"
/*!*************************************************!*\
  !*** ./apps/colors/view/ViewportController.mjs ***!
  \*************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @summary The main controller for the Colors demo application.
 * @description This controller orchestrates the entire Colors application, managing the dashboard widgets (grid, pie chart, bar chart),
 * handling real-time data updates, and demonstrating some of Neo.mjs's most advanced features.
 * It serves as a central hub for state management, cross-window communication, and the seamless drag-to-popup functionality.
 * This class is a key example of how to build a complex, interactive, and multi-window application.
 * @class Colors.view.ViewportController
 * @extends Neo.controller.Component
 * @see Neo.draggable.container.SortZone
 */
class ViewportController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.ViewportController'
         * @protected
         */
        className: 'Colors.view.ViewportController'
    }

    /**
     * @summary The ID for the `setInterval` used for real-time data updates.
     * @member {Number|null} intervalId
     */
    intervalId = null

    /**
     * @summary Factory method to open a widget in a new browser window or popup.
     * @description Determines whether to open a full browser window or a frameless popup based on the
     * `openWidgetsAsPopups` state. It calculates the correct URL and window features.
     * @param {String} name The reference name of the widget to open (e.g., 'grid').
     */
    async createBrowserWindow(name) {
        if (this.getStateProvider().getData('openWidgetsAsPopups')) {
            let dashboard = this.getReference('dashboard'),
                widget    = this.getReference(name),
                rect      = await this.component.getDomRect(widget.vdom.id); // using the vdom id to always get the top-level node

            await dashboard.openWidgetInPopup(widget, rect)
        } else {
            let {config, windowConfigs} = Neo,
                {environment}           = config,
                firstWindowId           = Object.keys(windowConfigs)[0],
                {basePath}              = windowConfigs[firstWindowId],
                url;

            if (environment !== 'development') {
                basePath = `${basePath + environment}/`
            }

            url = `${basePath}apps/colors/childapps/widget/index.html?name=${name}`;

            await Neo.Main.windowOpen({url, windowName: '_blank'})
        }
    }

    /**
     * @summary Cleans up the real-time update interval when the controller is destroyed.
     * @param args
     */
    destroy(...args) {
        this.intervalId && clearInterval(this.intervalId);
        super.destroy(...args)
    }

    /**
     * @summary Handles the change event from the 'Amount of Colors' slider.
     * @param {Object} data The event data.
     */
    onChangeAmountColors(data) {
        this.updateDataProperty(data, 'amountColors',  data.value)
    }

    /**
     * @summary Handles the change event from the 'Amount of Columns' radiofield.
     * @param {Object} data The event data.
     */
    onChangeAmountColumns(data) {
        this.updateDataProperty(data, 'amountColumns',  parseInt(data.value.name))
    }

    /**
     * @summary Handles the change event from the 'Amount of Rows' radiofield.
     * @param {Object} data The event data.
     */
    onChangeAmountRows(data) {
        this.updateDataProperty(data, 'amountRows',  parseInt(data.value.name))
    }

    /**
     * @summary Handles the change event from the 'Open widgets as Popups' checkbox.
     * @param {Object} data The event data.
     */
    onChangeOpenWidgetsAsPopups(data) {
        this.setState('openWidgetsAsPopups', data.value)
    }

    /**
     * @summary Lifecycle method, called after the controller's component is constructed.
     * @description Triggers the initial data load for the widgets.
     */
    onComponentConstructed() {
        super.onComponentConstructed();
        this.updateWidgets()
    }

    /**
     * @summary Handles the click event for the 'Detach Bar Chart' button.
     * @param {Object} data The event data.
     */
    async onDetachBarChartButtonClick(data) {
        await this.createBrowserWindow('bar-chart')
    }

    /**
     * @summary Handles the click event for the 'Detach Grid' button.
     * @param {Object} data The event data.
     */
    async onDetachGridButtonClick(data) {
        await this.createBrowserWindow('grid')
    }

    /**
     * @summary Handles the click event for the 'Detach Pie Chart' button.
     * @param {Object} data The event data.
     */
    async onDetachPieChartButtonClick(data) {
        await this.createBrowserWindow('pie-chart')
    }

    /**
     * @summary Handles the click event to request Window Management permissions.
     * @description The Window Management API is a new browser feature that allows web apps to control
     * the placement of windows, which is essential for the drag-to-popup feature.
     * @param {Object} data The event data.
     */
    async onEnableWindowManagementClick(data) {
        let me       = this,
            response = await Neo.main.addon.DragDrop.requestWindowManagementPermission({windowId: me.windowId}),
            button   = me.getReference('window-management-button');

        if (response.success) {
            button.text = 'W-M enabled';
            button.iconCls = 'fa fa-check-square';
            button.disabled = true;
        } else {
            button.text = 'W-M disabled';
            button.iconCls = 'fa fa-exclamation-triangle';
        }
    }

    /**
     * @summary Starts the real-time data update interval.
     * @param {Object} data The event data.
     */
    onStartButtonClick(data) {
        let me           = this,
            intervalTime = 1000 / 60; // assuming 60 FPS

        me.setState({isUpdating: true});

        if (!me.intervalId) {
            me.intervalId = setInterval(() => {
                me.updateWidgets()
            }, intervalTime)
        }
    }

    /**
     * @summary Stops the real-time data update interval.
     * @param {Object} data The event data.
     */
    onStopButtonClick(data) {
        let me = this;

        me.setState({isUpdating: false});

        if (me.intervalId) {
            clearInterval(me.intervalId);
            me.intervalId = null
        }
    }

    /**
     * @summary Updates the chart components with new data.
     * @param {Object} data The data for the charts.
     */
    updateCharts(data) {
        this.getReference('bar-chart').chartData = data;
        this.getReference('pie-chart').chartData = data
    }

    /**
     * @summary A generic handler to update a property in the state provider.
     * @description Also triggers a manual widget update if real-time updates are not currently running.
     * @param {Object} data The change event data.
     * @param {String} name The name of the property to update in the state provider.
     * @param {Number|Object|null} value The new value for the property.
     */
    updateDataProperty(data, name, value) {
        let stateProvider = this.getStateProvider();

        stateProvider.setData(name, value);

        if (data.oldValue !== null && !stateProvider.getData('isUpdating')) {
            this.updateWidgets()
        }
    }

    /**
     * @summary Updates the data grid component with new records.
     * @description Uses `bulkUpdateRecords` for performance if the store already has data, otherwise sets the initial data.
     * @param {Object[]} records The array of new records for the grid.
     */
    updateGrid(records) {
        let grid    = this.getReference('grid'),
            {store} = grid;

        if (store.getCount()) {
            grid.bulkUpdateRecords(records)
        } else {
            // Depending on the delay of the Socket Connection,
            // the next data package could still contain the old settings
            if (this.getStateProvider().getData('amountRows') === records.length) {
                store.data = records
            }
        }
    }

    /**
     * @summary Fetches new data from the backend service and updates all widgets.
     * @description This is the main data refresh method. It reads the current settings from the state provider,
     * and then uses Neo.mjs's RPC layer to seamlessly call the backend `ColorService.read()` method.
     * This demonstrates remote method access, allowing the App Worker to invoke backend functionality
     * as if it were a local method. After receiving the response, it distributes the new data to the grid and charts.
     */
    async updateWidgets() {
        let me            = this,
            stateProvider = me.getStateProvider(),
            response;

        // Timing issue inside dist/development => the namespace might not be registered yet
        if (!Colors.backend) {
            await me.timeout(50);
            me.updateWidgets()
        } else {
            response = await Colors.backend.ColorService.read({
                amountColors : stateProvider.getData('amountColors'),
                amountColumns: stateProvider.getData('amountColumns'),
                amountRows   : stateProvider.getData('amountRows')
            });

            if (!me.isDestroyed) {
                let {data} = response;

                me.updateGrid(data.tableData);
                me.updateCharts(data.summaryData)
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportController));


/***/ },

/***/ "./apps/colors/view/ViewportStateProvider.mjs"
/*!****************************************************!*\
  !*** ./apps/colors/view/ViewportStateProvider.mjs ***!
  \****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _store_Colors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/Colors.mjs */ "./apps/colors/store/Colors.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/state/Provider.mjs */ "./src/state/Provider.mjs");



/**
 * @class Colors.view.ViewportStateProvider
 * @extends Neo.state.Provider
 */
class ViewportStateProvider extends _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Colors.view.ViewportStateProvider'
         * @protected
         */
        className: 'Colors.view.ViewportStateProvider',
        /**
         * @member {Object} data
         */
        data: {
            /**
             * @member {Number} data.amountColors=10
             */
            amountColors: 10,
            /**
             * @member {Number} data.amountColumns=10
             */
            amountColumns: 10,
            /**
             * @member {Number} data.amountRows=10
             */
            amountRows: 10,
            /**
             * @member {Boolean} data.isUpdating=false
             */
            isUpdating: false,
            /**
             * @member {Boolean} data.openWidgetsAsPopups=true
             */
            openWidgetsAsPopups: true
        },
        /**
         * @member {Object} stores
         */
        stores: {
            colors: {
                module: _store_Colors_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ViewportStateProvider));


/***/ },

/***/ "./src/component/wrapper/AmChart.mjs"
/*!*******************************************!*\
  !*** ./src/component/wrapper/AmChart.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render an amChart
 * Requires setting Neo.config.useAmCharts to true (or manually include the lib)
 * @class Neo.component.wrapper.AmChart
 * @extends Neo.component.Base
 */
class AmChart extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.wrapper.AmChart'
         * @protected
         */
        className: 'Neo.component.wrapper.AmChart',
        /**
         * @member {String} ntype='am-chart'
         * @protected
         */
        ntype: 'am-chart',
        /**
         * See: https://www.amcharts.com/docs/v4/
         * @member {Object} chartConfig_=null
         * @reactive
         */
        chartConfig_: null,
        /**
         * Stores the chart data
         * @member {Array|null} chartData_=null
         * @reactive
         */
        chartData_: null,
        /**
         * @member {String} chartType='XYChart'
         */
        chartType: 'XYChart',
        /**
         * It is not possible to define adapters via json, so we pass a flag to main instead
         * @member {Boolean} combineSeriesTooltip=false
         */
        combineSeriesTooltip: false,
        /**
         * Charts & maps can have different targets to apply the data to. E.g.:
         * myChart.data = data; // => ''
         * myChart.series.values[0].data = data; // => 'series.values.0'
         * Use a Neo.ns() conform syntax with dots between props
         * @member {String} dataPath=''
         */
        dataPath: '',
        /**
         * am4charts, am4maps
         * @member {String} package='am4charts'
         */
        package: 'am4charts',
        style: {
            height: '100%'
        },
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {style: {position: 'relative'}, cn: [
            {style: {position: 'absolute', height: '100%', width: '100%'}, cn: [{}]}
        ]}
    }

    /**
     * Triggered after the chartData config got changed
     * @param {Array|null} value
     * @param {Array|null} oldValue
     * @protected
     */
    afterSetChartData(value, oldValue) {
        let me = this,
            {appName, dataPath, id, windowId} = me;

        if (value) {
            Neo.main.addon.AmCharts.updateData({
                appName,
                data: value,
                dataPath,
                id,
                windowId
            })
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        let me                      = this,
            {appName, id, windowId} = me,
            opts                    = {appName, id, windowId};

        if (value === false && oldValue !== undefined) {
            Neo.main.addon.AmCharts.destroy(opts)
        }

        super.afterSetMounted(value, oldValue);

        if (value) {
            opts = {
                ...opts,
                combineSeriesTooltip: me.combineSeriesTooltip,
                config              : me.chartConfig,
                package             : me.package,
                type                : me.chartType
            };

            if (me.chartData) {
                opts.data     = me.chartData;
                opts.dataPath = me.dataPath;
            }

            me.timeout(50).then(() => {
                Neo.main.addon.AmCharts.create(opts).then(me.onChartMounted)
            })
        }
    }

    /**
     * Triggered before the chartConfig config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetChartConfig(value, oldValue) {
        if (!value) {
            console.error('wrapper.AmChart defined without a chartConfig', this.id)
        }

        this.parseItemConfigs(value);
        return value
    }

    destroy(...args) {
        let {appName, id, windowId} = this;

        Neo.main.addon.AmCharts.destroy({appName, id, windowId})

        super.destroy(...args)
    }

    /**
     *
     */
    getVdomRoot() {
        return this.vdom.cn[0].cn[0]
    }

    /**
     *
     */
    getVnodeRoot() {
        return this.vnode.childNodes[0].childNodes[0]
    }

    /**
     * Override this method to trigger logic after the chart got mounted into the dom
     */
    onChartMounted() {

    }

    /**
     * Serializes the AmChart into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            chartConfig         : me.serializeConfig(me.chartConfig),
            chartData           : me.serializeConfig(me.chartData),
            chartType           : me.chartType,
            combineSeriesTooltip: me.combineSeriesTooltip,
            dataPath            : me.dataPath,
            package             : me.package
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AmChart));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfY29sb3JzX2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDOztBQUVwQztBQUNQLGNBQWMsMERBQVE7QUFDdEI7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDTCtDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBSztBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUscUJBQXFCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeENPO0FBQ1M7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFLO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLGVBQWUsd0RBQVU7QUFDekI7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCb0M7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBFQUFnQjtBQUNoRDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtB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QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxTQUFTLFFBQVEscUJBQXFCO0FBQ3RDLGFBQWEsUUFBUSxvREFBb0QsU0FBUztBQUNsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCOztBQUVwQyx5Q0FBeUMsc0JBQXNCOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy9hcHAubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy9tb2RlbC9Db2xvci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL3N0b3JlL0NvbG9ycy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL3ZpZXcvQmFyQ2hhcnRDb21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy92aWV3L0dyaWRDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy92aWV3L0hlYWRlclRvb2xiYXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL2NvbG9ycy92aWV3L1BpZUNoYXJ0Q29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvdmlldy9WaWV3cG9ydC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2FwcHMvY29sb3JzL3ZpZXcvVmlld3BvcnRDb250cm9sbGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vYXBwcy9jb2xvcnMvdmlldy9WaWV3cG9ydFN0YXRlUHJvdmlkZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L3dyYXBwZXIvQW1DaGFydC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vdmlldy9WaWV3cG9ydC5tanMnO1xuXG5leHBvcnQgY29uc3Qgb25TdGFydCA9ICgpID0+IE5lby5hcHAoe1xuICAgIG1haW5WaWV3OiBWaWV3cG9ydCxcbiAgICBuYW1lICAgIDogJ0NvbG9ycydcbn0pO1xuIiwiaW1wb3J0IE1vZGVsIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL01vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIENvbG9ycy5tb2RlbC5Db2xvclxuICogQGV4dGVuZHMgTmVvLmRhdGEuTW9kZWxcbiAqL1xuY2xhc3MgQ29sb3IgZXh0ZW5kcyBNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdDb2xvcnMubW9kZWwuQ29sb3InXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy5tb2RlbC5Db2xvcidcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgc3RhcnRDaGFyQ29kZSA9ICdBJy5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgID0gMjYsIC8vIGFtb3VudCBvZiBjaGFycyBpbnNpZGUgdGhlIElTTyBiYXNpYyBsYXRpbiBhbHBoYWJldFxuICAgICAgICAgICAgZmllbGRzICAgICAgICA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2lkJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjb2x1bW4nICsgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydENoYXJDb2RlICsgaSksXG4gICAgICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkc1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29sb3IpO1xuIiwiaW1wb3J0IENvbG9yTW9kZWwgZnJvbSAnLi4vbW9kZWwvQ29sb3IubWpzJztcbmltcG9ydCBTdG9yZSAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9kYXRhL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIENvbG9ycy5zdG9yZS5Db2xvcnNcbiAqIEBleHRlbmRzIE5lby5kYXRhLlN0b3JlXG4gKi9cbmNsYXNzIENvbG9ycyBleHRlbmRzIFN0b3JlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0NvbG9ycy5zdG9yZS5Db2xvcnMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy5zdG9yZS5Db2xvcnMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsPUNvbG9yTW9kZWxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDogQ29sb3JNb2RlbFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29sb3JzKTtcbiIsImltcG9ydCBBbUNoYXJ0Q29tcG9uZW50IGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvd3JhcHBlci9BbUNoYXJ0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIENvbG9ycy52aWV3LkJhckNoYXJ0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LndyYXBwZXIuQW1DaGFydFxuICovXG5jbGFzcyBCYXJDaGFydENvbXBvbmVudCBleHRlbmRzIEFtQ2hhcnRDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnZpZXcuQmFyQ2hhcnRDb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LkJhckNoYXJ0Q29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnY29sb3JzLWJhci1jaGFydCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ2NvbG9ycy1iYXItY2hhcnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2hhcnRUeXBlPSdQaWVDaGFydCdcbiAgICAgICAgICovXG4gICAgICAgIGNoYXJ0VHlwZTogJ1hZQ2hhcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjaGFydENvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnRDb25maWc6IHtcbiAgICAgICAgICAgIHNlcmllczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ29sdW1uU2VyaWVzJyxcblxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwgIDogJ2NvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ2NvbG9yJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlYOiAnY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVkgICA6ICdjb3VudCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHhBeGVzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDYXRlZ29yeUF4aXMnLFxuXG4gICAgICAgICAgICAgICAgZGF0YUZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ2NvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdDb2xvcnMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdWYWx1ZUF4aXMnLFxuXG4gICAgICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ09jY3VycmVuY2VzIGluIGdyaWQgY2VsbHMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFyQ2hhcnRDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJhc2VHcmlkQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uL3NyYy9ncmlkL0NvbnRhaW5lci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMudmlldy5HcmlkQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZ3JpZC5Db250YWluZXJcbiAqL1xuY2xhc3MgR3JpZENvbnRhaW5lciBleHRlbmRzIEJhc2VHcmlkQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0NvbG9ycy52aWV3LkdyaWRDb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LkdyaWRDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGFtb3VudENvbHVtbnNfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhbW91bnRDb2x1bW5zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBhbW91bnRSb3dzXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYW1vdW50Um93c186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGJpbmRcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IHtcbiAgICAgICAgICAgIGFtb3VudENvbHVtbnM6IGRhdGEgPT4gZGF0YS5hbW91bnRDb2x1bW5zLFxuICAgICAgICAgICAgYW1vdW50Um93cyAgIDogZGF0YSA9PiBkYXRhLmFtb3VudFJvd3MsXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgOiAnc3RvcmVzLmNvbG9ycydcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydjb2xvcnMtZ3JpZC1jb250YWluZXInXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNsczogWydjb2xvcnMtZ3JpZC1jb250YWluZXInXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYW1vdW50Q29sdW1ucyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QW1vdW50Q29sdW1ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdGFydENoYXJDb2RlID0gJ0EnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgY29sdW1ucyAgICAgICA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxBbGlnbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YUZpZWxkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgICA6ICcjJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAgICAgOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgICA6IDQwXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgY3VycmVudENoYXI7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgdmFsdWU7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydENoYXJDb2RlICsgaSk7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkYXRhRmllbGQ6ICdjb2x1bW4nICsgY3VycmVudENoYXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyIDogJ3VwLmNvbG9yUmVuZGVyZXInLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICAgICA6IGN1cnJlbnRDaGFyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1uc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhbW91bnRSb3dzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBbW91bnRSb3dzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnN0b3JlPy5jbGVhcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNvbG9yUmVuZGVyZXIoe3ZhbHVlfSkge1xuICAgICAgICByZXR1cm4ge2NsczogWydjb2xvci0nICsgdmFsdWVdLCB0ZXh0OiAnICd9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhHcmlkQ29udGFpbmVyKTtcbiIsImltcG9ydCBDaGVja0JveCAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9DaGVja0JveC5tanMnO1xuaW1wb3J0IENvbWJvQm94ICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NvbWJvQm94Lm1qcyc7XG5pbXBvcnQgTnVtYmVyRmllbGQgZnJvbSAnLi4vLi4vLi4vc3JjL2Zvcm0vZmllbGQvTnVtYmVyLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMudmlldy5IZWFkZXJUb29sYmFyXG4gKiBAZXh0ZW5kcyBOZW8udG9vbGJhci5CYXNlXG4gKi9cbmNsYXNzIEhlYWRlclRvb2xiYXIgZXh0ZW5kcyBUb29sYmFyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0NvbG9ycy52aWV3LkhlYWRlclRvb2xiYXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LkhlYWRlclRvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ2NvbG9ycy1oZWFkZXItdG9vbGJhciddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ2NvbG9ycy1oZWFkZXItdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOidoYm94JyxhbGlnbjonc3RyZXRjaCcsd3JhcDond3JhcCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICdoYm94JywgYWxpZ246ICdjZW50ZXInLCBwYWNrOiAnc3RhcnQnLCB3cmFwOiAnd3JhcCd9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIGJpbmQgICA6IHtkaXNhYmxlZDogZGF0YSA9PiBkYXRhLmlzVXBkYXRpbmd9LFxuICAgICAgICAgICAgaGFuZGxlcjogJ29uU3RhcnRCdXR0b25DbGljaycsXG4gICAgICAgICAgICB0ZXh0ICAgOiAnU3RhcnQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGJpbmQgICA6IHtkaXNhYmxlZDogZGF0YSA9PiAhZGF0YS5pc1VwZGF0aW5nfSxcbiAgICAgICAgICAgIGhhbmRsZXI6ICdvblN0b3BCdXR0b25DbGljaycsXG4gICAgICAgICAgICB0ZXh0ICAgOiAnU3RvcCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgIDogTnVtYmVyRmllbGQsXG4gICAgICAgICAgICBiaW5kICAgICAgICAgOiB7dmFsdWU6IGRhdGEgPT4gZGF0YS5hbW91bnRDb2xvcnN9LFxuICAgICAgICAgICAgY2xlYXJhYmxlICAgIDogZmFsc2UsXG4gICAgICAgICAgICBlZGl0YWJsZSAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb246ICdpbmxpbmUnLFxuICAgICAgICAgICAgbGFiZWxUZXh0ICAgIDogJyMgQ29sb3JzJyxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICA6IHtjaGFuZ2U6ICdvbkNoYW5nZUFtb3VudENvbG9ycyd9LFxuICAgICAgICAgICAgbWF4VmFsdWUgICAgIDogMTAsXG4gICAgICAgICAgICBtaW5WYWx1ZSAgICAgOiAzLFxuICAgICAgICAgICAgd2lkdGggICAgICAgIDogOTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgIDogQ29tYm9Cb3gsXG4gICAgICAgICAgICBiaW5kICAgICAgICAgOiB7dmFsdWU6IGRhdGEgPT4gU3RyaW5nKGRhdGEuYW1vdW50Q29sdW1ucyl9LFxuICAgICAgICAgICAgY2xlYXJhYmxlICAgIDogZmFsc2UsXG4gICAgICAgICAgICBlZGl0YWJsZSAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb246ICdpbmxpbmUnLFxuICAgICAgICAgICAgbGFiZWxUZXh0ICAgIDogJyMgQ29sdW1ucycsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgOiB7Y2hhbmdlOiAnb25DaGFuZ2VBbW91bnRDb2x1bW5zJ30sXG4gICAgICAgICAgICBzdG9yZSAgICAgICAgOiBbJzUnLCAnMTAnLCAnMTUnLCAnMjAnLCAnMjYnXSxcbiAgICAgICAgICAgIHdpZHRoICAgICAgICA6IDkwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IENvbWJvQm94LFxuICAgICAgICAgICAgYmluZCAgICAgICAgIDoge3ZhbHVlOiBkYXRhID0+IFN0cmluZyhkYXRhLmFtb3VudFJvd3MpfSxcbiAgICAgICAgICAgIGNsZWFyYWJsZSAgICA6IGZhbHNlLFxuICAgICAgICAgICAgZWRpdGFibGUgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiAnaW5saW5lJyxcbiAgICAgICAgICAgIGxhYmVsVGV4dCAgICA6ICcjIFJvd3MnLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgIDoge2NoYW5nZTogJ29uQ2hhbmdlQW1vdW50Um93cyd9LFxuICAgICAgICAgICAgc3RvcmUgICAgICAgIDogWyc1JywgJzEwJywgJzE1JywgJzIwJ10sXG4gICAgICAgICAgICB3aWR0aCAgICAgICAgOiA5MFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgICAgICBjbHMgIDogWydoZWFkZXItc3BhY2VyJ10sXG4gICAgICAgICAgICBmbGV4IDogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBoYW5kbGVyICA6ICdvbkVuYWJsZVdpbmRvd01hbmFnZW1lbnRDbGljaycsXG4gICAgICAgICAgICBpY29uQ2xzICA6ICdmYSBmYS13aW5kb3ctcmVzdG9yZScsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICd3aW5kb3ctbWFuYWdlbWVudC1idXR0b24nLFxuICAgICAgICAgICAgdGV4dCAgICAgOiAnRW5hYmxlIFdpbmRvdyBNYW5hZ2VtZW50J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBoYW5kbGVyICA6ICdvbkRldGFjaEdyaWRCdXR0b25DbGljaycsXG4gICAgICAgICAgICBpY29uQ2xzICA6ICdmYXMgZmEtdGFibGUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnZGV0YWNoLWdyaWQtYnV0dG9uJyxcbiAgICAgICAgICAgIHRleHQgICAgIDogJ0dyaWQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGhhbmRsZXIgIDogJ29uRGV0YWNoUGllQ2hhcnRCdXR0b25DbGljaycsXG4gICAgICAgICAgICBpY29uQ2xzICA6ICdmYXMgZmEtY2hhcnQtcGllJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogJ2RldGFjaC1waWUtY2hhcnQtYnV0dG9uJyxcbiAgICAgICAgICAgIHRleHQgICAgIDogJ1BpZSBDaGFydCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaGFuZGxlciAgOiAnb25EZXRhY2hCYXJDaGFydEJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgIGljb25DbHMgIDogJ2ZhcyBmYS1jaGFydC1jb2x1bW4nLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnZGV0YWNoLWJhci1jaGFydC1idXR0b24nLFxuICAgICAgICAgICAgdGV4dCAgICAgOiAnQmFyIENoYXJ0J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogQ2hlY2tCb3gsXG4gICAgICAgICAgICBiaW5kICAgICAgICAgIDoge2NoZWNrZWQ6IGRhdGEgPT4gZGF0YS5vcGVuV2lkZ2V0c0FzUG9wdXBzfSxcbiAgICAgICAgICAgIGhpZGVMYWJlbCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbGlzdGVuZXJzICAgICA6IHtjaGFuZ2U6ICdvbkNoYW5nZU9wZW5XaWRnZXRzQXNQb3B1cHMnfSxcbiAgICAgICAgICAgIHNob3dWYWx1ZUxhYmVsOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWVMYWJlbCAgICA6ICdQb3B1cHMnXG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhIZWFkZXJUb29sYmFyKTtcbiIsImltcG9ydCBBbUNoYXJ0Q29tcG9uZW50IGZyb20gJy4uLy4uLy4uL3NyYy9jb21wb25lbnQvd3JhcHBlci9BbUNoYXJ0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIENvbG9ycy52aWV3LlBpZUNoYXJ0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LndyYXBwZXIuQW1DaGFydFxuICovXG5jbGFzcyBQaWVDaGFydENvbXBvbmVudCBleHRlbmRzIEFtQ2hhcnRDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnZpZXcuUGllQ2hhcnRDb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LlBpZUNoYXJ0Q29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnY29sb3JzLXBpZS1jaGFydCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ2NvbG9ycy1waWUtY2hhcnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2hhcnRUeXBlPSdQaWVDaGFydCdcbiAgICAgICAgICovXG4gICAgICAgIGNoYXJ0VHlwZTogJ1BpZUNoYXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNoYXJ0Q29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydENvbmZpZzoge1xuICAgICAgICAgICAgc2VyaWVzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdQaWVTZXJpZXMnLFxuXG4gICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3Q6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICcjMWM2MGEwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjMjA2ZGI2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjMjQ3YWNiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjMmU4N2RhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjNDQ5M2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjNTlhMGUyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjNmZhY2U2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjODViOWVhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjOWJjNWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcjYjBkMmYxJ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdjb2xvcicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgOiAnY291bnQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUGllQ2hhcnRDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJhc2VWaWV3cG9ydCAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyc7XG5pbXBvcnQgQmFyQ2hhcnRDb21wb25lbnQgICAgIGZyb20gJy4vQmFyQ2hhcnRDb21wb25lbnQubWpzJztcbmltcG9ydCBEYXNoYm9hcmQgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2Rhc2hib2FyZC9Db250YWluZXIubWpzJztcbmltcG9ydCBEYXNoYm9hcmRQYW5lbCAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2Rhc2hib2FyZC9QYW5lbC5tanMnO1xuaW1wb3J0IEhlYWRlclRvb2xiYXIgICAgICAgICBmcm9tICcuL0hlYWRlclRvb2xiYXIubWpzJztcbmltcG9ydCBQaWVDaGFydENvbXBvbmVudCAgICAgZnJvbSAnLi9QaWVDaGFydENvbXBvbmVudC5tanMnO1xuaW1wb3J0IEdyaWRDb250YWluZXIgICAgICAgICBmcm9tICcuL0dyaWRDb250YWluZXIubWpzJztcbmltcG9ydCBWaWV3cG9ydENvbnRyb2xsZXIgICAgZnJvbSAnLi9WaWV3cG9ydENvbnRyb2xsZXIubWpzJztcbmltcG9ydCBWaWV3cG9ydFN0YXRlUHJvdmlkZXIgZnJvbSAnLi9WaWV3cG9ydFN0YXRlUHJvdmlkZXIubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgQ29sb3JzLnZpZXcuVmlld3BvcnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqL1xuY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBCYXNlVmlld3BvcnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnZpZXcuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ0NvbG9ycy52aWV3LlZpZXdwb3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9Wydjb2xvcnMtdmlld3BvcnQnLCduZW8tZGFzaGJvYXJkJ11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjbHM6IFsnY29sb3JzLXZpZXdwb3J0JywgJ25lby1kYXNoYm9hcmQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudH0gY29udHJvbGxlcj1WaWV3cG9ydENvbnRyb2xsZXJcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sbGVyOiBWaWV3cG9ydENvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dFxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBIZWFkZXJUb29sYmFyLFxuICAgICAgICAgICAgZmxleCAgOiAnbm9uZSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBEYXNoYm9hcmQsXG4gICAgICAgICAgICBsYXlvdXQgICA6IHtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgIHBvcHVwVXJsIDogJ2FwcHMvY29sb3JzL2NoaWxkYXBwcy93aWRnZXQvaW5kZXguaHRtbCcsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdkYXNoYm9hcmQnLFxuICAgICAgICAgICAgc29ydEdyb3VwOiAnbmVvLWNvbm5lY3RlZC1kYXNoYm9hcmQnLFxuXG4gICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICBtb2R1bGUgICA6IERhc2hib2FyZFBhbmVsLFxuICAgICAgICAgICAgICAgIGZsZXggICAgIDogMSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6ICdncmlkLXBhbmVsJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzICA6IFt7XG4gICAgICAgICAgICAgICAgICAgIGRvY2s6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1kcmFnZ2FibGUnXSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0dyaWQnXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge21vZHVsZTogR3JpZENvbnRhaW5lciwgcmVmZXJlbmNlOiAnZ3JpZCd9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogRGFzaGJvYXJkUGFuZWwsXG4gICAgICAgICAgICAgICAgZmxleCAgICAgOiAxLjMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiAncGllLWNoYXJ0LXBhbmVsJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzICA6IFt7XG4gICAgICAgICAgICAgICAgICAgIGRvY2s6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1kcmFnZ2FibGUnXSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1BpZSBDaGFydCdcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICAgICAgICB7bW9kdWxlOiBQaWVDaGFydENvbXBvbmVudCwgcmVmZXJlbmNlOiAncGllLWNoYXJ0J31cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgOiBEYXNoYm9hcmRQYW5lbCxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICA6IDEuMyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6ICdiYXItY2hhcnQtcGFuZWwnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMgIDogW3tcbiAgICAgICAgICAgICAgICAgICAgZG9jazogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIGNscyA6IFsnbmVvLWRyYWdnYWJsZSddLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnQmFyIENoYXJ0J1xuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHttb2R1bGU6IEJhckNoYXJ0Q29tcG9uZW50LCByZWZlcmVuY2U6ICdiYXItY2hhcnQnfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICB9XSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5zdGF0ZS5Qcm92aWRlcn0gc3RhdGVQcm92aWRlcj1WaWV3cG9ydFN0YXRlUHJvdmlkZXJcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0ZVByb3ZpZGVyOiBWaWV3cG9ydFN0YXRlUHJvdmlkZXJcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXdwb3J0KTtcbiIsImltcG9ydCBDb250cm9sbGVyIGZyb20gJy4uLy4uLy4uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFRoZSBtYWluIGNvbnRyb2xsZXIgZm9yIHRoZSBDb2xvcnMgZGVtbyBhcHBsaWNhdGlvbi5cbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGNvbnRyb2xsZXIgb3JjaGVzdHJhdGVzIHRoZSBlbnRpcmUgQ29sb3JzIGFwcGxpY2F0aW9uLCBtYW5hZ2luZyB0aGUgZGFzaGJvYXJkIHdpZGdldHMgKGdyaWQsIHBpZSBjaGFydCwgYmFyIGNoYXJ0KSxcbiAqIGhhbmRsaW5nIHJlYWwtdGltZSBkYXRhIHVwZGF0ZXMsIGFuZCBkZW1vbnN0cmF0aW5nIHNvbWUgb2YgTmVvLm1qcydzIG1vc3QgYWR2YW5jZWQgZmVhdHVyZXMuXG4gKiBJdCBzZXJ2ZXMgYXMgYSBjZW50cmFsIGh1YiBmb3Igc3RhdGUgbWFuYWdlbWVudCwgY3Jvc3Mtd2luZG93IGNvbW11bmljYXRpb24sIGFuZCB0aGUgc2VhbWxlc3MgZHJhZy10by1wb3B1cCBmdW5jdGlvbmFsaXR5LlxuICogVGhpcyBjbGFzcyBpcyBhIGtleSBleGFtcGxlIG9mIGhvdyB0byBidWlsZCBhIGNvbXBsZXgsIGludGVyYWN0aXZlLCBhbmQgbXVsdGktd2luZG93IGFwcGxpY2F0aW9uLlxuICogQGNsYXNzIENvbG9ycy52aWV3LlZpZXdwb3J0Q29udHJvbGxlclxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKiBAc2VlIE5lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lXG4gKi9cbmNsYXNzIFZpZXdwb3J0Q29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nQ29sb3JzLnZpZXcuVmlld3BvcnRDb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdDb2xvcnMudmlldy5WaWV3cG9ydENvbnRyb2xsZXInXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVGhlIElEIGZvciB0aGUgYHNldEludGVydmFsYCB1c2VkIGZvciByZWFsLXRpbWUgZGF0YSB1cGRhdGVzLlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpbnRlcnZhbElkXG4gICAgICovXG4gICAgaW50ZXJ2YWxJZCA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZhY3RvcnkgbWV0aG9kIHRvIG9wZW4gYSB3aWRnZXQgaW4gYSBuZXcgYnJvd3NlciB3aW5kb3cgb3IgcG9wdXAuXG4gICAgICogQGRlc2NyaXB0aW9uIERldGVybWluZXMgd2hldGhlciB0byBvcGVuIGEgZnVsbCBicm93c2VyIHdpbmRvdyBvciBhIGZyYW1lbGVzcyBwb3B1cCBiYXNlZCBvbiB0aGVcbiAgICAgKiBgb3BlbldpZGdldHNBc1BvcHVwc2Agc3RhdGUuIEl0IGNhbGN1bGF0ZXMgdGhlIGNvcnJlY3QgVVJMIGFuZCB3aW5kb3cgZmVhdHVyZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIHJlZmVyZW5jZSBuYW1lIG9mIHRoZSB3aWRnZXQgdG8gb3BlbiAoZS5nLiwgJ2dyaWQnKS5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCcm93c2VyV2luZG93KG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoJ29wZW5XaWRnZXRzQXNQb3B1cHMnKSkge1xuICAgICAgICAgICAgbGV0IGRhc2hib2FyZCA9IHRoaXMuZ2V0UmVmZXJlbmNlKCdkYXNoYm9hcmQnKSxcbiAgICAgICAgICAgICAgICB3aWRnZXQgICAgPSB0aGlzLmdldFJlZmVyZW5jZShuYW1lKSxcbiAgICAgICAgICAgICAgICByZWN0ICAgICAgPSBhd2FpdCB0aGlzLmNvbXBvbmVudC5nZXREb21SZWN0KHdpZGdldC52ZG9tLmlkKTsgLy8gdXNpbmcgdGhlIHZkb20gaWQgdG8gYWx3YXlzIGdldCB0aGUgdG9wLWxldmVsIG5vZGVcblxuICAgICAgICAgICAgYXdhaXQgZGFzaGJvYXJkLm9wZW5XaWRnZXRJblBvcHVwKHdpZGdldCwgcmVjdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCB7Y29uZmlnLCB3aW5kb3dDb25maWdzfSA9IE5lbyxcbiAgICAgICAgICAgICAgICB7ZW52aXJvbm1lbnR9ICAgICAgICAgICA9IGNvbmZpZyxcbiAgICAgICAgICAgICAgICBmaXJzdFdpbmRvd0lkICAgICAgICAgICA9IE9iamVjdC5rZXlzKHdpbmRvd0NvbmZpZ3MpWzBdLFxuICAgICAgICAgICAgICAgIHtiYXNlUGF0aH0gICAgICAgICAgICAgID0gd2luZG93Q29uZmlnc1tmaXJzdFdpbmRvd0lkXSxcbiAgICAgICAgICAgICAgICB1cmw7XG5cbiAgICAgICAgICAgIGlmIChlbnZpcm9ubWVudCAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgIGJhc2VQYXRoID0gYCR7YmFzZVBhdGggKyBlbnZpcm9ubWVudH0vYFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cmwgPSBgJHtiYXNlUGF0aH1hcHBzL2NvbG9ycy9jaGlsZGFwcHMvd2lkZ2V0L2luZGV4Lmh0bWw/bmFtZT0ke25hbWV9YDtcblxuICAgICAgICAgICAgYXdhaXQgTmVvLk1haW4ud2luZG93T3Blbih7dXJsLCB3aW5kb3dOYW1lOiAnX2JsYW5rJ30pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDbGVhbnMgdXAgdGhlIHJlYWwtdGltZSB1cGRhdGUgaW50ZXJ2YWwgd2hlbiB0aGUgY29udHJvbGxlciBpcyBkZXN0cm95ZWQuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbElkICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgdGhlIGNoYW5nZSBldmVudCBmcm9tIHRoZSAnQW1vdW50IG9mIENvbG9ycycgc2xpZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlQW1vdW50Q29sb3JzKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhUHJvcGVydHkoZGF0YSwgJ2Ftb3VudENvbG9ycycsICBkYXRhLnZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgdGhlIGNoYW5nZSBldmVudCBmcm9tIHRoZSAnQW1vdW50IG9mIENvbHVtbnMnIHJhZGlvZmllbGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgb25DaGFuZ2VBbW91bnRDb2x1bW5zKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhUHJvcGVydHkoZGF0YSwgJ2Ftb3VudENvbHVtbnMnLCAgcGFyc2VJbnQoZGF0YS52YWx1ZS5uYW1lKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRoZSBjaGFuZ2UgZXZlbnQgZnJvbSB0aGUgJ0Ftb3VudCBvZiBSb3dzJyByYWRpb2ZpZWxkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlQW1vdW50Um93cyhkYXRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVByb3BlcnR5KGRhdGEsICdhbW91bnRSb3dzJywgIHBhcnNlSW50KGRhdGEudmFsdWUubmFtZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0aGUgY2hhbmdlIGV2ZW50IGZyb20gdGhlICdPcGVuIHdpZGdldHMgYXMgUG9wdXBzJyBjaGVja2JveC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBvbkNoYW5nZU9wZW5XaWRnZXRzQXNQb3B1cHMoZGF0YSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCdvcGVuV2lkZ2V0c0FzUG9wdXBzJywgZGF0YS52YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMaWZlY3ljbGUgbWV0aG9kLCBjYWxsZWQgYWZ0ZXIgdGhlIGNvbnRyb2xsZXIncyBjb21wb25lbnQgaXMgY29uc3RydWN0ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIFRyaWdnZXJzIHRoZSBpbml0aWFsIGRhdGEgbG9hZCBmb3IgdGhlIHdpZGdldHMuXG4gICAgICovXG4gICAgb25Db21wb25lbnRDb25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVdpZGdldHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZXMgdGhlIGNsaWNrIGV2ZW50IGZvciB0aGUgJ0RldGFjaCBCYXIgQ2hhcnQnIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRldGFjaEJhckNoYXJ0QnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZUJyb3dzZXJXaW5kb3coJ2Jhci1jaGFydCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0aGUgY2xpY2sgZXZlbnQgZm9yIHRoZSAnRGV0YWNoIEdyaWQnIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRldGFjaEdyaWRCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlQnJvd3NlcldpbmRvdygnZ3JpZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlcyB0aGUgY2xpY2sgZXZlbnQgZm9yIHRoZSAnRGV0YWNoIFBpZSBDaGFydCcgYnV0dG9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIG9uRGV0YWNoUGllQ2hhcnRCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlQnJvd3NlcldpbmRvdygncGllLWNoYXJ0JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBIYW5kbGVzIHRoZSBjbGljayBldmVudCB0byByZXF1ZXN0IFdpbmRvdyBNYW5hZ2VtZW50IHBlcm1pc3Npb25zLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgV2luZG93IE1hbmFnZW1lbnQgQVBJIGlzIGEgbmV3IGJyb3dzZXIgZmVhdHVyZSB0aGF0IGFsbG93cyB3ZWIgYXBwcyB0byBjb250cm9sXG4gICAgICogdGhlIHBsYWNlbWVudCBvZiB3aW5kb3dzLCB3aGljaCBpcyBlc3NlbnRpYWwgZm9yIHRoZSBkcmFnLXRvLXBvcHVwIGZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgb25FbmFibGVXaW5kb3dNYW5hZ2VtZW50Q2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5yZXF1ZXN0V2luZG93TWFuYWdlbWVudFBlcm1pc3Npb24oe3dpbmRvd0lkOiBtZS53aW5kb3dJZH0pLFxuICAgICAgICAgICAgYnV0dG9uICAgPSBtZS5nZXRSZWZlcmVuY2UoJ3dpbmRvdy1tYW5hZ2VtZW50LWJ1dHRvbicpO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBidXR0b24udGV4dCA9ICdXLU0gZW5hYmxlZCc7XG4gICAgICAgICAgICBidXR0b24uaWNvbkNscyA9ICdmYSBmYS1jaGVjay1zcXVhcmUnO1xuICAgICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0ID0gJ1ctTSBkaXNhYmxlZCc7XG4gICAgICAgICAgICBidXR0b24uaWNvbkNscyA9ICdmYSBmYS1leGNsYW1hdGlvbi10cmlhbmdsZSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdGFydHMgdGhlIHJlYWwtdGltZSBkYXRhIHVwZGF0ZSBpbnRlcnZhbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBvblN0YXJ0QnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGludGVydmFsVGltZSA9IDEwMDAgLyA2MDsgLy8gYXNzdW1pbmcgNjAgRlBTXG5cbiAgICAgICAgbWUuc2V0U3RhdGUoe2lzVXBkYXRpbmc6IHRydWV9KTtcblxuICAgICAgICBpZiAoIW1lLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIG1lLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlV2lkZ2V0cygpXG4gICAgICAgICAgICB9LCBpbnRlcnZhbFRpbWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdG9wcyB0aGUgcmVhbC10aW1lIGRhdGEgdXBkYXRlIGludGVydmFsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIG9uU3RvcEJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5zZXRTdGF0ZSh7aXNVcGRhdGluZzogZmFsc2V9KTtcblxuICAgICAgICBpZiAobWUuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChtZS5pbnRlcnZhbElkKTtcbiAgICAgICAgICAgIG1lLmludGVydmFsSWQgPSBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBVcGRhdGVzIHRoZSBjaGFydCBjb21wb25lbnRzIHdpdGggbmV3IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSBjaGFydHMuXG4gICAgICovXG4gICAgdXBkYXRlQ2hhcnRzKGRhdGEpIHtcbiAgICAgICAgdGhpcy5nZXRSZWZlcmVuY2UoJ2Jhci1jaGFydCcpLmNoYXJ0RGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZ2V0UmVmZXJlbmNlKCdwaWUtY2hhcnQnKS5jaGFydERhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQSBnZW5lcmljIGhhbmRsZXIgdG8gdXBkYXRlIGEgcHJvcGVydHkgaW4gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAqIEBkZXNjcmlwdGlvbiBBbHNvIHRyaWdnZXJzIGEgbWFudWFsIHdpZGdldCB1cGRhdGUgaWYgcmVhbC10aW1lIHVwZGF0ZXMgYXJlIG5vdCBjdXJyZW50bHkgcnVubmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgY2hhbmdlIGV2ZW50IGRhdGEuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZSBpbiB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fG51bGx9IHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB1cGRhdGVEYXRhUHJvcGVydHkoZGF0YSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHN0YXRlUHJvdmlkZXIgPSB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKTtcblxuICAgICAgICBzdGF0ZVByb3ZpZGVyLnNldERhdGEobmFtZSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChkYXRhLm9sZFZhbHVlICE9PSBudWxsICYmICFzdGF0ZVByb3ZpZGVyLmdldERhdGEoJ2lzVXBkYXRpbmcnKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVXaWRnZXRzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFVwZGF0ZXMgdGhlIGRhdGEgZ3JpZCBjb21wb25lbnQgd2l0aCBuZXcgcmVjb3Jkcy5cbiAgICAgKiBAZGVzY3JpcHRpb24gVXNlcyBgYnVsa1VwZGF0ZVJlY29yZHNgIGZvciBwZXJmb3JtYW5jZSBpZiB0aGUgc3RvcmUgYWxyZWFkeSBoYXMgZGF0YSwgb3RoZXJ3aXNlIHNldHMgdGhlIGluaXRpYWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSByZWNvcmRzIFRoZSBhcnJheSBvZiBuZXcgcmVjb3JkcyBmb3IgdGhlIGdyaWQuXG4gICAgICovXG4gICAgdXBkYXRlR3JpZChyZWNvcmRzKSB7XG4gICAgICAgIGxldCBncmlkICAgID0gdGhpcy5nZXRSZWZlcmVuY2UoJ2dyaWQnKSxcbiAgICAgICAgICAgIHtzdG9yZX0gPSBncmlkO1xuXG4gICAgICAgIGlmIChzdG9yZS5nZXRDb3VudCgpKSB7XG4gICAgICAgICAgICBncmlkLmJ1bGtVcGRhdGVSZWNvcmRzKHJlY29yZHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIGRlbGF5IG9mIHRoZSBTb2NrZXQgQ29ubmVjdGlvbixcbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IGRhdGEgcGFja2FnZSBjb3VsZCBzdGlsbCBjb250YWluIHRoZSBvbGQgc2V0dGluZ3NcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXREYXRhKCdhbW91bnRSb3dzJykgPT09IHJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZGF0YSA9IHJlY29yZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZldGNoZXMgbmV3IGRhdGEgZnJvbSB0aGUgYmFja2VuZCBzZXJ2aWNlIGFuZCB1cGRhdGVzIGFsbCB3aWRnZXRzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIHRoZSBtYWluIGRhdGEgcmVmcmVzaCBtZXRob2QuIEl0IHJlYWRzIHRoZSBjdXJyZW50IHNldHRpbmdzIGZyb20gdGhlIHN0YXRlIHByb3ZpZGVyLFxuICAgICAqIGFuZCB0aGVuIHVzZXMgTmVvLm1qcydzIFJQQyBsYXllciB0byBzZWFtbGVzc2x5IGNhbGwgdGhlIGJhY2tlbmQgYENvbG9yU2VydmljZS5yZWFkKClgIG1ldGhvZC5cbiAgICAgKiBUaGlzIGRlbW9uc3RyYXRlcyByZW1vdGUgbWV0aG9kIGFjY2VzcywgYWxsb3dpbmcgdGhlIEFwcCBXb3JrZXIgdG8gaW52b2tlIGJhY2tlbmQgZnVuY3Rpb25hbGl0eVxuICAgICAqIGFzIGlmIGl0IHdlcmUgYSBsb2NhbCBtZXRob2QuIEFmdGVyIHJlY2VpdmluZyB0aGUgcmVzcG9uc2UsIGl0IGRpc3RyaWJ1dGVzIHRoZSBuZXcgZGF0YSB0byB0aGUgZ3JpZCBhbmQgY2hhcnRzLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVdpZGdldHMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlUHJvdmlkZXIgPSBtZS5nZXRTdGF0ZVByb3ZpZGVyKCksXG4gICAgICAgICAgICByZXNwb25zZTtcblxuICAgICAgICAvLyBUaW1pbmcgaXNzdWUgaW5zaWRlIGRpc3QvZGV2ZWxvcG1lbnQgPT4gdGhlIG5hbWVzcGFjZSBtaWdodCBub3QgYmUgcmVnaXN0ZXJlZCB5ZXRcbiAgICAgICAgaWYgKCFDb2xvcnMuYmFja2VuZCkge1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1MCk7XG4gICAgICAgICAgICBtZS51cGRhdGVXaWRnZXRzKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgQ29sb3JzLmJhY2tlbmQuQ29sb3JTZXJ2aWNlLnJlYWQoe1xuICAgICAgICAgICAgICAgIGFtb3VudENvbG9ycyA6IHN0YXRlUHJvdmlkZXIuZ2V0RGF0YSgnYW1vdW50Q29sb3JzJyksXG4gICAgICAgICAgICAgICAgYW1vdW50Q29sdW1uczogc3RhdGVQcm92aWRlci5nZXREYXRhKCdhbW91bnRDb2x1bW5zJyksXG4gICAgICAgICAgICAgICAgYW1vdW50Um93cyAgIDogc3RhdGVQcm92aWRlci5nZXREYXRhKCdhbW91bnRSb3dzJylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHtkYXRhfSA9IHJlc3BvbnNlO1xuXG4gICAgICAgICAgICAgICAgbWUudXBkYXRlR3JpZChkYXRhLnRhYmxlRGF0YSk7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlQ2hhcnRzKGRhdGEuc3VtbWFyeURhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXdwb3J0Q29udHJvbGxlcik7XG4iLCJpbXBvcnQgQ29sb3JzU3RvcmUgICBmcm9tICcuLi9zdG9yZS9Db2xvcnMubWpzJztcbmltcG9ydCBTdGF0ZVByb3ZpZGVyIGZyb20gJy4uLy4uLy4uL3NyYy9zdGF0ZS9Qcm92aWRlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvcnMudmlldy5WaWV3cG9ydFN0YXRlUHJvdmlkZXJcbiAqIEBleHRlbmRzIE5lby5zdGF0ZS5Qcm92aWRlclxuICovXG5jbGFzcyBWaWV3cG9ydFN0YXRlUHJvdmlkZXIgZXh0ZW5kcyBTdGF0ZVByb3ZpZGVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J0NvbG9ycy52aWV3LlZpZXdwb3J0U3RhdGVQcm92aWRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnQ29sb3JzLnZpZXcuVmlld3BvcnRTdGF0ZVByb3ZpZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGRhdGEuYW1vdW50Q29sb3JzPTEwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFtb3VudENvbG9yczogMTAsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZGF0YS5hbW91bnRDb2x1bW5zPTEwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFtb3VudENvbHVtbnM6IDEwLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGRhdGEuYW1vdW50Um93cz0xMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhbW91bnRSb3dzOiAxMCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGF0YS5pc1VwZGF0aW5nPWZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlzVXBkYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkYXRhLm9wZW5XaWRnZXRzQXNQb3B1cHM9dHJ1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvcGVuV2lkZ2V0c0FzUG9wdXBzOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0b3Jlc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVzOiB7XG4gICAgICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6IENvbG9yc1N0b3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXdwb3J0U3RhdGVQcm92aWRlcik7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL0Jhc2UubWpzJztcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjbGFzcyB0byByZW5kZXIgYW4gYW1DaGFydFxuICogUmVxdWlyZXMgc2V0dGluZyBOZW8uY29uZmlnLnVzZUFtQ2hhcnRzIHRvIHRydWUgKG9yIG1hbnVhbGx5IGluY2x1ZGUgdGhlIGxpYilcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LndyYXBwZXIuQW1DaGFydFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEFtQ2hhcnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC53cmFwcGVyLkFtQ2hhcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQud3JhcHBlci5BbUNoYXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2FtLWNoYXJ0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2FtLWNoYXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZTogaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjQvXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY2hhcnRDb25maWdfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjaGFydENvbmZpZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGNoYXJ0IGRhdGFcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gY2hhcnREYXRhXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnREYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2hhcnRUeXBlPSdYWUNoYXJ0J1xuICAgICAgICAgKi9cbiAgICAgICAgY2hhcnRUeXBlOiAnWFlDaGFydCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdCBpcyBub3QgcG9zc2libGUgdG8gZGVmaW5lIGFkYXB0ZXJzIHZpYSBqc29uLCBzbyB3ZSBwYXNzIGEgZmxhZyB0byBtYWluIGluc3RlYWRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY29tYmluZVNlcmllc1Rvb2x0aXA9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGNvbWJpbmVTZXJpZXNUb29sdGlwOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYXJ0cyAmIG1hcHMgY2FuIGhhdmUgZGlmZmVyZW50IHRhcmdldHMgdG8gYXBwbHkgdGhlIGRhdGEgdG8uIEUuZy46XG4gICAgICAgICAqIG15Q2hhcnQuZGF0YSA9IGRhdGE7IC8vID0+ICcnXG4gICAgICAgICAqIG15Q2hhcnQuc2VyaWVzLnZhbHVlc1swXS5kYXRhID0gZGF0YTsgLy8gPT4gJ3Nlcmllcy52YWx1ZXMuMCdcbiAgICAgICAgICogVXNlIGEgTmVvLm5zKCkgY29uZm9ybSBzeW50YXggd2l0aCBkb3RzIGJldHdlZW4gcHJvcHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkYXRhUGF0aD0nJ1xuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVBhdGg6ICcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogYW00Y2hhcnRzLCBhbTRtYXBzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcGFja2FnZT0nYW00Y2hhcnRzJ1xuICAgICAgICAgKi9cbiAgICAgICAgcGFja2FnZTogJ2FtNGNoYXJ0cycsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtzdHlsZToge3Bvc2l0aW9uOiAncmVsYXRpdmUnfSwgY246IFtcbiAgICAgICAgICAgIHtzdHlsZToge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBoZWlnaHQ6ICcxMDAlJywgd2lkdGg6ICcxMDAlJ30sIGNuOiBbe31dfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2hhcnREYXRhIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q2hhcnREYXRhKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIGRhdGFQYXRoLCBpZCwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5BbUNoYXJ0cy51cGRhdGVEYXRhKHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGFQYXRoLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICBvcHRzICAgICAgICAgICAgICAgICAgICA9IHthcHBOYW1lLCBpZCwgd2luZG93SWR9O1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgJiYgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uQW1DaGFydHMuZGVzdHJveShvcHRzKVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICAgICAgY29tYmluZVNlcmllc1Rvb2x0aXA6IG1lLmNvbWJpbmVTZXJpZXNUb29sdGlwLFxuICAgICAgICAgICAgICAgIGNvbmZpZyAgICAgICAgICAgICAgOiBtZS5jaGFydENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYWNrYWdlICAgICAgICAgICAgIDogbWUucGFja2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlICAgICAgICAgICAgICAgIDogbWUuY2hhcnRUeXBlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobWUuY2hhcnREYXRhKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5kYXRhICAgICA9IG1lLmNoYXJ0RGF0YTtcbiAgICAgICAgICAgICAgICBvcHRzLmRhdGFQYXRoID0gbWUuZGF0YVBhdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkFtQ2hhcnRzLmNyZWF0ZShvcHRzKS50aGVuKG1lLm9uQ2hhcnRNb3VudGVkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGNoYXJ0Q29uZmlnIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2hhcnRDb25maWcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dyYXBwZXIuQW1DaGFydCBkZWZpbmVkIHdpdGhvdXQgYSBjaGFydENvbmZpZycsIHRoaXMuaWQpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcnNlSXRlbUNvbmZpZ3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICBOZW8ubWFpbi5hZGRvbi5BbUNoYXJ0cy5kZXN0cm95KHthcHBOYW1lLCBpZCwgd2luZG93SWR9KVxuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tLmNuWzBdLmNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHRyaWdnZXIgbG9naWMgYWZ0ZXIgdGhlIGNoYXJ0IGdvdCBtb3VudGVkIGludG8gdGhlIGRvbVxuICAgICAqL1xuICAgIG9uQ2hhcnRNb3VudGVkKCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgQW1DaGFydCBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBjaGFydENvbmZpZyAgICAgICAgIDogbWUuc2VyaWFsaXplQ29uZmlnKG1lLmNoYXJ0Q29uZmlnKSxcbiAgICAgICAgICAgIGNoYXJ0RGF0YSAgICAgICAgICAgOiBtZS5zZXJpYWxpemVDb25maWcobWUuY2hhcnREYXRhKSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZSAgICAgICAgICAgOiBtZS5jaGFydFR5cGUsXG4gICAgICAgICAgICBjb21iaW5lU2VyaWVzVG9vbHRpcDogbWUuY29tYmluZVNlcmllc1Rvb2x0aXAsXG4gICAgICAgICAgICBkYXRhUGF0aCAgICAgICAgICAgIDogbWUuZGF0YVBhdGgsXG4gICAgICAgICAgICBwYWNrYWdlICAgICAgICAgICAgIDogbWUucGFja2FnZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBbUNoYXJ0KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==