"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_treeAccordion_app_mjs"],{

/***/ "./examples/treeAccordion/MainContainer.mjs":
/*!**************************************************!*\
  !*** ./examples/treeAccordion/MainContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_tree_Accordion_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/tree/Accordion.mjs */ "./src/tree/Accordion.mjs");
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/container/Panel.mjs */ "./src/container/Panel.mjs");
/* harmony import */ var _src_state_Provider_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/state/Provider.mjs */ "./src/state/Provider.mjs");
/* harmony import */ var _src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../src/data/Store.mjs */ "./src/data/Store.mjs");
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../src/controller/Component.mjs */ "./src/controller/Component.mjs");









/**
 * @class Neo.examples.treeAccordion.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        className           : 'Neo.examples.treeAccordion.MainContainer',
        autoMount           : true,
        configItemLabelWidth: 100,
        configItemWidth     : 230,
        layout              : {ntype: 'hbox', align: 'stretch'},
        cls                 : ['examples-container-accordion']
    }

    createConfigurationComponents() {
        let me       = this,
            treeList = me.exampleComponent.items[0];

        return [{
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            checked       : treeList.rootParentsAreCollapsible,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'rootParentsAreCollapsible')},
            valueLabelText: 'rootParentsAreCollapsible'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            checked       : treeList.firstParentIsVisible,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'firstParentIsVisible')},
            style         : {marginTop: '10px'},
            valueLabelText: 'firstParentIsVisible'
        }, {
            module        : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            checked       : treeList.showIcon,
            hideLabel     : true,
            hideValueLabel: false,
            listeners     : {change: me.onConfigChange.bind(me, 'showIcon')},
            style         : {marginTop: '10px'},
            valueLabelText: 'showIcon'
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable: true,
            labelText: 'height',
            listeners: {change: me.onConfigChange.bind(me, 'height')},
            maxValue : 1200,
            minValue : 250,
            stepSize : 50,
            value    : 650,
            style    : {marginTop: '10px'}
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable: true,
            labelText: 'width',
            listeners: {change: me.onConfigChange.bind(me, 'width')},
            maxValue : 1200,
            minValue : 200,
            stepSize : 3,
            style    : {marginTop: '10px'},
            value    : 400
        }, {
            ntype  : 'button',
            handler: me.onRemoveDomButtonClick.bind(me),
            style  : {marginTop: '20px'},
            text   : 'Remove DOM',
            width  : 100
        }]
    }

    /**
     * @returns {*}
     */
    createExampleComponent() {
        const me    = this,
              store = Neo.create(_src_data_Store_mjs__WEBPACK_IMPORTED_MODULE_6__["default"], {
                  keyProperty: 'id',
                  model      : {
                      fields: [
                          {name: 'collapsed', type: 'Boolean'},
                          {name: 'content', type: 'String'},
                          {name: 'iconCls', type: 'String'},
                          {name: 'id', type: 'Integer'},
                          {name: 'isLeaf', type: 'Boolean'},
                          {name: 'name', type: 'String'},
                          {name: 'parentId', type: 'Integer'}
                      ]
                  },

                  autoLoad: true,
                  url     : '../../examples/treeAccordion/tree.json'
              });

        return Neo.ntype({
            ntype: 'container',

            stateProvider: {
                data: {
                    selection: [{name: 'Please select something'}]
                }
            },

            layout: {ntype: 'hbox', align: 'stretch'},
            items : [{
                module: _src_tree_Accordion_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],

                bind: {selection: {key: 'selection', twoWay: true}},

                store: store,

                /*
                 * We are using data-binding.
                 * Here is an example for listener and controller
                 */
                // controller: {
                //     module: ViewController,
                //
                //     onAccordionItemClick(record) {
                //         let viewport = Neo.get('neo-configuration-viewport-1'),
                //             outputEl = viewport.getReference('output');
                //
                //         outputEl.html = record.name;
                //     }
                // },
                //
                // listeners: {
                //     leafItemClick: 'onAccordionItemClick'
                // }

                listeners: {
                    selectPreFirstItem: () => Neo.log('listener selectPreFirstItem fired'),
                    selectPostLastItem: () => Neo.log('listener selectPostLastItem fired')
                }
            }, {
                module: _src_container_Panel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                height: 150,
                flex : 1,

                itemDefaults: {
                    style: {
                        padding: '10px'
                    }
                },

                headers: [{
                    dock : 'top',
                    style: {borderRightColor: 'transparent'},

                    items: [{
                        ntype: 'label',
                        text : 'Accordion Selection'
                    }]
                }],

                items: [{
                    ntype    : 'component',
                    reference: 'output',
                    bind     : {html: data => data.selection[0].name}
                }]
            }]
        })
    }

    /**
     * @param {String} config
     * @param {Object} opts
     */
    onConfigChange(config, opts) {
        this.exampleComponent.items[0][config] = opts.value
    }

    /**
     *
     * @param {Object} data
     */
    onRemoveDomButtonClick(data) {
        let accordion = this.exampleComponent.items[0];
        accordion.hidden = !accordion.hidden
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./examples/treeAccordion/app.mjs":
/*!****************************************!*\
  !*** ./examples/treeAccordion/app.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/treeAccordion/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.treeAccordion'
});


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/selection/TreeAccordionModel.mjs":
/*!**********************************************!*\
  !*** ./src/selection/TreeAccordionModel.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _TreeModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeModel.mjs */ "./src/selection/TreeModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.selection.TreeAccordionModel
 * @extends Neo.selection.TreeModel
 */
class TreeAccordionModel extends _TreeModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.TreeAccordionModel'
         * @protected
         */
        className: 'Neo.selection.TreeAccordionModel',
        /**
         * @member {String} ntype='selection-treeaccordionmodel'
         * @protected
         */
        ntype: 'selection-treeaccordionmodel'
    }

    /**
     * Tries to find a child and returns it
     * @param {Object} record
     * @returns {Object|null}
     */
    checkForChild(record) {
        let {view}      = this,
            recordId    = record[view.getKeyProperty()],
            childRecord = null;

        for (let i = 0; i < view.store.count; i++) {
            const item = view.store.getAt(i);

            if (item.parentId === recordId) {
                childRecord = item;
                break
            }
        }

        return childRecord
    }

    /**
     * Return the parent record if any
     * @param {Object} record
     * @returns {Object|null}
     */
    checkForParent({parentId}) {
        return parentId ? this.view.store.get(parentId) : null
    }

    /**
     * Depending on {-1|1} step return
     * -1: previous record OR parent record
     *  1: next record or null
     *
     * @param {Object} record
     * @param {Number} step
     * @returns {Object|null}
     */
    checkForSibling(record, step) {
        let {view}         = this,
            {store}        = view,
            parentRecordId = record.parentId,
            recordId       = record[view.getKeyProperty()],
            hasFoundNext   = false,
            nextItemRecord = null,
            previousItemRecord;

        for (let i = 0; i < store.count; i++) {
            const item = store.getAt(i);

            if (hasFoundNext && item.parentId === parentRecordId) {
                nextItemRecord = item;
                break
            }

            if (!hasFoundNext && item.parentId === parentRecordId) {
                if (!hasFoundNext && item[view.getKeyProperty()] === recordId) {
                    if (step === -1) break;
                    hasFoundNext = true
                } else {
                    previousItemRecord = item
                }
            }
        }

        return step === 1 ? nextItemRecord : (previousItemRecord || store.get(parentRecordId))
    }

    /**
     * Find the next sibling of a parent item
     * @param {Object} record
     * @returns {Object|null}
     */
    checkNextParentSibling(record) {
        let me            = this,
            parent        = me.view.store.get(record.parentId),
            parentSibling = me.checkForSibling(parent, 1);

        if (!parentSibling && parent.parentId) {
            me.checkNextParentSibling(parent)
        }

        return parentSibling
    }

    /**
     * Called by keys (List.mjs:register)
     * Toggle collapse or if isLeaf select next item
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        let me     = this,
            {view} = me,
            itemId = me.getSelection()[0],
            record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || record.collapsed) {
            me.onKeyDownRight(data)
        } else {
            me.onKeyDownLeft(data)
        }
    }

    /**
     * Called by keys (List.mjs:register)
     * Deselect all and fire event selectPostLastItem
     * @param {Object} data
     */
    onKeyDownEscape(data) {
        this.deselectAll()
    }

    /**
     * Collapse folder or select previous
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        let me     = this,
            {view} = me,
            itemId = me.getSelection()[0],
            record;

        if (!itemId) {
            me.selectRoot();
            return
        }

        record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || record.collapsed || !view.rootParentsAreCollapsible) {
            me.onNavKey(data, -1)
        } else {
            me.toggleCollapsed(record, itemId, true)
        }
    }

    /**
     * Open folder or select next
     * @param {Object} data
     */
    onKeyDownRight(data) {
        let me     = this,
            {view} = me,
            itemId = me.getSelection()[0],
            record;

        if (!itemId) {
            me.selectRoot();
            return
        }

        record = view.store.get(view.getItemRecordId(itemId));

        if (record.isLeaf || !record.collapsed) {
            me.onNavKey(data, 1)
        } else {
            me.toggleCollapsed(record, itemId, false)
        }
    }

    /**
     * Handles 'up' and 'down' keys
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        let me     = this,
            {view} = me,
            item   = me.getSelection()[0],
            newRecord, record, recordId;

        if (item) {
            recordId = view.getItemRecordId(item);
            record   = view.store.get(recordId);

            if (step === 1) {
                if (!record.isLeaf && !record.collapsed) {
                    // find first child
                    newRecord = me.checkForChild(record)
                } else {
                    // find next sibling
                    newRecord = me.checkForSibling(record, step);
                    // no ==> loop through parent next siblings until no parent
                    if (!newRecord) {
                        newRecord = me.checkNextParentSibling(record)
                    }
                }
                // current item was the last item
                if (!newRecord) {
                    me.deselectAll();
                    view.fire('selectPostLastItem')
                }
            } else if (step === -1) {
                // check previous sibling
                newRecord = me.checkForSibling(record, step);
                // no ==> get parent
                if (!newRecord) {
                    newRecord = me.checkForParent(record)
                }
                // current item was the first item
                if (!newRecord) {
                    me.deselectAll();
                    view.fire('selectPreFirstItem')
                }
            }
        } else {
            me.selectRoot()
        }

        if (newRecord) {
            const itemId = view.getItemId(newRecord[me.view.getKeyProperty()]);

            me.selectAndScrollIntoView(itemId)
        }
    }

    /**
     * Select an item and scroll the tree to show the item in the center
     * @param {String} itemId
     */
    selectAndScrollIntoView(itemId) {
        this.select(itemId);

        Neo.main.DomAccess.scrollIntoView({
            id      : itemId,
            block   : 'center',
            windowId: this.view.windowId
        })
    }

    /**
     * Select the root item of the tree
     */
    selectRoot() {
        let {view}  = this,
            {store} = view,
            record, rootItemId;

        for (let i = 0; i < store.count; i++) {
            const record = store.getAt(i);

            if (!record.parentId) {
                rootItemId = view.getItemId(record[view.getKeyProperty()]);
                break
            }
        }

        this.selectAndScrollIntoView(rootItemId)
    }

    /**
     * Return the parent record if any
     * @param {Object} record
     * @param {String} itemId
     * @param {Boolean} collapse
     */
    toggleCollapsed(record, itemId, collapse) {
        let item  = this.view.getVdomChild(itemId),
            clsFn = collapse ? 'remove' : 'add';

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"][clsFn](item.cls, 'neo-folder-open');
        this.view.update();

        record.collapsed = collapse
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeAccordionModel));


/***/ }),

/***/ "./src/tree/Accordion.mjs":
/*!********************************!*\
  !*** ./src/tree/Accordion.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _tree_List_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/List.mjs */ "./src/tree/List.mjs");
/* harmony import */ var _selection_TreeAccordionModel_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../selection/TreeAccordionModel.mjs */ "./src/selection/TreeAccordionModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.tree.Accordion
 * @extends Neo.tree.List
 *
 * Accordion Store expects the following fields
 *
 *      [
 *          iconCls,        // can be defined in fields:icon
 *          content,        // can be defined in fields:text
 *          name,           // can be defined in fields:header
 *
 *          collapsed,      // collapsed state for non-leaf-items
 *          isLeaf,         // defines it item is leaf-item
 *          id,             // defines item id
 *          parentId        // leaf or sub-items need a parentId
 *      ]
 *
 */
class AccordionTree extends _tree_List_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tree.Accordion'
         * @protected
         */
        className: 'Neo.tree.Accordion',
        /**
         * @member {String} ntype='treeaccordion'
         * @protected
         */
        ntype: 'treeaccordion',
        /**
         * @member {String[]} baseCls=['neo-tree-accordion']
         */
        baseCls: ['neo-tree-list'],
        /**
         * Define the field names for the store to show header, text and icon
         * @member {Object} fields={header:'name',icon:'iconCls',text:'content'}
         */
        fields: {
            header: 'name',
            icon  : 'iconCls',
            text  : 'content'
        },
        /**
         * Set to false to hide the initial root item
         * @member {Boolean} firstParentIsVisible=true
         */
        firstParentIsVisible_: true,
        /**
         * Set to false will auto expand root parent items and disallow collapsing
         * @member {Boolean} rootParentIsCollapsible=false
         */
        rootParentsAreCollapsible_: false,
        /**
         * Currently selected item, which is bindable
         * @member {Record[]|null} selection=null
         *
         * @example
         *     module: AccordionTree,
         *     bind  : {selection: {key: 'selection', twoWay: true}}
         *
         *     ntype: 'component',
         *     bind : {html: data => data.selection[0].name}
         */
        selection_: null,
        /**
         * Set to false will hide the icons for all leaf items
         * @member {Boolean} showIcon=true
         */
        showIcon_: true,
        /**
         * @member {Boolean} showCollapseExpandAllIcons=true
         */
        showCollapseExpandAllIcons: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'ul', cls: ['neo-list-container', 'neo-list', 'neo-accordion-style'], cn: []}
        ]}
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.addDomListeners({
            focusin: me.onFocus,
            scope  : me
        })
    }

    /**
     * Called when changing firstParentIsVisible
     * First store item gets marked and additional css class
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetFirstParentIsVisible(value, oldValue) {
        let firstRecord = this.store.first();

        this.toggleCls('first-parent-not-visible', !value);

        if (firstRecord) {
            firstRecord.visible = value
        }
    }

    /**
     * Called when changing rootParentsAreCollapsible
     * Ensures that root items are expanded if not collapsible
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetRootParentsAreCollapsible(value, oldValue) {
        let me = this;

        me[!value ? 'addCls' : 'removeCls']('root-not-collapsible');

        if (me.vnodeInitialized && value === false) {
            let {store} = me;

            store.forEach(record => {
                if (record.parentId === null && !record.isLeaf) {
                    me.expandItem(record)
                }
            })
        }
    }

    /**
     * Called when changing showIcon
     * Changes the display of the icons
     *
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    afterSetShowIcon(value, oldValue) {
        const me      = this,
              {store} = me,
              hide    = !value;

        store.forEach(record => {
            const itemId   = me.getItemId(record[me.getKeyProperty()]),
                  vdom     = me.getVdomChild(itemId),
                  itemVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(vdom, 'iconCls');

            if (record.isLeaf) {
                itemVdom.removeDom = hide
            }
        })

        me.update()
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_TreeAccordionModel_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])
    }

    /**
     * Remove all items from the accordion
     * If you do not need to update the view after clearing, set `withUpdate = false`
     *
     * @param {Boolean} [withUpdate=true]
     */
    clear(withUpdate=true) {
        delete this.getVdomRoot().cn[0].cn

        withUpdate && this.update()
    }

    /**
     * Remove all items from the selection
     */
    clearSelection() {
        this.selectionModel.deselectAll();
    }

    /**
     * @param {String} [parentId] The parent node
     * @param {Object} [vdomRoot] The vdom template root for the current sub tree
     * @param {Number} level The hierarchy level of the tree
     * @returns {Object} vdomRoot
     * @protected
     */
    createItems(parentId, vdomRoot, level) {
        let me                   = this,
            {folderCls, itemCls} = me,
            items                = me.store.find('parentId', parentId),
            cls, id, itemIconCls, tmpRoot;

        if (items.length > 0) {
            if (!vdomRoot.cn) {
                vdomRoot.cn = []
            }

            if (parentId !== null) {
                vdomRoot.cn.push({
                    tag: 'ul',
                    cls: ['neo-list'],
                    cn : [],
                    id : `${me.id}__${parentId}__ul`
                });

                tmpRoot = vdomRoot.cn[vdomRoot.cn.length - 1]
            } else {
                tmpRoot = vdomRoot
            }

            items.forEach(item => {
                cls         = [itemCls];
                itemIconCls = ['neo-accordion-item-icon'];

                if (item.iconCls) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(itemIconCls, item.iconCls.split(' '))
                }

                if (item.isLeaf) {
                    cls.push(itemCls + (item.singleton ? '-leaf-singleton' : '-leaf'))
                } else {
                    cls.push(folderCls);

                    if (!item.parentId && !me.rootParentsAreCollapsible) {
                        cls.push('neo-not-collapsible');

                        if (item.collapsed) {
                            item.collapsed = false
                        }
                    }

                    if (!item.collapsed) {
                        cls.push('neo-folder-open')
                    }
                }

                id = me.getItemId(item.id);

                tmpRoot.cn.push({
                    tag     : 'li',
                    tabIndex: -1,
                    cls,
                    id,
                    cn      : [{
                        flag     : 'iconCls',
                        tag      : 'span',
                        cls      : itemIconCls,
                        id       : id + '__icon',
                        removeDom: (!item.isLeaf || !me.showIcon)
                    }, {
                        cls  : [itemCls + '-content'],
                        id   : id + '__item-content',
                        style: {pointerEvents: 'none'},
                        cn: [{
                            flag: 'name',
                            tag : 'span',
                            cls : [itemCls + '-content-header'],
                            id  : id + '__item-content-header',
                            text: item[me.fields.header]
                        }, {
                            flag: 'content',
                            tag : 'span',
                            cls : [itemCls + '-content-text'],
                            id  : id + '__item-content-text',
                            text: item[me.fields.text]
                        }]
                    }],
                    style: {
                        position: item.isLeaf ? null : 'sticky',
                        top     : item.isLeaf ? null : (level * 38) + 'px',
                        zIndex  : item.isLeaf ? null : (20 / (level + 1)),
                    }
                });

                tmpRoot = me.createItems(item.id, tmpRoot, level + 1)
            })
        }

        return vdomRoot
    }


    /**
     * Expands an item based on the record
     * @param {Object} record
     */
    expandItem(record) {
        let me     = this,
            itemId = me.getItemId(record[me.getKeyProperty()]),
            item   = me.getVdomChild(itemId);

        record.collapsed = false;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(item.cls, 'neo-folder-open');
        me.update()
    }

    /**
     * @param {Object} item
     * @param {Object} data
     */
    onItemClick(item, data) {
        super.onItemClick(item, data);

        let me               = this,
            {selectionModel} = me,
            itemId           = item.id,
            id               = Number(itemId.split('__')[1]),
            record           = me.store.get(id);

        selectionModel.select(item.id);

        if (!record.isLeaf) {
            /**
             * The folderItemClick event fires when a click occurs on a list item which does have child items.
             * Passes the item record to the event handler.
             * @event folderItemClick
             * @returns {Object} record
             */
            me.fire('folderItemClick', {record});

            record.collapsed = !record.collapsed
        }
    }

    /**
     * To place the root item at the correct location
     * @returns {Object}
     */
    getListItemsRoot() {
        return this.vdom.cn[0]
    }

    /**
     * Accordion gaining focus without selection => setSelection
     * @param {Object} data
     */
    onFocus(data) {
        let me               = this,
            {selectionModel} = me,
            selection        = selectionModel.getSelection()[0];

        !selection && selectionModel.selectRoot()
    }

    /**
     * Called from SelectionModel select()
     * @param {String[]} value
     */
    onSelect(value) {
        let me      = this,
            records = [];

        value.forEach((selectItemId) => {
            let id     = me.getItemRecordId(selectItemId),
                record = me.store.get(id);

            records.push(record)
        });

        me.selection = records
    }

    /**
     * After the store loaded, create the items for the list
     * @param {Record[]} records
     */
    onStoreLoad(records) {
        let me = this;

        me.clear(false);

        if (!me.mounted && me.isVnodeInitializing) {
            me.on('mounted', () => {
                me.createItems(null, me.getListItemsRoot(), 0);
                me.update()
            }, me, {once: true})
        } else {
            me.createItems(null, me.getListItemsRoot(), 0);
            me.update()
        }
    }

    /**
     * Update a record
     * @param {Object}         data
     * @param {Object[]}       data.fields
     * @param {Number}         data.index
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     */
    onStoreRecordChange(data) {
        let me               = this,
            {fields, record} = data,
            itemId           = me.getItemId(record[me.getKeyProperty()]),
            vdom             = me.getVdomChild(itemId),
            itemVdom;

        fields.forEach((field) => {
            itemVdom = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(vdom, field.name);

            if (itemVdom) {
                if (field.name === 'iconCls') {
                    let clsItems = field.value.split(' '),
                        cls      = ['neo-accordion-item-icon'];

                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, clsItems);
                    itemVdom.cls = cls
                } else {
                    itemVdom.text = field.value
                }
            }
        });

        me.update()
    }

    /**
     * Set the selection either bei record id or record.
     * You can pass a record or a recordId as value
     *
     * @param {Record|Record[]|Number|Number[]|String|String[]} value
     */
    setSelection(value) {
        if (value === null) {
            this.clearSelection();
            return
        }

        // In case you pass in an array use only the first item
        if (Neo.isArray(value)) {
            value = value[0]
        }

        let me = this,
            recordKeyProperty, elId;

        if (Neo.isRecord(value)) {
            recordKeyProperty = value[me.getKeyProperty()];
        } else {
            // RecordId
            recordKeyProperty = value;
        }

        elId = me.getItemId(recordKeyProperty);

        me.selectionModel.selectAndScrollIntoView(elId)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(AccordionTree));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX3RyZWVBY2NvcmRpb25fYXBwX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDSztBQUNMO0FBQ0c7QUFDRjtBQUNEO0FBQ0o7QUFDVTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLG9FQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnRUFBZ0U7QUFDN0Y7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLG9FQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyREFBMkQ7QUFDeEYsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBLFNBQVM7QUFDVCw0QkFBNEIsb0VBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtDQUErQztBQUM1RSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsU0FBUztBQUNULHVCQUF1QixrRUFBVztBQUNsQztBQUNBO0FBQ0Esd0JBQXdCLDZDQUE2QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1QsdUJBQXVCLGtFQUFXO0FBQ2xDO0FBQ0E7QUFDQSx3QkFBd0IsNENBQTRDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RCwyQkFBMkIsZ0NBQWdDO0FBQzNELDJCQUEyQixnQ0FBZ0M7QUFDM0QsMkJBQTJC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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx1REFBUTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsa0NBQWtDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbFNPO0FBQ047QUFDRDtBQUNtQjtBQUNuQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFRO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVCxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBUTs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSw2REFBZSwwQkFBMEIseUVBQWtCO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sSUFBSSxTQUFTO0FBQy9DLGlCQUFpQjs7QUFFakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdURBQVE7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLHVEQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSx3Q0FBd0MsT0FBTzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPLFdBQVc7QUFDL0IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0RBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1REFBUTtBQUM1QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFpRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL3RyZWVBY2NvcmRpb24vTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL3RyZWVBY2NvcmRpb24vYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9UcmVlQWNjb3JkaW9uTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdHJlZS9BY2NvcmRpb24ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBY2NvcmRpb25UcmVlICAgICAgICAgZnJvbSAnLi4vLi4vc3JjL3RyZWUvQWNjb3JkaW9uLm1qcyc7XG5pbXBvcnQgQ2hlY2tCb3ggICAgICAgICAgICAgIGZyb20gJy4uLy4uL3NyYy9mb3JtL2ZpZWxkL0NoZWNrQm94Lm1qcyc7XG5pbXBvcnQgQ29uZmlndXJhdGlvblZpZXdwb3J0IGZyb20gJy4uL0NvbmZpZ3VyYXRpb25WaWV3cG9ydC5tanMnO1xuaW1wb3J0IE51bWJlckZpZWxkICAgICAgICAgICBmcm9tICcuLi8uLi9zcmMvZm9ybS9maWVsZC9OdW1iZXIubWpzJztcbmltcG9ydCBQYW5lbCAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vc3JjL2NvbnRhaW5lci9QYW5lbC5tanMnO1xuaW1wb3J0IFN0YXRlUHJvdmlkZXIgICAgICAgICBmcm9tICcuLi8uLi9zcmMvc3RhdGUvUHJvdmlkZXIubWpzJztcbmltcG9ydCBTdG9yZSAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vc3JjL2RhdGEvU3RvcmUubWpzJztcbmltcG9ydCBWaWV3Q29udHJvbGxlciAgICAgICAgZnJvbSAnLi4vLi4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy50cmVlQWNjb3JkaW9uLk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5leGFtcGxlcy5Db25maWd1cmF0aW9uVmlld3BvcnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIENvbmZpZ3VyYXRpb25WaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgY2xhc3NOYW1lICAgICAgICAgICA6ICdOZW8uZXhhbXBsZXMudHJlZUFjY29yZGlvbi5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgYXV0b01vdW50ICAgICAgICAgICA6IHRydWUsXG4gICAgICAgIGNvbmZpZ0l0ZW1MYWJlbFdpZHRoOiAxMDAsXG4gICAgICAgIGNvbmZpZ0l0ZW1XaWR0aCAgICAgOiAyMzAsXG4gICAgICAgIGxheW91dCAgICAgICAgICAgICAgOiB7bnR5cGU6ICdoYm94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIGNscyAgICAgICAgICAgICAgICAgOiBbJ2V4YW1wbGVzLWNvbnRhaW5lci1hY2NvcmRpb24nXVxuICAgIH1cblxuICAgIGNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnRzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdHJlZUxpc3QgPSBtZS5leGFtcGxlQ29tcG9uZW50Lml0ZW1zWzBdO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IENoZWNrQm94LFxuICAgICAgICAgICAgY2hlY2tlZCAgICAgICA6IHRyZWVMaXN0LnJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUsXG4gICAgICAgICAgICBoaWRlTGFiZWwgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGhpZGVWYWx1ZUxhYmVsOiBmYWxzZSxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICAgOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAncm9vdFBhcmVudHNBcmVDb2xsYXBzaWJsZScpfSxcbiAgICAgICAgICAgIHZhbHVlTGFiZWxUZXh0OiAncm9vdFBhcmVudHNBcmVDb2xsYXBzaWJsZSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IENoZWNrQm94LFxuICAgICAgICAgICAgY2hlY2tlZCAgICAgICA6IHRyZWVMaXN0LmZpcnN0UGFyZW50SXNWaXNpYmxlLFxuICAgICAgICAgICAgaGlkZUxhYmVsICAgICA6IHRydWUsXG4gICAgICAgICAgICBoaWRlVmFsdWVMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgICAgIDoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2ZpcnN0UGFyZW50SXNWaXNpYmxlJyl9LFxuICAgICAgICAgICAgc3R5bGUgICAgICAgICA6IHttYXJnaW5Ub3A6ICcxMHB4J30sXG4gICAgICAgICAgICB2YWx1ZUxhYmVsVGV4dDogJ2ZpcnN0UGFyZW50SXNWaXNpYmxlJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogQ2hlY2tCb3gsXG4gICAgICAgICAgICBjaGVja2VkICAgICAgIDogdHJlZUxpc3Quc2hvd0ljb24sXG4gICAgICAgICAgICBoaWRlTGFiZWwgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGhpZGVWYWx1ZUxhYmVsOiBmYWxzZSxcbiAgICAgICAgICAgIGxpc3RlbmVycyAgICAgOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnc2hvd0ljb24nKX0sXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgIDoge21hcmdpblRvcDogJzEwcHgnfSxcbiAgICAgICAgICAgIHZhbHVlTGFiZWxUZXh0OiAnc2hvd0ljb24nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogTnVtYmVyRmllbGQsXG4gICAgICAgICAgICBjbGVhcmFibGU6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdoZWlnaHQnLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7Y2hhbmdlOiBtZS5vbkNvbmZpZ0NoYW5nZS5iaW5kKG1lLCAnaGVpZ2h0Jyl9LFxuICAgICAgICAgICAgbWF4VmFsdWUgOiAxMjAwLFxuICAgICAgICAgICAgbWluVmFsdWUgOiAyNTAsXG4gICAgICAgICAgICBzdGVwU2l6ZSA6IDUwLFxuICAgICAgICAgICAgdmFsdWUgICAgOiA2NTAsXG4gICAgICAgICAgICBzdHlsZSAgICA6IHttYXJnaW5Ub3A6ICcxMHB4J31cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBOdW1iZXJGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ3dpZHRoJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ3dpZHRoJyl9LFxuICAgICAgICAgICAgbWF4VmFsdWUgOiAxMjAwLFxuICAgICAgICAgICAgbWluVmFsdWUgOiAyMDAsXG4gICAgICAgICAgICBzdGVwU2l6ZSA6IDMsXG4gICAgICAgICAgICBzdHlsZSAgICA6IHttYXJnaW5Ub3A6ICcxMHB4J30sXG4gICAgICAgICAgICB2YWx1ZSAgICA6IDQwMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBudHlwZSAgOiAnYnV0dG9uJyxcbiAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uUmVtb3ZlRG9tQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICBzdHlsZSAgOiB7bWFyZ2luVG9wOiAnMjBweCd9LFxuICAgICAgICAgICAgdGV4dCAgIDogJ1JlbW92ZSBET00nLFxuICAgICAgICAgICAgd2lkdGggIDogMTAwXG4gICAgICAgIH1dXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgY3JlYXRlRXhhbXBsZUNvbXBvbmVudCgpIHtcbiAgICAgICAgY29uc3QgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgICBzdG9yZSA9IE5lby5jcmVhdGUoU3RvcmUsIHtcbiAgICAgICAgICAgICAgICAgIGtleVByb3BlcnR5OiAnaWQnLFxuICAgICAgICAgICAgICAgICAgbW9kZWwgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdjb2xsYXBzZWQnLCB0eXBlOiAnQm9vbGVhbid9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2NvbnRlbnQnLCB0eXBlOiAnU3RyaW5nJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnaWNvbkNscycsIHR5cGU6ICdTdHJpbmcnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdpZCcsIHR5cGU6ICdJbnRlZ2VyJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnaXNMZWFmJywgdHlwZTogJ0Jvb2xlYW4nfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICduYW1lJywgdHlwZTogJ1N0cmluZyd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ3BhcmVudElkJywgdHlwZTogJ0ludGVnZXInfVxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGF1dG9Mb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgdXJsICAgICA6ICcuLi8uLi9leGFtcGxlcy90cmVlQWNjb3JkaW9uL3RyZWUuanNvbidcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIE5lby5udHlwZSh7XG4gICAgICAgICAgICBudHlwZTogJ2NvbnRhaW5lcicsXG5cbiAgICAgICAgICAgIHN0YXRlUHJvdmlkZXI6IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogW3tuYW1lOiAnUGxlYXNlIHNlbGVjdCBzb21ldGhpbmcnfV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ2hib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgIGl0ZW1zIDogW3tcbiAgICAgICAgICAgICAgICBtb2R1bGU6IEFjY29yZGlvblRyZWUsXG5cbiAgICAgICAgICAgICAgICBiaW5kOiB7c2VsZWN0aW9uOiB7a2V5OiAnc2VsZWN0aW9uJywgdHdvV2F5OiB0cnVlfX0sXG5cbiAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFdlIGFyZSB1c2luZyBkYXRhLWJpbmRpbmcuXG4gICAgICAgICAgICAgICAgICogSGVyZSBpcyBhbiBleGFtcGxlIGZvciBsaXN0ZW5lciBhbmQgY29udHJvbGxlclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC8vIGNvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgbW9kdWxlOiBWaWV3Q29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgICBvbkFjY29yZGlvbkl0ZW1DbGljayhyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCB2aWV3cG9ydCA9IE5lby5nZXQoJ25lby1jb25maWd1cmF0aW9uLXZpZXdwb3J0LTEnKSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBvdXRwdXRFbCA9IHZpZXdwb3J0LmdldFJlZmVyZW5jZSgnb3V0cHV0Jyk7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIG91dHB1dEVsLmh0bWwgPSByZWNvcmQubmFtZTtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgbGVhZkl0ZW1DbGljazogJ29uQWNjb3JkaW9uSXRlbUNsaWNrJ1xuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RQcmVGaXJzdEl0ZW06ICgpID0+IE5lby5sb2coJ2xpc3RlbmVyIHNlbGVjdFByZUZpcnN0SXRlbSBmaXJlZCcpLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RQb3N0TGFzdEl0ZW06ICgpID0+IE5lby5sb2coJ2xpc3RlbmVyIHNlbGVjdFBvc3RMYXN0SXRlbSBmaXJlZCcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogUGFuZWwsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNTAsXG4gICAgICAgICAgICAgICAgZmxleCA6IDEsXG5cbiAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcxMHB4J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIGRvY2sgOiAndG9wJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtib3JkZXJSaWdodENvbG9yOiAndHJhbnNwYXJlbnQnfSxcblxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG50eXBlOiAnbGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA6ICdBY2NvcmRpb24gU2VsZWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH1dLFxuXG4gICAgICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgIDogJ2NvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogJ291dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIGJpbmQgICAgIDoge2h0bWw6IGRhdGEgPT4gZGF0YS5zZWxlY3Rpb25bMF0ubmFtZX1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkNvbmZpZ0NoYW5nZShjb25maWcsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5leGFtcGxlQ29tcG9uZW50Lml0ZW1zWzBdW2NvbmZpZ10gPSBvcHRzLnZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUmVtb3ZlRG9tQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgYWNjb3JkaW9uID0gdGhpcy5leGFtcGxlQ29tcG9uZW50Lml0ZW1zWzBdO1xuICAgICAgICBhY2NvcmRpb24uaGlkZGVuID0gIWFjY29yZGlvbi5oaWRkZW5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXIpO1xuIiwiaW1wb3J0IE1haW5Db250YWluZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvblN0YXJ0ID0gKCkgPT4gTmVvLmFwcCh7XG4gICAgbWFpblZpZXc6IE1haW5Db250YWluZXIsXG4gICAgbmFtZSAgICA6ICdOZW8uZXhhbXBsZXMudHJlZUFjY29yZGlvbidcbn0pO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IHtyZXNvbHZlQ2FsbGJhY2t9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29udHJvbGxlci5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29udHJvbGxlci5Db21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50LWNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50LWNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZWZlcmVuY2VzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y29tcG9uZW50fSA9IG1lO1xuXG4gICAgICAgIG1lLnJlZmVyZW5jZXMgPSB7fTtcblxuICAgICAgICBpZiAoY29tcG9uZW50LmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50Lm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwYXJlbnQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGFyZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgdGhpcy5nZXRQYXJlbnQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoYW5kbGVyTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFtjb21wb25lbnRdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxCb29sZWFufG51bGx9XG4gICAgICovXG4gICAgZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnR9ID0gbWUsXG4gICAgICAgICAgICBoYW5kbGVyQ2I7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhzIGZ1bmN0aW9uICpuYW1lKiBmaXJzdCBpbiB0aGUgQ29tcG9uZW50IGl0c2VsZi5cbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgaXQsIHJldHVybiB0cnVlIHNvIGNhbGxpbmcgY29kZSBrbm93cyBub3QgdG8gY29udGludWUgdG8gc2VhcmNoLlxuICAgICAgICAgICAgaGFuZGxlckNiID0gcmVzb2x2ZUNhbGxiYWNrKGhhbmRsZXJOYW1lLCBjb21wb25lbnQpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyIGZuIGlzIHJlc29sdmVkIGluIHRoZSBDb21wb25lbnQgb3IgaXRzIG93biBwYXJlbnQgY2hhaW4uXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBzdGF0dXMgaW5kaWNhdGluZyB0aGF0IHdlIGRvIG5vdCBuZWVkIGFuIGVhcmx5IGJpbmRpbmdcbiAgICAgICAgICAgIGlmIChoYW5kbGVyQ2IuZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5pc0Z1bmN0aW9uKG1lW2hhbmRsZXJOYW1lXSkgP1xuICAgICAgICAgICAgbWUgOiBwYXJlbnQ/LmdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBjb250cm9sbGVyIGluc2lkZSB0aGUgY29tcG9uZW50cyBwYXJlbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5jb21wb25lbnQucGFyZW50Py5nZXRDb250cm9sbGVyKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHVwZGF0ZSBjaGFuZ2VkIHJlZmVyZW5jZXMgKGUuZy4gY29udGFpbmVyLnJlbW92ZSgpIHRoZW4gY29udGFpbmVyLmFkZCgpIHVzaW5nIHRoZSBzYW1lIGtleSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJlZmVyZW5jZShuYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUucmVmZXJlbmNlc1tuYW1lXTtcblxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gbWUuY29tcG9uZW50LmRvd24oe3JlZmVyZW5jZTogbmFtZX0pO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgbWUucmVmZXJlbmNlc1tuYW1lXSA9IGNvbXBvbmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudCB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzYW1lTGV2ZWxPbmx5PWZhbHNlIHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgaW5zaWRlIHRoZSBjb21wb25lbnQgcGFyZW50IHRyZWUsXG4gICAgICogaW4gY2FzZSB0aGVyZSBpcyBub25lIG9uIHRoZSBzYW1lIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NhbWVMZXZlbE9ubHk9ZmFsc2VdXG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihzYW1lTGV2ZWxPbmx5PWZhbHNlKSB7XG4gICAgICAgIGxldCB7Y29tcG9uZW50fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzYW1lTGV2ZWxPbmx5ID8gY29tcG9uZW50LnN0YXRlUHJvdmlkZXIgOiBjb21wb25lbnQuZ2V0U3RhdGVQcm92aWRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIGFjY2Vzc2luZyBzdGF0ZS5Qcm92aWRlciBiYXNlZCBkYXRhLlN0b3Jlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZShrZXkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW5zaWRlIHlvdXIgdmlldyBjb250cm9sbGVycyBhcyBhIHN0YXJ0aW5nIHBvaW50IGluIGNhc2UgeW91IG5lZWQgcmVmZXJlbmNlc1xuICAgICAqIChpbnN0ZWFkIG9mIHVzaW5nIG9uQ29uc3RydWN0ZWQoKSBpbnNpZGUgeW91ciBjb250cm9sbGVyKVxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogV2lsbCBnZXQgY2FsbGVkIGJ5IGNvbXBvbmVudC5CYXNlOiBkZXN0cm95KCkgaW4gY2FzZSB0aGUgY29tcG9uZW50IGhhcyBhIHJlZmVyZW5jZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICovXG4gICAgcmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWZlcmVuY2VzfSA9IG1lLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT09IHJlZmVyZW5jZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZWZlcmVuY2VzW2tleV07XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmdldFBhcmVudCgpPy5yZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBzZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoLi4uYXJncylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgVHJlZU1vZGVsIGZyb20gJy4vVHJlZU1vZGVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gXCIuLi91dGlsL0FycmF5Lm1qc1wiO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLlRyZWVBY2NvcmRpb25Nb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWxcbiAqL1xuY2xhc3MgVHJlZUFjY29yZGlvbk1vZGVsIGV4dGVuZHMgVHJlZU1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uVHJlZUFjY29yZGlvbk1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLlRyZWVBY2NvcmRpb25Nb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tdHJlZWFjY29yZGlvbm1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi10cmVlYWNjb3JkaW9ubW9kZWwnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gZmluZCBhIGNoaWxkIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja0ZvckNoaWxkKHJlY29yZCkge1xuICAgICAgICBsZXQge3ZpZXd9ICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkSWQgICAgPSByZWNvcmRbdmlldy5nZXRLZXlQcm9wZXJ0eSgpXSxcbiAgICAgICAgICAgIGNoaWxkUmVjb3JkID0gbnVsbDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXcuc3RvcmUuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZpZXcuc3RvcmUuZ2V0QXQoaSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudElkID09PSByZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVjb3JkID0gaXRlbTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkUmVjb3JkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXJlbnQgcmVjb3JkIGlmIGFueVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgY2hlY2tGb3JQYXJlbnQoe3BhcmVudElkfSkge1xuICAgICAgICByZXR1cm4gcGFyZW50SWQgPyB0aGlzLnZpZXcuc3RvcmUuZ2V0KHBhcmVudElkKSA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXBlbmRpbmcgb24gey0xfDF9IHN0ZXAgcmV0dXJuXG4gICAgICogLTE6IHByZXZpb3VzIHJlY29yZCBPUiBwYXJlbnQgcmVjb3JkXG4gICAgICogIDE6IG5leHQgcmVjb3JkIG9yIG51bGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja0ZvclNpYmxpbmcocmVjb3JkLCBzdGVwKSB7XG4gICAgICAgIGxldCB7dmlld30gICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c3RvcmV9ICAgICAgICA9IHZpZXcsXG4gICAgICAgICAgICBwYXJlbnRSZWNvcmRJZCA9IHJlY29yZC5wYXJlbnRJZCxcbiAgICAgICAgICAgIHJlY29yZElkICAgICAgID0gcmVjb3JkW3ZpZXcuZ2V0S2V5UHJvcGVydHkoKV0sXG4gICAgICAgICAgICBoYXNGb3VuZE5leHQgICA9IGZhbHNlLFxuICAgICAgICAgICAgbmV4dEl0ZW1SZWNvcmQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNJdGVtUmVjb3JkO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcmUuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHN0b3JlLmdldEF0KGkpO1xuXG4gICAgICAgICAgICBpZiAoaGFzRm91bmROZXh0ICYmIGl0ZW0ucGFyZW50SWQgPT09IHBhcmVudFJlY29yZElkKSB7XG4gICAgICAgICAgICAgICAgbmV4dEl0ZW1SZWNvcmQgPSBpdGVtO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGFzRm91bmROZXh0ICYmIGl0ZW0ucGFyZW50SWQgPT09IHBhcmVudFJlY29yZElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNGb3VuZE5leHQgJiYgaXRlbVt2aWV3LmdldEtleVByb3BlcnR5KCldID09PSByZWNvcmRJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gLTEpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBoYXNGb3VuZE5leHQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNJdGVtUmVjb3JkID0gaXRlbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGVwID09PSAxID8gbmV4dEl0ZW1SZWNvcmQgOiAocHJldmlvdXNJdGVtUmVjb3JkIHx8IHN0b3JlLmdldChwYXJlbnRSZWNvcmRJZCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbmV4dCBzaWJsaW5nIG9mIGEgcGFyZW50IGl0ZW1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGNoZWNrTmV4dFBhcmVudFNpYmxpbmcocmVjb3JkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudCAgICAgICAgPSBtZS52aWV3LnN0b3JlLmdldChyZWNvcmQucGFyZW50SWQpLFxuICAgICAgICAgICAgcGFyZW50U2libGluZyA9IG1lLmNoZWNrRm9yU2libGluZyhwYXJlbnQsIDEpO1xuXG4gICAgICAgIGlmICghcGFyZW50U2libGluZyAmJiBwYXJlbnQucGFyZW50SWQpIHtcbiAgICAgICAgICAgIG1lLmNoZWNrTmV4dFBhcmVudFNpYmxpbmcocGFyZW50KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudFNpYmxpbmdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkga2V5cyAoTGlzdC5tanM6cmVnaXN0ZXIpXG4gICAgICogVG9nZ2xlIGNvbGxhcHNlIG9yIGlmIGlzTGVhZiBzZWxlY3QgbmV4dCBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25FbnRlcihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICBpdGVtSWQgPSBtZS5nZXRTZWxlY3Rpb24oKVswXSxcbiAgICAgICAgICAgIHJlY29yZCA9IHZpZXcuc3RvcmUuZ2V0KHZpZXcuZ2V0SXRlbVJlY29yZElkKGl0ZW1JZCkpO1xuXG4gICAgICAgIGlmIChyZWNvcmQuaXNMZWFmIHx8IHJlY29yZC5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIG1lLm9uS2V5RG93blJpZ2h0KGRhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5vbktleURvd25MZWZ0KGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkga2V5cyAoTGlzdC5tanM6cmVnaXN0ZXIpXG4gICAgICogRGVzZWxlY3QgYWxsIGFuZCBmaXJlIGV2ZW50IHNlbGVjdFBvc3RMYXN0SXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRXNjYXBlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2UgZm9sZGVyIG9yIHNlbGVjdCBwcmV2aW91c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duTGVmdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3ZpZXd9ID0gbWUsXG4gICAgICAgICAgICBpdGVtSWQgPSBtZS5nZXRTZWxlY3Rpb24oKVswXSxcbiAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICBpZiAoIWl0ZW1JZCkge1xuICAgICAgICAgICAgbWUuc2VsZWN0Um9vdCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICByZWNvcmQgPSB2aWV3LnN0b3JlLmdldCh2aWV3LmdldEl0ZW1SZWNvcmRJZChpdGVtSWQpKTtcblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZiB8fCByZWNvcmQuY29sbGFwc2VkIHx8ICF2aWV3LnJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUpIHtcbiAgICAgICAgICAgIG1lLm9uTmF2S2V5KGRhdGEsIC0xKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUudG9nZ2xlQ29sbGFwc2VkKHJlY29yZCwgaXRlbUlkLCB0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiBmb2xkZXIgb3Igc2VsZWN0IG5leHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93blJpZ2h0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dmlld30gPSBtZSxcbiAgICAgICAgICAgIGl0ZW1JZCA9IG1lLmdldFNlbGVjdGlvbigpWzBdLFxuICAgICAgICAgICAgcmVjb3JkO1xuXG4gICAgICAgIGlmICghaXRlbUlkKSB7XG4gICAgICAgICAgICBtZS5zZWxlY3RSb290KCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY29yZCA9IHZpZXcuc3RvcmUuZ2V0KHZpZXcuZ2V0SXRlbVJlY29yZElkKGl0ZW1JZCkpO1xuXG4gICAgICAgIGlmIChyZWNvcmQuaXNMZWFmIHx8ICFyZWNvcmQuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICBtZS5vbk5hdktleShkYXRhLCAxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUudG9nZ2xlQ29sbGFwc2VkKHJlY29yZCwgaXRlbUlkLCBmYWxzZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgJ3VwJyBhbmQgJ2Rvd24nIGtleXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgb25OYXZLZXkoZGF0YSwgc3RlcCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSA9IG1lLFxuICAgICAgICAgICAgaXRlbSAgID0gbWUuZ2V0U2VsZWN0aW9uKClbMF0sXG4gICAgICAgICAgICBuZXdSZWNvcmQsIHJlY29yZCwgcmVjb3JkSWQ7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlY29yZElkID0gdmlldy5nZXRJdGVtUmVjb3JkSWQoaXRlbSk7XG4gICAgICAgICAgICByZWNvcmQgICA9IHZpZXcuc3RvcmUuZ2V0KHJlY29yZElkKTtcblxuICAgICAgICAgICAgaWYgKHN0ZXAgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY29yZC5pc0xlYWYgJiYgIXJlY29yZC5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBuZXdSZWNvcmQgPSBtZS5jaGVja0ZvckNoaWxkKHJlY29yZClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIG5leHQgc2libGluZ1xuICAgICAgICAgICAgICAgICAgICBuZXdSZWNvcmQgPSBtZS5jaGVja0ZvclNpYmxpbmcocmVjb3JkLCBzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gPT0+IGxvb3AgdGhyb3VnaCBwYXJlbnQgbmV4dCBzaWJsaW5ncyB1bnRpbCBubyBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JlY29yZCA9IG1lLmNoZWNrTmV4dFBhcmVudFNpYmxpbmcocmVjb3JkKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaXRlbSB3YXMgdGhlIGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgIGlmICghbmV3UmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRlc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZmlyZSgnc2VsZWN0UG9zdExhc3RJdGVtJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgcHJldmlvdXMgc2libGluZ1xuICAgICAgICAgICAgICAgIG5ld1JlY29yZCA9IG1lLmNoZWNrRm9yU2libGluZyhyZWNvcmQsIHN0ZXApO1xuICAgICAgICAgICAgICAgIC8vIG5vID09PiBnZXQgcGFyZW50XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVjb3JkID0gbWUuY2hlY2tGb3JQYXJlbnQocmVjb3JkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGl0ZW0gd2FzIHRoZSBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKCFuZXdSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3RQcmVGaXJzdEl0ZW0nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnNlbGVjdFJvb3QoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1JlY29yZCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbUlkID0gdmlldy5nZXRJdGVtSWQobmV3UmVjb3JkW21lLnZpZXcuZ2V0S2V5UHJvcGVydHkoKV0pO1xuXG4gICAgICAgICAgICBtZS5zZWxlY3RBbmRTY3JvbGxJbnRvVmlldyhpdGVtSWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYW4gaXRlbSBhbmQgc2Nyb2xsIHRoZSB0cmVlIHRvIHNob3cgdGhlIGl0ZW0gaW4gdGhlIGNlbnRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtSWRcbiAgICAgKi9cbiAgICBzZWxlY3RBbmRTY3JvbGxJbnRvVmlldyhpdGVtSWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QoaXRlbUlkKTtcblxuICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgaWQgICAgICA6IGl0ZW1JZCxcbiAgICAgICAgICAgIGJsb2NrICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHdpbmRvd0lkOiB0aGlzLnZpZXcud2luZG93SWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIHJvb3QgaXRlbSBvZiB0aGUgdHJlZVxuICAgICAqL1xuICAgIHNlbGVjdFJvb3QoKSB7XG4gICAgICAgIGxldCB7dmlld30gID0gdGhpcyxcbiAgICAgICAgICAgIHtzdG9yZX0gPSB2aWV3LFxuICAgICAgICAgICAgcmVjb3JkLCByb290SXRlbUlkO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcmUuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gc3RvcmUuZ2V0QXQoaSk7XG5cbiAgICAgICAgICAgIGlmICghcmVjb3JkLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgcm9vdEl0ZW1JZCA9IHZpZXcuZ2V0SXRlbUlkKHJlY29yZFt2aWV3LmdldEtleVByb3BlcnR5KCldKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3RBbmRTY3JvbGxJbnRvVmlldyhyb290SXRlbUlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcGFyZW50IHJlY29yZCBpZiBhbnlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGFwc2VcbiAgICAgKi9cbiAgICB0b2dnbGVDb2xsYXBzZWQocmVjb3JkLCBpdGVtSWQsIGNvbGxhcHNlKSB7XG4gICAgICAgIGxldCBpdGVtICA9IHRoaXMudmlldy5nZXRWZG9tQ2hpbGQoaXRlbUlkKSxcbiAgICAgICAgICAgIGNsc0ZuID0gY29sbGFwc2UgPyAncmVtb3ZlJyA6ICdhZGQnO1xuXG4gICAgICAgIE5lb0FycmF5W2Nsc0ZuXShpdGVtLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlKCk7XG5cbiAgICAgICAgcmVjb3JkLmNvbGxhcHNlZCA9IGNvbGxhcHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUcmVlQWNjb3JkaW9uTW9kZWwpO1xuIiwiaW1wb3J0IENsYXNzU3lzdGVtVXRpbCAgICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUcmVlTGlzdCAgICAgICAgICAgZnJvbSAnLi4vdHJlZS9MaXN0Lm1qcyc7XG5pbXBvcnQgVHJlZUFjY29yZGlvbk1vZGVsIGZyb20gJy4uL3NlbGVjdGlvbi9UcmVlQWNjb3JkaW9uTW9kZWwubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby50cmVlLkFjY29yZGlvblxuICogQGV4dGVuZHMgTmVvLnRyZWUuTGlzdFxuICpcbiAqIEFjY29yZGlvbiBTdG9yZSBleHBlY3RzIHRoZSBmb2xsb3dpbmcgZmllbGRzXG4gKlxuICogICAgICBbXG4gKiAgICAgICAgICBpY29uQ2xzLCAgICAgICAgLy8gY2FuIGJlIGRlZmluZWQgaW4gZmllbGRzOmljb25cbiAqICAgICAgICAgIGNvbnRlbnQsICAgICAgICAvLyBjYW4gYmUgZGVmaW5lZCBpbiBmaWVsZHM6dGV4dFxuICogICAgICAgICAgbmFtZSwgICAgICAgICAgIC8vIGNhbiBiZSBkZWZpbmVkIGluIGZpZWxkczpoZWFkZXJcbiAqXG4gKiAgICAgICAgICBjb2xsYXBzZWQsICAgICAgLy8gY29sbGFwc2VkIHN0YXRlIGZvciBub24tbGVhZi1pdGVtc1xuICogICAgICAgICAgaXNMZWFmLCAgICAgICAgIC8vIGRlZmluZXMgaXQgaXRlbSBpcyBsZWFmLWl0ZW1cbiAqICAgICAgICAgIGlkLCAgICAgICAgICAgICAvLyBkZWZpbmVzIGl0ZW0gaWRcbiAqICAgICAgICAgIHBhcmVudElkICAgICAgICAvLyBsZWFmIG9yIHN1Yi1pdGVtcyBuZWVkIGEgcGFyZW50SWRcbiAqICAgICAgXVxuICpcbiAqL1xuY2xhc3MgQWNjb3JkaW9uVHJlZSBleHRlbmRzIFRyZWVMaXN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50cmVlLkFjY29yZGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRyZWUuQWNjb3JkaW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RyZWVhY2NvcmRpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndHJlZWFjY29yZGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10cmVlLWFjY29yZGlvbiddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10cmVlLWxpc3QnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSB0aGUgZmllbGQgbmFtZXMgZm9yIHRoZSBzdG9yZSB0byBzaG93IGhlYWRlciwgdGV4dCBhbmQgaWNvblxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGZpZWxkcz17aGVhZGVyOiduYW1lJyxpY29uOidpY29uQ2xzJyx0ZXh0Oidjb250ZW50J31cbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgaGVhZGVyOiAnbmFtZScsXG4gICAgICAgICAgICBpY29uICA6ICdpY29uQ2xzJyxcbiAgICAgICAgICAgIHRleHQgIDogJ2NvbnRlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gZmFsc2UgdG8gaGlkZSB0aGUgaW5pdGlhbCByb290IGl0ZW1cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZmlyc3RQYXJlbnRJc1Zpc2libGU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZmlyc3RQYXJlbnRJc1Zpc2libGVfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGZhbHNlIHdpbGwgYXV0byBleHBhbmQgcm9vdCBwYXJlbnQgaXRlbXMgYW5kIGRpc2FsbG93IGNvbGxhcHNpbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcm9vdFBhcmVudElzQ29sbGFwc2libGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLCB3aGljaCBpcyBiaW5kYWJsZVxuICAgICAgICAgKiBAbWVtYmVyIHtSZWNvcmRbXXxudWxsfSBzZWxlY3Rpb249bnVsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgbW9kdWxlOiBBY2NvcmRpb25UcmVlLFxuICAgICAgICAgKiAgICAgYmluZCAgOiB7c2VsZWN0aW9uOiB7a2V5OiAnc2VsZWN0aW9uJywgdHdvV2F5OiB0cnVlfX1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICogICAgIGJpbmQgOiB7aHRtbDogZGF0YSA9PiBkYXRhLnNlbGVjdGlvblswXS5uYW1lfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0aW9uXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byBmYWxzZSB3aWxsIGhpZGUgdGhlIGljb25zIGZvciBhbGwgbGVhZiBpdGVtc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93SWNvbj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93SWNvbl86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29uczogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7dGFnOiAndWwnLCBjbHM6IFsnbmVvLWxpc3QtY29udGFpbmVyJywgJ25lby1saXN0JywgJ25lby1hY2NvcmRpb24tc3R5bGUnXSwgY246IFtdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGZvY3VzaW46IG1lLm9uRm9jdXMsXG4gICAgICAgICAgICBzY29wZSAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5naW5nIGZpcnN0UGFyZW50SXNWaXNpYmxlXG4gICAgICogRmlyc3Qgc3RvcmUgaXRlbSBnZXRzIG1hcmtlZCBhbmQgYWRkaXRpb25hbCBjc3MgY2xhc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGaXJzdFBhcmVudElzVmlzaWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IGZpcnN0UmVjb3JkID0gdGhpcy5zdG9yZS5maXJzdCgpO1xuXG4gICAgICAgIHRoaXMudG9nZ2xlQ2xzKCdmaXJzdC1wYXJlbnQtbm90LXZpc2libGUnLCAhdmFsdWUpO1xuXG4gICAgICAgIGlmIChmaXJzdFJlY29yZCkge1xuICAgICAgICAgICAgZmlyc3RSZWNvcmQudmlzaWJsZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2luZyByb290UGFyZW50c0FyZUNvbGxhcHNpYmxlXG4gICAgICogRW5zdXJlcyB0aGF0IHJvb3QgaXRlbXMgYXJlIGV4cGFuZGVkIGlmIG5vdCBjb2xsYXBzaWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWVbIXZhbHVlID8gJ2FkZENscycgOiAncmVtb3ZlQ2xzJ10oJ3Jvb3Qtbm90LWNvbGxhcHNpYmxlJyk7XG5cbiAgICAgICAgaWYgKG1lLnZub2RlSW5pdGlhbGl6ZWQgJiYgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBsZXQge3N0b3JlfSA9IG1lO1xuXG4gICAgICAgICAgICBzdG9yZS5mb3JFYWNoKHJlY29yZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5wYXJlbnRJZCA9PT0gbnVsbCAmJiAhcmVjb3JkLmlzTGVhZikge1xuICAgICAgICAgICAgICAgICAgICBtZS5leHBhbmRJdGVtKHJlY29yZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gY2hhbmdpbmcgc2hvd0ljb25cbiAgICAgKiBDaGFuZ2VzIHRoZSBkaXNwbGF5IG9mIHRoZSBpY29uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dJY29uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAge3N0b3JlfSA9IG1lLFxuICAgICAgICAgICAgICBoaWRlICAgID0gIXZhbHVlO1xuXG4gICAgICAgIHN0b3JlLmZvckVhY2gocmVjb3JkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1JZCAgID0gbWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSksXG4gICAgICAgICAgICAgICAgICB2ZG9tICAgICA9IG1lLmdldFZkb21DaGlsZChpdGVtSWQpLFxuICAgICAgICAgICAgICAgICAgaXRlbVZkb20gPSBWRG9tVXRpbC5nZXRCeUZsYWcodmRvbSwgJ2ljb25DbHMnKTtcblxuICAgICAgICAgICAgaWYgKHJlY29yZC5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBpdGVtVmRvbS5yZW1vdmVEb20gPSBoaWRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5zZWxlY3Rpb24uTW9kZWx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFRyZWVBY2NvcmRpb25Nb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGl0ZW1zIGZyb20gdGhlIGFjY29yZGlvblxuICAgICAqIElmIHlvdSBkbyBub3QgbmVlZCB0byB1cGRhdGUgdGhlIHZpZXcgYWZ0ZXIgY2xlYXJpbmcsIHNldCBgd2l0aFVwZGF0ZSA9IGZhbHNlYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFVwZGF0ZT10cnVlXVxuICAgICAqL1xuICAgIGNsZWFyKHdpdGhVcGRhdGU9dHJ1ZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5nZXRWZG9tUm9vdCgpLmNuWzBdLmNuXG5cbiAgICAgICAgd2l0aFVwZGF0ZSAmJiB0aGlzLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBpdGVtcyBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdEFsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyZW50SWRdIFRoZSBwYXJlbnQgbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbVJvb3RdIFRoZSB2ZG9tIHRlbXBsYXRlIHJvb3QgZm9yIHRoZSBjdXJyZW50IHN1YiB0cmVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBoaWVyYXJjaHkgbGV2ZWwgb2YgdGhlIHRyZWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tUm9vdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcyhwYXJlbnRJZCwgdmRvbVJvb3QsIGxldmVsKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Zm9sZGVyQ2xzLCBpdGVtQ2xzfSA9IG1lLFxuICAgICAgICAgICAgaXRlbXMgICAgICAgICAgICAgICAgPSBtZS5zdG9yZS5maW5kKCdwYXJlbnRJZCcsIHBhcmVudElkKSxcbiAgICAgICAgICAgIGNscywgaWQsIGl0ZW1JY29uQ2xzLCB0bXBSb290O1xuXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXZkb21Sb290LmNuKSB7XG4gICAgICAgICAgICAgICAgdmRvbVJvb3QuY24gPSBbXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2ZG9tUm9vdC5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiAndWwnLFxuICAgICAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLWxpc3QnXSxcbiAgICAgICAgICAgICAgICAgICAgY24gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaWQgOiBgJHttZS5pZH1fXyR7cGFyZW50SWR9X191bGBcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSB2ZG9tUm9vdC5jblt2ZG9tUm9vdC5jbi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bXBSb290ID0gdmRvbVJvb3RcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjbHMgICAgICAgICA9IFtpdGVtQ2xzXTtcbiAgICAgICAgICAgICAgICBpdGVtSWNvbkNscyA9IFsnbmVvLWFjY29yZGlvbi1pdGVtLWljb24nXTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmljb25DbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGl0ZW1JY29uQ2xzLCBpdGVtLmljb25DbHMuc3BsaXQoJyAnKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzLnB1c2goaXRlbUNscyArIChpdGVtLnNpbmdsZXRvbiA/ICctbGVhZi1zaW5nbGV0b24nIDogJy1sZWFmJykpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzLnB1c2goZm9sZGVyQ2xzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ucGFyZW50SWQgJiYgIW1lLnJvb3RQYXJlbnRzQXJlQ29sbGFwc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tbm90LWNvbGxhcHNpYmxlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29sbGFwc2VkID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZm9sZGVyLW9wZW4nKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWQgPSBtZS5nZXRJdGVtSWQoaXRlbS5pZCk7XG5cbiAgICAgICAgICAgICAgICB0bXBSb290LmNuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0YWcgICAgIDogJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBjbiAgICAgIDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgICAgIDogJ2ljb25DbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IGl0ZW1JY29uQ2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgOiBpZCArICdfX2ljb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiAoIWl0ZW0uaXNMZWFmIHx8ICFtZS5zaG93SWNvbilcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzICA6IFtpdGVtQ2xzICsgJy1jb250ZW50J10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgIDogaWQgKyAnX19pdGVtLWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtwb2ludGVyRXZlbnRzOiAnbm9uZSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZzogJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyA6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgOiBbaXRlbUNscyArICctY29udGVudC1oZWFkZXInXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgOiBpZCArICdfX2l0ZW0tY29udGVudC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW1bbWUuZmllbGRzLmhlYWRlcl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnOiAnY29udGVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIDogJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyA6IFtpdGVtQ2xzICsgJy1jb250ZW50LXRleHQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgOiBpZCArICdfX2l0ZW0tY29udGVudC10ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpdGVtW21lLmZpZWxkcy50ZXh0XVxuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaXRlbS5pc0xlYWYgPyBudWxsIDogJ3N0aWNreScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgICAgIDogaXRlbS5pc0xlYWYgPyBudWxsIDogKGxldmVsICogMzgpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleCAgOiBpdGVtLmlzTGVhZiA/IG51bGwgOiAoMjAgLyAobGV2ZWwgKyAxKSksXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSBtZS5jcmVhdGVJdGVtcyhpdGVtLmlkLCB0bXBSb290LCBsZXZlbCArIDEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZkb21Sb290XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFuIGl0ZW0gYmFzZWQgb24gdGhlIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKi9cbiAgICBleHBhbmRJdGVtKHJlY29yZCkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1JZCA9IG1lLmdldEl0ZW1JZChyZWNvcmRbbWUuZ2V0S2V5UHJvcGVydHkoKV0pLFxuICAgICAgICAgICAgaXRlbSAgID0gbWUuZ2V0VmRvbUNoaWxkKGl0ZW1JZCk7XG5cbiAgICAgICAgcmVjb3JkLmNvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChpdGVtLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkl0ZW1DbGljayhpdGVtLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uSXRlbUNsaWNrKGl0ZW0sIGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzZWxlY3Rpb25Nb2RlbH0gPSBtZSxcbiAgICAgICAgICAgIGl0ZW1JZCAgICAgICAgICAgPSBpdGVtLmlkLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgICA9IE51bWJlcihpdGVtSWQuc3BsaXQoJ19fJylbMV0pLFxuICAgICAgICAgICAgcmVjb3JkICAgICAgICAgICA9IG1lLnN0b3JlLmdldChpZCk7XG5cbiAgICAgICAgc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGl0ZW0uaWQpO1xuXG4gICAgICAgIGlmICghcmVjb3JkLmlzTGVhZikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZm9sZGVySXRlbUNsaWNrIGV2ZW50IGZpcmVzIHdoZW4gYSBjbGljayBvY2N1cnMgb24gYSBsaXN0IGl0ZW0gd2hpY2ggZG9lcyBoYXZlIGNoaWxkIGl0ZW1zLlxuICAgICAgICAgICAgICogUGFzc2VzIHRoZSBpdGVtIHJlY29yZCB0byB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICAgICAqIEBldmVudCBmb2xkZXJJdGVtQ2xpY2tcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlY29yZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtZS5maXJlKCdmb2xkZXJJdGVtQ2xpY2snLCB7cmVjb3JkfSk7XG5cbiAgICAgICAgICAgIHJlY29yZC5jb2xsYXBzZWQgPSAhcmVjb3JkLmNvbGxhcHNlZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gcGxhY2UgdGhlIHJvb3QgaXRlbSBhdCB0aGUgY29ycmVjdCBsb2NhdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TGlzdEl0ZW1zUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY29yZGlvbiBnYWluaW5nIGZvY3VzIHdpdGhvdXQgc2VsZWN0aW9uID0+IHNldFNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Gb2N1cyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzZWxlY3Rpb25Nb2RlbH0gPSBtZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbiAgICAgICAgPSBzZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb24oKVswXTtcblxuICAgICAgICAhc2VsZWN0aW9uICYmIHNlbGVjdGlvbk1vZGVsLnNlbGVjdFJvb3QoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBmcm9tIFNlbGVjdGlvbk1vZGVsIHNlbGVjdCgpXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKi9cbiAgICBvblNlbGVjdCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmRzID0gW107XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoc2VsZWN0SXRlbUlkKSA9PiB7XG4gICAgICAgICAgICBsZXQgaWQgICAgID0gbWUuZ2V0SXRlbVJlY29yZElkKHNlbGVjdEl0ZW1JZCksXG4gICAgICAgICAgICAgICAgcmVjb3JkID0gbWUuc3RvcmUuZ2V0KGlkKTtcblxuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuc2VsZWN0aW9uID0gcmVjb3Jkc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBzdG9yZSBsb2FkZWQsIGNyZWF0ZSB0aGUgaXRlbXMgZm9yIHRoZSBsaXN0XG4gICAgICogQHBhcmFtIHtSZWNvcmRbXX0gcmVjb3Jkc1xuICAgICAqL1xuICAgIG9uU3RvcmVMb2FkKHJlY29yZHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jbGVhcihmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFtZS5tb3VudGVkICYmIG1lLmlzVm5vZGVJbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgIG1lLm9uKCdtb3VudGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1zKG51bGwsIG1lLmdldExpc3RJdGVtc1Jvb3QoKSwgMCk7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVJdGVtcyhudWxsLCBtZS5nZXRMaXN0SXRlbXNSb290KCksIDApO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSAgICAgICBkYXRhLmZpZWxkc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgIGRhdGEuaW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtSZWNvcmR9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBvblN0b3JlUmVjb3JkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2ZpZWxkcywgcmVjb3JkfSA9IGRhdGEsXG4gICAgICAgICAgICBpdGVtSWQgICAgICAgICAgID0gbWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSksXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgICAgID0gbWUuZ2V0VmRvbUNoaWxkKGl0ZW1JZCksXG4gICAgICAgICAgICBpdGVtVmRvbTtcblxuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIGl0ZW1WZG9tID0gVkRvbVV0aWwuZ2V0QnlGbGFnKHZkb20sIGZpZWxkLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbVZkb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PT0gJ2ljb25DbHMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbHNJdGVtcyA9IGZpZWxkLnZhbHVlLnNwbGl0KCcgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA9IFsnbmVvLWFjY29yZGlvbi1pdGVtLWljb24nXTtcblxuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCBjbHNJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1WZG9tLmNscyA9IGNsc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1WZG9tLnRleHQgPSBmaWVsZC52YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlbGVjdGlvbiBlaXRoZXIgYmVpIHJlY29yZCBpZCBvciByZWNvcmQuXG4gICAgICogWW91IGNhbiBwYXNzIGEgcmVjb3JkIG9yIGEgcmVjb3JkSWQgYXMgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVjb3JkfFJlY29yZFtdfE51bWJlcnxOdW1iZXJbXXxTdHJpbmd8U3RyaW5nW119IHZhbHVlXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiBjYXNlIHlvdSBwYXNzIGluIGFuIGFycmF5IHVzZSBvbmx5IHRoZSBmaXJzdCBpdGVtXG4gICAgICAgIGlmIChOZW8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmRLZXlQcm9wZXJ0eSwgZWxJZDtcblxuICAgICAgICBpZiAoTmVvLmlzUmVjb3JkKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVjb3JkS2V5UHJvcGVydHkgPSB2YWx1ZVttZS5nZXRLZXlQcm9wZXJ0eSgpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlY29yZElkXG4gICAgICAgICAgICByZWNvcmRLZXlQcm9wZXJ0eSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxJZCA9IG1lLmdldEl0ZW1JZChyZWNvcmRLZXlQcm9wZXJ0eSk7XG5cbiAgICAgICAgbWUuc2VsZWN0aW9uTW9kZWwuc2VsZWN0QW5kU2Nyb2xsSW50b1ZpZXcoZWxJZClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEFjY29yZGlvblRyZWUpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=