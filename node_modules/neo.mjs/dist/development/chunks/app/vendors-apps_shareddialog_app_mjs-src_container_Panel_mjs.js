"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-apps_shareddialog_app_mjs-src_container_Panel_mjs"],{

/***/ "./apps/shareddialog/app.mjs":
/*!***********************************!*\
  !*** ./apps/shareddialog/app.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/MainContainer.mjs */ "./apps/shareddialog/view/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'SharedDialog'
});


/***/ }),

/***/ "./apps/shareddialog/view/DemoDialog.mjs":
/*!***********************************************!*\
  !*** ./apps/shareddialog/view/DemoDialog.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_dialog_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/dialog/Base.mjs */ "./src/dialog/Base.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");



/**
 * @class SharedDialog.view.DemoDialog
 * @extends Neo.dialog.Base
 */
class DemoDialog extends _src_dialog_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.DemoDialog'
         * @protected
         */
        className: 'SharedDialog.view.DemoDialog',
        /**
         * @member {String} title='Drag me across Windows!'
         * @reactive
         */
        title: 'Drag me across Windows!',
        /**
         * @member {Object} containerConfig={style:padding:'20px}}
         */
        containerConfig: {
            style: {
                padding: '20px'
            }
        },
        /**
         * @member {Object} itemDefaults={labelWidth:70}
         * @reactive
         */
        itemDefaults: {
            flex      : 'none',
            labelWidth: 70
        },
        /**
         * @member {Object[]} items
         */
        items: [{
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            labelText: 'Field 1'
        }, {
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            labelText: 'Field 2'
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DemoDialog));


/***/ }),

/***/ "./apps/shareddialog/view/MainContainer.mjs":
/*!**************************************************!*\
  !*** ./apps/shareddialog/view/MainContainer.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_form_field_Radio_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/form/field/Radio.mjs */ "./src/form/field/Radio.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./apps/shareddialog/view/MainContainerController.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");






/**
 * @class SharedDialog.view.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.MainContainer'
         * @protected
         */
        className: 'SharedDialog.view.MainContainer',
        /**
         * @member {Neo.controller.Component} controller=MainContainerController
         * @reactive
         */
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex  : 'none',
            items :[{
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                flag   : 'open-dialog-button',
                handler: 'onCreateDialogButtonClick',
                iconCls: 'far fa-window-maximize',
                text   : 'Create Dialog',
            }, '->', {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'switchTheme',
                iconCls: 'fa fa-moon',
                text   : 'Theme Dark'
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'openDockedWindow',
                iconCls: 'far fa-window-restore',
                style  : {marginLeft: '1em'},
                text   : 'Open docked Window'
            }]
        }, {
            ntype : 'container',
            flex  : 'none',
            layout: 'hbox',

            style: {
                height     : '72px',
                marginRight: '1em',
                marginTop  : '1em'
            },

            items : [{
                ntype: 'component',
                flex : 1
            }, {
                ntype: 'container',
                flex : 'none',

                itemDefaults: {
                    module        : _src_form_field_Radio_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    hideValueLabel: false,
                    labelText     : '',
                    labelWidth    : 50,
                    name          : 'dockedPosition',

                    listeners: {
                        change: 'onDockedPositionChange'
                    }
                },

                items: [{
                    labelText : 'Dock',
                    valueLabel: 'Top',
                    value     : 'top'
                }, {
                    checked   : true,
                    valueLabel: 'Right',
                    value     : 'right'
                }, {
                    valueLabel: 'Bottom',
                    value     : 'bottom'
                }, {
                    valueLabel: 'Left',
                    value     : 'left'
                }]
            }]
        }, {
            ntype: 'component',
            flex : 1,
            text : '#1',

            style: {
                alignItems    : 'center',
                color         : '#bbb',
                display       : 'flex',
                fontSize      : '200px',
                justifyContent: 'center',
                marginBottom  : '88px',
                userSelect    : 'none'
            }
        }],
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @reactive
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Object} style={padding:'20px'}
         */
        style: {padding: '20px'}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./apps/shareddialog/view/MainContainerController.mjs":
/*!************************************************************!*\
  !*** ./apps/shareddialog/view/MainContainerController.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");
/* harmony import */ var _src_manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _DemoDialog_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DemoDialog.mjs */ "./apps/shareddialog/view/DemoDialog.mjs");
/* harmony import */ var _src_draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/draggable/DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../src/util/Rectangle.mjs */ "./src/util/Rectangle.mjs");







/**
 * @class SharedDialog.view.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='SharedDialog.view.MainContainerController'
         * @protected
         */
        className: 'SharedDialog.view.MainContainerController',
        /**
         * Valid values: bottom, left, right, top
         * @member {String} dockedWindowSide_='right'
         * @reactive
         */
        dockedWindowSide_: 'right',
    }

    /**
     * @member {String[]} connectedApps=[]
     */
    connectedApps = []
    /**
     * @member {String} currentTheme='neo-theme-light'
     */
    currentTheme = 'neo-theme-light'
    /**
     * @member {String} dockedWindowAppName='SharedDialog2'
     */
    dockedWindowAppName = 'SharedDialog2'
    /**
     * @member {Number|null} dockedWindowId=null
     */
    dockedWindowId = null
    /**
     * @member {Neo.component.Base|null} dockedWindowProxy=null
     */
    dockedWindowProxy = null
    /**
     * @member {Number} dockedWindowSize=500
     */
    dockedWindowSize = 620
    /**
     * @member {Object} dialogRect=null
     */
    dialogRect = null
    /**
     * @member {Object} dragStartWindowRect=null
     */
    dragStartWindowRect = null
    /**
     * @member {String|null} previousTheme=null
     */
    previousTheme = null
    /**
     * @member {Number|null} targetWindowSize=0
     */
    targetWindowSize = 0

    /**
     * Triggered after the dockedWindowSide config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDockedWindowSide(value, oldValue) {
        if (this.hasDockedWindow()) {
            Neo.main.addon.WindowPosition.setDock({
                name: this.dockedWindowAppName,
                dock: value
            })
        }
    }

    /**
     * @param {Object} data
     * @param {String} appName
     */
    createDialog(data, appName) {
        let me         = this,
            {windowId} = me;

        me.enableOpenDialogButtons(false);

        me.dialog = Neo.create(_DemoDialog_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            animateTargetId    : data.component.id,
            appName,
            boundaryContainerId: null,
            cls                : [me.currentTheme],
            height             : 200,
            width              : 300,
            windowId,

            dragZoneConfig: {
                alwaysFireDragMove: true
            },

            listeners: {
                close          : me.onDialogClose,
                dragZoneCreated: me.onDragZoneCreated,
                scope          : me
            }
        })
    }

    /**
     *
     */
    destroyDockedWindowProxy() {
        let me = this;

        if (me.dockedWindowProxy) {
            me.dockedWindowProxy.destroy(true);
            me.dockedWindowProxy = null
        }
    }

    /**
     * @param {Object} proxyRect
     */
    dropDialogBetweenWindows(proxyRect) {
        let me               = this,
            dialog           = me.dialog,
            intersection     = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].getIntersection(me.dragStartWindowRect, proxyRect),
            intersectionSize = intersection?.height * intersection?.width,
            side             = me.dockedWindowSide,
            size             = proxyRect.height * proxyRect.width,
            wrapperStyle;

        if (intersectionSize > size / 2) { // drop the dialog fully into the dragStart window
            me.destroyDockedWindowProxy();

            wrapperStyle = dialog.wrapperStyle;

            if (dialog.appName === me.dockedWindowAppName) {
                side = me.getOppositeSide(side);
            }

            switch (side) {
                case 'bottom':
                    wrapperStyle.top = `${me.dragStartWindowRect.height - proxyRect.height}px`;
                    break;
                case 'left':
                    wrapperStyle.left = '0px';
                    break;
                case 'right':
                    wrapperStyle.left = `${me.dragStartWindowRect.width - proxyRect.width}px`;
                    break;
                case 'top':
                    wrapperStyle.top = '0px';
                    break;
            }

            dialog.wrapperStyle = wrapperStyle;
        } else { // drop the dialog fully into the dragEnd window
            me.mountDialogInOtherWindow({
                fullyIncludeIntoWindow: true,
                proxyRect
            })
        }
    }

    /**
     * @param {Boolean} enable=true
     */
    enableOpenDialogButtons(enable=true) {
        this.getOpenDialogButtons().forEach(button => {
            button.disabled = !enable
        })
    }

    /**
     * @return {Neo.button.Base}
     */
    getOpenDockedWindowButton() {
        return this.component.down({iconCls: 'far fa-window-restore'})
    }

    /**
     *
     */
    getOpenDialogButtons() {
        return _src_manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find({flag: 'open-dialog-button'})
    }

    /**
     * @param {String} side
     * @return {String}
     */
    getOppositeSide(side) {
        return {
            bottom: 'top',
            left  : 'right',
            right : 'left',
            top   : 'bottom'
        }[side]
    }

    /**
     * @param {Object} proxyRect
     * @param {String} side
     * @param {Boolean} [fullyIncludeIntoWindow=false]
     * @return {{left: String, top: String}}
     */
    getProxyPosition(proxyRect, side, fullyIncludeIntoWindow=false) {
        let me                                      = this,
            {dragStartWindowRect, targetWindowSize} = me,
            left, top;

        switch (side) {
            case 'bottom':
                left = `${proxyRect.left}px`;
                top  = `${fullyIncludeIntoWindow ? 0 : proxyRect.top - dragStartWindowRect.height}px`;
                break;
            case 'left':
                left = `${fullyIncludeIntoWindow ? targetWindowSize - proxyRect.width : targetWindowSize + proxyRect.left}px`;
                top  = `${proxyRect.top}px`;
                break;
            case 'right':
                left = `${fullyIncludeIntoWindow ? 0 : proxyRect.left - dragStartWindowRect.width}px`;
                top  = `${proxyRect.top}px`;
                break;
            case 'top':
                left = `${proxyRect.left}px`;
                top  = `${fullyIncludeIntoWindow ? targetWindowSize - proxyRect.height : targetWindowSize + proxyRect.top}px`;
                break;
        }

        return {left, top}
    }

    /**
     * @return {Boolean}
     */
    hasDockedWindow() {
        return this.connectedApps.includes(this.dockedWindowAppName)
    }

    /**
     * @param {Object} data
     * @param {Object} data.proxyRect
     * @param {Boolean} [data.fullyIncludeIntoWindow]
     */
    mountDialogInOtherWindow(data) {
        let me                   = this,
            {appName, windowId}  = me.component,
            dialog               = me.dialog,
            dragEndWindowAppName = me.dockedWindowAppName,
            dragEndWindowId      = me.dockedWindowId,
            side                 = me.dockedWindowSide,
            needsSwitch, proxyPosition, wrapperStyle;

        if (dialog.appName === dragEndWindowAppName) {
            dragEndWindowAppName = appName;
            dragEndWindowId      = windowId;
            side                 = me.getOppositeSide(me.dockedWindowSide)
        }

        proxyPosition = me.getProxyPosition(data.proxyRect, side, data.fullyIncludeIntoWindow);

        dialog.unmount();

        // we need a delay to ensure dialog.Base: onDragEnd() is done.
        // we could use the dragEnd event of the dragZone instead.
        me.timeout(70).then(() => {
            needsSwitch = dialog.appName === dragEndWindowAppName;

            dialog.appName  = needsSwitch ? appName  : dragEndWindowAppName;
            dialog.windowId = needsSwitch ? windowId : dragEndWindowId;

            me.getOpenDialogButtons().forEach(button => {
                if (button.appName === dialog.appName) {
                    dialog.animateTargetId = button.id
                }
            });

            wrapperStyle = dialog.wrapperStyle;

            wrapperStyle.left = proxyPosition.left;
            wrapperStyle.top  = proxyPosition.top;

            dialog.wrapperStyle = wrapperStyle;

            me.destroyDockedWindowProxy();

            dialog.mount()
        })
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     * @param {Number} data.windowId
     */
    onAppConnect(data) {
        let me                  = this,
            {appName, windowId} = data;

        _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(me.connectedApps, appName);

        if (appName !== 'SharedDialog' && me.currentTheme !== 'neo-theme-light') {
            me.switchThemeForApp(windowId)
        }

        if (appName === me.dockedWindowAppName) {
            me.dockedWindowId = data.windowId;
            me.getOpenDockedWindowButton().disabled = true
        }

        me.enableOpenDialogButtons(!me.dialog)
    }

    /**
     * @param {Object} data
     * @param {String} data.appName
     */
    onAppDisconnect(data) {
        let me                                = this,
            {connectedApps, dialog, windowId} = me,
            name                              = data.appName;

        if (name === 'SharedDialog') {
            // we want to close all popup windows, which equals to all connected apps minus the main app
            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(connectedApps, 'SharedDialog');

            Neo.Main.windowClose({
                names: connectedApps,
                windowId
            })
        } if (name === me.dockedWindowAppName) {
            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(connectedApps, name);

            Neo.main.addon.WindowPosition.unregisterWindow({name, windowId});

            if (dialog && dialog.windowId !== windowId) {
                me.enableOpenDialogButtons()
            }

            me.getOpenDockedWindowButton().disabled = false
        }
    }

    /**
     * The App worker will receive connect & disconnect events inside the SharedWorkers context
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onAppConnect,
            disconnect: me.onAppDisconnect,
            scope     : me
        })
    }

    /**
     * @param {Object} data
     */
    onCreateDialogButtonClick(data) {
        this.createDialog(data, this.component.appName)
    }

    /**
     *
     */
    onDialogClose() {
        this.enableOpenDialogButtons(true);
        this.dialog = null
    }

    /**
     * @param {Object} data
     */
    onDockedPositionChange(data) {
        this.dockedWindowSide = data.value
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.hasDockedWindow()) {
            let me        = this,
                {dialog, dragStartWindowRect} = me,
                proxyRect = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].moveTo(me.dialogRect, data.clientX - data.offsetX, data.clientY - data.offsetY),
                side      = me.dockedWindowSide;

            if (dialog.appName === me.dockedWindowAppName) {
                side = me.getOppositeSide(me.dockedWindowSide)
            }

            if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].leavesSide(dragStartWindowRect, proxyRect, side)) {
                if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].excludes(dragStartWindowRect, proxyRect)) {
                    me.mountDialogInOtherWindow({proxyRect})
                } else {
                    me.dropDialogBetweenWindows(proxyRect)
                }
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragMove(data) {
        if (this.hasDockedWindow()) {
            let me        = this,
                {dialogRect, dragStartWindowRect, dockedWindowAppName, dockedWindowId} = me,
                proxyRect = _src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].moveTo(dialogRect, data.clientX - data.offsetX, data.clientY - data.offsetY),
                side      = me.dockedWindowSide,
                proxyPosition, vdom;

            // in case we trigger the drag:start inside the docked window,
            // we can keep the same logic with just flipping the side.
            if (me.dialog.appName === dockedWindowAppName) {
                dockedWindowAppName = me.component.appName;
                dockedWindowId      = me.component.windowId;
                side                = me.getOppositeSide(me.dockedWindowSide);
            }

            if (_src_util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].leavesSide(dragStartWindowRect, proxyRect, side)) {
                proxyPosition = me.getProxyPosition(proxyRect, side);

                if (!me.dockedWindowProxy) {
                    vdom = Neo.clone(me.dialog.dragZone.dragProxy.vdom, true);

                    delete vdom.id;

                    Object.assign(vdom.style, {
                        ...proxyPosition,
                        transform         : 'none',
                        transitionProperty: 'none'
                    });

                    me.dockedWindowProxy = Neo.create({
                        module          : _src_draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                        appName         : dockedWindowAppName,
                        cls             : ['neo-dialog', 'neo-panel', 'neo-container'],
                        moveInMainThread: false,
                        vdom            : vdom,
                        windowId        : dockedWindowId
                    });

                    // The other window has most likely not loaded The dialog JS module yet,
                    // but the drag proxy is using some CSS rules of it.
                    // todo: a new helper method to parse an existing instance based on its cmp tree for theme files
                    Neo.currentWorker.insertThemeFiles(dockedWindowId, Neo.dialog.Base.prototype);
                    Neo.currentWorker.insertThemeFiles(dockedWindowId, Neo.form.field.Text.prototype);
                    Neo.currentWorker.insertThemeFiles(dockedWindowId, Neo.form.field.trigger.Clear.prototype);
                    Neo.currentWorker.insertThemeFiles(dockedWindowId, Neo.draggable.DragProxyComponent.prototype)
                } else {
                    me.updateDockedWindowProxyStyle({
                        ...proxyPosition,
                        visibility: null
                    })
                }
            } else {
                me.updateDockedWindowProxyStyle({visibility: 'hidden'})
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragStart(data) {
        if (this.hasDockedWindow()) {
            let me               = this,
                {appName}        = me.component,
                dockedHorizontal = me.dockedWindowSide === 'left' || me.dockedWindowSide === 'right';

            me.dialogRect = data.dragElementRect;

            for (let item of data.eventData.path) {
                if (item.tagName === 'body') {
                    me.dragStartWindowRect = item.rect;
                    break
                }
            }

            if (me.hasDockedWindow()) {
                Neo.Main.getWindowData({
                    appName: me.dialog.appName === appName ? me.dockedWindowAppName : appName
                }).then(data => {
                    me.targetWindowSize = dockedHorizontal ? data.innerWidth : data.innerHeight
                })
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDragZoneCreated(data) {
        let me = this;

        data.dragZone.on({
            dragEnd  : me.onDragEnd,
            dragMove : me.onDragMove,
            dragStart: me.onDragStart,
            scope    : me
        })
    }

    /**
     * Creates a new popup window, which is initially docked to this.dockedWindowSide of the main window
     * @param {Object} handlerData
     */
    openDockedWindow(handlerData) {
        let {windowId} = this;

        Neo.Main.getWindowData({windowId}).then(data => {
            let me     = this,
                dock   = me.dockedWindowSide,
                size   = me.dockedWindowSize,
                height, left, top, width;

            switch (dock) {
                case 'bottom':
                    height = size;
                    left   = data.screenLeft;
                    top    = data.outerHeight + data.screenTop - 62;
                    width  = data.outerWidth;
                    break
                case 'left':
                    height = data.outerHeight - 86;
                    left   = data.screenLeft  - size;
                    top    = data.screenTop   + 24;
                    width  = size;
                    break
                case 'right':
                    height = data.outerHeight - 86;
                    left   = data.outerWidth  + data.screenLeft;
                    top    = data.screenTop   + 24;
                    width  = size;
                    break
                case 'top':
                    height = size;
                    left   = data.screenLeft;
                    top    = data.screenTop - size + 24;
                    width  = data.outerWidth;
                    break
            }

            Neo.Main.windowOpen({
                url           : 'childapps/shareddialog2/index.html',
                windowFeatures: `height=${height},left=${left},top=${top},width=${width}`,
                windowId,
                windowName    : me.dockedWindowAppName
            });

            Neo.main.addon.WindowPosition.registerWindow({
                dock,
                name: me.dockedWindowAppName,
                size,
                windowId
            })
        })
    }

    /**
     * Switches the theme for all connected apps
     * @param {Object} data
     */
    switchTheme(data) {
        let me         = this,
            button     = data.component,
            buttonText = 'Theme Light',
            dialog     = me.dialog,
            iconCls    = 'fa fa-sun',
            theme      = 'neo-theme-dark',
            cls;

        if (button.text === 'Theme Light') {
            buttonText = 'Theme Dark';
            iconCls    = 'fa fa-moon';
            theme      = 'neo-theme-light';
        }

        me.previousTheme = me.currentTheme;
        me.currentTheme  = theme;

        me.connectedApps.forEach(appName => {
            me.switchThemeForApp(Neo.apps[appName].windowId)
        });

        button.set({iconCls, text: buttonText});

        if (dialog) {
            cls = dialog.cls;

            _src_util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].removeAdd(cls, me.previousTheme, me.currentTheme);

            dialog.cls = cls
        }
    }

    /**
     * @param {Number} windowId
     */
    switchThemeForApp(windowId) {
        let {currentTheme, previousTheme} = this;

        Neo.main.DomAccess.setBodyCls({
            add    : [currentTheme],
            remove : previousTheme ? [previousTheme]: [],
            windowId
        })
    }

    /**
     * @param {Object} style
     */
    updateDockedWindowProxyStyle(style) {
        let dockedWindowProxy = this.dockedWindowProxy;

        if (dockedWindowProxy) {
            dockedWindowProxy.style = Object.assign(dockedWindowProxy.style || {}, style)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ }),

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ }),

/***/ "./src/container/Panel.mjs":
/*!*********************************!*\
  !*** ./src/container/Panel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");



/**
 * An extended Container supporting multiple docked header toolbars
 * @class Neo.container.Panel
 * @extends Neo.container.Base
 */
class Panel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Panel'
         * @protected
         */
        className: 'Neo.container.Panel',
        /**
         * @member {String} ntype='panel'
         * @protected
         */
        ntype: 'panel',
        /**
         * @member {String[]} baseCls=['neo-panel','neo-container']
         */
        baseCls: ['neo-panel', 'neo-container'],
        /**
         * @member {Object} containerConfig=null
         */
        containerConfig: null,
        /**
         * @member {Object} headerDefaults=null
         */
        headerDefaults: null,
        /**
         * @member {Array} headers=null
         */
        headers: null,
        /**
         * @member {Object} items={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        _layout: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Boolean} verticalHeadersFirst=false
         */
        verticalHeadersFirst: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.hasHeaders() && me.verticalHeadersFirst === true) {
            me.layout = {
                ntype: 'hbox',
                align: 'stretch'
            };
        }
    }

    /**
     * @param {Object} header the header config
     * @returns {Object}
     */
    static createHeaderConfig(header) {
        if (Neo.typeOf(header) === 'NeoInstance') {
            return header;
        }

        let config = {
            flex: '0 1 auto'
        };

        if (!header.module && !header.ntype) {
            config.cls   = ['neo-panel-header-toolbar', 'neo-toolbar'];
            config.ntype = 'toolbar';
        }

        if (header.text) {
            config.items = [{
                ntype: 'label',
                cls  : ['neo-panel-header-text', 'neo-label'],
                text : header.text
            }];

            delete header.text;
        }

        // assuming all labels inside a Panel Header are meant to be titles -> look the same way
        if (Array.isArray(header.items)) {
            header.items.forEach(item => {
                if (item.ntype === 'label') {
                    item.cls = ['neo-panel-header-text', 'neo-label'];
                }
            });
        }

        return {...config, ...header}
    }

    /**
     *
     */
    createItems() {
        let me              = this,
            containerConfig = me.containerConfig;

        if (!me.hasHeaders()) {
            containerConfig && me.set(containerConfig);
            super.createItems();
        } else {
            let hf                   = me.verticalHeadersFirst === false,
                headers              = me.headers || [],
                bottomHeaders        = headers.filter(header => {return header.dock === (hf ?'bottom': 'right')}),
                leftHeaders          = headers.filter(header => {return header.dock === (hf ?'left'  : 'top')}),
                rightHeaders         = headers.filter(header => {return header.dock === (hf ?'right' : 'bottom')}),
                topHeaders           = headers.filter(header => {return header.dock === (hf ?'top'   : 'left')}),
                hasHorizontalHeaders = bottomHeaders.length > 0 || topHeaders  .length > 0,
                hasVerticalHeaders   = leftHeaders  .length > 0 || rightHeaders.length > 0,
                {items}              = me,
                horizontalItems      = [],
                verticalItems        = [],
                config;

            topHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            if (hasVerticalHeaders && (hf && hasHorizontalHeaders || !hf && hasHorizontalHeaders)) {
                leftHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                horizontalItems.push({...me.headerDefaults, ...config});

                rightHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                verticalItems.push({
                    ntype    : 'container',
                    items    : horizontalItems,
                    layout   : {ntype: (hf ? 'hbox' : 'vbox'), align: 'stretch'},
                    reference: 'bodyContainer'
                });
            } else {
                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    reference   : 'bodyContainer',
                    ...containerConfig
                };

                verticalItems.push({...me.headerDefaults, ...config})
            }

            bottomHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            me.items = verticalItems;

            me.itemDefaults = null;

            super.createItems()
        }
    }

    /**
     * @returns {Boolean}
     */
    hasHeaders() {
        return Array.isArray(this.headers) && this.headers.length > 0
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Panel));


/***/ }),

/***/ "./src/container/Viewport.mjs":
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {appName, windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            appName,
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ }),

/***/ "./src/controller/Component.mjs":
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {Number|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/draggable/DragProxyComponent.mjs":
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyComponent));


/***/ }),

/***/ "./src/form/field/Radio.mjs":
/*!**********************************!*\
  !*** ./src/form/field/Radio.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * @class Neo.form.field.Radio
 * @extends Neo.form.field.CheckBox
 */
class Radio extends _CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Radio'
         * @protected
         */
        className: 'Neo.form.field.Radio',
        /**
         * @member {String} ntype='radiofield'
         * @protected
         */
        ntype: 'radiofield',
        /**
         * @member {String[]} baseCls=['neo-radiofield','neo-checkboxfield']
         */
        baseCls: ['neo-radiofield', 'neo-checkboxfield'],
        /**
         * @member {String[]} iconCls=['far','fa-circle']
         */
        iconCls: ['far', 'fa-circle'],
        /**
         * @member {String} inputType='radio'
         * @reactive
         */
        inputType: 'radio'
    }

    /**
     * Triggered after the checked config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetChecked(value, oldValue) {
        super.afterSetChecked(value, oldValue);

        // update radios with the same name to be unchecked
        value && this.uncheckGroupItems()
    }

    /**
     * Radios should only fire change & fieldChange events if checked.
     * If there was just 1 radio, you can not uncheck it.
     * @param {*} value
     * @param {*} oldValue
     */
    fireChangeEvent(value, oldValue) {
        this.checked && super.fireChangeEvent(value, oldValue)
    }

    /**
     * @returns {String[]}
     */
    getGroupValue() {
        let value = super.getGroupValue();

        return value.length > 0 ? value[0] : []
    }

    /**
     * Radios do not fire a change event for "uncheck", so we need to iterate over other radios with the same name.
     */
    uncheckGroupItems() {
        let me = this,
            radios;

        // discuss: we could limit this to radios inside the same form, IF a top level form is used
        radios = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].find({
            ntype: 'radiofield',
            name : me.name
        });

        radios.forEach(item => {
            if (item.id !== me.id && item._checked) {
                item.checked = false
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Radio));


/***/ }),

/***/ "./src/toolbar/Base.mjs":
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        },
        /**
         * @member {Boolean} sortable_=false
         * @reactive
         */
        sortable_: false,
        /**
         * @member {Neo.draggable.toolbar.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} sortZoneConfig=null
         */
        sortZoneConfig: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        if (this.sortZone) {
            this.sortZone.appName = value
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Triggered after the sortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSortable(value, oldValue) {
        let me = this;

        if (value && !me.sortZone) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_container_SortZone_mjs"), __webpack_require__.e("src_draggable_toolbar_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/toolbar/SortZone.mjs */ "./src/draggable/toolbar/SortZone.mjs")).then(module => {
                me.sortZone = Neo.create({
                    module             : module.default,
                    appName            : me.appName,
                    boundaryContainerId: me.id,
                    owner              : me,
                    windowId           : me.windowId,
                    ...me.sortZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        if (this.sortZone) {
            this.sortZone.windowId = value
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWFwcHNfc2hhcmVkZGlhbG9nX2FwcF9tanMtc3JjX2NvbnRhaW5lcl9QYW5lbF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7O0FBRTlDO0FBQ1AsY0FBYywrREFBYTtBQUMzQjtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTG9EO0FBQ0k7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsUUFBUSxjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFTO0FBQ2hDO0FBQ0EsU0FBUztBQUNULHVCQUF1QixnRUFBUztBQUNoQztBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlFQUFlLDBCQUEwQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hEeUI7QUFDSztBQUNKO0FBQ0E7QUFDTTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUVBQVE7QUFDcEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0Esb0JBQW9CLG9FQUF1QjtBQUMzQztBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQU87QUFDM0I7QUFDQTtBQUNBLHlCQUF5Qiw0REFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5QkFBeUIsNERBQU07QUFDL0I7QUFD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QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxrV0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLDJEQUFTLFdBQVc7QUFDNUQ7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9hcHBzL3NoYXJlZGRpYWxvZy9hcHAubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3NoYXJlZGRpYWxvZy92aWV3L0RlbW9EaWFsb2cubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3NoYXJlZGRpYWxvZy92aWV3L01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9hcHBzL3NoYXJlZGRpYWxvZy92aWV3L01haW5Db250YWluZXJDb250cm9sbGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9MYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvUGFuZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9EcmFnUHJveHlDb21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZm9ybS9maWVsZC9SYWRpby5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90b29sYmFyL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNYWluQ29udGFpbmVyIGZyb20gJy4vdmlldy9NYWluQ29udGFpbmVyLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvblN0YXJ0ID0gKCkgPT4gTmVvLmFwcCh7XG4gICAgbWFpblZpZXc6IE1haW5Db250YWluZXIsXG4gICAgbmFtZSAgICA6ICdTaGFyZWREaWFsb2cnXG59KTtcbiIsImltcG9ydCBEaWFsb2cgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2RpYWxvZy9CYXNlLm1qcyc7XG5pbXBvcnQgVGV4dEZpZWxkIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL1RleHQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgU2hhcmVkRGlhbG9nLnZpZXcuRGVtb0RpYWxvZ1xuICogQGV4dGVuZHMgTmVvLmRpYWxvZy5CYXNlXG4gKi9cbmNsYXNzIERlbW9EaWFsb2cgZXh0ZW5kcyBEaWFsb2cge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nU2hhcmVkRGlhbG9nLnZpZXcuRGVtb0RpYWxvZydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnU2hhcmVkRGlhbG9nLnZpZXcuRGVtb0RpYWxvZycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRpdGxlPSdEcmFnIG1lIGFjcm9zcyBXaW5kb3dzISdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZTogJ0RyYWcgbWUgYWNyb3NzIFdpbmRvd3MhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gY29udGFpbmVyQ29uZmlnPXtzdHlsZTpwYWRkaW5nOicyMHB4fX1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5lckNvbmZpZzoge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMjBweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtsYWJlbFdpZHRoOjcwfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgZmxleCAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgbGFiZWxXaWR0aDogNzBcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBpdGVtc1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ0ZpZWxkIDEnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnRmllbGQgMidcbiAgICAgICAgfV1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERlbW9EaWFsb2cpO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IFJhZGlvICAgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL1JhZGlvLm1qcyc7XG5pbXBvcnQgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMnO1xuaW1wb3J0IFRvb2xiYXIgICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy90b29sYmFyL0Jhc2UubWpzJztcbmltcG9ydCBWaWV3cG9ydCAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvY29udGFpbmVyL1ZpZXdwb3J0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIFNoYXJlZERpYWxvZy52aWV3Lk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuVmlld3BvcnRcbiAqL1xuY2xhc3MgTWFpbkNvbnRhaW5lciBleHRlbmRzIFZpZXdwb3J0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J1NoYXJlZERpYWxvZy52aWV3Lk1haW5Db250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ1NoYXJlZERpYWxvZy52aWV3Lk1haW5Db250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fSBjb250cm9sbGVyPU1haW5Db250YWluZXJDb250cm9sbGVyXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbGxlcjogTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX0gaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBUb29sYmFyLFxuICAgICAgICAgICAgZmxleCAgOiAnbm9uZScsXG4gICAgICAgICAgICBpdGVtcyA6W3tcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBCdXR0b24sXG4gICAgICAgICAgICAgICAgZmxhZyAgIDogJ29wZW4tZGlhbG9nLWJ1dHRvbicsXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogJ29uQ3JlYXRlRGlhbG9nQnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYXIgZmEtd2luZG93LW1heGltaXplJyxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnQ3JlYXRlIERpYWxvZycsXG4gICAgICAgICAgICB9LCAnLT4nLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6ICdzd2l0Y2hUaGVtZScsXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLW1vb24nLFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdUaGVtZSBEYXJrJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiAnb3BlbkRvY2tlZFdpbmRvdycsXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhciBmYS13aW5kb3ctcmVzdG9yZScsXG4gICAgICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpbkxlZnQ6ICcxZW0nfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnT3BlbiBkb2NrZWQgV2luZG93J1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbnR5cGUgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgIGZsZXggIDogJ25vbmUnLFxuICAgICAgICAgICAgbGF5b3V0OiAnaGJveCcsXG5cbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICA6ICc3MnB4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzFlbScsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wICA6ICcxZW0nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpdGVtcyA6IFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgICAgIGZsZXggOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgIGZsZXggOiAnbm9uZScsXG5cbiAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICA6IFJhZGlvLFxuICAgICAgICAgICAgICAgICAgICBoaWRlVmFsdWVMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxXaWR0aCAgICA6IDUwLFxuICAgICAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgIDogJ2RvY2tlZFBvc2l0aW9uJyxcblxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogJ29uRG9ja2VkUG9zaXRpb25DaGFuZ2UnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dCA6ICdEb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMYWJlbDogJ1RvcCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICA6ICd0b3AnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsOiAnUmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgOiAncmlnaHQnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsOiAnQm90dG9tJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgIDogJ2JvdHRvbSdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTGFiZWw6ICdMZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgIDogJ2xlZnQnXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgIGZsZXggOiAxLFxuICAgICAgICAgICAgdGV4dCA6ICcjMScsXG5cbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtcyAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGNvbG9yICAgICAgICAgOiAnI2JiYicsXG4gICAgICAgICAgICAgICAgZGlzcGxheSAgICAgICA6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZSAgICAgIDogJzIwMHB4JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tICA6ICc4OHB4JyxcbiAgICAgICAgICAgICAgICB1c2VyU2VsZWN0ICAgIDogJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOid2Ym94JyxhbGlnbjonc3RyZXRjaCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHN0eWxlPXtwYWRkaW5nOicyMHB4J31cbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlOiB7cGFkZGluZzogJzIwcHgnfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29udHJvbGxlciBmcm9tICcuLi8uLi8uLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyICAgIGZyb20gJy4uLy4uLy4uL3NyYy9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IERlbW9EaWFsb2cgICAgICAgICAgZnJvbSAnLi9EZW1vRGlhbG9nLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29tcG9uZW50ICBmcm9tICcuLi8uLi8uLi9zcmMvZHJhZ2dhYmxlL0RyYWdQcm94eUNvbXBvbmVudC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy91dGlsL1JlY3RhbmdsZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBTaGFyZWREaWFsb2cudmlldy5NYWluQ29udGFpbmVyQ29udHJvbGxlclxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXJDb250cm9sbGVyIGV4dGVuZHMgQ29tcG9uZW50Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdTaGFyZWREaWFsb2cudmlldy5NYWluQ29udGFpbmVyQ29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnU2hhcmVkRGlhbG9nLnZpZXcuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzOiBib3R0b20sIGxlZnQsIHJpZ2h0LCB0b3BcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkb2NrZWRXaW5kb3dTaWRlXz0ncmlnaHQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZG9ja2VkV2luZG93U2lkZV86ICdyaWdodCcsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGNvbm5lY3RlZEFwcHM9W11cbiAgICAgKi9cbiAgICBjb25uZWN0ZWRBcHBzID0gW11cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGN1cnJlbnRUaGVtZT0nbmVvLXRoZW1lLWxpZ2h0J1xuICAgICAqL1xuICAgIGN1cnJlbnRUaGVtZSA9ICduZW8tdGhlbWUtbGlnaHQnXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U3RyaW5nfSBkb2NrZWRXaW5kb3dBcHBOYW1lPSdTaGFyZWREaWFsb2cyJ1xuICAgICAqL1xuICAgIGRvY2tlZFdpbmRvd0FwcE5hbWUgPSAnU2hhcmVkRGlhbG9nMidcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gZG9ja2VkV2luZG93SWQ9bnVsbFxuICAgICAqL1xuICAgIGRvY2tlZFdpbmRvd0lkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBkb2NrZWRXaW5kb3dQcm94eT1udWxsXG4gICAgICovXG4gICAgZG9ja2VkV2luZG93UHJveHkgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfSBkb2NrZWRXaW5kb3dTaXplPTUwMFxuICAgICAqL1xuICAgIGRvY2tlZFdpbmRvd1NpemUgPSA2MjBcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRpYWxvZ1JlY3Q9bnVsbFxuICAgICAqL1xuICAgIGRpYWxvZ1JlY3QgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBkcmFnU3RhcnRXaW5kb3dSZWN0PW51bGxcbiAgICAgKi9cbiAgICBkcmFnU3RhcnRXaW5kb3dSZWN0ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBwcmV2aW91c1RoZW1lPW51bGxcbiAgICAgKi9cbiAgICBwcmV2aW91c1RoZW1lID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB0YXJnZXRXaW5kb3dTaXplPTBcbiAgICAgKi9cbiAgICB0YXJnZXRXaW5kb3dTaXplID0gMFxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkb2NrZWRXaW5kb3dTaWRlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERvY2tlZFdpbmRvd1NpZGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0RvY2tlZFdpbmRvdygpKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5XaW5kb3dQb3NpdGlvbi5zZXREb2NrKHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmRvY2tlZFdpbmRvd0FwcE5hbWUsXG4gICAgICAgICAgICAgICAgZG9jazogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBOYW1lXG4gICAgICovXG4gICAgY3JlYXRlRGlhbG9nKGRhdGEsIGFwcE5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3dpbmRvd0lkfSA9IG1lO1xuXG4gICAgICAgIG1lLmVuYWJsZU9wZW5EaWFsb2dCdXR0b25zKGZhbHNlKTtcblxuICAgICAgICBtZS5kaWFsb2cgPSBOZW8uY3JlYXRlKERlbW9EaWFsb2csIHtcbiAgICAgICAgICAgIGFuaW1hdGVUYXJnZXRJZCAgICA6IGRhdGEuY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgICAgOiBbbWUuY3VycmVudFRoZW1lXSxcbiAgICAgICAgICAgIGhlaWdodCAgICAgICAgICAgICA6IDIwMCxcbiAgICAgICAgICAgIHdpZHRoICAgICAgICAgICAgICA6IDMwMCxcbiAgICAgICAgICAgIHdpbmRvd0lkLFxuXG4gICAgICAgICAgICBkcmFnWm9uZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGFsd2F5c0ZpcmVEcmFnTW92ZTogdHJ1ZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgY2xvc2UgICAgICAgICAgOiBtZS5vbkRpYWxvZ0Nsb3NlLFxuICAgICAgICAgICAgICAgIGRyYWdab25lQ3JlYXRlZDogbWUub25EcmFnWm9uZUNyZWF0ZWQsXG4gICAgICAgICAgICAgICAgc2NvcGUgICAgICAgICAgOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveURvY2tlZFdpbmRvd1Byb3h5KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5kb2NrZWRXaW5kb3dQcm94eSkge1xuICAgICAgICAgICAgbWUuZG9ja2VkV2luZG93UHJveHkuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgIG1lLmRvY2tlZFdpbmRvd1Byb3h5ID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3h5UmVjdFxuICAgICAqL1xuICAgIGRyb3BEaWFsb2dCZXR3ZWVuV2luZG93cyhwcm94eVJlY3QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGlhbG9nICAgICAgICAgICA9IG1lLmRpYWxvZyxcbiAgICAgICAgICAgIGludGVyc2VjdGlvbiAgICAgPSBSZWN0YW5nbGUuZ2V0SW50ZXJzZWN0aW9uKG1lLmRyYWdTdGFydFdpbmRvd1JlY3QsIHByb3h5UmVjdCksXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25TaXplID0gaW50ZXJzZWN0aW9uPy5oZWlnaHQgKiBpbnRlcnNlY3Rpb24/LndpZHRoLFxuICAgICAgICAgICAgc2lkZSAgICAgICAgICAgICA9IG1lLmRvY2tlZFdpbmRvd1NpZGUsXG4gICAgICAgICAgICBzaXplICAgICAgICAgICAgID0gcHJveHlSZWN0LmhlaWdodCAqIHByb3h5UmVjdC53aWR0aCxcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZTtcblxuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uU2l6ZSA+IHNpemUgLyAyKSB7IC8vIGRyb3AgdGhlIGRpYWxvZyBmdWxseSBpbnRvIHRoZSBkcmFnU3RhcnQgd2luZG93XG4gICAgICAgICAgICBtZS5kZXN0cm95RG9ja2VkV2luZG93UHJveHkoKTtcblxuICAgICAgICAgICAgd3JhcHBlclN0eWxlID0gZGlhbG9nLndyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgaWYgKGRpYWxvZy5hcHBOYW1lID09PSBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lKSB7XG4gICAgICAgICAgICAgICAgc2lkZSA9IG1lLmdldE9wcG9zaXRlU2lkZShzaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLnRvcCA9IGAke21lLmRyYWdTdGFydFdpbmRvd1JlY3QuaGVpZ2h0IC0gcHJveHlSZWN0LmhlaWdodH1weGA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gYCR7bWUuZHJhZ1N0YXJ0V2luZG93UmVjdC53aWR0aCAtIHByb3h5UmVjdC53aWR0aH1weGA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpYWxvZy53cmFwcGVyU3R5bGUgPSB3cmFwcGVyU3R5bGU7XG4gICAgICAgIH0gZWxzZSB7IC8vIGRyb3AgdGhlIGRpYWxvZyBmdWxseSBpbnRvIHRoZSBkcmFnRW5kIHdpbmRvd1xuICAgICAgICAgICAgbWUubW91bnREaWFsb2dJbk90aGVyV2luZG93KHtcbiAgICAgICAgICAgICAgICBmdWxseUluY2x1ZGVJbnRvV2luZG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3h5UmVjdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlPXRydWVcbiAgICAgKi9cbiAgICBlbmFibGVPcGVuRGlhbG9nQnV0dG9ucyhlbmFibGU9dHJ1ZSkge1xuICAgICAgICB0aGlzLmdldE9wZW5EaWFsb2dCdXR0b25zKCkuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gIWVuYWJsZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge05lby5idXR0b24uQmFzZX1cbiAgICAgKi9cbiAgICBnZXRPcGVuRG9ja2VkV2luZG93QnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZG93bih7aWNvbkNsczogJ2ZhciBmYS13aW5kb3ctcmVzdG9yZSd9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0T3BlbkRpYWxvZ0J1dHRvbnMoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLmZpbmQoe2ZsYWc6ICdvcGVuLWRpYWxvZy1idXR0b24nfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRPcHBvc2l0ZVNpZGUoc2lkZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYm90dG9tOiAndG9wJyxcbiAgICAgICAgICAgIGxlZnQgIDogJ3JpZ2h0JyxcbiAgICAgICAgICAgIHJpZ2h0IDogJ2xlZnQnLFxuICAgICAgICAgICAgdG9wICAgOiAnYm90dG9tJ1xuICAgICAgICB9W3NpZGVdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3h5UmVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZnVsbHlJbmNsdWRlSW50b1dpbmRvdz1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHt7bGVmdDogU3RyaW5nLCB0b3A6IFN0cmluZ319XG4gICAgICovXG4gICAgZ2V0UHJveHlQb3NpdGlvbihwcm94eVJlY3QsIHNpZGUsIGZ1bGx5SW5jbHVkZUludG9XaW5kb3c9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZHJhZ1N0YXJ0V2luZG93UmVjdCwgdGFyZ2V0V2luZG93U2l6ZX0gPSBtZSxcbiAgICAgICAgICAgIGxlZnQsIHRvcDtcblxuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGAke3Byb3h5UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgICAgICB0b3AgID0gYCR7ZnVsbHlJbmNsdWRlSW50b1dpbmRvdyA/IDAgOiBwcm94eVJlY3QudG9wIC0gZHJhZ1N0YXJ0V2luZG93UmVjdC5oZWlnaHR9cHhgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGAke2Z1bGx5SW5jbHVkZUludG9XaW5kb3cgPyB0YXJnZXRXaW5kb3dTaXplIC0gcHJveHlSZWN0LndpZHRoIDogdGFyZ2V0V2luZG93U2l6ZSArIHByb3h5UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgICAgICB0b3AgID0gYCR7cHJveHlSZWN0LnRvcH1weGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGAke2Z1bGx5SW5jbHVkZUludG9XaW5kb3cgPyAwIDogcHJveHlSZWN0LmxlZnQgLSBkcmFnU3RhcnRXaW5kb3dSZWN0LndpZHRofXB4YDtcbiAgICAgICAgICAgICAgICB0b3AgID0gYCR7cHJveHlSZWN0LnRvcH1weGA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBgJHtwcm94eVJlY3QubGVmdH1weGA7XG4gICAgICAgICAgICAgICAgdG9wICA9IGAke2Z1bGx5SW5jbHVkZUludG9XaW5kb3cgPyB0YXJnZXRXaW5kb3dTaXplIC0gcHJveHlSZWN0LmhlaWdodCA6IHRhcmdldFdpbmRvd1NpemUgKyBwcm94eVJlY3QudG9wfXB4YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7bGVmdCwgdG9wfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzRG9ja2VkV2luZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRBcHBzLmluY2x1ZGVzKHRoaXMuZG9ja2VkV2luZG93QXBwTmFtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnByb3h5UmVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEuZnVsbHlJbmNsdWRlSW50b1dpbmRvd11cbiAgICAgKi9cbiAgICBtb3VudERpYWxvZ0luT3RoZXJXaW5kb3coZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIHdpbmRvd0lkfSAgPSBtZS5jb21wb25lbnQsXG4gICAgICAgICAgICBkaWFsb2cgICAgICAgICAgICAgICA9IG1lLmRpYWxvZyxcbiAgICAgICAgICAgIGRyYWdFbmRXaW5kb3dBcHBOYW1lID0gbWUuZG9ja2VkV2luZG93QXBwTmFtZSxcbiAgICAgICAgICAgIGRyYWdFbmRXaW5kb3dJZCAgICAgID0gbWUuZG9ja2VkV2luZG93SWQsXG4gICAgICAgICAgICBzaWRlICAgICAgICAgICAgICAgICA9IG1lLmRvY2tlZFdpbmRvd1NpZGUsXG4gICAgICAgICAgICBuZWVkc1N3aXRjaCwgcHJveHlQb3NpdGlvbiwgd3JhcHBlclN0eWxlO1xuXG4gICAgICAgIGlmIChkaWFsb2cuYXBwTmFtZSA9PT0gZHJhZ0VuZFdpbmRvd0FwcE5hbWUpIHtcbiAgICAgICAgICAgIGRyYWdFbmRXaW5kb3dBcHBOYW1lID0gYXBwTmFtZTtcbiAgICAgICAgICAgIGRyYWdFbmRXaW5kb3dJZCAgICAgID0gd2luZG93SWQ7XG4gICAgICAgICAgICBzaWRlICAgICAgICAgICAgICAgICA9IG1lLmdldE9wcG9zaXRlU2lkZShtZS5kb2NrZWRXaW5kb3dTaWRlKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJveHlQb3NpdGlvbiA9IG1lLmdldFByb3h5UG9zaXRpb24oZGF0YS5wcm94eVJlY3QsIHNpZGUsIGRhdGEuZnVsbHlJbmNsdWRlSW50b1dpbmRvdyk7XG5cbiAgICAgICAgZGlhbG9nLnVubW91bnQoKTtcblxuICAgICAgICAvLyB3ZSBuZWVkIGEgZGVsYXkgdG8gZW5zdXJlIGRpYWxvZy5CYXNlOiBvbkRyYWdFbmQoKSBpcyBkb25lLlxuICAgICAgICAvLyB3ZSBjb3VsZCB1c2UgdGhlIGRyYWdFbmQgZXZlbnQgb2YgdGhlIGRyYWdab25lIGluc3RlYWQuXG4gICAgICAgIG1lLnRpbWVvdXQoNzApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbmVlZHNTd2l0Y2ggPSBkaWFsb2cuYXBwTmFtZSA9PT0gZHJhZ0VuZFdpbmRvd0FwcE5hbWU7XG5cbiAgICAgICAgICAgIGRpYWxvZy5hcHBOYW1lICA9IG5lZWRzU3dpdGNoID8gYXBwTmFtZSAgOiBkcmFnRW5kV2luZG93QXBwTmFtZTtcbiAgICAgICAgICAgIGRpYWxvZy53aW5kb3dJZCA9IG5lZWRzU3dpdGNoID8gd2luZG93SWQgOiBkcmFnRW5kV2luZG93SWQ7XG5cbiAgICAgICAgICAgIG1lLmdldE9wZW5EaWFsb2dCdXR0b25zKCkuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChidXR0b24uYXBwTmFtZSA9PT0gZGlhbG9nLmFwcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmFuaW1hdGVUYXJnZXRJZCA9IGJ1dHRvbi5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSBkaWFsb2cud3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IHByb3h5UG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS50b3AgID0gcHJveHlQb3NpdGlvbi50b3A7XG5cbiAgICAgICAgICAgIGRpYWxvZy53cmFwcGVyU3R5bGUgPSB3cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgIG1lLmRlc3Ryb3lEb2NrZWRXaW5kb3dQcm94eSgpO1xuXG4gICAgICAgICAgICBkaWFsb2cubW91bnQoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25BcHBDb25uZWN0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIHdpbmRvd0lkfSA9IGRhdGE7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKG1lLmNvbm5lY3RlZEFwcHMsIGFwcE5hbWUpO1xuXG4gICAgICAgIGlmIChhcHBOYW1lICE9PSAnU2hhcmVkRGlhbG9nJyAmJiBtZS5jdXJyZW50VGhlbWUgIT09ICduZW8tdGhlbWUtbGlnaHQnKSB7XG4gICAgICAgICAgICBtZS5zd2l0Y2hUaGVtZUZvckFwcCh3aW5kb3dJZClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcHBOYW1lID09PSBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lKSB7XG4gICAgICAgICAgICBtZS5kb2NrZWRXaW5kb3dJZCA9IGRhdGEud2luZG93SWQ7XG4gICAgICAgICAgICBtZS5nZXRPcGVuRG9ja2VkV2luZG93QnV0dG9uKCkuZGlzYWJsZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBtZS5lbmFibGVPcGVuRGlhbG9nQnV0dG9ucyghbWUuZGlhbG9nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuYXBwTmFtZVxuICAgICAqL1xuICAgIG9uQXBwRGlzY29ubmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nvbm5lY3RlZEFwcHMsIGRpYWxvZywgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICBuYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBkYXRhLmFwcE5hbWU7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdTaGFyZWREaWFsb2cnKSB7XG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGNsb3NlIGFsbCBwb3B1cCB3aW5kb3dzLCB3aGljaCBlcXVhbHMgdG8gYWxsIGNvbm5lY3RlZCBhcHBzIG1pbnVzIHRoZSBtYWluIGFwcFxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNvbm5lY3RlZEFwcHMsICdTaGFyZWREaWFsb2cnKTtcblxuICAgICAgICAgICAgTmVvLk1haW4ud2luZG93Q2xvc2Uoe1xuICAgICAgICAgICAgICAgIG5hbWVzOiBjb25uZWN0ZWRBcHBzLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGlmIChuYW1lID09PSBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY29ubmVjdGVkQXBwcywgbmFtZSk7XG5cbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLldpbmRvd1Bvc2l0aW9uLnVucmVnaXN0ZXJXaW5kb3coe25hbWUsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgICAgIGlmIChkaWFsb2cgJiYgZGlhbG9nLndpbmRvd0lkICE9PSB3aW5kb3dJZCkge1xuICAgICAgICAgICAgICAgIG1lLmVuYWJsZU9wZW5EaWFsb2dCdXR0b25zKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZ2V0T3BlbkRvY2tlZFdpbmRvd0J1dHRvbigpLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBBcHAgd29ya2VyIHdpbGwgcmVjZWl2ZSBjb25uZWN0ICYgZGlzY29ubmVjdCBldmVudHMgaW5zaWRlIHRoZSBTaGFyZWRXb3JrZXJzIGNvbnRleHRcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5vbih7XG4gICAgICAgICAgICBjb25uZWN0ICAgOiBtZS5vbkFwcENvbm5lY3QsXG4gICAgICAgICAgICBkaXNjb25uZWN0OiBtZS5vbkFwcERpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DcmVhdGVEaWFsb2dCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlRGlhbG9nKGRhdGEsIHRoaXMuY29tcG9uZW50LmFwcE5hbWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRpYWxvZ0Nsb3NlKCkge1xuICAgICAgICB0aGlzLmVuYWJsZU9wZW5EaWFsb2dCdXR0b25zKHRydWUpO1xuICAgICAgICB0aGlzLmRpYWxvZyA9IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRG9ja2VkUG9zaXRpb25DaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmRvY2tlZFdpbmRvd1NpZGUgPSBkYXRhLnZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oYXNEb2NrZWRXaW5kb3coKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2RpYWxvZywgZHJhZ1N0YXJ0V2luZG93UmVjdH0gPSBtZSxcbiAgICAgICAgICAgICAgICBwcm94eVJlY3QgPSBSZWN0YW5nbGUubW92ZVRvKG1lLmRpYWxvZ1JlY3QsIGRhdGEuY2xpZW50WCAtIGRhdGEub2Zmc2V0WCwgZGF0YS5jbGllbnRZIC0gZGF0YS5vZmZzZXRZKSxcbiAgICAgICAgICAgICAgICBzaWRlICAgICAgPSBtZS5kb2NrZWRXaW5kb3dTaWRlO1xuXG4gICAgICAgICAgICBpZiAoZGlhbG9nLmFwcE5hbWUgPT09IG1lLmRvY2tlZFdpbmRvd0FwcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBzaWRlID0gbWUuZ2V0T3Bwb3NpdGVTaWRlKG1lLmRvY2tlZFdpbmRvd1NpZGUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChSZWN0YW5nbGUubGVhdmVzU2lkZShkcmFnU3RhcnRXaW5kb3dSZWN0LCBwcm94eVJlY3QsIHNpZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFJlY3RhbmdsZS5leGNsdWRlcyhkcmFnU3RhcnRXaW5kb3dSZWN0LCBwcm94eVJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1vdW50RGlhbG9nSW5PdGhlcldpbmRvdyh7cHJveHlSZWN0fSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5kcm9wRGlhbG9nQmV0d2VlbldpbmRvd3MocHJveHlSZWN0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0RvY2tlZFdpbmRvdygpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7ZGlhbG9nUmVjdCwgZHJhZ1N0YXJ0V2luZG93UmVjdCwgZG9ja2VkV2luZG93QXBwTmFtZSwgZG9ja2VkV2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICAgICAgcHJveHlSZWN0ID0gUmVjdGFuZ2xlLm1vdmVUbyhkaWFsb2dSZWN0LCBkYXRhLmNsaWVudFggLSBkYXRhLm9mZnNldFgsIGRhdGEuY2xpZW50WSAtIGRhdGEub2Zmc2V0WSksXG4gICAgICAgICAgICAgICAgc2lkZSAgICAgID0gbWUuZG9ja2VkV2luZG93U2lkZSxcbiAgICAgICAgICAgICAgICBwcm94eVBvc2l0aW9uLCB2ZG9tO1xuXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlIHRyaWdnZXIgdGhlIGRyYWc6c3RhcnQgaW5zaWRlIHRoZSBkb2NrZWQgd2luZG93LFxuICAgICAgICAgICAgLy8gd2UgY2FuIGtlZXAgdGhlIHNhbWUgbG9naWMgd2l0aCBqdXN0IGZsaXBwaW5nIHRoZSBzaWRlLlxuICAgICAgICAgICAgaWYgKG1lLmRpYWxvZy5hcHBOYW1lID09PSBkb2NrZWRXaW5kb3dBcHBOYW1lKSB7XG4gICAgICAgICAgICAgICAgZG9ja2VkV2luZG93QXBwTmFtZSA9IG1lLmNvbXBvbmVudC5hcHBOYW1lO1xuICAgICAgICAgICAgICAgIGRvY2tlZFdpbmRvd0lkICAgICAgPSBtZS5jb21wb25lbnQud2luZG93SWQ7XG4gICAgICAgICAgICAgICAgc2lkZSAgICAgICAgICAgICAgICA9IG1lLmdldE9wcG9zaXRlU2lkZShtZS5kb2NrZWRXaW5kb3dTaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFJlY3RhbmdsZS5sZWF2ZXNTaWRlKGRyYWdTdGFydFdpbmRvd1JlY3QsIHByb3h5UmVjdCwgc2lkZSkpIHtcbiAgICAgICAgICAgICAgICBwcm94eVBvc2l0aW9uID0gbWUuZ2V0UHJveHlQb3NpdGlvbihwcm94eVJlY3QsIHNpZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5kb2NrZWRXaW5kb3dQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICB2ZG9tID0gTmVvLmNsb25lKG1lLmRpYWxvZy5kcmFnWm9uZS5kcmFnUHJveHkudmRvbSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZkb20uaWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wcm94eVBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5kb2NrZWRXaW5kb3dQcm94eSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgIDogRHJhZ1Byb3h5Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgIDogZG9ja2VkV2luZG93QXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyAgICAgICAgICAgICA6IFsnbmVvLWRpYWxvZycsICduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZUluTWFpblRocmVhZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZG9tICAgICAgICAgICAgOiB2ZG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SWQgICAgICAgIDogZG9ja2VkV2luZG93SWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG90aGVyIHdpbmRvdyBoYXMgbW9zdCBsaWtlbHkgbm90IGxvYWRlZCBUaGUgZGlhbG9nIEpTIG1vZHVsZSB5ZXQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgZHJhZyBwcm94eSBpcyB1c2luZyBzb21lIENTUyBydWxlcyBvZiBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogYSBuZXcgaGVscGVyIG1ldGhvZCB0byBwYXJzZSBhbiBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBpdHMgY21wIHRyZWUgZm9yIHRoZW1lIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXMoZG9ja2VkV2luZG93SWQsIE5lby5kaWFsb2cuQmFzZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKGRvY2tlZFdpbmRvd0lkLCBOZW8uZm9ybS5maWVsZC5UZXh0LnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXMoZG9ja2VkV2luZG93SWQsIE5lby5mb3JtLmZpZWxkLnRyaWdnZXIuQ2xlYXIucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyhkb2NrZWRXaW5kb3dJZCwgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZURvY2tlZFdpbmRvd1Byb3h5U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJveHlQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZURvY2tlZFdpbmRvd1Byb3h5U3R5bGUoe3Zpc2liaWxpdHk6ICdoaWRkZW4nfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oYXNEb2NrZWRXaW5kb3coKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHthcHBOYW1lfSAgICAgICAgPSBtZS5jb21wb25lbnQsXG4gICAgICAgICAgICAgICAgZG9ja2VkSG9yaXpvbnRhbCA9IG1lLmRvY2tlZFdpbmRvd1NpZGUgPT09ICdsZWZ0JyB8fCBtZS5kb2NrZWRXaW5kb3dTaWRlID09PSAncmlnaHQnO1xuXG4gICAgICAgICAgICBtZS5kaWFsb2dSZWN0ID0gZGF0YS5kcmFnRWxlbWVudFJlY3Q7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgZGF0YS5ldmVudERhdGEucGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhZ05hbWUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgICAgICBtZS5kcmFnU3RhcnRXaW5kb3dSZWN0ID0gaXRlbS5yZWN0O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLmhhc0RvY2tlZFdpbmRvdygpKSB7XG4gICAgICAgICAgICAgICAgTmVvLk1haW4uZ2V0V2luZG93RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWU6IG1lLmRpYWxvZy5hcHBOYW1lID09PSBhcHBOYW1lID8gbWUuZG9ja2VkV2luZG93QXBwTmFtZSA6IGFwcE5hbWVcbiAgICAgICAgICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS50YXJnZXRXaW5kb3dTaXplID0gZG9ja2VkSG9yaXpvbnRhbCA/IGRhdGEuaW5uZXJXaWR0aCA6IGRhdGEuaW5uZXJIZWlnaHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdab25lQ3JlYXRlZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgZGF0YS5kcmFnWm9uZS5vbih7XG4gICAgICAgICAgICBkcmFnRW5kICA6IG1lLm9uRHJhZ0VuZCxcbiAgICAgICAgICAgIGRyYWdNb3ZlIDogbWUub25EcmFnTW92ZSxcbiAgICAgICAgICAgIGRyYWdTdGFydDogbWUub25EcmFnU3RhcnQsXG4gICAgICAgICAgICBzY29wZSAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwb3B1cCB3aW5kb3csIHdoaWNoIGlzIGluaXRpYWxseSBkb2NrZWQgdG8gdGhpcy5kb2NrZWRXaW5kb3dTaWRlIG9mIHRoZSBtYWluIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyRGF0YVxuICAgICAqL1xuICAgIG9wZW5Eb2NrZWRXaW5kb3coaGFuZGxlckRhdGEpIHtcbiAgICAgICAgbGV0IHt3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIE5lby5NYWluLmdldFdpbmRvd0RhdGEoe3dpbmRvd0lkfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRvY2sgICA9IG1lLmRvY2tlZFdpbmRvd1NpZGUsXG4gICAgICAgICAgICAgICAgc2l6ZSAgID0gbWUuZG9ja2VkV2luZG93U2l6ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQsIGxlZnQsIHRvcCwgd2lkdGg7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZG9jaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICA9IGRhdGEuc2NyZWVuTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgID0gZGF0YS5vdXRlckhlaWdodCArIGRhdGEuc2NyZWVuVG9wIC0gNjI7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICA9IGRhdGEub3V0ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gZGF0YS5vdXRlckhlaWdodCAtIDg2O1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgPSBkYXRhLnNjcmVlbkxlZnQgIC0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgID0gZGF0YS5zY3JlZW5Ub3AgICArIDI0O1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gZGF0YS5vdXRlckhlaWdodCAtIDg2O1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgPSBkYXRhLm91dGVyV2lkdGggICsgZGF0YS5zY3JlZW5MZWZ0O1xuICAgICAgICAgICAgICAgICAgICB0b3AgICAgPSBkYXRhLnNjcmVlblRvcCAgICsgMjQ7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgID0gZGF0YS5zY3JlZW5MZWZ0O1xuICAgICAgICAgICAgICAgICAgICB0b3AgICAgPSBkYXRhLnNjcmVlblRvcCAtIHNpemUgKyAyNDtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggID0gZGF0YS5vdXRlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW8uTWFpbi53aW5kb3dPcGVuKHtcbiAgICAgICAgICAgICAgICB1cmwgICAgICAgICAgIDogJ2NoaWxkYXBwcy9zaGFyZWRkaWFsb2cyL2luZGV4Lmh0bWwnLFxuICAgICAgICAgICAgICAgIHdpbmRvd0ZlYXR1cmVzOiBgaGVpZ2h0PSR7aGVpZ2h0fSxsZWZ0PSR7bGVmdH0sdG9wPSR7dG9wfSx3aWR0aD0ke3dpZHRofWAsXG4gICAgICAgICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgICAgICAgd2luZG93TmFtZSAgICA6IG1lLmRvY2tlZFdpbmRvd0FwcE5hbWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5XaW5kb3dQb3NpdGlvbi5yZWdpc3RlcldpbmRvdyh7XG4gICAgICAgICAgICAgICAgZG9jayxcbiAgICAgICAgICAgICAgICBuYW1lOiBtZS5kb2NrZWRXaW5kb3dBcHBOYW1lLFxuICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoZXMgdGhlIHRoZW1lIGZvciBhbGwgY29ubmVjdGVkIGFwcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHN3aXRjaFRoZW1lKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYnV0dG9uICAgICA9IGRhdGEuY29tcG9uZW50LFxuICAgICAgICAgICAgYnV0dG9uVGV4dCA9ICdUaGVtZSBMaWdodCcsXG4gICAgICAgICAgICBkaWFsb2cgICAgID0gbWUuZGlhbG9nLFxuICAgICAgICAgICAgaWNvbkNscyAgICA9ICdmYSBmYS1zdW4nLFxuICAgICAgICAgICAgdGhlbWUgICAgICA9ICduZW8tdGhlbWUtZGFyaycsXG4gICAgICAgICAgICBjbHM7XG5cbiAgICAgICAgaWYgKGJ1dHRvbi50ZXh0ID09PSAnVGhlbWUgTGlnaHQnKSB7XG4gICAgICAgICAgICBidXR0b25UZXh0ID0gJ1RoZW1lIERhcmsnO1xuICAgICAgICAgICAgaWNvbkNscyAgICA9ICdmYSBmYS1tb29uJztcbiAgICAgICAgICAgIHRoZW1lICAgICAgPSAnbmVvLXRoZW1lLWxpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnByZXZpb3VzVGhlbWUgPSBtZS5jdXJyZW50VGhlbWU7XG4gICAgICAgIG1lLmN1cnJlbnRUaGVtZSAgPSB0aGVtZTtcblxuICAgICAgICBtZS5jb25uZWN0ZWRBcHBzLmZvckVhY2goYXBwTmFtZSA9PiB7XG4gICAgICAgICAgICBtZS5zd2l0Y2hUaGVtZUZvckFwcChOZW8uYXBwc1thcHBOYW1lXS53aW5kb3dJZClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnV0dG9uLnNldCh7aWNvbkNscywgdGV4dDogYnV0dG9uVGV4dH0pO1xuXG4gICAgICAgIGlmIChkaWFsb2cpIHtcbiAgICAgICAgICAgIGNscyA9IGRpYWxvZy5jbHM7XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZUFkZChjbHMsIG1lLnByZXZpb3VzVGhlbWUsIG1lLmN1cnJlbnRUaGVtZSk7XG5cbiAgICAgICAgICAgIGRpYWxvZy5jbHMgPSBjbHNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aW5kb3dJZFxuICAgICAqL1xuICAgIHN3aXRjaFRoZW1lRm9yQXBwKHdpbmRvd0lkKSB7XG4gICAgICAgIGxldCB7Y3VycmVudFRoZW1lLCBwcmV2aW91c1RoZW1lfSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNldEJvZHlDbHMoe1xuICAgICAgICAgICAgYWRkICAgIDogW2N1cnJlbnRUaGVtZV0sXG4gICAgICAgICAgICByZW1vdmUgOiBwcmV2aW91c1RoZW1lID8gW3ByZXZpb3VzVGhlbWVdOiBbXSxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICovXG4gICAgdXBkYXRlRG9ja2VkV2luZG93UHJveHlTdHlsZShzdHlsZSkge1xuICAgICAgICBsZXQgZG9ja2VkV2luZG93UHJveHkgPSB0aGlzLmRvY2tlZFdpbmRvd1Byb3h5O1xuXG4gICAgICAgIGlmIChkb2NrZWRXaW5kb3dQcm94eSkge1xuICAgICAgICAgICAgZG9ja2VkV2luZG93UHJveHkuc3R5bGUgPSBPYmplY3QuYXNzaWduKGRvY2tlZFdpbmRvd1Byb3h5LnN0eWxlIHx8IHt9LCBzdHlsZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjbGFzcyB0byByZW5kZXIgYSBsYWJlbCB3aXRoIGEgdGV4dFxuICogQGNsYXNzIE5lby5jb21wb25lbnQuTGFiZWxcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBMYWJlbCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkxhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkxhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWxhYmVsJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWxhYmVsJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRhZz0nbGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0YWc6ICdsYWJlbCdcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExhYmVsKTtcbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgIGZyb20gJy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFuIGV4dGVuZGVkIENvbnRhaW5lciBzdXBwb3J0aW5nIG11bHRpcGxlIGRvY2tlZCBoZWFkZXIgdG9vbGJhcnNcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlBhbmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgUGFuZWwgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5QYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5QYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1wYW5lbCcsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjb250YWluZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBoZWFkZXJEZWZhdWx0cz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJEZWZhdWx0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBoZWFkZXJzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1zPXtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIF9sYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlOiAndmJveCcsXG4gICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB2ZXJ0aWNhbEhlYWRlcnNGaXJzdD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdmVydGljYWxIZWFkZXJzRmlyc3Q6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGFzSGVhZGVycygpICYmIG1lLnZlcnRpY2FsSGVhZGVyc0ZpcnN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZS5sYXlvdXQgPSB7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdoYm94JyxcbiAgICAgICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlciB0aGUgaGVhZGVyIGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpIHtcbiAgICAgICAgaWYgKE5lby50eXBlT2YoaGVhZGVyKSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgICAgICBmbGV4OiAnMCAxIGF1dG8nXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFoZWFkZXIubW9kdWxlICYmICFoZWFkZXIubnR5cGUpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMgICA9IFsnbmVvLXBhbmVsLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ107XG4gICAgICAgICAgICBjb25maWcubnR5cGUgPSAndG9vbGJhcic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhZGVyLnRleHQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5pdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLXBhbmVsLWhlYWRlci10ZXh0JywgJ25lby1sYWJlbCddLFxuICAgICAgICAgICAgICAgIHRleHQgOiBoZWFkZXIudGV4dFxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXIudGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc3VtaW5nIGFsbCBsYWJlbHMgaW5zaWRlIGEgUGFuZWwgSGVhZGVyIGFyZSBtZWFudCB0byBiZSB0aXRsZXMgLT4gbG9vayB0aGUgc2FtZSB3YXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyLml0ZW1zKSkge1xuICAgICAgICAgICAgaGVhZGVyLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ubnR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbHMgPSBbJ25lby1wYW5lbC1oZWFkZXItdGV4dCcsICduZW8tbGFiZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4uY29uZmlnLCAuLi5oZWFkZXJ9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb250YWluZXJDb25maWcgPSBtZS5jb250YWluZXJDb25maWc7XG5cbiAgICAgICAgaWYgKCFtZS5oYXNIZWFkZXJzKCkpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNvbmZpZyAmJiBtZS5zZXQoY29udGFpbmVyQ29uZmlnKTtcbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaGYgICAgICAgICAgICAgICAgICAgPSBtZS52ZXJ0aWNhbEhlYWRlcnNGaXJzdCA9PT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVycyAgICAgICAgICAgICAgPSBtZS5oZWFkZXJzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGJvdHRvbUhlYWRlcnMgICAgICAgID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtyZXR1cm4gaGVhZGVyLmRvY2sgPT09IChoZiA/J2JvdHRvbSc6ICdyaWdodCcpfSksXG4gICAgICAgICAgICAgICAgbGVmdEhlYWRlcnMgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8nbGVmdCcgIDogJ3RvcCcpfSksXG4gICAgICAgICAgICAgICAgcmlnaHRIZWFkZXJzICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ncmlnaHQnIDogJ2JvdHRvbScpfSksXG4gICAgICAgICAgICAgICAgdG9wSGVhZGVycyAgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ndG9wJyAgIDogJ2xlZnQnKX0pLFxuICAgICAgICAgICAgICAgIGhhc0hvcml6b250YWxIZWFkZXJzID0gYm90dG9tSGVhZGVycy5sZW5ndGggPiAwIHx8IHRvcEhlYWRlcnMgIC5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIGhhc1ZlcnRpY2FsSGVhZGVycyAgID0gbGVmdEhlYWRlcnMgIC5sZW5ndGggPiAwIHx8IHJpZ2h0SGVhZGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIHtpdGVtc30gICAgICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zICAgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIGNvbmZpZztcblxuICAgICAgICAgICAgdG9wSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNWZXJ0aWNhbEhlYWRlcnMgJiYgKGhmICYmIGhhc0hvcml6b250YWxIZWFkZXJzIHx8ICFoZiAmJiBoYXNIb3Jpem9udGFsSGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0SGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICAgICA6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICBmbGV4ICAgICAgICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IG1lLml0ZW1EZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKHsuLi5tZS5oZWFkZXJEZWZhdWx0cywgLi4uY29uZmlnfSk7XG5cbiAgICAgICAgICAgICAgICByaWdodEhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zICAgIDogaG9yaXpvbnRhbEl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQgICA6IHtudHlwZTogKGhmID8gJ2hib3gnIDogJ3Zib3gnKSwgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogJ2JvZHlDb250YWluZXInXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgICAgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZmxleCAgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbURlZmF1bHRzOiBtZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZSAgIDogJ2JvZHlDb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250YWluZXJDb25maWdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKHsuLi5tZS5oZWFkZXJEZWZhdWx0cywgLi4uY29uZmlnfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm90dG9tSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zID0gdmVydGljYWxJdGVtcztcblxuICAgICAgICAgICAgbWUuaXRlbURlZmF1bHRzID0gbnVsbDtcblxuICAgICAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzSGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5oZWFkZXJzKSAmJiB0aGlzLmhlYWRlcnMubGVuZ3RoID4gMFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUGFuZWwpO1xuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzICduZW8tYm9keS12aWV3cG9ydCcgdG8gdGhlIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXBwbHlCb2R5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc3VtaW5nIHRoYXQgYSBWaWV3cG9ydCBpcyB0aGUgdG9wIGxldmVsIHZpZXcgb2YgeW91ciBhcHAsIGFuZCB5b3Ugd2FudCB0byBtb3VudCBpdCByaWdodCBhd2F5LlxuICAgICAgICAgKiBDb3VsZCBiZSB3aXRob3V0IGFueSBpdGVtcy4gVXNlIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXZpZXdwb3J0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXZpZXdwb3J0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgYSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyIGFuZCBmaXJlcyBhIGN1c3RvbSByZXNpemUgZXZlbnRcbiAgICAgICAgICogd2hpY2ggb3RoZXIgaW5zdGFuY2VzIGNhbiBzdWJzY3JpYmUgdG8uXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vbml0b3JTaXplXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vbml0b3JTaXplXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5tb25pdG9yU2l6ZSkge1xuICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFt7cmVzaXplOiBtZS5vbkRvbVJlc2l6ZSwgc2NvcGU6IG1lfV0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQge2FwcE5hbWUsIHdpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5hcHBseUJvZHlDbHMgJiYgTmVvLm1haW4uRG9tQWNjZXNzLmFwcGx5Qm9keUNscyh7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgY2xzOiBbJ25lby1ib2R5LXZpZXdwb3J0J10sXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Eb21SZXNpemUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3Jlc2l6ZScsIGRhdGEpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWaWV3cG9ydCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQge3Jlc29sdmVDYWxsYmFja30gZnJvbSAnLi4vdXRpbC9GdW5jdGlvbi5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY29udHJvbGxlci5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkJhc2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29udHJvbGxlci5Db21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250cm9sbGVyLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb21wb25lbnQtY29udHJvbGxlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb21wb25lbnQtY29udHJvbGxlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IHBhcmVudF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlZmVyZW5jZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZWZlcmVuY2VzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjb21wb25lbnR9ID0gbWU7XG5cbiAgICAgICAgbWUucmVmZXJlbmNlcyA9IHt9O1xuXG4gICAgICAgIGlmIChjb21wb25lbnQuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnQub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uQ29tcG9uZW50Q29uc3RydWN0ZWQoKVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHBhcmVudCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQYXJlbnQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCB0aGlzLmdldFBhcmVudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gW2NvbXBvbmVudF1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fEJvb2xlYW58bnVsbH1cbiAgICAgKi9cbiAgICBnZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudH0gPSBtZSxcbiAgICAgICAgICAgIGhhbmRsZXJDYjtcblxuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciB0aHMgZnVuY3Rpb24gKm5hbWUqIGZpcnN0IGluIHRoZSBDb21wb25lbnQgaXRzZWxmLlxuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBpdCwgcmV0dXJuIHRydWUgc28gY2FsbGluZyBjb2RlIGtub3dzIG5vdCB0byBjb250aW51ZSB0byBzZWFyY2guXG4gICAgICAgICAgICBoYW5kbGVyQ2IgPSByZXNvbHZlQ2FsbGJhY2soaGFuZGxlck5hbWUsIGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZXIgZm4gaXMgcmVzb2x2ZWQgaW4gdGhlIENvbXBvbmVudCBvciBpdHMgb3duIHBhcmVudCBjaGFpbi5cbiAgICAgICAgICAgIC8vIFJldHVybiBhIHN0YXR1cyBpbmRpY2F0aW5nIHRoYXQgd2UgZG8gbm90IG5lZWQgYW4gZWFybHkgYmluZGluZ1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJDYi5mbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmVvLmlzRnVuY3Rpb24obWVbaGFuZGxlck5hbWVdKSA/XG4gICAgICAgICAgICBtZSA6IHBhcmVudD8uZ2V0SGFuZGxlclNjb3BlKGhhbmRsZXJOYW1lKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IGNvbnRyb2xsZXIgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnR9ID0gbWU7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lLmNvbXBvbmVudC5wYXJlbnQ/LmdldENvbnRyb2xsZXIoKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9kbzogdXBkYXRlIGNoYW5nZWQgcmVmZXJlbmNlcyAoZS5nLiBjb250YWluZXIucmVtb3ZlKCkgdGhlbiBjb250YWluZXIuYWRkKCkgdXNpbmcgdGhlIHNhbWUga2V5KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5yZWZlcmVuY2VzW25hbWVdO1xuXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBtZS5jb21wb25lbnQuZG93bih7cmVmZXJlbmNlOiBuYW1lfSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBtZS5yZWZlcmVuY2VzW25hbWVdID0gY29tcG9uZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9uZW50IHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNhbWVMZXZlbE9ubHk9ZmFsc2Ugd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3Qgc3RhdGVQcm92aWRlciBpbnNpZGUgdGhlIGNvbXBvbmVudCBwYXJlbnQgdHJlZSxcbiAgICAgKiBpbiBjYXNlIHRoZXJlIGlzIG5vbmUgb24gdGhlIHNhbWUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2FtZUxldmVsT25seT1mYWxzZV1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZVByb3ZpZGVyKHNhbWVMZXZlbE9ubHk9ZmFsc2UpIHtcbiAgICAgICAgbGV0IHtjb21wb25lbnR9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNhbWVMZXZlbE9ubHkgPyBjb21wb25lbnQuc3RhdGVQcm92aWRlciA6IGNvbXBvbmVudC5nZXRTdGF0ZVByb3ZpZGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgYWNjZXNzaW5nIHN0YXRlLlByb3ZpZGVyIGJhc2VkIGRhdGEuU3RvcmVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKi9cbiAgICBnZXRTdG9yZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKGtleSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbnNpZGUgeW91ciB2aWV3IGNvbnRyb2xsZXJzIGFzIGEgc3RhcnRpbmcgcG9pbnQgaW4gY2FzZSB5b3UgbmVlZCByZWZlcmVuY2VzXG4gICAgICogKGluc3RlYWQgb2YgdXNpbmcgb25Db25zdHJ1Y3RlZCgpIGluc2lkZSB5b3VyIGNvbnRyb2xsZXIpXG4gICAgICovXG4gICAgb25Db21wb25lbnRDb25zdHJ1Y3RlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGdldCBjYWxsZWQgYnkgY29tcG9uZW50LkJhc2U6IGRlc3Ryb3koKSBpbiBjYXNlIHRoZSBjb21wb25lbnQgaGFzIGEgcmVmZXJlbmNlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZW1vdmVSZWZlcmVuY2UoY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3JlZmVyZW5jZXN9ID0gbWUsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gcmVmZXJlbmNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlZmVyZW5jZXNba2V5XTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZ2V0UGFyZW50KCk/LnJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIHNldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuc2V0RGF0YSguLi5hcmdzKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1Byb3h5Q29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZHJhZ3Byb3h5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RyYWdwcm94eScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvSW5pdFZub2RlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0Vm5vZGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZHJhZ3Byb3h5J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRyYWdwcm94eSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMubW92ZUluTWFpblRocmVhZCkge1xuICAgICAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0RHJhZ1Byb3h5RWxlbWVudCh7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1Byb3h5Q29tcG9uZW50KTtcbiIsImltcG9ydCBDaGVja0JveCAgICAgICAgIGZyb20gJy4vQ2hlY2tCb3gubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uLy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mb3JtLmZpZWxkLlJhZGlvXG4gKiBAZXh0ZW5kcyBOZW8uZm9ybS5maWVsZC5DaGVja0JveFxuICovXG5jbGFzcyBSYWRpbyBleHRlbmRzIENoZWNrQm94IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mb3JtLmZpZWxkLlJhZGlvJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZm9ybS5maWVsZC5SYWRpbycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdyYWRpb2ZpZWxkJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3JhZGlvZmllbGQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tcmFkaW9maWVsZCcsJ25lby1jaGVja2JveGZpZWxkJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXJhZGlvZmllbGQnLCAnbmVvLWNoZWNrYm94ZmllbGQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBpY29uQ2xzPVsnZmFyJywnZmEtY2lyY2xlJ11cbiAgICAgICAgICovXG4gICAgICAgIGljb25DbHM6IFsnZmFyJywgJ2ZhLWNpcmNsZSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpbnB1dFR5cGU9J3JhZGlvJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlucHV0VHlwZTogJ3JhZGlvJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2hlY2tlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENoZWNrZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0Q2hlY2tlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSByYWRpb3Mgd2l0aCB0aGUgc2FtZSBuYW1lIHRvIGJlIHVuY2hlY2tlZFxuICAgICAgICB2YWx1ZSAmJiB0aGlzLnVuY2hlY2tHcm91cEl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSYWRpb3Mgc2hvdWxkIG9ubHkgZmlyZSBjaGFuZ2UgJiBmaWVsZENoYW5nZSBldmVudHMgaWYgY2hlY2tlZC5cbiAgICAgKiBJZiB0aGVyZSB3YXMganVzdCAxIHJhZGlvLCB5b3UgY2FuIG5vdCB1bmNoZWNrIGl0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgJiYgc3VwZXIuZmlyZUNoYW5nZUV2ZW50KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0R3JvdXBWYWx1ZSgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gc3VwZXIuZ2V0R3JvdXBWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwID8gdmFsdWVbMF0gOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJhZGlvcyBkbyBub3QgZmlyZSBhIGNoYW5nZSBldmVudCBmb3IgXCJ1bmNoZWNrXCIsIHNvIHdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIG90aGVyIHJhZGlvcyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gICAgICovXG4gICAgdW5jaGVja0dyb3VwSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICByYWRpb3M7XG5cbiAgICAgICAgLy8gZGlzY3Vzczogd2UgY291bGQgbGltaXQgdGhpcyB0byByYWRpb3MgaW5zaWRlIHRoZSBzYW1lIGZvcm0sIElGIGEgdG9wIGxldmVsIGZvcm0gaXMgdXNlZFxuICAgICAgICByYWRpb3MgPSBDb21wb25lbnRNYW5hZ2VyLmZpbmQoe1xuICAgICAgICAgICAgbnR5cGU6ICdyYWRpb2ZpZWxkJyxcbiAgICAgICAgICAgIG5hbWUgOiBtZS5uYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJhZGlvcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG1lLmlkICYmIGl0ZW0uX2NoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNoZWNrZWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUmFkaW8pO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExhYmVsICAgICBmcm9tICcuLi9jb21wb25lbnQvTGFiZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udG9vbGJhci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBkb2NrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRvY2tQb3NpdGlvbnM9Wyd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnLCBudWxsXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9ja1Bvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2xiYXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2xiYXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZG9ja189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHM9e250eXBlOididXR0b24nfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2ZsZXhib3gnLGFsaWduOidjZW50ZXInLGRpcmVjdGlvbjogJ3JvdycsIHBhY2s6J3N0YXJ0J31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlICAgIDogJ2ZsZXhib3gnLFxuICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNvcnRhYmxlXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLnRvb2xiYXIuU29ydFpvbmV8bnVsbH0gc29ydFpvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHNvcnRab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lQ29uZmlnOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS5hcHBOYW1lID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZG9jayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlICYmICFvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICBkb2NrUG9zaXRpb25zID0gbWUuZ2V0U3RhdGljQ29uZmlnKCdkb2NrUG9zaXRpb25zJyksXG4gICAgICAgICAgICBsYXlvdXRDb25maWcgID0gbWUuZ2V0TGF5b3V0Q29uZmlnKCk7XG5cbiAgICAgICAgZG9ja1Bvc2l0aW9ucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBrZXkgIT09IG51bGwgJiYgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1kb2NrLScgKyBrZXksIGtleSA9PT0gdmFsdWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWUubGF5b3V0KSB7XG4gICAgICAgICAgICBsYXlvdXRDb25maWcubnR5cGUgPSAnZmxleGJveCc7XG4gICAgICAgICAgICBtZS5zZXQoe2NscywgbGF5b3V0OiBsYXlvdXRDb25maWd9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUubGF5b3V0LnNldChsYXlvdXRDb25maWcpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3Rvb2xiYXIvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5zb3J0Wm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Wm9uZS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG5ldyBkb2NrIHBvc2l0aW9uIG1hdGNoZXMgYSB2YWx1ZSBvZiB0aGUgc3RhdGljIGRvY2tQb3NpdGlvbnMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2RvY2snLCAnZG9ja1Bvc2l0aW9ucycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxheW91dCBjb25maWcgZGVwZW5kaW5nIG9uIHRoaXMuZG9ja1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGxheW91dENvbmZpZ1xuICAgICAqL1xuICAgIGdldExheW91dENvbmZpZygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGxheW91dENvbmZpZztcblxuICAgICAgICBpZiAobWUuZG9jaykge1xuICAgICAgICAgICAgc3dpdGNoIChtZS5kb2NrKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uLXJldmVyc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbiAgICA6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheW91dENvbmZpZyB8fCBtZS5sYXlvdXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8TmVvLmNvbXBvbmVudC5CYXNlW119XG4gICAgICovXG4gICAgaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLm1hcChpdGVtID0+IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5pbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fVxuICAgICAqL1xuICAgIHJlcGxhY2VTcGFjZXIoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gJy0+JyA/IHttb2R1bGU6IENvbXBvbmVudCwgZmxleDogMX0gOiBpdGVtXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUb29sYmFyKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=