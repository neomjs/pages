"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_Gallery_mjs"],{

/***/ "./src/component/Gallery.mjs":
/*!***********************************!*\
  !*** ./src/component/Gallery.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _selection_GalleryModel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../selection/GalleryModel.mjs */ "./src/selection/GalleryModel.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/Store.mjs */ "./src/data/Store.mjs");






const itemsMounted = Symbol.for('itemsMounted');

/**
 * @class Neo.component.Gallery
 * @extends Neo.component.Base
 */
class Gallery extends _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Gallery'
         * @protected
         */
        className: 'Neo.component.Gallery',
        /**
         * @member {String} ntype='gallery'
         * @protected
         */
        ntype: 'gallery',
        /**
         * The amount of visible rows inside the gallery
         * @member {Number} amountRows_=3
         */
        amountRows_: 3,
        /**
         * The background color of the gallery container
         * @member {String} backgroundColor_='#000000'
         */
        backgroundColor_: '#000000',
        /**
         * @member {String[]} baseCls=['neo-gallery', 'page', 'view']
         */
        baseCls: ['neo-gallery', 'page', 'view'],
        /**
         * True disables selection of gallery items
         * @member {Boolean} disableSelection=false
         */
        disableSelection: false,
        /**
         * True will focus the gallery top level DOM node to enable the keyboard navigation right away
         * @member {Boolean} focusOnMount=true
         */
        focusOnMount: true,
        /**
         * The image height of the gallery
         * @member {Number} itemHeight=160
         */
        itemHeight: 160,
        /**
         * @member {Object} itemTpl_
         */
        itemTpl_:
        {cls: ['neo-gallery-item', 'image-wrap', 'view', 'neo-transition-1000'], tabIndex: '-1', cn: [
            {cls: ['neo-item-wrapper'], cn: [
                {tag: 'img', cls: [], style: {}}
            ]}
        ]},
        /**
         * The image width of the gallery
         * @member {Number} itemWidth=120
         */
        itemWidth: 120,
        /**
         * The unique record field containing the id.
         * @member {String} keyProperty='id'
         */
        keyProperty: 'id',
        /**
         * Additional used keys for the selection model
         * @member {Object} keys
         */
        keys: {},
        /**
         * The max amount of store items to show
         * @member {Number} maxItems_=300
         */
        maxItems_: 300,
        /**
         * The zooming factor which replaces the default wheelDelta.
         * @member {Number} mouseWheelDeltaX=10
         */
        mouseWheelDeltaX: 10,
        /**
         * The zooming factor which replaces the default wheelDelta.
         * @member {Number} mouseWheelDeltaY=10
         */
        mouseWheelDeltaY: 10,
        /**
         * Specifies whether the mouse wheel should change the translateZ value for zooming
         * @member {Boolean} mouseWheelEnabled_=true
         */
        mouseWheelEnabled_: true,
        /**
         * The DOM element offsetHeight of the top level div.
         * Gets fetched after the gallery got mounted.
         * @member {Number|null} offsetHeight=null
         * @protected
         */
        offsetHeight: null,
        /**
         * The DOM element offsetWidth of the top level div.
         * Gets fetched after the gallery got mounted.
         * @member {Number|null} offsetWidth=null
         * @protected
         */
        offsetWidth: null,
        /**
         * Set this one to true to order the items by row instead of by column
         * @member {Boolean} orderByRow_=false
         */
        orderByRow_: false,
        /**
         * The name of the CSS rule for selected items
         * @member {String} selectedItemCls='neo-selected'
         */
        selectedItemCls: 'neo-selected',
        /**
         * Uses the selection.GalleryModel by default
         * @member {Neo.selection.GalleryModel|null} selectionModel_=null
         */
        selectionModel_: null,
        /**
         * True to select the item inside the middle of the store items on mount
         * @member {Boolean} selectOnMount=true
         */
        selectOnMount: true,
        /**
         * The store instance or class containing the data for the gallery items
         * @member {Neo.data.Store|null} store_=null
         */
        store_: null,
        /**
         * The setTimeout() ids for calls which can get cancelled
         * @member {Array} transitionTimeouts=[]
         * @protected
         */
        transitionTimeouts: [],
        /**
         * The translateX value of the view origin
         * @member {Number} translateX_=0
         */
        translateX_: 0,
        /**
         * The translateX value of the view origin
         * @member {Number} translateY_=0
         */
        translateY_: 0,
        /**
         * The translateX value of the view origin
         * @member {Number} translateZ_=0
         */
        translateZ_: 0,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cls: ['page', 'view'], style: {}, tabIndex: '-1', cn: [
            {cls: ['origin', 'view'], style: {}, cn: [
                {cls: ['camera', 'view'], style: {}, cn: [
                    {cls: ['dolly', 'view'], style: {}, cn: [
                        {cls: ['view'], style: {}, cn: []}
                    ]}
                ]}
            ]}
        ]}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me[itemsMounted] = false;

        me.addDomListeners({
            click: me.onClick,
            wheel: me.onMouseWheel,
            scope: me
        })
    }

    /**
     * Triggered after the amountRows config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAmountRows(value, oldValue) {
        if (Neo.isNumber(oldValue)) {
            let me = this;

            me.afterSetOrderByRow(me.orderByRow, !me.orderByRow)
        }
    }

    /**
     * Triggered after the id config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);

        let me     = this,
            origin = me.vdom.cn[0],
            camera = origin.cn[0],
            dolly  = camera.cn[0],
            view   = dolly.cn[0],
            prefix = me.id + '__';

        camera.id = prefix + 'camera';
        dolly .id = prefix + 'dolly';
        origin.id = prefix + 'origin';
        view  .id = prefix + 'view';

        me.update()
    }

    /**
     * Triggered after the maxItem config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetMaxItems(value, oldValue) {
        let me = this;

        if (value && me.rendered) {
            if (oldValue > value) {
                me.destroyItems(value, oldValue - value)
            } else {
                me.createItems(oldValue)
            }
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        let me               = this,
            {selectionModel} = me;

        if (value) {
            me.focusOnMount && me.focus(me.id);

            me.timeout(300).then(() => {
                Neo.currentWorker.promiseMessage('main', {
                    action    : 'readDom',
                    appName   : me.appName,
                    attributes: ['offsetHeight', 'offsetWidth'],
                    vnodeId   : me.id,
                    windowId  : me.windowId
                }).then(data => {
                    me.offsetHeight = data.attributes.offsetHeight;
                    me.offsetWidth  = data.attributes.offsetWidth;

                    if (me.selectOnMount || selectionModel.hasSelection()) {
                        let selection = selectionModel.getSelection(),
                            key       = selection.length > 0 && selection[0];

                        if (!key) {
                            let index = parseInt(Math.min(me.maxItems, me.store.getCount()) / me.amountRows);

                            key = me.store.getKeyAt(index)
                        }

                        selectionModel.select(key)
                    }
                })
            })
        } else {
            selectionModel.items = []
        }
    }

    /**
     * Triggered after the orderByRow config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetOrderByRow(value, oldValue) {
        if (Neo.isBoolean(oldValue)) {
            let me   = this,
                i    = 0,
                len  = Math.min(me.maxItems, me.store.items.length),
                view = me.getItemsRoot();

            if (me.rendered) {
                me.refreshImageReflection();

                me.timeout(50).then(() => {
                    for (; i < len; i++) {
                        view.cn[i].style.transform = me.getItemTransform(i)
                    }

                    me.update();

                    me.timeout(500).then(() => {
                        let sm = me.selectionModel;

                        sm.hasSelection() && me.onSelectionChange(sm.items)
                    })
                })
            }
        }
    }

    /**
     * Triggered after the selectionModel config got changed
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    afterSetSelectionModel(value, oldValue) {
        oldValue?.destroy();
        this.rendered && value.register(this)
    }

    afterSetTranslateX() {this.moveOrigin()}
    afterSetTranslateY() {this.moveOrigin()}
    afterSetTranslateZ() {this.moveOrigin()}

    /**
     * Triggered before the store config gets changed.
     * @param {Neo.data.Store|null} value
     * @param {Neo.data.Store|null} oldValue
     * @returns {Neo.collection.Base|Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        let me = this;

        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], {
            listeners  : {
                load : me.onStoreLoad,
                sort : me.onSort,
                scope: me
            }
        })
    }

    /**
     * @returns {Object}
     */
    beforeGetItemTpl() {
        return Neo.clone(this._itemTpl, true)
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _selection_GalleryModel_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
            listeners: {
                selectionChange: this.onSelectionChange,
                scope          : this
            }
        })
    }

    /**
     * Override this method to get different item-markups
     * @param {Object} vdomItem
     * @param {Object} record
     * @param {Number} index
     * @returns {Object} vdomItem
     */
    createItem(vdomItem, record, index) {
        let me        = this,
            imageVdom = vdomItem.cn[0].cn[0];

        vdomItem.id = me.getItemVnodeId(record[me.keyProperty]);

        imageVdom.src = Neo.config.resourcesPath + 'examples/' + record.image;

        imageVdom.style.height = me.itemHeight + 'px';
        imageVdom.style.width  = me.itemWidth  + 'px';

        return vdomItem
    }

    /**
     * @param {Number} [startIndex] the start index for creating items,
     * e.g. increasing maxItems only needs to create the new ones
     * @protected
     */
    createItems(startIndex) {
        let me               = this,
            amountRows       = me.amountRows,
            orderByRow       = me.orderByRow,
            secondLastColumn = amountRows - 1,
            vdom             = me.vdom,
            itemsRoot        = me.getItemsRoot(),
            i                = startIndex || 0,
            len              = Math.min(me.maxItems, me.store.items.length),
            amountColumns, item, vdomItem;

        if (orderByRow) {
            amountColumns = Math.ceil(me.store.getCount() / amountRows)
        }

        for (; i < len; i++) {
            item      = me.store.items[i];
            vdomItem  = me.createItem(me.itemTpl, item, i);

            vdomItem. style = vdomItem.style || {};

            vdomItem.style['transform'] = me.getItemTransform(i);

            if (orderByRow) {
                if (i >= secondLastColumn * amountColumns) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(vdomItem.cls, 'neo-reflection')
                }
            } else {
                if (i % amountRows === secondLastColumn) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(vdomItem.cls, 'neo-reflection')
                }
            }

            itemsRoot.cn.push(vdomItem)
        }

        me.promiseUpdate().then(() => {
            me[itemsMounted] = true
        })
    }

    /**
     * @param {Number} [startIndex]
     * @param {Number} [amountItems]
     */
    destroyItems(startIndex, amountItems) {
        let me           = this,
            countItems   = amountItems || me.store.getCount(),
            selectedItem = me.selectionModel.items[0];

        me.getItemsRoot().cn.splice(startIndex || 0, countItems);
        me.update();

        if (me.selectionModel.hasSelection() && selectedItem > startIndex && selectedItem < startIndex + countItems) {
            me.afterSetMounted(true, false)
        }
    }

    /**
     * @param {Number} index
     * @returns {Number[]}
     */
    getCameraTransformForCell(index) {
        let me                      = this,
            {amountRows, itemWidth} = me,
            gap                     = 10,
            height                  = me.offsetHeight / (amountRows + 2),
            spacing                 = height + gap,
            x                       = Math.floor(index / amountRows),
            y                       = index - x * amountRows;

        if (me.orderByRow) {
            let amountColumns = Math.ceil(Math.min(me.maxItems, me.store.getCount()) / amountRows);

            x = index % amountColumns;
            y = Math.floor(index / amountColumns)
        }

        let cx = x * (itemWidth + 10),
            cy = (y + 0.5) * spacing * 1.1 + 50;

        return [-cx, -cy, 0]
    }

    /**
     * @param {String} vnodeId
     * @returns {Number} itemId
     */
    getItemId(vnodeId) {
        return parseInt(vnodeId.split('__')[1])
    }

    /**
     * Returns the vdom node containing the gallery items
     * @returns {Object} vdom
     */
    getItemsRoot() {
        return this.vdom.cn[0].cn[0].cn[0].cn[0]
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getItemTransform(index) {
        let me           = this,
            {amountRows} = me,
            x, y;

        if (me.orderByRow) {
            amountRows = Math.ceil(Math.min(me.maxItems, me.store.getCount()) / amountRows);

            x = index % amountRows;
            y = Math.floor(index / amountRows)
        } else {
            x = Math.floor(index / amountRows);
            y = index % amountRows
        }

        return this.translate3d(
            x * (me.itemWidth  + 10),
            y * (me.itemHeight + 10) + 100,
            0
        )
    }

    /**
     * @param {String} id
     * @returns {String}
     */
    getItemVnodeId(id) {
        return this.id + '__' + id
    }

    /**
     *
     */
    moveOrigin() {
        let me = this;

        me.vdom.cn[0].style.transform = me.translate3d(me.translateX, me.translateY, me.translateZ);
        me.update()
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        this.fire(data.id === this.id ? 'containerClick' : 'itemClick', data)
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.selectionModel?.register(this);
    }

    /**
     * @param {Object} data
     */
    onMouseWheel(data) {
        let me = this;

        if (me.mouseWheelEnabled) {
            me._translateX = me.translateX - (data.deltaX * me.mouseWheelDeltaX); // silent update
            me._translateZ = me.translateZ + (data.deltaY * me.mouseWheelDeltaY); // silent update

            me.moveOrigin();

            me.fire('changeTranslateX', me._translateX);
            me.fire('changeTranslateZ', me._translateZ)
        }
    }

    /**
     * @param {Array} value
     */
    onSelectionChange(value) {
        let me             = this,
            index          = me.store.indexOf(value?.[0] || 0),
            {appName, id, itemHeight, itemWidth, windowId} = me,
            camera         = me.vdom.cn[0].cn[0],
            cameraStyle    = camera.style,
            dollyTransform = me.getCameraTransformForCell(index),
            height         = me.offsetHeight / (me.amountRows + 2),
            width          = Math.round(height * itemWidth / itemHeight),
            spacing        = width + 10,
            timeoutId;

        me.transitionTimeouts.forEach(item => {
            clearTimeout(item)
        });

        me.transitionTimeouts.splice(0, me.transitionTimeouts.length);

        Neo.currentWorker.promiseMessage('main', {
            action : 'updateDom',
            appName,
            windowId,

            deltas: {
                id   : id + '__dolly',
                style: {
                    transform: me.translate3d(...dollyTransform)
                }
            }
        }).then(() => {
            Neo.currentWorker.promiseMessage('main', {
                action : 'readDom',
                appName,
                vnodeId: id,
                windowId,

                functions: [{
                    fn            : 'getComputedStyle',
                    params        : [id + '__dolly', null],
                    paramIsDomNode: [true, false],
                    scope         : 'defaultView',
                    returnFnName  : 'transform',
                    returnValue   : 'transform'
                }]
            }).then(data => {
                let transform = data.functions.transform,
                    translateX, angle;

                if (transform.indexOf('matrix3d') === 0) {
                    transform  = transform.substring(9, transform.length - 1); // remove matrix3d( ... )
                    transform  = transform.split(',').map(e => parseFloat(e));
                    translateX = transform[12] // bottom left element of the 4x4 matrix
                } else {
                    transform  = transform.substring(7, transform.length - 1); // remove matrix( ... )
                    transform  = transform.split(',').map(e => parseFloat(e));
                    translateX = transform[4] // bottom left element of the 2x3 matrix
                }

                translateX = translateX - dollyTransform[0];
                angle      = Math.min(Math.max(translateX / (spacing * 3), -1), 1) * 45;

                cameraStyle.transform          = `rotateY(${angle}deg)`;
                cameraStyle.transitionDuration = '330ms';

                me.update();

                timeoutId = setTimeout(() => {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(me.transitionTimeouts, timeoutId);

                    cameraStyle.transform          = 'rotateY(0deg)';
                    cameraStyle.transitionDuration = '5000ms';

                    me.update()
                }, 330);

                me.transitionTimeouts.push(timeoutId)
            })
        })
    }

    /**
     *
     */
    onSort() {
        if (this[itemsMounted] === true) {
            let me        = this,
                hasChange = false,
                items     = [...me.store.items || []],
                newCn     = [],
                view      = me.getItemsRoot(),
                vdomMap   = view.cn.map(e => e.id),
                fromIndex, vdomId;

            items.length = Math.min(me.maxItems, me.store.getCount());

            if (items.length > 0) {
                items.forEach((item, index) => {
                    vdomId    = me.getItemVnodeId(item[me.keyProperty]);
                    fromIndex = vdomMap.indexOf(vdomId);

                    newCn.push(view.cn[fromIndex]);

                    if (index !== fromIndex) {
                        hasChange = true
                    }
                });

                if (hasChange) {
                    view.cn = newCn;
                    me.update();

                    me.timeout(50).then(() => {
                        me.afterSetOrderByRow(me.orderByRow, !me.orderByRow)
                    })
                }
            }
        }
    }

    /**
     * @param {Object[]} items
     */
    onStoreLoad(items) {
        this.getItemsRoot().cn = []; // silent update
        this.createItems()
    }

    /**
     *
     */
    refreshImageReflection() {
        let me                       = this,
            {amountRows, orderByRow} = me,
            secondLastColumn         = amountRows - 1,
            view                     = me.getItemsRoot(),
            amountColumns;

        if (orderByRow) {
            amountColumns = Math.ceil(Math.min(me.maxItems, me.store.getCount()) / amountRows)
        }

        view.cn.forEach((item, index) => {
            if (orderByRow) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][index >= secondLastColumn * amountColumns ? 'add' : 'remove'](item.cls, 'neo-reflection')
            } else {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"][index % amountRows === secondLastColumn   ? 'add' : 'remove'](item.cls, 'neo-reflection')
            }
        });

        me.update()
    }

    /**
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @returns {String}
     */
    translate3d(x, y, z) {
        return `translate3d(${x}px, ${y}px, ${z}px)`
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Gallery));


/***/ }),

/***/ "./src/selection/GalleryModel.mjs":
/*!****************************************!*\
  !*** ./src/selection/GalleryModel.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Model.mjs */ "./src/selection/Model.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * A selection model intended to use for Neo.component.Gallery
 * @class Neo.selection.GalleryModel
 * @extends Neo.selection.Model
 */
class GalleryModel extends _Model_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.GalleryModel'
         * @protected
         */
        className: 'Neo.selection.GalleryModel',
        /**
         * @member {String} ntype='selection-gallerymodel'
         * @protected
         */
        ntype: 'selection-gallerymodel',
        /**
         * @member {String} cls='neo-selection-gallerymodel'
         * @protected
         */
        cls: 'neo-selection-gallerymodel',
        /**
         * True to stay in the same column when navigating with the up and down keys,
         * otherwise you will navigate to the next / prev column when moving out
         * @member {Boolean} stayInRow=false
         */
        stayInRow: false
    }

    /**
     * Override to not apply a domListener
     */
    addDomListener() {}

    /**
     *
     */
    onContainerClick() {
        let me       = this,
            {view}   = me,
            oldItems = [...me.items],
            deltas   = [];

        me.items.forEach(item => {
            deltas.push({
                id : view.getItemVnodeId(item),
                cls: {
                    add   : [],
                    remove: ['neo-selected']
                }
            });
        });

        me.items.splice(0, me.items.length);

        Neo.applyDeltas(view.appName, deltas).then(() => {
            me.fire('selectionChange', me.items, oldItems)
        })
    }

    /**
     * @param {Object} data
     */
    onItemClick(data) {
        let i      = 0,
            len    = data.path.length,
            {view} = this,
            key;

        for (; i < len; i++) {
            if (data.path[i].cls.includes('neo-gallery-item')) {
                key = view.getItemId(data.path[i].id);
                this.select(key);

                view.fire('select', {
                    record: view.store.get(key)
                });

                break
            }
        }
    }

    /**
     * @param {Object} data
     */
    onKeyDownDown(data) {
        this[this.view.orderByRow ? 'onNavKeyRow' : 'onNavKeyColumn'](1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownLeft(data) {
        this[this.view.orderByRow ? 'onNavKeyColumn' : 'onNavKeyRow'](-1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownRight(data) {
        this[this.view.orderByRow ? 'onNavKeyColumn' : 'onNavKeyRow'](1)
    }

    /**
     * @param {Object} data
     */
    onKeyDownUp(data) {
        this[this.view.orderByRow ? 'onNavKeyRow' : 'onNavKeyColumn'](-1)
    }

    /**
     * @param {Number} step=1
     */
    onNavKeyColumn(step=1) {
        let me           = this,
            {view}       = me,
            {store}      = view,
            selected     = me.items[0],
            countRecords = store.getCount(),
            index, record;

        if (selected) {
            index = store.indexOf(selected) + step
        } else {
            index = 0
        }

        if (index < 0) {
            index = countRecords - 1
        } else if (index >= countRecords) {
            index = 0
        }

        record = store.getAt(index);

        me.select(record[store.keyProperty]);

        view.fire('select', {
            record
        })
    }

    /**
     * @param {Number} step=1
     */
    onNavKeyRow(step=1) {
        let me                  = this,
            {stayInRow, view}   = me,
            {amountRows, store} = view,
            selected            = me.items[0],
            countRecords        = store.getCount(),
            index, record;

        if (view.orderByRow) {
            amountRows = Math.ceil(view.store.getCount() / amountRows)
        }

        step *= amountRows;

        if (selected) {
            index = store.indexOf(selected) + step
        } else {
            index = 0
        }

        if (index < 0) {
            if (!stayInRow) {
                index++
            }
            while (index < (countRecords - amountRows)) {
                index += amountRows
            }
        } else if (index >= countRecords) {
            if (!stayInRow) {
                index--
            }
            while (index >= amountRows) {
                index -= amountRows
            }
        }

        record = store.getAt(index);

        me.select(record[store.keyProperty]);

        view.fire('select', {
            record
        })
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        super.register(component);

        let me         = this,
            {id, view} = me;

        view.on({
            containerClick: me.onContainerClick,
            itemClick     : me.onItemClick,
            scope         : me
        });

        view.keys?._keys.push(
            {fn: 'onKeyDownDown'  ,key: 'Down'  ,scope: id},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
            {fn: 'onKeyDownUp'    ,key: 'Up'    ,scope: id}
        )
    }

    /**
     * @param {String} itemId
     */
    select(itemId) {
        let me            = this,
            {items, view} = me,
            oldItems      = [...items],
            deltas        = [],
            vnodeId       = view?.getItemVnodeId(itemId);

        // a select() call can happen before the view is registered
        if (!view) {
            // will get picked up by view.afterSetMounted()
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]['add'](items, itemId);
            return
        }

        if (me.singleSelect) {
            me.items.forEach(item => {
                if (item !== itemId) {
                    deltas.push({
                        id : view.getItemVnodeId(item),
                        cls: {
                            add   : [],
                            remove: ['neo-selected']
                        }
                    })
                }
            });

            items.splice(0, items.length)
        }

        deltas.push({
            id : vnodeId,
            cls: {
                add: ['neo-selected']
            }
        });

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]['add'](items, itemId);

        if (deltas.length > 0 && view.mounted) {
            Neo.applyDeltas(view.appName, deltas).then(() => {
                view.onSelect?.(items);
                me.fire('selectionChange', items, oldItems)
            })
        } else if (view.mounted) {
            view.onSelect?.(items);
            me.fire('selectionChange', items, oldItems)
        }
    }

    /**
     *
     */
    unregister() {
        let {id, view} = this;

        view.keys?.removeKeys([
            {fn: 'onKeyDownDown'  ,key: 'Down'  ,scope: id},
            {fn: 'onKeyDownLeft'  ,key: 'Left'  ,scope: id},
            {fn: 'onKeyDownRight' ,key: 'Right' ,scope: id},
            {fn: 'onKeyDownUp'    ,key: 'Up'    ,scope: id}
        ]);

        super.unregister()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GalleryModel));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfR2FsbGVyeV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ2I7QUFDbUI7QUFDWjtBQUNBOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBUztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsUUFBUSx1REFBUTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVOztBQUV2QjtBQUNBLGFBQWEsOENBQThDO0FBQzNELGFBQWEsOENBQThDO0FBQzNELGFBQWEsOENBQThDO0FBQzNELGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNEJBQTRCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9HYWxsZXJ5Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9HYWxsZXJ5TW9kZWwubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBHYWxsZXJ5TW9kZWwgICAgZnJvbSAnLi4vc2VsZWN0aW9uL0dhbGxlcnlNb2RlbC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgU3RvcmUgICAgICAgICAgIGZyb20gJy4uL2RhdGEvU3RvcmUubWpzJztcblxuY29uc3QgaXRlbXNNb3VudGVkID0gU3ltYm9sLmZvcignaXRlbXNNb3VudGVkJyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuR2FsbGVyeVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIEdhbGxlcnkgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5HYWxsZXJ5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkdhbGxlcnknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZ2FsbGVyeSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdnYWxsZXJ5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdmlzaWJsZSByb3dzIGluc2lkZSB0aGUgZ2FsbGVyeVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGFtb3VudFJvd3NfPTNcbiAgICAgICAgICovXG4gICAgICAgIGFtb3VudFJvd3NfOiAzLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGdhbGxlcnkgY29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYmFja2dyb3VuZENvbG9yXz0nIzAwMDAwMCdcbiAgICAgICAgICovXG4gICAgICAgIGJhY2tncm91bmRDb2xvcl86ICcjMDAwMDAwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWdhbGxlcnknLCAncGFnZScsICd2aWV3J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWdhbGxlcnknLCAncGFnZScsICd2aWV3J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGRpc2FibGVzIHNlbGVjdGlvbiBvZiBnYWxsZXJ5IGl0ZW1zXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVTZWxlY3Rpb249ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB3aWxsIGZvY3VzIHRoZSBnYWxsZXJ5IHRvcCBsZXZlbCBET00gbm9kZSB0byBlbmFibGUgdGhlIGtleWJvYXJkIG5hdmlnYXRpb24gcmlnaHQgYXdheVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmb2N1c09uTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9jdXNPbk1vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGltYWdlIGhlaWdodCBvZiB0aGUgZ2FsbGVyeVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGl0ZW1IZWlnaHQ9MTYwXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtSGVpZ2h0OiAxNjAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1UcGxfXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtVHBsXzpcbiAgICAgICAge2NsczogWyduZW8tZ2FsbGVyeS1pdGVtJywgJ2ltYWdlLXdyYXAnLCAndmlldycsICduZW8tdHJhbnNpdGlvbi0xMDAwJ10sIHRhYkluZGV4OiAnLTEnLCBjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8taXRlbS13cmFwcGVyJ10sIGNuOiBbXG4gICAgICAgICAgICAgICAge3RhZzogJ2ltZycsIGNsczogW10sIHN0eWxlOiB7fX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGltYWdlIHdpZHRoIG9mIHRoZSBnYWxsZXJ5XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaXRlbVdpZHRoPTEyMFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVdpZHRoOiAxMjAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5pcXVlIHJlY29yZCBmaWVsZCBjb250YWluaW5nIHRoZSBpZC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBrZXlQcm9wZXJ0eT0naWQnXG4gICAgICAgICAqL1xuICAgICAgICBrZXlQcm9wZXJ0eTogJ2lkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgdXNlZCBrZXlzIGZvciB0aGUgc2VsZWN0aW9uIG1vZGVsXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0ga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAga2V5czoge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4IGFtb3VudCBvZiBzdG9yZSBpdGVtcyB0byBzaG93XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWF4SXRlbXNfPTMwMFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4SXRlbXNfOiAzMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgem9vbWluZyBmYWN0b3Igd2hpY2ggcmVwbGFjZXMgdGhlIGRlZmF1bHQgd2hlZWxEZWx0YS5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtb3VzZVdoZWVsRGVsdGFYPTEwXG4gICAgICAgICAqL1xuICAgICAgICBtb3VzZVdoZWVsRGVsdGFYOiAxMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB6b29taW5nIGZhY3RvciB3aGljaCByZXBsYWNlcyB0aGUgZGVmYXVsdCB3aGVlbERlbHRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1vdXNlV2hlZWxEZWx0YVk9MTBcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlV2hlZWxEZWx0YVk6IDEwLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1vdXNlIHdoZWVsIHNob3VsZCBjaGFuZ2UgdGhlIHRyYW5zbGF0ZVogdmFsdWUgZm9yIHpvb21pbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW91c2VXaGVlbEVuYWJsZWRfPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlV2hlZWxFbmFibGVkXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBET00gZWxlbWVudCBvZmZzZXRIZWlnaHQgb2YgdGhlIHRvcCBsZXZlbCBkaXYuXG4gICAgICAgICAqIEdldHMgZmV0Y2hlZCBhZnRlciB0aGUgZ2FsbGVyeSBnb3QgbW91bnRlZC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG9mZnNldEhlaWdodD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldEhlaWdodDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBET00gZWxlbWVudCBvZmZzZXRXaWR0aCBvZiB0aGUgdG9wIGxldmVsIGRpdi5cbiAgICAgICAgICogR2V0cyBmZXRjaGVkIGFmdGVyIHRoZSBnYWxsZXJ5IGdvdCBtb3VudGVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gb2Zmc2V0V2lkdGg9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRXaWR0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIG9uZSB0byB0cnVlIHRvIG9yZGVyIHRoZSBpdGVtcyBieSByb3cgaW5zdGVhZCBvZiBieSBjb2x1bW5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb3JkZXJCeVJvd189ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIG9yZGVyQnlSb3dfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBDU1MgcnVsZSBmb3Igc2VsZWN0ZWQgaXRlbXNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzZWxlY3RlZEl0ZW1DbHM9J25lby1zZWxlY3RlZCdcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkSXRlbUNsczogJ25lby1zZWxlY3RlZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VzIHRoZSBzZWxlY3Rpb24uR2FsbGVyeU1vZGVsIGJ5IGRlZmF1bHRcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnNlbGVjdGlvbi5HYWxsZXJ5TW9kZWx8bnVsbH0gc2VsZWN0aW9uTW9kZWxfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc2VsZWN0IHRoZSBpdGVtIGluc2lkZSB0aGUgbWlkZGxlIG9mIHRoZSBzdG9yZSBpdGVtcyBvbiBtb3VudFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzZWxlY3RPbk1vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdE9uTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3RvcmUgaW5zdGFuY2Ugb3IgY2xhc3MgY29udGFpbmluZyB0aGUgZGF0YSBmb3IgdGhlIGdhbGxlcnkgaXRlbXNcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gc3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXRUaW1lb3V0KCkgaWRzIGZvciBjYWxscyB3aGljaCBjYW4gZ2V0IGNhbmNlbGxlZFxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gdHJhbnNpdGlvblRpbWVvdXRzPVtdXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25UaW1lb3V0czogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNsYXRlWCB2YWx1ZSBvZiB0aGUgdmlldyBvcmlnaW5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0cmFuc2xhdGVYXz0wXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2xhdGVYXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2xhdGVYIHZhbHVlIG9mIHRoZSB2aWV3IG9yaWdpblxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRyYW5zbGF0ZVlfPTBcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zbGF0ZVlfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRyYW5zbGF0ZVggdmFsdWUgb2YgdGhlIHZpZXcgb3JpZ2luXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdHJhbnNsYXRlWl89MFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNsYXRlWl86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NsczogWydwYWdlJywgJ3ZpZXcnXSwgc3R5bGU6IHt9LCB0YWJJbmRleDogJy0xJywgY246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnb3JpZ2luJywgJ3ZpZXcnXSwgc3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnY2FtZXJhJywgJ3ZpZXcnXSwgc3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ2RvbGx5JywgJ3ZpZXcnXSwgc3R5bGU6IHt9LCBjbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAge2NsczogWyd2aWV3J10sIHN0eWxlOiB7fSwgY246IFtdfVxuICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWVbaXRlbXNNb3VudGVkXSA9IGZhbHNlO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyh7XG4gICAgICAgICAgICBjbGljazogbWUub25DbGljayxcbiAgICAgICAgICAgIHdoZWVsOiBtZS5vbk1vdXNlV2hlZWwsXG4gICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFtb3VudFJvd3MgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QW1vdW50Um93cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc051bWJlcihvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLmFmdGVyU2V0T3JkZXJCeVJvdyhtZS5vcmRlckJ5Um93LCAhbWUub3JkZXJCeVJvdylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG9yaWdpbiA9IG1lLnZkb20uY25bMF0sXG4gICAgICAgICAgICBjYW1lcmEgPSBvcmlnaW4uY25bMF0sXG4gICAgICAgICAgICBkb2xseSAgPSBjYW1lcmEuY25bMF0sXG4gICAgICAgICAgICB2aWV3ICAgPSBkb2xseS5jblswXSxcbiAgICAgICAgICAgIHByZWZpeCA9IG1lLmlkICsgJ19fJztcblxuICAgICAgICBjYW1lcmEuaWQgPSBwcmVmaXggKyAnY2FtZXJhJztcbiAgICAgICAgZG9sbHkgLmlkID0gcHJlZml4ICsgJ2RvbGx5JztcbiAgICAgICAgb3JpZ2luLmlkID0gcHJlZml4ICsgJ29yaWdpbic7XG4gICAgICAgIHZpZXcgIC5pZCA9IHByZWZpeCArICd2aWV3JztcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWF4SXRlbSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhJdGVtcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUucmVuZGVyZWQpIHtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA+IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUuZGVzdHJveUl0ZW1zKHZhbHVlLCBvbGRWYWx1ZSAtIHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVJdGVtcyhvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzZWxlY3Rpb25Nb2RlbH0gPSBtZTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmZvY3VzT25Nb3VudCAmJiBtZS5mb2N1cyhtZS5pZCk7XG5cbiAgICAgICAgICAgIG1lLnRpbWVvdXQoMzAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uICAgIDogJ3JlYWREb20nLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ29mZnNldEhlaWdodCcsICdvZmZzZXRXaWR0aCddLFxuICAgICAgICAgICAgICAgICAgICB2bm9kZUlkICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQgIDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5vZmZzZXRIZWlnaHQgPSBkYXRhLmF0dHJpYnV0ZXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBtZS5vZmZzZXRXaWR0aCAgPSBkYXRhLmF0dHJpYnV0ZXMub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLnNlbGVjdE9uTW91bnQgfHwgc2VsZWN0aW9uTW9kZWwuaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBzZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgICAgICAgPSBzZWxlY3Rpb24ubGVuZ3RoID4gMCAmJiBzZWxlY3Rpb25bMF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gcGFyc2VJbnQoTWF0aC5taW4obWUubWF4SXRlbXMsIG1lLnN0b3JlLmdldENvdW50KCkpIC8gbWUuYW1vdW50Um93cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBtZS5zdG9yZS5nZXRLZXlBdChpbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuaXRlbXMgPSBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBvcmRlckJ5Um93IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0T3JkZXJCeVJvdyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc0Jvb2xlYW4ob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaSAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICA9IE1hdGgubWluKG1lLm1heEl0ZW1zLCBtZS5zdG9yZS5pdGVtcy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHZpZXcgPSBtZS5nZXRJdGVtc1Jvb3QoKTtcblxuICAgICAgICAgICAgaWYgKG1lLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgbWUucmVmcmVzaEltYWdlUmVmbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuY25baV0uc3R5bGUudHJhbnNmb3JtID0gbWUuZ2V0SXRlbVRyYW5zZm9ybShpKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUudGltZW91dCg1MDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNtID0gbWUuc2VsZWN0aW9uTW9kZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNtLmhhc1NlbGVjdGlvbigpICYmIG1lLm9uU2VsZWN0aW9uQ2hhbmdlKHNtLml0ZW1zKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgJiYgdmFsdWUucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICBhZnRlclNldFRyYW5zbGF0ZVgoKSB7dGhpcy5tb3ZlT3JpZ2luKCl9XG4gICAgYWZ0ZXJTZXRUcmFuc2xhdGVZKCkge3RoaXMubW92ZU9yaWdpbigpfVxuICAgIGFmdGVyU2V0VHJhbnNsYXRlWigpIHt0aGlzLm1vdmVPcmlnaW4oKX1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0b3JlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5TdG9yZXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbGxlY3Rpb24uQmFzZXxOZW8uZGF0YS5TdG9yZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBTdG9yZSwge1xuICAgICAgICAgICAgbGlzdGVuZXJzICA6IHtcbiAgICAgICAgICAgICAgICBsb2FkIDogbWUub25TdG9yZUxvYWQsXG4gICAgICAgICAgICAgICAgc29ydCA6IG1lLm9uU29ydCxcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGJlZm9yZUdldEl0ZW1UcGwoKSB7XG4gICAgICAgIHJldHVybiBOZW8uY2xvbmUodGhpcy5faXRlbVRwbCwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIEdhbGxlcnlNb2RlbCwge1xuICAgICAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2hhbmdlOiB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgIHNjb3BlICAgICAgICAgIDogdGhpc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGdldCBkaWZmZXJlbnQgaXRlbS1tYXJrdXBzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21JdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21JdGVtXG4gICAgICovXG4gICAgY3JlYXRlSXRlbSh2ZG9tSXRlbSwgcmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGltYWdlVmRvbSA9IHZkb21JdGVtLmNuWzBdLmNuWzBdO1xuXG4gICAgICAgIHZkb21JdGVtLmlkID0gbWUuZ2V0SXRlbVZub2RlSWQocmVjb3JkW21lLmtleVByb3BlcnR5XSk7XG5cbiAgICAgICAgaW1hZ2VWZG9tLnNyYyA9IE5lby5jb25maWcucmVzb3VyY2VzUGF0aCArICdleGFtcGxlcy8nICsgcmVjb3JkLmltYWdlO1xuXG4gICAgICAgIGltYWdlVmRvbS5zdHlsZS5oZWlnaHQgPSBtZS5pdGVtSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgaW1hZ2VWZG9tLnN0eWxlLndpZHRoICA9IG1lLml0ZW1XaWR0aCAgKyAncHgnO1xuXG4gICAgICAgIHJldHVybiB2ZG9tSXRlbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gdGhlIHN0YXJ0IGluZGV4IGZvciBjcmVhdGluZyBpdGVtcyxcbiAgICAgKiBlLmcuIGluY3JlYXNpbmcgbWF4SXRlbXMgb25seSBuZWVkcyB0byBjcmVhdGUgdGhlIG5ldyBvbmVzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYW1vdW50Um93cyAgICAgICA9IG1lLmFtb3VudFJvd3MsXG4gICAgICAgICAgICBvcmRlckJ5Um93ICAgICAgID0gbWUub3JkZXJCeVJvdyxcbiAgICAgICAgICAgIHNlY29uZExhc3RDb2x1bW4gPSBhbW91bnRSb3dzIC0gMSxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgaXRlbXNSb290ICAgICAgICA9IG1lLmdldEl0ZW1zUm9vdCgpLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgICA9IHN0YXJ0SW5kZXggfHwgMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgICAgPSBNYXRoLm1pbihtZS5tYXhJdGVtcywgbWUuc3RvcmUuaXRlbXMubGVuZ3RoKSxcbiAgICAgICAgICAgIGFtb3VudENvbHVtbnMsIGl0ZW0sIHZkb21JdGVtO1xuXG4gICAgICAgIGlmIChvcmRlckJ5Um93KSB7XG4gICAgICAgICAgICBhbW91bnRDb2x1bW5zID0gTWF0aC5jZWlsKG1lLnN0b3JlLmdldENvdW50KCkgLyBhbW91bnRSb3dzKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSAgICAgID0gbWUuc3RvcmUuaXRlbXNbaV07XG4gICAgICAgICAgICB2ZG9tSXRlbSAgPSBtZS5jcmVhdGVJdGVtKG1lLml0ZW1UcGwsIGl0ZW0sIGkpO1xuXG4gICAgICAgICAgICB2ZG9tSXRlbS4gc3R5bGUgPSB2ZG9tSXRlbS5zdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgdmRvbUl0ZW0uc3R5bGVbJ3RyYW5zZm9ybSddID0gbWUuZ2V0SXRlbVRyYW5zZm9ybShpKTtcblxuICAgICAgICAgICAgaWYgKG9yZGVyQnlSb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBzZWNvbmRMYXN0Q29sdW1uICogYW1vdW50Q29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQodmRvbUl0ZW0uY2xzLCAnbmVvLXJlZmxlY3Rpb24nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgJSBhbW91bnRSb3dzID09PSBzZWNvbmRMYXN0Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZCh2ZG9tSXRlbS5jbHMsICduZW8tcmVmbGVjdGlvbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtc1Jvb3QuY24ucHVzaCh2ZG9tSXRlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIG1lW2l0ZW1zTW91bnRlZF0gPSB0cnVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYW1vdW50SXRlbXNdXG4gICAgICovXG4gICAgZGVzdHJveUl0ZW1zKHN0YXJ0SW5kZXgsIGFtb3VudEl0ZW1zKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY291bnRJdGVtcyAgID0gYW1vdW50SXRlbXMgfHwgbWUuc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIHNlbGVjdGVkSXRlbSA9IG1lLnNlbGVjdGlvbk1vZGVsLml0ZW1zWzBdO1xuXG4gICAgICAgIG1lLmdldEl0ZW1zUm9vdCgpLmNuLnNwbGljZShzdGFydEluZGV4IHx8IDAsIGNvdW50SXRlbXMpO1xuICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICBpZiAobWUuc2VsZWN0aW9uTW9kZWwuaGFzU2VsZWN0aW9uKCkgJiYgc2VsZWN0ZWRJdGVtID4gc3RhcnRJbmRleCAmJiBzZWxlY3RlZEl0ZW0gPCBzdGFydEluZGV4ICsgY291bnRJdGVtcykge1xuICAgICAgICAgICAgbWUuYWZ0ZXJTZXRNb3VudGVkKHRydWUsIGZhbHNlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqL1xuICAgIGdldENhbWVyYVRyYW5zZm9ybUZvckNlbGwoaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthbW91bnRSb3dzLCBpdGVtV2lkdGh9ID0gbWUsXG4gICAgICAgICAgICBnYXAgICAgICAgICAgICAgICAgICAgICA9IDEwLFxuICAgICAgICAgICAgaGVpZ2h0ICAgICAgICAgICAgICAgICAgPSBtZS5vZmZzZXRIZWlnaHQgLyAoYW1vdW50Um93cyArIDIpLFxuICAgICAgICAgICAgc3BhY2luZyAgICAgICAgICAgICAgICAgPSBoZWlnaHQgKyBnYXAsXG4gICAgICAgICAgICB4ICAgICAgICAgICAgICAgICAgICAgICA9IE1hdGguZmxvb3IoaW5kZXggLyBhbW91bnRSb3dzKSxcbiAgICAgICAgICAgIHkgICAgICAgICAgICAgICAgICAgICAgID0gaW5kZXggLSB4ICogYW1vdW50Um93cztcblxuICAgICAgICBpZiAobWUub3JkZXJCeVJvdykge1xuICAgICAgICAgICAgbGV0IGFtb3VudENvbHVtbnMgPSBNYXRoLmNlaWwoTWF0aC5taW4obWUubWF4SXRlbXMsIG1lLnN0b3JlLmdldENvdW50KCkpIC8gYW1vdW50Um93cyk7XG5cbiAgICAgICAgICAgIHggPSBpbmRleCAlIGFtb3VudENvbHVtbnM7XG4gICAgICAgICAgICB5ID0gTWF0aC5mbG9vcihpbmRleCAvIGFtb3VudENvbHVtbnMpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3ggPSB4ICogKGl0ZW1XaWR0aCArIDEwKSxcbiAgICAgICAgICAgIGN5ID0gKHkgKyAwLjUpICogc3BhY2luZyAqIDEuMSArIDUwO1xuXG4gICAgICAgIHJldHVybiBbLWN4LCAtY3ksIDBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBpdGVtSWRcbiAgICAgKi9cbiAgICBnZXRJdGVtSWQodm5vZGVJZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodm5vZGVJZC5zcGxpdCgnX18nKVsxXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZG9tIG5vZGUgY29udGFpbmluZyB0aGUgZ2FsbGVyeSBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBnZXRJdGVtc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bMF0uY25bMF0uY25bMF0uY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEl0ZW1UcmFuc2Zvcm0oaW5kZXgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YW1vdW50Um93c30gPSBtZSxcbiAgICAgICAgICAgIHgsIHk7XG5cbiAgICAgICAgaWYgKG1lLm9yZGVyQnlSb3cpIHtcbiAgICAgICAgICAgIGFtb3VudFJvd3MgPSBNYXRoLmNlaWwoTWF0aC5taW4obWUubWF4SXRlbXMsIG1lLnN0b3JlLmdldENvdW50KCkpIC8gYW1vdW50Um93cyk7XG5cbiAgICAgICAgICAgIHggPSBpbmRleCAlIGFtb3VudFJvd3M7XG4gICAgICAgICAgICB5ID0gTWF0aC5mbG9vcihpbmRleCAvIGFtb3VudFJvd3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcihpbmRleCAvIGFtb3VudFJvd3MpO1xuICAgICAgICAgICAgeSA9IGluZGV4ICUgYW1vdW50Um93c1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlM2QoXG4gICAgICAgICAgICB4ICogKG1lLml0ZW1XaWR0aCAgKyAxMCksXG4gICAgICAgICAgICB5ICogKG1lLml0ZW1IZWlnaHQgKyAxMCkgKyAxMDAsXG4gICAgICAgICAgICAwXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEl0ZW1Wbm9kZUlkKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJ19fJyArIGlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBtb3ZlT3JpZ2luKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZkb20uY25bMF0uc3R5bGUudHJhbnNmb3JtID0gbWUudHJhbnNsYXRlM2QobWUudHJhbnNsYXRlWCwgbWUudHJhbnNsYXRlWSwgbWUudHJhbnNsYXRlWik7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKGRhdGEuaWQgPT09IHRoaXMuaWQgPyAnY29udGFpbmVyQ2xpY2snIDogJ2l0ZW1DbGljaycsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWw/LnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZVdoZWVsKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUubW91c2VXaGVlbEVuYWJsZWQpIHtcbiAgICAgICAgICAgIG1lLl90cmFuc2xhdGVYID0gbWUudHJhbnNsYXRlWCAtIChkYXRhLmRlbHRhWCAqIG1lLm1vdXNlV2hlZWxEZWx0YVgpOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICBtZS5fdHJhbnNsYXRlWiA9IG1lLnRyYW5zbGF0ZVogKyAoZGF0YS5kZWx0YVkgKiBtZS5tb3VzZVdoZWVsRGVsdGFZKTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgICAgICBtZS5tb3ZlT3JpZ2luKCk7XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ2NoYW5nZVRyYW5zbGF0ZVgnLCBtZS5fdHJhbnNsYXRlWCk7XG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2VUcmFuc2xhdGVaJywgbWUuX3RyYW5zbGF0ZVopXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZVxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpbmRleCAgICAgICAgICA9IG1lLnN0b3JlLmluZGV4T2YodmFsdWU/LlswXSB8fCAwKSxcbiAgICAgICAgICAgIHthcHBOYW1lLCBpZCwgaXRlbUhlaWdodCwgaXRlbVdpZHRoLCB3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIGNhbWVyYSAgICAgICAgID0gbWUudmRvbS5jblswXS5jblswXSxcbiAgICAgICAgICAgIGNhbWVyYVN0eWxlICAgID0gY2FtZXJhLnN0eWxlLFxuICAgICAgICAgICAgZG9sbHlUcmFuc2Zvcm0gPSBtZS5nZXRDYW1lcmFUcmFuc2Zvcm1Gb3JDZWxsKGluZGV4KSxcbiAgICAgICAgICAgIGhlaWdodCAgICAgICAgID0gbWUub2Zmc2V0SGVpZ2h0IC8gKG1lLmFtb3VudFJvd3MgKyAyKSxcbiAgICAgICAgICAgIHdpZHRoICAgICAgICAgID0gTWF0aC5yb3VuZChoZWlnaHQgKiBpdGVtV2lkdGggLyBpdGVtSGVpZ2h0KSxcbiAgICAgICAgICAgIHNwYWNpbmcgICAgICAgID0gd2lkdGggKyAxMCxcbiAgICAgICAgICAgIHRpbWVvdXRJZDtcblxuICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpdGVtKVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS50cmFuc2l0aW9uVGltZW91dHMuc3BsaWNlKDAsIG1lLnRyYW5zaXRpb25UaW1lb3V0cy5sZW5ndGgpO1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLnByb21pc2VNZXNzYWdlKCdtYWluJywge1xuICAgICAgICAgICAgYWN0aW9uIDogJ3VwZGF0ZURvbScsXG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgd2luZG93SWQsXG5cbiAgICAgICAgICAgIGRlbHRhczoge1xuICAgICAgICAgICAgICAgIGlkICAgOiBpZCArICdfX2RvbGx5JyxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IG1lLnRyYW5zbGF0ZTNkKC4uLmRvbGx5VHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gOiAncmVhZERvbScsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICB2bm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCxcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uczogW3tcbiAgICAgICAgICAgICAgICAgICAgZm4gICAgICAgICAgICA6ICdnZXRDb21wdXRlZFN0eWxlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zICAgICAgICA6IFtpZCArICdfX2RvbGx5JywgbnVsbF0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtSXNEb21Ob2RlOiBbdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgICAgIDogJ2RlZmF1bHRWaWV3JyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRm5OYW1lICA6ICd0cmFuc2Zvcm0nLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSAgIDogJ3RyYW5zZm9ybSdcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtID0gZGF0YS5mdW5jdGlvbnMudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYLCBhbmdsZTtcblxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0uaW5kZXhPZignbWF0cml4M2QnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gID0gdHJhbnNmb3JtLnN1YnN0cmluZyg5LCB0cmFuc2Zvcm0ubGVuZ3RoIC0gMSk7IC8vIHJlbW92ZSBtYXRyaXgzZCggLi4uIClcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtICA9IHRyYW5zZm9ybS5zcGxpdCgnLCcpLm1hcChlID0+IHBhcnNlRmxvYXQoZSkpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYID0gdHJhbnNmb3JtWzEyXSAvLyBib3R0b20gbGVmdCBlbGVtZW50IG9mIHRoZSA0eDQgbWF0cml4XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtICA9IHRyYW5zZm9ybS5zdWJzdHJpbmcoNywgdHJhbnNmb3JtLmxlbmd0aCAtIDEpOyAvLyByZW1vdmUgbWF0cml4KCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gID0gdHJhbnNmb3JtLnNwbGl0KCcsJykubWFwKGUgPT4gcGFyc2VGbG9hdChlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSB0cmFuc2Zvcm1bNF0gLy8gYm90dG9tIGxlZnQgZWxlbWVudCBvZiB0aGUgMngzIG1hdHJpeFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSB0cmFuc2xhdGVYIC0gZG9sbHlUcmFuc2Zvcm1bMF07XG4gICAgICAgICAgICAgICAgYW5nbGUgICAgICA9IE1hdGgubWluKE1hdGgubWF4KHRyYW5zbGF0ZVggLyAoc3BhY2luZyAqIDMpLCAtMSksIDEpICogNDU7XG5cbiAgICAgICAgICAgICAgICBjYW1lcmFTdHlsZS50cmFuc2Zvcm0gICAgICAgICAgPSBgcm90YXRlWSgke2FuZ2xlfWRlZylgO1xuICAgICAgICAgICAgICAgIGNhbWVyYVN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICczMzBtcyc7XG5cbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobWUudHJhbnNpdGlvblRpbWVvdXRzLCB0aW1lb3V0SWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYVN0eWxlLnRyYW5zZm9ybSAgICAgICAgICA9ICdyb3RhdGVZKDBkZWcpJztcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhU3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzUwMDBtcyc7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgICAgICB9LCAzMzApO1xuXG4gICAgICAgICAgICAgICAgbWUudHJhbnNpdGlvblRpbWVvdXRzLnB1c2godGltZW91dElkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU29ydCgpIHtcbiAgICAgICAgaWYgKHRoaXNbaXRlbXNNb3VudGVkXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaXRlbXMgICAgID0gWy4uLm1lLnN0b3JlLml0ZW1zIHx8IFtdXSxcbiAgICAgICAgICAgICAgICBuZXdDbiAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB2aWV3ICAgICAgPSBtZS5nZXRJdGVtc1Jvb3QoKSxcbiAgICAgICAgICAgICAgICB2ZG9tTWFwICAgPSB2aWV3LmNuLm1hcChlID0+IGUuaWQpLFxuICAgICAgICAgICAgICAgIGZyb21JbmRleCwgdmRvbUlkO1xuXG4gICAgICAgICAgICBpdGVtcy5sZW5ndGggPSBNYXRoLm1pbihtZS5tYXhJdGVtcywgbWUuc3RvcmUuZ2V0Q291bnQoKSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbUlkICAgID0gbWUuZ2V0SXRlbVZub2RlSWQoaXRlbVttZS5rZXlQcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgICAgICBmcm9tSW5kZXggPSB2ZG9tTWFwLmluZGV4T2YodmRvbUlkKTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdDbi5wdXNoKHZpZXcuY25bZnJvbUluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBmcm9tSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNuID0gbmV3Q247XG4gICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuYWZ0ZXJTZXRPcmRlckJ5Um93KG1lLm9yZGVyQnlSb3csICFtZS5vcmRlckJ5Um93KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gICAgICovXG4gICAgb25TdG9yZUxvYWQoaXRlbXMpIHtcbiAgICAgICAgdGhpcy5nZXRJdGVtc1Jvb3QoKS5jbiA9IFtdOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgIHRoaXMuY3JlYXRlSXRlbXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVmcmVzaEltYWdlUmVmbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YW1vdW50Um93cywgb3JkZXJCeVJvd30gPSBtZSxcbiAgICAgICAgICAgIHNlY29uZExhc3RDb2x1bW4gICAgICAgICA9IGFtb3VudFJvd3MgLSAxLFxuICAgICAgICAgICAgdmlldyAgICAgICAgICAgICAgICAgICAgID0gbWUuZ2V0SXRlbXNSb290KCksXG4gICAgICAgICAgICBhbW91bnRDb2x1bW5zO1xuXG4gICAgICAgIGlmIChvcmRlckJ5Um93KSB7XG4gICAgICAgICAgICBhbW91bnRDb2x1bW5zID0gTWF0aC5jZWlsKE1hdGgubWluKG1lLm1heEl0ZW1zLCBtZS5zdG9yZS5nZXRDb3VudCgpKSAvIGFtb3VudFJvd3MpXG4gICAgICAgIH1cblxuICAgICAgICB2aWV3LmNuLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAob3JkZXJCeVJvdykge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5W2luZGV4ID49IHNlY29uZExhc3RDb2x1bW4gKiBhbW91bnRDb2x1bW5zID8gJ2FkZCcgOiAncmVtb3ZlJ10oaXRlbS5jbHMsICduZW8tcmVmbGVjdGlvbicpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5W2luZGV4ICUgYW1vdW50Um93cyA9PT0gc2Vjb25kTGFzdENvbHVtbiAgID8gJ2FkZCcgOiAncmVtb3ZlJ10oaXRlbS5jbHMsICduZW8tcmVmbGVjdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0cmFuc2xhdGUzZCh4LCB5LCB6KSB7XG4gICAgICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsICR7en1weClgXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhHYWxsZXJ5KTtcbiIsImltcG9ydCBNb2RlbCAgICBmcm9tICcuL01vZGVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEEgc2VsZWN0aW9uIG1vZGVsIGludGVuZGVkIHRvIHVzZSBmb3IgTmVvLmNvbXBvbmVudC5HYWxsZXJ5XG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5HYWxsZXJ5TW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uTW9kZWxcbiAqL1xuY2xhc3MgR2FsbGVyeU1vZGVsIGV4dGVuZHMgTW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5HYWxsZXJ5TW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uR2FsbGVyeU1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi1nYWxsZXJ5bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLWdhbGxlcnltb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNscz0nbmVvLXNlbGVjdGlvbi1nYWxsZXJ5bW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsczogJ25lby1zZWxlY3Rpb24tZ2FsbGVyeW1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gc3RheSBpbiB0aGUgc2FtZSBjb2x1bW4gd2hlbiBuYXZpZ2F0aW5nIHdpdGggdGhlIHVwIGFuZCBkb3duIGtleXMsXG4gICAgICAgICAqIG90aGVyd2lzZSB5b3Ugd2lsbCBuYXZpZ2F0ZSB0byB0aGUgbmV4dCAvIHByZXYgY29sdW1uIHdoZW4gbW92aW5nIG91dFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzdGF5SW5Sb3c9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHN0YXlJblJvdzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0byBub3QgYXBwbHkgYSBkb21MaXN0ZW5lclxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVyKCkge31cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db250YWluZXJDbGljaygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSAgID0gbWUsXG4gICAgICAgICAgICBvbGRJdGVtcyA9IFsuLi5tZS5pdGVtc10sXG4gICAgICAgICAgICBkZWx0YXMgICA9IFtdO1xuXG4gICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQgOiB2aWV3LmdldEl0ZW1Wbm9kZUlkKGl0ZW0pLFxuICAgICAgICAgICAgICAgIGNsczoge1xuICAgICAgICAgICAgICAgICAgICBhZGQgICA6IFtdLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IFsnbmVvLXNlbGVjdGVkJ11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaXRlbXMuc3BsaWNlKDAsIG1lLml0ZW1zLmxlbmd0aCk7XG5cbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKHZpZXcuYXBwTmFtZSwgZGVsdGFzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3NlbGVjdGlvbkNoYW5nZScsIG1lLml0ZW1zLCBvbGRJdGVtcylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IGkgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgPSBkYXRhLnBhdGgubGVuZ3RoLFxuICAgICAgICAgICAge3ZpZXd9ID0gdGhpcyxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5wYXRoW2ldLmNscy5pbmNsdWRlcygnbmVvLWdhbGxlcnktaXRlbScpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdmlldy5nZXRJdGVtSWQoZGF0YS5wYXRoW2ldLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChrZXkpO1xuXG4gICAgICAgICAgICAgICAgdmlldy5maXJlKCdzZWxlY3QnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZDogdmlldy5zdG9yZS5nZXQoa2V5KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRG93bihkYXRhKSB7XG4gICAgICAgIHRoaXNbdGhpcy52aWV3Lm9yZGVyQnlSb3cgPyAnb25OYXZLZXlSb3cnIDogJ29uTmF2S2V5Q29sdW1uJ10oMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkxlZnQoZGF0YSkge1xuICAgICAgICB0aGlzW3RoaXMudmlldy5vcmRlckJ5Um93ID8gJ29uTmF2S2V5Q29sdW1uJyA6ICdvbk5hdktleVJvdyddKC0xKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duUmlnaHQoZGF0YSkge1xuICAgICAgICB0aGlzW3RoaXMudmlldy5vcmRlckJ5Um93ID8gJ29uTmF2S2V5Q29sdW1uJyA6ICdvbk5hdktleVJvdyddKDEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25VcChkYXRhKSB7XG4gICAgICAgIHRoaXNbdGhpcy52aWV3Lm9yZGVyQnlSb3cgPyAnb25OYXZLZXlSb3cnIDogJ29uTmF2S2V5Q29sdW1uJ10oLTEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXA9MVxuICAgICAqL1xuICAgIG9uTmF2S2V5Q29sdW1uKHN0ZXA9MSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2aWV3fSAgICAgICA9IG1lLFxuICAgICAgICAgICAge3N0b3JlfSAgICAgID0gdmlldyxcbiAgICAgICAgICAgIHNlbGVjdGVkICAgICA9IG1lLml0ZW1zWzBdLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGluZGV4LCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpbmRleCA9IHN0b3JlLmluZGV4T2Yoc2VsZWN0ZWQpICsgc3RlcFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSAwXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IGNvdW50UmVjb3JkcyAtIDFcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+PSBjb3VudFJlY29yZHMpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQoaW5kZXgpO1xuXG4gICAgICAgIG1lLnNlbGVjdChyZWNvcmRbc3RvcmUua2V5UHJvcGVydHldKTtcblxuICAgICAgICB2aWV3LmZpcmUoJ3NlbGVjdCcsIHtcbiAgICAgICAgICAgIHJlY29yZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwPTFcbiAgICAgKi9cbiAgICBvbk5hdktleVJvdyhzdGVwPTEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3N0YXlJblJvdywgdmlld30gICA9IG1lLFxuICAgICAgICAgICAge2Ftb3VudFJvd3MsIHN0b3JlfSA9IHZpZXcsXG4gICAgICAgICAgICBzZWxlY3RlZCAgICAgICAgICAgID0gbWUuaXRlbXNbMF0sXG4gICAgICAgICAgICBjb3VudFJlY29yZHMgICAgICAgID0gc3RvcmUuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIGluZGV4LCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKHZpZXcub3JkZXJCeVJvdykge1xuICAgICAgICAgICAgYW1vdW50Um93cyA9IE1hdGguY2VpbCh2aWV3LnN0b3JlLmdldENvdW50KCkgLyBhbW91bnRSb3dzKVxuICAgICAgICB9XG5cbiAgICAgICAgc3RlcCAqPSBhbW91bnRSb3dzO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgaW5kZXggPSBzdG9yZS5pbmRleE9mKHNlbGVjdGVkKSArIHN0ZXBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaWYgKCFzdGF5SW5Sb3cpIHtcbiAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCAoY291bnRSZWNvcmRzIC0gYW1vdW50Um93cykpIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBhbW91bnRSb3dzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gY291bnRSZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXlJblJvdykge1xuICAgICAgICAgICAgICAgIGluZGV4LS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA+PSBhbW91bnRSb3dzKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggLT0gYW1vdW50Um93c1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVjb3JkID0gc3RvcmUuZ2V0QXQoaW5kZXgpO1xuXG4gICAgICAgIG1lLnNlbGVjdChyZWNvcmRbc3RvcmUua2V5UHJvcGVydHldKTtcblxuICAgICAgICB2aWV3LmZpcmUoJ3NlbGVjdCcsIHtcbiAgICAgICAgICAgIHJlY29yZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXIoY29tcG9uZW50KTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aWQsIHZpZXd9ID0gbWU7XG5cbiAgICAgICAgdmlldy5vbih7XG4gICAgICAgICAgICBjb250YWluZXJDbGljazogbWUub25Db250YWluZXJDbGljayxcbiAgICAgICAgICAgIGl0ZW1DbGljayAgICAgOiBtZS5vbkl0ZW1DbGljayxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICB2aWV3LmtleXM/Ll9rZXlzLnB1c2goXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25Eb3duJyAgLGtleTogJ0Rvd24nICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93bkxlZnQnICAsa2V5OiAnTGVmdCcgICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duUmlnaHQnICxrZXk6ICdSaWdodCcgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25VcCcgICAgLGtleTogJ1VwJyAgICAsc2NvcGU6IGlkfVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqL1xuICAgIHNlbGVjdChpdGVtSWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1zLCB2aWV3fSA9IG1lLFxuICAgICAgICAgICAgb2xkSXRlbXMgICAgICA9IFsuLi5pdGVtc10sXG4gICAgICAgICAgICBkZWx0YXMgICAgICAgID0gW10sXG4gICAgICAgICAgICB2bm9kZUlkICAgICAgID0gdmlldz8uZ2V0SXRlbVZub2RlSWQoaXRlbUlkKTtcblxuICAgICAgICAvLyBhIHNlbGVjdCgpIGNhbGwgY2FuIGhhcHBlbiBiZWZvcmUgdGhlIHZpZXcgaXMgcmVnaXN0ZXJlZFxuICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgIC8vIHdpbGwgZ2V0IHBpY2tlZCB1cCBieSB2aWV3LmFmdGVyU2V0TW91bnRlZCgpXG4gICAgICAgICAgICBOZW9BcnJheVsnYWRkJ10oaXRlbXMsIGl0ZW1JZCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5zaW5nbGVTZWxlY3QpIHtcbiAgICAgICAgICAgIG1lLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA6IHZpZXcuZ2V0SXRlbVZub2RlSWQoaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQgICA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZTogWyduZW8tc2VsZWN0ZWQnXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdGVtcy5zcGxpY2UoMCwgaXRlbXMubGVuZ3RoKVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgaWQgOiB2bm9kZUlkLFxuICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgYWRkOiBbJ25lby1zZWxlY3RlZCddXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE5lb0FycmF5WydhZGQnXShpdGVtcywgaXRlbUlkKTtcblxuICAgICAgICBpZiAoZGVsdGFzLmxlbmd0aCA+IDAgJiYgdmlldy5tb3VudGVkKSB7XG4gICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXModmlldy5hcHBOYW1lLCBkZWx0YXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZpZXcub25TZWxlY3Q/LihpdGVtcyk7XG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnc2VsZWN0aW9uQ2hhbmdlJywgaXRlbXMsIG9sZEl0ZW1zKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICh2aWV3Lm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHZpZXcub25TZWxlY3Q/LihpdGVtcyk7XG4gICAgICAgICAgICBtZS5maXJlKCdzZWxlY3Rpb25DaGFuZ2UnLCBpdGVtcywgb2xkSXRlbXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIGxldCB7aWQsIHZpZXd9ID0gdGhpcztcblxuICAgICAgICB2aWV3LmtleXM/LnJlbW92ZUtleXMoW1xuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duRG93bicgICxrZXk6ICdEb3duJyAgLHNjb3BlOiBpZH0sXG4gICAgICAgICAgICB7Zm46ICdvbktleURvd25MZWZ0JyAgLGtleTogJ0xlZnQnICAsc2NvcGU6IGlkfSxcbiAgICAgICAgICAgIHtmbjogJ29uS2V5RG93blJpZ2h0JyAsa2V5OiAnUmlnaHQnICxzY29wZTogaWR9LFxuICAgICAgICAgICAge2ZuOiAnb25LZXlEb3duVXAnICAgICxrZXk6ICdVcCcgICAgLHNjb3BlOiBpZH1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgc3VwZXIudW5yZWdpc3RlcigpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhHYWxsZXJ5TW9kZWwpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9