"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_DragZone_mjs"],{

/***/ "./src/draggable/DragProxyComponent.mjs":
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragProxyComponent)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {Boolean} autoRender=true
         */
        autoRender: true,
        /**
         * @member {String[]} cls=['neo-dragproxy']
         */
        cls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.on('mounted', me.onMounted, me);
    }

    /**
     * @param {String} id
     */
    onMounted(id) {
        if (this.moveInMainThread) {
            Neo.main.addon.DragDrop.setDragProxyElement({
                appName: this.appName,
                id     : id
            });
        }
    }
}

Neo.applyClassConfig(DragProxyComponent);




/***/ }),

/***/ "./src/draggable/DragZone.mjs":
/*!************************************!*\
  !*** ./src/draggable/DragZone.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragZone)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.draggable.DragZone
 * @extends Neo.core.Base
 */
class DragZone extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static getStaticConfig() {return {
        /**
         * True automatically applies the core/Observable.mjs mixin
         * @member {Boolean} observable=true
         * @static
         */
        observable: true
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragZone'
         * @protected
         */
        className: 'Neo.draggable.DragZone',
        /**
         * @member {String} ntype='dragzone'
         * @protected
         */
        ntype: 'dragzone',
        /**
         * Adds this.dragProxyCls => 'neo-dragproxy' to the top level dragProxyEl node
         * @member {Boolean} addDragProxyCls=true
         */
        addDragProxyCls: true,
        /**
         * drag:move will by default only fire in case moveInMainThread === false.
         * In case you want to move the dragProxy inside main but still get the event,
         * set this config to true.
         * @member {Boolean} alwaysFireDragMove=false
         */
        alwaysFireDragMove: false,
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName_=null
         */
        appName_: null,
        /**
         * Optionally set a fixed cursor style to the document.body during drag operations
         * @member {String|null} bodyCursorStyle=null
         */
        bodyCursorStyle: null,
        /**
         * @member {String|null} boundaryContainerId=null
         */
        boundaryContainerId: null,
        /**
         * Store data which you want to pass to drop related events here
         * @member {Object|null} data=null
         */
        data: null,
        /**
         * The vdom (tree) of the element you want to drag
         * @member {Object|null} dragElement=null
         */
        dragElement: null,
        /**
         * The bounding client rect of the dragElement
         * Will get set inside dragStart()
         * @member {Object|null} dragElementRect=null
         */
        dragElementRect: null,
        /**
         * @member {Neo.component.Base|null} dragProxy=null
         * @protected
         */
        dragProxy: null,
        /**
         * @member {Object|null} dragProxyConfig=null
         */
        dragProxyConfig_: null,
        /**
         * @member {String} dragProxyCls='neo-dragproxy'
         */
        dragProxyCls: 'neo-dragproxy',
        /**
         * You can either pass an array of (dom) ids or cls rules or both
         * @example
         * dropZoneIdentifier: {
         *     ids: ['foo','bar']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2'],
         *     ids: ['foo','bar']
         * }
         * @member {Object|null} dropZoneIdentifier=null
         */
        dropZoneIdentifier: null,
        /**
         * @member {Boolean} moveHorizontal=true
         */
        moveHorizontal: true,
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true,
        /**
         * @member {Boolean} moveVertical=true
         */
        moveVertical: true,
        /**
         * @member {Number} offsetX=0
         */
        offsetX: 0,
        /**
         * @member {Number} offsetY=0
         */
        offsetY: 0,
        /**
         * @member {Neo.component.Base|null} owner=null
         */
        owner: null,
        /**
         * @member {String} proxyParentId_='document.body'
         */
        proxyParentId_: 'document.body',
        /**
         * @member {String|null} scrollContainerId=null
         */
        scrollContainerId: null,
        /**
         * @member {Number} scrollFactorLeft=1
         */
        scrollFactorLeft: 1,
        /**
         * @member {Number} scrollFactorTop=1
         */
        scrollFactorTop: 1,
        /**
         * True creates a position:absolute wrapper div which contains the cloned element
         * @member {Boolean} useProxyWrapper=true
         */
        useProxyWrapper: true
    }}

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        if (!Neo.main.addon.DragDrop) {
            console.error('You can not use Neo.draggable.DragZone without adding Neo.main.addon.DragDrop to the main thread addons', this.id);
        }
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        if (value) {
            Neo.currentWorker.insertThemeFiles(value, this.__proto__);
        }
    }

    /**
     * Triggered when accessing the dragProxyConfig config
     * We are re-using this config to create multiple dragProxies,
     * so it is important to work with a clone. see: createDragProxy()
     * @param {Object} value
     * @protected
     */
    beforeGetDragProxyConfig(value) {
        return Neo.clone(value, true, true);
    }

    /**
     * @param {Object} data
     */
    createDragProxy(data) {
        let me        = this,
            component = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            rect      = me.dragElementRect,
            vdom      = me.dragProxyConfig?.vdom,
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].clone(vdom ? vdom : me.dragElement);

        const config = {
            module          : _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,

            ...me.dragProxyConfig,

            vdom: me.useProxyWrapper ? {cn: [clone]} : clone // we want to override dragProxyConfig.vdom if needed
        };

        config.cls = config.cls || [];

        if (component) {
            config.cls.push(component.getTheme());
        }

        if (clone.cls && !me.useProxyWrapper) {
            config.cls.push(...clone.cls);
        }

        if (me.addDragProxyCls && config.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(config.cls, me.dragProxyCls);
        }

        config.style = config.style || {};

        Object.assign(config.style, {
            height: `${data.height}px`,
            left  : `${me.moveHorizontal ? data.x : rect.x}px`,
            top   : `${me.moveVertical   ? data.y : rect.y}px`,
            width : `${data.width}px`
        });

        me.dragProxy = Neo.create(config);
    }

    /**
     * Override for using custom animations
     */
    destroyDragProxy() {
        let me = this,
            id = me.dragProxy.id;

        setTimeout(() => {
            Neo.currentWorker.promiseMessage('main', {
                action : 'updateDom',
                appName: me.appName,
                deltas : [{action: 'removeNode', id: id}]
            });
        }, me.moveInMainThread ? 0 : 30);

        me.dragProxy.destroy();
    }

    /**
     * @param {Object} data
     */
    dragEnd(data) {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, 'neo-is-dragging');
        owner.cls = cls;

        if (me.dragProxy) {
            me.destroyDragProxy();
            me.dragProxy = null;
        }

        Object.assign(me, {
            dragElementRect  : null,
            offsetX          : 0,
            offsetY          : 0,
            scrollContainerId: null
        });

        me.fire('dragEnd', data);

        me.resetData();
    }

    /**
     * @param {Object} data
     */
    dragMove(data) {
        let me = this,
            style;

        if (!me.moveInMainThread && me.dragProxy) {
            style = me.dragProxy.style;

            if (me.moveHorizontal) {
                style.left = `${data.clientX - me.offsetX}px`;
            }

            if (me.moveVertical) {
                style.top = `${data.clientY - me.offsetY}px`;
            }

            me.dragProxy.style = style;
        }

        me.fire('dragMove', data);
    }

    /**
     * @param {Object} data
     */
    dragStart(data) {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls,
            rect  = me.getDragElementRect(data),
            offsetX, offsetY;

        me.setData();

        Neo.main.addon.DragDrop.setConfigs({
            appName: me.appName,
            ...me.getMainThreadConfigs()
        });

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(cls, 'neo-is-dragging');
        owner.cls = cls;

        offsetX = data.clientX - rect.left;
        offsetY = data.clientY - rect.top;

        Object.assign(me, {
            dragElementRect: rect,
            offsetX        : offsetX,
            offsetY        : offsetY
        });

        me.createDragProxy(rect);

        me.fire('dragStart', {
            clientX        : data.clientX,
            clientY        : data.clientY,
            dragElementRect: rect,
            eventData      : data,
            id             : me.id,
            offsetX        : offsetX,
            offsetY        : offsetY
        });
    }

    /**
     * @param {Object} data
     * @returns {Object}
     */
    getDragElementRect(data) {
        let me = this,
            id = me.getDragElementRoot().id;

        for (let item of data.path) {
            if (item.id === id) {
                return item.rect;
            }
        }

        for (let item of data.targetPath) {
            if (item.id === id) {
                return item.rect;
            }
        }

        return null;
    }

    /**
     * Override this method in case you want to wrap your dragElement.
     * See: draggable.tree.DragZone
     * @returns {Object}
     */
    getDragElementRoot() {
        return this.dragElement;
    }

    /**
     * Override this method inside class extensions to add more configs
     * which get passed to main.addon.DragDrop onDragStart()
     * @returns {Object}
     * @protected
     */
    getMainThreadConfigs() {
        let me = this;

        return {
            alwaysFireDragMove : me.alwaysFireDragMove,
            bodyCursorStyle    : me.bodyCursorStyle,
            boundaryContainerId: me.boundaryContainerId,
            dragElementRootId  : me.getDragElementRoot().id,
            dragProxyCls       : me.dragProxyCls,
            dragZoneId         : me.id,
            dropZoneIdentifier : me.dropZoneIdentifier,
            moveHorizontal     : me.moveHorizontal,
            moveVertical       : me.moveVertical,
            scrollContainerId  : me.scrollContainerId,
            scrollFactorLeft   : me.scrollFactorLeft,
            scrollFactorTop    : me.scrollFactorTop
        };
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDrop(data) {
        this.fire('drop', data);
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropEnter(data) {
        this.fire('drop:enter', data);
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropLeave(data) {
        this.fire('drop:leave', data);
    }

    /**
     *
     */
    resetData() {
        setTimeout(() => {
            this.data = null;
        }, 30);
    }

    /**
     * Extend this method for child classes to pass additional properties
     * @param {Object} data={}
     */
    setData(data={}) {
        let me = this;

        me.data = {
            dragElement: me.getDragElementRoot(),
            dragZoneId : me.id,
            ...data
        };
    }
}

Neo.applyClassConfig(DragZone);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfRHJhZ1pvbmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyREFBSTtBQUNyQyx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRXVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlEVztBQUNRO0FBQ1A7QUFDSztBQUNOOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBSTtBQUMzQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFB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Uzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9EcmFnUHJveHlDb21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL0RyYWdab25lLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIERyYWdQcm94eUNvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBnZXRDb25maWcoKSB7cmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZHJhZ3Byb3h5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RyYWdwcm94eScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b1JlbmRlcj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvUmVuZGVyOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNscz1bJ25lby1kcmFncHJveHknXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzOiBbJ25lby1kcmFncHJveHknXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVJbk1haW5UaHJlYWQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUluTWFpblRocmVhZDogdHJ1ZVxuICAgIH19XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm9uKCdtb3VudGVkJywgbWUub25Nb3VudGVkLCBtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICovXG4gICAgb25Nb3VudGVkKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmVJbk1haW5UaHJlYWQpIHtcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldERyYWdQcm94eUVsZW1lbnQoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWU6IHRoaXMuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgOiBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKERyYWdQcm94eUNvbXBvbmVudCk7XG5cbmV4cG9ydCB7RHJhZ1Byb3h5Q29tcG9uZW50IGFzIGRlZmF1bHR9O1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb21wb25lbnQgZnJvbSAnLi9EcmFnUHJveHlDb21wb25lbnQubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1pvbmUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS9PYnNlcnZhYmxlLm1qcyBtaXhpblxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgb2JzZXJ2YWJsZTogdHJ1ZVxuICAgIH19XG5cbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnWm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFnem9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFnem9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHRoaXMuZHJhZ1Byb3h5Q2xzID0+ICduZW8tZHJhZ3Byb3h5JyB0byB0aGUgdG9wIGxldmVsIGRyYWdQcm94eUVsIG5vZGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWRkRHJhZ1Byb3h5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFkZERyYWdQcm94eUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYWc6bW92ZSB3aWxsIGJ5IGRlZmF1bHQgb25seSBmaXJlIGluIGNhc2UgbW92ZUluTWFpblRocmVhZCA9PT0gZmFsc2UuXG4gICAgICAgICAqIEluIGNhc2UgeW91IHdhbnQgdG8gbW92ZSB0aGUgZHJhZ1Byb3h5IGluc2lkZSBtYWluIGJ1dCBzdGlsbCBnZXQgdGhlIGV2ZW50LFxuICAgICAgICAgKiBzZXQgdGhpcyBjb25maWcgdG8gdHJ1ZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWx3YXlzRmlyZURyYWdNb3ZlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhbHdheXNGaXJlRHJhZ01vdmU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIEFwcCB0aGlzIGluc3RhbmNlIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFwcE5hbWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWxseSBzZXQgYSBmaXhlZCBjdXJzb3Igc3R5bGUgdG8gdGhlIGRvY3VtZW50LmJvZHkgZHVyaW5nIGRyYWcgb3BlcmF0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYm9keUN1cnNvclN0eWxlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGJvZHlDdXJzb3JTdHlsZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBib3VuZGFyeUNvbnRhaW5lcklkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZSBkYXRhIHdoaWNoIHlvdSB3YW50IHRvIHBhc3MgdG8gZHJvcCByZWxhdGVkIGV2ZW50cyBoZXJlXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkYXRhPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmRvbSAodHJlZSkgb2YgdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gZHJhZ1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJhZ0VsZW1lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0VsZW1lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgdGhlIGRyYWdFbGVtZW50XG4gICAgICAgICAqIFdpbGwgZ2V0IHNldCBpbnNpZGUgZHJhZ1N0YXJ0KClcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyYWdFbGVtZW50UmVjdD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gZHJhZ1Byb3h5PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyYWdQcm94eUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHlDb25maWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkcmFnUHJveHlDbHM9J25lby1kcmFncHJveHknXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHlDbHM6ICduZW8tZHJhZ3Byb3h5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gZWl0aGVyIHBhc3MgYW4gYXJyYXkgb2YgKGRvbSkgaWRzIG9yIGNscyBydWxlcyBvciBib3RoXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGRyb3Bab25lSWRlbnRpZmllcjoge1xuICAgICAgICAgKiAgICAgaWRzOiBbJ2ZvbycsJ2JhciddXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogZHJvcFpvbmVJZGVudGlmaWVyOiB7XG4gICAgICAgICAqICAgICBjbHM6IFsnbXktY2xhc3MtMScsJ215LWNsYXNzLTInXVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGRyb3Bab25lSWRlbnRpZmllcjoge1xuICAgICAgICAgKiAgICAgY2xzOiBbJ215LWNsYXNzLTEnLCdteS1jbGFzcy0yJ10sXG4gICAgICAgICAqICAgICBpZHM6IFsnZm9vJywnYmFyJ11cbiAgICAgICAgICogfVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJvcFpvbmVJZGVudGlmaWVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lSWRlbnRpZmllcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVIb3Jpem9udGFsPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVIb3Jpem9udGFsOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZVZlcnRpY2FsPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gb2Zmc2V0WD0wXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBvZmZzZXRZPTBcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gb3duZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHByb3h5UGFyZW50SWRfPSdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgKi9cbiAgICAgICAgcHJveHlQYXJlbnRJZF86ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzY3JvbGxDb250YWluZXJJZD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxDb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsRmFjdG9yTGVmdD0xXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxGYWN0b3JMZWZ0OiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxGYWN0b3JUb3A9MVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsRmFjdG9yVG9wOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBjcmVhdGVzIGEgcG9zaXRpb246YWJzb2x1dGUgd3JhcHBlciBkaXYgd2hpY2ggY29udGFpbnMgdGhlIGNsb25lZCBlbGVtZW50XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVByb3h5V3JhcHBlcj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VQcm94eVdyYXBwZXI6IHRydWVcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignWW91IGNhbiBub3QgdXNlIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmUgd2l0aG91dCBhZGRpbmcgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3AgdG8gdGhlIG1haW4gdGhyZWFkIGFkZG9ucycsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMuX19wcm90b19fKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZHJhZ1Byb3h5Q29uZmlnIGNvbmZpZ1xuICAgICAqIFdlIGFyZSByZS11c2luZyB0aGlzIGNvbmZpZyB0byBjcmVhdGUgbXVsdGlwbGUgZHJhZ1Byb3hpZXMsXG4gICAgICogc28gaXQgaXMgaW1wb3J0YW50IHRvIHdvcmsgd2l0aCBhIGNsb25lLiBzZWU6IGNyZWF0ZURyYWdQcm94eSgpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldERyYWdQcm94eUNvbmZpZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvLmNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGNyZWF0ZURyYWdQcm94eShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChtZS5nZXREcmFnRWxlbWVudFJvb3QoKS5pZCkgfHwgbWUub3duZXIsXG4gICAgICAgICAgICByZWN0ICAgICAgPSBtZS5kcmFnRWxlbWVudFJlY3QsXG4gICAgICAgICAgICB2ZG9tICAgICAgPSBtZS5kcmFnUHJveHlDb25maWc/LnZkb20sXG4gICAgICAgICAgICBjbG9uZSAgICAgPSBWRG9tVXRpbC5jbG9uZSh2ZG9tID8gdmRvbSA6IG1lLmRyYWdFbGVtZW50KTtcblxuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgICAgOiBEcmFnUHJveHlDb21wb25lbnQsXG4gICAgICAgICAgICBhcHBOYW1lICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgbW92ZUluTWFpblRocmVhZDogbWUubW92ZUluTWFpblRocmVhZCxcbiAgICAgICAgICAgIHBhcmVudElkICAgICAgICA6IG1lLnByb3h5UGFyZW50SWQsXG5cbiAgICAgICAgICAgIC4uLm1lLmRyYWdQcm94eUNvbmZpZyxcblxuICAgICAgICAgICAgdmRvbTogbWUudXNlUHJveHlXcmFwcGVyID8ge2NuOiBbY2xvbmVdfSA6IGNsb25lIC8vIHdlIHdhbnQgdG8gb3ZlcnJpZGUgZHJhZ1Byb3h5Q29uZmlnLnZkb20gaWYgbmVlZGVkXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uZmlnLmNscyA9IGNvbmZpZy5jbHMgfHwgW107XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKGNvbXBvbmVudC5nZXRUaGVtZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9uZS5jbHMgJiYgIW1lLnVzZVByb3h5V3JhcHBlcikge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKC4uLmNsb25lLmNscyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuYWRkRHJhZ1Byb3h5Q2xzICYmIGNvbmZpZy5jbHMpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjb25maWcuY2xzLCBtZS5kcmFnUHJveHlDbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLnN0eWxlID0gY29uZmlnLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLnN0eWxlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IGAke2RhdGEuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIGxlZnQgIDogYCR7bWUubW92ZUhvcml6b250YWwgPyBkYXRhLnggOiByZWN0Lnh9cHhgLFxuICAgICAgICAgICAgdG9wICAgOiBgJHttZS5tb3ZlVmVydGljYWwgICA/IGRhdGEueSA6IHJlY3QueX1weGAsXG4gICAgICAgICAgICB3aWR0aCA6IGAke2RhdGEud2lkdGh9cHhgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdQcm94eSA9IE5lby5jcmVhdGUoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBmb3IgdXNpbmcgY3VzdG9tIGFuaW1hdGlvbnNcbiAgICAgKi9cbiAgICBkZXN0cm95RHJhZ1Byb3h5KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaWQgPSBtZS5kcmFnUHJveHkuaWQ7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gOiAndXBkYXRlRG9tJyxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGRlbHRhcyA6IFt7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkOiBpZH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbWUubW92ZUluTWFpblRocmVhZCA/IDAgOiAzMCk7XG5cbiAgICAgICAgbWUuZHJhZ1Byb3h5LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgb3duZXIgPSBtZS5vd25lcixcbiAgICAgICAgICAgIGNscyAgID0gb3duZXIuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8taXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgb3duZXIuY2xzID0gY2xzO1xuXG4gICAgICAgIGlmIChtZS5kcmFnUHJveHkpIHtcbiAgICAgICAgICAgIG1lLmRlc3Ryb3lEcmFnUHJveHkoKTtcbiAgICAgICAgICAgIG1lLmRyYWdQcm94eSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBkcmFnRWxlbWVudFJlY3QgIDogbnVsbCxcbiAgICAgICAgICAgIG9mZnNldFggICAgICAgICAgOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WSAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXJJZDogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5maXJlKCdkcmFnRW5kJywgZGF0YSk7XG5cbiAgICAgICAgbWUucmVzZXREYXRhKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBkcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBzdHlsZTtcblxuICAgICAgICBpZiAoIW1lLm1vdmVJbk1haW5UaHJlYWQgJiYgbWUuZHJhZ1Byb3h5KSB7XG4gICAgICAgICAgICBzdHlsZSA9IG1lLmRyYWdQcm94eS5zdHlsZTtcblxuICAgICAgICAgICAgaWYgKG1lLm1vdmVIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IGAke2RhdGEuY2xpZW50WCAtIG1lLm9mZnNldFh9cHhgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUubW92ZVZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gYCR7ZGF0YS5jbGllbnRZIC0gbWUub2Zmc2V0WX1weGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmRyYWdQcm94eS5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZSgnZHJhZ01vdmUnLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyLFxuICAgICAgICAgICAgY2xzICAgPSBvd25lci5jbHMsXG4gICAgICAgICAgICByZWN0ICA9IG1lLmdldERyYWdFbGVtZW50UmVjdChkYXRhKSxcbiAgICAgICAgICAgIG9mZnNldFgsIG9mZnNldFk7XG5cbiAgICAgICAgbWUuc2V0RGF0YSgpO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldENvbmZpZ3Moe1xuICAgICAgICAgICAgYXBwTmFtZTogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIC4uLm1lLmdldE1haW5UaHJlYWRDb25maWdzKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1pcy1kcmFnZ2luZycpO1xuICAgICAgICBvd25lci5jbHMgPSBjbHM7XG5cbiAgICAgICAgb2Zmc2V0WCA9IGRhdGEuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgb2Zmc2V0WSA9IGRhdGEuY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdDogcmVjdCxcbiAgICAgICAgICAgIG9mZnNldFggICAgICAgIDogb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFkgICAgICAgIDogb2Zmc2V0WVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5jcmVhdGVEcmFnUHJveHkocmVjdCk7XG5cbiAgICAgICAgbWUuZmlyZSgnZHJhZ1N0YXJ0Jywge1xuICAgICAgICAgICAgY2xpZW50WCAgICAgICAgOiBkYXRhLmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZICAgICAgICA6IGRhdGEuY2xpZW50WSxcbiAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdDogcmVjdCxcbiAgICAgICAgICAgIGV2ZW50RGF0YSAgICAgIDogZGF0YSxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICBvZmZzZXRYICAgICAgICA6IG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZICAgICAgICA6IG9mZnNldFlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldERyYWdFbGVtZW50UmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpZCA9IG1lLmdldERyYWdFbGVtZW50Um9vdCgpLmlkO1xuXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgZGF0YS5wYXRoKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5yZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBkYXRhLnRhcmdldFBhdGgpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBjYXNlIHlvdSB3YW50IHRvIHdyYXAgeW91ciBkcmFnRWxlbWVudC5cbiAgICAgKiBTZWU6IGRyYWdnYWJsZS50cmVlLkRyYWdab25lXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREcmFnRWxlbWVudFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluc2lkZSBjbGFzcyBleHRlbnNpb25zIHRvIGFkZCBtb3JlIGNvbmZpZ3NcbiAgICAgKiB3aGljaCBnZXQgcGFzc2VkIHRvIG1haW4uYWRkb24uRHJhZ0Ryb3Agb25EcmFnU3RhcnQoKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldE1haW5UaHJlYWRDb25maWdzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbHdheXNGaXJlRHJhZ01vdmUgOiBtZS5hbHdheXNGaXJlRHJhZ01vdmUsXG4gICAgICAgICAgICBib2R5Q3Vyc29yU3R5bGUgICAgOiBtZS5ib2R5Q3Vyc29yU3R5bGUsXG4gICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5ib3VuZGFyeUNvbnRhaW5lcklkLFxuICAgICAgICAgICAgZHJhZ0VsZW1lbnRSb290SWQgIDogbWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWQsXG4gICAgICAgICAgICBkcmFnUHJveHlDbHMgICAgICAgOiBtZS5kcmFnUHJveHlDbHMsXG4gICAgICAgICAgICBkcmFnWm9uZUlkICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIGRyb3Bab25lSWRlbnRpZmllciA6IG1lLmRyb3Bab25lSWRlbnRpZmllcixcbiAgICAgICAgICAgIG1vdmVIb3Jpem9udGFsICAgICA6IG1lLm1vdmVIb3Jpem9udGFsLFxuICAgICAgICAgICAgbW92ZVZlcnRpY2FsICAgICAgIDogbWUubW92ZVZlcnRpY2FsLFxuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQgIDogbWUuc2Nyb2xsQ29udGFpbmVySWQsXG4gICAgICAgICAgICBzY3JvbGxGYWN0b3JMZWZ0ICAgOiBtZS5zY3JvbGxGYWN0b3JMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsRmFjdG9yVG9wICAgIDogbWUuc2Nyb2xsRmFjdG9yVG9wXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIG92ZXJyaWRlIHRoZSBoYW5kbGVyIG9yIGxpc3RlbiB0byB0aGUgZXZlbnQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Ecm9wKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdkcm9wJywgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIG92ZXJyaWRlIHRoZSBoYW5kbGVyIG9yIGxpc3RlbiB0byB0aGUgZXZlbnQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Ecm9wRW50ZXIoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ2Ryb3A6ZW50ZXInLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgdGhpcyBjbGFzcyBhbmQgb3ZlcnJpZGUgdGhlIGhhbmRsZXIgb3IgbGlzdGVuIHRvIHRoZSBldmVudCBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyb3BMZWF2ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnZHJvcDpsZWF2ZScsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVzZXREYXRhKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIH0sIDMwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgdGhpcyBtZXRob2QgZm9yIGNoaWxkIGNsYXNzZXMgdG8gcGFzcyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YT17fVxuICAgICAqL1xuICAgIHNldERhdGEoZGF0YT17fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmRhdGEgPSB7XG4gICAgICAgICAgICBkcmFnRWxlbWVudDogbWUuZ2V0RHJhZ0VsZW1lbnRSb290KCksXG4gICAgICAgICAgICBkcmFnWm9uZUlkIDogbWUuaWQsXG4gICAgICAgICAgICAuLi5kYXRhXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5OZW8uYXBwbHlDbGFzc0NvbmZpZyhEcmFnWm9uZSk7XG5cbmV4cG9ydCB7RHJhZ1pvbmUgYXMgZGVmYXVsdH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=