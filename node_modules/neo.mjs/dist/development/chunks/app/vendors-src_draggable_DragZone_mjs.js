"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_DragZone_mjs"],{

/***/ "./src/draggable/DragZone.mjs"
/*!************************************!*\
  !*** ./src/draggable/DragZone.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DragProxyContainer.mjs */ "./src/draggable/DragProxyContainer.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");








/**
 * @class Neo.draggable.DragZone
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class DragZone extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.draggable.DragZone'
         * @protected
         */
        className: 'Neo.draggable.DragZone',
        /**
         * @member {String} ntype='dragzone'
         * @protected
         */
        ntype: 'dragzone',
        /**
         * Adds this.dragProxyCls => 'neo-dragproxy' to the top level dragProxyEl node
         * @member {Boolean} addDragProxyCls=true
         */
        addDragProxyCls: true,
        /**
         * Allow the drag proxy to move outside of the boundaryContainerId.
         * @member {Boolean} allowOverdrag=false
         */
        allowOverdrag: false,
        /**
         * drag:move will by default only fire in case moveInMainThread === false.
         * In case you want to move the dragProxy inside main but still get the event,
         * set this config to true.
         * @member {Boolean} alwaysFireDragMove=false
         */
        alwaysFireDragMove: false,
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * Optionally set a fixed cursor style to the document.body during drag operations
         * @member {String|null} bodyCursorStyle=null
         */
        bodyCursorStyle: null,
        /**
         * Limit the zone in which you can drag an element.
         * You can pass a node id, or an array of 2 node ids, in case you need an intersection.
         * Example for 2 ids: grid.header.Toolbar => boundaryContainerId: [id, me.parent.id]
         * @member {String|String[]|null} boundaryContainerId=null
         */
        boundaryContainerId: null,
        /**
         * Stores the DOMRect matching this.boundaryContainerId
         * @member {DOMRect|null} data=null
         * @protected
         */
        boundaryContainerRect: null,
        /**
         * Store data which you want to pass to drop related events here
         * @member {Object|null} data=null
         */
        data: null,
        /**
         * The vdom (tree) of the element you want to drag
         * @member {Object|null} dragElement=null
         */
        dragElement: null,
        /**
         * The bounding client rect of the dragElement
         * Will get set inside dragStart()
         * @member {Object|null} dragElementRect=null
         */
        dragElementRect: null,
        /**
         * @member {Neo.component.Base|null} dragProxy=null
         * @protected
         */
        dragProxy: null,
        /**
         * @member {Object|null} dragProxyConfig_=null
         * @reactive
         */
        dragProxyConfig_: null,
        /**
         * @member {String} dragProxyCls='neo-dragproxy'
         */
        dragProxyCls: 'neo-dragproxy',
        /**
         * You can either pass an array of (dom) ids or cls rules or both
         * @example
         * dropZoneIdentifier: {
         *     ids: ['foo','bar']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2'],
         *     ids: ['foo','bar']
         * }
         * @member {Object|null} dropZoneIdentifier=null
         */
        dropZoneIdentifier: null,
        /**
         * @member {Boolean} moveHorizontal=true
         */
        moveHorizontal: true,
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true,
        /**
         * @member {Boolean} moveVertical=true
         */
        moveVertical: true,
        /**
         * @member {Number} offsetX=0
         */
        offsetX: 0,
        /**
         * @member {Number} offsetY=0
         */
        offsetY: 0,
        /**
         * @member {Neo.component.Base|null} owner=null
         */
        owner: null,
        /**
         * @member {String} proxyParentId_='document.body'
         * @reactive
         */
        proxyParentId_: 'document.body',
        /**
         * @member {String|null} scrollContainerId=null
         */
        scrollContainerId: null,
        /**
         * @member {Number} scrollFactorLeft=1
         */
        scrollFactorLeft: 1,
        /**
         * @member {Number} scrollFactorTop=1
         */
        scrollFactorTop: 1,
        /**
         * True creates a position:absolute wrapper div which contains the cloned element
         * @member {Boolean} useProxyWrapper=true
         */
        useProxyWrapper: true,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        if (!Neo.main.addon.DragDrop) {
            console.error('You can not use Neo.draggable.DragZone without adding Neo.main.addon.DragDrop to the main thread addons', this.id)
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Triggered when accessing the dragProxyConfig config
     * We are re-using this config to create multiple dragProxies,
     * so it is important to work with a clone. see: createDragProxy()
     * @param {Object} value
     * @protected
     */
    beforeGetDragProxyConfig(value) {
        return Neo.clone(value, true, true)
    }

    /**
     * @param {Object}  data
     * @param {Boolean} createComponent=true
     * @returns {Object|Neo.draggable.DragProxyComponent}
     */
    async createDragProxy(data, createComponent=true) {
        let me          = this,
            component   = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            rect        = me.dragElementRect,
            proxyConfig = me.dragProxyConfig || {},
            isContainer = proxyConfig.module === _DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            vdom        = proxyConfig.vdom,
            clone       = !isContainer && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].clone(vdom ? vdom : me.dragElement),
            config, proxy;

        config = {
            module          : _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,
            windowId        : me.windowId,

            ...proxyConfig
        };

        if (isContainer) {
            // We use manual deltas to move the component, so the proxy VDOM starts empty
            config.height          = `${data.height}px`;
            config.items           = [];
            config.parentComponent = me.owner;
            config.width           = `${data.width}px`;

            config.cls = config.cls || [];
            config.cls.push('neo-draggable');
        } else {
            config.vdom = me.useProxyWrapper ? {cn: [clone]} : clone;

            if (clone.cls && !me.useProxyWrapper) {
                config.cls = config.cls || [];
                config.cls.push(...clone.cls)
            }
        }

        config.cls = config.cls || [];

        if (component) {
            config.cls.push(component.getTheme())
        }

        if (me.addDragProxyCls && config.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(config.cls, me.dragProxyCls)
        }

        config.style = config.style || {};

        Object.assign(config.style, {
            height: `${data.height}px`,
            left  : `${me.moveHorizontal ? data.x : rect.x}px`,
            top   : `${me.moveVertical   ? data.y : rect.y}px`,
            width : `${data.width}px`
        });

        if (createComponent) {
            if (isContainer) {
                config.autoInitVnode = true;
                config.autoMount     = true
            }

            me.dragProxy = proxy = Neo.create(config);

            if (isContainer) {
                await proxy.mountedPromise;

                me.dragPlaceholder = Neo.create({
                    module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    flex  : component.flex,
                    style : {height: `${data.height}px`, visibility: 'hidden', width: `${data.width}px`}
                });

                // Copy layout configs
                if (component.minHeight) me.dragPlaceholder.minHeight = component.minHeight;
                if (component.minWidth)  me.dragPlaceholder.minWidth  = component.minWidth;

                me.dragStartIndex = me.owner.items.indexOf(component);

                // Fetch the vnode from the vdom worker, without mounting it.
                const {vnode} = await Neo.vdom.Helper.create({vdom: me.dragPlaceholder.vdom});

                // Manual DOM manipulation to preserve Component state (e.g., Canvas or Charts)
                await Neo.applyDeltas(me.windowId, [{
                    action  : 'insertNode',
                    index   : me.dragStartIndex,
                    parentId: me.owner.getVdomItemsRoot().id,
                    vnode
                }, {
                    action  : 'moveNode',
                    id      : component.id,
                    index   : 0,
                    parentId: proxy.id
                }]);

                me.dragPlaceholder.set({
                    vnode,
                    mounted         : true,
                    vnodeInitialized: true
                })
            }

            return proxy
        }

        return config
    }

    /**
     * Override for using custom animations
     */
    destroyDragProxy() {
        let me = this,
            id = me.dragProxy.id;

        me.timeout(me.moveInMainThread ? 0 : 30).then(() => {
            Neo.applyDeltas(me.windowId, [{action: 'removeNode', id}])
        });

        me.dragProxy.destroy()
    }

    /**
     * @param {Object} data
     */
    dragEnd(data) {
        let me      = this,
            {owner} = me,
            {cls}   = owner;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(cls, 'neo-is-dragging');
        owner.cls = cls;

        if (me.dragProxy) {
            if (me.dragPlaceholder) {
                me.dragPlaceholder.destroy();
                me.dragPlaceholder = null
            }

            me.destroyDragProxy();
            me.dragProxy = null
        }

        Object.assign(me, {
            dragElementRect  : null,
            dragStartIndex   : null,
            offsetX          : 0,
            offsetY          : 0,
            scrollContainerId: null
        });

        me.fire('dragEnd', data);

        me.resetData()
    }

    /**
     * @param {Object} data
     */
    dragMove(data) {
        let me = this,
            style;

        if (!me.moveInMainThread && me.dragProxy) {
            style = me.dragProxy.style;

            if (me.moveHorizontal) {
                style.left = `${data.clientX - me.offsetX}px`;
            }

            if (me.moveVertical) {
                style.top = `${data.clientY - me.offsetY}px`;
            }

            me.dragProxy.style = style;
        }

        me.fire('dragMove', data)
    }

    /**
     * @param {Object} data
     */
    async dragStart(data) {
        let me                         = this,
            {appName, owner, windowId} = me,
            {cls}                      = owner,
            rect                       = me.getDragElementRect(data),
            mainData, offsetX, offsetY;

        me.setData();

        mainData = await Neo.main.addon.DragDrop.setConfigs({
            appName,
            windowId,
            ...me.getMainThreadConfigs()
        });

        me.boundaryContainerRect = mainData.boundaryContainerRect

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(cls, 'neo-is-dragging');
        owner.cls = cls;

        offsetX = data.clientX - rect.left;
        offsetY = data.clientY - rect.top;

        Object.assign(me, {
            dragElementRect: rect,
            offsetX,
            offsetY
        });

        await me.createDragProxy(rect);

        me.fire('dragStart', {
            clientX        : data.clientX,
            clientY        : data.clientY,
            dragElementRect: rect,
            eventData      : data,
            id             : me.id,
            offsetX,
            offsetY
        })
    }

    /**
     * @param {Object} data
     * @returns {Object}
     */
    getDragElementRect(data) {
        let me = this,
            id = me.getDragElementRoot().id;

        for (let item of data.path) {
            if (item.id === id) {
                return item.rect
            }
        }

        for (let item of data.targetPath) {
            if (item.id === id) {
                return item.rect
            }
        }

        return null
    }

    /**
     * Override this method in case you want to wrap your dragElement.
     * See: draggable.tree.DragZone
     * @returns {Object}
     */
    getDragElementRoot() {
        return this.dragElement
    }

    /**
     * Override this method inside class extensions to add more configs
     * which get passed to main.addon.DragDrop onDragStart()
     * @returns {Object}
     * @protected
     */
    getMainThreadConfigs() {
        let me = this;

        return {
            allowOverdrag      : me.allowOverdrag,
            alwaysFireDragMove : me.alwaysFireDragMove,
            bodyCursorStyle    : me.bodyCursorStyle,
            boundaryContainerId: me.boundaryContainerId,
            dragElementRootId  : me.getDragElementRoot().id,
            dragProxyCls       : me.dragProxyCls,
            dragZoneId         : me.id,
            dropZoneIdentifier : me.dropZoneIdentifier,
            moveHorizontal     : me.moveHorizontal,
            moveVertical       : me.moveVertical,
            scrollContainerId  : me.scrollContainerId,
            scrollFactorLeft   : me.scrollFactorLeft,
            scrollFactorTop    : me.scrollFactorTop
        }
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDrop(data) {
        this.fire('drop', data)
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropEnter(data) {
        this.fire('drop:enter', data)
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropLeave(data) {
        this.fire('drop:leave', data)
    }

    /**
     *
     */
    resetData() {
        this.timeout(50).then(() => {
            this.data = null
        })
    }

    /**
     * Extend this method for child classes to pass additional properties
     * @param {Object} data={}
     */
    setData(data={}) {
        let me = this;

        me.data = {
            dragElement: me.getDragElementRoot(),
            dragZoneId : me.id,
            ...data
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragZone));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfRHJhZ1pvbmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtEO0FBQ0s7QUFDRztBQUNBO0FBQ1A7QUFDSztBQUNOOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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YnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnQgICAgICAgICAgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb21wb25lbnQgZnJvbSAnLi9EcmFnUHJveHlDb21wb25lbnQubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb250YWluZXIgZnJvbSAnLi9EcmFnUHJveHlDb250YWluZXIubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKi9cbmNsYXNzIERyYWdab25lIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnWm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFnem9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFnem9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHRoaXMuZHJhZ1Byb3h5Q2xzID0+ICduZW8tZHJhZ3Byb3h5JyB0byB0aGUgdG9wIGxldmVsIGRyYWdQcm94eUVsIG5vZGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWRkRHJhZ1Byb3h5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFkZERyYWdQcm94eUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93IHRoZSBkcmFnIHByb3h5IHRvIG1vdmUgb3V0c2lkZSBvZiB0aGUgYm91bmRhcnlDb250YWluZXJJZC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWxsb3dPdmVyZHJhZz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWxsb3dPdmVyZHJhZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnOm1vdmUgd2lsbCBieSBkZWZhdWx0IG9ubHkgZmlyZSBpbiBjYXNlIG1vdmVJbk1haW5UaHJlYWQgPT09IGZhbHNlLlxuICAgICAgICAgKiBJbiBjYXNlIHlvdSB3YW50IHRvIG1vdmUgdGhlIGRyYWdQcm94eSBpbnNpZGUgbWFpbiBidXQgc3RpbGwgZ2V0IHRoZSBldmVudCxcbiAgICAgICAgICogc2V0IHRoaXMgY29uZmlnIHRvIHRydWUuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBpbnN0YW5jZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhcHBOYW1lXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwTmFtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbGx5IHNldCBhIGZpeGVkIGN1cnNvciBzdHlsZSB0byB0aGUgZG9jdW1lbnQuYm9keSBkdXJpbmcgZHJhZyBvcGVyYXRpb25zXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBib2R5Q3Vyc29yU3R5bGU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYm9keUN1cnNvclN0eWxlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogTGltaXQgdGhlIHpvbmUgaW4gd2hpY2ggeW91IGNhbiBkcmFnIGFuIGVsZW1lbnQuXG4gICAgICAgICAqIFlvdSBjYW4gcGFzcyBhIG5vZGUgaWQsIG9yIGFuIGFycmF5IG9mIDIgbm9kZSBpZHMsIGluIGNhc2UgeW91IG5lZWQgYW4gaW50ZXJzZWN0aW9uLlxuICAgICAgICAgKiBFeGFtcGxlIGZvciAyIGlkczogZ3JpZC5oZWFkZXIuVG9vbGJhciA9PiBib3VuZGFyeUNvbnRhaW5lcklkOiBbaWQsIG1lLnBhcmVudC5pZF1cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfFN0cmluZ1tdfG51bGx9IGJvdW5kYXJ5Q29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlcyB0aGUgRE9NUmVjdCBtYXRjaGluZyB0aGlzLmJvdW5kYXJ5Q29udGFpbmVySWRcbiAgICAgICAgICogQG1lbWJlciB7RE9NUmVjdHxudWxsfSBkYXRhPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYm91bmRhcnlDb250YWluZXJSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmUgZGF0YSB3aGljaCB5b3Ugd2FudCB0byBwYXNzIHRvIGRyb3AgcmVsYXRlZCBldmVudHMgaGVyZVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZGF0YT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZkb20gKHRyZWUpIG9mIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIGRyYWdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyYWdFbGVtZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdFbGVtZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBkcmFnRWxlbWVudFxuICAgICAgICAgKiBXaWxsIGdldCBzZXQgaW5zaWRlIGRyYWdTdGFydCgpXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcmFnRWxlbWVudFJlY3Q9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0VsZW1lbnRSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGRyYWdQcm94eT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdQcm94eTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcmFnUHJveHlDb25maWdfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHlDb25maWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkcmFnUHJveHlDbHM9J25lby1kcmFncHJveHknXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHlDbHM6ICduZW8tZHJhZ3Byb3h5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gZWl0aGVyIHBhc3MgYW4gYXJyYXkgb2YgKGRvbSkgaWRzIG9yIGNscyBydWxlcyBvciBib3RoXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGRyb3Bab25lSWRlbnRpZmllcjoge1xuICAgICAgICAgKiAgICAgaWRzOiBbJ2ZvbycsJ2JhciddXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogZHJvcFpvbmVJZGVudGlmaWVyOiB7XG4gICAgICAgICAqICAgICBjbHM6IFsnbXktY2xhc3MtMScsJ215LWNsYXNzLTInXVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGRyb3Bab25lSWRlbnRpZmllcjoge1xuICAgICAgICAgKiAgICAgY2xzOiBbJ215LWNsYXNzLTEnLCdteS1jbGFzcy0yJ10sXG4gICAgICAgICAqICAgICBpZHM6IFsnZm9vJywnYmFyJ11cbiAgICAgICAgICogfVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJvcFpvbmVJZGVudGlmaWVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lSWRlbnRpZmllcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVIb3Jpem9udGFsPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVIb3Jpem9udGFsOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZVZlcnRpY2FsPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gb2Zmc2V0WD0wXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBvZmZzZXRZPTBcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gb3duZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHByb3h5UGFyZW50SWRfPSdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHByb3h5UGFyZW50SWRfOiAnZG9jdW1lbnQuYm9keScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc2Nyb2xsQ29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbEZhY3RvckxlZnQ9MVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdDogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsRmFjdG9yVG9wPTFcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbEZhY3RvclRvcDogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgY3JlYXRlcyBhIHBvc2l0aW9uOmFic29sdXRlIHdyYXBwZXIgZGl2IHdoaWNoIGNvbnRhaW5zIHRoZSBjbG9uZWQgZWxlbWVudFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VQcm94eVdyYXBwZXI9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlUHJveHlXcmFwcGVyOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignWW91IGNhbiBub3QgdXNlIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmUgd2l0aG91dCBhZGRpbmcgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3AgdG8gdGhlIG1haW4gdGhyZWFkIGFkZG9ucycsIHRoaXMuaWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgdGhpcy5fX3Byb3RvX18pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBkcmFnUHJveHlDb25maWcgY29uZmlnXG4gICAgICogV2UgYXJlIHJlLXVzaW5nIHRoaXMgY29uZmlnIHRvIGNyZWF0ZSBtdWx0aXBsZSBkcmFnUHJveGllcyxcbiAgICAgKiBzbyBpdCBpcyBpbXBvcnRhbnQgdG8gd29yayB3aXRoIGEgY2xvbmUuIHNlZTogY3JlYXRlRHJhZ1Byb3h5KClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RHJhZ1Byb3h5Q29uZmlnKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uY2xvbmUodmFsdWUsIHRydWUsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjcmVhdGVDb21wb25lbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnR9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRHJhZ1Byb3h5KGRhdGEsIGNyZWF0ZUNvbXBvbmVudD10cnVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgICA9IE5lby5nZXRDb21wb25lbnQobWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWQpIHx8IG1lLm93bmVyLFxuICAgICAgICAgICAgcmVjdCAgICAgICAgPSBtZS5kcmFnRWxlbWVudFJlY3QsXG4gICAgICAgICAgICBwcm94eUNvbmZpZyA9IG1lLmRyYWdQcm94eUNvbmZpZyB8fCB7fSxcbiAgICAgICAgICAgIGlzQ29udGFpbmVyID0gcHJveHlDb25maWcubW9kdWxlID09PSBEcmFnUHJveHlDb250YWluZXIsXG4gICAgICAgICAgICB2ZG9tICAgICAgICA9IHByb3h5Q29uZmlnLnZkb20sXG4gICAgICAgICAgICBjbG9uZSAgICAgICA9ICFpc0NvbnRhaW5lciAmJiBWRG9tVXRpbC5jbG9uZSh2ZG9tID8gdmRvbSA6IG1lLmRyYWdFbGVtZW50KSxcbiAgICAgICAgICAgIGNvbmZpZywgcHJveHk7XG5cbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgIDogRHJhZ1Byb3h5Q29tcG9uZW50LFxuICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IG1lLm1vdmVJbk1haW5UaHJlYWQsXG4gICAgICAgICAgICBwYXJlbnRJZCAgICAgICAgOiBtZS5wcm94eVBhcmVudElkLFxuICAgICAgICAgICAgd2luZG93SWQgICAgICAgIDogbWUud2luZG93SWQsXG5cbiAgICAgICAgICAgIC4uLnByb3h5Q29uZmlnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAvLyBXZSB1c2UgbWFudWFsIGRlbHRhcyB0byBtb3ZlIHRoZSBjb21wb25lbnQsIHNvIHRoZSBwcm94eSBWRE9NIHN0YXJ0cyBlbXB0eVxuICAgICAgICAgICAgY29uZmlnLmhlaWdodCAgICAgICAgICA9IGAke2RhdGEuaGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIGNvbmZpZy5pdGVtcyAgICAgICAgICAgPSBbXTtcbiAgICAgICAgICAgIGNvbmZpZy5wYXJlbnRDb21wb25lbnQgPSBtZS5vd25lcjtcbiAgICAgICAgICAgIGNvbmZpZy53aWR0aCAgICAgICAgICAgPSBgJHtkYXRhLndpZHRofXB4YDtcblxuICAgICAgICAgICAgY29uZmlnLmNscyA9IGNvbmZpZy5jbHMgfHwgW107XG4gICAgICAgICAgICBjb25maWcuY2xzLnB1c2goJ25lby1kcmFnZ2FibGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy52ZG9tID0gbWUudXNlUHJveHlXcmFwcGVyID8ge2NuOiBbY2xvbmVdfSA6IGNsb25lO1xuXG4gICAgICAgICAgICBpZiAoY2xvbmUuY2xzICYmICFtZS51c2VQcm94eVdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2xzID0gY29uZmlnLmNscyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25maWcuY2xzLnB1c2goLi4uY2xvbmUuY2xzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLmNscyA9IGNvbmZpZy5jbHMgfHwgW107XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKGNvbXBvbmVudC5nZXRUaGVtZSgpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmFkZERyYWdQcm94eUNscyAmJiBjb25maWcuY2xzKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY29uZmlnLmNscywgbWUuZHJhZ1Byb3h5Q2xzKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLnN0eWxlID0gY29uZmlnLnN0eWxlIHx8IHt9O1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLnN0eWxlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IGAke2RhdGEuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIGxlZnQgIDogYCR7bWUubW92ZUhvcml6b250YWwgPyBkYXRhLnggOiByZWN0Lnh9cHhgLFxuICAgICAgICAgICAgdG9wICAgOiBgJHttZS5tb3ZlVmVydGljYWwgICA/IGRhdGEueSA6IHJlY3QueX1weGAsXG4gICAgICAgICAgICB3aWR0aCA6IGAke2RhdGEud2lkdGh9cHhgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjcmVhdGVDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hdXRvSW5pdFZub2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuYXV0b01vdW50ICAgICA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZHJhZ1Byb3h5ID0gcHJveHkgPSBOZW8uY3JlYXRlKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb3h5Lm1vdW50ZWRQcm9taXNlO1xuXG4gICAgICAgICAgICAgICAgbWUuZHJhZ1BsYWNlaG9sZGVyID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBmbGV4ICA6IGNvbXBvbmVudC5mbGV4LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSA6IHtoZWlnaHQ6IGAke2RhdGEuaGVpZ2h0fXB4YCwgdmlzaWJpbGl0eTogJ2hpZGRlbicsIHdpZHRoOiBgJHtkYXRhLndpZHRofXB4YH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgbGF5b3V0IGNvbmZpZ3NcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1pbkhlaWdodCkgbWUuZHJhZ1BsYWNlaG9sZGVyLm1pbkhlaWdodCA9IGNvbXBvbmVudC5taW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5taW5XaWR0aCkgIG1lLmRyYWdQbGFjZWhvbGRlci5taW5XaWR0aCAgPSBjb21wb25lbnQubWluV2lkdGg7XG5cbiAgICAgICAgICAgICAgICBtZS5kcmFnU3RhcnRJbmRleCA9IG1lLm93bmVyLml0ZW1zLmluZGV4T2YoY29tcG9uZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSB2bm9kZSBmcm9tIHRoZSB2ZG9tIHdvcmtlciwgd2l0aG91dCBtb3VudGluZyBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCB7dm5vZGV9ID0gYXdhaXQgTmVvLnZkb20uSGVscGVyLmNyZWF0ZSh7dmRvbTogbWUuZHJhZ1BsYWNlaG9sZGVyLnZkb219KTtcblxuICAgICAgICAgICAgICAgIC8vIE1hbnVhbCBET00gbWFuaXB1bGF0aW9uIHRvIHByZXNlcnZlIENvbXBvbmVudCBzdGF0ZSAoZS5nLiwgQ2FudmFzIG9yIENoYXJ0cylcbiAgICAgICAgICAgICAgICBhd2FpdCBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIFt7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiAgOiAnaW5zZXJ0Tm9kZScsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICAgOiBtZS5kcmFnU3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG1lLm93bmVyLmdldFZkb21JdGVtc1Jvb3QoKS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiAgOiAnbW92ZU5vZGUnLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCAgIDogMCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHByb3h5LmlkXG4gICAgICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICAgICAgbWUuZHJhZ1BsYWNlaG9sZGVyLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICAgICAgICBtb3VudGVkICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2bm9kZUluaXRpYWxpemVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb3h5XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZm9yIHVzaW5nIGN1c3RvbSBhbmltYXRpb25zXG4gICAgICovXG4gICAgZGVzdHJveURyYWdQcm94eSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGlkID0gbWUuZHJhZ1Byb3h5LmlkO1xuXG4gICAgICAgIG1lLnRpbWVvdXQobWUubW92ZUluTWFpblRocmVhZCA/IDAgOiAzMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIFt7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkfV0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdQcm94eS5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICB7Y2xzfSAgID0gb3duZXI7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1pcy1kcmFnZ2luZycpO1xuICAgICAgICBvd25lci5jbHMgPSBjbHM7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgaWYgKG1lLmRyYWdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIG1lLmRyYWdQbGFjZWhvbGRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ1BsYWNlaG9sZGVyID0gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5kZXN0cm95RHJhZ1Byb3h5KCk7XG4gICAgICAgICAgICBtZS5kcmFnUHJveHkgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBkcmFnRWxlbWVudFJlY3QgIDogbnVsbCxcbiAgICAgICAgICAgIGRyYWdTdGFydEluZGV4ICAgOiBudWxsLFxuICAgICAgICAgICAgb2Zmc2V0WCAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBvZmZzZXRZICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmZpcmUoJ2RyYWdFbmQnLCBkYXRhKTtcblxuICAgICAgICBtZS5yZXNldERhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgc3R5bGU7XG5cbiAgICAgICAgaWYgKCFtZS5tb3ZlSW5NYWluVGhyZWFkICYmIG1lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgc3R5bGUgPSBtZS5kcmFnUHJveHkuc3R5bGU7XG5cbiAgICAgICAgICAgIGlmIChtZS5tb3ZlSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBgJHtkYXRhLmNsaWVudFggLSBtZS5vZmZzZXRYfXB4YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLm1vdmVWZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLnRvcCA9IGAke2RhdGEuY2xpZW50WSAtIG1lLm9mZnNldFl9cHhgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5kcmFnUHJveHkuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmZpcmUoJ2RyYWdNb3ZlJywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZSwgb3duZXIsIHdpbmRvd0lkfSA9IG1lLFxuICAgICAgICAgICAge2Nsc30gICAgICAgICAgICAgICAgICAgICAgPSBvd25lcixcbiAgICAgICAgICAgIHJlY3QgICAgICAgICAgICAgICAgICAgICAgID0gbWUuZ2V0RHJhZ0VsZW1lbnRSZWN0KGRhdGEpLFxuICAgICAgICAgICAgbWFpbkRhdGEsIG9mZnNldFgsIG9mZnNldFk7XG5cbiAgICAgICAgbWUuc2V0RGF0YSgpO1xuXG4gICAgICAgIG1haW5EYXRhID0gYXdhaXQgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0Q29uZmlncyh7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgICAuLi5tZS5nZXRNYWluVGhyZWFkQ29uZmlncygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCA9IG1haW5EYXRhLmJvdW5kYXJ5Q29udGFpbmVyUmVjdFxuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8taXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgb3duZXIuY2xzID0gY2xzO1xuXG4gICAgICAgIG9mZnNldFggPSBkYXRhLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgIG9mZnNldFkgPSBkYXRhLmNsaWVudFkgLSByZWN0LnRvcDtcblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3QsXG4gICAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBtZS5jcmVhdGVEcmFnUHJveHkocmVjdCk7XG5cbiAgICAgICAgbWUuZmlyZSgnZHJhZ1N0YXJ0Jywge1xuICAgICAgICAgICAgY2xpZW50WCAgICAgICAgOiBkYXRhLmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZICAgICAgICA6IGRhdGEuY2xpZW50WSxcbiAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdDogcmVjdCxcbiAgICAgICAgICAgIGV2ZW50RGF0YSAgICAgIDogZGF0YSxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREcmFnRWxlbWVudFJlY3QoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaWQgPSBtZS5nZXREcmFnRWxlbWVudFJvb3QoKS5pZDtcblxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGRhdGEucGF0aCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ucmVjdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBkYXRhLnRhcmdldFBhdGgpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnJlY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gY2FzZSB5b3Ugd2FudCB0byB3cmFwIHlvdXIgZHJhZ0VsZW1lbnQuXG4gICAgICogU2VlOiBkcmFnZ2FibGUudHJlZS5EcmFnWm9uZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RHJhZ0VsZW1lbnRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnRWxlbWVudFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluc2lkZSBjbGFzcyBleHRlbnNpb25zIHRvIGFkZCBtb3JlIGNvbmZpZ3NcbiAgICAgKiB3aGljaCBnZXQgcGFzc2VkIHRvIG1haW4uYWRkb24uRHJhZ0Ryb3Agb25EcmFnU3RhcnQoKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldE1haW5UaHJlYWRDb25maWdzKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxvd092ZXJkcmFnICAgICAgOiBtZS5hbGxvd092ZXJkcmFnLFxuICAgICAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlIDogbWUuYWx3YXlzRmlyZURyYWdNb3ZlLFxuICAgICAgICAgICAgYm9keUN1cnNvclN0eWxlICAgIDogbWUuYm9keUN1cnNvclN0eWxlLFxuICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuYm91bmRhcnlDb250YWluZXJJZCxcbiAgICAgICAgICAgIGRyYWdFbGVtZW50Um9vdElkICA6IG1lLmdldERyYWdFbGVtZW50Um9vdCgpLmlkLFxuICAgICAgICAgICAgZHJhZ1Byb3h5Q2xzICAgICAgIDogbWUuZHJhZ1Byb3h5Q2xzLFxuICAgICAgICAgICAgZHJhZ1pvbmVJZCAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICBkcm9wWm9uZUlkZW50aWZpZXIgOiBtZS5kcm9wWm9uZUlkZW50aWZpZXIsXG4gICAgICAgICAgICBtb3ZlSG9yaXpvbnRhbCAgICAgOiBtZS5tb3ZlSG9yaXpvbnRhbCxcbiAgICAgICAgICAgIG1vdmVWZXJ0aWNhbCAgICAgICA6IG1lLm1vdmVWZXJ0aWNhbCxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkICA6IG1lLnNjcm9sbENvbnRhaW5lcklkLFxuICAgICAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdCAgIDogbWUuc2Nyb2xsRmFjdG9yTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbEZhY3RvclRvcCAgICA6IG1lLnNjcm9sbEZhY3RvclRvcFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIG92ZXJyaWRlIHRoZSBoYW5kbGVyIG9yIGxpc3RlbiB0byB0aGUgZXZlbnQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Ecm9wKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdkcm9wJywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgdGhpcyBjbGFzcyBhbmQgb3ZlcnJpZGUgdGhlIGhhbmRsZXIgb3IgbGlzdGVuIHRvIHRoZSBldmVudCBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyb3BFbnRlcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnZHJvcDplbnRlcicsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIG92ZXJyaWRlIHRoZSBoYW5kbGVyIG9yIGxpc3RlbiB0byB0aGUgZXZlbnQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Ecm9wTGVhdmUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ2Ryb3A6bGVhdmUnLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVzZXREYXRhKCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbnVsbFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCB0aGlzIG1ldGhvZCBmb3IgY2hpbGQgY2xhc3NlcyB0byBwYXNzIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhPXt9XG4gICAgICovXG4gICAgc2V0RGF0YShkYXRhPXt9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZGF0YSA9IHtcbiAgICAgICAgICAgIGRyYWdFbGVtZW50OiBtZS5nZXREcmFnRWxlbWVudFJvb3QoKSxcbiAgICAgICAgICAgIGRyYWdab25lSWQgOiBtZS5pZCxcbiAgICAgICAgICAgIC4uLmRhdGFcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1pvbmUpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==