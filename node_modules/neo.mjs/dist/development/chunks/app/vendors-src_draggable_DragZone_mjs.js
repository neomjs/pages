"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_DragZone_mjs"],{

/***/ "./src/draggable/DragZone.mjs"
/*!************************************!*\
  !*** ./src/draggable/DragZone.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DragProxyContainer.mjs */ "./src/draggable/DragProxyContainer.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");








/**
 * @class Neo.draggable.DragZone
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class DragZone extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.draggable.DragZone'
         * @protected
         */
        className: 'Neo.draggable.DragZone',
        /**
         * @member {String} ntype='dragzone'
         * @protected
         */
        ntype: 'dragzone',
        /**
         * Adds this.dragProxyCls => 'neo-dragproxy' to the top level dragProxyEl node
         * @member {Boolean} addDragProxyCls=true
         */
        addDragProxyCls: true,
        /**
         * Allow the drag proxy to move outside of the boundaryContainerId.
         * @member {Boolean} allowOverdrag=false
         */
        allowOverdrag: false,
        /**
         * drag:move will by default only fire in case moveInMainThread === false.
         * In case you want to move the dragProxy inside main but still get the event,
         * set this config to true.
         * @member {Boolean} alwaysFireDragMove=false
         */
        alwaysFireDragMove: false,
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * Optionally set a fixed cursor style to the document.body during drag operations
         * @member {String|null} bodyCursorStyle=null
         */
        bodyCursorStyle: null,
        /**
         * Limit the zone in which you can drag an element.
         * You can pass a node id, or an array of 2 node ids, in case you need an intersection.
         * Example for 2 ids: grid.header.Toolbar => boundaryContainerId: [id, me.parent.id]
         * @member {String|String[]|null} boundaryContainerId=null
         */
        boundaryContainerId: null,
        /**
         * Stores the DOMRect matching this.boundaryContainerId
         * @member {DOMRect|null} data=null
         * @protected
         */
        boundaryContainerRect: null,
        /**
         * Store data which you want to pass to drop related events here
         * @member {Object|null} data=null
         */
        data: null,
        /**
         * The vdom (tree) of the element you want to drag
         * @member {Object|null} dragElement=null
         */
        dragElement: null,
        /**
         * The bounding client rect of the dragElement
         * Will get set inside dragStart()
         * @member {Object|null} dragElementRect=null
         */
        dragElementRect: null,
        /**
         * @member {Neo.component.Base|null} dragProxy=null
         * @protected
         */
        dragProxy: null,
        /**
         * @member {Object|null} dragProxyConfig_=null
         * @reactive
         */
        dragProxyConfig_: null,
        /**
         * @member {String} dragProxyCls='neo-dragproxy'
         */
        dragProxyCls: 'neo-dragproxy',
        /**
         * You can either pass an array of (dom) ids or cls rules or both
         * @example
         * dropZoneIdentifier: {
         *     ids: ['foo','bar']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2'],
         *     ids: ['foo','bar']
         * }
         * @member {Object|null} dropZoneIdentifier=null
         */
        dropZoneIdentifier: null,
        /**
         * @member {Boolean} moveHorizontal=true
         */
        moveHorizontal: true,
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true,
        /**
         * @member {Boolean} moveVertical=true
         */
        moveVertical: true,
        /**
         * @member {Number} offsetX=0
         */
        offsetX: 0,
        /**
         * @member {Number} offsetY=0
         */
        offsetY: 0,
        /**
         * @member {Neo.component.Base|null} owner=null
         */
        owner: null,
        /**
         * @member {String} proxyParentId_='document.body'
         * @reactive
         */
        proxyParentId_: 'document.body',
        /**
         * @member {String|null} scrollContainerId=null
         */
        scrollContainerId: null,
        /**
         * @member {Number} scrollFactorLeft=1
         */
        scrollFactorLeft: 1,
        /**
         * @member {Number} scrollFactorTop=1
         */
        scrollFactorTop: 1,
        /**
         * True creates a position:absolute wrapper div which contains the cloned element
         * @member {Boolean} useProxyWrapper=true
         */
        useProxyWrapper: true,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        if (!Neo.main.addon.DragDrop) {
            console.error('You can not use Neo.draggable.DragZone without adding Neo.main.addon.DragDrop to the main thread addons', this.id)
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Triggered when accessing the dragProxyConfig config
     * We are re-using this config to create multiple dragProxies,
     * so it is important to work with a clone. see: createDragProxy()
     * @param {Object} value
     * @protected
     */
    beforeGetDragProxyConfig(value) {
        return Neo.clone(value, true, true)
    }

    /**
     * @param {Object}  data
     * @param {Boolean} createComponent=true
     * @returns {Object|Neo.draggable.DragProxyComponent}
     */
    async createDragProxy(data, createComponent=true) {
        let me          = this,
            component   = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            rect        = me.dragElementRect,
            proxyConfig = me.dragProxyConfig || {},
            isContainer = proxyConfig.module === _DragProxyContainer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            vdom        = proxyConfig.vdom,
            clone       = !isContainer && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].clone(vdom ? vdom : me.dragElement),
            config, proxy;

        config = {
            module          : _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,
            windowId        : me.windowId,

            ...proxyConfig
        };

        if (isContainer) {
            // We use manual deltas to move the component, so the proxy VDOM starts empty
            config.height          = `${data.height}px`;
            config.items           = [];
            config.parentComponent = me.owner;
            config.width           = `${data.width}px`;

            config.cls = config.cls || [];
            config.cls.push('neo-draggable');
        } else {
            config.vdom = me.useProxyWrapper ? {cn: [clone]} : clone;

            if (clone.cls && !me.useProxyWrapper) {
                config.cls = config.cls || [];
                config.cls.push(...clone.cls)
            }
        }

        config.cls = config.cls || [];

        if (component) {
            config.cls.push(component.getTheme())
        }

        if (me.addDragProxyCls && config.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(config.cls, me.dragProxyCls)
        }

        config.style = config.style || {};

        Object.assign(config.style, {
            height: `${data.height}px`,
            left  : `${me.moveHorizontal ? data.x : rect.x}px`,
            top   : `${me.moveVertical   ? data.y : rect.y}px`,
            width : `${data.width}px`
        });

        if (createComponent) {
            if (isContainer) {
                config.autoInitVnode = true;
                config.autoMount     = true
            }

            me.dragProxy = proxy = Neo.create(config);

            if (isContainer) {
                await proxy.mountedPromise;

                me.dragPlaceholder = Neo.create({
                    module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    flex  : component.flex,
                    style : {height: `${data.height}px`, visibility: 'hidden', width: `${data.width}px`}
                });

                // Copy layout configs
                if (component.minHeight) me.dragPlaceholder.minHeight = component.minHeight;
                if (component.minWidth)  me.dragPlaceholder.minWidth  = component.minWidth;

                me.dragStartIndex = me.owner.items.indexOf(component);

                // Fetch the vnode from the vdom worker, without mounting it.
                const {vnode} = await Neo.vdom.Helper.create({vdom: me.dragPlaceholder.vdom});

                // Manual DOM manipulation to preserve Component state (e.g., Canvas or Charts)
                await Neo.applyDeltas(me.windowId, [{
                    action  : 'insertNode',
                    index   : me.dragStartIndex,
                    parentId: me.owner.getVdomItemsRoot().id,
                    vnode
                }, {
                    action  : 'moveNode',
                    id      : component.id,
                    index   : 0,
                    parentId: proxy.id
                }]);

                me.dragPlaceholder.set({
                    vnode,
                    mounted         : true,
                    vnodeInitialized: true
                })
            }

            return proxy
        }

        return config
    }

    /**
     * Override for using custom animations
     */
    destroyDragProxy() {
        let me = this,
            id = me.dragProxy.id;

        me.timeout(me.moveInMainThread ? 0 : 30).then(() => {
            Neo.applyDeltas(me.windowId, [{action: 'removeNode', id}])
        });

        me.dragProxy.destroy()
    }

    /**
     * @param {Object} data
     */
    dragEnd(data) {
        let me      = this,
            {owner} = me,
            {cls}   = owner;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].remove(cls, 'neo-is-dragging');
        owner.cls = cls;

        if (me.dragProxy) {
            if (me.dragPlaceholder) {
                me.dragPlaceholder.destroy();
                me.dragPlaceholder = null
            }

            me.destroyDragProxy();
            me.dragProxy = null
        }

        Object.assign(me, {
            dragElementRect  : null,
            dragStartIndex   : null,
            offsetX          : 0,
            offsetY          : 0,
            scrollContainerId: null
        });

        me.fire('dragEnd', data);

        me.resetData()
    }

    /**
     * @param {Object} data
     * @param {Boolean} force=false
     */
    dragMove(data, force=false) {
        let me = this,
            style;

        if ((!me.moveInMainThread || force) && me.dragProxy) {
            style = me.dragProxy.style;

            if (me.moveHorizontal) {
                style.left = `${data.clientX - me.offsetX}px`;
            }

            if (me.moveVertical) {
                style.top = `${data.clientY - me.offsetY}px`;
            }

            me.dragProxy.style = style;
        }

        me.fire('dragMove', data)
    }

    /**
     * @param {Object} data
     */
    async dragStart(data) {
        let me                         = this,
            {appName, owner, windowId} = me,
            {cls}                      = owner,
            rect                       = me.getDragElementRect(data),
            mainData, offsetX, offsetY;

        me.setData();

        mainData = await Neo.main.addon.DragDrop.setConfigs({
            appName,
            windowId,
            ...me.getMainThreadConfigs()
        });

        me.boundaryContainerRect = mainData.boundaryContainerRect

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].add(cls, 'neo-is-dragging');
        owner.cls = cls;

        offsetX = data.clientX - rect.left;
        offsetY = data.clientY - rect.top;

        Object.assign(me, {
            dragElementRect: rect,
            offsetX,
            offsetY
        });

        await me.createDragProxy(rect);

        me.fire('dragStart', {
            clientX        : data.clientX,
            clientY        : data.clientY,
            dragElementRect: rect,
            eventData      : data,
            id             : me.id,
            offsetX,
            offsetY
        })
    }

    /**
     * @param {Object} data
     * @returns {Object}
     */
    getDragElementRect(data) {
        let me = this,
            id = me.getDragElementRoot().id;

        for (let item of data.path) {
            if (item.id === id) {
                return item.rect
            }
        }

        for (let item of data.targetPath) {
            if (item.id === id) {
                return item.rect
            }
        }

        return null
    }

    /**
     * Override this method in case you want to wrap your dragElement.
     * See: draggable.tree.DragZone
     * @returns {Object}
     */
    getDragElementRoot() {
        return this.dragElement
    }

    /**
     * Override this method inside class extensions to add more configs
     * which get passed to main.addon.DragDrop onDragStart()
     * @returns {Object}
     * @protected
     */
    getMainThreadConfigs() {
        let me = this;

        return {
            allowOverdrag      : me.allowOverdrag,
            alwaysFireDragMove : me.alwaysFireDragMove,
            bodyCursorStyle    : me.bodyCursorStyle,
            boundaryContainerId: me.boundaryContainerId,
            dragElementRootId  : me.getDragElementRoot().id,
            dragProxyCls       : me.dragProxyCls,
            dragZoneId         : me.id,
            dropZoneIdentifier : me.dropZoneIdentifier,
            moveHorizontal     : me.moveHorizontal,
            moveVertical       : me.moveVertical,
            scrollContainerId  : me.scrollContainerId,
            scrollFactorLeft   : me.scrollFactorLeft,
            scrollFactorTop    : me.scrollFactorTop
        }
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDrop(data) {
        this.fire('drop', data)
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropEnter(data) {
        this.fire('drop:enter', data)
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropLeave(data) {
        this.fire('drop:leave', data)
    }

    /**
     *
     */
    resetData() {
        this.timeout(50).then(() => {
            this.data = null
        })
    }

    /**
     * Extend this method for child classes to pass additional properties
     * @param {Object} data={}
     */
    setData(data={}) {
        let me = this;

        me.data = {
            dragElement: me.getDragElementRoot(),
            dragZoneId : me.id,
            ...data
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragZone));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfRHJhZ1pvbmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtEO0FBQ0s7QUFDRztBQUNBO0FBQ1A7QUFDSztBQUNOOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kcmFnZ2FibGUvRHJhZ1pvbmUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50ICAgICAgICAgIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29tcG9uZW50IGZyb20gJy4vRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29udGFpbmVyIGZyb20gJy4vRHJhZ1Byb3h5Q29udGFpbmVyLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLkRyYWdab25lXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBEcmFnWm9uZSBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUuRHJhZ1pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuRHJhZ1pvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZHJhZ3pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZHJhZ3pvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyB0aGlzLmRyYWdQcm94eUNscyA9PiAnbmVvLWRyYWdwcm94eScgdG8gdGhlIHRvcCBsZXZlbCBkcmFnUHJveHlFbCBub2RlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFkZERyYWdQcm94eUNscz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhZGREcmFnUHJveHlDbHM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvdyB0aGUgZHJhZyBwcm94eSB0byBtb3ZlIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJ5Q29udGFpbmVySWQuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsbG93T3ZlcmRyYWc9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGFsbG93T3ZlcmRyYWc6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZzptb3ZlIHdpbGwgYnkgZGVmYXVsdCBvbmx5IGZpcmUgaW4gY2FzZSBtb3ZlSW5NYWluVGhyZWFkID09PSBmYWxzZS5cbiAgICAgICAgICogSW4gY2FzZSB5b3Ugd2FudCB0byBtb3ZlIHRoZSBkcmFnUHJveHkgaW5zaWRlIG1haW4gYnV0IHN0aWxsIGdldCB0aGUgZXZlbnQsXG4gICAgICAgICAqIHNldCB0aGlzIGNvbmZpZyB0byB0cnVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbHdheXNGaXJlRHJhZ01vdmU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGFsd2F5c0ZpcmVEcmFnTW92ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgQXBwIHRoaXMgaW5zdGFuY2UgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwTmFtZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWxseSBzZXQgYSBmaXhlZCBjdXJzb3Igc3R5bGUgdG8gdGhlIGRvY3VtZW50LmJvZHkgZHVyaW5nIGRyYWcgb3BlcmF0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYm9keUN1cnNvclN0eWxlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGJvZHlDdXJzb3JTdHlsZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpbWl0IHRoZSB6b25lIGluIHdoaWNoIHlvdSBjYW4gZHJhZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBZb3UgY2FuIHBhc3MgYSBub2RlIGlkLCBvciBhbiBhcnJheSBvZiAyIG5vZGUgaWRzLCBpbiBjYXNlIHlvdSBuZWVkIGFuIGludGVyc2VjdGlvbi5cbiAgICAgICAgICogRXhhbXBsZSBmb3IgMiBpZHM6IGdyaWQuaGVhZGVyLlRvb2xiYXIgPT4gYm91bmRhcnlDb250YWluZXJJZDogW2lkLCBtZS5wYXJlbnQuaWRdXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xTdHJpbmdbXXxudWxsfSBib3VuZGFyeUNvbnRhaW5lcklkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIERPTVJlY3QgbWF0Y2hpbmcgdGhpcy5ib3VuZGFyeUNvbnRhaW5lcklkXG4gICAgICAgICAqIEBtZW1iZXIge0RPTVJlY3R8bnVsbH0gZGF0YT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJvdW5kYXJ5Q29udGFpbmVyUmVjdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3JlIGRhdGEgd2hpY2ggeW91IHdhbnQgdG8gcGFzcyB0byBkcm9wIHJlbGF0ZWQgZXZlbnRzIGhlcmVcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRhdGE9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZG9tICh0cmVlKSBvZiB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byBkcmFnXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkcmFnRWxlbWVudD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRWxlbWVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBvZiB0aGUgZHJhZ0VsZW1lbnRcbiAgICAgICAgICogV2lsbCBnZXQgc2V0IGluc2lkZSBkcmFnU3RhcnQoKVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJhZ0VsZW1lbnRSZWN0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdFbGVtZW50UmVjdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBkcmFnUHJveHk9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHk6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJhZ1Byb3h5Q29uZmlnXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5Q29uZmlnXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZHJhZ1Byb3h5Q2xzPSduZW8tZHJhZ3Byb3h5J1xuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5Q2xzOiAnbmVvLWRyYWdwcm94eScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgY2FuIGVpdGhlciBwYXNzIGFuIGFycmF5IG9mIChkb20pIGlkcyBvciBjbHMgcnVsZXMgb3IgYm90aFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBkcm9wWm9uZUlkZW50aWZpZXI6IHtcbiAgICAgICAgICogICAgIGlkczogWydmb28nLCdiYXInXVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGRyb3Bab25lSWRlbnRpZmllcjoge1xuICAgICAgICAgKiAgICAgY2xzOiBbJ215LWNsYXNzLTEnLCdteS1jbGFzcy0yJ11cbiAgICAgICAgICogfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBkcm9wWm9uZUlkZW50aWZpZXI6IHtcbiAgICAgICAgICogICAgIGNsczogWydteS1jbGFzcy0xJywnbXktY2xhc3MtMiddLFxuICAgICAgICAgKiAgICAgaWRzOiBbJ2ZvbycsJ2JhciddXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyb3Bab25lSWRlbnRpZmllcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wWm9uZUlkZW50aWZpZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSG9yaXpvbnRhbD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSG9yaXpvbnRhbDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVJbk1haW5UaHJlYWQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUluTWFpblRocmVhZDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVWZXJ0aWNhbD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlVmVydGljYWw6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG9mZnNldFg9MFxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gb2Zmc2V0WT0wXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcm94eVBhcmVudElkXz0nZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwcm94eVBhcmVudElkXzogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHNjcm9sbENvbnRhaW5lcklkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbENvbnRhaW5lcklkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxGYWN0b3JMZWZ0PTFcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbEZhY3RvckxlZnQ6IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbEZhY3RvclRvcD0xXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxGYWN0b3JUb3A6IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGNyZWF0ZXMgYSBwb3NpdGlvbjphYnNvbHV0ZSB3cmFwcGVyIGRpdiB3aGljaCBjb250YWlucyB0aGUgY2xvbmVkIGVsZW1lbnRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlUHJveHlXcmFwcGVyPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHVzZVByb3h5V3JhcHBlcjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGlmICghTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3ApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBjYW4gbm90IHVzZSBOZW8uZHJhZ2dhYmxlLkRyYWdab25lIHdpdGhvdXQgYWRkaW5nIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wIHRvIHRoZSBtYWluIHRocmVhZCBhZGRvbnMnLCB0aGlzLmlkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMuX19wcm90b19fKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZHJhZ1Byb3h5Q29uZmlnIGNvbmZpZ1xuICAgICAqIFdlIGFyZSByZS11c2luZyB0aGlzIGNvbmZpZyB0byBjcmVhdGUgbXVsdGlwbGUgZHJhZ1Byb3hpZXMsXG4gICAgICogc28gaXQgaXMgaW1wb3J0YW50IHRvIHdvcmsgd2l0aCBhIGNsb25lLiBzZWU6IGNyZWF0ZURyYWdQcm94eSgpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldERyYWdQcm94eUNvbmZpZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvLmNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY3JlYXRlQ29tcG9uZW50PXRydWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50fVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZURyYWdQcm94eShkYXRhLCBjcmVhdGVDb21wb25lbnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ICAgPSBOZW8uZ2V0Q29tcG9uZW50KG1lLmdldERyYWdFbGVtZW50Um9vdCgpLmlkKSB8fCBtZS5vd25lcixcbiAgICAgICAgICAgIHJlY3QgICAgICAgID0gbWUuZHJhZ0VsZW1lbnRSZWN0LFxuICAgICAgICAgICAgcHJveHlDb25maWcgPSBtZS5kcmFnUHJveHlDb25maWcgfHwge30sXG4gICAgICAgICAgICBpc0NvbnRhaW5lciA9IHByb3h5Q29uZmlnLm1vZHVsZSA9PT0gRHJhZ1Byb3h5Q29udGFpbmVyLFxuICAgICAgICAgICAgdmRvbSAgICAgICAgPSBwcm94eUNvbmZpZy52ZG9tLFxuICAgICAgICAgICAgY2xvbmUgICAgICAgPSAhaXNDb250YWluZXIgJiYgVkRvbVV0aWwuY2xvbmUodmRvbSA/IHZkb20gOiBtZS5kcmFnRWxlbWVudCksXG4gICAgICAgICAgICBjb25maWcsIHByb3h5O1xuXG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICA6IERyYWdQcm94eUNvbXBvbmVudCxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBtZS5tb3ZlSW5NYWluVGhyZWFkLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgIDogbWUucHJveHlQYXJlbnRJZCxcbiAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICA6IG1lLndpbmRvd0lkLFxuXG4gICAgICAgICAgICAuLi5wcm94eUNvbmZpZ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gV2UgdXNlIG1hbnVhbCBkZWx0YXMgdG8gbW92ZSB0aGUgY29tcG9uZW50LCBzbyB0aGUgcHJveHkgVkRPTSBzdGFydHMgZW1wdHlcbiAgICAgICAgICAgIGNvbmZpZy5oZWlnaHQgICAgICAgICAgPSBgJHtkYXRhLmhlaWdodH1weGA7XG4gICAgICAgICAgICBjb25maWcuaXRlbXMgICAgICAgICAgID0gW107XG4gICAgICAgICAgICBjb25maWcucGFyZW50Q29tcG9uZW50ID0gbWUub3duZXI7XG4gICAgICAgICAgICBjb25maWcud2lkdGggICAgICAgICAgID0gYCR7ZGF0YS53aWR0aH1weGA7XG5cbiAgICAgICAgICAgIGNvbmZpZy5jbHMgPSBjb25maWcuY2xzIHx8IFtdO1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKCduZW8tZHJhZ2dhYmxlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcudmRvbSA9IG1lLnVzZVByb3h5V3JhcHBlciA/IHtjbjogW2Nsb25lXX0gOiBjbG9uZTtcblxuICAgICAgICAgICAgaWYgKGNsb25lLmNscyAmJiAhbWUudXNlUHJveHlXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNscyA9IGNvbmZpZy5jbHMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKC4uLmNsb25lLmNscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5jbHMgPSBjb25maWcuY2xzIHx8IFtdO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMucHVzaChjb21wb25lbnQuZ2V0VGhlbWUoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5hZGREcmFnUHJveHlDbHMgJiYgY29uZmlnLmNscykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNvbmZpZy5jbHMsIG1lLmRyYWdQcm94eUNscylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5zdHlsZSA9IGNvbmZpZy5zdHlsZSB8fCB7fTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZy5zdHlsZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBgJHtkYXRhLmhlaWdodH1weGAsXG4gICAgICAgICAgICBsZWZ0ICA6IGAke21lLm1vdmVIb3Jpem9udGFsID8gZGF0YS54IDogcmVjdC54fXB4YCxcbiAgICAgICAgICAgIHRvcCAgIDogYCR7bWUubW92ZVZlcnRpY2FsICAgPyBkYXRhLnkgOiByZWN0Lnl9cHhgLFxuICAgICAgICAgICAgd2lkdGggOiBgJHtkYXRhLndpZHRofXB4YFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY3JlYXRlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuYXV0b0luaXRWbm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLmF1dG9Nb3VudCAgICAgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmRyYWdQcm94eSA9IHByb3h5ID0gTmVvLmNyZWF0ZShjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm94eS5tb3VudGVkUHJvbWlzZTtcblxuICAgICAgICAgICAgICAgIG1lLmRyYWdQbGFjZWhvbGRlciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgZmxleCAgOiBjb21wb25lbnQuZmxleCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgOiB7aGVpZ2h0OiBgJHtkYXRhLmhlaWdodH1weGAsIHZpc2liaWxpdHk6ICdoaWRkZW4nLCB3aWR0aDogYCR7ZGF0YS53aWR0aH1weGB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb3B5IGxheW91dCBjb25maWdzXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5taW5IZWlnaHQpIG1lLmRyYWdQbGFjZWhvbGRlci5taW5IZWlnaHQgPSBjb21wb25lbnQubWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubWluV2lkdGgpICBtZS5kcmFnUGxhY2Vob2xkZXIubWluV2lkdGggID0gY29tcG9uZW50Lm1pbldpZHRoO1xuXG4gICAgICAgICAgICAgICAgbWUuZHJhZ1N0YXJ0SW5kZXggPSBtZS5vd25lci5pdGVtcy5pbmRleE9mKGNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGZXRjaCB0aGUgdm5vZGUgZnJvbSB0aGUgdmRvbSB3b3JrZXIsIHdpdGhvdXQgbW91bnRpbmcgaXQuXG4gICAgICAgICAgICAgICAgY29uc3Qge3Zub2RlfSA9IGF3YWl0IE5lby52ZG9tLkhlbHBlci5jcmVhdGUoe3Zkb206IG1lLmRyYWdQbGFjZWhvbGRlci52ZG9tfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBNYW51YWwgRE9NIG1hbmlwdWxhdGlvbiB0byBwcmVzZXJ2ZSBDb21wb25lbnQgc3RhdGUgKGUuZy4sIENhbnZhcyBvciBDaGFydHMpXG4gICAgICAgICAgICAgICAgYXdhaXQgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCBbe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gIDogJ2luc2VydE5vZGUnLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCAgIDogbWUuZHJhZ1N0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBtZS5vd25lci5nZXRWZG9tSXRlbXNSb290KCkuaWQsXG4gICAgICAgICAgICAgICAgICAgIHZub2RlXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gIDogJ21vdmVOb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IGNvbXBvbmVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggICA6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBwcm94eS5pZFxuICAgICAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgICAgIG1lLmRyYWdQbGFjZWhvbGRlci5zZXQoe1xuICAgICAgICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbW91bnRlZCAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVJbml0aWFsaXplZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm94eVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGZvciB1c2luZyBjdXN0b20gYW5pbWF0aW9uc1xuICAgICAqL1xuICAgIGRlc3Ryb3lEcmFnUHJveHkoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpZCA9IG1lLmRyYWdQcm94eS5pZDtcblxuICAgICAgICBtZS50aW1lb3V0KG1lLm1vdmVJbk1haW5UaHJlYWQgPyAwIDogMzApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCBbe2FjdGlvbjogJ3JlbW92ZU5vZGUnLCBpZH1dKVxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5kcmFnUHJveHkuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBkcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAge2Nsc30gICA9IG93bmVyO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsICduZW8taXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgb3duZXIuY2xzID0gY2xzO1xuXG4gICAgICAgIGlmIChtZS5kcmFnUHJveHkpIHtcbiAgICAgICAgICAgIGlmIChtZS5kcmFnUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBtZS5kcmFnUGxhY2Vob2xkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIG1lLmRyYWdQbGFjZWhvbGRlciA9IG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZGVzdHJveURyYWdQcm94eSgpO1xuICAgICAgICAgICAgbWUuZHJhZ1Byb3h5ID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgZHJhZ0VsZW1lbnRSZWN0ICA6IG51bGwsXG4gICAgICAgICAgICBkcmFnU3RhcnRJbmRleCAgIDogbnVsbCxcbiAgICAgICAgICAgIG9mZnNldFggICAgICAgICAgOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WSAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXJJZDogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICBtZS5maXJlKCdkcmFnRW5kJywgZGF0YSk7XG5cbiAgICAgICAgbWUucmVzZXREYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2U9ZmFsc2VcbiAgICAgKi9cbiAgICBkcmFnTW92ZShkYXRhLCBmb3JjZT1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgc3R5bGU7XG5cbiAgICAgICAgaWYgKCghbWUubW92ZUluTWFpblRocmVhZCB8fCBmb3JjZSkgJiYgbWUuZHJhZ1Byb3h5KSB7XG4gICAgICAgICAgICBzdHlsZSA9IG1lLmRyYWdQcm94eS5zdHlsZTtcblxuICAgICAgICAgICAgaWYgKG1lLm1vdmVIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IGAke2RhdGEuY2xpZW50WCAtIG1lLm9mZnNldFh9cHhgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUubW92ZVZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gYCR7ZGF0YS5jbGllbnRZIC0gbWUub2Zmc2V0WX1weGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmRyYWdQcm94eS5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZSgnZHJhZ01vdmUnLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgZHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lLCBvd25lciwgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICB7Y2xzfSAgICAgICAgICAgICAgICAgICAgICA9IG93bmVyLFxuICAgICAgICAgICAgcmVjdCAgICAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXREcmFnRWxlbWVudFJlY3QoZGF0YSksXG4gICAgICAgICAgICBtYWluRGF0YSwgb2Zmc2V0WCwgb2Zmc2V0WTtcblxuICAgICAgICBtZS5zZXREYXRhKCk7XG5cbiAgICAgICAgbWFpbkRhdGEgPSBhd2FpdCBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5zZXRDb25maWdzKHtcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICB3aW5kb3dJZCxcbiAgICAgICAgICAgIC4uLm1lLmdldE1haW5UaHJlYWRDb25maWdzKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuYm91bmRhcnlDb250YWluZXJSZWN0ID0gbWFpbkRhdGEuYm91bmRhcnlDb250YWluZXJSZWN0XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1pcy1kcmFnZ2luZycpO1xuICAgICAgICBvd25lci5jbHMgPSBjbHM7XG5cbiAgICAgICAgb2Zmc2V0WCA9IGRhdGEuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgb2Zmc2V0WSA9IGRhdGEuY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdDogcmVjdCxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG1lLmNyZWF0ZURyYWdQcm94eShyZWN0KTtcblxuICAgICAgICBtZS5maXJlKCdkcmFnU3RhcnQnLCB7XG4gICAgICAgICAgICBjbGllbnRYICAgICAgICA6IGRhdGEuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFkgICAgICAgIDogZGF0YS5jbGllbnRZLFxuICAgICAgICAgICAgZHJhZ0VsZW1lbnRSZWN0OiByZWN0LFxuICAgICAgICAgICAgZXZlbnREYXRhICAgICAgOiBkYXRhLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldERyYWdFbGVtZW50UmVjdChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBpZCA9IG1lLmdldERyYWdFbGVtZW50Um9vdCgpLmlkO1xuXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgZGF0YS5wYXRoKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5yZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGRhdGEudGFyZ2V0UGF0aCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ucmVjdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBjYXNlIHlvdSB3YW50IHRvIHdyYXAgeW91ciBkcmFnRWxlbWVudC5cbiAgICAgKiBTZWU6IGRyYWdnYWJsZS50cmVlLkRyYWdab25lXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREcmFnRWxlbWVudFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFbGVtZW50XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW5zaWRlIGNsYXNzIGV4dGVuc2lvbnMgdG8gYWRkIG1vcmUgY29uZmlnc1xuICAgICAqIHdoaWNoIGdldCBwYXNzZWQgdG8gbWFpbi5hZGRvbi5EcmFnRHJvcCBvbkRyYWdTdGFydCgpXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0TWFpblRocmVhZENvbmZpZ3MoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbG93T3ZlcmRyYWcgICAgICA6IG1lLmFsbG93T3ZlcmRyYWcsXG4gICAgICAgICAgICBhbHdheXNGaXJlRHJhZ01vdmUgOiBtZS5hbHdheXNGaXJlRHJhZ01vdmUsXG4gICAgICAgICAgICBib2R5Q3Vyc29yU3R5bGUgICAgOiBtZS5ib2R5Q3Vyc29yU3R5bGUsXG4gICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5ib3VuZGFyeUNvbnRhaW5lcklkLFxuICAgICAgICAgICAgZHJhZ0VsZW1lbnRSb290SWQgIDogbWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWQsXG4gICAgICAgICAgICBkcmFnUHJveHlDbHMgICAgICAgOiBtZS5kcmFnUHJveHlDbHMsXG4gICAgICAgICAgICBkcmFnWm9uZUlkICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIGRyb3Bab25lSWRlbnRpZmllciA6IG1lLmRyb3Bab25lSWRlbnRpZmllcixcbiAgICAgICAgICAgIG1vdmVIb3Jpem9udGFsICAgICA6IG1lLm1vdmVIb3Jpem9udGFsLFxuICAgICAgICAgICAgbW92ZVZlcnRpY2FsICAgICAgIDogbWUubW92ZVZlcnRpY2FsLFxuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQgIDogbWUuc2Nyb2xsQ29udGFpbmVySWQsXG4gICAgICAgICAgICBzY3JvbGxGYWN0b3JMZWZ0ICAgOiBtZS5zY3JvbGxGYWN0b3JMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsRmFjdG9yVG9wICAgIDogbWUuc2Nyb2xsRmFjdG9yVG9wXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgdGhpcyBjbGFzcyBhbmQgb3ZlcnJpZGUgdGhlIGhhbmRsZXIgb3IgbGlzdGVuIHRvIHRoZSBldmVudCBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyb3AoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ2Ryb3AnLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCB0aGlzIGNsYXNzIGFuZCBvdmVycmlkZSB0aGUgaGFuZGxlciBvciBsaXN0ZW4gdG8gdGhlIGV2ZW50IGZyb20gdGhlIG91dHNpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJvcEVudGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdkcm9wOmVudGVyJywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgdGhpcyBjbGFzcyBhbmQgb3ZlcnJpZGUgdGhlIGhhbmRsZXIgb3IgbGlzdGVuIHRvIHRoZSBldmVudCBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyb3BMZWF2ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnZHJvcDpsZWF2ZScsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZXNldERhdGEoKSB7XG4gICAgICAgIHRoaXMudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBudWxsXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHRoaXMgbWV0aG9kIGZvciBjaGlsZCBjbGFzc2VzIHRvIHBhc3MgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGE9e31cbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGE9e30pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kYXRhID0ge1xuICAgICAgICAgICAgZHJhZ0VsZW1lbnQ6IG1lLmdldERyYWdFbGVtZW50Um9vdCgpLFxuICAgICAgICAgICAgZHJhZ1pvbmVJZCA6IG1lLmlkLFxuICAgICAgICAgICAgLi4uZGF0YVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEcmFnWm9uZSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9