"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_tooltip_Base_mjs"],{

/***/ "./src/component/Label.mjs":
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ }),

/***/ "./src/tooltip/Base.mjs":
/*!******************************!*\
  !*** ./src/tooltip/Base.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");



let singletons = {};

/**
 * Base class for component tooltips
 * @class Neo.tooltip.Base
 * @extends Neo.container.Base
 */
class Tooltip extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tooltip.Base'
         * @protected
         */
        className: 'Neo.tooltip.Base',
        /**
         * @member {String} ntype='tooltip'
         * @protected
         */
        ntype: 'tooltip',
        /**
         * @member {String[]} baseCls=['neo-tooltip']
         */
        baseCls: ['neo-tooltip'],
        /**
         * A reference to the target component which is supposed to show this tooltip on mouseenter
         * @member {String|null} componentId_=null
         * @reactive
         */
        componentId_: null,
        /**
         * Delegates down to a CSS selector inside the target component
         * @member {String|null} delegate=null
         */
        delegate: null,
        /**
         * The delay in ms before the tooltip gets hidden while hovering the target element.
         * Use null to disable the dismiss logic.
         * @member {Number|null} dismissDelay=10000
         */
        dismissDelay: 10000,
        /**
         * The dismissDelay task id generated by setTimeout()
         * @member {Number|null} dismissDelayTaskId=null
         * @protected
         */
        dismissDelayTaskId: null,
        /**
         * @member {Boolean} floating=true
         */
        floating: true,
        /**
         * The delay in ms before the tooltip gets shown
         * @member {Number|null} hideDelay=400
         */
        hideDelay: 400,
        /**
         * The showDelay task id generated by setTimeout()
         * @member {Number|null} hideDelayTaskId=null
         * @protected
         */
        hideDelayTaskId: null,
        /**
         * The delay in ms before the tooltip gets shown
         * @member {Number|null} showDelay=200
         */
        showDelay: 200,
        /**
         * The showDelay task id generated by setTimeout()
         * @member {Number|null} showDelayTaskId=null
         * @protected
         */
        showDelayTaskId: null,
        /**
         * True prevents the tooltip from hiding while the mouse cursor is above it
         * @member {Boolean|null} stayOnHover_=true
         * @reactive
         */
        stayOnHover_: true
    }

    /**
     * @param {String} id
     * @param {Function} callback
     * @param {Number} delay
     */
    addTimeout(id, callback, delay) {
        id += 'DelayTaskId';

        this.clearTimeout(this[id]);
        this[id] = setTimeout(callback, delay)
    }

    /**
     * Triggered after the componentId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetComponentId(value, oldValue) {
        if (oldValue) {
            // todo: remove the component domListeners
        }

        if (value) {
            let me = this;

            Neo.getComponent(value).addDomListeners({
                mouseenter: me.onDelegateMouseEnter,
                mouseleave: me.onDelegateMouseLeave,
                delegate  : me.delegate,
                scope     : me
            })
        }
    }

    /**
     * Triggered after the stayOnHover config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetStayOnHover(value, oldValue) {
        if (oldValue) {
            // todo: remove the component domListeners
        }

        if (value) {
            let me = this;

            me.addDomListeners([
                {mouseenter: me.onMouseEnter, scope: me},
                {mouseleave: me.onMouseLeave, scope: me}
            ])
        }
    }

    /**
     * Triggered after the text config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        if (value) {
            let me    = this,
                items = me.items || [],
                item  = items[0];

            if (item?.ntype === 'label') {
                item.text = value
            } else {
                me.add({
                    module: _component_Label_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    text  : value
                })
            }
        }
    }

    /**
     * Clears one or multiple setTimeout call(s)
     * @param {String[]|String} timers valid values: dismiss, hide, show
     */
    clearTimeout(timers) {
        if (!Array.isArray(timers)) {
            timers = [timers]
        }

        let me = this,
            id;

        timers.forEach(timer => {
            id = timer + 'DelayTaskId';

            if (me[id]) {
                clearTimeout(me[id]);
                me[id] = null
            }
        })
    }

    /**
     * @param {Neo.controller.Application} app
     * @returns {Neo.tooltip.Base}
     */
    static createSingleton(app) {
        if (!singletons[app.name]) {
            singletons[app.name] = Neo.create('Neo.tooltip.Base', {
                appName     : app.name,
                componentId : app.mainView.id,
                delegate    : this.delegateFilter,
                isShared    : true,
                resetCfg    : {},
                windowId    : app.mainView.windowId,
                listeners : {
                    // Reconfigure on over a target
                    targetOver({ target, data }) {
                        let me = this,
                            config, key;

                        // Revert last pointerOver config set to initial setting.
                        me.setSilent(me.resetCfg);
                        me.resetCfg = {};

                        // Use the tooltip config block that the target was configured with
                        // to reconfigure this instance, or if there was none, check the
                        // data-neo-tooltip property for a text string.
                        config = target?._tooltip || {text: data.target.data.neoTooltip};

                        // Cache things we have to reset
                        for (key in config) {
                            me.resetCfg[key] = me[key]
                        }

                        // Set ourself up as the target wants
                        me.set(config)
                    }
                }
            });
        }

        return singletons[app.name]
    }

    // Used as a delegate filter to activate on targets which have a tooltip configuration
    static delegateFilter(path) {
        for (let i = 0, { length } = path; i < length; i++) {
            if (path[i].cls.includes('neo-uses-shared-tooltip') || path[i].data['neoTooltip']) {
                return i
            }
        }
    }

    /**
     * Instantly hides the tooltip
     */
    hide() {
        let me = this;

        me.clearTimeout(['dismiss', 'hide', 'show']);
        me.mounted && me.unmount()
    }

    /**
     * Hides the tooltip using the given hideDelay
     * @param {Object|null} data
     */
    hideDelayed(data) {
        let me = this;

        if (me.hideDelay) {
            me.addTimeout('hide', me.hide.bind(me), me.hideDelay)
        } else {
            me.hide(data)
        }
    }

    /**
     * @param {Object} data
     */
    onDelegateMouseEnter(data) {
        let me              = this,
            {currentTarget} = data;

        // If it's an internal move within the delegate, do nothing
        if (currentTarget !== me.activeTarget?.id) {
            me.activeTarget = Neo.get(currentTarget);

            // Allow listeners (eg the Tooltip singleton) which is shared between all Components
            // listens for this in order to reconfigure itself from the activeTarget.
            // So this event must be fired before the alignment is set up.
            me.fire('targetOver', {
                target : me.activeTarget,
                data
            });

            me.align.target = currentTarget;
            me.align.targetMargin = 10;

            // Still visible, just realign
            if (me.mounted) {
                me.show();
                me.alignTo()
            } else {
                me.showDelayed(data)
            }
        }
    }

    /**
     * @param {Object} data
     */
    onDelegateMouseLeave(data) {
        let me = this;

        // If it's an internal move within the delegate, do nothing
        if (data.currentTarget === me.activeTarget?.id) {
            me.fire('targetOut', {
                target : me.activeTarget,
                data
            });

            me.activeTarget = null;
            me.hideDelayed(data)
        }
    }

    /**
     * mouseenter event listener for the tooltip element
     * @param {Object} data
     */
    onMouseEnter(data) {
        let me       = this,
            targetId = data.path[0].id;

        // only use path[0] based events to ignore mouseenter & leave for child nodes
        me.id === targetId && me.clearTimeout(['dismiss', 'hide'])
    }

    /**
     * mouseleave event listener for the tooltip element
     * @param {Object} data
     */
    onMouseLeave(data) {
        let me       = this,
            targetId = data.path[0].id;

        // only use path[0] based events to ignore mouseenter & leave for child nodes
        me.id === targetId && me.hideDelayed(null)
    }

    /**
     * Instantly shows the tooltip
     * @param {Object} data
     */
    show(data) {
        let me = this;

        me.showDelayTaskId = null;

        me.clearTimeout(['hide', 'dismiss']);

        if (me.dismissDelay) {
            me.addTimeout('dismiss', me.hide.bind(me), me.dismissDelay, data)
        }

        !me.mounted && me.initVnode(true)
    }

    /**
     * Shows the tooltip using the given showDelay
     * @param {Object} data
     */
    showDelayed(data) {
        let me = this;

        if (me.showDelay) {
            me.addTimeout('show', me.show.bind(me), me.showDelay)
        } else {
            me.show(data)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tooltip));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190b29sdGlwX0Jhc2VfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFTO0FBQzdCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDUztBQUNDOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFTO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUNBQXVDO0FBQ3hELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDRCQUE0Qiw0REFBSztBQUNqQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUyxRQUFRLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9MYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90b29sdGlwL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY2xhc3MgdG8gcmVuZGVyIGEgbGFiZWwgd2l0aCBhIHRleHRcbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkxhYmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTGFiZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5MYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5MYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdsYWJlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1sYWJlbCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1sYWJlbCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0YWc9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFnOiAnbGFiZWwnXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhMYWJlbCk7XG4iLCJpbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgTGFiZWwgICAgIGZyb20gJy4uL2NvbXBvbmVudC9MYWJlbC5tanMnO1xuXG5sZXQgc2luZ2xldG9ucyA9IHt9O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbXBvbmVudCB0b29sdGlwc1xuICogQGNsYXNzIE5lby50b29sdGlwLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50b29sdGlwLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50b29sdGlwLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9vbHRpcCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0b29sdGlwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRvb2x0aXAnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdG9vbHRpcCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCBjb21wb25lbnQgd2hpY2ggaXMgc3VwcG9zZWQgdG8gc2hvdyB0aGlzIHRvb2x0aXAgb24gbW91c2VlbnRlclxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29tcG9uZW50SWRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnRJZF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxlZ2F0ZXMgZG93biB0byBhIENTUyBzZWxlY3RvciBpbnNpZGUgdGhlIHRhcmdldCBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRlbGVnYXRlPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRlbGVnYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlbGF5IGluIG1zIGJlZm9yZSB0aGUgdG9vbHRpcCBnZXRzIGhpZGRlbiB3aGlsZSBob3ZlcmluZyB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgICAqIFVzZSBudWxsIHRvIGRpc2FibGUgdGhlIGRpc21pc3MgbG9naWMuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBkaXNtaXNzRGVsYXk9MTAwMDBcbiAgICAgICAgICovXG4gICAgICAgIGRpc21pc3NEZWxheTogMTAwMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzbWlzc0RlbGF5IHRhc2sgaWQgZ2VuZXJhdGVkIGJ5IHNldFRpbWVvdXQoKVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gZGlzbWlzc0RlbGF5VGFza0lkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzbWlzc0RlbGF5VGFza0lkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZmxvYXRpbmc9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZmxvYXRpbmc6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgaW4gbXMgYmVmb3JlIHRoZSB0b29sdGlwIGdldHMgc2hvd25cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGhpZGVEZWxheT00MDBcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVEZWxheTogNDAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNob3dEZWxheSB0YXNrIGlkIGdlbmVyYXRlZCBieSBzZXRUaW1lb3V0KClcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGhpZGVEZWxheVRhc2tJZD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVEZWxheVRhc2tJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWxheSBpbiBtcyBiZWZvcmUgdGhlIHRvb2x0aXAgZ2V0cyBzaG93blxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gc2hvd0RlbGF5PTIwMFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0RlbGF5OiAyMDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2hvd0RlbGF5IHRhc2sgaWQgZ2VuZXJhdGVkIGJ5IHNldFRpbWVvdXQoKVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gc2hvd0RlbGF5VGFza0lkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0RlbGF5VGFza0lkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBwcmV2ZW50cyB0aGUgdG9vbHRpcCBmcm9tIGhpZGluZyB3aGlsZSB0aGUgbW91c2UgY3Vyc29yIGlzIGFib3ZlIGl0XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW58bnVsbH0gc3RheU9uSG92ZXJfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF5T25Ib3Zlcl86IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICAgICAqL1xuICAgIGFkZFRpbWVvdXQoaWQsIGNhbGxiYWNrLCBkZWxheSkge1xuICAgICAgICBpZCArPSAnRGVsYXlUYXNrSWQnO1xuXG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRoaXNbaWRdKTtcbiAgICAgICAgdGhpc1tpZF0gPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudElkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbXBvbmVudElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHRvZG86IHJlbW92ZSB0aGUgY29tcG9uZW50IGRvbUxpc3RlbmVyc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KHZhbHVlKS5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgIG1vdXNlZW50ZXI6IG1lLm9uRGVsZWdhdGVNb3VzZUVudGVyLFxuICAgICAgICAgICAgICAgIG1vdXNlbGVhdmU6IG1lLm9uRGVsZWdhdGVNb3VzZUxlYXZlLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlICA6IG1lLmRlbGVnYXRlLFxuICAgICAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdGF5T25Ib3ZlciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFN0YXlPbkhvdmVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHRvZG86IHJlbW92ZSB0aGUgY29tcG9uZW50IGRvbUxpc3RlbmVyc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgICAgIHttb3VzZWVudGVyOiBtZS5vbk1vdXNlRW50ZXIsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAge21vdXNlbGVhdmU6IG1lLm9uTW91c2VMZWF2ZSwgc2NvcGU6IG1lfVxuICAgICAgICAgICAgXSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRleHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpdGVtcyA9IG1lLml0ZW1zIHx8IFtdLFxuICAgICAgICAgICAgICAgIGl0ZW0gID0gaXRlbXNbMF07XG5cbiAgICAgICAgICAgIGlmIChpdGVtPy5udHlwZSA9PT0gJ2xhYmVsJykge1xuICAgICAgICAgICAgICAgIGl0ZW0udGV4dCA9IHZhbHVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIHRleHQgIDogdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIG9uZSBvciBtdWx0aXBsZSBzZXRUaW1lb3V0IGNhbGwocylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gdGltZXJzIHZhbGlkIHZhbHVlczogZGlzbWlzcywgaGlkZSwgc2hvd1xuICAgICAqL1xuICAgIGNsZWFyVGltZW91dCh0aW1lcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRpbWVycykpIHtcbiAgICAgICAgICAgIHRpbWVycyA9IFt0aW1lcnNdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaWQ7XG5cbiAgICAgICAgdGltZXJzLmZvckVhY2godGltZXIgPT4ge1xuICAgICAgICAgICAgaWQgPSB0aW1lciArICdEZWxheVRhc2tJZCc7XG5cbiAgICAgICAgICAgIGlmIChtZVtpZF0pIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQobWVbaWRdKTtcbiAgICAgICAgICAgICAgICBtZVtpZF0gPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5BcHBsaWNhdGlvbn0gYXBwXG4gICAgICogQHJldHVybnMge05lby50b29sdGlwLkJhc2V9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNpbmdsZXRvbihhcHApIHtcbiAgICAgICAgaWYgKCFzaW5nbGV0b25zW2FwcC5uYW1lXSkge1xuICAgICAgICAgICAgc2luZ2xldG9uc1thcHAubmFtZV0gPSBOZW8uY3JlYXRlKCdOZW8udG9vbHRpcC5CYXNlJywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgIDogYXBwLm5hbWUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50SWQgOiBhcHAubWFpblZpZXcuaWQsXG4gICAgICAgICAgICAgICAgZGVsZWdhdGUgICAgOiB0aGlzLmRlbGVnYXRlRmlsdGVyLFxuICAgICAgICAgICAgICAgIGlzU2hhcmVkICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZXNldENmZyAgICA6IHt9LFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgIDogYXBwLm1haW5WaWV3LndpbmRvd0lkLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjb25maWd1cmUgb24gb3ZlciBhIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRPdmVyKHsgdGFyZ2V0LCBkYXRhIH0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLCBrZXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmVydCBsYXN0IHBvaW50ZXJPdmVyIGNvbmZpZyBzZXQgdG8gaW5pdGlhbCBzZXR0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0U2lsZW50KG1lLnJlc2V0Q2ZnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnJlc2V0Q2ZnID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgdG9vbHRpcCBjb25maWcgYmxvY2sgdGhhdCB0aGUgdGFyZ2V0IHdhcyBjb25maWd1cmVkIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHJlY29uZmlndXJlIHRoaXMgaW5zdGFuY2UsIG9yIGlmIHRoZXJlIHdhcyBub25lLCBjaGVjayB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEtbmVvLXRvb2x0aXAgcHJvcGVydHkgZm9yIGEgdGV4dCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSB0YXJnZXQ/Ll90b29sdGlwIHx8IHt0ZXh0OiBkYXRhLnRhcmdldC5kYXRhLm5lb1Rvb2x0aXB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGluZ3Mgd2UgaGF2ZSB0byByZXNldFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUucmVzZXRDZmdba2V5XSA9IG1lW2tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IG91cnNlbGYgdXAgYXMgdGhlIHRhcmdldCB3YW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0KGNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNpbmdsZXRvbnNbYXBwLm5hbWVdXG4gICAgfVxuXG4gICAgLy8gVXNlZCBhcyBhIGRlbGVnYXRlIGZpbHRlciB0byBhY3RpdmF0ZSBvbiB0YXJnZXRzIHdoaWNoIGhhdmUgYSB0b29sdGlwIGNvbmZpZ3VyYXRpb25cbiAgICBzdGF0aWMgZGVsZWdhdGVGaWx0ZXIocGF0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgeyBsZW5ndGggfSA9IHBhdGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2xzLmluY2x1ZGVzKCduZW8tdXNlcy1zaGFyZWQtdG9vbHRpcCcpIHx8IHBhdGhbaV0uZGF0YVsnbmVvVG9vbHRpcCddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRseSBoaWRlcyB0aGUgdG9vbHRpcFxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY2xlYXJUaW1lb3V0KFsnZGlzbWlzcycsICdoaWRlJywgJ3Nob3cnXSk7XG4gICAgICAgIG1lLm1vdW50ZWQgJiYgbWUudW5tb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHRvb2x0aXAgdXNpbmcgdGhlIGdpdmVuIGhpZGVEZWxheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGRhdGFcbiAgICAgKi9cbiAgICBoaWRlRGVsYXllZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmhpZGVEZWxheSkge1xuICAgICAgICAgICAgbWUuYWRkVGltZW91dCgnaGlkZScsIG1lLmhpZGUuYmluZChtZSksIG1lLmhpZGVEZWxheSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmhpZGUoZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EZWxlZ2F0ZU1vdXNlRW50ZXIoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjdXJyZW50VGFyZ2V0fSA9IGRhdGE7XG5cbiAgICAgICAgLy8gSWYgaXQncyBhbiBpbnRlcm5hbCBtb3ZlIHdpdGhpbiB0aGUgZGVsZWdhdGUsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgIT09IG1lLmFjdGl2ZVRhcmdldD8uaWQpIHtcbiAgICAgICAgICAgIG1lLmFjdGl2ZVRhcmdldCA9IE5lby5nZXQoY3VycmVudFRhcmdldCk7XG5cbiAgICAgICAgICAgIC8vIEFsbG93IGxpc3RlbmVycyAoZWcgdGhlIFRvb2x0aXAgc2luZ2xldG9uKSB3aGljaCBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgQ29tcG9uZW50c1xuICAgICAgICAgICAgLy8gbGlzdGVucyBmb3IgdGhpcyBpbiBvcmRlciB0byByZWNvbmZpZ3VyZSBpdHNlbGYgZnJvbSB0aGUgYWN0aXZlVGFyZ2V0LlxuICAgICAgICAgICAgLy8gU28gdGhpcyBldmVudCBtdXN0IGJlIGZpcmVkIGJlZm9yZSB0aGUgYWxpZ25tZW50IGlzIHNldCB1cC5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3RhcmdldE92ZXInLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0IDogbWUuYWN0aXZlVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5hbGlnbi50YXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgbWUuYWxpZ24udGFyZ2V0TWFyZ2luID0gMTA7XG5cbiAgICAgICAgICAgIC8vIFN0aWxsIHZpc2libGUsIGp1c3QgcmVhbGlnblxuICAgICAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBtZS5zaG93KCk7XG4gICAgICAgICAgICAgICAgbWUuYWxpZ25UbygpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnNob3dEZWxheWVkKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRGVsZWdhdGVNb3VzZUxlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBJZiBpdCdzIGFuIGludGVybmFsIG1vdmUgd2l0aGluIHRoZSBkZWxlZ2F0ZSwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoZGF0YS5jdXJyZW50VGFyZ2V0ID09PSBtZS5hY3RpdmVUYXJnZXQ/LmlkKSB7XG4gICAgICAgICAgICBtZS5maXJlKCd0YXJnZXRPdXQnLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0IDogbWUuYWN0aXZlVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgbWUuaGlkZURlbGF5ZWQoZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1vdXNlZW50ZXIgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VFbnRlcihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXRJZCA9IGRhdGEucGF0aFswXS5pZDtcblxuICAgICAgICAvLyBvbmx5IHVzZSBwYXRoWzBdIGJhc2VkIGV2ZW50cyB0byBpZ25vcmUgbW91c2VlbnRlciAmIGxlYXZlIGZvciBjaGlsZCBub2Rlc1xuICAgICAgICBtZS5pZCA9PT0gdGFyZ2V0SWQgJiYgbWUuY2xlYXJUaW1lb3V0KFsnZGlzbWlzcycsICdoaWRlJ10pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbW91c2VsZWF2ZSBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZUxlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRhcmdldElkID0gZGF0YS5wYXRoWzBdLmlkO1xuXG4gICAgICAgIC8vIG9ubHkgdXNlIHBhdGhbMF0gYmFzZWQgZXZlbnRzIHRvIGlnbm9yZSBtb3VzZWVudGVyICYgbGVhdmUgZm9yIGNoaWxkIG5vZGVzXG4gICAgICAgIG1lLmlkID09PSB0YXJnZXRJZCAmJiBtZS5oaWRlRGVsYXllZChudWxsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRseSBzaG93cyB0aGUgdG9vbHRpcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgc2hvdyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuc2hvd0RlbGF5VGFza0lkID0gbnVsbDtcblxuICAgICAgICBtZS5jbGVhclRpbWVvdXQoWydoaWRlJywgJ2Rpc21pc3MnXSk7XG5cbiAgICAgICAgaWYgKG1lLmRpc21pc3NEZWxheSkge1xuICAgICAgICAgICAgbWUuYWRkVGltZW91dCgnZGlzbWlzcycsIG1lLmhpZGUuYmluZChtZSksIG1lLmRpc21pc3NEZWxheSwgZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgICFtZS5tb3VudGVkICYmIG1lLmluaXRWbm9kZSh0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSB0b29sdGlwIHVzaW5nIHRoZSBnaXZlbiBzaG93RGVsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHNob3dEZWxheWVkKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2hvd0RlbGF5KSB7XG4gICAgICAgICAgICBtZS5hZGRUaW1lb3V0KCdzaG93JywgbWUuc2hvdy5iaW5kKG1lKSwgbWUuc2hvd0RlbGF5KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuc2hvdyhkYXRhKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUb29sdGlwKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==