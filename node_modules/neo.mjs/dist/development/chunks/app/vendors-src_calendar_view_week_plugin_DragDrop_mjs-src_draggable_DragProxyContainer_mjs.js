export const __webpack_esm_id__ = "vendors-src_calendar_view_week_plugin_DragDrop_mjs-src_draggable_DragProxyContainer_mjs";
export const __webpack_esm_ids__ = ["vendors-src_calendar_view_week_plugin_DragDrop_mjs-src_draggable_DragProxyContainer_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/calendar/view/week/EventDragZone.mjs"
/*!**************************************************!*\
  !*** ./src/calendar/view/week/EventDragZone.mjs ***!
  \**************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../draggable/DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.calendar.view.week.EventDragZone
 * @extends Neo.draggable.DragZone
 */
class EventDragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.EventDragZone'
         * @protected
         */
        className: 'Neo.calendar.view.week.EventDragZone',
        /**
         * @member {Boolean} addDragProxyCls=false
         */
        addDragProxyCls: false,
        /**
         * @member {Boolean} enableResizingAcrossOppositeEdge=true
         */
        enableResizingAcrossOppositeEdge: true,
        /**
         * @member {Number} axisEndTime=0
         */
        axisEndTime: 0,
        /**
         * @member {Number} axisStartTime=0
         */
        axisStartTime: 0,
        /**
         * @member {Number} columnHeight=0
         */
        columnHeight: 0,
        /**
         * @member {Number} columnTop=0
         */
        columnTop: 0,
        /**
         * @member {Number} currentInterval=0
         */
        currentInterval: 0,
        /**
         * time in minutes
         * @member {Number} eventDuration=0
         */
        eventDuration: 0,
        /**
         * @member {Object} eventRecord=null
         */
        eventRecord: null,
        /**
         * Internal flag.
         * If we resize across the opposite edge and then back, we need to update the related edge position once.
         * @member {Boolean} forceUpdate=false
         * @protected
         */
        forceUpdate: false,
        /**
         * Internal flag
         * @member {Boolean} hasOverflow=false
         * @protected
         */
        hasOverflow: false,
        /**
         * time in minutes
         * @member {Number} intervalSize=15
         */
        intervalSize: 15,
        /**
         * @member {Boolean} keepEndDate=false
         */
        keepEndDate: false,
        /**
         * @member {Boolean} keepStartDate=false
         */
        keepStartDate: false,
        /**
         * @member {Boolean} moveHorizontal=false
         */
        moveHorizontal: false,
        /**
         * @member {Boolean} moveInMainThread=false
         */
        moveInMainThread: false,
        /**
         * Internal flag.
         * @member {Date} newEndDate=null
         * @protected
         */
        newEndDate: null,
        /**
         * Internal flag.
         * @member {Date} newStartDate=null
         * @protected
         */
        newStartDate: null,
        /**
         * @member {Number} scrollFactorLeft=3
         */
        scrollFactorLeft: 3,
        /**
         * @member {Boolean} useProxyWrapper=false
         */
        useProxyWrapper: false
    }

    /**
     *
     */
    addBodyCursorCls() {
        Neo.applyDeltas(this.windowId, {id: 'document.body', cls: {add: ['neo-cursor-move']}})
    }

    /**
     * Resolves the 24:00 issue, where an event would end on the next day
     * @param {Date} date
     * @returns {Date}
     */
    adjustEndDate(date) {
        if (date.getHours() === 0 && date.getMinutes() === 0) {
            // if an event ends at 24:00, change it to 23:59 => otherwise the day increases by 1
            date.setMinutes(date.getMinutes() - 1)
        } else if (!(date.getHours() === 23 && date.getMinutes() === 59) && date.getMinutes() % this.intervalSize !== 0) {
            // otherwise switch non interval based values back
            date.setMinutes(date.getMinutes() + 1)
        }

        return date
    }

    /**
     * Triggered after the proxyParentId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetProxyParentId(value, oldValue) {
        if (value && oldValue !== undefined) {
            let me = this;

            // check if the node did not get removed yet
            if (me.dragProxy?.vdom.cn[0].id) {
                Neo.applyDeltas(me.windowId, {
                    action  : 'moveNode',
                    id      : me.dragProxy.id,
                    index   : 0,
                    parentId: value
                })
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Boolean} createComponent=true
     * @returns {Object|Neo.draggable.DragProxyComponent}
     */
    async createDragProxy(data, createComponent=true) {
        let me        = this,
            component = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            vdom      = me.dragProxyConfig?.vdom,
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].clone(vdom ? vdom : me.dragElement);

            clone.cn[2].removeDom = false;

        const config = {
            module          : _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,
            windowId        : me.windowId,

            ...me.dragProxyConfig,

            vdom: me.useProxyWrapper ? {cn: [clone]} : clone // we want to override dragProxyConfig.vdom if needed
        };

        config.cls = config.cls || [];

        config.cls.push('neo-focus');

        if (component) {
            config.cls.push(component.getTheme())
        }

        if (clone.cls && !me.useProxyWrapper) {
            config.cls.push(...clone.cls)
        }

        if (me.addDragProxyCls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(config.cls, me.dragProxyCls)
        }

        Object.assign(config.style, {
            height: `${data.height}px`,
            top   : `${data.y - me.columnTop}px`,
            width : `${data.width}px`
        });

        if (createComponent) {
            return me.dragProxy = Neo.create(config)
        }

        return config
    }

    /**
     * DragEnd equals drop, since we can only drag to valid positions
     * todo: ESC key
     * @param {Object} data
     */
    dragEnd(data) {
        super.dragEnd(data);

        let me      = this,
            {owner} = me,
            record  = me.eventRecord,
            endDate, startDate;

        if (me.keepStartDate) {
            endDate   = me.newEndDate;
            startDate = me.newStartDate || record.startDate
        } else {
            startDate = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].find(owner.vdom, me.proxyParentId).vdom.flag + 'T12:00:00.000Z');
            startDate.setHours(me.axisStartTime);
            startDate.setMinutes(me.currentInterval * me.intervalSize);

            if (me.keepEndDate) {
                endDate   = me.newEndDate   || record.endDate;
                startDate = me.newStartDate || startDate
            } else {
                endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(startDate);
                endDate.setMinutes(endDate.getMinutes() + me.eventDuration)
            }
        }

        endDate = me.adjustEndDate(endDate);

        record.setSilent({
            endDate,
            startDate
        });

        Object.assign(me, {
            currentInterval: 0,
            hasOverflow    : false,
            keepEndDate    : false,
            keepStartDate  : false,
            newEndDate     : null,
            newStartDate   : null,
            proxyParentId  : null
        });

        // todo: updating a record field which is included inside a sorter should trigger collection.doSort()
        // see: https://github.com/neomjs/neo/issues/2392

        owner.getStateProvider().getStore('events').doSort();
        owner.updateEvents()
    }

    /**
     * @param {Object} data
     */
    dragMove(data) {
        let me              = this,
            {axisEndTime, axisStartTime, columnHeight, eventDuration, intervalSize, keepEndDate, keepStartDate, owner} = me,
            i               = 0,
            path            = data.targetPath,
            len             = path.length,
            record          = me.eventRecord,
            switchDirection = false,
            {timeAxis}      = owner,
            axisStartDate, currentInterval, deltas, duration, endDate, eventIntervals, height, intervalHeight,
            intervals, limitInterval, minimumEventIntervals, position, startDate, startInterval;

        if (me.dragProxy) {
            if (!keepEndDate && !keepStartDate) {
                for (; i < len; i++) {
                    if (path[i].cls.includes('neo-c-w-column')) {
                        me.proxyParentId = path[i].id;
                        break
                    }
                }
            }

            intervals      = (axisEndTime - axisStartTime) * 60 / intervalSize; // 15 minutes each
            intervalHeight = columnHeight / intervals;

            position = Math.min(columnHeight, data.clientY - me.offsetY - me.columnTop);

            currentInterval = Math.floor(position / intervalHeight);

            endDate   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.endDate);
            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.startDate);

            // events can have a smaller start time than the axis min value.
            // resizing via the north handle needs to adjust the duration to honor this.
            if (keepEndDate) {
                if (axisStartTime > startDate.getHours()) {
                    startDate.setHours(axisStartTime);
                    startDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000 // duration in minutes
                }
            }

            // events can have a bigger end time than the axis max value.
            // resizing via the south handle needs to adjust the duration to honor this.
            if (keepStartDate) {
                if (axisEndTime < endDate.getHours()) {
                    endDate.setHours(axisEndTime);
                    endDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000 // duration in minutes
                }
            }

            if (!keepEndDate) {
                // events must not end after the last visible interval
                currentInterval = Math.min(currentInterval, intervals - (eventDuration / intervalSize))
            }

            deltas = [{
                id   : me.dragProxy.id,
                style: {}
            }];

            if (keepEndDate || keepStartDate) {
                axisStartDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.startDate);
                axisStartDate.setHours(axisStartTime);
                axisStartDate.setMinutes(0);

                minimumEventIntervals = owner.minimumEventDuration / intervalSize;
                startInterval         = (record.startDate - axisStartDate) / intervalSize / 60 / 1000;

                if (keepEndDate) {
                    limitInterval = startInterval + (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        if (me.forceUpdate && currentInterval > limitInterval -minimumEventIntervals && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return
                        } else if (currentInterval >= limitInterval + minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(currentInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(limitInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                            deltas[0].style.top = `calc(${limitInterval * intervalHeight / columnHeight * 100}% + 1px)`
                        } else {
                            me.forceUpdate  = false;
                            me.newStartDate = null
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.min(currentInterval, limitInterval - minimumEventIntervals)
                    }

                } else if (keepStartDate) {
                    limitInterval = startInterval - (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        // events must not start before the first visible interval
                        currentInterval = Math.max(-(eventDuration / intervalSize), currentInterval);

                        if (currentInterval <= limitInterval - minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(eventDuration + limitInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(eventDuration + currentInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours

                            position = (eventDuration / intervalSize + currentInterval) * intervalHeight; // snap to valid intervals
                            position = position / columnHeight * 100;

                            deltas[0].style.top = `calc(${position}% + 1px)`
                        } else if (me.forceUpdate && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return
                        } else if (me.forceUpdate && currentInterval >= limitInterval + minimumEventIntervals) {
                            if (me.currentInterval !== currentInterval) {
                                me.forceUpdate  = false;
                                me.newStartDate = null;
                                deltas[0].style.top = `calc(${startInterval * intervalHeight / columnHeight * 100}% + 1px)`
                            }
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.max(currentInterval, limitInterval + minimumEventIntervals)
                    }
                }
            }

            if (!keepStartDate) {
                // events must not start before the first visible interval
                currentInterval = Math.max(0, currentInterval)
            }

            if (me.currentInterval !== currentInterval) {
                if (!switchDirection) {
                    if (!keepEndDate) {
                        endDate.setHours(axisStartTime);
                        endDate.setMinutes(eventDuration + currentInterval * intervalSize)
                    }

                    if (keepStartDate) {
                        me.newEndDate = endDate;
                        duration = (endDate - record.startDate) / 60 / 60 / 1000 // duration in hours
                    } else {
                        startDate.setHours(axisStartTime);
                        startDate.setMinutes(currentInterval * intervalSize);

                        position = currentInterval * intervalHeight; // snap to valid intervals
                        position = position / columnHeight * 100;

                        deltas[0].style.top = `calc(${position}% + 1px)`
                    }

                    if (keepEndDate) {
                        duration = (record.endDate - startDate) / 60 / 60 / 1000 // duration in hours
                    }
                }

                endDate = me.adjustEndDate(endDate);

                deltas.push({
                    id         : me.dragProxy.vdom.cn[2].id,
                    textContent: owner.intlFormat_time.format(endDate)
                });

                if (keepEndDate || keepStartDate) {
                    height = Math.round(duration / (axisEndTime - axisStartTime) * 100 * 1000) / 1000;
                    deltas[0].style.height = `calc(${height}% - 2px)`
                }

                deltas.push({
                    id         : me.dragProxy.vdom.cn[0].id,
                    textContent: owner.intlFormat_time.format(startDate)
                });

                // check if the node got added yet
                if (me.dragProxy.vdom.cn[0].id) {
                    eventIntervals = (duration && duration * 60 || eventDuration) / timeAxis.interval;

                    if (eventIntervals <= 2) {
                        if (timeAxis.rowHeight / eventIntervals < 25 && !me.hasOverflow) {
                            deltas.push({
                                id : me.dragProxy.id,
                                cls: {add: ['neo-overflow']}
                            });

                            me.hasOverflow = true
                        }
                    } else if (me.hasOverflow) {
                        deltas.push({
                            id : me.dragProxy.id,
                            cls: {remove: ['neo-overflow']}
                        });

                        me.hasOverflow = false
                    }

                    Neo.applyDeltas(me.windowId, deltas)
                }
            }

            me.currentInterval = currentInterval
        }
    }

    /**
     * @param {Object} data
     */
    async dragStart(data) {
        let me            = this,
            rects         = await me.owner.getDomRect([me.getDragElementRoot().id, data.path[1].id]),
            eventDuration = (me.eventRecord.endDate - me.eventRecord.startDate) / 60 / 1000,
            offsetX       = data.clientX - rects[0].left,
            offsetY       = data.clientY - rects[0].top;

        Object.assign(me, {
            columnHeight   : rects[1].height,
            columnTop      : rects[1].top,
            dragElementRect: rects[0],
            eventDuration  : Math.round(eventDuration / me.intervalSize) * me.intervalSize,
            offsetX,
            offsetY
        });

        await me.createDragProxy(rects[0]);

        me.fire('dragStart', {
            dragElementRect: rects[0],
            id             : me.id,
            offsetX,
            offsetY
        });

        me.dragMove(data)
    }

    /**
     *
     */
    removeBodyCursorCls() {
        Neo.applyDeltas(this.windowId, {id: 'document.body', cls: {remove: ['neo-cursor-move']}})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(EventDragZone));


/***/ },

/***/ "./src/calendar/view/week/plugin/DragDrop.mjs"
/*!****************************************************!*\
  !*** ./src/calendar/view/week/plugin/DragDrop.mjs ***!
  \****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EventDragZone.mjs */ "./src/calendar/view/week/EventDragZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../util/VDom.mjs */ "./src/util/VDom.mjs");





const newRecordSymbol = Symbol.for('newRecordSymbol');

/**
 * @class Neo.calendar.view.week.plugin.DragDrop
 * @extends Neo.plugin.Base
 */
class DragDrop extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.plugin.DragDrop'
         * @protected
         */
        className: 'Neo.calendar.view.week.plugin.DragDrop',
        /**
         * @member {String} ntype='plugin-calendar-week-dragdrop'
         * @protected
         */
        ntype: 'plugin-calendar-week-dragdrop',
        /**
         * @member {Boolean} isDragging=false
         * @protected
         */
        isDragging: false,
        /**
         * @member {String} resizablePluginType='plugin-calendar-week-dragdrop'
         */
        resizablePluginType: 'calendar-week-eventresizable'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me         = this,
            columnOpts = {scope: me, delegate: '.neo-c-w-column'},
            eventOpts  = {scope: me, delegate: '.neo-event'};

        me.owner.addDomListeners([
            {'drag:end'  : me.onColumnDragEnd,   ...columnOpts},
            {'drag:end'  : me.onEventDragEnd,    ...eventOpts},
            {'drag:move' : me.onColumnDragMove,  ...columnOpts},
            {'drag:move' : me.onEventDragMove,   ...eventOpts},
            {'drag:start': me.onColumnDragStart, ...columnOpts},
            {'drag:start': me.onEventDragStart,  ...eventOpts}
        ]);
    }

    /**
     * Adjusts drag events which start on an event resize handle
     * @param {Object} data
     * @returns {Object}
     */
    adjustResizeEvent(data) {
        data.path.shift();
        data.targetPath.shift();
        data.target = data.path[0];

        return data;
    }

    /**
     * @param {Object} opts
     * @param {Object} opts.dragElement
     * @param {Boolean} opts.enableResizingAcrossOppositeEdge
     * @param {Object} opts.eventRecord
     * @param {String} opts.proxyParentId
     * @returns {Neo.calendar.view.week.EventDragZone}
     */
    getEventDragZone(opts) {
        let me                         = this,
            {appName, owner, windowId} = me,
            {eventDragZone, timeAxis}  = owner,

            config = {
                axisEndTime                     : timeAxis.getTime(owner.endTime),
                axisStartTime                   : timeAxis.getTime(owner.startTime),
                dragElement                     : opts.dragElement,
                enableResizingAcrossOppositeEdge: opts.enableResizingAcrossOppositeEdge,
                eventRecord                     : opts.eventRecord,
                proxyParentId                   : opts.proxyParentId
            };

        if (!eventDragZone) {
            owner.eventDragZone = eventDragZone = Neo.create({
                module           : _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                appName,
                owner,
                scrollContainerId: owner.getScrollContainer().id,
                windowId,
                ...config,

                dragProxyConfig: {
                    style: {
                        transition: 'none',
                        willChange: 'height'
                    }
                }
            })
        } else {
            eventDragZone.set(config)
        }

        return eventDragZone
    }

    /**
     * Returns the active field value of the active or first calendar record
     * @returns {Boolean}
     */
    isActiveCalendar() {
        let {owner}         = this,
            {calendarStore} = owner,
            calendarId      = owner.data.activeCalendarId || calendarStore.getAt(0)[calendarStore.keyProperty];

        return calendarStore.get(calendarId).active
    }

    /**
     * @param {Object} path
     * @returns {Boolean}
     */
    isTopLevelColumn(path) {
        return path[0].cls.includes('neo-c-w-column')
    }

    /**
     * @param {Object} eventData
     * @returns {Boolean}
     */
    isTopLevelEvent(eventData) {
        return eventData.path[0].cls.includes('neo-event')
    }

    /**
     * @param {Object} data
     */
    onColumnDragEnd(data) {
        let me      = this,
            {owner} = me,
            record  = me[newRecordSymbol];

        if (record && me.isTopLevelColumn(data.path)) {
            me.isDragging = false;

            delete me[newRecordSymbol];

            Neo.applyDeltas(me.windowId, {
                id   : owner.getEventId(record.id),
                style: {opacity: 1}
            }).then(() => {
                owner.eventDragZone.dragEnd();
                owner.getPlugin(me.resizablePluginType).onDragEnd(data)
            })
        }
    }

    /**
     * @param {Object} data
     */
    onColumnDragMove(data) {
        let me = this;

        if (me.isActiveCalendar() && me.isTopLevelColumn(data.path)) {
            me.owner.eventDragZone?.dragMove(data)
        }
    }

    /**
     * @param {Object} data
     */
    async onColumnDragStart(data) {
        let me = this;

        if (me.isActiveCalendar() && me.isTopLevelColumn(data.targetPath)) {
            let {owner}         = me,
                axisStartTime   = owner.timeAxis.getTime(owner.startTime),
                {calendarStore} = owner,
                columnRect      = data.path[0].rect,
                intervalSize    = 15,
                intervals       = (owner.timeAxis.getTime(owner.endTime) - axisStartTime) * 60 / intervalSize,
                intervalHeight  = columnRect.height / intervals,
                position        = Math.min(columnRect.height, data.clientY - columnRect.top),
                currentInterval = Math.floor(position / intervalHeight),
                startDate       = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, data.path[0].id).vdom.flag + 'T12:00:00.000Z'),
                dragElement, endDate, eventDragZone, eventId, record;

            me.isDragging = true;

            startDate.setHours(axisStartTime);
            startDate.setMinutes(Math.min(currentInterval * intervalSize, intervals * intervalSize - owner.minimumEventDuration));

            endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(startDate);

            endDate.setMinutes(endDate.getMinutes() + owner.minimumEventDuration);

            // 24:00 fix
            endDate.getHours() === 0 && endDate.getMinutes() === 0 && endDate.setMinutes(endDate.getMinutes() - 1);

            record = owner.eventStore.add({
                calendarId: owner.data.activeCalendarId || calendarStore.getAt(0)[calendarStore.keyProperty],
                endDate,
                startDate,
                title     : 'New Event'
            }, true)[0];

            // we need to cache a reference to make the record accessible for onColumnDragEnd()
            me[newRecordSymbol] = record;

            // wait until the new event got mounted
            await me.timeout(50);

            eventId     = owner.getEventId(record.id);
            dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, eventId).vdom;

            eventDragZone = me.getEventDragZone({
                dragElement,
                enableResizingAcrossOppositeEdge: true,
                eventRecord                     : record,
                proxyParentId                   : data.path[0].id
            });

            owner.getPlugin(me.resizablePluginType).onDragStart(data);
            await eventDragZone.dragStart(data);

            await me.timeout(50);

            me.isDragging && Neo.applyDeltas(me.windowId, {
                id   : eventId,
                style: {opacity: 0}
            })
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragEnd(data) {
        let me              = this,
            {owner}         = me,
            {eventDragZone} = owner;

        if (owner.enableDrag) {
            eventDragZone.dragEnd();

            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data);
                owner.getPlugin(me.resizablePluginType).onDragEnd(data)
            } else {
                eventDragZone.removeBodyCursorCls()
            }

            me.isDragging = false
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragMove(data) {
        let me      = this,
            {owner} = me;

        if (owner.enableDrag) {
            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data)
            }

            owner.eventDragZone.dragMove(data)
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragStart(data) {
        let me        = this,
            {owner}   = me,
            modelData = owner.data;

        if (owner.enableDrag) {
            let isTopLevelEvent = me.isTopLevelEvent(data),
                dragElement, eventDragZone;

            if (!isTopLevelEvent) {
                data = me.adjustResizeEvent(data)
            }

            me.isDragging = true;

            dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, data.path[0].id).vdom;

            eventDragZone = me.getEventDragZone({
                dragElement,
                enableResizingAcrossOppositeEdge: modelData.events.enableResizingAcrossOppositeEdge,
                eventRecord                     : owner.eventStore.get(dragElement.flag),
                proxyParentId                   : data.path[1].id
            });

            if (isTopLevelEvent) {
                eventDragZone.addBodyCursorCls()
            } else {
                owner.getPlugin(me.resizablePluginType).onDragStart(data)
            }

            eventDragZone.dragStart(data)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragDrop));


/***/ },

/***/ "./src/draggable/DragProxyComponent.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyComponent));


/***/ },

/***/ "./src/draggable/DragProxyContainer.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyContainer.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");



/**
 * @class Neo.draggable.DragProxyContainer
 * @extends Neo.container.Base
 */
class DragProxyContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyContainer'
         * @protected
         */
        className: 'Neo.draggable.DragProxyContainer',
        /**
         * @member {String} ntype='dragproxycontainer'
         * @protected
         */
        ntype: 'dragproxycontainer',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Object} layout='fit'
         * @reactive
         */
        layout: 'fit',
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        // We want to reuse the styling of the DragProxyComponent, since both use the same baseCls.
        // Instead of duplicating the scss file, we are forcing the ThemeEngine to load the component file.
        if (value) {
            Neo.currentWorker.insertThemeFiles(value, _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype)
        }
    }

    /**
     * We do NOT want to destroy child items, since they get re-used.
     * @param {...*} args
     */
    destroy(...args) {
        this.items = [];
        super.destroy(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyContainer));


/***/ },

/***/ "./src/plugin/Base.mjs"
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X3dlZWtfcGx1Z2luX0RyYWdEcm9wX21qcy1zcmNfZHJhZ2dhYmxlX0RyYWdQcm94eUNvbnRhaW5lcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNtQjtBQUNWO0FBQ1I7QUFDRDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQVE7QUFDcEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtB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QSxpQkFBaUIsdUJBQXVCOztBQUV4Qyx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtEQUFrQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGtDQUFrQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDcEZkOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYSxPQUFPLFdBQVc7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy93ZWVrL0V2ZW50RHJhZ1pvbmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY2FsZW5kYXIvdmlldy93ZWVrL3BsdWdpbi9EcmFnRHJvcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kcmFnZ2FibGUvRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9EcmFnUHJveHlDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRlVXRpbCAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29tcG9uZW50IGZyb20gJy4uLy4uLy4uL2RyYWdnYWJsZS9EcmFnUHJveHlDb21wb25lbnQubWpzJztcbmltcG9ydCBEcmFnWm9uZSAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LndlZWsuRXZlbnREcmFnWm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS5EcmFnWm9uZVxuICovXG5jbGFzcyBFdmVudERyYWdab25lIGV4dGVuZHMgRHJhZ1pvbmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudERyYWdab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy53ZWVrLkV2ZW50RHJhZ1pvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWRkRHJhZ1Byb3h5Q2xzPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGREcmFnUHJveHlDbHM6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2U9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2U6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGF4aXNFbmRUaW1lPTBcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNFbmRUaW1lOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBheGlzU3RhcnRUaW1lPTBcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNTdGFydFRpbWU6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtbkhlaWdodD0wXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5IZWlnaHQ6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtblRvcD0wXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5Ub3A6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbnRlcnZhbD0wXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50SW50ZXJ2YWw6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aW1lIGluIG1pbnV0ZXNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBldmVudER1cmF0aW9uPTBcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50RHVyYXRpb246IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGV2ZW50UmVjb3JkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50UmVjb3JkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy5cbiAgICAgICAgICogSWYgd2UgcmVzaXplIGFjcm9zcyB0aGUgb3Bwb3NpdGUgZWRnZSBhbmQgdGhlbiBiYWNrLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmVsYXRlZCBlZGdlIHBvc2l0aW9uIG9uY2UuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGZvcmNlVXBkYXRlPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGFzT3ZlcmZsb3c9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzT3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogdGltZSBpbiBtaW51dGVzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaW50ZXJ2YWxTaXplPTE1XG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnZhbFNpemU6IDE1LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0ga2VlcEVuZERhdGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGtlZXBFbmREYXRlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGtlZXBTdGFydERhdGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGtlZXBTdGFydERhdGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUhvcml6b250YWw9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVIb3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVJbk1haW5UaHJlYWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy5cbiAgICAgICAgICogQG1lbWJlciB7RGF0ZX0gbmV3RW5kRGF0ZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5ld0VuZERhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnLlxuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfSBuZXdTdGFydERhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBuZXdTdGFydERhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbEZhY3RvckxlZnQ9M1xuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdDogMyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVByb3h5V3JhcHBlcj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlUHJveHlXcmFwcGVyOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkQm9keUN1cnNvckNscygpIHtcbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKHRoaXMud2luZG93SWQsIHtpZDogJ2RvY3VtZW50LmJvZHknLCBjbHM6IHthZGQ6IFsnbmVvLWN1cnNvci1tb3ZlJ119fSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgMjQ6MDAgaXNzdWUsIHdoZXJlIGFuIGV2ZW50IHdvdWxkIGVuZCBvbiB0aGUgbmV4dCBkYXlcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICAgKi9cbiAgICBhZGp1c3RFbmREYXRlKGRhdGUpIHtcbiAgICAgICAgaWYgKGRhdGUuZ2V0SG91cnMoKSA9PT0gMCAmJiBkYXRlLmdldE1pbnV0ZXMoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgYW4gZXZlbnQgZW5kcyBhdCAyNDowMCwgY2hhbmdlIGl0IHRvIDIzOjU5ID0+IG90aGVyd2lzZSB0aGUgZGF5IGluY3JlYXNlcyBieSAxXG4gICAgICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgLSAxKVxuICAgICAgICB9IGVsc2UgaWYgKCEoZGF0ZS5nZXRIb3VycygpID09PSAyMyAmJiBkYXRlLmdldE1pbnV0ZXMoKSA9PT0gNTkpICYmIGRhdGUuZ2V0TWludXRlcygpICUgdGhpcy5pbnRlcnZhbFNpemUgIT09IDApIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzd2l0Y2ggbm9uIGludGVydmFsIGJhc2VkIHZhbHVlcyBiYWNrXG4gICAgICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyAxKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHByb3h5UGFyZW50SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UHJveHlQYXJlbnRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBub2RlIGRpZCBub3QgZ2V0IHJlbW92ZWQgeWV0XG4gICAgICAgICAgICBpZiAobWUuZHJhZ1Byb3h5Py52ZG9tLmNuWzBdLmlkKSB7XG4gICAgICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiAgOiAnbW92ZU5vZGUnLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuZHJhZ1Byb3h5LmlkLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCAgIDogMCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjcmVhdGVDb21wb25lbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnR9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRHJhZ1Byb3h5KGRhdGEsIGNyZWF0ZUNvbXBvbmVudD10cnVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChtZS5nZXREcmFnRWxlbWVudFJvb3QoKS5pZCkgfHwgbWUub3duZXIsXG4gICAgICAgICAgICB2ZG9tICAgICAgPSBtZS5kcmFnUHJveHlDb25maWc/LnZkb20sXG4gICAgICAgICAgICBjbG9uZSAgICAgPSBWRG9tVXRpbC5jbG9uZSh2ZG9tID8gdmRvbSA6IG1lLmRyYWdFbGVtZW50KTtcblxuICAgICAgICAgICAgY2xvbmUuY25bMl0ucmVtb3ZlRG9tID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgbW9kdWxlICAgICAgICAgIDogRHJhZ1Byb3h5Q29tcG9uZW50LFxuICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IG1lLm1vdmVJbk1haW5UaHJlYWQsXG4gICAgICAgICAgICBwYXJlbnRJZCAgICAgICAgOiBtZS5wcm94eVBhcmVudElkLFxuICAgICAgICAgICAgd2luZG93SWQgICAgICAgIDogbWUud2luZG93SWQsXG5cbiAgICAgICAgICAgIC4uLm1lLmRyYWdQcm94eUNvbmZpZyxcblxuICAgICAgICAgICAgdmRvbTogbWUudXNlUHJveHlXcmFwcGVyID8ge2NuOiBbY2xvbmVdfSA6IGNsb25lIC8vIHdlIHdhbnQgdG8gb3ZlcnJpZGUgZHJhZ1Byb3h5Q29uZmlnLnZkb20gaWYgbmVlZGVkXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uZmlnLmNscyA9IGNvbmZpZy5jbHMgfHwgW107XG5cbiAgICAgICAgY29uZmlnLmNscy5wdXNoKCduZW8tZm9jdXMnKTtcblxuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25maWcuY2xzLnB1c2goY29tcG9uZW50LmdldFRoZW1lKCkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvbmUuY2xzICYmICFtZS51c2VQcm94eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMucHVzaCguLi5jbG9uZS5jbHMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuYWRkRHJhZ1Byb3h5Q2xzKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY29uZmlnLmNscywgbWUuZHJhZ1Byb3h5Q2xzKVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcuc3R5bGUsIHtcbiAgICAgICAgICAgIGhlaWdodDogYCR7ZGF0YS5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgdG9wICAgOiBgJHtkYXRhLnkgLSBtZS5jb2x1bW5Ub3B9cHhgLFxuICAgICAgICAgICAgd2lkdGggOiBgJHtkYXRhLndpZHRofXB4YFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY3JlYXRlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuZHJhZ1Byb3h5ID0gTmVvLmNyZWF0ZShjb25maWcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhZ0VuZCBlcXVhbHMgZHJvcCwgc2luY2Ugd2UgY2FuIG9ubHkgZHJhZyB0byB2YWxpZCBwb3NpdGlvbnNcbiAgICAgKiB0b2RvOiBFU0Mga2V5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBkcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgc3VwZXIuZHJhZ0VuZChkYXRhKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICByZWNvcmQgID0gbWUuZXZlbnRSZWNvcmQsXG4gICAgICAgICAgICBlbmREYXRlLCBzdGFydERhdGU7XG5cbiAgICAgICAgaWYgKG1lLmtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgIGVuZERhdGUgICA9IG1lLm5ld0VuZERhdGU7XG4gICAgICAgICAgICBzdGFydERhdGUgPSBtZS5uZXdTdGFydERhdGUgfHwgcmVjb3JkLnN0YXJ0RGF0ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnREYXRlID0gbmV3IERhdGUoVkRvbVV0aWwuZmluZChvd25lci52ZG9tLCBtZS5wcm94eVBhcmVudElkKS52ZG9tLmZsYWcgKyAnVDEyOjAwOjAwLjAwMFonKTtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhtZS5heGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKG1lLmN1cnJlbnRJbnRlcnZhbCAqIG1lLmludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgIGlmIChtZS5rZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIGVuZERhdGUgICA9IG1lLm5ld0VuZERhdGUgICB8fCByZWNvcmQuZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICBzdGFydERhdGUgPSBtZS5uZXdTdGFydERhdGUgfHwgc3RhcnREYXRlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZERhdGUgPSBEYXRlVXRpbC5jbG9uZShzdGFydERhdGUpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcyhlbmREYXRlLmdldE1pbnV0ZXMoKSArIG1lLmV2ZW50RHVyYXRpb24pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbmREYXRlID0gbWUuYWRqdXN0RW5kRGF0ZShlbmREYXRlKTtcblxuICAgICAgICByZWNvcmQuc2V0U2lsZW50KHtcbiAgICAgICAgICAgIGVuZERhdGUsXG4gICAgICAgICAgICBzdGFydERhdGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgY3VycmVudEludGVydmFsOiAwLFxuICAgICAgICAgICAgaGFzT3ZlcmZsb3cgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBFbmREYXRlICAgIDogZmFsc2UsXG4gICAgICAgICAgICBrZWVwU3RhcnREYXRlICA6IGZhbHNlLFxuICAgICAgICAgICAgbmV3RW5kRGF0ZSAgICAgOiBudWxsLFxuICAgICAgICAgICAgbmV3U3RhcnREYXRlICAgOiBudWxsLFxuICAgICAgICAgICAgcHJveHlQYXJlbnRJZCAgOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRvZG86IHVwZGF0aW5nIGEgcmVjb3JkIGZpZWxkIHdoaWNoIGlzIGluY2x1ZGVkIGluc2lkZSBhIHNvcnRlciBzaG91bGQgdHJpZ2dlciBjb2xsZWN0aW9uLmRvU29ydCgpXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIzOTJcblxuICAgICAgICBvd25lci5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoJ2V2ZW50cycpLmRvU29ydCgpO1xuICAgICAgICBvd25lci51cGRhdGVFdmVudHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtheGlzRW5kVGltZSwgYXhpc1N0YXJ0VGltZSwgY29sdW1uSGVpZ2h0LCBldmVudER1cmF0aW9uLCBpbnRlcnZhbFNpemUsIGtlZXBFbmREYXRlLCBrZWVwU3RhcnREYXRlLCBvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBwYXRoICAgICAgICAgICAgPSBkYXRhLnRhcmdldFBhdGgsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgICAgPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIHJlY29yZCAgICAgICAgICA9IG1lLmV2ZW50UmVjb3JkLFxuICAgICAgICAgICAgc3dpdGNoRGlyZWN0aW9uID0gZmFsc2UsXG4gICAgICAgICAgICB7dGltZUF4aXN9ICAgICAgPSBvd25lcixcbiAgICAgICAgICAgIGF4aXNTdGFydERhdGUsIGN1cnJlbnRJbnRlcnZhbCwgZGVsdGFzLCBkdXJhdGlvbiwgZW5kRGF0ZSwgZXZlbnRJbnRlcnZhbHMsIGhlaWdodCwgaW50ZXJ2YWxIZWlnaHQsXG4gICAgICAgICAgICBpbnRlcnZhbHMsIGxpbWl0SW50ZXJ2YWwsIG1pbmltdW1FdmVudEludGVydmFscywgcG9zaXRpb24sIHN0YXJ0RGF0ZSwgc3RhcnRJbnRlcnZhbDtcblxuICAgICAgICBpZiAobWUuZHJhZ1Byb3h5KSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBFbmREYXRlICYmICFrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aFtpXS5jbHMuaW5jbHVkZXMoJ25lby1jLXctY29sdW1uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnByb3h5UGFyZW50SWQgPSBwYXRoW2ldLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW50ZXJ2YWxzICAgICAgPSAoYXhpc0VuZFRpbWUgLSBheGlzU3RhcnRUaW1lKSAqIDYwIC8gaW50ZXJ2YWxTaXplOyAvLyAxNSBtaW51dGVzIGVhY2hcbiAgICAgICAgICAgIGludGVydmFsSGVpZ2h0ID0gY29sdW1uSGVpZ2h0IC8gaW50ZXJ2YWxzO1xuXG4gICAgICAgICAgICBwb3NpdGlvbiA9IE1hdGgubWluKGNvbHVtbkhlaWdodCwgZGF0YS5jbGllbnRZIC0gbWUub2Zmc2V0WSAtIG1lLmNvbHVtblRvcCk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGguZmxvb3IocG9zaXRpb24gLyBpbnRlcnZhbEhlaWdodCk7XG5cbiAgICAgICAgICAgIGVuZERhdGUgICA9IERhdGVVdGlsLmNsb25lKHJlY29yZC5lbmREYXRlKTtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IERhdGVVdGlsLmNsb25lKHJlY29yZC5zdGFydERhdGUpO1xuXG4gICAgICAgICAgICAvLyBldmVudHMgY2FuIGhhdmUgYSBzbWFsbGVyIHN0YXJ0IHRpbWUgdGhhbiB0aGUgYXhpcyBtaW4gdmFsdWUuXG4gICAgICAgICAgICAvLyByZXNpemluZyB2aWEgdGhlIG5vcnRoIGhhbmRsZSBuZWVkcyB0byBhZGp1c3QgdGhlIGR1cmF0aW9uIHRvIGhvbm9yIHRoaXMuXG4gICAgICAgICAgICBpZiAoa2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1N0YXJ0VGltZSA+IHN0YXJ0RGF0ZS5nZXRIb3VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldE1pbnV0ZXMoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnREdXJhdGlvbiA9IChlbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gMTAwMCAvLyBkdXJhdGlvbiBpbiBtaW51dGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBldmVudHMgY2FuIGhhdmUgYSBiaWdnZXIgZW5kIHRpbWUgdGhhbiB0aGUgYXhpcyBtYXggdmFsdWUuXG4gICAgICAgICAgICAvLyByZXNpemluZyB2aWEgdGhlIHNvdXRoIGhhbmRsZSBuZWVkcyB0byBhZGp1c3QgdGhlIGR1cmF0aW9uIHRvIGhvbm9yIHRoaXMuXG4gICAgICAgICAgICBpZiAoa2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzRW5kVGltZSA8IGVuZERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldEhvdXJzKGF4aXNFbmRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDEwMDAgLy8gZHVyYXRpb24gaW4gbWludXRlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFrZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBtdXN0IG5vdCBlbmQgYWZ0ZXIgdGhlIGxhc3QgdmlzaWJsZSBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWluKGN1cnJlbnRJbnRlcnZhbCwgaW50ZXJ2YWxzIC0gKGV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemUpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWx0YXMgPSBbe1xuICAgICAgICAgICAgICAgIGlkICAgOiBtZS5kcmFnUHJveHkuaWQsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHt9XG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlIHx8IGtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICBheGlzU3RhcnREYXRlID0gRGF0ZVV0aWwuY2xvbmUocmVjb3JkLnN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0RGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICBheGlzU3RhcnREYXRlLnNldE1pbnV0ZXMoMCk7XG5cbiAgICAgICAgICAgICAgICBtaW5pbXVtRXZlbnRJbnRlcnZhbHMgPSBvd25lci5taW5pbXVtRXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZTtcbiAgICAgICAgICAgICAgICBzdGFydEludGVydmFsICAgICAgICAgPSAocmVjb3JkLnN0YXJ0RGF0ZSAtIGF4aXNTdGFydERhdGUpIC8gaW50ZXJ2YWxTaXplIC8gNjAgLyAxMDAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0SW50ZXJ2YWwgPSBzdGFydEludGVydmFsICsgKGV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5lbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmZvcmNlVXBkYXRlICYmIGN1cnJlbnRJbnRlcnZhbCA+IGxpbWl0SW50ZXJ2YWwgLW1pbmltdW1FdmVudEludGVydmFscyAmJiBjdXJyZW50SW50ZXJ2YWwgPCBsaW1pdEludGVydmFsICsgbWluaW11bUV2ZW50SW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB3ZSByZXNpemUgYmFjayB0byB0aGUgb3JpZ2luYWwgZGlyZWN0aW9uLCBrZWVwIHRoZSBtaW4gaW50ZXJ2YWwgdW50aWwgd2Ugc25hcCBiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRJbnRlcnZhbCA+PSBsaW1pdEludGVydmFsICsgbWluaW11bUV2ZW50SW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoRGlyZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5mb3JjZVVwZGF0ZSAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoY3VycmVudEludGVydmFsICogaW50ZXJ2YWxTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlID0gbWUuYWRqdXN0RW5kRGF0ZShlbmREYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld0VuZERhdGUgPSBlbmREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKGxpbWl0SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3U3RhcnREYXRlID0gc3RhcnREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMDsgLy8gZHVyYXRpb24gaW4gaG91cnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUudG9wID0gYGNhbGMoJHtsaW1pdEludGVydmFsICogaW50ZXJ2YWxIZWlnaHQgLyBjb2x1bW5IZWlnaHQgKiAxMDB9JSArIDFweClgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZvcmNlVXBkYXRlICA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld1N0YXJ0RGF0ZSA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3dpdGNoRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLm1pbihjdXJyZW50SW50ZXJ2YWwsIGxpbWl0SW50ZXJ2YWwgLSBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW1pdEludGVydmFsID0gc3RhcnRJbnRlcnZhbCAtIChldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBtdXN0IG5vdCBzdGFydCBiZWZvcmUgdGhlIGZpcnN0IHZpc2libGUgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWF4KC0oZXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZSksIGN1cnJlbnRJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJ2YWwgPD0gbGltaXRJbnRlcnZhbCAtIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaERpcmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuZm9yY2VVcGRhdGUgID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKGV2ZW50RHVyYXRpb24gKyBsaW1pdEludGVydmFsICogaW50ZXJ2YWxTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlID0gbWUuYWRqdXN0RW5kRGF0ZShlbmREYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld0VuZERhdGUgPSBlbmREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKGV2ZW50RHVyYXRpb24gKyBjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3U3RhcnREYXRlID0gc3RhcnREYXRlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMDsgLy8gZHVyYXRpb24gaW4gaG91cnNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKGV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemUgKyBjdXJyZW50SW50ZXJ2YWwpICogaW50ZXJ2YWxIZWlnaHQ7IC8vIHNuYXAgdG8gdmFsaWQgaW50ZXJ2YWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIGNvbHVtbkhlaWdodCAqIDEwMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhc1swXS5zdHlsZS50b3AgPSBgY2FsYygke3Bvc2l0aW9ufSUgKyAxcHgpYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5mb3JjZVVwZGF0ZSAmJiBjdXJyZW50SW50ZXJ2YWwgPCBsaW1pdEludGVydmFsICsgbWluaW11bUV2ZW50SW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB3ZSByZXNpemUgYmFjayB0byB0aGUgb3JpZ2luYWwgZGlyZWN0aW9uLCBrZWVwIHRoZSBtaW4gaW50ZXJ2YWwgdW50aWwgd2Ugc25hcCBiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lLmZvcmNlVXBkYXRlICYmIGN1cnJlbnRJbnRlcnZhbCA+PSBsaW1pdEludGVydmFsICsgbWluaW11bUV2ZW50SW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmN1cnJlbnRJbnRlcnZhbCAhPT0gY3VycmVudEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZvcmNlVXBkYXRlICA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdTdGFydERhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUudG9wID0gYGNhbGMoJHtzdGFydEludGVydmFsICogaW50ZXJ2YWxIZWlnaHQgLyBjb2x1bW5IZWlnaHQgKiAxMDB9JSArIDFweClgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzd2l0Y2hEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWF4KGN1cnJlbnRJbnRlcnZhbCwgbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzIG11c3Qgbm90IHN0YXJ0IGJlZm9yZSB0aGUgZmlyc3QgdmlzaWJsZSBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGgubWF4KDAsIGN1cnJlbnRJbnRlcnZhbClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lLmN1cnJlbnRJbnRlcnZhbCAhPT0gY3VycmVudEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzd2l0Y2hEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcyhldmVudER1cmF0aW9uICsgY3VycmVudEludGVydmFsICogaW50ZXJ2YWxTaXplKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld0VuZERhdGUgPSBlbmREYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSAoZW5kRGF0ZSAtIHJlY29yZC5zdGFydERhdGUpIC8gNjAgLyA2MCAvIDEwMDAgLy8gZHVyYXRpb24gaW4gaG91cnNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gY3VycmVudEludGVydmFsICogaW50ZXJ2YWxIZWlnaHQ7IC8vIHNuYXAgdG8gdmFsaWQgaW50ZXJ2YWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIC8gY29sdW1uSGVpZ2h0ICogMTAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUudG9wID0gYGNhbGMoJHtwb3NpdGlvbn0lICsgMXB4KWBcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSAocmVjb3JkLmVuZERhdGUgLSBzdGFydERhdGUpIC8gNjAgLyA2MCAvIDEwMDAgLy8gZHVyYXRpb24gaW4gaG91cnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVuZERhdGUgPSBtZS5hZGp1c3RFbmREYXRlKGVuZERhdGUpO1xuXG4gICAgICAgICAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgIDogbWUuZHJhZ1Byb3h5LnZkb20uY25bMl0uaWQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBvd25lci5pbnRsRm9ybWF0X3RpbWUuZm9ybWF0KGVuZERhdGUpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2VlcEVuZERhdGUgfHwga2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGR1cmF0aW9uIC8gKGF4aXNFbmRUaW1lIC0gYXhpc1N0YXJ0VGltZSkgKiAxMDAgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhc1swXS5zdHlsZS5oZWlnaHQgPSBgY2FsYygke2hlaWdodH0lIC0gMnB4KWBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgICAgOiBtZS5kcmFnUHJveHkudmRvbS5jblswXS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnQ6IG93bmVyLmludGxGb3JtYXRfdGltZS5mb3JtYXQoc3RhcnREYXRlKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5vZGUgZ290IGFkZGVkIHlldFxuICAgICAgICAgICAgICAgIGlmIChtZS5kcmFnUHJveHkudmRvbS5jblswXS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudEludGVydmFscyA9IChkdXJhdGlvbiAmJiBkdXJhdGlvbiAqIDYwIHx8IGV2ZW50RHVyYXRpb24pIC8gdGltZUF4aXMuaW50ZXJ2YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SW50ZXJ2YWxzIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lQXhpcy5yb3dIZWlnaHQgLyBldmVudEludGVydmFscyA8IDI1ICYmICFtZS5oYXNPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgOiBtZS5kcmFnUHJveHkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczoge2FkZDogWyduZW8tb3ZlcmZsb3cnXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmhhc092ZXJmbG93ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lLmhhc092ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgOiBtZS5kcmFnUHJveHkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzOiB7cmVtb3ZlOiBbJ25lby1vdmVyZmxvdyddfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmhhc092ZXJmbG93ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS53aW5kb3dJZCwgZGVsdGFzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuY3VycmVudEludGVydmFsID0gY3VycmVudEludGVydmFsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY3RzICAgICAgICAgPSBhd2FpdCBtZS5vd25lci5nZXREb21SZWN0KFttZS5nZXREcmFnRWxlbWVudFJvb3QoKS5pZCwgZGF0YS5wYXRoWzFdLmlkXSksXG4gICAgICAgICAgICBldmVudER1cmF0aW9uID0gKG1lLmV2ZW50UmVjb3JkLmVuZERhdGUgLSBtZS5ldmVudFJlY29yZC5zdGFydERhdGUpIC8gNjAgLyAxMDAwLFxuICAgICAgICAgICAgb2Zmc2V0WCAgICAgICA9IGRhdGEuY2xpZW50WCAtIHJlY3RzWzBdLmxlZnQsXG4gICAgICAgICAgICBvZmZzZXRZICAgICAgID0gZGF0YS5jbGllbnRZIC0gcmVjdHNbMF0udG9wO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGNvbHVtbkhlaWdodCAgIDogcmVjdHNbMV0uaGVpZ2h0LFxuICAgICAgICAgICAgY29sdW1uVG9wICAgICAgOiByZWN0c1sxXS50b3AsXG4gICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3RzWzBdLFxuICAgICAgICAgICAgZXZlbnREdXJhdGlvbiAgOiBNYXRoLnJvdW5kKGV2ZW50RHVyYXRpb24gLyBtZS5pbnRlcnZhbFNpemUpICogbWUuaW50ZXJ2YWxTaXplLFxuICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUuY3JlYXRlRHJhZ1Byb3h5KHJlY3RzWzBdKTtcblxuICAgICAgICBtZS5maXJlKCdkcmFnU3RhcnQnLCB7XG4gICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3RzWzBdLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdNb3ZlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVCb2R5Q3Vyc29yQ2xzKCkge1xuICAgICAgICBOZW8uYXBwbHlEZWx0YXModGhpcy53aW5kb3dJZCwge2lkOiAnZG9jdW1lbnQuYm9keScsIGNsczoge3JlbW92ZTogWyduZW8tY3Vyc29yLW1vdmUnXX19KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRXZlbnREcmFnWm9uZSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICBmcm9tICcuLi8uLi8uLi8uLi9wbHVnaW4vQmFzZS5tanMnO1xuaW1wb3J0IERhdGVVdGlsICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgRXZlbnREcmFnWm9uZSBmcm9tICcuLi9FdmVudERyYWdab25lLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICBmcm9tICcuLi8uLi8uLi8uLi91dGlsL1ZEb20ubWpzJztcblxuY29uc3QgbmV3UmVjb3JkU3ltYm9sID0gU3ltYm9sLmZvcignbmV3UmVjb3JkU3ltYm9sJyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LndlZWsucGx1Z2luLkRyYWdEcm9wXG4gKiBAZXh0ZW5kcyBOZW8ucGx1Z2luLkJhc2VcbiAqL1xuY2xhc3MgRHJhZ0Ryb3AgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LndlZWsucGx1Z2luLkRyYWdEcm9wJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy53ZWVrLnBsdWdpbi5EcmFnRHJvcCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4tY2FsZW5kYXItd2Vlay1kcmFnZHJvcCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4tY2FsZW5kYXItd2Vlay1kcmFnZHJvcCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0RyYWdnaW5nPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZXNpemFibGVQbHVnaW5UeXBlPSdwbHVnaW4tY2FsZW5kYXItd2Vlay1kcmFnZHJvcCdcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6YWJsZVBsdWdpblR5cGU6ICdjYWxlbmRhci13ZWVrLWV2ZW50cmVzaXphYmxlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbk9wdHMgPSB7c2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tYy13LWNvbHVtbid9LFxuICAgICAgICAgICAgZXZlbnRPcHRzICA9IHtzY29wZTogbWUsIGRlbGVnYXRlOiAnLm5lby1ldmVudCd9O1xuXG4gICAgICAgIG1lLm93bmVyLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkNvbHVtbkRyYWdFbmQsICAgLi4uY29sdW1uT3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkV2ZW50RHJhZ0VuZCwgICAgLi4uZXZlbnRPcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzptb3ZlJyA6IG1lLm9uQ29sdW1uRHJhZ01vdmUsICAuLi5jb2x1bW5PcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzptb3ZlJyA6IG1lLm9uRXZlbnREcmFnTW92ZSwgICAuLi5ldmVudE9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOnN0YXJ0JzogbWUub25Db2x1bW5EcmFnU3RhcnQsIC4uLmNvbHVtbk9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOnN0YXJ0JzogbWUub25FdmVudERyYWdTdGFydCwgIC4uLmV2ZW50T3B0c31cbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBkcmFnIGV2ZW50cyB3aGljaCBzdGFydCBvbiBhbiBldmVudCByZXNpemUgaGFuZGxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFkanVzdFJlc2l6ZUV2ZW50KGRhdGEpIHtcbiAgICAgICAgZGF0YS5wYXRoLnNoaWZ0KCk7XG4gICAgICAgIGRhdGEudGFyZ2V0UGF0aC5zaGlmdCgpO1xuICAgICAgICBkYXRhLnRhcmdldCA9IGRhdGEucGF0aFswXTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRyYWdFbGVtZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRzLmVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZXZlbnRSZWNvcmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5wcm94eVBhcmVudElkXG4gICAgICogQHJldHVybnMge05lby5jYWxlbmRhci52aWV3LndlZWsuRXZlbnREcmFnWm9uZX1cbiAgICAgKi9cbiAgICBnZXRFdmVudERyYWdab25lKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lLCBvd25lciwgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICB7ZXZlbnREcmFnWm9uZSwgdGltZUF4aXN9ICA9IG93bmVyLFxuXG4gICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYXhpc0VuZFRpbWUgICAgICAgICAgICAgICAgICAgICA6IHRpbWVBeGlzLmdldFRpbWUob3duZXIuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0VGltZSAgICAgICAgICAgICAgICAgICA6IHRpbWVBeGlzLmdldFRpbWUob3duZXIuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCAgICAgICAgICAgICAgICAgICAgIDogb3B0cy5kcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgICBlbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZTogb3B0cy5lbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZSxcbiAgICAgICAgICAgICAgICBldmVudFJlY29yZCAgICAgICAgICAgICAgICAgICAgIDogb3B0cy5ldmVudFJlY29yZCxcbiAgICAgICAgICAgICAgICBwcm94eVBhcmVudElkICAgICAgICAgICAgICAgICAgIDogb3B0cy5wcm94eVBhcmVudElkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZXZlbnREcmFnWm9uZSkge1xuICAgICAgICAgICAgb3duZXIuZXZlbnREcmFnWm9uZSA9IGV2ZW50RHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgIDogRXZlbnREcmFnWm9uZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkOiBvd25lci5nZXRTY3JvbGxDb250YWluZXIoKS5pZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAuLi5jb25maWcsXG5cbiAgICAgICAgICAgICAgICBkcmFnUHJveHlDb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbGxDaGFuZ2U6ICdoZWlnaHQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5zZXQoY29uZmlnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50RHJhZ1pvbmVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgZmllbGQgdmFsdWUgb2YgdGhlIGFjdGl2ZSBvciBmaXJzdCBjYWxlbmRhciByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0FjdGl2ZUNhbGVuZGFyKCkge1xuICAgICAgICBsZXQge293bmVyfSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjYWxlbmRhclN0b3JlfSA9IG93bmVyLFxuICAgICAgICAgICAgY2FsZW5kYXJJZCAgICAgID0gb3duZXIuZGF0YS5hY3RpdmVDYWxlbmRhcklkIHx8IGNhbGVuZGFyU3RvcmUuZ2V0QXQoMClbY2FsZW5kYXJTdG9yZS5rZXlQcm9wZXJ0eV07XG5cbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3RvcmUuZ2V0KGNhbGVuZGFySWQpLmFjdGl2ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXRoXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUb3BMZXZlbENvbHVtbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLWMtdy1jb2x1bW4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RvcExldmVsRXZlbnQoZXZlbnREYXRhKSB7XG4gICAgICAgIHJldHVybiBldmVudERhdGEucGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1ldmVudCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbHVtbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICByZWNvcmQgID0gbWVbbmV3UmVjb3JkU3ltYm9sXTtcblxuICAgICAgICBpZiAocmVjb3JkICYmIG1lLmlzVG9wTGV2ZWxDb2x1bW4oZGF0YS5wYXRoKSkge1xuICAgICAgICAgICAgbWUuaXNEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBkZWxldGUgbWVbbmV3UmVjb3JkU3ltYm9sXTtcblxuICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCB7XG4gICAgICAgICAgICAgICAgaWQgICA6IG93bmVyLmdldEV2ZW50SWQocmVjb3JkLmlkKSxcbiAgICAgICAgICAgICAgICBzdHlsZToge29wYWNpdHk6IDF9XG4gICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvd25lci5ldmVudERyYWdab25lLmRyYWdFbmQoKTtcbiAgICAgICAgICAgICAgICBvd25lci5nZXRQbHVnaW4obWUucmVzaXphYmxlUGx1Z2luVHlwZSkub25EcmFnRW5kKGRhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNvbHVtbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNBY3RpdmVDYWxlbmRhcigpICYmIG1lLmlzVG9wTGV2ZWxDb2x1bW4oZGF0YS5wYXRoKSkge1xuICAgICAgICAgICAgbWUub3duZXIuZXZlbnREcmFnWm9uZT8uZHJhZ01vdmUoZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25Db2x1bW5EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0FjdGl2ZUNhbGVuZGFyKCkgJiYgbWUuaXNUb3BMZXZlbENvbHVtbihkYXRhLnRhcmdldFBhdGgpKSB7XG4gICAgICAgICAgICBsZXQge293bmVyfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0VGltZSAgID0gb3duZXIudGltZUF4aXMuZ2V0VGltZShvd25lci5zdGFydFRpbWUpLFxuICAgICAgICAgICAgICAgIHtjYWxlbmRhclN0b3JlfSA9IG93bmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtblJlY3QgICAgICA9IGRhdGEucGF0aFswXS5yZWN0LFxuICAgICAgICAgICAgICAgIGludGVydmFsU2l6ZSAgICA9IDE1LFxuICAgICAgICAgICAgICAgIGludGVydmFscyAgICAgICA9IChvd25lci50aW1lQXhpcy5nZXRUaW1lKG93bmVyLmVuZFRpbWUpIC0gYXhpc1N0YXJ0VGltZSkgKiA2MCAvIGludGVydmFsU2l6ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbEhlaWdodCAgPSBjb2x1bW5SZWN0LmhlaWdodCAvIGludGVydmFscyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiAgICAgICAgPSBNYXRoLm1pbihjb2x1bW5SZWN0LmhlaWdodCwgZGF0YS5jbGllbnRZIC0gY29sdW1uUmVjdC50b3ApLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IE1hdGguZmxvb3IocG9zaXRpb24gLyBpbnRlcnZhbEhlaWdodCksXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlICAgICAgID0gbmV3IERhdGUoVkRvbVV0aWwuZmluZChvd25lci52ZG9tLCBkYXRhLnBhdGhbMF0uaWQpLnZkb20uZmxhZyArICdUMTI6MDA6MDAuMDAwWicpLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50LCBlbmREYXRlLCBldmVudERyYWdab25lLCBldmVudElkLCByZWNvcmQ7XG5cbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhNYXRoLm1pbihjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUsIGludGVydmFscyAqIGludGVydmFsU2l6ZSAtIG93bmVyLm1pbmltdW1FdmVudER1cmF0aW9uKSk7XG5cbiAgICAgICAgICAgIGVuZERhdGUgPSBEYXRlVXRpbC5jbG9uZShzdGFydERhdGUpO1xuXG4gICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZW5kRGF0ZS5nZXRNaW51dGVzKCkgKyBvd25lci5taW5pbXVtRXZlbnREdXJhdGlvbik7XG5cbiAgICAgICAgICAgIC8vIDI0OjAwIGZpeFxuICAgICAgICAgICAgZW5kRGF0ZS5nZXRIb3VycygpID09PSAwICYmIGVuZERhdGUuZ2V0TWludXRlcygpID09PSAwICYmIGVuZERhdGUuc2V0TWludXRlcyhlbmREYXRlLmdldE1pbnV0ZXMoKSAtIDEpO1xuXG4gICAgICAgICAgICByZWNvcmQgPSBvd25lci5ldmVudFN0b3JlLmFkZCh7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJJZDogb3duZXIuZGF0YS5hY3RpdmVDYWxlbmRhcklkIHx8IGNhbGVuZGFyU3RvcmUuZ2V0QXQoMClbY2FsZW5kYXJTdG9yZS5rZXlQcm9wZXJ0eV0sXG4gICAgICAgICAgICAgICAgZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICBzdGFydERhdGUsXG4gICAgICAgICAgICAgICAgdGl0bGUgICAgIDogJ05ldyBFdmVudCdcbiAgICAgICAgICAgIH0sIHRydWUpWzBdO1xuXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNhY2hlIGEgcmVmZXJlbmNlIHRvIG1ha2UgdGhlIHJlY29yZCBhY2Nlc3NpYmxlIGZvciBvbkNvbHVtbkRyYWdFbmQoKVxuICAgICAgICAgICAgbWVbbmV3UmVjb3JkU3ltYm9sXSA9IHJlY29yZDtcblxuICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV3IGV2ZW50IGdvdCBtb3VudGVkXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUwKTtcblxuICAgICAgICAgICAgZXZlbnRJZCAgICAgPSBvd25lci5nZXRFdmVudElkKHJlY29yZC5pZCk7XG4gICAgICAgICAgICBkcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmQob3duZXIudmRvbSwgZXZlbnRJZCkudmRvbTtcblxuICAgICAgICAgICAgZXZlbnREcmFnWm9uZSA9IG1lLmdldEV2ZW50RHJhZ1pvbmUoe1xuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50LFxuICAgICAgICAgICAgICAgIGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV2ZW50UmVjb3JkICAgICAgICAgICAgICAgICAgICAgOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgcHJveHlQYXJlbnRJZCAgICAgICAgICAgICAgICAgICA6IGRhdGEucGF0aFswXS5pZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG93bmVyLmdldFBsdWdpbihtZS5yZXNpemFibGVQbHVnaW5UeXBlKS5vbkRyYWdTdGFydChkYXRhKTtcbiAgICAgICAgICAgIGF3YWl0IGV2ZW50RHJhZ1pvbmUuZHJhZ1N0YXJ0KGRhdGEpO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUwKTtcblxuICAgICAgICAgICAgbWUuaXNEcmFnZ2luZyAmJiBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIHtcbiAgICAgICAgICAgICAgICBpZCAgIDogZXZlbnRJZCxcbiAgICAgICAgICAgICAgICBzdHlsZToge29wYWNpdHk6IDB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50RHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICB7ZXZlbnREcmFnWm9uZX0gPSBvd25lcjtcblxuICAgICAgICBpZiAob3duZXIuZW5hYmxlRHJhZykge1xuICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5kcmFnRW5kKCk7XG5cbiAgICAgICAgICAgIGlmICghbWUuaXNUb3BMZXZlbEV2ZW50KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG1lLmFkanVzdFJlc2l6ZUV2ZW50KGRhdGEpO1xuICAgICAgICAgICAgICAgIG93bmVyLmdldFBsdWdpbihtZS5yZXNpemFibGVQbHVnaW5UeXBlKS5vbkRyYWdFbmQoZGF0YSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5yZW1vdmVCb2R5Q3Vyc29yQ2xzKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnREcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZTtcblxuICAgICAgICBpZiAob3duZXIuZW5hYmxlRHJhZykge1xuICAgICAgICAgICAgaWYgKCFtZS5pc1RvcExldmVsRXZlbnQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbWUuYWRqdXN0UmVzaXplRXZlbnQoZGF0YSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duZXIuZXZlbnREcmFnWm9uZS5kcmFnTW92ZShkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50RHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ICAgPSBtZSxcbiAgICAgICAgICAgIG1vZGVsRGF0YSA9IG93bmVyLmRhdGE7XG5cbiAgICAgICAgaWYgKG93bmVyLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIGxldCBpc1RvcExldmVsRXZlbnQgPSBtZS5pc1RvcExldmVsRXZlbnQoZGF0YSksXG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQsIGV2ZW50RHJhZ1pvbmU7XG5cbiAgICAgICAgICAgIGlmICghaXNUb3BMZXZlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG1lLmFkanVzdFJlc2l6ZUV2ZW50KGRhdGEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBkcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmQob3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tO1xuXG4gICAgICAgICAgICBldmVudERyYWdab25lID0gbWUuZ2V0RXZlbnREcmFnWm9uZSh7XG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2U6IG1vZGVsRGF0YS5ldmVudHMuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2UsXG4gICAgICAgICAgICAgICAgZXZlbnRSZWNvcmQgICAgICAgICAgICAgICAgICAgICA6IG93bmVyLmV2ZW50U3RvcmUuZ2V0KGRyYWdFbGVtZW50LmZsYWcpLFxuICAgICAgICAgICAgICAgIHByb3h5UGFyZW50SWQgICAgICAgICAgICAgICAgICAgOiBkYXRhLnBhdGhbMV0uaWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNUb3BMZXZlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5hZGRCb2R5Q3Vyc29yQ2xzKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3duZXIuZ2V0UGx1Z2luKG1lLnJlc2l6YWJsZVBsdWdpblR5cGUpLm9uRHJhZ1N0YXJ0KGRhdGEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUuZHJhZ1N0YXJ0KGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERyYWdEcm9wKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1Byb3h5Q29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZHJhZ3Byb3h5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RyYWdwcm94eScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvSW5pdFZub2RlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0Vm5vZGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZHJhZ3Byb3h5J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRyYWdwcm94eSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMubW92ZUluTWFpblRocmVhZCkge1xuICAgICAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0RHJhZ1Byb3h5RWxlbWVudCh7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1Byb3h5Q29tcG9uZW50KTtcbiIsImltcG9ydCBCYXNlQ29udGFpbmVyICAgICAgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb21wb25lbnQgZnJvbSAnLi9EcmFnUHJveHlDb21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBEcmFnUHJveHlDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFncHJveHljb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZHJhZ3Byb3h5Y29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Jbml0Vm5vZGU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0luaXRWbm9kZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1kcmFncHJveHknXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZHJhZ3Byb3h5J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD0nZml0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogJ2ZpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5tb3ZlSW5NYWluVGhyZWFkKSB7XG4gICAgICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5zZXREcmFnUHJveHlFbGVtZW50KHthcHBOYW1lLCBpZCwgd2luZG93SWR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICAvLyBXZSB3YW50IHRvIHJldXNlIHRoZSBzdHlsaW5nIG9mIHRoZSBEcmFnUHJveHlDb21wb25lbnQsIHNpbmNlIGJvdGggdXNlIHRoZSBzYW1lIGJhc2VDbHMuXG4gICAgICAgIC8vIEluc3RlYWQgb2YgZHVwbGljYXRpbmcgdGhlIHNjc3MgZmlsZSwgd2UgYXJlIGZvcmNpbmcgdGhlIFRoZW1lRW5naW5lIHRvIGxvYWQgdGhlIGNvbXBvbmVudCBmaWxlLlxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIERyYWdQcm94eUNvbXBvbmVudC5wcm90b3R5cGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBkbyBOT1Qgd2FudCB0byBkZXN0cm95IGNoaWxkIGl0ZW1zLCBzaW5jZSB0aGV5IGdldCByZS11c2VkLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERyYWdQcm94eUNvbnRhaW5lcik7XG4iLCJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwbHVnaW4gaW1wbGVtZW50YXRpb25zLlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFBsdWdpbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHBsdWdpbiBudHlwZXMgbmVlZCB0byBzdGFydCB3aXRoICdwbHVnaW4tJyB0byBlbnN1cmUgdGhhdCBjb21wb25lbnQuQmFzZTogZ2V0UGx1Z2luKCkgY2FuIGZpbmQgdGhlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZTtcblxuICAgICAgICBpZiAob3duZXIuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUub25Pd25lckNvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyLm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5vbk93bmVyQ29uc3RydWN0ZWQoKVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvd25lci5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyTW91bnRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIub24oJ21vdW50ZWQnLCBtZS5vbk93bmVyTW91bnRlZCwgbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMuX19wcm90b19fKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG93bmVyIENvbXBvbmVudCB3aGVuIGl0IGlzIGNvbnN0cnVjdGVkXG4gICAgICovXG4gICAgb25Pd25lckNvbnN0cnVjdGVkKCkge1xuICAgICAgICBsZXQge293bmVyfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG93bmVyLndpbmRvd0lkKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd0lkID0gb3duZXIud2luZG93SWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG93bmVyIENvbXBvbmVudCB3aGVuIGl0IGRvZXMgZ2V0IG1vdW50ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyTW91bnRlZCgpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUGx1Z2luKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==