"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_week_Component_mjs"],{

/***/ "./src/calendar/view/week/Component.mjs":
/*!**********************************************!*\
  !*** ./src/calendar/view/week/Component.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TimeAxisComponent.mjs */ "./src/calendar/view/week/TimeAxisComponent.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.week.Component
 * @extends Neo.component.Base
 */
class Component extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for timeAxisPosition
     * @member {String[]} timeAxisPositions=['end','start']
     * @protected
     * @static
     */
    static timeAxisPositions = ['end', 'start']

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.Component'
         * @protected
         */
        className: 'Neo.calendar.view.week.Component',
        /**
         * @member {String[]} baseCls=['neo-calendar-weekcomponent']
         */
        baseCls: ['neo-calendar-weekcomponent'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            enableDrag          : data => data.events.enableDrag,
            endTime             : data => data.endTime,
            eventBorder         : data => data.events.border,
            eventStore          : 'stores.events',
            intlFormat_time     : data => data.intlFormat_time,
            locale              : data => data.locale,
            minimumEventDuration: data => data.minimumEventDuration,
            showWeekends        : data => data.showWeekends,
            startTime           : data => data.startTime,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Bound to the view model
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         */
        calendarStore_: null,
        /**
         * Amount of hidden columns on both sides each inside this view.
         * @member {Number} columnsBuffer_=7
         */
        columnsBuffer_: 7,
        /**
         * Amount of visible columns inside this view.
         * @member {Number} columnsVisible_=7
         */
        columnsVisible_: 7,
        /**
         * Bound to the view model.
         * @member {Date|null} currentDate_=null
         * @protected
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='short'
         */
        dayNameFormat_: 'short',
        /**
         * Bound to the view model.
         * @member {Boolean} enableDrag_=true
         * @protected
         */
        enableDrag_: true,
        /**
         * Bound to the view model
         * @member {String|null} eventBorder_=null
         */
        eventBorder_: null,
        /**
         * @member {Neo.calendar.view.week.EventDragZone|null} eventDragZone=null
         */
        eventDragZone: null,
        /**
         * Bound to the view model
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         */
        eventStore_: null,
        /**
         * Will get passed from updateHeader()
         * @member {Date|null} firstColumnDate=null
         * @protected
         */
        firstColumnDate: null,
        /**
         * Internal flag to check if updateHeader(true) has already run
         * @member {Boolean} headerCreated=false
         * @protected
         */
        headerCreated: false,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * Bound to the view model.
         * @member {Intl.DateTimeFormat|null} intlFormat_time_=null
         * @protected
         */
        intlFormat_time_: null,
        /**
         * @member {Boolean} isUpdating=false
         * @protected
         */
        isUpdating: false,
        /**
         * Bound to the view model.
         * @member {String} locale_=Neo.config.locale
         */
        locale_: Neo.config.locale,
        /**
         * Time in minutes. Bound to the view model.
         * @member {Number} minimumEventDuration=30
         * @protected
         */
        minimumEventDuration: 30,
        /**
         * Internal flag to store if updateEvents() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * config values for Neo.calendar.view.week.plugin.DragDrop
         * @member {Object} pluginDragDropConfig=null
         */
        pluginDragDropConfig: null,
        /**
         * config values for Neo.calendar.view.week.plugin.EventResizable
         * @member {Object} pluginResizableConfig=null
         */
        pluginEventResizableConfig: null,
        /**
         * @member {Boolean} showEventEndTime_=false
         */
        showEventEndTime_: false,
        /**
         * Bound to the view model.
         * @member {Boolean} showWeekends_=true
         */
        showWeekends_: true,
        /**
         * @member {Object} timeAxis=null
         */
        timeAxis: null,
        /**
         * @member {Object} timeAxisConfig=null
         */
        timeAxisConfig: null,
        /**
         * Position the timeAxis at the left or right side.
         * Valid values are start & end.
         * start => left, end => right in LTR mode.
         * @member {String} timeAxisPosition_='start'
         */
        timeAxisPosition_: 'start',
        /**
         * Internal flag to store the total amount of rendered columns.
         * Changing columnsBuffer or columnsVisible will update this value.
         * @member {Number|null} totalColumns=null
         * @protected
         */
        totalColumns: null,
        updateDepth: -1,
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-scroll-overlay']},
            {cls: ['neo-c-w-scrollcontainer'], flag: 'neo-c-w-scrollcontainer', cn: [
                {cls: ['neo-header-row'], flag: 'neo-header-row', cn: []},
                {cls: ['neo-c-w-column-timeaxis-container'], flag: 'neo-c-w-column-timeaxis-container', cn: [
                    {cls: ['neo-c-w-column-container'], flag: 'neo-c-w-column-container', style: {}, cn: []}
                ]}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the view model.
         * @member {Number} weekStartDay_=0
         */
        weekStartDay_: 0
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {dblclick: me.onEventDoubleClick, scope: me, delegate: '.neo-event'},
            {wheel   : me.onWheel,            scope: me}
        ]);

        me.timeAxis = Neo.create({
            module   : _TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            appName  : me.appName,
            parentId : me.id,
            listeners: {change: me.onTimeAxisChange, scope : me},
            windowId : me.windowId,
            ...me.timeAxisConfig
        });

        me.getColumnTimeAxisContainer().cn[me.timeAxisPosition === 'start' ? 'unshift' : 'push'](me.timeAxis.createVdomReference());

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {
            me.needsEventUpdate = true
        }

        me.updateHeader(true, me.needsEventUpdate);

        me.needsEventUpdate && me.updateEvents(false);

        me.headerCreated = true
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     * @param {Boolean} [silent=false]
     */
    adjustTotalHeight(data, silent=false) {
        let me                       = this,
            {rowHeight, rowsPerItem} = data,
            height                   = data.totalHeight - rowHeight,
            i                        = 0,
            gradient                 = [];

        for (; i < rowsPerItem; i++) {
            gradient.push(
                `var(--c-w-background-color) ${i * rowHeight + i}px`,
                `var(--c-w-background-color) ${(i + 1) * rowHeight + i}px`,
                'var(--c-w-border-color) 0'
            )
        }

        Object.assign(me.getColumnContainer().style, {
            backgroundImage: `linear-gradient(${gradient.join(',')})`,
            backgroundSize : `1px ${rowsPerItem * rowHeight + rowsPerItem}px`,
            height         : `${height}px`,
            maxHeight      : `${height}px`
        });

        !silent && me.update()
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the columnsBuffer config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetColumnsBuffer(value, oldValue) {
        this.totalColumns = this.visibleColumns + 2 * value
    }

    /**
     * Triggered after the columnsVisible config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetColumnsVisible(value, oldValue) {
        this.totalColumns = 2 * this.columnsBuffer + value
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        let me = this;

        if (me.isConstructed) {
            me.updateHeader(false, true);
            me.updateEvents()
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});
        oldValue && me.updateHeader()
    }

    /**
     * Triggered after the enableDrag config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetEnableDrag(value, oldValue) {
        if (value && !this.getPlugin('calendar-week-dragdrop')) {
            Promise.all([
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_calendar_view_week_plugin_DragDrop_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/DragDrop.mjs */ "./src/calendar/view/week/plugin/DragDrop.mjs")),
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_plugin_Resizable_mjs"), __webpack_require__.e("src_calendar_view_week_plugin_EventResizable_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/EventResizable.mjs */ "./src/calendar/view/week/plugin/EventResizable.mjs"))
            ]).then(modules => {
                let me                  = this,
                    {appName, windowId} = me,
                    plugins             = me.plugins || [];

                plugins.push({
                    module : modules[0].default,
                    appName,
                    windowId,
                    ...me.pluginDragDropConfig
                }, {
                    module       : modules[1].default,
                    appName,
                    delegationCls: 'neo-event',
                    directions   : ['b', 't'],
                    windowId,
                    ...me.pluginEventResizableConfig
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the eventBorder config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetEventBorder(value, oldValue) {
        let me    = this,
            {cls} = me;

        oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, `neo-event-border-${oldValue}`);
        value    && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(   cls, `neo-event-border-${value}`);

        me.cls = cls
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onEventStoreLoad,
            recordChange: me.onEventStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue) {
            let me = this;

            me.intlFormat_day  = new Intl.DateTimeFormat(value, {weekday: me.dayNameFormat});
            me.updateHeader()
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this,
            scrollContainerId, rect;

        if (value) {
            if (me.needsEventUpdate) {
                me.updateEvents();
                me.needsEventUpdate = false
            }

            await me.timeout(100);

            rect              = await me.getDomRect(me.getColumnContainer().id);
            scrollContainerId = me.getScrollContainer().id;

            scrollContainerId && Neo.main.DomAccess.scrollBy({
                appName  : me.appName,
                direction: 'left',
                id       : scrollContainerId,
                value    : rect.width * me.columnsBuffer / me.columnsVisible / 3
            })
        }
    }

    /**
     * Triggered after the showEventEndTime config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowEventEndTime(value, oldValue) {
        oldValue !== undefined && this.updateEvents()
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-show-weekends');

        me._cls = cls; // silent update

        if (oldValue !== undefined) {
            me.updateHeader(false, true);
            me.updateEvents()
        }
    }

    /**
     * Triggered after the timeAxisPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTimeAxisPosition(value, oldValue) {
        let me                = this,
            {cls}             = me,
            timeAxisContainer = me.getColumnTimeAxisContainer();

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value === 'end' ? 'add' : 'remove'](cls, 'neo-timeaxis-end');

        if (oldValue !== undefined) {
            timeAxisContainer.cn.unshift(timeAxisContainer.cn.pop()) // switch the order of the 2 items
        }

        me.cls = cls; // silent update
        me.update()
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        if (oldValue !== undefined) {
            this.updateHeader(false, true);
            this.updateEvents()
        }
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.dayNameFormats)
    }

    /**
     * Triggered before the timeAxisPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTimeAxisPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'timeAxisPosition')
    }

    /**
     * Triggered before the weekStartDay config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetWeekStartDay(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'weekStartDay', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.weekStartDays)
    }

    /**
     * @param {Date} date
     * @returns {Object}
     */
    createColumnAndHeader(date) {
        let me          = this,
            columnCls   = ['neo-c-w-column', 'neo-draggable'],
            currentDate = date.getDate(),
            currentDay  = date.getDay(),
            dateCls     = ['neo-date'],
            removeDom   = false,
            column, header;

        if (currentDay === 0 || currentDay === 6) {
            columnCls.push('neo-weekend');
            !me.showWeekends && (removeDom = true)
        }

        if (currentDate === today.day && date.getMonth() === today.month && date.getFullYear() === today.year) {
            dateCls.push('neo-today')
        }

        column = {cls: columnCls, flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date), removeDom};

        header =
        {cls: ['neo-header-row-item'], removeDom: removeDom, cn: [
            {cls: ['neo-day'], html: me.intlFormat_day.format(date)},
            {cls: dateCls,     html: currentDate}
        ]};

        return {column, header}
    }

    /**
     *
     */
    destroy(...args) {
        this.timeAxis = null;

        super.destroy(...args)
    }

    /**
     *
     */
    getColumnContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-column-container')
    }

    /**
     * @param {Date} date
     * @returns {String}
     */
    getColumnId(date) {
        return `${this.id}_col_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date)}`
    }

    /**
     * @param {Date} date
     * @returns {String}
     */
    getColumnHeaderId(date) {
        return `${this.id}_ch_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date)}`
    }

    /**
     *
     */
    getColumnTimeAxisContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-column-timeaxis-container')
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getEventId(recordId) {
        return `${this.id}__${recordId}`
    }

    /**
     *
     */
    getHeaderContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-header-row')
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * @returns {String}
     */
    getIdKey() {
        return 'c-w'
    }

    /**
     *
     */
    getScrollContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-scrollcontainer')
    }

    /**
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.updateEvents()
    }

    /**
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.updateEvents()
    }

    /**
     * @param {Object} data
     */
    onEventDoubleClick(data) {
        if (this.data.events.enableEdit) {
            let {path} = data;

            !path[0].cls.includes('neo-event') && path.shift();

            let me                 = this,
                {editEventContainer} = me.owner,
                eventNode          = path[0],
                eventVdom          = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].find(me.vdom, eventNode.id).vdom,
                record             = me.eventStore.get(eventVdom.flag),
                {style}            = editEventContainer;

            Object.assign(style, {left: `${eventNode.rect.width + 15}px`, top: eventVdom.style.top});
            editEventContainer.setSilent({parentId: path[1].id, record, style});
            editEventContainer.render(true)
        }
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.updateEvents()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreRecordChange(data) {
        this.updateEvents()
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @param {Object[]} data.path
     */
    onFocusChange(data) {
        let {oldPath, path} = data;

        oldPath?.[0]?.cls.includes('neo-event') && Neo.applyDeltas(this.appName, {id: oldPath[0].id, cls: {remove: ['neo-focus']}});
        path   ?.[0]?.cls.includes('neo-event') && Neo.applyDeltas(this.appName, {id: path[0]   .id, cls: {add:    ['neo-focus']}})
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     */
    onTimeAxisChange(data) {
        let me = this;

        me.adjustTotalHeight(data, me.headerCreated);
        me.headerCreated && me.updateEvents()
    }

    /**
     * @param {Object} data
     */
    onWheel(data) {
        if (!this.isUpdating && Math.abs(data.deltaX) > Math.abs(data.deltaY)) {
            let me                                               = this,
                columns                                          = me.getColumnContainer(),
                {columnsBuffer, columnsVisible, firstColumnDate} = me,
                header                                           = me.getHeaderContainer(),
                i                                                = 0,
                timeAxisWidth                                    = 50,
                width                                            = data.clientWidth - timeAxisWidth,
                config, date, scrollValue;

            // console.log(data.scrollLeft, Math.round(data.scrollLeft / (data.clientWidth - timeAxisWidth) * 7));

            if (data.deltaX > 0 && Math.round(data.scrollLeft / width * columnsBuffer) > columnsBuffer + columnsVisible - 1) {
                date = new Date(columns.cn[columns.cn.length - 1].flag);

                columns.cn.splice(0, columnsBuffer);
                header .cn.splice(0, columnsBuffer);

                for (; i < columnsBuffer; i++) {
                    date.setDate(date.getDate() + 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.push(config.column);
                    header .cn.push(config.header)
                }

                firstColumnDate.setDate(firstColumnDate.getDate() + columnsBuffer);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                me.timeout(50).then(() => {me.updateEvents(false, columnsBuffer + columnsVisible, me.totalColumns)});

                scrollValue = -width
            }

            else if (data.deltaX < 0 && Math.round(data.scrollLeft / width * columnsBuffer) < 1) {
                date = new Date(columns.cn[0].flag);

                columns.cn.length = columnsBuffer + columnsVisible;
                header .cn.length = columnsBuffer + columnsVisible;

                for (; i < columnsBuffer; i++) {
                    date.setDate(date.getDate() - 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.unshift(config.column);
                    header .cn.unshift(config.header)
                }

                firstColumnDate.setDate(firstColumnDate.getDate() - columnsBuffer);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                me.timeout(50).then(() => {me.updateEvents(false, 0, columnsBuffer)});

                scrollValue = width
            }

            if (scrollValue) {
                me.isUpdating = true;

                me.promiseUpdate().then(() => {
                    Neo.main.DomAccess.scrollBy({
                        direction: 'left',
                        id       : me.getScrollContainer().id,
                        value    : scrollValue
                    }).then(() => {
                        me.isUpdating = false
                    })
                })
            }
        }
    }

    /**
     * @param {Date} date
     */
    setFirstColumnDate(date) {
        date.setDate(date.getDate() - date.getDay() + this.weekStartDay - this.columnsBuffer)
    }

    /**
     * The algorithm relies on the eventStore being sorted by startDate ASC
     * @param {Boolean} [silent=false]
     * @param {Number} [startIndex=0]
     * @param {Number} [endIndex=this.totalColumns]
     */
    updateEvents(silent=false, startIndex=0, endIndex=this.totalColumns) {
        let me = this;

        if (!me.mounted) {
            me.needsEventUpdate = true
        } else {
            let {calendarStore, eventStore, showEventEndTime, timeAxis, vdom} = me,
                endTime   = timeAxis.getTime(me.endTime),
                startTime = timeAxis.getTime(me.startTime),
                totalTime = endTime - startTime,
                date      = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(me.firstColumnDate),
                content   = me.getColumnContainer(),
                j         = startIndex,
                calendarRecord, column, dayRecords, duration, endDate, eventCls, eventIntervals, hasOverflow, height, i,
                len, record, recordKey, startDate, startHours, top;

            date.setDate(date.getDate() + startIndex);

            for (; j < endIndex; j++) {
                column = content.cn[j];

                column.cn = []; // remove previous events from the vdom

                dayRecords = eventStore.getDayRecords(date);
                len        = dayRecords.length;

                for (i = 0; i < len; i++) {
                    record         = dayRecords[i];
                    calendarRecord = calendarStore.get(record.calendarId);

                    if (calendarRecord?.active) {
                        endDate   = record.endDate;
                        startDate = record.startDate;

                        if (endTime <= startDate.getHours() || startTime >= endDate.getHours()) {
                            continue
                        }

                        if (endTime < endDate.getHours()) {
                            endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(endDate);
                            endDate.setHours(endTime);
                            endDate.setMinutes(0)
                        }

                        if (startTime > startDate.getHours()) {
                            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(startDate);
                            startDate.setHours(startTime);
                            startDate.setMinutes(0)
                        }

                        duration       = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                        eventCls       = ['neo-event', 'neo-draggable', `neo-${calendarRecord.color}`];
                        eventIntervals = duration * 60 / timeAxis.interval;
                        hasOverflow    = false;
                        height         = Math.round(duration / totalTime * 100 * 1000) / 1000;
                        recordKey      = record[eventStore.keyProperty];
                        startHours     = (startDate.getHours() * 60 + startDate.getMinutes()) / 60;
                        top            = Math.round((startHours - startTime) / totalTime * 100 * 1000) / 1000;

                        if (eventIntervals <= 2) {
                            hasOverflow = timeAxis.rowHeight * eventIntervals < (showEventEndTime ? 50 : 34);

                            if (hasOverflow && !(showEventEndTime && (timeAxis.rowHeight / eventIntervals >= 34))) {
                                eventCls.push('neo-overflow')
                            }
                        }

                        showEventEndTime = !(hasOverflow && eventIntervals === 1 || !showEventEndTime);

                        showEventEndTime && eventCls.push('neo-show-end-time');

                        column.cn.push({
                            cls     : eventCls,
                            flag    : recordKey,
                            id      : me.getEventId(recordKey),
                            tabIndex: -1,

                            cn: [{
                                cls : ['neo-event-time'],
                                html: me.intlFormat_time.format(record.startDate),
                                id  : `${me.id}__time__${recordKey}`
                            }, {
                                cls : ['neo-event-title'],
                                html: record.title,
                                id  : `${me.id}__title__${recordKey}`
                            }, {
                                cls      : ['neo-event-time', 'neo-event-end-time'],
                                html     : me.intlFormat_time.format(record.endDate),
                                id       : `${me.id}__enddate__${recordKey}`,
                                removeDom: !showEventEndTime
                            }],

                            style: {
                                height: `calc(${height}% - 2px)`,
                                top   : `calc(${top}% + 1px)`,
                                width : 'calc(100% - 1px)'
                            }
                        })
                    }
                }

                date.setDate(date.getDate() + 1)
            }

            !silent && me.update()
        }
    }

    /**
     * @param {Boolean} [create=false]
     * @param {Boolean} [silent=false]
     */
    updateHeader(create=false, silent=false) {
        let me             = this,
            {showWeekends} = me,
            date           = me.currentDate, // cloned
            content        = me.getColumnContainer(),
            header         = me.getHeaderContainer(),
            i              = 0,
            columnCls, currentDate, currentDay, dateCls, headerId, removeDom;

        me.setFirstColumnDate(date);

        me.firstColumnDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(date);

        for (; i < me.totalColumns; i++) {
            columnCls   = ['neo-c-w-column', 'neo-draggable'];
            currentDate = date.getDate();
            currentDay  = date.getDay();
            dateCls     = ['neo-date'];
            removeDom   = false;

            if (currentDay === 0 || currentDay === 6) {
                columnCls.push('neo-weekend');
                !showWeekends && (removeDom = true)
            }

            if (currentDate === today.day && date.getMonth() === today.month && date.getFullYear() === today.year) {
                dateCls.push('neo-today')
            }

            headerId = me.getColumnHeaderId(date);

            if (create) {
                content.cn.push({cls: columnCls, flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date), id: me.getColumnId(date), removeDom});

                header.cn.push(
                {cls: ['neo-header-row-item'], id: headerId, removeDom, cn: [
                    {cls: ['neo-day'], html: me.intlFormat_day.format(date), id: `${headerId}_day`},
                    {cls : dateCls,    html: currentDate,                    id: `${headerId}_date`}
                ]})
            } else {
                Object.assign(content.cn[i], {
                    cls : columnCls,
                    flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date),
                    id  : me.getColumnId(date),
                    removeDom
                });

                Object.assign(header.cn[i],       {id: headerId, removeDom});
                Object.assign(header.cn[i].cn[0], {html: me.intlFormat_day.format(date), id: `${headerId}_day`});
                Object.assign(header.cn[i].cn[1], {cls: dateCls, html: currentDate, id: `${headerId}_date`})
            }

            date.setDate(date.getDate() + 1)
        }

        !silent && me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/calendar/view/week/TimeAxisComponent.mjs":
/*!******************************************************!*\
  !*** ./src/calendar/view/week/TimeAxisComponent.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.calendar.view.week.TimeAxisComponent
 * @extends Neo.container.Base
 */
class TimeAxisComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for interval
     * @member {Number[]} intervals=[15,30,60]
     * @protected
     * @static
     */
    static intervals = [15, 30, 60]

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.TimeAxisComponent'
         * @protected
         */
        className: 'Neo.calendar.view.week.TimeAxisComponent',
        /**
         * @member {String[]} baseCls=['neo-calendar-timeaxis']
         */
        baseCls: ['neo-calendar-timeaxis'],
        /**
         * @member {Object} bind
         */
        bind: {
            endTime  : data => data.endTime,
            startTime: data => data.startTime
        },
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         */
        endTime_: '24:00',
        /**
         * The time interval in minutes to display as rows.
         * Valid values: 15, 30, 60
         * @member {Number} interval_=30
         */
        interval_: 30,
        /**
         * @member {Number} rowHeight_=20
         */
        rowHeight_: 20,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         */
        startTime_: '00:00',
        /**
         * @member {Object} vdom
         */
        vdom:
        {style: {}}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.createItems();
        me.afterSetRowHeight(me.rowHeight, 0)
    }

    /**
     * Triggered after the endTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetEndTime(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            // todo: handle 24:00 as 23:59
            if (!value) {
                me._endTime = '24:00'
            }

            me.afterSetRowHeight(me.rowHeight, 0)
        }
    }

    /**
     * Triggered after the interval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInterval(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0)
        }
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        if (oldValue !== undefined && this.vdom.cn) {
            let me                = this,
                endTime           = me.getTime(me.endTime),
                startTime         = me.getTime(me.startTime),
                {rowHeight, vdom} = me,
                rowsPerItem       = me.getRowsPerItem(),
                itemHeight        = rowsPerItem * rowHeight + rowsPerItem, // rowsPerItem * 1px borders
                totalHeight       = rowHeight + ((endTime - startTime) * itemHeight),
                i, itemStyle;

            Object.assign(vdom.style, {
                backgroundImage    : `linear-gradient(var(--c-w-background-color) ${itemHeight - 1}px, var(--c-w-border-color) 1px)`,
                backgroundPositionY: `${-itemHeight + 1}px`,
                backgroundSize     : `0.4em ${itemHeight}px`,
                height             : `${totalHeight - rowHeight + 1}px`,
                maxHeight          : `${totalHeight - rowHeight + 1}px`
            });

            for (i=0; i < 25; i++) {
                itemStyle = {
                    height: `${itemHeight}px`
                };

                if (i === startTime) {
                    itemStyle.marginTop = `${-2 - rowHeight * (rowsPerItem === 1 ? 0.5 : rowsPerItem === 2 ? 1 : 2)}px`
                } else {
                    delete itemStyle.marginTop
                }

                vdom.cn[i].style = itemStyle;

                vdom.cn[i].removeDom = (i < startTime || i - 1 >= endTime);
            }

            me.fire('change', {
                component: me,
                rowHeight,
                rowsPerItem,
                totalHeight
            })
        }
    }

    /**
     * Triggered after the startTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetStartTime(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0)
        }
    }

    /**
     * Triggered before the interval config gets changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    beforeSetInterval(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'interval')
    }

    /**
     *
     */
    createItems() {
        let {vdom} = this,
            html, i;

        vdom.cn = [];

        for (i=0; i < 25; i++) {
            html = i === 24 ? '00:00' : (i < 10 ? '0' : '') + i + ':00';

            vdom.cn.push({
                cls: ['neo-c-w-timeaxis-item'],
                cn : [{html}]
            })
        }
    }

    /**
     * Calculates the amount of rows related to the interval config
     * @returns {Number}
     */
    getRowsPerItem() {
        let {interval} = this;
        return interval === 60 ? 1 : interval === 30 ? 2 : 4
    }

    /**
     * Calculates the time for the end- or startTime
     * @param {String} value
     * @returns {Number}
     */
    getTime(value) {
        return value.split(':').map(Number)[0]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TimeAxisComponent));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X3dlZWtfQ29tcG9uZW50X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDTDtBQUNDO0FBQ0E7QUFDRDs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBYTtBQUNyQztBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiww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Qyw0QkFBNEI7QUFDcEUsYUFBYTs7QUFFYixzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLCtCQUErQixXQUFXO0FBQzFDOztBQUVBO0FBQ0EsNkNBQTZDLHVFQUF1RTtBQUNwSCxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGlDQUFpQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L3dlZWsvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9UaW1lQXhpc0NvbXBvbmVudC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VDb21wb25lbnQgICAgIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgRGF0ZVV0aWwgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFRpbWVBeGlzQ29tcG9uZW50IGZyb20gJy4vVGltZUF4aXNDb21wb25lbnQubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL1ZEb20ubWpzJztcblxuY29uc3QgdG9kYXlEYXRlID0gbmV3IERhdGUoKTtcblxuY29uc3QgdG9kYXkgPSB7XG4gICAgZGF5ICA6IHRvZGF5RGF0ZS5nZXREYXRlKCksXG4gICAgbW9udGg6IHRvZGF5RGF0ZS5nZXRNb250aCgpLFxuICAgIHllYXIgOiB0b2RheURhdGUuZ2V0RnVsbFllYXIoKVxufTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRpbWVBeGlzUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdGltZUF4aXNQb3NpdGlvbnM9WydlbmQnLCdzdGFydCddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdGltZUF4aXNQb3NpdGlvbnMgPSBbJ2VuZCcsICdzdGFydCddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LndlZWsuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy53ZWVrLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhci13ZWVrY29tcG9uZW50J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFyLXdlZWtjb21wb25lbnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZSAgICAgICA6ICdzdG9yZXMuY2FsZW5kYXJzJyxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlICAgICAgICAgOiBkYXRhID0+IGRhdGEuY3VycmVudERhdGUsXG4gICAgICAgICAgICBlbmFibGVEcmFnICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmV2ZW50cy5lbmFibGVEcmFnLFxuICAgICAgICAgICAgZW5kVGltZSAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5lbmRUaW1lLFxuICAgICAgICAgICAgZXZlbnRCb3JkZXIgICAgICAgICA6IGRhdGEgPT4gZGF0YS5ldmVudHMuYm9yZGVyLFxuICAgICAgICAgICAgZXZlbnRTdG9yZSAgICAgICAgICA6ICdzdG9yZXMuZXZlbnRzJyxcbiAgICAgICAgICAgIGludGxGb3JtYXRfdGltZSAgICAgOiBkYXRhID0+IGRhdGEuaW50bEZvcm1hdF90aW1lLFxuICAgICAgICAgICAgbG9jYWxlICAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5sb2NhbGUsXG4gICAgICAgICAgICBtaW5pbXVtRXZlbnREdXJhdGlvbjogZGF0YSA9PiBkYXRhLm1pbmltdW1FdmVudER1cmF0aW9uLFxuICAgICAgICAgICAgc2hvd1dlZWtlbmRzICAgICAgICA6IGRhdGEgPT4gZGF0YS5zaG93V2Vla2VuZHMsXG4gICAgICAgICAgICBzdGFydFRpbWUgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLnN0YXJ0VGltZSxcbiAgICAgICAgICAgIHdlZWtTdGFydERheSAgICAgICAgOiBkYXRhID0+IGRhdGEud2Vla1N0YXJ0RGF5XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IGNhbGVuZGFyU3RvcmVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyU3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IG9mIGhpZGRlbiBjb2x1bW5zIG9uIGJvdGggc2lkZXMgZWFjaCBpbnNpZGUgdGhpcyB2aWV3LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtbnNCdWZmZXJfPTdcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbnNCdWZmZXJfOiA3LFxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IG9mIHZpc2libGUgY29sdW1ucyBpbnNpZGUgdGhpcyB2aWV3LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtbnNWaXNpYmxlXz03XG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5zVmlzaWJsZV86IDcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBjdXJyZW50RGF0ZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50RGF0ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBjb2x1bW4gaGVhZGVycy5cbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZTogbmFycm93LCBzaG9ydCAmIGxvbmdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkYXlOYW1lRm9ybWF0Xz0nc2hvcnQnXG4gICAgICAgICAqL1xuICAgICAgICBkYXlOYW1lRm9ybWF0XzogJ3Nob3J0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSB2aWV3IG1vZGVsLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVEcmFnXz10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZURyYWdfOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGV2ZW50Qm9yZGVyXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudEJvcmRlcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy53ZWVrLkV2ZW50RHJhZ1pvbmV8bnVsbH0gZXZlbnREcmFnWm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudERyYWdab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWxcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnN0b3JlLkV2ZW50c3xudWxsfSBldmVudFN0b3JlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudFN0b3JlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgZ2V0IHBhc3NlZCBmcm9tIHVwZGF0ZUhlYWRlcigpXG4gICAgICAgICAqIEBtZW1iZXIge0RhdGV8bnVsbH0gZmlyc3RDb2x1bW5EYXRlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZmlyc3RDb2x1bW5EYXRlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBjaGVjayBpZiB1cGRhdGVIZWFkZXIodHJ1ZSkgaGFzIGFscmVhZHkgcnVuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhlYWRlckNyZWF0ZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyQ3JlYXRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtJbnRsLkRhdGVUaW1lRm9ybWF0fG51bGx9IGludGxGb3JtYXRfZGF5PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF9kYXk6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSBpbnRsRm9ybWF0X3RpbWVfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW50bEZvcm1hdF90aW1lXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVXBkYXRpbmc9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNVcGRhdGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBsb2NhbGVfPU5lby5jb25maWcubG9jYWxlXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhbGVfOiBOZW8uY29uZmlnLmxvY2FsZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWUgaW4gbWludXRlcy4gQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWluaW11bUV2ZW50RHVyYXRpb249MzBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWluaW11bUV2ZW50RHVyYXRpb246IDMwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBzdG9yZSBpZiB1cGRhdGVFdmVudHMoKSBnb3QgY2FsbGVkIHdoaWxlIG5vdCBiZWluZyBtb3VudGVkXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG5lZWRzRXZlbnRVcGRhdGU9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbmVlZHNFdmVudFVwZGF0ZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyfG51bGx9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb25maWcgdmFsdWVzIGZvciBOZW8uY2FsZW5kYXIudmlldy53ZWVrLnBsdWdpbi5EcmFnRHJvcFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHBsdWdpbkRyYWdEcm9wQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBsdWdpbkRyYWdEcm9wQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogY29uZmlnIHZhbHVlcyBmb3IgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5wbHVnaW4uRXZlbnRSZXNpemFibGVcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBwbHVnaW5SZXNpemFibGVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGx1Z2luRXZlbnRSZXNpemFibGVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93RXZlbnRFbmRUaW1lXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0V2ZW50RW5kVGltZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHZpZXcgbW9kZWwuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dXZWVrZW5kc189dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1dlZWtlbmRzXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdGltZUF4aXM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGltZUF4aXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHRpbWVBeGlzQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRpbWVBeGlzQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gdGhlIHRpbWVBeGlzIGF0IHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmUgc3RhcnQgJiBlbmQuXG4gICAgICAgICAqIHN0YXJ0ID0+IGxlZnQsIGVuZCA9PiByaWdodCBpbiBMVFIgbW9kZS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0aW1lQXhpc1Bvc2l0aW9uXz0nc3RhcnQnXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lQXhpc1Bvc2l0aW9uXzogJ3N0YXJ0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcmUgdGhlIHRvdGFsIGFtb3VudCBvZiByZW5kZXJlZCBjb2x1bW5zLlxuICAgICAgICAgKiBDaGFuZ2luZyBjb2x1bW5zQnVmZmVyIG9yIGNvbHVtbnNWaXNpYmxlIHdpbGwgdXBkYXRlIHRoaXMgdmFsdWUuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB0b3RhbENvbHVtbnM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbENvbHVtbnM6IG51bGwsXG4gICAgICAgIHVwZGF0ZURlcHRoOiAtMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1zY3JvbGwtb3ZlcmxheSddfSxcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWMtdy1zY3JvbGxjb250YWluZXInXSwgZmxhZzogJ25lby1jLXctc2Nyb2xsY29udGFpbmVyJywgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1oZWFkZXItcm93J10sIGZsYWc6ICduZW8taGVhZGVyLXJvdycsIGNuOiBbXX0sXG4gICAgICAgICAgICAgICAge2NsczogWyduZW8tYy13LWNvbHVtbi10aW1lYXhpcy1jb250YWluZXInXSwgZmxhZzogJ25lby1jLXctY29sdW1uLXRpbWVheGlzLWNvbnRhaW5lcicsIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWMtdy1jb2x1bW4tY29udGFpbmVyJ10sIGZsYWc6ICduZW8tYy13LWNvbHVtbi1jb250YWluZXInLCBzdHlsZToge30sIGNuOiBbXX1cbiAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgXX1cbiAgICAgICAgXX0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwLTYgPT4gU3VuLVNhdFxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgdmlldyBtb2RlbC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWVrU3RhcnREYXlfPTBcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtTdGFydERheV86IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7ZGJsY2xpY2s6IG1lLm9uRXZlbnREb3VibGVDbGljaywgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tZXZlbnQnfSxcbiAgICAgICAgICAgIHt3aGVlbCAgIDogbWUub25XaGVlbCwgICAgICAgICAgICBzY29wZTogbWV9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIG1lLnRpbWVBeGlzID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFRpbWVBeGlzQ29tcG9uZW50LFxuICAgICAgICAgICAgYXBwTmFtZSAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgcGFyZW50SWQgOiBtZS5pZCxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25UaW1lQXhpc0NoYW5nZSwgc2NvcGUgOiBtZX0sXG4gICAgICAgICAgICB3aW5kb3dJZCA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgLi4ubWUudGltZUF4aXNDb25maWdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZ2V0Q29sdW1uVGltZUF4aXNDb250YWluZXIoKS5jblttZS50aW1lQXhpc1Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShtZS50aW1lQXhpcy5jcmVhdGVWZG9tUmVmZXJlbmNlKCkpO1xuXG4gICAgICAgIGlmIChtZS5jYWxlbmRhclN0b3JlLmdldENvdW50KCkgPiAwICYmIG1lLmV2ZW50U3RvcmUuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIG1lLm5lZWRzRXZlbnRVcGRhdGUgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGVIZWFkZXIodHJ1ZSwgbWUubmVlZHNFdmVudFVwZGF0ZSk7XG5cbiAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSAmJiBtZS51cGRhdGVFdmVudHMoZmFsc2UpO1xuXG4gICAgICAgIG1lLmhlYWRlckNyZWF0ZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5yb3dzUGVySXRlbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnRvdGFsSGVpZ2h0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIGFkanVzdFRvdGFsSGVpZ2h0KGRhdGEsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyb3dIZWlnaHQsIHJvd3NQZXJJdGVtfSA9IGRhdGEsXG4gICAgICAgICAgICBoZWlnaHQgICAgICAgICAgICAgICAgICAgPSBkYXRhLnRvdGFsSGVpZ2h0IC0gcm93SGVpZ2h0LFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGdyYWRpZW50ICAgICAgICAgICAgICAgICA9IFtdO1xuXG4gICAgICAgIGZvciAoOyBpIDwgcm93c1Blckl0ZW07IGkrKykge1xuICAgICAgICAgICAgZ3JhZGllbnQucHVzaChcbiAgICAgICAgICAgICAgICBgdmFyKC0tYy13LWJhY2tncm91bmQtY29sb3IpICR7aSAqIHJvd0hlaWdodCArIGl9cHhgLFxuICAgICAgICAgICAgICAgIGB2YXIoLS1jLXctYmFja2dyb3VuZC1jb2xvcikgJHsoaSArIDEpICogcm93SGVpZ2h0ICsgaX1weGAsXG4gICAgICAgICAgICAgICAgJ3ZhcigtLWMtdy1ib3JkZXItY29sb3IpIDAnXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLmdldENvbHVtbkNvbnRhaW5lcigpLnN0eWxlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGBsaW5lYXItZ3JhZGllbnQoJHtncmFkaWVudC5qb2luKCcsJyl9KWAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSA6IGAxcHggJHtyb3dzUGVySXRlbSAqIHJvd0hlaWdodCArIHJvd3NQZXJJdGVtfXB4YCxcbiAgICAgICAgICAgIGhlaWdodCAgICAgICAgIDogYCR7aGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIG1heEhlaWdodCAgICAgIDogYCR7aGVpZ2h0fXB4YFxuICAgICAgICB9KTtcblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjYWxlbmRhclN0b3JlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkNhbGVuZGFyc3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLnN0b3JlLkNhbGVuZGFyc3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENhbGVuZGFyU3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG5cbiAgICAgICAgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbG9hZCAgICAgICAgOiBtZS5vbkNhbGVuZGFyU3RvcmVMb2FkLFxuICAgICAgICAgICAgcmVjb3JkQ2hhbmdlOiBtZS5vbkNhbGVuZGFyU3RvcmVSZWNvcmRDaGFuZ2UsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH07XG5cbiAgICAgICAgb2xkVmFsdWU/LnVuKGxpc3RlbmVycyk7XG4gICAgICAgIHZhbHVlICAgPy5vbihsaXN0ZW5lcnMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjb2x1bW5zQnVmZmVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbHVtbnNCdWZmZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudG90YWxDb2x1bW5zID0gdGhpcy52aXNpYmxlQ29sdW1ucyArIDIgKiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29sdW1uc1Zpc2libGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29sdW1uc1Zpc2libGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudG90YWxDb2x1bW5zID0gMiAqIHRoaXMuY29sdW1uc0J1ZmZlciArIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjdXJyZW50RGF0ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0RhdGV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtEYXRlfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnREYXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVIZWFkZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlRXZlbnRzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZGF5TmFtZUZvcm1hdCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREYXlOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmludGxGb3JtYXRfZGF5ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobWUubG9jYWxlLCB7d2Vla2RheTogdmFsdWV9KTtcbiAgICAgICAgb2xkVmFsdWUgJiYgbWUudXBkYXRlSGVhZGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVuYWJsZURyYWcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFbmFibGVEcmFnKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuZ2V0UGx1Z2luKCdjYWxlbmRhci13ZWVrLWRyYWdkcm9wJykpIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4vcGx1Z2luL0RyYWdEcm9wLm1qcycpLFxuICAgICAgICAgICAgICAgIGltcG9ydCgnLi9wbHVnaW4vRXZlbnRSZXNpemFibGUubWpzJylcbiAgICAgICAgICAgIF0pLnRoZW4obW9kdWxlcyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB7YXBwTmFtZSwgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbnMgICAgICAgICAgICAgPSBtZS5wbHVnaW5zIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlIDogbW9kdWxlc1swXS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUucGx1Z2luRHJhZ0Ryb3BDb25maWdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IG1vZHVsZXNbMV0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGlvbkNsczogJ25lby1ldmVudCcsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMgICA6IFsnYicsICd0J10sXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5wbHVnaW5FdmVudFJlc2l6YWJsZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50Qm9yZGVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudEJvcmRlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtjbHN9ID0gbWU7XG5cbiAgICAgICAgb2xkVmFsdWUgJiYgTmVvQXJyYXkucmVtb3ZlKGNscywgYG5lby1ldmVudC1ib3JkZXItJHtvbGRWYWx1ZX1gKTtcbiAgICAgICAgdmFsdWUgICAgJiYgTmVvQXJyYXkuYWRkKCAgIGNscywgYG5lby1ldmVudC1ib3JkZXItJHt2YWx1ZX1gKTtcblxuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV2ZW50U3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIuc3RvcmUuRXZlbnRzfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RXZlbnRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcblxuICAgICAgICBsaXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBsb2FkICAgICAgICA6IG1lLm9uRXZlbnRTdG9yZUxvYWQsXG4gICAgICAgICAgICByZWNvcmRDaGFuZ2U6IG1lLm9uRXZlbnRTdG9yZVJlY29yZENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfTtcblxuICAgICAgICBvbGRWYWx1ZT8udW4obGlzdGVuZXJzKTtcbiAgICAgICAgdmFsdWUgICA/Lm9uKGxpc3RlbmVycylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGxvY2FsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRMb2NhbGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgbWUuaW50bEZvcm1hdF9kYXkgID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodmFsdWUsIHt3ZWVrZGF5OiBtZS5kYXlOYW1lRm9ybWF0fSk7XG4gICAgICAgICAgICBtZS51cGRhdGVIZWFkZXIoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkLCByZWN0O1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1lLm5lZWRzRXZlbnRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVFdmVudHMoKTtcbiAgICAgICAgICAgICAgICBtZS5uZWVkc0V2ZW50VXBkYXRlID0gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMDApO1xuXG4gICAgICAgICAgICByZWN0ICAgICAgICAgICAgICA9IGF3YWl0IG1lLmdldERvbVJlY3QobWUuZ2V0Q29sdW1uQ29udGFpbmVyKCkuaWQpO1xuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQgPSBtZS5nZXRTY3JvbGxDb250YWluZXIoKS5pZDtcblxuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQgJiYgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgOiBzY3JvbGxDb250YWluZXJJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IHJlY3Qud2lkdGggKiBtZS5jb2x1bW5zQnVmZmVyIC8gbWUuY29sdW1uc1Zpc2libGUgLyAzXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93RXZlbnRFbmRUaW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd0V2ZW50RW5kVGltZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnVwZGF0ZUV2ZW50cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzaG93V2Vla2VuZHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTaG93V2Vla2VuZHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSA9IG1lO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLXNob3ctd2Vla2VuZHMnKTtcblxuICAgICAgICBtZS5fY2xzID0gY2xzOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUhlYWRlcihmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGVFdmVudHMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aW1lQXhpc1Bvc2l0aW9uIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRpbWVBeGlzUG9zaXRpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAgdGltZUF4aXNDb250YWluZXIgPSBtZS5nZXRDb2x1bW5UaW1lQXhpc0NvbnRhaW5lcigpO1xuXG4gICAgICAgIE5lb0FycmF5W3ZhbHVlID09PSAnZW5kJyA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby10aW1lYXhpcy1lbmQnKTtcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZUF4aXNDb250YWluZXIuY24udW5zaGlmdCh0aW1lQXhpc0NvbnRhaW5lci5jbi5wb3AoKSkgLy8gc3dpdGNoIHRoZSBvcmRlciBvZiB0aGUgMiBpdGVtc1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuY2xzID0gY2xzOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3ZWVrU3RhcnREYXkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2Vla1N0YXJ0RGF5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFkZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFdmVudHMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZGF5TmFtZUZvcm1hdCBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERheU5hbWVGb3JtYXQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkYXlOYW1lRm9ybWF0JywgRGF0ZVV0aWwucHJvdG90eXBlLmRheU5hbWVGb3JtYXRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHRpbWVBeGlzUG9zaXRpb24gY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRUaW1lQXhpc1Bvc2l0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAndGltZUF4aXNQb3NpdGlvbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgd2Vla1N0YXJ0RGF5IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0V2Vla1N0YXJ0RGF5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnd2Vla1N0YXJ0RGF5JywgRGF0ZVV0aWwucHJvdG90eXBlLndlZWtTdGFydERheXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGVDb2x1bW5BbmRIZWFkZXIoZGF0ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29sdW1uQ2xzICAgPSBbJ25lby1jLXctY29sdW1uJywgJ25lby1kcmFnZ2FibGUnXSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICBjdXJyZW50RGF5ICA9IGRhdGUuZ2V0RGF5KCksXG4gICAgICAgICAgICBkYXRlQ2xzICAgICA9IFsnbmVvLWRhdGUnXSxcbiAgICAgICAgICAgIHJlbW92ZURvbSAgID0gZmFsc2UsXG4gICAgICAgICAgICBjb2x1bW4sIGhlYWRlcjtcblxuICAgICAgICBpZiAoY3VycmVudERheSA9PT0gMCB8fCBjdXJyZW50RGF5ID09PSA2KSB7XG4gICAgICAgICAgICBjb2x1bW5DbHMucHVzaCgnbmVvLXdlZWtlbmQnKTtcbiAgICAgICAgICAgICFtZS5zaG93V2Vla2VuZHMgJiYgKHJlbW92ZURvbSA9IHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudERhdGUgPT09IHRvZGF5LmRheSAmJiBkYXRlLmdldE1vbnRoKCkgPT09IHRvZGF5Lm1vbnRoICYmIGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gdG9kYXkueWVhcikge1xuICAgICAgICAgICAgZGF0ZUNscy5wdXNoKCduZW8tdG9kYXknKVxuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1uID0ge2NsczogY29sdW1uQ2xzLCBmbGFnOiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKSwgcmVtb3ZlRG9tfTtcblxuICAgICAgICBoZWFkZXIgPVxuICAgICAgICB7Y2xzOiBbJ25lby1oZWFkZXItcm93LWl0ZW0nXSwgcmVtb3ZlRG9tOiByZW1vdmVEb20sIGNuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1kYXknXSwgaHRtbDogbWUuaW50bEZvcm1hdF9kYXkuZm9ybWF0KGRhdGUpfSxcbiAgICAgICAgICAgIHtjbHM6IGRhdGVDbHMsICAgICBodG1sOiBjdXJyZW50RGF0ZX1cbiAgICAgICAgXX07XG5cbiAgICAgICAgcmV0dXJuIHtjb2x1bW4sIGhlYWRlcn1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLnRpbWVBeGlzID0gbnVsbDtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5nZXRCeUZsYWcodGhpcy52ZG9tLCAnbmVvLWMtdy1jb2x1bW4tY29udGFpbmVyJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbHVtbklkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X2NvbF8ke0RhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbHVtbkhlYWRlcklkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X2NoXyR7RGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSl9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0Q29sdW1uVGltZUF4aXNDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5nZXRCeUZsYWcodGhpcy52ZG9tLCAnbmVvLWMtdy1jb2x1bW4tdGltZWF4aXMtY29udGFpbmVyJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHJlY29yZElkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRFdmVudElkKHJlY29yZElkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHtyZWNvcmRJZH1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5nZXRCeUZsYWcodGhpcy52ZG9tLCAnbmVvLWhlYWRlci1yb3cnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgaW5zaWRlIGNyZWF0ZUlkKCkgYXMgdGhlIGRlZmF1bHQgdmFsdWUgcGFzc2VkIHRvIHRoZSBJZEdlbmVyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldElkS2V5KCkge1xuICAgICAgICByZXR1cm4gJ2MtdydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFNjcm9sbENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmdldEJ5RmxhZyh0aGlzLnZkb20sICduZW8tYy13LXNjcm9sbGNvbnRhaW5lcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2FsZW5kYXJTdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLmV2ZW50U3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgdGhpcy51cGRhdGVFdmVudHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DYWxlbmRhclN0b3JlUmVjb3JkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFdmVudHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudERvdWJsZUNsaWNrKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ldmVudHMuZW5hYmxlRWRpdCkge1xuICAgICAgICAgICAgbGV0IHtwYXRofSA9IGRhdGE7XG5cbiAgICAgICAgICAgICFwYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLWV2ZW50JykgJiYgcGF0aC5zaGlmdCgpO1xuXG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7ZWRpdEV2ZW50Q29udGFpbmVyfSA9IG1lLm93bmVyLFxuICAgICAgICAgICAgICAgIGV2ZW50Tm9kZSAgICAgICAgICA9IHBhdGhbMF0sXG4gICAgICAgICAgICAgICAgZXZlbnRWZG9tICAgICAgICAgID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBldmVudE5vZGUuaWQpLnZkb20sXG4gICAgICAgICAgICAgICAgcmVjb3JkICAgICAgICAgICAgID0gbWUuZXZlbnRTdG9yZS5nZXQoZXZlbnRWZG9tLmZsYWcpLFxuICAgICAgICAgICAgICAgIHtzdHlsZX0gICAgICAgICAgICA9IGVkaXRFdmVudENvbnRhaW5lcjtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge2xlZnQ6IGAke2V2ZW50Tm9kZS5yZWN0LndpZHRoICsgMTV9cHhgLCB0b3A6IGV2ZW50VmRvbS5zdHlsZS50b3B9KTtcbiAgICAgICAgICAgIGVkaXRFdmVudENvbnRhaW5lci5zZXRTaWxlbnQoe3BhcmVudElkOiBwYXRoWzFdLmlkLCByZWNvcmQsIHN0eWxlfSk7XG4gICAgICAgICAgICBlZGl0RXZlbnRDb250YWluZXIucmVuZGVyKHRydWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAgICovXG4gICAgb25FdmVudFN0b3JlTG9hZChkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdG9yZS5nZXRDb3VudCgpID4gMCAmJiB0aGlzLnVwZGF0ZUV2ZW50cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnRTdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXZlbnRzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucGF0aFxuICAgICAqL1xuICAgIG9uRm9jdXNDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQge29sZFBhdGgsIHBhdGh9ID0gZGF0YTtcblxuICAgICAgICBvbGRQYXRoPy5bMF0/LmNscy5pbmNsdWRlcygnbmVvLWV2ZW50JykgJiYgTmVvLmFwcGx5RGVsdGFzKHRoaXMuYXBwTmFtZSwge2lkOiBvbGRQYXRoWzBdLmlkLCBjbHM6IHtyZW1vdmU6IFsnbmVvLWZvY3VzJ119fSk7XG4gICAgICAgIHBhdGggICA/LlswXT8uY2xzLmluY2x1ZGVzKCduZW8tZXZlbnQnKSAmJiBOZW8uYXBwbHlEZWx0YXModGhpcy5hcHBOYW1lLCB7aWQ6IHBhdGhbMF0gICAuaWQsIGNsczoge2FkZDogICAgWyduZW8tZm9jdXMnXX19KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93SGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93c1Blckl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS50b3RhbEhlaWdodFxuICAgICAqL1xuICAgIG9uVGltZUF4aXNDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkanVzdFRvdGFsSGVpZ2h0KGRhdGEsIG1lLmhlYWRlckNyZWF0ZWQpO1xuICAgICAgICBtZS5oZWFkZXJDcmVhdGVkICYmIG1lLnVwZGF0ZUV2ZW50cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbldoZWVsKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRpbmcgJiYgTWF0aC5hYnMoZGF0YS5kZWx0YVgpID4gTWF0aC5hYnMoZGF0YS5kZWx0YVkpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBjb2x1bW5zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXRDb2x1bW5Db250YWluZXIoKSxcbiAgICAgICAgICAgICAgICB7Y29sdW1uc0J1ZmZlciwgY29sdW1uc1Zpc2libGUsIGZpcnN0Q29sdW1uRGF0ZX0gPSBtZSxcbiAgICAgICAgICAgICAgICBoZWFkZXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXRIZWFkZXJDb250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIHRpbWVBeGlzV2lkdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDUwLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IGRhdGEuY2xpZW50V2lkdGggLSB0aW1lQXhpc1dpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZywgZGF0ZSwgc2Nyb2xsVmFsdWU7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEuc2Nyb2xsTGVmdCwgTWF0aC5yb3VuZChkYXRhLnNjcm9sbExlZnQgLyAoZGF0YS5jbGllbnRXaWR0aCAtIHRpbWVBeGlzV2lkdGgpICogNykpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5kZWx0YVggPiAwICYmIE1hdGgucm91bmQoZGF0YS5zY3JvbGxMZWZ0IC8gd2lkdGggKiBjb2x1bW5zQnVmZmVyKSA+IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZSAtIDEpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoY29sdW1ucy5jbltjb2x1bW5zLmNuLmxlbmd0aCAtIDFdLmZsYWcpO1xuXG4gICAgICAgICAgICAgICAgY29sdW1ucy5jbi5zcGxpY2UoMCwgY29sdW1uc0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgaGVhZGVyIC5jbi5zcGxpY2UoMCwgY29sdW1uc0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvbHVtbnNCdWZmZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBtZS5jcmVhdGVDb2x1bW5BbmRIZWFkZXIoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5jbi5wdXNoKGNvbmZpZy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLnB1c2goY29uZmlnLmhlYWRlcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJzdENvbHVtbkRhdGUuc2V0RGF0ZShmaXJzdENvbHVtbkRhdGUuZ2V0RGF0ZSgpICsgY29sdW1uc0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGEgc2hvcnQgZGVsYXkgdG8gbW92ZSB0aGUgZXZlbnQgcmVuZGVyaW5nIGludG8gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAgICAgICAgICAgIC8vIERldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMjE2XG4gICAgICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7bWUudXBkYXRlRXZlbnRzKGZhbHNlLCBjb2x1bW5zQnVmZmVyICsgY29sdW1uc1Zpc2libGUsIG1lLnRvdGFsQ29sdW1ucyl9KTtcblxuICAgICAgICAgICAgICAgIHNjcm9sbFZhbHVlID0gLXdpZHRoXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuZGVsdGFYIDwgMCAmJiBNYXRoLnJvdW5kKGRhdGEuc2Nyb2xsTGVmdCAvIHdpZHRoICogY29sdW1uc0J1ZmZlcikgPCAxKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGNvbHVtbnMuY25bMF0uZmxhZyk7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLmxlbmd0aCA9IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZTtcbiAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLmxlbmd0aCA9IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZTtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY29sdW1uc0J1ZmZlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lLmNyZWF0ZUNvbHVtbkFuZEhlYWRlcihkYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLnVuc2hpZnQoY29uZmlnLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciAuY24udW5zaGlmdChjb25maWcuaGVhZGVyKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpcnN0Q29sdW1uRGF0ZS5zZXREYXRlKGZpcnN0Q29sdW1uRGF0ZS5nZXREYXRlKCkgLSBjb2x1bW5zQnVmZmVyKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgYSBzaG9ydCBkZWxheSB0byBtb3ZlIHRoZSBldmVudCByZW5kZXJpbmcgaW50byB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAgICAgICAgICAgICAgLy8gRGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIyMTZcbiAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHttZS51cGRhdGVFdmVudHMoZmFsc2UsIDAsIGNvbHVtbnNCdWZmZXIpfSk7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxWYWx1ZSA9IHdpZHRoXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc2Nyb2xsQnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmdldFNjcm9sbENvbnRhaW5lcigpLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiBzY3JvbGxWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgKi9cbiAgICBzZXRGaXJzdENvbHVtbkRhdGUoZGF0ZSkge1xuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXRlLmdldERheSgpICsgdGhpcy53ZWVrU3RhcnREYXkgLSB0aGlzLmNvbHVtbnNCdWZmZXIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFsZ29yaXRobSByZWxpZXMgb24gdGhlIGV2ZW50U3RvcmUgYmVpbmcgc29ydGVkIGJ5IHN0YXJ0RGF0ZSBBU0NcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4PTBdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleD10aGlzLnRvdGFsQ29sdW1uc11cbiAgICAgKi9cbiAgICB1cGRhdGVFdmVudHMoc2lsZW50PWZhbHNlLCBzdGFydEluZGV4PTAsIGVuZEluZGV4PXRoaXMudG90YWxDb2x1bW5zKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5uZWVkc0V2ZW50VXBkYXRlID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHtjYWxlbmRhclN0b3JlLCBldmVudFN0b3JlLCBzaG93RXZlbnRFbmRUaW1lLCB0aW1lQXhpcywgdmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBlbmRUaW1lICAgPSB0aW1lQXhpcy5nZXRUaW1lKG1lLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IHRpbWVBeGlzLmdldFRpbWUobWUuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIGRhdGUgICAgICA9IERhdGVVdGlsLmNsb25lKG1lLmZpcnN0Q29sdW1uRGF0ZSksXG4gICAgICAgICAgICAgICAgY29udGVudCAgID0gbWUuZ2V0Q29sdW1uQ29udGFpbmVyKCksXG4gICAgICAgICAgICAgICAgaiAgICAgICAgID0gc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgICBjYWxlbmRhclJlY29yZCwgY29sdW1uLCBkYXlSZWNvcmRzLCBkdXJhdGlvbiwgZW5kRGF0ZSwgZXZlbnRDbHMsIGV2ZW50SW50ZXJ2YWxzLCBoYXNPdmVyZmxvdywgaGVpZ2h0LCBpLFxuICAgICAgICAgICAgICAgIGxlbiwgcmVjb3JkLCByZWNvcmRLZXksIHN0YXJ0RGF0ZSwgc3RhcnRIb3VycywgdG9wO1xuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGFydEluZGV4KTtcblxuICAgICAgICAgICAgZm9yICg7IGogPCBlbmRJbmRleDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gY29udGVudC5jbltqXTtcblxuICAgICAgICAgICAgICAgIGNvbHVtbi5jbiA9IFtdOyAvLyByZW1vdmUgcHJldmlvdXMgZXZlbnRzIGZyb20gdGhlIHZkb21cblxuICAgICAgICAgICAgICAgIGRheVJlY29yZHMgPSBldmVudFN0b3JlLmdldERheVJlY29yZHMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgbGVuICAgICAgICA9IGRheVJlY29yZHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCAgICAgICAgID0gZGF5UmVjb3Jkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJSZWNvcmQgPSBjYWxlbmRhclN0b3JlLmdldChyZWNvcmQuY2FsZW5kYXJJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyUmVjb3JkPy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUgICA9IHJlY29yZC5lbmREYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlID0gcmVjb3JkLnN0YXJ0RGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFRpbWUgPD0gc3RhcnREYXRlLmdldEhvdXJzKCkgfHwgc3RhcnRUaW1lID49IGVuZERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRUaW1lIDwgZW5kRGF0ZS5nZXRIb3VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZSA9IERhdGVVdGlsLmNsb25lKGVuZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoZW5kVGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFRpbWUgPiBzdGFydERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IERhdGVVdGlsLmNsb25lKHN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlLnNldE1pbnV0ZXMoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gICAgICAgPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDYwIC8gMTAwMDsgLy8gZHVyYXRpb24gaW4gaG91cnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xzICAgICAgID0gWyduZW8tZXZlbnQnLCAnbmVvLWRyYWdnYWJsZScsIGBuZW8tJHtjYWxlbmRhclJlY29yZC5jb2xvcn1gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW50ZXJ2YWxzID0gZHVyYXRpb24gKiA2MCAvIHRpbWVBeGlzLmludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3cgICAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAgICAgICAgID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIHRvdGFsVGltZSAqIDEwMCAqIDEwMDApIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZEtleSAgICAgID0gcmVjb3JkW2V2ZW50U3RvcmUua2V5UHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRIb3VycyAgICAgPSAoc3RhcnREYXRlLmdldEhvdXJzKCkgKiA2MCArIHN0YXJ0RGF0ZS5nZXRNaW51dGVzKCkpIC8gNjA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgICAgICAgICAgICA9IE1hdGgucm91bmQoKHN0YXJ0SG91cnMgLSBzdGFydFRpbWUpIC8gdG90YWxUaW1lICogMTAwICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRJbnRlcnZhbHMgPD0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc092ZXJmbG93ID0gdGltZUF4aXMucm93SGVpZ2h0ICogZXZlbnRJbnRlcnZhbHMgPCAoc2hvd0V2ZW50RW5kVGltZSA/IDUwIDogMzQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc092ZXJmbG93ICYmICEoc2hvd0V2ZW50RW5kVGltZSAmJiAodGltZUF4aXMucm93SGVpZ2h0IC8gZXZlbnRJbnRlcnZhbHMgPj0gMzQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudENscy5wdXNoKCduZW8tb3ZlcmZsb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50RW5kVGltZSA9ICEoaGFzT3ZlcmZsb3cgJiYgZXZlbnRJbnRlcnZhbHMgPT09IDEgfHwgIXNob3dFdmVudEVuZFRpbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRFbmRUaW1lICYmIGV2ZW50Q2xzLnB1c2goJ25lby1zaG93LWVuZC10aW1lJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgIDogZXZlbnRDbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyAgICA6IHJlY29yZEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogbWUuZ2V0RXZlbnRJZChyZWNvcmRLZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiAtMSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNuOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgOiBbJ25lby1ldmVudC10aW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IG1lLmludGxGb3JtYXRfdGltZS5mb3JtYXQocmVjb3JkLnN0YXJ0RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICA6IGAke21lLmlkfV9fdGltZV9fJHtyZWNvcmRLZXl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZXZlbnQtdGl0bGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbDogcmVjb3JkLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgOiBgJHttZS5pZH1fX3RpdGxlX18ke3JlY29yZEtleX1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWV2ZW50LXRpbWUnLCAnbmVvLWV2ZW50LWVuZC10aW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgICAgIDogbWUuaW50bEZvcm1hdF90aW1lLmZvcm1hdChyZWNvcmQuZW5kRGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgIDogYCR7bWUuaWR9X19lbmRkYXRlX18ke3JlY29yZEtleX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVEb206ICFzaG93RXZlbnRFbmRUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGBjYWxjKCR7aGVpZ2h0fSUgLSAycHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBgY2FsYygke3RvcH0lICsgMXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogJ2NhbGMoMTAwJSAtIDFweCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NyZWF0ZT1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICovXG4gICAgdXBkYXRlSGVhZGVyKGNyZWF0ZT1mYWxzZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c2hvd1dlZWtlbmRzfSA9IG1lLFxuICAgICAgICAgICAgZGF0ZSAgICAgICAgICAgPSBtZS5jdXJyZW50RGF0ZSwgLy8gY2xvbmVkXG4gICAgICAgICAgICBjb250ZW50ICAgICAgICA9IG1lLmdldENvbHVtbkNvbnRhaW5lcigpLFxuICAgICAgICAgICAgaGVhZGVyICAgICAgICAgPSBtZS5nZXRIZWFkZXJDb250YWluZXIoKSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGNvbHVtbkNscywgY3VycmVudERhdGUsIGN1cnJlbnREYXksIGRhdGVDbHMsIGhlYWRlcklkLCByZW1vdmVEb207XG5cbiAgICAgICAgbWUuc2V0Rmlyc3RDb2x1bW5EYXRlKGRhdGUpO1xuXG4gICAgICAgIG1lLmZpcnN0Q29sdW1uRGF0ZSA9IERhdGVVdGlsLmNsb25lKGRhdGUpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbWUudG90YWxDb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIGNvbHVtbkNscyAgID0gWyduZW8tYy13LWNvbHVtbicsICduZW8tZHJhZ2dhYmxlJ107XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgY3VycmVudERheSAgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgZGF0ZUNscyAgICAgPSBbJ25lby1kYXRlJ107XG4gICAgICAgICAgICByZW1vdmVEb20gICA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudERheSA9PT0gMCB8fCBjdXJyZW50RGF5ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgY29sdW1uQ2xzLnB1c2goJ25lby13ZWVrZW5kJyk7XG4gICAgICAgICAgICAgICAgIXNob3dXZWVrZW5kcyAmJiAocmVtb3ZlRG9tID0gdHJ1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRlID09PSB0b2RheS5kYXkgJiYgZGF0ZS5nZXRNb250aCgpID09PSB0b2RheS5tb250aCAmJiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHRvZGF5LnllYXIpIHtcbiAgICAgICAgICAgICAgICBkYXRlQ2xzLnB1c2goJ25lby10b2RheScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcklkID0gbWUuZ2V0Q29sdW1uSGVhZGVySWQoZGF0ZSk7XG5cbiAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LmNuLnB1c2goe2NsczogY29sdW1uQ2xzLCBmbGFnOiBEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKSwgaWQ6IG1lLmdldENvbHVtbklkKGRhdGUpLCByZW1vdmVEb219KTtcblxuICAgICAgICAgICAgICAgIGhlYWRlci5jbi5wdXNoKFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWhlYWRlci1yb3ctaXRlbSddLCBpZDogaGVhZGVySWQsIHJlbW92ZURvbSwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tZGF5J10sIGh0bWw6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKSwgaWQ6IGAke2hlYWRlcklkfV9kYXlgfSxcbiAgICAgICAgICAgICAgICAgICAge2NscyA6IGRhdGVDbHMsICAgIGh0bWw6IGN1cnJlbnREYXRlLCAgICAgICAgICAgICAgICAgICAgaWQ6IGAke2hlYWRlcklkfV9kYXRlYH1cbiAgICAgICAgICAgICAgICBdfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb250ZW50LmNuW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgIGNscyA6IGNvbHVtbkNscyxcbiAgICAgICAgICAgICAgICAgICAgZmxhZzogRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGlkICA6IG1lLmdldENvbHVtbklkKGRhdGUpLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVEb21cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVyLmNuW2ldLCAgICAgICB7aWQ6IGhlYWRlcklkLCByZW1vdmVEb219KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlci5jbltpXS5jblswXSwge2h0bWw6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKSwgaWQ6IGAke2hlYWRlcklkfV9kYXlgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXIuY25baV0uY25bMV0sIHtjbHM6IGRhdGVDbHMsIGh0bWw6IGN1cnJlbnREYXRlLCBpZDogYCR7aGVhZGVySWR9X2RhdGVgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMSlcbiAgICAgICAgfVxuXG4gICAgICAgICFzaWxlbnQgJiYgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LndlZWsuVGltZUF4aXNDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBUaW1lQXhpc0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBpbnRlcnZhbFxuICAgICAqIEBtZW1iZXIge051bWJlcltdfSBpbnRlcnZhbHM9WzE1LDMwLDYwXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGludGVydmFscyA9IFsxNSwgMzAsIDYwXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy53ZWVrLlRpbWVBeGlzQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy53ZWVrLlRpbWVBeGlzQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLXRpbWVheGlzJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFyLXRpbWVheGlzJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGJpbmRcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IHtcbiAgICAgICAgICAgIGVuZFRpbWUgIDogZGF0YSA9PiBkYXRhLmVuZFRpbWUsXG4gICAgICAgICAgICBzdGFydFRpbWU6IGRhdGEgPT4gZGF0YS5zdGFydFRpbWVcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZnVsbCBob3VycyBhcmUgdmFsaWQgZm9yIG5vd1xuICAgICAgICAgKiBmb3JtYXQ6ICdoaDptbSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBlbmRUaW1lXz0nMjQ6MDAnXG4gICAgICAgICAqL1xuICAgICAgICBlbmRUaW1lXzogJzI0OjAwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIGludGVydmFsIGluIG1pbnV0ZXMgdG8gZGlzcGxheSBhcyByb3dzLlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXM6IDE1LCAzMCwgNjBcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBpbnRlcnZhbF89MzBcbiAgICAgICAgICovXG4gICAgICAgIGludGVydmFsXzogMzAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvd0hlaWdodF89MjBcbiAgICAgICAgICovXG4gICAgICAgIHJvd0hlaWdodF86IDIwLFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBmdWxsIGhvdXJzIGFyZSB2YWxpZCBmb3Igbm93XG4gICAgICAgICAqIGZvcm1hdDogJ2hoOm1tJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHN0YXJ0VGltZV89JzAwOjAwJ1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRUaW1lXzogJzAwOjAwJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbTpcbiAgICAgICAge3N0eWxlOiB7fX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIG1lLmFmdGVyU2V0Um93SGVpZ2h0KG1lLnJvd0hlaWdodCwgMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGVuZFRpbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RW5kVGltZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIHRvZG86IGhhbmRsZSAyNDowMCBhcyAyMzo1OVxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLl9lbmRUaW1lID0gJzI0OjAwJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5hZnRlclNldFJvd0hlaWdodChtZS5yb3dIZWlnaHQsIDApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGludGVydmFsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEludGVydmFsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hZnRlclNldFJvd0hlaWdodCh0aGlzLnJvd0hlaWdodCwgMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm93SGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJvd0hlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy52ZG9tLmNuKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGVuZFRpbWUgICAgICAgICAgID0gbWUuZ2V0VGltZShtZS5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgICAgICAgICA9IG1lLmdldFRpbWUobWUuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICB7cm93SGVpZ2h0LCB2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgICAgIHJvd3NQZXJJdGVtICAgICAgID0gbWUuZ2V0Um93c1Blckl0ZW0oKSxcbiAgICAgICAgICAgICAgICBpdGVtSGVpZ2h0ICAgICAgICA9IHJvd3NQZXJJdGVtICogcm93SGVpZ2h0ICsgcm93c1Blckl0ZW0sIC8vIHJvd3NQZXJJdGVtICogMXB4IGJvcmRlcnNcbiAgICAgICAgICAgICAgICB0b3RhbEhlaWdodCAgICAgICA9IHJvd0hlaWdodCArICgoZW5kVGltZSAtIHN0YXJ0VGltZSkgKiBpdGVtSGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBpLCBpdGVtU3R5bGU7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmRvbS5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZSAgICA6IGBsaW5lYXItZ3JhZGllbnQodmFyKC0tYy13LWJhY2tncm91bmQtY29sb3IpICR7aXRlbUhlaWdodCAtIDF9cHgsIHZhcigtLWMtdy1ib3JkZXItY29sb3IpIDFweClgLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRQb3NpdGlvblk6IGAkey1pdGVtSGVpZ2h0ICsgMX1weGAsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFNpemUgICAgIDogYDAuNGVtICR7aXRlbUhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICAgICAgICAgICAgIDogYCR7dG90YWxIZWlnaHQgLSByb3dIZWlnaHQgKyAxfXB4YCxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgICAgICAgICAgOiBgJHt0b3RhbEhlaWdodCAtIHJvd0hlaWdodCArIDF9cHhgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yIChpPTA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2l0ZW1IZWlnaHR9cHhgXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09PSBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlLm1hcmdpblRvcCA9IGAkey0yIC0gcm93SGVpZ2h0ICogKHJvd3NQZXJJdGVtID09PSAxID8gMC41IDogcm93c1Blckl0ZW0gPT09IDIgPyAxIDogMil9cHhgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1TdHlsZS5tYXJnaW5Ub3BcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2ZG9tLmNuW2ldLnN0eWxlID0gaXRlbVN0eWxlO1xuXG4gICAgICAgICAgICAgICAgdmRvbS5jbltpXS5yZW1vdmVEb20gPSAoaSA8IHN0YXJ0VGltZSB8fCBpIC0gMSA+PSBlbmRUaW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuZmlyZSgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogbWUsXG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJvd3NQZXJJdGVtLFxuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdGFydFRpbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RhcnRUaW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hZnRlclNldFJvd0hlaWdodCh0aGlzLnJvd0hlaWdodCwgMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGludGVydmFsIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0SW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdpbnRlcnZhbCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IHt2ZG9tfSA9IHRoaXMsXG4gICAgICAgICAgICBodG1sLCBpO1xuXG4gICAgICAgIHZkb20uY24gPSBbXTtcblxuICAgICAgICBmb3IgKGk9MDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgIGh0bWwgPSBpID09PSAyNCA/ICcwMDowMCcgOiAoaSA8IDEwID8gJzAnIDogJycpICsgaSArICc6MDAnO1xuXG4gICAgICAgICAgICB2ZG9tLmNuLnB1c2goe1xuICAgICAgICAgICAgICAgIGNsczogWyduZW8tYy13LXRpbWVheGlzLWl0ZW0nXSxcbiAgICAgICAgICAgICAgICBjbiA6IFt7aHRtbH1dXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYW1vdW50IG9mIHJvd3MgcmVsYXRlZCB0byB0aGUgaW50ZXJ2YWwgY29uZmlnXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSb3dzUGVySXRlbSgpIHtcbiAgICAgICAgbGV0IHtpbnRlcnZhbH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gaW50ZXJ2YWwgPT09IDYwID8gMSA6IGludGVydmFsID09PSAzMCA/IDIgOiA0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdGltZSBmb3IgdGhlIGVuZC0gb3Igc3RhcnRUaW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRUaW1lKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpWzBdXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUaW1lQXhpc0NvbXBvbmVudCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=