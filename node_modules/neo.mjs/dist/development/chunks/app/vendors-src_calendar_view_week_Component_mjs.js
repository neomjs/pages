export const __webpack_esm_id__ = "vendors-src_calendar_view_week_Component_mjs";
export const __webpack_esm_ids__ = ["vendors-src_calendar_view_week_Component_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/calendar/view/week/Component.mjs"
/*!**********************************************!*\
  !*** ./src/calendar/view/week/Component.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TimeAxisComponent.mjs */ "./src/calendar/view/week/TimeAxisComponent.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






const todayDate = new Date();

const today = {
    day  : todayDate.getDate(),
    month: todayDate.getMonth(),
    year : todayDate.getFullYear()
};

/**
 * @class Neo.calendar.view.week.Component
 * @extends Neo.component.Base
 */
class Component extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for timeAxisPosition
     * @member {String[]} timeAxisPositions=['end','start']
     * @protected
     * @static
     */
    static timeAxisPositions = ['end', 'start']

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.Component'
         * @protected
         */
        className: 'Neo.calendar.view.week.Component',
        /**
         * @member {String[]} baseCls=['neo-calendar-weekcomponent']
         */
        baseCls: ['neo-calendar-weekcomponent'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore       : 'stores.calendars',
            currentDate         : data => data.currentDate,
            enableDrag          : data => data.events.enableDrag,
            endTime             : data => data.endTime,
            eventBorder         : data => data.events.border,
            eventStore          : 'stores.events',
            intlFormat_time     : data => data.timeFormatter,
            locale              : data => data.locale,
            minimumEventDuration: data => data.minimumEventDuration,
            showWeekends        : data => data.showWeekends,
            startTime           : data => data.startTime,
            weekStartDay        : data => data.weekStartDay
        },
        /**
         * Bound to the state provider
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         * @reactive
         */
        calendarStore_: null,
        /**
         * Amount of hidden columns on both sides each inside this view.
         * @member {Number} columnsBuffer_=7
         * @reactive
         */
        columnsBuffer_: 7,
        /**
         * Amount of visible columns inside this view.
         * @member {Number} columnsVisible_=7
         * @reactive
         */
        columnsVisible_: 7,
        /**
         * Bound to the state provider.
         * @member {Date|null} currentDate_=null
         * @protected
         * @reactive
         */
        currentDate_: null,
        /**
         * The format of the column headers.
         * Valid values are: narrow, short & long
         * @member {String} dayNameFormat_='short'
         * @reactive
         */
        dayNameFormat_: 'short',
        /**
         * Bound to the state provider.
         * @member {Boolean} enableDrag_=true
         * @protected
         * @reactive
         */
        enableDrag_: true,
        /**
         * Bound to the state provider
         * @member {String|null} eventBorder_=null
         * @reactive
         */
        eventBorder_: null,
        /**
         * @member {Neo.calendar.view.week.EventDragZone|null} eventDragZone=null
         */
        eventDragZone: null,
        /**
         * Bound to the state provider
         * @member {Neo.calendar.store.Events|null} eventStore_=null
         * @reactive
         */
        eventStore_: null,
        /**
         * Will get passed from updateHeader()
         * @member {Date|null} firstColumnDate=null
         * @protected
         */
        firstColumnDate: null,
        /**
         * Internal flag to check if updateHeader(true) has already run
         * @member {Boolean} headerCreated=false
         * @protected
         */
        headerCreated: false,
        /**
         * @member {Intl.DateTimeFormat|null} intlFormat_day=null
         * @protected
         */
        intlFormat_day: null,
        /**
         * Bound to the state provider.
         * @member {Intl.DateTimeFormat|null} intlFormat_time_=null
         * @protected
         * @reactive
         */
        intlFormat_time_: null,
        /**
         * @member {Boolean} isUpdating=false
         * @protected
         */
        isUpdating: false,
        /**
         * Bound to the state provider.
         * @member {String} locale_=Neo.config.locale
         * @reactive
         */
        locale_: Neo.config.locale,
        /**
         * Time in minutes. Bound to the state provider.
         * @member {Number} minimumEventDuration=30
         * @protected
         */
        minimumEventDuration: 30,
        /**
         * Internal flag to store if updateEvents() got called while not being mounted
         * @member {Boolean} needsEventUpdate=false
         * @protected
         */
        needsEventUpdate: false,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null,
        /**
         * config values for Neo.calendar.view.week.plugin.DragDrop
         * @member {Object} pluginDragDropConfig=null
         */
        pluginDragDropConfig: null,
        /**
         * config values for Neo.calendar.view.week.plugin.EventResizable
         * @member {Object} pluginResizableConfig=null
         */
        pluginEventResizableConfig: null,
        /**
         * @member {Boolean} showEventEndTime_=false
         * @reactive
         */
        showEventEndTime_: false,
        /**
         * Bound to the state provider.
         * @member {Boolean} showWeekends_=true
         * @reactive
         */
        showWeekends_: true,
        /**
         * @member {Object} timeAxis=null
         */
        timeAxis: null,
        /**
         * @member {Object} timeAxisConfig=null
         */
        timeAxisConfig: null,
        /**
         * Position the timeAxis at the left or right side.
         * Valid values are start & end.
         * start => left, end => right in LTR mode.
         * @member {String} timeAxisPosition_='start'
         * @reactive
         */
        timeAxisPosition_: 'start',
        /**
         * Internal flag to store the total amount of rendered columns.
         * Changing columnsBuffer or columnsVisible will update this value.
         * @member {Number|null} totalColumns=null
         * @protected
         */
        totalColumns: null,
        updateDepth: -1,
        /**
         * @member {Object} vdom
         */
        vdom:
        {cn: [
            {cls: ['neo-scroll-overlay']},
            {cls: ['neo-c-w-scrollcontainer'], flag: 'neo-c-w-scrollcontainer', cn: [
                {cls: ['neo-header-row'], flag: 'neo-header-row', cn: []},
                {cls: ['neo-c-w-column-timeaxis-container'], flag: 'neo-c-w-column-timeaxis-container', cn: [
                    {cls: ['neo-c-w-column-container'], flag: 'neo-c-w-column-container', style: {}, cn: []}
                ]}
            ]}
        ]},
        /**
         * 0-6 => Sun-Sat
         * Bound to the state provider.
         * @member {Number} weekStartDay_=0
         * @reactive
         */
        weekStartDay_: 0
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners([
            {dblclick: me.onEventDoubleClick, scope: me, delegate: '.neo-event'},
            {wheel   : me.onWheel,            scope: me}
        ]);

        me.timeAxis = Neo.create({
            module   : _TimeAxisComponent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            appName  : me.appName,
            parentId : me.id,
            listeners: {change: me.onTimeAxisChange, scope : me},
            windowId : me.windowId,
            ...me.timeAxisConfig
        });

        me.getColumnTimeAxisContainer().cn[me.timeAxisPosition === 'start' ? 'unshift' : 'push'](me.timeAxis.createVdomReference());

        if (me.calendarStore.getCount() > 0 && me.eventStore.getCount() > 0) {
            me.needsEventUpdate = true
        }

        me.updateHeader(true, me.needsEventUpdate);

        me.needsEventUpdate && me.updateEvents(false);

        me.headerCreated = true
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     * @param {Boolean} [silent=false]
     */
    adjustTotalHeight(data, silent=false) {
        let me                       = this,
            {rowHeight, rowsPerItem} = data,
            height                   = data.totalHeight - rowHeight,
            i                        = 0,
            gradient                 = [];

        for (; i < rowsPerItem; i++) {
            gradient.push(
                `var(--c-w-background-color) ${i * rowHeight + i}px`,
                `var(--c-w-background-color) ${(i + 1) * rowHeight + i}px`,
                'var(--c-w-border-color) 0'
            )
        }

        Object.assign(me.getColumnContainer().style, {
            backgroundImage: `linear-gradient(${gradient.join(',')})`,
            backgroundSize : `1px ${rowsPerItem * rowHeight + rowsPerItem}px`,
            height         : `${height}px`,
            maxHeight      : `${height}px`
        });

        !silent && me.update()
    }

    /**
     * Triggered after the calendarStore config got changed
     * @param {Neo.calendar.store.Calendars|null} value
     * @param {Neo.calendar.store.Calendars|null} oldValue
     * @protected
     */
    afterSetCalendarStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onCalendarStoreLoad,
            recordChange: me.onCalendarStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the columnsBuffer config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetColumnsBuffer(value, oldValue) {
        this.totalColumns = this.visibleColumns + 2 * value
    }

    /**
     * Triggered after the columnsVisible config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetColumnsVisible(value, oldValue) {
        this.totalColumns = 2 * this.columnsBuffer + value
    }

    /**
     * Triggered after the currentDate config got changed
     * @param {Date} value
     * @param {Date} oldValue
     * @protected
     */
    afterSetCurrentDate(value, oldValue) {
        let me = this;

        if (me.isConstructed) {
            me.updateHeader(false, true);
            me.updateEvents()
        }
    }

    /**
     * Triggered after the dayNameFormat config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDayNameFormat(value, oldValue) {
        let me = this;

        me.intlFormat_day = new Intl.DateTimeFormat(me.locale, {weekday: value});
        oldValue && me.updateHeader()
    }

    /**
     * Triggered after the enableDrag config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetEnableDrag(value, oldValue) {
        if (value && !this.getPlugin('calendar-week-dragdrop')) {
            Promise.all([
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_calendar_view_week_plugin_DragDrop_mjs-src_draggable_DragProxyContainer_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/DragDrop.mjs */ "./src/calendar/view/week/plugin/DragDrop.mjs")),
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_DragProxyContainer_mjs-src_plugin_Resizable_mjs"), __webpack_require__.e("src_calendar_view_week_plugin_EventResizable_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./plugin/EventResizable.mjs */ "./src/calendar/view/week/plugin/EventResizable.mjs"))
            ]).then(modules => {
                let me        = this,
                    {appName} = me,
                    plugins   = me.plugins || [];

                plugins.push({
                    module : modules[0].default,
                    appName,
                    ...me.pluginDragDropConfig
                }, {
                    module       : modules[1].default,
                    appName,
                    delegationCls: 'neo-event',
                    directions   : ['b', 't'],
                    ...me.pluginEventResizableConfig
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the eventBorder config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetEventBorder(value, oldValue) {
        let me    = this,
            {cls} = me;

        oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(cls, `neo-event-border-${oldValue}`);
        value    && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(   cls, `neo-event-border-${value}`);

        me.cls = cls
    }

    /**
     * Triggered after the eventStore config got changed
     * @param {Neo.calendar.store.Events|null} value
     * @param {Neo.calendar.store.Events|null} oldValue
     * @protected
     */
    afterSetEventStore(value, oldValue) {
        let me = this,

        listeners = {
            load        : me.onEventStoreLoad,
            recordChange: me.onEventStoreRecordChange,
            scope       : me
        };

        oldValue?.un(listeners);
        value   ?.on(listeners)
    }

    /**
     * Triggered after the locale config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetLocale(value, oldValue) {
        if (oldValue) {
            let me = this;

            me.intlFormat_day  = new Intl.DateTimeFormat(value, {weekday: me.dayNameFormat});
            me.updateHeader()
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this,
            scrollContainerId, rect;

        if (value) {
            if (me.needsEventUpdate) {
                me.updateEvents();
                me.needsEventUpdate = false
            }

            await me.timeout(100);

            rect              = await me.getDomRect(me.getColumnContainer().id);
            scrollContainerId = me.getScrollContainer().id;

            scrollContainerId && Neo.main.DomAccess.scrollBy({
                appName  : me.appName,
                direction: 'left',
                id       : scrollContainerId,
                value    : rect.width * me.columnsBuffer / me.columnsVisible / 3,
                windowId : me.windowId
            })
        }
    }

    /**
     * Triggered after the showEventEndTime config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowEventEndTime(value, oldValue) {
        oldValue !== undefined && this.updateEvents()
    }

    /**
     * Triggered after the showWeekends config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetShowWeekends(value, oldValue) {
        let me    = this,
            {cls} = me;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value ? 'add' : 'remove'](cls, 'neo-show-weekends');

        me._cls = cls; // silent update

        if (oldValue !== undefined) {
            me.updateHeader(false, true);
            me.updateEvents()
        }
    }

    /**
     * Triggered after the timeAxisPosition config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTimeAxisPosition(value, oldValue) {
        let me                = this,
            {cls}             = me,
            timeAxisContainer = me.getColumnTimeAxisContainer();

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"][value === 'end' ? 'add' : 'remove'](cls, 'neo-timeaxis-end');

        if (oldValue !== undefined) {
            timeAxisContainer.cn.unshift(timeAxisContainer.cn.pop()) // switch the order of the 2 items
        }

        me.cls = cls; // silent update
        me.update()
    }

    /**
     * Triggered after the weekStartDay config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetWeekStartDay(value, oldValue) {
        if (oldValue !== undefined) {
            this.updateHeader(false, true);
            this.updateEvents()
        }
    }

    /**
     * Triggered before the dayNameFormat config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetDayNameFormat(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dayNameFormat', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.dayNameFormats)
    }

    /**
     * Triggered before the timeAxisPosition config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetTimeAxisPosition(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'timeAxisPosition')
    }

    /**
     * Triggered before the weekStartDay config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetWeekStartDay(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'weekStartDay', _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.weekStartDays)
    }

    /**
     * @param {Date} date
     * @returns {Object}
     */
    createColumnAndHeader(date) {
        let me          = this,
            columnCls   = ['neo-c-w-column', 'neo-draggable'],
            currentDate = date.getDate(),
            currentDay  = date.getDay(),
            dateCls     = ['neo-date'],
            removeDom   = false,
            column, header;

        if (currentDay === 0 || currentDay === 6) {
            columnCls.push('neo-weekend');
            !me.showWeekends && (removeDom = true)
        }

        if (currentDate === today.day && date.getMonth() === today.month && date.getFullYear() === today.year) {
            dateCls.push('neo-today')
        }

        column = {cls: columnCls, flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date), removeDom};

        header =
        {cls: ['neo-header-row-item'], removeDom: removeDom, cn: [
            {cls: ['neo-day'], text: me.intlFormat_day.format(date)},
            {cls: dateCls,     text: currentDate}
        ]};

        return {column, header}
    }

    /**
     *
     */
    destroy(...args) {
        this.timeAxis = null;

        super.destroy(...args)
    }

    /**
     *
     */
    getColumnContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-column-container')
    }

    /**
     * @param {Date} date
     * @returns {String}
     */
    getColumnId(date) {
        return `${this.id}_col_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date)}`
    }

    /**
     * @param {Date} date
     * @returns {String}
     */
    getColumnHeaderId(date) {
        return `${this.id}_ch_${_util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date)}`
    }

    /**
     *
     */
    getColumnTimeAxisContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-column-timeaxis-container')
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getEventId(recordId) {
        return `${this.id}__${recordId}`
    }

    /**
     *
     */
    getHeaderContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-header-row')
    }

    /**
     * Used inside createId() as the default value passed to the IdGenerator.
     * @returns {String}
     */
    getIdKey() {
        return 'c-w'
    }

    /**
     *
     */
    getScrollContainer() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getByFlag(this.vdom, 'neo-c-w-scrollcontainer')
    }

    /**
     * @param {Object[]} data
     */
    onCalendarStoreLoad(data) {
        this.eventStore.getCount() > 0 && this.updateEvents()
    }

    /**
     * @param {Object} data
     */
    onCalendarStoreRecordChange(data) {
        this.updateEvents()
    }

    /**
     * @param {Object} data
     */
    onEventDoubleClick(data) {
        if (this.data.events.enableEdit) {
            let {path} = data;

            !path[0].cls.includes('neo-event') && path.shift();

            let me                 = this,
                {editEventContainer} = me.owner,
                eventNode          = path[0],
                eventVdom          = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].find(me.vdom, eventNode.id).vdom,
                record             = me.eventStore.get(eventVdom.flag),
                {style}            = editEventContainer;

            Object.assign(style, {left: `${eventNode.rect.width + 15}px`, top: eventVdom.style.top});
            editEventContainer.setSilent({parentId: path[1].id, record, style});
            editEventContainer.initVnode(true)
        }
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreLoad(data) {
        this.calendarStore.getCount() > 0 && this.updateEvents()
    }

    /**
     * @param {Object[]} data
     */
    onEventStoreRecordChange(data) {
        this.updateEvents()
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.oldPath
     * @param {Object[]} data.path
     */
    onFocusChange(data) {
        let {oldPath, path} = data;

        oldPath?.[0]?.cls.includes('neo-event') && Neo.applyDeltas(this.windowId, {id: oldPath[0].id, cls: {remove: ['neo-focus']}});
        path   ?.[0]?.cls.includes('neo-event') && Neo.applyDeltas(this.windowId, {id: path[0]   .id, cls: {add:    ['neo-focus']}})
    }

    /**
     * @param {Object} data
     * @param {Neo.component.Base} data.component
     * @param {Number} data.rowHeight
     * @param {Number} data.rowsPerItem
     * @param {Number} data.totalHeight
     */
    onTimeAxisChange(data) {
        let me = this;

        me.adjustTotalHeight(data, me.headerCreated);
        me.headerCreated && me.updateEvents()
    }

    /**
     * @param {Object} data
     */
    onWheel(data) {
        if (!this.isUpdating && Math.abs(data.deltaX) > Math.abs(data.deltaY)) {
            let me                                               = this,
                columns                                          = me.getColumnContainer(),
                {columnsBuffer, columnsVisible, firstColumnDate} = me,
                header                                           = me.getHeaderContainer(),
                i                                                = 0,
                timeAxisWidth                                    = 50,
                width                                            = data.clientWidth - timeAxisWidth,
                config, date, scrollValue;

            // console.log(data.scrollLeft, Math.round(data.scrollLeft / (data.clientWidth - timeAxisWidth) * 7));

            if (data.deltaX > 0 && Math.round(data.scrollLeft / width * columnsBuffer) > columnsBuffer + columnsVisible - 1) {
                date = new Date(columns.cn[columns.cn.length - 1].flag);

                columns.cn.splice(0, columnsBuffer);
                header .cn.splice(0, columnsBuffer);

                for (; i < columnsBuffer; i++) {
                    date.setDate(date.getDate() + 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.push(config.column);
                    header .cn.push(config.header)
                }

                firstColumnDate.setDate(firstColumnDate.getDate() + columnsBuffer);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                me.timeout(50).then(() => {me.updateEvents(false, columnsBuffer + columnsVisible, me.totalColumns)});

                scrollValue = -width
            }

            else if (data.deltaX < 0 && Math.round(data.scrollLeft / width * columnsBuffer) < 1) {
                date = new Date(columns.cn[0].flag);

                columns.cn.length = columnsBuffer + columnsVisible;
                header .cn.length = columnsBuffer + columnsVisible;

                for (; i < columnsBuffer; i++) {
                    date.setDate(date.getDate() - 1);

                    config = me.createColumnAndHeader(date);

                    columns.cn.unshift(config.column);
                    header .cn.unshift(config.header)
                }

                firstColumnDate.setDate(firstColumnDate.getDate() - columnsBuffer);

                // we need a short delay to move the event rendering into the next animation frame.
                // Details: https://github.com/neomjs/neo/issues/2216
                me.timeout(50).then(() => {me.updateEvents(false, 0, columnsBuffer)});

                scrollValue = width
            }

            if (scrollValue) {
                me.isUpdating = true;

                me.promiseUpdate().then(() => {
                    Neo.main.DomAccess.scrollBy({
                        direction: 'left',
                        id       : me.getScrollContainer().id,
                        value    : scrollValue,
                        windowId : me.windowId
                    }).then(() => {
                        me.isUpdating = false
                    })
                })
            }
        }
    }

    /**
     * @param {Date} date
     */
    setFirstColumnDate(date) {
        date.setDate(date.getDate() - date.getDay() + this.weekStartDay - this.columnsBuffer)
    }

    /**
     * The algorithm relies on the eventStore being sorted by startDate ASC
     * @param {Boolean} [silent=false]
     * @param {Number} [startIndex=0]
     * @param {Number} [endIndex=this.totalColumns]
     */
    updateEvents(silent=false, startIndex=0, endIndex=this.totalColumns) {
        let me = this;

        if (!me.mounted) {
            me.needsEventUpdate = true
        } else {
            let {calendarStore, eventStore, showEventEndTime, timeAxis, vdom} = me,
                endTime   = timeAxis.getTime(me.endTime),
                startTime = timeAxis.getTime(me.startTime),
                totalTime = endTime - startTime,
                date      = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(me.firstColumnDate),
                content   = me.getColumnContainer(),
                j         = startIndex,
                calendarRecord, column, dayRecords, duration, endDate, eventCls, eventIntervals, hasOverflow, height, i,
                len, record, recordKey, startDate, startHours, top;

            date.setDate(date.getDate() + startIndex);

            for (; j < endIndex; j++) {
                column = content.cn[j];

                column.cn = []; // remove previous events from the vdom

                dayRecords = eventStore.getDayRecords(date);
                len        = dayRecords.length;

                for (i = 0; i < len; i++) {
                    record         = dayRecords[i];
                    calendarRecord = calendarStore.get(record.calendarId);

                    if (calendarRecord?.active) {
                        endDate   = record.endDate;
                        startDate = record.startDate;

                        if (endTime <= startDate.getHours() || startTime >= endDate.getHours()) {
                            continue
                        }

                        if (endTime < endDate.getHours()) {
                            endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(endDate);
                            endDate.setHours(endTime);
                            endDate.setMinutes(0)
                        }

                        if (startTime > startDate.getHours()) {
                            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(startDate);
                            startDate.setHours(startTime);
                            startDate.setMinutes(0)
                        }

                        duration       = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                        eventCls       = ['neo-event', 'neo-draggable', `neo-${calendarRecord.color}`];
                        eventIntervals = duration * 60 / timeAxis.interval;
                        hasOverflow    = false;
                        height         = Math.round(duration / totalTime * 100 * 1000) / 1000;
                        recordKey      = record[eventStore.keyProperty];
                        startHours     = (startDate.getHours() * 60 + startDate.getMinutes()) / 60;
                        top            = Math.round((startHours - startTime) / totalTime * 100 * 1000) / 1000;

                        if (eventIntervals <= 2) {
                            hasOverflow = timeAxis.rowHeight * eventIntervals < (showEventEndTime ? 50 : 34);

                            if (hasOverflow && !(showEventEndTime && (timeAxis.rowHeight / eventIntervals >= 34))) {
                                eventCls.push('neo-overflow')
                            }
                        }

                        showEventEndTime = !(hasOverflow && eventIntervals === 1 || !showEventEndTime);

                        showEventEndTime && eventCls.push('neo-show-end-time');

                        column.cn.push({
                            cls     : eventCls,
                            flag    : recordKey,
                            id      : me.getEventId(recordKey),
                            tabIndex: -1,

                            cn: [{
                                cls : ['neo-event-time'],
                                id  : `${me.id}__time__${recordKey}`,
                                text: me.intlFormat_time.format(record.startDate)
                            }, {
                                cls : ['neo-event-title'],
                                id  : `${me.id}__title__${recordKey}`,
                                text: record.title
                            }, {
                                cls      : ['neo-event-time', 'neo-event-end-time'],
                                id       : `${me.id}__enddate__${recordKey}`,
                                removeDom: !showEventEndTime,
                                text     : me.intlFormat_time.format(record.endDate)
                            }],

                            style: {
                                height: `calc(${height}% - 2px)`,
                                top   : `calc(${top}% + 1px)`,
                                width : 'calc(100% - 1px)'
                            }
                        })
                    }
                }

                date.setDate(date.getDate() + 1)
            }

            !silent && me.update()
        }
    }

    /**
     * @param {Boolean} [create=false]
     * @param {Boolean} [silent=false]
     */
    updateHeader(create=false, silent=false) {
        let me             = this,
            {showWeekends} = me,
            date           = me.currentDate, // cloned
            content        = me.getColumnContainer(),
            header         = me.getHeaderContainer(),
            i              = 0,
            columnCls, currentDate, currentDay, dateCls, headerId, removeDom;

        me.setFirstColumnDate(date);

        me.firstColumnDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(date);

        for (; i < me.totalColumns; i++) {
            columnCls   = ['neo-c-w-column', 'neo-draggable'];
            currentDate = date.getDate();
            currentDay  = date.getDay();
            dateCls     = ['neo-date'];
            removeDom   = false;

            if (currentDay === 0 || currentDay === 6) {
                columnCls.push('neo-weekend');
                !showWeekends && (removeDom = true)
            }

            if (currentDate === today.day && date.getMonth() === today.month && date.getFullYear() === today.year) {
                dateCls.push('neo-today')
            }

            headerId = me.getColumnHeaderId(date);

            if (create) {
                content.cn.push({cls: columnCls, flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date), id: me.getColumnId(date), removeDom});

                header.cn.push(
                {cls: ['neo-header-row-item'], id: headerId, removeDom, cn: [
                    {cls: ['neo-day'], id: `${headerId}_day`,  text: me.intlFormat_day.format(date)},
                    {cls : dateCls,    id: `${headerId}_date`, text: currentDate}
                ]})
            } else {
                Object.assign(content.cn[i], {
                    cls : columnCls,
                    flag: _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].convertToyyyymmdd(date),
                    id  : me.getColumnId(date),
                    removeDom
                });

                Object.assign(header.cn[i],       {id: headerId, removeDom});
                Object.assign(header.cn[i].cn[0], {id: `${headerId}_day`, text: me.intlFormat_day.format(date)});
                Object.assign(header.cn[i].cn[1], {cls: dateCls, id: `${headerId}_date`, text: currentDate})
            }

            date.setDate(date.getDate() + 1)
        }

        !silent && me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/calendar/view/week/TimeAxisComponent.mjs"
/*!******************************************************!*\
  !*** ./src/calendar/view/week/TimeAxisComponent.mjs ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.calendar.view.week.TimeAxisComponent
 * @extends Neo.container.Base
 */
class TimeAxisComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for interval
     * @member {Number[]} intervals=[15,30,60]
     * @protected
     * @static
     */
    static intervals = [15, 30, 60]

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.TimeAxisComponent'
         * @protected
         */
        className: 'Neo.calendar.view.week.TimeAxisComponent',
        /**
         * @member {String[]} baseCls=['neo-calendar-timeaxis']
         */
        baseCls: ['neo-calendar-timeaxis'],
        /**
         * @member {Object} bind
         */
        bind: {
            endTime  : data => data.endTime,
            startTime: data => data.startTime
        },
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         * @reactive
         */
        endTime_: '24:00',
        /**
         * The time interval in minutes to display as rows.
         * Valid values: 15, 30, 60
         * @member {Number} interval_=30
         * @reactive
         */
        interval_: 30,
        /**
         * @member {Number} rowHeight_=20
         * @reactive
         */
        rowHeight_: 20,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         * @reactive
         */
        startTime_: '00:00',
        /**
         * @member {Object} vdom
         */
        vdom:
        {style: {}}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.createItems();
        me.afterSetRowHeight(me.rowHeight, 0)
    }

    /**
     * Triggered after the endTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetEndTime(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            // todo: handle 24:00 as 23:59
            if (!value) {
                me._endTime = '24:00'
            }

            me.afterSetRowHeight(me.rowHeight, 0)
        }
    }

    /**
     * Triggered after the interval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetInterval(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0)
        }
    }

    /**
     * Triggered after the rowHeight config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetRowHeight(value, oldValue) {
        if (oldValue !== undefined && this.vdom.cn) {
            let me                = this,
                endTime           = me.getTime(me.endTime),
                startTime         = me.getTime(me.startTime),
                {rowHeight, vdom} = me,
                rowsPerItem       = me.getRowsPerItem(),
                itemHeight        = rowsPerItem * rowHeight + rowsPerItem, // rowsPerItem * 1px borders
                totalHeight       = rowHeight + ((endTime - startTime) * itemHeight),
                i, itemStyle;

            Object.assign(vdom.style, {
                backgroundImage    : `linear-gradient(var(--c-w-background-color) ${itemHeight - 1}px, var(--c-w-border-color) 1px)`,
                backgroundPositionY: `${-itemHeight + 1}px`,
                backgroundSize     : `0.4em ${itemHeight}px`,
                height             : `${totalHeight - rowHeight + 1}px`,
                maxHeight          : `${totalHeight - rowHeight + 1}px`
            });

            for (i=0; i < 25; i++) {
                itemStyle = {
                    height: `${itemHeight}px`
                };

                if (i === startTime) {
                    itemStyle.marginTop = `${-2 - rowHeight * (rowsPerItem === 1 ? 0.5 : rowsPerItem === 2 ? 1 : 2)}px`
                } else {
                    delete itemStyle.marginTop
                }

                vdom.cn[i].style = itemStyle;

                vdom.cn[i].removeDom = (i < startTime || i - 1 >= endTime);
            }

            me.fire('change', {
                component: me,
                rowHeight,
                rowsPerItem,
                totalHeight
            })
        }
    }

    /**
     * Triggered after the startTime config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetStartTime(value, oldValue) {
        if (oldValue !== undefined) {
            this.afterSetRowHeight(this.rowHeight, 0)
        }
    }

    /**
     * Triggered before the interval config gets changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    beforeSetInterval(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'interval')
    }

    /**
     *
     */
    createItems() {
        let {vdom} = this,
            text, i;

        vdom.cn = [];

        for (i=0; i < 25; i++) {
            text = i === 24 ? '00:00' : (i < 10 ? '0' : '') + i + ':00';

            vdom.cn.push({
                cls: ['neo-c-w-timeaxis-item'],
                cn : [{text}]
            })
        }
    }

    /**
     * Calculates the amount of rows related to the interval config
     * @returns {Number}
     */
    getRowsPerItem() {
        let {interval} = this;
        return interval === 60 ? 1 : interval === 30 ? 2 : 4
    }

    /**
     * Calculates the time for the end- or startTime
     * @param {String} value
     * @returns {Number}
     */
    getTime(value) {
        return value.split(':').map(Number)[0]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TimeAxisComponent));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X3dlZWtfQ29tcG9uZW50X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTREO0FBQ0w7QUFDQztBQUNBO0FBQ0Q7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQWE7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWE7QUFDYixpQkFBaUIsd0RBQXdEO0FBQ3pFLGlCQUFpQjtBQUNqQixxQkFBcUIsOEVBQThFO0FBQ25HO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxtRUFBbUU7QUFDaEYsYUFBYTtBQUNiOztBQUVBO0FBQ0EsdUJBQXVCLDhEQUFpQjtBQUN4QztBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBOztBQUVBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0EsK0NBQStDLGtCQUFrQjtBQUNqRSwrQ0FBK0Msd0JBQXdCO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxtQkFBbUI7QUFDbkUsb0NBQW9DLHNDQUFzQztBQUMxRSxnQ0FBZ0MsT0FBTztBQUN2QyxnQ0FBZ0MsT0FBTztBQUN2QyxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xELGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRSxlQUFlO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0VUFBK0I7QUFDL0MsZ0JBQWdCLGlaQUFxQztBQUNyRDtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSzs7QUFFbEIsb0JBQW9CLHVEQUFRLGlDQUFpQyxTQUFTO0FBQ3RFLG9CQUFvQix1REFBUSxpQ0FBaUMsTUFBTTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0MsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUUsMEJBQTBCO0FBQzNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLOztBQUVsQixRQUFRLHVEQUFROztBQUVoQix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5Qjs7QUFFQSxRQUFRLHVEQUFROztBQUVoQjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsc0RBQVE7QUFDakY7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usc0RBQVE7QUFDaEY7O0FBRUE7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQixzREFBUTs7QUFFaEQ7QUFDQSxTQUFTO0FBQ1QsYUFBYSx1REFBdUQ7QUFDcEUsYUFBYTtBQUNiOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVEsT0FBTyxzREFBUSx5QkFBeUI7QUFDbEU7O0FBRUE7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxNQUFNLHNEQUFRLHlCQUF5QjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQVE7QUFDdkI7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxJQUFJLFNBQVM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNOztBQUV2Qjs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQSxxQ0FBcUMsc0RBQVE7QUFDN0M7QUFDQSxpQkFBaUIsa0JBQWtCOztBQUVuQyxrQ0FBa0MsU0FBUywwQkFBMEIsOEJBQThCO0FBQ25HLDBDQUEwQyxvQ0FBb0M7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBLGFBQWEsZUFBZTs7QUFFNUIsbUZBQW1GLHlCQUF5Qix1QkFBdUI7QUFDbkksbUZBQW1GLHlCQUF5Qix1QkFBdUI7QUFDbkk7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFnRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsbUJBQW1CO0FBQzFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLHdFQUF3RTs7QUFFbkg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLG1CQUFtQjtBQUMxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyx5Q0FBeUM7O0FBRXBGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaUJBQWlCLDZEQUE2RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxzREFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0Msc0RBQVE7QUFDaEQ7QUFDQTtBQUNBOztBQUVBLGlGQUFpRjtBQUNqRiwrRUFBK0UscUJBQXFCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxNQUFNLFVBQVUsVUFBVTtBQUNuRTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlDQUF5QyxNQUFNLFdBQVcsVUFBVTtBQUNwRTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhDQUE4QyxNQUFNLGFBQWEsVUFBVTtBQUMzRTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZELGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCLHNEQUFROztBQUVyQyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQyxzQkFBc0Isc0RBQVEsOERBQThEOztBQUU3SDtBQUNBLGlCQUFpQjtBQUNqQixxQkFBcUIseUJBQXlCLFNBQVMsNkNBQTZDO0FBQ3BHLHFCQUFxQix5QkFBeUIsU0FBUztBQUN2RCxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQVE7QUFDbEM7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakIsbURBQW1ELHdCQUF3QjtBQUMzRSxtREFBbUQsT0FBTyxTQUFTLDRDQUE0QztBQUMvRyxtREFBbUQscUJBQXFCLFNBQVMsMEJBQTBCO0FBQzNHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHlCQUF5QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDeC9CVzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQVM7QUFDekM7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0ZBQW9GLGVBQWU7QUFDbkcsd0NBQXdDLGdCQUFnQjtBQUN4RCw4Q0FBOEMsV0FBVztBQUN6RCx3Q0FBd0MsNEJBQTRCO0FBQ3BFLHdDQUF3Qyw0QkFBNEI7QUFDcEUsYUFBYTs7QUFFYixzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLCtCQUErQixXQUFXO0FBQzFDOztBQUVBO0FBQ0EsNkNBQTZDLHVFQUF1RTtBQUNwSCxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGlDQUFpQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L3dlZWsvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9UaW1lQXhpc0NvbXBvbmVudC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VDb21wb25lbnQgICAgIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5pbXBvcnQgRGF0ZVV0aWwgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFRpbWVBeGlzQ29tcG9uZW50IGZyb20gJy4vVGltZUF4aXNDb21wb25lbnQubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICBmcm9tICcuLi8uLi8uLi91dGlsL1ZEb20ubWpzJztcblxuY29uc3QgdG9kYXlEYXRlID0gbmV3IERhdGUoKTtcblxuY29uc3QgdG9kYXkgPSB7XG4gICAgZGF5ICA6IHRvZGF5RGF0ZS5nZXREYXRlKCksXG4gICAgbW9udGg6IHRvZGF5RGF0ZS5nZXRNb250aCgpLFxuICAgIHllYXIgOiB0b2RheURhdGUuZ2V0RnVsbFllYXIoKVxufTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5Db21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIHRpbWVBeGlzUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdGltZUF4aXNQb3NpdGlvbnM9WydlbmQnLCdzdGFydCddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdGltZUF4aXNQb3NpdGlvbnMgPSBbJ2VuZCcsICdzdGFydCddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LndlZWsuQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy53ZWVrLkNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhci13ZWVrY29tcG9uZW50J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFyLXdlZWtjb21wb25lbnQnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZSAgICAgICA6ICdzdG9yZXMuY2FsZW5kYXJzJyxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlICAgICAgICAgOiBkYXRhID0+IGRhdGEuY3VycmVudERhdGUsXG4gICAgICAgICAgICBlbmFibGVEcmFnICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmV2ZW50cy5lbmFibGVEcmFnLFxuICAgICAgICAgICAgZW5kVGltZSAgICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5lbmRUaW1lLFxuICAgICAgICAgICAgZXZlbnRCb3JkZXIgICAgICAgICA6IGRhdGEgPT4gZGF0YS5ldmVudHMuYm9yZGVyLFxuICAgICAgICAgICAgZXZlbnRTdG9yZSAgICAgICAgICA6ICdzdG9yZXMuZXZlbnRzJyxcbiAgICAgICAgICAgIGludGxGb3JtYXRfdGltZSAgICAgOiBkYXRhID0+IGRhdGEudGltZUZvcm1hdHRlcixcbiAgICAgICAgICAgIGxvY2FsZSAgICAgICAgICAgICAgOiBkYXRhID0+IGRhdGEubG9jYWxlLFxuICAgICAgICAgICAgbWluaW11bUV2ZW50RHVyYXRpb246IGRhdGEgPT4gZGF0YS5taW5pbXVtRXZlbnREdXJhdGlvbixcbiAgICAgICAgICAgIHNob3dXZWVrZW5kcyAgICAgICAgOiBkYXRhID0+IGRhdGEuc2hvd1dlZWtlbmRzLFxuICAgICAgICAgICAgc3RhcnRUaW1lICAgICAgICAgICA6IGRhdGEgPT4gZGF0YS5zdGFydFRpbWUsXG4gICAgICAgICAgICB3ZWVrU3RhcnREYXkgICAgICAgIDogZGF0YSA9PiBkYXRhLndlZWtTdGFydERheVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gY2FsZW5kYXJTdG9yZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyU3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW1vdW50IG9mIGhpZGRlbiBjb2x1bW5zIG9uIGJvdGggc2lkZXMgZWFjaCBpbnNpZGUgdGhpcyB2aWV3LlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtbnNCdWZmZXJfPTdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5zQnVmZmVyXzogNyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFtb3VudCBvZiB2aXNpYmxlIGNvbHVtbnMgaW5zaWRlIHRoaXMgdmlldy5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjb2x1bW5zVmlzaWJsZV89N1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbHVtbnNWaXNpYmxlXzogNyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBjdXJyZW50RGF0ZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudERhdGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvcm1hdCBvZiB0aGUgY29sdW1uIGhlYWRlcnMuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlcyBhcmU6IG5hcnJvdywgc2hvcnQgJiBsb25nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGF5TmFtZUZvcm1hdF89J3Nob3J0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRheU5hbWVGb3JtYXRfOiAnc2hvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVEcmFnXz10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGVEcmFnXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlclxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZXZlbnRCb3JkZXJfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBldmVudEJvcmRlcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy53ZWVrLkV2ZW50RHJhZ1pvbmV8bnVsbH0gZXZlbnREcmFnWm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBldmVudERyYWdab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci5zdG9yZS5FdmVudHN8bnVsbH0gZXZlbnRTdG9yZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50U3RvcmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBnZXQgcGFzc2VkIGZyb20gdXBkYXRlSGVhZGVyKClcbiAgICAgICAgICogQG1lbWJlciB7RGF0ZXxudWxsfSBmaXJzdENvbHVtbkRhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBmaXJzdENvbHVtbkRhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHRvIGNoZWNrIGlmIHVwZGF0ZUhlYWRlcih0cnVlKSBoYXMgYWxyZWFkeSBydW5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGVhZGVyQ3JlYXRlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJDcmVhdGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0ludGwuRGF0ZVRpbWVGb3JtYXR8bnVsbH0gaW50bEZvcm1hdF9kYXk9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRsRm9ybWF0X2RheTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSBpbnRsRm9ybWF0X3RpbWVfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGludGxGb3JtYXRfdGltZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1VwZGF0aW5nPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzVXBkYXRpbmc6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGxvY2FsZV89TmVvLmNvbmZpZy5sb2NhbGVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhbGVfOiBOZW8uY29uZmlnLmxvY2FsZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWUgaW4gbWludXRlcy4gQm91bmQgdG8gdGhlIHN0YXRlIHByb3ZpZGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbmltdW1FdmVudER1cmF0aW9uPTMwXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1pbmltdW1FdmVudER1cmF0aW9uOiAzMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgdG8gc3RvcmUgaWYgdXBkYXRlRXZlbnRzKCkgZ290IGNhbGxlZCB3aGlsZSBub3QgYmVpbmcgbW91bnRlZFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBuZWVkc0V2ZW50VXBkYXRlPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5lZWRzRXZlbnRVcGRhdGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lcnxudWxsfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogY29uZmlnIHZhbHVlcyBmb3IgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5wbHVnaW4uRHJhZ0Ryb3BcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBwbHVnaW5EcmFnRHJvcENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBwbHVnaW5EcmFnRHJvcENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbmZpZyB2YWx1ZXMgZm9yIE5lby5jYWxlbmRhci52aWV3LndlZWsucGx1Z2luLkV2ZW50UmVzaXphYmxlXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcGx1Z2luUmVzaXphYmxlQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBsdWdpbkV2ZW50UmVzaXphYmxlQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0V2ZW50RW5kVGltZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93RXZlbnRFbmRUaW1lXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3VuZCB0byB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dXZWVrZW5kc189dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dXZWVrZW5kc186IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHRpbWVBeGlzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRpbWVBeGlzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB0aW1lQXhpc0NvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lQXhpc0NvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc2l0aW9uIHRoZSB0aW1lQXhpcyBhdCB0aGUgbGVmdCBvciByaWdodCBzaWRlLlxuICAgICAgICAgKiBWYWxpZCB2YWx1ZXMgYXJlIHN0YXJ0ICYgZW5kLlxuICAgICAgICAgKiBzdGFydCA9PiBsZWZ0LCBlbmQgPT4gcmlnaHQgaW4gTFRSIG1vZGUuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdGltZUF4aXNQb3NpdGlvbl89J3N0YXJ0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRpbWVBeGlzUG9zaXRpb25fOiAnc3RhcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB0byBzdG9yZSB0aGUgdG90YWwgYW1vdW50IG9mIHJlbmRlcmVkIGNvbHVtbnMuXG4gICAgICAgICAqIENoYW5naW5nIGNvbHVtbnNCdWZmZXIgb3IgY29sdW1uc1Zpc2libGUgd2lsbCB1cGRhdGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHRvdGFsQ29sdW1ucz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRvdGFsQ29sdW1uczogbnVsbCxcbiAgICAgICAgdXBkYXRlRGVwdGg6IC0xLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tXG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLXNjcm9sbC1vdmVybGF5J119LFxuICAgICAgICAgICAge2NsczogWyduZW8tYy13LXNjcm9sbGNvbnRhaW5lciddLCBmbGFnOiAnbmVvLWMtdy1zY3JvbGxjb250YWluZXInLCBjbjogW1xuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWhlYWRlci1yb3cnXSwgZmxhZzogJ25lby1oZWFkZXItcm93JywgY246IFtdfSxcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1jLXctY29sdW1uLXRpbWVheGlzLWNvbnRhaW5lciddLCBmbGFnOiAnbmVvLWMtdy1jb2x1bW4tdGltZWF4aXMtY29udGFpbmVyJywgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tYy13LWNvbHVtbi1jb250YWluZXInXSwgZmxhZzogJ25lby1jLXctY29sdW1uLWNvbnRhaW5lcicsIHN0eWxlOiB7fSwgY246IFtdfVxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAtNiA9PiBTdW4tU2F0XG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB3ZWVrU3RhcnREYXlfPTBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3ZWVrU3RhcnREYXlfOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAge2RibGNsaWNrOiBtZS5vbkV2ZW50RG91YmxlQ2xpY2ssIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLWV2ZW50J30sXG4gICAgICAgICAgICB7d2hlZWwgICA6IG1lLm9uV2hlZWwsICAgICAgICAgICAgc2NvcGU6IG1lfVxuICAgICAgICBdKTtcblxuICAgICAgICBtZS50aW1lQXhpcyA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBUaW1lQXhpc0NvbXBvbmVudCxcbiAgICAgICAgICAgIGFwcE5hbWUgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIHBhcmVudElkIDogbWUuaWQsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uVGltZUF4aXNDaGFuZ2UsIHNjb3BlIDogbWV9LFxuICAgICAgICAgICAgd2luZG93SWQgOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgIC4uLm1lLnRpbWVBeGlzQ29uZmlnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmdldENvbHVtblRpbWVBeGlzQ29udGFpbmVyKCkuY25bbWUudGltZUF4aXNQb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10obWUudGltZUF4aXMuY3JlYXRlVmRvbVJlZmVyZW5jZSgpKTtcblxuICAgICAgICBpZiAobWUuY2FsZW5kYXJTdG9yZS5nZXRDb3VudCgpID4gMCAmJiBtZS5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBtZS5uZWVkc0V2ZW50VXBkYXRlID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlSGVhZGVyKHRydWUsIG1lLm5lZWRzRXZlbnRVcGRhdGUpO1xuXG4gICAgICAgIG1lLm5lZWRzRXZlbnRVcGRhdGUgJiYgbWUudXBkYXRlRXZlbnRzKGZhbHNlKTtcblxuICAgICAgICBtZS5oZWFkZXJDcmVhdGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93SGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93c1Blckl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS50b3RhbEhlaWdodFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKi9cbiAgICBhZGp1c3RUb3RhbEhlaWdodChkYXRhLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cm93SGVpZ2h0LCByb3dzUGVySXRlbX0gPSBkYXRhLFxuICAgICAgICAgICAgaGVpZ2h0ICAgICAgICAgICAgICAgICAgID0gZGF0YS50b3RhbEhlaWdodCAtIHJvd0hlaWdodCxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBncmFkaWVudCAgICAgICAgICAgICAgICAgPSBbXTtcblxuICAgICAgICBmb3IgKDsgaSA8IHJvd3NQZXJJdGVtOyBpKyspIHtcbiAgICAgICAgICAgIGdyYWRpZW50LnB1c2goXG4gICAgICAgICAgICAgICAgYHZhcigtLWMtdy1iYWNrZ3JvdW5kLWNvbG9yKSAke2kgKiByb3dIZWlnaHQgKyBpfXB4YCxcbiAgICAgICAgICAgICAgICBgdmFyKC0tYy13LWJhY2tncm91bmQtY29sb3IpICR7KGkgKyAxKSAqIHJvd0hlaWdodCArIGl9cHhgLFxuICAgICAgICAgICAgICAgICd2YXIoLS1jLXctYm9yZGVyLWNvbG9yKSAwJ1xuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZS5nZXRDb2x1bW5Db250YWluZXIoKS5zdHlsZSwge1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgbGluZWFyLWdyYWRpZW50KCR7Z3JhZGllbnQuam9pbignLCcpfSlgLFxuICAgICAgICAgICAgYmFja2dyb3VuZFNpemUgOiBgMXB4ICR7cm93c1Blckl0ZW0gKiByb3dIZWlnaHQgKyByb3dzUGVySXRlbX1weGAsXG4gICAgICAgICAgICBoZWlnaHQgICAgICAgICA6IGAke2hlaWdodH1weGAsXG4gICAgICAgICAgICBtYXhIZWlnaHQgICAgICA6IGAke2hlaWdodH1weGBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgIXNpbGVudCAmJiBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2FsZW5kYXJTdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5DYWxlbmRhcnN8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDYWxlbmRhclN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25DYWxlbmRhclN0b3JlTG9hZCxcbiAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25DYWxlbmRhclN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9O1xuXG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY29sdW1uc0J1ZmZlciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDb2x1bW5zQnVmZmVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnRvdGFsQ29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnMgKyAyICogdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNvbHVtbnNWaXNpYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbHVtbnNWaXNpYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnRvdGFsQ29sdW1ucyA9IDIgKiB0aGlzLmNvbHVtbnNCdWZmZXIgKyB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY3VycmVudERhdGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtEYXRlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDdXJyZW50RGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUudXBkYXRlSGVhZGVyKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUV2ZW50cygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRheU5hbWVGb3JtYXQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGF5TmFtZUZvcm1hdCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pbnRsRm9ybWF0X2RheSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KG1lLmxvY2FsZSwge3dlZWtkYXk6IHZhbHVlfSk7XG4gICAgICAgIG9sZFZhbHVlICYmIG1lLnVwZGF0ZUhlYWRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBlbmFibGVEcmFnIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RW5hYmxlRHJhZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmdldFBsdWdpbignY2FsZW5kYXItd2Vlay1kcmFnZHJvcCcpKSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgaW1wb3J0KCcuL3BsdWdpbi9EcmFnRHJvcC5tanMnKSxcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4vcGx1Z2luL0V2ZW50UmVzaXphYmxlLm1qcycpXG4gICAgICAgICAgICBdKS50aGVuKG1vZHVsZXMgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB7YXBwTmFtZX0gPSBtZSxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2lucyAgID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSA6IG1vZHVsZXNbMF0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgLi4ubWUucGx1Z2luRHJhZ0Ryb3BDb25maWdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IG1vZHVsZXNbMV0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGlvbkNsczogJ25lby1ldmVudCcsXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMgICA6IFsnYicsICd0J10sXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLnBsdWdpbkV2ZW50UmVzaXphYmxlQ29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS5wbHVnaW5zID0gcGx1Z2luc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRCb3JkZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEV2ZW50Qm9yZGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZTtcblxuICAgICAgICBvbGRWYWx1ZSAmJiBOZW9BcnJheS5yZW1vdmUoY2xzLCBgbmVvLWV2ZW50LWJvcmRlci0ke29sZFZhbHVlfWApO1xuICAgICAgICB2YWx1ZSAgICAmJiBOZW9BcnJheS5hZGQoICAgY2xzLCBgbmVvLWV2ZW50LWJvcmRlci0ke3ZhbHVlfWApO1xuXG4gICAgICAgIG1lLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXZlbnRTdG9yZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5FdmVudHN8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5zdG9yZS5FdmVudHN8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFdmVudFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGxvYWQgICAgICAgIDogbWUub25FdmVudFN0b3JlTG9hZCxcbiAgICAgICAgICAgIHJlY29yZENoYW5nZTogbWUub25FdmVudFN0b3JlUmVjb3JkQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9O1xuXG4gICAgICAgIG9sZFZhbHVlPy51bihsaXN0ZW5lcnMpO1xuICAgICAgICB2YWx1ZSAgID8ub24obGlzdGVuZXJzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbG9jYWxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldExvY2FsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5pbnRsRm9ybWF0X2RheSAgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh2YWx1ZSwge3dlZWtkYXk6IG1lLmRheU5hbWVGb3JtYXR9KTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZUhlYWRlcigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQsIHJlY3Q7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWUubmVlZHNFdmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUV2ZW50cygpO1xuICAgICAgICAgICAgICAgIG1lLm5lZWRzRXZlbnRVcGRhdGUgPSBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDEwMCk7XG5cbiAgICAgICAgICAgIHJlY3QgICAgICAgICAgICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChtZS5nZXRDb2x1bW5Db250YWluZXIoKS5pZCk7XG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXJJZCA9IG1lLmdldFNjcm9sbENvbnRhaW5lcigpLmlkO1xuXG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXJJZCAmJiBOZW8ubWFpbi5Eb21BY2Nlc3Muc2Nyb2xsQnkoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWUgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IHNjcm9sbENvbnRhaW5lcklkLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgIDogcmVjdC53aWR0aCAqIG1lLmNvbHVtbnNCdWZmZXIgLyBtZS5jb2x1bW5zVmlzaWJsZSAvIDMsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd0V2ZW50RW5kVGltZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNob3dFdmVudEVuZFRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cGRhdGVFdmVudHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2hvd1dlZWtlbmRzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2hvd1dlZWtlbmRzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gPSBtZTtcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1zaG93LXdlZWtlbmRzJyk7XG5cbiAgICAgICAgbWUuX2NscyA9IGNsczsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVIZWFkZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlRXZlbnRzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGltZUF4aXNQb3NpdGlvbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUaW1lQXhpc1Bvc2l0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gICAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIHRpbWVBeGlzQ29udGFpbmVyID0gbWUuZ2V0Q29sdW1uVGltZUF4aXNDb250YWluZXIoKTtcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA9PT0gJ2VuZCcgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tdGltZWF4aXMtZW5kJyk7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVBeGlzQ29udGFpbmVyLmNuLnVuc2hpZnQodGltZUF4aXNDb250YWluZXIuY24ucG9wKCkpIC8vIHN3aXRjaCB0aGUgb3JkZXIgb2YgdGhlIDIgaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNscyA9IGNsczsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2Vla1N0YXJ0RGF5IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdlZWtTdGFydERheSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSGVhZGVyKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXZlbnRzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRheU5hbWVGb3JtYXQgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREYXlOYW1lRm9ybWF0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZGF5TmFtZUZvcm1hdCcsIERhdGVVdGlsLnByb3RvdHlwZS5kYXlOYW1lRm9ybWF0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB0aW1lQXhpc1Bvc2l0aW9uIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VGltZUF4aXNQb3NpdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3RpbWVBeGlzUG9zaXRpb24nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHdlZWtTdGFydERheSBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFdlZWtTdGFydERheSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ3dlZWtTdGFydERheScsIERhdGVVdGlsLnByb3RvdHlwZS53ZWVrU3RhcnREYXlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlQ29sdW1uQW5kSGVhZGVyKGRhdGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbHVtbkNscyAgID0gWyduZW8tYy13LWNvbHVtbicsICduZW8tZHJhZ2dhYmxlJ10sXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgICAgY3VycmVudERheSAgPSBkYXRlLmdldERheSgpLFxuICAgICAgICAgICAgZGF0ZUNscyAgICAgPSBbJ25lby1kYXRlJ10sXG4gICAgICAgICAgICByZW1vdmVEb20gICA9IGZhbHNlLFxuICAgICAgICAgICAgY29sdW1uLCBoZWFkZXI7XG5cbiAgICAgICAgaWYgKGN1cnJlbnREYXkgPT09IDAgfHwgY3VycmVudERheSA9PT0gNikge1xuICAgICAgICAgICAgY29sdW1uQ2xzLnB1c2goJ25lby13ZWVrZW5kJyk7XG4gICAgICAgICAgICAhbWUuc2hvd1dlZWtlbmRzICYmIChyZW1vdmVEb20gPSB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnREYXRlID09PSB0b2RheS5kYXkgJiYgZGF0ZS5nZXRNb250aCgpID09PSB0b2RheS5tb250aCAmJiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHRvZGF5LnllYXIpIHtcbiAgICAgICAgICAgIGRhdGVDbHMucHVzaCgnbmVvLXRvZGF5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbHVtbiA9IHtjbHM6IGNvbHVtbkNscywgZmxhZzogRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSksIHJlbW92ZURvbX07XG5cbiAgICAgICAgaGVhZGVyID1cbiAgICAgICAge2NsczogWyduZW8taGVhZGVyLXJvdy1pdGVtJ10sIHJlbW92ZURvbTogcmVtb3ZlRG9tLCBjbjogW1xuICAgICAgICAgICAge2NsczogWyduZW8tZGF5J10sIHRleHQ6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKX0sXG4gICAgICAgICAgICB7Y2xzOiBkYXRlQ2xzLCAgICAgdGV4dDogY3VycmVudERhdGV9XG4gICAgICAgIF19O1xuXG4gICAgICAgIHJldHVybiB7Y29sdW1uLCBoZWFkZXJ9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy50aW1lQXhpcyA9IG51bGw7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZ2V0QnlGbGFnKHRoaXMudmRvbSwgJ25lby1jLXctY29sdW1uLWNvbnRhaW5lcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5JZChkYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9jb2xfJHtEYXRlVXRpbC5jb252ZXJ0VG95eXl5bW1kZChkYXRlKX1gXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5IZWFkZXJJZChkYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9jaF8ke0RhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldENvbHVtblRpbWVBeGlzQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZ2V0QnlGbGFnKHRoaXMudmRvbSwgJ25lby1jLXctY29sdW1uLXRpbWVheGlzLWNvbnRhaW5lcicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0RXZlbnRJZChyZWNvcmRJZCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fXyR7cmVjb3JkSWR9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZ2V0QnlGbGFnKHRoaXMudmRvbSwgJ25lby1oZWFkZXItcm93JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGluc2lkZSBjcmVhdGVJZCgpIGFzIHRoZSBkZWZhdWx0IHZhbHVlIHBhc3NlZCB0byB0aGUgSWRHZW5lcmF0b3IuXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRJZEtleSgpIHtcbiAgICAgICAgcmV0dXJuICdjLXcnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRTY3JvbGxDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5nZXRCeUZsYWcodGhpcy52ZG9tLCAnbmVvLWMtdy1zY3JvbGxjb250YWluZXInKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkNhbGVuZGFyU3RvcmVMb2FkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudFN0b3JlLmdldENvdW50KCkgPiAwICYmIHRoaXMudXBkYXRlRXZlbnRzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2FsZW5kYXJTdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXZlbnRzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnREb3VibGVDbGljayhkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZXZlbnRzLmVuYWJsZUVkaXQpIHtcbiAgICAgICAgICAgIGxldCB7cGF0aH0gPSBkYXRhO1xuXG4gICAgICAgICAgICAhcGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1ldmVudCcpICYmIHBhdGguc2hpZnQoKTtcblxuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2VkaXRFdmVudENvbnRhaW5lcn0gPSBtZS5vd25lcixcbiAgICAgICAgICAgICAgICBldmVudE5vZGUgICAgICAgICAgPSBwYXRoWzBdLFxuICAgICAgICAgICAgICAgIGV2ZW50VmRvbSAgICAgICAgICA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgZXZlbnROb2RlLmlkKS52ZG9tLFxuICAgICAgICAgICAgICAgIHJlY29yZCAgICAgICAgICAgICA9IG1lLmV2ZW50U3RvcmUuZ2V0KGV2ZW50VmRvbS5mbGFnKSxcbiAgICAgICAgICAgICAgICB7c3R5bGV9ICAgICAgICAgICAgPSBlZGl0RXZlbnRDb250YWluZXI7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHtsZWZ0OiBgJHtldmVudE5vZGUucmVjdC53aWR0aCArIDE1fXB4YCwgdG9wOiBldmVudFZkb20uc3R5bGUudG9wfSk7XG4gICAgICAgICAgICBlZGl0RXZlbnRDb250YWluZXIuc2V0U2lsZW50KHtwYXJlbnRJZDogcGF0aFsxXS5pZCwgcmVjb3JkLCBzdHlsZX0pO1xuICAgICAgICAgICAgZWRpdEV2ZW50Q29udGFpbmVyLmluaXRWbm9kZSh0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnRTdG9yZUxvYWQoZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RvcmUuZ2V0Q291bnQoKSA+IDAgJiYgdGhpcy51cGRhdGVFdmVudHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50U3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnBhdGhcbiAgICAgKi9cbiAgICBvbkZvY3VzQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IHtvbGRQYXRoLCBwYXRofSA9IGRhdGE7XG5cbiAgICAgICAgb2xkUGF0aD8uWzBdPy5jbHMuaW5jbHVkZXMoJ25lby1ldmVudCcpICYmIE5lby5hcHBseURlbHRhcyh0aGlzLndpbmRvd0lkLCB7aWQ6IG9sZFBhdGhbMF0uaWQsIGNsczoge3JlbW92ZTogWyduZW8tZm9jdXMnXX19KTtcbiAgICAgICAgcGF0aCAgID8uWzBdPy5jbHMuaW5jbHVkZXMoJ25lby1ldmVudCcpICYmIE5lby5hcHBseURlbHRhcyh0aGlzLndpbmRvd0lkLCB7aWQ6IHBhdGhbMF0gICAuaWQsIGNsczoge2FkZDogICAgWyduZW8tZm9jdXMnXX19KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93SGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEucm93c1Blckl0ZW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS50b3RhbEhlaWdodFxuICAgICAqL1xuICAgIG9uVGltZUF4aXNDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmFkanVzdFRvdGFsSGVpZ2h0KGRhdGEsIG1lLmhlYWRlckNyZWF0ZWQpO1xuICAgICAgICBtZS5oZWFkZXJDcmVhdGVkICYmIG1lLnVwZGF0ZUV2ZW50cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbldoZWVsKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRpbmcgJiYgTWF0aC5hYnMoZGF0YS5kZWx0YVgpID4gTWF0aC5hYnMoZGF0YS5kZWx0YVkpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBjb2x1bW5zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXRDb2x1bW5Db250YWluZXIoKSxcbiAgICAgICAgICAgICAgICB7Y29sdW1uc0J1ZmZlciwgY29sdW1uc1Zpc2libGUsIGZpcnN0Q29sdW1uRGF0ZX0gPSBtZSxcbiAgICAgICAgICAgICAgICBoZWFkZXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBtZS5nZXRIZWFkZXJDb250YWluZXIoKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIHRpbWVBeGlzV2lkdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDUwLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IGRhdGEuY2xpZW50V2lkdGggLSB0aW1lQXhpc1dpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZywgZGF0ZSwgc2Nyb2xsVmFsdWU7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEuc2Nyb2xsTGVmdCwgTWF0aC5yb3VuZChkYXRhLnNjcm9sbExlZnQgLyAoZGF0YS5jbGllbnRXaWR0aCAtIHRpbWVBeGlzV2lkdGgpICogNykpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5kZWx0YVggPiAwICYmIE1hdGgucm91bmQoZGF0YS5zY3JvbGxMZWZ0IC8gd2lkdGggKiBjb2x1bW5zQnVmZmVyKSA+IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZSAtIDEpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoY29sdW1ucy5jbltjb2x1bW5zLmNuLmxlbmd0aCAtIDFdLmZsYWcpO1xuXG4gICAgICAgICAgICAgICAgY29sdW1ucy5jbi5zcGxpY2UoMCwgY29sdW1uc0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgaGVhZGVyIC5jbi5zcGxpY2UoMCwgY29sdW1uc0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvbHVtbnNCdWZmZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBtZS5jcmVhdGVDb2x1bW5BbmRIZWFkZXIoZGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5jbi5wdXNoKGNvbmZpZy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLnB1c2goY29uZmlnLmhlYWRlcilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJzdENvbHVtbkRhdGUuc2V0RGF0ZShmaXJzdENvbHVtbkRhdGUuZ2V0RGF0ZSgpICsgY29sdW1uc0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGEgc2hvcnQgZGVsYXkgdG8gbW92ZSB0aGUgZXZlbnQgcmVuZGVyaW5nIGludG8gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAgICAgICAgICAgIC8vIERldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMjE2XG4gICAgICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7bWUudXBkYXRlRXZlbnRzKGZhbHNlLCBjb2x1bW5zQnVmZmVyICsgY29sdW1uc1Zpc2libGUsIG1lLnRvdGFsQ29sdW1ucyl9KTtcblxuICAgICAgICAgICAgICAgIHNjcm9sbFZhbHVlID0gLXdpZHRoXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuZGVsdGFYIDwgMCAmJiBNYXRoLnJvdW5kKGRhdGEuc2Nyb2xsTGVmdCAvIHdpZHRoICogY29sdW1uc0J1ZmZlcikgPCAxKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGNvbHVtbnMuY25bMF0uZmxhZyk7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLmxlbmd0aCA9IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZTtcbiAgICAgICAgICAgICAgICBoZWFkZXIgLmNuLmxlbmd0aCA9IGNvbHVtbnNCdWZmZXIgKyBjb2x1bW5zVmlzaWJsZTtcblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY29sdW1uc0J1ZmZlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lLmNyZWF0ZUNvbHVtbkFuZEhlYWRlcihkYXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLmNuLnVuc2hpZnQoY29uZmlnLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciAuY24udW5zaGlmdChjb25maWcuaGVhZGVyKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpcnN0Q29sdW1uRGF0ZS5zZXREYXRlKGZpcnN0Q29sdW1uRGF0ZS5nZXREYXRlKCkgLSBjb2x1bW5zQnVmZmVyKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgYSBzaG9ydCBkZWxheSB0byBtb3ZlIHRoZSBldmVudCByZW5kZXJpbmcgaW50byB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAgICAgICAgICAgICAgLy8gRGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIyMTZcbiAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHttZS51cGRhdGVFdmVudHMoZmFsc2UsIDAsIGNvbHVtbnNCdWZmZXIpfSk7XG5cbiAgICAgICAgICAgICAgICBzY3JvbGxWYWx1ZSA9IHdpZHRoXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmlzVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbWUucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc2Nyb2xsQnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmdldFNjcm9sbENvbnRhaW5lcigpLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgOiBzY3JvbGxWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkIDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5pc1VwZGF0aW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICovXG4gICAgc2V0Rmlyc3RDb2x1bW5EYXRlKGRhdGUpIHtcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gZGF0ZS5nZXREYXkoKSArIHRoaXMud2Vla1N0YXJ0RGF5IC0gdGhpcy5jb2x1bW5zQnVmZmVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhbGdvcml0aG0gcmVsaWVzIG9uIHRoZSBldmVudFN0b3JlIGJlaW5nIHNvcnRlZCBieSBzdGFydERhdGUgQVNDXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleD0wXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXg9dGhpcy50b3RhbENvbHVtbnNdXG4gICAgICovXG4gICAgdXBkYXRlRXZlbnRzKHNpbGVudD1mYWxzZSwgc3RhcnRJbmRleD0wLCBlbmRJbmRleD10aGlzLnRvdGFsQ29sdW1ucykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUubW91bnRlZCkge1xuICAgICAgICAgICAgbWUubmVlZHNFdmVudFVwZGF0ZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCB7Y2FsZW5kYXJTdG9yZSwgZXZlbnRTdG9yZSwgc2hvd0V2ZW50RW5kVGltZSwgdGltZUF4aXMsIHZkb219ID0gbWUsXG4gICAgICAgICAgICAgICAgZW5kVGltZSAgID0gdGltZUF4aXMuZ2V0VGltZShtZS5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lQXhpcy5nZXRUaW1lKG1lLnN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBkYXRlICAgICAgPSBEYXRlVXRpbC5jbG9uZShtZS5maXJzdENvbHVtbkRhdGUpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgICA9IG1lLmdldENvbHVtbkNvbnRhaW5lcigpLFxuICAgICAgICAgICAgICAgIGogICAgICAgICA9IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJSZWNvcmQsIGNvbHVtbiwgZGF5UmVjb3JkcywgZHVyYXRpb24sIGVuZERhdGUsIGV2ZW50Q2xzLCBldmVudEludGVydmFscywgaGFzT3ZlcmZsb3csIGhlaWdodCwgaSxcbiAgICAgICAgICAgICAgICBsZW4sIHJlY29yZCwgcmVjb3JkS2V5LCBzdGFydERhdGUsIHN0YXJ0SG91cnMsIHRvcDtcblxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RhcnRJbmRleCk7XG5cbiAgICAgICAgICAgIGZvciAoOyBqIDwgZW5kSW5kZXg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbnRlbnQuY25bal07XG5cbiAgICAgICAgICAgICAgICBjb2x1bW4uY24gPSBbXTsgLy8gcmVtb3ZlIHByZXZpb3VzIGV2ZW50cyBmcm9tIHRoZSB2ZG9tXG5cbiAgICAgICAgICAgICAgICBkYXlSZWNvcmRzID0gZXZlbnRTdG9yZS5nZXREYXlSZWNvcmRzKGRhdGUpO1xuICAgICAgICAgICAgICAgIGxlbiAgICAgICAgPSBkYXlSZWNvcmRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQgICAgICAgICA9IGRheVJlY29yZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyUmVjb3JkID0gY2FsZW5kYXJTdG9yZS5nZXQocmVjb3JkLmNhbGVuZGFySWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhclJlY29yZD8uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlICAgPSByZWNvcmQuZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IHJlY29yZC5zdGFydERhdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRUaW1lIDw9IHN0YXJ0RGF0ZS5nZXRIb3VycygpIHx8IHN0YXJ0VGltZSA+PSBlbmREYXRlLmdldEhvdXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kVGltZSA8IGVuZERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUgPSBEYXRlVXRpbC5jbG9uZShlbmREYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldEhvdXJzKGVuZFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcygwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lID4gc3RhcnREYXRlLmdldEhvdXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUgPSBEYXRlVXRpbC5jbG9uZShzdGFydERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uICAgICAgID0gKGVuZERhdGUgLSBzdGFydERhdGUpIC8gNjAgLyA2MCAvIDEwMDA7IC8vIGR1cmF0aW9uIGluIGhvdXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudENscyAgICAgICA9IFsnbmVvLWV2ZW50JywgJ25lby1kcmFnZ2FibGUnLCBgbmVvLSR7Y2FsZW5kYXJSZWNvcmQuY29sb3J9YF07XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEludGVydmFscyA9IGR1cmF0aW9uICogNjAgLyB0aW1lQXhpcy5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc092ZXJmbG93ICAgID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgICAgICAgICA9IE1hdGgucm91bmQoZHVyYXRpb24gLyB0b3RhbFRpbWUgKiAxMDAgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRLZXkgICAgICA9IHJlY29yZFtldmVudFN0b3JlLmtleVByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SG91cnMgICAgID0gKHN0YXJ0RGF0ZS5nZXRIb3VycygpICogNjAgKyBzdGFydERhdGUuZ2V0TWludXRlcygpKSAvIDYwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wICAgICAgICAgICAgPSBNYXRoLnJvdW5kKChzdGFydEhvdXJzIC0gc3RhcnRUaW1lKSAvIHRvdGFsVGltZSAqIDEwMCAqIDEwMDApIC8gMTAwMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SW50ZXJ2YWxzIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPdmVyZmxvdyA9IHRpbWVBeGlzLnJvd0hlaWdodCAqIGV2ZW50SW50ZXJ2YWxzIDwgKHNob3dFdmVudEVuZFRpbWUgPyA1MCA6IDM0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPdmVyZmxvdyAmJiAhKHNob3dFdmVudEVuZFRpbWUgJiYgKHRpbWVBeGlzLnJvd0hlaWdodCAvIGV2ZW50SW50ZXJ2YWxzID49IDM0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRDbHMucHVzaCgnbmVvLW92ZXJmbG93JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dFdmVudEVuZFRpbWUgPSAhKGhhc092ZXJmbG93ICYmIGV2ZW50SW50ZXJ2YWxzID09PSAxIHx8ICFzaG93RXZlbnRFbmRUaW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50RW5kVGltZSAmJiBldmVudENscy5wdXNoKCduZW8tc2hvdy1lbmQtdGltZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uY24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgICA6IGV2ZW50Q2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgICAgOiByZWNvcmRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmdldEV2ZW50SWQocmVjb3JkS2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogLTEsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbjogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzIDogWyduZW8tZXZlbnQtdGltZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgOiBgJHttZS5pZH1fX3RpbWVfXyR7cmVjb3JkS2V5fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG1lLmludGxGb3JtYXRfdGltZS5mb3JtYXQocmVjb3JkLnN0YXJ0RGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyA6IFsnbmVvLWV2ZW50LXRpdGxlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICA6IGAke21lLmlkfV9fdGl0bGVfXyR7cmVjb3JkS2V5fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHJlY29yZC50aXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1ldmVudC10aW1lJywgJ25lby1ldmVudC1lbmQtdGltZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IGAke21lLmlkfV9fZW5kZGF0ZV9fJHtyZWNvcmRLZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiAhc2hvd0V2ZW50RW5kVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCAgICAgOiBtZS5pbnRsRm9ybWF0X3RpbWUuZm9ybWF0KHJlY29yZC5lbmREYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgY2FsYygke2hlaWdodH0lIC0gMnB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAgIDogYGNhbGMoJHt0b3B9JSArIDFweClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA6ICdjYWxjKDEwMCUgLSAxcHgpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjcmVhdGU9ZmFsc2VdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICAgICAqL1xuICAgIHVwZGF0ZUhlYWRlcihjcmVhdGU9ZmFsc2UsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3Nob3dXZWVrZW5kc30gPSBtZSxcbiAgICAgICAgICAgIGRhdGUgICAgICAgICAgID0gbWUuY3VycmVudERhdGUsIC8vIGNsb25lZFxuICAgICAgICAgICAgY29udGVudCAgICAgICAgPSBtZS5nZXRDb2x1bW5Db250YWluZXIoKSxcbiAgICAgICAgICAgIGhlYWRlciAgICAgICAgID0gbWUuZ2V0SGVhZGVyQ29udGFpbmVyKCksXG4gICAgICAgICAgICBpICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBjb2x1bW5DbHMsIGN1cnJlbnREYXRlLCBjdXJyZW50RGF5LCBkYXRlQ2xzLCBoZWFkZXJJZCwgcmVtb3ZlRG9tO1xuXG4gICAgICAgIG1lLnNldEZpcnN0Q29sdW1uRGF0ZShkYXRlKTtcblxuICAgICAgICBtZS5maXJzdENvbHVtbkRhdGUgPSBEYXRlVXRpbC5jbG9uZShkYXRlKTtcblxuICAgICAgICBmb3IgKDsgaSA8IG1lLnRvdGFsQ29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICBjb2x1bW5DbHMgICA9IFsnbmVvLWMtdy1jb2x1bW4nLCAnbmVvLWRyYWdnYWJsZSddO1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIGN1cnJlbnREYXkgID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgIGRhdGVDbHMgICAgID0gWyduZW8tZGF0ZSddO1xuICAgICAgICAgICAgcmVtb3ZlRG9tICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnREYXkgPT09IDAgfHwgY3VycmVudERheSA9PT0gNikge1xuICAgICAgICAgICAgICAgIGNvbHVtbkNscy5wdXNoKCduZW8td2Vla2VuZCcpO1xuICAgICAgICAgICAgICAgICFzaG93V2Vla2VuZHMgJiYgKHJlbW92ZURvbSA9IHRydWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50RGF0ZSA9PT0gdG9kYXkuZGF5ICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gdG9kYXkubW9udGggJiYgZGF0ZS5nZXRGdWxsWWVhcigpID09PSB0b2RheS55ZWFyKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUNscy5wdXNoKCduZW8tdG9kYXknKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZWFkZXJJZCA9IG1lLmdldENvbHVtbkhlYWRlcklkKGRhdGUpO1xuXG4gICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5jbi5wdXNoKHtjbHM6IGNvbHVtbkNscywgZmxhZzogRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0ZSksIGlkOiBtZS5nZXRDb2x1bW5JZChkYXRlKSwgcmVtb3ZlRG9tfSk7XG5cbiAgICAgICAgICAgICAgICBoZWFkZXIuY24ucHVzaChcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1oZWFkZXItcm93LWl0ZW0nXSwgaWQ6IGhlYWRlcklkLCByZW1vdmVEb20sIGNuOiBbXG4gICAgICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWRheSddLCBpZDogYCR7aGVhZGVySWR9X2RheWAsICB0ZXh0OiBtZS5pbnRsRm9ybWF0X2RheS5mb3JtYXQoZGF0ZSl9LFxuICAgICAgICAgICAgICAgICAgICB7Y2xzIDogZGF0ZUNscywgICAgaWQ6IGAke2hlYWRlcklkfV9kYXRlYCwgdGV4dDogY3VycmVudERhdGV9XG4gICAgICAgICAgICAgICAgXX0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGVudC5jbltpXSwge1xuICAgICAgICAgICAgICAgICAgICBjbHMgOiBjb2x1bW5DbHMsXG4gICAgICAgICAgICAgICAgICAgIGZsYWc6IERhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGUpLFxuICAgICAgICAgICAgICAgICAgICBpZCAgOiBtZS5nZXRDb2x1bW5JZChkYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlci5jbltpXSwgICAgICAge2lkOiBoZWFkZXJJZCwgcmVtb3ZlRG9tfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXIuY25baV0uY25bMF0sIHtpZDogYCR7aGVhZGVySWR9X2RheWAsIHRleHQ6IG1lLmludGxGb3JtYXRfZGF5LmZvcm1hdChkYXRlKX0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVyLmNuW2ldLmNuWzFdLCB7Y2xzOiBkYXRlQ2xzLCBpZDogYCR7aGVhZGVySWR9X2RhdGVgLCB0ZXh0OiBjdXJyZW50RGF0ZX0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpXG4gICAgICAgIH1cblxuICAgICAgICAhc2lsZW50ICYmIG1lLnVwZGF0ZSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy53ZWVrLlRpbWVBeGlzQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVGltZUF4aXNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaW50ZXJ2YWxcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJbXX0gaW50ZXJ2YWxzPVsxNSwzMCw2MF1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBpbnRlcnZhbHMgPSBbMTUsIDMwLCA2MF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5UaW1lQXhpc0NvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5UaW1lQXhpc0NvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhci10aW1lYXhpcyddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhci10aW1lYXhpcyddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBlbmRUaW1lICA6IGRhdGEgPT4gZGF0YS5lbmRUaW1lLFxuICAgICAgICAgICAgc3RhcnRUaW1lOiBkYXRhID0+IGRhdGEuc3RhcnRUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGZ1bGwgaG91cnMgYXJlIHZhbGlkIGZvciBub3dcbiAgICAgICAgICogZm9ybWF0OiAnaGg6bW0nXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZW5kVGltZV89JzI0OjAwJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGVuZFRpbWVfOiAnMjQ6MDAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgaW50ZXJ2YWwgaW4gbWludXRlcyB0byBkaXNwbGF5IGFzIHJvd3MuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogMTUsIDMwLCA2MFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGludGVydmFsXz0zMFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGludGVydmFsXzogMzAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJvd0hlaWdodF89MjBcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByb3dIZWlnaHRfOiAyMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZnVsbCBob3VycyBhcmUgdmFsaWQgZm9yIG5vd1xuICAgICAgICAgKiBmb3JtYXQ6ICdoaDptbSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzdGFydFRpbWVfPScwMDowMCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydFRpbWVfOiAnMDA6MDAnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tXG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOlxuICAgICAgICB7c3R5bGU6IHt9fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY3JlYXRlSXRlbXMoKTtcbiAgICAgICAgbWUuYWZ0ZXJTZXRSb3dIZWlnaHQobWUucm93SGVpZ2h0LCAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZW5kVGltZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRFbmRUaW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgLy8gdG9kbzogaGFuZGxlIDI0OjAwIGFzIDIzOjU5XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUuX2VuZFRpbWUgPSAnMjQ6MDAnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmFmdGVyU2V0Um93SGVpZ2h0KG1lLnJvd0hlaWdodCwgMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SW50ZXJ2YWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyU2V0Um93SGVpZ2h0KHRoaXMucm93SGVpZ2h0LCAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb3dIZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um93SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZkb20uY24pIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZW5kVGltZSAgICAgICAgICAgPSBtZS5nZXRUaW1lKG1lLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSAgICAgICAgID0gbWUuZ2V0VGltZShtZS5zdGFydFRpbWUpLFxuICAgICAgICAgICAgICAgIHtyb3dIZWlnaHQsIHZkb219ID0gbWUsXG4gICAgICAgICAgICAgICAgcm93c1Blckl0ZW0gICAgICAgPSBtZS5nZXRSb3dzUGVySXRlbSgpLFxuICAgICAgICAgICAgICAgIGl0ZW1IZWlnaHQgICAgICAgID0gcm93c1Blckl0ZW0gKiByb3dIZWlnaHQgKyByb3dzUGVySXRlbSwgLy8gcm93c1Blckl0ZW0gKiAxcHggYm9yZGVyc1xuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICAgICAgID0gcm93SGVpZ2h0ICsgKChlbmRUaW1lIC0gc3RhcnRUaW1lKSAqIGl0ZW1IZWlnaHQpLFxuICAgICAgICAgICAgICAgIGksIGl0ZW1TdHlsZTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2ZG9tLnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlICAgIDogYGxpbmVhci1ncmFkaWVudCh2YXIoLS1jLXctYmFja2dyb3VuZC1jb2xvcikgJHtpdGVtSGVpZ2h0IC0gMX1weCwgdmFyKC0tYy13LWJvcmRlci1jb2xvcikgMXB4KWAsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uWTogYCR7LWl0ZW1IZWlnaHQgKyAxfXB4YCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSAgICAgOiBgMC40ZW0gJHtpdGVtSGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgICAgICAgICAgICAgOiBgJHt0b3RhbEhlaWdodCAtIHJvd0hlaWdodCArIDF9cHhgLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodCAgICAgICAgICA6IGAke3RvdGFsSGVpZ2h0IC0gcm93SGVpZ2h0ICsgMX1weGBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7aXRlbUhlaWdodH1weGBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUubWFyZ2luVG9wID0gYCR7LTIgLSByb3dIZWlnaHQgKiAocm93c1Blckl0ZW0gPT09IDEgPyAwLjUgOiByb3dzUGVySXRlbSA9PT0gMiA/IDEgOiAyKX1weGBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbVN0eWxlLm1hcmdpblRvcFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZkb20uY25baV0uc3R5bGUgPSBpdGVtU3R5bGU7XG5cbiAgICAgICAgICAgICAgICB2ZG9tLmNuW2ldLnJlbW92ZURvbSA9IChpIDwgc3RhcnRUaW1lIHx8IGkgLSAxID49IGVuZFRpbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBtZSxcbiAgICAgICAgICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgICAgICAgICAgcm93c1Blckl0ZW0sXG4gICAgICAgICAgICAgICAgdG90YWxIZWlnaHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0YXJ0VGltZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdGFydFRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyU2V0Um93SGVpZ2h0KHRoaXMucm93SGVpZ2h0LCAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaW50ZXJ2YWwgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRJbnRlcnZhbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2ludGVydmFsJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQge3Zkb219ID0gdGhpcyxcbiAgICAgICAgICAgIHRleHQsIGk7XG5cbiAgICAgICAgdmRvbS5jbiA9IFtdO1xuXG4gICAgICAgIGZvciAoaT0wOyBpIDwgMjU7IGkrKykge1xuICAgICAgICAgICAgdGV4dCA9IGkgPT09IDI0ID8gJzAwOjAwJyA6IChpIDwgMTAgPyAnMCcgOiAnJykgKyBpICsgJzowMCc7XG5cbiAgICAgICAgICAgIHZkb20uY24ucHVzaCh7XG4gICAgICAgICAgICAgICAgY2xzOiBbJ25lby1jLXctdGltZWF4aXMtaXRlbSddLFxuICAgICAgICAgICAgICAgIGNuIDogW3t0ZXh0fV1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhbW91bnQgb2Ygcm93cyByZWxhdGVkIHRvIHRoZSBpbnRlcnZhbCBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd3NQZXJJdGVtKCkge1xuICAgICAgICBsZXQge2ludGVydmFsfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbCA9PT0gNjAgPyAxIDogaW50ZXJ2YWwgPT09IDMwID8gMiA6IDRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB0aW1lIGZvciB0aGUgZW5kLSBvciBzdGFydFRpbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFRpbWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNwbGl0KCc6JykubWFwKE51bWJlcilbMF1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRpbWVBeGlzQ29tcG9uZW50KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==