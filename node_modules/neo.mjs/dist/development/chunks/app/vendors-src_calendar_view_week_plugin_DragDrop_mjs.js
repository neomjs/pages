"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_calendar_view_week_plugin_DragDrop_mjs"],{

/***/ "./src/calendar/view/week/EventDragZone.mjs":
/*!**************************************************!*\
  !*** ./src/calendar/view/week/EventDragZone.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../draggable/DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../util/VDom.mjs */ "./src/util/VDom.mjs");






/**
 * @class Neo.calendar.view.week.EventDragZone
 * @extends Neo.draggable.DragZone
 */
class EventDragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.EventDragZone'
         * @protected
         */
        className: 'Neo.calendar.view.week.EventDragZone',
        /**
         * @member {Boolean} addDragProxyCls=false
         */
        addDragProxyCls: false,
        /**
         * @member {Boolean} enableResizingAcrossOppositeEdge=true
         */
        enableResizingAcrossOppositeEdge: true,
        /**
         * @member {Number} axisEndTime=0
         */
        axisEndTime: 0,
        /**
         * @member {Number} axisStartTime=0
         */
        axisStartTime: 0,
        /**
         * @member {Number} columnHeight=0
         */
        columnHeight: 0,
        /**
         * @member {Number} columnTop=0
         */
        columnTop: 0,
        /**
         * @member {Number} currentInterval=0
         */
        currentInterval: 0,
        /**
         * time in minutes
         * @member {Number} eventDuration=0
         */
        eventDuration: 0,
        /**
         * @member {Object} eventRecord=null
         */
        eventRecord: null,
        /**
         * Internal flag.
         * If we resize across the opposite edge and then back, we need to update the related edge position once.
         * @member {Boolean} forceUpdate=false
         * @protected
         */
        forceUpdate: false,
        /**
         * Internal flag
         * @member {Boolean} hasOverflow=false
         * @protected
         */
        hasOverflow: false,
        /**
         * time in minutes
         * @member {Number} intervalSize=15
         */
        intervalSize: 15,
        /**
         * @member {Boolean} keepEndDate=false
         */
        keepEndDate: false,
        /**
         * @member {Boolean} keepStartDate=false
         */
        keepStartDate: false,
        /**
         * @member {Boolean} moveHorizontal=false
         */
        moveHorizontal: false,
        /**
         * @member {Boolean} moveInMainThread=false
         */
        moveInMainThread: false,
        /**
         * Internal flag.
         * @member {Date} newEndDate=null
         * @protected
         */
        newEndDate: null,
        /**
         * Internal flag.
         * @member {Date} newStartDate=null
         * @protected
         */
        newStartDate: null,
        /**
         * @member {Number} scrollFactorLeft=3
         */
        scrollFactorLeft: 3,
        /**
         * @member {Boolean} useProxyWrapper=false
         */
        useProxyWrapper: false
    }

    /**
     *
     */
    addBodyCursorCls() {
        Neo.applyDeltas(this.appName, {id: 'document.body', cls: {add: ['neo-cursor-move']}})
    }

    /**
     * Resolves the 24:00 issue, where an event would end on the next day
     * @param {Date} date
     * @returns {Date}
     */
    adjustEndDate(date) {
        if (date.getHours() === 0 && date.getMinutes() === 0) {
            // if an event ends at 24:00, change it to 23:59 => otherwise the day increases by 1
            date.setMinutes(date.getMinutes() - 1)
        } else if (!(date.getHours() === 23 && date.getMinutes() === 59) && date.getMinutes() % this.intervalSize !== 0) {
            // otherwise switch non interval based values back
            date.setMinutes(date.getMinutes() + 1)
        }

        return date
    }

    /**
     * Triggered after the proxyParentId config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetProxyParentId(value, oldValue) {
        if (value && oldValue !== undefined) {
            let me = this;

            // check if the node did not get removed yet
            if (me.dragProxy?.vdom.cn[0].id) {
                Neo.applyDeltas(me.appName, {
                    action  : 'moveNode',
                    id      : me.dragProxy.id,
                    index   : 0,
                    parentId: value
                })
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Boolean} createComponent=true
     * @returns {Object|Neo.draggable.DragProxyComponent}
     */
    async createDragProxy(data, createComponent=true) {
        let me        = this,
            component = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            vdom      = me.dragProxyConfig?.vdom,
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].clone(vdom ? vdom : me.dragElement);

            clone.cn[2].removeDom = false;

        const config = {
            module          : _draggable_DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,
            windowId        : me.windowId,

            ...me.dragProxyConfig,

            vdom: me.useProxyWrapper ? {cn: [clone]} : clone // we want to override dragProxyConfig.vdom if needed
        };

        config.cls = config.cls || [];

        config.cls.push('neo-focus');

        if (component) {
            config.cls.push(component.getTheme())
        }

        if (clone.cls && !me.useProxyWrapper) {
            config.cls.push(...clone.cls)
        }

        if (me.addDragProxyCls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(config.cls, me.dragProxyCls)
        }

        Object.assign(config.style, {
            height: `${data.height}px`,
            top   : `${data.y - me.columnTop}px`,
            width : `${data.width}px`
        });

        if (createComponent) {
            return me.dragProxy = Neo.create(config)
        }

        return config
    }

    /**
     * DragEnd equals drop, since we can only drag to valid positions
     * todo: ESC key
     * @param {Object} data
     */
    dragEnd(data) {
        super.dragEnd(data);

        let me      = this,
            {owner} = me,
            record  = me.eventRecord,
            endDate, startDate;

        if (me.keepStartDate) {
            endDate   = me.newEndDate;
            startDate = me.newStartDate || record.startDate
        } else {
            startDate = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].find(owner.vdom, me.proxyParentId).vdom.flag + 'T12:00:00.000Z');
            startDate.setHours(me.axisStartTime);
            startDate.setMinutes(me.currentInterval * me.intervalSize);

            if (me.keepEndDate) {
                endDate   = me.newEndDate   || record.endDate;
                startDate = me.newStartDate || startDate
            } else {
                endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(startDate);
                endDate.setMinutes(endDate.getMinutes() + me.eventDuration)
            }
        }

        endDate = me.adjustEndDate(endDate);

        record.setSilent({
            endDate,
            startDate
        });

        Object.assign(me, {
            currentInterval: 0,
            hasOverflow    : false,
            keepEndDate    : false,
            keepStartDate  : false,
            newEndDate     : null,
            newStartDate   : null,
            proxyParentId  : null
        });

        // todo: updating a record field which is included inside a sorter should trigger collection.doSort()
        // see: https://github.com/neomjs/neo/issues/2392

        owner.getStateProvider().getStore('events').doSort();
        owner.updateEvents()
    }

    /**
     * @param {Object} data
     */
    dragMove(data) {
        let me              = this,
            {axisEndTime, axisStartTime, columnHeight, eventDuration, intervalSize, keepEndDate, keepStartDate, owner} = me,
            i               = 0,
            path            = data.targetPath,
            len             = path.length,
            record          = me.eventRecord,
            switchDirection = false,
            {timeAxis}      = owner,
            axisStartDate, currentInterval, deltas, duration, endDate, eventIntervals, height, intervalHeight,
            intervals, limitInterval, minimumEventIntervals, position, startDate, startInterval;

        if (me.dragProxy) {
            if (!keepEndDate && !keepStartDate) {
                for (; i < len; i++) {
                    if (path[i].cls.includes('neo-c-w-column')) {
                        me.proxyParentId = path[i].id;
                        break
                    }
                }
            }

            intervals      = (axisEndTime - axisStartTime) * 60 / intervalSize; // 15 minutes each
            intervalHeight = columnHeight / intervals;

            position = Math.min(columnHeight, data.clientY - me.offsetY - me.columnTop);

            currentInterval = Math.floor(position / intervalHeight);

            endDate   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.endDate);
            startDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.startDate);

            // events can have a smaller start time than the axis min value.
            // resizing via the north handle needs to adjust the duration to honor this.
            if (keepEndDate) {
                if (axisStartTime > startDate.getHours()) {
                    startDate.setHours(axisStartTime);
                    startDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000 // duration in minutes
                }
            }

            // events can have a bigger end time than the axis max value.
            // resizing via the south handle needs to adjust the duration to honor this.
            if (keepStartDate) {
                if (axisEndTime < endDate.getHours()) {
                    endDate.setHours(axisEndTime);
                    endDate.setMinutes(0);

                    eventDuration = (endDate - startDate) / 60 / 1000 // duration in minutes
                }
            }

            if (!keepEndDate) {
                // events must not end after the last visible interval
                currentInterval = Math.min(currentInterval, intervals - (eventDuration / intervalSize))
            }

            deltas = [{
                id   : me.dragProxy.id,
                style: {}
            }];

            if (keepEndDate || keepStartDate) {
                axisStartDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].clone(record.startDate);
                axisStartDate.setHours(axisStartTime);
                axisStartDate.setMinutes(0);

                minimumEventIntervals = owner.minimumEventDuration / intervalSize;
                startInterval         = (record.startDate - axisStartDate) / intervalSize / 60 / 1000;

                if (keepEndDate) {
                    limitInterval = startInterval + (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        if (me.forceUpdate && currentInterval > limitInterval -minimumEventIntervals && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return
                        } else if (currentInterval >= limitInterval + minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(currentInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(limitInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours
                            deltas[0].style.top = `calc(${limitInterval * intervalHeight / columnHeight * 100}% + 1px)`
                        } else {
                            me.forceUpdate  = false;
                            me.newStartDate = null
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.min(currentInterval, limitInterval - minimumEventIntervals)
                    }

                } else if (keepStartDate) {
                    limitInterval = startInterval - (eventDuration / intervalSize);

                    if (me.enableResizingAcrossOppositeEdge) {
                        // events must not start before the first visible interval
                        currentInterval = Math.max(-(eventDuration / intervalSize), currentInterval);

                        if (currentInterval <= limitInterval - minimumEventIntervals) {
                            switchDirection = true;
                            me.forceUpdate  = true;

                            endDate.setHours(axisStartTime);
                            endDate.setMinutes(eventDuration + limitInterval * intervalSize);
                            endDate = me.adjustEndDate(endDate);

                            me.newEndDate = endDate;

                            startDate.setHours(axisStartTime);
                            startDate.setMinutes(eventDuration + currentInterval * intervalSize);

                            me.newStartDate = startDate;

                            duration = (endDate - startDate) / 60 / 60 / 1000; // duration in hours

                            position = (eventDuration / intervalSize + currentInterval) * intervalHeight; // snap to valid intervals
                            position = position / columnHeight * 100;

                            deltas[0].style.top = `calc(${position}% + 1px)`
                        } else if (me.forceUpdate && currentInterval < limitInterval + minimumEventIntervals) {
                            // when we resize back to the original direction, keep the min interval until we snap back
                            return
                        } else if (me.forceUpdate && currentInterval >= limitInterval + minimumEventIntervals) {
                            if (me.currentInterval !== currentInterval) {
                                me.forceUpdate  = false;
                                me.newStartDate = null;
                                deltas[0].style.top = `calc(${startInterval * intervalHeight / columnHeight * 100}% + 1px)`
                            }
                        }
                    }

                    if (!switchDirection) {
                        currentInterval = Math.max(currentInterval, limitInterval + minimumEventIntervals)
                    }
                }
            }

            if (!keepStartDate) {
                // events must not start before the first visible interval
                currentInterval = Math.max(0, currentInterval)
            }

            if (me.currentInterval !== currentInterval) {
                if (!switchDirection) {
                    if (!keepEndDate) {
                        endDate.setHours(axisStartTime);
                        endDate.setMinutes(eventDuration + currentInterval * intervalSize)
                    }

                    if (keepStartDate) {
                        me.newEndDate = endDate;
                        duration = (endDate - record.startDate) / 60 / 60 / 1000 // duration in hours
                    } else {
                        startDate.setHours(axisStartTime);
                        startDate.setMinutes(currentInterval * intervalSize);

                        position = currentInterval * intervalHeight; // snap to valid intervals
                        position = position / columnHeight * 100;

                        deltas[0].style.top = `calc(${position}% + 1px)`
                    }

                    if (keepEndDate) {
                        duration = (record.endDate - startDate) / 60 / 60 / 1000 // duration in hours
                    }
                }

                endDate = me.adjustEndDate(endDate);

                deltas.push({
                    id         : me.dragProxy.vdom.cn[2].id,
                    textContent: owner.intlFormat_time.format(endDate)
                });

                if (keepEndDate || keepStartDate) {
                    height = Math.round(duration / (axisEndTime - axisStartTime) * 100 * 1000) / 1000;
                    deltas[0].style.height = `calc(${height}% - 2px)`
                }

                deltas.push({
                    id         : me.dragProxy.vdom.cn[0].id,
                    textContent: owner.intlFormat_time.format(startDate)
                });

                // check if the node got added yet
                if (me.dragProxy.vdom.cn[0].id) {
                    eventIntervals = (duration && duration * 60 || eventDuration) / timeAxis.interval;

                    if (eventIntervals <= 2) {
                        if (timeAxis.rowHeight / eventIntervals < 25 && !me.hasOverflow) {
                            deltas.push({
                                id : me.dragProxy.id,
                                cls: {add: ['neo-overflow']}
                            });

                            me.hasOverflow = true
                        }
                    } else if (me.hasOverflow) {
                        deltas.push({
                            id : me.dragProxy.id,
                            cls: {remove: ['neo-overflow']}
                        });

                        me.hasOverflow = false
                    }

                    Neo.applyDeltas(me.appName, deltas)
                }
            }

            me.currentInterval = currentInterval
        }
    }

    /**
     * @param {Object} data
     */
    async dragStart(data) {
        let me            = this,
            rects         = await me.owner.getDomRect([me.getDragElementRoot().id, data.path[1].id]),
            eventDuration = (me.eventRecord.endDate - me.eventRecord.startDate) / 60 / 1000,
            offsetX       = data.clientX - rects[0].left,
            offsetY       = data.clientY - rects[0].top;

        Object.assign(me, {
            columnHeight   : rects[1].height,
            columnTop      : rects[1].top,
            dragElementRect: rects[0],
            eventDuration  : Math.round(eventDuration / me.intervalSize) * me.intervalSize,
            offsetX,
            offsetY
        });

        await me.createDragProxy(rects[0]);

        me.fire('dragStart', {
            dragElementRect: rects[0],
            id             : me.id,
            offsetX,
            offsetY
        });

        me.dragMove(data)
    }

    /**
     *
     */
    removeBodyCursorCls() {
        Neo.applyDeltas(this.appName, {id: 'document.body', cls: {remove: ['neo-cursor-move']}})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(EventDragZone));


/***/ }),

/***/ "./src/calendar/view/week/plugin/DragDrop.mjs":
/*!****************************************************!*\
  !*** ./src/calendar/view/week/plugin/DragDrop.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EventDragZone.mjs */ "./src/calendar/view/week/EventDragZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../util/VDom.mjs */ "./src/util/VDom.mjs");





const newRecordSymbol = Symbol.for('newRecordSymbol');

/**
 * @class Neo.calendar.view.week.plugin.DragDrop
 * @extends Neo.plugin.Base
 */
class DragDrop extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.week.plugin.DragDrop'
         * @protected
         */
        className: 'Neo.calendar.view.week.plugin.DragDrop',
        /**
         * @member {String} ntype='plugin-calendar-week-dragdrop'
         * @protected
         */
        ntype: 'plugin-calendar-week-dragdrop',
        /**
         * @member {Boolean} isDragging=false
         * @protected
         */
        isDragging: false,
        /**
         * @member {String} resizablePluginType='plugin-calendar-week-dragdrop'
         */
        resizablePluginType: 'calendar-week-eventresizable'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me         = this,
            columnOpts = {scope: me, delegate: '.neo-c-w-column'},
            eventOpts  = {scope: me, delegate: '.neo-event'};

        me.owner.addDomListeners([
            {'drag:end'  : me.onColumnDragEnd,   ...columnOpts},
            {'drag:end'  : me.onEventDragEnd,    ...eventOpts},
            {'drag:move' : me.onColumnDragMove,  ...columnOpts},
            {'drag:move' : me.onEventDragMove,   ...eventOpts},
            {'drag:start': me.onColumnDragStart, ...columnOpts},
            {'drag:start': me.onEventDragStart,  ...eventOpts}
        ]);
    }

    /**
     * Adjusts drag events which start on an event resize handle
     * @param {Object} data
     * @returns {Object}
     */
    adjustResizeEvent(data) {
        data.path.shift();
        data.targetPath.shift();
        data.target = data.path[0];

        return data;
    }

    /**
     * @param {Object} opts
     * @param {Object} opts.dragElement
     * @param {Boolean} opts.enableResizingAcrossOppositeEdge
     * @param {Object} opts.eventRecord
     * @param {String} opts.proxyParentId
     * @returns {Neo.calendar.view.week.EventDragZone}
     */
    getEventDragZone(opts) {
        let me                         = this,
            {appName, owner, windowId} = me,
            {eventDragZone, timeAxis}  = owner,

            config = {
                axisEndTime                     : timeAxis.getTime(owner.endTime),
                axisStartTime                   : timeAxis.getTime(owner.startTime),
                dragElement                     : opts.dragElement,
                enableResizingAcrossOppositeEdge: opts.enableResizingAcrossOppositeEdge,
                eventRecord                     : opts.eventRecord,
                proxyParentId                   : opts.proxyParentId
            };

        if (!eventDragZone) {
            owner.eventDragZone = eventDragZone = Neo.create({
                module           : _EventDragZone_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                appName,
                owner,
                scrollContainerId: owner.getScrollContainer().id,
                windowId,
                ...config,

                dragProxyConfig: {
                    style: {
                        transition: 'none',
                        willChange: 'height'
                    }
                }
            })
        } else {
            eventDragZone.set(config)
        }

        return eventDragZone
    }

    /**
     * Returns the active field value of the active or first calendar record
     * @returns {Boolean}
     */
    isActiveCalendar() {
        let {owner}         = this,
            {calendarStore} = owner,
            calendarId      = owner.data.activeCalendarId || calendarStore.getAt(0)[calendarStore.keyProperty];

        return calendarStore.get(calendarId).active
    }

    /**
     * @param {Object} path
     * @returns {Boolean}
     */
    isTopLevelColumn(path) {
        return path[0].cls.includes('neo-c-w-column')
    }

    /**
     * @param {Object} eventData
     * @returns {Boolean}
     */
    isTopLevelEvent(eventData) {
        return eventData.path[0].cls.includes('neo-event')
    }

    /**
     * @param {Object} data
     */
    onColumnDragEnd(data) {
        let me      = this,
            {owner} = me,
            record  = me[newRecordSymbol];

        if (record && me.isTopLevelColumn(data.path)) {
            me.isDragging = false;

            delete me[newRecordSymbol];

            Neo.applyDeltas(me.appName, {
                id   : owner.getEventId(record.id),
                style: {opacity: 1}
            }).then(() => {
                owner.eventDragZone.dragEnd();
                owner.getPlugin(me.resizablePluginType).onDragEnd(data)
            })
        }
    }

    /**
     * @param {Object} data
     */
    onColumnDragMove(data) {
        let me = this;

        if (me.isActiveCalendar() && me.isTopLevelColumn(data.path)) {
            me.owner.eventDragZone?.dragMove(data)
        }
    }

    /**
     * @param {Object} data
     */
    async onColumnDragStart(data) {
        let me = this;

        if (me.isActiveCalendar() && me.isTopLevelColumn(data.targetPath)) {
            let {owner}         = me,
                axisStartTime   = owner.timeAxis.getTime(owner.startTime),
                {calendarStore} = owner,
                columnRect      = data.path[0].rect,
                intervalSize    = 15,
                intervals       = (owner.timeAxis.getTime(owner.endTime) - axisStartTime) * 60 / intervalSize,
                intervalHeight  = columnRect.height / intervals,
                position        = Math.min(columnRect.height, data.clientY - columnRect.top),
                currentInterval = Math.floor(position / intervalHeight),
                startDate       = new Date(_util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, data.path[0].id).vdom.flag + 'T12:00:00.000Z'),
                dragElement, endDate, eventDragZone, eventId, record;

            me.isDragging = true;

            startDate.setHours(axisStartTime);
            startDate.setMinutes(Math.min(currentInterval * intervalSize, intervals * intervalSize - owner.minimumEventDuration));

            endDate = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(startDate);

            endDate.setMinutes(endDate.getMinutes() + owner.minimumEventDuration);

            // 24:00 fix
            endDate.getHours() === 0 && endDate.getMinutes() === 0 && endDate.setMinutes(endDate.getMinutes() - 1);

            record = owner.eventStore.add({
                calendarId: owner.data.activeCalendarId || calendarStore.getAt(0)[calendarStore.keyProperty],
                endDate,
                startDate,
                title     : 'New Event'
            })[0];

            // we need to cache a reference to make the record accessible for onColumnDragEnd()
            me[newRecordSymbol] = record;

            // wait until the new event got mounted
            await me.timeout(50);

            eventId     = owner.getEventId(record.id);
            dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, eventId).vdom;

            eventDragZone = me.getEventDragZone({
                dragElement,
                enableResizingAcrossOppositeEdge: true,
                eventRecord                     : record,
                proxyParentId                   : data.path[0].id
            });

            owner.getPlugin(me.resizablePluginType).onDragStart(data);
            await eventDragZone.dragStart(data);

            await me.timeout(50);

            me.isDragging && Neo.applyDeltas(me.appName, {
                id   : eventId,
                style: {opacity: 0}
            })
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragEnd(data) {
        let me              = this,
            {owner}         = me,
            {eventDragZone} = owner;

        if (owner.enableDrag) {
            eventDragZone.dragEnd();

            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data);
                owner.getPlugin(me.resizablePluginType).onDragEnd(data)
            } else {
                eventDragZone.removeBodyCursorCls()
            }

            me.isDragging = false
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragMove(data) {
        let me      = this,
            {owner} = me;

        if (owner.enableDrag) {
            if (!me.isTopLevelEvent(data)) {
                data = me.adjustResizeEvent(data)
            }

            owner.eventDragZone.dragMove(data)
        }
    }

    /**
     * @param {Object} data
     */
    onEventDragStart(data) {
        let me        = this,
            {owner}   = me,
            modelData = owner.data;

        if (owner.enableDrag) {
            let isTopLevelEvent = me.isTopLevelEvent(data),
                dragElement, eventDragZone;

            if (!isTopLevelEvent) {
                data = me.adjustResizeEvent(data)
            }

            me.isDragging = true;

            dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, data.path[0].id).vdom;

            eventDragZone = me.getEventDragZone({
                dragElement,
                enableResizingAcrossOppositeEdge: modelData.events.enableResizingAcrossOppositeEdge,
                eventRecord                     : owner.eventStore.get(dragElement.flag),
                proxyParentId                   : data.path[1].id
            });

            if (isTopLevelEvent) {
                eventDragZone.addBodyCursorCls()
            } else {
                owner.getPlugin(me.resizablePluginType).onDragStart(data)
            }

            eventDragZone.dragStart(data)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragDrop));


/***/ }),

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jYWxlbmRhcl92aWV3X3dlZWtfcGx1Z2luX0RyYWdEcm9wX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDbUI7QUFDVjtBQUNSO0FBQ0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUFRO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtB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Q0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHdCQUF3QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNVRKOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9FdmVudERyYWdab25lLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvd2Vlay9wbHVnaW4vRHJhZ0Ryb3AubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL0Jhc2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRlVXRpbCAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9EYXRlLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29tcG9uZW50IGZyb20gJy4uLy4uLy4uL2RyYWdnYWJsZS9EcmFnUHJveHlDb21wb25lbnQubWpzJztcbmltcG9ydCBEcmFnWm9uZSAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LndlZWsuRXZlbnREcmFnWm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS5EcmFnWm9uZVxuICovXG5jbGFzcyBFdmVudERyYWdab25lIGV4dGVuZHMgRHJhZ1pvbmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudERyYWdab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy53ZWVrLkV2ZW50RHJhZ1pvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWRkRHJhZ1Byb3h5Q2xzPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGREcmFnUHJveHlDbHM6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2U9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2U6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGF4aXNFbmRUaW1lPTBcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNFbmRUaW1lOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBheGlzU3RhcnRUaW1lPTBcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNTdGFydFRpbWU6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtbkhlaWdodD0wXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5IZWlnaHQ6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGNvbHVtblRvcD0wXG4gICAgICAgICAqL1xuICAgICAgICBjb2x1bW5Ub3A6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbnRlcnZhbD0wXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50SW50ZXJ2YWw6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aW1lIGluIG1pbnV0ZXNcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBldmVudER1cmF0aW9uPTBcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50RHVyYXRpb246IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGV2ZW50UmVjb3JkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGV2ZW50UmVjb3JkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy5cbiAgICAgICAgICogSWYgd2UgcmVzaXplIGFjcm9zcyB0aGUgb3Bwb3NpdGUgZWRnZSBhbmQgdGhlbiBiYWNrLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmVsYXRlZCBlZGdlIHBvc2l0aW9uIG9uY2UuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGZvcmNlVXBkYXRlPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGFzT3ZlcmZsb3c9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzT3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogdGltZSBpbiBtaW51dGVzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaW50ZXJ2YWxTaXplPTE1XG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnZhbFNpemU6IDE1LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0ga2VlcEVuZERhdGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGtlZXBFbmREYXRlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGtlZXBTdGFydERhdGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGtlZXBTdGFydERhdGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUhvcml6b250YWw9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVIb3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVJbk1haW5UaHJlYWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZy5cbiAgICAgICAgICogQG1lbWJlciB7RGF0ZX0gbmV3RW5kRGF0ZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5ld0VuZERhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnLlxuICAgICAgICAgKiBAbWVtYmVyIHtEYXRlfSBuZXdTdGFydERhdGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBuZXdTdGFydERhdGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbEZhY3RvckxlZnQ9M1xuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdDogMyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVByb3h5V3JhcHBlcj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlUHJveHlXcmFwcGVyOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgYWRkQm9keUN1cnNvckNscygpIHtcbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKHRoaXMuYXBwTmFtZSwge2lkOiAnZG9jdW1lbnQuYm9keScsIGNsczoge2FkZDogWyduZW8tY3Vyc29yLW1vdmUnXX19KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSAyNDowMCBpc3N1ZSwgd2hlcmUgYW4gZXZlbnQgd291bGQgZW5kIG9uIHRoZSBuZXh0IGRheVxuICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAqL1xuICAgIGFkanVzdEVuZERhdGUoZGF0ZSkge1xuICAgICAgICBpZiAoZGF0ZS5nZXRIb3VycygpID09PSAwICYmIGRhdGUuZ2V0TWludXRlcygpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiBhbiBldmVudCBlbmRzIGF0IDI0OjAwLCBjaGFuZ2UgaXQgdG8gMjM6NTkgPT4gb3RoZXJ3aXNlIHRoZSBkYXkgaW5jcmVhc2VzIGJ5IDFcbiAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSAtIDEpXG4gICAgICAgIH0gZWxzZSBpZiAoIShkYXRlLmdldEhvdXJzKCkgPT09IDIzICYmIGRhdGUuZ2V0TWludXRlcygpID09PSA1OSkgJiYgZGF0ZS5nZXRNaW51dGVzKCkgJSB0aGlzLmludGVydmFsU2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHN3aXRjaCBub24gaW50ZXJ2YWwgYmFzZWQgdmFsdWVzIGJhY2tcbiAgICAgICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIDEpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcHJveHlQYXJlbnRJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQcm94eVBhcmVudElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5vZGUgZGlkIG5vdCBnZXQgcmVtb3ZlZCB5ZXRcbiAgICAgICAgICAgIGlmIChtZS5kcmFnUHJveHk/LnZkb20uY25bMF0uaWQpIHtcbiAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gIDogJ21vdmVOb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICA6IG1lLmRyYWdQcm94eS5pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggICA6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY3JlYXRlQ29tcG9uZW50PXRydWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50fVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZURyYWdQcm94eShkYXRhLCBjcmVhdGVDb21wb25lbnQ9dHJ1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQobWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWQpIHx8IG1lLm93bmVyLFxuICAgICAgICAgICAgdmRvbSAgICAgID0gbWUuZHJhZ1Byb3h5Q29uZmlnPy52ZG9tLFxuICAgICAgICAgICAgY2xvbmUgICAgID0gVkRvbVV0aWwuY2xvbmUodmRvbSA/IHZkb20gOiBtZS5kcmFnRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGNsb25lLmNuWzJdLnJlbW92ZURvbSA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICA6IERyYWdQcm94eUNvbXBvbmVudCxcbiAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiBtZS5tb3ZlSW5NYWluVGhyZWFkLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgIDogbWUucHJveHlQYXJlbnRJZCxcbiAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICA6IG1lLndpbmRvd0lkLFxuXG4gICAgICAgICAgICAuLi5tZS5kcmFnUHJveHlDb25maWcsXG5cbiAgICAgICAgICAgIHZkb206IG1lLnVzZVByb3h5V3JhcHBlciA/IHtjbjogW2Nsb25lXX0gOiBjbG9uZSAvLyB3ZSB3YW50IHRvIG92ZXJyaWRlIGRyYWdQcm94eUNvbmZpZy52ZG9tIGlmIG5lZWRlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbmZpZy5jbHMgPSBjb25maWcuY2xzIHx8IFtdO1xuXG4gICAgICAgIGNvbmZpZy5jbHMucHVzaCgnbmVvLWZvY3VzJyk7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKGNvbXBvbmVudC5nZXRUaGVtZSgpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsb25lLmNscyAmJiAhbWUudXNlUHJveHlXcmFwcGVyKSB7XG4gICAgICAgICAgICBjb25maWcuY2xzLnB1c2goLi4uY2xvbmUuY2xzKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmFkZERyYWdQcm94eUNscykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNvbmZpZy5jbHMsIG1lLmRyYWdQcm94eUNscylcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLnN0eWxlLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IGAke2RhdGEuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIHRvcCAgIDogYCR7ZGF0YS55IC0gbWUuY29sdW1uVG9wfXB4YCxcbiAgICAgICAgICAgIHdpZHRoIDogYCR7ZGF0YS53aWR0aH1weGBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmRyYWdQcm94eSA9IE5lby5jcmVhdGUoY29uZmlnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYWdFbmQgZXF1YWxzIGRyb3AsIHNpbmNlIHdlIGNhbiBvbmx5IGRyYWcgdG8gdmFsaWQgcG9zaXRpb25zXG4gICAgICogdG9kbzogRVNDIGtleVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgZHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIHN1cGVyLmRyYWdFbmQoZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgcmVjb3JkICA9IG1lLmV2ZW50UmVjb3JkLFxuICAgICAgICAgICAgZW5kRGF0ZSwgc3RhcnREYXRlO1xuXG4gICAgICAgIGlmIChtZS5rZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICBlbmREYXRlICAgPSBtZS5uZXdFbmREYXRlO1xuICAgICAgICAgICAgc3RhcnREYXRlID0gbWUubmV3U3RhcnREYXRlIHx8IHJlY29yZC5zdGFydERhdGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKFZEb21VdGlsLmZpbmQob3duZXIudmRvbSwgbWUucHJveHlQYXJlbnRJZCkudmRvbS5mbGFnICsgJ1QxMjowMDowMC4wMDBaJyk7XG4gICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMobWUuYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhtZS5jdXJyZW50SW50ZXJ2YWwgKiBtZS5pbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICBpZiAobWUua2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICBlbmREYXRlICAgPSBtZS5uZXdFbmREYXRlICAgfHwgcmVjb3JkLmVuZERhdGU7XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlID0gbWUubmV3U3RhcnREYXRlIHx8IHN0YXJ0RGF0ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmREYXRlID0gRGF0ZVV0aWwuY2xvbmUoc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZW5kRGF0ZS5nZXRNaW51dGVzKCkgKyBtZS5ldmVudER1cmF0aW9uKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZW5kRGF0ZSA9IG1lLmFkanVzdEVuZERhdGUoZW5kRGF0ZSk7XG5cbiAgICAgICAgcmVjb3JkLnNldFNpbGVudCh7XG4gICAgICAgICAgICBlbmREYXRlLFxuICAgICAgICAgICAgc3RhcnREYXRlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbnRlcnZhbDogMCxcbiAgICAgICAgICAgIGhhc092ZXJmbG93ICAgIDogZmFsc2UsXG4gICAgICAgICAgICBrZWVwRW5kRGF0ZSAgICA6IGZhbHNlLFxuICAgICAgICAgICAga2VlcFN0YXJ0RGF0ZSAgOiBmYWxzZSxcbiAgICAgICAgICAgIG5ld0VuZERhdGUgICAgIDogbnVsbCxcbiAgICAgICAgICAgIG5ld1N0YXJ0RGF0ZSAgIDogbnVsbCxcbiAgICAgICAgICAgIHByb3h5UGFyZW50SWQgIDogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0b2RvOiB1cGRhdGluZyBhIHJlY29yZCBmaWVsZCB3aGljaCBpcyBpbmNsdWRlZCBpbnNpZGUgYSBzb3J0ZXIgc2hvdWxkIHRyaWdnZXIgY29sbGVjdGlvbi5kb1NvcnQoKVxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMzkyXG5cbiAgICAgICAgb3duZXIuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdldmVudHMnKS5kb1NvcnQoKTtcbiAgICAgICAgb3duZXIudXBkYXRlRXZlbnRzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXhpc0VuZFRpbWUsIGF4aXNTdGFydFRpbWUsIGNvbHVtbkhlaWdodCwgZXZlbnREdXJhdGlvbiwgaW50ZXJ2YWxTaXplLCBrZWVwRW5kRGF0ZSwga2VlcFN0YXJ0RGF0ZSwgb3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgcGF0aCAgICAgICAgICAgID0gZGF0YS50YXJnZXRQYXRoLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICAgID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICByZWNvcmQgICAgICAgICAgPSBtZS5ldmVudFJlY29yZCxcbiAgICAgICAgICAgIHN3aXRjaERpcmVjdGlvbiA9IGZhbHNlLFxuICAgICAgICAgICAge3RpbWVBeGlzfSAgICAgID0gb3duZXIsXG4gICAgICAgICAgICBheGlzU3RhcnREYXRlLCBjdXJyZW50SW50ZXJ2YWwsIGRlbHRhcywgZHVyYXRpb24sIGVuZERhdGUsIGV2ZW50SW50ZXJ2YWxzLCBoZWlnaHQsIGludGVydmFsSGVpZ2h0LFxuICAgICAgICAgICAgaW50ZXJ2YWxzLCBsaW1pdEludGVydmFsLCBtaW5pbXVtRXZlbnRJbnRlcnZhbHMsIHBvc2l0aW9uLCBzdGFydERhdGUsIHN0YXJ0SW50ZXJ2YWw7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgaWYgKCFrZWVwRW5kRGF0ZSAmJiAha2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2xzLmluY2x1ZGVzKCduZW8tYy13LWNvbHVtbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5wcm94eVBhcmVudElkID0gcGF0aFtpXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGludGVydmFscyAgICAgID0gKGF4aXNFbmRUaW1lIC0gYXhpc1N0YXJ0VGltZSkgKiA2MCAvIGludGVydmFsU2l6ZTsgLy8gMTUgbWludXRlcyBlYWNoXG4gICAgICAgICAgICBpbnRlcnZhbEhlaWdodCA9IGNvbHVtbkhlaWdodCAvIGludGVydmFscztcblxuICAgICAgICAgICAgcG9zaXRpb24gPSBNYXRoLm1pbihjb2x1bW5IZWlnaHQsIGRhdGEuY2xpZW50WSAtIG1lLm9mZnNldFkgLSBtZS5jb2x1bW5Ub3ApO1xuXG4gICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gaW50ZXJ2YWxIZWlnaHQpO1xuXG4gICAgICAgICAgICBlbmREYXRlICAgPSBEYXRlVXRpbC5jbG9uZShyZWNvcmQuZW5kRGF0ZSk7XG4gICAgICAgICAgICBzdGFydERhdGUgPSBEYXRlVXRpbC5jbG9uZShyZWNvcmQuc3RhcnREYXRlKTtcblxuICAgICAgICAgICAgLy8gZXZlbnRzIGNhbiBoYXZlIGEgc21hbGxlciBzdGFydCB0aW1lIHRoYW4gdGhlIGF4aXMgbWluIHZhbHVlLlxuICAgICAgICAgICAgLy8gcmVzaXppbmcgdmlhIHRoZSBub3J0aCBoYW5kbGUgbmVlZHMgdG8gYWRqdXN0IHRoZSBkdXJhdGlvbiB0byBob25vciB0aGlzLlxuICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNTdGFydFRpbWUgPiBzdGFydERhdGUuZ2V0SG91cnMoKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRNaW51dGVzKDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RHVyYXRpb24gPSAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSkgLyA2MCAvIDEwMDAgLy8gZHVyYXRpb24gaW4gbWludXRlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXZlbnRzIGNhbiBoYXZlIGEgYmlnZ2VyIGVuZCB0aW1lIHRoYW4gdGhlIGF4aXMgbWF4IHZhbHVlLlxuICAgICAgICAgICAgLy8gcmVzaXppbmcgdmlhIHRoZSBzb3V0aCBoYW5kbGUgbmVlZHMgdG8gYWRqdXN0IHRoZSBkdXJhdGlvbiB0byBob25vciB0aGlzLlxuICAgICAgICAgICAgaWYgKGtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc0VuZFRpbWUgPCBlbmREYXRlLmdldEhvdXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRIb3VycyhheGlzRW5kVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcygwKTtcblxuICAgICAgICAgICAgICAgICAgICBldmVudER1cmF0aW9uID0gKGVuZERhdGUgLSBzdGFydERhdGUpIC8gNjAgLyAxMDAwIC8vIGR1cmF0aW9uIGluIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgha2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgbXVzdCBub3QgZW5kIGFmdGVyIHRoZSBsYXN0IHZpc2libGUgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLm1pbihjdXJyZW50SW50ZXJ2YWwsIGludGVydmFscyAtIChldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsdGFzID0gW3tcbiAgICAgICAgICAgICAgICBpZCAgIDogbWUuZHJhZ1Byb3h5LmlkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7fVxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGlmIChrZWVwRW5kRGF0ZSB8fCBrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0RGF0ZSA9IERhdGVVdGlsLmNsb25lKHJlY29yZC5zdGFydERhdGUpO1xuICAgICAgICAgICAgICAgIGF4aXNTdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgYXhpc1N0YXJ0RGF0ZS5zZXRNaW51dGVzKDApO1xuXG4gICAgICAgICAgICAgICAgbWluaW11bUV2ZW50SW50ZXJ2YWxzID0gb3duZXIubWluaW11bUV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemU7XG4gICAgICAgICAgICAgICAgc3RhcnRJbnRlcnZhbCAgICAgICAgID0gKHJlY29yZC5zdGFydERhdGUgLSBheGlzU3RhcnREYXRlKSAvIGludGVydmFsU2l6ZSAvIDYwIC8gMTAwMDtcblxuICAgICAgICAgICAgICAgIGlmIChrZWVwRW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW1pdEludGVydmFsID0gc3RhcnRJbnRlcnZhbCArIChldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWUuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZS5mb3JjZVVwZGF0ZSAmJiBjdXJyZW50SW50ZXJ2YWwgPiBsaW1pdEludGVydmFsIC1taW5pbXVtRXZlbnRJbnRlcnZhbHMgJiYgY3VycmVudEludGVydmFsIDwgbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzaXplIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGRpcmVjdGlvbiwga2VlcCB0aGUgbWluIGludGVydmFsIHVudGlsIHdlIHNuYXAgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50SW50ZXJ2YWwgPj0gbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaERpcmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuZm9yY2VVcGRhdGUgID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZSA9IG1lLmFkanVzdEVuZERhdGUoZW5kRGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdFbmREYXRlID0gZW5kRGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhsaW1pdEludGVydmFsICogaW50ZXJ2YWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld1N0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKGVuZERhdGUgLSBzdGFydERhdGUpIC8gNjAgLyA2MCAvIDEwMDA7IC8vIGR1cmF0aW9uIGluIGhvdXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzWzBdLnN0eWxlLnRvcCA9IGBjYWxjKCR7bGltaXRJbnRlcnZhbCAqIGludGVydmFsSGVpZ2h0IC8gY29sdW1uSGVpZ2h0ICogMTAwfSUgKyAxcHgpYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5mb3JjZVVwZGF0ZSAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdTdGFydERhdGUgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEludGVydmFsID0gTWF0aC5taW4oY3VycmVudEludGVydmFsLCBsaW1pdEludGVydmFsIC0gbWluaW11bUV2ZW50SW50ZXJ2YWxzKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbnRlcnZhbCA9IHN0YXJ0SW50ZXJ2YWwgLSAoZXZlbnREdXJhdGlvbiAvIGludGVydmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVudHMgbXVzdCBub3Qgc3RhcnQgYmVmb3JlIHRoZSBmaXJzdCB2aXNpYmxlIGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLm1heCgtKGV2ZW50RHVyYXRpb24gLyBpbnRlcnZhbFNpemUpLCBjdXJyZW50SW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEludGVydmFsIDw9IGxpbWl0SW50ZXJ2YWwgLSBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2hEaXJlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZvcmNlVXBkYXRlICA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0TWludXRlcyhldmVudER1cmF0aW9uICsgbGltaXRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZSA9IG1lLmFkanVzdEVuZERhdGUoZW5kRGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdFbmREYXRlID0gZW5kRGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zZXRIb3VycyhheGlzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhldmVudER1cmF0aW9uICsgY3VycmVudEludGVydmFsICogaW50ZXJ2YWxTaXplKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLm5ld1N0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKGVuZERhdGUgLSBzdGFydERhdGUpIC8gNjAgLyA2MCAvIDEwMDA7IC8vIGR1cmF0aW9uIGluIGhvdXJzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IChldmVudER1cmF0aW9uIC8gaW50ZXJ2YWxTaXplICsgY3VycmVudEludGVydmFsKSAqIGludGVydmFsSGVpZ2h0OyAvLyBzbmFwIHRvIHZhbGlkIGludGVydmFsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gLyBjb2x1bW5IZWlnaHQgKiAxMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUudG9wID0gYGNhbGMoJHtwb3NpdGlvbn0lICsgMXB4KWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuZm9yY2VVcGRhdGUgJiYgY3VycmVudEludGVydmFsIDwgbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzaXplIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGRpcmVjdGlvbiwga2VlcCB0aGUgbWluIGludGVydmFsIHVudGlsIHdlIHNuYXAgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5mb3JjZVVwZGF0ZSAmJiBjdXJyZW50SW50ZXJ2YWwgPj0gbGltaXRJbnRlcnZhbCArIG1pbmltdW1FdmVudEludGVydmFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZS5jdXJyZW50SW50ZXJ2YWwgIT09IGN1cnJlbnRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5mb3JjZVVwZGF0ZSAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUubmV3U3RhcnREYXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzWzBdLnN0eWxlLnRvcCA9IGBjYWxjKCR7c3RhcnRJbnRlcnZhbCAqIGludGVydmFsSGVpZ2h0IC8gY29sdW1uSGVpZ2h0ICogMTAwfSUgKyAxcHgpYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3dpdGNoRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLm1heChjdXJyZW50SW50ZXJ2YWwsIGxpbWl0SW50ZXJ2YWwgKyBtaW5pbXVtRXZlbnRJbnRlcnZhbHMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgha2VlcFN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBtdXN0IG5vdCBzdGFydCBiZWZvcmUgdGhlIGZpcnN0IHZpc2libGUgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLm1heCgwLCBjdXJyZW50SW50ZXJ2YWwpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZS5jdXJyZW50SW50ZXJ2YWwgIT09IGN1cnJlbnRJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGlmICghc3dpdGNoRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRlLnNldE1pbnV0ZXMoZXZlbnREdXJhdGlvbiArIGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsU2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZWVwU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5uZXdFbmREYXRlID0gZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKGVuZERhdGUgLSByZWNvcmQuc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwIC8vIGR1cmF0aW9uIGluIGhvdXJzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0SG91cnMoYXhpc1N0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERhdGUuc2V0TWludXRlcyhjdXJyZW50SW50ZXJ2YWwgKiBpbnRlcnZhbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGN1cnJlbnRJbnRlcnZhbCAqIGludGVydmFsSGVpZ2h0OyAvLyBzbmFwIHRvIHZhbGlkIGludGVydmFsc1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIGNvbHVtbkhlaWdodCAqIDEwMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzWzBdLnN0eWxlLnRvcCA9IGBjYWxjKCR7cG9zaXRpb259JSArIDFweClgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcEVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gKHJlY29yZC5lbmREYXRlIC0gc3RhcnREYXRlKSAvIDYwIC8gNjAgLyAxMDAwIC8vIGR1cmF0aW9uIGluIGhvdXJzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbmREYXRlID0gbWUuYWRqdXN0RW5kRGF0ZShlbmREYXRlKTtcblxuICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQgICAgICAgICA6IG1lLmRyYWdQcm94eS52ZG9tLmNuWzJdLmlkLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudDogb3duZXIuaW50bEZvcm1hdF90aW1lLmZvcm1hdChlbmREYXRlKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtlZXBFbmREYXRlIHx8IGtlZXBTdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIChheGlzRW5kVGltZSAtIGF4aXNTdGFydFRpbWUpICogMTAwICogMTAwMCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YXNbMF0uc3R5bGUuaGVpZ2h0ID0gYGNhbGMoJHtoZWlnaHR9JSAtIDJweClgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgIDogbWUuZHJhZ1Byb3h5LnZkb20uY25bMF0uaWQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBvd25lci5pbnRsRm9ybWF0X3RpbWUuZm9ybWF0KHN0YXJ0RGF0ZSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBub2RlIGdvdCBhZGRlZCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAobWUuZHJhZ1Byb3h5LnZkb20uY25bMF0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnRlcnZhbHMgPSAoZHVyYXRpb24gJiYgZHVyYXRpb24gKiA2MCB8fCBldmVudER1cmF0aW9uKSAvIHRpbWVBeGlzLmludGVydmFsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudEludGVydmFscyA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZUF4aXMucm93SGVpZ2h0IC8gZXZlbnRJbnRlcnZhbHMgPCAyNSAmJiAhbWUuaGFzT3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkIDogbWUuZHJhZ1Byb3h5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6IHthZGQ6IFsnbmVvLW92ZXJmbG93J119XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5oYXNPdmVyZmxvdyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5oYXNPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkIDogbWUuZHJhZ1Byb3h5LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsczoge3JlbW92ZTogWyduZW8tb3ZlcmZsb3cnXX1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5oYXNPdmVyZmxvdyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwgZGVsdGFzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuY3VycmVudEludGVydmFsID0gY3VycmVudEludGVydmFsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY3RzICAgICAgICAgPSBhd2FpdCBtZS5vd25lci5nZXREb21SZWN0KFttZS5nZXREcmFnRWxlbWVudFJvb3QoKS5pZCwgZGF0YS5wYXRoWzFdLmlkXSksXG4gICAgICAgICAgICBldmVudER1cmF0aW9uID0gKG1lLmV2ZW50UmVjb3JkLmVuZERhdGUgLSBtZS5ldmVudFJlY29yZC5zdGFydERhdGUpIC8gNjAgLyAxMDAwLFxuICAgICAgICAgICAgb2Zmc2V0WCAgICAgICA9IGRhdGEuY2xpZW50WCAtIHJlY3RzWzBdLmxlZnQsXG4gICAgICAgICAgICBvZmZzZXRZICAgICAgID0gZGF0YS5jbGllbnRZIC0gcmVjdHNbMF0udG9wO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGNvbHVtbkhlaWdodCAgIDogcmVjdHNbMV0uaGVpZ2h0LFxuICAgICAgICAgICAgY29sdW1uVG9wICAgICAgOiByZWN0c1sxXS50b3AsXG4gICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3RzWzBdLFxuICAgICAgICAgICAgZXZlbnREdXJhdGlvbiAgOiBNYXRoLnJvdW5kKGV2ZW50RHVyYXRpb24gLyBtZS5pbnRlcnZhbFNpemUpICogbWUuaW50ZXJ2YWxTaXplLFxuICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUuY3JlYXRlRHJhZ1Byb3h5KHJlY3RzWzBdKTtcblxuICAgICAgICBtZS5maXJlKCdkcmFnU3RhcnQnLCB7XG4gICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3RzWzBdLFxuICAgICAgICAgICAgaWQgICAgICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRyYWdNb3ZlKGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVCb2R5Q3Vyc29yQ2xzKCkge1xuICAgICAgICBOZW8uYXBwbHlEZWx0YXModGhpcy5hcHBOYW1lLCB7aWQ6ICdkb2N1bWVudC5ib2R5JywgY2xzOiB7cmVtb3ZlOiBbJ25lby1jdXJzb3ItbW92ZSddfX0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhFdmVudERyYWdab25lKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgIGZyb20gJy4uLy4uLy4uLy4uL3BsdWdpbi9CYXNlLm1qcyc7XG5pbXBvcnQgRGF0ZVV0aWwgICAgICBmcm9tICcuLi8uLi8uLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBFdmVudERyYWdab25lIGZyb20gJy4uL0V2ZW50RHJhZ1pvbmUubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgIGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG5jb25zdCBuZXdSZWNvcmRTeW1ib2wgPSBTeW1ib2wuZm9yKCduZXdSZWNvcmRTeW1ib2wnKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5wbHVnaW4uRHJhZ0Ryb3BcbiAqIEBleHRlbmRzIE5lby5wbHVnaW4uQmFzZVxuICovXG5jbGFzcyBEcmFnRHJvcCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNhbGVuZGFyLnZpZXcud2Vlay5wbHVnaW4uRHJhZ0Ryb3AnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jYWxlbmRhci52aWV3LndlZWsucGx1Z2luLkRyYWdEcm9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbi1jYWxlbmRhci13ZWVrLWRyYWdkcm9wJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbi1jYWxlbmRhci13ZWVrLWRyYWdkcm9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzRHJhZ2dpbmc9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlc2l6YWJsZVBsdWdpblR5cGU9J3BsdWdpbi1jYWxlbmRhci13ZWVrLWRyYWdkcm9wJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXphYmxlUGx1Z2luVHlwZTogJ2NhbGVuZGFyLXdlZWstZXZlbnRyZXNpemFibGUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29sdW1uT3B0cyA9IHtzY29wZTogbWUsIGRlbGVnYXRlOiAnLm5lby1jLXctY29sdW1uJ30sXG4gICAgICAgICAgICBldmVudE9wdHMgID0ge3Njb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLWV2ZW50J307XG5cbiAgICAgICAgbWUub3duZXIuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uQ29sdW1uRHJhZ0VuZCwgICAuLi5jb2x1bW5PcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uRXZlbnREcmFnRW5kLCAgICAuLi5ldmVudE9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25Db2x1bW5EcmFnTW92ZSwgIC4uLmNvbHVtbk9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25FdmVudERyYWdNb3ZlLCAgIC4uLmV2ZW50T3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkNvbHVtbkRyYWdTdGFydCwgLi4uY29sdW1uT3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkV2ZW50RHJhZ1N0YXJ0LCAgLi4uZXZlbnRPcHRzfVxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGRyYWcgZXZlbnRzIHdoaWNoIHN0YXJ0IG9uIGFuIGV2ZW50IHJlc2l6ZSBoYW5kbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYWRqdXN0UmVzaXplRXZlbnQoZGF0YSkge1xuICAgICAgICBkYXRhLnBhdGguc2hpZnQoKTtcbiAgICAgICAgZGF0YS50YXJnZXRQYXRoLnNoaWZ0KCk7XG4gICAgICAgIGRhdGEudGFyZ2V0ID0gZGF0YS5wYXRoWzBdO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZHJhZ0VsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdHMuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5ldmVudFJlY29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnByb3h5UGFyZW50SWRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNhbGVuZGFyLnZpZXcud2Vlay5FdmVudERyYWdab25lfVxuICAgICAqL1xuICAgIGdldEV2ZW50RHJhZ1pvbmUob3B0cykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIG93bmVyLCB3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIHtldmVudERyYWdab25lLCB0aW1lQXhpc30gID0gb3duZXIsXG5cbiAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBheGlzRW5kVGltZSAgICAgICAgICAgICAgICAgICAgIDogdGltZUF4aXMuZ2V0VGltZShvd25lci5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgICBheGlzU3RhcnRUaW1lICAgICAgICAgICAgICAgICAgIDogdGltZUF4aXMuZ2V0VGltZShvd25lci5zdGFydFRpbWUpLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgICAgICAgICAgICAgICAgICAgOiBvcHRzLmRyYWdFbGVtZW50LFxuICAgICAgICAgICAgICAgIGVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlOiBvcHRzLmVuYWJsZVJlc2l6aW5nQWNyb3NzT3Bwb3NpdGVFZGdlLFxuICAgICAgICAgICAgICAgIGV2ZW50UmVjb3JkICAgICAgICAgICAgICAgICAgICAgOiBvcHRzLmV2ZW50UmVjb3JkLFxuICAgICAgICAgICAgICAgIHByb3h5UGFyZW50SWQgICAgICAgICAgICAgICAgICAgOiBvcHRzLnByb3h5UGFyZW50SWRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFldmVudERyYWdab25lKSB7XG4gICAgICAgICAgICBvd25lci5ldmVudERyYWdab25lID0gZXZlbnREcmFnWm9uZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgOiBFdmVudERyYWdab25lLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQ6IG93bmVyLmdldFNjcm9sbENvbnRhaW5lcigpLmlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcblxuICAgICAgICAgICAgICAgIGRyYWdQcm94eUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lsbENoYW5nZTogJ2hlaWdodCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmVudERyYWdab25lLnNldChjb25maWcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnREcmFnWm9uZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdGl2ZSBmaWVsZCB2YWx1ZSBvZiB0aGUgYWN0aXZlIG9yIGZpcnN0IGNhbGVuZGFyIHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzQWN0aXZlQ2FsZW5kYXIoKSB7XG4gICAgICAgIGxldCB7b3duZXJ9ICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NhbGVuZGFyU3RvcmV9ID0gb3duZXIsXG4gICAgICAgICAgICBjYWxlbmRhcklkICAgICAgPSBvd25lci5kYXRhLmFjdGl2ZUNhbGVuZGFySWQgfHwgY2FsZW5kYXJTdG9yZS5nZXRBdCgwKVtjYWxlbmRhclN0b3JlLmtleVByb3BlcnR5XTtcblxuICAgICAgICByZXR1cm4gY2FsZW5kYXJTdG9yZS5nZXQoY2FsZW5kYXJJZCkuYWN0aXZlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RvcExldmVsQ29sdW1uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbMF0uY2xzLmluY2x1ZGVzKCduZW8tYy13LWNvbHVtbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVG9wTGV2ZWxFdmVudChldmVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50RGF0YS5wYXRoWzBdLmNscy5pbmNsdWRlcygnbmVvLWV2ZW50JylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ29sdW1uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIHJlY29yZCAgPSBtZVtuZXdSZWNvcmRTeW1ib2xdO1xuXG4gICAgICAgIGlmIChyZWNvcmQgJiYgbWUuaXNUb3BMZXZlbENvbHVtbihkYXRhLnBhdGgpKSB7XG4gICAgICAgICAgICBtZS5pc0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZVtuZXdSZWNvcmRTeW1ib2xdO1xuXG4gICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwge1xuICAgICAgICAgICAgICAgIGlkICAgOiBvd25lci5nZXRFdmVudElkKHJlY29yZC5pZCksXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtvcGFjaXR5OiAxfVxuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgb3duZXIuZXZlbnREcmFnWm9uZS5kcmFnRW5kKCk7XG4gICAgICAgICAgICAgICAgb3duZXIuZ2V0UGx1Z2luKG1lLnJlc2l6YWJsZVBsdWdpblR5cGUpLm9uRHJhZ0VuZChkYXRhKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Db2x1bW5EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzQWN0aXZlQ2FsZW5kYXIoKSAmJiBtZS5pc1RvcExldmVsQ29sdW1uKGRhdGEucGF0aCkpIHtcbiAgICAgICAgICAgIG1lLm93bmVyLmV2ZW50RHJhZ1pvbmU/LmRyYWdNb3ZlKGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uQ29sdW1uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNBY3RpdmVDYWxlbmRhcigpICYmIG1lLmlzVG9wTGV2ZWxDb2x1bW4oZGF0YS50YXJnZXRQYXRoKSkge1xuICAgICAgICAgICAgbGV0IHtvd25lcn0gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgIGF4aXNTdGFydFRpbWUgICA9IG93bmVyLnRpbWVBeGlzLmdldFRpbWUob3duZXIuc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICB7Y2FsZW5kYXJTdG9yZX0gPSBvd25lcixcbiAgICAgICAgICAgICAgICBjb2x1bW5SZWN0ICAgICAgPSBkYXRhLnBhdGhbMF0ucmVjdCxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbFNpemUgICAgPSAxNSxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbHMgICAgICAgPSAob3duZXIudGltZUF4aXMuZ2V0VGltZShvd25lci5lbmRUaW1lKSAtIGF4aXNTdGFydFRpbWUpICogNjAgLyBpbnRlcnZhbFNpemUsXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxIZWlnaHQgID0gY29sdW1uUmVjdC5oZWlnaHQgLyBpbnRlcnZhbHMsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gICAgICAgID0gTWF0aC5taW4oY29sdW1uUmVjdC5oZWlnaHQsIGRhdGEuY2xpZW50WSAtIGNvbHVtblJlY3QudG9wKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJ2YWwgPSBNYXRoLmZsb29yKHBvc2l0aW9uIC8gaW50ZXJ2YWxIZWlnaHQpLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSAgICAgICA9IG5ldyBEYXRlKFZEb21VdGlsLmZpbmQob3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tLmZsYWcgKyAnVDEyOjAwOjAwLjAwMFonKSxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCwgZW5kRGF0ZSwgZXZlbnREcmFnWm9uZSwgZXZlbnRJZCwgcmVjb3JkO1xuXG4gICAgICAgICAgICBtZS5pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgc3RhcnREYXRlLnNldEhvdXJzKGF4aXNTdGFydFRpbWUpO1xuICAgICAgICAgICAgc3RhcnREYXRlLnNldE1pbnV0ZXMoTWF0aC5taW4oY3VycmVudEludGVydmFsICogaW50ZXJ2YWxTaXplLCBpbnRlcnZhbHMgKiBpbnRlcnZhbFNpemUgLSBvd25lci5taW5pbXVtRXZlbnREdXJhdGlvbikpO1xuXG4gICAgICAgICAgICBlbmREYXRlID0gRGF0ZVV0aWwuY2xvbmUoc3RhcnREYXRlKTtcblxuICAgICAgICAgICAgZW5kRGF0ZS5zZXRNaW51dGVzKGVuZERhdGUuZ2V0TWludXRlcygpICsgb3duZXIubWluaW11bUV2ZW50RHVyYXRpb24pO1xuXG4gICAgICAgICAgICAvLyAyNDowMCBmaXhcbiAgICAgICAgICAgIGVuZERhdGUuZ2V0SG91cnMoKSA9PT0gMCAmJiBlbmREYXRlLmdldE1pbnV0ZXMoKSA9PT0gMCAmJiBlbmREYXRlLnNldE1pbnV0ZXMoZW5kRGF0ZS5nZXRNaW51dGVzKCkgLSAxKTtcblxuICAgICAgICAgICAgcmVjb3JkID0gb3duZXIuZXZlbnRTdG9yZS5hZGQoe1xuICAgICAgICAgICAgICAgIGNhbGVuZGFySWQ6IG93bmVyLmRhdGEuYWN0aXZlQ2FsZW5kYXJJZCB8fCBjYWxlbmRhclN0b3JlLmdldEF0KDApW2NhbGVuZGFyU3RvcmUua2V5UHJvcGVydHldLFxuICAgICAgICAgICAgICAgIGVuZERhdGUsXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgIHRpdGxlICAgICA6ICdOZXcgRXZlbnQnXG4gICAgICAgICAgICB9KVswXTtcblxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjYWNoZSBhIHJlZmVyZW5jZSB0byBtYWtlIHRoZSByZWNvcmQgYWNjZXNzaWJsZSBmb3Igb25Db2x1bW5EcmFnRW5kKClcbiAgICAgICAgICAgIG1lW25ld1JlY29yZFN5bWJvbF0gPSByZWNvcmQ7XG5cbiAgICAgICAgICAgIC8vIHdhaXQgdW50aWwgdGhlIG5ldyBldmVudCBnb3QgbW91bnRlZFxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1MCk7XG5cbiAgICAgICAgICAgIGV2ZW50SWQgICAgID0gb3duZXIuZ2V0RXZlbnRJZChyZWNvcmQuaWQpO1xuICAgICAgICAgICAgZHJhZ0VsZW1lbnQgPSBWRG9tVXRpbC5maW5kKG93bmVyLnZkb20sIGV2ZW50SWQpLnZkb207XG5cbiAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUgPSBtZS5nZXRFdmVudERyYWdab25lKHtcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgICBlbmFibGVSZXNpemluZ0Fjcm9zc09wcG9zaXRlRWRnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBldmVudFJlY29yZCAgICAgICAgICAgICAgICAgICAgIDogcmVjb3JkLFxuICAgICAgICAgICAgICAgIHByb3h5UGFyZW50SWQgICAgICAgICAgICAgICAgICAgOiBkYXRhLnBhdGhbMF0uaWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvd25lci5nZXRQbHVnaW4obWUucmVzaXphYmxlUGx1Z2luVHlwZSkub25EcmFnU3RhcnQoZGF0YSk7XG4gICAgICAgICAgICBhd2FpdCBldmVudERyYWdab25lLmRyYWdTdGFydChkYXRhKTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1MCk7XG5cbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgJiYgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgICAgICBpZCAgIDogZXZlbnRJZCxcbiAgICAgICAgICAgICAgICBzdHlsZToge29wYWNpdHk6IDB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50RHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICB7ZXZlbnREcmFnWm9uZX0gPSBvd25lcjtcblxuICAgICAgICBpZiAob3duZXIuZW5hYmxlRHJhZykge1xuICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5kcmFnRW5kKCk7XG5cbiAgICAgICAgICAgIGlmICghbWUuaXNUb3BMZXZlbEV2ZW50KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG1lLmFkanVzdFJlc2l6ZUV2ZW50KGRhdGEpO1xuICAgICAgICAgICAgICAgIG93bmVyLmdldFBsdWdpbihtZS5yZXNpemFibGVQbHVnaW5UeXBlKS5vbkRyYWdFbmQoZGF0YSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5yZW1vdmVCb2R5Q3Vyc29yQ2xzKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRXZlbnREcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZTtcblxuICAgICAgICBpZiAob3duZXIuZW5hYmxlRHJhZykge1xuICAgICAgICAgICAgaWYgKCFtZS5pc1RvcExldmVsRXZlbnQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbWUuYWRqdXN0UmVzaXplRXZlbnQoZGF0YSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duZXIuZXZlbnREcmFnWm9uZS5kcmFnTW92ZShkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkV2ZW50RHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ICAgPSBtZSxcbiAgICAgICAgICAgIG1vZGVsRGF0YSA9IG93bmVyLmRhdGE7XG5cbiAgICAgICAgaWYgKG93bmVyLmVuYWJsZURyYWcpIHtcbiAgICAgICAgICAgIGxldCBpc1RvcExldmVsRXZlbnQgPSBtZS5pc1RvcExldmVsRXZlbnQoZGF0YSksXG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQsIGV2ZW50RHJhZ1pvbmU7XG5cbiAgICAgICAgICAgIGlmICghaXNUb3BMZXZlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG1lLmFkanVzdFJlc2l6ZUV2ZW50KGRhdGEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBkcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmQob3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tO1xuXG4gICAgICAgICAgICBldmVudERyYWdab25lID0gbWUuZ2V0RXZlbnREcmFnWm9uZSh7XG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2U6IG1vZGVsRGF0YS5ldmVudHMuZW5hYmxlUmVzaXppbmdBY3Jvc3NPcHBvc2l0ZUVkZ2UsXG4gICAgICAgICAgICAgICAgZXZlbnRSZWNvcmQgICAgICAgICAgICAgICAgICAgICA6IG93bmVyLmV2ZW50U3RvcmUuZ2V0KGRyYWdFbGVtZW50LmZsYWcpLFxuICAgICAgICAgICAgICAgIHByb3h5UGFyZW50SWQgICAgICAgICAgICAgICAgICAgOiBkYXRhLnBhdGhbMV0uaWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNUb3BMZXZlbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnREcmFnWm9uZS5hZGRCb2R5Q3Vyc29yQ2xzKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3duZXIuZ2V0UGx1Z2luKG1lLnJlc2l6YWJsZVBsdWdpblR5cGUpLm9uRHJhZ1N0YXJ0KGRhdGEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50RHJhZ1pvbmUuZHJhZ1N0YXJ0KGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERyYWdEcm9wKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHBsdWdpbiBpbXBsZW1lbnRhdGlvbnMuXG4gKiBQbHVnaW5zIGFyZSBpbnRlbmRlZCB0byBnZXQgcHV0IGludG8gdGhlIHBsdWdpbnMgY29uZmlnIG9mIGNvbXBvbmVudC5CYXNlXG4gKiB0byBlbmhhbmNlIHRoZW0gb3IgYWRkIGFkZGl0aW9uYWwgZmVhdHVyZXNcbiAqIEBjbGFzcyBOZW8ucGx1Z2luLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgUGx1Z2luIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgcGx1Z2luIG50eXBlcyBuZWVkIHRvIHN0YXJ0IHdpdGggJ3BsdWdpbi0nIHRvIGVuc3VyZSB0aGF0IGNvbXBvbmVudC5CYXNlOiBnZXRQbHVnaW4oKSBjYW4gZmluZCB0aGVtXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZF86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWU7XG5cbiAgICAgICAgaWYgKG93bmVyLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJDb25zdHJ1Y3RlZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUub25Pd25lckNvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3duZXIubW91bnRlZCkge1xuICAgICAgICAgICAgbWUub25Pd25lck1vdW50ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyLm9uKCdtb3VudGVkJywgbWUub25Pd25lck1vdW50ZWQsIG1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKHZhbHVlLCB0aGlzLl9fcHJvdG9fXylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBpcyBjb25zdHJ1Y3RlZFxuICAgICAqL1xuICAgIG9uT3duZXJDb25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgbGV0IHtvd25lcn0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChvd25lci53aW5kb3dJZCkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dJZCA9IG93bmVyLndpbmRvd0lkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBkb2VzIGdldCBtb3VudGVkXG4gICAgICovXG4gICAgb25Pd25lck1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBsdWdpbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=