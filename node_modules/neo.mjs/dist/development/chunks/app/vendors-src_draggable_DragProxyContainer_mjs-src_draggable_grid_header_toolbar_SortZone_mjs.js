"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_DragProxyContainer_mjs-src_draggable_grid_header_toolbar_SortZone_mjs"],{

/***/ "./src/draggable/DragProxyComponent.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyComponent));


/***/ },

/***/ "./src/draggable/DragProxyContainer.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyContainer.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");



/**
 * @class Neo.draggable.DragProxyContainer
 * @extends Neo.container.Base
 */
class DragProxyContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyContainer'
         * @protected
         */
        className: 'Neo.draggable.DragProxyContainer',
        /**
         * @member {String} ntype='dragproxycontainer'
         * @protected
         */
        ntype: 'dragproxycontainer',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Object} layout='fit'
         * @reactive
         */
        layout: 'fit',
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        // We want to reuse the styling of the DragProxyComponent, since both use the same baseCls.
        // Instead of duplicating the scss file, we are forcing the ThemeEngine to load the component file.
        if (value) {
            Neo.currentWorker.insertThemeFiles(value, _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype)
        }
    }

    /**
     * We do NOT want to destroy child items, since they get re-used.
     * @param {...*} args
     */
    destroy(...args) {
        this.items = [];
        super.destroy(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyContainer));


/***/ },

/***/ "./src/draggable/grid/header/toolbar/SortZone.mjs"
/*!********************************************************!*\
  !*** ./src/draggable/grid/header/toolbar/SortZone.mjs ***!
  \********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_SortZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../container/SortZone.mjs */ "./src/draggable/container/SortZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../util/VDom.mjs */ "./src/util/VDom.mjs");



/**
 * @class Neo.draggable.grid.header.toolbar.SortZone
 * @extends Neo.draggable.container.SortZone
 */
class SortZone extends _container_SortZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.grid.header.toolbar.SortZone'
         * @protected
         */
        className: 'Neo.draggable.grid.header.toolbar.SortZone',
        /**
         * @member {String} ntype='grid-header-toolbar-sortzone'
         * @protected
         */
        ntype: 'grid-header-toolbar-sortzone',
        /**
         * @member {String|null} itemMargin='1px'
         * @protected
         */
        itemMargin: '1px',
        /**
         * @member {Boolean} moveColumnContent=true
         */
        moveColumnContent: true,
        /**
         * @member {Boolean} moveVertical=false
         */
        moveVertical: false
    }

    /**
     * @param {Neo.util.Rectangle} rect
     * @param {Neo.util.Rectangle} parentRect
     */
    adjustProxyRectToParent(rect, parentRect) {
        rect.x = rect.x - parentRect.x - 1;
        rect.y = rect.y - parentRect.y - 1
    }

    /**
     * @param {Object}  data
     * @param {Boolean} createComponent=true
     * @returns {Object|Neo.draggable.DragProxyComponent}
     */
    async createDragProxy(data, createComponent=true) {
        if (!this.moveColumnContent) {
            return await super.createDragProxy(data, createComponent)
        }

        let me            = this,
            grid          = me.owner.parent,
            {body}        = grid,
            bodyWrapperId = Neo.getId('grid-body-wrapper'),
            gridRows      = body.getVdomRoot().cn,
            columnIndex   = me.dragElement['aria-colindex'] - 1,
            {dataField}   = body.columnPositions.getAt(columnIndex),
            cells         = body.getColumnCells(dataField),
            rows          = [],
            config        = await super.createDragProxy(data, false),
            rect          = await grid.getDomRect(),
            row;

        config.cls = ['neo-grid-wrapper', me.owner.getTheme()];

        config.style.height = `${rect.height - 2}px`; // minus border-bottom & border-top

        cells.forEach((cell, index) => {
            row = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone({ // clone to remove ids
                cls  : gridRows[index].cls,
                cn   : [cell],
                style: gridRows[index].style
            });

            delete row.cn[0].style.left;

            rows.push(row)
        });

        config.vdom =
        {cn: [
            {cls: ['neo-grid-container'], cn: [
                {...config.vdom, cls: ['neo-grid-header-toolbar', 'neo-toolbar']},
                {cls: ['neo-grid-body-wrapper'], id: bodyWrapperId, cn: [
                    {cls: ['neo-grid-body'], cn: rows},
                    {cls: ['neo-grid-scrollbar'], style: {height: body.vdom.cn[0].height}}
                ]}
            ]}
        ]};

        config.listeners = {
            mounted() {
                Neo.main.DomAccess.scrollTo({
                    id      : bodyWrapperId,
                    value   : body.scrollTop,
                    windowId: me.windowId
                })
            }
        };

        if (createComponent) {
            return me.dragProxy = Neo.create(config)
        }

        return config
    }

    /**
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        super.moveTo(fromIndex, toIndex);
        this.owner.parent.columns.move(fromIndex, toIndex)
    }

    /**
     * @param {Object} data
     */
    async onDragEnd(data) {
        await super.onDragEnd(data);

        let {owner} = this;

        owner.items.forEach((item, index) => {
            item.vdom['aria-colindex'] = index + 1; // 1 based
        });

        owner.updateDepth = 2;
        owner.update();

        await owner.passSizeToBody();

        await this.timeout(20);

        owner.parent.body.createViewData()
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        await super.onDragStart(data);

        if (this.moveColumnContent) {
            let me             = this,
                {body}         = me.owner.parent,
                columnIndex    = me.dragElement['aria-colindex'] - 1,
                columnPosition = body.columnPositions.getAt(columnIndex),
                {dataField}    = columnPosition,
                cells          = body.getColumnCells(dataField);

            columnPosition.hidden = true;

            cells.forEach(cell => {
                cell.style.visibility = 'hidden'
            });

            body.update()
        }
    }

    /**
     * @param {Number} index1
     * @param {Number} index2
     */
    switchItems(index1, index2) {
        super.switchItems(index1, index2);

        if (this.moveColumnContent) {
            let me                = this,
                {itemRects}       = me,
                {body}            = me.owner.parent,
                {columnPositions} = body,
                column1Position   = columnPositions.getAt(index1),
                column2Position   = columnPositions.getAt(index2),
                column1Cells      = body.getColumnCells(column1Position.dataField),
                column2Cells      = body.getColumnCells(column2Position.dataField);

            Object.assign(column1Position, {
                width: itemRects[index2].width,
                x    : itemRects[index2].x + 1
            });

            Object.assign(column2Position, {
                width: itemRects[index1].width,
                x    : itemRects[index1].x + 1
            });

            columnPositions.move(index1, index2);

            column1Cells.forEach(node => {
                node.style.left  = column1Position.x     + 'px';
                node.style.width = column1Position.width + 'px'
            });

            column2Cells.forEach(node => {
                node.style.left  = column2Position.x     + 'px';
                node.style.width = column2Position.width + 'px'
            });

            body.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SortZone));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfRHJhZ1Byb3h5Q29udGFpbmVyX21qcy1zcmNfZHJhZ2dhYmxlX2dyaWRfaGVhZGVyX3Rvb2xiYXJfU29ydFpvbmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyREFBSTtBQUNyQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7O0FBRXhDLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGtDQUFrQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JESztBQUNHOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyREFBYTtBQUM5QztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHVCQUF1Qjs7QUFFeEMseURBQXlELHNCQUFzQjtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwrREFBa0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxrQ0FBa0MsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRlM7QUFDTDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0RBQVk7QUFDbkM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLGdCQUFnQixLQUFLOztBQUV0RDtBQUNBLGtCQUFrQixzREFBUSxTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsU0FBUztBQUNULGFBQWE7QUFDYixpQkFBaUIsZ0VBQWdFO0FBQ2pGLGlCQUFpQjtBQUNqQixxQkFBcUIsaUNBQWlDO0FBQ3RELHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0Esb0RBQW9EO0FBQ3BELFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDLGlCQUFpQixpQkFBaUI7QUFDbEMsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHdCQUF3QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kcmFnZ2FibGUvRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9EcmFnUHJveHlDb250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL2dyaWQvaGVhZGVyL3Rvb2xiYXIvU29ydFpvbmUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlIGZyb20gJy4uL2NvbXBvbmVudC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1Byb3h5Q29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZHJhZ3Byb3h5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RyYWdwcm94eScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvSW5pdFZub2RlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0Vm5vZGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZHJhZ3Byb3h5J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRyYWdwcm94eSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMubW92ZUluTWFpblRocmVhZCkge1xuICAgICAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0RHJhZ1Byb3h5RWxlbWVudCh7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1Byb3h5Q29tcG9uZW50KTtcbiIsImltcG9ydCBCYXNlQ29udGFpbmVyICAgICAgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBEcmFnUHJveHlDb21wb25lbnQgZnJvbSAnLi9EcmFnUHJveHlDb21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBEcmFnUHJveHlDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFncHJveHljb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZHJhZ3Byb3h5Y29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Jbml0Vm5vZGU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0luaXRWbm9kZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1kcmFncHJveHknXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tZHJhZ3Byb3h5J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD0nZml0J1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDogJ2ZpdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5tb3ZlSW5NYWluVGhyZWFkKSB7XG4gICAgICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5zZXREcmFnUHJveHlFbGVtZW50KHthcHBOYW1lLCBpZCwgd2luZG93SWR9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICAvLyBXZSB3YW50IHRvIHJldXNlIHRoZSBzdHlsaW5nIG9mIHRoZSBEcmFnUHJveHlDb21wb25lbnQsIHNpbmNlIGJvdGggdXNlIHRoZSBzYW1lIGJhc2VDbHMuXG4gICAgICAgIC8vIEluc3RlYWQgb2YgZHVwbGljYXRpbmcgdGhlIHNjc3MgZmlsZSwgd2UgYXJlIGZvcmNpbmcgdGhlIFRoZW1lRW5naW5lIHRvIGxvYWQgdGhlIGNvbXBvbmVudCBmaWxlLlxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIERyYWdQcm94eUNvbXBvbmVudC5wcm90b3R5cGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBkbyBOT1Qgd2FudCB0byBkZXN0cm95IGNoaWxkIGl0ZW1zLCBzaW5jZSB0aGV5IGdldCByZS11c2VkLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koLi4uYXJncylcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERyYWdQcm94eUNvbnRhaW5lcik7XG4iLCJpbXBvcnQgQmFzZVNvcnRab25lIGZyb20gJy4uLy4uLy4uL2NvbnRhaW5lci9Tb3J0Wm9uZS5tanMnO1xuaW1wb3J0IFZkb21VdGlsICAgICBmcm9tICAnLi4vLi4vLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuZ3JpZC5oZWFkZXIudG9vbGJhci5Tb3J0Wm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmVcbiAqL1xuY2xhc3MgU29ydFpvbmUgZXh0ZW5kcyBCYXNlU29ydFpvbmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5ncmlkLmhlYWRlci50b29sYmFyLlNvcnRab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLmdyaWQuaGVhZGVyLnRvb2xiYXIuU29ydFpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZ3JpZC1oZWFkZXItdG9vbGJhci1zb3J0em9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdncmlkLWhlYWRlci10b29sYmFyLXNvcnR6b25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpdGVtTWFyZ2luPScxcHgnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1NYXJnaW46ICcxcHgnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUNvbHVtbkNvbnRlbnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUNvbHVtbkNvbnRlbnQ6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlVmVydGljYWw9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVWZXJ0aWNhbDogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby51dGlsLlJlY3RhbmdsZX0gcmVjdFxuICAgICAqIEBwYXJhbSB7TmVvLnV0aWwuUmVjdGFuZ2xlfSBwYXJlbnRSZWN0XG4gICAgICovXG4gICAgYWRqdXN0UHJveHlSZWN0VG9QYXJlbnQocmVjdCwgcGFyZW50UmVjdCkge1xuICAgICAgICByZWN0LnggPSByZWN0LnggLSBwYXJlbnRSZWN0LnggLSAxO1xuICAgICAgICByZWN0LnkgPSByZWN0LnkgLSBwYXJlbnRSZWN0LnkgLSAxXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjcmVhdGVDb21wb25lbnQ9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8TmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnR9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRHJhZ1Byb3h5KGRhdGEsIGNyZWF0ZUNvbXBvbmVudD10cnVlKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3ZlQ29sdW1uQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLmNyZWF0ZURyYWdQcm94eShkYXRhLCBjcmVhdGVDb21wb25lbnQpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBncmlkICAgICAgICAgID0gbWUub3duZXIucGFyZW50LFxuICAgICAgICAgICAge2JvZHl9ICAgICAgICA9IGdyaWQsXG4gICAgICAgICAgICBib2R5V3JhcHBlcklkID0gTmVvLmdldElkKCdncmlkLWJvZHktd3JhcHBlcicpLFxuICAgICAgICAgICAgZ3JpZFJvd3MgICAgICA9IGJvZHkuZ2V0VmRvbVJvb3QoKS5jbixcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ICAgPSBtZS5kcmFnRWxlbWVudFsnYXJpYS1jb2xpbmRleCddIC0gMSxcbiAgICAgICAgICAgIHtkYXRhRmllbGR9ICAgPSBib2R5LmNvbHVtblBvc2l0aW9ucy5nZXRBdChjb2x1bW5JbmRleCksXG4gICAgICAgICAgICBjZWxscyAgICAgICAgID0gYm9keS5nZXRDb2x1bW5DZWxscyhkYXRhRmllbGQpLFxuICAgICAgICAgICAgcm93cyAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgY29uZmlnICAgICAgICA9IGF3YWl0IHN1cGVyLmNyZWF0ZURyYWdQcm94eShkYXRhLCBmYWxzZSksXG4gICAgICAgICAgICByZWN0ICAgICAgICAgID0gYXdhaXQgZ3JpZC5nZXREb21SZWN0KCksXG4gICAgICAgICAgICByb3c7XG5cbiAgICAgICAgY29uZmlnLmNscyA9IFsnbmVvLWdyaWQtd3JhcHBlcicsIG1lLm93bmVyLmdldFRoZW1lKCldO1xuXG4gICAgICAgIGNvbmZpZy5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodCAtIDJ9cHhgOyAvLyBtaW51cyBib3JkZXItYm90dG9tICYgYm9yZGVyLXRvcFxuXG4gICAgICAgIGNlbGxzLmZvckVhY2goKGNlbGwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByb3cgPSBWZG9tVXRpbC5jbG9uZSh7IC8vIGNsb25lIHRvIHJlbW92ZSBpZHNcbiAgICAgICAgICAgICAgICBjbHMgIDogZ3JpZFJvd3NbaW5kZXhdLmNscyxcbiAgICAgICAgICAgICAgICBjbiAgIDogW2NlbGxdLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBncmlkUm93c1tpbmRleF0uc3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWxldGUgcm93LmNuWzBdLnN0eWxlLmxlZnQ7XG5cbiAgICAgICAgICAgIHJvd3MucHVzaChyb3cpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZy52ZG9tID1cbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1ncmlkLWNvbnRhaW5lciddLCBjbjogW1xuICAgICAgICAgICAgICAgIHsuLi5jb25maWcudmRvbSwgY2xzOiBbJ25lby1ncmlkLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ119LFxuICAgICAgICAgICAgICAgIHtjbHM6IFsnbmVvLWdyaWQtYm9keS13cmFwcGVyJ10sIGlkOiBib2R5V3JhcHBlcklkLCBjbjogW1xuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1ncmlkLWJvZHknXSwgY246IHJvd3N9LFxuICAgICAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1ncmlkLXNjcm9sbGJhciddLCBzdHlsZToge2hlaWdodDogYm9keS52ZG9tLmNuWzBdLmhlaWdodH19XG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIF19XG4gICAgICAgIF19O1xuXG4gICAgICAgIGNvbmZpZy5saXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBtb3VudGVkKCkge1xuICAgICAgICAgICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBib2R5V3JhcHBlcklkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgIDogYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmRyYWdQcm94eSA9IE5lby5jcmVhdGUoY29uZmlnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleFxuICAgICAqL1xuICAgIG1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgc3VwZXIubW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgICAgIHRoaXMub3duZXIucGFyZW50LmNvbHVtbnMubW92ZShmcm9tSW5kZXgsIHRvSW5kZXgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBhd2FpdCBzdXBlci5vbkRyYWdFbmQoZGF0YSk7XG5cbiAgICAgICAgbGV0IHtvd25lcn0gPSB0aGlzO1xuXG4gICAgICAgIG93bmVyLml0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtLnZkb21bJ2FyaWEtY29saW5kZXgnXSA9IGluZGV4ICsgMTsgLy8gMSBiYXNlZFxuICAgICAgICB9KTtcblxuICAgICAgICBvd25lci51cGRhdGVEZXB0aCA9IDI7XG4gICAgICAgIG93bmVyLnVwZGF0ZSgpO1xuXG4gICAgICAgIGF3YWl0IG93bmVyLnBhc3NTaXplVG9Cb2R5KCk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy50aW1lb3V0KDIwKTtcblxuICAgICAgICBvd25lci5wYXJlbnQuYm9keS5jcmVhdGVWaWV3RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLm9uRHJhZ1N0YXJ0KGRhdGEpO1xuXG4gICAgICAgIGlmICh0aGlzLm1vdmVDb2x1bW5Db250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtib2R5fSAgICAgICAgID0gbWUub3duZXIucGFyZW50LFxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4ICAgID0gbWUuZHJhZ0VsZW1lbnRbJ2FyaWEtY29saW5kZXgnXSAtIDEsXG4gICAgICAgICAgICAgICAgY29sdW1uUG9zaXRpb24gPSBib2R5LmNvbHVtblBvc2l0aW9ucy5nZXRBdChjb2x1bW5JbmRleCksXG4gICAgICAgICAgICAgICAge2RhdGFGaWVsZH0gICAgPSBjb2x1bW5Qb3NpdGlvbixcbiAgICAgICAgICAgICAgICBjZWxscyAgICAgICAgICA9IGJvZHkuZ2V0Q29sdW1uQ2VsbHMoZGF0YUZpZWxkKTtcblxuICAgICAgICAgICAgY29sdW1uUG9zaXRpb24uaGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICAgICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJvZHkudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgyXG4gICAgICovXG4gICAgc3dpdGNoSXRlbXMoaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgc3VwZXIuc3dpdGNoSXRlbXMoaW5kZXgxLCBpbmRleDIpO1xuXG4gICAgICAgIGlmICh0aGlzLm1vdmVDb2x1bW5Db250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtpdGVtUmVjdHN9ICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAge2JvZHl9ICAgICAgICAgICAgPSBtZS5vd25lci5wYXJlbnQsXG4gICAgICAgICAgICAgICAge2NvbHVtblBvc2l0aW9uc30gPSBib2R5LFxuICAgICAgICAgICAgICAgIGNvbHVtbjFQb3NpdGlvbiAgID0gY29sdW1uUG9zaXRpb25zLmdldEF0KGluZGV4MSksXG4gICAgICAgICAgICAgICAgY29sdW1uMlBvc2l0aW9uICAgPSBjb2x1bW5Qb3NpdGlvbnMuZ2V0QXQoaW5kZXgyKSxcbiAgICAgICAgICAgICAgICBjb2x1bW4xQ2VsbHMgICAgICA9IGJvZHkuZ2V0Q29sdW1uQ2VsbHMoY29sdW1uMVBvc2l0aW9uLmRhdGFGaWVsZCksXG4gICAgICAgICAgICAgICAgY29sdW1uMkNlbGxzICAgICAgPSBib2R5LmdldENvbHVtbkNlbGxzKGNvbHVtbjJQb3NpdGlvbi5kYXRhRmllbGQpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbHVtbjFQb3NpdGlvbiwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtUmVjdHNbaW5kZXgyXS53aWR0aCxcbiAgICAgICAgICAgICAgICB4ICAgIDogaXRlbVJlY3RzW2luZGV4Ml0ueCArIDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbHVtbjJQb3NpdGlvbiwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtUmVjdHNbaW5kZXgxXS53aWR0aCxcbiAgICAgICAgICAgICAgICB4ICAgIDogaXRlbVJlY3RzW2luZGV4MV0ueCArIDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb2x1bW5Qb3NpdGlvbnMubW92ZShpbmRleDEsIGluZGV4Mik7XG5cbiAgICAgICAgICAgIGNvbHVtbjFDZWxscy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCAgPSBjb2x1bW4xUG9zaXRpb24ueCAgICAgKyAncHgnO1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSBjb2x1bW4xUG9zaXRpb24ud2lkdGggKyAncHgnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29sdW1uMkNlbGxzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ICA9IGNvbHVtbjJQb3NpdGlvbi54ICAgICArICdweCc7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IGNvbHVtbjJQb3NpdGlvbi53aWR0aCArICdweCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBib2R5LnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNvcnRab25lKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=