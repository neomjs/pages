export const __webpack_esm_id__ = "vendors-src_draggable_DragProxyContainer_mjs-src_draggable_grid_header_toolbar_SortZone_mjs";
export const __webpack_esm_ids__ = ["vendors-src_draggable_DragProxyContainer_mjs-src_draggable_grid_header_toolbar_SortZone_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/draggable/DragProxyComponent.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyComponent.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyComponent));


/***/ },

/***/ "./src/draggable/DragProxyContainer.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/DragProxyContainer.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./src/draggable/DragProxyComponent.mjs");



/**
 * @class Neo.draggable.DragProxyContainer
 * @extends Neo.container.Base
 */
class DragProxyContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.DragProxyContainer'
         * @protected
         */
        className: 'Neo.draggable.DragProxyContainer',
        /**
         * @member {String} ntype='dragproxycontainer'
         * @protected
         */
        ntype: 'dragproxycontainer',
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-dragproxy']
         */
        baseCls: ['neo-dragproxy'],
        /**
         * @member {Object} layout='fit'
         * @reactive
         */
        layout: 'fit',
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && this.moveInMainThread) {
            let {appName, id, windowId} = this;

            Neo.main.addon.DragDrop.setDragProxyElement({appName, id, windowId})
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        // We want to reuse the styling of the DragProxyComponent, since both use the same baseCls.
        // Instead of duplicating the scss file, we are forcing the ThemeEngine to load the component file.
        if (value) {
            Neo.currentWorker.insertThemeFiles(value, _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].prototype)
        }
    }

    /**
     * We do NOT want to destroy child items, since they get re-used.
     * @param {...*} args
     */
    destroy(...args) {
        this.items = [];
        super.destroy(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragProxyContainer));


/***/ },

/***/ "./src/draggable/grid/header/toolbar/SortZone.mjs"
/*!********************************************************!*\
  !*** ./src/draggable/grid/header/toolbar/SortZone.mjs ***!
  \********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_SortZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../container/SortZone.mjs */ "./src/draggable/container/SortZone.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../util/VDom.mjs */ "./src/util/VDom.mjs");



/**
 * @summary Manages drag-and-drop column reordering for Grids.
 *
 * This class handles the complexity of visualizing column moves in a highly optimized, multi-threaded environment.
 *
 * **Key Architectural Patterns:**
 *
 * 1.  **Surgical DOM Move (High-Fidelity Proxy):**
 *     For component-based columns (e.g., Sparklines using OffscreenCanvas), creating clones for the drag proxy
 *     is expensive and breaks context. Instead, this class uses `Neo.applyDeltas` to temporarily *move* the
 *     live DOM content (the first child of the cell) from the Grid into the Proxy. This preserves the
 *     component's state and canvas context without overhead. The content is restored to the Grid on drop.
 *
 * 2.  **Disjoint Updates (Deep Refresh):**
 *     The Grid uses disjoint `Neo.grid.Row` components which update silently. To ensure the Grid body
 *     reflects drag operations (like hiding the original column or shuffling cells), this class forces
 *     a deep update (`updateDepth: -1`) on the `Grid.Body`. This flushes the state of all Row components
 *     to the VDOM worker in a single batch.
 *
 * @class Neo.draggable.grid.header.toolbar.SortZone
 * @extends Neo.draggable.container.SortZone
 */
class SortZone extends _container_SortZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.grid.header.toolbar.SortZone'
         * @protected
         */
        className: 'Neo.draggable.grid.header.toolbar.SortZone',
        /**
         * @member {String} ntype='grid-header-toolbar-sortzone'
         * @protected
         */
        ntype: 'grid-header-toolbar-sortzone',
        /**
         * @member {String|null} itemMargin='1px'
         * @protected
         */
        itemMargin: '1px',
        /**
         * @member {Boolean} moveColumnContent=true
         */
        moveColumnContent: true,
        /**
         * @member {Boolean} moveVertical=false
         */
        moveVertical: false
    }

    /**
     * @param {Neo.util.Rectangle} rect
     * @param {Neo.util.Rectangle} parentRect
     */
    adjustProxyRectToParent(rect, parentRect) {
        rect.x = rect.x - parentRect.x - 1;
        rect.y = rect.y - parentRect.y - 1
    }

    /**
     * Creates the drag proxy.
     *
     * **Surgical DOM Move Implementation:**
     * Detects if a cell contains component content (checking `cell.cn`). If found, it creates an empty
     * container in the proxy's VDOM and schedules a `moveNode` delta to transfer the live content
     * from the Grid to the Proxy after mounting. This bypasses VDOM cloning for heavy components.
     *
     * @param {Object}  data
     * @param {Boolean} createComponent=true
     * @returns {Object|Neo.draggable.DragProxyComponent}
     */
    async createDragProxy(data, createComponent=true) {
        if (!this.moveColumnContent) {
            return await super.createDragProxy(data, createComponent)
        }

        let me            = this,
            grid          = me.owner.parent,
            {body}        = grid,
            bodyWrapperId = Neo.getId('grid-body-wrapper'),
            columnIndex   = me.dragElement['aria-colindex'] - 1,
            {dataField}   = body.columnPositions.getAt(columnIndex),
            cells         = body.getColumnCells(dataField),
            rows          = [],
            config        = await super.createDragProxy(data, false),
            rect          = await grid.getDomRect(),
            row, rowComponent;

        config.cls = ['neo-grid-wrapper', me.owner.getTheme()];

        config.style.height = `${rect.height - 2}px`; // minus border-bottom & border-top

        let moveDeltas = [],
            proxyCell, proxyCellId;

        me.movedComponents = [];

        cells.forEach((cell, index) => {
            rowComponent = body.items[index];

            row = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone({ // clone to remove ids
                cls  : rowComponent.vdom.cls,
                style: rowComponent.vdom.style
            });

            proxyCell = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].clone(cell);
            delete proxyCell.id;
            delete proxyCell.style.left;

            proxyCellId  = Neo.getId('proxy-cell');
            proxyCell.id = proxyCellId;

            if (cell.cn && cell.cn.length > 0) {
                let content   = cell.cn[0],
                    contentId = content.id || content.componentId;

                if (contentId) {
                    proxyCell.cn = [];

                    moveDeltas.push({
                        action  : 'moveNode',
                        id      : contentId,
                        index   : 0,
                        parentId: proxyCellId
                    });

                    me.movedComponents.push({
                        id              : contentId,
                        originalParentId: cell.id
                    })
                }
            }

            row.cn = [proxyCell];
            rows.push(row)
        });

        config.vdom =
        {cn: [
            {cls: ['neo-grid-container', ...grid.cls], cn: [
                {...config.vdom, cls: ['neo-grid-header-toolbar', 'neo-toolbar']},
                {cls: ['neo-grid-body-wrapper'], id: bodyWrapperId, cn: [
                    {cls: ['neo-grid-body'], cn: rows},
                    {cls: ['neo-grid-scrollbar'], style: {height: body.vdom.cn[0].height}}
                ]}
            ]}
        ]};

        config.listeners = {
            mounted() {
                Neo.main.DomAccess.scrollTo({
                    id      : bodyWrapperId,
                    value   : body.scrollTop,
                    windowId: me.windowId
                });

                if (moveDeltas.length > 0) {
                    Neo.applyDeltas(me.windowId, moveDeltas)
                }
            }
        };

        if (createComponent) {
            return me.dragProxy = Neo.create(config)
        }

        return config
    }

    /**
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        super.moveTo(fromIndex, toIndex);
        this.owner.parent.columns.move(fromIndex, toIndex)
    }

    /**
     * @param {Object} data
     */
    async onDragEnd(data) {
        // Restore moved nodes BEFORE destroying the proxy to ensure they return to the Grid.
        if (this.movedComponents?.length > 0) {
            let restoreDeltas = this.movedComponents.map(item => ({
                action  : 'moveNode',
                id      : item.id,
                index   : 0,
                parentId: item.originalParentId
            }));

            await Neo.applyDeltas(this.windowId, restoreDeltas);
            this.movedComponents = null
        }

        await super.onDragEnd(data);

        let {owner} = this;

        owner.items.forEach((item, index) => {
            item.vdom['aria-colindex'] = index + 1; // 1 based
        });

        owner.updateDepth = 2;
        owner.update();

        await owner.passSizeToBody();

        await this.timeout(20);

        owner.parent.body.createViewData(false, true)
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        await super.onDragStart(data);

        if (this.moveColumnContent) {
            let me             = this,
                {body}         = me.owner.parent,
                columnIndex    = me.dragElement['aria-colindex'] - 1,
                columnPosition = body.columnPositions.getAt(columnIndex),
                {dataField}    = columnPosition,
                cells          = body.getColumnCells(dataField);

            columnPosition.hidden = true;

            cells.forEach(cell => {
                cell.style.visibility = 'hidden'
            });

            // Force a deep update to propagate Row component VDOM changes (visibility) to the worker.
            body.updateDepth = -1;
            body.update()
        }
    }

    /**
     * @param {Number} index1
     * @param {Number} index2
     */
    switchItems(index1, index2) {
        super.switchItems(index1, index2);

        if (this.moveColumnContent) {
            let me                = this,
                {itemRects}       = me,
                {body}            = me.owner.parent,
                {columnPositions} = body,
                column1Position   = columnPositions.getAt(index1),
                column2Position   = columnPositions.getAt(index2),
                column1Cells      = body.getColumnCells(column1Position.dataField),
                column2Cells      = body.getColumnCells(column2Position.dataField);

            Object.assign(column1Position, {
                width: itemRects[index2].width,
                x    : itemRects[index2].x + 1
            });

            Object.assign(column2Position, {
                width: itemRects[index1].width,
                x    : itemRects[index1].x + 1
            });

            columnPositions.move(index1, index2);

            column1Cells.forEach(node => {
                node.style.left  = column1Position.x     + 'px';
                node.style.width = column1Position.width + 'px'
            });

            column2Cells.forEach(node => {
                node.style.left  = column2Position.x     + 'px';
                node.style.width = column2Position.width + 'px'
            });

            // Force a deep update to propagate Row component VDOM changes (position) to the worker.
            body.updateDepth = -1;
            body.update()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SortZone));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfRHJhZ1Byb3h5Q29udGFpbmVyX21qcy1zcmNfZHJhZ2dhYmxlX2dyaWRfaGVhZGVyX3Rvb2xiYXJfU29ydFpvbmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQUk7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUJBQXVCOztBQUV4Qyx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxrQ0FBa0MsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyREs7QUFDRzs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkRBQWE7QUFDOUM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7O0FBRXhDLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0RBQWtCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsa0NBQWtDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEZTO0FBQ0w7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFZO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQyxnQkFBZ0IsS0FBSzs7QUFFdEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixzREFBUSxTQUFTO0FBQ25DO0FBQ0E7QUFDQSxhQUFhOztBQUViLHdCQUF3QixzREFBUTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxTQUFTO0FBQ1QsYUFBYTtBQUNiLGlCQUFpQixnRUFBZ0U7QUFDakYsaUJBQWlCO0FBQ2pCLHFCQUFxQixpQ0FBaUM7QUFDdEQscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQSxvREFBb0Q7QUFDcEQsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDLGlCQUFpQixpQkFBaUI7QUFDbEMsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL0RyYWdQcm94eUNvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kcmFnZ2FibGUvRHJhZ1Byb3h5Q29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9ncmlkL2hlYWRlci90b29sYmFyL1NvcnRab25lLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5CYXNlXG4gKi9cbmNsYXNzIERyYWdQcm94eUNvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2RyYWdwcm94eSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFncHJveHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0luaXRWbm9kZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvSW5pdFZub2RlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWRyYWdwcm94eSddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1kcmFncHJveHknXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVJbk1haW5UaHJlYWQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUluTWFpblRocmVhZDogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLm1vdmVJbk1haW5UaHJlYWQpIHtcbiAgICAgICAgICAgIGxldCB7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldERyYWdQcm94eUVsZW1lbnQoe2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERyYWdQcm94eUNvbXBvbmVudCk7XG4iLCJpbXBvcnQgQmFzZUNvbnRhaW5lciAgICAgIGZyb20gJy4uL2NvbnRhaW5lci9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29tcG9uZW50IGZyb20gJy4vRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1Byb3h5Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZHJhZ3Byb3h5Y29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RyYWdwcm94eWNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvSW5pdFZub2RlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0Vm5vZGU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b01vdW50OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZHJhZ3Byb3h5J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRyYWdwcm94eSddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9J2ZpdCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6ICdmaXQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMubW92ZUluTWFpblRocmVhZCkge1xuICAgICAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc2V0RHJhZ1Byb3h5RWxlbWVudCh7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgLy8gV2Ugd2FudCB0byByZXVzZSB0aGUgc3R5bGluZyBvZiB0aGUgRHJhZ1Byb3h5Q29tcG9uZW50LCBzaW5jZSBib3RoIHVzZSB0aGUgc2FtZSBiYXNlQ2xzLlxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGR1cGxpY2F0aW5nIHRoZSBzY3NzIGZpbGUsIHdlIGFyZSBmb3JjaW5nIHRoZSBUaGVtZUVuZ2luZSB0byBsb2FkIHRoZSBjb21wb25lbnQgZmlsZS5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKHZhbHVlLCBEcmFnUHJveHlDb21wb25lbnQucHJvdG90eXBlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgZG8gTk9UIHdhbnQgdG8gZGVzdHJveSBjaGlsZCBpdGVtcywgc2luY2UgdGhleSBnZXQgcmUtdXNlZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEcmFnUHJveHlDb250YWluZXIpO1xuIiwiaW1wb3J0IEJhc2VTb3J0Wm9uZSBmcm9tICcuLi8uLi8uLi9jb250YWluZXIvU29ydFpvbmUubWpzJztcbmltcG9ydCBWZG9tVXRpbCAgICAgZnJvbSAgJy4uLy4uLy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IE1hbmFnZXMgZHJhZy1hbmQtZHJvcCBjb2x1bW4gcmVvcmRlcmluZyBmb3IgR3JpZHMuXG4gKlxuICogVGhpcyBjbGFzcyBoYW5kbGVzIHRoZSBjb21wbGV4aXR5IG9mIHZpc3VhbGl6aW5nIGNvbHVtbiBtb3ZlcyBpbiBhIGhpZ2hseSBvcHRpbWl6ZWQsIG11bHRpLXRocmVhZGVkIGVudmlyb25tZW50LlxuICpcbiAqICoqS2V5IEFyY2hpdGVjdHVyYWwgUGF0dGVybnM6KipcbiAqXG4gKiAxLiAgKipTdXJnaWNhbCBET00gTW92ZSAoSGlnaC1GaWRlbGl0eSBQcm94eSk6KipcbiAqICAgICBGb3IgY29tcG9uZW50LWJhc2VkIGNvbHVtbnMgKGUuZy4sIFNwYXJrbGluZXMgdXNpbmcgT2Zmc2NyZWVuQ2FudmFzKSwgY3JlYXRpbmcgY2xvbmVzIGZvciB0aGUgZHJhZyBwcm94eVxuICogICAgIGlzIGV4cGVuc2l2ZSBhbmQgYnJlYWtzIGNvbnRleHQuIEluc3RlYWQsIHRoaXMgY2xhc3MgdXNlcyBgTmVvLmFwcGx5RGVsdGFzYCB0byB0ZW1wb3JhcmlseSAqbW92ZSogdGhlXG4gKiAgICAgbGl2ZSBET00gY29udGVudCAodGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBjZWxsKSBmcm9tIHRoZSBHcmlkIGludG8gdGhlIFByb3h5LiBUaGlzIHByZXNlcnZlcyB0aGVcbiAqICAgICBjb21wb25lbnQncyBzdGF0ZSBhbmQgY2FudmFzIGNvbnRleHQgd2l0aG91dCBvdmVyaGVhZC4gVGhlIGNvbnRlbnQgaXMgcmVzdG9yZWQgdG8gdGhlIEdyaWQgb24gZHJvcC5cbiAqXG4gKiAyLiAgKipEaXNqb2ludCBVcGRhdGVzIChEZWVwIFJlZnJlc2gpOioqXG4gKiAgICAgVGhlIEdyaWQgdXNlcyBkaXNqb2ludCBgTmVvLmdyaWQuUm93YCBjb21wb25lbnRzIHdoaWNoIHVwZGF0ZSBzaWxlbnRseS4gVG8gZW5zdXJlIHRoZSBHcmlkIGJvZHlcbiAqICAgICByZWZsZWN0cyBkcmFnIG9wZXJhdGlvbnMgKGxpa2UgaGlkaW5nIHRoZSBvcmlnaW5hbCBjb2x1bW4gb3Igc2h1ZmZsaW5nIGNlbGxzKSwgdGhpcyBjbGFzcyBmb3JjZXNcbiAqICAgICBhIGRlZXAgdXBkYXRlIChgdXBkYXRlRGVwdGg6IC0xYCkgb24gdGhlIGBHcmlkLkJvZHlgLiBUaGlzIGZsdXNoZXMgdGhlIHN0YXRlIG9mIGFsbCBSb3cgY29tcG9uZW50c1xuICogICAgIHRvIHRoZSBWRE9NIHdvcmtlciBpbiBhIHNpbmdsZSBiYXRjaC5cbiAqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5ncmlkLmhlYWRlci50b29sYmFyLlNvcnRab25lXG4gKiBAZXh0ZW5kcyBOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZVxuICovXG5jbGFzcyBTb3J0Wm9uZSBleHRlbmRzIEJhc2VTb3J0Wm9uZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLmdyaWQuaGVhZGVyLnRvb2xiYXIuU29ydFpvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuZ3JpZC5oZWFkZXIudG9vbGJhci5Tb3J0Wm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdncmlkLWhlYWRlci10b29sYmFyLXNvcnR6b25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2dyaWQtaGVhZGVyLXRvb2xiYXItc29ydHpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGl0ZW1NYXJnaW49JzFweCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbU1hcmdpbjogJzFweCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlQ29sdW1uQ29udGVudD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlQ29sdW1uQ29udGVudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVWZXJ0aWNhbD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVZlcnRpY2FsOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLnV0aWwuUmVjdGFuZ2xlfSByZWN0XG4gICAgICogQHBhcmFtIHtOZW8udXRpbC5SZWN0YW5nbGV9IHBhcmVudFJlY3RcbiAgICAgKi9cbiAgICBhZGp1c3RQcm94eVJlY3RUb1BhcmVudChyZWN0LCBwYXJlbnRSZWN0KSB7XG4gICAgICAgIHJlY3QueCA9IHJlY3QueCAtIHBhcmVudFJlY3QueCAtIDE7XG4gICAgICAgIHJlY3QueSA9IHJlY3QueSAtIHBhcmVudFJlY3QueSAtIDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBkcmFnIHByb3h5LlxuICAgICAqXG4gICAgICogKipTdXJnaWNhbCBET00gTW92ZSBJbXBsZW1lbnRhdGlvbjoqKlxuICAgICAqIERldGVjdHMgaWYgYSBjZWxsIGNvbnRhaW5zIGNvbXBvbmVudCBjb250ZW50IChjaGVja2luZyBgY2VsbC5jbmApLiBJZiBmb3VuZCwgaXQgY3JlYXRlcyBhbiBlbXB0eVxuICAgICAqIGNvbnRhaW5lciBpbiB0aGUgcHJveHkncyBWRE9NIGFuZCBzY2hlZHVsZXMgYSBgbW92ZU5vZGVgIGRlbHRhIHRvIHRyYW5zZmVyIHRoZSBsaXZlIGNvbnRlbnRcbiAgICAgKiBmcm9tIHRoZSBHcmlkIHRvIHRoZSBQcm94eSBhZnRlciBtb3VudGluZy4gVGhpcyBieXBhc3NlcyBWRE9NIGNsb25pbmcgZm9yIGhlYXZ5IGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNyZWF0ZUNvbXBvbmVudD10cnVlXG4gICAgICogQHJldHVybnMge09iamVjdHxOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eUNvbXBvbmVudH1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVEcmFnUHJveHkoZGF0YSwgY3JlYXRlQ29tcG9uZW50PXRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdmVDb2x1bW5Db250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuY3JlYXRlRHJhZ1Byb3h5KGRhdGEsIGNyZWF0ZUNvbXBvbmVudClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGdyaWQgICAgICAgICAgPSBtZS5vd25lci5wYXJlbnQsXG4gICAgICAgICAgICB7Ym9keX0gICAgICAgID0gZ3JpZCxcbiAgICAgICAgICAgIGJvZHlXcmFwcGVySWQgPSBOZW8uZ2V0SWQoJ2dyaWQtYm9keS13cmFwcGVyJyksXG4gICAgICAgICAgICBjb2x1bW5JbmRleCAgID0gbWUuZHJhZ0VsZW1lbnRbJ2FyaWEtY29saW5kZXgnXSAtIDEsXG4gICAgICAgICAgICB7ZGF0YUZpZWxkfSAgID0gYm9keS5jb2x1bW5Qb3NpdGlvbnMuZ2V0QXQoY29sdW1uSW5kZXgpLFxuICAgICAgICAgICAgY2VsbHMgICAgICAgICA9IGJvZHkuZ2V0Q29sdW1uQ2VsbHMoZGF0YUZpZWxkKSxcbiAgICAgICAgICAgIHJvd3MgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGNvbmZpZyAgICAgICAgPSBhd2FpdCBzdXBlci5jcmVhdGVEcmFnUHJveHkoZGF0YSwgZmFsc2UpLFxuICAgICAgICAgICAgcmVjdCAgICAgICAgICA9IGF3YWl0IGdyaWQuZ2V0RG9tUmVjdCgpLFxuICAgICAgICAgICAgcm93LCByb3dDb21wb25lbnQ7XG5cbiAgICAgICAgY29uZmlnLmNscyA9IFsnbmVvLWdyaWQtd3JhcHBlcicsIG1lLm93bmVyLmdldFRoZW1lKCldO1xuXG4gICAgICAgIGNvbmZpZy5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodCAtIDJ9cHhgOyAvLyBtaW51cyBib3JkZXItYm90dG9tICYgYm9yZGVyLXRvcFxuXG4gICAgICAgIGxldCBtb3ZlRGVsdGFzID0gW10sXG4gICAgICAgICAgICBwcm94eUNlbGwsIHByb3h5Q2VsbElkO1xuXG4gICAgICAgIG1lLm1vdmVkQ29tcG9uZW50cyA9IFtdO1xuXG4gICAgICAgIGNlbGxzLmZvckVhY2goKGNlbGwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByb3dDb21wb25lbnQgPSBib2R5Lml0ZW1zW2luZGV4XTtcblxuICAgICAgICAgICAgcm93ID0gVmRvbVV0aWwuY2xvbmUoeyAvLyBjbG9uZSB0byByZW1vdmUgaWRzXG4gICAgICAgICAgICAgICAgY2xzICA6IHJvd0NvbXBvbmVudC52ZG9tLmNscyxcbiAgICAgICAgICAgICAgICBzdHlsZTogcm93Q29tcG9uZW50LnZkb20uc3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm94eUNlbGwgPSBWZG9tVXRpbC5jbG9uZShjZWxsKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm94eUNlbGwuaWQ7XG4gICAgICAgICAgICBkZWxldGUgcHJveHlDZWxsLnN0eWxlLmxlZnQ7XG5cbiAgICAgICAgICAgIHByb3h5Q2VsbElkICA9IE5lby5nZXRJZCgncHJveHktY2VsbCcpO1xuICAgICAgICAgICAgcHJveHlDZWxsLmlkID0gcHJveHlDZWxsSWQ7XG5cbiAgICAgICAgICAgIGlmIChjZWxsLmNuICYmIGNlbGwuY24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ICAgPSBjZWxsLmNuWzBdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50SWQgPSBjb250ZW50LmlkIHx8IGNvbnRlbnQuY29tcG9uZW50SWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5Q2VsbC5jbiA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIG1vdmVEZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gIDogJ21vdmVOb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBjb250ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAgIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBwcm94eUNlbGxJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5tb3ZlZENvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgOiBjb250ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFBhcmVudElkOiBjZWxsLmlkXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByb3cuY24gPSBbcHJveHlDZWxsXTtcbiAgICAgICAgICAgIHJvd3MucHVzaChyb3cpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZy52ZG9tID1cbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7Y2xzOiBbJ25lby1ncmlkLWNvbnRhaW5lcicsIC4uLmdyaWQuY2xzXSwgY246IFtcbiAgICAgICAgICAgICAgICB7Li4uY29uZmlnLnZkb20sIGNsczogWyduZW8tZ3JpZC1oZWFkZXItdG9vbGJhcicsICduZW8tdG9vbGJhciddfSxcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1ncmlkLWJvZHktd3JhcHBlciddLCBpZDogYm9keVdyYXBwZXJJZCwgY246IFtcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tZ3JpZC1ib2R5J10sIGNuOiByb3dzfSxcbiAgICAgICAgICAgICAgICAgICAge2NsczogWyduZW8tZ3JpZC1zY3JvbGxiYXInXSwgc3R5bGU6IHtoZWlnaHQ6IGJvZHkudmRvbS5jblswXS5oZWlnaHR9fVxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfTtcblxuICAgICAgICBjb25maWcubGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgbW91bnRlZCgpIHtcbiAgICAgICAgICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogYm9keVdyYXBwZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICA6IGJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChtb3ZlRGVsdGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCBtb3ZlRGVsdGFzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY3JlYXRlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuZHJhZ1Byb3h5ID0gTmVvLmNyZWF0ZShjb25maWcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgbW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICBzdXBlci5tb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgdGhpcy5vd25lci5wYXJlbnQuY29sdW1ucy5tb3ZlKGZyb21JbmRleCwgdG9JbmRleClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIC8vIFJlc3RvcmUgbW92ZWQgbm9kZXMgQkVGT1JFIGRlc3Ryb3lpbmcgdGhlIHByb3h5IHRvIGVuc3VyZSB0aGV5IHJldHVybiB0byB0aGUgR3JpZC5cbiAgICAgICAgaWYgKHRoaXMubW92ZWRDb21wb25lbnRzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgcmVzdG9yZURlbHRhcyA9IHRoaXMubW92ZWRDb21wb25lbnRzLm1hcChpdGVtID0+ICh7XG4gICAgICAgICAgICAgICAgYWN0aW9uICA6ICdtb3ZlTm9kZScsXG4gICAgICAgICAgICAgICAgaWQgICAgICA6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgaW5kZXggICA6IDAsXG4gICAgICAgICAgICAgICAgcGFyZW50SWQ6IGl0ZW0ub3JpZ2luYWxQYXJlbnRJZFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBhd2FpdCBOZW8uYXBwbHlEZWx0YXModGhpcy53aW5kb3dJZCwgcmVzdG9yZURlbHRhcyk7XG4gICAgICAgICAgICB0aGlzLm1vdmVkQ29tcG9uZW50cyA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHN1cGVyLm9uRHJhZ0VuZChkYXRhKTtcblxuICAgICAgICBsZXQge293bmVyfSA9IHRoaXM7XG5cbiAgICAgICAgb3duZXIuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGl0ZW0udmRvbVsnYXJpYS1jb2xpbmRleCddID0gaW5kZXggKyAxOyAvLyAxIGJhc2VkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG93bmVyLnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgb3duZXIudXBkYXRlKCk7XG5cbiAgICAgICAgYXdhaXQgb3duZXIucGFzc1NpemVUb0JvZHkoKTtcblxuICAgICAgICBhd2FpdCB0aGlzLnRpbWVvdXQoMjApO1xuXG4gICAgICAgIG93bmVyLnBhcmVudC5ib2R5LmNyZWF0ZVZpZXdEYXRhKGZhbHNlLCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBhd2FpdCBzdXBlci5vbkRyYWdTdGFydChkYXRhKTtcblxuICAgICAgICBpZiAodGhpcy5tb3ZlQ29sdW1uQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7Ym9keX0gICAgICAgICA9IG1lLm93bmVyLnBhcmVudCxcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCAgICA9IG1lLmRyYWdFbGVtZW50WydhcmlhLWNvbGluZGV4J10gLSAxLFxuICAgICAgICAgICAgICAgIGNvbHVtblBvc2l0aW9uID0gYm9keS5jb2x1bW5Qb3NpdGlvbnMuZ2V0QXQoY29sdW1uSW5kZXgpLFxuICAgICAgICAgICAgICAgIHtkYXRhRmllbGR9ICAgID0gY29sdW1uUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgY2VsbHMgICAgICAgICAgPSBib2R5LmdldENvbHVtbkNlbGxzKGRhdGFGaWVsZCk7XG5cbiAgICAgICAgICAgIGNvbHVtblBvc2l0aW9uLmhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgY2VsbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGb3JjZSBhIGRlZXAgdXBkYXRlIHRvIHByb3BhZ2F0ZSBSb3cgY29tcG9uZW50IFZET00gY2hhbmdlcyAodmlzaWJpbGl0eSkgdG8gdGhlIHdvcmtlci5cbiAgICAgICAgICAgIGJvZHkudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgICAgIGJvZHkudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgyXG4gICAgICovXG4gICAgc3dpdGNoSXRlbXMoaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgc3VwZXIuc3dpdGNoSXRlbXMoaW5kZXgxLCBpbmRleDIpO1xuXG4gICAgICAgIGlmICh0aGlzLm1vdmVDb2x1bW5Db250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtpdGVtUmVjdHN9ICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAge2JvZHl9ICAgICAgICAgICAgPSBtZS5vd25lci5wYXJlbnQsXG4gICAgICAgICAgICAgICAge2NvbHVtblBvc2l0aW9uc30gPSBib2R5LFxuICAgICAgICAgICAgICAgIGNvbHVtbjFQb3NpdGlvbiAgID0gY29sdW1uUG9zaXRpb25zLmdldEF0KGluZGV4MSksXG4gICAgICAgICAgICAgICAgY29sdW1uMlBvc2l0aW9uICAgPSBjb2x1bW5Qb3NpdGlvbnMuZ2V0QXQoaW5kZXgyKSxcbiAgICAgICAgICAgICAgICBjb2x1bW4xQ2VsbHMgICAgICA9IGJvZHkuZ2V0Q29sdW1uQ2VsbHMoY29sdW1uMVBvc2l0aW9uLmRhdGFGaWVsZCksXG4gICAgICAgICAgICAgICAgY29sdW1uMkNlbGxzICAgICAgPSBib2R5LmdldENvbHVtbkNlbGxzKGNvbHVtbjJQb3NpdGlvbi5kYXRhRmllbGQpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbHVtbjFQb3NpdGlvbiwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtUmVjdHNbaW5kZXgyXS53aWR0aCxcbiAgICAgICAgICAgICAgICB4ICAgIDogaXRlbVJlY3RzW2luZGV4Ml0ueCArIDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbHVtbjJQb3NpdGlvbiwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtUmVjdHNbaW5kZXgxXS53aWR0aCxcbiAgICAgICAgICAgICAgICB4ICAgIDogaXRlbVJlY3RzW2luZGV4MV0ueCArIDFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb2x1bW5Qb3NpdGlvbnMubW92ZShpbmRleDEsIGluZGV4Mik7XG5cbiAgICAgICAgICAgIGNvbHVtbjFDZWxscy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCAgPSBjb2x1bW4xUG9zaXRpb24ueCAgICAgKyAncHgnO1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSBjb2x1bW4xUG9zaXRpb24ud2lkdGggKyAncHgnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29sdW1uMkNlbGxzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ICA9IGNvbHVtbjJQb3NpdGlvbi54ICAgICArICdweCc7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IGNvbHVtbjJQb3NpdGlvbi53aWR0aCArICdweCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGb3JjZSBhIGRlZXAgdXBkYXRlIHRvIHByb3BhZ2F0ZSBSb3cgY29tcG9uZW50IFZET00gY2hhbmdlcyAocG9zaXRpb24pIHRvIHRoZSB3b3JrZXIuXG4gICAgICAgICAgICBib2R5LnVwZGF0ZURlcHRoID0gLTE7XG4gICAgICAgICAgICBib2R5LnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFNvcnRab25lKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==