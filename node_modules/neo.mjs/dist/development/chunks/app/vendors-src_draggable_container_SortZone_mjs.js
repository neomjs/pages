"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_container_SortZone_mjs"],{

/***/ "./src/draggable/container/DragZone.mjs":
/*!**********************************************!*\
  !*** ./src/draggable/container/DragZone.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.draggable.container.DragZone
 * @extends Neo.draggable.DragZone
 */
class DragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.container.DragZone'
         * @protected
         */
        className: 'Neo.draggable.container.DragZone',
        /**
         * @member {String} ntype='container-dragzone'
         * @protected
         */
        ntype: 'container-dragzone'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            opts    = {delegate: '.neo-draggable', scope: me};

        owner.addDomListeners([
            {'drag:end'  : me.onDragEnd,   ...opts},
            {'drag:move' : me.onDragMove,  ...opts},
            {'drag:start': me.onDragStart, ...opts}
        ]);

        owner.on({
            insert      : me.onItemInsert,
            itemsCreated: me.onItemsCreated,
            scope       : me
        });

        // The container items can already be created
        me.adjustItemCls(true);
    }

    /**
     * @param {Boolean} draggable
     */
    adjustItemCls(draggable) {
        let me      = this,
            {owner} = me,
            wrapperCls;

        owner.items.forEach(item => {
            // spacers
            if (typeof item === 'string') {
                return;
            }

            wrapperCls = item.wrapperCls || [];

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
            item.wrapperCls = wrapperCls;
        });
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.owner.draggable) {
            let me           = this,
                proxy        = me.dragProxy,
                cls          = proxy.cls || {},
                rect         = me.dragElementRect,
                wrapperStyle = proxy.wrapperStyle || {};

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-animate');
            proxy.cls = cls;

            // ensure to get into the next animation frame
            me.timeout(30).then(() => {
                wrapperStyle.left = `${rect.left}px`;
                wrapperStyle.top  = `${rect.top}px`;

                proxy.wrapperStyle = wrapperStyle;

                me.timeout(100).then(() => {
                    me.dragEnd();
                });
            });
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me = this;

        if (me.owner.draggable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.owner.vdom, data.path[0].id).vdom;
            await me.dragStart(data);
        }
    }

    /**
     * @param {Object}             data
     * @param {Number}             data.index
     * @param {Neo.component.Base} data.item
     */
    onItemInsert(data) {
        let {item}     = data,
            wrapperCls = item.wrapperCls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, 'neo-draggable');
        item.wrapperCls = wrapperCls;
    }

    /**
     * @param {Object}               data
     * @param {String}               data.id
     * @param {Neo.component.Base[]} data.items
     */
    onItemsCreated(data) {
        this.adjustItemCls(true);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragZone));


/***/ }),

/***/ "./src/draggable/container/SortZone.mjs":
/*!**********************************************!*\
  !*** ./src/draggable/container/SortZone.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragZone.mjs */ "./src/draggable/container/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");





/**
 * @class Neo.draggable.container.SortZone
 * @extends Neo.draggable.container.DragZone
 */
class SortZone extends _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.container.SortZone'
         * @protected
         */
        className: 'Neo.draggable.container.SortZone',
        /**
         * @member {String} ntype='container-sortzone'
         * @protected
         */
        ntype: 'container-sortzone',
        /**
         * Depending on the parent structure using position absolute and relative, it can be needed to subtract
         * the x & y parent rect values from the item rects.
         * @member {Boolean} adjustItemRectsToParent=false
         */
        adjustItemRectsToParent: false,
        /**
         * @member {Boolean} alwaysFireDragMove=true
         */
        alwaysFireDragMove: true,
        /**
         * @member {Number} currentIndex=-1
         * @protected
         */
        currentIndex: -1,
        /**
         * A CSS selector to identify the drag handle within a component.
         * If specified, the drag is initiated on this element, but the owning component is dragged.
         * @member {String|null} dragHandleSelector=null
         */
        dragHandleSelector: null,
        /**
         * @member {Boolean} enableProxyToPopup=false
         */
        enableProxyToPopup: false,
        /**
         * @member {Object} indexMap=null
         * @protected
         */
        indexMap: null,
        /**
         * @member {String|null} itemMargin=null
         * @protected
         */
        itemMargin: null,
        /**
         * @member {Array|null} itemRects=null
         * @protected
         */
        itemRects: null,
        /**
         * @member {Array|null} itemStyles=null
         * @protected
         */
        itemStyles: null,
        /**
         * @member {Object} ownerRect=null
         * @protected
         */
        ownerRect: null,
        /**
         * @member {Object} ownerStyle=null
         * @protected
         */
        ownerStyle: null,
        /**
         * @member {Boolean} alwaysFireDragMove=false
         * @protected
         */
        reversedLayoutDirection: false,
        /**
         * @member {Number} scrollLeft=0
         */
        scrollLeft: 0,
        /**
         * @member {Number} scrollTop=0
         */
        scrollTop: 0,
        /**
         * Internal flag: onDragStart() will set the value to horizontal or vertical, depending on the current layout.
         * @member {String} sortDirection='horizontal'
         * @protected
         */
        sortDirection: 'horizontal',
        /**
         * @member {Number} startIndex=-1
         * @protected
         */
        startIndex: -1
    }

    /**
     * @member {Boolean} isOverDragging=false
     * @protected
     */
    isOverDragging = false
    /**
     * @member {Boolean} isWindowDragging=false
     * @protected
     */
    isWindowDragging = false

    /**
     * Toggles the neo-draggable cls on items inside our owner.
     * @param {Boolean} draggable
     */
    adjustItemCls(draggable) {
        let me = this;

        if (me.dragHandleSelector) {
            const handleCls     = me.dragHandleSelector.startsWith('.') ? me.dragHandleSelector.substring(1) : me.dragHandleSelector;
            const sortableItems = me.owner.items.filter(item =>
                typeof item !== 'string' && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(item.vdom, {cls: handleCls})
            );

            sortableItems.forEach(item => {
                const wrapperCls = item.wrapperCls || [];
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
                item.wrapperCls = wrapperCls
            });
        } else {
            super.adjustItemCls(draggable)
        }
    }

    /**
     * Helper method, override as needed
     * @returns {Object}
     */
    getDragProxyConfig() {
        return {...this.dragProxyConfig, cls: [...this.owner.cls]}
    }

    /**
     * Override this method for class extensions (e.g. tab.header.Toolbar)
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        this.owner.moveTo(fromIndex, toIndex);
    }

    /**
     * @param {Object} data
     */
    async onDragEnd(data) {
        let me                  = this,
            {itemStyles, owner} = me,
            ownerStyle          = owner.style || {},
            itemStyle;

        await me.timeout(10);

        if (owner.sortable) {
            ownerStyle.height   = me.ownerStyle.height    || null;
            ownerStyle.minWidth = me.ownerStyle.minWidth  || null;
            ownerStyle.width    = me.ownerStyle.width     || null;

            owner.style = ownerStyle;

            me.sortableItems.forEach((item, index) => {
                itemStyle = item.wrapperStyle || {};

                Object.assign(itemStyle, {
                    height  : itemStyles[index].height || null,
                    left    : null,
                    margin  : null,
                    position: null,
                    top     : null,
                    width   : itemStyles[index].width || null
                });

                if (index === me.startIndex) {
                    itemStyle.visibility = null
                }

                item.wrapperStyle = itemStyle
            });

            if (me.startIndex !== me.currentIndex) {
                me.moveTo(
                    me.owner.items.indexOf(me.sortableItems[me.startIndex]),
                    me.owner.items.indexOf(me.sortableItems[me.currentIndex])
                );
            }

            Object.assign(me, {
                currentIndex : -1,
                indexMap     : null,
                itemRects    : null,
                itemStyles   : null,
                ownerRect    : null,
                startIndex   : -1,
                sortableItems: null
            });

            await me.timeout(30);

            me.dragEnd(data) // we do not want to trigger the super class call here
        }
    }

    /**
     * @param {Object} data
     */
    async onDragMove(data) {
        let me = this;

        // The method can trigger before we got the client rects from the main thread
        if (!me.itemRects || me.isScrolling) {
            return
        }

        if (me.dragProxy && me.enableProxyToPopup) {
            const {proxyRect} = data;

            if (proxyRect && me.boundaryContainerRect) {
                const
                    boundaryRect     = me.boundaryContainerRect,
                    intersection     = _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersection(proxyRect, boundaryRect),
                    proxyArea        = proxyRect.width * proxyRect.height,
                    intersectionArea = intersection ? intersection.width * intersection.height : 0;

                if (!me.isWindowDragging) {
                    if (proxyArea > 0 && (intersectionArea / proxyArea) < 0.5) {
                        me.isWindowDragging = true; // Set flag to prevent re-entry

                        me.fire('dragBoundaryExit', {
                            draggedItem: Neo.getComponent(me.dragElement.id),
                            proxyRect,
                            sortZone   : me
                        });
                        return // Stop further processing in onDragMove
                    }
                } else if (me.isWindowDragging) {
                    if (proxyArea > 0 && (intersectionArea / proxyArea) > 0.51) {
                        me.fire('dragBoundaryEntry', {
                            draggedItem: Neo.getComponent(me.dragElement.id),
                            proxyRect,
                            sortZone   : me
                        });
                    }
                    return;
                }
            }
        }

        let {clientX, clientY} = data,
            index              = me.currentIndex,
            {itemRects}        = me,
            maxItems           = itemRects.length - 1,
            ownerX             = me.adjustItemRectsToParent ? me.ownerRect.x : 0,
            ownerY             = me.adjustItemRectsToParent ? me.ownerRect.y : 0,
            reversed           = me.reversedLayoutDirection,
            delta, isOverDragging, isOverDraggingEnd, isOverDraggingStart, itemHeightOrWidth, moveFactor;

        if (me.sortDirection === 'horizontal') {
            delta               = clientX - ownerX + me.scrollLeft - me.offsetX - itemRects[index].left;
            isOverDraggingEnd   = clientX > me.boundaryContainerRect.right;
            isOverDraggingStart = clientX < me.boundaryContainerRect.left;
            itemHeightOrWidth   = 'width'
        } else {
            delta               = clientY - ownerY + me.scrollTop - me.offsetY - itemRects[index].top;
            isOverDraggingEnd   = clientY > me.boundaryContainerRect.bottom;
            isOverDraggingStart = clientY < me.boundaryContainerRect.top;
            itemHeightOrWidth   = 'height'
        }

        isOverDragging = isOverDraggingEnd || isOverDraggingStart;
        moveFactor     = isOverDragging ? 0.02 : 0.55; // We can not use 0.5, since items would jump back & forth

        if (isOverDraggingStart) {
            if (index > 0) {
                me.currentIndex--;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (isOverDraggingEnd) {
            if (index < maxItems) {
                me.currentIndex++;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index > 0 && (!reversed && delta < 0 || reversed && delta > 0)) {
            if (Math.abs(delta) > itemRects[index - 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex--;
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index < maxItems && (!reversed && delta > 0 || reversed && delta < 0)) {
            if (Math.abs(delta) > itemRects[index + 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex++;
                me.switchItems(index, me.currentIndex)
            }
        }

        me.isOverDragging = isOverDragging && me.currentIndex !== 0 && me.currentIndex !== maxItems;

        if (me.isOverDragging) {
            await me.timeout(30); // wait for 1 frame

            if (me.isOverDragging) {
                await me.onDragMove(data)
            }
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me                   = this,
            {adjustItemRectsToParent, dragHandleSelector, owner} = me,
            itemStyles           = me.itemStyles = [],
            {layout}             = owner,
            ownerStyle           = owner.style || {},
            draggedItem, index, indexMap, itemStyle, rect, sortableItems;

        if (owner.sortable) {
            if (dragHandleSelector) {
                const handleClassName = dragHandleSelector.substring(1);
                const handleNode      = data.path.find(node => node.cls.includes(handleClassName));

                if (!handleNode) {
                    return;
                }

                const handleIndex = data.path.indexOf(handleNode);

                for (let i = handleIndex; i < data.path.length; i++) {
                    const potentialItemNode = data.path[i];
                    const component = Neo.getComponent(potentialItemNode.id);

                    if (component && owner.items.includes(component)) {
                        draggedItem = component;
                        break;
                    }
                }

                if (!draggedItem) {
                    return;
                }

                sortableItems = owner.items.filter(item => _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(item.vdom, {
                    cls: dragHandleSelector.startsWith('.') ? dragHandleSelector.substring(1) : dragHandleSelector
                }));
                index         = sortableItems.indexOf(draggedItem);

                if (index < 0) {
                    return;
                }
            } else {
                draggedItem   = Neo.getComponent(data.path[0].id);
                sortableItems = owner.items;
                index         = owner.indexOf(draggedItem.id);
            }

            indexMap = {};

            Object.assign(me, {
                currentIndex           : index,
                dragElement            : _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, draggedItem.id).vdom,
                dragProxyConfig        : me.getDragProxyConfig(),
                indexMap,
                ownerStyle             : {height: ownerStyle.height, minWidth: ownerStyle.minWidth, width: ownerStyle.width},
                reversedLayoutDirection: layout.direction === 'column-reverse' || layout.direction === 'row-reverse',
                sortableItems,
                sortDirection          : layout.direction?.includes('column') ? 'vertical' : 'horizontal',
                startIndex             : index
            });

            await me.dragStart(data);

            sortableItems.forEach((item, i) => {
                indexMap[i] = owner.items.indexOf(item);

                itemStyles.push({
                    height: item.height ? `${item.height}px` :  item.style?.height,
                    width : item.width  ? `${item.width}px`  :  item.style?.width
                });
            });

            const itemRects = await owner.getDomRect([owner.id].concat(sortableItems.map(e => e.id)));

            me.ownerRect = itemRects.shift();

            owner.style = {
                ...ownerStyle,
                height  : `${me.ownerRect.height}px`,
                minWidth: `${me.ownerRect.width}px`,
                width   : `${me.ownerRect.width}px`
            };

            adjustItemRectsToParent && itemRects.forEach(rect => {
                rect.x -= me.ownerRect.x;
                rect.y -= me.ownerRect.y
            });

            me.itemRects = itemRects;

            sortableItems.forEach((item, i) => {
                itemStyle = item.wrapperStyle || {};
                rect      = me.itemRects[i];

                me.adjustProxyRectToParent?.(rect, me.ownerRect);

                item.wrapperStyle = Object.assign(itemStyle, {
                    height  : `${rect.height}px`,
                    left    : `${rect.left}px`,
                    margin  : me.itemMargin,
                    position: 'absolute',
                    top     : `${rect.top}px`,
                    width   : `${rect.width}px`
                });
            });

            await me.timeout(5);

            itemStyle = draggedItem.wrapperStyle || {};
            itemStyle.visibility = 'hidden';
            draggedItem.wrapperStyle = itemStyle;
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async scrollToIndex() {
        let me = this;

        me.isScrolling = true;
        await me.owner.scrollToIndex?.(me.currentIndex, me.itemRects[me.currentIndex]);
        me.isScrolling = false
    }

    /**
     * @param {Object} data
     */
    startWindowDrag(data) {
        let me            = this,
            {popupHeight, popupWidth, windowName} = data;

        // Hide the drag proxy since the window is now the visual indicator
        me.dragProxy.hidden = true;

        Neo.main.addon.DragDrop.startWindowDrag({
            popupHeight,
            popupName: windowName,
            popupWidth
        });
    }

    /**
     * @param {Number} index1
     * @param {Number} index2
     */
    switchItems(index1, index2) {
        let me       = this,
            reversed = me.reversedLayoutDirection,
            tmp;

        if ((!reversed && index2 < index1) || (reversed && index1 < index2)) {
            tmp    = index1;
            index1 = index2;
            index2 = tmp;
        }

        let itemRects = me.itemRects,
            map       = me.indexMap,
            rect1     = itemRects[index1],
            rect2     = itemRects[index2],
            rect1Copy = rect1.clone(),
            rect2Copy = rect2.clone();

        if (me.sortDirection === 'horizontal') {
            rect1.width = rect2Copy.width;
            rect2.x     = rect1Copy.x + rect2Copy.width;
            rect2.width = rect1Copy.width
        } else {
            rect1.height = rect2Copy.height;
            rect2.height = rect1Copy.height;
            rect2.y      = rect1Copy.y + rect2Copy.height;
        }

        tmp         = map[index1];
        map[index1] = map[index2];
        map[index2] = tmp;

        me.updateItem(index1, rect1);
        me.updateItem(index2, rect2)
    }

    /**
     * @param {Number} index
     * @param {Object} rect
     */
    updateItem(index, rect) {
        let me             = this,
            item           = me.owner.items[me.indexMap[index]],
            {wrapperStyle} = item;

        wrapperStyle.left = `${rect.left}px`;
        wrapperStyle.top  = `${rect.top}px`;

        item.wrapperStyle = wrapperStyle
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SortZone));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfY29udGFpbmVyX1NvcnRab25lX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ1I7QUFDRDs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0RBQVk7QUFDbkM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLHVCQUF1Qjs7QUFFdkI7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLHNDQUFzQztBQUNuRCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLHVEQUFRO0FBQ3BCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQSxZQUFZLHVEQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRCx1Q0FBdUMsU0FBUzs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsc0RBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBLGFB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QjtBQUNqRCw2QkFBNkIsbUJBQW1CO0FBQ2hELDZCQUE2QixtQkFBbUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QyxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUMsaUNBQWlDLFdBQVc7QUFDNUMsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7O0FBRTNCLCtCQUErQixVQUFVO0FBQ3pDLCtCQUErQixTQUFTOztBQUV4QztBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsd0JBQXdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9jb250YWluZXIvRHJhZ1pvbmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL2NvbnRhaW5lci9Tb3J0Wm9uZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VEcmFnWm9uZSBmcm9tICcuLi8uLi9kcmFnZ2FibGUvRHJhZ1pvbmUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuRHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqL1xuY2xhc3MgRHJhZ1pvbmUgZXh0ZW5kcyBCYXNlRHJhZ1pvbmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5jb250YWluZXIuRHJhZ1pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuY29udGFpbmVyLkRyYWdab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbnRhaW5lci1kcmFnem9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb250YWluZXItZHJhZ3pvbmUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgb3B0cyAgICA9IHtkZWxlZ2F0ZTogJy5uZW8tZHJhZ2dhYmxlJywgc2NvcGU6IG1lfTtcblxuICAgICAgICBvd25lci5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25EcmFnRW5kLCAgIC4uLm9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25EcmFnTW92ZSwgIC4uLm9wdHN9LFxuICAgICAgICAgICAgeydkcmFnOnN0YXJ0JzogbWUub25EcmFnU3RhcnQsIC4uLm9wdHN9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIG93bmVyLm9uKHtcbiAgICAgICAgICAgIGluc2VydCAgICAgIDogbWUub25JdGVtSW5zZXJ0LFxuICAgICAgICAgICAgaXRlbXNDcmVhdGVkOiBtZS5vbkl0ZW1zQ3JlYXRlZCxcbiAgICAgICAgICAgIHNjb3BlICAgICAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGhlIGNvbnRhaW5lciBpdGVtcyBjYW4gYWxyZWFkeSBiZSBjcmVhdGVkXG4gICAgICAgIG1lLmFkanVzdEl0ZW1DbHModHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkcmFnZ2FibGVcbiAgICAgKi9cbiAgICBhZGp1c3RJdGVtQ2xzKGRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICB3cmFwcGVyQ2xzO1xuXG4gICAgICAgIG93bmVyLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAvLyBzcGFjZXJzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwcGVyQ2xzID0gaXRlbS53cmFwcGVyQ2xzIHx8IFtdO1xuXG4gICAgICAgICAgICBOZW9BcnJheS50b2dnbGUod3JhcHBlckNscywgJ25lby1kcmFnZ2FibGUnLCBkcmFnZ2FibGUpO1xuICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNscztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5vd25lci5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHByb3h5ICAgICAgICA9IG1lLmRyYWdQcm94eSxcbiAgICAgICAgICAgICAgICBjbHMgICAgICAgICAgPSBwcm94eS5jbHMgfHwge30sXG4gICAgICAgICAgICAgICAgcmVjdCAgICAgICAgID0gbWUuZHJhZ0VsZW1lbnRSZWN0LFxuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IHByb3h5LndyYXBwZXJTdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgJ25lby1hbmltYXRlJyk7XG4gICAgICAgICAgICBwcm94eS5jbHMgPSBjbHM7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBnZXQgaW50byB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgICAgIG1lLnRpbWVvdXQoMzApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUudG9wICA9IGAke3JlY3QudG9wfXB4YDtcblxuICAgICAgICAgICAgICAgIHByb3h5LndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZTtcblxuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoMTAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ0VuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ1N0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUub3duZXIuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBtZS5kcmFnRWxlbWVudCA9IFZEb21VdGlsLmZpbmQobWUub3duZXIudmRvbSwgZGF0YS5wYXRoWzBdLmlkKS52ZG9tO1xuICAgICAgICAgICAgYXdhaXQgbWUuZHJhZ1N0YXJ0KGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgZGF0YS5pbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBkYXRhLml0ZW1cbiAgICAgKi9cbiAgICBvbkl0ZW1JbnNlcnQoZGF0YSkge1xuICAgICAgICBsZXQge2l0ZW19ICAgICA9IGRhdGEsXG4gICAgICAgICAgICB3cmFwcGVyQ2xzID0gaXRlbS53cmFwcGVyQ2xzIHx8IFtdO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZCh3cmFwcGVyQ2xzLCAnbmVvLWRyYWdnYWJsZScpO1xuICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgICBkYXRhLmlkXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2VbXX0gZGF0YS5pdGVtc1xuICAgICAqL1xuICAgIG9uSXRlbXNDcmVhdGVkKGRhdGEpIHtcbiAgICAgICAgdGhpcy5hZGp1c3RJdGVtQ2xzKHRydWUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRHJhZ1pvbmUpO1xuIiwiaW1wb3J0IERyYWdab25lICBmcm9tICcuL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lXG4gKiBAZXh0ZW5kcyBOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5EcmFnWm9uZVxuICovXG5jbGFzcyBTb3J0Wm9uZSBleHRlbmRzIERyYWdab25lIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb250YWluZXItc29ydHpvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29udGFpbmVyLXNvcnR6b25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcGVuZGluZyBvbiB0aGUgcGFyZW50IHN0cnVjdHVyZSB1c2luZyBwb3NpdGlvbiBhYnNvbHV0ZSBhbmQgcmVsYXRpdmUsIGl0IGNhbiBiZSBuZWVkZWQgdG8gc3VidHJhY3RcbiAgICAgICAgICogdGhlIHggJiB5IHBhcmVudCByZWN0IHZhbHVlcyBmcm9tIHRoZSBpdGVtIHJlY3RzLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhZGp1c3RJdGVtUmVjdHNUb1BhcmVudD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWx3YXlzRmlyZURyYWdNb3ZlPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFsd2F5c0ZpcmVEcmFnTW92ZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY3VycmVudEluZGV4PS0xXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnRJbmRleDogLTEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIENTUyBzZWxlY3RvciB0byBpZGVudGlmeSB0aGUgZHJhZyBoYW5kbGUgd2l0aGluIGEgY29tcG9uZW50LlxuICAgICAgICAgKiBJZiBzcGVjaWZpZWQsIHRoZSBkcmFnIGlzIGluaXRpYXRlZCBvbiB0aGlzIGVsZW1lbnQsIGJ1dCB0aGUgb3duaW5nIGNvbXBvbmVudCBpcyBkcmFnZ2VkLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZHJhZ0hhbmRsZVNlbGVjdG9yPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdIYW5kbGVTZWxlY3RvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZVByb3h5VG9Qb3B1cD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlUHJveHlUb1BvcHVwOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaW5kZXhNYXA9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbmRleE1hcDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBpdGVtTWFyZ2luPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbU1hcmdpbjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGl0ZW1SZWN0cz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1SZWN0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGl0ZW1TdHlsZXM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtU3R5bGVzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBvd25lclJlY3Q9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lclJlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG93bmVyU3R5bGU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lclN0eWxlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWx3YXlzRmlyZURyYWdNb3ZlPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJldmVyc2VkTGF5b3V0RGlyZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsTGVmdD0wXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzY3JvbGxUb3A9MFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsVG9wOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZzogb25EcmFnU3RhcnQoKSB3aWxsIHNldCB0aGUgdmFsdWUgdG8gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGxheW91dC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBzb3J0RGlyZWN0aW9uPSdob3Jpem9udGFsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0RGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHN0YXJ0SW5kZXg9LTFcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRJbmRleDogLTFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc092ZXJEcmFnZ2luZz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc092ZXJEcmFnZ2luZyA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNXaW5kb3dEcmFnZ2luZz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc1dpbmRvd0RyYWdnaW5nID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIG5lby1kcmFnZ2FibGUgY2xzIG9uIGl0ZW1zIGluc2lkZSBvdXIgb3duZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkcmFnZ2FibGVcbiAgICAgKi9cbiAgICBhZGp1c3RJdGVtQ2xzKGRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5kcmFnSGFuZGxlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNscyAgICAgPSBtZS5kcmFnSGFuZGxlU2VsZWN0b3Iuc3RhcnRzV2l0aCgnLicpID8gbWUuZHJhZ0hhbmRsZVNlbGVjdG9yLnN1YnN0cmluZygxKSA6IG1lLmRyYWdIYW5kbGVTZWxlY3RvcjtcbiAgICAgICAgICAgIGNvbnN0IHNvcnRhYmxlSXRlbXMgPSBtZS5vd25lci5pdGVtcy5maWx0ZXIoaXRlbSA9PlxuICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJyAmJiBWRG9tVXRpbC5maW5kKGl0ZW0udmRvbSwge2NsczogaGFuZGxlQ2xzfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVyQ2xzID0gaXRlbS53cmFwcGVyQ2xzIHx8IFtdO1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZSh3cmFwcGVyQ2xzLCAnbmVvLWRyYWdnYWJsZScsIGRyYWdnYWJsZSk7XG4gICAgICAgICAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5hZGp1c3RJdGVtQ2xzKGRyYWdnYWJsZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QsIG92ZXJyaWRlIGFzIG5lZWRlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RHJhZ1Byb3h5Q29uZmlnKCkge1xuICAgICAgICByZXR1cm4gey4uLnRoaXMuZHJhZ1Byb3h5Q29uZmlnLCBjbHM6IFsuLi50aGlzLm93bmVyLmNsc119XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgZm9yIGNsYXNzIGV4dGVuc2lvbnMgKGUuZy4gdGFiLmhlYWRlci5Ub29sYmFyKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleFxuICAgICAqL1xuICAgIG1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgdGhpcy5vd25lci5tb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpdGVtU3R5bGVzLCBvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIG93bmVyU3R5bGUgICAgICAgICAgPSBvd25lci5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZTtcblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDEwKTtcblxuICAgICAgICBpZiAob3duZXIuc29ydGFibGUpIHtcbiAgICAgICAgICAgIG93bmVyU3R5bGUuaGVpZ2h0ICAgPSBtZS5vd25lclN0eWxlLmhlaWdodCAgICB8fCBudWxsO1xuICAgICAgICAgICAgb3duZXJTdHlsZS5taW5XaWR0aCA9IG1lLm93bmVyU3R5bGUubWluV2lkdGggIHx8IG51bGw7XG4gICAgICAgICAgICBvd25lclN0eWxlLndpZHRoICAgID0gbWUub3duZXJTdHlsZS53aWR0aCAgICAgfHwgbnVsbDtcblxuICAgICAgICAgICAgb3duZXIuc3R5bGUgPSBvd25lclN0eWxlO1xuXG4gICAgICAgICAgICBtZS5zb3J0YWJsZUl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlID0gaXRlbS53cmFwcGVyU3R5bGUgfHwge307XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW1TdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgIDogaXRlbVN0eWxlc1tpbmRleF0uaGVpZ2h0IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW4gIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgIDogaXRlbVN0eWxlc1tpbmRleF0ud2lkdGggfHwgbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBtZS5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1TdHlsZS52aXNpYmlsaXR5ID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gaXRlbVN0eWxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1lLnN0YXJ0SW5kZXggIT09IG1lLmN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIG1lLm1vdmVUbyhcbiAgICAgICAgICAgICAgICAgICAgbWUub3duZXIuaXRlbXMuaW5kZXhPZihtZS5zb3J0YWJsZUl0ZW1zW21lLnN0YXJ0SW5kZXhdKSxcbiAgICAgICAgICAgICAgICAgICAgbWUub3duZXIuaXRlbXMuaW5kZXhPZihtZS5zb3J0YWJsZUl0ZW1zW21lLmN1cnJlbnRJbmRleF0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA6IC0xLFxuICAgICAgICAgICAgICAgIGluZGV4TWFwICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgaXRlbVJlY3RzICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGVzICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIG93bmVyUmVjdCAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCAgIDogLTEsXG4gICAgICAgICAgICAgICAgc29ydGFibGVJdGVtczogbnVsbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApO1xuXG4gICAgICAgICAgICBtZS5kcmFnRW5kKGRhdGEpIC8vIHdlIGRvIG5vdCB3YW50IHRvIHRyaWdnZXIgdGhlIHN1cGVyIGNsYXNzIGNhbGwgaGVyZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBUaGUgbWV0aG9kIGNhbiB0cmlnZ2VyIGJlZm9yZSB3ZSBnb3QgdGhlIGNsaWVudCByZWN0cyBmcm9tIHRoZSBtYWluIHRocmVhZFxuICAgICAgICBpZiAoIW1lLml0ZW1SZWN0cyB8fCBtZS5pc1Njcm9sbGluZykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuZHJhZ1Byb3h5ICYmIG1lLmVuYWJsZVByb3h5VG9Qb3B1cCkge1xuICAgICAgICAgICAgY29uc3Qge3Byb3h5UmVjdH0gPSBkYXRhO1xuXG4gICAgICAgICAgICBpZiAocHJveHlSZWN0ICYmIG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5UmVjdCAgICAgPSBtZS5ib3VuZGFyeUNvbnRhaW5lclJlY3QsXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbiAgICAgPSBSZWN0YW5nbGUuZ2V0SW50ZXJzZWN0aW9uKHByb3h5UmVjdCwgYm91bmRhcnlSZWN0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBcmVhICAgICAgICA9IHByb3h5UmVjdC53aWR0aCAqIHByb3h5UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbkFyZWEgPSBpbnRlcnNlY3Rpb24gPyBpbnRlcnNlY3Rpb24ud2lkdGggKiBpbnRlcnNlY3Rpb24uaGVpZ2h0IDogMDtcblxuICAgICAgICAgICAgICAgIGlmICghbWUuaXNXaW5kb3dEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJveHlBcmVhID4gMCAmJiAoaW50ZXJzZWN0aW9uQXJlYSAvIHByb3h5QXJlYSkgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmlzV2luZG93RHJhZ2dpbmcgPSB0cnVlOyAvLyBTZXQgZmxhZyB0byBwcmV2ZW50IHJlLWVudHJ5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2RyYWdCb3VuZGFyeUV4aXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEl0ZW06IE5lby5nZXRDb21wb25lbnQobWUuZHJhZ0VsZW1lbnQuaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0Wm9uZSAgIDogbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8vIFN0b3AgZnVydGhlciBwcm9jZXNzaW5nIGluIG9uRHJhZ01vdmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuaXNXaW5kb3dEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJveHlBcmVhID4gMCAmJiAoaW50ZXJzZWN0aW9uQXJlYSAvIHByb3h5QXJlYSkgPiAwLjUxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5maXJlKCdkcmFnQm91bmRhcnlFbnRyeScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbTogTmVvLmdldENvbXBvbmVudChtZS5kcmFnRWxlbWVudC5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRab25lICAgOiBtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7Y2xpZW50WCwgY2xpZW50WX0gPSBkYXRhLFxuICAgICAgICAgICAgaW5kZXggICAgICAgICAgICAgID0gbWUuY3VycmVudEluZGV4LFxuICAgICAgICAgICAge2l0ZW1SZWN0c30gICAgICAgID0gbWUsXG4gICAgICAgICAgICBtYXhJdGVtcyAgICAgICAgICAgPSBpdGVtUmVjdHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG93bmVyWCAgICAgICAgICAgICA9IG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gbWUub3duZXJSZWN0LnggOiAwLFxuICAgICAgICAgICAgb3duZXJZICAgICAgICAgICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyBtZS5vd25lclJlY3QueSA6IDAsXG4gICAgICAgICAgICByZXZlcnNlZCAgICAgICAgICAgPSBtZS5yZXZlcnNlZExheW91dERpcmVjdGlvbixcbiAgICAgICAgICAgIGRlbHRhLCBpc092ZXJEcmFnZ2luZywgaXNPdmVyRHJhZ2dpbmdFbmQsIGlzT3ZlckRyYWdnaW5nU3RhcnQsIGl0ZW1IZWlnaHRPcldpZHRoLCBtb3ZlRmFjdG9yO1xuXG4gICAgICAgIGlmIChtZS5zb3J0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGRlbHRhICAgICAgICAgICAgICAgPSBjbGllbnRYIC0gb3duZXJYICsgbWUuc2Nyb2xsTGVmdCAtIG1lLm9mZnNldFggLSBpdGVtUmVjdHNbaW5kZXhdLmxlZnQ7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gY2xpZW50WCA+IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5yaWdodDtcbiAgICAgICAgICAgIGlzT3ZlckRyYWdnaW5nU3RhcnQgPSBjbGllbnRYIDwgbWUuYm91bmRhcnlDb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0T3JXaWR0aCAgID0gJ3dpZHRoJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgICAgICAgICAgICAgICA9IGNsaWVudFkgLSBvd25lclkgKyBtZS5zY3JvbGxUb3AgLSBtZS5vZmZzZXRZIC0gaXRlbVJlY3RzW2luZGV4XS50b3A7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gY2xpZW50WSA+IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5ib3R0b207XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ1N0YXJ0ID0gY2xpZW50WSA8IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0T3JXaWR0aCAgID0gJ2hlaWdodCdcbiAgICAgICAgfVxuXG4gICAgICAgIGlzT3ZlckRyYWdnaW5nID0gaXNPdmVyRHJhZ2dpbmdFbmQgfHwgaXNPdmVyRHJhZ2dpbmdTdGFydDtcbiAgICAgICAgbW92ZUZhY3RvciAgICAgPSBpc092ZXJEcmFnZ2luZyA/IDAuMDIgOiAwLjU1OyAvLyBXZSBjYW4gbm90IHVzZSAwLjUsIHNpbmNlIGl0ZW1zIHdvdWxkIGp1bXAgYmFjayAmIGZvcnRoXG5cbiAgICAgICAgaWYgKGlzT3ZlckRyYWdnaW5nU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5zY3JvbGxUb0luZGV4KCk7XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGlzT3ZlckRyYWdnaW5nRW5kKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBtYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnNjcm9sbFRvSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPiAwICYmICghcmV2ZXJzZWQgJiYgZGVsdGEgPCAwIHx8IHJldmVyc2VkICYmIGRlbHRhID4gMCkpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBpdGVtUmVjdHNbaW5kZXggLSAxXVtpdGVtSGVpZ2h0T3JXaWR0aF0gKiBtb3ZlRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgbWUuY3VycmVudEluZGV4LS07XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGluZGV4IDwgbWF4SXRlbXMgJiYgKCFyZXZlcnNlZCAmJiBkZWx0YSA+IDAgfHwgcmV2ZXJzZWQgJiYgZGVsdGEgPCAwKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+IGl0ZW1SZWN0c1tpbmRleCArIDFdW2l0ZW1IZWlnaHRPcldpZHRoXSAqIG1vdmVGYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNPdmVyRHJhZ2dpbmcgPSBpc092ZXJEcmFnZ2luZyAmJiBtZS5jdXJyZW50SW5kZXggIT09IDAgJiYgbWUuY3VycmVudEluZGV4ICE9PSBtYXhJdGVtcztcblxuICAgICAgICBpZiAobWUuaXNPdmVyRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApOyAvLyB3YWl0IGZvciAxIGZyYW1lXG5cbiAgICAgICAgICAgIGlmIChtZS5pc092ZXJEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm9uRHJhZ01vdmUoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FkanVzdEl0ZW1SZWN0c1RvUGFyZW50LCBkcmFnSGFuZGxlU2VsZWN0b3IsIG93bmVyfSA9IG1lLFxuICAgICAgICAgICAgaXRlbVN0eWxlcyAgICAgICAgICAgPSBtZS5pdGVtU3R5bGVzID0gW10sXG4gICAgICAgICAgICB7bGF5b3V0fSAgICAgICAgICAgICA9IG93bmVyLFxuICAgICAgICAgICAgb3duZXJTdHlsZSAgICAgICAgICAgPSBvd25lci5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGRyYWdnZWRJdGVtLCBpbmRleCwgaW5kZXhNYXAsIGl0ZW1TdHlsZSwgcmVjdCwgc29ydGFibGVJdGVtcztcblxuICAgICAgICBpZiAob3duZXIuc29ydGFibGUpIHtcbiAgICAgICAgICAgIGlmIChkcmFnSGFuZGxlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVDbGFzc05hbWUgPSBkcmFnSGFuZGxlU2VsZWN0b3Iuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZU5vZGUgICAgICA9IGRhdGEucGF0aC5maW5kKG5vZGUgPT4gbm9kZS5jbHMuaW5jbHVkZXMoaGFuZGxlQ2xhc3NOYW1lKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUluZGV4ID0gZGF0YS5wYXRoLmluZGV4T2YoaGFuZGxlTm9kZSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaGFuZGxlSW5kZXg7IGkgPCBkYXRhLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsSXRlbU5vZGUgPSBkYXRhLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQocG90ZW50aWFsSXRlbU5vZGUuaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgb3duZXIuaXRlbXMuaW5jbHVkZXMoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEl0ZW0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZHJhZ2dlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMgPSBvd25lci5pdGVtcy5maWx0ZXIoaXRlbSA9PiBWRG9tVXRpbC5maW5kKGl0ZW0udmRvbSwge1xuICAgICAgICAgICAgICAgICAgICBjbHM6IGRyYWdIYW5kbGVTZWxlY3Rvci5zdGFydHNXaXRoKCcuJykgPyBkcmFnSGFuZGxlU2VsZWN0b3Iuc3Vic3RyaW5nKDEpIDogZHJhZ0hhbmRsZVNlbGVjdG9yXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgPSBzb3J0YWJsZUl0ZW1zLmluZGV4T2YoZHJhZ2dlZEl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbSAgID0gTmVvLmdldENvbXBvbmVudChkYXRhLnBhdGhbMF0uaWQpO1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMgPSBvd25lci5pdGVtcztcbiAgICAgICAgICAgICAgICBpbmRleCAgICAgICAgID0gb3duZXIuaW5kZXhPZihkcmFnZ2VkSXRlbS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluZGV4TWFwID0ge307XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggICAgICAgICAgIDogaW5kZXgsXG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQgICAgICAgICAgICA6IFZEb21VdGlsLmZpbmQob3duZXIudmRvbSwgZHJhZ2dlZEl0ZW0uaWQpLnZkb20sXG4gICAgICAgICAgICAgICAgZHJhZ1Byb3h5Q29uZmlnICAgICAgICA6IG1lLmdldERyYWdQcm94eUNvbmZpZygpLFxuICAgICAgICAgICAgICAgIGluZGV4TWFwLFxuICAgICAgICAgICAgICAgIG93bmVyU3R5bGUgICAgICAgICAgICAgOiB7aGVpZ2h0OiBvd25lclN0eWxlLmhlaWdodCwgbWluV2lkdGg6IG93bmVyU3R5bGUubWluV2lkdGgsIHdpZHRoOiBvd25lclN0eWxlLndpZHRofSxcbiAgICAgICAgICAgICAgICByZXZlcnNlZExheW91dERpcmVjdGlvbjogbGF5b3V0LmRpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyB8fCBsYXlvdXQuZGlyZWN0aW9uID09PSAncm93LXJldmVyc2UnLFxuICAgICAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMsXG4gICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiAgICAgICAgICA6IGxheW91dC5kaXJlY3Rpb24/LmluY2x1ZGVzKCdjb2x1bW4nKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCAgICAgICAgICAgICA6IGluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgbWUuZHJhZ1N0YXJ0KGRhdGEpO1xuXG4gICAgICAgICAgICBzb3J0YWJsZUl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpbmRleE1hcFtpXSA9IG93bmVyLml0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpdGVtU3R5bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW0uaGVpZ2h0ID8gYCR7aXRlbS5oZWlnaHR9cHhgIDogIGl0ZW0uc3R5bGU/LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBpdGVtLndpZHRoICA/IGAke2l0ZW0ud2lkdGh9cHhgICA6ICBpdGVtLnN0eWxlPy53aWR0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1SZWN0cyA9IGF3YWl0IG93bmVyLmdldERvbVJlY3QoW293bmVyLmlkXS5jb25jYXQoc29ydGFibGVJdGVtcy5tYXAoZSA9PiBlLmlkKSkpO1xuXG4gICAgICAgICAgICBtZS5vd25lclJlY3QgPSBpdGVtUmVjdHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgb3duZXIuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ub3duZXJTdHlsZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgIDogYCR7bWUub3duZXJSZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGAke21lLm93bmVyUmVjdC53aWR0aH1weGAsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IGAke21lLm93bmVyUmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ICYmIGl0ZW1SZWN0cy5mb3JFYWNoKHJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIHJlY3QueCAtPSBtZS5vd25lclJlY3QueDtcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbWUub3duZXJSZWN0LnlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtUmVjdHMgPSBpdGVtUmVjdHM7XG5cbiAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHJlY3QgICAgICA9IG1lLml0ZW1SZWN0c1tpXTtcblxuICAgICAgICAgICAgICAgIG1lLmFkanVzdFByb3h5UmVjdFRvUGFyZW50Py4ocmVjdCwgbWUub3duZXJSZWN0KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gT2JqZWN0LmFzc2lnbihpdGVtU3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiAgOiBtZS5pdGVtTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgICA6IGAke3JlY3QudG9wfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggICA6IGAke3JlY3Qud2lkdGh9cHhgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1KTtcblxuICAgICAgICAgICAgaXRlbVN0eWxlID0gZHJhZ2dlZEl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgaXRlbVN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGRyYWdnZWRJdGVtLndyYXBwZXJTdHlsZSA9IGl0ZW1TdHlsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHNjcm9sbFRvSW5kZXgoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuaXNTY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICBhd2FpdCBtZS5vd25lci5zY3JvbGxUb0luZGV4Py4obWUuY3VycmVudEluZGV4LCBtZS5pdGVtUmVjdHNbbWUuY3VycmVudEluZGV4XSk7XG4gICAgICAgIG1lLmlzU2Nyb2xsaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHN0YXJ0V2luZG93RHJhZyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwb3B1cEhlaWdodCwgcG9wdXBXaWR0aCwgd2luZG93TmFtZX0gPSBkYXRhO1xuXG4gICAgICAgIC8vIEhpZGUgdGhlIGRyYWcgcHJveHkgc2luY2UgdGhlIHdpbmRvdyBpcyBub3cgdGhlIHZpc3VhbCBpbmRpY2F0b3JcbiAgICAgICAgbWUuZHJhZ1Byb3h5LmhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3Auc3RhcnRXaW5kb3dEcmFnKHtcbiAgICAgICAgICAgIHBvcHVwSGVpZ2h0LFxuICAgICAgICAgICAgcG9wdXBOYW1lOiB3aW5kb3dOYW1lLFxuICAgICAgICAgICAgcG9wdXBXaWR0aFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MlxuICAgICAqL1xuICAgIHN3aXRjaEl0ZW1zKGluZGV4MSwgaW5kZXgyKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZXZlcnNlZCA9IG1lLnJldmVyc2VkTGF5b3V0RGlyZWN0aW9uLFxuICAgICAgICAgICAgdG1wO1xuXG4gICAgICAgIGlmICgoIXJldmVyc2VkICYmIGluZGV4MiA8IGluZGV4MSkgfHwgKHJldmVyc2VkICYmIGluZGV4MSA8IGluZGV4MikpIHtcbiAgICAgICAgICAgIHRtcCAgICA9IGluZGV4MTtcbiAgICAgICAgICAgIGluZGV4MSA9IGluZGV4MjtcbiAgICAgICAgICAgIGluZGV4MiA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtUmVjdHMgPSBtZS5pdGVtUmVjdHMsXG4gICAgICAgICAgICBtYXAgICAgICAgPSBtZS5pbmRleE1hcCxcbiAgICAgICAgICAgIHJlY3QxICAgICA9IGl0ZW1SZWN0c1tpbmRleDFdLFxuICAgICAgICAgICAgcmVjdDIgICAgID0gaXRlbVJlY3RzW2luZGV4Ml0sXG4gICAgICAgICAgICByZWN0MUNvcHkgPSByZWN0MS5jbG9uZSgpLFxuICAgICAgICAgICAgcmVjdDJDb3B5ID0gcmVjdDIuY2xvbmUoKTtcblxuICAgICAgICBpZiAobWUuc29ydERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICByZWN0MS53aWR0aCA9IHJlY3QyQ29weS53aWR0aDtcbiAgICAgICAgICAgIHJlY3QyLnggICAgID0gcmVjdDFDb3B5LnggKyByZWN0MkNvcHkud2lkdGg7XG4gICAgICAgICAgICByZWN0Mi53aWR0aCA9IHJlY3QxQ29weS53aWR0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjdDEuaGVpZ2h0ID0gcmVjdDJDb3B5LmhlaWdodDtcbiAgICAgICAgICAgIHJlY3QyLmhlaWdodCA9IHJlY3QxQ29weS5oZWlnaHQ7XG4gICAgICAgICAgICByZWN0Mi55ICAgICAgPSByZWN0MUNvcHkueSArIHJlY3QyQ29weS5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgICAgICAgICA9IG1hcFtpbmRleDFdO1xuICAgICAgICBtYXBbaW5kZXgxXSA9IG1hcFtpbmRleDJdO1xuICAgICAgICBtYXBbaW5kZXgyXSA9IHRtcDtcblxuICAgICAgICBtZS51cGRhdGVJdGVtKGluZGV4MSwgcmVjdDEpO1xuICAgICAgICBtZS51cGRhdGVJdGVtKGluZGV4MiwgcmVjdDIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKi9cbiAgICB1cGRhdGVJdGVtKGluZGV4LCByZWN0KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtICAgICAgICAgICA9IG1lLm93bmVyLml0ZW1zW21lLmluZGV4TWFwW2luZGV4XV0sXG4gICAgICAgICAgICB7d3JhcHBlclN0eWxlfSA9IGl0ZW07XG5cbiAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBgJHtyZWN0LmxlZnR9cHhgO1xuICAgICAgICB3cmFwcGVyU3R5bGUudG9wICA9IGAke3JlY3QudG9wfXB4YDtcblxuICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU29ydFpvbmUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9