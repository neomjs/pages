"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_container_SortZone_mjs"],{

/***/ "./src/draggable/container/DragZone.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/container/DragZone.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.draggable.container.DragZone
 * @extends Neo.draggable.DragZone
 */
class DragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.container.DragZone'
         * @protected
         */
        className: 'Neo.draggable.container.DragZone',
        /**
         * @member {String} ntype='container-dragzone'
         * @protected
         */
        ntype: 'container-dragzone'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            opts    = {delegate: '.neo-draggable', scope: me};

        owner.addDomListeners([
            {'drag:end'  : me.onDragEnd,   ...opts},
            {'drag:move' : me.onDragMove,  ...opts},
            {'drag:start': me.onDragStart, ...opts}
        ]);

        owner.on({
            insert      : me.onItemInsert,
            itemsCreated: me.onItemsCreated,
            scope       : me
        });

        // The container items can already be created
        me.adjustItemCls(true);
    }

    /**
     * @param {Boolean} draggable
     */
    adjustItemCls(draggable) {
        let me      = this,
            {owner} = me,
            wrapperCls;

        owner.items.forEach(item => {
            // spacers
            if (typeof item === 'string') {
                return;
            }

            wrapperCls = item.wrapperCls || [];

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
            item.wrapperCls = wrapperCls;
        });
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.owner.draggable) {
            let me           = this,
                proxy        = me.dragProxy,
                cls          = proxy.cls || {},
                rect         = me.dragElementRect,
                wrapperStyle = proxy.wrapperStyle || {};

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-animate');
            proxy.cls = cls;

            // ensure to get into the next animation frame
            me.timeout(30).then(() => {
                wrapperStyle.left = `${rect.left}px`;
                wrapperStyle.top  = `${rect.top}px`;

                proxy.wrapperStyle = wrapperStyle;

                me.timeout(100).then(() => {
                    me.dragEnd();
                });
            });
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me = this;

        if (me.owner.draggable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.owner.vdom, data.path[0].id).vdom;
            await me.dragStart(data);
        }
    }

    /**
     * @param {Object}             data
     * @param {Number}             data.index
     * @param {Neo.component.Base} data.item
     */
    onItemInsert(data) {
        let {item}     = data,
            wrapperCls = item.wrapperCls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, 'neo-draggable');
        item.wrapperCls = wrapperCls;
    }

    /**
     * @param {Object}               data
     * @param {String}               data.id
     * @param {Neo.component.Base[]} data.items
     */
    onItemsCreated(data) {
        this.adjustItemCls(true);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragZone));


/***/ },

/***/ "./src/draggable/container/SortZone.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/container/SortZone.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragZone.mjs */ "./src/draggable/container/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");





/**
 * @summary Manages the drag-and-drop reordering of items within a container, with support for window detachment.
 *
 * This class extends `Neo.draggable.container.DragZone` to provide sorting capabilities for `Neo.container.Base` instances.
 * It handles the complex logic of tracking item positions, swapping them during the drag operation, and updating
 * the container's layout upon drop.
 *
 * A key feature of this class is its support for **Window Detachment** (tearing tabs or items out of the main window).
 * When an item is dragged outside the browser window boundaries:
 * 1. The `startWindowDrag` method is triggered.
 * 2. The drag placeholder is hidden.
 * 3. The `calculateExpandedLayout` method dynamically computes a new layout for the remaining items, expanding them
 *    to fill the empty space (animating `width`, `height`, `top`, and `left`).
 * 4. If the drag re-enters the window (`onDragBoundaryEntry`), the original layout snapshot is restored, and the
 *    placeholder reappears, allowing for a seamless return to sorting mode.
 *
 * This class interacts closely with:
 * - `Neo.draggable.DragProxy`: For the visual representation of the dragged item.
 * - `Neo.main.addon.DragDrop`: For communicating drag state across the browser/OS environment.
 *
 * @class Neo.draggable.container.SortZone
 * @extends Neo.draggable.container.DragZone
 * @see Neo.draggable.container.DragZone
 * @see Neo.main.addon.DragDrop
 */
class SortZone extends _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.container.SortZone'
         * @protected
         */
        className: 'Neo.draggable.container.SortZone',
        /**
         * @member {String} ntype='container-sortzone'
         * @protected
         */
        ntype: 'container-sortzone',
        /**
         * Depending on the parent structure using position absolute and relative, it can be needed to subtract
         * the x & y parent rect values from the item rects.
         * @member {Boolean} adjustItemRectsToParent=false
         */
        adjustItemRectsToParent: false,
        /**
         * @member {Boolean} alwaysFireDragMove=true
         */
        alwaysFireDragMove: true,
        /**
         * @member {Number} currentIndex=-1
         * @protected
         */
        currentIndex: -1,
        /**
         * A CSS selector to identify the drag handle within a component.
         * If specified, the drag is initiated on this element, but the owning component is dragged.
         * @member {String|null} dragHandleSelector=null
         */
        dragHandleSelector: null,
        /**
         * @member {Boolean} enableProxyToPopup=false
         */
        enableProxyToPopup: false,
        /**
         * @member {Object} indexMap=null
         * @protected
         */
        indexMap: null,
        /**
         * @member {Array|null} itemRects=null
         * @protected
         */
        itemRects: null,
        /**
         * @member {Array|null} itemStyles=null
         * @protected
         */
        itemStyles: null,
        /**
         * @member {Object} ownerRect=null
         * @protected
         */
        ownerRect: null,
        /**
         * @member {Object} ownerStyle=null
         * @protected
         */
        ownerStyle: null,
        /**
         * @member {Boolean} alwaysFireDragMove=false
         * @protected
         */
        reversedLayoutDirection: false,
        /**
         * @member {Number} scrollLeft=0
         */
        scrollLeft: 0,
        /**
         * @member {Number} scrollTop=0
         */
        scrollTop: 0,
        /**
         * Internal flag: onDragStart() will set the value to horizontal or vertical, depending on the current layout.
         * @member {String} sortDirection='horizontal'
         * @protected
         */
        sortDirection: 'horizontal',
        /**
         * @member {Number} startIndex=-1
         * @protected
         */
        startIndex: -1
    }

    /**
     * @member {Boolean} isOverDragging=false
     * @protected
     */
    isOverDragging = false
    /**
     * @member {Boolean} isWindowDragging=false
     * @protected
     */
    isWindowDragging = false

    /**
     * Toggles the neo-draggable cls on items inside our owner.
     * @param {Boolean} draggable
     */
    adjustItemCls(draggable) {
        let me = this;

        if (me.dragHandleSelector) {
            const handleCls     = me.dragHandleSelector.startsWith('.') ? me.dragHandleSelector.substring(1) : me.dragHandleSelector;
            const sortableItems = me.owner.items.filter(item =>
                typeof item !== 'string' && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(item.vdom, {cls: handleCls})
            );

            sortableItems.forEach(item => {
                const wrapperCls = item.wrapperCls || [];
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
                item.wrapperCls = wrapperCls
            });
        } else {
            super.adjustItemCls(draggable)
        }
    }

    /**
     * Helper method, override as needed
     * @returns {Object}
     */
    getDragProxyConfig() {
        return {...this.dragProxyConfig, cls: [...this.owner.cls]}
    }

    /**
     * Override this method for class extensions (e.g. tab.header.Toolbar)
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        this.owner.moveTo(fromIndex, toIndex);
    }

    /**
     * Handles the completion of the drag operation.
     *
     * This method is responsible for:
     * 1.  **Finalizing the Drop:** If valid, it moves the DOM nodes to their final positions (via `Neo.applyDeltas`).
     * 2.  **Cleanup:** Removes the drag placeholder and resets internal state flags (`isWindowDragging`, `currentIndex`, etc.).
     * 3.  **Layout Restoration:** Resets the styles of all items (clearing the absolute positioning used during the drag)
     *     so they return to the container's natural layout flow.
     * 4.  **State Synchronization:** Calls `owner.moveTo()` to update the container's `items` array to reflect the new order.
     *
     * @param {Object} data - The drag end event data.
     */
    async onDragEnd(data) {
        let me                  = this,
            {itemStyles, owner} = me,
            ownerStyle          = owner.style || {},
            itemStyle;

        await me.timeout(10);

        if (owner.dragResortable) {
            if (me.dragPlaceholder) {
                const
                    component = me.dragComponent,
                    deltas    = [],
                    index     = me.sortableItems.indexOf(me.dragPlaceholder);

                if (component && index > -1) {
                    if (!me.isWindowDragging) {
                        deltas.push({
                            action  : 'moveNode',
                            id      : component.id,
                            index,    // Visually correct index (where placeholder is)
                            parentId: owner.getVdomItemsRoot().id
                        });
                    }

                    deltas.push({
                        action: 'removeNode',
                        id    : me.dragPlaceholder.id
                    });

                    // Manual DOM restoration
                    await Neo.applyDeltas(me.windowId, deltas)
                }
            }

            ownerStyle.height   = me.ownerStyle.height    || null;
            ownerStyle.minWidth = me.ownerStyle.minWidth  || null;
            ownerStyle.width    = me.ownerStyle.width     || null;

            owner.style = ownerStyle;

            me.sortableItems?.forEach((item, index) => {
                if (me.isWindowDragging && item === me.dragComponent) {
                    return
                }

                itemStyle = item.wrapperStyle || {};

                Object.assign(itemStyle, {
                    height  : itemStyles[index].height || null,
                    left    : null,
                    margin  : null,
                    position: null,
                    top     : null,
                    width   : itemStyles[index].width || null
                });

                if (index === me.startIndex) {
                    itemStyle.visibility = null
                }

                item.wrapperStyle = itemStyle
            });

            if (!me.isWindowDragging && me.startIndex !== me.currentIndex) {
                let fromIndex, toIndex;

                if (me.dragPlaceholder) {
                    const component = me.dragComponent;
                    fromIndex = me.owner.items.indexOf(component);
                    toIndex   = me.owner.items.indexOf(me.sortableItems[me.currentIndex]);
                } else {
                    fromIndex = me.owner.items.indexOf(me.sortableItems[me.startIndex]);
                    toIndex   = me.owner.items.indexOf(me.sortableItems[me.currentIndex]);
                }

                me.moveTo(fromIndex, toIndex);
            }

            Object.assign(me, {
                currentIndex    : -1,
                indexMap        : null,
                isWindowDragging: false,
                itemRects       : null,
                itemStyles      : null,
                ownerRect       : null,
                startIndex      : -1,
                sortableItems   : null
            });

            await me.timeout(30);

            me.dragEnd(data) // we do not want to trigger the super class call here
        }
    }

    /**
     * Handles the drag move event. This is the core logic loop for the drag operation.
     *
     * Responsibilities:
     * 1.  **Window Drag Re-entry:** Checks if a window drag has re-entered the original container boundaries.
     *     If so, it restores the original layout snapshot (`itemRects`) and shows the placeholder, effectively
     *     "snapping" the dashboard back to its sortable state.
     * 2.  **Window Drag Exit:** Detects if the drag proxy has left the container boundaries (if `enableProxyToPopup` is true)
     *     and triggers the `dragBoundaryExit` event to potentially start a window drag.
     * 3.  **Standard Sorting:** If not in window-drag mode, it calculates the drag delta and swaps items (`switchItems`)
     *     if the threshold is crossed, updating the `currentIndex`.
     * 4.  **Auto-Scrolling:** Manages auto-scrolling when dragging near the edges of the container.
     *
     * @param {Object} data - The drag move event data.
     */
    async onDragMove(data) {
        let me = this;

        // The method can trigger before we got the client rects from the main thread
        if (!me.itemRects || me.isScrolling) {
            return
        }

        if (me.dragProxy && me.enableProxyToPopup) {
            const {proxyRect} = data;

            if (proxyRect && me.boundaryContainerRect) {
                const
                    boundaryRect     = me.boundaryContainerRect,
                    intersection     = _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersection(proxyRect, boundaryRect),
                    proxyArea        = proxyRect.width * proxyRect.height,
                    intersectionArea = intersection ? intersection.width * intersection.height : 0;

                if (!me.isWindowDragging) {
                    if (proxyArea > 0 && (intersectionArea / proxyArea) < 0.5) {
                        me.isWindowDragging = true; // Set flag to prevent re-entry

                        me.fire('dragBoundaryExit', {
                            draggedItem: me.dragComponent,
                            proxyRect,
                            sortZone   : me
                        });
                        return // Stop further processing in onDragMove
                    }
                } else if (me.isWindowDragging) {
                    if (proxyArea > 0 && (intersectionArea / proxyArea) > 0.51) {
                        // Restore layout
                        me.dragPlaceholder.wrapperStyle = {
                            ...me.dragPlaceholder.wrapperStyle,
                            visibility: 'visible'
                        };

                        // Re-applying the current state:
                        me.itemRects.forEach((rect, index) => {
                            let mappedIndex = me.indexMap[index];
                            if (mappedIndex !== -1) {
                                let item = me.owner.items[mappedIndex];

                                if (item !== me.dragPlaceholder && item !== me.dragComponent) {
                                    item.wrapperStyle = {
                                        ...item.wrapperStyle,
                                        height: `${rect.height}px`,
                                        left  : `${rect.left}px`,
                                        top   : `${rect.top}px`,
                                        width : `${rect.width}px`
                                    };
                                }
                            }
                        });

                        me.fire('dragBoundaryEntry', {
                            draggedItem: me.dragComponent,
                            proxyRect,
                            sortZone   : me
                        })
                    }
                    return
                }
            }
        }

        let {clientX, clientY} = data,
            index              = me.currentIndex,
            {itemRects}        = me,
            maxItems           = itemRects.length - 1,
            ownerX             = me.adjustItemRectsToParent ? me.ownerRect.x : 0,
            ownerY             = me.adjustItemRectsToParent ? me.ownerRect.y : 0,
            reversed           = me.reversedLayoutDirection,
            delta, isOverDragging, isOverDraggingEnd, isOverDraggingStart, itemHeightOrWidth, moveFactor;

        if (me.sortDirection === 'horizontal') {
            delta               = clientX - ownerX + me.scrollLeft - me.offsetX - itemRects[index].left;
            isOverDraggingEnd   = clientX > me.boundaryContainerRect.right;
            isOverDraggingStart = clientX < me.boundaryContainerRect.left;
            itemHeightOrWidth   = 'width'
        } else {
            delta               = clientY - ownerY + me.scrollTop - me.offsetY - itemRects[index].top;
            isOverDraggingEnd   = clientY > me.boundaryContainerRect.bottom;
            isOverDraggingStart = clientY < me.boundaryContainerRect.top;
            itemHeightOrWidth   = 'height'
        }

        isOverDragging = isOverDraggingEnd || isOverDraggingStart;
        moveFactor     = isOverDragging ? 0.02 : 0.55; // We can not use 0.5, since items would jump back & forth

        if (isOverDraggingStart) {
            if (index > 0) {
                me.currentIndex--;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (isOverDraggingEnd) {
            if (index < maxItems) {
                me.currentIndex++;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index > 0 && (!reversed && delta < 0 || reversed && delta > 0)) {
            if (Math.abs(delta) > itemRects[index - 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex--;
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index < maxItems && (!reversed && delta > 0 || reversed && delta < 0)) {
            if (Math.abs(delta) > itemRects[index + 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex++;
                me.switchItems(index, me.currentIndex)
            }
        }

        me.isOverDragging = isOverDragging && me.currentIndex !== 0 && me.currentIndex !== maxItems;

        if (me.isOverDragging) {
            await me.timeout(30); // wait for 1 frame

            if (me.isOverDragging) {
                await me.onDragMove(data)
            }
        }
    }

    /**
     * Initializes the drag operation.
     *
     * Key actions:
     * 1.  **Identify Drag Target:** Determines which item is being dragged (handling `dragHandleSelector` if present).
     * 2.  **Snapshot Layout:** Captures the current DOM rectangles (`itemRects`) of all sortable items. This snapshot
     *     is critical for:
     *     - Calculating drag deltas for sorting.
     *     - Restoring the layout after a window drag re-entry.
     *     - Inferring gaps and offsets for `calculateExpandedLayout`.
     * 3.  **Setup Proxy & Placeholder:** Configures the visual drag proxy and inserts the placeholder into the `sortableItems` list.
     * 4.  **Apply Absolute Positioning:** Temporarily switches all items to `position: absolute` based on their captured
     *     coordinates to enable smooth, GPU-accelerated movement during the drag.
     *
     * @param {Object} data - The drag start event data.
     */
    async onDragStart(data) {
        let me                   = this,
            {adjustItemRectsToParent, dragHandleSelector, owner} = me,
            itemStyles           = me.itemStyles = [],
            {layout}             = owner,
            ownerStyle           = owner.style || {},
            draggedItem, index, indexMap, itemStyle, rect, sortableItems;

        if (owner.dragResortable) {
            if (dragHandleSelector) {
                const handleClassName = dragHandleSelector.substring(1);
                const handleNode      = data.path.find(node => node.cls.includes(handleClassName));

                if (!handleNode) {
                    return;
                }

                const handleIndex = data.path.indexOf(handleNode);

                for (let i = handleIndex; i < data.path.length; i++) {
                    const potentialItemNode = data.path[i];
                    const component = Neo.getComponent(potentialItemNode.id);

                    if (component && owner.items.includes(component)) {
                        draggedItem = component;
                        break;
                    }
                }

                if (!draggedItem) {
                    return;
                }

                sortableItems = owner.items.filter(item => _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(item.vdom, {
                    cls: dragHandleSelector.startsWith('.') ? dragHandleSelector.substring(1) : dragHandleSelector
                }));
                index         = sortableItems.indexOf(draggedItem);

                if (index < 0) {
                    return;
                }
            } else {
                draggedItem   = Neo.getComponent(data.path[0].id);
                sortableItems = owner.items;
                index         = owner.indexOf(draggedItem.id);
            }

            indexMap = {};

            Object.assign(me, {
                currentIndex           : index,
                dragElement            : _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, draggedItem.id).vdom,
                dragProxyConfig        : me.getDragProxyConfig(),
                indexMap,
                ownerStyle             : {height: ownerStyle.height, minWidth: ownerStyle.minWidth, width: ownerStyle.width},
                reversedLayoutDirection: layout.direction === 'column-reverse' || layout.direction === 'row-reverse',
                sortableItems,
                sortDirection          : layout.direction?.includes('column') ? 'vertical' : 'horizontal',
                startIndex             : index
            });

            me.dragComponent = draggedItem;

            sortableItems.forEach((item, i) => {
                indexMap[i] = owner.items.indexOf(item);

                itemStyles.push({
                    height: item.height ? `${item.height}px` :  item.style?.height,
                    width : item.width  ? `${item.width}px`  :  item.style?.width
                });
            });

            const itemRects = await owner.getDomRect([owner.id].concat(sortableItems.map(e => e.id)));

            me.ownerRect = itemRects.shift();

            owner.style = {
                ...ownerStyle,
                height  : `${me.ownerRect.height}px`,
                minWidth: `${me.ownerRect.width}px`,
                width   : `${me.ownerRect.width}px`
            };

            adjustItemRectsToParent && itemRects.forEach(rect => {
                rect.x -= me.ownerRect.x;
                rect.y -= me.ownerRect.y
            });

            me.itemRects = itemRects;

            await me.dragStart(data);

            if (me.dragPlaceholder) {
                const placeholderIndex = sortableItems.indexOf(draggedItem);
                if (placeholderIndex > -1) {
                    sortableItems[placeholderIndex] = me.dragPlaceholder;
                }
                me.dragElement = me.dragPlaceholder.vdom;
            }

            sortableItems.forEach((item, i) => {
                itemStyle = item.wrapperStyle || {};
                rect      = me.itemRects[i];

                me.adjustProxyRectToParent?.(rect, me.ownerRect);

                item.wrapperStyle = Object.assign(itemStyle, {
                    height  : `${rect.height}px`,
                    left    : `${rect.left}px`,
                    margin  : '0px',
                    position: 'absolute',
                    top     : `${rect.top}px`,
                    width   : `${rect.width}px`
                });
            });

            await me.timeout(5);

            // If we have a placeholder, the original item is already hidden/moved.
            // But we might want to ensure the placeholder (which is now in sortableItems) matches expectations?
            // The logic below originally hid the draggedItem.
            // If we use placeholder, draggedItem is in proxy (visible). Placeholder is hidden.
            // me.dragPlaceholder logic in DragZone already set it to visibility: hidden.
            if (!me.dragPlaceholder) {
                itemStyle = draggedItem.wrapperStyle || {};
                itemStyle.visibility = 'hidden';
                draggedItem.wrapperStyle = itemStyle;
            }
        }
    }

    /**
     * Calculates a new layout for the remaining items when one item is dragged out of the container (e.g., into a new window).
     *
     * This method ensures the dashboard doesn't leave a "hole" where the dragged item was. Instead, it:
     * 1.  **Infers Gaps & Offsets:** Analyzes the cached `itemRects` to mathematically derive the container's padding
     *     and the gaps between items, ensuring the new layout respects the original design tokens.
     * 2.  **Identifies Remaining Items:** Filters out the dragged component and its placeholder.
     * 3.  **Distributes Space:** Calculates the available space (Total Size - Offsets - Gaps - Fixed Items) and distributes
     *     it among flex items proportional to their flex values.
     * 4.  **Generates Styles:** Returns a list of style objects (`top`, `left`, `width`, `height`) to be applied to the remaining items.
     *
     * @returns {Object[]} Array of objects containing the `item` reference and the calculated `style` object.
     */
    calculateExpandedLayout() {
        let me           = this,
            ownerRect    = me.ownerRect,
            isHorizontal = me.sortDirection === 'horizontal',
            totalSize    = isHorizontal ? ownerRect.width : ownerRect.height,
            items        = [],
            totalFlex    = 0,
            usedSize     = 0,
            rects        = [],
            startOffset  = 0,
            endOffset    = 0,
            gap          = 0,
            topOffset    = 0,
            bottomOffset = 0,
            leftOffset   = 0,
            rightOffset  = 0,
            startX       = me.adjustItemRectsToParent ? 0 : ownerRect.x,
            startY       = me.adjustItemRectsToParent ? 0 : ownerRect.y;

        // 1. Calculate offsets and gaps from the original slots (itemRects)
        if (me.itemRects.length > 0) {
            let r0 = me.itemRects[0],
                rn = me.itemRects[me.itemRects.length - 1];

            if (isHorizontal) {
                startOffset  = me.adjustItemRectsToParent ? r0.x : r0.x - ownerRect.x;
                endOffset    = totalSize - (me.adjustItemRectsToParent ? (rn.x + rn.width) : (rn.x - ownerRect.x + rn.width));
                topOffset    = me.adjustItemRectsToParent ? r0.y : r0.y - ownerRect.y;
                bottomOffset = ownerRect.height - (me.adjustItemRectsToParent ? (r0.y + r0.height) : (r0.y - ownerRect.y + r0.height)); // Approx from first item

                if (me.itemRects.length > 1) {
                    let r1 = me.itemRects[1];
                    gap = r1.x - (r0.x + r0.width);
                }
            } else {
                startOffset = me.adjustItemRectsToParent ? r0.y : r0.y - ownerRect.y;
                endOffset   = totalSize - (me.adjustItemRectsToParent ? (rn.y + rn.height) : (rn.y - ownerRect.y + rn.height));
                leftOffset  = me.adjustItemRectsToParent ? r0.x : r0.x - ownerRect.x;
                rightOffset = ownerRect.width - (me.adjustItemRectsToParent ? (r0.x + r0.width) : (r0.x - ownerRect.x + r0.width));

                if (me.itemRects.length > 1) {
                    let r1 = me.itemRects[1];
                    gap = r1.y - (r0.y + r0.height);
                }
            }
        }
        // 2. Filter valid items
        for (let i = 0; i < me.itemRects.length; i++) {
            let mappedIndex = me.indexMap[i];

            if (mappedIndex === -1) {
                 continue;
            }

            let item = me.owner.items[mappedIndex];

            if (item === me.dragPlaceholder || item === me.dragComponent) {
                continue;
            }

            let rect = me.itemRects[i];

            items.push({item, rect});

            if (item.flex) {
                totalFlex += item.flex;
            } else {
                let size = isHorizontal ? rect.width : rect.height;
                usedSize += size;
            }
        }

        // 3. Calculate available space
        let totalGaps      = Math.max(0, items.length - 1),
            availableSpace = Math.max(0, totalSize - startOffset - endOffset - (totalGaps * gap) - usedSize);

        // 4. Distribute space
        let currentPos = startOffset;

        items.forEach(({item, rect}, index) => {
            let itemSize, style = {};

            if (item.flex) {
                itemSize = (item.flex / totalFlex) * availableSpace;
            } else {
                itemSize = isHorizontal ? rect.width : rect.height;
            }

            if (isHorizontal) {
                style = {
                    left  : `${startX + currentPos}px`,
                    top   : `${startY + topOffset}px`,
                    height: `${ownerRect.height - topOffset - bottomOffset}px`,
                    width : `${itemSize}px`
                };
            } else {
                style = {
                    left  : `${startX + leftOffset}px`,
                    top   : `${startY + currentPos}px`,
                    height: `${itemSize}px`,
                    width : `${ownerRect.width - leftOffset - rightOffset}px`
                };
            }

            rects.push({item, style});
            currentPos += itemSize + gap;
        });

        return rects;
    }

    /**
     * @returns {Promise<void>}
     */
    async scrollToIndex() {
        let me = this;

        me.isScrolling = true;
        await me.owner.scrollToIndex?.(me.currentIndex, me.itemRects[me.currentIndex]);
        me.isScrolling = false
    }

    /**
     * Handles the drag move event. This is the core logic loop for the drag operation.
     *
     * Responsibilities:
     * 1.  **Window Drag Re-entry:** Checks if a window drag has re-entered the original container boundaries.
     *     If so, it restores the original layout snapshot (`itemRects`) and shows the placeholder, effectively
     *     "snapping" the dashboard back to its sortable state.
     * 2.  **Window Drag Exit:** Detects if the drag proxy has left the container boundaries (if `enableProxyToPopup` is true)
     *     and triggers the `dragBoundaryExit` event to potentially start a window drag.
     * 3.  **Standard Sorting:** If not in window-drag mode, it calculates the drag delta and swaps items (`switchItems`)
     *     if the threshold is crossed, updating the `currentIndex`.
     * 4.  **Auto-Scrolling:** Manages auto-scrolling when dragging near the edges of the container.
     *
     * @param {Object} data - The drag move event data.
     */
    startWindowDrag(data) {
        let me = this,
            {popupHeight, popupWidth, windowName} = data;

        // Keep the proxy active to capture mouse events, but make it invisible
        me.dragProxy.style = {opacity: 0};
        me.isWindowDragging = true;

        if (me.dragPlaceholder) {
            me.dragPlaceholder.wrapperStyle = {
                ...me.dragPlaceholder.wrapperStyle,
                visibility: 'hidden'
            };
        }

        // Apply expanded layout
        let expandedLayout = me.calculateExpandedLayout();
        expandedLayout.forEach(({item, style}) => {
            item.wrapperStyle = {...item.wrapperStyle, ...style};
        });

        Neo.main.addon.DragDrop.startWindowDrag({
            popupHeight,
            popupName: windowName,
            popupWidth,
            windowId : me.windowId
        });
    }

    /**
     * Swaps two items in the sort list, updating their layout coordinates and the internal index map.
     *
     * This method handles the physical reordering of items during a drag operation. It performs the following:
     * 1.  **Normalization:** Ensures indices are ordered correctly based on layout direction.
     * 2.  **Geometry Calculation:** Swaps the dimensions (width/height) of the two items and recalculates
     *     their positions (x/y), preserving the original gap between them. This ensures that items of different
     *     sizes swap correctly without breaking the layout structure.
     * 3.  **State Update:** Updates the `indexMap` to reflect the new logical order of items.
     * 4.  **Visual Update:** Calls `updateItem` to apply the new coordinates to the DOM.
     *
     * @param {Number} index1 - The index of the first item to swap.
     * @param {Number} index2 - The index of the second item to swap.
     */
    switchItems(index1, index2) {
        let me       = this,
            reversed = me.reversedLayoutDirection,
            tmp;

        if ((!reversed && index2 < index1) || (reversed && index1 < index2)) {
            tmp    = index1;
            index1 = index2;
            index2 = tmp;
        }

        let itemRects = me.itemRects,
            map       = me.indexMap,
            rect1     = itemRects[index1],
            rect2     = itemRects[index2],
            rect1Copy = rect1.clone(),
            rect2Copy = rect2.clone();

        if (me.sortDirection === 'horizontal') {
            const gap = rect2Copy.x - (rect1Copy.x + rect1Copy.width);

            rect1.width = rect2Copy.width;
            rect2.x     = rect1Copy.x + rect2Copy.width + gap;
            rect2.width = rect1Copy.width
        } else {
            const gap = rect2Copy.y - (rect1Copy.y + rect1Copy.height);

            rect1.height = rect2Copy.height;
            rect2.height = rect1Copy.height;
            rect2.y      = rect1Copy.y + rect2Copy.height + gap;
        }

        tmp         = map[index1];
        map[index1] = map[index2];
        map[index2] = tmp;

        me.updateItem(index1, rect1);
        me.updateItem(index2, rect2)
    }

    /**
     * @param {Number} index
     * @param {Object} rect
     */
    updateItem(index, rect) {
        let me          = this,
            mappedIndex = me.indexMap[index],
            item;

        if (mappedIndex === -1) {
            if (me.dragPlaceholder) {
                item = me.dragPlaceholder;
            } else {
                return
            }
        } else {
            item = me.owner.items[mappedIndex];

            if (me.dragPlaceholder && item === me.dragComponent) {
                item = me.dragPlaceholder
            }
        }

        let {wrapperStyle} = item;

        wrapperStyle.left = `${rect.left}px`;
        wrapperStyle.top  = `${rect.top}px`;

        item.wrapperStyle = wrapperStyle
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SortZone));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfY29udGFpbmVyX1NvcnRab25lX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ1I7QUFDRDs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0RBQVk7QUFDbkM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLHVCQUF1Qjs7QUFFdkI7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLHNDQUFzQztBQUNuRCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLHVEQUFRO0FBQ3BCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQSxZQUFZLHVEQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRCx1Q0FBdUMsU0FBUzs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsc0RBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBLGFB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Q0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQ0FBcUM7O0FBRWxEO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0MsaUNBQWlDO0FBQ2pDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxjQUFjOztBQUUzQiwrQkFBK0IsVUFBVTtBQUN6QywrQkFBK0IsU0FBUzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHdCQUF3QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kcmFnZ2FibGUvY29udGFpbmVyL0RyYWdab25lLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RyYWdnYWJsZS9jb250YWluZXIvU29ydFpvbmUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlRHJhZ1pvbmUgZnJvbSAnLi4vLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgIGZyb20gJy4uLy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuY29udGFpbmVyLkRyYWdab25lXG4gKiBAZXh0ZW5kcyBOZW8uZHJhZ2dhYmxlLkRyYWdab25lXG4gKi9cbmNsYXNzIERyYWdab25lIGV4dGVuZHMgQmFzZURyYWdab25lIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kcmFnZ2FibGUuY29udGFpbmVyLkRyYWdab25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5EcmFnWm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb250YWluZXItZHJhZ3pvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29udGFpbmVyLWRyYWd6b25lJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIG9wdHMgICAgPSB7ZGVsZWdhdGU6ICcubmVvLWRyYWdnYWJsZScsIHNjb3BlOiBtZX07XG5cbiAgICAgICAgb3duZXIuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uRHJhZ0VuZCwgICAuLi5vcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzptb3ZlJyA6IG1lLm9uRHJhZ01vdmUsICAuLi5vcHRzfSxcbiAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uRHJhZ1N0YXJ0LCAuLi5vcHRzfVxuICAgICAgICBdKTtcblxuICAgICAgICBvd25lci5vbih7XG4gICAgICAgICAgICBpbnNlcnQgICAgICA6IG1lLm9uSXRlbUluc2VydCxcbiAgICAgICAgICAgIGl0ZW1zQ3JlYXRlZDogbWUub25JdGVtc0NyZWF0ZWQsXG4gICAgICAgICAgICBzY29wZSAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoZSBjb250YWluZXIgaXRlbXMgY2FuIGFscmVhZHkgYmUgY3JlYXRlZFxuICAgICAgICBtZS5hZGp1c3RJdGVtQ2xzKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJhZ2dhYmxlXG4gICAgICovXG4gICAgYWRqdXN0SXRlbUNscyhkcmFnZ2FibGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgd3JhcHBlckNscztcblxuICAgICAgICBvd25lci5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgLy8gc3BhY2Vyc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcHBlckNscyA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXTtcblxuICAgICAgICAgICAgTmVvQXJyYXkudG9nZ2xlKHdyYXBwZXJDbHMsICduZW8tZHJhZ2dhYmxlJywgZHJhZ2dhYmxlKTtcbiAgICAgICAgICAgIGl0ZW0ud3JhcHBlckNscyA9IHdyYXBwZXJDbHM7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMub3duZXIuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwcm94eSAgICAgICAgPSBtZS5kcmFnUHJveHksXG4gICAgICAgICAgICAgICAgY2xzICAgICAgICAgID0gcHJveHkuY2xzIHx8IHt9LFxuICAgICAgICAgICAgICAgIHJlY3QgICAgICAgICA9IG1lLmRyYWdFbGVtZW50UmVjdCxcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSBwcm94eS53cmFwcGVyU3R5bGUgfHwge307XG5cbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8tYW5pbWF0ZScpO1xuICAgICAgICAgICAgcHJveHkuY2xzID0gY2xzO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gZ2V0IGludG8gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gICAgICAgICAgICBtZS50aW1lb3V0KDMwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IGAke3JlY3QubGVmdH1weGA7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLnRvcCAgPSBgJHtyZWN0LnRvcH1weGA7XG5cbiAgICAgICAgICAgICAgICBwcm94eS53cmFwcGVyU3R5bGUgPSB3cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDEwMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRyYWdFbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLm93bmVyLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgbWUuZHJhZ0VsZW1lbnQgPSBWRG9tVXRpbC5maW5kKG1lLm93bmVyLnZkb20sIGRhdGEucGF0aFswXS5pZCkudmRvbTtcbiAgICAgICAgICAgIGF3YWl0IG1lLmRyYWdTdGFydChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgIGRhdGEuaW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gZGF0YS5pdGVtXG4gICAgICovXG4gICAgb25JdGVtSW5zZXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IHtpdGVtfSAgICAgPSBkYXRhLFxuICAgICAgICAgICAgd3JhcHBlckNscyA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXTtcblxuICAgICAgICBOZW9BcnJheS5hZGQod3JhcHBlckNscywgJ25lby1kcmFnZ2FibGUnKTtcbiAgICAgICAgaXRlbS53cmFwcGVyQ2xzID0gd3JhcHBlckNscztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgZGF0YS5pZFxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlW119IGRhdGEuaXRlbXNcbiAgICAgKi9cbiAgICBvbkl0ZW1zQ3JlYXRlZChkYXRhKSB7XG4gICAgICAgIHRoaXMuYWRqdXN0SXRlbUNscyh0cnVlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKERyYWdab25lKTtcbiIsImltcG9ydCBEcmFnWm9uZSAgZnJvbSAnLi9EcmFnWm9uZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4uLy4uL3V0aWwvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IE1hbmFnZXMgdGhlIGRyYWctYW5kLWRyb3AgcmVvcmRlcmluZyBvZiBpdGVtcyB3aXRoaW4gYSBjb250YWluZXIsIHdpdGggc3VwcG9ydCBmb3Igd2luZG93IGRldGFjaG1lbnQuXG4gKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIGBOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5EcmFnWm9uZWAgdG8gcHJvdmlkZSBzb3J0aW5nIGNhcGFiaWxpdGllcyBmb3IgYE5lby5jb250YWluZXIuQmFzZWAgaW5zdGFuY2VzLlxuICogSXQgaGFuZGxlcyB0aGUgY29tcGxleCBsb2dpYyBvZiB0cmFja2luZyBpdGVtIHBvc2l0aW9ucywgc3dhcHBpbmcgdGhlbSBkdXJpbmcgdGhlIGRyYWcgb3BlcmF0aW9uLCBhbmQgdXBkYXRpbmdcbiAqIHRoZSBjb250YWluZXIncyBsYXlvdXQgdXBvbiBkcm9wLlxuICpcbiAqIEEga2V5IGZlYXR1cmUgb2YgdGhpcyBjbGFzcyBpcyBpdHMgc3VwcG9ydCBmb3IgKipXaW5kb3cgRGV0YWNobWVudCoqICh0ZWFyaW5nIHRhYnMgb3IgaXRlbXMgb3V0IG9mIHRoZSBtYWluIHdpbmRvdykuXG4gKiBXaGVuIGFuIGl0ZW0gaXMgZHJhZ2dlZCBvdXRzaWRlIHRoZSBicm93c2VyIHdpbmRvdyBib3VuZGFyaWVzOlxuICogMS4gVGhlIGBzdGFydFdpbmRvd0RyYWdgIG1ldGhvZCBpcyB0cmlnZ2VyZWQuXG4gKiAyLiBUaGUgZHJhZyBwbGFjZWhvbGRlciBpcyBoaWRkZW4uXG4gKiAzLiBUaGUgYGNhbGN1bGF0ZUV4cGFuZGVkTGF5b3V0YCBtZXRob2QgZHluYW1pY2FsbHkgY29tcHV0ZXMgYSBuZXcgbGF5b3V0IGZvciB0aGUgcmVtYWluaW5nIGl0ZW1zLCBleHBhbmRpbmcgdGhlbVxuICogICAgdG8gZmlsbCB0aGUgZW1wdHkgc3BhY2UgKGFuaW1hdGluZyBgd2lkdGhgLCBgaGVpZ2h0YCwgYHRvcGAsIGFuZCBgbGVmdGApLlxuICogNC4gSWYgdGhlIGRyYWcgcmUtZW50ZXJzIHRoZSB3aW5kb3cgKGBvbkRyYWdCb3VuZGFyeUVudHJ5YCksIHRoZSBvcmlnaW5hbCBsYXlvdXQgc25hcHNob3QgaXMgcmVzdG9yZWQsIGFuZCB0aGVcbiAqICAgIHBsYWNlaG9sZGVyIHJlYXBwZWFycywgYWxsb3dpbmcgZm9yIGEgc2VhbWxlc3MgcmV0dXJuIHRvIHNvcnRpbmcgbW9kZS5cbiAqXG4gKiBUaGlzIGNsYXNzIGludGVyYWN0cyBjbG9zZWx5IHdpdGg6XG4gKiAtIGBOZW8uZHJhZ2dhYmxlLkRyYWdQcm94eWA6IEZvciB0aGUgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkcmFnZ2VkIGl0ZW0uXG4gKiAtIGBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcGA6IEZvciBjb21tdW5pY2F0aW5nIGRyYWcgc3RhdGUgYWNyb3NzIHRoZSBicm93c2VyL09TIGVudmlyb25tZW50LlxuICpcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuRHJhZ1pvbmVcbiAqIEBzZWUgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuRHJhZ1pvbmVcbiAqIEBzZWUgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3BcbiAqL1xuY2xhc3MgU29ydFpvbmUgZXh0ZW5kcyBEcmFnWm9uZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5Tb3J0Wm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29udGFpbmVyLXNvcnR6b25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbnRhaW5lci1zb3J0em9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXBlbmRpbmcgb24gdGhlIHBhcmVudCBzdHJ1Y3R1cmUgdXNpbmcgcG9zaXRpb24gYWJzb2x1dGUgYW5kIHJlbGF0aXZlLCBpdCBjYW4gYmUgbmVlZGVkIHRvIHN1YnRyYWN0XG4gICAgICAgICAqIHRoZSB4ICYgeSBwYXJlbnQgcmVjdCB2YWx1ZXMgZnJvbSB0aGUgaXRlbSByZWN0cy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGFkanVzdEl0ZW1SZWN0c1RvUGFyZW50OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhbHdheXNGaXJlRHJhZ01vdmU6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbmRleD0tMVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50SW5kZXg6IC0xLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBDU1Mgc2VsZWN0b3IgdG8gaWRlbnRpZnkgdGhlIGRyYWcgaGFuZGxlIHdpdGhpbiBhIGNvbXBvbmVudC5cbiAgICAgICAgICogSWYgc3BlY2lmaWVkLCB0aGUgZHJhZyBpcyBpbml0aWF0ZWQgb24gdGhpcyBlbGVtZW50LCBidXQgdGhlIG93bmluZyBjb21wb25lbnQgaXMgZHJhZ2dlZC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRyYWdIYW5kbGVTZWxlY3Rvcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnSGFuZGxlU2VsZWN0b3I6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVQcm94eVRvUG9wdXA9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZVByb3h5VG9Qb3B1cDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGluZGV4TWFwPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXhNYXA6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBpdGVtUmVjdHM9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtUmVjdHM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBpdGVtU3R5bGVzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVN0eWxlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gb3duZXJSZWN0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXJSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBvd25lclN0eWxlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXJTdHlsZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZXZlcnNlZExheW91dERpcmVjdGlvbjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbExlZnQ9MFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsVG9wPTBcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWc6IG9uRHJhZ1N0YXJ0KCkgd2lsbCBzZXQgdGhlIHZhbHVlIHRvIGhvcml6b250YWwgb3IgdmVydGljYWwsIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBsYXlvdXQuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc29ydERpcmVjdGlvbj0naG9yaXpvbnRhbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydERpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzdGFydEluZGV4PS0xXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0SW5kZXg6IC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNPdmVyRHJhZ2dpbmc9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNPdmVyRHJhZ2dpbmcgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzV2luZG93RHJhZ2dpbmc9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNXaW5kb3dEcmFnZ2luZyA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBuZW8tZHJhZ2dhYmxlIGNscyBvbiBpdGVtcyBpbnNpZGUgb3VyIG93bmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJhZ2dhYmxlXG4gICAgICovXG4gICAgYWRqdXN0SXRlbUNscyhkcmFnZ2FibGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuZHJhZ0hhbmRsZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbHMgICAgID0gbWUuZHJhZ0hhbmRsZVNlbGVjdG9yLnN0YXJ0c1dpdGgoJy4nKSA/IG1lLmRyYWdIYW5kbGVTZWxlY3Rvci5zdWJzdHJpbmcoMSkgOiBtZS5kcmFnSGFuZGxlU2VsZWN0b3I7XG4gICAgICAgICAgICBjb25zdCBzb3J0YWJsZUl0ZW1zID0gbWUub3duZXIuaXRlbXMuZmlsdGVyKGl0ZW0gPT5cbiAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ3N0cmluZycgJiYgVkRvbVV0aWwuZmluZChpdGVtLnZkb20sIHtjbHM6IGhhbmRsZUNsc30pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzb3J0YWJsZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlckNscyA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS50b2dnbGUod3JhcHBlckNscywgJ25lby1kcmFnZ2FibGUnLCBkcmFnZ2FibGUpO1xuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuYWRqdXN0SXRlbUNscyhkcmFnZ2FibGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kLCBvdmVycmlkZSBhcyBuZWVkZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldERyYWdQcm94eUNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHsuLi50aGlzLmRyYWdQcm94eUNvbmZpZywgY2xzOiBbLi4udGhpcy5vd25lci5jbHNdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGZvciBjbGFzcyBleHRlbnNpb25zIChlLmcuIHRhYi5oZWFkZXIuVG9vbGJhcilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXhcbiAgICAgKi9cbiAgICBtb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIHRoaXMub3duZXIubW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgY29tcGxldGlvbiBvZiB0aGUgZHJhZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3I6XG4gICAgICogMS4gICoqRmluYWxpemluZyB0aGUgRHJvcDoqKiBJZiB2YWxpZCwgaXQgbW92ZXMgdGhlIERPTSBub2RlcyB0byB0aGVpciBmaW5hbCBwb3NpdGlvbnMgKHZpYSBgTmVvLmFwcGx5RGVsdGFzYCkuXG4gICAgICogMi4gICoqQ2xlYW51cDoqKiBSZW1vdmVzIHRoZSBkcmFnIHBsYWNlaG9sZGVyIGFuZCByZXNldHMgaW50ZXJuYWwgc3RhdGUgZmxhZ3MgKGBpc1dpbmRvd0RyYWdnaW5nYCwgYGN1cnJlbnRJbmRleGAsIGV0Yy4pLlxuICAgICAqIDMuICAqKkxheW91dCBSZXN0b3JhdGlvbjoqKiBSZXNldHMgdGhlIHN0eWxlcyBvZiBhbGwgaXRlbXMgKGNsZWFyaW5nIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbmluZyB1c2VkIGR1cmluZyB0aGUgZHJhZylcbiAgICAgKiAgICAgc28gdGhleSByZXR1cm4gdG8gdGhlIGNvbnRhaW5lcidzIG5hdHVyYWwgbGF5b3V0IGZsb3cuXG4gICAgICogNC4gICoqU3RhdGUgU3luY2hyb25pemF0aW9uOioqIENhbGxzIGBvd25lci5tb3ZlVG8oKWAgdG8gdXBkYXRlIHRoZSBjb250YWluZXIncyBgaXRlbXNgIGFycmF5IHRvIHJlZmxlY3QgdGhlIG5ldyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRyYWcgZW5kIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1TdHlsZXMsIG93bmVyfSA9IG1lLFxuICAgICAgICAgICAgb3duZXJTdHlsZSAgICAgICAgICA9IG93bmVyLnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgaXRlbVN0eWxlO1xuXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMTApO1xuXG4gICAgICAgIGlmIChvd25lci5kcmFnUmVzb3J0YWJsZSkge1xuICAgICAgICAgICAgaWYgKG1lLmRyYWdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLmRyYWdDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhcyAgICA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCAgICAgPSBtZS5zb3J0YWJsZUl0ZW1zLmluZGV4T2YobWUuZHJhZ1BsYWNlaG9sZGVyKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLmlzV2luZG93RHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gIDogJ21vdmVOb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgIDogY29tcG9uZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCAgICAvLyBWaXN1YWxseSBjb3JyZWN0IGluZGV4ICh3aGVyZSBwbGFjZWhvbGRlciBpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogb3duZXIuZ2V0VmRvbUl0ZW1zUm9vdCgpLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3JlbW92ZU5vZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgICAgOiBtZS5kcmFnUGxhY2Vob2xkZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFudWFsIERPTSByZXN0b3JhdGlvblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIGRlbHRhcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG93bmVyU3R5bGUuaGVpZ2h0ICAgPSBtZS5vd25lclN0eWxlLmhlaWdodCAgICB8fCBudWxsO1xuICAgICAgICAgICAgb3duZXJTdHlsZS5taW5XaWR0aCA9IG1lLm93bmVyU3R5bGUubWluV2lkdGggIHx8IG51bGw7XG4gICAgICAgICAgICBvd25lclN0eWxlLndpZHRoICAgID0gbWUub3duZXJTdHlsZS53aWR0aCAgICAgfHwgbnVsbDtcblxuICAgICAgICAgICAgb3duZXIuc3R5bGUgPSBvd25lclN0eWxlO1xuXG4gICAgICAgICAgICBtZS5zb3J0YWJsZUl0ZW1zPy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtZS5pc1dpbmRvd0RyYWdnaW5nICYmIGl0ZW0gPT09IG1lLmRyYWdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlID0gaXRlbS53cmFwcGVyU3R5bGUgfHwge307XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0ZW1TdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgIDogaXRlbVN0eWxlc1tpbmRleF0uaGVpZ2h0IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW4gIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgIDogaXRlbVN0eWxlc1tpbmRleF0ud2lkdGggfHwgbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBtZS5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1TdHlsZS52aXNpYmlsaXR5ID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gaXRlbVN0eWxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtZS5pc1dpbmRvd0RyYWdnaW5nICYmIG1lLnN0YXJ0SW5kZXggIT09IG1lLmN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tSW5kZXgsIHRvSW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAobWUuZHJhZ1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG1lLmRyYWdDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGZyb21JbmRleCA9IG1lLm93bmVyLml0ZW1zLmluZGV4T2YoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdG9JbmRleCAgID0gbWUub3duZXIuaXRlbXMuaW5kZXhPZihtZS5zb3J0YWJsZUl0ZW1zW21lLmN1cnJlbnRJbmRleF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21JbmRleCA9IG1lLm93bmVyLml0ZW1zLmluZGV4T2YobWUuc29ydGFibGVJdGVtc1ttZS5zdGFydEluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIHRvSW5kZXggICA9IG1lLm93bmVyLml0ZW1zLmluZGV4T2YobWUuc29ydGFibGVJdGVtc1ttZS5jdXJyZW50SW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5tb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCAgICA6IC0xLFxuICAgICAgICAgICAgICAgIGluZGV4TWFwICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNXaW5kb3dEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXRlbVJlY3RzICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGVzICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIG93bmVyUmVjdCAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCAgICAgIDogLTEsXG4gICAgICAgICAgICAgICAgc29ydGFibGVJdGVtcyAgIDogbnVsbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApO1xuXG4gICAgICAgICAgICBtZS5kcmFnRW5kKGRhdGEpIC8vIHdlIGRvIG5vdCB3YW50IHRvIHRyaWdnZXIgdGhlIHN1cGVyIGNsYXNzIGNhbGwgaGVyZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgZHJhZyBtb3ZlIGV2ZW50LiBUaGlzIGlzIHRoZSBjb3JlIGxvZ2ljIGxvb3AgZm9yIHRoZSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFJlc3BvbnNpYmlsaXRpZXM6XG4gICAgICogMS4gICoqV2luZG93IERyYWcgUmUtZW50cnk6KiogQ2hlY2tzIGlmIGEgd2luZG93IGRyYWcgaGFzIHJlLWVudGVyZWQgdGhlIG9yaWdpbmFsIGNvbnRhaW5lciBib3VuZGFyaWVzLlxuICAgICAqICAgICBJZiBzbywgaXQgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIGxheW91dCBzbmFwc2hvdCAoYGl0ZW1SZWN0c2ApIGFuZCBzaG93cyB0aGUgcGxhY2Vob2xkZXIsIGVmZmVjdGl2ZWx5XG4gICAgICogICAgIFwic25hcHBpbmdcIiB0aGUgZGFzaGJvYXJkIGJhY2sgdG8gaXRzIHNvcnRhYmxlIHN0YXRlLlxuICAgICAqIDIuICAqKldpbmRvdyBEcmFnIEV4aXQ6KiogRGV0ZWN0cyBpZiB0aGUgZHJhZyBwcm94eSBoYXMgbGVmdCB0aGUgY29udGFpbmVyIGJvdW5kYXJpZXMgKGlmIGBlbmFibGVQcm94eVRvUG9wdXBgIGlzIHRydWUpXG4gICAgICogICAgIGFuZCB0cmlnZ2VycyB0aGUgYGRyYWdCb3VuZGFyeUV4aXRgIGV2ZW50IHRvIHBvdGVudGlhbGx5IHN0YXJ0IGEgd2luZG93IGRyYWcuXG4gICAgICogMy4gICoqU3RhbmRhcmQgU29ydGluZzoqKiBJZiBub3QgaW4gd2luZG93LWRyYWcgbW9kZSwgaXQgY2FsY3VsYXRlcyB0aGUgZHJhZyBkZWx0YSBhbmQgc3dhcHMgaXRlbXMgKGBzd2l0Y2hJdGVtc2ApXG4gICAgICogICAgIGlmIHRoZSB0aHJlc2hvbGQgaXMgY3Jvc3NlZCwgdXBkYXRpbmcgdGhlIGBjdXJyZW50SW5kZXhgLlxuICAgICAqIDQuICAqKkF1dG8tU2Nyb2xsaW5nOioqIE1hbmFnZXMgYXV0by1zY3JvbGxpbmcgd2hlbiBkcmFnZ2luZyBuZWFyIHRoZSBlZGdlcyBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZHJhZyBtb3ZlIGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gVGhlIG1ldGhvZCBjYW4gdHJpZ2dlciBiZWZvcmUgd2UgZ290IHRoZSBjbGllbnQgcmVjdHMgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgICAgICAgaWYgKCFtZS5pdGVtUmVjdHMgfHwgbWUuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmRyYWdQcm94eSAmJiBtZS5lbmFibGVQcm94eVRvUG9wdXApIHtcbiAgICAgICAgICAgIGNvbnN0IHtwcm94eVJlY3R9ID0gZGF0YTtcblxuICAgICAgICAgICAgaWYgKHByb3h5UmVjdCAmJiBtZS5ib3VuZGFyeUNvbnRhaW5lclJlY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVJlY3QgICAgID0gbWUuYm91bmRhcnlDb250YWluZXJSZWN0LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gICAgID0gUmVjdGFuZ2xlLmdldEludGVyc2VjdGlvbihwcm94eVJlY3QsIGJvdW5kYXJ5UmVjdCksXG4gICAgICAgICAgICAgICAgICAgIHByb3h5QXJlYSAgICAgICAgPSBwcm94eVJlY3Qud2lkdGggKiBwcm94eVJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25BcmVhID0gaW50ZXJzZWN0aW9uID8gaW50ZXJzZWN0aW9uLndpZHRoICogaW50ZXJzZWN0aW9uLmhlaWdodCA6IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1lLmlzV2luZG93RHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3h5QXJlYSA+IDAgJiYgKGludGVyc2VjdGlvbkFyZWEgLyBwcm94eUFyZWEpIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5pc1dpbmRvd0RyYWdnaW5nID0gdHJ1ZTsgLy8gU2V0IGZsYWcgdG8gcHJldmVudCByZS1lbnRyeVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5maXJlKCdkcmFnQm91bmRhcnlFeGl0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtOiBtZS5kcmFnQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0Wm9uZSAgIDogbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8vIFN0b3AgZnVydGhlciBwcm9jZXNzaW5nIGluIG9uRHJhZ01vdmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuaXNXaW5kb3dEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJveHlBcmVhID4gMCAmJiAoaW50ZXJzZWN0aW9uQXJlYSAvIHByb3h5QXJlYSkgPiAwLjUxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGxheW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ1BsYWNlaG9sZGVyLndyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tZS5kcmFnUGxhY2Vob2xkZXIud3JhcHBlclN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtYXBwbHlpbmcgdGhlIGN1cnJlbnQgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5pdGVtUmVjdHMuZm9yRWFjaCgocmVjdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWFwcGVkSW5kZXggPSBtZS5pbmRleE1hcFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IG1lLm93bmVyLml0ZW1zW21hcHBlZEluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gbWUuZHJhZ1BsYWNlaG9sZGVyICYmIGl0ZW0gIT09IG1lLmRyYWdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLml0ZW0ud3JhcHBlclN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgIDogYCR7cmVjdC5sZWZ0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgICA6IGAke3JlY3QudG9wfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IGAke3JlY3Qud2lkdGh9cHhgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2RyYWdCb3VuZGFyeUVudHJ5Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtOiBtZS5kcmFnQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0Wm9uZSAgIDogbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHtjbGllbnRYLCBjbGllbnRZfSA9IGRhdGEsXG4gICAgICAgICAgICBpbmRleCAgICAgICAgICAgICAgPSBtZS5jdXJyZW50SW5kZXgsXG4gICAgICAgICAgICB7aXRlbVJlY3RzfSAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIG1heEl0ZW1zICAgICAgICAgICA9IGl0ZW1SZWN0cy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgb3duZXJYICAgICAgICAgICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyBtZS5vd25lclJlY3QueCA6IDAsXG4gICAgICAgICAgICBvd25lclkgICAgICAgICAgICAgPSBtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IG1lLm93bmVyUmVjdC55IDogMCxcbiAgICAgICAgICAgIHJldmVyc2VkICAgICAgICAgICA9IG1lLnJldmVyc2VkTGF5b3V0RGlyZWN0aW9uLFxuICAgICAgICAgICAgZGVsdGEsIGlzT3ZlckRyYWdnaW5nLCBpc092ZXJEcmFnZ2luZ0VuZCwgaXNPdmVyRHJhZ2dpbmdTdGFydCwgaXRlbUhlaWdodE9yV2lkdGgsIG1vdmVGYWN0b3I7XG5cbiAgICAgICAgaWYgKG1lLnNvcnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgZGVsdGEgICAgICAgICAgICAgICA9IGNsaWVudFggLSBvd25lclggKyBtZS5zY3JvbGxMZWZ0IC0gbWUub2Zmc2V0WCAtIGl0ZW1SZWN0c1tpbmRleF0ubGVmdDtcbiAgICAgICAgICAgIGlzT3ZlckRyYWdnaW5nRW5kICAgPSBjbGllbnRYID4gbWUuYm91bmRhcnlDb250YWluZXJSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgaXNPdmVyRHJhZ2dpbmdTdGFydCA9IGNsaWVudFggPCBtZS5ib3VuZGFyeUNvbnRhaW5lclJlY3QubGVmdDtcbiAgICAgICAgICAgIGl0ZW1IZWlnaHRPcldpZHRoICAgPSAnd2lkdGgnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSAgICAgICAgICAgICAgID0gY2xpZW50WSAtIG93bmVyWSArIG1lLnNjcm9sbFRvcCAtIG1lLm9mZnNldFkgLSBpdGVtUmVjdHNbaW5kZXhdLnRvcDtcbiAgICAgICAgICAgIGlzT3ZlckRyYWdnaW5nRW5kICAgPSBjbGllbnRZID4gbWUuYm91bmRhcnlDb250YWluZXJSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGlzT3ZlckRyYWdnaW5nU3RhcnQgPSBjbGllbnRZIDwgbWUuYm91bmRhcnlDb250YWluZXJSZWN0LnRvcDtcbiAgICAgICAgICAgIGl0ZW1IZWlnaHRPcldpZHRoICAgPSAnaGVpZ2h0J1xuICAgICAgICB9XG5cbiAgICAgICAgaXNPdmVyRHJhZ2dpbmcgPSBpc092ZXJEcmFnZ2luZ0VuZCB8fCBpc092ZXJEcmFnZ2luZ1N0YXJ0O1xuICAgICAgICBtb3ZlRmFjdG9yICAgICA9IGlzT3ZlckRyYWdnaW5nID8gMC4wMiA6IDAuNTU7IC8vIFdlIGNhbiBub3QgdXNlIDAuNSwgc2luY2UgaXRlbXMgd291bGQganVtcCBiYWNrICYgZm9ydGhcblxuICAgICAgICBpZiAoaXNPdmVyRHJhZ2dpbmdTdGFydCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleC0tO1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnNjcm9sbFRvSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoaXNPdmVyRHJhZ2dpbmdFbmQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IG1heEl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgbWUuY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUuc2Nyb2xsVG9JbmRleCgpO1xuICAgICAgICAgICAgICAgIG1lLnN3aXRjaEl0ZW1zKGluZGV4LCBtZS5jdXJyZW50SW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChpbmRleCA+IDAgJiYgKCFyZXZlcnNlZCAmJiBkZWx0YSA8IDAgfHwgcmV2ZXJzZWQgJiYgZGVsdGEgPiAwKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+IGl0ZW1SZWN0c1tpbmRleCAtIDFdW2l0ZW1IZWlnaHRPcldpZHRoXSAqIG1vdmVGYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPCBtYXhJdGVtcyAmJiAoIXJldmVyc2VkICYmIGRlbHRhID4gMCB8fCByZXZlcnNlZCAmJiBkZWx0YSA8IDApKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gaXRlbVJlY3RzW2luZGV4ICsgMV1baXRlbUhlaWdodE9yV2lkdGhdICogbW92ZUZhY3Rvcikge1xuICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIG1lLnN3aXRjaEl0ZW1zKGluZGV4LCBtZS5jdXJyZW50SW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc092ZXJEcmFnZ2luZyA9IGlzT3ZlckRyYWdnaW5nICYmIG1lLmN1cnJlbnRJbmRleCAhPT0gMCAmJiBtZS5jdXJyZW50SW5kZXggIT09IG1heEl0ZW1zO1xuXG4gICAgICAgIGlmIChtZS5pc092ZXJEcmFnZ2luZykge1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgzMCk7IC8vIHdhaXQgZm9yIDEgZnJhbWVcblxuICAgICAgICAgICAgaWYgKG1lLmlzT3ZlckRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbWUub25EcmFnTW92ZShkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogS2V5IGFjdGlvbnM6XG4gICAgICogMS4gICoqSWRlbnRpZnkgRHJhZyBUYXJnZXQ6KiogRGV0ZXJtaW5lcyB3aGljaCBpdGVtIGlzIGJlaW5nIGRyYWdnZWQgKGhhbmRsaW5nIGBkcmFnSGFuZGxlU2VsZWN0b3JgIGlmIHByZXNlbnQpLlxuICAgICAqIDIuICAqKlNuYXBzaG90IExheW91dDoqKiBDYXB0dXJlcyB0aGUgY3VycmVudCBET00gcmVjdGFuZ2xlcyAoYGl0ZW1SZWN0c2ApIG9mIGFsbCBzb3J0YWJsZSBpdGVtcy4gVGhpcyBzbmFwc2hvdFxuICAgICAqICAgICBpcyBjcml0aWNhbCBmb3I6XG4gICAgICogICAgIC0gQ2FsY3VsYXRpbmcgZHJhZyBkZWx0YXMgZm9yIHNvcnRpbmcuXG4gICAgICogICAgIC0gUmVzdG9yaW5nIHRoZSBsYXlvdXQgYWZ0ZXIgYSB3aW5kb3cgZHJhZyByZS1lbnRyeS5cbiAgICAgKiAgICAgLSBJbmZlcnJpbmcgZ2FwcyBhbmQgb2Zmc2V0cyBmb3IgYGNhbGN1bGF0ZUV4cGFuZGVkTGF5b3V0YC5cbiAgICAgKiAzLiAgKipTZXR1cCBQcm94eSAmIFBsYWNlaG9sZGVyOioqIENvbmZpZ3VyZXMgdGhlIHZpc3VhbCBkcmFnIHByb3h5IGFuZCBpbnNlcnRzIHRoZSBwbGFjZWhvbGRlciBpbnRvIHRoZSBgc29ydGFibGVJdGVtc2AgbGlzdC5cbiAgICAgKiA0LiAgKipBcHBseSBBYnNvbHV0ZSBQb3NpdGlvbmluZzoqKiBUZW1wb3JhcmlseSBzd2l0Y2hlcyBhbGwgaXRlbXMgdG8gYHBvc2l0aW9uOiBhYnNvbHV0ZWAgYmFzZWQgb24gdGhlaXIgY2FwdHVyZWRcbiAgICAgKiAgICAgY29vcmRpbmF0ZXMgdG8gZW5hYmxlIHNtb290aCwgR1BVLWFjY2VsZXJhdGVkIG1vdmVtZW50IGR1cmluZyB0aGUgZHJhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRyYWcgc3RhcnQgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBvbkRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQsIGRyYWdIYW5kbGVTZWxlY3Rvciwgb3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBpdGVtU3R5bGVzICAgICAgICAgICA9IG1lLml0ZW1TdHlsZXMgPSBbXSxcbiAgICAgICAgICAgIHtsYXlvdXR9ICAgICAgICAgICAgID0gb3duZXIsXG4gICAgICAgICAgICBvd25lclN0eWxlICAgICAgICAgICA9IG93bmVyLnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgZHJhZ2dlZEl0ZW0sIGluZGV4LCBpbmRleE1hcCwgaXRlbVN0eWxlLCByZWN0LCBzb3J0YWJsZUl0ZW1zO1xuXG4gICAgICAgIGlmIChvd25lci5kcmFnUmVzb3J0YWJsZSkge1xuICAgICAgICAgICAgaWYgKGRyYWdIYW5kbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsYXNzTmFtZSA9IGRyYWdIYW5kbGVTZWxlY3Rvci5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlTm9kZSAgICAgID0gZGF0YS5wYXRoLmZpbmQobm9kZSA9PiBub2RlLmNscy5pbmNsdWRlcyhoYW5kbGVDbGFzc05hbWUpKTtcblxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlSW5kZXggPSBkYXRhLnBhdGguaW5kZXhPZihoYW5kbGVOb2RlKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBoYW5kbGVJbmRleDsgaSA8IGRhdGEucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxJdGVtTm9kZSA9IGRhdGEucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChwb3RlbnRpYWxJdGVtTm9kZS5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBvd25lci5pdGVtcy5pbmNsdWRlcyhjb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFkcmFnZ2VkSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc29ydGFibGVJdGVtcyA9IG93bmVyLml0ZW1zLmZpbHRlcihpdGVtID0+IFZEb21VdGlsLmZpbmQoaXRlbS52ZG9tLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogZHJhZ0hhbmRsZVNlbGVjdG9yLnN0YXJ0c1dpdGgoJy4nKSA/IGRyYWdIYW5kbGVTZWxlY3Rvci5zdWJzdHJpbmcoMSkgOiBkcmFnSGFuZGxlU2VsZWN0b3JcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaW5kZXggICAgICAgICA9IHNvcnRhYmxlSXRlbXMuaW5kZXhPZihkcmFnZ2VkSXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtICAgPSBOZW8uZ2V0Q29tcG9uZW50KGRhdGEucGF0aFswXS5pZCk7XG4gICAgICAgICAgICAgICAgc29ydGFibGVJdGVtcyA9IG93bmVyLml0ZW1zO1xuICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgPSBvd25lci5pbmRleE9mKGRyYWdnZWRJdGVtLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5kZXhNYXAgPSB7fTtcblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCAgICAgICAgICAgOiBpbmRleCxcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCAgICAgICAgICAgIDogVkRvbVV0aWwuZmluZChvd25lci52ZG9tLCBkcmFnZ2VkSXRlbS5pZCkudmRvbSxcbiAgICAgICAgICAgICAgICBkcmFnUHJveHlDb25maWcgICAgICAgIDogbWUuZ2V0RHJhZ1Byb3h5Q29uZmlnKCksXG4gICAgICAgICAgICAgICAgaW5kZXhNYXAsXG4gICAgICAgICAgICAgICAgb3duZXJTdHlsZSAgICAgICAgICAgICA6IHtoZWlnaHQ6IG93bmVyU3R5bGUuaGVpZ2h0LCBtaW5XaWR0aDogb3duZXJTdHlsZS5taW5XaWR0aCwgd2lkdGg6IG93bmVyU3R5bGUud2lkdGh9LFxuICAgICAgICAgICAgICAgIHJldmVyc2VkTGF5b3V0RGlyZWN0aW9uOiBsYXlvdXQuZGlyZWN0aW9uID09PSAnY29sdW1uLXJldmVyc2UnIHx8IGxheW91dC5kaXJlY3Rpb24gPT09ICdyb3ctcmV2ZXJzZScsXG4gICAgICAgICAgICAgICAgc29ydGFibGVJdGVtcyxcbiAgICAgICAgICAgICAgICBzb3J0RGlyZWN0aW9uICAgICAgICAgIDogbGF5b3V0LmRpcmVjdGlvbj8uaW5jbHVkZXMoJ2NvbHVtbicpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ICAgICAgICAgICAgIDogaW5kZXhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5kcmFnQ29tcG9uZW50ID0gZHJhZ2dlZEl0ZW07XG5cbiAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGluZGV4TWFwW2ldID0gb3duZXIuaXRlbXMuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgICAgIGl0ZW1TdHlsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbS5oZWlnaHQgPyBgJHtpdGVtLmhlaWdodH1weGAgOiAgaXRlbS5zdHlsZT8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA6IGl0ZW0ud2lkdGggID8gYCR7aXRlbS53aWR0aH1weGAgIDogIGl0ZW0uc3R5bGU/LndpZHRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgaXRlbVJlY3RzID0gYXdhaXQgb3duZXIuZ2V0RG9tUmVjdChbb3duZXIuaWRdLmNvbmNhdChzb3J0YWJsZUl0ZW1zLm1hcChlID0+IGUuaWQpKSk7XG5cbiAgICAgICAgICAgIG1lLm93bmVyUmVjdCA9IGl0ZW1SZWN0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgICBvd25lci5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5vd25lclN0eWxlLFxuICAgICAgICAgICAgICAgIGhlaWdodCAgOiBgJHttZS5vd25lclJlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogYCR7bWUub3duZXJSZWN0LndpZHRofXB4YCxcbiAgICAgICAgICAgICAgICB3aWR0aCAgIDogYCR7bWUub3duZXJSZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgJiYgaXRlbVJlY3RzLmZvckVhY2gocmVjdCA9PiB7XG4gICAgICAgICAgICAgICAgcmVjdC54IC09IG1lLm93bmVyUmVjdC54O1xuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBtZS5vd25lclJlY3QueVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1SZWN0cyA9IGl0ZW1SZWN0cztcblxuICAgICAgICAgICAgYXdhaXQgbWUuZHJhZ1N0YXJ0KGRhdGEpO1xuXG4gICAgICAgICAgICBpZiAobWUuZHJhZ1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJJbmRleCA9IHNvcnRhYmxlSXRlbXMuaW5kZXhPZihkcmFnZ2VkSXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVySW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZUl0ZW1zW3BsYWNlaG9sZGVySW5kZXhdID0gbWUuZHJhZ1BsYWNlaG9sZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZS5kcmFnRWxlbWVudCA9IG1lLmRyYWdQbGFjZWhvbGRlci52ZG9tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3J0YWJsZUl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBpdGVtLndyYXBwZXJTdHlsZSB8fCB7fTtcbiAgICAgICAgICAgICAgICByZWN0ICAgICAgPSBtZS5pdGVtUmVjdHNbaV07XG5cbiAgICAgICAgICAgICAgICBtZS5hZGp1c3RQcm94eVJlY3RUb1BhcmVudD8uKHJlY3QsIG1lLm93bmVyUmVjdCk7XG5cbiAgICAgICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IE9iamVjdC5hc3NpZ24oaXRlbVN0eWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAgOiBgJHtyZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgICAgOiBgJHtyZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW4gIDogJzBweCcsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICB0b3AgICAgIDogYCR7cmVjdC50b3B9cHhgLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAgIDogYCR7cmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDUpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcGxhY2Vob2xkZXIsIHRoZSBvcmlnaW5hbCBpdGVtIGlzIGFscmVhZHkgaGlkZGVuL21vdmVkLlxuICAgICAgICAgICAgLy8gQnV0IHdlIG1pZ2h0IHdhbnQgdG8gZW5zdXJlIHRoZSBwbGFjZWhvbGRlciAod2hpY2ggaXMgbm93IGluIHNvcnRhYmxlSXRlbXMpIG1hdGNoZXMgZXhwZWN0YXRpb25zP1xuICAgICAgICAgICAgLy8gVGhlIGxvZ2ljIGJlbG93IG9yaWdpbmFsbHkgaGlkIHRoZSBkcmFnZ2VkSXRlbS5cbiAgICAgICAgICAgIC8vIElmIHdlIHVzZSBwbGFjZWhvbGRlciwgZHJhZ2dlZEl0ZW0gaXMgaW4gcHJveHkgKHZpc2libGUpLiBQbGFjZWhvbGRlciBpcyBoaWRkZW4uXG4gICAgICAgICAgICAvLyBtZS5kcmFnUGxhY2Vob2xkZXIgbG9naWMgaW4gRHJhZ1pvbmUgYWxyZWFkeSBzZXQgaXQgdG8gdmlzaWJpbGl0eTogaGlkZGVuLlxuICAgICAgICAgICAgaWYgKCFtZS5kcmFnUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBkcmFnZ2VkSXRlbS53cmFwcGVyU3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbS53cmFwcGVyU3R5bGUgPSBpdGVtU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGEgbmV3IGxheW91dCBmb3IgdGhlIHJlbWFpbmluZyBpdGVtcyB3aGVuIG9uZSBpdGVtIGlzIGRyYWdnZWQgb3V0IG9mIHRoZSBjb250YWluZXIgKGUuZy4sIGludG8gYSBuZXcgd2luZG93KS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIGRhc2hib2FyZCBkb2Vzbid0IGxlYXZlIGEgXCJob2xlXCIgd2hlcmUgdGhlIGRyYWdnZWQgaXRlbSB3YXMuIEluc3RlYWQsIGl0OlxuICAgICAqIDEuICAqKkluZmVycyBHYXBzICYgT2Zmc2V0czoqKiBBbmFseXplcyB0aGUgY2FjaGVkIGBpdGVtUmVjdHNgIHRvIG1hdGhlbWF0aWNhbGx5IGRlcml2ZSB0aGUgY29udGFpbmVyJ3MgcGFkZGluZ1xuICAgICAqICAgICBhbmQgdGhlIGdhcHMgYmV0d2VlbiBpdGVtcywgZW5zdXJpbmcgdGhlIG5ldyBsYXlvdXQgcmVzcGVjdHMgdGhlIG9yaWdpbmFsIGRlc2lnbiB0b2tlbnMuXG4gICAgICogMi4gICoqSWRlbnRpZmllcyBSZW1haW5pbmcgSXRlbXM6KiogRmlsdGVycyBvdXQgdGhlIGRyYWdnZWQgY29tcG9uZW50IGFuZCBpdHMgcGxhY2Vob2xkZXIuXG4gICAgICogMy4gICoqRGlzdHJpYnV0ZXMgU3BhY2U6KiogQ2FsY3VsYXRlcyB0aGUgYXZhaWxhYmxlIHNwYWNlIChUb3RhbCBTaXplIC0gT2Zmc2V0cyAtIEdhcHMgLSBGaXhlZCBJdGVtcykgYW5kIGRpc3RyaWJ1dGVzXG4gICAgICogICAgIGl0IGFtb25nIGZsZXggaXRlbXMgcHJvcG9ydGlvbmFsIHRvIHRoZWlyIGZsZXggdmFsdWVzLlxuICAgICAqIDQuICAqKkdlbmVyYXRlcyBTdHlsZXM6KiogUmV0dXJucyBhIGxpc3Qgb2Ygc3R5bGUgb2JqZWN0cyAoYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGApIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJlbWFpbmluZyBpdGVtcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX0gQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBgaXRlbWAgcmVmZXJlbmNlIGFuZCB0aGUgY2FsY3VsYXRlZCBgc3R5bGVgIG9iamVjdC5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVFeHBhbmRlZExheW91dCgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lclJlY3QgICAgPSBtZS5vd25lclJlY3QsXG4gICAgICAgICAgICBpc0hvcml6b250YWwgPSBtZS5zb3J0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICB0b3RhbFNpemUgICAgPSBpc0hvcml6b250YWwgPyBvd25lclJlY3Qud2lkdGggOiBvd25lclJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgaXRlbXMgICAgICAgID0gW10sXG4gICAgICAgICAgICB0b3RhbEZsZXggICAgPSAwLFxuICAgICAgICAgICAgdXNlZFNpemUgICAgID0gMCxcbiAgICAgICAgICAgIHJlY3RzICAgICAgICA9IFtdLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQgID0gMCxcbiAgICAgICAgICAgIGVuZE9mZnNldCAgICA9IDAsXG4gICAgICAgICAgICBnYXAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgdG9wT2Zmc2V0ICAgID0gMCxcbiAgICAgICAgICAgIGJvdHRvbU9mZnNldCA9IDAsXG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ICAgPSAwLFxuICAgICAgICAgICAgcmlnaHRPZmZzZXQgID0gMCxcbiAgICAgICAgICAgIHN0YXJ0WCAgICAgICA9IG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gMCA6IG93bmVyUmVjdC54LFxuICAgICAgICAgICAgc3RhcnRZICAgICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyAwIDogb3duZXJSZWN0Lnk7XG5cbiAgICAgICAgLy8gMS4gQ2FsY3VsYXRlIG9mZnNldHMgYW5kIGdhcHMgZnJvbSB0aGUgb3JpZ2luYWwgc2xvdHMgKGl0ZW1SZWN0cylcbiAgICAgICAgaWYgKG1lLml0ZW1SZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgcjAgPSBtZS5pdGVtUmVjdHNbMF0sXG4gICAgICAgICAgICAgICAgcm4gPSBtZS5pdGVtUmVjdHNbbWUuaXRlbVJlY3RzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyByMC54IDogcjAueCAtIG93bmVyUmVjdC54O1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCAgICA9IHRvdGFsU2l6ZSAtIChtZS5hZGp1c3RJdGVtUmVjdHNUb1BhcmVudCA/IChybi54ICsgcm4ud2lkdGgpIDogKHJuLnggLSBvd25lclJlY3QueCArIHJuLndpZHRoKSk7XG4gICAgICAgICAgICAgICAgdG9wT2Zmc2V0ICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyByMC55IDogcjAueSAtIG93bmVyUmVjdC55O1xuICAgICAgICAgICAgICAgIGJvdHRvbU9mZnNldCA9IG93bmVyUmVjdC5oZWlnaHQgLSAobWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyAocjAueSArIHIwLmhlaWdodCkgOiAocjAueSAtIG93bmVyUmVjdC55ICsgcjAuaGVpZ2h0KSk7IC8vIEFwcHJveCBmcm9tIGZpcnN0IGl0ZW1cblxuICAgICAgICAgICAgICAgIGlmIChtZS5pdGVtUmVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcjEgPSBtZS5pdGVtUmVjdHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGdhcCA9IHIxLnggLSAocjAueCArIHIwLndpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyByMC55IDogcjAueSAtIG93bmVyUmVjdC55O1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCAgID0gdG90YWxTaXplIC0gKG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gKHJuLnkgKyBybi5oZWlnaHQpIDogKHJuLnkgLSBvd25lclJlY3QueSArIHJuLmhlaWdodCkpO1xuICAgICAgICAgICAgICAgIGxlZnRPZmZzZXQgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyByMC54IDogcjAueCAtIG93bmVyUmVjdC54O1xuICAgICAgICAgICAgICAgIHJpZ2h0T2Zmc2V0ID0gb3duZXJSZWN0LndpZHRoIC0gKG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gKHIwLnggKyByMC53aWR0aCkgOiAocjAueCAtIG93bmVyUmVjdC54ICsgcjAud2lkdGgpKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5pdGVtUmVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcjEgPSBtZS5pdGVtUmVjdHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGdhcCA9IHIxLnkgLSAocjAueSArIHIwLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDIuIEZpbHRlciB2YWxpZCBpdGVtc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLml0ZW1SZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZEluZGV4ID0gbWUuaW5kZXhNYXBbaV07XG5cbiAgICAgICAgICAgIGlmIChtYXBwZWRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpdGVtID0gbWUub3duZXIuaXRlbXNbbWFwcGVkSW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gbWUuZHJhZ1BsYWNlaG9sZGVyIHx8IGl0ZW0gPT09IG1lLmRyYWdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlY3QgPSBtZS5pdGVtUmVjdHNbaV07XG5cbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe2l0ZW0sIHJlY3R9KTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uZmxleCkge1xuICAgICAgICAgICAgICAgIHRvdGFsRmxleCArPSBpdGVtLmZsZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzaXplID0gaXNIb3Jpem9udGFsID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHVzZWRTaXplICs9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBDYWxjdWxhdGUgYXZhaWxhYmxlIHNwYWNlXG4gICAgICAgIGxldCB0b3RhbEdhcHMgICAgICA9IE1hdGgubWF4KDAsIGl0ZW1zLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgYXZhaWxhYmxlU3BhY2UgPSBNYXRoLm1heCgwLCB0b3RhbFNpemUgLSBzdGFydE9mZnNldCAtIGVuZE9mZnNldCAtICh0b3RhbEdhcHMgKiBnYXApIC0gdXNlZFNpemUpO1xuXG4gICAgICAgIC8vIDQuIERpc3RyaWJ1dGUgc3BhY2VcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSBzdGFydE9mZnNldDtcblxuICAgICAgICBpdGVtcy5mb3JFYWNoKCh7aXRlbSwgcmVjdH0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgaXRlbVNpemUsIHN0eWxlID0ge307XG5cbiAgICAgICAgICAgIGlmIChpdGVtLmZsZXgpIHtcbiAgICAgICAgICAgICAgICBpdGVtU2l6ZSA9IChpdGVtLmZsZXggLyB0b3RhbEZsZXgpICogYXZhaWxhYmxlU3BhY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1TaXplID0gaXNIb3Jpem9udGFsID8gcmVjdC53aWR0aCA6IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgIDogYCR7c3RhcnRYICsgY3VycmVudFBvc31weGAsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgIDogYCR7c3RhcnRZICsgdG9wT2Zmc2V0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtvd25lclJlY3QuaGVpZ2h0IC0gdG9wT2Zmc2V0IC0gYm90dG9tT2Zmc2V0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggOiBgJHtpdGVtU2l6ZX1weGBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgOiBgJHtzdGFydFggKyBsZWZ0T2Zmc2V0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgdG9wICAgOiBgJHtzdGFydFkgKyBjdXJyZW50UG9zfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtpdGVtU2l6ZX1weGAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7b3duZXJSZWN0LndpZHRoIC0gbGVmdE9mZnNldCAtIHJpZ2h0T2Zmc2V0fXB4YFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY3RzLnB1c2goe2l0ZW0sIHN0eWxlfSk7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IGl0ZW1TaXplICsgZ2FwO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVjdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgc2Nyb2xsVG9JbmRleCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgIGF3YWl0IG1lLm93bmVyLnNjcm9sbFRvSW5kZXg/LihtZS5jdXJyZW50SW5kZXgsIG1lLml0ZW1SZWN0c1ttZS5jdXJyZW50SW5kZXhdKTtcbiAgICAgICAgbWUuaXNTY3JvbGxpbmcgPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGRyYWcgbW92ZSBldmVudC4gVGhpcyBpcyB0aGUgY29yZSBsb2dpYyBsb29wIGZvciB0aGUgZHJhZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBSZXNwb25zaWJpbGl0aWVzOlxuICAgICAqIDEuICAqKldpbmRvdyBEcmFnIFJlLWVudHJ5OioqIENoZWNrcyBpZiBhIHdpbmRvdyBkcmFnIGhhcyByZS1lbnRlcmVkIHRoZSBvcmlnaW5hbCBjb250YWluZXIgYm91bmRhcmllcy5cbiAgICAgKiAgICAgSWYgc28sIGl0IHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBsYXlvdXQgc25hcHNob3QgKGBpdGVtUmVjdHNgKSBhbmQgc2hvd3MgdGhlIHBsYWNlaG9sZGVyLCBlZmZlY3RpdmVseVxuICAgICAqICAgICBcInNuYXBwaW5nXCIgdGhlIGRhc2hib2FyZCBiYWNrIHRvIGl0cyBzb3J0YWJsZSBzdGF0ZS5cbiAgICAgKiAyLiAgKipXaW5kb3cgRHJhZyBFeGl0OioqIERldGVjdHMgaWYgdGhlIGRyYWcgcHJveHkgaGFzIGxlZnQgdGhlIGNvbnRhaW5lciBib3VuZGFyaWVzIChpZiBgZW5hYmxlUHJveHlUb1BvcHVwYCBpcyB0cnVlKVxuICAgICAqICAgICBhbmQgdHJpZ2dlcnMgdGhlIGBkcmFnQm91bmRhcnlFeGl0YCBldmVudCB0byBwb3RlbnRpYWxseSBzdGFydCBhIHdpbmRvdyBkcmFnLlxuICAgICAqIDMuICAqKlN0YW5kYXJkIFNvcnRpbmc6KiogSWYgbm90IGluIHdpbmRvdy1kcmFnIG1vZGUsIGl0IGNhbGN1bGF0ZXMgdGhlIGRyYWcgZGVsdGEgYW5kIHN3YXBzIGl0ZW1zIChgc3dpdGNoSXRlbXNgKVxuICAgICAqICAgICBpZiB0aGUgdGhyZXNob2xkIGlzIGNyb3NzZWQsIHVwZGF0aW5nIHRoZSBgY3VycmVudEluZGV4YC5cbiAgICAgKiA0LiAgKipBdXRvLVNjcm9sbGluZzoqKiBNYW5hZ2VzIGF1dG8tc2Nyb2xsaW5nIHdoZW4gZHJhZ2dpbmcgbmVhciB0aGUgZWRnZXMgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRyYWcgbW92ZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIHN0YXJ0V2luZG93RHJhZyhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7cG9wdXBIZWlnaHQsIHBvcHVwV2lkdGgsIHdpbmRvd05hbWV9ID0gZGF0YTtcblxuICAgICAgICAvLyBLZWVwIHRoZSBwcm94eSBhY3RpdmUgdG8gY2FwdHVyZSBtb3VzZSBldmVudHMsIGJ1dCBtYWtlIGl0IGludmlzaWJsZVxuICAgICAgICBtZS5kcmFnUHJveHkuc3R5bGUgPSB7b3BhY2l0eTogMH07XG4gICAgICAgIG1lLmlzV2luZG93RHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIGlmIChtZS5kcmFnUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIG1lLmRyYWdQbGFjZWhvbGRlci53cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ubWUuZHJhZ1BsYWNlaG9sZGVyLndyYXBwZXJTdHlsZSxcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IGV4cGFuZGVkIGxheW91dFxuICAgICAgICBsZXQgZXhwYW5kZWRMYXlvdXQgPSBtZS5jYWxjdWxhdGVFeHBhbmRlZExheW91dCgpO1xuICAgICAgICBleHBhbmRlZExheW91dC5mb3JFYWNoKCh7aXRlbSwgc3R5bGV9KSA9PiB7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHsuLi5pdGVtLndyYXBwZXJTdHlsZSwgLi4uc3R5bGV9O1xuICAgICAgICB9KTtcblxuICAgICAgICBOZW8ubWFpbi5hZGRvbi5EcmFnRHJvcC5zdGFydFdpbmRvd0RyYWcoe1xuICAgICAgICAgICAgcG9wdXBIZWlnaHQsXG4gICAgICAgICAgICBwb3B1cE5hbWU6IHdpbmRvd05hbWUsXG4gICAgICAgICAgICBwb3B1cFdpZHRoLFxuICAgICAgICAgICAgd2luZG93SWQgOiBtZS53aW5kb3dJZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB0d28gaXRlbXMgaW4gdGhlIHNvcnQgbGlzdCwgdXBkYXRpbmcgdGhlaXIgbGF5b3V0IGNvb3JkaW5hdGVzIGFuZCB0aGUgaW50ZXJuYWwgaW5kZXggbWFwLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgcGh5c2ljYWwgcmVvcmRlcmluZyBvZiBpdGVtcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi4gSXQgcGVyZm9ybXMgdGhlIGZvbGxvd2luZzpcbiAgICAgKiAxLiAgKipOb3JtYWxpemF0aW9uOioqIEVuc3VyZXMgaW5kaWNlcyBhcmUgb3JkZXJlZCBjb3JyZWN0bHkgYmFzZWQgb24gbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgKiAyLiAgKipHZW9tZXRyeSBDYWxjdWxhdGlvbjoqKiBTd2FwcyB0aGUgZGltZW5zaW9ucyAod2lkdGgvaGVpZ2h0KSBvZiB0aGUgdHdvIGl0ZW1zIGFuZCByZWNhbGN1bGF0ZXNcbiAgICAgKiAgICAgdGhlaXIgcG9zaXRpb25zICh4L3kpLCBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCBnYXAgYmV0d2VlbiB0aGVtLiBUaGlzIGVuc3VyZXMgdGhhdCBpdGVtcyBvZiBkaWZmZXJlbnRcbiAgICAgKiAgICAgc2l6ZXMgc3dhcCBjb3JyZWN0bHkgd2l0aG91dCBicmVha2luZyB0aGUgbGF5b3V0IHN0cnVjdHVyZS5cbiAgICAgKiAzLiAgKipTdGF0ZSBVcGRhdGU6KiogVXBkYXRlcyB0aGUgYGluZGV4TWFwYCB0byByZWZsZWN0IHRoZSBuZXcgbG9naWNhbCBvcmRlciBvZiBpdGVtcy5cbiAgICAgKiA0LiAgKipWaXN1YWwgVXBkYXRlOioqIENhbGxzIGB1cGRhdGVJdGVtYCB0byBhcHBseSB0aGUgbmV3IGNvb3JkaW5hdGVzIHRvIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgxIC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIHRvIHN3YXAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MiAtIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0gdG8gc3dhcC5cbiAgICAgKi9cbiAgICBzd2l0Y2hJdGVtcyhpbmRleDEsIGluZGV4Mikge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmV2ZXJzZWQgPSBtZS5yZXZlcnNlZExheW91dERpcmVjdGlvbixcbiAgICAgICAgICAgIHRtcDtcblxuICAgICAgICBpZiAoKCFyZXZlcnNlZCAmJiBpbmRleDIgPCBpbmRleDEpIHx8IChyZXZlcnNlZCAmJiBpbmRleDEgPCBpbmRleDIpKSB7XG4gICAgICAgICAgICB0bXAgICAgPSBpbmRleDE7XG4gICAgICAgICAgICBpbmRleDEgPSBpbmRleDI7XG4gICAgICAgICAgICBpbmRleDIgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXRlbVJlY3RzID0gbWUuaXRlbVJlY3RzLFxuICAgICAgICAgICAgbWFwICAgICAgID0gbWUuaW5kZXhNYXAsXG4gICAgICAgICAgICByZWN0MSAgICAgPSBpdGVtUmVjdHNbaW5kZXgxXSxcbiAgICAgICAgICAgIHJlY3QyICAgICA9IGl0ZW1SZWN0c1tpbmRleDJdLFxuICAgICAgICAgICAgcmVjdDFDb3B5ID0gcmVjdDEuY2xvbmUoKSxcbiAgICAgICAgICAgIHJlY3QyQ29weSA9IHJlY3QyLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKG1lLnNvcnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgY29uc3QgZ2FwID0gcmVjdDJDb3B5LnggLSAocmVjdDFDb3B5LnggKyByZWN0MUNvcHkud2lkdGgpO1xuXG4gICAgICAgICAgICByZWN0MS53aWR0aCA9IHJlY3QyQ29weS53aWR0aDtcbiAgICAgICAgICAgIHJlY3QyLnggICAgID0gcmVjdDFDb3B5LnggKyByZWN0MkNvcHkud2lkdGggKyBnYXA7XG4gICAgICAgICAgICByZWN0Mi53aWR0aCA9IHJlY3QxQ29weS53aWR0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2FwID0gcmVjdDJDb3B5LnkgLSAocmVjdDFDb3B5LnkgKyByZWN0MUNvcHkuaGVpZ2h0KTtcblxuICAgICAgICAgICAgcmVjdDEuaGVpZ2h0ID0gcmVjdDJDb3B5LmhlaWdodDtcbiAgICAgICAgICAgIHJlY3QyLmhlaWdodCA9IHJlY3QxQ29weS5oZWlnaHQ7XG4gICAgICAgICAgICByZWN0Mi55ICAgICAgPSByZWN0MUNvcHkueSArIHJlY3QyQ29weS5oZWlnaHQgKyBnYXA7XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgICAgICAgICA9IG1hcFtpbmRleDFdO1xuICAgICAgICBtYXBbaW5kZXgxXSA9IG1hcFtpbmRleDJdO1xuICAgICAgICBtYXBbaW5kZXgyXSA9IHRtcDtcblxuICAgICAgICBtZS51cGRhdGVJdGVtKGluZGV4MSwgcmVjdDEpO1xuICAgICAgICBtZS51cGRhdGVJdGVtKGluZGV4MiwgcmVjdDIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKi9cbiAgICB1cGRhdGVJdGVtKGluZGV4LCByZWN0KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtYXBwZWRJbmRleCA9IG1lLmluZGV4TWFwW2luZGV4XSxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgaWYgKG1hcHBlZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKG1lLmRyYWdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBtZS5kcmFnUGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IG1lLm93bmVyLml0ZW1zW21hcHBlZEluZGV4XTtcblxuICAgICAgICAgICAgaWYgKG1lLmRyYWdQbGFjZWhvbGRlciAmJiBpdGVtID09PSBtZS5kcmFnQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lLmRyYWdQbGFjZWhvbGRlclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHt3cmFwcGVyU3R5bGV9ID0gaXRlbTtcblxuICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IGAke3JlY3QubGVmdH1weGA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS50b3AgID0gYCR7cmVjdC50b3B9cHhgO1xuXG4gICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTb3J0Wm9uZSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9