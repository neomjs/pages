"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_draggable_container_SortZone_mjs"],{

/***/ "./src/draggable/container/DragZone.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/container/DragZone.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.draggable.container.DragZone
 * @extends Neo.draggable.DragZone
 */
class DragZone extends _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.container.DragZone'
         * @protected
         */
        className: 'Neo.draggable.container.DragZone',
        /**
         * @member {String} ntype='container-dragzone'
         * @protected
         */
        ntype: 'container-dragzone'
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me,
            opts    = {delegate: '.neo-draggable', scope: me};

        owner.addDomListeners([
            {'drag:end'  : me.onDragEnd,   ...opts},
            {'drag:move' : me.onDragMove,  ...opts},
            {'drag:start': me.onDragStart, ...opts}
        ]);

        owner.on({
            insert      : me.onItemInsert,
            itemsCreated: me.onItemsCreated,
            scope       : me
        });

        // The container items can already be created
        me.adjustItemCls(true);
    }

    /**
     * @param {Boolean} draggable
     */
    adjustItemCls(draggable) {
        let me      = this,
            {owner} = me,
            wrapperCls;

        owner.items.forEach(item => {
            // spacers
            if (typeof item === 'string') {
                return;
            }

            wrapperCls = item.wrapperCls || [];

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
            item.wrapperCls = wrapperCls;
        });
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        if (this.owner.draggable) {
            let me           = this,
                proxy        = me.dragProxy,
                cls          = proxy.cls || {},
                rect         = me.dragElementRect,
                wrapperStyle = proxy.wrapperStyle || {};

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(cls, 'neo-animate');
            proxy.cls = cls;

            // ensure to get into the next animation frame
            me.timeout(30).then(() => {
                wrapperStyle.left = `${rect.left}px`;
                wrapperStyle.top  = `${rect.top}px`;

                proxy.wrapperStyle = wrapperStyle;

                me.timeout(100).then(() => {
                    me.dragEnd();
                });
            });
        }
    }

    /**
     * @param {Object} data
     */
    async onDragStart(data) {
        let me = this;

        if (me.owner.draggable) {
            me.dragElement = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.owner.vdom, data.path[0].id).vdom;
            await me.dragStart(data);
        }
    }

    /**
     * @param {Object}             data
     * @param {Number}             data.index
     * @param {Neo.component.Base} data.item
     */
    onItemInsert(data) {
        let {item}     = data,
            wrapperCls = item.wrapperCls || [];

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].add(wrapperCls, 'neo-draggable');
        item.wrapperCls = wrapperCls;
    }

    /**
     * @param {Object}               data
     * @param {String}               data.id
     * @param {Neo.component.Base[]} data.items
     */
    onItemsCreated(data) {
        this.adjustItemCls(true);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DragZone));


/***/ },

/***/ "./src/draggable/container/SortZone.mjs"
/*!**********************************************!*\
  !*** ./src/draggable/container/SortZone.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DragZone.mjs */ "./src/draggable/container/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");





/**
 * @summary Manages the drag-and-drop reordering of items within a container, with support for window detachment.
 *
 * This class extends `Neo.draggable.container.DragZone` to provide sorting capabilities for `Neo.container.Base` instances.
 * It handles the complex logic of tracking item positions, swapping them during the drag operation, and updating
 * the container's layout upon drop.
 *
 * A key feature of this class is its support for **Window Detachment** (tearing tabs or items out of the main window).
 * When an item is dragged outside the browser window boundaries:
 * 1. The `startWindowDrag` method is triggered.
 * 2. The drag placeholder is hidden.
 * 3. The `calculateExpandedLayout` method dynamically computes a new layout for the remaining items, expanding them
 *    to fill the empty space (animating `width`, `height`, `top`, and `left`).
 * 4. If the drag re-enters the window (`onDragBoundaryEntry`), the original layout snapshot is restored, and the
 *    placeholder reappears, allowing for a seamless return to sorting mode.
 *
 * This class interacts closely with:
 * - `Neo.draggable.DragProxy`: For the visual representation of the dragged item.
 * - `Neo.main.addon.DragDrop`: For communicating drag state across the browser/OS environment.
 *
 * @class Neo.draggable.container.SortZone
 * @extends Neo.draggable.container.DragZone
 * @see Neo.draggable.container.DragZone
 * @see Neo.main.addon.DragDrop
 */
class SortZone extends _DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.draggable.container.SortZone'
         * @protected
         */
        className: 'Neo.draggable.container.SortZone',
        /**
         * @member {String} ntype='container-sortzone'
         * @protected
         */
        ntype: 'container-sortzone',
        /**
         * Depending on the parent structure using position absolute and relative, it can be needed to subtract
         * the x & y parent rect values from the item rects.
         * @member {Boolean} adjustItemRectsToParent=false
         */
        adjustItemRectsToParent: false,
        /**
         * @member {Boolean} alwaysFireDragMove=true
         */
        alwaysFireDragMove: true,
        /**
         * @member {Number} currentIndex=-1
         * @protected
         */
        currentIndex: -1,
        /**
         * The intersection ratio (0-1) required to detach an item into a new window.
         * Lower values mean the item must be dragged further out.
         * @member {Number} detachThreshold=0.8
         */
        detachThreshold: 0.8,
        /**
         * A CSS selector to identify the drag handle within a component.
         * If specified, the drag is initiated on this element, but the owning component is dragged.
         * @member {String|null} dragHandleSelector=null
         */
        dragHandleSelector: null,
        /**
         * @member {Boolean} enableProxyToPopup=false
         */
        enableProxyToPopup: false,
        /**
         * @member {Object} indexMap=null
         * @protected
         */
        indexMap: null,
        /**
         * @member {Array|null} itemRects=null
         * @protected
         */
        itemRects: null,
        /**
         * @member {Array|null} itemStyles=null
         * @protected
         */
        itemStyles: null,
        /**
         * @member {Number} lastIntersectionRatio=1
         * @protected
         */
        lastIntersectionRatio: 1,
        /**
         * @member {Object} ownerRect=null
         * @protected
         */
        ownerRect: null,
        /**
         * @member {Object} ownerStyle=null
         * @protected
         */
        ownerStyle: null,
        /**
         * The intersection ratio (0-1) required to re-attach a window-dragged item back into the container.
         * Higher values mean the item must be dragged further in.
         * @member {Number} reattachThreshold=0.6
         */
        reattachThreshold: 0.6,
        /**
         * @member {Boolean} alwaysFireDragMove=false
         * @protected
         */
        reversedLayoutDirection: false,
        /**
         * @member {Number} scrollLeft=0
         */
        scrollLeft: 0,
        /**
         * @member {Number} scrollTop=0
         */
        scrollTop: 0,
        /**
         * Internal flag: onDragStart() will set the value to horizontal or vertical, depending on the current layout.
         * @member {String} sortDirection='horizontal'
         * @protected
         */
        sortDirection: 'horizontal',
        /**
         * @member {Number} startIndex=-1
         * @protected
         */
        startIndex: -1
    }

    /**
     * @member {Boolean} isOverDragging=false
     * @protected
     */
    isOverDragging = false
    /**
     * @member {Boolean} isWindowDragging=false
     * @protected
     */
    isWindowDragging = false

    /**
     * Toggles the neo-draggable cls on items inside our owner.
     * @param {Boolean} draggable
     */
    adjustItemCls(draggable) {
        let me = this;

        if (me.dragHandleSelector) {
            const handleCls     = me.dragHandleSelector.startsWith('.') ? me.dragHandleSelector.substring(1) : me.dragHandleSelector;
            const sortableItems = me.owner.items.filter(item =>
                typeof item !== 'string' && _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(item.vdom, {cls: handleCls})
            );

            sortableItems.forEach(item => {
                const wrapperCls = item.wrapperCls || [];
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].toggle(wrapperCls, 'neo-draggable', draggable);
                item.wrapperCls = wrapperCls
            });
        } else {
            super.adjustItemCls(draggable)
        }
    }

    /**
     * @param {Object} data
     * @returns {Boolean} true if the method processing should stop
     */
    checkWindowBoundary(data) {
        let me = this,
            {proxyRect} = data;

        if (proxyRect && me.boundaryContainerRect) {
            const
                boundaryRect      = me.boundaryContainerRect,
                intersection      = _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getIntersection(proxyRect, boundaryRect),
                proxyArea         = proxyRect.width * proxyRect.height,
                intersectionArea  = intersection ? intersection.width * intersection.height : 0,
                intersectionRatio = proxyArea > 0 ? intersectionArea / proxyArea : 0,
                isMovingIn        = intersectionRatio > me.lastIntersectionRatio,
                isMovingOut       = intersectionRatio < me.lastIntersectionRatio;

            me.lastIntersectionRatio = intersectionRatio;

            if (!me.isWindowDragging) {
                if (isMovingOut && intersectionRatio < me.detachThreshold) {
                    me.isWindowDragging = true; // Set flag to prevent re-entry

                    me.fire('dragBoundaryExit', {
                        draggedItem: me.dragComponent,
                        proxyRect,
                        sortZone   : me
                    });
                    return true // Stop further processing in onDragMove
                }
            } else if (me.isWindowDragging) {
                if (isMovingIn && intersectionRatio > me.reattachThreshold) {
                    // Restore layout
                    me.dragPlaceholder.wrapperStyle = {
                        ...me.dragPlaceholder.wrapperStyle,
                        visibility: 'visible'
                    };

                    // Re-applying the current state:
                    me.itemRects.forEach((rect, index) => {
                        let mappedIndex = me.indexMap[index];
                        if (mappedIndex !== -1) {
                            let item = me.owner.items[mappedIndex];

                            if (item !== me.dragPlaceholder && item !== me.dragComponent) {
                                item.wrapperStyle = {
                                    ...item.wrapperStyle,
                                    height: `${rect.height}px`,
                                    left  : `${rect.left}px`,
                                    top   : `${rect.top}px`,
                                    width : `${rect.width}px`
                                }
                            }
                        }
                    });

                    me.fire('dragBoundaryEntry', {
                        draggedItem: me.dragComponent,
                        proxyRect,
                        sortZone   : me
                    })
                } else {
                    me.onWindowDragContinue(intersectionRatio, data)
                }
                return true
            }
        }

        return false
    }

    /**
     * Helper method, override as needed
     * @returns {Object}
     */
    getDragProxyConfig() {
        return {...this.dragProxyConfig, cls: [...this.owner.cls]}
    }

    /**
     * Override this method for class extensions (e.g. tab.header.Toolbar)
     * @param {Number} fromIndex
     * @param {Number} toIndex
     */
    moveTo(fromIndex, toIndex) {
        this.owner.moveTo(fromIndex, toIndex);
    }

    /**
     * Handles the completion of the drag operation.
     *
     * This method is responsible for:
     * 1.  **Finalizing the Drop:** If valid, it moves the DOM nodes to their final positions (via `Neo.applyDeltas`).
     * 2.  **Cleanup:** Removes the drag placeholder and resets internal state flags (`isWindowDragging`, `currentIndex`, etc.).
     * 3.  **Layout Restoration:** Resets the styles of all items (clearing the absolute positioning used during the drag)
     *     so they return to the container's natural layout flow.
     * 4.  **State Synchronization:** Calls `owner.moveTo()` to update the container's `items` array to reflect the new order.
     *
     * @param {Object} data - The drag end event data.
     */
    async onDragEnd(data) {
        let me                  = this,
            {itemStyles, owner} = me,
            ownerStyle          = owner.style || {},
            itemStyle;

        await me.timeout(10);

        if (owner.dragResortable) {
            if (me.dragPlaceholder) {
                const
                    component = me.dragComponent,
                    deltas    = [],
                    index     = me.sortableItems.indexOf(me.dragPlaceholder);

                if (component && index > -1) {
                    if (!me.isWindowDragging) {
                        // Only move DOM if not window dragging or if it's a remote drag being finalized locally
                        if (!me.isRemoteDragging || (me.isRemoteDragging && !me.isWindowDragging)) {
                             deltas.push({
                                action  : 'moveNode',
                                id      : component.id,
                                index,    // Visually correct index (where placeholder is)
                                parentId: owner.getVdomItemsRoot().id
                            })
                        }
                    }

                    deltas.push({
                        action: 'removeNode',
                        id    : me.dragPlaceholder.id
                    });

                    // Manual DOM restoration
                    await Neo.applyDeltas(me.windowId, deltas)
                }
            }

            ownerStyle.height   = me.ownerStyle.height    || null;
            ownerStyle.minWidth = me.ownerStyle.minWidth  || null;
            ownerStyle.width    = me.ownerStyle.width     || null;

            owner.style = ownerStyle;

            me.sortableItems?.forEach((item, index) => {
                if (me.isWindowDragging && item === me.dragComponent) {
                    return
                }

                itemStyle = item.wrapperStyle || {};

                Object.assign(itemStyle, {
                    height  : itemStyles[index].height || null,
                    left    : null,
                    margin  : null,
                    position: null,
                    top     : null,
                    width   : itemStyles[index].width || null
                });

                if (index === me.startIndex) {
                    itemStyle.visibility = null
                }

                item.wrapperStyle = itemStyle
            });

            // Restore visibility of the dragged component (it's not in sortableItems if placeholder is used)
            if (me.dragComponent) {
                let style = me.dragComponent.wrapperStyle || {};
                style.visibility = null;
                me.dragComponent.wrapperStyle = style;
            }

            if (!me.isWindowDragging && !me.isRemoteDragging && me.startIndex !== me.currentIndex) {
                let fromIndex, toIndex;

                if (me.dragPlaceholder) {
                    const component = me.dragComponent;
                    fromIndex = me.owner.items.indexOf(component);
                    toIndex   = me.owner.items.indexOf(me.sortableItems[me.currentIndex]);
                } else {
                    fromIndex = me.owner.items.indexOf(me.sortableItems[me.startIndex]);
                    toIndex   = me.owner.items.indexOf(me.sortableItems[me.currentIndex]);
                }

                me.moveTo(fromIndex, toIndex);
            }

            Object.assign(me, {
                currentIndex    : -1,
                indexMap        : null,
                isRemoteDragging: false,
                isWindowDragging: false,
                itemRects       : null,
                itemStyles      : null,
                ownerRect       : null,
                startIndex      : -1,
                sortableItems   : null
            });

            await me.timeout(30);

            me.dragEnd(data) // we do not want to trigger the super class call here
        }
    }

    /**
     * Handles the drag move event. This is the core logic loop for the drag operation.
     *
     * Responsibilities:
     * 1.  **Window Drag Re-entry:** Checks if a window drag has re-entered the original container boundaries.
     *     If so, it restores the original layout snapshot (`itemRects`) and shows the placeholder, effectively
     *     "snapping" the dashboard back to its sortable state.
     * 2.  **Window Drag Exit:** Detects if the drag proxy has left the container boundaries (if `enableProxyToPopup` is true)
     *     and triggers the `dragBoundaryExit` event to potentially start a window drag.
     * 3.  **Standard Sorting:** If not in window-drag mode, it calculates the drag delta and swaps items (`switchItems`)
     *     if the threshold is crossed, updating the `currentIndex`.
     * 4.  **Auto-Scrolling:** Manages auto-scrolling when dragging near the edges of the container.
     *
     * @param {Object} data The drag move event data.
     */
    async onDragMove(data) {
        let me = this;

        // The method can trigger before we got the client rects from the main thread
        if (!me.itemRects || me.isScrolling) {
            return
        }

        // console.log('SortZone onDragMove', me.dragProxy);

        if (!me.isRemoteDragging && me.dragProxy && me.enableProxyToPopup) {
            if (me.checkWindowBoundary(data)) {
                return
            }
        }

        let {clientX, clientY} = data,
            index              = me.currentIndex,
            {itemRects}        = me,
            maxItems           = itemRects.length - 1,
            ownerX             = me.adjustItemRectsToParent ? me.ownerRect.x : 0,
            ownerY             = me.adjustItemRectsToParent ? me.ownerRect.y : 0,
            reversed           = me.reversedLayoutDirection,
            delta, isOverDragging, isOverDraggingEnd, isOverDraggingStart, itemHeightOrWidth, moveFactor;

        if (me.sortDirection === 'horizontal') {
            delta               = clientX - ownerX + me.scrollLeft - me.offsetX - itemRects[index].left;
            isOverDraggingEnd   = clientX > me.boundaryContainerRect.right;
            isOverDraggingStart = clientX < me.boundaryContainerRect.left;
            itemHeightOrWidth   = 'width'
        } else {
            delta               = clientY - ownerY + me.scrollTop - me.offsetY - itemRects[index].top;
            isOverDraggingEnd   = clientY > me.boundaryContainerRect.bottom;
            isOverDraggingStart = clientY < me.boundaryContainerRect.top;
            itemHeightOrWidth   = 'height'
        }

        isOverDragging = isOverDraggingEnd || isOverDraggingStart;
        moveFactor     = isOverDragging ? 0.02 : 0.55; // We can not use 0.5, since items would jump back & forth

        if (isOverDraggingStart) {
            if (index > 0) {
                me.currentIndex--;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (isOverDraggingEnd) {
            if (index < maxItems) {
                me.currentIndex++;
                await me.scrollToIndex();
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index > 0 && (!reversed && delta < 0 || reversed && delta > 0)) {
            if (Math.abs(delta) > itemRects[index - 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex--;
                me.switchItems(index, me.currentIndex)
            }
        }

        else if (index < maxItems && (!reversed && delta > 0 || reversed && delta < 0)) {
            if (Math.abs(delta) > itemRects[index + 1][itemHeightOrWidth] * moveFactor) {
                me.currentIndex++;
                me.switchItems(index, me.currentIndex)
            }
        }

        me.isOverDragging = isOverDragging && me.currentIndex !== 0 && me.currentIndex !== maxItems;

        if (me.isOverDragging) {
            await me.timeout(30); // wait for 1 frame

            if (me.isOverDragging) {
                await me.onDragMove(data)
            }
        }
    }

    /**
     * Initializes the drag operation.
     *
     * Key actions:
     * 1.  **Identify Drag Target:** Determines which item is being dragged (handling `dragHandleSelector` if present).
     * 2.  **Snapshot Layout:** Captures the current DOM rectangles (`itemRects`) of all sortable items. This snapshot
     *     is critical for:
     *     - Calculating drag deltas for sorting.
     *     - Restoring the layout after a window drag re-entry.
     *     - Inferring gaps and offsets for `calculateExpandedLayout`.
     * 3.  **Setup Proxy & Placeholder:** Configures the visual drag proxy and inserts the placeholder into the `sortableItems` list.
     * 4.  **Apply Absolute Positioning:** Temporarily switches all items to `position: absolute` based on their captured
     *     coordinates to enable smooth, GPU-accelerated movement during the drag.
     *
     * @param {Object} data - The drag start event data.
     */
    async onDragStart(data) {
        let me         = this,
            {adjustItemRectsToParent, dragHandleSelector, owner} = me,
            itemStyles = me.itemStyles = [],
            {layout}   = owner,
            ownerStyle = owner.style || {},
            draggedItem, index, indexMap, itemStyle, rect, sortableItems;

        if (owner.dragResortable) {
            if (dragHandleSelector) {
                const handleClassName = dragHandleSelector.substring(1);
                const handleNode      = data.path.find(node => node.cls.includes(handleClassName));

                if (!handleNode) {
                    return
                }

                const handleIndex = data.path.indexOf(handleNode);

                for (let i = handleIndex; i < data.path.length; i++) {
                    const potentialItemNode = data.path[i];
                    const component = Neo.getComponent(potentialItemNode.id);

                    if (component && owner.items.includes(component)) {
                        draggedItem = component;
                        break;
                    }
                }

                if (!draggedItem) {
                    return
                }

                sortableItems = owner.items.filter(item => _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(item.vdom, {
                    cls: dragHandleSelector.startsWith('.') ? dragHandleSelector.substring(1) : dragHandleSelector
                }));
                index         = sortableItems.indexOf(draggedItem);

                if (index < 0) {
                    return
                }
            } else {
                draggedItem   = Neo.getComponent(data.path[0].id);
                sortableItems = owner.items;
                index         = owner.indexOf(draggedItem.id)
            }

            indexMap = {};

            Object.assign(me, {
                currentIndex           : index,
                dragElement            : _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(owner.vdom, draggedItem.id).vdom,
                dragProxyConfig        : me.getDragProxyConfig(),
                indexMap,
                lastIntersectionRatio  : 1,
                ownerStyle             : {height: ownerStyle.height, minWidth: ownerStyle.minWidth, width: ownerStyle.width},
                reversedLayoutDirection: layout.direction === 'column-reverse' || layout.direction === 'row-reverse',
                sortableItems,
                sortDirection          : layout.direction?.includes('column') ? 'vertical' : 'horizontal',
                startIndex             : index
            });

            me.dragComponent = draggedItem;

            sortableItems.forEach((item, i) => {
                indexMap[i] = owner.items.indexOf(item);

                itemStyles.push({
                    height: item.height ? `${item.height}px` :  item.style?.height,
                    width : item.width  ? `${item.width}px`  :  item.style?.width
                })
            });

            const itemRects = await owner.getDomRect([owner.id].concat(sortableItems.map(e => e.id)));

            me.ownerRect = itemRects.shift();

            // Calculate real owner dimensions based on first and last item rects (accounting for padding)
            if (itemRects.length > 0) {
                const firstItemRect = itemRects[0];
                const lastItemRect  = itemRects[itemRects.length - 1];

                if (me.sortDirection === 'horizontal') {
                    if (firstItemRect.x > me.ownerRect.x) {
                        me.ownerRect.x = firstItemRect.x
                    }
                    if (firstItemRect.y > me.ownerRect.y) {
                        me.ownerRect.y = firstItemRect.y
                    }
                    me.ownerRect.width  = (lastItemRect.x + lastItemRect.width)  - me.ownerRect.x;
                    me.ownerRect.height = (lastItemRect.y + lastItemRect.height) - me.ownerRect.y
                } else {
                    if (firstItemRect.x > me.ownerRect.x) {
                        me.ownerRect.x = firstItemRect.x
                    }
                    if (firstItemRect.y > me.ownerRect.y) {
                        me.ownerRect.y = firstItemRect.y
                    }
                    me.ownerRect.width  = (lastItemRect.x + lastItemRect.width)  - me.ownerRect.x;
                    me.ownerRect.height = (lastItemRect.y + lastItemRect.height) - me.ownerRect.y
                }
            }

            owner.style = {
                ...ownerStyle,
                height  : `${me.ownerRect.height}px`,
                minWidth: `${me.ownerRect.width}px`,
                width   : `${me.ownerRect.width}px`
            };

            adjustItemRectsToParent && itemRects.forEach(rect => {
                rect.x -= me.ownerRect.x;
                rect.y -= me.ownerRect.y
            });

            me.itemRects = itemRects;

            await me.dragStart(data);

            if (me.dragPlaceholder) {
                const placeholderIndex = sortableItems.indexOf(draggedItem);
                if (placeholderIndex > -1) {
                    sortableItems[placeholderIndex] = me.dragPlaceholder
                }
                me.dragElement = me.dragPlaceholder.vdom
            }

            sortableItems.forEach((item, i) => {
                itemStyle = item.wrapperStyle || {};
                rect      = me.itemRects[i];

                me.adjustProxyRectToParent?.(rect, me.ownerRect);

                item.wrapperStyle = Object.assign(itemStyle, {
                    height  : `${rect.height}px`,
                    left    : `${rect.left}px`,
                    margin  : '0px',
                    position: 'absolute',
                    top     : `${rect.top}px`,
                    width   : `${rect.width}px`
                })
            });

            await me.timeout(5);

            if (!me.dragPlaceholder) {
                itemStyle = draggedItem.wrapperStyle || {};
                itemStyle.visibility = 'hidden';
                draggedItem.wrapperStyle = itemStyle
            }
        }
    }

    /**
     * @param {Number} intersectionRatio
     * @param {Object} data
     */
    onWindowDragContinue(intersectionRatio, data) {}

    /**
     * @returns {Promise<void>}
     */
    async scrollToIndex() {
        let me = this;

        me.isScrolling = true;
        await me.owner.scrollToIndex?.(me.currentIndex, me.itemRects[me.currentIndex]);
        me.isScrolling = false
    }

    /**
     * Swaps two items in the sort list, updating their layout coordinates and the internal index map.
     *
     * This method handles the physical reordering of items during a drag operation. It performs the following:
     * 1.  **Normalization:** Ensures indices are ordered correctly based on layout direction.
     * 2.  **Geometry Calculation:** Swaps the dimensions (width/height) of the two items and recalculates
     *     their positions (x/y), preserving the original gap between them. This ensures that items of different
     *     sizes swap correctly without breaking the layout structure.
     * 3.  **State Update:** Updates the `indexMap` to reflect the new logical order of items.
     * 4.  **Visual Update:** Calls `updateItem` to apply the new coordinates to the DOM.
     *
     * @param {Number} index1 - The index of the first item to swap.
     * @param {Number} index2 - The index of the second item to swap.
     */
    switchItems(index1, index2) {
        let me       = this,
            reversed = me.reversedLayoutDirection,
            tmp;

        if ((!reversed && index2 < index1) || (reversed && index1 < index2)) {
            tmp    = index1;
            index1 = index2;
            index2 = tmp
        }

        let itemRects = me.itemRects,
            map       = me.indexMap,
            rect1     = itemRects[index1],
            rect2     = itemRects[index2],
            rect1Copy = rect1.clone(),
            rect2Copy = rect2.clone();

        if (me.sortDirection === 'horizontal') {
            const gap = rect2Copy.x - (rect1Copy.x + rect1Copy.width);

            rect1.width = rect2Copy.width;
            rect2.x     = rect1Copy.x + rect2Copy.width + gap;
            rect2.width = rect1Copy.width
        } else {
            const gap = rect2Copy.y - (rect1Copy.y + rect1Copy.height);

            rect1.height = rect2Copy.height;
            rect2.height = rect1Copy.height;
            rect2.y      = rect1Copy.y + rect2Copy.height + gap
        }

        tmp         = map[index1];
        map[index1] = map[index2];
        map[index2] = tmp;

        me.updateItem(index1, rect1);
        me.updateItem(index2, rect2)
    }

    /**
     * @param {Number} index
     * @param {Object} rect
     */
    updateItem(index, rect) {
        let me          = this,
            mappedIndex = me.indexMap[index],
            item;

        if (mappedIndex === -1) {
            if (me.dragPlaceholder) {
                item = me.dragPlaceholder
            } else {
                return
            }
        } else {
            item = me.owner.items[mappedIndex];

            if (me.dragPlaceholder && item === me.dragComponent) {
                item = me.dragPlaceholder
            }
        }

        let {wrapperStyle} = item;

        wrapperStyle.left = `${rect.left}px`;
        wrapperStyle.top  = `${rect.top}px`;

        item.wrapperStyle = wrapperStyle
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(SortZone));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kcmFnZ2FibGVfY29udGFpbmVyX1NvcnRab25lX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ1I7QUFDRDs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0RBQVk7QUFDbkM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLHVCQUF1Qjs7QUFFdkI7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLHNDQUFzQztBQUNuRCxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLHVEQUFRO0FBQ3BCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQSxZQUFZLHVEQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRCx1Q0FBdUMsU0FBUzs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsc0RBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBLGFB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QUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsY0FBYzs7QUFFM0IsK0JBQStCLFVBQVU7QUFDekMsK0JBQStCLFNBQVM7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx3QkFBd0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZHJhZ2dhYmxlL2NvbnRhaW5lci9EcmFnWm9uZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kcmFnZ2FibGUvY29udGFpbmVyL1NvcnRab25lLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZURyYWdab25lIGZyb20gJy4uLy4uL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5EcmFnWm9uZVxuICogQGV4dGVuZHMgTmVvLmRyYWdnYWJsZS5EcmFnWm9uZVxuICovXG5jbGFzcyBEcmFnWm9uZSBleHRlbmRzIEJhc2VEcmFnWm9uZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZHJhZ2dhYmxlLmNvbnRhaW5lci5EcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5jb250YWluZXIuRHJhZ1pvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29udGFpbmVyLWRyYWd6b25lJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbnRhaW5lci1kcmFnem9uZSdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBvcHRzICAgID0ge2RlbGVnYXRlOiAnLm5lby1kcmFnZ2FibGUnLCBzY29wZTogbWV9O1xuXG4gICAgICAgIG93bmVyLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkRyYWdFbmQsICAgLi4ub3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6bW92ZScgOiBtZS5vbkRyYWdNb3ZlLCAgLi4ub3B0c30sXG4gICAgICAgICAgICB7J2RyYWc6c3RhcnQnOiBtZS5vbkRyYWdTdGFydCwgLi4ub3B0c31cbiAgICAgICAgXSk7XG5cbiAgICAgICAgb3duZXIub24oe1xuICAgICAgICAgICAgaW5zZXJ0ICAgICAgOiBtZS5vbkl0ZW1JbnNlcnQsXG4gICAgICAgICAgICBpdGVtc0NyZWF0ZWQ6IG1lLm9uSXRlbXNDcmVhdGVkLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGUgY29udGFpbmVyIGl0ZW1zIGNhbiBhbHJlYWR5IGJlIGNyZWF0ZWRcbiAgICAgICAgbWUuYWRqdXN0SXRlbUNscyh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRyYWdnYWJsZVxuICAgICAqL1xuICAgIGFkanVzdEl0ZW1DbHMoZHJhZ2dhYmxlKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIHdyYXBwZXJDbHM7XG5cbiAgICAgICAgb3duZXIuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIHNwYWNlcnNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyYXBwZXJDbHMgPSBpdGVtLndyYXBwZXJDbHMgfHwgW107XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZSh3cmFwcGVyQ2xzLCAnbmVvLWRyYWdnYWJsZScsIGRyYWdnYWJsZSk7XG4gICAgICAgICAgICBpdGVtLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLm93bmVyLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJveHkgICAgICAgID0gbWUuZHJhZ1Byb3h5LFxuICAgICAgICAgICAgICAgIGNscyAgICAgICAgICA9IHByb3h5LmNscyB8fCB7fSxcbiAgICAgICAgICAgICAgICByZWN0ICAgICAgICAgPSBtZS5kcmFnRWxlbWVudFJlY3QsXG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlID0gcHJveHkud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCAnbmVvLWFuaW1hdGUnKTtcbiAgICAgICAgICAgIHByb3h5LmNscyA9IGNscztcblxuICAgICAgICAgICAgLy8gZW5zdXJlIHRvIGdldCBpbnRvIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgICAgbWUudGltZW91dCgzMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBgJHtyZWN0LmxlZnR9cHhgO1xuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZS50b3AgID0gYCR7cmVjdC50b3B9cHhgO1xuXG4gICAgICAgICAgICAgICAgcHJveHkud3JhcHBlclN0eWxlID0gd3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICAgICAgbWUudGltZW91dCgxMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5kcmFnRW5kKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5vd25lci5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIG1lLmRyYWdFbGVtZW50ID0gVkRvbVV0aWwuZmluZChtZS5vd25lci52ZG9tLCBkYXRhLnBhdGhbMF0uaWQpLnZkb207XG4gICAgICAgICAgICBhd2FpdCBtZS5kcmFnU3RhcnQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICBkYXRhLmluZGV4XG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGRhdGEuaXRlbVxuICAgICAqL1xuICAgIG9uSXRlbUluc2VydChkYXRhKSB7XG4gICAgICAgIGxldCB7aXRlbX0gICAgID0gZGF0YSxcbiAgICAgICAgICAgIHdyYXBwZXJDbHMgPSBpdGVtLndyYXBwZXJDbHMgfHwgW107XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKHdyYXBwZXJDbHMsICduZW8tZHJhZ2dhYmxlJyk7XG4gICAgICAgIGl0ZW0ud3JhcHBlckNscyA9IHdyYXBwZXJDbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZVtdfSBkYXRhLml0ZW1zXG4gICAgICovXG4gICAgb25JdGVtc0NyZWF0ZWQoZGF0YSkge1xuICAgICAgICB0aGlzLmFkanVzdEl0ZW1DbHModHJ1ZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEcmFnWm9uZSk7XG4iLCJpbXBvcnQgRHJhZ1pvbmUgIGZyb20gJy4vRHJhZ1pvbmUubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuLi8uLi91dGlsL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBNYW5hZ2VzIHRoZSBkcmFnLWFuZC1kcm9wIHJlb3JkZXJpbmcgb2YgaXRlbXMgd2l0aGluIGEgY29udGFpbmVyLCB3aXRoIHN1cHBvcnQgZm9yIHdpbmRvdyBkZXRhY2htZW50LlxuICpcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyBgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuRHJhZ1pvbmVgIHRvIHByb3ZpZGUgc29ydGluZyBjYXBhYmlsaXRpZXMgZm9yIGBOZW8uY29udGFpbmVyLkJhc2VgIGluc3RhbmNlcy5cbiAqIEl0IGhhbmRsZXMgdGhlIGNvbXBsZXggbG9naWMgb2YgdHJhY2tpbmcgaXRlbSBwb3NpdGlvbnMsIHN3YXBwaW5nIHRoZW0gZHVyaW5nIHRoZSBkcmFnIG9wZXJhdGlvbiwgYW5kIHVwZGF0aW5nXG4gKiB0aGUgY29udGFpbmVyJ3MgbGF5b3V0IHVwb24gZHJvcC5cbiAqXG4gKiBBIGtleSBmZWF0dXJlIG9mIHRoaXMgY2xhc3MgaXMgaXRzIHN1cHBvcnQgZm9yICoqV2luZG93IERldGFjaG1lbnQqKiAodGVhcmluZyB0YWJzIG9yIGl0ZW1zIG91dCBvZiB0aGUgbWFpbiB3aW5kb3cpLlxuICogV2hlbiBhbiBpdGVtIGlzIGRyYWdnZWQgb3V0c2lkZSB0aGUgYnJvd3NlciB3aW5kb3cgYm91bmRhcmllczpcbiAqIDEuIFRoZSBgc3RhcnRXaW5kb3dEcmFnYCBtZXRob2QgaXMgdHJpZ2dlcmVkLlxuICogMi4gVGhlIGRyYWcgcGxhY2Vob2xkZXIgaXMgaGlkZGVuLlxuICogMy4gVGhlIGBjYWxjdWxhdGVFeHBhbmRlZExheW91dGAgbWV0aG9kIGR5bmFtaWNhbGx5IGNvbXB1dGVzIGEgbmV3IGxheW91dCBmb3IgdGhlIHJlbWFpbmluZyBpdGVtcywgZXhwYW5kaW5nIHRoZW1cbiAqICAgIHRvIGZpbGwgdGhlIGVtcHR5IHNwYWNlIChhbmltYXRpbmcgYHdpZHRoYCwgYGhlaWdodGAsIGB0b3BgLCBhbmQgYGxlZnRgKS5cbiAqIDQuIElmIHRoZSBkcmFnIHJlLWVudGVycyB0aGUgd2luZG93IChgb25EcmFnQm91bmRhcnlFbnRyeWApLCB0aGUgb3JpZ2luYWwgbGF5b3V0IHNuYXBzaG90IGlzIHJlc3RvcmVkLCBhbmQgdGhlXG4gKiAgICBwbGFjZWhvbGRlciByZWFwcGVhcnMsIGFsbG93aW5nIGZvciBhIHNlYW1sZXNzIHJldHVybiB0byBzb3J0aW5nIG1vZGUuXG4gKlxuICogVGhpcyBjbGFzcyBpbnRlcmFjdHMgY2xvc2VseSB3aXRoOlxuICogLSBgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlgOiBGb3IgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZHJhZ2dlZCBpdGVtLlxuICogLSBgTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3BgOiBGb3IgY29tbXVuaWNhdGluZyBkcmFnIHN0YXRlIGFjcm9zcyB0aGUgYnJvd3Nlci9PUyBlbnZpcm9ubWVudC5cbiAqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmVcbiAqIEBleHRlbmRzIE5lby5kcmFnZ2FibGUuY29udGFpbmVyLkRyYWdab25lXG4gKiBAc2VlIE5lby5kcmFnZ2FibGUuY29udGFpbmVyLkRyYWdab25lXG4gKiBAc2VlIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wXG4gKi9cbmNsYXNzIFNvcnRab25lIGV4dGVuZHMgRHJhZ1pvbmUge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5jb250YWluZXIuU29ydFpvbmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuY29udGFpbmVyLlNvcnRab25lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbnRhaW5lci1zb3J0em9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb250YWluZXItc29ydHpvbmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVwZW5kaW5nIG9uIHRoZSBwYXJlbnQgc3RydWN0dXJlIHVzaW5nIHBvc2l0aW9uIGFic29sdXRlIGFuZCByZWxhdGl2ZSwgaXQgY2FuIGJlIG5lZWRlZCB0byBzdWJ0cmFjdFxuICAgICAgICAgKiB0aGUgeCAmIHkgcGFyZW50IHJlY3QgdmFsdWVzIGZyb20gdGhlIGl0ZW0gcmVjdHMuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFkanVzdEl0ZW1SZWN0c1RvUGFyZW50PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGp1c3RJdGVtUmVjdHNUb1BhcmVudDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbHdheXNGaXJlRHJhZ01vdmU9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBjdXJyZW50SW5kZXg9LTFcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudEluZGV4OiAtMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gcmF0aW8gKDAtMSkgcmVxdWlyZWQgdG8gZGV0YWNoIGFuIGl0ZW0gaW50byBhIG5ldyB3aW5kb3cuXG4gICAgICAgICAqIExvd2VyIHZhbHVlcyBtZWFuIHRoZSBpdGVtIG11c3QgYmUgZHJhZ2dlZCBmdXJ0aGVyIG91dC5cbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBkZXRhY2hUaHJlc2hvbGQ9MC44XG4gICAgICAgICAqL1xuICAgICAgICBkZXRhY2hUaHJlc2hvbGQ6IDAuOCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgQ1NTIHNlbGVjdG9yIHRvIGlkZW50aWZ5IHRoZSBkcmFnIGhhbmRsZSB3aXRoaW4gYSBjb21wb25lbnQuXG4gICAgICAgICAqIElmIHNwZWNpZmllZCwgdGhlIGRyYWcgaXMgaW5pdGlhdGVkIG9uIHRoaXMgZWxlbWVudCwgYnV0IHRoZSBvd25pbmcgY29tcG9uZW50IGlzIGRyYWdnZWQuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBkcmFnSGFuZGxlU2VsZWN0b3I9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0hhbmRsZVNlbGVjdG9yOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZW5hYmxlUHJveHlUb1BvcHVwPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGVQcm94eVRvUG9wdXA6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpbmRleE1hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGluZGV4TWFwOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaXRlbVJlY3RzPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVJlY3RzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaXRlbVN0eWxlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1TdHlsZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGxhc3RJbnRlcnNlY3Rpb25SYXRpbz0xXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGxhc3RJbnRlcnNlY3Rpb25SYXRpbzogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gb3duZXJSZWN0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXJSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBvd25lclN0eWxlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXJTdHlsZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gcmF0aW8gKDAtMSkgcmVxdWlyZWQgdG8gcmUtYXR0YWNoIGEgd2luZG93LWRyYWdnZWQgaXRlbSBiYWNrIGludG8gdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICogSGlnaGVyIHZhbHVlcyBtZWFuIHRoZSBpdGVtIG11c3QgYmUgZHJhZ2dlZCBmdXJ0aGVyIGluLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHJlYXR0YWNoVGhyZXNob2xkPTAuNlxuICAgICAgICAgKi9cbiAgICAgICAgcmVhdHRhY2hUaHJlc2hvbGQ6IDAuNixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGFsd2F5c0ZpcmVEcmFnTW92ZT1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZXZlcnNlZExheW91dERpcmVjdGlvbjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbExlZnQ9MFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsVG9wPTBcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbFRvcDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWc6IG9uRHJhZ1N0YXJ0KCkgd2lsbCBzZXQgdGhlIHZhbHVlIHRvIGhvcml6b250YWwgb3IgdmVydGljYWwsIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBsYXlvdXQuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gc29ydERpcmVjdGlvbj0naG9yaXpvbnRhbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydERpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBzdGFydEluZGV4PS0xXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0SW5kZXg6IC0xXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNPdmVyRHJhZ2dpbmc9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNPdmVyRHJhZ2dpbmcgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzV2luZG93RHJhZ2dpbmc9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNXaW5kb3dEcmFnZ2luZyA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBuZW8tZHJhZ2dhYmxlIGNscyBvbiBpdGVtcyBpbnNpZGUgb3VyIG93bmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJhZ2dhYmxlXG4gICAgICovXG4gICAgYWRqdXN0SXRlbUNscyhkcmFnZ2FibGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuZHJhZ0hhbmRsZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDbHMgICAgID0gbWUuZHJhZ0hhbmRsZVNlbGVjdG9yLnN0YXJ0c1dpdGgoJy4nKSA/IG1lLmRyYWdIYW5kbGVTZWxlY3Rvci5zdWJzdHJpbmcoMSkgOiBtZS5kcmFnSGFuZGxlU2VsZWN0b3I7XG4gICAgICAgICAgICBjb25zdCBzb3J0YWJsZUl0ZW1zID0gbWUub3duZXIuaXRlbXMuZmlsdGVyKGl0ZW0gPT5cbiAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ3N0cmluZycgJiYgVkRvbVV0aWwuZmluZChpdGVtLnZkb20sIHtjbHM6IGhhbmRsZUNsc30pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzb3J0YWJsZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlckNscyA9IGl0ZW0ud3JhcHBlckNscyB8fCBbXTtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS50b2dnbGUod3JhcHBlckNscywgJ25lby1kcmFnZ2FibGUnLCBkcmFnZ2FibGUpO1xuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlckNscyA9IHdyYXBwZXJDbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuYWRqdXN0SXRlbUNscyhkcmFnZ2FibGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2QgcHJvY2Vzc2luZyBzaG91bGQgc3RvcFxuICAgICAqL1xuICAgIGNoZWNrV2luZG93Qm91bmRhcnkoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge3Byb3h5UmVjdH0gPSBkYXRhO1xuXG4gICAgICAgIGlmIChwcm94eVJlY3QgJiYgbWUuYm91bmRhcnlDb250YWluZXJSZWN0KSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5UmVjdCAgICAgID0gbWUuYm91bmRhcnlDb250YWluZXJSZWN0LFxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbiAgICAgID0gUmVjdGFuZ2xlLmdldEludGVyc2VjdGlvbihwcm94eVJlY3QsIGJvdW5kYXJ5UmVjdCksXG4gICAgICAgICAgICAgICAgcHJveHlBcmVhICAgICAgICAgPSBwcm94eVJlY3Qud2lkdGggKiBwcm94eVJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbkFyZWEgID0gaW50ZXJzZWN0aW9uID8gaW50ZXJzZWN0aW9uLndpZHRoICogaW50ZXJzZWN0aW9uLmhlaWdodCA6IDAsXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUmF0aW8gPSBwcm94eUFyZWEgPiAwID8gaW50ZXJzZWN0aW9uQXJlYSAvIHByb3h5QXJlYSA6IDAsXG4gICAgICAgICAgICAgICAgaXNNb3ZpbmdJbiAgICAgICAgPSBpbnRlcnNlY3Rpb25SYXRpbyA+IG1lLmxhc3RJbnRlcnNlY3Rpb25SYXRpbyxcbiAgICAgICAgICAgICAgICBpc01vdmluZ091dCAgICAgICA9IGludGVyc2VjdGlvblJhdGlvIDwgbWUubGFzdEludGVyc2VjdGlvblJhdGlvO1xuXG4gICAgICAgICAgICBtZS5sYXN0SW50ZXJzZWN0aW9uUmF0aW8gPSBpbnRlcnNlY3Rpb25SYXRpbztcblxuICAgICAgICAgICAgaWYgKCFtZS5pc1dpbmRvd0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTW92aW5nT3V0ICYmIGludGVyc2VjdGlvblJhdGlvIDwgbWUuZGV0YWNoVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzV2luZG93RHJhZ2dpbmcgPSB0cnVlOyAvLyBTZXQgZmxhZyB0byBwcmV2ZW50IHJlLWVudHJ5XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuZmlyZSgnZHJhZ0JvdW5kYXJ5RXhpdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtOiBtZS5kcmFnQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydFpvbmUgICA6IG1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZSAvLyBTdG9wIGZ1cnRoZXIgcHJvY2Vzc2luZyBpbiBvbkRyYWdNb3ZlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5pc1dpbmRvd0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTW92aW5nSW4gJiYgaW50ZXJzZWN0aW9uUmF0aW8gPiBtZS5yZWF0dGFjaFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGxheW91dFxuICAgICAgICAgICAgICAgICAgICBtZS5kcmFnUGxhY2Vob2xkZXIud3JhcHBlclN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWUuZHJhZ1BsYWNlaG9sZGVyLndyYXBwZXJTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLWFwcGx5aW5nIHRoZSBjdXJyZW50IHN0YXRlOlxuICAgICAgICAgICAgICAgICAgICBtZS5pdGVtUmVjdHMuZm9yRWFjaCgocmVjdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXBwZWRJbmRleCA9IG1lLmluZGV4TWFwW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwZWRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IG1lLm93bmVyLml0ZW1zW21hcHBlZEluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSBtZS5kcmFnUGxhY2Vob2xkZXIgJiYgaXRlbSAhPT0gbWUuZHJhZ0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLml0ZW0ud3JhcHBlclN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtyZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgICA6IGAke3JlY3QudG9wfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7cmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuZmlyZSgnZHJhZ0JvdW5kYXJ5RW50cnknLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbTogbWUuZHJhZ0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRab25lICAgOiBtZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm9uV2luZG93RHJhZ0NvbnRpbnVlKGludGVyc2VjdGlvblJhdGlvLCBkYXRhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCwgb3ZlcnJpZGUgYXMgbmVlZGVkXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREcmFnUHJveHlDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB7Li4udGhpcy5kcmFnUHJveHlDb25maWcsIGNsczogWy4uLnRoaXMub3duZXIuY2xzXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY2xhc3MgZXh0ZW5zaW9ucyAoZS5nLiB0YWIuaGVhZGVyLlRvb2xiYXIpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4XG4gICAgICovXG4gICAgbW92ZVRvKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICB0aGlzLm93bmVyLm1vdmVUbyhmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGNvbXBsZXRpb24gb2YgdGhlIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yOlxuICAgICAqIDEuICAqKkZpbmFsaXppbmcgdGhlIERyb3A6KiogSWYgdmFsaWQsIGl0IG1vdmVzIHRoZSBET00gbm9kZXMgdG8gdGhlaXIgZmluYWwgcG9zaXRpb25zICh2aWEgYE5lby5hcHBseURlbHRhc2ApLlxuICAgICAqIDIuICAqKkNsZWFudXA6KiogUmVtb3ZlcyB0aGUgZHJhZyBwbGFjZWhvbGRlciBhbmQgcmVzZXRzIGludGVybmFsIHN0YXRlIGZsYWdzIChgaXNXaW5kb3dEcmFnZ2luZ2AsIGBjdXJyZW50SW5kZXhgLCBldGMuKS5cbiAgICAgKiAzLiAgKipMYXlvdXQgUmVzdG9yYXRpb246KiogUmVzZXRzIHRoZSBzdHlsZXMgb2YgYWxsIGl0ZW1zIChjbGVhcmluZyB0aGUgYWJzb2x1dGUgcG9zaXRpb25pbmcgdXNlZCBkdXJpbmcgdGhlIGRyYWcpXG4gICAgICogICAgIHNvIHRoZXkgcmV0dXJuIHRvIHRoZSBjb250YWluZXIncyBuYXR1cmFsIGxheW91dCBmbG93LlxuICAgICAqIDQuICAqKlN0YXRlIFN5bmNocm9uaXphdGlvbjoqKiBDYWxscyBgb3duZXIubW92ZVRvKClgIHRvIHVwZGF0ZSB0aGUgY29udGFpbmVyJ3MgYGl0ZW1zYCBhcnJheSB0byByZWZsZWN0IHRoZSBuZXcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkcmFnIGVuZCBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ0VuZChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpdGVtU3R5bGVzLCBvd25lcn0gPSBtZSxcbiAgICAgICAgICAgIG93bmVyU3R5bGUgICAgICAgICAgPSBvd25lci5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGl0ZW1TdHlsZTtcblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDEwKTtcblxuICAgICAgICBpZiAob3duZXIuZHJhZ1Jlc29ydGFibGUpIHtcbiAgICAgICAgICAgIGlmIChtZS5kcmFnUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBtZS5kcmFnQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBkZWx0YXMgICAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggICAgID0gbWUuc29ydGFibGVJdGVtcy5pbmRleE9mKG1lLmRyYWdQbGFjZWhvbGRlcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZS5pc1dpbmRvd0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG1vdmUgRE9NIGlmIG5vdCB3aW5kb3cgZHJhZ2dpbmcgb3IgaWYgaXQncyBhIHJlbW90ZSBkcmFnIGJlaW5nIGZpbmFsaXplZCBsb2NhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLmlzUmVtb3RlRHJhZ2dpbmcgfHwgKG1lLmlzUmVtb3RlRHJhZ2dpbmcgJiYgIW1lLmlzV2luZG93RHJhZ2dpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uICA6ICdtb3ZlTm9kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgICAgOiBjb21wb25lbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCAgICAvLyBWaXN1YWxseSBjb3JyZWN0IGluZGV4ICh3aGVyZSBwbGFjZWhvbGRlciBpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG93bmVyLmdldFZkb21JdGVtc1Jvb3QoKS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWx0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdyZW1vdmVOb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkICAgIDogbWUuZHJhZ1BsYWNlaG9sZGVyLmlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbCBET00gcmVzdG9yYXRpb25cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCBkZWx0YXMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvd25lclN0eWxlLmhlaWdodCAgID0gbWUub3duZXJTdHlsZS5oZWlnaHQgICAgfHwgbnVsbDtcbiAgICAgICAgICAgIG93bmVyU3R5bGUubWluV2lkdGggPSBtZS5vd25lclN0eWxlLm1pbldpZHRoICB8fCBudWxsO1xuICAgICAgICAgICAgb3duZXJTdHlsZS53aWR0aCAgICA9IG1lLm93bmVyU3R5bGUud2lkdGggICAgIHx8IG51bGw7XG5cbiAgICAgICAgICAgIG93bmVyLnN0eWxlID0gb3duZXJTdHlsZTtcblxuICAgICAgICAgICAgbWUuc29ydGFibGVJdGVtcz8uZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWUuaXNXaW5kb3dEcmFnZ2luZyAmJiBpdGVtID09PSBtZS5kcmFnQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdGVtU3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGl0ZW1TdHlsZXNbaW5kZXhdLmhlaWdodCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0b3AgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggICA6IGl0ZW1TdHlsZXNbaW5kZXhdLndpZHRoIHx8IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbWUuc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3R5bGUudmlzaWJpbGl0eSA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IGl0ZW1TdHlsZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdmlzaWJpbGl0eSBvZiB0aGUgZHJhZ2dlZCBjb21wb25lbnQgKGl0J3Mgbm90IGluIHNvcnRhYmxlSXRlbXMgaWYgcGxhY2Vob2xkZXIgaXMgdXNlZClcbiAgICAgICAgICAgIGlmIChtZS5kcmFnQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gbWUuZHJhZ0NvbXBvbmVudC53cmFwcGVyU3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgc3R5bGUudmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ0NvbXBvbmVudC53cmFwcGVyU3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtZS5pc1dpbmRvd0RyYWdnaW5nICYmICFtZS5pc1JlbW90ZURyYWdnaW5nICYmIG1lLnN0YXJ0SW5kZXggIT09IG1lLmN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tSW5kZXgsIHRvSW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAobWUuZHJhZ1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG1lLmRyYWdDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGZyb21JbmRleCA9IG1lLm93bmVyLml0ZW1zLmluZGV4T2YoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdG9JbmRleCAgID0gbWUub3duZXIuaXRlbXMuaW5kZXhPZihtZS5zb3J0YWJsZUl0ZW1zW21lLmN1cnJlbnRJbmRleF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21JbmRleCA9IG1lLm93bmVyLml0ZW1zLmluZGV4T2YobWUuc29ydGFibGVJdGVtc1ttZS5zdGFydEluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIHRvSW5kZXggICA9IG1lLm93bmVyLml0ZW1zLmluZGV4T2YobWUuc29ydGFibGVJdGVtc1ttZS5jdXJyZW50SW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5tb3ZlVG8oZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZSwge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCAgICA6IC0xLFxuICAgICAgICAgICAgICAgIGluZGV4TWFwICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNSZW1vdGVEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNXaW5kb3dEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXRlbVJlY3RzICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGVzICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIG93bmVyUmVjdCAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCAgICAgIDogLTEsXG4gICAgICAgICAgICAgICAgc29ydGFibGVJdGVtcyAgIDogbnVsbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApO1xuXG4gICAgICAgICAgICBtZS5kcmFnRW5kKGRhdGEpIC8vIHdlIGRvIG5vdCB3YW50IHRvIHRyaWdnZXIgdGhlIHN1cGVyIGNsYXNzIGNhbGwgaGVyZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgZHJhZyBtb3ZlIGV2ZW50LiBUaGlzIGlzIHRoZSBjb3JlIGxvZ2ljIGxvb3AgZm9yIHRoZSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFJlc3BvbnNpYmlsaXRpZXM6XG4gICAgICogMS4gICoqV2luZG93IERyYWcgUmUtZW50cnk6KiogQ2hlY2tzIGlmIGEgd2luZG93IGRyYWcgaGFzIHJlLWVudGVyZWQgdGhlIG9yaWdpbmFsIGNvbnRhaW5lciBib3VuZGFyaWVzLlxuICAgICAqICAgICBJZiBzbywgaXQgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIGxheW91dCBzbmFwc2hvdCAoYGl0ZW1SZWN0c2ApIGFuZCBzaG93cyB0aGUgcGxhY2Vob2xkZXIsIGVmZmVjdGl2ZWx5XG4gICAgICogICAgIFwic25hcHBpbmdcIiB0aGUgZGFzaGJvYXJkIGJhY2sgdG8gaXRzIHNvcnRhYmxlIHN0YXRlLlxuICAgICAqIDIuICAqKldpbmRvdyBEcmFnIEV4aXQ6KiogRGV0ZWN0cyBpZiB0aGUgZHJhZyBwcm94eSBoYXMgbGVmdCB0aGUgY29udGFpbmVyIGJvdW5kYXJpZXMgKGlmIGBlbmFibGVQcm94eVRvUG9wdXBgIGlzIHRydWUpXG4gICAgICogICAgIGFuZCB0cmlnZ2VycyB0aGUgYGRyYWdCb3VuZGFyeUV4aXRgIGV2ZW50IHRvIHBvdGVudGlhbGx5IHN0YXJ0IGEgd2luZG93IGRyYWcuXG4gICAgICogMy4gICoqU3RhbmRhcmQgU29ydGluZzoqKiBJZiBub3QgaW4gd2luZG93LWRyYWcgbW9kZSwgaXQgY2FsY3VsYXRlcyB0aGUgZHJhZyBkZWx0YSBhbmQgc3dhcHMgaXRlbXMgKGBzd2l0Y2hJdGVtc2ApXG4gICAgICogICAgIGlmIHRoZSB0aHJlc2hvbGQgaXMgY3Jvc3NlZCwgdXBkYXRpbmcgdGhlIGBjdXJyZW50SW5kZXhgLlxuICAgICAqIDQuICAqKkF1dG8tU2Nyb2xsaW5nOioqIE1hbmFnZXMgYXV0by1zY3JvbGxpbmcgd2hlbiBkcmFnZ2luZyBuZWFyIHRoZSBlZGdlcyBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRyYWcgbW92ZSBldmVudCBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIG9uRHJhZ01vdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRoZSBtZXRob2QgY2FuIHRyaWdnZXIgYmVmb3JlIHdlIGdvdCB0aGUgY2xpZW50IHJlY3RzIGZyb20gdGhlIG1haW4gdGhyZWFkXG4gICAgICAgIGlmICghbWUuaXRlbVJlY3RzIHx8IG1lLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTb3J0Wm9uZSBvbkRyYWdNb3ZlJywgbWUuZHJhZ1Byb3h5KTtcblxuICAgICAgICBpZiAoIW1lLmlzUmVtb3RlRHJhZ2dpbmcgJiYgbWUuZHJhZ1Byb3h5ICYmIG1lLmVuYWJsZVByb3h5VG9Qb3B1cCkge1xuICAgICAgICAgICAgaWYgKG1lLmNoZWNrV2luZG93Qm91bmRhcnkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7Y2xpZW50WCwgY2xpZW50WX0gPSBkYXRhLFxuICAgICAgICAgICAgaW5kZXggICAgICAgICAgICAgID0gbWUuY3VycmVudEluZGV4LFxuICAgICAgICAgICAge2l0ZW1SZWN0c30gICAgICAgID0gbWUsXG4gICAgICAgICAgICBtYXhJdGVtcyAgICAgICAgICAgPSBpdGVtUmVjdHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG93bmVyWCAgICAgICAgICAgICA9IG1lLmFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ID8gbWUub3duZXJSZWN0LnggOiAwLFxuICAgICAgICAgICAgb3duZXJZICAgICAgICAgICAgID0gbWUuYWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQgPyBtZS5vd25lclJlY3QueSA6IDAsXG4gICAgICAgICAgICByZXZlcnNlZCAgICAgICAgICAgPSBtZS5yZXZlcnNlZExheW91dERpcmVjdGlvbixcbiAgICAgICAgICAgIGRlbHRhLCBpc092ZXJEcmFnZ2luZywgaXNPdmVyRHJhZ2dpbmdFbmQsIGlzT3ZlckRyYWdnaW5nU3RhcnQsIGl0ZW1IZWlnaHRPcldpZHRoLCBtb3ZlRmFjdG9yO1xuXG4gICAgICAgIGlmIChtZS5zb3J0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGRlbHRhICAgICAgICAgICAgICAgPSBjbGllbnRYIC0gb3duZXJYICsgbWUuc2Nyb2xsTGVmdCAtIG1lLm9mZnNldFggLSBpdGVtUmVjdHNbaW5kZXhdLmxlZnQ7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gY2xpZW50WCA+IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5yaWdodDtcbiAgICAgICAgICAgIGlzT3ZlckRyYWdnaW5nU3RhcnQgPSBjbGllbnRYIDwgbWUuYm91bmRhcnlDb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0T3JXaWR0aCAgID0gJ3dpZHRoJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGEgICAgICAgICAgICAgICA9IGNsaWVudFkgLSBvd25lclkgKyBtZS5zY3JvbGxUb3AgLSBtZS5vZmZzZXRZIC0gaXRlbVJlY3RzW2luZGV4XS50b3A7XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ0VuZCAgID0gY2xpZW50WSA+IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC5ib3R0b207XG4gICAgICAgICAgICBpc092ZXJEcmFnZ2luZ1N0YXJ0ID0gY2xpZW50WSA8IG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgICBpdGVtSGVpZ2h0T3JXaWR0aCAgID0gJ2hlaWdodCdcbiAgICAgICAgfVxuXG4gICAgICAgIGlzT3ZlckRyYWdnaW5nID0gaXNPdmVyRHJhZ2dpbmdFbmQgfHwgaXNPdmVyRHJhZ2dpbmdTdGFydDtcbiAgICAgICAgbW92ZUZhY3RvciAgICAgPSBpc092ZXJEcmFnZ2luZyA/IDAuMDIgOiAwLjU1OyAvLyBXZSBjYW4gbm90IHVzZSAwLjUsIHNpbmNlIGl0ZW1zIHdvdWxkIGp1bXAgYmFjayAmIGZvcnRoXG5cbiAgICAgICAgaWYgKGlzT3ZlckRyYWdnaW5nU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgtLTtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS5zY3JvbGxUb0luZGV4KCk7XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGlzT3ZlckRyYWdnaW5nRW5kKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBtYXhJdGVtcykge1xuICAgICAgICAgICAgICAgIG1lLmN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnNjcm9sbFRvSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPiAwICYmICghcmV2ZXJzZWQgJiYgZGVsdGEgPCAwIHx8IHJldmVyc2VkICYmIGRlbHRhID4gMCkpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBpdGVtUmVjdHNbaW5kZXggLSAxXVtpdGVtSGVpZ2h0T3JXaWR0aF0gKiBtb3ZlRmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgbWUuY3VycmVudEluZGV4LS07XG4gICAgICAgICAgICAgICAgbWUuc3dpdGNoSXRlbXMoaW5kZXgsIG1lLmN1cnJlbnRJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGluZGV4IDwgbWF4SXRlbXMgJiYgKCFyZXZlcnNlZCAmJiBkZWx0YSA+IDAgfHwgcmV2ZXJzZWQgJiYgZGVsdGEgPCAwKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+IGl0ZW1SZWN0c1tpbmRleCArIDFdW2l0ZW1IZWlnaHRPcldpZHRoXSAqIG1vdmVGYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICBtZS5zd2l0Y2hJdGVtcyhpbmRleCwgbWUuY3VycmVudEluZGV4KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNPdmVyRHJhZ2dpbmcgPSBpc092ZXJEcmFnZ2luZyAmJiBtZS5jdXJyZW50SW5kZXggIT09IDAgJiYgbWUuY3VycmVudEluZGV4ICE9PSBtYXhJdGVtcztcblxuICAgICAgICBpZiAobWUuaXNPdmVyRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApOyAvLyB3YWl0IGZvciAxIGZyYW1lXG5cbiAgICAgICAgICAgIGlmIChtZS5pc092ZXJEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm9uRHJhZ01vdmUoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEtleSBhY3Rpb25zOlxuICAgICAqIDEuICAqKklkZW50aWZ5IERyYWcgVGFyZ2V0OioqIERldGVybWluZXMgd2hpY2ggaXRlbSBpcyBiZWluZyBkcmFnZ2VkIChoYW5kbGluZyBgZHJhZ0hhbmRsZVNlbGVjdG9yYCBpZiBwcmVzZW50KS5cbiAgICAgKiAyLiAgKipTbmFwc2hvdCBMYXlvdXQ6KiogQ2FwdHVyZXMgdGhlIGN1cnJlbnQgRE9NIHJlY3RhbmdsZXMgKGBpdGVtUmVjdHNgKSBvZiBhbGwgc29ydGFibGUgaXRlbXMuIFRoaXMgc25hcHNob3RcbiAgICAgKiAgICAgaXMgY3JpdGljYWwgZm9yOlxuICAgICAqICAgICAtIENhbGN1bGF0aW5nIGRyYWcgZGVsdGFzIGZvciBzb3J0aW5nLlxuICAgICAqICAgICAtIFJlc3RvcmluZyB0aGUgbGF5b3V0IGFmdGVyIGEgd2luZG93IGRyYWcgcmUtZW50cnkuXG4gICAgICogICAgIC0gSW5mZXJyaW5nIGdhcHMgYW5kIG9mZnNldHMgZm9yIGBjYWxjdWxhdGVFeHBhbmRlZExheW91dGAuXG4gICAgICogMy4gICoqU2V0dXAgUHJveHkgJiBQbGFjZWhvbGRlcjoqKiBDb25maWd1cmVzIHRoZSB2aXN1YWwgZHJhZyBwcm94eSBhbmQgaW5zZXJ0cyB0aGUgcGxhY2Vob2xkZXIgaW50byB0aGUgYHNvcnRhYmxlSXRlbXNgIGxpc3QuXG4gICAgICogNC4gICoqQXBwbHkgQWJzb2x1dGUgUG9zaXRpb25pbmc6KiogVGVtcG9yYXJpbHkgc3dpdGNoZXMgYWxsIGl0ZW1zIHRvIGBwb3NpdGlvbjogYWJzb2x1dGVgIGJhc2VkIG9uIHRoZWlyIGNhcHR1cmVkXG4gICAgICogICAgIGNvb3JkaW5hdGVzIHRvIGVuYWJsZSBzbW9vdGgsIEdQVS1hY2NlbGVyYXRlZCBtb3ZlbWVudCBkdXJpbmcgdGhlIGRyYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkcmFnIHN0YXJ0IGV2ZW50IGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YWRqdXN0SXRlbVJlY3RzVG9QYXJlbnQsIGRyYWdIYW5kbGVTZWxlY3Rvciwgb3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBpdGVtU3R5bGVzID0gbWUuaXRlbVN0eWxlcyA9IFtdLFxuICAgICAgICAgICAge2xheW91dH0gICA9IG93bmVyLFxuICAgICAgICAgICAgb3duZXJTdHlsZSA9IG93bmVyLnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgZHJhZ2dlZEl0ZW0sIGluZGV4LCBpbmRleE1hcCwgaXRlbVN0eWxlLCByZWN0LCBzb3J0YWJsZUl0ZW1zO1xuXG4gICAgICAgIGlmIChvd25lci5kcmFnUmVzb3J0YWJsZSkge1xuICAgICAgICAgICAgaWYgKGRyYWdIYW5kbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsYXNzTmFtZSA9IGRyYWdIYW5kbGVTZWxlY3Rvci5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlTm9kZSAgICAgID0gZGF0YS5wYXRoLmZpbmQobm9kZSA9PiBub2RlLmNscy5pbmNsdWRlcyhoYW5kbGVDbGFzc05hbWUpKTtcblxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVJbmRleCA9IGRhdGEucGF0aC5pbmRleE9mKGhhbmRsZU5vZGUpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGhhbmRsZUluZGV4OyBpIDwgZGF0YS5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbEl0ZW1Ob2RlID0gZGF0YS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KHBvdGVudGlhbEl0ZW1Ob2RlLmlkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIG93bmVyLml0ZW1zLmluY2x1ZGVzKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdnZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMgPSBvd25lci5pdGVtcy5maWx0ZXIoaXRlbSA9PiBWRG9tVXRpbC5maW5kKGl0ZW0udmRvbSwge1xuICAgICAgICAgICAgICAgICAgICBjbHM6IGRyYWdIYW5kbGVTZWxlY3Rvci5zdGFydHNXaXRoKCcuJykgPyBkcmFnSGFuZGxlU2VsZWN0b3Iuc3Vic3RyaW5nKDEpIDogZHJhZ0hhbmRsZVNlbGVjdG9yXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgPSBzb3J0YWJsZUl0ZW1zLmluZGV4T2YoZHJhZ2dlZEl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdnZWRJdGVtICAgPSBOZW8uZ2V0Q29tcG9uZW50KGRhdGEucGF0aFswXS5pZCk7XG4gICAgICAgICAgICAgICAgc29ydGFibGVJdGVtcyA9IG93bmVyLml0ZW1zO1xuICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgPSBvd25lci5pbmRleE9mKGRyYWdnZWRJdGVtLmlkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmRleE1hcCA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4ICAgICAgICAgICA6IGluZGV4LFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgICAgICAgICAgOiBWRG9tVXRpbC5maW5kKG93bmVyLnZkb20sIGRyYWdnZWRJdGVtLmlkKS52ZG9tLFxuICAgICAgICAgICAgICAgIGRyYWdQcm94eUNvbmZpZyAgICAgICAgOiBtZS5nZXREcmFnUHJveHlDb25maWcoKSxcbiAgICAgICAgICAgICAgICBpbmRleE1hcCxcbiAgICAgICAgICAgICAgICBsYXN0SW50ZXJzZWN0aW9uUmF0aW8gIDogMSxcbiAgICAgICAgICAgICAgICBvd25lclN0eWxlICAgICAgICAgICAgIDoge2hlaWdodDogb3duZXJTdHlsZS5oZWlnaHQsIG1pbldpZHRoOiBvd25lclN0eWxlLm1pbldpZHRoLCB3aWR0aDogb3duZXJTdHlsZS53aWR0aH0sXG4gICAgICAgICAgICAgICAgcmV2ZXJzZWRMYXlvdXREaXJlY3Rpb246IGxheW91dC5kaXJlY3Rpb24gPT09ICdjb2x1bW4tcmV2ZXJzZScgfHwgbGF5b3V0LmRpcmVjdGlvbiA9PT0gJ3Jvdy1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICBzb3J0YWJsZUl0ZW1zLFxuICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gICAgICAgICAgOiBsYXlvdXQuZGlyZWN0aW9uPy5pbmNsdWRlcygnY29sdW1uJykgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggICAgICAgICAgICAgOiBpbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmRyYWdDb21wb25lbnQgPSBkcmFnZ2VkSXRlbTtcblxuICAgICAgICAgICAgc29ydGFibGVJdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaW5kZXhNYXBbaV0gPSBvd25lci5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtLmhlaWdodCA/IGAke2l0ZW0uaGVpZ2h0fXB4YCA6ICBpdGVtLnN0eWxlPy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIDogaXRlbS53aWR0aCAgPyBgJHtpdGVtLndpZHRofXB4YCAgOiAgaXRlbS5zdHlsZT8ud2lkdGhcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1SZWN0cyA9IGF3YWl0IG93bmVyLmdldERvbVJlY3QoW293bmVyLmlkXS5jb25jYXQoc29ydGFibGVJdGVtcy5tYXAoZSA9PiBlLmlkKSkpO1xuXG4gICAgICAgICAgICBtZS5vd25lclJlY3QgPSBpdGVtUmVjdHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJlYWwgb3duZXIgZGltZW5zaW9ucyBiYXNlZCBvbiBmaXJzdCBhbmQgbGFzdCBpdGVtIHJlY3RzIChhY2NvdW50aW5nIGZvciBwYWRkaW5nKVxuICAgICAgICAgICAgaWYgKGl0ZW1SZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RJdGVtUmVjdCA9IGl0ZW1SZWN0c1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0SXRlbVJlY3QgID0gaXRlbVJlY3RzW2l0ZW1SZWN0cy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5zb3J0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SXRlbVJlY3QueCA+IG1lLm93bmVyUmVjdC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3QueCA9IGZpcnN0SXRlbVJlY3QueFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1SZWN0LnkgPiBtZS5vd25lclJlY3QueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUub3duZXJSZWN0LnkgPSBmaXJzdEl0ZW1SZWN0LnlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3Qud2lkdGggID0gKGxhc3RJdGVtUmVjdC54ICsgbGFzdEl0ZW1SZWN0LndpZHRoKSAgLSBtZS5vd25lclJlY3QueDtcbiAgICAgICAgICAgICAgICAgICAgbWUub3duZXJSZWN0LmhlaWdodCA9IChsYXN0SXRlbVJlY3QueSArIGxhc3RJdGVtUmVjdC5oZWlnaHQpIC0gbWUub3duZXJSZWN0LnlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RJdGVtUmVjdC54ID4gbWUub3duZXJSZWN0LngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm93bmVyUmVjdC54ID0gZmlyc3RJdGVtUmVjdC54XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SXRlbVJlY3QueSA+IG1lLm93bmVyUmVjdC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3QueSA9IGZpcnN0SXRlbVJlY3QueVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lLm93bmVyUmVjdC53aWR0aCAgPSAobGFzdEl0ZW1SZWN0LnggKyBsYXN0SXRlbVJlY3Qud2lkdGgpICAtIG1lLm93bmVyUmVjdC54O1xuICAgICAgICAgICAgICAgICAgICBtZS5vd25lclJlY3QuaGVpZ2h0ID0gKGxhc3RJdGVtUmVjdC55ICsgbGFzdEl0ZW1SZWN0LmhlaWdodCkgLSBtZS5vd25lclJlY3QueVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3duZXIuc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4ub3duZXJTdHlsZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgIDogYCR7bWUub3duZXJSZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGAke21lLm93bmVyUmVjdC53aWR0aH1weGAsXG4gICAgICAgICAgICAgICAgd2lkdGggICA6IGAke21lLm93bmVyUmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFkanVzdEl0ZW1SZWN0c1RvUGFyZW50ICYmIGl0ZW1SZWN0cy5mb3JFYWNoKHJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIHJlY3QueCAtPSBtZS5vd25lclJlY3QueDtcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbWUub3duZXJSZWN0LnlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtUmVjdHMgPSBpdGVtUmVjdHM7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLmRyYWdTdGFydChkYXRhKTtcblxuICAgICAgICAgICAgaWYgKG1lLmRyYWdQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVySW5kZXggPSBzb3J0YWJsZUl0ZW1zLmluZGV4T2YoZHJhZ2dlZEl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGFibGVJdGVtc1twbGFjZWhvbGRlckluZGV4XSA9IG1lLmRyYWdQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZS5kcmFnRWxlbWVudCA9IG1lLmRyYWdQbGFjZWhvbGRlci52ZG9tXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvcnRhYmxlSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW1TdHlsZSA9IGl0ZW0ud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHJlY3QgICAgICA9IG1lLml0ZW1SZWN0c1tpXTtcblxuICAgICAgICAgICAgICAgIG1lLmFkanVzdFByb3h5UmVjdFRvUGFyZW50Py4ocmVjdCwgbWUub3duZXJSZWN0KTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ud3JhcHBlclN0eWxlID0gT2JqZWN0LmFzc2lnbihpdGVtU3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICA6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICA6IGAke3JlY3QubGVmdH1weGAsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiAgOiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICAgOiBgJHtyZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCg1KTtcblxuICAgICAgICAgICAgaWYgKCFtZS5kcmFnUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBpdGVtU3R5bGUgPSBkcmFnZ2VkSXRlbS53cmFwcGVyU3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgaXRlbVN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICBkcmFnZ2VkSXRlbS53cmFwcGVyU3R5bGUgPSBpdGVtU3R5bGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnNlY3Rpb25SYXRpb1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25XaW5kb3dEcmFnQ29udGludWUoaW50ZXJzZWN0aW9uUmF0aW8sIGRhdGEpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBzY3JvbGxUb0luZGV4KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgYXdhaXQgbWUub3duZXIuc2Nyb2xsVG9JbmRleD8uKG1lLmN1cnJlbnRJbmRleCwgbWUuaXRlbVJlY3RzW21lLmN1cnJlbnRJbmRleF0pO1xuICAgICAgICBtZS5pc1Njcm9sbGluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgdHdvIGl0ZW1zIGluIHRoZSBzb3J0IGxpc3QsIHVwZGF0aW5nIHRoZWlyIGxheW91dCBjb29yZGluYXRlcyBhbmQgdGhlIGludGVybmFsIGluZGV4IG1hcC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdGhlIHBoeXNpY2FsIHJlb3JkZXJpbmcgb2YgaXRlbXMgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uIEl0IHBlcmZvcm1zIHRoZSBmb2xsb3dpbmc6XG4gICAgICogMS4gICoqTm9ybWFsaXphdGlvbjoqKiBFbnN1cmVzIGluZGljZXMgYXJlIG9yZGVyZWQgY29ycmVjdGx5IGJhc2VkIG9uIGxheW91dCBkaXJlY3Rpb24uXG4gICAgICogMi4gICoqR2VvbWV0cnkgQ2FsY3VsYXRpb246KiogU3dhcHMgdGhlIGRpbWVuc2lvbnMgKHdpZHRoL2hlaWdodCkgb2YgdGhlIHR3byBpdGVtcyBhbmQgcmVjYWxjdWxhdGVzXG4gICAgICogICAgIHRoZWlyIHBvc2l0aW9ucyAoeC95KSwgcHJlc2VydmluZyB0aGUgb3JpZ2luYWwgZ2FwIGJldHdlZW4gdGhlbS4gVGhpcyBlbnN1cmVzIHRoYXQgaXRlbXMgb2YgZGlmZmVyZW50XG4gICAgICogICAgIHNpemVzIHN3YXAgY29ycmVjdGx5IHdpdGhvdXQgYnJlYWtpbmcgdGhlIGxheW91dCBzdHJ1Y3R1cmUuXG4gICAgICogMy4gICoqU3RhdGUgVXBkYXRlOioqIFVwZGF0ZXMgdGhlIGBpbmRleE1hcGAgdG8gcmVmbGVjdCB0aGUgbmV3IGxvZ2ljYWwgb3JkZXIgb2YgaXRlbXMuXG4gICAgICogNC4gICoqVmlzdWFsIFVwZGF0ZToqKiBDYWxscyBgdXBkYXRlSXRlbWAgdG8gYXBwbHkgdGhlIG5ldyBjb29yZGluYXRlcyB0byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MSAtIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSB0byBzd2FwLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDIgLSBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtIHRvIHN3YXAuXG4gICAgICovXG4gICAgc3dpdGNoSXRlbXMoaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJldmVyc2VkID0gbWUucmV2ZXJzZWRMYXlvdXREaXJlY3Rpb24sXG4gICAgICAgICAgICB0bXA7XG5cbiAgICAgICAgaWYgKCghcmV2ZXJzZWQgJiYgaW5kZXgyIDwgaW5kZXgxKSB8fCAocmV2ZXJzZWQgJiYgaW5kZXgxIDwgaW5kZXgyKSkge1xuICAgICAgICAgICAgdG1wICAgID0gaW5kZXgxO1xuICAgICAgICAgICAgaW5kZXgxID0gaW5kZXgyO1xuICAgICAgICAgICAgaW5kZXgyID0gdG1wXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXRlbVJlY3RzID0gbWUuaXRlbVJlY3RzLFxuICAgICAgICAgICAgbWFwICAgICAgID0gbWUuaW5kZXhNYXAsXG4gICAgICAgICAgICByZWN0MSAgICAgPSBpdGVtUmVjdHNbaW5kZXgxXSxcbiAgICAgICAgICAgIHJlY3QyICAgICA9IGl0ZW1SZWN0c1tpbmRleDJdLFxuICAgICAgICAgICAgcmVjdDFDb3B5ID0gcmVjdDEuY2xvbmUoKSxcbiAgICAgICAgICAgIHJlY3QyQ29weSA9IHJlY3QyLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKG1lLnNvcnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgY29uc3QgZ2FwID0gcmVjdDJDb3B5LnggLSAocmVjdDFDb3B5LnggKyByZWN0MUNvcHkud2lkdGgpO1xuXG4gICAgICAgICAgICByZWN0MS53aWR0aCA9IHJlY3QyQ29weS53aWR0aDtcbiAgICAgICAgICAgIHJlY3QyLnggICAgID0gcmVjdDFDb3B5LnggKyByZWN0MkNvcHkud2lkdGggKyBnYXA7XG4gICAgICAgICAgICByZWN0Mi53aWR0aCA9IHJlY3QxQ29weS53aWR0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2FwID0gcmVjdDJDb3B5LnkgLSAocmVjdDFDb3B5LnkgKyByZWN0MUNvcHkuaGVpZ2h0KTtcblxuICAgICAgICAgICAgcmVjdDEuaGVpZ2h0ID0gcmVjdDJDb3B5LmhlaWdodDtcbiAgICAgICAgICAgIHJlY3QyLmhlaWdodCA9IHJlY3QxQ29weS5oZWlnaHQ7XG4gICAgICAgICAgICByZWN0Mi55ICAgICAgPSByZWN0MUNvcHkueSArIHJlY3QyQ29weS5oZWlnaHQgKyBnYXBcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCAgICAgICAgID0gbWFwW2luZGV4MV07XG4gICAgICAgIG1hcFtpbmRleDFdID0gbWFwW2luZGV4Ml07XG4gICAgICAgIG1hcFtpbmRleDJdID0gdG1wO1xuXG4gICAgICAgIG1lLnVwZGF0ZUl0ZW0oaW5kZXgxLCByZWN0MSk7XG4gICAgICAgIG1lLnVwZGF0ZUl0ZW0oaW5kZXgyLCByZWN0MilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxuICAgICAqL1xuICAgIHVwZGF0ZUl0ZW0oaW5kZXgsIHJlY3QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1hcHBlZEluZGV4ID0gbWUuaW5kZXhNYXBbaW5kZXhdLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBpZiAobWFwcGVkSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAobWUuZHJhZ1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lLmRyYWdQbGFjZWhvbGRlclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5vd25lci5pdGVtc1ttYXBwZWRJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChtZS5kcmFnUGxhY2Vob2xkZXIgJiYgaXRlbSA9PT0gbWUuZHJhZ0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBtZS5kcmFnUGxhY2Vob2xkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7d3JhcHBlclN0eWxlfSA9IGl0ZW07XG5cbiAgICAgICAgd3JhcHBlclN0eWxlLmxlZnQgPSBgJHtyZWN0LmxlZnR9cHhgO1xuICAgICAgICB3cmFwcGVyU3R5bGUudG9wICA9IGAke3JlY3QudG9wfXB4YDtcblxuICAgICAgICBpdGVtLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU29ydFpvbmUpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==