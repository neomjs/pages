export const __webpack_esm_id__ = "vendors-src_tree_List_mjs";
export const __webpack_esm_ids__ = ["vendors-src_tree_List_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/selection/TreeModel.mjs"
/*!*************************************!*\
  !*** ./src/selection/TreeModel.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ListModel.mjs */ "./src/selection/ListModel.mjs");


/**
 * @class Neo.selection.TreeModel
 * @extends Neo.selection.ListModel
 */
class TreeModel extends _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.TreeModel'
         * @protected
         */
        className: 'Neo.selection.TreeModel',
        /**
         * @member {String} ntype='selection-treemodel'
         * @protected
         */
        ntype: 'selection-treemodel'
    }

    /**
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        // Neo.log('onKeyDownEnter', data)
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        // Neo.log('onNavKey', data, step)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeModel));


/***/ },

/***/ "./src/tree/List.mjs"
/*!***************************!*\
  !*** ./src/tree/List.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../list/Base.mjs */ "./src/list/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_TreeModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/TreeModel.mjs */ "./src/selection/TreeModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







/**
 * @summary A hierarchical list component supporting nested folders, expansion, and sticky headers.
 *
 * This component renders hierarchical data structures (trees) using a flat store managed by a `Neo.selection.TreeModel`.
 * It provides built-in support for:
 * - **Recursive rendering:** Efficiently renders deeply nested folder structures.
 * - **Collapsible folders:** Interactive expand/collapse functionality for branch nodes.
 * - **Sticky Headers:** Folder headers use CSS `position: sticky` to remain visible while scrolling through their content.
 * - **Stuck State Detection:** When `saveScrollPosition` is enabled, the component tracks the sticky state via JS and applies
 *   a `.neo-stuck` class to headers that are currently pinned. This is useful for visual customization, such as applying
 *   backgrounds to transparent items.
 * - **Drag and Drop:** Supports reordering via `dragResortable` or moving items between lists via `draggable`.
 * - **Filtering:** Deep-filtering that preserves folder structures for matched leaf nodes.
 *
 * Keywords: `Hierarchical Data`, `Tree View`, `Recursive List`, `Sticky Headers`, `Folder View`
 *
 * @class Neo.tree.List
 * @extends Neo.list.Base
 * @see Neo.selection.TreeModel
 */
class Tree extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tree.List'
         * @protected
         */
        className: 'Neo.tree.List',
        /**
         * @member {String} ntype='treelist'
         * @protected
         */
        ntype: 'treelist',
        /**
         * @member {String[]} baseCls=['neo-tree-list']
         */
        baseCls: ['neo-tree-list'],
        /**
         * @member {Boolean} disableSelection=false
         * @reactive
         */
        disableSelection: false,
        /**
         * @member {Boolean} dragResortable_=false
         * @reactive
         */
        dragResortable_: false,
        /**
         * @member {Neo.draggable.tree.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {String} folderCls='neo-list-folder'
         */
        folderCls: 'neo-list-folder',
        /**
         * @member {Boolean} showCollapseExpandAllIcons=true
         */
        showCollapseExpandAllIcons: true,
        /**
         * @member {Neo.draggable.tree.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        sortZoneConfig: null,
        /**
         * @member {String[]} wrapperCls=[]
         * @reactive
         */
        wrapperCls: [],
        /**
         * Set this config to true to monitor the scroll position of the list.
         * This enables the `onScrollCapture` logic which calculates if sticky folder headers
         * are currently in a "stuck" state (pinned to the top), applying the `.neo-stuck` CSS class.
         * Useful for applying visual changes (e.g. background opacity) only when headers are sticking.
         * @member {Boolean} saveScrollPosition=false
         */
        saveScrollPosition: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'ul', cls: ['neo-list-container', 'neo-list'], tabIndex: -1, cn: []}
        ]}
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value) {
            if (me.dragResortable) {
                console.error('tree.List can be either draggable or dragResortable, not both.', me.id)
            } else if (!me.dragZone) {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-src_draggable_tree_DragZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/tree/DragZone.mjs */ "./src/draggable/tree/DragZone.mjs")).then(module => {
                    me.dragZone = Neo.create({
                        module  : module.default,
                        appName : me.appName,
                        owner   : me,
                        windowId: me.windowId,
                        ...me.dragZoneConfig
                    })
                })
            }
        }
    }

    /**
     * Triggered after the dragResortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDragResortable(value, oldValue) {
        let me = this;

        if (value) {
            if (me.draggable) {
                console.error('tree.List can be either draggable or dragResortable, not both.', me.id)
            } else if (!me.sortZone) {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_DragProxyContainer_mjs-src_draggable_tree_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/tree/SortZone.mjs */ "./src/draggable/tree/SortZone.mjs")).then(module => {
                    me.sortZone = Neo.create({
                        module             : module.default,
                        appName            : me.appName,
                        boundaryContainerId: me.id,
                        owner              : me,
                        windowId           : me.windowId,
                        ...me.sortZoneConfig
                    })
                })
            }
        }
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _selection_TreeModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store} value
     * @param {Object|Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        if (!value) {
            value = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
                keyProperty: 'id'
            })
        }

        return super.beforeSetStore(value, oldValue)
    }


    /**
     * Collapses all folders
     * @param {Boolean} [silent]=false Set silent to true to prevent a vnode update
     */
    collapseAll(silent=false) {
        let me       = this,
            hasMatch = false,
            nextSibling, node, parentNode, index;

        me.store.forEach(item => {
            if (!item.isLeaf) {
                node = me.getVdomChild(me.getItemId(item.id), me.vdom);

                if (node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = null;
                    node.style.top      = null;

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = true
                    }

                    hasMatch = true
                }
            }
        });

        if (hasMatch && !silent) {
            me.update()
        }
    }

    /**
     * Creates the VDOM object for a single tree item (leaf or folder).
     *
     * This method is the core VDOM factory for the tree. It constructs the `li` element
     * representing a record. Key responsibilities:
     * 1.  **Class Assignment:** Applies `itemCls`, `folderCls`, and `iconCls` based on record state.
     * 2.  **Hierarchy visualization:** Calculates `zIndex` and `padding` based on depth (`level`).
     * 3.  **Sticky Positioning:** Sets `position: sticky` and calculates `top` offsets for folder nodes
     *     to ensure they stack correctly while scrolling.
     * 4.  **Content:** Creates the label and icon structure.
     *
     * @param {Object} record The data record from the store
     * @returns {Object} The VDOM object for the list item
     */
    createItem(record) {
        let me                   = this,
            {folderCls, itemCls} = me,
            cls                  = [itemCls],
            contentCls           = [itemCls + '-content'],
            keyProperty          = me.getKeyProperty(),
            itemVdom;

        if (record.iconCls) {
            if (Array.isArray(record.iconCls)) {
                contentCls.push(...record.iconCls)
            } else {
                contentCls.push(record.iconCls)
            }
        }

        if (record.isLeaf) {
            cls.push(itemCls + (record.singleton ? '-leaf-singleton' : '-leaf'))
        } else {
            cls.push(folderCls);

            if (!record.collapsed) {
                cls.push('neo-folder-open')
            }
        }

        itemVdom = {
            tag: 'li',
            cls,
            id   : me.getItemId(record[keyProperty]),
            level: record.level,
            cn   : [{
                tag  : 'span',
                cls  : contentCls,
                html : record[me.displayField],
                style: {pointerEvents: 'none'}
            }],
            style: {
                display : record.hidden ? 'none' : 'flex',
                padding : '10px',
                position: (record.isLeaf || record.collapsed) ? null : 'sticky',
                top     : (record.isLeaf || record.collapsed) ? null : (record.level * 38) + 'px',
                zIndex  : record.isLeaf ? 1 : (10000 + record.level)
            }
        };

        if (me.itemsFocusable) {
            itemVdom.tabIndex = -1
        }

        return itemVdom
    }

    /**
     * Recursively generates the VDOM tree structure starting from a given parent.
     *
     * This method implements the recursive logic required to turn a flat store into a
     * hierarchical DOM structure.
     * - It finds all direct children of the `parentId`.
     * - It creates a `ul` container for them.
     * - For each child, it calls `createItem` to generate the node.
     * - It recursively calls itself (`createItemLevel`) for each child to build the next level.
     *
     * This approach ensures that the visual hierarchy matches the data relationship,
     * supporting arbitrary depth.
     *
     * @param {String} [parentId] The parent node id (null for root level)
     * @param {Object} [vdomRoot] The vdom template root for the current sub tree
     * @param {Number} level The current hierarchy level (depth)
     * @param {Boolean} hidden=false Whether this branch is currently hidden (collapsed parent)
     * @returns {Object} vdomRoot
     * @protected
     */
    createItemLevel(parentId, vdomRoot, level, hidden=false) {
        let me    = this,
            items = me.store.find('parentId', parentId),
            tmpRoot;

        if (items.length > 0) {
            if (!vdomRoot.cn) {
                vdomRoot.cn = []
            }

            if (parentId !== null) {
                vdomRoot.cn.push({
                    tag      : 'ul',
                    cls      : ['neo-list'],
                    cn       : [],
                    removeDom: hidden,
                    style    : {
                        paddingLeft: '15px'
                    }
                });

                tmpRoot = vdomRoot.cn[vdomRoot.cn.length - 1]
            } else {
                tmpRoot = vdomRoot
            }

            items.forEach(record => {
                record.level = level;

                tmpRoot.cn.push(me.createItem(record));

                me.createItemLevel(record.id, tmpRoot, level + 1, record.hidden || hidden || record.collapsed)
            })
        }

        return vdomRoot
    }

    /**
     * The main entry point for rendering the tree's content.
     *
     * This method clears the current list content and initiates the recursive rendering process
     * by calling `createItemLevel` starting from the root (null parent).
     * It is typically called when the store is loaded or when a full refresh is needed.
     *
     * @protected
     */
    createItems() {
        let me        = this,
            itemsRoot = me.getListItemsRoot();

        itemsRoot.cn = [];

        me.createItemLevel(null, itemsRoot, 0);
        me.update()
    }

    /**
     * Expands all folders
     * @param {Boolean} silent=false Set silent to true to prevent a vnode update
     */
    expandAll(silent=false) {
        let me       = this,
            hasMatch = false,
            nextSibling, node, parentNode, index;

        me.store.forEach(item => {
            if (!item.isLeaf) {
                node = me.getVdomChild(me.getItemId(item.id), me.vdom);

                if (!node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = 'sticky';
                    node.style.top      = (node.level * 38) + 'px';

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = false
                    }

                    hasMatch = true
                }
            }
        });

        if (hasMatch && !silent) {
            me.update()
        }
    }

    /**
     * Expands all parent nodes of a given item and scrolls it into view once mounted.
     * @param {String|Number} itemId
     * @returns {Promise<void>}
     */
    async expandAndScrollToItem(itemId) {
        let me = this;

        me.expandParents(itemId);

        const
            id   = me.getItemId(itemId),
            rect = await me.waitForDomRect({id, attempts: 20, delay: 50});

        if (rect) {
            me.scrollToItem(itemId)
        }
    }

    /**
     * Expands all parent folders of a given item
     * @param {String|Number} itemId
     */
    expandParents(itemId) {
        let me       = this,
            item     = me.store.get(itemId),
            hasMatch = false,
            nextSibling, node, parentId, parentNode, index;

        if (item) {
            parentId = item.parentId;

            while (parentId) {
                node = me.getVdomChild(me.getItemId(parentId));

                if (node && !node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = 'sticky';
                    node.style.top      = (node.level * 38) + 'px';

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = false
                    }

                    hasMatch = true
                }

                item     = me.store.get(parentId);
                parentId = item ? item.parentId : null
            }
        }

        if (hasMatch) {
            me.update()
        }
    }

    /**
     * Hides Tree nodes which do not match the filter
     * @param {String} property The store field to filter by
     * @param {String} value The filter value
     * @param {Number|null} parentId The root id for the current filter call
     * @param {Boolean} [parentMatch]=false In case a parent folder matches the filter, show its child items
     * @returns {Boolean} false if at least one child item is filtered
     */
    filter(property, value, parentId, parentMatch = false) {
        let me         = this,
            isFiltered = true,
            valueRegEx = new RegExp(value, 'gi'),
            childReturnValue, directMatch, node;

        if (!value) {
            value = ''
        }

        me.store.forEach(item => {
            if (item.parentId === parentId) {
                directMatch = false;
                node        = me.getVdomChild(me.getItemId(item.id), me.vdom);

                node.cn[0].html = item[property].replace(valueRegEx, match => {
                    directMatch = true;
                    return `<span class="neo-highlight-search">${match}</span>`
                });

                if (item.isLeaf) {
                    childReturnValue = true
                } else {
                    childReturnValue = me.filter(property, value, item.id, directMatch || parentMatch)
                }

                if (directMatch || parentMatch || childReturnValue === false || value === '') {
                    isFiltered = false
                }

                node.style.display = isFiltered ? 'none' : 'list-item'
            }
        });

        if (parentId === null) {
            me.expandAll(true);
            me.update()
        }

        return isFiltered
    }

    /**
     * Scrolls a list item into the visible area
     * @param {String|Number} itemId
     */
    scrollToItem(itemId) {
        let me = this;

        Neo.main.DomAccess.scrollIntoView({
            id      : me.getItemId(itemId),
            inline  : 'start',
            windowId: me.windowId
        })
    }

    /**
     * @returns {Object}
     */
    getListItemsRoot() {
        let me = this,
            cn = me.vdom.cn;

        if (cn.length >= 3 && cn[0].cls?.includes('neo-treelist-collapse-all-icon')) {
            return cn[2]
        }

        return cn[0]
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        if (data.target.cls.includes('neo-treelist-menu-item')) {
            this.onMenuItemClick(data.target.cls)
        } else {
            super.onClick(data)
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.showCollapseExpandAllIcons) {
            me.vdom.cn.unshift({
                cls: ['neo-treelist-menu-item', 'neo-treelist-collapse-all-icon'],
                cn : [{
                    tag: 'span',
                    cls: ['neo-treelist-menu-item-content']
                }]
            }, {
                cls: ['neo-treelist-menu-item', 'neo-treelist-expand-all-icon'],
                cn : [{
                    tag: 'span',
                    cls: ['neo-treelist-menu-item-content']
                }]
            });

            me.update()
        }
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me          = this,
            {items}     = me.store,
            i           = 0,
            len         = items.length,
            keyProperty = me.getKeyProperty(),
            path        = data.path.map(e => e.id),
            item, record, tmpItem, vnodeId;

        for (; i < len; i++) {
            tmpItem = items[i];
            vnodeId = me.getItemId(tmpItem[keyProperty]);

            if (path.includes(vnodeId)) {
                record = tmpItem;
                item = me.getVdomChild(vnodeId);
                break
            }
        }

        if (item) {
            if (item.cls?.includes(me.folderCls)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(item.cls, 'neo-folder-open');

                let isOpen              = item.cls.includes('neo-folder-open'),
                    {parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, item.id),
                    nextSibling         = parentNode.cn[index + 1];

                item.style.position = isOpen ? 'sticky' : null;
                item.style.top      = isOpen ? (item.level * 38) + 'px' : null;

                if (nextSibling?.tag === 'ul') {
                    nextSibling.removeDom = !isOpen
                }

                me.update()
            } else {
                me.onLeafItemClick(record);

                /**
                 * The leafItemClick event fires when a click occurs on a list item which does not have child items.
                 * Passes the item record to the event handler.
                 * @event leafItemClick
                 * @returns {Object} record
                 */
                me.fire('leafItemClick', record)
            }

            super.onItemClick(node, data)
        }
    }

    /**
     * Placeholder method
     * @param {Object} record
     */
    onLeafItemClick(record) {

    }

    /**
     * Gets triggered by clicks on the collapse or expand all icons
     * @param {Array} cls
     * @protected
     */
    onMenuItemClick(cls) {
        if (cls.includes('neo-treelist-collapse-all-icon')) {
            this.collapseAll()
        } else {
            this.expandAll()
        }
    }

    /**
     * Captures the scroll stream from the Main Thread to detect sticky states.
     *
     * When `saveScrollPosition` is true, this method calculates which folder headers are currently
     * pinned ("stuck") to the top of the viewport by comparing their computed `top` style with
     * the current `scrollTop`. It toggles the `neo-stuck` class on these items, allowing for
     * conditional styling (e.g. background opacity) only when headers are sticking.
     *
     * @param {Object} data
     * @param {Number} data.scrollTop The current scroll position
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);

        let me = this;

        if (me.saveScrollPosition) {
            let scrollTop       = data.scrollTop,
                needsUpdate     = false,
                y               = 0,
                stuckCandidates = {};

            const traverse = (node) => {
                if (!node.cn) return;

                let lastFolderOpen = true;

                node.cn.forEach(child => {
                    if (child.tag === 'li') {
                        if (child.cls.includes(me.folderCls)) {
                            let topStyle = child.style.top;

                            if (topStyle) {
                                let isStuck = scrollTop > 0 && (y - scrollTop) <= parseInt(topStyle);

                                if (isStuck) {
                                    let level = child.level || 0;
                                    stuckCandidates[level] ??= [];
                                    stuckCandidates[level].push(child)
                                } else {
                                    if (child.cls.includes('neo-stuck')) {
                                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(child.cls, 'neo-stuck');
                                        needsUpdate = true
                                    }
                                }
                            }

                            lastFolderOpen = child.cls.includes('neo-folder-open')
                        } else {
                            lastFolderOpen = true
                        }

                        if (child.style?.display !== 'none' && !child.removeDom) {
                            y += 51
                        }
                    } else if (child.tag === 'ul') {
                        if (lastFolderOpen && !child.removeDom) {
                            traverse(child)
                        }
                    }
                })
            };

            if (me.vdom.cn && me.vdom.cn[0]) {
                traverse(me.vdom.cn[0])
            }

            Object.values(stuckCandidates).forEach(items => {
                let last = items[items.length - 1];

                items.forEach(item => {
                    let shouldBeStuck = (item === last),
                        hasClass      = item.cls.includes('neo-stuck');

                    if (shouldBeStuck !== hasClass) {
                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(item.cls, 'neo-stuck', shouldBeStuck);
                        needsUpdate = true
                    }
                })
            });

            if (needsUpdate) {
                me.update()
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Number} data.index
     * @param {Neo.data.Model} data.model
     * @param {Object} data.record
     */
    onStoreRecordChange(data) {
        let me                  = this,
            {record}            = data,
            {index, parentNode} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, me.getItemId(record.id));

        parentNode.cn[index] = me.createItem(record);

        me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tree));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190cmVlX0xpc3RfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVM7QUFDakM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUseUJBQXlCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDTTtBQUNPO0FBQ0Q7QUFDTDtBQUNTO0FBQ1Y7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQUk7QUFDdkI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsdVRBQXdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsK1RBQXdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLDZEQUFlLDBCQUEwQixnRUFBUztBQUNqRTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSx1QkFBdUI7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFVO0FBQ3pDO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdURBQVE7O0FBRTVCLHNCQUFzQixtQkFBbUIsRUFBRSxzREFBUTtBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsdURBQVE7O0FBRTVCLHNCQUFzQixtQkFBbUIsRUFBRSxzREFBUTtBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0Qjs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVEQUFROztBQUU1QixzQkFBc0IsbUJBQW1CLEVBQUUsc0RBQVE7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFROztBQUV4QjtBQUNBLHFCQUFxQixtQkFBbUIsRUFBRSxzREFBUTtBQUNsRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esd0NBQXdDLHVEQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix1REFBUTtBQUNoQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLG1CQUFtQixFQUFFLHNEQUFROztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsb0JBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3NlbGVjdGlvbi9UcmVlTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdHJlZS9MaXN0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGlzdE1vZGVsIGZyb20gJy4vTGlzdE1vZGVsLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5zZWxlY3Rpb24uVHJlZU1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uc2VsZWN0aW9uLkxpc3RNb2RlbFxuICovXG5jbGFzcyBUcmVlTW9kZWwgZXh0ZW5kcyBMaXN0TW9kZWwge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zZWxlY3Rpb24uVHJlZU1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3NlbGVjdGlvbi10cmVlbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc2VsZWN0aW9uLXRyZWVtb2RlbCdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uS2V5RG93bkVudGVyKGRhdGEpIHtcbiAgICAgICAgLy8gTmVvLmxvZygnb25LZXlEb3duRW50ZXInLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcbiAgICAgKi9cbiAgICBvbk5hdktleShkYXRhLCBzdGVwKSB7XG4gICAgICAgIC8vIE5lby5sb2coJ29uTmF2S2V5JywgZGF0YSwgc3RlcClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRyZWVNb2RlbCk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgIGZyb20gJy4uL2xpc3QvQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiAgICAgIGZyb20gJy4uL2NvbGxlY3Rpb24vQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVHJlZU1vZGVsICAgICAgIGZyb20gJy4uL3NlbGVjdGlvbi9UcmVlTW9kZWwubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgZnJvbSBcIi4uL3V0aWwvVkRvbS5tanNcIjtcblxuLyoqXG4gKiBAc3VtbWFyeSBBIGhpZXJhcmNoaWNhbCBsaXN0IGNvbXBvbmVudCBzdXBwb3J0aW5nIG5lc3RlZCBmb2xkZXJzLCBleHBhbnNpb24sIGFuZCBzdGlja3kgaGVhZGVycy5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGhpZXJhcmNoaWNhbCBkYXRhIHN0cnVjdHVyZXMgKHRyZWVzKSB1c2luZyBhIGZsYXQgc3RvcmUgbWFuYWdlZCBieSBhIGBOZW8uc2VsZWN0aW9uLlRyZWVNb2RlbGAuXG4gKiBJdCBwcm92aWRlcyBidWlsdC1pbiBzdXBwb3J0IGZvcjpcbiAqIC0gKipSZWN1cnNpdmUgcmVuZGVyaW5nOioqIEVmZmljaWVudGx5IHJlbmRlcnMgZGVlcGx5IG5lc3RlZCBmb2xkZXIgc3RydWN0dXJlcy5cbiAqIC0gKipDb2xsYXBzaWJsZSBmb2xkZXJzOioqIEludGVyYWN0aXZlIGV4cGFuZC9jb2xsYXBzZSBmdW5jdGlvbmFsaXR5IGZvciBicmFuY2ggbm9kZXMuXG4gKiAtICoqU3RpY2t5IEhlYWRlcnM6KiogRm9sZGVyIGhlYWRlcnMgdXNlIENTUyBgcG9zaXRpb246IHN0aWNreWAgdG8gcmVtYWluIHZpc2libGUgd2hpbGUgc2Nyb2xsaW5nIHRocm91Z2ggdGhlaXIgY29udGVudC5cbiAqIC0gKipTdHVjayBTdGF0ZSBEZXRlY3Rpb246KiogV2hlbiBgc2F2ZVNjcm9sbFBvc2l0aW9uYCBpcyBlbmFibGVkLCB0aGUgY29tcG9uZW50IHRyYWNrcyB0aGUgc3RpY2t5IHN0YXRlIHZpYSBKUyBhbmQgYXBwbGllc1xuICogICBhIGAubmVvLXN0dWNrYCBjbGFzcyB0byBoZWFkZXJzIHRoYXQgYXJlIGN1cnJlbnRseSBwaW5uZWQuIFRoaXMgaXMgdXNlZnVsIGZvciB2aXN1YWwgY3VzdG9taXphdGlvbiwgc3VjaCBhcyBhcHBseWluZ1xuICogICBiYWNrZ3JvdW5kcyB0byB0cmFuc3BhcmVudCBpdGVtcy5cbiAqIC0gKipEcmFnIGFuZCBEcm9wOioqIFN1cHBvcnRzIHJlb3JkZXJpbmcgdmlhIGBkcmFnUmVzb3J0YWJsZWAgb3IgbW92aW5nIGl0ZW1zIGJldHdlZW4gbGlzdHMgdmlhIGBkcmFnZ2FibGVgLlxuICogLSAqKkZpbHRlcmluZzoqKiBEZWVwLWZpbHRlcmluZyB0aGF0IHByZXNlcnZlcyBmb2xkZXIgc3RydWN0dXJlcyBmb3IgbWF0Y2hlZCBsZWFmIG5vZGVzLlxuICpcbiAqIEtleXdvcmRzOiBgSGllcmFyY2hpY2FsIERhdGFgLCBgVHJlZSBWaWV3YCwgYFJlY3Vyc2l2ZSBMaXN0YCwgYFN0aWNreSBIZWFkZXJzYCwgYEZvbGRlciBWaWV3YFxuICpcbiAqIEBjbGFzcyBOZW8udHJlZS5MaXN0XG4gKiBAZXh0ZW5kcyBOZW8ubGlzdC5CYXNlXG4gKiBAc2VlIE5lby5zZWxlY3Rpb24uVHJlZU1vZGVsXG4gKi9cbmNsYXNzIFRyZWUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50cmVlLkxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50cmVlLkxpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndHJlZWxpc3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndHJlZWxpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdHJlZS1saXN0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXRyZWUtbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGlzYWJsZVNlbGVjdGlvbj1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJhZ1Jlc29ydGFibGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Jlc29ydGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUudHJlZS5EcmFnWm9uZXxudWxsfSBkcmFnWm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnWm9uZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZm9sZGVyQ2xzPSduZW8tbGlzdC1mb2xkZXInXG4gICAgICAgICAqL1xuICAgICAgICBmb2xkZXJDbHM6ICduZW8tbGlzdC1mb2xkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2hvd0NvbGxhcHNlRXhwYW5kQWxsSWNvbnM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd0NvbGxhcHNlRXhwYW5kQWxsSWNvbnM6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLnRyZWUuU29ydFpvbmV8bnVsbH0gc29ydFpvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRyYWdab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IHdyYXBwZXJDbHM9W11cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwcGVyQ2xzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGNvbmZpZyB0byB0cnVlIHRvIG1vbml0b3IgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgbGlzdC5cbiAgICAgICAgICogVGhpcyBlbmFibGVzIHRoZSBgb25TY3JvbGxDYXB0dXJlYCBsb2dpYyB3aGljaCBjYWxjdWxhdGVzIGlmIHN0aWNreSBmb2xkZXIgaGVhZGVyc1xuICAgICAgICAgKiBhcmUgY3VycmVudGx5IGluIGEgXCJzdHVja1wiIHN0YXRlIChwaW5uZWQgdG8gdGhlIHRvcCksIGFwcGx5aW5nIHRoZSBgLm5lby1zdHVja2AgQ1NTIGNsYXNzLlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGFwcGx5aW5nIHZpc3VhbCBjaGFuZ2VzIChlLmcuIGJhY2tncm91bmQgb3BhY2l0eSkgb25seSB3aGVuIGhlYWRlcnMgYXJlIHN0aWNraW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzYXZlU2Nyb2xsUG9zaXRpb249ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNhdmVTY3JvbGxQb3NpdGlvbjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge2NuOiBbXG4gICAgICAgICAgICB7dGFnOiAndWwnLCBjbHM6IFsnbmVvLWxpc3QtY29udGFpbmVyJywgJ25lby1saXN0J10sIHRhYkluZGV4OiAtMSwgY246IFtdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZHJhZ2dhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RHJhZ2dhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1lLmRyYWdSZXNvcnRhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJlZS5MaXN0IGNhbiBiZSBlaXRoZXIgZHJhZ2dhYmxlIG9yIGRyYWdSZXNvcnRhYmxlLCBub3QgYm90aC4nLCBtZS5pZClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1lLmRyYWdab25lKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvdHJlZS9EcmFnWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRyYWdab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1lLmRyYWdab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZHJhZ1Jlc29ydGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnUmVzb3J0YWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChtZS5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmVlLkxpc3QgY2FuIGJlIGVpdGhlciBkcmFnZ2FibGUgb3IgZHJhZ1Jlc29ydGFibGUsIG5vdCBib3RoLicsIG1lLmlkKVxuICAgICAgICAgICAgfSBlbHNlIGlmICghbWUuc29ydFpvbmUpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4uL2RyYWdnYWJsZS90cmVlL1NvcnRab25lLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc29ydFpvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIgICAgICAgICAgICAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZCAgICAgICAgICAgOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1lLnNvcnRab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNlbGVjdGlvbk1vZGVsIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnNlbGVjdGlvbi5Nb2RlbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U2VsZWN0aW9uTW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgVHJlZU1vZGVsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0b3JlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuU3RvcmV9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuU3RvcmV9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5kYXRhLlN0b3JlfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBOZW8uY3JlYXRlKENvbGxlY3Rpb24sIHtcbiAgICAgICAgICAgICAgICBrZXlQcm9wZXJ0eTogJ2lkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdXBlci5iZWZvcmVTZXRTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYWxsIGZvbGRlcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnRdPWZhbHNlIFNldCBzaWxlbnQgdG8gdHJ1ZSB0byBwcmV2ZW50IGEgdm5vZGUgdXBkYXRlXG4gICAgICovXG4gICAgY29sbGFwc2VBbGwoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlLFxuICAgICAgICAgICAgbmV4dFNpYmxpbmcsIG5vZGUsIHBhcmVudE5vZGUsIGluZGV4O1xuXG4gICAgICAgIG1lLnN0b3JlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1lLmdldFZkb21DaGlsZChtZS5nZXRJdGVtSWQoaXRlbS5pZCksIG1lLnZkb20pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2xzLmluY2x1ZGVzKCduZW8tZm9sZGVyLW9wZW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobm9kZS5jbHMsICduZW8tZm9sZGVyLW9wZW4nKTtcblxuICAgICAgICAgICAgICAgICAgICAoe3BhcmVudE5vZGUsIGluZGV4fSA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbm9kZS5pZCkpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZyAgICAgICAgICA9IHBhcmVudE5vZGUuY25baW5kZXggKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgICAgICA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nPy50YWcgPT09ICd1bCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc01hdGNoICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBWRE9NIG9iamVjdCBmb3IgYSBzaW5nbGUgdHJlZSBpdGVtIChsZWFmIG9yIGZvbGRlcikuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgY29yZSBWRE9NIGZhY3RvcnkgZm9yIHRoZSB0cmVlLiBJdCBjb25zdHJ1Y3RzIHRoZSBgbGlgIGVsZW1lbnRcbiAgICAgKiByZXByZXNlbnRpbmcgYSByZWNvcmQuIEtleSByZXNwb25zaWJpbGl0aWVzOlxuICAgICAqIDEuICAqKkNsYXNzIEFzc2lnbm1lbnQ6KiogQXBwbGllcyBgaXRlbUNsc2AsIGBmb2xkZXJDbHNgLCBhbmQgYGljb25DbHNgIGJhc2VkIG9uIHJlY29yZCBzdGF0ZS5cbiAgICAgKiAyLiAgKipIaWVyYXJjaHkgdmlzdWFsaXphdGlvbjoqKiBDYWxjdWxhdGVzIGB6SW5kZXhgIGFuZCBgcGFkZGluZ2AgYmFzZWQgb24gZGVwdGggKGBsZXZlbGApLlxuICAgICAqIDMuICAqKlN0aWNreSBQb3NpdGlvbmluZzoqKiBTZXRzIGBwb3NpdGlvbjogc3RpY2t5YCBhbmQgY2FsY3VsYXRlcyBgdG9wYCBvZmZzZXRzIGZvciBmb2xkZXIgbm9kZXNcbiAgICAgKiAgICAgdG8gZW5zdXJlIHRoZXkgc3RhY2sgY29ycmVjdGx5IHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiA0LiAgKipDb250ZW50OioqIENyZWF0ZXMgdGhlIGxhYmVsIGFuZCBpY29uIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQgVGhlIGRhdGEgcmVjb3JkIGZyb20gdGhlIHN0b3JlXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIFZET00gb2JqZWN0IGZvciB0aGUgbGlzdCBpdGVtXG4gICAgICovXG4gICAgY3JlYXRlSXRlbShyZWNvcmQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmb2xkZXJDbHMsIGl0ZW1DbHN9ID0gbWUsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgICAgICA9IFtpdGVtQ2xzXSxcbiAgICAgICAgICAgIGNvbnRlbnRDbHMgICAgICAgICAgID0gW2l0ZW1DbHMgKyAnLWNvbnRlbnQnXSxcbiAgICAgICAgICAgIGtleVByb3BlcnR5ICAgICAgICAgID0gbWUuZ2V0S2V5UHJvcGVydHkoKSxcbiAgICAgICAgICAgIGl0ZW1WZG9tO1xuXG4gICAgICAgIGlmIChyZWNvcmQuaWNvbkNscykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjb3JkLmljb25DbHMpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudENscy5wdXNoKC4uLnJlY29yZC5pY29uQ2xzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q2xzLnB1c2gocmVjb3JkLmljb25DbHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZikge1xuICAgICAgICAgICAgY2xzLnB1c2goaXRlbUNscyArIChyZWNvcmQuc2luZ2xldG9uID8gJy1sZWFmLXNpbmdsZXRvbicgOiAnLWxlYWYnKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNscy5wdXNoKGZvbGRlckNscyk7XG5cbiAgICAgICAgICAgIGlmICghcmVjb3JkLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZm9sZGVyLW9wZW4nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbVZkb20gPSB7XG4gICAgICAgICAgICB0YWc6ICdsaScsXG4gICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0SXRlbUlkKHJlY29yZFtrZXlQcm9wZXJ0eV0pLFxuICAgICAgICAgICAgbGV2ZWw6IHJlY29yZC5sZXZlbCxcbiAgICAgICAgICAgIGNuICAgOiBbe1xuICAgICAgICAgICAgICAgIHRhZyAgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgY2xzICA6IGNvbnRlbnRDbHMsXG4gICAgICAgICAgICAgICAgaHRtbCA6IHJlY29yZFttZS5kaXNwbGF5RmllbGRdLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7cG9pbnRlckV2ZW50czogJ25vbmUnfVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGRpc3BsYXkgOiByZWNvcmQuaGlkZGVuID8gJ25vbmUnIDogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgOiAnMTBweCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IChyZWNvcmQuaXNMZWFmIHx8IHJlY29yZC5jb2xsYXBzZWQpID8gbnVsbCA6ICdzdGlja3knLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgOiAocmVjb3JkLmlzTGVhZiB8fCByZWNvcmQuY29sbGFwc2VkKSA/IG51bGwgOiAocmVjb3JkLmxldmVsICogMzgpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB6SW5kZXggIDogcmVjb3JkLmlzTGVhZiA/IDEgOiAoMTAwMDAgKyByZWNvcmQubGV2ZWwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1lLml0ZW1zRm9jdXNhYmxlKSB7XG4gICAgICAgICAgICBpdGVtVmRvbS50YWJJbmRleCA9IC0xXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbVZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBnZW5lcmF0ZXMgdGhlIFZET00gdHJlZSBzdHJ1Y3R1cmUgc3RhcnRpbmcgZnJvbSBhIGdpdmVuIHBhcmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIHJlY3Vyc2l2ZSBsb2dpYyByZXF1aXJlZCB0byB0dXJuIGEgZmxhdCBzdG9yZSBpbnRvIGFcbiAgICAgKiBoaWVyYXJjaGljYWwgRE9NIHN0cnVjdHVyZS5cbiAgICAgKiAtIEl0IGZpbmRzIGFsbCBkaXJlY3QgY2hpbGRyZW4gb2YgdGhlIGBwYXJlbnRJZGAuXG4gICAgICogLSBJdCBjcmVhdGVzIGEgYHVsYCBjb250YWluZXIgZm9yIHRoZW0uXG4gICAgICogLSBGb3IgZWFjaCBjaGlsZCwgaXQgY2FsbHMgYGNyZWF0ZUl0ZW1gIHRvIGdlbmVyYXRlIHRoZSBub2RlLlxuICAgICAqIC0gSXQgcmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIChgY3JlYXRlSXRlbUxldmVsYCkgZm9yIGVhY2ggY2hpbGQgdG8gYnVpbGQgdGhlIG5leHQgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIGFwcHJvYWNoIGVuc3VyZXMgdGhhdCB0aGUgdmlzdWFsIGhpZXJhcmNoeSBtYXRjaGVzIHRoZSBkYXRhIHJlbGF0aW9uc2hpcCxcbiAgICAgKiBzdXBwb3J0aW5nIGFyYml0cmFyeSBkZXB0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyZW50SWRdIFRoZSBwYXJlbnQgbm9kZSBpZCAobnVsbCBmb3Igcm9vdCBsZXZlbClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Zkb21Sb290XSBUaGUgdmRvbSB0ZW1wbGF0ZSByb290IGZvciB0aGUgY3VycmVudCBzdWIgdHJlZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgY3VycmVudCBoaWVyYXJjaHkgbGV2ZWwgKGRlcHRoKVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGlkZGVuPWZhbHNlIFdoZXRoZXIgdGhpcyBicmFuY2ggaXMgY3VycmVudGx5IGhpZGRlbiAoY29sbGFwc2VkIHBhcmVudClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tUm9vdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtTGV2ZWwocGFyZW50SWQsIHZkb21Sb290LCBsZXZlbCwgaGlkZGVuPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyA9IG1lLnN0b3JlLmZpbmQoJ3BhcmVudElkJywgcGFyZW50SWQpLFxuICAgICAgICAgICAgdG1wUm9vdDtcblxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCF2ZG9tUm9vdC5jbikge1xuICAgICAgICAgICAgICAgIHZkb21Sb290LmNuID0gW11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmRvbVJvb3QuY24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRhZyAgICAgIDogJ3VsJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1saXN0J10sXG4gICAgICAgICAgICAgICAgICAgIGNuICAgICAgIDogW10sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogaGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMTVweCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdG1wUm9vdCA9IHZkb21Sb290LmNuW3Zkb21Sb290LmNuLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSB2ZG9tUm9vdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKHJlY29yZCA9PiB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmxldmVsID0gbGV2ZWw7XG5cbiAgICAgICAgICAgICAgICB0bXBSb290LmNuLnB1c2gobWUuY3JlYXRlSXRlbShyZWNvcmQpKTtcblxuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1MZXZlbChyZWNvcmQuaWQsIHRtcFJvb3QsIGxldmVsICsgMSwgcmVjb3JkLmhpZGRlbiB8fCBoaWRkZW4gfHwgcmVjb3JkLmNvbGxhcHNlZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbVJvb3RcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgcmVuZGVyaW5nIHRoZSB0cmVlJ3MgY29udGVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNsZWFycyB0aGUgY3VycmVudCBsaXN0IGNvbnRlbnQgYW5kIGluaXRpYXRlcyB0aGUgcmVjdXJzaXZlIHJlbmRlcmluZyBwcm9jZXNzXG4gICAgICogYnkgY2FsbGluZyBgY3JlYXRlSXRlbUxldmVsYCBzdGFydGluZyBmcm9tIHRoZSByb290IChudWxsIHBhcmVudCkuXG4gICAgICogSXQgaXMgdHlwaWNhbGx5IGNhbGxlZCB3aGVuIHRoZSBzdG9yZSBpcyBsb2FkZWQgb3Igd2hlbiBhIGZ1bGwgcmVmcmVzaCBpcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXNSb290ID0gbWUuZ2V0TGlzdEl0ZW1zUm9vdCgpO1xuXG4gICAgICAgIGl0ZW1zUm9vdC5jbiA9IFtdO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1MZXZlbChudWxsLCBpdGVtc1Jvb3QsIDApO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIGZvbGRlcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZSBTZXQgc2lsZW50IHRvIHRydWUgdG8gcHJldmVudCBhIHZub2RlIHVwZGF0ZVxuICAgICAqL1xuICAgIGV4cGFuZEFsbChzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0U2libGluZywgbm9kZSwgcGFyZW50Tm9kZSwgaW5kZXg7XG5cbiAgICAgICAgbWUuc3RvcmUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWUuZ2V0VmRvbUNoaWxkKG1lLmdldEl0ZW1JZChpdGVtLmlkKSwgbWUudmRvbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuY2xzLmluY2x1ZGVzKCduZW8tZm9sZGVyLW9wZW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQobm9kZS5jbHMsICduZW8tZm9sZGVyLW9wZW4nKTtcblxuICAgICAgICAgICAgICAgICAgICAoe3BhcmVudE5vZGUsIGluZGV4fSA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbm9kZS5pZCkpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZyAgICAgICAgICA9IHBhcmVudE5vZGUuY25baW5kZXggKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3N0aWNreSc7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUudG9wICAgICAgPSAobm9kZS5sZXZlbCAqIDM4KSArICdweCc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nPy50YWcgPT09ICd1bCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZURvbSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNNYXRjaCAmJiAhc2lsZW50KSB7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgcGFyZW50IG5vZGVzIG9mIGEgZ2l2ZW4gaXRlbSBhbmQgc2Nyb2xscyBpdCBpbnRvIHZpZXcgb25jZSBtb3VudGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaXRlbUlkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgZXhwYW5kQW5kU2Nyb2xsVG9JdGVtKGl0ZW1JZCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmV4cGFuZFBhcmVudHMoaXRlbUlkKTtcblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgaWQgICA9IG1lLmdldEl0ZW1JZChpdGVtSWQpLFxuICAgICAgICAgICAgcmVjdCA9IGF3YWl0IG1lLndhaXRGb3JEb21SZWN0KHtpZCwgYXR0ZW1wdHM6IDIwLCBkZWxheTogNTB9KTtcblxuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgbWUuc2Nyb2xsVG9JdGVtKGl0ZW1JZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIHBhcmVudCBmb2xkZXJzIG9mIGEgZ2l2ZW4gaXRlbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaXRlbUlkXG4gICAgICovXG4gICAgZXhwYW5kUGFyZW50cyhpdGVtSWQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gICAgID0gbWUuc3RvcmUuZ2V0KGl0ZW1JZCksXG4gICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlLFxuICAgICAgICAgICAgbmV4dFNpYmxpbmcsIG5vZGUsIHBhcmVudElkLCBwYXJlbnROb2RlLCBpbmRleDtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcGFyZW50SWQgPSBpdGVtLnBhcmVudElkO1xuXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWUuZ2V0VmRvbUNoaWxkKG1lLmdldEl0ZW1JZChwYXJlbnRJZCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgIW5vZGUuY2xzLmluY2x1ZGVzKCduZW8tZm9sZGVyLW9wZW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQobm9kZS5jbHMsICduZW8tZm9sZGVyLW9wZW4nKTtcblxuICAgICAgICAgICAgICAgICAgICAoe3BhcmVudE5vZGUsIGluZGV4fSA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbm9kZS5pZCkpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZyAgICAgICAgICA9IHBhcmVudE5vZGUuY25baW5kZXggKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3N0aWNreSc7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUudG9wICAgICAgPSAobm9kZS5sZXZlbCAqIDM4KSArICdweCc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nPy50YWcgPT09ICd1bCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZURvbSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtICAgICA9IG1lLnN0b3JlLmdldChwYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50SWQgPSBpdGVtID8gaXRlbS5wYXJlbnRJZCA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNNYXRjaCkge1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGVzIFRyZWUgbm9kZXMgd2hpY2ggZG8gbm90IG1hdGNoIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIHN0b3JlIGZpZWxkIHRvIGZpbHRlciBieVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgZmlsdGVyIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gcGFyZW50SWQgVGhlIHJvb3QgaWQgZm9yIHRoZSBjdXJyZW50IGZpbHRlciBjYWxsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyZW50TWF0Y2hdPWZhbHNlIEluIGNhc2UgYSBwYXJlbnQgZm9sZGVyIG1hdGNoZXMgdGhlIGZpbHRlciwgc2hvdyBpdHMgY2hpbGQgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZmFsc2UgaWYgYXQgbGVhc3Qgb25lIGNoaWxkIGl0ZW0gaXMgZmlsdGVyZWRcbiAgICAgKi9cbiAgICBmaWx0ZXIocHJvcGVydHksIHZhbHVlLCBwYXJlbnRJZCwgcGFyZW50TWF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpc0ZpbHRlcmVkID0gdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlUmVnRXggPSBuZXcgUmVnRXhwKHZhbHVlLCAnZ2knKSxcbiAgICAgICAgICAgIGNoaWxkUmV0dXJuVmFsdWUsIGRpcmVjdE1hdGNoLCBub2RlO1xuXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnN0b3JlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnRJZCA9PT0gcGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3RNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUgICAgICAgID0gbWUuZ2V0VmRvbUNoaWxkKG1lLmdldEl0ZW1JZChpdGVtLmlkKSwgbWUudmRvbSk7XG5cbiAgICAgICAgICAgICAgICBub2RlLmNuWzBdLmh0bWwgPSBpdGVtW3Byb3BlcnR5XS5yZXBsYWNlKHZhbHVlUmVnRXgsIG1hdGNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0TWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwibmVvLWhpZ2hsaWdodC1zZWFyY2hcIj4ke21hdGNofTwvc3Bhbj5gXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZXR1cm5WYWx1ZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFJldHVyblZhbHVlID0gbWUuZmlsdGVyKHByb3BlcnR5LCB2YWx1ZSwgaXRlbS5pZCwgZGlyZWN0TWF0Y2ggfHwgcGFyZW50TWF0Y2gpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdE1hdGNoIHx8IHBhcmVudE1hdGNoIHx8IGNoaWxkUmV0dXJuVmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpc0ZpbHRlcmVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBpc0ZpbHRlcmVkID8gJ25vbmUnIDogJ2xpc3QtaXRlbSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcmVudElkID09PSBudWxsKSB7XG4gICAgICAgICAgICBtZS5leHBhbmRBbGwodHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRmlsdGVyZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGEgbGlzdCBpdGVtIGludG8gdGhlIHZpc2libGUgYXJlYVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaXRlbUlkXG4gICAgICovXG4gICAgc2Nyb2xsVG9JdGVtKGl0ZW1JZCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICBpZCAgICAgIDogbWUuZ2V0SXRlbUlkKGl0ZW1JZCksXG4gICAgICAgICAgICBpbmxpbmUgIDogJ3N0YXJ0JyxcbiAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TGlzdEl0ZW1zUm9vdCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGNuID0gbWUudmRvbS5jbjtcblxuICAgICAgICBpZiAoY24ubGVuZ3RoID49IDMgJiYgY25bMF0uY2xzPy5pbmNsdWRlcygnbmVvLXRyZWVsaXN0LWNvbGxhcHNlLWFsbC1pY29uJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjblsyXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNuWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEudGFyZ2V0LmNscy5pbmNsdWRlcygnbmVvLXRyZWVsaXN0LW1lbnUtaXRlbScpKSB7XG4gICAgICAgICAgICB0aGlzLm9uTWVudUl0ZW1DbGljayhkYXRhLnRhcmdldC5jbHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5vbkNsaWNrKGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5zaG93Q29sbGFwc2VFeHBhbmRBbGxJY29ucykge1xuICAgICAgICAgICAgbWUudmRvbS5jbi51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLXRyZWVsaXN0LW1lbnUtaXRlbScsICduZW8tdHJlZWxpc3QtY29sbGFwc2UtYWxsLWljb24nXSxcbiAgICAgICAgICAgICAgICBjbiA6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLXRyZWVsaXN0LW1lbnUtaXRlbS1jb250ZW50J11cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNsczogWyduZW8tdHJlZWxpc3QtbWVudS1pdGVtJywgJ25lby10cmVlbGlzdC1leHBhbmQtYWxsLWljb24nXSxcbiAgICAgICAgICAgICAgICBjbiA6IFt7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLXRyZWVsaXN0LW1lbnUtaXRlbS1jb250ZW50J11cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25JdGVtQ2xpY2sobm9kZSwgZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2l0ZW1zfSAgICAgPSBtZS5zdG9yZSxcbiAgICAgICAgICAgIGkgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAga2V5UHJvcGVydHkgPSBtZS5nZXRLZXlQcm9wZXJ0eSgpLFxuICAgICAgICAgICAgcGF0aCAgICAgICAgPSBkYXRhLnBhdGgubWFwKGUgPT4gZS5pZCksXG4gICAgICAgICAgICBpdGVtLCByZWNvcmQsIHRtcEl0ZW0sIHZub2RlSWQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdG1wSXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgdm5vZGVJZCA9IG1lLmdldEl0ZW1JZCh0bXBJdGVtW2tleVByb3BlcnR5XSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmluY2x1ZGVzKHZub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gdG1wSXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtID0gbWUuZ2V0VmRvbUNoaWxkKHZub2RlSWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2xzPy5pbmNsdWRlcyhtZS5mb2xkZXJDbHMpKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGl0ZW0uY2xzLCAnbmVvLWZvbGRlci1vcGVuJyk7XG5cbiAgICAgICAgICAgICAgICBsZXQgaXNPcGVuICAgICAgICAgICAgICA9IGl0ZW0uY2xzLmluY2x1ZGVzKCduZW8tZm9sZGVyLW9wZW4nKSxcbiAgICAgICAgICAgICAgICAgICAge3BhcmVudE5vZGUsIGluZGV4fSA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgaXRlbS5pZCksXG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nICAgICAgICAgPSBwYXJlbnROb2RlLmNuW2luZGV4ICsgMV07XG5cbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLnBvc2l0aW9uID0gaXNPcGVuID8gJ3N0aWNreScgOiBudWxsO1xuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUudG9wICAgICAgPSBpc09wZW4gPyAoaXRlbS5sZXZlbCAqIDM4KSArICdweCcgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nPy50YWcgPT09ICd1bCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlRG9tID0gIWlzT3BlblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLm9uTGVhZkl0ZW1DbGljayhyZWNvcmQpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGxlYWZJdGVtQ2xpY2sgZXZlbnQgZmlyZXMgd2hlbiBhIGNsaWNrIG9jY3VycyBvbiBhIGxpc3QgaXRlbSB3aGljaCBkb2VzIG5vdCBoYXZlIGNoaWxkIGl0ZW1zLlxuICAgICAgICAgICAgICAgICAqIFBhc3NlcyB0aGUgaXRlbSByZWNvcmQgdG8gdGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IGxlYWZJdGVtQ2xpY2tcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWNvcmRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdsZWFmSXRlbUNsaWNrJywgcmVjb3JkKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdXBlci5vbkl0ZW1DbGljayhub2RlLCBkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqL1xuICAgIG9uTGVhZkl0ZW1DbGljayhyZWNvcmQpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGJ5IGNsaWNrcyBvbiB0aGUgY29sbGFwc2Ugb3IgZXhwYW5kIGFsbCBpY29uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNsc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbk1lbnVJdGVtQ2xpY2soY2xzKSB7XG4gICAgICAgIGlmIChjbHMuaW5jbHVkZXMoJ25lby10cmVlbGlzdC1jb2xsYXBzZS1hbGwtaWNvbicpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlQWxsKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kQWxsKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhcHR1cmVzIHRoZSBzY3JvbGwgc3RyZWFtIGZyb20gdGhlIE1haW4gVGhyZWFkIHRvIGRldGVjdCBzdGlja3kgc3RhdGVzLlxuICAgICAqXG4gICAgICogV2hlbiBgc2F2ZVNjcm9sbFBvc2l0aW9uYCBpcyB0cnVlLCB0aGlzIG1ldGhvZCBjYWxjdWxhdGVzIHdoaWNoIGZvbGRlciBoZWFkZXJzIGFyZSBjdXJyZW50bHlcbiAgICAgKiBwaW5uZWQgKFwic3R1Y2tcIikgdG8gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgYnkgY29tcGFyaW5nIHRoZWlyIGNvbXB1dGVkIGB0b3BgIHN0eWxlIHdpdGhcbiAgICAgKiB0aGUgY3VycmVudCBgc2Nyb2xsVG9wYC4gSXQgdG9nZ2xlcyB0aGUgYG5lby1zdHVja2AgY2xhc3Mgb24gdGhlc2UgaXRlbXMsIGFsbG93aW5nIGZvclxuICAgICAqIGNvbmRpdGlvbmFsIHN0eWxpbmcgKGUuZy4gYmFja2dyb3VuZCBvcGFjaXR5KSBvbmx5IHdoZW4gaGVhZGVycyBhcmUgc3RpY2tpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNjcm9sbFRvcCBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICAgKi9cbiAgICBvblNjcm9sbENhcHR1cmUoZGF0YSkge1xuICAgICAgICBzdXBlci5vblNjcm9sbENhcHR1cmUoZGF0YSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2F2ZVNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsVG9wICAgICAgID0gZGF0YS5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgICAgID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgeSAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBzdHVja0NhbmRpZGF0ZXMgPSB7fTtcblxuICAgICAgICAgICAgY29uc3QgdHJhdmVyc2UgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5jbikgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgbGV0IGxhc3RGb2xkZXJPcGVuID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIG5vZGUuY24uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50YWcgPT09ICdsaScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jbHMuaW5jbHVkZXMobWUuZm9sZGVyQ2xzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3BTdHlsZSA9IGNoaWxkLnN0eWxlLnRvcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3BTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNTdHVjayA9IHNjcm9sbFRvcCA+IDAgJiYgKHkgLSBzY3JvbGxUb3ApIDw9IHBhcnNlSW50KHRvcFN0eWxlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHVjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxldmVsID0gY2hpbGQubGV2ZWwgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0dWNrQ2FuZGlkYXRlc1tsZXZlbF0gPz89IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R1Y2tDYW5kaWRhdGVzW2xldmVsXS5wdXNoKGNoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNscy5pbmNsdWRlcygnbmVvLXN0dWNrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2hpbGQuY2xzLCAnbmVvLXN0dWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Rm9sZGVyT3BlbiA9IGNoaWxkLmNscy5pbmNsdWRlcygnbmVvLWZvbGRlci1vcGVuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEZvbGRlck9wZW4gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5zdHlsZT8uZGlzcGxheSAhPT0gJ25vbmUnICYmICFjaGlsZC5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IDUxXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQudGFnID09PSAndWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEZvbGRlck9wZW4gJiYgIWNoaWxkLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlKGNoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChtZS52ZG9tLmNuICYmIG1lLnZkb20uY25bMF0pIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZShtZS52ZG9tLmNuWzBdKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHN0dWNrQ2FuZGlkYXRlcykuZm9yRWFjaChpdGVtcyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaG91bGRCZVN0dWNrID0gKGl0ZW0gPT09IGxhc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2xhc3MgICAgICA9IGl0ZW0uY2xzLmluY2x1ZGVzKCduZW8tc3R1Y2snKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQmVTdHVjayAhPT0gaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZShpdGVtLmNscywgJ25lby1zdHVjaycsIHNob3VsZEJlU3R1Y2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5pbmRleFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBvblN0b3JlUmVjb3JkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3JlY29yZH0gICAgICAgICAgICA9IGRhdGEsXG4gICAgICAgICAgICB7aW5kZXgsIHBhcmVudE5vZGV9ID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBtZS5nZXRJdGVtSWQocmVjb3JkLmlkKSk7XG5cbiAgICAgICAgcGFyZW50Tm9kZS5jbltpbmRleF0gPSBtZS5jcmVhdGVJdGVtKHJlY29yZCk7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRyZWUpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==