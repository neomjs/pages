"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_tree_List_mjs"],{

/***/ "./src/selection/TreeModel.mjs"
/*!*************************************!*\
  !*** ./src/selection/TreeModel.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ListModel.mjs */ "./src/selection/ListModel.mjs");


/**
 * @class Neo.selection.TreeModel
 * @extends Neo.selection.ListModel
 */
class TreeModel extends _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.TreeModel'
         * @protected
         */
        className: 'Neo.selection.TreeModel',
        /**
         * @member {String} ntype='selection-treemodel'
         * @protected
         */
        ntype: 'selection-treemodel'
    }

    /**
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        // Neo.log('onKeyDownEnter', data)
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        // Neo.log('onNavKey', data, step)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeModel));


/***/ },

/***/ "./src/tree/List.mjs"
/*!***************************!*\
  !*** ./src/tree/List.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../list/Base.mjs */ "./src/list/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_TreeModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/TreeModel.mjs */ "./src/selection/TreeModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







/**
 * @summary A hierarchical list component supporting nested folders, expansion, and sticky headers.
 *
 * This component renders hierarchical data structures (trees) using a flat store managed by a `Neo.selection.TreeModel`.
 * It provides built-in support for:
 * - **Recursive rendering:** Efficiently renders deeply nested folder structures.
 * - **Collapsible folders:** Interactive expand/collapse functionality for branch nodes.
 * - **Sticky Headers:** Folder headers use CSS `position: sticky` to remain visible while scrolling through their content.
 * - **Stuck State Detection:** When `saveScrollPosition` is enabled, the component tracks the sticky state via JS and applies
 *   a `.neo-stuck` class to headers that are currently pinned. This is useful for visual customization, such as applying
 *   backgrounds to transparent items.
 * - **Drag and Drop:** Supports reordering via `dragResortable` or moving items between lists via `draggable`.
 * - **Filtering:** Deep-filtering that preserves folder structures for matched leaf nodes.
 *
 * Keywords: `Hierarchical Data`, `Tree View`, `Recursive List`, `Sticky Headers`, `Folder View`
 *
 * @class Neo.tree.List
 * @extends Neo.list.Base
 * @see Neo.selection.TreeModel
 */
class Tree extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tree.List'
         * @protected
         */
        className: 'Neo.tree.List',
        /**
         * @member {String} ntype='treelist'
         * @protected
         */
        ntype: 'treelist',
        /**
         * @member {String[]} baseCls=['neo-tree-list']
         */
        baseCls: ['neo-tree-list'],
        /**
         * @member {Boolean} disableSelection=false
         * @reactive
         */
        disableSelection: false,
        /**
         * @member {Boolean} dragResortable_=false
         * @reactive
         */
        dragResortable_: false,
        /**
         * @member {Neo.draggable.tree.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {String} folderCls='neo-list-folder'
         */
        folderCls: 'neo-list-folder',
        /**
         * @member {Boolean} showCollapseExpandAllIcons=true
         */
        showCollapseExpandAllIcons: true,
        /**
         * @member {Neo.draggable.tree.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        sortZoneConfig: null,
        /**
         * @member {String[]} wrapperCls=[]
         * @reactive
         */
        wrapperCls: [],
        /**
         * Set this config to true to monitor the scroll position of the list.
         * This enables the `onScrollCapture` logic which calculates if sticky folder headers
         * are currently in a "stuck" state (pinned to the top), applying the `.neo-stuck` CSS class.
         * Useful for applying visual changes (e.g. background opacity) only when headers are sticking.
         * @member {Boolean} saveScrollPosition=false
         */
        saveScrollPosition: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'ul', cls: ['neo-list-container', 'neo-list'], tabIndex: -1, cn: []}
        ]}
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value) {
            if (me.dragResortable) {
                console.error('tree.List can be either draggable or dragResortable, not both.', me.id)
            } else if (!me.dragZone) {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-src_draggable_tree_DragZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/tree/DragZone.mjs */ "./src/draggable/tree/DragZone.mjs")).then(module => {
                    me.dragZone = Neo.create({
                        module  : module.default,
                        appName : me.appName,
                        owner   : me,
                        windowId: me.windowId,
                        ...me.dragZoneConfig
                    })
                })
            }
        }
    }

    /**
     * Triggered after the dragResortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDragResortable(value, oldValue) {
        let me = this;

        if (value) {
            if (me.draggable) {
                console.error('tree.List can be either draggable or dragResortable, not both.', me.id)
            } else if (!me.sortZone) {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_DragProxyContainer_mjs-src_draggable_tree_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/tree/SortZone.mjs */ "./src/draggable/tree/SortZone.mjs")).then(module => {
                    me.sortZone = Neo.create({
                        module             : module.default,
                        appName            : me.appName,
                        boundaryContainerId: me.id,
                        owner              : me,
                        windowId           : me.windowId,
                        ...me.sortZoneConfig
                    })
                })
            }
        }
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _selection_TreeModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store} value
     * @param {Object|Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        if (!value) {
            value = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
                keyProperty: 'id'
            })
        }

        return super.beforeSetStore(value, oldValue)
    }


    /**
     * Collapses all folders
     * @param {Boolean} [silent]=false Set silent to true to prevent a vnode update
     */
    collapseAll(silent=false) {
        let me       = this,
            hasMatch = false,
            nextSibling, node, parentNode, index;

        me.store.forEach(item => {
            if (!item.isLeaf) {
                node = me.getVdomChild(me.getItemId(item.id), me.vdom);

                if (node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = null;
                    node.style.top      = null;

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = true
                    }

                    hasMatch = true
                }
            }
        });

        if (hasMatch && !silent) {
            me.update()
        }
    }

    /**
     * Creates the VDOM object for a single tree item (leaf or folder).
     *
     * This method is the core VDOM factory for the tree. It constructs the `li` element
     * representing a record. Key responsibilities:
     * 1.  **Class Assignment:** Applies `itemCls`, `folderCls`, and `iconCls` based on record state.
     * 2.  **Hierarchy visualization:** Calculates `zIndex` and `padding` based on depth (`level`).
     * 3.  **Sticky Positioning:** Sets `position: sticky` and calculates `top` offsets for folder nodes
     *     to ensure they stack correctly while scrolling.
     * 4.  **Content:** Creates the label and icon structure.
     *
     * @param {Object} record The data record from the store
     * @returns {Object} The VDOM object for the list item
     */
    createItem(record) {
        let me                   = this,
            {folderCls, itemCls} = me,
            cls                  = [itemCls],
            contentCls           = [itemCls + '-content'],
            keyProperty          = me.getKeyProperty(),
            itemVdom;

        if (record.iconCls) {
            if (Array.isArray(record.iconCls)) {
                contentCls.push(...record.iconCls)
            } else {
                contentCls.push(record.iconCls)
            }
        }

        if (record.isLeaf) {
            cls.push(itemCls + (record.singleton ? '-leaf-singleton' : '-leaf'))
        } else {
            cls.push(folderCls);

            if (!record.collapsed) {
                cls.push('neo-folder-open')
            }
        }

        itemVdom = {
            tag: 'li',
            cls,
            id   : me.getItemId(record[keyProperty]),
            level: record.level,
            cn   : [{
                tag  : 'span',
                cls  : contentCls,
                html : record[me.displayField],
                style: {pointerEvents: 'none'}
            }],
            style: {
                display : record.hidden ? 'none' : 'flex',
                padding : '10px',
                position: (record.isLeaf || record.collapsed) ? null : 'sticky',
                top     : (record.isLeaf || record.collapsed) ? null : (record.level * 38) + 'px',
                zIndex  : record.isLeaf ? 1 : (10000 + record.level)
            }
        };

        if (me.itemsFocusable) {
            itemVdom.tabIndex = -1
        }

        return itemVdom
    }

    /**
     * Recursively generates the VDOM tree structure starting from a given parent.
     *
     * This method implements the recursive logic required to turn a flat store into a
     * hierarchical DOM structure.
     * - It finds all direct children of the `parentId`.
     * - It creates a `ul` container for them.
     * - For each child, it calls `createItem` to generate the node.
     * - It recursively calls itself (`createItemLevel`) for each child to build the next level.
     *
     * This approach ensures that the visual hierarchy matches the data relationship,
     * supporting arbitrary depth.
     *
     * @param {String} [parentId] The parent node id (null for root level)
     * @param {Object} [vdomRoot] The vdom template root for the current sub tree
     * @param {Number} level The current hierarchy level (depth)
     * @param {Boolean} hidden=false Whether this branch is currently hidden (collapsed parent)
     * @returns {Object} vdomRoot
     * @protected
     */
    createItemLevel(parentId, vdomRoot, level, hidden=false) {
        let me    = this,
            items = me.store.find('parentId', parentId),
            tmpRoot;

        if (items.length > 0) {
            if (!vdomRoot.cn) {
                vdomRoot.cn = []
            }

            if (parentId !== null) {
                vdomRoot.cn.push({
                    tag      : 'ul',
                    cls      : ['neo-list'],
                    cn       : [],
                    removeDom: hidden,
                    style    : {
                        paddingLeft: '15px'
                    }
                });

                tmpRoot = vdomRoot.cn[vdomRoot.cn.length - 1]
            } else {
                tmpRoot = vdomRoot
            }

            items.forEach(record => {
                record.level = level;

                tmpRoot.cn.push(me.createItem(record));

                me.createItemLevel(record.id, tmpRoot, level + 1, record.hidden || hidden || record.collapsed)
            })
        }

        return vdomRoot
    }

    /**
     * The main entry point for rendering the tree's content.
     *
     * This method clears the current list content and initiates the recursive rendering process
     * by calling `createItemLevel` starting from the root (null parent).
     * It is typically called when the store is loaded or when a full refresh is needed.
     *
     * @protected
     */
    createItems() {
        let me        = this,
            itemsRoot = me.getListItemsRoot();

        itemsRoot.cn = [];

        me.createItemLevel(null, itemsRoot, 0);
        me.update()
    }

    /**
     * Expands all folders
     * @param {Boolean} silent=false Set silent to true to prevent a vnode update
     */
    expandAll(silent=false) {
        let me       = this,
            hasMatch = false,
            nextSibling, node, parentNode, index;

        me.store.forEach(item => {
            if (!item.isLeaf) {
                node = me.getVdomChild(me.getItemId(item.id), me.vdom);

                if (!node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = 'sticky';
                    node.style.top      = (node.level * 38) + 'px';

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = false
                    }

                    hasMatch = true
                }
            }
        });

        if (hasMatch && !silent) {
            me.update()
        }
    }

    /**
     * Expands all parent nodes of a given item and scrolls it into view once mounted.
     * @param {String|Number} itemId
     * @returns {Promise<void>}
     */
    async expandAndScrollToItem(itemId) {
        let me = this;

        me.expandParents(itemId);

        const
            id   = me.getItemId(itemId),
            rect = await me.waitForDomRect({id, attempts: 20, delay: 50});

        if (rect) {
            me.scrollToItem(itemId)
        }
    }

    /**
     * Expands all parent folders of a given item
     * @param {String|Number} itemId
     */
    expandParents(itemId) {
        let me       = this,
            item     = me.store.get(itemId),
            hasMatch = false,
            nextSibling, node, parentId, parentNode, index;

        if (item) {
            parentId = item.parentId;

            while (parentId) {
                node = me.getVdomChild(me.getItemId(parentId));

                if (node && !node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = 'sticky';
                    node.style.top      = (node.level * 38) + 'px';

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = false
                    }

                    hasMatch = true
                }

                item     = me.store.get(parentId);
                parentId = item ? item.parentId : null
            }
        }

        if (hasMatch) {
            me.update()
        }
    }

    /**
     * Hides Tree nodes which do not match the filter
     * @param {String} property The store field to filter by
     * @param {String} value The filter value
     * @param {Number|null} parentId The root id for the current filter call
     * @param {Boolean} [parentMatch]=false In case a parent folder matches the filter, show its child items
     * @returns {Boolean} false if at least one child item is filtered
     */
    filter(property, value, parentId, parentMatch = false) {
        let me         = this,
            isFiltered = true,
            valueRegEx = new RegExp(value, 'gi'),
            childReturnValue, directMatch, node;

        if (!value) {
            value = ''
        }

        me.store.forEach(item => {
            if (item.parentId === parentId) {
                directMatch = false;
                node        = me.getVdomChild(me.getItemId(item.id), me.vdom);

                node.cn[0].html = item[property].replace(valueRegEx, match => {
                    directMatch = true;
                    return `<span class="neo-highlight-search">${match}</span>`
                });

                if (item.isLeaf) {
                    childReturnValue = true
                } else {
                    childReturnValue = me.filter(property, value, item.id, directMatch || parentMatch)
                }

                if (directMatch || parentMatch || childReturnValue === false || value === '') {
                    isFiltered = false
                }

                node.style.display = isFiltered ? 'none' : 'list-item'
            }
        });

        if (parentId === null) {
            me.expandAll(true);
            me.update()
        }

        return isFiltered
    }

    /**
     * Scrolls a list item into the visible area
     * @param {String|Number} itemId
     */
    scrollToItem(itemId) {
        let me = this;

        Neo.main.DomAccess.scrollIntoView({
            id      : me.getItemId(itemId),
            inline  : 'start',
            windowId: me.windowId
        })
    }

    /**
     * @returns {Object}
     */
    getListItemsRoot() {
        let me = this,
            cn = me.vdom.cn;

        if (cn.length >= 3 && cn[0].cls?.includes('neo-treelist-collapse-all-icon')) {
            return cn[2]
        }

        return cn[0]
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        if (data.target.cls.includes('neo-treelist-menu-item')) {
            this.onMenuItemClick(data.target.cls)
        } else {
            super.onClick(data)
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.showCollapseExpandAllIcons) {
            me.vdom.cn.unshift({
                cls: ['neo-treelist-menu-item', 'neo-treelist-collapse-all-icon'],
                cn : [{
                    tag: 'span',
                    cls: ['neo-treelist-menu-item-content']
                }]
            }, {
                cls: ['neo-treelist-menu-item', 'neo-treelist-expand-all-icon'],
                cn : [{
                    tag: 'span',
                    cls: ['neo-treelist-menu-item-content']
                }]
            });

            me.update()
        }
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me          = this,
            {items}     = me.store,
            i           = 0,
            len         = items.length,
            keyProperty = me.getKeyProperty(),
            path        = data.path.map(e => e.id),
            item, record, tmpItem, vnodeId;

        for (; i < len; i++) {
            tmpItem = items[i];
            vnodeId = me.getItemId(tmpItem[keyProperty]);

            if (path.includes(vnodeId)) {
                record = tmpItem;
                item = me.getVdomChild(vnodeId);
                break
            }
        }

        if (item) {
            if (item.cls?.includes(me.folderCls)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(item.cls, 'neo-folder-open');

                let isOpen              = item.cls.includes('neo-folder-open'),
                    {parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, item.id),
                    nextSibling         = parentNode.cn[index + 1];

                item.style.position = isOpen ? 'sticky' : null;
                item.style.top      = isOpen ? (item.level * 38) + 'px' : null;

                if (nextSibling?.tag === 'ul') {
                    nextSibling.removeDom = !isOpen
                }

                me.update()
            } else {
                me.onLeafItemClick(record);

                /**
                 * The leafItemClick event fires when a click occurs on a list item which does not have child items.
                 * Passes the item record to the event handler.
                 * @event leafItemClick
                 * @returns {Object} record
                 */
                me.fire('leafItemClick', record)
            }

            super.onItemClick(node, data)
        }
    }

    /**
     * Placeholder method
     * @param {Object} record
     */
    onLeafItemClick(record) {

    }

    /**
     * Gets triggered by clicks on the collapse or expand all icons
     * @param {Array} cls
     * @protected
     */
    onMenuItemClick(cls) {
        if (cls.includes('neo-treelist-collapse-all-icon')) {
            this.collapseAll()
        } else {
            this.expandAll()
        }
    }

    /**
     * Captures the scroll stream from the Main Thread to detect sticky states.
     *
     * When `saveScrollPosition` is true, this method calculates which folder headers are currently
     * pinned ("stuck") to the top of the viewport by comparing their computed `top` style with
     * the current `scrollTop`. It toggles the `neo-stuck` class on these items, allowing for
     * conditional styling (e.g. background opacity) only when headers are sticking.
     *
     * @param {Object} data
     * @param {Number} data.scrollTop The current scroll position
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);

        let me = this;

        if (me.saveScrollPosition) {
            let scrollTop       = data.scrollTop,
                needsUpdate     = false,
                y               = 0,
                stuckCandidates = {};

            const traverse = (node) => {
                if (!node.cn) return;

                let lastFolderOpen = true;

                node.cn.forEach(child => {
                    if (child.tag === 'li') {
                        if (child.cls.includes(me.folderCls)) {
                            let topStyle = child.style.top;

                            if (topStyle) {
                                let isStuck = scrollTop > 0 && (y - scrollTop) <= parseInt(topStyle);

                                if (isStuck) {
                                    let level = child.level || 0;
                                    stuckCandidates[level] ??= [];
                                    stuckCandidates[level].push(child)
                                } else {
                                    if (child.cls.includes('neo-stuck')) {
                                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(child.cls, 'neo-stuck');
                                        needsUpdate = true
                                    }
                                }
                            }

                            lastFolderOpen = child.cls.includes('neo-folder-open')
                        } else {
                            lastFolderOpen = true
                        }

                        if (child.style?.display !== 'none' && !child.removeDom) {
                            y += 51
                        }
                    } else if (child.tag === 'ul') {
                        if (lastFolderOpen && !child.removeDom) {
                            traverse(child)
                        }
                    }
                })
            };

            if (me.vdom.cn && me.vdom.cn[0]) {
                traverse(me.vdom.cn[0])
            }

            Object.values(stuckCandidates).forEach(items => {
                let last = items[items.length - 1];

                items.forEach(item => {
                    let shouldBeStuck = (item === last),
                        hasClass      = item.cls.includes('neo-stuck');

                    if (shouldBeStuck !== hasClass) {
                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(item.cls, 'neo-stuck', shouldBeStuck);
                        needsUpdate = true
                    }
                })
            });

            if (needsUpdate) {
                me.update()
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Number} data.index
     * @param {Neo.data.Model} data.model
     * @param {Object} data.record
     */
    onStoreRecordChange(data) {
        let me                  = this,
            {record}            = data,
            {index, parentNode} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, me.getItemId(record.id));

        parentNode.cn[index] = me.createItem(record);

        me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tree));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190cmVlX0xpc3RfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBUztBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx5QkFBeUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENNO0FBQ087QUFDRDtBQUNMO0FBQ1M7QUFDVjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBSTtBQUN2QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVB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bEM7QUFDQSx3Q0FBd0MsdURBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHVEQUFRO0FBQ2hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsbUJBQW1CLEVBQUUsc0RBQVE7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL1RyZWVNb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90cmVlL0xpc3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaXN0TW9kZWwgZnJvbSAnLi9MaXN0TW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uTGlzdE1vZGVsXG4gKi9cbmNsYXNzIFRyZWVNb2RlbCBleHRlbmRzIExpc3RNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLlRyZWVNb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLXRyZWVtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tdHJlZW1vZGVsJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRW50ZXIoZGF0YSkge1xuICAgICAgICAvLyBOZW8ubG9nKCdvbktleURvd25FbnRlcicsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIG9uTmF2S2V5KGRhdGEsIHN0ZXApIHtcbiAgICAgICAgLy8gTmVvLmxvZygnb25OYXZLZXknLCBkYXRhLCBzdGVwKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVHJlZU1vZGVsKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgZnJvbSAnLi4vbGlzdC9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb2xsZWN0aW9uICAgICAgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUcmVlTW9kZWwgICAgICAgZnJvbSAnLi4vc2VsZWN0aW9uL1RyZWVNb2RlbC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICBmcm9tIFwiLi4vdXRpbC9WRG9tLm1qc1wiO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEEgaGllcmFyY2hpY2FsIGxpc3QgY29tcG9uZW50IHN1cHBvcnRpbmcgbmVzdGVkIGZvbGRlcnMsIGV4cGFuc2lvbiwgYW5kIHN0aWNreSBoZWFkZXJzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IHJlbmRlcnMgaGllcmFyY2hpY2FsIGRhdGEgc3RydWN0dXJlcyAodHJlZXMpIHVzaW5nIGEgZmxhdCBzdG9yZSBtYW5hZ2VkIGJ5IGEgYE5lby5zZWxlY3Rpb24uVHJlZU1vZGVsYC5cbiAqIEl0IHByb3ZpZGVzIGJ1aWx0LWluIHN1cHBvcnQgZm9yOlxuICogLSAqKlJlY3Vyc2l2ZSByZW5kZXJpbmc6KiogRWZmaWNpZW50bHkgcmVuZGVycyBkZWVwbHkgbmVzdGVkIGZvbGRlciBzdHJ1Y3R1cmVzLlxuICogLSAqKkNvbGxhcHNpYmxlIGZvbGRlcnM6KiogSW50ZXJhY3RpdmUgZXhwYW5kL2NvbGxhcHNlIGZ1bmN0aW9uYWxpdHkgZm9yIGJyYW5jaCBub2Rlcy5cbiAqIC0gKipTdGlja3kgSGVhZGVyczoqKiBGb2xkZXIgaGVhZGVycyB1c2UgQ1NTIGBwb3NpdGlvbjogc3RpY2t5YCB0byByZW1haW4gdmlzaWJsZSB3aGlsZSBzY3JvbGxpbmcgdGhyb3VnaCB0aGVpciBjb250ZW50LlxuICogLSAqKlN0dWNrIFN0YXRlIERldGVjdGlvbjoqKiBXaGVuIGBzYXZlU2Nyb2xsUG9zaXRpb25gIGlzIGVuYWJsZWQsIHRoZSBjb21wb25lbnQgdHJhY2tzIHRoZSBzdGlja3kgc3RhdGUgdmlhIEpTIGFuZCBhcHBsaWVzXG4gKiAgIGEgYC5uZW8tc3R1Y2tgIGNsYXNzIHRvIGhlYWRlcnMgdGhhdCBhcmUgY3VycmVudGx5IHBpbm5lZC4gVGhpcyBpcyB1c2VmdWwgZm9yIHZpc3VhbCBjdXN0b21pemF0aW9uLCBzdWNoIGFzIGFwcGx5aW5nXG4gKiAgIGJhY2tncm91bmRzIHRvIHRyYW5zcGFyZW50IGl0ZW1zLlxuICogLSAqKkRyYWcgYW5kIERyb3A6KiogU3VwcG9ydHMgcmVvcmRlcmluZyB2aWEgYGRyYWdSZXNvcnRhYmxlYCBvciBtb3ZpbmcgaXRlbXMgYmV0d2VlbiBsaXN0cyB2aWEgYGRyYWdnYWJsZWAuXG4gKiAtICoqRmlsdGVyaW5nOioqIERlZXAtZmlsdGVyaW5nIHRoYXQgcHJlc2VydmVzIGZvbGRlciBzdHJ1Y3R1cmVzIGZvciBtYXRjaGVkIGxlYWYgbm9kZXMuXG4gKlxuICogS2V5d29yZHM6IGBIaWVyYXJjaGljYWwgRGF0YWAsIGBUcmVlIFZpZXdgLCBgUmVjdXJzaXZlIExpc3RgLCBgU3RpY2t5IEhlYWRlcnNgLCBgRm9sZGVyIFZpZXdgXG4gKlxuICogQGNsYXNzIE5lby50cmVlLkxpc3RcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqIEBzZWUgTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWxcbiAqL1xuY2xhc3MgVHJlZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRyZWUuTGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRyZWUuTGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0cmVlbGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0cmVlbGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10cmVlLWxpc3QnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdHJlZS1saXN0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlU2VsZWN0aW9uPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZVNlbGVjdGlvbjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnUmVzb3J0YWJsZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUmVzb3J0YWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS50cmVlLkRyYWdab25lfG51bGx9IGRyYWdab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmb2xkZXJDbHM9J25lby1saXN0LWZvbGRlcidcbiAgICAgICAgICovXG4gICAgICAgIGZvbGRlckNsczogJ25lby1saXN0LWZvbGRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29uczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUudHJlZS5Tb3J0Wm9uZXxudWxsfSBzb3J0Wm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZHJhZ1pvbmVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gd3JhcHBlckNscz1bXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBwZXJDbHM6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgdG8gbW9uaXRvciB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKiBUaGlzIGVuYWJsZXMgdGhlIGBvblNjcm9sbENhcHR1cmVgIGxvZ2ljIHdoaWNoIGNhbGN1bGF0ZXMgaWYgc3RpY2t5IGZvbGRlciBoZWFkZXJzXG4gICAgICAgICAqIGFyZSBjdXJyZW50bHkgaW4gYSBcInN0dWNrXCIgc3RhdGUgKHBpbm5lZCB0byB0aGUgdG9wKSwgYXBwbHlpbmcgdGhlIGAubmVvLXN0dWNrYCBDU1MgY2xhc3MuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgYXBwbHlpbmcgdmlzdWFsIGNoYW5nZXMgKGUuZy4gYmFja2dyb3VuZCBvcGFjaXR5KSBvbmx5IHdoZW4gaGVhZGVycyBhcmUgc3RpY2tpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNhdmVTY3JvbGxQb3NpdGlvbj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2F2ZVNjcm9sbFBvc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHt0YWc6ICd1bCcsIGNsczogWyduZW8tbGlzdC1jb250YWluZXInLCAnbmVvLWxpc3QnXSwgdGFiSW5kZXg6IC0xLCBjbjogW119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnZ2FibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWUuZHJhZ1Jlc29ydGFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmVlLkxpc3QgY2FuIGJlIGVpdGhlciBkcmFnZ2FibGUgb3IgZHJhZ1Jlc29ydGFibGUsIG5vdCBib3RoLicsIG1lLmlkKVxuICAgICAgICAgICAgfSBlbHNlIGlmICghbWUuZHJhZ1pvbmUpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4uL2RyYWdnYWJsZS90cmVlL0RyYWdab25lLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWUuZHJhZ1pvbmVDb25maWdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnUmVzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyYWdSZXNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1lLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyZWUuTGlzdCBjYW4gYmUgZWl0aGVyIGRyYWdnYWJsZSBvciBkcmFnUmVzb3J0YWJsZSwgbm90IGJvdGguJywgbWUuaWQpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtZS5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3RyZWUvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5zb3J0Wm9uZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWUuc29ydFpvbmVDb25maWdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uc2VsZWN0aW9uLk1vZGVsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBUcmVlTW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE5lby5jcmVhdGUoQ29sbGVjdGlvbiwge1xuICAgICAgICAgICAgICAgIGtleVByb3BlcnR5OiAnaWQnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhbGwgZm9sZGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudF09ZmFsc2UgU2V0IHNpbGVudCB0byB0cnVlIHRvIHByZXZlbnQgYSB2bm9kZSB1cGRhdGVcbiAgICAgKi9cbiAgICBjb2xsYXBzZUFsbChzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0U2libGluZywgbm9kZSwgcGFyZW50Tm9kZSwgaW5kZXg7XG5cbiAgICAgICAgbWUuc3RvcmUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWUuZ2V0VmRvbUNoaWxkKG1lLmdldEl0ZW1JZChpdGVtLmlkKSwgbWUudmRvbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jbHMuaW5jbHVkZXMoJ25lby1mb2xkZXItb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShub2RlLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICh7cGFyZW50Tm9kZSwgaW5kZXh9ID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBub2RlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nICAgICAgICAgID0gcGFyZW50Tm9kZS5jbltpbmRleCArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnRvcCAgICAgID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmc/LnRhZyA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzTWF0Y2ggJiYgIXNpbGVudCkge1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFZET00gb2JqZWN0IGZvciBhIHNpbmdsZSB0cmVlIGl0ZW0gKGxlYWYgb3IgZm9sZGVyKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSBjb3JlIFZET00gZmFjdG9yeSBmb3IgdGhlIHRyZWUuIEl0IGNvbnN0cnVjdHMgdGhlIGBsaWAgZWxlbWVudFxuICAgICAqIHJlcHJlc2VudGluZyBhIHJlY29yZC4gS2V5IHJlc3BvbnNpYmlsaXRpZXM6XG4gICAgICogMS4gICoqQ2xhc3MgQXNzaWdubWVudDoqKiBBcHBsaWVzIGBpdGVtQ2xzYCwgYGZvbGRlckNsc2AsIGFuZCBgaWNvbkNsc2AgYmFzZWQgb24gcmVjb3JkIHN0YXRlLlxuICAgICAqIDIuICAqKkhpZXJhcmNoeSB2aXN1YWxpemF0aW9uOioqIENhbGN1bGF0ZXMgYHpJbmRleGAgYW5kIGBwYWRkaW5nYCBiYXNlZCBvbiBkZXB0aCAoYGxldmVsYCkuXG4gICAgICogMy4gICoqU3RpY2t5IFBvc2l0aW9uaW5nOioqIFNldHMgYHBvc2l0aW9uOiBzdGlja3lgIGFuZCBjYWxjdWxhdGVzIGB0b3BgIG9mZnNldHMgZm9yIGZvbGRlciBub2Rlc1xuICAgICAqICAgICB0byBlbnN1cmUgdGhleSBzdGFjayBjb3JyZWN0bHkgd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIDQuICAqKkNvbnRlbnQ6KiogQ3JlYXRlcyB0aGUgbGFiZWwgYW5kIGljb24gc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCBUaGUgZGF0YSByZWNvcmQgZnJvbSB0aGUgc3RvcmVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgVkRPTSBvYmplY3QgZm9yIHRoZSBsaXN0IGl0ZW1cbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtKHJlY29yZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2ZvbGRlckNscywgaXRlbUNsc30gPSBtZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgICAgID0gW2l0ZW1DbHNdLFxuICAgICAgICAgICAgY29udGVudENscyAgICAgICAgICAgPSBbaXRlbUNscyArICctY29udGVudCddLFxuICAgICAgICAgICAga2V5UHJvcGVydHkgICAgICAgICAgPSBtZS5nZXRLZXlQcm9wZXJ0eSgpLFxuICAgICAgICAgICAgaXRlbVZkb207XG5cbiAgICAgICAgaWYgKHJlY29yZC5pY29uQ2xzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWNvcmQuaWNvbkNscykpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q2xzLnB1c2goLi4ucmVjb3JkLmljb25DbHMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRDbHMucHVzaChyZWNvcmQuaWNvbkNscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQuaXNMZWFmKSB7XG4gICAgICAgICAgICBjbHMucHVzaChpdGVtQ2xzICsgKHJlY29yZC5zaW5nbGV0b24gPyAnLWxlYWYtc2luZ2xldG9uJyA6ICctbGVhZicpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xzLnB1c2goZm9sZGVyQ2xzKTtcblxuICAgICAgICAgICAgaWYgKCFyZWNvcmQuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgY2xzLnB1c2goJ25lby1mb2xkZXItb3BlbicpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtVmRvbSA9IHtcbiAgICAgICAgICAgIHRhZzogJ2xpJyxcbiAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRJdGVtSWQocmVjb3JkW2tleVByb3BlcnR5XSksXG4gICAgICAgICAgICBsZXZlbDogcmVjb3JkLmxldmVsLFxuICAgICAgICAgICAgY24gICA6IFt7XG4gICAgICAgICAgICAgICAgdGFnICA6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICBjbHMgIDogY29udGVudENscyxcbiAgICAgICAgICAgICAgICBodG1sIDogcmVjb3JkW21lLmRpc3BsYXlGaWVsZF0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtwb2ludGVyRXZlbnRzOiAnbm9uZSd9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheSA6IHJlY29yZC5oaWRkZW4gPyAnbm9uZScgOiAnZmxleCcsXG4gICAgICAgICAgICAgICAgcGFkZGluZyA6ICcxMHB4JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogKHJlY29yZC5pc0xlYWYgfHwgcmVjb3JkLmNvbGxhcHNlZCkgPyBudWxsIDogJ3N0aWNreScsXG4gICAgICAgICAgICAgICAgdG9wICAgICA6IChyZWNvcmQuaXNMZWFmIHx8IHJlY29yZC5jb2xsYXBzZWQpID8gbnVsbCA6IChyZWNvcmQubGV2ZWwgKiAzOCkgKyAncHgnLFxuICAgICAgICAgICAgICAgIHpJbmRleCAgOiByZWNvcmQuaXNMZWFmID8gMSA6ICgxMDAwMCArIHJlY29yZC5sZXZlbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWUuaXRlbXNGb2N1c2FibGUpIHtcbiAgICAgICAgICAgIGl0ZW1WZG9tLnRhYkluZGV4ID0gLTFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtVmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGdlbmVyYXRlcyB0aGUgVkRPTSB0cmVlIHN0cnVjdHVyZSBzdGFydGluZyBmcm9tIGEgZ2l2ZW4gcGFyZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgcmVjdXJzaXZlIGxvZ2ljIHJlcXVpcmVkIHRvIHR1cm4gYSBmbGF0IHN0b3JlIGludG8gYVxuICAgICAqIGhpZXJhcmNoaWNhbCBET00gc3RydWN0dXJlLlxuICAgICAqIC0gSXQgZmluZHMgYWxsIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGUgYHBhcmVudElkYC5cbiAgICAgKiAtIEl0IGNyZWF0ZXMgYSBgdWxgIGNvbnRhaW5lciBmb3IgdGhlbS5cbiAgICAgKiAtIEZvciBlYWNoIGNoaWxkLCBpdCBjYWxscyBgY3JlYXRlSXRlbWAgdG8gZ2VuZXJhdGUgdGhlIG5vZGUuXG4gICAgICogLSBJdCByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgKGBjcmVhdGVJdGVtTGV2ZWxgKSBmb3IgZWFjaCBjaGlsZCB0byBidWlsZCB0aGUgbmV4dCBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgYXBwcm9hY2ggZW5zdXJlcyB0aGF0IHRoZSB2aXN1YWwgaGllcmFyY2h5IG1hdGNoZXMgdGhlIGRhdGEgcmVsYXRpb25zaGlwLFxuICAgICAqIHN1cHBvcnRpbmcgYXJiaXRyYXJ5IGRlcHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJlbnRJZF0gVGhlIHBhcmVudCBub2RlIGlkIChudWxsIGZvciByb290IGxldmVsKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbVJvb3RdIFRoZSB2ZG9tIHRlbXBsYXRlIHJvb3QgZm9yIHRoZSBjdXJyZW50IHN1YiB0cmVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBjdXJyZW50IGhpZXJhcmNoeSBsZXZlbCAoZGVwdGgpXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBoaWRkZW49ZmFsc2UgV2hldGhlciB0aGlzIGJyYW5jaCBpcyBjdXJyZW50bHkgaGlkZGVuIChjb2xsYXBzZWQgcGFyZW50KVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21Sb290XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1MZXZlbChwYXJlbnRJZCwgdmRvbVJvb3QsIGxldmVsLCBoaWRkZW49ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zID0gbWUuc3RvcmUuZmluZCgncGFyZW50SWQnLCBwYXJlbnRJZCksXG4gICAgICAgICAgICB0bXBSb290O1xuXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXZkb21Sb290LmNuKSB7XG4gICAgICAgICAgICAgICAgdmRvbVJvb3QuY24gPSBbXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2ZG9tUm9vdC5jbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFnICAgICAgOiAndWwnLFxuICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWxpc3QnXSxcbiAgICAgICAgICAgICAgICAgICAgY24gICAgICAgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiBoaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICcxNXB4J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0bXBSb290ID0gdmRvbVJvb3QuY25bdmRvbVJvb3QuY24ubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wUm9vdCA9IHZkb21Sb290XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2gocmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICByZWNvcmQubGV2ZWwgPSBsZXZlbDtcblxuICAgICAgICAgICAgICAgIHRtcFJvb3QuY24ucHVzaChtZS5jcmVhdGVJdGVtKHJlY29yZCkpO1xuXG4gICAgICAgICAgICAgICAgbWUuY3JlYXRlSXRlbUxldmVsKHJlY29yZC5pZCwgdG1wUm9vdCwgbGV2ZWwgKyAxLCByZWNvcmQuaGlkZGVuIHx8IGhpZGRlbiB8fCByZWNvcmQuY29sbGFwc2VkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZG9tUm9vdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGVudHJ5IHBvaW50IGZvciByZW5kZXJpbmcgdGhlIHRyZWUncyBjb250ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2xlYXJzIHRoZSBjdXJyZW50IGxpc3QgY29udGVudCBhbmQgaW5pdGlhdGVzIHRoZSByZWN1cnNpdmUgcmVuZGVyaW5nIHByb2Nlc3NcbiAgICAgKiBieSBjYWxsaW5nIGBjcmVhdGVJdGVtTGV2ZWxgIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QgKG51bGwgcGFyZW50KS5cbiAgICAgKiBJdCBpcyB0eXBpY2FsbHkgY2FsbGVkIHdoZW4gdGhlIHN0b3JlIGlzIGxvYWRlZCBvciB3aGVuIGEgZnVsbCByZWZyZXNoIGlzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtc1Jvb3QgPSBtZS5nZXRMaXN0SXRlbXNSb290KCk7XG5cbiAgICAgICAgaXRlbXNSb290LmNuID0gW107XG5cbiAgICAgICAgbWUuY3JlYXRlSXRlbUxldmVsKG51bGwsIGl0ZW1zUm9vdCwgMCk7XG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgZm9sZGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlIFNldCBzaWxlbnQgdG8gdHJ1ZSB0byBwcmV2ZW50IGEgdm5vZGUgdXBkYXRlXG4gICAgICovXG4gICAgZXhwYW5kQWxsKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZSxcbiAgICAgICAgICAgIG5leHRTaWJsaW5nLCBub2RlLCBwYXJlbnROb2RlLCBpbmRleDtcblxuICAgICAgICBtZS5zdG9yZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFpdGVtLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtZS5nZXRWZG9tQ2hpbGQobWUuZ2V0SXRlbUlkKGl0ZW0uaWQpLCBtZS52ZG9tKTtcblxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5jbHMuaW5jbHVkZXMoJ25lby1mb2xkZXItb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChub2RlLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICh7cGFyZW50Tm9kZSwgaW5kZXh9ID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBub2RlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nICAgICAgICAgID0gcGFyZW50Tm9kZS5jbltpbmRleCArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnc3RpY2t5JztcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgICAgICA9IChub2RlLmxldmVsICogMzgpICsgJ3B4JztcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmc/LnRhZyA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlRG9tID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc01hdGNoICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFsbCBwYXJlbnQgbm9kZXMgb2YgYSBnaXZlbiBpdGVtIGFuZCBzY3JvbGxzIGl0IGludG8gdmlldyBvbmNlIG1vdW50ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpdGVtSWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBleHBhbmRBbmRTY3JvbGxUb0l0ZW0oaXRlbUlkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZXhwYW5kUGFyZW50cyhpdGVtSWQpO1xuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBpZCAgID0gbWUuZ2V0SXRlbUlkKGl0ZW1JZCksXG4gICAgICAgICAgICByZWN0ID0gYXdhaXQgbWUud2FpdEZvckRvbVJlY3Qoe2lkLCBhdHRlbXB0czogMjAsIGRlbGF5OiA1MH0pO1xuXG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICBtZS5zY3JvbGxUb0l0ZW0oaXRlbUlkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgcGFyZW50IGZvbGRlcnMgb2YgYSBnaXZlbiBpdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpdGVtSWRcbiAgICAgKi9cbiAgICBleHBhbmRQYXJlbnRzKGl0ZW1JZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSAgICAgPSBtZS5zdG9yZS5nZXQoaXRlbUlkKSxcbiAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0U2libGluZywgbm9kZSwgcGFyZW50SWQsIHBhcmVudE5vZGUsIGluZGV4O1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBwYXJlbnRJZCA9IGl0ZW0ucGFyZW50SWQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtZS5nZXRWZG9tQ2hpbGQobWUuZ2V0SXRlbUlkKHBhcmVudElkKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiAhbm9kZS5jbHMuaW5jbHVkZXMoJ25lby1mb2xkZXItb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LmFkZChub2RlLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICh7cGFyZW50Tm9kZSwgaW5kZXh9ID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBub2RlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nICAgICAgICAgID0gcGFyZW50Tm9kZS5jbltpbmRleCArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnc3RpY2t5JztcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgICAgICA9IChub2RlLmxldmVsICogMzgpICsgJ3B4JztcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmc/LnRhZyA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlRG9tID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0gICAgID0gbWUuc3RvcmUuZ2V0KHBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCA9IGl0ZW0gPyBpdGVtLnBhcmVudElkIDogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc01hdGNoKSB7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZXMgVHJlZSBub2RlcyB3aGljaCBkbyBub3QgbWF0Y2ggdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBUaGUgc3RvcmUgZmllbGQgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBmaWx0ZXIgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBwYXJlbnRJZCBUaGUgcm9vdCBpZCBmb3IgdGhlIGN1cnJlbnQgZmlsdGVyIGNhbGxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJlbnRNYXRjaF09ZmFsc2UgSW4gY2FzZSBhIHBhcmVudCBmb2xkZXIgbWF0Y2hlcyB0aGUgZmlsdGVyLCBzaG93IGl0cyBjaGlsZCBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBmYWxzZSBpZiBhdCBsZWFzdCBvbmUgY2hpbGQgaXRlbSBpcyBmaWx0ZXJlZFxuICAgICAqL1xuICAgIGZpbHRlcihwcm9wZXJ0eSwgdmFsdWUsIHBhcmVudElkLCBwYXJlbnRNYXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlzRmlsdGVyZWQgPSB0cnVlLFxuICAgICAgICAgICAgdmFsdWVSZWdFeCA9IG5ldyBSZWdFeHAodmFsdWUsICdnaScpLFxuICAgICAgICAgICAgY2hpbGRSZXR1cm5WYWx1ZSwgZGlyZWN0TWF0Y2gsIG5vZGU7XG5cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuc3RvcmUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudElkID09PSBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZSAgICAgICAgPSBtZS5nZXRWZG9tQ2hpbGQobWUuZ2V0SXRlbUlkKGl0ZW0uaWQpLCBtZS52ZG9tKTtcblxuICAgICAgICAgICAgICAgIG5vZGUuY25bMF0uaHRtbCA9IGl0ZW1bcHJvcGVydHldLnJlcGxhY2UodmFsdWVSZWdFeCwgbWF0Y2ggPT4ge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCJuZW8taGlnaGxpZ2h0LXNlYXJjaFwiPiR7bWF0Y2h9PC9zcGFuPmBcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzTGVhZikge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFJldHVyblZhbHVlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUmV0dXJuVmFsdWUgPSBtZS5maWx0ZXIocHJvcGVydHksIHZhbHVlLCBpdGVtLmlkLCBkaXJlY3RNYXRjaCB8fCBwYXJlbnRNYXRjaClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0TWF0Y2ggfHwgcGFyZW50TWF0Y2ggfHwgY2hpbGRSZXR1cm5WYWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlsdGVyZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9IGlzRmlsdGVyZWQgPyAnbm9uZScgOiAnbGlzdC1pdGVtJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocGFyZW50SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lLmV4cGFuZEFsbCh0cnVlKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNGaWx0ZXJlZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYSBsaXN0IGl0ZW0gaW50byB0aGUgdmlzaWJsZSBhcmVhXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpdGVtSWRcbiAgICAgKi9cbiAgICBzY3JvbGxUb0l0ZW0oaXRlbUlkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgIGlkICAgICAgOiBtZS5nZXRJdGVtSWQoaXRlbUlkKSxcbiAgICAgICAgICAgIGlubGluZSAgOiAnc3RhcnQnLFxuICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMaXN0SXRlbXNSb290KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY24gPSBtZS52ZG9tLmNuO1xuXG4gICAgICAgIGlmIChjbi5sZW5ndGggPj0gMyAmJiBjblswXS5jbHM/LmluY2x1ZGVzKCduZW8tdHJlZWxpc3QtY29sbGFwc2UtYWxsLWljb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNuWzJdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY25bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS50YXJnZXQuY2xzLmluY2x1ZGVzKCduZW8tdHJlZWxpc3QtbWVudS1pdGVtJykpIHtcbiAgICAgICAgICAgIHRoaXMub25NZW51SXRlbUNsaWNrKGRhdGEudGFyZ2V0LmNscylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLm9uQ2xpY2soZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnNob3dDb2xsYXBzZUV4cGFuZEFsbEljb25zKSB7XG4gICAgICAgICAgICBtZS52ZG9tLmNuLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgIGNsczogWyduZW8tdHJlZWxpc3QtbWVudS1pdGVtJywgJ25lby10cmVlbGlzdC1jb2xsYXBzZS1hbGwtaWNvbiddLFxuICAgICAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIGNsczogWyduZW8tdHJlZWxpc3QtbWVudS1pdGVtLWNvbnRlbnQnXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY2xzOiBbJ25lby10cmVlbGlzdC1tZW51LWl0ZW0nLCAnbmVvLXRyZWVsaXN0LWV4cGFuZC1hbGwtaWNvbiddLFxuICAgICAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIGNsczogWyduZW8tdHJlZWxpc3QtbWVudS1pdGVtLWNvbnRlbnQnXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkl0ZW1DbGljayhub2RlLCBkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aXRlbXN9ICAgICA9IG1lLnN0b3JlLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBrZXlQcm9wZXJ0eSA9IG1lLmdldEtleVByb3BlcnR5KCksXG4gICAgICAgICAgICBwYXRoICAgICAgICA9IGRhdGEucGF0aC5tYXAoZSA9PiBlLmlkKSxcbiAgICAgICAgICAgIGl0ZW0sIHJlY29yZCwgdG1wSXRlbSwgdm5vZGVJZDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0bXBJdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICB2bm9kZUlkID0gbWUuZ2V0SXRlbUlkKHRtcEl0ZW1ba2V5UHJvcGVydHldKTtcblxuICAgICAgICAgICAgaWYgKHBhdGguaW5jbHVkZXModm5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQgPSB0bXBJdGVtO1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBtZS5nZXRWZG9tQ2hpbGQodm5vZGVJZCk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5jbHM/LmluY2x1ZGVzKG1lLmZvbGRlckNscykpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS50b2dnbGUoaXRlbS5jbHMsICduZW8tZm9sZGVyLW9wZW4nKTtcblxuICAgICAgICAgICAgICAgIGxldCBpc09wZW4gICAgICAgICAgICAgID0gaXRlbS5jbHMuaW5jbHVkZXMoJ25lby1mb2xkZXItb3BlbicpLFxuICAgICAgICAgICAgICAgICAgICB7cGFyZW50Tm9kZSwgaW5kZXh9ID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBpdGVtLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgICAgICAgICA9IHBhcmVudE5vZGUuY25baW5kZXggKyAxXTtcblxuICAgICAgICAgICAgICAgIGl0ZW0uc3R5bGUucG9zaXRpb24gPSBpc09wZW4gPyAnc3RpY2t5JyA6IG51bGw7XG4gICAgICAgICAgICAgICAgaXRlbS5zdHlsZS50b3AgICAgICA9IGlzT3BlbiA/IChpdGVtLmxldmVsICogMzgpICsgJ3B4JyA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmc/LnRhZyA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZy5yZW1vdmVEb20gPSAhaXNPcGVuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUub25MZWFmSXRlbUNsaWNrKHJlY29yZCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgbGVhZkl0ZW1DbGljayBldmVudCBmaXJlcyB3aGVuIGEgY2xpY2sgb2NjdXJzIG9uIGEgbGlzdCBpdGVtIHdoaWNoIGRvZXMgbm90IGhhdmUgY2hpbGQgaXRlbXMuXG4gICAgICAgICAgICAgICAgICogUGFzc2VzIHRoZSBpdGVtIHJlY29yZCB0byB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgbGVhZkl0ZW1DbGlja1xuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlY29yZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2xlYWZJdGVtQ2xpY2snLCByZWNvcmQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN1cGVyLm9uSXRlbUNsaWNrKG5vZGUsIGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICovXG4gICAgb25MZWFmSXRlbUNsaWNrKHJlY29yZCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYnkgY2xpY2tzIG9uIHRoZSBjb2xsYXBzZSBvciBleHBhbmQgYWxsIGljb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2xzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uTWVudUl0ZW1DbGljayhjbHMpIHtcbiAgICAgICAgaWYgKGNscy5pbmNsdWRlcygnbmVvLXRyZWVsaXN0LWNvbGxhcHNlLWFsbC1pY29uJykpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2VBbGwoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRBbGwoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FwdHVyZXMgdGhlIHNjcm9sbCBzdHJlYW0gZnJvbSB0aGUgTWFpbiBUaHJlYWQgdG8gZGV0ZWN0IHN0aWNreSBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGBzYXZlU2Nyb2xsUG9zaXRpb25gIGlzIHRydWUsIHRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgd2hpY2ggZm9sZGVyIGhlYWRlcnMgYXJlIGN1cnJlbnRseVxuICAgICAqIHBpbm5lZCAoXCJzdHVja1wiKSB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydCBieSBjb21wYXJpbmcgdGhlaXIgY29tcHV0ZWQgYHRvcGAgc3R5bGUgd2l0aFxuICAgICAqIHRoZSBjdXJyZW50IGBzY3JvbGxUb3BgLiBJdCB0b2dnbGVzIHRoZSBgbmVvLXN0dWNrYCBjbGFzcyBvbiB0aGVzZSBpdGVtcywgYWxsb3dpbmcgZm9yXG4gICAgICogY29uZGl0aW9uYWwgc3R5bGluZyAoZS5nLiBiYWNrZ3JvdW5kIG9wYWNpdHkpIG9ubHkgd2hlbiBoZWFkZXJzIGFyZSBzdGlja2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2Nyb2xsVG9wIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgICAqL1xuICAgIG9uU2Nyb2xsQ2FwdHVyZShkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uU2Nyb2xsQ2FwdHVyZShkYXRhKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5zYXZlU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGxldCBzY3JvbGxUb3AgICAgICAgPSBkYXRhLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB5ICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIHN0dWNrQ2FuZGlkYXRlcyA9IHt9O1xuXG4gICAgICAgICAgICBjb25zdCB0cmF2ZXJzZSA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmNuKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBsZXQgbGFzdEZvbGRlck9wZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbm9kZS5jbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2xpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNscy5pbmNsdWRlcyhtZS5mb2xkZXJDbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvcFN0eWxlID0gY2hpbGQuc3R5bGUudG9wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1N0dWNrID0gc2Nyb2xsVG9wID4gMCAmJiAoeSAtIHNjcm9sbFRvcCkgPD0gcGFyc2VJbnQodG9wU3R5bGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0dWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGV2ZWwgPSBjaGlsZC5sZXZlbCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R1Y2tDYW5kaWRhdGVzW2xldmVsXSA/Pz0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHVja0NhbmRpZGF0ZXNbbGV2ZWxdLnB1c2goY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2xzLmluY2x1ZGVzKCduZW8tc3R1Y2snKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjaGlsZC5jbHMsICduZW8tc3R1Y2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RGb2xkZXJPcGVuID0gY2hpbGQuY2xzLmluY2x1ZGVzKCduZW8tZm9sZGVyLW9wZW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Rm9sZGVyT3BlbiA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnN0eWxlPy5kaXNwbGF5ICE9PSAnbm9uZScgJiYgIWNoaWxkLnJlbW92ZURvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gNTFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC50YWcgPT09ICd1bCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Rm9sZGVyT3BlbiAmJiAhY2hpbGQucmVtb3ZlRG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2UoY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG1lLnZkb20uY24gJiYgbWUudmRvbS5jblswXSkge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlKG1lLnZkb20uY25bMF0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMoc3R1Y2tDYW5kaWRhdGVzKS5mb3JFYWNoKGl0ZW1zID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNob3VsZEJlU3R1Y2sgPSAoaXRlbSA9PT0gbGFzdCksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyAgICAgID0gaXRlbS5jbHMuaW5jbHVkZXMoJ25lby1zdHVjaycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRCZVN0dWNrICE9PSBoYXNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGl0ZW0uY2xzLCAnbmVvLXN0dWNrJywgc2hvdWxkQmVTdHVjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5maWVsZHMgRWFjaCBmaWVsZCBvYmplY3QgY29udGFpbnMgdGhlIGtleXM6IG5hbWUsIG9sZFZhbHVlLCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmluZGV4XG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnJlY29yZFxuICAgICAqL1xuICAgIG9uU3RvcmVSZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVjb3JkfSAgICAgICAgICAgID0gZGF0YSxcbiAgICAgICAgICAgIHtpbmRleCwgcGFyZW50Tm9kZX0gPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIG1lLmdldEl0ZW1JZChyZWNvcmQuaWQpKTtcblxuICAgICAgICBwYXJlbnROb2RlLmNuW2luZGV4XSA9IG1lLmNyZWF0ZUl0ZW0ocmVjb3JkKTtcblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVHJlZSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9