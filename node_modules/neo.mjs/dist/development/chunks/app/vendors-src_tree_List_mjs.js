"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_tree_List_mjs"],{

/***/ "./src/selection/TreeModel.mjs"
/*!*************************************!*\
  !*** ./src/selection/TreeModel.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ListModel.mjs */ "./src/selection/ListModel.mjs");


/**
 * @class Neo.selection.TreeModel
 * @extends Neo.selection.ListModel
 */
class TreeModel extends _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.TreeModel'
         * @protected
         */
        className: 'Neo.selection.TreeModel',
        /**
         * @member {String} ntype='selection-treemodel'
         * @protected
         */
        ntype: 'selection-treemodel'
    }

    /**
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        // Neo.log('onKeyDownEnter', data)
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        // Neo.log('onNavKey', data, step)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeModel));


/***/ },

/***/ "./src/tree/List.mjs"
/*!***************************!*\
  !*** ./src/tree/List.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../list/Base.mjs */ "./src/list/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_TreeModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/TreeModel.mjs */ "./src/selection/TreeModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







/**
 * @summary A hierarchical list component supporting nested folders, expansion, and sticky headers.
 *
 * This component renders hierarchical data structures (trees) using a flat store managed by a `Neo.selection.TreeModel`.
 * It provides built-in support for:
 * - **Recursive rendering:** Efficiently renders deeply nested folder structures.
 * - **Collapsible folders:** Interactive expand/collapse functionality for branch nodes.
 * - **Sticky Headers:** Folder headers use CSS `position: sticky` to remain visible while scrolling through their content.
 * - **Stuck State Detection:** When `saveScrollPosition` is enabled, the component tracks the sticky state via JS and applies
 *   a `.neo-stuck` class to headers that are currently pinned. This is useful for visual customization, such as applying
 *   backgrounds to transparent items.
 * - **Drag and Drop:** Supports reordering via `dragResortable` or moving items between lists via `draggable`.
 * - **Filtering:** Deep-filtering that preserves folder structures for matched leaf nodes.
 *
 * Keywords: `Hierarchical Data`, `Tree View`, `Recursive List`, `Sticky Headers`, `Folder View`
 *
 * @class Neo.tree.List
 * @extends Neo.list.Base
 * @see Neo.selection.TreeModel
 */
class Tree extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tree.List'
         * @protected
         */
        className: 'Neo.tree.List',
        /**
         * @member {String} ntype='treelist'
         * @protected
         */
        ntype: 'treelist',
        /**
         * @member {String[]} baseCls=['neo-tree-list']
         */
        baseCls: ['neo-tree-list'],
        /**
         * @member {Boolean} disableSelection=false
         * @reactive
         */
        disableSelection: false,
        /**
         * @member {Boolean} dragResortable_=false
         * @reactive
         */
        dragResortable_: false,
        /**
         * @member {Neo.draggable.tree.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {String} folderCls='neo-list-folder'
         */
        folderCls: 'neo-list-folder',
        /**
         * @member {Boolean} showCollapseExpandAllIcons=true
         */
        showCollapseExpandAllIcons: true,
        /**
         * @member {Neo.draggable.tree.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        sortZoneConfig: null,
        /**
         * @member {String[]} wrapperCls=[]
         * @reactive
         */
        wrapperCls: [],
        /**
         * Set this config to true to monitor the scroll position of the list.
         * This enables the `onScrollCapture` logic which calculates if sticky folder headers
         * are currently in a "stuck" state (pinned to the top), applying the `.neo-stuck` CSS class.
         * Useful for applying visual changes (e.g. background opacity) only when headers are sticking.
         * @member {Boolean} saveScrollPosition=false
         */
        saveScrollPosition: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'ul', cls: ['neo-list-container', 'neo-list'], tabIndex: -1, cn: []}
        ]}
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value) {
            if (me.dragResortable) {
                console.error('tree.List can be either draggable or dragResortable, not both.', me.id)
            } else if (!me.dragZone) {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-src_draggable_tree_DragZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/tree/DragZone.mjs */ "./src/draggable/tree/DragZone.mjs")).then(module => {
                    me.dragZone = Neo.create({
                        module  : module.default,
                        appName : me.appName,
                        owner   : me,
                        windowId: me.windowId,
                        ...me.dragZoneConfig
                    })
                })
            }
        }
    }

    /**
     * Triggered after the dragResortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDragResortable(value, oldValue) {
        let me = this;

        if (value) {
            if (me.draggable) {
                console.error('tree.List can be either draggable or dragResortable, not both.', me.id)
            } else if (!me.sortZone) {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_DragProxyContainer_mjs-src_draggable_tree_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/tree/SortZone.mjs */ "./src/draggable/tree/SortZone.mjs")).then(module => {
                    me.sortZone = Neo.create({
                        module             : module.default,
                        appName            : me.appName,
                        boundaryContainerId: me.id,
                        owner              : me,
                        windowId           : me.windowId,
                        ...me.sortZoneConfig
                    })
                })
            }
        }
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _selection_TreeModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store} value
     * @param {Object|Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        if (!value) {
            value = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
                keyProperty: 'id'
            })
        }

        return super.beforeSetStore(value, oldValue)
    }


    /**
     * Collapses all folders
     * @param {Boolean} [silent]=false Set silent to true to prevent a vnode update
     */
    collapseAll(silent=false) {
        let me       = this,
            hasMatch = false,
            nextSibling, node, parentNode, index;

        me.store.forEach(item => {
            if (!item.isLeaf) {
                node = me.getVdomChild(me.getItemId(item.id), me.vdom);

                if (node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = true
                    }

                    hasMatch = true
                }
            }
        });

        if (hasMatch && !silent) {
            me.update()
        }
    }

    /**
     * Creates the VDOM object for a single tree item (leaf or folder).
     *
     * This method is the core VDOM factory for the tree. It constructs the `li` element
     * representing a record. Key responsibilities:
     * 1.  **Class Assignment:** Applies `itemCls`, `folderCls`, and `iconCls` based on record state.
     * 2.  **Hierarchy visualization:** Calculates `zIndex` and `padding` based on depth (`level`).
     * 3.  **Sticky Positioning:** Sets `position: sticky` and calculates `top` offsets for folder nodes
     *     to ensure they stack correctly while scrolling.
     * 4.  **Content:** Creates the label and icon structure.
     *
     * @param {Object} record The data record from the store
     * @returns {Object} The VDOM object for the list item
     */
    createItem(record) {
        let me                   = this,
            {folderCls, itemCls} = me,
            cls                  = [itemCls],
            contentCls           = [itemCls + '-content'],
            keyProperty          = me.getKeyProperty(),
            itemVdom;

        if (record.iconCls) {
            if (Array.isArray(record.iconCls)) {
                contentCls.push(...record.iconCls)
            } else {
                contentCls.push(record.iconCls)
            }
        }

        if (record.isLeaf) {
            cls.push(itemCls + (record.singleton ? '-leaf-singleton' : '-leaf'))
        } else {
            cls.push(folderCls);

            if (!record.collapsed) {
                cls.push('neo-folder-open')
            }
        }

        itemVdom = {
            tag: 'li',
            cls,
            id   : me.getItemId(record[keyProperty]),
            level: record.level,
            cn   : [{
                tag  : 'span',
                cls  : contentCls,
                html : record[me.displayField],
                style: {pointerEvents: 'none'}
            }],
            style: {
                display : record.hidden ? 'none' : 'flex',
                padding : '10px',
                position: (record.isLeaf || record.collapsed) ? null : 'sticky',
                top     : (record.isLeaf || record.collapsed) ? null : (record.level * 38) + 'px',
                zIndex  : record.isLeaf ? 1 : (10000 + record.level)
            }
        };

        if (me.itemsFocusable) {
            itemVdom.tabIndex = -1
        }

        return itemVdom
    }

    /**
     * Recursively generates the VDOM tree structure starting from a given parent.
     *
     * This method implements the recursive logic required to turn a flat store into a
     * hierarchical DOM structure.
     * - It finds all direct children of the `parentId`.
     * - It creates a `ul` container for them.
     * - For each child, it calls `createItem` to generate the node.
     * - It recursively calls itself (`createItemLevel`) for each child to build the next level.
     *
     * This approach ensures that the visual hierarchy matches the data relationship,
     * supporting arbitrary depth.
     *
     * @param {String} [parentId] The parent node id (null for root level)
     * @param {Object} [vdomRoot] The vdom template root for the current sub tree
     * @param {Number} level The current hierarchy level (depth)
     * @param {Boolean} hidden=false Whether this branch is currently hidden (collapsed parent)
     * @returns {Object} vdomRoot
     * @protected
     */
    createItemLevel(parentId, vdomRoot, level, hidden=false) {
        let me    = this,
            items = me.store.find('parentId', parentId),
            tmpRoot;

        if (items.length > 0) {
            if (!vdomRoot.cn) {
                vdomRoot.cn = []
            }

            if (parentId !== null) {
                vdomRoot.cn.push({
                    tag      : 'ul',
                    cls      : ['neo-list'],
                    cn       : [],
                    removeDom: hidden,
                    style    : {
                        paddingLeft: '15px'
                    }
                });

                tmpRoot = vdomRoot.cn[vdomRoot.cn.length - 1]
            } else {
                tmpRoot = vdomRoot
            }

            items.forEach(record => {
                record.level = level;

                tmpRoot.cn.push(me.createItem(record));

                me.createItemLevel(record.id, tmpRoot, level + 1, record.hidden || hidden || record.collapsed)
            })
        }

        return vdomRoot
    }

    /**
     * The main entry point for rendering the tree's content.
     *
     * This method clears the current list content and initiates the recursive rendering process
     * by calling `createItemLevel` starting from the root (null parent).
     * It is typically called when the store is loaded or when a full refresh is needed.
     *
     * @protected
     */
    createItems() {
        let me        = this,
            itemsRoot = me.getListItemsRoot();

        itemsRoot.cn = [];

        me.createItemLevel(null, itemsRoot, 0);
        me.update()
    }

    /**
     * Expands all folders
     * @param {Boolean} silent=false Set silent to true to prevent a vnode update
     */
    expandAll(silent=false) {
        let me       = this,
            hasMatch = false,
            nextSibling, node, parentNode, index;

        me.store.forEach(item => {
            if (!item.isLeaf) {
                node = me.getVdomChild(me.getItemId(item.id), me.vdom);

                if (!node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = false
                    }

                    hasMatch = true
                }
            }
        });

        if (hasMatch && !silent) {
            me.update()
        }
    }

    /**
     * Expands all parent folders of a given item
     * @param {String|Number} itemId
     */
    expandParents(itemId) {
        let me       = this,
            item     = me.store.get(itemId),
            hasMatch = false,
            nextSibling, node, parentId, parentNode, index;

        if (item) {
            parentId = item.parentId;

            while (parentId) {
                node = me.getVdomChild(me.getItemId(parentId));

                if (node && !node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = false
                    }

                    hasMatch = true
                }

                item     = me.store.get(parentId);
                parentId = item ? item.parentId : null
            }
        }

        if (hasMatch) {
            me.update()
        }
    }

    /**
     * Hides Tree nodes which do not match the filter
     * @param {String} property The store field to filter by
     * @param {String} value The filter value
     * @param {Number|null} parentId The root id for the current filter call
     * @param {Boolean} [parentMatch]=false In case a parent folder matches the filter, show its child items
     * @returns {Boolean} false if at least one child item is filtered
     */
    filter(property, value, parentId, parentMatch = false) {
        let me         = this,
            isFiltered = true,
            valueRegEx = new RegExp(value, 'gi'),
            childReturnValue, directMatch, node;

        if (!value) {
            value = ''
        }

        me.store.forEach(item => {
            if (item.parentId === parentId) {
                directMatch = false;
                node        = me.getVdomChild(me.getItemId(item.id), me.vdom);

                node.cn[0].html = item[property].replace(valueRegEx, match => {
                    directMatch = true;
                    return `<span class="neo-highlight-search">${match}</span>`
                });

                if (item.isLeaf) {
                    childReturnValue = true
                } else {
                    childReturnValue = me.filter(property, value, item.id, directMatch || parentMatch)
                }

                if (directMatch || parentMatch || childReturnValue === false || value === '') {
                    isFiltered = false
                }

                node.style.display = isFiltered ? 'none' : 'list-item'
            }
        });

        if (parentId === null) {
            me.expandAll(true);
            me.update()
        }

        return isFiltered
    }

    /**
     * Scrolls a list item into the visible area
     * @param {String|Number} itemId
     */
    scrollToItem(itemId) {
        let me = this;

        Neo.main.DomAccess.scrollIntoView({
            id      : me.getItemId(itemId),
            windowId: me.windowId
        })
    }

    /**
     * @returns {Object}
     */
    getListItemsRoot() {
        return this.vdom.cn[this.showCollapseExpandAllIcons ? 2 : 0]
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        if (data.target.cls.includes('neo-treelist-menu-item')) {
            this.onMenuItemClick(data.target.cls)
        } else {
            super.onClick(data)
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.showCollapseExpandAllIcons) {
            me.vdom.cn.unshift({
                cls: ['neo-treelist-menu-item', 'neo-treelist-collapse-all-icon'],
                cn : [{
                    tag: 'span',
                    cls: ['neo-treelist-menu-item-content']
                }]
            }, {
                cls: ['neo-treelist-menu-item', 'neo-treelist-expand-all-icon'],
                cn : [{
                    tag: 'span',
                    cls: ['neo-treelist-menu-item-content']
                }]
            });

            me.update()
        }
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me          = this,
            {items}     = me.store,
            i           = 0,
            len         = items.length,
            keyProperty = me.getKeyProperty(),
            path        = data.path.map(e => e.id),
            item, record, tmpItem, vnodeId;

        for (; i < len; i++) {
            tmpItem = items[i];
            vnodeId = me.getItemId(tmpItem[keyProperty]);

            if (path.includes(vnodeId)) {
                record = tmpItem;
                item = me.getVdomChild(vnodeId);
                break
            }
        }

        if (item) {
            if (item.cls?.includes(me.folderCls)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(item.cls, 'neo-folder-open');

                let isOpen              = item.cls.includes('neo-folder-open'),
                    {parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, item.id),
                    nextSibling         = parentNode.cn[index + 1];

                item.style.position = isOpen ? 'sticky' : null;
                item.style.top      = isOpen ? (item.level * 38) + 'px' : null;

                if (nextSibling?.tag === 'ul') {
                    nextSibling.removeDom = !isOpen
                }

                me.update()
            } else {
                me.onLeafItemClick(record);

                /**
                 * The leafItemClick event fires when a click occurs on a list item which does not have child items.
                 * Passes the item record to the event handler.
                 * @event leafItemClick
                 * @returns {Object} record
                 */
                me.fire('leafItemClick', record)
            }

            super.onItemClick(node, data)
        }
    }

    /**
     * Placeholder method
     * @param {Object} record
     */
    onLeafItemClick(record) {

    }

    /**
     * Gets triggered by clicks on the collapse or expand all icons
     * @param {Array} cls
     * @protected
     */
    onMenuItemClick(cls) {
        if (cls.includes('neo-treelist-collapse-all-icon')) {
            this.collapseAll()
        } else {
            this.expandAll()
        }
    }

    /**
     * Captures the scroll stream from the Main Thread to detect sticky states.
     *
     * When `saveScrollPosition` is true, this method calculates which folder headers are currently
     * pinned ("stuck") to the top of the viewport by comparing their computed `top` style with
     * the current `scrollTop`. It toggles the `neo-stuck` class on these items, allowing for
     * conditional styling (e.g. background opacity) only when headers are sticking.
     *
     * @param {Object} data
     * @param {Number} data.scrollTop The current scroll position
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);

        let me = this;

        if (me.saveScrollPosition) {
            let scrollTop       = data.scrollTop,
                needsUpdate     = false,
                y               = 0,
                stuckCandidates = {};

            const traverse = (node) => {
                if (!node.cn) return;

                let lastFolderOpen = true;

                node.cn.forEach(child => {
                    if (child.tag === 'li') {
                        if (child.cls.includes(me.folderCls)) {
                            let topStyle = child.style.top;

                            if (topStyle) {
                                let isStuck = scrollTop > 0 && (y - scrollTop) <= parseInt(topStyle);

                                if (isStuck) {
                                    let level = child.level || 0;
                                    stuckCandidates[level] ??= [];
                                    stuckCandidates[level].push(child)
                                } else {
                                    if (child.cls.includes('neo-stuck')) {
                                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(child.cls, 'neo-stuck');
                                        needsUpdate = true
                                    }
                                }
                            }

                            lastFolderOpen = child.cls.includes('neo-folder-open')
                        } else {
                            lastFolderOpen = true
                        }

                        if (child.style?.display !== 'none' && !child.removeDom) {
                            y += 51
                        }
                    } else if (child.tag === 'ul') {
                        if (lastFolderOpen && !child.removeDom) {
                            traverse(child)
                        }
                    }
                })
            };

            if (me.vdom.cn && me.vdom.cn[0]) {
                traverse(me.vdom.cn[0])
            }

            Object.values(stuckCandidates).forEach(items => {
                let last = items[items.length - 1];

                items.forEach(item => {
                    let shouldBeStuck = (item === last),
                        hasClass      = item.cls.includes('neo-stuck');

                    if (shouldBeStuck !== hasClass) {
                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(item.cls, 'neo-stuck', shouldBeStuck);
                        needsUpdate = true
                    }
                })
            });

            if (needsUpdate) {
                me.update()
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Number} data.index
     * @param {Neo.data.Model} data.model
     * @param {Object} data.record
     */
    onStoreRecordChange(data) {
        let me                  = this,
            {record}            = data,
            {index, parentNode} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, me.getItemId(record.id));

        parentNode.cn[index] = me.createItem(record);

        me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tree));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190cmVlX0xpc3RfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBUztBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx5QkFBeUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENNO0FBQ087QUFDRDtBQUNMO0FBQ1M7QUFDVjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzREFBSTtBQUN2QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVB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Q0E7O0FBRUE7QUFDQSx3QkFBd0IsdURBQVE7QUFDaEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxtQkFBbUIsRUFBRSxzREFBUTs7QUFFMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLG9CQUFvQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zZWxlY3Rpb24vVHJlZU1vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3RyZWUvTGlzdC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpc3RNb2RlbCBmcm9tICcuL0xpc3RNb2RlbC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uc2VsZWN0aW9uLlRyZWVNb2RlbFxuICogQGV4dGVuZHMgTmVvLnNlbGVjdGlvbi5MaXN0TW9kZWxcbiAqL1xuY2xhc3MgVHJlZU1vZGVsIGV4dGVuZHMgTGlzdE1vZGVsIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zZWxlY3Rpb24uVHJlZU1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc2VsZWN0aW9uLlRyZWVNb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzZWxlY3Rpb24tdHJlZW1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3NlbGVjdGlvbi10cmVlbW9kZWwnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd25FbnRlcihkYXRhKSB7XG4gICAgICAgIC8vIE5lby5sb2coJ29uS2V5RG93bkVudGVyJywgZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgb25OYXZLZXkoZGF0YSwgc3RlcCkge1xuICAgICAgICAvLyBOZW8ubG9nKCdvbk5hdktleScsIGRhdGEsIHN0ZXApXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUcmVlTW9kZWwpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICBmcm9tICcuLi9saXN0L0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gICAgICBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFRyZWVNb2RlbCAgICAgICBmcm9tICcuLi9zZWxlY3Rpb24vVHJlZU1vZGVsLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgIGZyb20gXCIuLi91dGlsL1ZEb20ubWpzXCI7XG5cbi8qKlxuICogQHN1bW1hcnkgQSBoaWVyYXJjaGljYWwgbGlzdCBjb21wb25lbnQgc3VwcG9ydGluZyBuZXN0ZWQgZm9sZGVycywgZXhwYW5zaW9uLCBhbmQgc3RpY2t5IGhlYWRlcnMuXG4gKlxuICogVGhpcyBjb21wb25lbnQgcmVuZGVycyBoaWVyYXJjaGljYWwgZGF0YSBzdHJ1Y3R1cmVzICh0cmVlcykgdXNpbmcgYSBmbGF0IHN0b3JlIG1hbmFnZWQgYnkgYSBgTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWxgLlxuICogSXQgcHJvdmlkZXMgYnVpbHQtaW4gc3VwcG9ydCBmb3I6XG4gKiAtICoqUmVjdXJzaXZlIHJlbmRlcmluZzoqKiBFZmZpY2llbnRseSByZW5kZXJzIGRlZXBseSBuZXN0ZWQgZm9sZGVyIHN0cnVjdHVyZXMuXG4gKiAtICoqQ29sbGFwc2libGUgZm9sZGVyczoqKiBJbnRlcmFjdGl2ZSBleHBhbmQvY29sbGFwc2UgZnVuY3Rpb25hbGl0eSBmb3IgYnJhbmNoIG5vZGVzLlxuICogLSAqKlN0aWNreSBIZWFkZXJzOioqIEZvbGRlciBoZWFkZXJzIHVzZSBDU1MgYHBvc2l0aW9uOiBzdGlja3lgIHRvIHJlbWFpbiB2aXNpYmxlIHdoaWxlIHNjcm9sbGluZyB0aHJvdWdoIHRoZWlyIGNvbnRlbnQuXG4gKiAtICoqU3R1Y2sgU3RhdGUgRGV0ZWN0aW9uOioqIFdoZW4gYHNhdmVTY3JvbGxQb3NpdGlvbmAgaXMgZW5hYmxlZCwgdGhlIGNvbXBvbmVudCB0cmFja3MgdGhlIHN0aWNreSBzdGF0ZSB2aWEgSlMgYW5kIGFwcGxpZXNcbiAqICAgYSBgLm5lby1zdHVja2AgY2xhc3MgdG8gaGVhZGVycyB0aGF0IGFyZSBjdXJyZW50bHkgcGlubmVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgdmlzdWFsIGN1c3RvbWl6YXRpb24sIHN1Y2ggYXMgYXBwbHlpbmdcbiAqICAgYmFja2dyb3VuZHMgdG8gdHJhbnNwYXJlbnQgaXRlbXMuXG4gKiAtICoqRHJhZyBhbmQgRHJvcDoqKiBTdXBwb3J0cyByZW9yZGVyaW5nIHZpYSBgZHJhZ1Jlc29ydGFibGVgIG9yIG1vdmluZyBpdGVtcyBiZXR3ZWVuIGxpc3RzIHZpYSBgZHJhZ2dhYmxlYC5cbiAqIC0gKipGaWx0ZXJpbmc6KiogRGVlcC1maWx0ZXJpbmcgdGhhdCBwcmVzZXJ2ZXMgZm9sZGVyIHN0cnVjdHVyZXMgZm9yIG1hdGNoZWQgbGVhZiBub2Rlcy5cbiAqXG4gKiBLZXl3b3JkczogYEhpZXJhcmNoaWNhbCBEYXRhYCwgYFRyZWUgVmlld2AsIGBSZWN1cnNpdmUgTGlzdGAsIGBTdGlja3kgSGVhZGVyc2AsIGBGb2xkZXIgVmlld2BcbiAqXG4gKiBAY2xhc3MgTmVvLnRyZWUuTGlzdFxuICogQGV4dGVuZHMgTmVvLmxpc3QuQmFzZVxuICogQHNlZSBOZW8uc2VsZWN0aW9uLlRyZWVNb2RlbFxuICovXG5jbGFzcyBUcmVlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udHJlZS5MaXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udHJlZS5MaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3RyZWVsaXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3RyZWVsaXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRyZWUtbGlzdCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10cmVlLWxpc3QnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVTZWxlY3Rpb249ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlU2VsZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyYWdSZXNvcnRhYmxlXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdSZXNvcnRhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLnRyZWUuRHJhZ1pvbmV8bnVsbH0gZHJhZ1pvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGZvbGRlckNscz0nbmVvLWxpc3QtZm9sZGVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgZm9sZGVyQ2xzOiAnbmVvLWxpc3QtZm9sZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNob3dDb2xsYXBzZUV4cGFuZEFsbEljb25zPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHNob3dDb2xsYXBzZUV4cGFuZEFsbEljb25zOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS50cmVlLlNvcnRab25lfG51bGx9IHNvcnRab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHNvcnRab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcmFnWm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB3cmFwcGVyQ2xzPVtdXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlckNsczogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gdHJ1ZSB0byBtb25pdG9yIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGxpc3QuXG4gICAgICAgICAqIFRoaXMgZW5hYmxlcyB0aGUgYG9uU2Nyb2xsQ2FwdHVyZWAgbG9naWMgd2hpY2ggY2FsY3VsYXRlcyBpZiBzdGlja3kgZm9sZGVyIGhlYWRlcnNcbiAgICAgICAgICogYXJlIGN1cnJlbnRseSBpbiBhIFwic3R1Y2tcIiBzdGF0ZSAocGlubmVkIHRvIHRoZSB0b3ApLCBhcHBseWluZyB0aGUgYC5uZW8tc3R1Y2tgIENTUyBjbGFzcy5cbiAgICAgICAgICogVXNlZnVsIGZvciBhcHBseWluZyB2aXN1YWwgY2hhbmdlcyAoZS5nLiBiYWNrZ3JvdW5kIG9wYWNpdHkpIG9ubHkgd2hlbiBoZWFkZXJzIGFyZSBzdGlja2luZy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2F2ZVNjcm9sbFBvc2l0aW9uPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzYXZlU2Nyb2xsUG9zaXRpb246IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHtjbjogW1xuICAgICAgICAgICAge3RhZzogJ3VsJywgY2xzOiBbJ25lby1saXN0LWNvbnRhaW5lcicsICduZW8tbGlzdCddLCB0YWJJbmRleDogLTEsIGNuOiBbXX1cbiAgICAgICAgXX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyYWdnYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChtZS5kcmFnUmVzb3J0YWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyZWUuTGlzdCBjYW4gYmUgZWl0aGVyIGRyYWdnYWJsZSBvciBkcmFnUmVzb3J0YWJsZSwgbm90IGJvdGguJywgbWUuaWQpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3RyZWUvRHJhZ1pvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5kcmFnWm9uZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lciAgIDogbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5tZS5kcmFnWm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdSZXNvcnRhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RHJhZ1Jlc29ydGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWUuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJlZS5MaXN0IGNhbiBiZSBlaXRoZXIgZHJhZ2dhYmxlIG9yIGRyYWdSZXNvcnRhYmxlLCBub3QgYm90aC4nLCBtZS5pZClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1lLnNvcnRab25lKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvdHJlZS9Tb3J0Wm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNvcnRab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyICAgICAgICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SWQgICAgICAgICAgIDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5tZS5zb3J0Wm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzZWxlY3Rpb25Nb2RlbCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TmVvLnNlbGVjdGlvbi5Nb2RlbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5zZWxlY3Rpb24uTW9kZWx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNlbGVjdGlvbk1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIFRyZWVNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5kYXRhLlN0b3JlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5kYXRhLlN0b3JlfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTmVvLmNyZWF0ZShDb2xsZWN0aW9uLCB7XG4gICAgICAgICAgICAgICAga2V5UHJvcGVydHk6ICdpZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuYmVmb3JlU2V0U3RvcmUodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFsbCBmb2xkZXJzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50XT1mYWxzZSBTZXQgc2lsZW50IHRvIHRydWUgdG8gcHJldmVudCBhIHZub2RlIHVwZGF0ZVxuICAgICAqL1xuICAgIGNvbGxhcHNlQWxsKHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZSxcbiAgICAgICAgICAgIG5leHRTaWJsaW5nLCBub2RlLCBwYXJlbnROb2RlLCBpbmRleDtcblxuICAgICAgICBtZS5zdG9yZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFpdGVtLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtZS5nZXRWZG9tQ2hpbGQobWUuZ2V0SXRlbUlkKGl0ZW0uaWQpLCBtZS52ZG9tKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlLmNscy5pbmNsdWRlcygnbmVvLWZvbGRlci1vcGVuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKG5vZGUuY2xzLCAnbmVvLWZvbGRlci1vcGVuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgKHtwYXJlbnROb2RlLCBpbmRleH0gPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIG5vZGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgICAgICAgICAgPSBwYXJlbnROb2RlLmNuW2luZGV4ICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nPy50YWcgPT09ICd1bCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc01hdGNoICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBWRE9NIG9iamVjdCBmb3IgYSBzaW5nbGUgdHJlZSBpdGVtIChsZWFmIG9yIGZvbGRlcikuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgY29yZSBWRE9NIGZhY3RvcnkgZm9yIHRoZSB0cmVlLiBJdCBjb25zdHJ1Y3RzIHRoZSBgbGlgIGVsZW1lbnRcbiAgICAgKiByZXByZXNlbnRpbmcgYSByZWNvcmQuIEtleSByZXNwb25zaWJpbGl0aWVzOlxuICAgICAqIDEuICAqKkNsYXNzIEFzc2lnbm1lbnQ6KiogQXBwbGllcyBgaXRlbUNsc2AsIGBmb2xkZXJDbHNgLCBhbmQgYGljb25DbHNgIGJhc2VkIG9uIHJlY29yZCBzdGF0ZS5cbiAgICAgKiAyLiAgKipIaWVyYXJjaHkgdmlzdWFsaXphdGlvbjoqKiBDYWxjdWxhdGVzIGB6SW5kZXhgIGFuZCBgcGFkZGluZ2AgYmFzZWQgb24gZGVwdGggKGBsZXZlbGApLlxuICAgICAqIDMuICAqKlN0aWNreSBQb3NpdGlvbmluZzoqKiBTZXRzIGBwb3NpdGlvbjogc3RpY2t5YCBhbmQgY2FsY3VsYXRlcyBgdG9wYCBvZmZzZXRzIGZvciBmb2xkZXIgbm9kZXNcbiAgICAgKiAgICAgdG8gZW5zdXJlIHRoZXkgc3RhY2sgY29ycmVjdGx5IHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiA0LiAgKipDb250ZW50OioqIENyZWF0ZXMgdGhlIGxhYmVsIGFuZCBpY29uIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQgVGhlIGRhdGEgcmVjb3JkIGZyb20gdGhlIHN0b3JlXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIFZET00gb2JqZWN0IGZvciB0aGUgbGlzdCBpdGVtXG4gICAgICovXG4gICAgY3JlYXRlSXRlbShyZWNvcmQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtmb2xkZXJDbHMsIGl0ZW1DbHN9ID0gbWUsXG4gICAgICAgICAgICBjbHMgICAgICAgICAgICAgICAgICA9IFtpdGVtQ2xzXSxcbiAgICAgICAgICAgIGNvbnRlbnRDbHMgICAgICAgICAgID0gW2l0ZW1DbHMgKyAnLWNvbnRlbnQnXSxcbiAgICAgICAgICAgIGtleVByb3BlcnR5ICAgICAgICAgID0gbWUuZ2V0S2V5UHJvcGVydHkoKSxcbiAgICAgICAgICAgIGl0ZW1WZG9tO1xuXG4gICAgICAgIGlmIChyZWNvcmQuaWNvbkNscykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjb3JkLmljb25DbHMpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudENscy5wdXNoKC4uLnJlY29yZC5pY29uQ2xzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q2xzLnB1c2gocmVjb3JkLmljb25DbHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjb3JkLmlzTGVhZikge1xuICAgICAgICAgICAgY2xzLnB1c2goaXRlbUNscyArIChyZWNvcmQuc2luZ2xldG9uID8gJy1sZWFmLXNpbmdsZXRvbicgOiAnLWxlYWYnKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNscy5wdXNoKGZvbGRlckNscyk7XG5cbiAgICAgICAgICAgIGlmICghcmVjb3JkLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIGNscy5wdXNoKCduZW8tZm9sZGVyLW9wZW4nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbVZkb20gPSB7XG4gICAgICAgICAgICB0YWc6ICdsaScsXG4gICAgICAgICAgICBjbHMsXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0SXRlbUlkKHJlY29yZFtrZXlQcm9wZXJ0eV0pLFxuICAgICAgICAgICAgbGV2ZWw6IHJlY29yZC5sZXZlbCxcbiAgICAgICAgICAgIGNuICAgOiBbe1xuICAgICAgICAgICAgICAgIHRhZyAgOiAnc3BhbicsXG4gICAgICAgICAgICAgICAgY2xzICA6IGNvbnRlbnRDbHMsXG4gICAgICAgICAgICAgICAgaHRtbCA6IHJlY29yZFttZS5kaXNwbGF5RmllbGRdLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7cG9pbnRlckV2ZW50czogJ25vbmUnfVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGRpc3BsYXkgOiByZWNvcmQuaGlkZGVuID8gJ25vbmUnIDogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgOiAnMTBweCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IChyZWNvcmQuaXNMZWFmIHx8IHJlY29yZC5jb2xsYXBzZWQpID8gbnVsbCA6ICdzdGlja3knLFxuICAgICAgICAgICAgICAgIHRvcCAgICAgOiAocmVjb3JkLmlzTGVhZiB8fCByZWNvcmQuY29sbGFwc2VkKSA/IG51bGwgOiAocmVjb3JkLmxldmVsICogMzgpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB6SW5kZXggIDogcmVjb3JkLmlzTGVhZiA/IDEgOiAoMTAwMDAgKyByZWNvcmQubGV2ZWwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1lLml0ZW1zRm9jdXNhYmxlKSB7XG4gICAgICAgICAgICBpdGVtVmRvbS50YWJJbmRleCA9IC0xXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbVZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBnZW5lcmF0ZXMgdGhlIFZET00gdHJlZSBzdHJ1Y3R1cmUgc3RhcnRpbmcgZnJvbSBhIGdpdmVuIHBhcmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgdGhlIHJlY3Vyc2l2ZSBsb2dpYyByZXF1aXJlZCB0byB0dXJuIGEgZmxhdCBzdG9yZSBpbnRvIGFcbiAgICAgKiBoaWVyYXJjaGljYWwgRE9NIHN0cnVjdHVyZS5cbiAgICAgKiAtIEl0IGZpbmRzIGFsbCBkaXJlY3QgY2hpbGRyZW4gb2YgdGhlIGBwYXJlbnRJZGAuXG4gICAgICogLSBJdCBjcmVhdGVzIGEgYHVsYCBjb250YWluZXIgZm9yIHRoZW0uXG4gICAgICogLSBGb3IgZWFjaCBjaGlsZCwgaXQgY2FsbHMgYGNyZWF0ZUl0ZW1gIHRvIGdlbmVyYXRlIHRoZSBub2RlLlxuICAgICAqIC0gSXQgcmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIChgY3JlYXRlSXRlbUxldmVsYCkgZm9yIGVhY2ggY2hpbGQgdG8gYnVpbGQgdGhlIG5leHQgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIGFwcHJvYWNoIGVuc3VyZXMgdGhhdCB0aGUgdmlzdWFsIGhpZXJhcmNoeSBtYXRjaGVzIHRoZSBkYXRhIHJlbGF0aW9uc2hpcCxcbiAgICAgKiBzdXBwb3J0aW5nIGFyYml0cmFyeSBkZXB0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyZW50SWRdIFRoZSBwYXJlbnQgbm9kZSBpZCAobnVsbCBmb3Igcm9vdCBsZXZlbClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Zkb21Sb290XSBUaGUgdmRvbSB0ZW1wbGF0ZSByb290IGZvciB0aGUgY3VycmVudCBzdWIgdHJlZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgY3VycmVudCBoaWVyYXJjaHkgbGV2ZWwgKGRlcHRoKVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGlkZGVuPWZhbHNlIFdoZXRoZXIgdGhpcyBicmFuY2ggaXMgY3VycmVudGx5IGhpZGRlbiAoY29sbGFwc2VkIHBhcmVudClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tUm9vdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtTGV2ZWwocGFyZW50SWQsIHZkb21Sb290LCBsZXZlbCwgaGlkZGVuPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyA9IG1lLnN0b3JlLmZpbmQoJ3BhcmVudElkJywgcGFyZW50SWQpLFxuICAgICAgICAgICAgdG1wUm9vdDtcblxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCF2ZG9tUm9vdC5jbikge1xuICAgICAgICAgICAgICAgIHZkb21Sb290LmNuID0gW11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmRvbVJvb3QuY24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRhZyAgICAgIDogJ3VsJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1saXN0J10sXG4gICAgICAgICAgICAgICAgICAgIGNuICAgICAgIDogW10sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogaGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMTVweCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdG1wUm9vdCA9IHZkb21Sb290LmNuW3Zkb21Sb290LmNuLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSB2ZG9tUm9vdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKHJlY29yZCA9PiB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmxldmVsID0gbGV2ZWw7XG5cbiAgICAgICAgICAgICAgICB0bXBSb290LmNuLnB1c2gobWUuY3JlYXRlSXRlbShyZWNvcmQpKTtcblxuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUl0ZW1MZXZlbChyZWNvcmQuaWQsIHRtcFJvb3QsIGxldmVsICsgMSwgcmVjb3JkLmhpZGRlbiB8fCBoaWRkZW4gfHwgcmVjb3JkLmNvbGxhcHNlZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbVJvb3RcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgcmVuZGVyaW5nIHRoZSB0cmVlJ3MgY29udGVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNsZWFycyB0aGUgY3VycmVudCBsaXN0IGNvbnRlbnQgYW5kIGluaXRpYXRlcyB0aGUgcmVjdXJzaXZlIHJlbmRlcmluZyBwcm9jZXNzXG4gICAgICogYnkgY2FsbGluZyBgY3JlYXRlSXRlbUxldmVsYCBzdGFydGluZyBmcm9tIHRoZSByb290IChudWxsIHBhcmVudCkuXG4gICAgICogSXQgaXMgdHlwaWNhbGx5IGNhbGxlZCB3aGVuIHRoZSBzdG9yZSBpcyBsb2FkZWQgb3Igd2hlbiBhIGZ1bGwgcmVmcmVzaCBpcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXNSb290ID0gbWUuZ2V0TGlzdEl0ZW1zUm9vdCgpO1xuXG4gICAgICAgIGl0ZW1zUm9vdC5jbiA9IFtdO1xuXG4gICAgICAgIG1lLmNyZWF0ZUl0ZW1MZXZlbChudWxsLCBpdGVtc1Jvb3QsIDApO1xuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIGZvbGRlcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZSBTZXQgc2lsZW50IHRvIHRydWUgdG8gcHJldmVudCBhIHZub2RlIHVwZGF0ZVxuICAgICAqL1xuICAgIGV4cGFuZEFsbChzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0U2libGluZywgbm9kZSwgcGFyZW50Tm9kZSwgaW5kZXg7XG5cbiAgICAgICAgbWUuc3RvcmUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWUuZ2V0VmRvbUNoaWxkKG1lLmdldEl0ZW1JZChpdGVtLmlkKSwgbWUudmRvbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuY2xzLmluY2x1ZGVzKCduZW8tZm9sZGVyLW9wZW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS5hZGQobm9kZS5jbHMsICduZW8tZm9sZGVyLW9wZW4nKTtcblxuICAgICAgICAgICAgICAgICAgICAoe3BhcmVudE5vZGUsIGluZGV4fSA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbm9kZS5pZCkpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZyAgICAgICAgICA9IHBhcmVudE5vZGUuY25baW5kZXggKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmc/LnRhZyA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlRG9tID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc01hdGNoICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFsbCBwYXJlbnQgZm9sZGVycyBvZiBhIGdpdmVuIGl0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1JZFxuICAgICAqL1xuICAgIGV4cGFuZFBhcmVudHMoaXRlbUlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtICAgICA9IG1lLnN0b3JlLmdldChpdGVtSWQpLFxuICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZSxcbiAgICAgICAgICAgIG5leHRTaWJsaW5nLCBub2RlLCBwYXJlbnRJZCwgcGFyZW50Tm9kZSwgaW5kZXg7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHBhcmVudElkID0gaXRlbS5wYXJlbnRJZDtcblxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1lLmdldFZkb21DaGlsZChtZS5nZXRJdGVtSWQocGFyZW50SWQpKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmICFub2RlLmNscy5pbmNsdWRlcygnbmVvLWZvbGRlci1vcGVuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKG5vZGUuY2xzLCAnbmVvLWZvbGRlci1vcGVuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgKHtwYXJlbnROb2RlLCBpbmRleH0gPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIG5vZGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgICAgICAgICAgPSBwYXJlbnROb2RlLmNuW2luZGV4ICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nPy50YWcgPT09ICd1bCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZURvbSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtICAgICA9IG1lLnN0b3JlLmdldChwYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50SWQgPSBpdGVtID8gaXRlbS5wYXJlbnRJZCA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNNYXRjaCkge1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGVzIFRyZWUgbm9kZXMgd2hpY2ggZG8gbm90IG1hdGNoIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIHN0b3JlIGZpZWxkIHRvIGZpbHRlciBieVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgZmlsdGVyIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gcGFyZW50SWQgVGhlIHJvb3QgaWQgZm9yIHRoZSBjdXJyZW50IGZpbHRlciBjYWxsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyZW50TWF0Y2hdPWZhbHNlIEluIGNhc2UgYSBwYXJlbnQgZm9sZGVyIG1hdGNoZXMgdGhlIGZpbHRlciwgc2hvdyBpdHMgY2hpbGQgaXRlbXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZmFsc2UgaWYgYXQgbGVhc3Qgb25lIGNoaWxkIGl0ZW0gaXMgZmlsdGVyZWRcbiAgICAgKi9cbiAgICBmaWx0ZXIocHJvcGVydHksIHZhbHVlLCBwYXJlbnRJZCwgcGFyZW50TWF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpc0ZpbHRlcmVkID0gdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlUmVnRXggPSBuZXcgUmVnRXhwKHZhbHVlLCAnZ2knKSxcbiAgICAgICAgICAgIGNoaWxkUmV0dXJuVmFsdWUsIGRpcmVjdE1hdGNoLCBub2RlO1xuXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnN0b3JlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnRJZCA9PT0gcGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3RNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUgICAgICAgID0gbWUuZ2V0VmRvbUNoaWxkKG1lLmdldEl0ZW1JZChpdGVtLmlkKSwgbWUudmRvbSk7XG5cbiAgICAgICAgICAgICAgICBub2RlLmNuWzBdLmh0bWwgPSBpdGVtW3Byb3BlcnR5XS5yZXBsYWNlKHZhbHVlUmVnRXgsIG1hdGNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0TWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwibmVvLWhpZ2hsaWdodC1zZWFyY2hcIj4ke21hdGNofTwvc3Bhbj5gXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZXR1cm5WYWx1ZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFJldHVyblZhbHVlID0gbWUuZmlsdGVyKHByb3BlcnR5LCB2YWx1ZSwgaXRlbS5pZCwgZGlyZWN0TWF0Y2ggfHwgcGFyZW50TWF0Y2gpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdE1hdGNoIHx8IHBhcmVudE1hdGNoIHx8IGNoaWxkUmV0dXJuVmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpc0ZpbHRlcmVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBpc0ZpbHRlcmVkID8gJ25vbmUnIDogJ2xpc3QtaXRlbSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcmVudElkID09PSBudWxsKSB7XG4gICAgICAgICAgICBtZS5leHBhbmRBbGwodHJ1ZSk7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRmlsdGVyZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGEgbGlzdCBpdGVtIGludG8gdGhlIHZpc2libGUgYXJlYVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaXRlbUlkXG4gICAgICovXG4gICAgc2Nyb2xsVG9JdGVtKGl0ZW1JZCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICBpZCAgICAgIDogbWUuZ2V0SXRlbUlkKGl0ZW1JZCksXG4gICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldExpc3RJdGVtc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb20uY25bdGhpcy5zaG93Q29sbGFwc2VFeHBhbmRBbGxJY29ucyA/IDIgOiAwXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnRhcmdldC5jbHMuaW5jbHVkZXMoJ25lby10cmVlbGlzdC1tZW51LWl0ZW0nKSkge1xuICAgICAgICAgICAgdGhpcy5vbk1lbnVJdGVtQ2xpY2soZGF0YS50YXJnZXQuY2xzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIub25DbGljayhkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2hvd0NvbGxhcHNlRXhwYW5kQWxsSWNvbnMpIHtcbiAgICAgICAgICAgIG1lLnZkb20uY24udW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgY2xzOiBbJ25lby10cmVlbGlzdC1tZW51LWl0ZW0nLCAnbmVvLXRyZWVsaXN0LWNvbGxhcHNlLWFsbC1pY29uJ10sXG4gICAgICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBbJ25lby10cmVlbGlzdC1tZW51LWl0ZW0tY29udGVudCddXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLXRyZWVsaXN0LW1lbnUtaXRlbScsICduZW8tdHJlZWxpc3QtZXhwYW5kLWFsbC1pY29uJ10sXG4gICAgICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBbJ25lby10cmVlbGlzdC1tZW51LWl0ZW0tY29udGVudCddXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpdGVtc30gICAgID0gbWUuc3RvcmUsXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGtleVByb3BlcnR5ID0gbWUuZ2V0S2V5UHJvcGVydHkoKSxcbiAgICAgICAgICAgIHBhdGggICAgICAgID0gZGF0YS5wYXRoLm1hcChlID0+IGUuaWQpLFxuICAgICAgICAgICAgaXRlbSwgcmVjb3JkLCB0bXBJdGVtLCB2bm9kZUlkO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRtcEl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIHZub2RlSWQgPSBtZS5nZXRJdGVtSWQodG1wSXRlbVtrZXlQcm9wZXJ0eV0pO1xuXG4gICAgICAgICAgICBpZiAocGF0aC5pbmNsdWRlcyh2bm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRtcEl0ZW07XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lLmdldFZkb21DaGlsZCh2bm9kZUlkKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNscz8uaW5jbHVkZXMobWUuZm9sZGVyQ2xzKSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZShpdGVtLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGlzT3BlbiAgICAgICAgICAgICAgPSBpdGVtLmNscy5pbmNsdWRlcygnbmVvLWZvbGRlci1vcGVuJyksXG4gICAgICAgICAgICAgICAgICAgIHtwYXJlbnROb2RlLCBpbmRleH0gPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIGl0ZW0uaWQpLFxuICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZyAgICAgICAgID0gcGFyZW50Tm9kZS5jbltpbmRleCArIDFdO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5zdHlsZS5wb3NpdGlvbiA9IGlzT3BlbiA/ICdzdGlja3knIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLnRvcCAgICAgID0gaXNPcGVuID8gKGl0ZW0ubGV2ZWwgKiAzOCkgKyAncHgnIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0U2libGluZz8udGFnID09PSAndWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZURvbSA9ICFpc09wZW5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5vbkxlYWZJdGVtQ2xpY2socmVjb3JkKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBsZWFmSXRlbUNsaWNrIGV2ZW50IGZpcmVzIHdoZW4gYSBjbGljayBvY2N1cnMgb24gYSBsaXN0IGl0ZW0gd2hpY2ggZG9lcyBub3QgaGF2ZSBjaGlsZCBpdGVtcy5cbiAgICAgICAgICAgICAgICAgKiBQYXNzZXMgdGhlIGl0ZW0gcmVjb3JkIHRvIHRoZSBldmVudCBoYW5kbGVyLlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBsZWFmSXRlbUNsaWNrXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gcmVjb3JkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnbGVhZkl0ZW1DbGljaycsIHJlY29yZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3VwZXIub25JdGVtQ2xpY2sobm9kZSwgZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKi9cbiAgICBvbkxlYWZJdGVtQ2xpY2socmVjb3JkKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBieSBjbGlja3Mgb24gdGhlIGNvbGxhcHNlIG9yIGV4cGFuZCBhbGwgaWNvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjbHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25NZW51SXRlbUNsaWNrKGNscykge1xuICAgICAgICBpZiAoY2xzLmluY2x1ZGVzKCduZW8tdHJlZWxpc3QtY29sbGFwc2UtYWxsLWljb24nKSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZUFsbCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZEFsbCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlcyB0aGUgc2Nyb2xsIHN0cmVhbSBmcm9tIHRoZSBNYWluIFRocmVhZCB0byBkZXRlY3Qgc3RpY2t5IHN0YXRlcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYHNhdmVTY3JvbGxQb3NpdGlvbmAgaXMgdHJ1ZSwgdGhpcyBtZXRob2QgY2FsY3VsYXRlcyB3aGljaCBmb2xkZXIgaGVhZGVycyBhcmUgY3VycmVudGx5XG4gICAgICogcGlubmVkIChcInN0dWNrXCIpIHRvIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IGJ5IGNvbXBhcmluZyB0aGVpciBjb21wdXRlZCBgdG9wYCBzdHlsZSB3aXRoXG4gICAgICogdGhlIGN1cnJlbnQgYHNjcm9sbFRvcGAuIEl0IHRvZ2dsZXMgdGhlIGBuZW8tc3R1Y2tgIGNsYXNzIG9uIHRoZXNlIGl0ZW1zLCBhbGxvd2luZyBmb3JcbiAgICAgKiBjb25kaXRpb25hbCBzdHlsaW5nIChlLmcuIGJhY2tncm91bmQgb3BhY2l0eSkgb25seSB3aGVuIGhlYWRlcnMgYXJlIHN0aWNraW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JvbGxUb3AgVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25TY3JvbGxDYXB0dXJlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25TY3JvbGxDYXB0dXJlKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnNhdmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgICAgICAgbGV0IHNjcm9sbFRvcCAgICAgICA9IGRhdGEuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHkgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgc3R1Y2tDYW5kaWRhdGVzID0ge307XG5cbiAgICAgICAgICAgIGNvbnN0IHRyYXZlcnNlID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuY24pIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGxldCBsYXN0Rm9sZGVyT3BlbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBub2RlLmNuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2xzLmluY2x1ZGVzKG1lLmZvbGRlckNscykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9wU3R5bGUgPSBjaGlsZC5zdHlsZS50b3A7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzU3R1Y2sgPSBzY3JvbGxUb3AgPiAwICYmICh5IC0gc2Nyb2xsVG9wKSA8PSBwYXJzZUludCh0b3BTdHlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3R1Y2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsZXZlbCA9IGNoaWxkLmxldmVsIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHVja0NhbmRpZGF0ZXNbbGV2ZWxdID8/PSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0dWNrQ2FuZGlkYXRlc1tsZXZlbF0ucHVzaChjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jbHMuaW5jbHVkZXMoJ25lby1zdHVjaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNoaWxkLmNscywgJ25lby1zdHVjaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEZvbGRlck9wZW4gPSBjaGlsZC5jbHMuaW5jbHVkZXMoJ25lby1mb2xkZXItb3BlbicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RGb2xkZXJPcGVuID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuc3R5bGU/LmRpc3BsYXkgIT09ICdub25lJyAmJiAhY2hpbGQucmVtb3ZlRG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSA1MVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLnRhZyA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RGb2xkZXJPcGVuICYmICFjaGlsZC5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobWUudmRvbS5jbiAmJiBtZS52ZG9tLmNuWzBdKSB7XG4gICAgICAgICAgICAgICAgdHJhdmVyc2UobWUudmRvbS5jblswXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhzdHVja0NhbmRpZGF0ZXMpLmZvckVhY2goaXRlbXMgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkQmVTdHVjayA9IChpdGVtID09PSBsYXN0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NsYXNzICAgICAgPSBpdGVtLmNscy5pbmNsdWRlcygnbmVvLXN0dWNrJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEJlU3R1Y2sgIT09IGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS50b2dnbGUoaXRlbS5jbHMsICduZW8tc3R1Y2snLCBzaG91bGRCZVN0dWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICovXG4gICAgb25TdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWNvcmR9ICAgICAgICAgICAgPSBkYXRhLFxuICAgICAgICAgICAge2luZGV4LCBwYXJlbnROb2RlfSA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbWUuZ2V0SXRlbUlkKHJlY29yZC5pZCkpO1xuXG4gICAgICAgIHBhcmVudE5vZGUuY25baW5kZXhdID0gbWUuY3JlYXRlSXRlbShyZWNvcmQpO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUcmVlKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=