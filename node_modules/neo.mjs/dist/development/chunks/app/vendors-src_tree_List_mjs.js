export const __webpack_esm_id__ = "vendors-src_tree_List_mjs";
export const __webpack_esm_ids__ = ["vendors-src_tree_List_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/selection/TreeModel.mjs"
/*!*************************************!*\
  !*** ./src/selection/TreeModel.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ListModel.mjs */ "./src/selection/ListModel.mjs");


/**
 * @class Neo.selection.TreeModel
 * @extends Neo.selection.ListModel
 */
class TreeModel extends _ListModel_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.selection.TreeModel'
         * @protected
         */
        className: 'Neo.selection.TreeModel',
        /**
         * @member {String} ntype='selection-treemodel'
         * @protected
         */
        ntype: 'selection-treemodel'
    }

    /**
     * @param {Object} data
     */
    onKeyDownEnter(data) {
        // Neo.log('onKeyDownEnter', data)
    }

    /**
     * @param {Object} data
     * @param {Number} step
     */
    onNavKey(data, step) {
        // Neo.log('onNavKey', data, step)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeModel));


/***/ },

/***/ "./src/tree/List.mjs"
/*!***************************!*\
  !*** ./src/tree/List.mjs ***!
  \***************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../list/Base.mjs */ "./src/list/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _selection_TreeModel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../selection/TreeModel.mjs */ "./src/selection/TreeModel.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");







/**
 * @summary A hierarchical list component supporting nested folders, expansion, and sticky headers.
 *
 * This component renders hierarchical data structures (trees) using a flat store managed by a `Neo.selection.TreeModel`.
 * It provides built-in support for:
 * - **Recursive rendering:** Efficiently renders deeply nested folder structures.
 * - **Collapsible folders:** Interactive expand/collapse functionality for branch nodes.
 * - **Sticky Headers:** Folder headers use CSS `position: sticky` to remain visible while scrolling through their content.
 * - **Stuck State Detection:** When `saveScrollPosition` is enabled, the component tracks the sticky state via JS and applies
 *   a `.neo-stuck` class to headers that are currently pinned. This is useful for visual customization, such as applying
 *   backgrounds to transparent items.
 * - **Drag and Drop:** Supports reordering via `dragResortable` or moving items between lists via `draggable`.
 * - **Filtering:** Deep-filtering that preserves folder structures for matched leaf nodes.
 *
 * Keywords: `Hierarchical Data`, `Tree View`, `Recursive List`, `Sticky Headers`, `Folder View`
 *
 * @class Neo.tree.List
 * @extends Neo.list.Base
 * @see Neo.selection.TreeModel
 */
class Tree extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.tree.List'
         * @protected
         */
        className: 'Neo.tree.List',
        /**
         * @member {String} ntype='treelist'
         * @protected
         */
        ntype: 'treelist',
        /**
         * @member {String[]} baseCls=['neo-tree-list']
         */
        baseCls: ['neo-tree-list'],
        /**
         * @member {Boolean} disableSelection=false
         * @reactive
         */
        disableSelection: false,
        /**
         * @member {Boolean} dragResortable_=false
         * @reactive
         */
        dragResortable_: false,
        /**
         * @member {Neo.draggable.tree.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {String} folderCls='neo-list-folder'
         */
        folderCls: 'neo-list-folder',
        /**
         * @member {Boolean} showCollapseExpandAllIcons=true
         */
        showCollapseExpandAllIcons: true,
        /**
         * @member {Neo.draggable.tree.SortZone|null} sortZone=null
         */
        sortZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        sortZoneConfig: null,
        /**
         * @member {String[]} wrapperCls=[]
         * @reactive
         */
        wrapperCls: [],
        /**
         * Set this config to true to monitor the scroll position of the list.
         * This enables the `onScrollCapture` logic which calculates if sticky folder headers
         * are currently in a "stuck" state (pinned to the top), applying the `.neo-stuck` CSS class.
         * Useful for applying visual changes (e.g. background opacity) only when headers are sticking.
         * @member {Boolean} saveScrollPosition=false
         */
        saveScrollPosition: false,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {cn: [
            {tag: 'ul', cls: ['neo-list-container', 'neo-list'], tabIndex: -1, cn: []}
        ]}
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this;

        if (value) {
            if (me.dragResortable) {
                console.error('tree.List can be either draggable or dragResortable, not both.', me.id)
            } else if (!me.dragZone) {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-src_draggable_tree_DragZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/tree/DragZone.mjs */ "./src/draggable/tree/DragZone.mjs")).then(module => {
                    me.dragZone = Neo.create({
                        module  : module.default,
                        appName : me.appName,
                        owner   : me,
                        windowId: me.windowId,
                        ...me.dragZoneConfig
                    })
                })
            }
        }
    }

    /**
     * Triggered after the dragResortable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDragResortable(value, oldValue) {
        let me = this;

        if (value) {
            if (me.draggable) {
                console.error('tree.List can be either draggable or dragResortable, not both.', me.id)
            } else if (!me.sortZone) {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_DragProxyContainer_mjs-src_draggable_tree_SortZone_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/tree/SortZone.mjs */ "./src/draggable/tree/SortZone.mjs")).then(module => {
                    me.sortZone = Neo.create({
                        module             : module.default,
                        appName            : me.appName,
                        boundaryContainerId: me.id,
                        owner              : me,
                        windowId           : me.windowId,
                        ...me.sortZoneConfig
                    })
                })
            }
        }
    }

    /**
     * Triggered before the selectionModel config gets changed.
     * @param {Neo.selection.Model} value
     * @param {Neo.selection.Model} oldValue
     * @returns {Neo.selection.Model}
     * @protected
     */
    beforeSetSelectionModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _selection_TreeModel_mjs__WEBPACK_IMPORTED_MODULE_4__["default"])
    }

    /**
     * Triggered before the store config gets changed.
     * @param {Object|Neo.data.Store} value
     * @param {Object|Neo.data.Store} oldValue
     * @returns {Neo.data.Store}
     * @protected
     */
    beforeSetStore(value, oldValue) {
        if (!value) {
            value = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {
                keyProperty: 'id'
            })
        }

        return super.beforeSetStore(value, oldValue)
    }


    /**
     * Collapses all folders
     * @param {Boolean} [silent]=false Set silent to true to prevent a vnode update
     */
    collapseAll(silent=false) {
        let me       = this,
            hasMatch = false,
            nextSibling, node, parentNode, index;

        me.store.forEach(item => {
            if (!item.isLeaf) {
                node = me.getVdomChild(me.getItemId(item.id), me.vdom);

                if (node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = null;
                    node.style.top      = null;

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = true
                    }

                    hasMatch = true
                }
            }
        });

        if (hasMatch && !silent) {
            me.update()
        }
    }

    /**
     * Creates the VDOM object for a single tree item (leaf or folder).
     *
     * This method is the core VDOM factory for the tree. It constructs the `li` element
     * representing a record. Key responsibilities:
     * 1.  **Class Assignment:** Applies `itemCls`, `folderCls`, and `iconCls` based on record state.
     * 2.  **Hierarchy visualization:** Calculates `zIndex` and `padding` based on depth (`level`).
     * 3.  **Sticky Positioning:** Sets `position: sticky` and calculates `top` offsets for folder nodes
     *     to ensure they stack correctly while scrolling.
     * 4.  **Content:** Creates the label and icon structure.
     *
     * @param {Object} record The data record from the store
     * @returns {Object} The VDOM object for the list item
     */
    createItem(record) {
        let me                   = this,
            {folderCls, itemCls} = me,
            cls                  = [itemCls],
            contentCls           = [itemCls + '-content'],
            keyProperty          = me.getKeyProperty(),
            itemVdom;

        if (record.iconCls) {
            if (Array.isArray(record.iconCls)) {
                contentCls.push(...record.iconCls)
            } else {
                contentCls.push(record.iconCls)
            }
        }

        if (record.isLeaf) {
            cls.push(itemCls + (record.singleton ? '-leaf-singleton' : '-leaf'))
        } else {
            cls.push(folderCls);

            if (!record.collapsed) {
                cls.push('neo-folder-open')
            }
        }

        itemVdom = {
            tag: 'li',
            cls,
            id   : me.getItemId(record[keyProperty]),
            level: record.level,
            cn   : [{
                tag  : 'span',
                cls  : contentCls,
                html : record[me.displayField],
                style: {pointerEvents: 'none'}
            }],
            style: {
                '--neo-tree-level': record.level,
                display           : record.hidden ? 'none' : 'flex',
                padding           : '10px',
                position          : (record.isLeaf || record.collapsed) ? null : 'sticky',
                top               : (record.isLeaf || record.collapsed) ? null : (record.level * 38) + 'px',
                zIndex            : record.isLeaf ? 1 : (10000 + record.level)
            }
        };

        if (me.itemsFocusable) {
            itemVdom.tabIndex = -1
        }

        return itemVdom
    }

    /**
     * Recursively generates the VDOM tree structure starting from a given parent.
     *
     * This method implements the recursive logic required to turn a flat store into a
     * hierarchical DOM structure.
     * - It finds all direct children of the `parentId`.
     * - It creates a `ul` container for them.
     * - For each child, it calls `createItem` to generate the node.
     * - It recursively calls itself (`createItemLevel`) for each child to build the next level.
     *
     * This approach ensures that the visual hierarchy matches the data relationship,
     * supporting arbitrary depth.
     *
     * @param {String} [parentId] The parent node id (null for root level)
     * @param {Object} [vdomRoot] The vdom template root for the current sub tree
     * @param {Number} level The current hierarchy level (depth)
     * @param {Boolean} hidden=false Whether this branch is currently hidden (collapsed parent)
     * @returns {Object} vdomRoot
     * @protected
     */
    createItemLevel(parentId, vdomRoot, level, hidden=false) {
        let me    = this,
            items = me.store.find('parentId', parentId),
            tmpRoot;

        if (items.length > 0) {
            if (!vdomRoot.cn) {
                vdomRoot.cn = []
            }

            if (parentId !== null) {
                vdomRoot.cn.push({
                    tag      : 'ul',
                    cls      : ['neo-list'],
                    cn       : [],
                    removeDom: hidden,
                    style    : {
                        paddingLeft: '15px'
                    }
                });

                tmpRoot = vdomRoot.cn[vdomRoot.cn.length - 1]
            } else {
                tmpRoot = vdomRoot
            }

            items.forEach(record => {
                record.level = level;

                tmpRoot.cn.push(me.createItem(record));

                me.createItemLevel(record.id, tmpRoot, level + 1, record.hidden || hidden || record.collapsed)
            })
        }

        return vdomRoot
    }

    /**
     * The main entry point for rendering the tree's content.
     *
     * This method clears the current list content and initiates the recursive rendering process
     * by calling `createItemLevel` starting from the root (null parent).
     * It is typically called when the store is loaded or when a full refresh is needed.
     *
     * @protected
     */
    createItems() {
        let me        = this,
            itemsRoot = me.getListItemsRoot();

        itemsRoot.cn = [];

        me.createItemLevel(null, itemsRoot, 0);
        me.update()
    }

    /**
     * Expands all folders
     * @param {Boolean} silent=false Set silent to true to prevent a vnode update
     */
    expandAll(silent=false) {
        let me       = this,
            hasMatch = false,
            nextSibling, node, parentNode, index;

        me.store.forEach(item => {
            if (!item.isLeaf) {
                node = me.getVdomChild(me.getItemId(item.id), me.vdom);

                if (!node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = 'sticky';
                    node.style.top      = (node.level * 38) + 'px';

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = false
                    }

                    hasMatch = true
                }
            }
        });

        if (hasMatch && !silent) {
            me.update()
        }
    }

    /**
     * Expands all parent nodes of a given item and scrolls it into view once mounted.
     * @param {String|Number} itemId
     * @returns {Promise<void>}
     */
    async expandAndScrollToItem(itemId) {
        let me = this;

        me.expandParents(itemId);

        const
            id   = me.getItemId(itemId),
            rect = await me.waitForDomRect({id, attempts: 20, delay: 50});

        if (rect) {
            me.scrollToItem(itemId)
        }
    }

    /**
     * Expands all parent folders of a given item
     * @param {String|Number} itemId
     */
    expandParents(itemId) {
        let me       = this,
            item     = me.store.get(itemId),
            hasMatch = false,
            nextSibling, node, parentId, parentNode, index;

        if (item) {
            parentId = item.parentId;

            while (parentId) {
                node = me.getVdomChild(me.getItemId(parentId));

                if (node && !node.cls.includes('neo-folder-open')) {
                    _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].add(node.cls, 'neo-folder-open');

                    ({parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, node.id));
                    nextSibling          = parentNode.cn[index + 1];

                    node.style.position = 'sticky';
                    node.style.top      = (node.level * 38) + 'px';

                    if (nextSibling?.tag === 'ul') {
                        nextSibling.removeDom = false
                    }

                    hasMatch = true
                }

                item     = me.store.get(parentId);
                parentId = item ? item.parentId : null
            }
        }

        if (hasMatch) {
            me.update()
        }
    }

    /**
     * Hides Tree nodes which do not match the filter
     * @param {String} property The store field to filter by
     * @param {String} value The filter value
     * @param {Number|null} parentId The root id for the current filter call
     * @param {Boolean} [parentMatch]=false In case a parent folder matches the filter, show its child items
     * @returns {Boolean} false if at least one child item is filtered
     */
    filter(property, value, parentId, parentMatch = false) {
        let me         = this,
            isFiltered = true,
            valueRegEx = new RegExp(value, 'gi'),
            childReturnValue, directMatch, node;

        if (!value) {
            value = ''
        }

        me.store.forEach(item => {
            if (item.parentId === parentId) {
                directMatch = false;
                node        = me.getVdomChild(me.getItemId(item.id), me.vdom);

                node.cn[0].html = item[property].replace(valueRegEx, match => {
                    directMatch = true;
                    return `<span class="neo-highlight-search">${match}</span>`
                });

                if (item.isLeaf) {
                    childReturnValue = true
                } else {
                    childReturnValue = me.filter(property, value, item.id, directMatch || parentMatch)
                }

                if (directMatch || parentMatch || childReturnValue === false || value === '') {
                    isFiltered = false
                }

                node.style.display = isFiltered ? 'none' : 'list-item'
            }
        });

        if (parentId === null) {
            me.expandAll(true);
            me.update()
        }

        return isFiltered
    }

    /**
     * Scrolls a list item into the visible area
     * @param {String|Number} itemId
     */
    scrollToItem(itemId) {
        let me = this;

        Neo.main.DomAccess.scrollIntoView({
            id      : me.getItemId(itemId),
            inline  : 'start',
            windowId: me.windowId
        })
    }

    /**
     * @returns {Object}
     */
    getListItemsRoot() {
        let me = this,
            cn = me.vdom.cn;

        if (cn.length >= 3 && cn[0].cls?.includes('neo-treelist-collapse-all-icon')) {
            return cn[2]
        }

        return cn[0]
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        if (data.target.cls.includes('neo-treelist-menu-item')) {
            this.onMenuItemClick(data.target.cls)
        } else {
            super.onClick(data)
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.showCollapseExpandAllIcons) {
            me.vdom.cn.unshift({
                cls: ['neo-treelist-menu-item', 'neo-treelist-collapse-all-icon'],
                cn : [{
                    tag: 'span',
                    cls: ['neo-treelist-menu-item-content']
                }]
            }, {
                cls: ['neo-treelist-menu-item', 'neo-treelist-expand-all-icon'],
                cn : [{
                    tag: 'span',
                    cls: ['neo-treelist-menu-item-content']
                }]
            });

            me.update()
        }
    }

    /**
     * @param {Object} node
     * @param {Object} data
     */
    onItemClick(node, data) {
        let me          = this,
            {items}     = me.store,
            i           = 0,
            len         = items.length,
            keyProperty = me.getKeyProperty(),
            path        = data.path.map(e => e.id),
            item, record, tmpItem, vnodeId;

        for (; i < len; i++) {
            tmpItem = items[i];
            vnodeId = me.getItemId(tmpItem[keyProperty]);

            if (path.includes(vnodeId)) {
                record = tmpItem;
                item = me.getVdomChild(vnodeId);
                break
            }
        }

        if (item) {
            if (item.cls?.includes(me.folderCls)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(item.cls, 'neo-folder-open');

                let isOpen              = item.cls.includes('neo-folder-open'),
                    {parentNode, index} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, item.id),
                    nextSibling         = parentNode.cn[index + 1];

                item.style.position = isOpen ? 'sticky' : null;
                item.style.top      = isOpen ? (item.level * 38) + 'px' : null;

                if (nextSibling?.tag === 'ul') {
                    nextSibling.removeDom = !isOpen
                }

                me.update()
            } else {
                me.onLeafItemClick(record);

                /**
                 * The leafItemClick event fires when a click occurs on a list item which does not have child items.
                 * Passes the item record to the event handler.
                 * @event leafItemClick
                 * @returns {Object} record
                 */
                me.fire('leafItemClick', record)
            }

            super.onItemClick(node, data)
        }
    }

    /**
     * Placeholder method
     * @param {Object} record
     */
    onLeafItemClick(record) {

    }

    /**
     * Gets triggered by clicks on the collapse or expand all icons
     * @param {Array} cls
     * @protected
     */
    onMenuItemClick(cls) {
        if (cls.includes('neo-treelist-collapse-all-icon')) {
            this.collapseAll()
        } else {
            this.expandAll()
        }
    }

    /**
     * Captures the scroll stream from the Main Thread to detect sticky states.
     *
     * When `saveScrollPosition` is true, this method calculates which folder headers are currently
     * pinned ("stuck") to the top of the viewport by comparing their computed `top` style with
     * the current `scrollTop`. It toggles the `neo-stuck` class on these items, allowing for
     * conditional styling (e.g. background opacity) only when headers are sticking.
     *
     * @param {Object} data
     * @param {Number} data.scrollTop The current scroll position
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);

        let me = this;

        if (me.saveScrollPosition) {
            let scrollTop       = data.scrollTop,
                needsUpdate     = false,
                y               = 0,
                stuckCandidates = {};

            const traverse = (node) => {
                if (!node.cn) return;

                let lastFolderOpen = true;

                node.cn.forEach(child => {
                    if (child.tag === 'li') {
                        if (child.cls.includes(me.folderCls)) {
                            let topStyle = child.style.top;

                            if (topStyle) {
                                let isStuck = scrollTop > 0 && (y - scrollTop) <= parseInt(topStyle);

                                if (isStuck) {
                                    let level = child.level || 0;
                                    stuckCandidates[level] ??= [];
                                    stuckCandidates[level].push(child)
                                } else {
                                    if (child.cls.includes('neo-stuck')) {
                                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].remove(child.cls, 'neo-stuck');
                                        needsUpdate = true
                                    }
                                }
                            }

                            lastFolderOpen = child.cls.includes('neo-folder-open')
                        } else {
                            lastFolderOpen = true
                        }

                        if (child.style?.display !== 'none' && !child.removeDom) {
                            y += 51
                        }
                    } else if (child.tag === 'ul') {
                        if (lastFolderOpen && !child.removeDom) {
                            traverse(child)
                        }
                    }
                })
            };

            if (me.vdom.cn && me.vdom.cn[0]) {
                traverse(me.vdom.cn[0])
            }

            Object.values(stuckCandidates).forEach(items => {
                let last = items[items.length - 1];

                items.forEach(item => {
                    let shouldBeStuck = (item === last),
                        hasClass      = item.cls.includes('neo-stuck');

                    if (shouldBeStuck !== hasClass) {
                        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].toggle(item.cls, 'neo-stuck', shouldBeStuck);
                        needsUpdate = true
                    }
                })
            });

            if (needsUpdate) {
                me.update()
            }
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Number} data.index
     * @param {Neo.data.Model} data.model
     * @param {Object} data.record
     */
    onStoreRecordChange(data) {
        let me                  = this,
            {record}            = data,
            {index, parentNode} = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vdom, me.getItemId(record.id));

        parentNode.cn[index] = me.createItem(record);

        me.update()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Tree));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190cmVlX0xpc3RfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVM7QUFDakM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUseUJBQXlCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDTTtBQUNPO0FBQ0Q7QUFDTDtBQUNTO0FBQ1Y7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQUk7QUFDdkI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixV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a0M7QUFDbEM7QUFDQSx3Q0FBd0MsdURBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHVEQUFRO0FBQ2hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsbUJBQW1CLEVBQUUsc0RBQVE7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvc2VsZWN0aW9uL1RyZWVNb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90cmVlL0xpc3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaXN0TW9kZWwgZnJvbSAnLi9MaXN0TW9kZWwubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWxcbiAqIEBleHRlbmRzIE5lby5zZWxlY3Rpb24uTGlzdE1vZGVsXG4gKi9cbmNsYXNzIFRyZWVNb2RlbCBleHRlbmRzIExpc3RNb2RlbCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc2VsZWN0aW9uLlRyZWVNb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc2VsZWN0aW9uLXRyZWVtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzZWxlY3Rpb24tdHJlZW1vZGVsJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duRW50ZXIoZGF0YSkge1xuICAgICAgICAvLyBOZW8ubG9nKCdvbktleURvd25FbnRlcicsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFxuICAgICAqL1xuICAgIG9uTmF2S2V5KGRhdGEsIHN0ZXApIHtcbiAgICAgICAgLy8gTmVvLmxvZygnb25OYXZLZXknLCBkYXRhLCBzdGVwKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVHJlZU1vZGVsKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgZnJvbSAnLi4vbGlzdC9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb2xsZWN0aW9uICAgICAgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBUcmVlTW9kZWwgICAgICAgZnJvbSAnLi4vc2VsZWN0aW9uL1RyZWVNb2RlbC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICBmcm9tIFwiLi4vdXRpbC9WRG9tLm1qc1wiO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEEgaGllcmFyY2hpY2FsIGxpc3QgY29tcG9uZW50IHN1cHBvcnRpbmcgbmVzdGVkIGZvbGRlcnMsIGV4cGFuc2lvbiwgYW5kIHN0aWNreSBoZWFkZXJzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IHJlbmRlcnMgaGllcmFyY2hpY2FsIGRhdGEgc3RydWN0dXJlcyAodHJlZXMpIHVzaW5nIGEgZmxhdCBzdG9yZSBtYW5hZ2VkIGJ5IGEgYE5lby5zZWxlY3Rpb24uVHJlZU1vZGVsYC5cbiAqIEl0IHByb3ZpZGVzIGJ1aWx0LWluIHN1cHBvcnQgZm9yOlxuICogLSAqKlJlY3Vyc2l2ZSByZW5kZXJpbmc6KiogRWZmaWNpZW50bHkgcmVuZGVycyBkZWVwbHkgbmVzdGVkIGZvbGRlciBzdHJ1Y3R1cmVzLlxuICogLSAqKkNvbGxhcHNpYmxlIGZvbGRlcnM6KiogSW50ZXJhY3RpdmUgZXhwYW5kL2NvbGxhcHNlIGZ1bmN0aW9uYWxpdHkgZm9yIGJyYW5jaCBub2Rlcy5cbiAqIC0gKipTdGlja3kgSGVhZGVyczoqKiBGb2xkZXIgaGVhZGVycyB1c2UgQ1NTIGBwb3NpdGlvbjogc3RpY2t5YCB0byByZW1haW4gdmlzaWJsZSB3aGlsZSBzY3JvbGxpbmcgdGhyb3VnaCB0aGVpciBjb250ZW50LlxuICogLSAqKlN0dWNrIFN0YXRlIERldGVjdGlvbjoqKiBXaGVuIGBzYXZlU2Nyb2xsUG9zaXRpb25gIGlzIGVuYWJsZWQsIHRoZSBjb21wb25lbnQgdHJhY2tzIHRoZSBzdGlja3kgc3RhdGUgdmlhIEpTIGFuZCBhcHBsaWVzXG4gKiAgIGEgYC5uZW8tc3R1Y2tgIGNsYXNzIHRvIGhlYWRlcnMgdGhhdCBhcmUgY3VycmVudGx5IHBpbm5lZC4gVGhpcyBpcyB1c2VmdWwgZm9yIHZpc3VhbCBjdXN0b21pemF0aW9uLCBzdWNoIGFzIGFwcGx5aW5nXG4gKiAgIGJhY2tncm91bmRzIHRvIHRyYW5zcGFyZW50IGl0ZW1zLlxuICogLSAqKkRyYWcgYW5kIERyb3A6KiogU3VwcG9ydHMgcmVvcmRlcmluZyB2aWEgYGRyYWdSZXNvcnRhYmxlYCBvciBtb3ZpbmcgaXRlbXMgYmV0d2VlbiBsaXN0cyB2aWEgYGRyYWdnYWJsZWAuXG4gKiAtICoqRmlsdGVyaW5nOioqIERlZXAtZmlsdGVyaW5nIHRoYXQgcHJlc2VydmVzIGZvbGRlciBzdHJ1Y3R1cmVzIGZvciBtYXRjaGVkIGxlYWYgbm9kZXMuXG4gKlxuICogS2V5d29yZHM6IGBIaWVyYXJjaGljYWwgRGF0YWAsIGBUcmVlIFZpZXdgLCBgUmVjdXJzaXZlIExpc3RgLCBgU3RpY2t5IEhlYWRlcnNgLCBgRm9sZGVyIFZpZXdgXG4gKlxuICogQGNsYXNzIE5lby50cmVlLkxpc3RcbiAqIEBleHRlbmRzIE5lby5saXN0LkJhc2VcbiAqIEBzZWUgTmVvLnNlbGVjdGlvbi5UcmVlTW9kZWxcbiAqL1xuY2xhc3MgVHJlZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRyZWUuTGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRyZWUuTGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0cmVlbGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0cmVlbGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby10cmVlLWxpc3QnXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdHJlZS1saXN0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlU2VsZWN0aW9uPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZVNlbGVjdGlvbjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnUmVzb3J0YWJsZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUmVzb3J0YWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS50cmVlLkRyYWdab25lfG51bGx9IGRyYWdab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBmb2xkZXJDbHM9J25lby1saXN0LWZvbGRlcidcbiAgICAgICAgICovXG4gICAgICAgIGZvbGRlckNsczogJ25lby1saXN0LWZvbGRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29ucz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzaG93Q29sbGFwc2VFeHBhbmRBbGxJY29uczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUudHJlZS5Tb3J0Wm9uZXxudWxsfSBzb3J0Wm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0Wm9uZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZHJhZ1pvbmVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ydFpvbmVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gd3JhcHBlckNscz1bXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBwZXJDbHM6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgdG8gbW9uaXRvciB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBsaXN0LlxuICAgICAgICAgKiBUaGlzIGVuYWJsZXMgdGhlIGBvblNjcm9sbENhcHR1cmVgIGxvZ2ljIHdoaWNoIGNhbGN1bGF0ZXMgaWYgc3RpY2t5IGZvbGRlciBoZWFkZXJzXG4gICAgICAgICAqIGFyZSBjdXJyZW50bHkgaW4gYSBcInN0dWNrXCIgc3RhdGUgKHBpbm5lZCB0byB0aGUgdG9wKSwgYXBwbHlpbmcgdGhlIGAubmVvLXN0dWNrYCBDU1MgY2xhc3MuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgYXBwbHlpbmcgdmlzdWFsIGNoYW5nZXMgKGUuZy4gYmFja2dyb3VuZCBvcGFjaXR5KSBvbmx5IHdoZW4gaGVhZGVycyBhcmUgc3RpY2tpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNhdmVTY3JvbGxQb3NpdGlvbj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2F2ZVNjcm9sbFBvc2l0aW9uOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gX3Zkb21cbiAgICAgICAgICovXG4gICAgICAgIF92ZG9tOlxuICAgICAgICB7Y246IFtcbiAgICAgICAgICAgIHt0YWc6ICd1bCcsIGNsczogWyduZW8tbGlzdC1jb250YWluZXInLCAnbmVvLWxpc3QnXSwgdGFiSW5kZXg6IC0xLCBjbjogW119XG4gICAgICAgIF19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcmFnZ2FibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobWUuZHJhZ1Jlc29ydGFibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmVlLkxpc3QgY2FuIGJlIGVpdGhlciBkcmFnZ2FibGUgb3IgZHJhZ1Jlc29ydGFibGUsIG5vdCBib3RoLicsIG1lLmlkKVxuICAgICAgICAgICAgfSBlbHNlIGlmICghbWUuZHJhZ1pvbmUpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4uL2RyYWdnYWJsZS90cmVlL0RyYWdab25lLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcE5hbWUgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWUuZHJhZ1pvbmVDb25maWdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnUmVzb3J0YWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyYWdSZXNvcnRhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG1lLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyZWUuTGlzdCBjYW4gYmUgZWl0aGVyIGRyYWdnYWJsZSBvciBkcmFnUmVzb3J0YWJsZSwgbm90IGJvdGguJywgbWUuaWQpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtZS5zb3J0Wm9uZSkge1xuICAgICAgICAgICAgICAgIGltcG9ydCgnLi4vZHJhZ2dhYmxlL3RyZWUvU29ydFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5zb3J0Wm9uZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogbW9kdWxlLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWUuc29ydFpvbmVDb25maWdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2VsZWN0aW9uTW9kZWwgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge05lby5zZWxlY3Rpb24uTW9kZWx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uc2VsZWN0aW9uLk1vZGVsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uc2VsZWN0aW9uLk1vZGVsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTZWxlY3Rpb25Nb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBUcmVlTW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5TdG9yZX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE5lby5jcmVhdGUoQ29sbGVjdGlvbiwge1xuICAgICAgICAgICAgICAgIGtleVByb3BlcnR5OiAnaWQnXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmJlZm9yZVNldFN0b3JlKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhbGwgZm9sZGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudF09ZmFsc2UgU2V0IHNpbGVudCB0byB0cnVlIHRvIHByZXZlbnQgYSB2bm9kZSB1cGRhdGVcbiAgICAgKi9cbiAgICBjb2xsYXBzZUFsbChzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0U2libGluZywgbm9kZSwgcGFyZW50Tm9kZSwgaW5kZXg7XG5cbiAgICAgICAgbWUuc3RvcmUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWUuZ2V0VmRvbUNoaWxkKG1lLmdldEl0ZW1JZChpdGVtLmlkKSwgbWUudmRvbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jbHMuaW5jbHVkZXMoJ25lby1mb2xkZXItb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShub2RlLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgICh7cGFyZW50Tm9kZSwgaW5kZXh9ID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBub2RlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nICAgICAgICAgID0gcGFyZW50Tm9kZS5jbltpbmRleCArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnRvcCAgICAgID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmc/LnRhZyA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzTWF0Y2ggJiYgIXNpbGVudCkge1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFZET00gb2JqZWN0IGZvciBhIHNpbmdsZSB0cmVlIGl0ZW0gKGxlYWYgb3IgZm9sZGVyKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSBjb3JlIFZET00gZmFjdG9yeSBmb3IgdGhlIHRyZWUuIEl0IGNvbnN0cnVjdHMgdGhlIGBsaWAgZWxlbWVudFxuICAgICAqIHJlcHJlc2VudGluZyBhIHJlY29yZC4gS2V5IHJlc3BvbnNpYmlsaXRpZXM6XG4gICAgICogMS4gICoqQ2xhc3MgQXNzaWdubWVudDoqKiBBcHBsaWVzIGBpdGVtQ2xzYCwgYGZvbGRlckNsc2AsIGFuZCBgaWNvbkNsc2AgYmFzZWQgb24gcmVjb3JkIHN0YXRlLlxuICAgICAqIDIuICAqKkhpZXJhcmNoeSB2aXN1YWxpemF0aW9uOioqIENhbGN1bGF0ZXMgYHpJbmRleGAgYW5kIGBwYWRkaW5nYCBiYXNlZCBvbiBkZXB0aCAoYGxldmVsYCkuXG4gICAgICogMy4gICoqU3RpY2t5IFBvc2l0aW9uaW5nOioqIFNldHMgYHBvc2l0aW9uOiBzdGlja3lgIGFuZCBjYWxjdWxhdGVzIGB0b3BgIG9mZnNldHMgZm9yIGZvbGRlciBub2Rlc1xuICAgICAqICAgICB0byBlbnN1cmUgdGhleSBzdGFjayBjb3JyZWN0bHkgd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIDQuICAqKkNvbnRlbnQ6KiogQ3JlYXRlcyB0aGUgbGFiZWwgYW5kIGljb24gc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCBUaGUgZGF0YSByZWNvcmQgZnJvbSB0aGUgc3RvcmVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgVkRPTSBvYmplY3QgZm9yIHRoZSBsaXN0IGl0ZW1cbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtKHJlY29yZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2ZvbGRlckNscywgaXRlbUNsc30gPSBtZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgICAgID0gW2l0ZW1DbHNdLFxuICAgICAgICAgICAgY29udGVudENscyAgICAgICAgICAgPSBbaXRlbUNscyArICctY29udGVudCddLFxuICAgICAgICAgICAga2V5UHJvcGVydHkgICAgICAgICAgPSBtZS5nZXRLZXlQcm9wZXJ0eSgpLFxuICAgICAgICAgICAgaXRlbVZkb207XG5cbiAgICAgICAgaWYgKHJlY29yZC5pY29uQ2xzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWNvcmQuaWNvbkNscykpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q2xzLnB1c2goLi4ucmVjb3JkLmljb25DbHMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRDbHMucHVzaChyZWNvcmQuaWNvbkNscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWNvcmQuaXNMZWFmKSB7XG4gICAgICAgICAgICBjbHMucHVzaChpdGVtQ2xzICsgKHJlY29yZC5zaW5nbGV0b24gPyAnLWxlYWYtc2luZ2xldG9uJyA6ICctbGVhZicpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xzLnB1c2goZm9sZGVyQ2xzKTtcblxuICAgICAgICAgICAgaWYgKCFyZWNvcmQuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgY2xzLnB1c2goJ25lby1mb2xkZXItb3BlbicpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtVmRvbSA9IHtcbiAgICAgICAgICAgIHRhZzogJ2xpJyxcbiAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgIGlkICAgOiBtZS5nZXRJdGVtSWQocmVjb3JkW2tleVByb3BlcnR5XSksXG4gICAgICAgICAgICBsZXZlbDogcmVjb3JkLmxldmVsLFxuICAgICAgICAgICAgY24gICA6IFt7XG4gICAgICAgICAgICAgICAgdGFnICA6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICBjbHMgIDogY29udGVudENscyxcbiAgICAgICAgICAgICAgICBodG1sIDogcmVjb3JkW21lLmRpc3BsYXlGaWVsZF0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtwb2ludGVyRXZlbnRzOiAnbm9uZSd9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgJy0tbmVvLXRyZWUtbGV2ZWwnOiByZWNvcmQubGV2ZWwsXG4gICAgICAgICAgICAgICAgZGlzcGxheSAgICAgICAgICAgOiByZWNvcmQuaGlkZGVuID8gJ25vbmUnIDogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgICAgICAgICAgIDogJzEwcHgnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICAgICAgICAgIDogKHJlY29yZC5pc0xlYWYgfHwgcmVjb3JkLmNvbGxhcHNlZCkgPyBudWxsIDogJ3N0aWNreScsXG4gICAgICAgICAgICAgICAgdG9wICAgICAgICAgICAgICAgOiAocmVjb3JkLmlzTGVhZiB8fCByZWNvcmQuY29sbGFwc2VkKSA/IG51bGwgOiAocmVjb3JkLmxldmVsICogMzgpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB6SW5kZXggICAgICAgICAgICA6IHJlY29yZC5pc0xlYWYgPyAxIDogKDEwMDAwICsgcmVjb3JkLmxldmVsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtZS5pdGVtc0ZvY3VzYWJsZSkge1xuICAgICAgICAgICAgaXRlbVZkb20udGFiSW5kZXggPSAtMVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1WZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZ2VuZXJhdGVzIHRoZSBWRE9NIHRyZWUgc3RydWN0dXJlIHN0YXJ0aW5nIGZyb20gYSBnaXZlbiBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSByZWN1cnNpdmUgbG9naWMgcmVxdWlyZWQgdG8gdHVybiBhIGZsYXQgc3RvcmUgaW50byBhXG4gICAgICogaGllcmFyY2hpY2FsIERPTSBzdHJ1Y3R1cmUuXG4gICAgICogLSBJdCBmaW5kcyBhbGwgZGlyZWN0IGNoaWxkcmVuIG9mIHRoZSBgcGFyZW50SWRgLlxuICAgICAqIC0gSXQgY3JlYXRlcyBhIGB1bGAgY29udGFpbmVyIGZvciB0aGVtLlxuICAgICAqIC0gRm9yIGVhY2ggY2hpbGQsIGl0IGNhbGxzIGBjcmVhdGVJdGVtYCB0byBnZW5lcmF0ZSB0aGUgbm9kZS5cbiAgICAgKiAtIEl0IHJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiAoYGNyZWF0ZUl0ZW1MZXZlbGApIGZvciBlYWNoIGNoaWxkIHRvIGJ1aWxkIHRoZSBuZXh0IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBhcHByb2FjaCBlbnN1cmVzIHRoYXQgdGhlIHZpc3VhbCBoaWVyYXJjaHkgbWF0Y2hlcyB0aGUgZGF0YSByZWxhdGlvbnNoaXAsXG4gICAgICogc3VwcG9ydGluZyBhcmJpdHJhcnkgZGVwdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmVudElkXSBUaGUgcGFyZW50IG5vZGUgaWQgKG51bGwgZm9yIHJvb3QgbGV2ZWwpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt2ZG9tUm9vdF0gVGhlIHZkb20gdGVtcGxhdGUgcm9vdCBmb3IgdGhlIGN1cnJlbnQgc3ViIHRyZWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIGN1cnJlbnQgaGllcmFyY2h5IGxldmVsIChkZXB0aClcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhpZGRlbj1mYWxzZSBXaGV0aGVyIHRoaXMgYnJhbmNoIGlzIGN1cnJlbnRseSBoaWRkZW4gKGNvbGxhcHNlZCBwYXJlbnQpXG4gICAgICogQHJldHVybnMge09iamVjdH0gdmRvbVJvb3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlSXRlbUxldmVsKHBhcmVudElkLCB2ZG9tUm9vdCwgbGV2ZWwsIGhpZGRlbj1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgPSBtZS5zdG9yZS5maW5kKCdwYXJlbnRJZCcsIHBhcmVudElkKSxcbiAgICAgICAgICAgIHRtcFJvb3Q7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghdmRvbVJvb3QuY24pIHtcbiAgICAgICAgICAgICAgICB2ZG9tUm9vdC5jbiA9IFtdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZkb21Sb290LmNuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0YWcgICAgICA6ICd1bCcsXG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogWyduZW8tbGlzdCddLFxuICAgICAgICAgICAgICAgICAgICBjbiAgICAgICA6IFtdLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVEb206IGhpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogJzE1cHgnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRtcFJvb3QgPSB2ZG9tUm9vdC5jblt2ZG9tUm9vdC5jbi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bXBSb290ID0gdmRvbVJvb3RcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaChyZWNvcmQgPT4ge1xuICAgICAgICAgICAgICAgIHJlY29yZC5sZXZlbCA9IGxldmVsO1xuXG4gICAgICAgICAgICAgICAgdG1wUm9vdC5jbi5wdXNoKG1lLmNyZWF0ZUl0ZW0ocmVjb3JkKSk7XG5cbiAgICAgICAgICAgICAgICBtZS5jcmVhdGVJdGVtTGV2ZWwocmVjb3JkLmlkLCB0bXBSb290LCBsZXZlbCArIDEsIHJlY29yZC5oaWRkZW4gfHwgaGlkZGVuIHx8IHJlY29yZC5jb2xsYXBzZWQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZkb21Sb290XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIHJlbmRlcmluZyB0aGUgdHJlZSdzIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjbGVhcnMgdGhlIGN1cnJlbnQgbGlzdCBjb250ZW50IGFuZCBpbml0aWF0ZXMgdGhlIHJlY3Vyc2l2ZSByZW5kZXJpbmcgcHJvY2Vzc1xuICAgICAqIGJ5IGNhbGxpbmcgYGNyZWF0ZUl0ZW1MZXZlbGAgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCAobnVsbCBwYXJlbnQpLlxuICAgICAqIEl0IGlzIHR5cGljYWxseSBjYWxsZWQgd2hlbiB0aGUgc3RvcmUgaXMgbG9hZGVkIG9yIHdoZW4gYSBmdWxsIHJlZnJlc2ggaXMgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zUm9vdCA9IG1lLmdldExpc3RJdGVtc1Jvb3QoKTtcblxuICAgICAgICBpdGVtc1Jvb3QuY24gPSBbXTtcblxuICAgICAgICBtZS5jcmVhdGVJdGVtTGV2ZWwobnVsbCwgaXRlbXNSb290LCAwKTtcbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFsbCBmb2xkZXJzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2UgU2V0IHNpbGVudCB0byB0cnVlIHRvIHByZXZlbnQgYSB2bm9kZSB1cGRhdGVcbiAgICAgKi9cbiAgICBleHBhbmRBbGwoc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNNYXRjaCA9IGZhbHNlLFxuICAgICAgICAgICAgbmV4dFNpYmxpbmcsIG5vZGUsIHBhcmVudE5vZGUsIGluZGV4O1xuXG4gICAgICAgIG1lLnN0b3JlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1lLmdldFZkb21DaGlsZChtZS5nZXRJdGVtSWQoaXRlbS5pZCksIG1lLnZkb20pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmNscy5pbmNsdWRlcygnbmVvLWZvbGRlci1vcGVuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKG5vZGUuY2xzLCAnbmVvLWZvbGRlci1vcGVuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgKHtwYXJlbnROb2RlLCBpbmRleH0gPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIG5vZGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgICAgICAgICAgPSBwYXJlbnROb2RlLmNuW2luZGV4ICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdzdGlja3knO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnRvcCAgICAgID0gKG5vZGUubGV2ZWwgKiAzOCkgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U2libGluZz8udGFnID09PSAndWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZy5yZW1vdmVEb20gPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzTWF0Y2ggJiYgIXNpbGVudCkge1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIHBhcmVudCBub2RlcyBvZiBhIGdpdmVuIGl0ZW0gYW5kIHNjcm9sbHMgaXQgaW50byB2aWV3IG9uY2UgbW91bnRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1JZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGV4cGFuZEFuZFNjcm9sbFRvSXRlbShpdGVtSWQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5leHBhbmRQYXJlbnRzKGl0ZW1JZCk7XG5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGlkICAgPSBtZS5nZXRJdGVtSWQoaXRlbUlkKSxcbiAgICAgICAgICAgIHJlY3QgPSBhd2FpdCBtZS53YWl0Rm9yRG9tUmVjdCh7aWQsIGF0dGVtcHRzOiAyMCwgZGVsYXk6IDUwfSk7XG5cbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIG1lLnNjcm9sbFRvSXRlbShpdGVtSWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFsbCBwYXJlbnQgZm9sZGVycyBvZiBhIGdpdmVuIGl0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1JZFxuICAgICAqL1xuICAgIGV4cGFuZFBhcmVudHMoaXRlbUlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtICAgICA9IG1lLnN0b3JlLmdldChpdGVtSWQpLFxuICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZSxcbiAgICAgICAgICAgIG5leHRTaWJsaW5nLCBub2RlLCBwYXJlbnRJZCwgcGFyZW50Tm9kZSwgaW5kZXg7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHBhcmVudElkID0gaXRlbS5wYXJlbnRJZDtcblxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1lLmdldFZkb21DaGlsZChtZS5nZXRJdGVtSWQocGFyZW50SWQpKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmICFub2RlLmNscy5pbmNsdWRlcygnbmVvLWZvbGRlci1vcGVuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkuYWRkKG5vZGUuY2xzLCAnbmVvLWZvbGRlci1vcGVuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgKHtwYXJlbnROb2RlLCBpbmRleH0gPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIG5vZGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgICAgICAgICAgPSBwYXJlbnROb2RlLmNuW2luZGV4ICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdzdGlja3knO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnRvcCAgICAgID0gKG5vZGUubGV2ZWwgKiAzOCkgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U2libGluZz8udGFnID09PSAndWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZy5yZW1vdmVEb20gPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbSAgICAgPSBtZS5zdG9yZS5nZXQocGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIHBhcmVudElkID0gaXRlbSA/IGl0ZW0ucGFyZW50SWQgOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyBUcmVlIG5vZGVzIHdoaWNoIGRvIG5vdCBtYXRjaCB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBzdG9yZSBmaWVsZCB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGZpbHRlciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHBhcmVudElkIFRoZSByb290IGlkIGZvciB0aGUgY3VycmVudCBmaWx0ZXIgY2FsbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmVudE1hdGNoXT1mYWxzZSBJbiBjYXNlIGEgcGFyZW50IGZvbGRlciBtYXRjaGVzIHRoZSBmaWx0ZXIsIHNob3cgaXRzIGNoaWxkIGl0ZW1zXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGZhbHNlIGlmIGF0IGxlYXN0IG9uZSBjaGlsZCBpdGVtIGlzIGZpbHRlcmVkXG4gICAgICovXG4gICAgZmlsdGVyKHByb3BlcnR5LCB2YWx1ZSwgcGFyZW50SWQsIHBhcmVudE1hdGNoID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXNGaWx0ZXJlZCA9IHRydWUsXG4gICAgICAgICAgICB2YWx1ZVJlZ0V4ID0gbmV3IFJlZ0V4cCh2YWx1ZSwgJ2dpJyksXG4gICAgICAgICAgICBjaGlsZFJldHVyblZhbHVlLCBkaXJlY3RNYXRjaCwgbm9kZTtcblxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnXG4gICAgICAgIH1cblxuICAgICAgICBtZS5zdG9yZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucGFyZW50SWQgPT09IHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0TWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlICAgICAgICA9IG1lLmdldFZkb21DaGlsZChtZS5nZXRJdGVtSWQoaXRlbS5pZCksIG1lLnZkb20pO1xuXG4gICAgICAgICAgICAgICAgbm9kZS5jblswXS5odG1sID0gaXRlbVtwcm9wZXJ0eV0ucmVwbGFjZSh2YWx1ZVJlZ0V4LCBtYXRjaCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA8c3BhbiBjbGFzcz1cIm5lby1oaWdobGlnaHQtc2VhcmNoXCI+JHttYXRjaH08L3NwYW4+YFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUmV0dXJuVmFsdWUgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZXR1cm5WYWx1ZSA9IG1lLmZpbHRlcihwcm9wZXJ0eSwgdmFsdWUsIGl0ZW0uaWQsIGRpcmVjdE1hdGNoIHx8IHBhcmVudE1hdGNoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3RNYXRjaCB8fCBwYXJlbnRNYXRjaCB8fCBjaGlsZFJldHVyblZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGaWx0ZXJlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gaXNGaWx0ZXJlZCA/ICdub25lJyA6ICdsaXN0LWl0ZW0nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwYXJlbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbWUuZXhwYW5kQWxsKHRydWUpO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0ZpbHRlcmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyBhIGxpc3QgaXRlbSBpbnRvIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1JZFxuICAgICAqL1xuICAgIHNjcm9sbFRvSXRlbShpdGVtSWQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgaWQgICAgICA6IG1lLmdldEl0ZW1JZChpdGVtSWQpLFxuICAgICAgICAgICAgaW5saW5lICA6ICdzdGFydCcsXG4gICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldExpc3RJdGVtc1Jvb3QoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBjbiA9IG1lLnZkb20uY247XG5cbiAgICAgICAgaWYgKGNuLmxlbmd0aCA+PSAzICYmIGNuWzBdLmNscz8uaW5jbHVkZXMoJ25lby10cmVlbGlzdC1jb2xsYXBzZS1hbGwtaWNvbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gY25bMl1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjblswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DbGljayhkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnRhcmdldC5jbHMuaW5jbHVkZXMoJ25lby10cmVlbGlzdC1tZW51LWl0ZW0nKSkge1xuICAgICAgICAgICAgdGhpcy5vbk1lbnVJdGVtQ2xpY2soZGF0YS50YXJnZXQuY2xzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIub25DbGljayhkYXRhKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuc2hvd0NvbGxhcHNlRXhwYW5kQWxsSWNvbnMpIHtcbiAgICAgICAgICAgIG1lLnZkb20uY24udW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgY2xzOiBbJ25lby10cmVlbGlzdC1tZW51LWl0ZW0nLCAnbmVvLXRyZWVsaXN0LWNvbGxhcHNlLWFsbC1pY29uJ10sXG4gICAgICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBbJ25lby10cmVlbGlzdC1tZW51LWl0ZW0tY29udGVudCddXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLXRyZWVsaXN0LW1lbnUtaXRlbScsICduZW8tdHJlZWxpc3QtZXhwYW5kLWFsbC1pY29uJ10sXG4gICAgICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBbJ25lby10cmVlbGlzdC1tZW51LWl0ZW0tY29udGVudCddXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uSXRlbUNsaWNrKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtpdGVtc30gICAgID0gbWUuc3RvcmUsXG4gICAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGtleVByb3BlcnR5ID0gbWUuZ2V0S2V5UHJvcGVydHkoKSxcbiAgICAgICAgICAgIHBhdGggICAgICAgID0gZGF0YS5wYXRoLm1hcChlID0+IGUuaWQpLFxuICAgICAgICAgICAgaXRlbSwgcmVjb3JkLCB0bXBJdGVtLCB2bm9kZUlkO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRtcEl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIHZub2RlSWQgPSBtZS5nZXRJdGVtSWQodG1wSXRlbVtrZXlQcm9wZXJ0eV0pO1xuXG4gICAgICAgICAgICBpZiAocGF0aC5pbmNsdWRlcyh2bm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRtcEl0ZW07XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lLmdldFZkb21DaGlsZCh2bm9kZUlkKTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNscz8uaW5jbHVkZXMobWUuZm9sZGVyQ2xzKSkge1xuICAgICAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZShpdGVtLmNscywgJ25lby1mb2xkZXItb3BlbicpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGlzT3BlbiAgICAgICAgICAgICAgPSBpdGVtLmNscy5pbmNsdWRlcygnbmVvLWZvbGRlci1vcGVuJyksXG4gICAgICAgICAgICAgICAgICAgIHtwYXJlbnROb2RlLCBpbmRleH0gPSBWRG9tVXRpbC5maW5kKG1lLnZkb20sIGl0ZW0uaWQpLFxuICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZyAgICAgICAgID0gcGFyZW50Tm9kZS5jbltpbmRleCArIDFdO1xuXG4gICAgICAgICAgICAgICAgaXRlbS5zdHlsZS5wb3NpdGlvbiA9IGlzT3BlbiA/ICdzdGlja3knIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLnRvcCAgICAgID0gaXNPcGVuID8gKGl0ZW0ubGV2ZWwgKiAzOCkgKyAncHgnIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0U2libGluZz8udGFnID09PSAndWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZURvbSA9ICFpc09wZW5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5vbkxlYWZJdGVtQ2xpY2socmVjb3JkKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBsZWFmSXRlbUNsaWNrIGV2ZW50IGZpcmVzIHdoZW4gYSBjbGljayBvY2N1cnMgb24gYSBsaXN0IGl0ZW0gd2hpY2ggZG9lcyBub3QgaGF2ZSBjaGlsZCBpdGVtcy5cbiAgICAgICAgICAgICAgICAgKiBQYXNzZXMgdGhlIGl0ZW0gcmVjb3JkIHRvIHRoZSBldmVudCBoYW5kbGVyLlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBsZWFmSXRlbUNsaWNrXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gcmVjb3JkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnbGVhZkl0ZW1DbGljaycsIHJlY29yZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3VwZXIub25JdGVtQ2xpY2sobm9kZSwgZGF0YSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKi9cbiAgICBvbkxlYWZJdGVtQ2xpY2socmVjb3JkKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBieSBjbGlja3Mgb24gdGhlIGNvbGxhcHNlIG9yIGV4cGFuZCBhbGwgaWNvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjbHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25NZW51SXRlbUNsaWNrKGNscykge1xuICAgICAgICBpZiAoY2xzLmluY2x1ZGVzKCduZW8tdHJlZWxpc3QtY29sbGFwc2UtYWxsLWljb24nKSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZUFsbCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZEFsbCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlcyB0aGUgc2Nyb2xsIHN0cmVhbSBmcm9tIHRoZSBNYWluIFRocmVhZCB0byBkZXRlY3Qgc3RpY2t5IHN0YXRlcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYHNhdmVTY3JvbGxQb3NpdGlvbmAgaXMgdHJ1ZSwgdGhpcyBtZXRob2QgY2FsY3VsYXRlcyB3aGljaCBmb2xkZXIgaGVhZGVycyBhcmUgY3VycmVudGx5XG4gICAgICogcGlubmVkIChcInN0dWNrXCIpIHRvIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IGJ5IGNvbXBhcmluZyB0aGVpciBjb21wdXRlZCBgdG9wYCBzdHlsZSB3aXRoXG4gICAgICogdGhlIGN1cnJlbnQgYHNjcm9sbFRvcGAuIEl0IHRvZ2dsZXMgdGhlIGBuZW8tc3R1Y2tgIGNsYXNzIG9uIHRoZXNlIGl0ZW1zLCBhbGxvd2luZyBmb3JcbiAgICAgKiBjb25kaXRpb25hbCBzdHlsaW5nIChlLmcuIGJhY2tncm91bmQgb3BhY2l0eSkgb25seSB3aGVuIGhlYWRlcnMgYXJlIHN0aWNraW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JvbGxUb3AgVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25TY3JvbGxDYXB0dXJlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25TY3JvbGxDYXB0dXJlKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnNhdmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgICAgICAgbGV0IHNjcm9sbFRvcCAgICAgICA9IGRhdGEuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHkgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgc3R1Y2tDYW5kaWRhdGVzID0ge307XG5cbiAgICAgICAgICAgIGNvbnN0IHRyYXZlcnNlID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuY24pIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGxldCBsYXN0Rm9sZGVyT3BlbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBub2RlLmNuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2xzLmluY2x1ZGVzKG1lLmZvbGRlckNscykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9wU3R5bGUgPSBjaGlsZC5zdHlsZS50b3A7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzU3R1Y2sgPSBzY3JvbGxUb3AgPiAwICYmICh5IC0gc2Nyb2xsVG9wKSA8PSBwYXJzZUludCh0b3BTdHlsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3R1Y2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsZXZlbCA9IGNoaWxkLmxldmVsIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHVja0NhbmRpZGF0ZXNbbGV2ZWxdID8/PSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0dWNrQ2FuZGlkYXRlc1tsZXZlbF0ucHVzaChjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jbHMuaW5jbHVkZXMoJ25lby1zdHVjaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNoaWxkLmNscywgJ25lby1zdHVjaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEZvbGRlck9wZW4gPSBjaGlsZC5jbHMuaW5jbHVkZXMoJ25lby1mb2xkZXItb3BlbicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RGb2xkZXJPcGVuID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuc3R5bGU/LmRpc3BsYXkgIT09ICdub25lJyAmJiAhY2hpbGQucmVtb3ZlRG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSA1MVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLnRhZyA9PT0gJ3VsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RGb2xkZXJPcGVuICYmICFjaGlsZC5yZW1vdmVEb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobWUudmRvbS5jbiAmJiBtZS52ZG9tLmNuWzBdKSB7XG4gICAgICAgICAgICAgICAgdHJhdmVyc2UobWUudmRvbS5jblswXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhzdHVja0NhbmRpZGF0ZXMpLmZvckVhY2goaXRlbXMgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdWxkQmVTdHVjayA9IChpdGVtID09PSBsYXN0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NsYXNzICAgICAgPSBpdGVtLmNscy5pbmNsdWRlcygnbmVvLXN0dWNrJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEJlU3R1Y2sgIT09IGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBOZW9BcnJheS50b2dnbGUoaXRlbS5jbHMsICduZW8tc3R1Y2snLCBzaG91bGRCZVN0dWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaW5kZXhcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICovXG4gICAgb25TdG9yZVJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWNvcmR9ICAgICAgICAgICAgPSBkYXRhLFxuICAgICAgICAgICAge2luZGV4LCBwYXJlbnROb2RlfSA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbWUuZ2V0SXRlbUlkKHJlY29yZC5pZCkpO1xuXG4gICAgICAgIHBhcmVudE5vZGUuY25baW5kZXhdID0gbWUuY3JlYXRlSXRlbShyZWNvcmQpO1xuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhUcmVlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==