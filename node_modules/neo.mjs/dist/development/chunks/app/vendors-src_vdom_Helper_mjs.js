"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_vdom_Helper_mjs"],{

/***/ "./src/util/String.mjs":
/*!*****************************!*\
  !*** ./src/util/String.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.String
 * @extends Neo.core.Base
 */
class StringUtil extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @member {Object} charEntityMap
     * @static
     */
    static charEntityMap = {
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        '\'': '&apos;',
        '$' : '&dollar;',
        '\\': '&bsol;',
        '/' : '&sol;'
    }
    /**
     * @member {RegExp} charPattern
     * @static
     */
    static charPattern = /[&<>"'$\\]/g
    /**
     * @member {RegExp} entityPattern
     * @static
     */
    static entityPattern = /(&amp;)|(&lt;)|(&gt;)|(&quot;)|(&apos;)|(&dollar;)|(&bsol;)|(&sol;)/g

    static config = {
        /**
         * @member {String} className='Neo.util.String'
         * @protected
         */
        className: 'Neo.util.String'
    }

    /**
     * Escape HTML special characters
     * @param {String} value
     */
    static escapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.charPattern, me.getEntityFromChar.bind(me))
    }

    /**
     * Get char equivalent of a mapped entity
     * @param {String} entity
     */
    static getCharFromEntity(entity) {
        let mappedChar = Object.keys(this.charEntityMap).find(key => this.charEntityMap[key] === entity);
        return mappedChar || entity
    }

    /**
     * Get entity equivalent of a mapped char
     * @param {String} char
     */
    static getEntityFromChar(char) {
        return this.charEntityMap[char] || char
    }

    /**
     * Unescape HTML special characters
     * @param {String} value
     */
    static unescapeHtml(value) {
        let me = this; // inside a static method, we are pointing to the class prototype

        if (!Neo.isString(value)) {
            return value
        }

        return value.replace(me.entityPattern, me.getCharFromEntity.bind(me))
    }

    /**
     * Returns the passed string with the first letter uncapitalized.
     * @param {String} value
     * @returns  {String}
     */
    static uncapitalize(value) {
        return value && value[0].toLowerCase() + value.substring(1)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(StringUtil));


/***/ }),

/***/ "./src/util/Style.mjs":
/*!****************************!*\
  !*** ./src/util/Style.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Style
 * @extends Neo.core.Base
 */
class Style extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Style'
         * @protected
         */
        className: 'Neo.util.Style'
    }

    /**
     * Creates an delta object, containing the styles of newStyle which are not included or different than in oldStyle
     * Styles included in oldStyle but missing in newStyle will get a value of null
     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
     * @param {Object|String} newStyle
     * @param {Object|String} oldStyle
     * @returns {Object} style delta
     */
    static compareStyles(newStyle, oldStyle) {
        let styles = {};

        if (Neo.isString(newStyle)) {
            newStyle = Neo.createStyleObject(newStyle)
        }

        if (Neo.isString(oldStyle)) {
            oldStyle = Neo.createStyleObject(oldStyle)
        }

        if (!newStyle && !oldStyle) {
            return null
        } else if (!oldStyle) {
            return Neo.clone(newStyle)
        } else if (!newStyle) {
            Object.keys(oldStyle).forEach(function(style) {
                styles[style] = null
            });
        } else {
            Object.keys(newStyle).forEach(style => {
                if (!oldStyle.hasOwnProperty(style) || oldStyle[style] !== newStyle[style]) {
                    styles[style] = newStyle[style]
                }
            });

            Object.keys(oldStyle).forEach(style => {
                if (!newStyle.hasOwnProperty(style)) {
                    styles[style] = null
                }
            });

            if (Object.keys(styles).length > 0) {
                return styles
            }

            return null
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Style));


/***/ }),

/***/ "./src/vdom/Helper.mjs":
/*!*****************************!*\
  !*** ./src/vdom/Helper.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Style_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Style.mjs */ "./src/util/Style.mjs");
/* harmony import */ var _domConstants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domConstants.mjs */ "./src/vdom/domConstants.mjs");
/* harmony import */ var _VNode_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VNode.mjs */ "./src/vdom/VNode.mjs");






const NeoConfig = Neo.config;

/**
 * The central class for the VDom worker to create vnodes & delta updates.
 * @class Neo.vdom.Helper
 * @extends Neo.core.Base
 * @singleton
 */
class Helper extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.vdom.Helper'
         * @protected
         */
        className: 'Neo.vdom.Helper',
        /**
         * Remote method access for other workers
         * @member {Object} remote={app:['create','update']}
         * @protected
         */
        remote: {
            app: [
                'create',
                'update'
            ]
        },
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object}         config
     * @param {Object}         config.deltas
     * @param {Neo.vdom.VNode} config.oldVnode
     * @param {Neo.vdom.VNode} config.vnode
     * @param {Map}            config.vnodeMap
     * @returns {Object} deltas
     * @protected
     */
    compareAttributes({deltas, oldVnode, vnode, vnodeMap}) {
        // Do not compare attributes for component references
        if (oldVnode.componentId && (oldVnode.id === vnode.id || oldVnode.componentId === vnode.id)) {
            return deltas
        }

        let attributes, delta, value, keys, styles, add, remove;

        if (vnode.vtype === 'text' && vnode.innerHTML !== oldVnode.innerHTML) {
            deltas.default.push({
                action  : 'updateVtext',
                id      : vnode.id,
                parentId: vnodeMap.get(vnode.id).parentNode.id,
                value   : vnode.innerHTML
            })
        } else {
            keys = Object.keys(vnode);

            Object.keys(oldVnode).forEach(prop => {
                if (!vnode.hasOwnProperty(prop)) {
                    keys.push(prop)
                } else if (prop === 'attributes') { // find removed attributes
                    Object.keys(oldVnode[prop]).forEach(attr => {
                        if (!vnode[prop].hasOwnProperty(attr)) {
                            vnode[prop][attr] = null
                        }
                    })
                }
            });

            keys.forEach(prop => {
                delta = {};
                value = vnode[prop];

                switch (prop) {
                    case 'attributes':
                        attributes = {};

                        Object.entries(value).forEach(([key, value]) => {
                            if (!(oldVnode.attributes.hasOwnProperty(key) && oldVnode.attributes[key] === value)) {
                                if (value !== null && !Neo.isString(value) && Neo.isEmpty(value)) {
                                    // ignore empty arrays & objects
                                } else {
                                    attributes[key] = value
                                }
                            }
                        });

                        if (Object.keys(attributes).length > 0) {
                            delta.attributes = attributes;

                            Object.entries(attributes).forEach(([key, value]) => {
                                if (value === null || value === '') {
                                    delete vnode.attributes[key]
                                }
                            })
                        }
                        break
                    case 'nodeName':
                    case 'innerHTML':
                    case 'textContent':
                        if (value !== oldVnode[prop]) {
                            delta[prop] = value
                        }
                        break
                    case 'style':
                        styles = _util_Style_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].compareStyles(value, oldVnode.style);
                        if (styles) {
                            delta.style = styles
                        }
                        break
                    case 'className':
                        if (oldVnode.className) {
                            add    = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(value, oldVnode.className);
                            remove = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].difference(oldVnode.className, value)
                        } else {
                            add    =  value;
                            remove = []
                        }

                        if (add.length > 0 || remove.length > 0) {
                            delta.cls = {};

                            if (add   .length > 0) {delta.cls.add    = add}
                            if (remove.length > 0) {delta.cls.remove = remove}
                        }
                        break
                }

                if (Object.keys(delta).length > 0) {
                    delta.id = vnode.id;
                    deltas.default.push(delta)
                }
            })
        }

        return deltas
    }

    /**
     * Creates a Neo.vdom.VNode tree for the given vdom template.
     * The top level vnode contains the outerHTML as a string,
     * in case Neo.config.useStringBasedMounting === true
     * @param {Object} opts
     * @param {String} opts.appName
     * @param {Boolean} [opts.autoMount]
     * @param {String} opts.parentId
     * @param {Number} opts.parentIndex
     * @param {Object} opts.vdom
     * @param {Number} opts.windowId
     * @returns {Promise<Object>}
     */
    async create(opts) {
        let me = this,
            returnValue, vnode;

        await me.importDomApiVnodeCreator();
        await me.importStringFromVnode();

        vnode       = me.createVnode(opts.vdom);
        returnValue = {...opts, vnode};

        delete returnValue.vdom;

        if (NeoConfig.useStringBasedMounting) {
            returnValue.outerHTML = Neo.vdom.util.StringFromVnode.create(vnode)
        }

        return returnValue
    }

    /**
     * @param {Object}                config
     * @param {Object}                [config.deltas={default: [], remove: []}]
     * @param {Neo.vdom.VNode|Object} config.oldVnode
     * @param {Map}                   [config.oldVnodeMap]
     * @param {Neo.vdom.VNode|Object} config.vnode
     * @param {Map}                   [config.vnodeMap]
     * @returns {Object} deltas
     * @protected
     */
    createDeltas(config) {
        let {deltas={default: [], remove: []}, oldVnode, vnode} = config,
            oldVnodeId = oldVnode?.id || oldVnode?.componentId,
            vnodeId    = vnode?.id;

        // Edge case: setting `removeDom: true` on a top-level vdom node
        if (!vnode && oldVnodeId) {
            deltas.remove.push({action: 'removeNode', id: oldVnodeId});
            return deltas
        }

        if (vnode.static) {
            return deltas
        }

        if (vnodeId !== oldVnodeId && vnode.componentId !== oldVnode.componentId) {
            throw new Error(`createDeltas() must get called for the same node. ${vnodeId}, ${oldVnodeId}`);
        }

        let me            = this,
            oldVnodeMap   = config.oldVnodeMap  || me.createVnodeMap({vnode: oldVnode}),
            vnodeMap      = config.vnodeMap     || me.createVnodeMap({vnode}),
            childNodes    = vnode   .childNodes || [],
            oldChildNodes = oldVnode.childNodes || [],
            i             = 0,
            indexDelta    = 0,
            insertDelta   = 0,
            len           = Math.max(childNodes.length, oldChildNodes.length),
            childNode, nodeInNewTree, oldChildNode, oldChildNodeId;

        me.compareAttributes({deltas, oldVnode, vnode, vnodeMap});

        if (childNodes.length === 0 && oldChildNodes.length > 1) {
            deltas.remove.push({action: 'removeAll', parentId: vnodeId});
            return deltas
        }

        for (; i < len; i++) {
            childNode    = childNodes[i];
            oldChildNode = oldChildNodes[i + indexDelta];

            if (!childNode && !oldChildNode) {
                break
            }

            // Same node, continue recursively
            if (childNode && oldChildNode && (
                childNode.id === oldChildNode.id ||
                (childNode.componentId && childNode.componentId === oldChildNode.componentId))
            ) {
                me.createDeltas({deltas, oldVnode: oldChildNode, oldVnodeMap, vnode: childNode, vnodeMap});
                continue
            }

            if (oldChildNode) {
                oldChildNodeId = oldChildNode.id || oldChildNode.componentId;
                nodeInNewTree  = vnodeMap.get(oldChildNodeId);

                // Remove node, if no longer inside the new tree
                if (!nodeInNewTree) {
                    me.removeNode({deltas, oldVnode: oldChildNode, oldVnodeMap});
                    i--;
                    insertDelta++;
                    continue
                }

                // The old child node got moved into a different not processed array. It will get picked up there.
                if (childNode && vnodeId !== nodeInNewTree.parentNode.id) {
                    i--;
                    indexDelta++;
                    continue
                }
            }

            if (childNode) {
                if (me.isMovedNode(childNode, oldVnodeMap)) {
                    me.moveNode({deltas, insertDelta, oldVnodeMap, vnode: childNode, vnodeMap})
                } else {
                    me.insertNode({deltas, index: i + insertDelta, oldVnodeMap, vnode: childNode, vnodeMap})
                }

                if (oldChildNode && vnodeId === vnodeMap.get(oldChildNodeId)?.parentNode.id) {
                    len++
                }
            }
        }

        return deltas
    }

    /**
     * @param {Object} opts
     * @returns {Object|Neo.vdom.VNode|null}
     * @protected
     */
    createVnode(opts) {
        // do not create vnode instances for component reference objects
        if (opts.componentId) {
            opts.childNodes ??= []; // Consistency: Every VNode has a childNodes array
            opts.id         ??= opts.componentId

            return opts
        }

        if (opts.removeDom === true) {
            return null
        }

        let me   = this,
            node = {attributes: {}, style: {}},
            potentialNode;

        Object.entries(opts).forEach(([key, value]) => {
            if (value !== undefined && value !== null && key !== 'flag' && key !== 'removeDom') {
                let hasUnit, newValue, style;

                switch(key) {
                    case 'tag':
                        node.nodeName = value;
                        break
                    case 'html':
                        node.innerHTML = value.toString(); // support for numbers
                        break
                    case 'text':
                        node.textContent = value
                        break
                    case 'cn':
                        if (!Array.isArray(value)) {
                            value = [value]
                        }

                        newValue = [];

                        value.forEach(item => {
                            if (item.removeDom !== true) {
                                delete item.removeDom; // could be false
                                potentialNode = me.createVnode(item);

                                if (potentialNode) { // don't add null values
                                    newValue.push(potentialNode)
                                }
                            }
                        });

                        node.childNodes = newValue;
                        break
                    case 'cls':
                        if (value && !Array.isArray(value)) {
                            node.className = [value]
                        } else if (!(Array.isArray(value) && value.length < 1)) {
                            node.className = value
                        }
                        break
                    case 'data':
                        if (value && Neo.typeOf(value) === 'Object') {
                            Object.entries(value).forEach(([key, val]) => {
                                node.attributes[`data-${Neo.decamel(key)}`] = val
                            })
                        }
                        break;
                    case 'height':
                    case 'maxHeight':
                    case 'maxWidth':
                    case 'minHeight':
                    case 'minWidth':
                    case 'width':
                        if (_domConstants_mjs__WEBPACK_IMPORTED_MODULE_3__.rawDimensionTags.has(node.nodeName)) {
                            node.attributes[key] = value + ''
                        } else {
                            hasUnit = value != parseInt(value);
                            node.style[key] = value + (hasUnit ? '' : 'px')
                        }
                        break
                    case 'componentId':
                    case 'id':
                    case 'static':
                        node[key] = value;
                        break
                    case 'style':
                        style = node.style;
                        if (Neo.isString(value)) {
                            node.style = Object.assign(style, Neo.core.Util.createStyleObject(value))
                        } else {
                            node.style = Object.assign(style, value)
                        }
                        break
                    default:
                        node.attributes[key] = value + '';
                        break
                }
            }
        });

        // Relevant for vtype='text'
        if (Object.keys(node.attributes).length < 1) {
            delete node.attributes
        }

        // Relevant for vtype='text'
        if (Object.keys(node.style).length < 1) {
            delete node.style
        }

        return new _VNode_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](node)
    }

    /**
     * Creates a flat map of the tree, containing ids as keys and infos as values
     * @param {Object}         config
     * @param {Number}         [config.index=0]
     * @param {Map}            [config.map=new Map()]
     * @param {Neo.vdom.VNode} [config.parentNode=null]
     * @param {Neo.vdom.VNode} config.vnode
     * @returns {Map}
     *     {String}         id vnode.id (convenience shortcut)
     *     {Number}         index
     *     {String}         parentId
     *     {Neo.vdom.VNode} vnode
     * @protected
     */
    createVnodeMap({index=0, map=new Map(), parentNode=null, vnode}) {
        if (vnode) {
            let id = vnode.id || vnode.componentId;

            map.set(id, {id, index, parentNode, vnode});

            vnode.childNodes?.forEach((childNode, index) => {
                this.createVnodeMap({index, map, parentNode: vnode, vnode: childNode})
            })
        }

        return map
    }

    /**
     * The logic will parse the vnode (tree) to find existing items inside a given map.
     * It will not search for further childNodes inside an already found vnode.
     * @param {Object}         config
     * @param {Map}            [config.movedNodes=new Map()]
     * @param {Map}            config.oldVnodeMap
     * @param {Neo.vdom.VNode} config.vnode
     * @param {Map}            config.vnodeMap
     * @returns {Map}
     * @protected
     */
    findMovedNodes({movedNodes=new Map(), oldVnodeMap, vnode, vnodeMap}) {
        let id = vnode?.id;

        if (id) {
            if (this.isMovedNode(vnode, oldVnodeMap)) {
                movedNodes.set(id, vnodeMap.get(id))
            } else {
                vnode.childNodes?.forEach(childNode => {
                    if (childNode.vtype !== 'text') {
                        this.findMovedNodes({movedNodes, oldVnodeMap, vnode: childNode, vnodeMap})
                    }
                })
            }
        }

        return movedNodes
    }

    /**
     * For delta updates to work, every node inside the live DOM needs a unique ID.
     * Text nodes need to get wrapped into comment nodes, which contain the ID to ensure consistency.
     * As the result, we need a physical index which counts every text node as 3 nodes.
     * @param {Neo.vdom.VNode} parentNode
     * @param {Number}         logicalIndex
     * @returns {Number}
     */
    getPhysicalIndex(parentNode, logicalIndex) {
        let physicalIndex = logicalIndex,
            i              = 0;

        for (; i < logicalIndex; i++) {
            if (parentNode.childNodes[i]?.vtype === 'text') {
                physicalIndex += 2 // Accounts for <!--neo-vtext--> wrappers
            }
        }

        return physicalIndex
    }

    /**
     * Only import for the DOM API based mount adapter.
     * @returns {Promise<void>}
     * @protected
     */
    async importDomApiVnodeCreator() {
        if (!NeoConfig.useStringBasedMounting && !Neo.vdom.util?.DomApiVnodeCreator) {
            await __webpack_require__.e(/*! import() */ "src_vdom_util_DomApiVnodeCreator_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./util/DomApiVnodeCreator.mjs */ "./src/vdom/util/DomApiVnodeCreator.mjs"))
        }
    }

    /**
     * Only import for the string based mount adapter.
     * @returns {Promise<void>}
     * @protected
     */
    async importStringFromVnode() {
        if (NeoConfig.useStringBasedMounting && !Neo.vdom.util?.StringFromVnode) {
            await __webpack_require__.e(/*! import() */ "src_vdom_util_StringFromVnode_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./util/StringFromVnode.mjs */ "./src/vdom/util/StringFromVnode.mjs"))
        }
    }

    /**
     * @param {Object}         config
     * @param {Object}         config.deltas
     * @param {Number}         config.index
     * @param {Map}            config.oldVnodeMap
     * @param {Neo.vdom.VNode} config.vnode
     * @param {Map}            config.vnodeMap
     * @protected
     */
    insertNode({deltas, index, oldVnodeMap, vnode, vnodeMap}) {
        let details                = vnodeMap.get(vnode.id),
            {parentNode}           = details,
            parentId               = parentNode.id,
            me                     = this,
            movedNodes             = me.findMovedNodes({oldVnodeMap, vnode, vnodeMap}),
            delta                  = {action: 'insertNode', parentId},
            hasLeadingTextChildren = false,
            physicalIndex          = me.getPhysicalIndex(parentNode, index); // Processes the children of the *NEW* parent's VNode in the *current* state

        Object.assign(delta, {hasLeadingTextChildren, index: physicalIndex});

        if (NeoConfig.useStringBasedMounting) {
            // For string-based mounting, pass a string excluding moved nodes
            delta.outerHTML = Neo.vdom.util.StringFromVnode.create(vnode, movedNodes)
        } else {
            // For direct DOM API mounting, pass the pruned VNode tree
            delta.vnode = Neo.vdom.util.DomApiVnodeCreator.create(vnode, movedNodes)
        }

        deltas.default.push(delta);

        // Insert the new node into the old tree, to simplify future OPs
        oldVnodeMap.get(parentId).vnode.childNodes.splice(index, 0, vnode);

        movedNodes.forEach(details => {
            let {id}     = details,
                parentId = details.parentNode.id;

            deltas.default.push({action: 'moveNode', id, index: details.index, parentId});

            me.createDeltas({deltas, oldVnode: oldVnodeMap.get(id).vnode, oldVnodeMap, vnode: details.vnode, vnodeMap})
        })
    }

    /**
     *
     * @param {Neo.vdom.VNode} vnode
     * @param {Map} oldVnodeMap
     * @returns {Boolean}
     * @protected
     */
    isMovedNode(vnode, oldVnodeMap) {
        let oldVnode = oldVnodeMap.get(vnode.id);

        return oldVnode && (
            !oldVnode.vnode.componentId ||                   // the old vnode is not a reference
            vnode.componentId === oldVnode.vnode.componentId // old & new nodes are the same references
        )
    }

    /**
     * @param {Object}         config
     * @param {Object}         config.deltas
     * @param {Number}         config.insertDelta
     * @param {Map}            config.oldVnodeMap
     * @param {Neo.vdom.VNode} config.vnode
     * @param {Map}            config.vnodeMap
     * @protected
     */
    moveNode({deltas, insertDelta, oldVnodeMap, vnode, vnodeMap}) {
        let details             = vnodeMap.get(vnode.id),
            {index, parentNode} = details,
            parentId            = parentNode.id,
            movedNode           = oldVnodeMap.get(vnode.id),
            movedParentNode     = movedNode.parentNode,
            {childNodes}        = movedParentNode,
            delta               = {action: 'moveNode', id: vnode.id, parentId},
            physicalIndex       = this.getPhysicalIndex(parentNode, index); // Processes the children of the *NEW* parent's VNode in the *current* state (parentNode.childNodes)

        Object.assign(delta, {index: physicalIndex + insertDelta});
        deltas.default.push(delta);

        // This block implements the "corrupting the old tree" optimization for performance.
        // It pre-modifies the old VNode map to reflect the move, preventing redundant deltas later.
        if (parentId !== movedParentNode.id) {
            // We need to remove the node from the old parent childNodes
            // (which must not be the same as the node they got moved into)
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(childNodes, movedNode.vnode);

            // Get the VNode representing the *new parent* from the 'old VNode map'.
            // This is crucial: 'oldParentNode' here is the *old state's VNode for the new parent*.
            let oldParentNode = oldVnodeMap.get(parentId);

            if (oldParentNode) {
                // If moved into a new parent node, update the reference inside the flat map
                movedNode.parentNode = oldParentNode.vnode;

                // Reassign 'childNodes' property to now point to the 'childNodes' array
                // of this 'old state's VNode for the new parent'.
                childNodes = movedNode.parentNode.childNodes
            }
        }

        // Add the node into the old vnode tree to simplify future OPs.
        // NeoArray.insert() will switch to move() in case the node already exists.
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].insert(childNodes, index, movedNode.vnode);

        this.createDeltas({deltas, oldVnode: movedNode.vnode, oldVnodeMap, vnode, vnodeMap})
    }

    /**
     * @param {Object}         config
     * @param {Object}         config.deltas
     * @param {Neo.vdom.VNode} config.oldVnode
     * @param {Map}            config.oldVnodeMap
     * @protected
     */
    removeNode({deltas, oldVnode, oldVnodeMap}) {
        if (oldVnode.componentId) {
            oldVnode.id ??= oldVnode.componentId
        }

        let delta        = {action: 'removeNode', id: oldVnode.id},
            {parentNode} = oldVnodeMap.get(oldVnode.id);

        if (oldVnode.vtype === 'text') {
            delta.parentId = parentNode.id
        }

        deltas.remove.push(delta);

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(parentNode.childNodes, oldVnode)
    }

    /**
     * Creates a Neo.vdom.VNode tree for the given vdom template and compares the new vnode with the current one
     * to calculate the vdom deltas.
     * @param {Object} opts
     * @param {Object} opts.vdom
     * @param {Object} opts.vnode
     * @returns {Promise<Object>}
     */
    async update(opts) {
        let me = this,
            deltas, vnode;

        await me.importDomApiVnodeCreator();
        await me.importStringFromVnode();

        vnode  = me.createVnode(opts.vdom);
        deltas = me.createDeltas({oldVnode: opts.vnode, vnode});

        // Trees to remove could contain nodes which we want to re-use (move),
        // so we need to execute the removeNode OPs last.
        deltas = deltas.default.concat(deltas.remove);

        return {deltas, updateVdom: true, vnode}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Helper));


/***/ }),

/***/ "./src/vdom/VNode.mjs":
/*!****************************!*\
  !*** ./src/vdom/VNode.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/String.mjs */ "./src/util/String.mjs");


/**
 * Wrapper class for vnode objects.
 * For convenience, a VNode instance will always contain a childNodes array, which can be empty.
 * A VNode can optionally have `innerHTML` xor `textContent`
 * `textContent` is better from a XSS security perspective.
 * If by accident both are set, `innerHTML` will get the priority.
 *
 * @class Neo.vdom.VNode
 */
class VNode {
    /**
     * @param {Object} config
     */
    constructor(config) {
        /**
         * Not set for vtype='text' nodes
         * @member {Object} attributes={}
         */

        /**
         * @member {Array} childNodes=[]
         */

        /**
         * Not set for vtype='text' nodes
         * @member {Array} className=[]
         */

        /**
         * @member {String} id=Neo.getId('vnode')
         */

        /**
         * @member {String} innerHTML
         */

        /**
         * @member {String} nodeName
         */

        /**
         * true excludes the node from delta-updates
         * @member {Boolean} static
         */

        /**
         * Not set for vtype='text' nodes
         * @member {Object} style
         */

        /**
         * @member {String} textContent
         */

        /**
         * Valid values are "root", "text" & "vnode"
         * @member {String} vtype='vnode'
         */

        let me            = this,
            {textContent} = config,
            hasInnerHtml  = Object.hasOwn(config, 'innerHTML'),
            isVText       = config.vtype === 'text';

        Object.assign(me, {
            childNodes: config.childNodes || [],
            id        : config.id         || Neo.getId(isVText ? 'vtext' : 'vnode'),
            vtype     : config.vtype      || 'vnode'
        });

        if (isVText) {
            // XSS Security: a pure text node is not supposed to contain HTML
            me.textContent = _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].escapeHtml(hasInnerHtml ? config.innerHTML : textContent)
        } else {
            Object.assign(me, {
                attributes: config.attributes || {},
                className : config.className  || [],
                nodeName  : config.nodeName   || 'div',
                style     : config.style
            });

            // Use vdom.html on your own risk, it is not fully XSS secure.
            if (hasInnerHtml) {
                me.innerHTML = config.innerHTML
            }

            // We only apply textContent, in case it has content
            else if (Object.hasOwn(config, 'textContent')) {
                me.textContent = Neo.config.useStringBasedMounting ? _util_String_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].escapeHtml(textContent) : textContent
            }
        }

        // We only apply the static attribute, in case the value is true
        if (config.static) {
            me.static = true
        }
    }
}

const ns = Neo.ns('Neo.vdom', true);
ns.VNode = VNode;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VNode);


/***/ }),

/***/ "./src/vdom/domConstants.mjs":
/*!***********************************!*\
  !*** ./src/vdom/domConstants.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rawDimensionTags: () => (/* binding */ rawDimensionTags),
/* harmony export */   voidAttributes: () => (/* binding */ voidAttributes),
/* harmony export */   voidElements: () => (/* binding */ voidElements)
/* harmony export */ });
/**
 * The following top-level attributes will get converted into styles:
 * height, maxHeight, maxWidth, minHeight, minWidth, width
 *
 * Some tags must not do the transformation, so we add them here.
 * @member {Set} rawDimensionTags
 */
const rawDimensionTags = new Set([
    'circle',
    'clipPath',
    'ellipse',
    'filter',
    'foreignObject',
    'image',
    'marker',
    'mask',
    'pattern',
    'rect',
    'svg',
    'use'
]);

/**
 * Void attributes inside html tags
 * @member {Set} voidAttributes
 * @protected
 */
const voidAttributes = new Set([
    'checked',
    'defer',
    'disabled',
    'ismap',
    'multiple',
    'nohref',
    'noresize',
    'noshade',
    'nowrap',
    'open',
    'readonly',
    'required',
    'reversed',
    'selected'
]);

/**
 * Void html tags
 * @member {Set} voidElements
 * @protected
 */
const voidElements = new Set([
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
]);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY192ZG9tX0hlbHBlcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFJO0FBQzdCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sT0FBTyxTQUFTLFNBQVMsV0FBVyxTQUFTLFFBQVE7O0FBRTlGO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwwQkFBMEIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQy9GTjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtB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QUFDQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLDZCQUE2Qix3REFBVTtBQUN2QyxVQUFVO0FBQ1Y7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUVBQXFFLHdEQUFVO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsS0FBSyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvU3RyaW5nLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvU3R5bGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdmRvbS9IZWxwZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdmRvbS9WTm9kZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy92ZG9tL2RvbUNvbnN0YW50cy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlN0cmluZ1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTdHJpbmdVdGlsIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBjaGFyRW50aXR5TWFwXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBjaGFyRW50aXR5TWFwID0ge1xuICAgICAgICAnJicgOiAnJmFtcDsnLFxuICAgICAgICAnPCcgOiAnJmx0OycsXG4gICAgICAgICc+JyA6ICcmZ3Q7JyxcbiAgICAgICAgJ1wiJyA6ICcmcXVvdDsnLFxuICAgICAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgICAgICckJyA6ICcmZG9sbGFyOycsXG4gICAgICAgICdcXFxcJzogJyZic29sOycsXG4gICAgICAgICcvJyA6ICcmc29sOydcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7UmVnRXhwfSBjaGFyUGF0dGVyblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hhclBhdHRlcm4gPSAvWyY8PlwiJyRcXFxcXS9nXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7UmVnRXhwfSBlbnRpdHlQYXR0ZXJuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBlbnRpdHlQYXR0ZXJuID0gLygmYW1wOyl8KCZsdDspfCgmZ3Q7KXwoJnF1b3Q7KXwoJmFwb3M7KXwoJmRvbGxhcjspfCgmYnNvbDspfCgmc29sOykvZ1xuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5TdHJpbmcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlN0cmluZydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGUgSFRNTCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZXNjYXBlSHRtbCh2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzOyAvLyBpbnNpZGUgYSBzdGF0aWMgbWV0aG9kLCB3ZSBhcmUgcG9pbnRpbmcgdG8gdGhlIGNsYXNzIHByb3RvdHlwZVxuXG4gICAgICAgIGlmICghTmVvLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShtZS5jaGFyUGF0dGVybiwgbWUuZ2V0RW50aXR5RnJvbUNoYXIuYmluZChtZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNoYXIgZXF1aXZhbGVudCBvZiBhIG1hcHBlZCBlbnRpdHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW50aXR5XG4gICAgICovXG4gICAgc3RhdGljIGdldENoYXJGcm9tRW50aXR5KGVudGl0eSkge1xuICAgICAgICBsZXQgbWFwcGVkQ2hhciA9IE9iamVjdC5rZXlzKHRoaXMuY2hhckVudGl0eU1hcCkuZmluZChrZXkgPT4gdGhpcy5jaGFyRW50aXR5TWFwW2tleV0gPT09IGVudGl0eSk7XG4gICAgICAgIHJldHVybiBtYXBwZWRDaGFyIHx8IGVudGl0eVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBlbnRpdHkgZXF1aXZhbGVudCBvZiBhIG1hcHBlZCBjaGFyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoYXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RW50aXR5RnJvbUNoYXIoY2hhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFyRW50aXR5TWFwW2NoYXJdIHx8IGNoYXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmVzY2FwZSBIVE1MIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmVzY2FwZUh0bWwodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpczsgLy8gaW5zaWRlIGEgc3RhdGljIG1ldGhvZCwgd2UgYXJlIHBvaW50aW5nIHRvIHRoZSBjbGFzcyBwcm90b3R5cGVcblxuICAgICAgICBpZiAoIU5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobWUuZW50aXR5UGF0dGVybiwgbWUuZ2V0Q2hhckZyb21FbnRpdHkuYmluZChtZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFzc2VkIHN0cmluZyB3aXRoIHRoZSBmaXJzdCBsZXR0ZXIgdW5jYXBpdGFsaXplZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyAge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdW5jYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZVswXS50b0xvd2VyQ2FzZSgpICsgdmFsdWUuc3Vic3RyaW5nKDEpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdHJpbmdVdGlsKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5TdHlsZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTdHlsZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuU3R5bGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlN0eWxlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZGVsdGEgb2JqZWN0LCBjb250YWluaW5nIHRoZSBzdHlsZXMgb2YgbmV3U3R5bGUgd2hpY2ggYXJlIG5vdCBpbmNsdWRlZCBvciBkaWZmZXJlbnQgdGhhbiBpbiBvbGRTdHlsZVxuICAgICAqIFN0eWxlcyBpbmNsdWRlZCBpbiBvbGRTdHlsZSBidXQgbWlzc2luZyBpbiBuZXdTdHlsZSB3aWxsIGdldCBhIHZhbHVlIG9mIG51bGxcbiAgICAgKiBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9zdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmV3U3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9sZFN0eWxlXG4gICAgICogQHJldHVybnMge09iamVjdH0gc3R5bGUgZGVsdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVN0eWxlcyhuZXdTdHlsZSwgb2xkU3R5bGUpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IHt9O1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcobmV3U3R5bGUpKSB7XG4gICAgICAgICAgICBuZXdTdHlsZSA9IE5lby5jcmVhdGVTdHlsZU9iamVjdChuZXdTdHlsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcob2xkU3R5bGUpKSB7XG4gICAgICAgICAgICBvbGRTdHlsZSA9IE5lby5jcmVhdGVTdHlsZU9iamVjdChvbGRTdHlsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3U3R5bGUgJiYgIW9sZFN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKCFvbGRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIE5lby5jbG9uZShuZXdTdHlsZSlcbiAgICAgICAgfSBlbHNlIGlmICghbmV3U3R5bGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3U3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb2xkU3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpIHx8IG9sZFN0eWxlW3N0eWxlXSAhPT0gbmV3U3R5bGVbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBuZXdTdHlsZVtzdHlsZV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMob2xkU3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbmV3U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFN0eWxlKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBTdHlsZSAgICAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9TdHlsZS5tanMnO1xuaW1wb3J0IHtyYXdEaW1lbnNpb25UYWdzfSBmcm9tICcuL2RvbUNvbnN0YW50cy5tanMnO1xuaW1wb3J0IFZOb2RlICAgICAgICAgICAgICBmcm9tICcuL1ZOb2RlLm1qcyc7XG5cbmNvbnN0IE5lb0NvbmZpZyA9IE5lby5jb25maWc7XG5cbi8qKlxuICogVGhlIGNlbnRyYWwgY2xhc3MgZm9yIHRoZSBWRG9tIHdvcmtlciB0byBjcmVhdGUgdm5vZGVzICYgZGVsdGEgdXBkYXRlcy5cbiAqIEBjbGFzcyBOZW8udmRvbS5IZWxwZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgSGVscGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udmRvbS5IZWxwZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby52ZG9tLkhlbHBlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdGUgbWV0aG9kIGFjY2VzcyBmb3Igb3RoZXIgd29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlbW90ZT17YXBwOlsnY3JlYXRlJywndXBkYXRlJ119XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgYXBwOiBbXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgJ3VwZGF0ZSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZy5kZWx0YXNcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcub2xkVm5vZGVcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcudm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcudm5vZGVNYXBcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBkZWx0YXNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29tcGFyZUF0dHJpYnV0ZXMoe2RlbHRhcywgb2xkVm5vZGUsIHZub2RlLCB2bm9kZU1hcH0pIHtcbiAgICAgICAgLy8gRG8gbm90IGNvbXBhcmUgYXR0cmlidXRlcyBmb3IgY29tcG9uZW50IHJlZmVyZW5jZXNcbiAgICAgICAgaWYgKG9sZFZub2RlLmNvbXBvbmVudElkICYmIChvbGRWbm9kZS5pZCA9PT0gdm5vZGUuaWQgfHwgb2xkVm5vZGUuY29tcG9uZW50SWQgPT09IHZub2RlLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhc1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGF0dHJpYnV0ZXMsIGRlbHRhLCB2YWx1ZSwga2V5cywgc3R5bGVzLCBhZGQsIHJlbW92ZTtcblxuICAgICAgICBpZiAodm5vZGUudnR5cGUgPT09ICd0ZXh0JyAmJiB2bm9kZS5pbm5lckhUTUwgIT09IG9sZFZub2RlLmlubmVySFRNTCkge1xuICAgICAgICAgICAgZGVsdGFzLmRlZmF1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uICA6ICd1cGRhdGVWdGV4dCcsXG4gICAgICAgICAgICAgICAgaWQgICAgICA6IHZub2RlLmlkLFxuICAgICAgICAgICAgICAgIHBhcmVudElkOiB2bm9kZU1hcC5nZXQodm5vZGUuaWQpLnBhcmVudE5vZGUuaWQsXG4gICAgICAgICAgICAgICAgdmFsdWUgICA6IHZub2RlLmlubmVySFRNTFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2bm9kZSk7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFZub2RlKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdm5vZGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHByb3ApXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnYXR0cmlidXRlcycpIHsgLy8gZmluZCByZW1vdmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2xkVm5vZGVbcHJvcF0pLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZub2RlW3Byb3BdLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGVbcHJvcF1bYXR0cl0gPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IHt9O1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdm5vZGVbcHJvcF07XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvbGRWbm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkgJiYgb2xkVm5vZGUuYXR0cmlidXRlc1trZXldID09PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFOZW8uaXNTdHJpbmcodmFsdWUpICYmIE5lby5pc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGVtcHR5IGFycmF5cyAmIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdm5vZGUuYXR0cmlidXRlc1trZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbm9kZU5hbWUnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Q29udGVudCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZub2RlW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFbcHJvcF0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gU3R5bGUuY29tcGFyZVN0eWxlcyh2YWx1ZSwgb2xkVm5vZGUuc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhLnN0eWxlID0gc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbGFzc05hbWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZub2RlLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZCAgICA9IE5lb0FycmF5LmRpZmZlcmVuY2UodmFsdWUsIG9sZFZub2RlLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gTmVvQXJyYXkuZGlmZmVyZW5jZShvbGRWbm9kZS5jbGFzc05hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQgICAgPSAgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZC5sZW5ndGggPiAwIHx8IHJlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEuY2xzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkICAgLmxlbmd0aCA+IDApIHtkZWx0YS5jbHMuYWRkICAgID0gYWRkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmUubGVuZ3RoID4gMCkge2RlbHRhLmNscy5yZW1vdmUgPSByZW1vdmV9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWx0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YS5pZCA9IHZub2RlLmlkO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YXMuZGVmYXVsdC5wdXNoKGRlbHRhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVsdGFzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE5lby52ZG9tLlZOb2RlIHRyZWUgZm9yIHRoZSBnaXZlbiB2ZG9tIHRlbXBsYXRlLlxuICAgICAqIFRoZSB0b3AgbGV2ZWwgdm5vZGUgY29udGFpbnMgdGhlIG91dGVySFRNTCBhcyBhIHN0cmluZyxcbiAgICAgKiBpbiBjYXNlIE5lby5jb25maWcudXNlU3RyaW5nQmFzZWRNb3VudGluZyA9PT0gdHJ1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuYXV0b01vdW50XVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnBhcmVudElkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMucGFyZW50SW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy52ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMud2luZG93SWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSwgdm5vZGU7XG5cbiAgICAgICAgYXdhaXQgbWUuaW1wb3J0RG9tQXBpVm5vZGVDcmVhdG9yKCk7XG4gICAgICAgIGF3YWl0IG1lLmltcG9ydFN0cmluZ0Zyb21Wbm9kZSgpO1xuXG4gICAgICAgIHZub2RlICAgICAgID0gbWUuY3JlYXRlVm5vZGUob3B0cy52ZG9tKTtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSB7Li4ub3B0cywgdm5vZGV9O1xuXG4gICAgICAgIGRlbGV0ZSByZXR1cm5WYWx1ZS52ZG9tO1xuXG4gICAgICAgIGlmIChOZW9Db25maWcudXNlU3RyaW5nQmFzZWRNb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUub3V0ZXJIVE1MID0gTmVvLnZkb20udXRpbC5TdHJpbmdGcm9tVm5vZGUuY3JlYXRlKHZub2RlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgICBbY29uZmlnLmRlbHRhcz17ZGVmYXVsdDogW10sIHJlbW92ZTogW119XVxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV8T2JqZWN0fSBjb25maWcub2xkVm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICAgICAgICAgW2NvbmZpZy5vbGRWbm9kZU1hcF1cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfE9iamVjdH0gY29uZmlnLnZub2RlXG4gICAgICogQHBhcmFtIHtNYXB9ICAgICAgICAgICAgICAgICAgIFtjb25maWcudm5vZGVNYXBdXG4gICAgICogQHJldHVybnMge09iamVjdH0gZGVsdGFzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZURlbHRhcyhjb25maWcpIHtcbiAgICAgICAgbGV0IHtkZWx0YXM9e2RlZmF1bHQ6IFtdLCByZW1vdmU6IFtdfSwgb2xkVm5vZGUsIHZub2RlfSA9IGNvbmZpZyxcbiAgICAgICAgICAgIG9sZFZub2RlSWQgPSBvbGRWbm9kZT8uaWQgfHwgb2xkVm5vZGU/LmNvbXBvbmVudElkLFxuICAgICAgICAgICAgdm5vZGVJZCAgICA9IHZub2RlPy5pZDtcblxuICAgICAgICAvLyBFZGdlIGNhc2U6IHNldHRpbmcgYHJlbW92ZURvbTogdHJ1ZWAgb24gYSB0b3AtbGV2ZWwgdmRvbSBub2RlXG4gICAgICAgIGlmICghdm5vZGUgJiYgb2xkVm5vZGVJZCkge1xuICAgICAgICAgICAgZGVsdGFzLnJlbW92ZS5wdXNoKHthY3Rpb246ICdyZW1vdmVOb2RlJywgaWQ6IG9sZFZub2RlSWR9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2bm9kZS5zdGF0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2bm9kZUlkICE9PSBvbGRWbm9kZUlkICYmIHZub2RlLmNvbXBvbmVudElkICE9PSBvbGRWbm9kZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjcmVhdGVEZWx0YXMoKSBtdXN0IGdldCBjYWxsZWQgZm9yIHRoZSBzYW1lIG5vZGUuICR7dm5vZGVJZH0sICR7b2xkVm5vZGVJZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG9sZFZub2RlTWFwICAgPSBjb25maWcub2xkVm5vZGVNYXAgIHx8IG1lLmNyZWF0ZVZub2RlTWFwKHt2bm9kZTogb2xkVm5vZGV9KSxcbiAgICAgICAgICAgIHZub2RlTWFwICAgICAgPSBjb25maWcudm5vZGVNYXAgICAgIHx8IG1lLmNyZWF0ZVZub2RlTWFwKHt2bm9kZX0pLFxuICAgICAgICAgICAgY2hpbGROb2RlcyAgICA9IHZub2RlICAgLmNoaWxkTm9kZXMgfHwgW10sXG4gICAgICAgICAgICBvbGRDaGlsZE5vZGVzID0gb2xkVm5vZGUuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgaW5kZXhEZWx0YSAgICA9IDAsXG4gICAgICAgICAgICBpbnNlcnREZWx0YSAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgPSBNYXRoLm1heChjaGlsZE5vZGVzLmxlbmd0aCwgb2xkQ2hpbGROb2Rlcy5sZW5ndGgpLFxuICAgICAgICAgICAgY2hpbGROb2RlLCBub2RlSW5OZXdUcmVlLCBvbGRDaGlsZE5vZGUsIG9sZENoaWxkTm9kZUlkO1xuXG4gICAgICAgIG1lLmNvbXBhcmVBdHRyaWJ1dGVzKHtkZWx0YXMsIG9sZFZub2RlLCB2bm9kZSwgdm5vZGVNYXB9KTtcblxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgJiYgb2xkQ2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBkZWx0YXMucmVtb3ZlLnB1c2goe2FjdGlvbjogJ3JlbW92ZUFsbCcsIHBhcmVudElkOiB2bm9kZUlkfSk7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGFzXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgICAgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgb2xkQ2hpbGROb2RlID0gb2xkQ2hpbGROb2Rlc1tpICsgaW5kZXhEZWx0YV07XG5cbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlICYmICFvbGRDaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYW1lIG5vZGUsIGNvbnRpbnVlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlICYmIG9sZENoaWxkTm9kZSAmJiAoXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLmlkID09PSBvbGRDaGlsZE5vZGUuaWQgfHxcbiAgICAgICAgICAgICAgICAoY2hpbGROb2RlLmNvbXBvbmVudElkICYmIGNoaWxkTm9kZS5jb21wb25lbnRJZCA9PT0gb2xkQ2hpbGROb2RlLmNvbXBvbmVudElkKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZURlbHRhcyh7ZGVsdGFzLCBvbGRWbm9kZTogb2xkQ2hpbGROb2RlLCBvbGRWbm9kZU1hcCwgdm5vZGU6IGNoaWxkTm9kZSwgdm5vZGVNYXB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2xkQ2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgb2xkQ2hpbGROb2RlSWQgPSBvbGRDaGlsZE5vZGUuaWQgfHwgb2xkQ2hpbGROb2RlLmNvbXBvbmVudElkO1xuICAgICAgICAgICAgICAgIG5vZGVJbk5ld1RyZWUgID0gdm5vZGVNYXAuZ2V0KG9sZENoaWxkTm9kZUlkKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBub2RlLCBpZiBubyBsb25nZXIgaW5zaWRlIHRoZSBuZXcgdHJlZVxuICAgICAgICAgICAgICAgIGlmICghbm9kZUluTmV3VHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5yZW1vdmVOb2RlKHtkZWx0YXMsIG9sZFZub2RlOiBvbGRDaGlsZE5vZGUsIG9sZFZub2RlTWFwfSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0RGVsdGErKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgb2xkIGNoaWxkIG5vZGUgZ290IG1vdmVkIGludG8gYSBkaWZmZXJlbnQgbm90IHByb2Nlc3NlZCBhcnJheS4gSXQgd2lsbCBnZXQgcGlja2VkIHVwIHRoZXJlLlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgJiYgdm5vZGVJZCAhPT0gbm9kZUluTmV3VHJlZS5wYXJlbnROb2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhEZWx0YSsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChtZS5pc01vdmVkTm9kZShjaGlsZE5vZGUsIG9sZFZub2RlTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3ZlTm9kZSh7ZGVsdGFzLCBpbnNlcnREZWx0YSwgb2xkVm5vZGVNYXAsIHZub2RlOiBjaGlsZE5vZGUsIHZub2RlTWFwfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5pbnNlcnROb2RlKHtkZWx0YXMsIGluZGV4OiBpICsgaW5zZXJ0RGVsdGEsIG9sZFZub2RlTWFwLCB2bm9kZTogY2hpbGROb2RlLCB2bm9kZU1hcH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9sZENoaWxkTm9kZSAmJiB2bm9kZUlkID09PSB2bm9kZU1hcC5nZXQob2xkQ2hpbGROb2RlSWQpPy5wYXJlbnROb2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbisrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbHRhc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHJldHVybnMge09iamVjdHxOZW8udmRvbS5WTm9kZXxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVWbm9kZShvcHRzKSB7XG4gICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgdm5vZGUgaW5zdGFuY2VzIGZvciBjb21wb25lbnQgcmVmZXJlbmNlIG9iamVjdHNcbiAgICAgICAgaWYgKG9wdHMuY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIG9wdHMuY2hpbGROb2RlcyA/Pz0gW107IC8vIENvbnNpc3RlbmN5OiBFdmVyeSBWTm9kZSBoYXMgYSBjaGlsZE5vZGVzIGFycmF5XG4gICAgICAgICAgICBvcHRzLmlkICAgICAgICAgPz89IG9wdHMuY29tcG9uZW50SWRcblxuICAgICAgICAgICAgcmV0dXJuIG9wdHNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLnJlbW92ZURvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSB7YXR0cmlidXRlczoge30sIHN0eWxlOiB7fX0sXG4gICAgICAgICAgICBwb3RlbnRpYWxOb2RlO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG9wdHMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYga2V5ICE9PSAnZmxhZycgJiYga2V5ICE9PSAncmVtb3ZlRG9tJykge1xuICAgICAgICAgICAgICAgIGxldCBoYXNVbml0LCBuZXdWYWx1ZSwgc3R5bGU7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2goa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gdmFsdWUudG9TdHJpbmcoKTsgLy8gc3VwcG9ydCBmb3IgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZW1vdmVEb20gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0ucmVtb3ZlRG9tOyAvLyBjb3VsZCBiZSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxOb2RlID0gbWUuY3JlYXRlVm5vZGUoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE5vZGUpIHsgLy8gZG9uJ3QgYWRkIG51bGwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZS5wdXNoKHBvdGVudGlhbE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gW3ZhbHVlXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA8IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzW2BkYXRhLSR7TmVvLmRlY2FtZWwoa2V5KX1gXSA9IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF4SGVpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF4V2lkdGgnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaW5IZWlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaW5XaWR0aCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdEaW1lbnNpb25UYWdzLmhhcyhub2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlc1trZXldID0gdmFsdWUgKyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNVbml0ID0gdmFsdWUgIT0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVba2V5XSA9IHZhbHVlICsgKGhhc1VuaXQgPyAnJyA6ICdweCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21wb25lbnRJZCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlID0gT2JqZWN0LmFzc2lnbihzdHlsZSwgTmVvLmNvcmUuVXRpbC5jcmVhdGVTdHlsZU9iamVjdCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUgPSBPYmplY3QuYXNzaWduKHN0eWxlLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlICsgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVsZXZhbnQgZm9yIHZ0eXBlPSd0ZXh0J1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5hdHRyaWJ1dGVzKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5hdHRyaWJ1dGVzXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWxldmFudCBmb3IgdnR5cGU9J3RleHQnXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlLnN0eWxlKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5zdHlsZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWTm9kZShub2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0IG1hcCBvZiB0aGUgdHJlZSwgY29udGFpbmluZyBpZHMgYXMga2V5cyBhbmQgaW5mb3MgYXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgW2NvbmZpZy5pbmRleD0wXVxuICAgICAqIEBwYXJhbSB7TWFwfSAgICAgICAgICAgIFtjb25maWcubWFwPW5ldyBNYXAoKV1cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBbY29uZmlnLnBhcmVudE5vZGU9bnVsbF1cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcudm5vZGVcbiAgICAgKiBAcmV0dXJucyB7TWFwfVxuICAgICAqICAgICB7U3RyaW5nfSAgICAgICAgIGlkIHZub2RlLmlkIChjb252ZW5pZW5jZSBzaG9ydGN1dClcbiAgICAgKiAgICAge051bWJlcn0gICAgICAgICBpbmRleFxuICAgICAqICAgICB7U3RyaW5nfSAgICAgICAgIHBhcmVudElkXG4gICAgICogICAgIHtOZW8udmRvbS5WTm9kZX0gdm5vZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlVm5vZGVNYXAoe2luZGV4PTAsIG1hcD1uZXcgTWFwKCksIHBhcmVudE5vZGU9bnVsbCwgdm5vZGV9KSB7XG4gICAgICAgIGlmICh2bm9kZSkge1xuICAgICAgICAgICAgbGV0IGlkID0gdm5vZGUuaWQgfHwgdm5vZGUuY29tcG9uZW50SWQ7XG5cbiAgICAgICAgICAgIG1hcC5zZXQoaWQsIHtpZCwgaW5kZXgsIHBhcmVudE5vZGUsIHZub2RlfSk7XG5cbiAgICAgICAgICAgIHZub2RlLmNoaWxkTm9kZXM/LmZvckVhY2goKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVZub2RlTWFwKHtpbmRleCwgbWFwLCBwYXJlbnROb2RlOiB2bm9kZSwgdm5vZGU6IGNoaWxkTm9kZX0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2dpYyB3aWxsIHBhcnNlIHRoZSB2bm9kZSAodHJlZSkgdG8gZmluZCBleGlzdGluZyBpdGVtcyBpbnNpZGUgYSBnaXZlbiBtYXAuXG4gICAgICogSXQgd2lsbCBub3Qgc2VhcmNoIGZvciBmdXJ0aGVyIGNoaWxkTm9kZXMgaW5zaWRlIGFuIGFscmVhZHkgZm91bmQgdm5vZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgY29uZmlnXG4gICAgICogQHBhcmFtIHtNYXB9ICAgICAgICAgICAgW2NvbmZpZy5tb3ZlZE5vZGVzPW5ldyBNYXAoKV1cbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcub2xkVm5vZGVNYXBcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcudm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcudm5vZGVNYXBcbiAgICAgKiBAcmV0dXJucyB7TWFwfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaW5kTW92ZWROb2Rlcyh7bW92ZWROb2Rlcz1uZXcgTWFwKCksIG9sZFZub2RlTWFwLCB2bm9kZSwgdm5vZGVNYXB9KSB7XG4gICAgICAgIGxldCBpZCA9IHZub2RlPy5pZDtcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTW92ZWROb2RlKHZub2RlLCBvbGRWbm9kZU1hcCkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlZE5vZGVzLnNldChpZCwgdm5vZGVNYXAuZ2V0KGlkKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuY2hpbGROb2Rlcz8uZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLnZ0eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZE1vdmVkTm9kZXMoe21vdmVkTm9kZXMsIG9sZFZub2RlTWFwLCB2bm9kZTogY2hpbGROb2RlLCB2bm9kZU1hcH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVkTm9kZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3IgZGVsdGEgdXBkYXRlcyB0byB3b3JrLCBldmVyeSBub2RlIGluc2lkZSB0aGUgbGl2ZSBET00gbmVlZHMgYSB1bmlxdWUgSUQuXG4gICAgICogVGV4dCBub2RlcyBuZWVkIHRvIGdldCB3cmFwcGVkIGludG8gY29tbWVudCBub2Rlcywgd2hpY2ggY29udGFpbiB0aGUgSUQgdG8gZW5zdXJlIGNvbnNpc3RlbmN5LlxuICAgICAqIEFzIHRoZSByZXN1bHQsIHdlIG5lZWQgYSBwaHlzaWNhbCBpbmRleCB3aGljaCBjb3VudHMgZXZlcnkgdGV4dCBub2RlIGFzIDMgbm9kZXMuXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gcGFyZW50Tm9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgIGxvZ2ljYWxJbmRleFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UGh5c2ljYWxJbmRleChwYXJlbnROb2RlLCBsb2dpY2FsSW5kZXgpIHtcbiAgICAgICAgbGV0IHBoeXNpY2FsSW5kZXggPSBsb2dpY2FsSW5kZXgsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICA9IDA7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsb2dpY2FsSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUuY2hpbGROb2Rlc1tpXT8udnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHBoeXNpY2FsSW5kZXggKz0gMiAvLyBBY2NvdW50cyBmb3IgPCEtLW5lby12dGV4dC0tPiB3cmFwcGVyc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBoeXNpY2FsSW5kZXhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IGltcG9ydCBmb3IgdGhlIERPTSBBUEkgYmFzZWQgbW91bnQgYWRhcHRlci5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgaW1wb3J0RG9tQXBpVm5vZGVDcmVhdG9yKCkge1xuICAgICAgICBpZiAoIU5lb0NvbmZpZy51c2VTdHJpbmdCYXNlZE1vdW50aW5nICYmICFOZW8udmRvbS51dGlsPy5Eb21BcGlWbm9kZUNyZWF0b3IpIHtcbiAgICAgICAgICAgIGF3YWl0IGltcG9ydCgnLi91dGlsL0RvbUFwaVZub2RlQ3JlYXRvci5tanMnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSBpbXBvcnQgZm9yIHRoZSBzdHJpbmcgYmFzZWQgbW91bnQgYWRhcHRlci5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgaW1wb3J0U3RyaW5nRnJvbVZub2RlKCkge1xuICAgICAgICBpZiAoTmVvQ29uZmlnLnVzZVN0cmluZ0Jhc2VkTW91bnRpbmcgJiYgIU5lby52ZG9tLnV0aWw/LlN0cmluZ0Zyb21Wbm9kZSkge1xuICAgICAgICAgICAgYXdhaXQgaW1wb3J0KCcuL3V0aWwvU3RyaW5nRnJvbVZub2RlLm1qcycpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBjb25maWcuZGVsdGFzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgY29uZmlnLmluZGV4XG4gICAgICogQHBhcmFtIHtNYXB9ICAgICAgICAgICAgY29uZmlnLm9sZFZub2RlTWFwXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gY29uZmlnLnZub2RlXG4gICAgICogQHBhcmFtIHtNYXB9ICAgICAgICAgICAgY29uZmlnLnZub2RlTWFwXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluc2VydE5vZGUoe2RlbHRhcywgaW5kZXgsIG9sZFZub2RlTWFwLCB2bm9kZSwgdm5vZGVNYXB9KSB7XG4gICAgICAgIGxldCBkZXRhaWxzICAgICAgICAgICAgICAgID0gdm5vZGVNYXAuZ2V0KHZub2RlLmlkKSxcbiAgICAgICAgICAgIHtwYXJlbnROb2RlfSAgICAgICAgICAgPSBkZXRhaWxzLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgICAgICAgICA9IHBhcmVudE5vZGUuaWQsXG4gICAgICAgICAgICBtZSAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG1vdmVkTm9kZXMgICAgICAgICAgICAgPSBtZS5maW5kTW92ZWROb2Rlcyh7b2xkVm5vZGVNYXAsIHZub2RlLCB2bm9kZU1hcH0pLFxuICAgICAgICAgICAgZGVsdGEgICAgICAgICAgICAgICAgICA9IHthY3Rpb246ICdpbnNlcnROb2RlJywgcGFyZW50SWR9LFxuICAgICAgICAgICAgaGFzTGVhZGluZ1RleHRDaGlsZHJlbiA9IGZhbHNlLFxuICAgICAgICAgICAgcGh5c2ljYWxJbmRleCAgICAgICAgICA9IG1lLmdldFBoeXNpY2FsSW5kZXgocGFyZW50Tm9kZSwgaW5kZXgpOyAvLyBQcm9jZXNzZXMgdGhlIGNoaWxkcmVuIG9mIHRoZSAqTkVXKiBwYXJlbnQncyBWTm9kZSBpbiB0aGUgKmN1cnJlbnQqIHN0YXRlXG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihkZWx0YSwge2hhc0xlYWRpbmdUZXh0Q2hpbGRyZW4sIGluZGV4OiBwaHlzaWNhbEluZGV4fSk7XG5cbiAgICAgICAgaWYgKE5lb0NvbmZpZy51c2VTdHJpbmdCYXNlZE1vdW50aW5nKSB7XG4gICAgICAgICAgICAvLyBGb3Igc3RyaW5nLWJhc2VkIG1vdW50aW5nLCBwYXNzIGEgc3RyaW5nIGV4Y2x1ZGluZyBtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgZGVsdGEub3V0ZXJIVE1MID0gTmVvLnZkb20udXRpbC5TdHJpbmdGcm9tVm5vZGUuY3JlYXRlKHZub2RlLCBtb3ZlZE5vZGVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIGRpcmVjdCBET00gQVBJIG1vdW50aW5nLCBwYXNzIHRoZSBwcnVuZWQgVk5vZGUgdHJlZVxuICAgICAgICAgICAgZGVsdGEudm5vZGUgPSBOZW8udmRvbS51dGlsLkRvbUFwaVZub2RlQ3JlYXRvci5jcmVhdGUodm5vZGUsIG1vdmVkTm9kZXMpXG4gICAgICAgIH1cblxuICAgICAgICBkZWx0YXMuZGVmYXVsdC5wdXNoKGRlbHRhKTtcblxuICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBub2RlIGludG8gdGhlIG9sZCB0cmVlLCB0byBzaW1wbGlmeSBmdXR1cmUgT1BzXG4gICAgICAgIG9sZFZub2RlTWFwLmdldChwYXJlbnRJZCkudm5vZGUuY2hpbGROb2Rlcy5zcGxpY2UoaW5kZXgsIDAsIHZub2RlKTtcblxuICAgICAgICBtb3ZlZE5vZGVzLmZvckVhY2goZGV0YWlscyA9PiB7XG4gICAgICAgICAgICBsZXQge2lkfSAgICAgPSBkZXRhaWxzLFxuICAgICAgICAgICAgICAgIHBhcmVudElkID0gZGV0YWlscy5wYXJlbnROb2RlLmlkO1xuXG4gICAgICAgICAgICBkZWx0YXMuZGVmYXVsdC5wdXNoKHthY3Rpb246ICdtb3ZlTm9kZScsIGlkLCBpbmRleDogZGV0YWlscy5pbmRleCwgcGFyZW50SWR9KTtcblxuICAgICAgICAgICAgbWUuY3JlYXRlRGVsdGFzKHtkZWx0YXMsIG9sZFZub2RlOiBvbGRWbm9kZU1hcC5nZXQoaWQpLnZub2RlLCBvbGRWbm9kZU1hcCwgdm5vZGU6IGRldGFpbHMudm5vZGUsIHZub2RlTWFwfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IHZub2RlXG4gICAgICogQHBhcmFtIHtNYXB9IG9sZFZub2RlTWFwXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzTW92ZWROb2RlKHZub2RlLCBvbGRWbm9kZU1hcCkge1xuICAgICAgICBsZXQgb2xkVm5vZGUgPSBvbGRWbm9kZU1hcC5nZXQodm5vZGUuaWQpO1xuXG4gICAgICAgIHJldHVybiBvbGRWbm9kZSAmJiAoXG4gICAgICAgICAgICAhb2xkVm5vZGUudm5vZGUuY29tcG9uZW50SWQgfHwgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9sZCB2bm9kZSBpcyBub3QgYSByZWZlcmVuY2VcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudElkID09PSBvbGRWbm9kZS52bm9kZS5jb21wb25lbnRJZCAvLyBvbGQgJiBuZXcgbm9kZXMgYXJlIHRoZSBzYW1lIHJlZmVyZW5jZXNcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZy5kZWx0YXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICBjb25maWcuaW5zZXJ0RGVsdGFcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcub2xkVm5vZGVNYXBcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcudm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcudm5vZGVNYXBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZU5vZGUoe2RlbHRhcywgaW5zZXJ0RGVsdGEsIG9sZFZub2RlTWFwLCB2bm9kZSwgdm5vZGVNYXB9KSB7XG4gICAgICAgIGxldCBkZXRhaWxzICAgICAgICAgICAgID0gdm5vZGVNYXAuZ2V0KHZub2RlLmlkKSxcbiAgICAgICAgICAgIHtpbmRleCwgcGFyZW50Tm9kZX0gPSBkZXRhaWxzLFxuICAgICAgICAgICAgcGFyZW50SWQgICAgICAgICAgICA9IHBhcmVudE5vZGUuaWQsXG4gICAgICAgICAgICBtb3ZlZE5vZGUgICAgICAgICAgID0gb2xkVm5vZGVNYXAuZ2V0KHZub2RlLmlkKSxcbiAgICAgICAgICAgIG1vdmVkUGFyZW50Tm9kZSAgICAgPSBtb3ZlZE5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHtjaGlsZE5vZGVzfSAgICAgICAgPSBtb3ZlZFBhcmVudE5vZGUsXG4gICAgICAgICAgICBkZWx0YSAgICAgICAgICAgICAgID0ge2FjdGlvbjogJ21vdmVOb2RlJywgaWQ6IHZub2RlLmlkLCBwYXJlbnRJZH0sXG4gICAgICAgICAgICBwaHlzaWNhbEluZGV4ICAgICAgID0gdGhpcy5nZXRQaHlzaWNhbEluZGV4KHBhcmVudE5vZGUsIGluZGV4KTsgLy8gUHJvY2Vzc2VzIHRoZSBjaGlsZHJlbiBvZiB0aGUgKk5FVyogcGFyZW50J3MgVk5vZGUgaW4gdGhlICpjdXJyZW50KiBzdGF0ZSAocGFyZW50Tm9kZS5jaGlsZE5vZGVzKVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVsdGEsIHtpbmRleDogcGh5c2ljYWxJbmRleCArIGluc2VydERlbHRhfSk7XG4gICAgICAgIGRlbHRhcy5kZWZhdWx0LnB1c2goZGVsdGEpO1xuXG4gICAgICAgIC8vIFRoaXMgYmxvY2sgaW1wbGVtZW50cyB0aGUgXCJjb3JydXB0aW5nIHRoZSBvbGQgdHJlZVwiIG9wdGltaXphdGlvbiBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8vIEl0IHByZS1tb2RpZmllcyB0aGUgb2xkIFZOb2RlIG1hcCB0byByZWZsZWN0IHRoZSBtb3ZlLCBwcmV2ZW50aW5nIHJlZHVuZGFudCBkZWx0YXMgbGF0ZXIuXG4gICAgICAgIGlmIChwYXJlbnRJZCAhPT0gbW92ZWRQYXJlbnROb2RlLmlkKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBvbGQgcGFyZW50IGNoaWxkTm9kZXNcbiAgICAgICAgICAgIC8vICh3aGljaCBtdXN0IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbm9kZSB0aGV5IGdvdCBtb3ZlZCBpbnRvKVxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNoaWxkTm9kZXMsIG1vdmVkTm9kZS52bm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgVk5vZGUgcmVwcmVzZW50aW5nIHRoZSAqbmV3IHBhcmVudCogZnJvbSB0aGUgJ29sZCBWTm9kZSBtYXAnLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBjcnVjaWFsOiAnb2xkUGFyZW50Tm9kZScgaGVyZSBpcyB0aGUgKm9sZCBzdGF0ZSdzIFZOb2RlIGZvciB0aGUgbmV3IHBhcmVudCouXG4gICAgICAgICAgICBsZXQgb2xkUGFyZW50Tm9kZSA9IG9sZFZub2RlTWFwLmdldChwYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChvbGRQYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbW92ZWQgaW50byBhIG5ldyBwYXJlbnQgbm9kZSwgdXBkYXRlIHRoZSByZWZlcmVuY2UgaW5zaWRlIHRoZSBmbGF0IG1hcFxuICAgICAgICAgICAgICAgIG1vdmVkTm9kZS5wYXJlbnROb2RlID0gb2xkUGFyZW50Tm9kZS52bm9kZTtcblxuICAgICAgICAgICAgICAgIC8vIFJlYXNzaWduICdjaGlsZE5vZGVzJyBwcm9wZXJ0eSB0byBub3cgcG9pbnQgdG8gdGhlICdjaGlsZE5vZGVzJyBhcnJheVxuICAgICAgICAgICAgICAgIC8vIG9mIHRoaXMgJ29sZCBzdGF0ZSdzIFZOb2RlIGZvciB0aGUgbmV3IHBhcmVudCcuXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IG1vdmVkTm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgbm9kZSBpbnRvIHRoZSBvbGQgdm5vZGUgdHJlZSB0byBzaW1wbGlmeSBmdXR1cmUgT1BzLlxuICAgICAgICAvLyBOZW9BcnJheS5pbnNlcnQoKSB3aWxsIHN3aXRjaCB0byBtb3ZlKCkgaW4gY2FzZSB0aGUgbm9kZSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgTmVvQXJyYXkuaW5zZXJ0KGNoaWxkTm9kZXMsIGluZGV4LCBtb3ZlZE5vZGUudm5vZGUpO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlRGVsdGFzKHtkZWx0YXMsIG9sZFZub2RlOiBtb3ZlZE5vZGUudm5vZGUsIG9sZFZub2RlTWFwLCB2bm9kZSwgdm5vZGVNYXB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGNvbmZpZy5kZWx0YXNcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBjb25maWcub2xkVm5vZGVcbiAgICAgKiBAcGFyYW0ge01hcH0gICAgICAgICAgICBjb25maWcub2xkVm5vZGVNYXBcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZSh7ZGVsdGFzLCBvbGRWbm9kZSwgb2xkVm5vZGVNYXB9KSB7XG4gICAgICAgIGlmIChvbGRWbm9kZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgb2xkVm5vZGUuaWQgPz89IG9sZFZub2RlLmNvbXBvbmVudElkXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGVsdGEgICAgICAgID0ge2FjdGlvbjogJ3JlbW92ZU5vZGUnLCBpZDogb2xkVm5vZGUuaWR9LFxuICAgICAgICAgICAge3BhcmVudE5vZGV9ID0gb2xkVm5vZGVNYXAuZ2V0KG9sZFZub2RlLmlkKTtcblxuICAgICAgICBpZiAob2xkVm5vZGUudnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgZGVsdGEucGFyZW50SWQgPSBwYXJlbnROb2RlLmlkXG4gICAgICAgIH1cblxuICAgICAgICBkZWx0YXMucmVtb3ZlLnB1c2goZGVsdGEpO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShwYXJlbnROb2RlLmNoaWxkTm9kZXMsIG9sZFZub2RlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBOZW8udmRvbS5WTm9kZSB0cmVlIGZvciB0aGUgZ2l2ZW4gdmRvbSB0ZW1wbGF0ZSBhbmQgY29tcGFyZXMgdGhlIG5ldyB2bm9kZSB3aXRoIHRoZSBjdXJyZW50IG9uZVxuICAgICAqIHRvIGNhbGN1bGF0ZSB0aGUgdmRvbSBkZWx0YXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy52ZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudm5vZGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBkZWx0YXMsIHZub2RlO1xuXG4gICAgICAgIGF3YWl0IG1lLmltcG9ydERvbUFwaVZub2RlQ3JlYXRvcigpO1xuICAgICAgICBhd2FpdCBtZS5pbXBvcnRTdHJpbmdGcm9tVm5vZGUoKTtcblxuICAgICAgICB2bm9kZSAgPSBtZS5jcmVhdGVWbm9kZShvcHRzLnZkb20pO1xuICAgICAgICBkZWx0YXMgPSBtZS5jcmVhdGVEZWx0YXMoe29sZFZub2RlOiBvcHRzLnZub2RlLCB2bm9kZX0pO1xuXG4gICAgICAgIC8vIFRyZWVzIHRvIHJlbW92ZSBjb3VsZCBjb250YWluIG5vZGVzIHdoaWNoIHdlIHdhbnQgdG8gcmUtdXNlIChtb3ZlKSxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBleGVjdXRlIHRoZSByZW1vdmVOb2RlIE9QcyBsYXN0LlxuICAgICAgICBkZWx0YXMgPSBkZWx0YXMuZGVmYXVsdC5jb25jYXQoZGVsdGFzLnJlbW92ZSk7XG5cbiAgICAgICAgcmV0dXJuIHtkZWx0YXMsIHVwZGF0ZVZkb206IHRydWUsIHZub2RlfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoSGVscGVyKTtcbiIsImltcG9ydCBTdHJpbmdVdGlsIGZyb20gJy4uL3V0aWwvU3RyaW5nLm1qcyc7XG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBmb3Igdm5vZGUgb2JqZWN0cy5cbiAqIEZvciBjb252ZW5pZW5jZSwgYSBWTm9kZSBpbnN0YW5jZSB3aWxsIGFsd2F5cyBjb250YWluIGEgY2hpbGROb2RlcyBhcnJheSwgd2hpY2ggY2FuIGJlIGVtcHR5LlxuICogQSBWTm9kZSBjYW4gb3B0aW9uYWxseSBoYXZlIGBpbm5lckhUTUxgIHhvciBgdGV4dENvbnRlbnRgXG4gKiBgdGV4dENvbnRlbnRgIGlzIGJldHRlciBmcm9tIGEgWFNTIHNlY3VyaXR5IHBlcnNwZWN0aXZlLlxuICogSWYgYnkgYWNjaWRlbnQgYm90aCBhcmUgc2V0LCBgaW5uZXJIVE1MYCB3aWxsIGdldCB0aGUgcHJpb3JpdHkuXG4gKlxuICogQGNsYXNzIE5lby52ZG9tLlZOb2RlXG4gKi9cbmNsYXNzIFZOb2RlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3Qgc2V0IGZvciB2dHlwZT0ndGV4dCcgbm9kZXNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBhdHRyaWJ1dGVzPXt9XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheX0gY2hpbGROb2Rlcz1bXVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogTm90IHNldCBmb3IgdnR5cGU9J3RleHQnIG5vZGVzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBjbGFzc05hbWU9W11cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaWQ9TmVvLmdldElkKCd2bm9kZScpXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGlubmVySFRNTFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBub2RlTmFtZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBleGNsdWRlcyB0aGUgbm9kZSBmcm9tIGRlbHRhLXVwZGF0ZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc3RhdGljXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3Qgc2V0IGZvciB2dHlwZT0ndGV4dCcgbm9kZXNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdHlsZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB0ZXh0Q29udGVudFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWQgdmFsdWVzIGFyZSBcInJvb3RcIiwgXCJ0ZXh0XCIgJiBcInZub2RlXCJcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSB2dHlwZT0ndm5vZGUnXG4gICAgICAgICAqL1xuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt0ZXh0Q29udGVudH0gPSBjb25maWcsXG4gICAgICAgICAgICBoYXNJbm5lckh0bWwgID0gT2JqZWN0Lmhhc093bihjb25maWcsICdpbm5lckhUTUwnKSxcbiAgICAgICAgICAgIGlzVlRleHQgICAgICAgPSBjb25maWcudnR5cGUgPT09ICd0ZXh0JztcblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBjaGlsZE5vZGVzOiBjb25maWcuY2hpbGROb2RlcyB8fCBbXSxcbiAgICAgICAgICAgIGlkICAgICAgICA6IGNvbmZpZy5pZCAgICAgICAgIHx8IE5lby5nZXRJZChpc1ZUZXh0ID8gJ3Z0ZXh0JyA6ICd2bm9kZScpLFxuICAgICAgICAgICAgdnR5cGUgICAgIDogY29uZmlnLnZ0eXBlICAgICAgfHwgJ3Zub2RlJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaXNWVGV4dCkge1xuICAgICAgICAgICAgLy8gWFNTIFNlY3VyaXR5OiBhIHB1cmUgdGV4dCBub2RlIGlzIG5vdCBzdXBwb3NlZCB0byBjb250YWluIEhUTUxcbiAgICAgICAgICAgIG1lLnRleHRDb250ZW50ID0gU3RyaW5nVXRpbC5lc2NhcGVIdG1sKGhhc0lubmVySHRtbCA/IGNvbmZpZy5pbm5lckhUTUwgOiB0ZXh0Q29udGVudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBjb25maWcuYXR0cmlidXRlcyB8fCB7fSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgOiBjb25maWcuY2xhc3NOYW1lICB8fCBbXSxcbiAgICAgICAgICAgICAgICBub2RlTmFtZSAgOiBjb25maWcubm9kZU5hbWUgICB8fCAnZGl2JyxcbiAgICAgICAgICAgICAgICBzdHlsZSAgICAgOiBjb25maWcuc3R5bGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVc2UgdmRvbS5odG1sIG9uIHlvdXIgb3duIHJpc2ssIGl0IGlzIG5vdCBmdWxseSBYU1Mgc2VjdXJlLlxuICAgICAgICAgICAgaWYgKGhhc0lubmVySHRtbCkge1xuICAgICAgICAgICAgICAgIG1lLmlubmVySFRNTCA9IGNvbmZpZy5pbm5lckhUTUxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2Ugb25seSBhcHBseSB0ZXh0Q29udGVudCwgaW4gY2FzZSBpdCBoYXMgY29udGVudFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093bihjb25maWcsICd0ZXh0Q29udGVudCcpKSB7XG4gICAgICAgICAgICAgICAgbWUudGV4dENvbnRlbnQgPSBOZW8uY29uZmlnLnVzZVN0cmluZ0Jhc2VkTW91bnRpbmcgPyBTdHJpbmdVdGlsLmVzY2FwZUh0bWwodGV4dENvbnRlbnQpIDogdGV4dENvbnRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG9ubHkgYXBwbHkgdGhlIHN0YXRpYyBhdHRyaWJ1dGUsIGluIGNhc2UgdGhlIHZhbHVlIGlzIHRydWVcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0aWMpIHtcbiAgICAgICAgICAgIG1lLnN0YXRpYyA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgbnMgPSBOZW8ubnMoJ05lby52ZG9tJywgdHJ1ZSk7XG5ucy5WTm9kZSA9IFZOb2RlO1xuXG5leHBvcnQgZGVmYXVsdCBWTm9kZTtcbiIsIi8qKlxuICogVGhlIGZvbGxvd2luZyB0b3AtbGV2ZWwgYXR0cmlidXRlcyB3aWxsIGdldCBjb252ZXJ0ZWQgaW50byBzdHlsZXM6XG4gKiBoZWlnaHQsIG1heEhlaWdodCwgbWF4V2lkdGgsIG1pbkhlaWdodCwgbWluV2lkdGgsIHdpZHRoXG4gKlxuICogU29tZSB0YWdzIG11c3Qgbm90IGRvIHRoZSB0cmFuc2Zvcm1hdGlvbiwgc28gd2UgYWRkIHRoZW0gaGVyZS5cbiAqIEBtZW1iZXIge1NldH0gcmF3RGltZW5zaW9uVGFnc1xuICovXG5leHBvcnQgY29uc3QgcmF3RGltZW5zaW9uVGFncyA9IG5ldyBTZXQoW1xuICAgICdjaXJjbGUnLFxuICAgICdjbGlwUGF0aCcsXG4gICAgJ2VsbGlwc2UnLFxuICAgICdmaWx0ZXInLFxuICAgICdmb3JlaWduT2JqZWN0JyxcbiAgICAnaW1hZ2UnLFxuICAgICdtYXJrZXInLFxuICAgICdtYXNrJyxcbiAgICAncGF0dGVybicsXG4gICAgJ3JlY3QnLFxuICAgICdzdmcnLFxuICAgICd1c2UnXG5dKTtcblxuLyoqXG4gKiBWb2lkIGF0dHJpYnV0ZXMgaW5zaWRlIGh0bWwgdGFnc1xuICogQG1lbWJlciB7U2V0fSB2b2lkQXR0cmlidXRlc1xuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY29uc3Qgdm9pZEF0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdpc21hcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbm9ocmVmJyxcbiAgICAnbm9yZXNpemUnLFxuICAgICdub3NoYWRlJyxcbiAgICAnbm93cmFwJyxcbiAgICAnb3BlbicsXG4gICAgJ3JlYWRvbmx5JyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZXZlcnNlZCcsXG4gICAgJ3NlbGVjdGVkJ1xuXSk7XG5cbi8qKlxuICogVm9pZCBodG1sIHRhZ3NcbiAqIEBtZW1iZXIge1NldH0gdm9pZEVsZW1lbnRzXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmV4cG9ydCBjb25zdCB2b2lkRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICAnYXJlYScsXG4gICAgJ2Jhc2UnLFxuICAgICdicicsXG4gICAgJ2NvbCcsXG4gICAgJ2VtYmVkJyxcbiAgICAnaHInLFxuICAgICdpbWcnLFxuICAgICdpbnB1dCcsXG4gICAgJ2xpbmsnLFxuICAgICdtZXRhJyxcbiAgICAncGFyYW0nLFxuICAgICdzb3VyY2UnLFxuICAgICd0cmFjaycsXG4gICAgJ3dicidcbl0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9