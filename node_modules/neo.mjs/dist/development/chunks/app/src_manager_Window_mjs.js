"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_manager_Window_mjs"],{

/***/ "./src/manager/Window.mjs"
/*!********************************!*\
  !*** ./src/manager/Window.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");



/**
 * @summary The "God View" for the multi-window application workspace.
 * @description This manager maintains a real-time geometric map of all connected browser windows in the App Worker.
 * It is the central authority for spatial awareness, enabling features like the "Infinite Canvas" where
 * interactions (like Drag & Drop) can span across multiple OS-level windows.
 *
 * It receives high-frequency position updates from the Main Thread (via `Neo.main.addon.WindowPosition`)
 * and provides intersection testing APIs to determine which window is under a given screen coordinate.
 *
 * @class Neo.manager.Window
 * @extends Neo.manager.Base
 * @singleton
 * @see Neo.main.addon.WindowPosition
 */
class Window extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Window'
         * @protected
         */
        className: 'Neo.manager.Window',
        /**
         * @member {Boolean} isSafari
         * @protected
         */
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * Returns the windowId which intersects with the given global screen coordinates.
     * This is the core intersection test for cross-window drag and drop operations.
     * @param {Number} x Screen X coordinate
     * @param {Number} y Screen Y coordinate
     * @returns {String|null} The windowId of the target window, or null if no intersection.
     */
    getWindowAt(x, y) {
        let item = this.items.find(item => item.outerRect?.intersects({bottom: y, right: x, x, y}));

        return item ? item.id : null
    }

    /**
     * @param {Object} data
     * @returns {Object} {chrome, innerRect, outerRect}
     */
    calculateGeometry(data) {
        const
            {innerHeight, innerWidth, mozInnerScreenX, mozInnerScreenY, outerHeight, outerWidth, screenLeft, screenTop} = data,
            widthDiff    = outerWidth  - innerWidth,
            heightDiff   = outerHeight - innerHeight,
            // Assumption: Side borders are symmetric
            sideBorder   = widthDiff / 2,
            // Assumption: Bottom border matches side border (common in Windows)
            bottomBorder = sideBorder,
            // The rest is the top chrome (header)
            topChrome    = heightDiff - bottomBorder;

        const chrome = {
            bottom: bottomBorder,
            left  : sideBorder,
            right : sideBorder,
            top   : topChrome
        };

        let viewportLeft, viewportTop;

        if (typeof mozInnerScreenX === 'number') {
            // Firefox: explicit viewport coordinates
            viewportLeft = mozInnerScreenX;
            viewportTop  = mozInnerScreenY
        } else if (this.isSafari) {
            // Safari: screenLeft/Top is Frame position. Add chrome to get Viewport.
            viewportLeft = screenLeft + sideBorder;
            viewportTop  = screenTop  + topChrome
        } else {
            // Chrome/Edge: screenLeft/Top is Viewport position.
            viewportLeft = screenLeft;
            viewportTop  = screenTop
        }

        const innerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](viewportLeft, viewportTop, innerWidth, innerHeight);

        const outerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            viewportLeft - sideBorder,
            viewportTop  - topChrome,
            outerWidth,
            outerHeight
        );

        return {chrome, innerRect, outerRect}
    }

    /**
     * Triggered when a new browser window connects to the SharedWorker.
     * In Shared Worker mode, `Neo.worker.App#onConnect` ensures that `windowData`
     * is fetched from the Main Thread and included in the payload.
     * @param {Object} data
     * @param {Number} data.appName
     * @param {Object} [data.windowData] Contains geometry data (screenLeft, innerHeight, etc.)
     * @param {String} data.windowId
     */
    onWindowConnect({appName, windowData, windowId}) {
        let chrome    = null,
            innerRect = null,
            outerRect = null;

        if (windowData) {
            ({chrome, innerRect, outerRect} = this.calculateGeometry(windowData))
        }

        console.log('Window.onWindowConnect', {windowId, appName, chrome, innerRect, outerRect});

        this.register({appName, chrome, id: windowId, innerRect, outerRect})
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowDisconnect({windowId}) {
        this.unregister(windowId)
    }

    /**
     * Updates the geometric state of a window based on data from the Main Thread.
     * This method is called via direct delegation from the App Worker to minimize overhead.
     * @param {Object} data
     * @param {Number} data.innerHeight
     * @param {Number} data.outerHeight
     * @param {Number} data.outerWidth
     * @param {Number} data.screenLeft
     * @param {Number} data.screenTop
     * @param {String} data.windowId
     */
    onWindowPositionChange(data) {
        const
            me   = this,
            item = me.get(data.windowId),
            {chrome, innerRect, outerRect} = me.calculateGeometry(data);

        if (item) {
            item.chrome    = chrome;
            item.innerRect = innerRect;
            item.outerRect = outerRect
        } else {
            me.register({
                chrome,
                id: data.windowId,
                innerRect,
                outerRect
            })
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            className: this.className,
            windows  : this.items.map(win => ({
                id       : win.id,
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Window));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfbWFuYWdlcl9XaW5kb3dfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNXOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFPO0FBQzVCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBLHVFQUF1RSwwQkFBMEI7O0FBRWpHO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyR0FBMkc7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QiwyREFBUzs7QUFFdkMsOEJBQThCLDJEQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDhCQUE4QjtBQUM1Qzs7QUFFQSwrQ0FBK0MsZ0RBQWdEOztBQUUvRix1QkFBdUIsb0RBQW9EO0FBQzNFOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21hbmFnZXIvV2luZG93Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWFuYWdlciAgIGZyb20gJy4vQmFzZS5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuLi91dGlsL1JlY3RhbmdsZS5tanMnO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFRoZSBcIkdvZCBWaWV3XCIgZm9yIHRoZSBtdWx0aS13aW5kb3cgYXBwbGljYXRpb24gd29ya3NwYWNlLlxuICogQGRlc2NyaXB0aW9uIFRoaXMgbWFuYWdlciBtYWludGFpbnMgYSByZWFsLXRpbWUgZ2VvbWV0cmljIG1hcCBvZiBhbGwgY29ubmVjdGVkIGJyb3dzZXIgd2luZG93cyBpbiB0aGUgQXBwIFdvcmtlci5cbiAqIEl0IGlzIHRoZSBjZW50cmFsIGF1dGhvcml0eSBmb3Igc3BhdGlhbCBhd2FyZW5lc3MsIGVuYWJsaW5nIGZlYXR1cmVzIGxpa2UgdGhlIFwiSW5maW5pdGUgQ2FudmFzXCIgd2hlcmVcbiAqIGludGVyYWN0aW9ucyAobGlrZSBEcmFnICYgRHJvcCkgY2FuIHNwYW4gYWNyb3NzIG11bHRpcGxlIE9TLWxldmVsIHdpbmRvd3MuXG4gKlxuICogSXQgcmVjZWl2ZXMgaGlnaC1mcmVxdWVuY3kgcG9zaXRpb24gdXBkYXRlcyBmcm9tIHRoZSBNYWluIFRocmVhZCAodmlhIGBOZW8ubWFpbi5hZGRvbi5XaW5kb3dQb3NpdGlvbmApXG4gKiBhbmQgcHJvdmlkZXMgaW50ZXJzZWN0aW9uIHRlc3RpbmcgQVBJcyB0byBkZXRlcm1pbmUgd2hpY2ggd2luZG93IGlzIHVuZGVyIGEgZ2l2ZW4gc2NyZWVuIGNvb3JkaW5hdGUuXG4gKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLldpbmRvd1xuICogQGV4dGVuZHMgTmVvLm1hbmFnZXIuQmFzZVxuICogQHNpbmdsZXRvblxuICogQHNlZSBOZW8ubWFpbi5hZGRvbi5XaW5kb3dQb3NpdGlvblxuICovXG5jbGFzcyBXaW5kb3cgZXh0ZW5kcyBNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLldpbmRvdydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuV2luZG93JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzU2FmYXJpXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzU2FmYXJpOiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBOZW8uY3VycmVudFdvcmtlci5vbih7XG4gICAgICAgICAgICBjb25uZWN0ICAgOiBtZS5vbldpbmRvd0Nvbm5lY3QsXG4gICAgICAgICAgICBkaXNjb25uZWN0OiBtZS5vbldpbmRvd0Rpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzY29wZSAgICAgOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpbmRvd0lkIHdoaWNoIGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gZ2xvYmFsIHNjcmVlbiBjb29yZGluYXRlcy5cbiAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIGludGVyc2VjdGlvbiB0ZXN0IGZvciBjcm9zcy13aW5kb3cgZHJhZyBhbmQgZHJvcCBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFNjcmVlbiBYIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBTY3JlZW4gWSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBUaGUgd2luZG93SWQgb2YgdGhlIHRhcmdldCB3aW5kb3csIG9yIG51bGwgaWYgbm8gaW50ZXJzZWN0aW9uLlxuICAgICAqL1xuICAgIGdldFdpbmRvd0F0KHgsIHkpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm91dGVyUmVjdD8uaW50ZXJzZWN0cyh7Ym90dG9tOiB5LCByaWdodDogeCwgeCwgeX0pKTtcblxuICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaWQgOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7Y2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH1cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVHZW9tZXRyeShkYXRhKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICB7aW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIG1veklubmVyU2NyZWVuWCwgbW96SW5uZXJTY3JlZW5ZLCBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aCwgc2NyZWVuTGVmdCwgc2NyZWVuVG9wfSA9IGRhdGEsXG4gICAgICAgICAgICB3aWR0aERpZmYgICAgPSBvdXRlcldpZHRoICAtIGlubmVyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHREaWZmICAgPSBvdXRlckhlaWdodCAtIGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgLy8gQXNzdW1wdGlvbjogU2lkZSBib3JkZXJzIGFyZSBzeW1tZXRyaWNcbiAgICAgICAgICAgIHNpZGVCb3JkZXIgICA9IHdpZHRoRGlmZiAvIDIsXG4gICAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBCb3R0b20gYm9yZGVyIG1hdGNoZXMgc2lkZSBib3JkZXIgKGNvbW1vbiBpbiBXaW5kb3dzKVxuICAgICAgICAgICAgYm90dG9tQm9yZGVyID0gc2lkZUJvcmRlcixcbiAgICAgICAgICAgIC8vIFRoZSByZXN0IGlzIHRoZSB0b3AgY2hyb21lIChoZWFkZXIpXG4gICAgICAgICAgICB0b3BDaHJvbWUgICAgPSBoZWlnaHREaWZmIC0gYm90dG9tQm9yZGVyO1xuXG4gICAgICAgIGNvbnN0IGNocm9tZSA9IHtcbiAgICAgICAgICAgIGJvdHRvbTogYm90dG9tQm9yZGVyLFxuICAgICAgICAgICAgbGVmdCAgOiBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgcmlnaHQgOiBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgdG9wICAgOiB0b3BDaHJvbWVcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgdmlld3BvcnRMZWZ0LCB2aWV3cG9ydFRvcDtcblxuICAgICAgICBpZiAodHlwZW9mIG1veklubmVyU2NyZWVuWCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3g6IGV4cGxpY2l0IHZpZXdwb3J0IGNvb3JkaW5hdGVzXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSBtb3pJbm5lclNjcmVlblg7XG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgPSBtb3pJbm5lclNjcmVlbllcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2FmYXJpKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmk6IHNjcmVlbkxlZnQvVG9wIGlzIEZyYW1lIHBvc2l0aW9uLiBBZGQgY2hyb21lIHRvIGdldCBWaWV3cG9ydC5cbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IHNjcmVlbkxlZnQgKyBzaWRlQm9yZGVyO1xuICAgICAgICAgICAgdmlld3BvcnRUb3AgID0gc2NyZWVuVG9wICArIHRvcENocm9tZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IHNjcmVlbkxlZnQvVG9wIGlzIFZpZXdwb3J0IHBvc2l0aW9uLlxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gc2NyZWVuTGVmdDtcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICA9IHNjcmVlblRvcFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5uZXJSZWN0ID0gbmV3IFJlY3RhbmdsZSh2aWV3cG9ydExlZnQsIHZpZXdwb3J0VG9wLCBpbm5lcldpZHRoLCBpbm5lckhlaWdodCk7XG5cbiAgICAgICAgY29uc3Qgb3V0ZXJSZWN0ID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCAtIHNpZGVCb3JkZXIsXG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgLSB0b3BDaHJvbWUsXG4gICAgICAgICAgICBvdXRlcldpZHRoLFxuICAgICAgICAgICAgb3V0ZXJIZWlnaHRcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBuZXcgYnJvd3NlciB3aW5kb3cgY29ubmVjdHMgdG8gdGhlIFNoYXJlZFdvcmtlci5cbiAgICAgKiBJbiBTaGFyZWQgV29ya2VyIG1vZGUsIGBOZW8ud29ya2VyLkFwcCNvbkNvbm5lY3RgIGVuc3VyZXMgdGhhdCBgd2luZG93RGF0YWBcbiAgICAgKiBpcyBmZXRjaGVkIGZyb20gdGhlIE1haW4gVGhyZWFkIGFuZCBpbmNsdWRlZCBpbiB0aGUgcGF5bG9hZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGEud2luZG93RGF0YV0gQ29udGFpbnMgZ2VvbWV0cnkgZGF0YSAoc2NyZWVuTGVmdCwgaW5uZXJIZWlnaHQsIGV0Yy4pXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd0Nvbm5lY3Qoe2FwcE5hbWUsIHdpbmRvd0RhdGEsIHdpbmRvd0lkfSkge1xuICAgICAgICBsZXQgY2hyb21lICAgID0gbnVsbCxcbiAgICAgICAgICAgIGlubmVyUmVjdCA9IG51bGwsXG4gICAgICAgICAgICBvdXRlclJlY3QgPSBudWxsO1xuXG4gICAgICAgIGlmICh3aW5kb3dEYXRhKSB7XG4gICAgICAgICAgICAoe2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9ID0gdGhpcy5jYWxjdWxhdGVHZW9tZXRyeSh3aW5kb3dEYXRhKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdXaW5kb3cub25XaW5kb3dDb25uZWN0Jywge3dpbmRvd0lkLCBhcHBOYW1lLCBjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3Rlcih7YXBwTmFtZSwgY2hyb21lLCBpZDogd2luZG93SWQsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIG9uV2luZG93RGlzY29ubmVjdCh7d2luZG93SWR9KSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3Rlcih3aW5kb3dJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnZW9tZXRyaWMgc3RhdGUgb2YgYSB3aW5kb3cgYmFzZWQgb24gZGF0YSBmcm9tIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdmlhIGRpcmVjdCBkZWxlZ2F0aW9uIGZyb20gdGhlIEFwcCBXb3JrZXIgdG8gbWluaW1pemUgb3ZlcmhlYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5pbm5lckhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm91dGVySGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEub3V0ZXJXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNjcmVlbkxlZnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JlZW5Ub3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIG9uV2luZG93UG9zaXRpb25DaGFuZ2UoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gbWUuZ2V0KGRhdGEud2luZG93SWQpLFxuICAgICAgICAgICAge2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9ID0gbWUuY2FsY3VsYXRlR2VvbWV0cnkoZGF0YSk7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0uY2hyb21lICAgID0gY2hyb21lO1xuICAgICAgICAgICAgaXRlbS5pbm5lclJlY3QgPSBpbm5lclJlY3Q7XG4gICAgICAgICAgICBpdGVtLm91dGVyUmVjdCA9IG91dGVyUmVjdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUucmVnaXN0ZXIoe1xuICAgICAgICAgICAgICAgIGNocm9tZSxcbiAgICAgICAgICAgICAgICBpZDogZGF0YS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICBpbm5lclJlY3QsXG4gICAgICAgICAgICAgICAgb3V0ZXJSZWN0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuY2xhc3NOYW1lLFxuICAgICAgICAgICAgd2luZG93cyAgOiB0aGlzLml0ZW1zLm1hcCh3aW4gPT4gKHtcbiAgICAgICAgICAgICAgICBpZCAgICAgICA6IHdpbi5pZCxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICA6IHdpbi5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGNocm9tZSAgIDogd2luLmNocm9tZSxcbiAgICAgICAgICAgICAgICBpbm5lclJlY3Q6IHdpbi5pbm5lclJlY3QsXG4gICAgICAgICAgICAgICAgb3V0ZXJSZWN0OiB3aW4ub3V0ZXJSZWN0XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoV2luZG93KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=