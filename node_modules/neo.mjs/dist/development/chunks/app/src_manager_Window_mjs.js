"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_manager_Window_mjs"],{

/***/ "./src/manager/Window.mjs":
/*!********************************!*\
  !*** ./src/manager/Window.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");



/**
 * @summary The "God View" for the multi-window application workspace.
 * @description This manager maintains a real-time geometric map of all connected browser windows in the App Worker.
 * It is the central authority for spatial awareness, enabling features like the "Infinite Canvas" where
 * interactions (like Drag & Drop) can span across multiple OS-level windows.
 *
 * It receives high-frequency position updates from the Main Thread (via `Neo.main.addon.WindowPosition`)
 * and provides intersection testing APIs to determine which window is under a given screen coordinate.
 *
 * @class Neo.manager.Window
 * @extends Neo.manager.Base
 * @singleton
 * @see Neo.main.addon.WindowPosition
 */
class Window extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Window'
         * @protected
         */
        className: 'Neo.manager.Window',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * Returns the windowId which intersects with the given global screen coordinates.
     * This is the core intersection test for cross-window drag and drop operations.
     * @param {Number} x Screen X coordinate
     * @param {Number} y Screen Y coordinate
     * @returns {String|null} The windowId of the target window, or null if no intersection.
     */
    getWindowAt(x, y) {
        let item = this.items.find(item => item.rect?.contains({x, y, right: x, bottom: y}));

        return item ? item.id : null
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowConnect({appName, windowId}) {
        this.register({appName, id: windowId, rect: null})
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowDisconnect({windowId}) {
        this.unregister(windowId)
    }

    /**
     * Updates the geometric state of a window based on data from the Main Thread.
     * This method is called via direct delegation from the App Worker to minimize overhead.
     * @param {Object} data
     * @param {Number} data.outerHeight
     * @param {Number} data.outerWidth
     * @param {Number} data.screenLeft
     * @param {Number} data.screenTop
     * @param {String} data.windowId
     */
    onWindowPositionChange({outerHeight, outerWidth, screenLeft, screenTop, windowId}) {
        let item = this.get(windowId),
            rect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](screenLeft, screenTop, outerWidth, outerHeight);

        if (item) {
            item.rect = rect
        } else {
            this.register({id: windowId, rect})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Window));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfbWFuYWdlcl9XaW5kb3dfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNXOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFPO0FBQzVCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQSxnRUFBZ0UsMEJBQTBCOztBQUUxRjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHVCQUF1QixrQ0FBa0M7QUFDekQ7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSw0QkFBNEIseURBQXlEO0FBQ3JGO0FBQ0EsdUJBQXVCLDJEQUFTOztBQUVoQztBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1dpbmRvdy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hbmFnZXIgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBUaGUgXCJHb2QgVmlld1wiIGZvciB0aGUgbXVsdGktd2luZG93IGFwcGxpY2F0aW9uIHdvcmtzcGFjZS5cbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1hbmFnZXIgbWFpbnRhaW5zIGEgcmVhbC10aW1lIGdlb21ldHJpYyBtYXAgb2YgYWxsIGNvbm5lY3RlZCBicm93c2VyIHdpbmRvd3MgaW4gdGhlIEFwcCBXb3JrZXIuXG4gKiBJdCBpcyB0aGUgY2VudHJhbCBhdXRob3JpdHkgZm9yIHNwYXRpYWwgYXdhcmVuZXNzLCBlbmFibGluZyBmZWF0dXJlcyBsaWtlIHRoZSBcIkluZmluaXRlIENhbnZhc1wiIHdoZXJlXG4gKiBpbnRlcmFjdGlvbnMgKGxpa2UgRHJhZyAmIERyb3ApIGNhbiBzcGFuIGFjcm9zcyBtdWx0aXBsZSBPUy1sZXZlbCB3aW5kb3dzLlxuICpcbiAqIEl0IHJlY2VpdmVzIGhpZ2gtZnJlcXVlbmN5IHBvc2l0aW9uIHVwZGF0ZXMgZnJvbSB0aGUgTWFpbiBUaHJlYWQgKHZpYSBgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb25gKVxuICogYW5kIHByb3ZpZGVzIGludGVyc2VjdGlvbiB0ZXN0aW5nIEFQSXMgdG8gZGV0ZXJtaW5lIHdoaWNoIHdpbmRvdyBpcyB1bmRlciBhIGdpdmVuIHNjcmVlbiBjb29yZGluYXRlLlxuICpcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5XaW5kb3dcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqIEBzZWUgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb25cbiAqL1xuY2xhc3MgV2luZG93IGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5XaW5kb3cnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLldpbmRvdycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lby5jdXJyZW50V29ya2VyLm9uKHtcbiAgICAgICAgICAgIGNvbm5lY3QgICA6IG1lLm9uV2luZG93Q29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG1lLm9uV2luZG93RGlzY29ubmVjdCxcbiAgICAgICAgICAgIHNjb3BlICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2luZG93SWQgd2hpY2ggaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBnbG9iYWwgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICAgICAqIFRoaXMgaXMgdGhlIGNvcmUgaW50ZXJzZWN0aW9uIHRlc3QgZm9yIGNyb3NzLXdpbmRvdyBkcmFnIGFuZCBkcm9wIG9wZXJhdGlvbnMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggU2NyZWVuIFggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFNjcmVlbiBZIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFRoZSB3aW5kb3dJZCBvZiB0aGUgdGFyZ2V0IHdpbmRvdywgb3IgbnVsbCBpZiBubyBpbnRlcnNlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0V2luZG93QXQoeCwgeSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuaXRlbXMuZmluZChpdGVtID0+IGl0ZW0ucmVjdD8uY29udGFpbnMoe3gsIHksIHJpZ2h0OiB4LCBib3R0b206IHl9KSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlkIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuYXBwTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25XaW5kb3dDb25uZWN0KHthcHBOYW1lLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih7YXBwTmFtZSwgaWQ6IHdpbmRvd0lkLCByZWN0OiBudWxsfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmFwcE5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS53aW5kb3dJZFxuICAgICAqL1xuICAgIG9uV2luZG93RGlzY29ubmVjdCh7d2luZG93SWR9KSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3Rlcih3aW5kb3dJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnZW9tZXRyaWMgc3RhdGUgb2YgYSB3aW5kb3cgYmFzZWQgb24gZGF0YSBmcm9tIHRoZSBNYWluIFRocmVhZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdmlhIGRpcmVjdCBkZWxlZ2F0aW9uIGZyb20gdGhlIEFwcCBXb3JrZXIgdG8gbWluaW1pemUgb3ZlcmhlYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vdXRlckhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm91dGVyV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JlZW5MZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyZWVuVG9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd1Bvc2l0aW9uQ2hhbmdlKHtvdXRlckhlaWdodCwgb3V0ZXJXaWR0aCwgc2NyZWVuTGVmdCwgc2NyZWVuVG9wLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmdldCh3aW5kb3dJZCksXG4gICAgICAgICAgICByZWN0ID0gbmV3IFJlY3RhbmdsZShzY3JlZW5MZWZ0LCBzY3JlZW5Ub3AsIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5yZWN0ID0gcmVjdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih7aWQ6IHdpbmRvd0lkLCByZWN0fSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoV2luZG93KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=