export const __webpack_esm_id__ = "src_manager_Window_mjs";
export const __webpack_esm_ids__ = ["src_manager_Window_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/manager/Window.mjs"
/*!********************************!*\
  !*** ./src/manager/Window.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");



/**
 * @summary The "God View" for the multi-window application workspace.
 * @description This manager maintains a real-time geometric map of all connected browser windows in the App Worker.
 * It is the central authority for spatial awareness, enabling features like the "Infinite Canvas" where
 * interactions (like Drag & Drop) can span across multiple OS-level windows.
 *
 * It receives high-frequency position updates from the Main Thread (via `Neo.main.addon.WindowPosition`)
 * and provides intersection testing APIs to determine which window is under a given screen coordinate.
 *
 * @class Neo.manager.Window
 * @extends Neo.manager.Base
 * @singleton
 * @see Neo.main.addon.WindowPosition
 */
class Window extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Window'
         * @protected
         */
        className: 'Neo.manager.Window',
        /**
         * @member {Boolean} isSafari
         * @protected
         */
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        Neo.currentWorker.on({
            connect   : me.onWindowConnect,
            disconnect: me.onWindowDisconnect,
            scope     : me
        })
    }

    /**
     * Returns the windowId which intersects with the given global screen coordinates.
     * This is the core intersection test for cross-window drag and drop operations.
     * @param {Number} x Screen X coordinate
     * @param {Number} y Screen Y coordinate
     * @returns {String|null} The windowId of the target window, or null if no intersection.
     */
    getWindowAt(x, y) {
        let item = this.items.find(item => item.outerRect?.intersects({bottom: y, right: x, x, y}));

        return item ? item.id : null
    }

    /**
     * @param {Object} data
     * @returns {Object} {chrome, innerRect, outerRect}
     */
    calculateGeometry(data) {
        const
            {innerHeight, innerWidth, mozInnerScreenX, mozInnerScreenY, outerHeight, outerWidth, screenLeft, screenTop} = data,
            widthDiff    = outerWidth  - innerWidth,
            heightDiff   = outerHeight - innerHeight,
            // Assumption: Side borders are symmetric
            sideBorder   = widthDiff / 2,
            // Assumption: Bottom border matches side border (common in Windows)
            bottomBorder = sideBorder,
            // The rest is the top chrome (header)
            topChrome    = heightDiff - bottomBorder;

        const chrome = {
            bottom: bottomBorder,
            left  : sideBorder,
            right : sideBorder,
            top   : topChrome
        };

        let viewportLeft, viewportTop;

        if (typeof mozInnerScreenX === 'number') {
            // Firefox: explicit viewport coordinates
            viewportLeft = mozInnerScreenX;
            viewportTop  = mozInnerScreenY
        } else if (this.isSafari) {
            // Safari: screenLeft/Top is Frame position. Add chrome to get Viewport.
            viewportLeft = screenLeft + sideBorder;
            viewportTop  = screenTop  + topChrome
        } else {
            // Chrome/Edge: screenLeft/Top is Viewport position.
            viewportLeft = screenLeft;
            viewportTop  = screenTop
        }

        const innerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](viewportLeft, viewportTop, innerWidth, innerHeight);

        const outerRect = new _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            viewportLeft - sideBorder,
            viewportTop  - topChrome,
            outerWidth,
            outerHeight
        );

        return {chrome, innerRect, outerRect}
    }

    /**
     * Triggered when a new browser window connects to the SharedWorker.
     * In Shared Worker mode, `Neo.worker.App#onConnect` ensures that `windowData`
     * is fetched from the Main Thread and included in the payload.
     * @param {Object} data
     * @param {Number} data.appName
     * @param {Object} [data.windowData] Contains geometry data (screenLeft, innerHeight, etc.)
     * @param {String} data.windowId
     */
    onWindowConnect({appName, windowData, windowId}) {
        let chrome    = null,
            innerRect = null,
            outerRect = null;

        if (windowData) {
            ({chrome, innerRect, outerRect} = this.calculateGeometry(windowData))
        }

        console.log('Window.onWindowConnect', {windowId, appName, chrome, innerRect, outerRect});

        this.register({appName, chrome, id: windowId, innerRect, outerRect})
    }

    /**
     * @param {Object} data
     * @param {Number} data.appName
     * @param {String} data.windowId
     */
    onWindowDisconnect({windowId}) {
        this.unregister(windowId)
    }

    /**
     * Updates the geometric state of a window based on data from the Main Thread.
     * This method is called via direct delegation from the App Worker to minimize overhead.
     * @param {Object} data
     * @param {Number} data.innerHeight
     * @param {Number} data.outerHeight
     * @param {Number} data.outerWidth
     * @param {Number} data.screenLeft
     * @param {Number} data.screenTop
     * @param {String} data.windowId
     */
    onWindowPositionChange(data) {
        const
            me   = this,
            item = me.get(data.windowId),
            {chrome, innerRect, outerRect} = me.calculateGeometry(data);

        if (item) {
            item.chrome    = chrome;
            item.innerRect = innerRect;
            item.outerRect = outerRect
        } else {
            me.register({
                chrome,
                id: data.windowId,
                innerRect,
                outerRect
            })
        }
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            className: this.className,
            windows  : this.items.map(win => ({
                id       : win.id,
                appName  : win.appName,
                chrome   : win.chrome,
                innerRect: win.innerRect,
                outerRect: win.outerRect
            }))
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Window));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfbWFuYWdlcl9XaW5kb3dfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDVzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBTztBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQSx1RUFBdUUsMEJBQTBCOztBQUVqRztBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkdBQTJHO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsMkRBQVM7O0FBRXZDLDhCQUE4QiwyREFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7O0FBRUEsK0NBQStDLGdEQUFnRDs7QUFFL0YsdUJBQXVCLG9EQUFvRDtBQUMzRTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHNCQUFzQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1dpbmRvdy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hbmFnZXIgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcblxuLyoqXG4gKiBAc3VtbWFyeSBUaGUgXCJHb2QgVmlld1wiIGZvciB0aGUgbXVsdGktd2luZG93IGFwcGxpY2F0aW9uIHdvcmtzcGFjZS5cbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1hbmFnZXIgbWFpbnRhaW5zIGEgcmVhbC10aW1lIGdlb21ldHJpYyBtYXAgb2YgYWxsIGNvbm5lY3RlZCBicm93c2VyIHdpbmRvd3MgaW4gdGhlIEFwcCBXb3JrZXIuXG4gKiBJdCBpcyB0aGUgY2VudHJhbCBhdXRob3JpdHkgZm9yIHNwYXRpYWwgYXdhcmVuZXNzLCBlbmFibGluZyBmZWF0dXJlcyBsaWtlIHRoZSBcIkluZmluaXRlIENhbnZhc1wiIHdoZXJlXG4gKiBpbnRlcmFjdGlvbnMgKGxpa2UgRHJhZyAmIERyb3ApIGNhbiBzcGFuIGFjcm9zcyBtdWx0aXBsZSBPUy1sZXZlbCB3aW5kb3dzLlxuICpcbiAqIEl0IHJlY2VpdmVzIGhpZ2gtZnJlcXVlbmN5IHBvc2l0aW9uIHVwZGF0ZXMgZnJvbSB0aGUgTWFpbiBUaHJlYWQgKHZpYSBgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb25gKVxuICogYW5kIHByb3ZpZGVzIGludGVyc2VjdGlvbiB0ZXN0aW5nIEFQSXMgdG8gZGV0ZXJtaW5lIHdoaWNoIHdpbmRvdyBpcyB1bmRlciBhIGdpdmVuIHNjcmVlbiBjb29yZGluYXRlLlxuICpcbiAqIEBjbGFzcyBOZW8ubWFuYWdlci5XaW5kb3dcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqIEBzZWUgTmVvLm1haW4uYWRkb24uV2luZG93UG9zaXRpb25cbiAqL1xuY2xhc3MgV2luZG93IGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5XaW5kb3cnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5tYW5hZ2VyLldpbmRvdycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1NhZmFyaVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1NhZmFyaTogL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIub24oe1xuICAgICAgICAgICAgY29ubmVjdCAgIDogbWUub25XaW5kb3dDb25uZWN0LFxuICAgICAgICAgICAgZGlzY29ubmVjdDogbWUub25XaW5kb3dEaXNjb25uZWN0LFxuICAgICAgICAgICAgc2NvcGUgICAgIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aW5kb3dJZCB3aGljaCBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIGdsb2JhbCBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAgICogVGhpcyBpcyB0aGUgY29yZSBpbnRlcnNlY3Rpb24gdGVzdCBmb3IgY3Jvc3Mtd2luZG93IGRyYWcgYW5kIGRyb3Agb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBTY3JlZW4gWCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgU2NyZWVuIFkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gVGhlIHdpbmRvd0lkIG9mIHRoZSB0YXJnZXQgd2luZG93LCBvciBudWxsIGlmIG5vIGludGVyc2VjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRXaW5kb3dBdCh4LCB5KSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5vdXRlclJlY3Q/LmludGVyc2VjdHMoe2JvdHRvbTogeSwgcmlnaHQ6IHgsIHgsIHl9KSk7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlkIDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge09iamVjdH0ge2Nocm9tZSwgaW5uZXJSZWN0LCBvdXRlclJlY3R9XG4gICAgICovXG4gICAgY2FsY3VsYXRlR2VvbWV0cnkoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAge2lubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBtb3pJbm5lclNjcmVlblgsIG1veklubmVyU2NyZWVuWSwgb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGgsIHNjcmVlbkxlZnQsIHNjcmVlblRvcH0gPSBkYXRhLFxuICAgICAgICAgICAgd2lkdGhEaWZmICAgID0gb3V0ZXJXaWR0aCAgLSBpbm5lcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0RGlmZiAgID0gb3V0ZXJIZWlnaHQgLSBpbm5lckhlaWdodCxcbiAgICAgICAgICAgIC8vIEFzc3VtcHRpb246IFNpZGUgYm9yZGVycyBhcmUgc3ltbWV0cmljXG4gICAgICAgICAgICBzaWRlQm9yZGVyICAgPSB3aWR0aERpZmYgLyAyLFxuICAgICAgICAgICAgLy8gQXNzdW1wdGlvbjogQm90dG9tIGJvcmRlciBtYXRjaGVzIHNpZGUgYm9yZGVyIChjb21tb24gaW4gV2luZG93cylcbiAgICAgICAgICAgIGJvdHRvbUJvcmRlciA9IHNpZGVCb3JkZXIsXG4gICAgICAgICAgICAvLyBUaGUgcmVzdCBpcyB0aGUgdG9wIGNocm9tZSAoaGVhZGVyKVxuICAgICAgICAgICAgdG9wQ2hyb21lICAgID0gaGVpZ2h0RGlmZiAtIGJvdHRvbUJvcmRlcjtcblxuICAgICAgICBjb25zdCBjaHJvbWUgPSB7XG4gICAgICAgICAgICBib3R0b206IGJvdHRvbUJvcmRlcixcbiAgICAgICAgICAgIGxlZnQgIDogc2lkZUJvcmRlcixcbiAgICAgICAgICAgIHJpZ2h0IDogc2lkZUJvcmRlcixcbiAgICAgICAgICAgIHRvcCAgIDogdG9wQ2hyb21lXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHZpZXdwb3J0TGVmdCwgdmlld3BvcnRUb3A7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb3pJbm5lclNjcmVlblggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94OiBleHBsaWNpdCB2aWV3cG9ydCBjb29yZGluYXRlc1xuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gbW96SW5uZXJTY3JlZW5YO1xuICAgICAgICAgICAgdmlld3BvcnRUb3AgID0gbW96SW5uZXJTY3JlZW5ZXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1NhZmFyaSkge1xuICAgICAgICAgICAgLy8gU2FmYXJpOiBzY3JlZW5MZWZ0L1RvcCBpcyBGcmFtZSBwb3NpdGlvbi4gQWRkIGNocm9tZSB0byBnZXQgVmlld3BvcnQuXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSBzY3JlZW5MZWZ0ICsgc2lkZUJvcmRlcjtcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wICA9IHNjcmVlblRvcCAgKyB0b3BDaHJvbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZS9FZGdlOiBzY3JlZW5MZWZ0L1RvcCBpcyBWaWV3cG9ydCBwb3NpdGlvbi5cbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IHNjcmVlbkxlZnQ7XG4gICAgICAgICAgICB2aWV3cG9ydFRvcCAgPSBzY3JlZW5Ub3BcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlubmVyUmVjdCA9IG5ldyBSZWN0YW5nbGUodmlld3BvcnRMZWZ0LCB2aWV3cG9ydFRvcCwgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IG91dGVyUmVjdCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgLSBzaWRlQm9yZGVyLFxuICAgICAgICAgICAgdmlld3BvcnRUb3AgIC0gdG9wQ2hyb21lLFxuICAgICAgICAgICAgb3V0ZXJXaWR0aCxcbiAgICAgICAgICAgIG91dGVySGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgbmV3IGJyb3dzZXIgd2luZG93IGNvbm5lY3RzIHRvIHRoZSBTaGFyZWRXb3JrZXIuXG4gICAgICogSW4gU2hhcmVkIFdvcmtlciBtb2RlLCBgTmVvLndvcmtlci5BcHAjb25Db25uZWN0YCBlbnN1cmVzIHRoYXQgYHdpbmRvd0RhdGFgXG4gICAgICogaXMgZmV0Y2hlZCBmcm9tIHRoZSBNYWluIFRocmVhZCBhbmQgaW5jbHVkZWQgaW4gdGhlIHBheWxvYWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhLndpbmRvd0RhdGFdIENvbnRhaW5zIGdlb21ldHJ5IGRhdGEgKHNjcmVlbkxlZnQsIGlubmVySGVpZ2h0LCBldGMuKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLndpbmRvd0lkXG4gICAgICovXG4gICAgb25XaW5kb3dDb25uZWN0KHthcHBOYW1lLCB3aW5kb3dEYXRhLCB3aW5kb3dJZH0pIHtcbiAgICAgICAgbGV0IGNocm9tZSAgICA9IG51bGwsXG4gICAgICAgICAgICBpbm5lclJlY3QgPSBudWxsLFxuICAgICAgICAgICAgb3V0ZXJSZWN0ID0gbnVsbDtcblxuICAgICAgICBpZiAod2luZG93RGF0YSkge1xuICAgICAgICAgICAgKHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSA9IHRoaXMuY2FsY3VsYXRlR2VvbWV0cnkod2luZG93RGF0YSkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnV2luZG93Lm9uV2luZG93Q29ubmVjdCcsIHt3aW5kb3dJZCwgYXBwTmFtZSwgY2hyb21lLCBpbm5lclJlY3QsIG91dGVyUmVjdH0pO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoe2FwcE5hbWUsIGNocm9tZSwgaWQ6IHdpbmRvd0lkLCBpbm5lclJlY3QsIG91dGVyUmVjdH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd0Rpc2Nvbm5lY3Qoe3dpbmRvd0lkfSkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIod2luZG93SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2VvbWV0cmljIHN0YXRlIG9mIGEgd2luZG93IGJhc2VkIG9uIGRhdGEgZnJvbSB0aGUgTWFpbiBUaHJlYWQuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHZpYSBkaXJlY3QgZGVsZWdhdGlvbiBmcm9tIHRoZSBBcHAgV29ya2VyIHRvIG1pbmltaXplIG92ZXJoZWFkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuaW5uZXJIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5vdXRlckhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLm91dGVyV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YS5zY3JlZW5MZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuc2NyZWVuVG9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEud2luZG93SWRcbiAgICAgKi9cbiAgICBvbldpbmRvd1Bvc2l0aW9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLmdldChkYXRhLndpbmRvd0lkKSxcbiAgICAgICAgICAgIHtjaHJvbWUsIGlubmVyUmVjdCwgb3V0ZXJSZWN0fSA9IG1lLmNhbGN1bGF0ZUdlb21ldHJ5KGRhdGEpO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmNocm9tZSAgICA9IGNocm9tZTtcbiAgICAgICAgICAgIGl0ZW0uaW5uZXJSZWN0ID0gaW5uZXJSZWN0O1xuICAgICAgICAgICAgaXRlbS5vdXRlclJlY3QgPSBvdXRlclJlY3RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBjaHJvbWUsXG4gICAgICAgICAgICAgICAgaWQ6IGRhdGEud2luZG93SWQsXG4gICAgICAgICAgICAgICAgaW5uZXJSZWN0LFxuICAgICAgICAgICAgICAgIG91dGVyUmVjdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHdpbmRvd3MgIDogdGhpcy5pdGVtcy5tYXAod2luID0+ICh7XG4gICAgICAgICAgICAgICAgaWQgICAgICAgOiB3aW4uaWQsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgOiB3aW4uYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjaHJvbWUgICA6IHdpbi5jaHJvbWUsXG4gICAgICAgICAgICAgICAgaW5uZXJSZWN0OiB3aW4uaW5uZXJSZWN0LFxuICAgICAgICAgICAgICAgIG91dGVyUmVjdDogd2luLm91dGVyUmVjdFxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFdpbmRvdyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=