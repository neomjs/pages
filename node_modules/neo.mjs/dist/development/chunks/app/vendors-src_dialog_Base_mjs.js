"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_dialog_Base_mjs"],{

/***/ "./src/dialog/Base.mjs"
/*!*****************************!*\
  !*** ./src/dialog/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _container_Panel_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../container/Panel.mjs */ "./src/container/Panel.mjs");
/* harmony import */ var _header_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./header/Toolbar.mjs */ "./src/dialog/header/Toolbar.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");





let DragZone;

/**
 * @class Neo.dialog.Base
 * @extends Neo.container.Panel
 */
class Dialog extends _container_Panel_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Valid values for closeAction
     * @member {String[]} closeActions=['close','hide']
     * @protected
     * @static
     */
    static closeActions = ['close', 'hide']

    static config = {
        /**
         * @member {String} className='Neo.dialog.Base'
         * @protected
         */
        className: 'Neo.dialog.Base',
        /**
         * @member {String} ntype='dialog'
         * @protected
         */
        ntype: 'dialog',
        /**
         * @member {Boolean} animateOnDragEnd=false
         */
        animateOnDragEnd: false,
        /**
         * @member {String|null} animateTargetId_=null
         * @reactive
         */
        animateTargetId_: null,
        /**
         * @member {Boolean} autoInitVnode=true
         */
        autoInitVnode: true,
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {Boolean} autoShow=true
         */
        autoShow: true,
        /**
         * @member {String[]} baseCls=['neo-dialog','neo-panel','neo-container']
         * @protected
         */
        baseCls: ['neo-dialog', 'neo-panel', 'neo-container'],
        /**
         * Either a dom node id, 'document.body' or null
         * @member {String|null} boundaryContainerId='document.body'
         */
        boundaryContainerId: 'document.body',
        /**
         * Define what happens in case you click on the close button
         * close will destroy the instance, hide will keep it for later re-use.
         * Valid values: close, hide
         * @member {String} closeAction='close'
         */
        closeAction: 'close',
        /**
         * @member {Boolean} draggable_=true
         * @reactive
         */
        draggable_: true,
        /**
         * @member {Boolean} dragListenersAdded=false
         * @protected
         */
        dragListenersAdded: false,
        /**
         * @member {Neo.draggable.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * @member {Boolean} floating=true
         */
        floating: true,
        /**
         * @member {Object} headerConfig=null
         */
        headerConfig: null,
        /**
         * @member {Neo.toolbar.Base|null} headerToolbar=null
         */
        headerToolbar: null,
        /**
         * @member {Boolean} isDragging=false
         * @protected
         */
        isDragging: false,
        /**
         * @member {Object} keys={Escape:'onKeyDownEscape'}
         * @reactive
         */
        keys: {
            Escape: 'onKeyDownEscape'
        },
        /**
         * @member {String} maximizeCls='far fa-window-maximize'
         */
        maximizeCls: 'far fa-window-maximize',
        /**
         * @member {Boolean} maximized_=false
         * @reactive
         */
        maximized_: false,
        /**
         * @member {String} minimizeCls='far fa-window-minimize'
         */
        minimizeCls: 'far fa-window-minimize',
        /**
         * @member {Boolean} modal_=false
         * @reactive
         */
        modal_: false,
        /**
         * @member {Boolean} resizable_=true
         * @reactive
         */
        resizable_: true,
        /**
         * @member {Object} resizablePluginConfig=null
         */
        resizablePluginConfig: null,
        /**
         * @member {String|null} title_=null
         * @reactive
         */
        title_: null,
        /**
         * Set to `true` to have tabbing wrap within this Dialog.
         * Should be used with `modal`.
         * @member {Boolean} trapFocus_=false
         * @reactive
         */
        trapFocus_: false
    }

    /**
     * @member {Neo.component.Base|null} animateTarget=null
     */
    get animateTarget() {
        return Neo.getComponent(this.animateTargetId)
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        this.createHeader()
    }

    /**
     * Triggered after the animateTargetId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAnimateTargetId(value, oldValue) {
        this.autoMount  = !value;
        this.autoInitVnode = !value
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        let me        = this,
            resizable = me.getPlugin('resizable');

        if (me.dragZone) {
            me.dragZone.appName = value
        }

        if (resizable) {
            resizable.appName = value
        }

        super.afterSetAppName(value, oldValue)
    }

    /**
     * Triggered after the draggable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDraggable(value, oldValue) {
        let me = this,
            cls;

        if (oldValue !== undefined && me.headerToolbar) {
            cls = me.headerToolbar.cls;
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_0__["default"][value ? 'add' : 'remove'](cls, 'neo-draggable');
            me.headerToolbar.cls = cls
        }

        value && Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("src_draggable_DragProxyContainer_mjs-_ef4c1")]).then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs")).then(module => {
            DragZone = module.default;

            if (!me.dragListenersAdded) {
                const dragListeners = [
                    {'drag:end'  : me.onDragEnd,   scope: me, delegate: '.neo-header-toolbar'},
                    {'drag:start': me.onDragStart, scope: me, delegate: '.neo-header-toolbar'}
                ];

                if (me.dragZoneConfig?.alwaysFireDragMove) {
                    dragListeners.push(
                        {'drag:move': me.onDragMove, scope: me, delegate: '.neo-header-toolbar'}
                    )
                }

                me.domListeners       = [...me.domListeners, ...dragListeners];
                me.dragListenersAdded = true
            }
        })
    }

    /**
     * Triggered after the maximized config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    async afterSetMaximized(value, oldValue) {
        let me        = this,
            firstCall = oldValue === undefined,
            {cls}     = me.vdom;

        !firstCall && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].add(cls, 'animated-hiding-showing');
        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].toggle(cls, 'neo-maximized', value);
        me.update();

        if (!firstCall) {
            await(me.timeout(250));

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].remove(cls, 'animated-hiding-showing');
            me.update()
        }
    }

    /**
     * Triggered after the modal config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetModal(value, oldValue) {
        let me = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].toggle(me.vdom.cls, 'neo-modal', value);
        me.update();

        me.vnodeInitialized && me.syncModalMask()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        // Ensure focus trapping is up-to-date, enabled or disabled.
        oldValue !== undefined && this.syncTrapFocus()
    }

    /**
     * Triggered after the resizable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetResizable(value, oldValue) {
        if (value && !this.getPlugin('resizable')) {
            Promise.all(/*! import() */[__webpack_require__.e("vendors-src_draggable_DragZone_mjs"), __webpack_require__.e("vendors-src_draggable_DragProxyContainer_mjs-src_plugin_Resizable_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../plugin/Resizable.mjs */ "./src/plugin/Resizable.mjs")).then(module => {
                let me        = this,
                    {appName} = me,
                    plugins   = me.plugins || [];

                plugins.push({
                    module       : module.default,
                    appName,
                    delegationCls: 'neo-dialog',
                    ...me.resizablePluginConfig
                });

                me.plugins = plugins
            })
        }
    }

    /**
     * Triggered after the title config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTitle(value, oldValue) {
        let {headerToolbar} = this;

        if (headerToolbar) {
            headerToolbar.title = value
        }
    }

    /**
     * Triggered after the trapFocus config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetTrapFocus(value, oldValue) {
        this.syncTrapFocus()
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        let me        = this,
            resizable = me.getPlugin('resizable');

        if (me.dragZone) {
            me.dragZone.windowId = value
        }

        if (resizable) {
            resizable.windowId = value
        }

        super.afterSetWindowId(value, oldValue)
    }

    /**
     *
     */
    async animateHide() {
        let me                  = this,
            {animateTarget, id} = me,
            rects, windowId;

        // Assuming that we want to show the dialog inside the same browser window as the animation target
        me.windowId = windowId = animateTarget.windowId;
        me.appName  = animateTarget.appName;

        rects = await me.getDomRect([id, me.animateTargetId])

        await Neo.applyDeltas(windowId, {
            id,
            style: {
                height   : `${rects[0].height}px`,
                left     : `${rects[0].left  }px`,
                top      : `${rects[0].top   }px`,
                transform: 'none',
                width    : `${rects[0].width }px`
            }
        });

        await me.timeout(30);

        await Neo.applyDeltas(windowId, {
            id,
            cls: {
                add: ['animated-hiding-showing']
            },
            style: {
                height: `${rects[1].height}px`,
                left  : `${rects[1].left  }px`,
                top   : `${rects[1].top   }px`,
                width : `${rects[1].width }px`
            }
        });

        await me.timeout(250);

        me.closeOrHide(false);

        if (me.closeAction === 'hide') {
            await Neo.applyDeltas(windowId, {id, action: 'removeNode'})
        }
    }

    /**
     *
     */
    async animateShow() {
        let me                         = this,
            {animateTarget, id, style} = me,
            appName, rect;

        // Assuming that we want to show the dialog inside the same browser window as the animation target
        me.windowId = animateTarget.windowId;
        me.appName  = appName = animateTarget.appName;

        rect = await me.getDomRect(me.animateTargetId);

        if (style.left || style.top) {
            let tempStyle = {...style};

            // Ensure that the initial mounting happens outside the visible area
            delete style.left;
            delete style.top;

            me.style = style;

            // Silent update & ensure that a given starting position won't get lost
            me._style = style = tempStyle
        }

        // rendered outside the visible area
        await me.initVnode(true);

        let [dialogRect, bodyRect] = await me.waitForDomRect({id: [me.id, 'document.body']});

        // Move to cover the animation target
        await Neo.applyDeltas(me.windowId, {
            id,
            style: {
                height: `${rect.height}px`,
                left  : `${rect.left  }px`,
                top   : `${rect.top   }px`,
                width : `${rect.width }px`
            }
        });

        // Wait for the element to achieve its initial rectangle
        await me.timeout(50);

        // Expand to final state
        await Neo.applyDeltas(me.windowId, {
            id,
            cls: {
                add: ['animated-hiding-showing']
            },
            style: {
                height: style?.height || `${dialogRect.height}px`,
                left  : style?.left   || `${Math.round(bodyRect.width  / 2 - dialogRect.width  / 2)}px`,
                top   : style?.top    || `${Math.round(bodyRect.height / 2 - dialogRect.height / 2)}px`,
                width : style?.width  || `${dialogRect.width}px`
            }
        });

        await me.timeout(200);

        // Remove the animation class
        await Neo.applyDeltas(me.windowId, {id, cls: {remove: ['animated-hiding-showing']}});

        me.show(false)
    }

    /**
     * Triggered before the closeAction config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetCloseAction(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'closeAction')
    }

    /**
     * @param {Boolean} animate=!!this.animateTargetId
     */
    close(animate=!!this.animateTargetId) {
        let me = this;

        me.revertFocus();

        if (animate) {
            me.animateHide()
        } else {
            me.fire('close');
            me.destroy(true)
        }
    }

    /**
     * @param {Boolean} animate=!!this.animateTargetId
     */
    async closeOrHide(animate=!!this.animateTargetId) {
        let me = this;

        me[me.closeAction](animate);
        await me.timeout(30);
        me.syncModalMask(me.id)
    }

    /**
     * Action when clicking the X button inside the header toolbar.
     * @param {Object} data
     * @protected
     */
    closeOrHideAction(data) {
        this.closeOrHide()
    }

    /**
     *
     */
    createHeader() {
        let me                  = this,
            {appName, windowId} = me,
            cls                 = ['neo-header-toolbar', 'neo-toolbar'],
            headers             = me.headers || [];

        me.draggable && cls.push('neo-draggable');

        me.headerToolbar = Neo.create({
            module   : _header_Toolbar_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName,
            cls,
            dock     : 'top',
            flex     : 'none',
            id       : me.getHeaderToolbarId(),
            listeners: {headerAction: me.executeHeaderAction, scope: me},
            title    : me.title,
            windowId,
            ...me.headerConfig
        });

        headers.unshift(me.headerToolbar);

        me.headers = headers
    }

    /**
     * {Object} data
     */
    executeHeaderAction(data) {
        let me = this,

        map = {
            close   : me.closeOrHideAction,
            maximize: me.maximize
        };

        map[data.action]?.call(me, data);

        me.fire('headerAction', {
            dialog: me,
            ...data
        })
    }

    /**
     * Returns the id of the animation node
     * @returns {String}
     */
    getAnimateTargetId() {
        return this.id + '-animate'
    }

    /**
     * Returns the id of the header toolbar
     * @returns {String}
     */
    getHeaderToolbarId() {
        return this.id + '-header-toolbar'
    }

    /**
     * @returns {Object} vdom
     */
    getProxyVdom() {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(this.vdom)
    }

    /**
     * @param {Boolean} animate=!!this.animateTargetId
     */
    async hide(animate=!!this.animateTargetId) {
        let me = this;

        if (animate) {
            me.animateHide()
        } else {
            me.unmount();
            me.fire('hide')
        }

        await me.timeout(30);

        me.syncModalMask()
    }

    /**
     *
     */
    init() {
        super.init();

        let me = this;

        if (me.animateTargetId) {
            me.autoShow && me.show()
        } else {
            me.timeout(100).then(() => {
                me.syncModalMask()
            })
        }
    }

    /**
     * @param {Object} [data]
     */
    maximize(data) {
        let me = this;

        data.component.iconCls = me.maximized ? me.maximizeCls : me.minimizeCls;

        me.maximized = !me.maximized
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        me.headerToolbar = me.down({
            id: me.getHeaderToolbarId()
        })
    }

    /**
     * @param data
     */
    onDragEnd(data) {
        let me = this,
            initialTransitionProperty, style;

        if (!me.maximized) {
            me.getDomRect(me.dragZone.dragProxy.id).then(rect => {
                style = me.style;

                Object.assign(style, {
                    height   : `${rect.height}px`,
                    left     : `${rect.left}px`,
                    opacity  : 1,
                    top      : `${rect.top}px`,
                    transform: 'none',
                    width    : `${rect.width}px`
                });

                if (!me.animateOnDragEnd) {
                    initialTransitionProperty = style.transitionProperty || null;

                    style.transitionProperty = 'none';

                    me.timeout(50).then(() => {
                        style = me.style;

                        style.transitionProperty = initialTransitionProperty;

                        me.style = style
                    })
                }

                me.style = style;

                me.dragZone.dragEnd(data);

                // we need a reset, otherwise we do not get a change event for the next onDragStart() call
                me.dragZone.boundaryContainerId = null;
                me.isDragging                   = false;

                me.focus(me.id, true)
            })
        }
    }

    /**
     * This method will only get triggered in case alwaysFireDragMove is included inside the dragZoneConfig
     * @param data
     */
    onDragMove(data) {
        this.dragZone.dragMove(data)
    }

    /**
     * @param data
     */
    onDragStart(data) {
        let me                      = this,
            {appName, id, windowId} = me,
            style                   = me.style || {};

        if (!me.maximized) {
            me.isDragging = true;

            me.getPlugin('resizable')?.removeAllNodes();

            if (!me.dragZone) {
                me.dragZone = Neo.create({
                    module             : DragZone,
                    appName,
                    bodyCursorStyle    : 'move !important',
                    boundaryContainerId: me.boundaryContainerId,
                    dragElement        : me.vdom,
                    dragProxyConfig    : {vdom: me.getProxyVdom()},
                    owner              : me,
                    useProxyWrapper    : false,
                    windowId,
                    ...me.dragZoneConfig
                });

                me.fire('dragZoneCreated', {dragZone: me.dragZone, id})
            } else {
                me.dragZone.boundaryContainerId = me.boundaryContainerId
            }

            me.dragZone.dragStart(data);

            style.opacity = 0.7;

            me.style = style
        }
    }

    /**
     *
     */
    onKeyDownEscape() {
        this.hidden = true
    }

    /**
     * @param {Boolean} [mount] Mount the DOM after the vnode got created
     */
    async render(mount) {
        let me             = this,
            {wrapperStyle} = me;

        // If there is no animation target, we need to ensure that the initial offscreen positioning
        // from .neo-floating gets reverted
        if (!me.animateTargetId) {
            if (!wrapperStyle.left) {
                wrapperStyle.left = 'initial'
            }

            if (!wrapperStyle.top) {
                wrapperStyle.top = 'initial'
            }

            me.wrapperStyle = wrapperStyle
        }

        await super.render(mount)
    }

    /**
     * @param {Boolean} animate=!!this.animateTargetId
     */
    show(animate=!!this.animateTargetId) {
        let me = this;

        if (animate) {
            me.animateShow()
        } else {
            if (!me.mounted) {
                me.initVnode(true)
            }

            me.fire('show')
        }

        me.syncModalMask()
    }

    /**
     * @param {String} id=this.id
     */
    syncModalMask(id=this.id) {
        let {modal, windowId} = this;

        // This should sync the visibility and position of the modal mask element.
        Neo.main.DomAccess.syncModalMask({id, modal, windowId})
    }

    /**
     *
     */
    syncTrapFocus() {
        let me             = this,
            {id, windowId} = me;

        if (me.mounted) {
            Neo.main.DomAccess.trapFocus({id, trap: me.trapFocus, windowId})
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Dialog));


/***/ },

/***/ "./src/dialog/header/Toolbar.mjs"
/*!***************************************!*\
  !*** ./src/dialog/header/Toolbar.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");


/**
 * @class Neo.dialog.header.Toolbar
 * @extends Neo.toolbar.Base
 */
class Toolbar extends _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.dialog.header.Toolbar'
         * @protected
         */
        className: 'Neo.dialog.header.Toolbar',
        /**
         * @member {Object} actionMap
         */
        actionMap: {
            close   : () => ({action: 'close',    iconCls: 'far fa-window-close'}),
            maximize: () => ({action: 'maximize', iconCls: 'far fa-window-maximize'})
        },
        /**
         * You can define the action order and directly add custom actions.
         * @example
         * {
         *     actions: [
         *         'close',
         *         'maximize',
         *         {action: 'help', iconCls: 'far fa-circle-question'}
         *     ]
         * }
         *
         * You can also extend the actionMap if needed.
         * @member {Object[]|String[]|null} actions=['maximize','close']
         */
        actions: ['maximize', 'close'],
        /**
         * @member {String|null} title=null
         */
        title_: null
    }

    /**
     * Triggered after the title config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTitle(value, oldValue) {
        this.down({flag: 'title-label'})?.set({
            hidden: !value,
            text  : value
        })
    }

    /**
     *
     */
    createItems() {
        let me      = this,
            handler = me.fireAction.bind(me),
            items   = me.items || [],
            {title} = me;

        items.push({
            ntype : 'label',
            cls   : ['neo-panel-header-text', 'neo-label'],
            flag  : 'title-label',
            hidden: !title,
            text  : title
        });

        if (me.actions) {
            items.push('->');

            me.actions.forEach(action => {
                if (Neo.typeOf(action) !== 'Object') {
                    action = me.actionMap[action]()
                }

                items.push({handler, ...action})
            })
        }

        me.items = items;

        super.createItems()
    }

    /**
     * @param {Object} data
     */
    fireAction(data) {
        let {component} = data;

        this.fire('headerAction', {
            action: component.action,
            component,
            scope : this
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kaWFsb2dfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUM7QUFDSztBQUNGO0FBQ0o7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFLO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxNQUFNO0FBQ2xD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QTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLDhCQUE4QixtREFBbUQ7QUFDakYsOEJBQThCLHNEQUFzRDtBQUNwRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUJBQW1CO0FBQy9DLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLFdBQVc7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RpYWxvZy9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RpYWxvZy9oZWFkZXIvVG9vbGJhci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBQYW5lbCAgICBmcm9tICcuLi9jb250YWluZXIvUGFuZWwubWpzJztcbmltcG9ydCBUb29sYmFyICBmcm9tICcuL2hlYWRlci9Ub29sYmFyLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbmxldCBEcmFnWm9uZTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRpYWxvZy5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLlBhbmVsXG4gKi9cbmNsYXNzIERpYWxvZyBleHRlbmRzIFBhbmVsIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCB2YWx1ZXMgZm9yIGNsb3NlQWN0aW9uXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGNsb3NlQWN0aW9ucz1bJ2Nsb3NlJywnaGlkZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2xvc2VBY3Rpb25zID0gWydjbG9zZScsICdoaWRlJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRpYWxvZy5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGlhbG9nLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZGlhbG9nJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2RpYWxvZycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhbmltYXRlT25EcmFnRW5kPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlT25EcmFnRW5kOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhbmltYXRlVGFyZ2V0SWRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlVGFyZ2V0SWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0luaXRWbm9kZT10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvSW5pdFZub2RlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9TaG93PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9TaG93OiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tZGlhbG9nJywnbmVvLXBhbmVsJywnbmVvLWNvbnRhaW5lciddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWRpYWxvZycsICduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogRWl0aGVyIGEgZG9tIG5vZGUgaWQsICdkb2N1bWVudC5ib2R5JyBvciBudWxsXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBib3VuZGFyeUNvbnRhaW5lcklkPSdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgKi9cbiAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lIHdoYXQgaGFwcGVucyBpbiBjYXNlIHlvdSBjbGljayBvbiB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgICAqIGNsb3NlIHdpbGwgZGVzdHJveSB0aGUgaW5zdGFuY2UsIGhpZGUgd2lsbCBrZWVwIGl0IGZvciBsYXRlciByZS11c2UuXG4gICAgICAgICAqIFZhbGlkIHZhbHVlczogY2xvc2UsIGhpZGVcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbG9zZUFjdGlvbj0nY2xvc2UnXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZUFjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyYWdnYWJsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnYWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcmFnTGlzdGVuZXJzQWRkZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xpc3RlbmVyc0FkZGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUuRHJhZ1pvbmV8bnVsbH0gZHJhZ1pvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRyYWdab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdab25lQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZmxvYXRpbmc9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZmxvYXRpbmc6IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGhlYWRlckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8udG9vbGJhci5CYXNlfG51bGx9IGhlYWRlclRvb2xiYXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyVG9vbGJhcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzRHJhZ2dpbmc9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGtleXM9e0VzY2FwZTonb25LZXlEb3duRXNjYXBlJ31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzOiB7XG4gICAgICAgICAgICBFc2NhcGU6ICdvbktleURvd25Fc2NhcGUnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG1heGltaXplQ2xzPSdmYXIgZmEtd2luZG93LW1heGltaXplJ1xuICAgICAgICAgKi9cbiAgICAgICAgbWF4aW1pemVDbHM6ICdmYXIgZmEtd2luZG93LW1heGltaXplJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1heGltaXplZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtYXhpbWl6ZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbWluaW1pemVDbHM9J2ZhciBmYS13aW5kb3ctbWluaW1pemUnXG4gICAgICAgICAqL1xuICAgICAgICBtaW5pbWl6ZUNsczogJ2ZhciBmYS13aW5kb3ctbWluaW1pemUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9kYWxfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW9kYWxfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlc2l6YWJsZV89dHJ1ZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6YWJsZV86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlc2l6YWJsZVBsdWdpbkNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemFibGVQbHVnaW5Db25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdGl0bGVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIHRvIGhhdmUgdGFiYmluZyB3cmFwIHdpdGhpbiB0aGlzIERpYWxvZy5cbiAgICAgICAgICogU2hvdWxkIGJlIHVzZWQgd2l0aCBgbW9kYWxgLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB0cmFwRm9jdXNfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhcEZvY3VzXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gYW5pbWF0ZVRhcmdldD1udWxsXG4gICAgICovXG4gICAgZ2V0IGFuaW1hdGVUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuYW5pbWF0ZVRhcmdldElkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICB0aGlzLmNyZWF0ZUhlYWRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhbmltYXRlVGFyZ2V0SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFuaW1hdGVUYXJnZXRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5hdXRvTW91bnQgID0gIXZhbHVlO1xuICAgICAgICB0aGlzLmF1dG9Jbml0Vm5vZGUgPSAhdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVzaXphYmxlID0gbWUuZ2V0UGx1Z2luKCdyZXNpemFibGUnKTtcblxuICAgICAgICBpZiAobWUuZHJhZ1pvbmUpIHtcbiAgICAgICAgICAgIG1lLmRyYWdab25lLmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc2l6YWJsZSkge1xuICAgICAgICAgICAgcmVzaXphYmxlLmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyYWdnYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGNscztcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtZS5oZWFkZXJUb29sYmFyKSB7XG4gICAgICAgICAgICBjbHMgPSBtZS5oZWFkZXJUb29sYmFyLmNscztcbiAgICAgICAgICAgIE5lb0FycmF5W3ZhbHVlID8gJ2FkZCcgOiAncmVtb3ZlJ10oY2xzLCAnbmVvLWRyYWdnYWJsZScpO1xuICAgICAgICAgICAgbWUuaGVhZGVyVG9vbGJhci5jbHMgPSBjbHNcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICYmIGltcG9ydCgnLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgIERyYWdab25lID0gbW9kdWxlLmRlZmF1bHQ7XG5cbiAgICAgICAgICAgIGlmICghbWUuZHJhZ0xpc3RlbmVyc0FkZGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhZ0xpc3RlbmVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgeydkcmFnOmVuZCcgIDogbWUub25EcmFnRW5kLCAgIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLWhlYWRlci10b29sYmFyJ30sXG4gICAgICAgICAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uRHJhZ1N0YXJ0LCBzY29wZTogbWUsIGRlbGVnYXRlOiAnLm5lby1oZWFkZXItdG9vbGJhcid9XG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5kcmFnWm9uZUNvbmZpZz8uYWx3YXlzRmlyZURyYWdNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHsnZHJhZzptb3ZlJzogbWUub25EcmFnTW92ZSwgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8taGVhZGVyLXRvb2xiYXInfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuZG9tTGlzdGVuZXJzICAgICAgID0gWy4uLm1lLmRvbUxpc3RlbmVycywgLi4uZHJhZ0xpc3RlbmVyc107XG4gICAgICAgICAgICAgICAgbWUuZHJhZ0xpc3RlbmVyc0FkZGVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWF4aW1pemVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0TWF4aW1pemVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGZpcnN0Q2FsbCA9IG9sZFZhbHVlID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgICB7Y2xzfSAgICAgPSBtZS52ZG9tO1xuXG4gICAgICAgICFmaXJzdENhbGwgJiYgTmVvQXJyYXkuYWRkKGNscywgJ2FuaW1hdGVkLWhpZGluZy1zaG93aW5nJyk7XG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8tbWF4aW1pemVkJywgdmFsdWUpO1xuICAgICAgICBtZS51cGRhdGUoKTtcblxuICAgICAgICBpZiAoIWZpcnN0Q2FsbCkge1xuICAgICAgICAgICAgYXdhaXQobWUudGltZW91dCgyNTApKTtcblxuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ2FuaW1hdGVkLWhpZGluZy1zaG93aW5nJyk7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb2RhbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vZGFsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShtZS52ZG9tLmNscywgJ25lby1tb2RhbCcsIHZhbHVlKTtcbiAgICAgICAgbWUudXBkYXRlKCk7XG5cbiAgICAgICAgbWUudm5vZGVJbml0aWFsaXplZCAmJiBtZS5zeW5jTW9kYWxNYXNrKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICAvLyBFbnN1cmUgZm9jdXMgdHJhcHBpbmcgaXMgdXAtdG8tZGF0ZSwgZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnN5bmNUcmFwRm9jdXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVzaXphYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UmVzaXphYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuZ2V0UGx1Z2luKCdyZXNpemFibGUnKSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9wbHVnaW4vUmVzaXphYmxlLm1qcycpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAge2FwcE5hbWV9ID0gbWUsXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbnMgICA9IG1lLnBsdWdpbnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGlvbkNsczogJ25lby1kaWFsb2cnLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5yZXNpemFibGVQbHVnaW5Db25maWdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLnBsdWdpbnMgPSBwbHVnaW5zXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aXRsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGl0bGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCB7aGVhZGVyVG9vbGJhcn0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChoZWFkZXJUb29sYmFyKSB7XG4gICAgICAgICAgICBoZWFkZXJUb29sYmFyLnRpdGxlID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHJhcEZvY3VzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhcEZvY3VzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnN5bmNUcmFwRm9jdXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlc2l6YWJsZSA9IG1lLmdldFBsdWdpbigncmVzaXphYmxlJyk7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdab25lKSB7XG4gICAgICAgICAgICBtZS5kcmFnWm9uZS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzaXphYmxlKSB7XG4gICAgICAgICAgICByZXNpemFibGUud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBhbmltYXRlSGlkZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FuaW1hdGVUYXJnZXQsIGlkfSA9IG1lLFxuICAgICAgICAgICAgcmVjdHMsIHdpbmRvd0lkO1xuXG4gICAgICAgIC8vIEFzc3VtaW5nIHRoYXQgd2Ugd2FudCB0byBzaG93IHRoZSBkaWFsb2cgaW5zaWRlIHRoZSBzYW1lIGJyb3dzZXIgd2luZG93IGFzIHRoZSBhbmltYXRpb24gdGFyZ2V0XG4gICAgICAgIG1lLndpbmRvd0lkID0gd2luZG93SWQgPSBhbmltYXRlVGFyZ2V0LndpbmRvd0lkO1xuICAgICAgICBtZS5hcHBOYW1lICA9IGFuaW1hdGVUYXJnZXQuYXBwTmFtZTtcblxuICAgICAgICByZWN0cyA9IGF3YWl0IG1lLmdldERvbVJlY3QoW2lkLCBtZS5hbmltYXRlVGFyZ2V0SWRdKVxuXG4gICAgICAgIGF3YWl0IE5lby5hcHBseURlbHRhcyh3aW5kb3dJZCwge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGhlaWdodCAgIDogYCR7cmVjdHNbMF0uaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IGAke3JlY3RzWzBdLmxlZnQgIH1weGAsXG4gICAgICAgICAgICAgICAgdG9wICAgICAgOiBgJHtyZWN0c1swXS50b3AgICB9cHhgLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgIDogYCR7cmVjdHNbMF0ud2lkdGggfXB4YFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTtcblxuICAgICAgICBhd2FpdCBOZW8uYXBwbHlEZWx0YXMod2luZG93SWQsIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgYWRkOiBbJ2FuaW1hdGVkLWhpZGluZy1zaG93aW5nJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGhlaWdodDogYCR7cmVjdHNbMV0uaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICBsZWZ0ICA6IGAke3JlY3RzWzFdLmxlZnQgIH1weGAsXG4gICAgICAgICAgICAgICAgdG9wICAgOiBgJHtyZWN0c1sxXS50b3AgICB9cHhgLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7cmVjdHNbMV0ud2lkdGggfXB4YFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDI1MCk7XG5cbiAgICAgICAgbWUuY2xvc2VPckhpZGUoZmFsc2UpO1xuXG4gICAgICAgIGlmIChtZS5jbG9zZUFjdGlvbiA9PT0gJ2hpZGUnKSB7XG4gICAgICAgICAgICBhd2FpdCBOZW8uYXBwbHlEZWx0YXMod2luZG93SWQsIHtpZCwgYWN0aW9uOiAncmVtb3ZlTm9kZSd9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBhbmltYXRlU2hvdygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthbmltYXRlVGFyZ2V0LCBpZCwgc3R5bGV9ID0gbWUsXG4gICAgICAgICAgICBhcHBOYW1lLCByZWN0O1xuXG4gICAgICAgIC8vIEFzc3VtaW5nIHRoYXQgd2Ugd2FudCB0byBzaG93IHRoZSBkaWFsb2cgaW5zaWRlIHRoZSBzYW1lIGJyb3dzZXIgd2luZG93IGFzIHRoZSBhbmltYXRpb24gdGFyZ2V0XG4gICAgICAgIG1lLndpbmRvd0lkID0gYW5pbWF0ZVRhcmdldC53aW5kb3dJZDtcbiAgICAgICAgbWUuYXBwTmFtZSAgPSBhcHBOYW1lID0gYW5pbWF0ZVRhcmdldC5hcHBOYW1lO1xuXG4gICAgICAgIHJlY3QgPSBhd2FpdCBtZS5nZXREb21SZWN0KG1lLmFuaW1hdGVUYXJnZXRJZCk7XG5cbiAgICAgICAgaWYgKHN0eWxlLmxlZnQgfHwgc3R5bGUudG9wKSB7XG4gICAgICAgICAgICBsZXQgdGVtcFN0eWxlID0gey4uLnN0eWxlfTtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGluaXRpYWwgbW91bnRpbmcgaGFwcGVucyBvdXRzaWRlIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZS5sZWZ0O1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlLnRvcDtcblxuICAgICAgICAgICAgbWUuc3R5bGUgPSBzdHlsZTtcblxuICAgICAgICAgICAgLy8gU2lsZW50IHVwZGF0ZSAmIGVuc3VyZSB0aGF0IGEgZ2l2ZW4gc3RhcnRpbmcgcG9zaXRpb24gd29uJ3QgZ2V0IGxvc3RcbiAgICAgICAgICAgIG1lLl9zdHlsZSA9IHN0eWxlID0gdGVtcFN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW5kZXJlZCBvdXRzaWRlIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgYXdhaXQgbWUuaW5pdFZub2RlKHRydWUpO1xuXG4gICAgICAgIGxldCBbZGlhbG9nUmVjdCwgYm9keVJlY3RdID0gYXdhaXQgbWUud2FpdEZvckRvbVJlY3Qoe2lkOiBbbWUuaWQsICdkb2N1bWVudC5ib2R5J119KTtcblxuICAgICAgICAvLyBNb3ZlIHRvIGNvdmVyIHRoZSBhbmltYXRpb24gdGFyZ2V0XG4gICAgICAgIGF3YWl0IE5lby5hcHBseURlbHRhcyhtZS53aW5kb3dJZCwge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGhlaWdodDogYCR7cmVjdC5oZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgIGxlZnQgIDogYCR7cmVjdC5sZWZ0ICB9cHhgLFxuICAgICAgICAgICAgICAgIHRvcCAgIDogYCR7cmVjdC50b3AgICB9cHhgLFxuICAgICAgICAgICAgICAgIHdpZHRoIDogYCR7cmVjdC53aWR0aCB9cHhgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBlbGVtZW50IHRvIGFjaGlldmUgaXRzIGluaXRpYWwgcmVjdGFuZ2xlXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoNTApO1xuXG4gICAgICAgIC8vIEV4cGFuZCB0byBmaW5hbCBzdGF0ZVxuICAgICAgICBhd2FpdCBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgYWRkOiBbJ2FuaW1hdGVkLWhpZGluZy1zaG93aW5nJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGhlaWdodDogc3R5bGU/LmhlaWdodCB8fCBgJHtkaWFsb2dSZWN0LmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiBzdHlsZT8ubGVmdCAgIHx8IGAke01hdGgucm91bmQoYm9keVJlY3Qud2lkdGggIC8gMiAtIGRpYWxvZ1JlY3Qud2lkdGggIC8gMil9cHhgLFxuICAgICAgICAgICAgICAgIHRvcCAgIDogc3R5bGU/LnRvcCAgICB8fCBgJHtNYXRoLnJvdW5kKGJvZHlSZWN0LmhlaWdodCAvIDIgLSBkaWFsb2dSZWN0LmhlaWdodCAvIDIpfXB4YCxcbiAgICAgICAgICAgICAgICB3aWR0aCA6IHN0eWxlPy53aWR0aCAgfHwgYCR7ZGlhbG9nUmVjdC53aWR0aH1weGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMDApO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYW5pbWF0aW9uIGNsYXNzXG4gICAgICAgIGF3YWl0IE5lby5hcHBseURlbHRhcyhtZS53aW5kb3dJZCwge2lkLCBjbHM6IHtyZW1vdmU6IFsnYW5pbWF0ZWQtaGlkaW5nLXNob3dpbmcnXX19KTtcblxuICAgICAgICBtZS5zaG93KGZhbHNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGNsb3NlQWN0aW9uIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2xvc2VBY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdjbG9zZUFjdGlvbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWRcbiAgICAgKi9cbiAgICBjbG9zZShhbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5yZXZlcnRGb2N1cygpO1xuXG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICBtZS5hbmltYXRlSGlkZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5maXJlKCdjbG9zZScpO1xuICAgICAgICAgICAgbWUuZGVzdHJveSh0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZU9ySGlkZShhbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZVttZS5jbG9zZUFjdGlvbl0oYW5pbWF0ZSk7XG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApO1xuICAgICAgICBtZS5zeW5jTW9kYWxNYXNrKG1lLmlkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGlvbiB3aGVuIGNsaWNraW5nIHRoZSBYIGJ1dHRvbiBpbnNpZGUgdGhlIGhlYWRlciB0b29sYmFyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNsb3NlT3JIaWRlQWN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jbG9zZU9ySGlkZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVIZWFkZXIoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHBOYW1lLCB3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIGNscyAgICAgICAgICAgICAgICAgPSBbJ25lby1oZWFkZXItdG9vbGJhcicsICduZW8tdG9vbGJhciddLFxuICAgICAgICAgICAgaGVhZGVycyAgICAgICAgICAgICA9IG1lLmhlYWRlcnMgfHwgW107XG5cbiAgICAgICAgbWUuZHJhZ2dhYmxlICYmIGNscy5wdXNoKCduZW8tZHJhZ2dhYmxlJyk7XG5cbiAgICAgICAgbWUuaGVhZGVyVG9vbGJhciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBUb29sYmFyLFxuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgIGRvY2sgICAgIDogJ3RvcCcsXG4gICAgICAgICAgICBmbGV4ICAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGlkICAgICAgIDogbWUuZ2V0SGVhZGVyVG9vbGJhcklkKCksXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtoZWFkZXJBY3Rpb246IG1lLmV4ZWN1dGVIZWFkZXJBY3Rpb24sIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICB0aXRsZSAgICA6IG1lLnRpdGxlLFxuICAgICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgICAuLi5tZS5oZWFkZXJDb25maWdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaGVhZGVycy51bnNoaWZ0KG1lLmhlYWRlclRvb2xiYXIpO1xuXG4gICAgICAgIG1lLmhlYWRlcnMgPSBoZWFkZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICoge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGV4ZWN1dGVIZWFkZXJBY3Rpb24oZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuXG4gICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgIGNsb3NlICAgOiBtZS5jbG9zZU9ySGlkZUFjdGlvbixcbiAgICAgICAgICAgIG1heGltaXplOiBtZS5tYXhpbWl6ZVxuICAgICAgICB9O1xuXG4gICAgICAgIG1hcFtkYXRhLmFjdGlvbl0/LmNhbGwobWUsIGRhdGEpO1xuXG4gICAgICAgIG1lLmZpcmUoJ2hlYWRlckFjdGlvbicsIHtcbiAgICAgICAgICAgIGRpYWxvZzogbWUsXG4gICAgICAgICAgICAuLi5kYXRhXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGFuaW1hdGlvbiBub2RlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBbmltYXRlVGFyZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICsgJy1hbmltYXRlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBoZWFkZXIgdG9vbGJhclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SGVhZGVyVG9vbGJhcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCArICctaGVhZGVyLXRvb2xiYXInXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH0gdmRvbVxuICAgICAqL1xuICAgIGdldFByb3h5VmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmNsb25lKHRoaXMudmRvbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFuaW1hdGU9ISF0aGlzLmFuaW1hdGVUYXJnZXRJZFxuICAgICAqL1xuICAgIGFzeW5jIGhpZGUoYW5pbWF0ZT0hIXRoaXMuYW5pbWF0ZVRhcmdldElkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgIG1lLmFuaW1hdGVIaWRlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnVubW91bnQoKTtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2hpZGUnKVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgzMCk7XG5cbiAgICAgICAgbWUuc3luY01vZGFsTWFzaygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBzdXBlci5pbml0KCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuYW5pbWF0ZVRhcmdldElkKSB7XG4gICAgICAgICAgICBtZS5hdXRvU2hvdyAmJiBtZS5zaG93KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLnRpbWVvdXQoMTAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5zeW5jTW9kYWxNYXNrKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICovXG4gICAgbWF4aW1pemUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGRhdGEuY29tcG9uZW50Lmljb25DbHMgPSBtZS5tYXhpbWl6ZWQgPyBtZS5tYXhpbWl6ZUNscyA6IG1lLm1pbmltaXplQ2xzO1xuXG4gICAgICAgIG1lLm1heGltaXplZCA9ICFtZS5tYXhpbWl6ZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmhlYWRlclRvb2xiYXIgPSBtZS5kb3duKHtcbiAgICAgICAgICAgIGlkOiBtZS5nZXRIZWFkZXJUb29sYmFySWQoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGluaXRpYWxUcmFuc2l0aW9uUHJvcGVydHksIHN0eWxlO1xuXG4gICAgICAgIGlmICghbWUubWF4aW1pemVkKSB7XG4gICAgICAgICAgICBtZS5nZXREb21SZWN0KG1lLmRyYWdab25lLmRyYWdQcm94eS5pZCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IG1lLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgICA6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBgJHtyZWN0LmxlZnR9cHhgLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHRvcCAgICAgIDogYCR7cmVjdC50b3B9cHhgLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggICAgOiBgJHtyZWN0LndpZHRofXB4YFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5hbmltYXRlT25EcmFnRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxUcmFuc2l0aW9uUHJvcGVydHkgPSBzdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgfHwgbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IG1lLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBpbml0aWFsVHJhbnNpdGlvblByb3BlcnR5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zdHlsZSA9IHN0eWxlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuc3R5bGUgPSBzdHlsZTtcblxuICAgICAgICAgICAgICAgIG1lLmRyYWdab25lLmRyYWdFbmQoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGEgcmVzZXQsIG90aGVyd2lzZSB3ZSBkbyBub3QgZ2V0IGEgY2hhbmdlIGV2ZW50IGZvciB0aGUgbmV4dCBvbkRyYWdTdGFydCgpIGNhbGxcbiAgICAgICAgICAgICAgICBtZS5kcmFnWm9uZS5ib3VuZGFyeUNvbnRhaW5lcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBtZS5pc0RyYWdnaW5nICAgICAgICAgICAgICAgICAgID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBtZS5mb2N1cyhtZS5pZCwgdHJ1ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG9ubHkgZ2V0IHRyaWdnZXJlZCBpbiBjYXNlIGFsd2F5c0ZpcmVEcmFnTW92ZSBpcyBpbmNsdWRlZCBpbnNpZGUgdGhlIGRyYWdab25lQ29uZmlnXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kcmFnWm9uZS5kcmFnTW92ZShkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIHN0eWxlICAgICAgICAgICAgICAgICAgID0gbWUuc3R5bGUgfHwge307XG5cbiAgICAgICAgaWYgKCFtZS5tYXhpbWl6ZWQpIHtcbiAgICAgICAgICAgIG1lLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBtZS5nZXRQbHVnaW4oJ3Jlc2l6YWJsZScpPy5yZW1vdmVBbGxOb2RlcygpO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmRyYWdab25lKSB7XG4gICAgICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogRHJhZ1pvbmUsXG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGJvZHlDdXJzb3JTdHlsZSAgICA6ICdtb3ZlICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBtZS5ib3VuZGFyeUNvbnRhaW5lcklkLFxuICAgICAgICAgICAgICAgICAgICBkcmFnRWxlbWVudCAgICAgICAgOiBtZS52ZG9tLFxuICAgICAgICAgICAgICAgICAgICBkcmFnUHJveHlDb25maWcgICAgOiB7dmRvbTogbWUuZ2V0UHJveHlWZG9tKCl9LFxuICAgICAgICAgICAgICAgICAgICBvd25lciAgICAgICAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlUHJveHlXcmFwcGVyICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5kcmFnWm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnZHJhZ1pvbmVDcmVhdGVkJywge2RyYWdab25lOiBtZS5kcmFnWm9uZSwgaWR9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5kcmFnWm9uZS5ib3VuZGFyeUNvbnRhaW5lcklkID0gbWUuYm91bmRhcnlDb250YWluZXJJZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5kcmFnWm9uZS5kcmFnU3RhcnQoZGF0YSk7XG5cbiAgICAgICAgICAgIHN0eWxlLm9wYWNpdHkgPSAwLjc7XG5cbiAgICAgICAgICAgIG1lLnN0eWxlID0gc3R5bGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25LZXlEb3duRXNjYXBlKCkge1xuICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttb3VudF0gTW91bnQgdGhlIERPTSBhZnRlciB0aGUgdm5vZGUgZ290IGNyZWF0ZWRcbiAgICAgKi9cbiAgICBhc3luYyByZW5kZXIobW91bnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt3cmFwcGVyU3R5bGV9ID0gbWU7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYW5pbWF0aW9uIHRhcmdldCwgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgaW5pdGlhbCBvZmZzY3JlZW4gcG9zaXRpb25pbmdcbiAgICAgICAgLy8gZnJvbSAubmVvLWZsb2F0aW5nIGdldHMgcmV2ZXJ0ZWRcbiAgICAgICAgaWYgKCFtZS5hbmltYXRlVGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIGlmICghd3JhcHBlclN0eWxlLmxlZnQpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9ICdpbml0aWFsJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXdyYXBwZXJTdHlsZS50b3ApIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUudG9wID0gJ2luaXRpYWwnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLndyYXBwZXJTdHlsZSA9IHdyYXBwZXJTdHlsZVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc3VwZXIucmVuZGVyKG1vdW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZT0hIXRoaXMuYW5pbWF0ZVRhcmdldElkXG4gICAgICovXG4gICAgc2hvdyhhbmltYXRlPSEhdGhpcy5hbmltYXRlVGFyZ2V0SWQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgICAgbWUuYW5pbWF0ZVNob3coKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgbWUuaW5pdFZub2RlKHRydWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmZpcmUoJ3Nob3cnKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuc3luY01vZGFsTWFzaygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkPXRoaXMuaWRcbiAgICAgKi9cbiAgICBzeW5jTW9kYWxNYXNrKGlkPXRoaXMuaWQpIHtcbiAgICAgICAgbGV0IHttb2RhbCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICAvLyBUaGlzIHNob3VsZCBzeW5jIHRoZSB2aXNpYmlsaXR5IGFuZCBwb3NpdGlvbiBvZiB0aGUgbW9kYWwgbWFzayBlbGVtZW50LlxuICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3Muc3luY01vZGFsTWFzayh7aWQsIG1vZGFsLCB3aW5kb3dJZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBzeW5jVHJhcEZvY3VzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2lkLCB3aW5kb3dJZH0gPSBtZTtcblxuICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLnRyYXBGb2N1cyh7aWQsIHRyYXA6IG1lLnRyYXBGb2N1cywgd2luZG93SWR9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEaWFsb2cpO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vdG9vbGJhci9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kaWFsb2cuaGVhZGVyLlRvb2xiYXJcbiAqIEBleHRlbmRzIE5lby50b29sYmFyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRpYWxvZy5oZWFkZXIuVG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRpYWxvZy5oZWFkZXIuVG9vbGJhcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGFjdGlvbk1hcFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aW9uTWFwOiB7XG4gICAgICAgICAgICBjbG9zZSAgIDogKCkgPT4gKHthY3Rpb246ICdjbG9zZScsICAgIGljb25DbHM6ICdmYXIgZmEtd2luZG93LWNsb3NlJ30pLFxuICAgICAgICAgICAgbWF4aW1pemU6ICgpID0+ICh7YWN0aW9uOiAnbWF4aW1pemUnLCBpY29uQ2xzOiAnZmFyIGZhLXdpbmRvdy1tYXhpbWl6ZSd9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiBkZWZpbmUgdGhlIGFjdGlvbiBvcmRlciBhbmQgZGlyZWN0bHkgYWRkIGN1c3RvbSBhY3Rpb25zLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB7XG4gICAgICAgICAqICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAqICAgICAgICAgJ2Nsb3NlJyxcbiAgICAgICAgICogICAgICAgICAnbWF4aW1pemUnLFxuICAgICAgICAgKiAgICAgICAgIHthY3Rpb246ICdoZWxwJywgaWNvbkNsczogJ2ZhciBmYS1jaXJjbGUtcXVlc3Rpb24nfVxuICAgICAgICAgKiAgICAgXVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWxzbyBleHRlbmQgdGhlIGFjdGlvbk1hcCBpZiBuZWVkZWQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfFN0cmluZ1tdfG51bGx9IGFjdGlvbnM9WydtYXhpbWl6ZScsJ2Nsb3NlJ11cbiAgICAgICAgICovXG4gICAgICAgIGFjdGlvbnM6IFsnbWF4aW1pemUnLCAnY2xvc2UnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0aXRsZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZV86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHRpdGxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRpdGxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRvd24oe2ZsYWc6ICd0aXRsZS1sYWJlbCd9KT8uc2V0KHtcbiAgICAgICAgICAgIGhpZGRlbjogIXZhbHVlLFxuICAgICAgICAgICAgdGV4dCAgOiB2YWx1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBtZS5maXJlQWN0aW9uLmJpbmQobWUpLFxuICAgICAgICAgICAgaXRlbXMgICA9IG1lLml0ZW1zIHx8IFtdLFxuICAgICAgICAgICAge3RpdGxlfSA9IG1lO1xuXG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgbnR5cGUgOiAnbGFiZWwnLFxuICAgICAgICAgICAgY2xzICAgOiBbJ25lby1wYW5lbC1oZWFkZXItdGV4dCcsICduZW8tbGFiZWwnXSxcbiAgICAgICAgICAgIGZsYWcgIDogJ3RpdGxlLWxhYmVsJyxcbiAgICAgICAgICAgIGhpZGRlbjogIXRpdGxlLFxuICAgICAgICAgICAgdGV4dCAgOiB0aXRsZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWUuYWN0aW9ucykge1xuICAgICAgICAgICAgaXRlbXMucHVzaCgnLT4nKTtcblxuICAgICAgICAgICAgbWUuYWN0aW9ucy5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby50eXBlT2YoYWN0aW9uKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gbWUuYWN0aW9uTWFwW2FjdGlvbl0oKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe2hhbmRsZXIsIC4uLmFjdGlvbn0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXRlbXMgPSBpdGVtcztcblxuICAgICAgICBzdXBlci5jcmVhdGVJdGVtcygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBmaXJlQWN0aW9uKGRhdGEpIHtcbiAgICAgICAgbGV0IHtjb21wb25lbnR9ID0gZGF0YTtcblxuICAgICAgICB0aGlzLmZpcmUoJ2hlYWRlckFjdGlvbicsIHtcbiAgICAgICAgICAgIGFjdGlvbjogY29tcG9uZW50LmFjdGlvbixcbiAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgIHNjb3BlIDogdGhpc1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVG9vbGJhcik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9