export const __webpack_esm_id__ = "vendors-src_component_Base_mjs";
export const __webpack_esm_ids__ = ["vendors-src_component_Base_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/component/Abstract.mjs"
/*!************************************!*\
  !*** ./src/component/Abstract.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _mixin_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mixin/DomEvents.mjs */ "./src/mixin/DomEvents.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _mixin_VdomLifecycle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mixin/VdomLifecycle.mjs */ "./src/mixin/VdomLifecycle.mjs");
/* harmony import */ var _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../manager/VDomUpdate.mjs */ "./src/manager/VDomUpdate.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");










const
    closestController   = Symbol.for('closestController'),
    closestProvider     = Symbol.for('closestProvider'),
    twoWayBindingSymbol = Symbol.for('twoWayBinding');

/**
 * @class Neo.component.Abstract
 * @extends Neo.core.Base
 * @mixes Neo.component.mixin.DomEvents
 * @mixes Neo.core.Observable
 * @mixes Neo.component.mixin.VdomLifecycle
 */
class Abstract extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Abstract'
         * @protected
         */
        className: 'Neo.component.Abstract',
        /**
         * @member {String} ntype='abstract-component'
         * @protected
         */
        ntype: 'abstract-component',
        /**
         * Additional namespaces to load theme files for.
         * @member {String[]|null} additionalThemeFiles=null
         * @example ['AgentOSStrategy.view.Viewport']
         */
        additionalThemeFiles: null,
        /**
         * The name of the App this component belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * Bind configs to state.Provider data properties.
         * @member {Object|null} bind_={[isDescriptor]:true,merge:'deep',value:null}
         * @reactive
         */
        bind_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_8__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * Custom CSS selectors to apply to the root level node of this component
         * @member {String[]} cls_=null
         * @reactive
         */
        cls_: null,
        /**
         * Convenience shortcut to access the data config of the closest state.Provider.
         * Read only.
         * @member {Object} data_=null
         * @protected
         * @reactive
         */
        data_: null,
        /**
         * Disabled components will get the neo-disabled cls applied and won't receive DOM events
         * @member {Boolean} disabled_=false
         * @reactive
         */
        disabled_: false,
        /**
         * @member {Neo.core.Base[]} mixins=[DomEvents, Observable, VdomLifecycle]
         */
        mixins: [_mixin_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], _mixin_VdomLifecycle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]],
        /**
         * Override specific stateProvider data properties.
         * This will merge the content.
         * @member {Object|null} modelData=null
         */
        modelData: null,
        /**
         * True after the component initVnode() method was called. Also fires the rendered event.
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * If the parentId does not match a neo component id, you can manually set this value for finding
         * view controllers or state providers.
         * Use case: manually dropping components into a vdom structure
         * @member {Neo.component.Base|null} parentComponent_=null
         * @protected
         * @reactive
         */
        parentComponent_: null,
        /**
         * The parent component id or document.body
         * @member {String} parentId_='document.body'
         * @reactive
         */
        parentId_: 'document.body',
        /**
         * @member {Boolean} saveScrollPosition=true
         */
        saveScrollPosition: true,
        /**
         * Optionally add a state.Provider to share state data with child components
         * @member {Object|null} stateProvider_=null
         * @reactive
         */
        stateProvider_: null,
        /**
         * A map of config names and values to reset to when the component unmounts.
         * @member {Object|null} unmountConfigs_={[isDescriptor]:true,merge:'deep',value:null}
         * @example {activeIndex: null, value: ''}
         * @reactive
         */
        unmountConfigs_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_8__.isDescriptor]: true,
            merge         : 'deep',
            value         : null
        },
        /**
         * The custom windowIs (timestamp) this component belongs to
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * Internal flag which will get set to true while a component is waiting for its mountedPromise
     * @member {Boolean} isAwaitingMount=false
     * @protected
     */
    isAwaitingMount = false

    /**
     * Convenience shortcut to access the App this component belongs to
     * @returns {Neo.controller.Application|null}
     */
    get app() {
        // We need Neo.appsByName as a fallback for Playwright-based unit testing
        return Neo.apps[this.windowId] || Neo.appsByName[this.appName]?.[0] || null
    }

    /**
     * A Promise that resolves when the component is mounted to the DOM.
     * This provides a convenient way to wait for the component to be fully
     * available and interactive before executing subsequent logic.
     *
     * It also handles unmounting by resetting the promise, so it can be safely
     * awaited again if the component is remounted.
     * @returns {Promise<Neo.component.Base>}
     */
    get mountedPromise() {
        let me = this;

        if (!me._mountedPromise) {
            me._mountedPromise = new Promise(resolve => {
                if (me.mounted) {
                    resolve(me);
                } else {
                    me.mountedPromiseResolve = resolve
                }
            })
        }

        return me._mountedPromise
    }

    /**
     * Convenience method to access the parent component
     * @returns {Neo.component.Base|null}
     */
    get parent() {
        let me = this;

        return me.parentComponent || (me.parentId === 'document.body' ? null : Neo.getComponent(me.parentId))
    }

    /**
     * Triggered after any config got changed
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     * @protected
     */
    afterSetConfig(key, value, oldValue) {
        let me = this;

        if (Neo.isUsingStateProviders && me[twoWayBindingSymbol]) {
            // When a component config is updated by its state provider, this flag is set to the config's key.
            // This prevents circular updates in two-way data bindings by skipping the push back to the state provider.
            if (me._skipTwoWayPush === key) {
                return;
            }
            let binding = me.bind?.[key];

            if (binding?.twoWay) {
                this.getStateProvider()?.setData(binding.key, value)
            }
        }
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);

        oldValue && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(oldValue);
        value    && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].register(this)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            const me = this;

            if (value) { // mount
                me.initDomEvents?.();
                me.mountedPromiseResolve?.(this);
                delete me.mountedPromiseResolve;

                // When a component becomes mounted, it might have pending VDOM update promises
                // (e.g. from a set() call that was deferred because the component wasn't mounted yet).
                // If the mount happened because a Parent component updated (implicitly covering this component),
                // this component's own pending update cycle might be skipped or not yet triggered.
                // We explicitly execute the callbacks here to ensure those pending promises are resolved immediately
                // upon mount, preventing deadlocks where code awaits a VDOM update that effectively already happened.
                _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].executeCallbacks(me.id, {
                    deltas: [],
                    vnode : me.vnode
                })
            } else { // unmount
                delete me._mountedPromise;

                me.resetMountedDomEvents?.();

                if (me.unmountConfigs) {
                    me.set(me.unmountConfigs)
                }
            }
        }
    }

    /**
     * Triggered after the parentId config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetParentId(value, oldValue) {
        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].onParentIdChange(this, oldValue)
    }

    /**
     * Triggered after the stateProvider config got changed
     * @param {Neo.state.Provider} value
     * @param {Object|Neo.state.Provider|null} oldValue
     * @protected
     */
    afterSetStateProvider(value, oldValue) {
        value?.createBindings(this)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        const me = this;

        if (value) {
            me.controller    && (me.controller.windowId    = value);
            me.stateProvider && (me.stateProvider.windowId = value);

            Neo.currentWorker.insertThemeFiles(value, me.__proto__)
        }

        // If a component gets moved into a different window, an update cycle might still be running.
        // Since the update might no longer get mapped, we want to re-enable this instance for future updates.
        if (oldValue) {
            me.isVdomUpdating = false
        }
    }

    /**
     * Triggered when accessing the data config
     * Convenience shortcut which is expensive to use, since it will generate a merged parent state providers data map.
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getStateProvider()?.getHierarchyData()
    }

    /**
     * Triggered before the stateProvider config gets changed.
     * Creates a state.Provider instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.state.Provider}
     * @protected
     */
    beforeSetStateProvider(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me            = this,
                defaultValues = {component: me, windowId: me.windowId};

            if (me.modelData) {
                defaultValues.data = me.modelData
            }

            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, 'Neo.state.Provider', defaultValues)
        }

        return null
    }

    /**
     *
     */
    destroy() {
        this.removeDomEvents();
        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(this);
        this.stateProvider = null; // triggers destroy()
        super.destroy()
    }

    /**
     * Find an instance stored inside a config via optionally passing a ntype.
     * Returns this[configName] or the closest parent component with a match.
     * Used by getController() & getStateProvider()
     * @param {String} configName
     * @param {String} [ntype]
     * @returns {Neo.core.Base|null}
     */
    getConfigInstanceByNtype(configName, ntype) {
        let me                = this,
            config            = me[configName],
            {parentComponent} = me;

        if (config && (!ntype || ntype === config.ntype)) {
            return config
        }

        if (!parentComponent && me.parentId) {
            parentComponent = me.parent || Neo.get(me.parentId);
        }

        if (parentComponent) {
            if (parentComponent === me) {
                console.error('Circular parent reference detected', me.id);
                return null
            }

            // todo: We need ?. until functional.component.Base supports controllers
            return parentComponent.getConfigInstanceByNtype?.(configName, ntype)
        }

        return null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * Returns this.stateProvider or the closest parent stateProvider
     * @param {String} [ntype]
     * @returns {Neo.state.Provider|null}
     */
    getStateProvider(ntype) {
        if (!Neo.isUsingStateProviders) {
            return null
        }

        let me = this,
            provider;

        if (!ntype) {
            provider = me[closestProvider];

            if (provider) {
                return provider
            }
        }

        provider = me.getConfigInstanceByNtype('stateProvider', ntype);

        if (!ntype) {
            me[closestProvider] = provider
        }

        return provider
    }

    /**
     * @param args
     */
    initConfig(...args) {
        super.initConfig(...args);
        this.getStateProvider()?.createBindings(this)
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        let me    = this,
            vnode;

        if (me.vnode) {
            vnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].getById(me.vnode, data.target.id);

            if (vnode) {
                // Directly updating the persistent vnode state (plain object).
                // This does not trigger a VDOM update, but ensures the state is preserved
                // for future re-renders (e.g. unmount/remount).
                vnode.scrollTop  = data.scrollTop;
                vnode.scrollLeft = data.scrollLeft
            }
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} silent=false
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        const
            me        = this,
            wasHidden = me.hidden;

        me.setSilent(values);

        if (!silent && me.needsVdomUpdate) {
            if (wasHidden && !me.hidden) {
                me.show?.(); // show() is not part of the abstract base class
                return Promise.resolve()
            }

            return me.promiseUpdate()
        }

        return Promise.resolve()
    }

    /**
     * A silent version of set(), which does not trigger a vdom update at the end.
     * Useful for batching multiple config changes.
     * @param {Object} values={}
     */
    setSilent(values={}) {
        this.silentVdomUpdate = true;
        super.set(values);
        this.silentVdomUpdate = false
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }

    /**
     * Serializes the component into a JSON-compatible object.
     * Extends the core.Base serialization with component-specific properties.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            appName      : me.appName,
            bind         : me.bind ? Object.keys(me.bind) : null,
            mounted      : me.mounted,
            parentId     : me.parentId,
            stateProvider: me.stateProvider?.toJSON(),
            windowId     : me.windowId
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Abstract));


/***/ },

/***/ "./src/component/Base.mjs"
/*!********************************!*\
  !*** ./src/component/Base.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Abstract.mjs */ "./src/component/Abstract.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/KeyNavigation.mjs */ "./src/util/KeyNavigation.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_Style_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Style.mjs */ "./src/util/Style.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");












const
    addUnits          = value => value == null ? value : isNaN(value) ? value : `${value}px`,
    closestController = Symbol.for('closestController'),
    lengthRE          = /^\d+\w+$/;

/**
 * Base class for all Components which have a DOM representation
 * @class Neo.component.Base
 * @extends Neo.component.Abstract
 */
class Component extends _Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for hideMode
     * @member {String[]} hideModes=['removeDom','visibility']
     * @protected
     * @static
     */
    static hideModes = ['removeDom', 'visibility']

    static config = {
        /**
         * @member {String} className='Neo.component.Base'
         * @protected
         */
        className: 'Neo.component.Base',
        /**
         * @member {String} ntype='component'
         * @protected
         */
        ntype: 'component',
        /**
         * The default alignment specification to position this Component relative to some other
         * Component, or Element or Rectangle. Only applies in case floating = true.
         * @member {Object|String} align_={[isDescriptor]: true, merge: 'deep', value: {edgeAlign: 't-b',constrainTo: 'document.body'}}
         * @reactive
         */
        align_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'deep',
            value: {
                edgeAlign  : 't-b',
                constrainTo: 'document.body'
            }
        },
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=[]
         */
        baseCls: [],
        /**
         * manager.Focus will change this flag on focusin & out dom events
         * @member {Boolean} containsFocus_=false
         * @protected
         * @reactive
         */
        containsFocus_: false,
        /**
         * Assign a component controller to this component (pass an imported module or the string based class name)
         * @member {Neo.controller.Component|String} controller_=null
         * @reactive
         */
        controller_: null,
        /**
         * Set this config to true to dynamically import a DropZone module & create an instance
         * @member {Boolean} droppable_=false
         * @reactive
         */
        droppable_: false,
        /**
         * @member {Neo.draggable.DropZone|null} dropZone=null
         */
        dropZone: null,
        /**
         * @member {Object} dropZoneConfig=null
         */
        dropZoneConfig: null,
        /**
         * True to mount this component into the viewport outside of the document flow
         * @member {Boolean} floating
         */
        floating: false,
        /**
         * Internal flag which will get set to true on mount
         * @member {Boolean} hasBeenMounted=false
         * @protected
         */
        hasBeenMounted: false,
        /**
         * Shortcut for style.height, defaults to px
         * @member {Number|String|null} height_=null
         * @reactive
         */
        height_: null,
        /**
         * Initial setting to hide or show the component and
         * you can use either hide()/show() or change this config directly to change the hidden state
         * @member {Boolean} hidden_=false
         * @reactive
         */
        hidden_: false,
        /**
         * Used for hide and show and defines if the component
         * should use css visibility:'hidden' or vdom:removeDom
         * @member {String} hideMode_='removeDom'
         * @reactive
         */
        hideMode_: 'removeDom',
        /**
         * The top level innerHTML of the component
         * @member {String|null} html_=null
         * @reactive
         */
        html_: null,
        /**
         * Set to `true` to show a spinner centered in the component.
         * Set to a string to show a message next to a spinner centered in the component.
         * @member {Boolean|String} isLoading=false
         */
        isLoading_: false,
        /**
         * Using the keys config will create an instance of Neo.util.KeyNavigation.
         * @see {@link Neo.util.KeyNavigation KeyNavigation}
         * @member {Object} keys_=null
         * @reactive
         */
        keys_: null,
        /**
         * Gets used inside afterSetIsLoading() to define the CSS for the loading spinner icon
         * @member {String[]} loadingSpinnerCls_=['fa','fa-spinner','fa-spin']
         * @reactive
         */
        loadingSpinnerCls_: ['fa', 'fa-spinner', 'fa-spin'],
        /**
         * Shortcut for style.maxHeight, defaults to px
         * @member {Number|String|null} maxHeight_=null
         * @reactive
         */
        maxHeight_: null,
        /**
         * Shortcut for style.maxWidth, defaults to px
         * @member {Number|String|null} maxWidth_=null
         * @reactive
         */
        maxWidth_: null,
        /**
         * Shortcut for style.minHeight, defaults to px
         * @member {Number|String|null} minHeight_=null
         * @reactive
         */
        minHeight_: null,
        /**
         * Shortcut for style.minWidth, defaults to px
         * @member {Number|String|null} minWidth_=null
         * @reactive
         */
        minWidth_: null,
        /**
         * Array of Plugin Modules and / or config objects
         * @member {Array|null} plugins_=null
         * @protected
         * @reactive
         */
        plugins_: null,
        /**
         * Set a reference for accessing the component inside view controllers.
         * References will also get mapped into the vdom root (data-ref: value).
         * @member {String|null} reference_=null
         * @protected
         * @reactive
         */
        reference_: null,
        /**
         * Make the view Responsive by adding alternative configs.
         * The definition happens via responsiveCfg
         * @member {Object} responsive=null
         * @protected
         */
        responsive_: null,
        /**
         * Specify a role tag attribute for the vdom root.
         * See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles
         * @member {String|null} role_=null
         * @reactive
         */
        role_: null,
        /**
         * Set this to true for style 'overflow:auto'.
         * Set this to 'x' or 'y' to add style 'overflow-x' or 'overflow-y' to 'auto'
         * Other than false this will add cls 'neo-scrollable'.
         * @member {Boolean|"x"|"y"} scrollable_=false
         * @reactive
         */
        scrollable_: false,
        /**
         * Style attributes added to this vdom root. see: getVdomRoot()
         *
         * **Important:** When `vdom === vdomRoot` (single node component), the `wrapperStyle` mechanism
         * creates a persistent state loop to support runtime VDOM mutations.
         * This means that to *remove* a style property you previously set, you MUST set it to `null`.
         * Using `delete` or setting `undefined` will revert to the "previous state", which unfortunately
         * includes the very value you are trying to remove if it has leaked into `wrapperStyle`.
         *
         * @member {Object} style={[isDescriptor]: true, merge: 'shallow', value: null}
         */
        style_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'shallow',
            value         : null
        },
        /**
         * You can pass a used theme directly to any component,
         * to style specific component trees differently from your main view.
         * @member {String|null} theme_=null
         * @reactive
         */
        theme_: null,
        /**
         * While it is recommended to define tags inside the vdom of classes,
         * this shortcut enables us to change the vdom root tag on instance level.
         * Use cases: switch a Toolbar to a "nav" tag, switch a SideNav to an "aside" tag.
         * @member {String|null} tag_=null
         * @reactive
         */
        tag_: null,
        /**
         * The top level textContent of the component
         * @member {String|null} text_=null
         * @reactive
         */
        text_: null,
        /**
         * Add tooltip config object or a string containing the display text
         * See tooltip/Base.mjs
         *
         * By default, a single, shared Tooltip instance is used for all widgets that request
         * a tooltip. It reconfigures itself from the widget's definition just before showing.
         *
         * If a widget needs its own instance for any reason, include the property `ownInstance: true`
         * in the tooltip config object.
         * @member {Object|String} tooltip_=null
         * @reactive
         */
        tooltip_: null,
        /**
         * Add 'primary' and other attributes to make it an outstanding design
         * @member {String|null} ui_=null
         * @reactive
         */
        ui_: null,
        /**
         * Shortcut for style.width, defaults to px
         * @member {Number|String|null} width_=null
         * @reactive
         */
        width_: null,
        /**
         * @member {String[]|null} wrapperCls_=null
         * @reactive
         */
        wrapperCls_: null,
        /**
         * Top level style attributes. Useful in case getVdomRoot() does not point to the top level DOM node.
         *
         * **Note:** The getter for this config reads `vdom.style` as a default value to support runtime mutations.
         * This creates the persistent state loop described in the `style_` config documentation.
         *
         * @member {Object|null} wrapperStyle_={[isDescriptor]: true, merge: 'shallow', value: null}
         * @reactive
         */
        wrapperStyle_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'shallow',
            value         : null
        },
        /**
         * The vdom markup for this component.
         * @member {Object} _vdom={}
         */
        _vdom: {}
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        let me = this;

        if (!Object.hasOwn(me, '_vdom') && me._vdom) {
            me._vdom = Neo.clone(me._vdom, true)
        }

        super.construct(config)
    }

    /**
     * Returns true if this Component is fully visible, that is it is not hidden and has no hidden ancestors
     */
    get isVisible() {
        return this.mounted && !this.hidden && (!this.parent || this.parent.isVisible);
    }

    /**
     * The setter will handle vdom updates automatically
     * @member {Object} vdom=this._vdom
     */
    get vdom() {
        return this._vdom
    }
    set vdom(value) {
        this.afterSetVdom(value, value)
    }

    /**
     * Add a new cls to the vdomRoot
     * @param {String} value
     */
    addCls(value) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);
        this.cls = cls
    }

    /**
     * Either a string like 'color: red; background-color: blue;'
     * or an object containing style attributes
     * @param {String|Object} value
     * @returns {Object} all styles of this.el
     */
    addStyle(value) {
        if (Neo.isString(value)) {
            value =  Neo.createStyleObject(value)
        }

        // todo: add a check if something has changed

        return this.style = Object.assign(this.style, value)
    }

    /**
     * Add a new wrapperCls to the top level node
     * @param {String} value
     */
    addWrapperCls(value) {
        let {wrapperCls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(wrapperCls, value);
        this.wrapperCls = wrapperCls
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {

    }

    /**
     * Triggered after the cls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetCls(value, oldValue) {
        oldValue = oldValue || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls;

        if (vdom !== vdomRoot) {
            // we are using a wrapper node
            vdomRoot.cls = [...value]
        } else {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(me.wrapperCls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].difference(oldValue, value));
            vdom.cls = cls
        }

        me.update()
    }

    /**
     * Triggered after the disabled config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisabled(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"][value ? 'add' : 'remove'](cls, 'neo-disabled');
        this.cls = cls
    }



    /**
     * Triggered after the droppable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDroppable(value, oldValue) {
        let me = this;

        if (value && !me.dropZone) {
            __webpack_require__.e(/*! import() */ "src_draggable_DropZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DropZone.mjs */ "./src/draggable/DropZone.mjs")).then(module => {
                me.dropZone = Neo.create({
                    module  : module.default,
                    appName : me.appName,
                    owner   : me,
                    windowId: me.windowId,
                    ...me.dropZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the height config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetHeight(value, oldValue) {
        this.configuredHeight = addUnits(value);
        this.changeVdomRootKey('height', value)
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let me    = this,
            state = value ? 'hide' : 'show';

        if (value && oldValue === undefined && me.hideMode === 'removeDom') {
            me.vdom.removeDom = true
        } else if (value || oldValue !== undefined) {
            me[state]()
        }

        if (!value) {
            me.revertFocus();
        }

        me.fire(state, {id: me.id});
        me.fire('hiddenChange', {id: me.id, oldValue, value})
    }

    /**
     * Triggered after the html config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetHtml(value, oldValue) {
        this.changeVdomRootKey('html', value)
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);

        let me = this;

        if (me.configsApplied) {
            me.ensureStableIds();
            me.update()
        }
    }

    /**
     * Triggered after the isLoading config got changed
     * @param {Boolean|String} value
     * @param {Boolean|String} oldValue
     * @protected
     */
    afterSetIsLoading(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me                 = this,
                {wrapperCls, vdom} = me,
                maskIndex;

            if (oldValue !== undefined && vdom.cn) {
                maskIndex = vdom.cn.findLastIndex(c => c.cls?.includes('neo-load-mask'));

                // Remove the load mask
                if (maskIndex !== -1) {
                    vdom.cn.splice(maskIndex, 1)
                }
            }

            if (value) {
                if (!vdom.cn) {
                    vdom.cn = []
                }

                vdom.cn.push(me.createLoadingMask(value))
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].toggle(wrapperCls, 'neo-masked', value);
            me.set({vdom, wrapperCls})
        }
    }

    /**
     * Triggered after the maxHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxHeight(value, oldValue) {
        this.configuredMaxHeight = addUnits(value);
        this.changeVdomRootKey('maxHeight', value)
    }

    /**
     * Triggered after the maxWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxWidth(value, oldValue) {
        this.configuredMaxWidth = addUnits(value);
        this.changeVdomRootKey('maxWidth', value)
    }

    /**
     * Triggered after the minHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinHeight(value, oldValue) {
        this.configuredMinHeight = addUnits(value);
        this.changeVdomRootKey('minHeight', value)
    }

    /**
     * Triggered after the minWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinWidth(value, oldValue) {
        this.configuredMinWidth = addUnits(value);
        this.changeVdomRootKey('minWidth', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (oldValue !== undefined) {
            let me = this;

            if (value) { // mount
                me.hasBeenMounted = true;

                if (me.floating) {
                    me.alignTo();

                    // Focus will be pushed into the first input field or other focusable item
                    me.focus(me.id, true)
                }

                me.fire('mounted', me.id);
            } else { // unmount
                me.revertFocus()
            }
        }
    }

    /**
     * Triggered after the reference config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetReference(value, oldValue) {
        value && this.changeVdomRootKey('data-ref', value)
    }

    /**
     * Triggered after the responsive config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    async afterSetResponsive(value, oldValue) {
        if (value && !this.getPlugin('responsive')) {
            let me      = this,
                module  = await __webpack_require__.e(/*! import() */ "src_plugin_Responsive_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../../src/plugin/Responsive.mjs */ "./src/plugin/Responsive.mjs")),
                plugins = me.plugins || [];

            plugins.push({
                module : module.default,
                appName: me.appName,
                value
            });

            me.plugins = plugins
        }
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.changeVdomRootKey('role', value)
    }

    /**
     * Triggered after the scrollable config got changed
     * @param {String|Boolean} value
     * @param {String|Boolean|null} oldValue
     * @protected
     */
    afterSetScrollable(value, oldValue) {
        if (oldValue === undefined && !value) {
            return
        }

        let me = this;

        if (oldValue) {
            let oldOverflowKey = 'overflow';

            if (!Neo.isBoolean(oldValue)) {
                oldOverflowKey += Neo.capitalize(oldValue)
            }

            me.removeStyle([oldOverflowKey])
        }

        if (!Neo.isEmpty(value)) {
            let overflowKey = 'overflow';

            if (value && !Neo.isBoolean(value)) {
                overflowKey += Neo.capitalize(value)
            }

            if (value) {
                me.addStyle(overflowKey + ':auto');
                me.addCls('neo-scrollable')
            } else {
                me.removeCls('neo-scrollable')
            }
        }
    }

    /**
     * Triggered after the style config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle()
        }
    }

    /**
     * Triggered after the tag config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTag(value, oldValue) {
        value && this.changeVdomRootKey('tag', value)
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me          = this,
                {cls}       = me,
                needsUpdate = false;

            if (oldValue && cls.includes(oldValue)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, oldValue);
                needsUpdate = true
            }

            // We do not need to add a DOM based CSS selector, in case the theme is already inherited
            if (value !== me.parent?.theme) {
                value && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);
                needsUpdate = true
            }

            if (needsUpdate) {
                me.cls = cls
            }
        }
    }

    /**
     * Triggered after the text config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        this.changeVdomRootKey('text', value)
    }

    /**
     * Triggered after the tooltip config got changed
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @protected
     */
    afterSetTooltip(value, oldValue) {
        oldValue?.destroy?.();

        if (value) {
            if (Neo.ns('Neo.tooltip.Base')) {
                this.createTooltip(value)
            } else {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_container_Base_mjs"), __webpack_require__.e("vendors-src_tooltip_Base_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../tooltip/Base.mjs */ "./src/tooltip/Base.mjs")).then(() => {
                    this.createTooltip(value)
                })
            }
        }
    }

    /**
     * For styling purposes only.
     * To define button styles or component styles,
     * this will add a css class: neo-ntype-value
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetUi(value, oldValue) {
        let me  = this,
            cls = me.cls;

        if (oldValue) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, `neo-${me.ntype}-${oldValue}`)
        }

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, `neo-${me.ntype}-${value}`)
        }

        me.cls = cls
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        this.configuredWidth = addUnits(value);
        this.changeVdomRootKey('width', value)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let controller = this.controller;

        if (controller) {
            controller.windowId = value
        }
    }

    /**
     * Triggered after the wrapperCls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetWrapperCls(value, oldValue) {
        oldValue = oldValue || [];
        value    = value    || [];

        let me       = this,
            {vdom}   = me,
            vdomRoot = me.getVdomRoot(),
            cls      = vdom.cls || [];

        if (vdom === vdomRoot) {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(cls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].difference(oldValue, value));
            vdom.cls = cls
        } else {
            // we are not using a wrapper => cls & wrapperCls share the same node
            value = value ? value : [];

            oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, oldValue);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);

            vdom.cls = cls
        }

        me.update()
    }

    /**
     * Triggered after the wrapperStyle config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetWrapperStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle()
        }
    }

    /**
     * Aligns the top level node inside the main thread
     * @param {Object} spec={}
     * @returns {Promise<void>}
     */
    async alignTo(spec={}) {
        const
            me    = this,
            align = {
                ...me.align,
                ...spec,
                id                 : me.id,
                configuredFlex     : me.configuredFlex,
                configuredWidth    : me.configuredWidth,
                configuredHeight   : me.configuredHeight,
                configuredMinWidth : me.configuredMinWidth,
                configuredMinHeight: me.configuredMinHeight,
                configuredMaxWidth : me.configuredMaxWidth,
                configuredMaxHeight: me.configuredMaxHeight,
                windowId           : me.windowId
            };

        if (align.target) {
            await Neo.main.DomAccess.align(align)
        }
    }

    /**
     * Triggered when accessing the cls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the style config
     * @param {Object} value
     * @protected
     */
    beforeGetStyle(value) {
        return {...value}
    }

    /**
     * Triggered when accessing the wrapperCls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetWrapperCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the wrapperStyle config.
     *
     * It merges the current `vdom.style` into the result to ensure that runtime style mutations
     * (hacks) or initial VDOM styles are preserved and not overwritten by the config value.
     *
     * **Warning:** This creates the persistent state loop described in the `style_` config.
     * Reading the output (`vdom.style`) as the default for the input (`wrapperStyle`) means
     * merged styles become permanent unless explicitly cleared with `null`.
     *
     * @param {Object} value
     * @protected
     */
    beforeGetWrapperStyle(value) {
        return {...Object.assign(this.vdom.style || {}, value)}
    }

    /**
     * Triggered before the align config gets changed.
     * @param {Object|String} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        let me = this;

        // Just a simple 't-b'
        if (typeof value === 'string') {
            value = {
                edgeAlign: value
            }
        }

        return value
    }

    /**
     * Triggered before the cls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(value || [], this.baseCls, this.getBaseClass());
    }

    /**
     * Triggered before the controller config gets changed.
     * Creates a controller.Component instance if needed.
     * @param {Neo.controller.Component|Object} value
     * @param {Neo.controller.Component|null} oldValue
     * @returns {Neo.controller.Component}
     * @protected
     */
    beforeSetController(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, 'Neo.controller.Component', {
                component: this,
                windowId : this.windowId
            })
        }

        return value
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Triggered before the hideMode config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetHideMode(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'hideMode')
    }

    /**
     * Triggered before the keys config gets changed.
     * Creates a KeyNavigation instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.util.KeyNavigation|null}
     * @protected
     */
    beforeSetKeys(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
                keyDownEventBubble: true,
                keys              : value
            })
        }

        return value
    }

    /**
     * Triggered before the plugins config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @returns {Neo.plugin.Base[]}
     * @protected
     */
    beforeSetPlugins(value, oldValue) {
        if (Array.isArray(value)) {
            value.forEach((item, index) => {
                value[index] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(item, null, {
                    owner: this
                })
            })
        }

        return value
    }

    /**
     * Triggered before the silentVdomUpdate config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetSilentVdomUpdate(value, oldValue) {
        if (value === true) {
            return Neo.isNumber(oldValue) ? (oldValue + 1) : 1
        }

        return (Neo.isNumber(oldValue) && oldValue > 0) ? (oldValue - 1) : 0
    }

    /**
     * Triggered before the updateDepth config gets changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetUpdateDepth(value, oldValue) {
        if (oldValue === undefined) {
            return value
        }

        return oldValue === -1 || value === -1 ? -1 : Math.max(value, oldValue)
    }

    /**
     * Changes the value of a vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     */
    changeVdomRootKey(key, value) {
        let me   = this,
            root = me.getVdomRoot();

        if (value) {
            root[key] = value
        } else {
            delete root[key]
        }

        me.update()
    }

    /**
     * Override this method in case you need different mask markups.
     * The removal logic relies on the top level node having the cls 'neo-load-mask'
     * @param {Boolean|String} loadingMessage
     * @returns {Object} vdom
     */
    createLoadingMask(loadingMessage) {
        return {
            cls: ['neo-load-mask'],
            cn : [{
                cls: ['neo-load-mask-body'],
                cn : [{
                    cls: this.loadingSpinnerCls
                }, {
                    cls      : ['neo-loading-message'],
                    removeDom: !Neo.isString(loadingMessage),
                    text     : loadingMessage
                }]
            }]
        }
    }

    /**
     * Creates the tooltip instances
     * @param {Object|String} value
     * @protected
     */
    createTooltip(value) {
        if (typeof value === 'string') {
            value = {
                text: value
            }
        }

        let me = this;

        if (value.ownInstance) {
            me._tooltip = Neo.create('Neo.tooltip.Base', {
                ...value,
                appName    : me.appName,
                componentId: me.id,
                windowId   : me.windowId
            })
        } else {
            me._tooltip = value;
            Neo.tooltip.Base.createSingleton(me.app);
            me.addCls('neo-uses-shared-tooltip');
            me.update()
        }
    }

    /**
     * Unregister this instance from the ComponentManager
     * @param {Boolean} updateParentVdom=false true to remove the component from the parent vdom => real dom
     * @param {Boolean} silent=false true to update the vdom silently (useful for destroying multiple child items in a row)
     * todo: unregister events
     */
    destroy(updateParentVdom=false, silent=false) {
        let me                 = this,
            {parent, parentId} = me,
            parentVdom;

        me.revertFocus();

        me.controller = null; // triggers destroy()

        me.reference && me.getController()?.removeReference(me); // remove own reference from parent controllers

        me.plugins?.forEach(plugin => {
            plugin.destroy()
        });

        if (updateParentVdom && parentId) {
            if (parentId === 'document.body') {
                Neo.applyDeltas(me.windowId, {action: 'removeNode', id: me.vdom.id})
            } else {
                parentVdom = parent.vdom;

                _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].removeVdomChild(parentVdom, me.vdom.id);
                parent[silent ? '_vdom' : 'vdom'] = parentVdom
            }
        }

        super.destroy();

        // We do want to prevent delayed calls after a component instance got destroyed.
        me.onFocusLeave = Neo.emptyFn;
        me.unmount      = Neo.emptyFn
    }

    /**
     * Convenience shortcut for Neo.manager.Component.down
     * @param {Object|String} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    down(config, returnFirstMatch=true) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].down(this, config, returnFirstMatch)
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} id=this.id
     * @param {Boolean} children=false
     * @param {Boolean} preventScroll
     */
    focus(id=this.id, children=false, preventScroll) {
        Neo.main.DomAccess.focus({children, id, preventScroll, windowId: this.windowId})
    }

    /**
     * Override this method to add dynamic values into this.cls
     * @returns {String[]}
     */
    getBaseClass() {
        const result = [];

        if (this.floating) {
            result.push('neo-floating')
        }

        return result
    }

    /**
     * Returns this.controller or the closest parent controller
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        let me = this,
            controller;

        if (!ntype) {
            controller = me[closestController];

            if (controller) {
                return controller
            }
        }

        controller = me.getConfigInstanceByNtype('controller', ntype);

        if (!ntype) {
            me[closestController] = controller
        }

        return controller
    }

    /**
     * Convenience shortcut
     * @param {String[]|String} id=this.id
     * @param {String} windowId=this.windowId
     * @returns {Promise<Neo.util.Rectangle|Neo.util.Rectangle[]>}
     */
    async getDomRect(id=this.id, windowId=this.windowId) {
        let result = await this.trap(Neo.main.DomAccess.getBoundingClientRect({id, windowId}));

        if (Array.isArray(result)) {
            return result.map(rect => _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].clone(rect))
        }

        return _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].clone(result)
    }

    /**
     * Get the parent components as an array
     * @returns {Neo.component.Base[]}
     */
    getParents() {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(this)
    }

    /**
     * @param {Object|String} opts
     * @returns {Neo.plugin.Base|null}
     */
    getPlugin(opts) {
        if (Neo.isString(opts)) {
            if (!opts.startsWith('plugin-')) {
                opts = 'plugin-' + opts
            }

            opts = {ntype: opts}
        }

        let me = this,
            hasMatch;

        for (const plugin of me.plugins || []) {
            hasMatch = true;

            for (const key in opts) {
                if (plugin[key] !== opts[key]) {
                    hasMatch = false;
                    break
                }
            }

            if (hasMatch) {
                return plugin
            }
        }

        return null
    }

    /**
     * convenience shortcut
     * @param {String} value
     * @returns {Neo.component.Base|null}
     */
    getReference(value) {
        return this.down({reference: value})
    }

    /**
     * Walks up the vdom tree and returns the closest theme found
     * @returns {String}
     */
    getTheme() {
        let me         = this,
            themeMatch = 'neo-theme-',
            mainView, parentNodes;

        for (const item of me.cls || []) {
            if (item.startsWith(themeMatch)) {
                return item
            }
        }

        mainView = me.app?.mainView;

        if (mainView) {
            parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].getParentNodes(mainView.vdom, me.id);

            for (const node of parentNodes || []) {
                for (const item of node.cls || []) {
                    if (item.startsWith(themeMatch)) {
                        return item
                    }
                }
            }
        }

        return Neo.config.themes?.[0]
    }

    /**
     * Hide the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     * If hideMode === 'removeDom' you can pass a timeout for custom css class hiding.
     * @param {Number} timeout
     */
    hide(timeout) {
        let me = this;

        if (me.hideMode !== 'visibility') {
            let removeFn = function () {
                if (me.parentId !== 'document.body') {
                    me.vdom.removeDom = true;
                    me.parent.updateDepth = 2;
                    me.parent.update()
                } else {
                    me.unmount()
                }
            }

            if (timeout) {
                me.timeout(timeout).then(removeFn)
            } else {
                removeFn()
            }
        } else {
            let style = me.style;
            style.visibility = 'hidden';
            me.style = style
        }

        me._hidden = true
    }

    /**
     *
     */
    init() {
        this.autoInitVnode && this.initVnode()
    }

    /**
     * Check if this component or any of its parents is floating
     * @returns {Boolean}
     */
    isFloating() {
        let me = this;

        if (me.floating) {
            return true
        }

        if (!me.parent) {
            return false
        }

        return  me.parent.floating
    }

    /**
     * @param {Number|String} value
     * @returns {Promise<number>}
     */
    async measure(value) {
        if (value != null) {
            if (value.endsWith('px')) {
                value = parseFloat(value)
            } else if (lengthRE.test(value)) {
                let {id, windowId} = this;
                value = await this.trap(Neo.main.DomAccess.measure({id, value, windowId}))
            } else if (!isNaN(value)) {
                value = parseFloat(value)
            }
        }

        return value
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let config = super.mergeConfig(...args),
            vdom   = config.vdom || config._vdom || {};

        // It should be possible to modify root level vdom attributes on instance level.
        // Note that vdom is not a real config, but implemented via get() & set().
        this._vdom = Neo.clone({...vdom, ...this._vdom || {}}, true);

        this.ensureStableIds();

        delete config._vdom;
        delete config.vdom;

        return config
    }

    /**
     * Can get called after the component got vnodeInitialized. See the autoMount config as well.
     * We have decided to always force a new initVnode(true) call here.
     * Rationale:
     * 1. The overhead of tracking hasUnmountedVdomChanges on every vdom update is removed.
     * 2. The edge case of mounting a pre-calculated but untouched vnode tree is < 1%.
     * 3. The cost of re-generating the vnode tree is low enough to justify the robustness and simplicity.
     * 4. This ensures that the DOM is always mounted with the most up-to-date vdom state.
     */
    async mount() {
        return this.initVnode(true)
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.keys?.register(this)
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);

        let me = this;

        if (me._vdom) {
            let vdomNode = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].getById(me._vdom, data.target.id);

            if (vdomNode) {
                vdomNode.scrollTop  = data.scrollTop;
                vdomNode.scrollLeft = data.scrollLeft
            }
        }
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        // If we are hidden, or unmounted while we still contain focus, we have to revert
        // focus to where it came from if possible
        this.focusEnterData = data
    }

    /**
     * @param {Object} data
     */
    onFocusLeave(data) {
        this.focusEnterData = null
    }

    /**
     * Triggered by manager.Focus
     * @name onFocusEnter
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusLeave
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusMove
     * @function
     * @param {Object} opts
     * @param {Array}  opts.newPath dom element ids upwards
     * @param {Array}  opts.oldPath dom element ids upwards
     */

    /**
     * Remove a cls from the vdomRoot
     * @param {String} value
     */
    removeCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, value);
        this.cls = cls
    }



    /**
     * Either a string like 'color' or an array containing style attributes to remove
     * @param {String|Array} value camelCase only
     * @returns {Object} all styles of this.el
     */
    removeStyle(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let {style}  = this,
            doUpdate = false;

        Object.keys(style).forEach(key => {
            if (value.indexOf(key) > -1) {
                delete style[key];
                doUpdate = true
            }
        });

        if (doUpdate) {
            this.style = style
        }

        return style
    }

    /**
     *
     */
    revertFocus() {
        let relatedTarget = this.focusEnterData?.relatedTarget;

        if (this.containsFocus && relatedTarget) {
            Neo.getComponent(relatedTarget.id)?.focus()
        }
    }

    /**
     * Show the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     */
    show() {
        let me = this;

        if (me.hideMode !== 'visibility') {
            delete me.vdom.removeDom;

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.parentId !== 'document.body') {
                me.parent.updateDepth = -1;
                me.parent.update()
            } else {
                !me.mounted && me.initVnode(true)
            }
        } else {
            let style = me.style;
            // We need to set null, since the style might be inside wrapperStyle,
            // which would get re-applied in case we just delete the property.
            style.visibility = null;
            me.style = style
        }

        me._hidden = false
    }

    /**
     * Toggle a cls inside the vdomRoot of the component
     * @param {String} value
     * @param {Boolean} [add] Use this param to enforce an add() or remove() operation.
     */
    toggleCls(value, add) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].toggle(cls, value, add);
        this.cls = cls
    }

    /**
     * Removes the component DOM
     */
    unmount() {
        let me = this;

        me.vdom.removeDom = true;

        me._hidden = true; // silent update
        me.mounted = false;

        Neo.applyDeltas(me.windowId, {action: 'removeNode', id: me.vdom.id})
    }

    /**
     * Convenience shortcut for Neo.manager.Component.up
     * @param {Object|String} config
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    up(config) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].up(this.id, config)
    }

    /**
     * Serializes the component into a JSON-compatible object.
     * Extends the core.Base serialization with component-specific properties.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            align       : me.align,
            cls         : me.cls,
            controller  : me.controller?.toJSON(),
            disabled    : me.disabled,
            height      : me.height,
            hidden      : me.hidden,
            keys        : me.keys?.toJSON(),
            reference   : me.reference,
            role        : me.role,
            style       : me.style,
            theme       : me.theme,
            ui          : me.ui,
            vdom        : me.vdom,
            vnode       : me.vnode,
            width       : me.width,
            wrapperCls  : me.wrapperCls,
            wrapperStyle: me.wrapperStyle
        }
    }

    /**
     *
     */
    updateStyle() {
        let me       = this,
            {vdom}   = me,
            vdomRoot = me.getVdomRoot();

        if (vdom !== vdomRoot) {
            vdom    .style = me.wrapperStyle;
            vdomRoot.style = me.style
        } else {
            vdom.style = {...me.wrapperStyle, ...me.style}
        }

        me.update()
    }

    /**
     * In case you are sure a DOMRect exists, use getDomRect()
     * Otherwise you can wait for it using this method.
     * @example:
     *     await this.initVnode(true);
     *     await this.waitForDomRect();
     * @param {Object}          opts
     * @param {Number}          opts.attempts=10 Reruns in case the rect height or width equals 0
     * @param {Number}          opts.delay=50    Time in ms before checking again
     * @param {String[]|String} opts.id=this.id
     * @param {String}          opts.windowId=this.windowId
     * @returns {Promise<Neo.util.Rectangle|Neo.util.Rectangle[]>}
     */
    async waitForDomRect({attempts=10, delay=50, id=this.id, windowId=this.windowId} = {}) {
        let me     = this,
            result = await me.getDomRect(id),
            reRun  = false;

        if (Array.isArray(result)) {
            result.forEach(rect => {
                if (rect.height < 1 || rect.width < 1) {
                    reRun = true
                }
            })
        } else if (result.height < 1 || result.width < 1) {
            reRun = true
        }

        if (reRun && attempts > 0) {
            await me.timeout(delay);
            return await me.waitForDomRect({attempts: attempts-1, delay, id, windowId})
        }

        return result
    }
}

/**
 * manager.Focus fires the event after focusEnter, focusLeave or focusMove
 * @event focusChange
 * @param {Object} data
 * @param {Object[]} [data.path] dom element ids upwards
 * @param {Object[]} [data.oldPath] dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path
 * @event focusEnter
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is not included inside the dom id path
 * @event focusLeave
 * @param {Object} data
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path, but the path itself changed
 * @event focusMove
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/manager/VDomUpdate.mjs"
/*!************************************!*\
  !*** ./src/manager/VDomUpdate.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");


/**
 * The VDomUpdate manager is a singleton responsible for orchestrating and optimizing
 * component VDOM updates within the Neo.mjs framework. It acts as a central coordinator
 * to optimize the VDOM update process. Its primary goal is to reduce the amount of
 * message roundtrips between the application and VDOM workers by aggregating multiple
 * component updates into a single, optimized VDOM tree.
 *
 * Key Responsibilities:
 * 1. **Update Merging & Aggregation:** Allows a parent component to absorb the update
 *    requests of its children. Instead of each child triggering a separate VDOM update
 *    message to the VDOM worker, the parent sends a single, aggregated VDOM tree. This
 *    significantly reduces the overhead of worker communication and can result in smaller,
 *    more focused data for the VDOM worker to process. While the amount of final DOM
 *    modifications remains the same, this aggregation is key to performance.
 *
 *    **Teleportation (Disjoint Updates):** The manager now supports processing multiple
 *    disjoint components in a single "Teleportation" batch. This allows deep descendants
 *    to update in parallel with their ancestors without requiring the ancestor to "bridge"
 *    the gap, eliminating O(N) overhead for deep updates.
 *
 * 2. **Asynchronous Flow Control:** Manages the asynchronous nature of VDOM updates, which
 *    are often processed in a worker thread. It ensures that code awaiting an update
 *    (e.g., via a returned Promise) is correctly notified upon completion.
 *
 * 3. **Dependency Chaining:** Provides a "post-update" queue, allowing one component's
 *    update to be declaratively chained to another's, ensuring a predictable order of
 *    operations.
 *
 * 4. **State Tracking:** Keeps track of updates that are "in-flight" (i.e., currently
 *    being processed), which helps to avoid race conditions and redundant work.
 *
 * By centralizing these concerns, VDomUpdate plays a critical role in the framework's
 * performance and rendering efficiency.
 *
 * @class Neo.manager.VDomUpdate
 * @extends Neo.collection.Base
 * @singleton
 */
class VDomUpdate extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.VDomUpdate'
         * @protected
         */
        className: 'Neo.manager.VDomUpdate',
        /**
         * A collection that maps a parent component's ID (`ownerId`) to the set of child
         * components whose VDOM updates have been merged into that parent's update cycle.
         *
         * The structure for each entry is:
         * `{ ownerId: 'parent-id', children: Map<'child-id', {childUpdateDepth, distance}> }`
         *
         * - `ownerId`: The `id` of the parent component taking responsibility for the update.
         * - `children`: A Map where keys are the `id`s of the merged children and values
         *   are objects containing metadata needed to calculate the total update scope.
         *
         * @member {Neo.collection.Base|null} mergedCallbackMap=null
         * @protected
         */
        mergedCallbackMap: null,
        /**
         * A collection that queues components that need to be updated immediately after
         * another component's update cycle completes. This is used to handle rendering
         * dependencies.
         *
         * The structure for each entry is:
         * `{ ownerId: 'component-id', children: [{childId, resolve}] }`
         *
         * - `ownerId`: The `id` of the component whose update completion will trigger the queued updates.
         * - `children`: An array of objects, where `childId` is the component to update and
         *   `resolve` is the Promise resolver to call after that subsequent update is done.
         *
         * @member {Neo.collection.Base|null} postUpdateQueueMap=null
         * @protected
         */
        postUpdateQueueMap: null,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * A Map that tracks the in-flight update status of descendants for each component.
     * This "Reverse Lookup" map allows ancestor components to check if any of their
     * descendants are currently updating in O(1) time, without walking the tree downwards.
     *
     * Key: ancestorId, Value: Map<descendantId, true>
     *
     * This is crucial for the `VdomLifecycle.isChildUpdating` guard, which prevents
     * race conditions where a parent update might clobber a concurrent child update.
     *
     * @member {Map<String, Map<String, Boolean>>} descendantInFlightMap=new Map()
     * @protected
     */
    descendantInFlightMap = new Map()
    /**
     * A Map that tracks VDOM updates that have been dispatched to the VDOM worker but
     * have not yet completed. This prevents redundant updates for the same component.
     *
     * The structure is: `Map<'component-id', updateDepth>`
     *
     * @member {Map|null} inFlightUpdateMap=null
     * @protected
     */
    inFlightUpdateMap = null;
    /**
     * A Map that stores callbacks to be executed immediately after a component's VDOM update
     * finishes, but BEFORE the `needsVdomUpdate` check for the next cycle.
     *
     * Key: componentId, Value: callback Function
     *
     * @member {Map<String, Function>} preUpdateMap=new Map()
     * @protected
     */
    preUpdateMap = new Map()
    /**
     * A Map that stores Promise `resolve` functions associated with a component's update.
     * When a component's VDOM update is finalized, the callbacks for its ID are executed,
     * resolving the Promise returned by the component's `update()` method.
     *
     * The structure is: `Map<'component-id', [callback1, callback2, ...]>`
     *
     * @member {Map|null} promiseCallbackMap=null
     * @protected
     */
    promiseCallbackMap = null;

    /**
     * Initializes the manager's internal collections and maps.
     * This is called automatically when the singleton instance is created.
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        const me = this;

        me.inFlightUpdateMap  = new Map();
        me.mergedCallbackMap  = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], {keyProperty: 'ownerId'});
        me.postUpdateQueueMap = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], {keyProperty: 'ownerId'});
        me.promiseCallbackMap = new Map();
    }

    /**
     * Registers a callback function to be executed when a specific component's
     * VDOM update completes. This is the mechanism that resolves the Promise
     * returned by `Component#update()`.
     * @param {String}   ownerId  The `id` of the component owning the update.
     * @param {Function} callback The function to execute upon completion.
     */
    addPromiseCallback(ownerId, callback) {
        let me = this;

        if (!me.promiseCallbackMap.has(ownerId)) {
            me.promiseCallbackMap.set(ownerId, [])
        }

        me.promiseCallbackMap.get(ownerId).push(callback)
    }

    /**
     * Executes all callbacks associated with a completed VDOM update for a given `ownerId`.
     * This method first processes callbacks for any children that were merged into this
     * update cycle, then executes the callbacks for the `ownerId` itself.
     *
     * **Teleportation / Batch Support:**
     * The `processedChildIds` argument is crucial for Disjoint Updates. It ensures we only
     * execute callbacks for children that were *actually* included in the VDOM payload.
     * Children that were filtered out (e.g. due to collisions with a parent update) will
     * NOT have their callbacks executed here; they will be handled by the covering parent's callback.
     *
     * @param {String} ownerId The `id` of the component whose update has just completed.
     * @param {Object} [data]  Optional data to pass to the callbacks.
     * @param {Set<String>|null} [processedChildIds] IDs of children actually included in this update.
     */
    executeCallbacks(ownerId, data, processedChildIds) {
        let me           = this,
            item         = me.mergedCallbackMap.get(ownerId),
            callbackData = data ? [data] : [];

        if (item && processedChildIds) {
            for (const childId of processedChildIds) {
                if (item.children.has(childId)) {
                    me.executePromiseCallbacks(childId, ...callbackData);
                    item.children.delete(childId)
                }
            }

            if (item.children.size === 0) {
                me.mergedCallbackMap.remove(ownerId)
            }
        }

        me.executePromiseCallbacks(ownerId, ...callbackData)
    }

    /**
     * Retrieves and executes the registered Pre-Update callback for a component.
     * This is called by VdomLifecycle just before checking `needsVdomUpdate`.
     * @param {String} id The component ID.
     */
    executePreUpdates(id) {
        let callback = this.preUpdateMap.get(id);

        if (callback) {
            this.preUpdateMap.delete(id);
            callback()
        }
    }

    /**
     * A helper method that invokes all registered promise callbacks for a given
     * component ID and then clears them from the queue.
     * @param {String} ownerId The `id` of the component.
     * @param {Object} [data]  Optional data to pass to the callbacks.
     */
    executePromiseCallbacks(ownerId, data) {
        let me        = this,
            callbacks = me.promiseCallbackMap.get(ownerId);

        if (callbacks) {
            for (let i = 0, len = callbacks.length; i < len; i++) {
                callbacks[i](data)
            }
            me.promiseCallbackMap.delete(ownerId);
        }
    }

    /**
     * Calculates the required `updateDepth` for a parent component based on its own
     * needs and the needs of all child components whose updates have been merged into it.
     * The final depth is the maximum required depth to ensure all changes are rendered.
     *
     * For example, if a parent needs to update its direct content (`updateDepth: 1`) but
     * a merged child 3 levels down needs a full subtree update (`childUpdateDepth: -1`),
     * this method will return -1, signaling a full recursive update from the parent.
     *
     * This method is called by the parent component right before it dispatches its VDOM update.
     * @param {String} ownerId The `id` of the parent component.
     * @returns {Number|null} The adjusted update depth, or `null` if no merged children exist.
     */
    getAdjustedUpdateDepth(ownerId) {
        let me       = this,
            owner    = Neo.getComponent(ownerId),
            item     = me.mergedCallbackMap.get(ownerId),
            maxDepth = owner?.updateDepth ?? 1,
            newDepth;

        if (item) {
            for (const value of item.children.values()) {
                if (value.childUpdateDepth === -1) {
                    newDepth = -1
                } else {
                    // The new depth is the distance to the child plus the child's own required update depth.
                    newDepth = value.distance + value.childUpdateDepth
                }

                if (newDepth === -1) {
                    maxDepth = -1
                } else if (maxDepth !== -1) {
                    maxDepth = Math.max(maxDepth, newDepth)
                }
            }

            return maxDepth
        }

        return null
    }

    /**
     * Checks if a component has any descendants currently undergoing a VDOM update.
     * This method is used by `VdomLifecycle` to detect potential race conditions
     * before starting a parent update.
     * @param {String} ownerId The component ID to check.
     * @returns {Boolean} True if any descendant is in-flight.
     */
    hasInFlightDescendants(ownerId) {
        return this.descendantInFlightMap.has(ownerId)
    }

    /**
     * Retrieves the `updateDepth` for a component's update that is currently in-flight.
     * @param {String} ownerId The `id` of the component owning the update.
     * @returns {Number|undefined} The update depth, or `undefined` if no update is in-flight.
     */
    getInFlightUpdateDepth(ownerId) {
        return this.inFlightUpdateMap.get(ownerId)
    }

    /**
     * Returns a Set of child component IDs that have been merged into a parent's update cycle,
     * PLUS all intermediate "Bridge" components (ancestors) required to reach them.
     *
     * This set serves as an "AllowList" for TreeBuilder. When a parent updates with depth > 1,
     * TreeBuilder will use this set to perform **Sparse Tree Generation**:
     * 1. Components in this set are expanded (traversed).
     * 2. Components NOT in this set are pruned (sent as placeholders), even if the depth allows expansion.
     *
     * This optimization allows clean siblings to be skipped, reducing payload size and enabling parallelism.
     *
     * @param {String} ownerId The `id` of the parent component.
     * @returns {Set<String>|null} A Set containing IDs of merged children AND bridge ancestors, or `null`.
     */
    getMergedChildIds(ownerId) {
        const item = this.mergedCallbackMap.get(ownerId);

        if (item) {
            const ids = new Set(item.children.keys());

            // Add Bridge Paths: Walk up from each merged child to the owner
            for (const [childId, meta] of item.children) {
                if (meta.distance > 1) {
                    let component = Neo.getComponent(childId);

                    while (component && component.parentId && component.parentId !== ownerId) {
                        component = Neo.getComponent(component.parentId);
                        if (component) {
                            ids.add(component.id)
                        }
                    }
                }
            }

            return ids
        }

        return null
    }

    /**
     * Marks a component's VDOM update as "in-flight," meaning it has been sent to the
     * worker for processing.
     * @param {String} ownerId     The `id` of the component owning the update.
     * @param {Number} updateDepth The depth of the in-flight update.
     */
    registerInFlightUpdate(ownerId, updateDepth) {
        this.inFlightUpdateMap.set(ownerId, updateDepth);

        // Register this component as an in-flight descendant for all its parents
        const parentIds = Neo.manager.Component.getParentIds(Neo.getComponent(ownerId));

        for (let i = 0, len = parentIds.length; i < len; i++) {
            let parentId = parentIds[i],
                map      = this.descendantInFlightMap.get(parentId);

            if (!map) {
                map = new Map();
                this.descendantInFlightMap.set(parentId, map)
            }

            map.set(ownerId, true)
        }
    }

    /**
     * Registers a child's update request to be merged into its parent's update cycle.
     * This is called by a child component when it determines it can delegate its update
     * to an ancestor (see `VdomLifecycle.mergeIntoParentUpdate`).
     *
     * **Merging Logic:**
     * Merging reduces VDOM worker traffic by bundling multiple component updates into
     * a single message. The child effectively "cancels" its own standalone update and
     * piggybacks on the parent's pending update.
     *
     * @param {String} ownerId          The `id` of the parent component that will own the merged update.
     * @param {String} childId          The `id` of the child component requesting the merge.
     * @param {Number} childUpdateDepth The update depth required by the child.
     * @param {Number} distance         The component tree distance (number of levels) between the parent and child.
     */
    registerMerged(ownerId, childId, childUpdateDepth, distance) {
        let me   = this,
            item = me.mergedCallbackMap.get(ownerId);

        if (!item) {
            item = {ownerId, children: new Map()};
            me.mergedCallbackMap.add(item)
        }

        item.children.set(childId, {childUpdateDepth, distance})
    }

    /**
     * Queues a component update to be executed after another component's update is complete.
     * @param {String} ownerId     The `id` of the component to wait for.
     * @param {String} childId     The `id` of the component to update afterward.
     * @param {Function} [resolve] The Promise resolver to be called when the `childId`'s subsequent update finishes.
     */
    registerPostUpdate(ownerId, childId, resolve) {
        let me   = this,
            item = me.postUpdateQueueMap.get(ownerId);

        if (!item) {
            item = {ownerId, children: []};
            me.postUpdateQueueMap.add(item)
        }

        item.children.push({childId, resolve})
    }

    /**
     * Registers a callback to be executed for a component immediately after its current
     * VDOM update finishes, but before the next update cycle begins.
     * @param {String} id The component ID.
     * @param {Function} callback
     */
    registerPreUpdate(id, callback) {
        this.preUpdateMap.set(id, callback)
    }

    /**
     * Triggers all pending updates that were queued to run after the specified `ownerId`'s
     * update has completed.
     * @param {String} ownerId The `id` of the component whose update has just finished.
     */
    triggerPostUpdates(ownerId) {
        let me   = this,
            item = me.postUpdateQueueMap.get(ownerId),
            component;

        if (item) {
            for (let i = 0, len = item.children.length; i < len; i++) {
                let entry = item.children[i];
                component = Neo.getComponent(entry.childId);

                if (component) {
                    entry.resolve && me.addPromiseCallback(component.id, entry.resolve);
                    component.update()
                }
            }

            me.postUpdateQueueMap.remove(item)
        }
    }

    /**
     * Removes a component's update from the "in-flight" registry. This is called after
     * the VDOM worker confirms the update has been processed.
     * @param {String} ownerId The `id` of the component owning the update.
     */
    unregisterInFlightUpdate(ownerId) {
        this.inFlightUpdateMap.delete(ownerId);

        // Remove this component from the in-flight descendant maps of all its parents
        // We need to iterate all registered ancestors to ensure we catch cases where
        // the component moved (re-parented) during the update.
        for (const [parentId, map] of this.descendantInFlightMap) {
            if (map.has(ownerId)) {
                map.delete(ownerId);

                if (map.size === 0) {
                    this.descendantInFlightMap.delete(parentId)
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VDomUpdate));


/***/ },

/***/ "./src/mixin/DomEvents.mjs"
/*!*********************************!*\
  !*** ./src/mixin/DomEvents.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");



/**
 * A mixin providing DOM event handling capabilities to components.
 * This mixin is consumed by both Neo.component.Base and Neo.functional.component.Base
 * to enable consistent management of DOM event listeners across different component types.
 * @class Neo.mixin.DomEvents
 * @extends Neo.core.Base
 */
class DomEvents extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.mixin.DomEvents'
         * @protected
         */
        className: 'Neo.mixin.DomEvents',
        /**
         * An array of domListener configs
         * @member {Object[]|null} domListeners_=null
         * @example
         * afterSetStayOnHover(value, oldValue) {
         *     if (value) {
         *         let me = this;
         *
         *         me.addDomListeners(
         *             {mouseenter: me.onMouseEnter, scope: me},
         *             {mouseleave: me.onMouseLeave, scope: me}
         *         )
         *    }
         *}
         * @reactive
         */
        domListeners_: null
    }

    /**
     * Convenience shortcut to add additional dom listeners
     * @param {Object|Object[]} value
     */
    addDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let domListeners = this.domListeners;

        domListeners.push(...value);

        this.domListeners = domListeners
    }

    /**
     * Registers the domListeners inside the Neo.manager.DomEvent
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetDomListeners(value, oldValue) {
        let me = this;

        if (value?.[0] || oldValue?.[0]) {
            _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].updateDomListeners(me, value, oldValue)
        }
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Initializes DOM event listeners.
     */
    initDomEvents() {
        let me = this;
        if (me.domListeners?.length > 0) {
            // todo: the main thread reply of mount arrives after pushing the task into the queue which does not ensure the dom is mounted
            me.timeout(150).then(() => {
                _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mountDomListeners(me)
            }).catch(err => {
                if (err !== Neo.isDestroyed) {
                    throw err
                }
            })
        }
    }

    /**
     * Resets the mounted flag for local domEvent listeners
     */
    resetMountedDomEvents() {
        _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resetMountedDomListeners(this)
    }

    /**
     * Destroys DOM event listeners.
     */
    removeDomEvents() {
        this.domListeners = []
    }

    /**
     * @param {Array|Object} value
     */
    removeDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value];
        }

        let me             = this,
            {domListeners} = me,
            i, len;

        value.forEach(item => {
            i = 0;
            len = domListeners.length;

            for (; i < len; i++) {
                if (Neo.isEqual(item, domListeners[i])) {
                    domListeners.splice(i, 1);
                    break
                }
            }
        });

        me.domListeners = domListeners
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvents));


/***/ },

/***/ "./src/mixin/VdomLifecycle.mjs"
/*!*************************************!*\
  !*** ./src/mixin/VdomLifecycle.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/vdom/TreeBuilder.mjs */ "./src/util/vdom/TreeBuilder.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../manager/VDomUpdate.mjs */ "./src/manager/VDomUpdate.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");








const {currentWorker} = Neo;

/**
 * @class Neo.mixin.VdomLifecycle
 * @extends Neo.core.Base
 */
class VdomLifecycle extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.mixin.VdomLifecycle'
         * @protected
         */
        className: 'Neo.mixin.VdomLifecycle',
        /**
         * True automatically initializes the vnode of a component after being created inside the init call.
         * Recommended for dialogs & drag-proxies.
         * Top level views should definitely use false.
         * @member {Boolean} autoInitVnode=false
         */
        autoInitVnode: false,
        /**
         * True automatically mounts a component after being rendered.
         * Use this for the top level component of your app.
         * @member {Boolean} autoMount=false
         */
        autoMount: false,
        /**
         * Internal flag which will get set to true while an update request (worker messages) is in progress
         * @member {Boolean} isVdomUpdating_=false
         * @protected
         * @reactive
         */
        isVdomUpdating_: false,
        /**
         * True in case the component is initializing the vnode
         * @member {Boolean} isVnodeInitializing_=false
         * @protected
         * @reactive
         */
        isVnodeInitializing_: false,
        /**
         * True in case the component is mounted to the DOM
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * Internal flag which will get set to true in case an update call arrives while another update is running
         * @member {Boolean} needsVdomUpdate_=false
         * @protected
         * @reactive
         */
        needsVdomUpdate_: false,
        /**
         * Set this to true for bulk updates. Ensure to set it back to false afterwards.
         * Internally the value will get saved as a number to ensure that child methods won't stop the silent mode too early.
         * @member {Boolean} silentVdomUpdate_=false
         * @reactive
         */
        silentVdomUpdate_: false,
        /**
         * Defines the depth of the vdom tree for the next update cycle.
         * - The value 1 will only send the current vdom structure as it is
         * - The value of 2 will include the vdom of direct children
         * - The value of 3 will include the vdom of grandchildren
         * - The value of -1 will include the full tree of any depth
         * @member {Number} updateDepth_=1
         * @reactive
         */
        updateDepth_: 1,
        /**
         * The component vnode tree. Available after the component got vnodeInitialized.
         * @member {Object} vnode_=={[isDescriptor]: true, value: null, isEqual: (a, b) => a === b,}
         * @protected
         * @reactive
         */
        vnode_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_6__.isDescriptor]: true,
            clone         : 'none',
            cloneOnGet    : 'none',
            isEqual       : (a, b) => a === b, // vnode trees can be huge, and will get compared by the vdom worker.
            value         : null,
        },
        /**
         * True after the component initVnode() method was called. Also fires the vnodeInitialized event.
         * @member {Boolean} vnodeInitialized_=false
         * @protected
         * @reactive
         */
        vnodeInitialized_: false
    }

    /**
     * Triggered after the vdom pseudo-config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVdom(value, oldValue) {
        this.updateVdom()
    }

    /**
     * Triggered after the vnode config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVnode(value, oldValue) {
        value && this.syncVnodeTree()
    }

    /**
     * Triggered after the vnodeInitialized config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetVnodeInitialized(value, oldValue) {
        let me = this;

        if (value) {
            me.fire('vnodeInitialized', me.id);

            if (me.needsVdomUpdate) {
                me.update()
            }
        }
    }

    /**
     * Creates a lightweight, serializable placeholder for this component, intended for injection
     * into the VDOM of other components.
     *
     * This is the **only recommended way** to nest a component within another component's VDOM tree.
     * Directly embedding one component's full `vdom` object into another's is an anti-pattern
     * that violates the principle of scoped VDOM, leading to unpredictable rendering behavior
     * and making updates inefficient.
     *
     * At its core, the returned object contains a `componentId` that uniquely identifies the
     * component instance. In cases where a component's structure is wrapped by another element
     * (e.g., a Button in a Table Header being wrapped by a `<td>`), the reference will also
     * include the wrapper's `id`. This happens when a component uses `getVdomRoot()` to
     * designate a deeper node as its logical root, causing the component's `id` and its
     * VDOM root's `id` to differ. The framework uses this dual-ID reference to correctly
     * assemble the final VDOM tree.
     *
     * @returns {{componentId: String, id: String|undefined}} The VDOM reference object.
     */
    createVdomReference() {
        let me        = this,
            reference = {componentId: me.id},
            vdomId    = me.vdom.id;

        if (vdomId && me.id !== vdomId) {
            reference.id = vdomId
        }

        return reference
    }

    /**
     * Ensures that the root VDOM node and its wrapper (if any) have stable, unique IDs
     * derived from the component instance ID. This prevents auto-generated ID collisions
     * in `ComponentManager.wrapperNodes`.
     * @protected
     */
    ensureStableIds() {
        const
            me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot();

        if (vdomRoot) {
            vdomRoot.id = me.id;

            if (vdom !== vdomRoot) {
                vdom.id = me.id + '__wrapper'
            }
        }
    }

    /**
     * Internal method to send update requests to the vdom worker.
     *
     * **Teleportation / Batched Disjoint Updates:**
     * This method implements the core logic for "Teleportation". Instead of merging child updates
     * into the parent's VDOM tree (which requires expanding the parent's tree to reach the child),
     * we collect all merged child updates and send them as a **batch of disjoint payloads**.
     *
     * 1. **Recursive Collection:** We recursively collect all `mergedChildIds` from the component
     *    and its descendants.
     * 2. **Disjoint Payloads:** For each component in the batch, we generate a "self-only" VDOM
     *    payload (`updateDepth: 1`). This allows the VDOM engine to update the child directly
     *    without needing the parent to "bridge" to it.
     * 3. **Collision Filtering:** We filter out child updates that are already covered by a
     *    parent update in the same batch (e.g., if the parent is doing a full tree update).
     *
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @private
     */
    async executeVdomUpdate(resolve, reject) {
        let me = this;

        resolve && _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addPromiseCallback(me.id, resolve);

        me.isVdomUpdating = true;
        // Centralize in-flight state
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerInFlightUpdate(me.id, me.updateDepth);

        try {
            // We need to ensure that the task queue is empty before collecting payloads.
            // This is critical for cases where a component state change (triggering update)
            // is followed immediately by a structural change (e.g. remove) in the same tick.
            // Using setTimeout forces a Macrotask yield, ensuring all sync operations complete.
            await new Promise(resolve => setTimeout(resolve, 1));

            const
                updates                 = {},
                depths                  = new Map(),
                processed               = new Set(), // Prevent duplicates and cycles
                componentMergedChildren = new Map(); // Snapshot of merged children processed in this batch

            const collectPayloads = (componentId) => {
                if (processed.has(componentId)) return;
                processed.add(componentId);

                const component = Neo.getComponent(componentId);
                if (!component || component.isDestroyed) return;

                // Skip unmounted components. They will be expanded by the Parent's TreeBuilder
                // and handled via the Parent's resolveVdomUpdate -> syncVnodeTree.
                if (!component.vnode) return;

                // IMPORTANT: In a multi-window SharedWorker environment, we must NOT batch
                // updates from components that have moved to a different window.
                // Doing so would cause deltas meant for Window B to be sent to Window A.
                if (component.windowId !== me.windowId) return;

                // For every component, we check its own merged children
                const mergedChildIds = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getMergedChildIds(componentId);

                // Track depth for collision filtering
                depths.set(componentId, component.updateDepth);

                // Snapshot the merged children we are about to process.
                // This prevents race conditions where a child merges *after* collection but *before* resolution,
                // causing it to be acknowledged/cleared without actually being updated.
                if (mergedChildIds) {
                    componentMergedChildren.set(componentId, mergedChildIds);
                }

                // Generate payload for this component.
                // - Depth 1 (Teleportation): Pass ids=null to force disjoint/pruned payload.
                // - Depth > 1 (Hybrid): Pass ids=mergedChildIds to enable Sparse Tree generation (pruning clean siblings).
                //   Note: Depth -1 (Full Tree) ignores ids and is always Dense.
                const ids = component.updateDepth !== 1 ? mergedChildIds : null;

                // We pass null as the second arg to respect the component's configured updateDepth.
                updates[componentId] = component.getVdomUpdatePayload(ids, null);

                // Recursively collect merged children
                if (mergedChildIds) {
                    for (const childId of mergedChildIds) {
                        collectPayloads(childId)
                    }
                }
            };

            // Start collection from the root of the update (me)
            collectPayloads(me.id);

            // Collision Filtering:
            // If a parent update covers this child, remove the child from the disjoint batch
            for (const id in updates) {
                if (Object.hasOwn(updates, id)) {
                    let parent   = Neo.getComponent(id)?.parent,
                        distance = 1;

                    while (parent) {
                        if (updates[parent.id]) {
                            const parentDepth = depths.get(parent.id);
                            // If parent covers this child, remove the child from the disjoint batch
                            if (parentDepth === -1 || parentDepth > distance) {
                                delete updates[id];
                                break; // exit the while loop
                            }
                        }
                        parent   = parent.parent;
                        distance++
                    }
                }
            }

            const batchData = {updates};

            // CRITICAL: SharedWorker Context Injection
            // This block MUST NOT be removed or simplified.
            // In a SharedWorker environment, the VDOM worker needs to know WHICH window
            // initiated the update to route the reply and DOM deltas correctly.
            // Without `windowId` and `appName`, `RemoteMethodAccess` cannot determine the target,
            // causing cross-window operations (like dragging a component to a new window) to fail silently.
            if (currentWorker?.isSharedWorker) {
                batchData.appName  = me.appName;
                batchData.windowId = me.windowId
            }

            const response = await Promise.resolve(Neo.vdom.Helper.updateBatch(batchData));

            // Component could be destroyed while the update is running
            if (me.id) {
                // When not using a VdomWorker, we need to apply the deltas inside the App worker
                if (!Neo.config.useVdomWorker && response.deltas?.length > 0) {
                    await Neo.applyDeltas(me.windowId, response.deltas)
                }

                // Distribute results back to ALL components in the batch
                for (const id in response.vnodes) {
                    if (Object.hasOwn(response.vnodes, id)) {
                        const vnode = response.vnodes[id];
                        const component = Neo.getComponent(id);

                        if (component && !component.isDestroyed) {
                            component.vnode = vnode;

                            // Resolve the update for this component and its merged children
                            // Note: response.deltas contains the aggregated deltas for the whole batch
                            component.resolveVdomUpdate({
                                deltas: response.deltas,
                                vnode
                            }, componentMergedChildren.get(id));
                        }
                    }
                }
            }
        } catch (err) {
            me.isVdomUpdating = false;
            // Ensure state is cleaned up on error
            _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].unregisterInFlightUpdate(me.id);
            reject?.(err)
        }
    }

    /**
     * Honors different item roots for mount / render OPs
     * @returns {String}
     */
    getMountedParentId() {
        let parentId  = this.parentId,
            parent    = Neo.getComponent(parentId),
            itemsRoot = parent?.getVdomItemsRoot?.();

        return itemsRoot ? itemsRoot.id : parentId
    }

    /**
     * Calculate the real parentIndex inside the DOM
     * @returns {Number|undefined}
     */
    getMountedParentIndex() {
        let parent = this.parent,
            items  = parent?.items || [],
            i      = 0,
            index  = 0,
            len    = items.length,
            item;

        for (; i < len; i++) {
            item = items[i];

            if (item === this) {
                return index
            }

            if (!item.hidden && item.hideMode === 'removeDom') {
                index++
            }
        }
    }

    /**
     * Generates the update payload for this component.
     * @param {Set<String>|null} mergedChildIds
     * @param {Number} [depth] Override the update depth
     * @returns {Object} opts
     */
    getVdomUpdatePayload(mergedChildIds, depth) {
        let me = this,
            updateDepth = depth ?? me.updateDepth,
            {vdom, vnode} = me,
            opts = {
                vdom : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(vdom,   updateDepth, mergedChildIds),
                vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVnodeTree(vnode, updateDepth, mergedChildIds)
            };

        if (currentWorker?.isSharedWorker) {
            opts.appName  = me.appName;
            opts.windowId = me.windowId
        }

        // We cannot set the config directly => it could already be false,
        // and we still want to pass it further into subtrees
        me._needsVdomUpdate = false;
        me.afterSetNeedsVdomUpdate?.(false, true);

        // Reset the updateDepth to the default value for the next update cycle
        me._updateDepth = me.constructor.config.updateDepth;

        return opts
    }

    /**
     * Search a vdom child node by id for a given vdom tree
     * @param {String} id
     * @param {Object} vdom=this.vdom
     * @returns {Object}
     */
    getVdomChild(id, vdom=this.vdom) {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(vdom, id)?.vdom
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode
    }

    /**
     * Checks if a child update can be merged into a parent update.
     *
     * **Merge Strategy (Optimization):**
     * We allow merging regardless of distance (Teleportation).
     * The `executeVdomUpdate` logic will distinguish between Connected (merged into tree)
     * and Disjoint (batched separately) updates.
     *
     * @param {Number} updateDepth
     * @param {Number} distance
     * @returns {Boolean}
     */
    canMergeUpdate(updateDepth, distance) {
        return true
    }

    /**
     * Checks if a given updateDepth & distance would result in an update collision.
     * The check must use `<` because `updateDepth` is 1-based.
     *
     * **Scoped VDOM Update Rationale:**
     * - `updateDepth: 1` means the update is scoped to the component itself.
     * - The Parent's VDOM payload naturally contains only its own structure and **reference nodes**
     *   (placeholders) for its children (e.g. `{componentId: '...'}`).
     * - At Depth 1, these references are **not expanded** into the children's full VDOM trees.
     * - Therefore, a Parent (Depth 1) update and a Child update operate on **disjoint** sets of DOM nodes.
     * - They **do not collide** and **should not merge**. They should run as independent, parallel updates.
     *
     * - A direct child is at `distance: 1`.
     * Therefore, an update with depth 1 should NOT collide with a child at distance 1 (1 < 1 is false).
     *
     * @param {Number} updateDepth
     * @param {Number} distance
     * @returns {Boolean}
     */
    hasUpdateCollision(updateDepth, distance) {
        return updateDepth === -1 ? true : distance < updateDepth
    }

    /**
     * Creates the vnode tree for this component and mounts the component in case
     * - you pass true for the mount param
     * - or the autoMount config is set to true
     * @param {Boolean} [mount] Mount the DOM after the vnode got created
     * @returns {Promise<any>} If getting there, we return the data from vdom.Helper: create(), containing the vnode.
     */
    async initVnode(mount) {
        let me        = this,
            autoMount = mount || me.autoMount,
            {app}     = me,
            {allowVdomUpdatesInTests, unitTestMode, useVdomWorker} = Neo.config;

        if (unitTestMode && !allowVdomUpdatesInTests) return;

        // Verify that the critical rendering path => CSS files for the new tree is in place
        if (!unitTestMode && autoMount && currentWorker.countLoadingThemeFiles !== 0) {
            currentWorker.on('themeFilesLoaded', function() {
                !me.mounted && me.initVnode(mount)
            }, me, {once: true});

            return
        }

        me.isVnodeInitializing = true;

        if (!app.vnodeInitialized) {
            app.isVnodeInitializing = true
        }

        try {
            if (me.vdom) {
                me.isVdomUpdating = true;

                me.ensureStableIds();

                // Ensure child components do not trigger updates while the vnode generation is in progress
                _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerInFlightUpdate(me.id, -1);

                delete me.vdom.removeDom;

                me._needsVdomUpdate = false;
                me.afterSetNeedsVdomUpdate?.(false, true);

                const data = await Promise.resolve(Neo.vdom.Helper.create({
                    appName    : me.appName,
                    autoMount,
                    parentId   : autoMount ? me.getMountedParentId()    : undefined,
                    parentIndex: autoMount ? me.getMountedParentIndex() : undefined,
                    vdom       : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(me.vdom, -1),
                    windowId   : me.windowId
                }));

                me.onInitVnode(data.vnode, useVdomWorker ? autoMount : false);

                if (autoMount && !useVdomWorker) {
                    // When running without a VdomWorker, Helper.create is local and returns a plain object.
                    // We must manually send the insertNode delta to the main thread.
                    await Neo.applyDeltas(me.windowId, [{
                        action   : 'insertNode',
                        id       : me.id,
                        index    : me.getMountedParentIndex(),
                        outerHTML: data.outerHTML,
                        parentId : me.getMountedParentId(),
                        vnode    : data.vnode
                    }]);

                    me.mounted = true
                }

                if (!data.deltas) {
                    data.deltas = []
                }

                me.resolveVdomUpdate(data);

                return data
            }
        } catch (err) {
            console.error('initVnode error', err, me.id);
            throw err
        }
    }

    /**
     * Synchronization Guard: Checks if any descendant component is currently updating its VDOM.
     *
     * If a descendant is in-flight, this method registers a post-update callback on the
     * blocking descendant and returns `true`, signaling the caller (`updateVdom`) to yield.
     * This prevents the Parent from starting an update that might overwrite or conflict
     * with the Child's concurrent work, effectively serializing the updates.
     *
     * @param {Function} [resolve] Gets passed by updateVdom() to be called after the blocking update finishes.
     * @returns {Boolean} True if a child update conflict exists (Parent should yield).
     */
    isChildUpdating(resolve) {
        let me = this;

        if (_manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].hasInFlightDescendants(me.id)) {
            let map          = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].descendantInFlightMap.get(me.id),
                descendantId = map.keys().next().value;

            if (Neo.config.logVdomUpdateCollisions) {
                console.warn('vdom child update conflict with:', descendantId, 'for:', me)
            }

            _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerPostUpdate(descendantId, me.id, resolve);
            return true
        }

        return false
    }

    /**
     * Checks for vdom updates inside the parent chain and if found.
     * Registers the component for a vdom update once done.
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] Gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean}
     */
    isParentUpdating(parentId=this.parentId, resolve, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                if (parent.isVdomUpdating) {
                    // Get the in-flight update depth from the central manager
                    const parentUpdateDepth = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getInFlightUpdateDepth(parent.id);

                    if (me.hasUpdateCollision(parentUpdateDepth, distance)) {
                        if (Neo.config.logVdomUpdateCollisions) {
                            console.warn('vdom parent update conflict with:', parent, 'for:', me)
                        }

                        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerPostUpdate(parent.id, me.id, resolve);
                        return true
                    }

                    // If an update is running and does not have a collision, we do not need to check further parents
                    return false
                }

                return me.isParentUpdating(parent.parentId, resolve, distance+1)
            }
        }

        return false
    }

    /**
     * Traverses the parent chain to find an ancestor that is pending a VDOM update.
     * If found, and if the update scope allows (see `canMergeUpdate`), this component's
     * update is merged into the ancestor's cycle.
     *
     * **Recursive Traversal:**
     * This method recursively walks up the component tree (`distance + 1`). This enables
     * transitive merging (Grandchild -> Child -> Parent) and merging into ancestors even
     * if intermediate parents are not updating.
     *
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean} True if the update was successfully merged.
     */
    mergeIntoParentUpdate(parentId=this.parentId, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                // We are checking for parent.updateDepth, since we care about the depth of the next update cycle
                if (parent.needsVdomUpdate && me.canMergeUpdate(parent.updateDepth, distance)) {
                    _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerMerged(parent.id, me.id, me.updateDepth, distance);
                    return true
                }

                return me.mergeIntoParentUpdate(parent.parentId, distance+1)
            }
        }

        return false
    }

    /**
     * Gets called from the initVnode() promise success handler
     * @param {Object} vnode
     * @param {Boolean} autoMount Mount the DOM after the vnode got created
     * @protected
     */
    onInitVnode(vnode, autoMount) {
        let me    = this,
            {app} = me;

        me.isVnodeInitializing = false;

        // if app is a check to see if the Component got destroyed while vnodeInitialising => before onInitVnode got triggered
        if (app) {
            if (!app.vnodeInitialized) {
                app.isVnodeInitializing = false;
                app.vnodeInitialized = true;
                app.fire('vnodeInitialized')
            }

            me.vnode = vnode;

            let childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildIds(vnode),
                i        = 0,
                len      = childIds.length,
                child;

            for (; i < len; i++) {
                child = Neo.getComponent(childIds[i]);

                if (child) {
                    child.vnodeInitialized = true
                }
            }

            me.vnodeInitialized = true;

            if (autoMount) {
                me.mounted = true;

                if (!app.mounted) {
                    app.mounted = true;
                    app.fire('mounted')
                }
            }
        }
    }

    /**
     * @returns {Promise<any>}
     */
    promiseUpdate() {
        let me = this;

        return new Promise((resolve, reject) => {
            const id = Symbol();

            me.registerAsync(id, reject);

            me.updateVdom(
                (val) => {me.unregisterAsync(id); resolve(val)},
                (err) => {me.unregisterAsync(id); reject(err)}
            )
        })
    }

    /**
     * Internal helper fn to resolve the Promise for updateVdom()
     * @param {Object} [data] The return value of vdom.Helper.update()
     * @param {Set<String>|null} [mergedChildIds] IDs of children included in this update
     * @protected
     */
    resolveVdomUpdate(data, mergedChildIds) {
        let me = this;

        me.isVdomUpdating = false;

        // Execute callbacks for merged updates
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].executeCallbacks(me.id, data, mergedChildIds);

        // The update is no longer in-flight
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].unregisterInFlightUpdate(me.id);

        // Trigger updates for components that were in-flight
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].triggerPostUpdates(me.id);

        // Execute callbacks which wanted to run before the next update cycle
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].executePreUpdates(me.id);

        if (me.needsVdomUpdate) {
            // any new promise callbacks will get picked up by the next update cycle
            me.update()
        }
    }

    /**
     * Placeholder method for util.VDom.syncVdomState to allow overriding (disabling) it
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     * @param {Object} [vdom=this.vdom]
     * @param {Boolean} force=false
     */
    syncVdomState(vnode=this.vnode, vdom=this.vdom, force=false) {
        _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].syncVdomState(vnode, vdom, force)
    }

    /**
     * In case a component receives a new vnode, we want to do:
     * - sync the vdom ids
     * - setting vnodeInitialized to true for child components
     * - updating the parent component to ensure that the vnode tree stays persistent
     *
     * **Implementation Detail:**
     * This method uses a two-pass strategy to handle child updates:
     * 1. **Update Visible Children:** We iterate over children found directly in the new VNode structure
     *    (via `ComponentManager.getChildren`). This preserves the baseline behavior where fully expanded
     *    VNode trees (e.g., from `Helper.create`) are synced without unnecessary "downgrading" to references.
     * 2. **Unmount Missing Children:** We iterate over ALL logical children (via `ComponentManager.find`)
     *    to detect any that are absent from the new VNode tree (e.g., `removeDom: true`).
     *    Crucially, we use `VNodeUtil.find` to distinguish between a "Placeholder" (valid, do nothing)
     *    and a "Removal" (invalid, unmount).
     *
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     */
    syncVnodeTree(vnode=this.vnode) {
        let me              = this,
            childComponents = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildren(me),
            debug           = false,
            map             = {},
            childVnode, start;

        if (debug) {
            start = performance.now()
        }

        me.syncVdomState();

        if (vnode && me.id !== vnode.id) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].registerWrapperNode(vnode.id, me)
        }

        // we need one separate iteration first to ensure all wrapper nodes get registered
        for (let i = 0, len = childComponents.length; i < len; i++) {
            let component = childComponents[i];
            childVnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vnode, component.vdom.id)?.vnode;

            if (childVnode) {
                map[component.id] = childVnode;

                if (component.id !== childVnode.id) {
                    _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].registerWrapperNode(childVnode.id, component)
                }
            }
        }

        // delegate the latest node updates to all possible child components found inside the vnode tree
        for (let i = 0, len = childComponents.length; i < len; i++) {
            let component = childComponents[i];
            childVnode = map[component.id];

            if (childVnode) {
                // silent update
                component._vnode = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addVnodeComponentReferences(childVnode, component.id);

                component.vnodeInitialized = true;
                component.mounted          = true
            } else {
                console.warn('syncVnodeTree: Could not replace the child vnode for', component.id)
            }
        }

        // New logic to handle unmounting of removed children
        let directChildren = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getDirectChildren(me.id);
        for (let i = 0, len = directChildren.length; i < len; i++) {
            let component = directChildren[i];
            if (!childComponents.includes(component)) {
                childVnode = null;

                // Check if it exists in the tree (as placeholder)
                // We use VNodeUtil.find which resolves placeholders
                if (me.vnode) {
                    childVnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vnode, component.vdom.id)?.vnode
                }

                if (!childVnode && !component.floating) {
                    component._vnode = null;
                    component.mounted = false
                }
            }
        }

        // silent update
        me._vnode = vnode ? _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addVnodeComponentReferences(vnode, me.id) : null;

        debug && console.log('syncVnodeTree', me.id, performance.now() - start)
    }

    /**
     *
     */
    update() {
        this.afterSetVdom(this.vdom, null)
    }

    /**
     * Gets called after the vdom config gets changed in case the component is already mounted (delta updates).
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @protected
     */
    updateVdom(resolve, reject) {
        if (!this.isConstructed) {
            resolve?.();
            return
        }

        let me                         = this,
            {mounted, parentId, vnode} = me,
            {config}                   = Neo;

        if (config.unitTestMode && !config.allowVdomUpdatesInTests) {
            reject?.();
            return
        }

        me.ensureStableIds();

        // If there's a promise, register it against this component's ID immediately.
        // The manager will ensure it's called when the appropriate update cycle completes.
        resolve && _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addPromiseCallback(me.id, resolve);

        // Attempt to merge into a parent's update cycle.
        // We do this even if silent, to ensure we catch the bus if a parent is departing.
        if (me.mergeIntoParentUpdate(parentId)) {
            me.needsVdomUpdate = true;
            return
        }

        if (me.isVdomUpdating || !me.vnodeInitialized || me.silentVdomUpdate) {
            me.needsVdomUpdate = true
        } else {
            // If an update is triggered on an unmounted component, we must wait for it to be mounted.
            if (!mounted) {
                // Use a flag to prevent setting up multiple `then` listeners for subsequent updates
                // that might arrive before the component is mounted.
                if (!me.isAwaitingMount) {
                    me.isAwaitingMount = true;
                    me.mountedPromise.then(() => {
                        me.isAwaitingMount = false;
                        // After mounting, re-trigger the update cycle. The cached callbacks will be picked up.
                        me.vnode && me.update();
                    });
                }
            }
            else {
                if (
                    !me.isParentUpdating(parentId, resolve)
                    && !me.isChildUpdating(resolve)
                    && vnode
                ) {
                    // Check for merged child updates and adjust the update depth accordingly
                    // let adjustedDepth = VDomUpdate.getAdjustedUpdateDepth(me.id);
                    //
                    // if (adjustedDepth !== null) {
                    //     me.updateDepth = adjustedDepth;
                    // }

                    // Verify that the critical rendering path => CSS files for the new tree is in place
                    if (!config.isMiddleware && !config.unitTestMode && currentWorker.countLoadingThemeFiles !== 0) {
                        currentWorker.on('themeFilesLoaded', function() {
                            me.updateVdom(resolve, reject)
                        }, me, {once: true})
                    } else {
                        me.executeVdomUpdate(null, reject)
                    }
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VdomLifecycle));


/***/ },

/***/ "./src/util/KeyNavigation.mjs"
/*!************************************!*\
  !*** ./src/util/KeyNavigation.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.util.KeyNavigation
 * @extends Neo.core.Base
 */
class KeyNavigation extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.KeyNavigation'
         * @protected
         */
        className: 'Neo.util.KeyNavigation',
        /**
         * @member {String} ntype='keynav'
         * @protected
         */
        ntype: 'keynav',
        /**
         * Internally stores the component id inside _component
         * @member {Neo.component.Base|null} component_=null
         * @reactive
         */
        component_: null,
        /**
         * Set this to true in case the keydown event is supposed to bubble upwards inside the component tree
         * @member {Boolean} keyDownEventBubble=false
         */
        keyDownEventBubble: false,
        /**
         * @member {Array|null} keys_=null
         * @reactive
         */
        keys_: null
    }

    add(value) {
        this._keys.push(...this.parseKeys(value))
    }

    /**
     * @protected
     * @returns {Neo.component.Base}
     */
    beforeGetComponent() {
        return Neo.getComponent(this._component)
    }

    /**
     * @param {Neo.component.Base} value
     * @protected
     * @returns {String} the component id
     */
    beforeSetComponent(value) {
        return value?.id
    }

    /**
     *
     */
    destroy() {
        this.unregister();
        super.destroy()
    }

    /**
     * @param {Object} data
     */
    onKeyDown(data) {
        // Using the chrome auto-fill feature does trigger a keydown event, not containing a key. See: #64
        if (data.key) {
            let me           = this,
                upperCaseKey = data.key.toUpperCase(),
                scope;

            upperCaseKey = me.parseUpperCaseKey(upperCaseKey);

            me.keys.forEach(key => {
                scope = Neo.isString(key.scope) ? Neo.get(key.scope) : key.scope;

                if (key.key.toUpperCase() === upperCaseKey) {
                    if (Neo.isFunction(key.fn)) {
                        key.fn.apply(scope, [data, me.component])
                    } else {
                        scope[key.fn]?.apply(scope, [data, me.component])
                    }
                }
            })
        }
    }

    /**
     * @param {Object} value
     * @returns {Object}
     */
    parseKeys(value) {
        if (!Array.isArray(value)) {
            let componentId = this._component,
                keyArray    = [];

            if (componentId) {
                Object.entries(value).forEach(([key, val]) => {
                    if (key !== 'scope') {
                        keyArray.push({
                            fn   : val,
                            key,
                            scope: value.scope || componentId // todo: support VCs later on
                        })
                    }
                });

                value = keyArray
            }
        }

        return value
    }

    /**
     * Replaces specific key names, e.g. " " => SPACE
     * @param {String} key
     * @protected
     * @returns {String}
     */
    parseUpperCaseKey(key) {
        switch (key) {
            case ' ':
                key = 'SPACE';
                break
            case 'ARROWDOWN':
                key = 'DOWN';
                break
            case 'ARROWLEFT':
                key = 'LEFT';
                break
            case 'ARROWRIGHT':
                key = 'RIGHT';
                break
            case 'ARROWUP':
                key = 'UP';
                break
        }

        return key
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me = this;

        me.component = component;
        me.keys      = me.parseKeys(me.keys);

        component.addDomListeners({
            keydown: {
                bubble: me.keyDownEventBubble,
                fn    : me.onKeyDown,
                scope : me
            }
        })
    }

    /**
     * Remove a key listener using the same config used when creating it
     * @param {Object} config
     */
    removeKey(config) {
        let me   = this,
            keys = me._keys,
            i    = 0,
            len  = keys.length,
            key;

        for (; i < len; i++) {
            key = keys[i];

            if (Neo.isEqual(key, config)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(keys, key);
                break
            }
        }
    }

    /**
     * Remove multiple key listeners passing an array of config items
     * @param {Array} items
     */
    removeKeys(items) {
        Array.isArray(items) && items.forEach(item => this.removeKey(item))
    }

    /**
     *
     */
    unregister() {
        // todo: remove the dom listener from the owner component
    }

    /**
     * Serializes the KeyNavigation into a JSON-compatible object.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            component: me.serializeConfig(me.component),
            keys     : me.serializeConfig(me.keys)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(KeyNavigation));


/***/ },

/***/ "./src/util/Style.mjs"
/*!****************************!*\
  !*** ./src/util/Style.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Style
 * @extends Neo.core.Base
 */
class Style extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Style'
         * @protected
         */
        className: 'Neo.util.Style'
    }

    /**
     * Creates an delta object, containing the styles of newStyle which are not included or different than in oldStyle
     * Styles included in oldStyle but missing in newStyle will get a value of null
     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
     * @param {Object|String} newStyle
     * @param {Object|String} oldStyle
     * @returns {Object} style delta
     */
    static compareStyles(newStyle, oldStyle) {
        let styles = {};

        if (Neo.isString(newStyle)) {
            newStyle = Neo.createStyleObject(newStyle)
        }

        if (Neo.isString(oldStyle)) {
            oldStyle = Neo.createStyleObject(oldStyle)
        }

        if (!newStyle && !oldStyle) {
            return null
        } else if (!oldStyle) {
            return Neo.clone(newStyle)
        } else {
            newStyle && Object.keys(newStyle).forEach(style => {
                if (!oldStyle.hasOwnProperty(style) || oldStyle[style] !== newStyle[style]) {
                    styles[style] = newStyle[style]
                }
            });

            Object.keys(oldStyle).forEach(style => {
                if (!newStyle  || !newStyle.hasOwnProperty(style)) {
                    styles[style] = null
                }
            });

            if (Object.keys(styles).length > 0) {
                return styles
            }

            return null
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Style));


/***/ },

/***/ "./src/util/vdom/TreeBuilder.mjs"
/*!***************************************!*\
  !*** ./src/util/vdom/TreeBuilder.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * A singleton utility class responsible for recursively building VDOM and VNode trees.
 * It can expand component references within a tree structure into their full VDOM/VNode representations,
 * supporting selective (asymmetric) tree expansion for optimized updates.
 * @class Neo.util.vdom.TreeBuilder
 * @extends Neo.core.Base
 * @singleton
 */
class TreeBuilder extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.vdom.TreeBuilder'
         * @protected
         */
        className: 'Neo.util.vdom.TreeBuilder',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Private helper to recursively build a tree, abstracting the child node key.
     * @param {Object} node The vdom or vnode to process.
     * @param {Number} depth The current recursion depth.
     * @param {Set<String>|null} mergedChildIds A set of component IDs to selectively expand.
     * @param {String} childKey The property name for child nodes ('cn' or 'childNodes').
     * @returns {Object}
     * @private
     */
    #buildTree(node, depth, mergedChildIds, childKey) {
        // We can not use Neo.isObject() here, since inside unit-test scenarios, we will import vdom.Helper into main threads.
        // Inside this scenario, Neo.isObject() returns false for VNode instances
        if (typeof node !== 'object' || node === null) {
            return node
        }

        // JIT ID Generation (App Authority)
        // If we are processing a VDOM tree (childKey === 'cn') and the node has no ID,
        // we must generate one now to ensure deterministic identity before the VDOM leaves the App Worker.
        if (childKey === 'cn' && !node.id) {
            node.id = Neo.getId(node.vtype === 'text' ? 'vtext' : 'vnode')
        }

        let output = {...node}; // Shallow copy

        if (node[childKey]) {
            output[childKey] = [];

            for (let i = 0, len = node[childKey].length; i < len; i++) {
                let item        = node[childKey][i],
                    currentItem = item,
                    childDepth;

                if (currentItem.componentId) {
                    const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(currentItem.componentId);

                    // Sparse Tree Generation & Scoped Updates
                    // We prune the branch (send a placeholder) if:
                    // 1. We are at the depth boundary (depth === 1) AND it's not a merged update.
                    // 2. We are in a Merged Update (mergedChildIds exists) AND this component is not in the AllowList (not dirty/bridge).
                    // Exception: We never prune if depth is -1 (Full Tree) or if the component is not mounted yet.
                    if (depth !== -1 && component?.vnode) {
                        const isExpandable = mergedChildIds?.has(currentItem.componentId);

                        if ((depth === 1 && !isExpandable) || (mergedChildIds && !isExpandable)) {
                            output[childKey].push({...currentItem, neoIgnore: true});
                            continue // Stop processing this branch, move to next item
                        }
                    }

                    // Expand the branch if it's part of a merged update, or if the depth requires it, OR if the vnode is missing
                    if (depth > 1 || depth === -1 || mergedChildIds?.has(currentItem.componentId) || !component?.vnode) {
                        // Use the correct tree type based on the childKey
                        const componentTree = childKey === 'cn' ? component?.vdom : component?.vnode;
                        if (componentTree) {
                            currentItem = componentTree
                        }
                    }
                }

                if (item.componentId) {
                    childDepth = (depth === -1) ? -1 : Math.max(0, depth - 1)
                } else {
                    childDepth = depth
                }

                output[childKey].push(this.#buildTree(currentItem, childDepth, mergedChildIds, childKey))
            }
        }

        return output
    }


    /**
     * Copies a given vdom tree and replaces child component references with their vdom.
     * @param {Object} vdom
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVdomTree(vdom, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vdom, depth, mergedChildIds, 'cn')
    }

    /**
     * Copies a given vnode tree and replaces child component references with their vnode.
     * @param {Object} vnode
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVnodeTree(vnode, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vnode, depth, mergedChildIds, 'childNodes')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeBuilder));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDTztBQUNDO0FBQ0Y7QUFDQTtBQUNJO0FBQ0Q7QUFDUjtBQUNROztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBSTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQVk7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0EsaUJBQWlCLDREQUFTLEVBQUUsNERBQVUsRUFBRSxnRUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNB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aUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixVQUFVOztBQUVoQztBQUNBOztBQUVBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyw4REFBZ0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDJCQUEyQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvQWJzdHJhY3QubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9WRG9tVXBkYXRlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21peGluL0RvbUV2ZW50cy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9taXhpbi9WZG9tTGlmZWN5Y2xlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvS2V5TmF2aWdhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL1N0eWxlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvdmRvbS9UcmVlQnVpbGRlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IERvbUV2ZW50cyAgICAgICAgZnJvbSAnLi4vbWl4aW4vRG9tRXZlbnRzLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBWZG9tTGlmZWN5Y2xlICAgIGZyb20gJy4uL21peGluL1Zkb21MaWZlY3ljbGUubWpzJztcbmltcG9ydCBWRG9tVXBkYXRlICAgICAgIGZyb20gJy4uL21hbmFnZXIvVkRvbVVwZGF0ZS5tanMnO1xuaW1wb3J0IFZOb2RlVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WTm9kZS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbmNvbnN0XG4gICAgY2xvc2VzdENvbnRyb2xsZXIgICA9IFN5bWJvbC5mb3IoJ2Nsb3Nlc3RDb250cm9sbGVyJyksXG4gICAgY2xvc2VzdFByb3ZpZGVyICAgICA9IFN5bWJvbC5mb3IoJ2Nsb3Nlc3RQcm92aWRlcicpLFxuICAgIHR3b1dheUJpbmRpbmdTeW1ib2wgPSBTeW1ib2wuZm9yKCd0d29XYXlCaW5kaW5nJyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQWJzdHJhY3RcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29tcG9uZW50Lm1peGluLkRvbUV2ZW50c1xuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqIEBtaXhlcyBOZW8uY29tcG9uZW50Lm1peGluLlZkb21MaWZlY3ljbGVcbiAqL1xuY2xhc3MgQWJzdHJhY3QgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuQWJzdHJhY3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuQWJzdHJhY3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nYWJzdHJhY3QtY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Fic3RyYWN0LWNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIG5hbWVzcGFjZXMgdG8gbG9hZCB0aGVtZSBmaWxlcyBmb3IuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGFkZGl0aW9uYWxUaGVtZUZpbGVzPW51bGxcbiAgICAgICAgICogQGV4YW1wbGUgWydBZ2VudE9TU3RyYXRlZ3kudmlldy5WaWV3cG9ydCddXG4gICAgICAgICAqL1xuICAgICAgICBhZGRpdGlvbmFsVGhlbWVGaWxlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBjb21wb25lbnQgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwTmFtZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBjb25maWdzIHRvIHN0YXRlLlByb3ZpZGVyIGRhdGEgcHJvcGVydGllcy5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGJpbmRfPXtbaXNEZXNjcmlwdG9yXTp0cnVlLG1lcmdlOidkZWVwJyx2YWx1ZTpudWxsfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGJpbmRfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnZGVlcCcsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VzdG9tIENTUyBzZWxlY3RvcnMgdG8gYXBwbHkgdG8gdGhlIHJvb3QgbGV2ZWwgbm9kZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY2xzXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHRvIGFjY2VzcyB0aGUgZGF0YSBjb25maWcgb2YgdGhlIGNsb3Nlc3Qgc3RhdGUuUHJvdmlkZXIuXG4gICAgICAgICAqIFJlYWQgb25seS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVkIGNvbXBvbmVudHMgd2lsbCBnZXQgdGhlIG5lby1kaXNhYmxlZCBjbHMgYXBwbGllZCBhbmQgd29uJ3QgcmVjZWl2ZSBET00gZXZlbnRzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVkXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5CYXNlW119IG1peGlucz1bRG9tRXZlbnRzLCBPYnNlcnZhYmxlLCBWZG9tTGlmZWN5Y2xlXVxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW5zOiBbRG9tRXZlbnRzLCBPYnNlcnZhYmxlLCBWZG9tTGlmZWN5Y2xlXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIHNwZWNpZmljIHN0YXRlUHJvdmlkZXIgZGF0YSBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBUaGlzIHdpbGwgbWVyZ2UgdGhlIGNvbnRlbnQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBtb2RlbERhdGE9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kZWxEYXRhOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhZnRlciB0aGUgY29tcG9uZW50IGluaXRWbm9kZSgpIG1ldGhvZCB3YXMgY2FsbGVkLiBBbHNvIGZpcmVzIHRoZSByZW5kZXJlZCBldmVudC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW91bnRlZF89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vdW50ZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBwYXJlbnRJZCBkb2VzIG5vdCBtYXRjaCBhIG5lbyBjb21wb25lbnQgaWQsIHlvdSBjYW4gbWFudWFsbHkgc2V0IHRoaXMgdmFsdWUgZm9yIGZpbmRpbmdcbiAgICAgICAgICogdmlldyBjb250cm9sbGVycyBvciBzdGF0ZSBwcm92aWRlcnMuXG4gICAgICAgICAqIFVzZSBjYXNlOiBtYW51YWxseSBkcm9wcGluZyBjb21wb25lbnRzIGludG8gYSB2ZG9tIHN0cnVjdHVyZVxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gcGFyZW50Q29tcG9uZW50Xz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRDb21wb25lbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmVudCBjb21wb25lbnQgaWQgb3IgZG9jdW1lbnQuYm9keVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHBhcmVudElkXz0nZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRJZF86ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNhdmVTY3JvbGxQb3NpdGlvbj10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBzYXZlU2Nyb2xsUG9zaXRpb246IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbGx5IGFkZCBhIHN0YXRlLlByb3ZpZGVyIHRvIHNoYXJlIHN0YXRlIGRhdGEgd2l0aCBjaGlsZCBjb21wb25lbnRzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBzdGF0ZVByb3ZpZGVyXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGVQcm92aWRlcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBjb25maWcgbmFtZXMgYW5kIHZhbHVlcyB0byByZXNldCB0byB3aGVuIHRoZSBjb21wb25lbnQgdW5tb3VudHMuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSB1bm1vdW50Q29uZmlnc189e1tpc0Rlc2NyaXB0b3JdOnRydWUsbWVyZ2U6J2RlZXAnLHZhbHVlOm51bGx9XG4gICAgICAgICAqIEBleGFtcGxlIHthY3RpdmVJbmRleDogbnVsbCwgdmFsdWU6ICcnfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVubW91bnRDb25maWdzXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXN0b20gd2luZG93SXMgKHRpbWVzdGFtcCkgdGhpcyBjb21wb25lbnQgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gd2luZG93SWRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZF86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIHdoaWxlIGEgY29tcG9uZW50IGlzIHdhaXRpbmcgZm9yIGl0cyBtb3VudGVkUHJvbWlzZVxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzQXdhaXRpbmdNb3VudD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0F3YWl0aW5nTW91bnQgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWNjZXNzIHRoZSBBcHAgdGhpcyBjb21wb25lbnQgYmVsb25ncyB0b1xuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5BcHBsaWNhdGlvbnxudWxsfVxuICAgICAqL1xuICAgIGdldCBhcHAoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgTmVvLmFwcHNCeU5hbWUgYXMgYSBmYWxsYmFjayBmb3IgUGxheXdyaWdodC1iYXNlZCB1bml0IHRlc3RpbmdcbiAgICAgICAgcmV0dXJuIE5lby5hcHBzW3RoaXMud2luZG93SWRdIHx8IE5lby5hcHBzQnlOYW1lW3RoaXMuYXBwTmFtZV0/LlswXSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgdG8gdGhlIERPTS5cbiAgICAgKiBUaGlzIHByb3ZpZGVzIGEgY29udmVuaWVudCB3YXkgdG8gd2FpdCBmb3IgdGhlIGNvbXBvbmVudCB0byBiZSBmdWxseVxuICAgICAqIGF2YWlsYWJsZSBhbmQgaW50ZXJhY3RpdmUgYmVmb3JlIGV4ZWN1dGluZyBzdWJzZXF1ZW50IGxvZ2ljLlxuICAgICAqXG4gICAgICogSXQgYWxzbyBoYW5kbGVzIHVubW91bnRpbmcgYnkgcmVzZXR0aW5nIHRoZSBwcm9taXNlLCBzbyBpdCBjYW4gYmUgc2FmZWx5XG4gICAgICogYXdhaXRlZCBhZ2FpbiBpZiB0aGUgY29tcG9uZW50IGlzIHJlbW91bnRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8uY29tcG9uZW50LkJhc2U+fVxuICAgICAqL1xuICAgIGdldCBtb3VudGVkUHJvbWlzZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLl9tb3VudGVkUHJvbWlzZSkge1xuICAgICAgICAgICAgbWUuX21vdW50ZWRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUubW91bnRlZFByb21pc2VSZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuX21vdW50ZWRQcm9taXNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFjY2VzcyB0aGUgcGFyZW50IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBtZS5wYXJlbnRDb21wb25lbnQgfHwgKG1lLnBhcmVudElkID09PSAnZG9jdW1lbnQuYm9keScgPyBudWxsIDogTmVvLmdldENvbXBvbmVudChtZS5wYXJlbnRJZCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIGFueSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDb25maWcoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoTmVvLmlzVXNpbmdTdGF0ZVByb3ZpZGVycyAmJiBtZVt0d29XYXlCaW5kaW5nU3ltYm9sXSkge1xuICAgICAgICAgICAgLy8gV2hlbiBhIGNvbXBvbmVudCBjb25maWcgaXMgdXBkYXRlZCBieSBpdHMgc3RhdGUgcHJvdmlkZXIsIHRoaXMgZmxhZyBpcyBzZXQgdG8gdGhlIGNvbmZpZydzIGtleS5cbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgY2lyY3VsYXIgdXBkYXRlcyBpbiB0d28td2F5IGRhdGEgYmluZGluZ3MgYnkgc2tpcHBpbmcgdGhlIHB1c2ggYmFjayB0byB0aGUgc3RhdGUgcHJvdmlkZXIuXG4gICAgICAgICAgICBpZiAobWUuX3NraXBUd29XYXlQdXNoID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmluZGluZyA9IG1lLmJpbmQ/LltrZXldO1xuXG4gICAgICAgICAgICBpZiAoYmluZGluZz8udHdvV2F5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCk/LnNldERhdGEoYmluZGluZy5rZXksIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBvbGRWYWx1ZSAmJiBDb21wb25lbnRNYW5hZ2VyLnVucmVnaXN0ZXIob2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAgICAmJiBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7IC8vIG1vdW50XG4gICAgICAgICAgICAgICAgbWUuaW5pdERvbUV2ZW50cz8uKCk7XG4gICAgICAgICAgICAgICAgbWUubW91bnRlZFByb21pc2VSZXNvbHZlPy4odGhpcyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lLm1vdW50ZWRQcm9taXNlUmVzb2x2ZTtcblxuICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBjb21wb25lbnQgYmVjb21lcyBtb3VudGVkLCBpdCBtaWdodCBoYXZlIHBlbmRpbmcgVkRPTSB1cGRhdGUgcHJvbWlzZXNcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBmcm9tIGEgc2V0KCkgY2FsbCB0aGF0IHdhcyBkZWZlcnJlZCBiZWNhdXNlIHRoZSBjb21wb25lbnQgd2Fzbid0IG1vdW50ZWQgeWV0KS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbW91bnQgaGFwcGVuZWQgYmVjYXVzZSBhIFBhcmVudCBjb21wb25lbnQgdXBkYXRlZCAoaW1wbGljaXRseSBjb3ZlcmluZyB0aGlzIGNvbXBvbmVudCksXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQncyBvd24gcGVuZGluZyB1cGRhdGUgY3ljbGUgbWlnaHQgYmUgc2tpcHBlZCBvciBub3QgeWV0IHRyaWdnZXJlZC5cbiAgICAgICAgICAgICAgICAvLyBXZSBleHBsaWNpdGx5IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyBoZXJlIHRvIGVuc3VyZSB0aG9zZSBwZW5kaW5nIHByb21pc2VzIGFyZSByZXNvbHZlZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIC8vIHVwb24gbW91bnQsIHByZXZlbnRpbmcgZGVhZGxvY2tzIHdoZXJlIGNvZGUgYXdhaXRzIGEgVkRPTSB1cGRhdGUgdGhhdCBlZmZlY3RpdmVseSBhbHJlYWR5IGhhcHBlbmVkLlxuICAgICAgICAgICAgICAgIFZEb21VcGRhdGUuZXhlY3V0ZUNhbGxiYWNrcyhtZS5pZCwge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB2bm9kZSA6IG1lLnZub2RlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVubW91bnRcbiAgICAgICAgICAgICAgICBkZWxldGUgbWUuX21vdW50ZWRQcm9taXNlO1xuXG4gICAgICAgICAgICAgICAgbWUucmVzZXRNb3VudGVkRG9tRXZlbnRzPy4oKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS51bm1vdW50Q29uZmlncykge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZXQobWUudW5tb3VudENvbmZpZ3MpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBwYXJlbnRJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0UGFyZW50SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIENvbXBvbmVudE1hbmFnZXIub25QYXJlbnRJZENoYW5nZSh0aGlzLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0YXRlUHJvdmlkZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U3RhdGVQcm92aWRlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWU/LmNyZWF0ZUJpbmRpbmdzKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmNvbnRyb2xsZXIgICAgJiYgKG1lLmNvbnRyb2xsZXIud2luZG93SWQgICAgPSB2YWx1ZSk7XG4gICAgICAgICAgICBtZS5zdGF0ZVByb3ZpZGVyICYmIChtZS5zdGF0ZVByb3ZpZGVyLndpbmRvd0lkID0gdmFsdWUpO1xuXG4gICAgICAgICAgICBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKHZhbHVlLCBtZS5fX3Byb3RvX18pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIGNvbXBvbmVudCBnZXRzIG1vdmVkIGludG8gYSBkaWZmZXJlbnQgd2luZG93LCBhbiB1cGRhdGUgY3ljbGUgbWlnaHQgc3RpbGwgYmUgcnVubmluZy5cbiAgICAgICAgLy8gU2luY2UgdGhlIHVwZGF0ZSBtaWdodCBubyBsb25nZXIgZ2V0IG1hcHBlZCwgd2Ugd2FudCB0byByZS1lbmFibGUgdGhpcyBpbnN0YW5jZSBmb3IgZnV0dXJlIHVwZGF0ZXMuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbWUuaXNWZG9tVXBkYXRpbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBkYXRhIGNvbmZpZ1xuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHdoaWNoIGlzIGV4cGVuc2l2ZSB0byB1c2UsIHNpbmNlIGl0IHdpbGwgZ2VuZXJhdGUgYSBtZXJnZWQgcGFyZW50IHN0YXRlIHByb3ZpZGVycyBkYXRhIG1hcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RGF0YSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCk/LmdldEhpZXJhcmNoeURhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0YXRlUHJvdmlkZXIgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBDcmVhdGVzIGEgc3RhdGUuUHJvdmlkZXIgaW5zdGFuY2UgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uc3RhdGUuUHJvdmlkZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0YXRlUHJvdmlkZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlcyA9IHtjb21wb25lbnQ6IG1lLCB3aW5kb3dJZDogbWUud2luZG93SWR9O1xuXG4gICAgICAgICAgICBpZiAobWUubW9kZWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlcy5kYXRhID0gbWUubW9kZWxEYXRhXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsICdOZW8uc3RhdGUuUHJvdmlkZXInLCBkZWZhdWx0VmFsdWVzKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRG9tRXZlbnRzKCk7XG4gICAgICAgIENvbXBvbmVudE1hbmFnZXIudW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgdGhpcy5zdGF0ZVByb3ZpZGVyID0gbnVsbDsgLy8gdHJpZ2dlcnMgZGVzdHJveSgpXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW4gaW5zdGFuY2Ugc3RvcmVkIGluc2lkZSBhIGNvbmZpZyB2aWEgb3B0aW9uYWxseSBwYXNzaW5nIGEgbnR5cGUuXG4gICAgICogUmV0dXJucyB0aGlzW2NvbmZpZ05hbWVdIG9yIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCBhIG1hdGNoLlxuICAgICAqIFVzZWQgYnkgZ2V0Q29udHJvbGxlcigpICYgZ2V0U3RhdGVQcm92aWRlcigpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29uZmlnSW5zdGFuY2VCeU50eXBlKGNvbmZpZ05hbWUsIG50eXBlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgICAgICAgICAgICA9IG1lW2NvbmZpZ05hbWVdLFxuICAgICAgICAgICAge3BhcmVudENvbXBvbmVudH0gPSBtZTtcblxuICAgICAgICBpZiAoY29uZmlnICYmICghbnR5cGUgfHwgbnR5cGUgPT09IGNvbmZpZy5udHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyZW50Q29tcG9uZW50ICYmIG1lLnBhcmVudElkKSB7XG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQgPSBtZS5wYXJlbnQgfHwgTmVvLmdldChtZS5wYXJlbnRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50ID09PSBtZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NpcmN1bGFyIHBhcmVudCByZWZlcmVuY2UgZGV0ZWN0ZWQnLCBtZS5pZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdG9kbzogV2UgbmVlZCA/LiB1bnRpbCBmdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlIHN1cHBvcnRzIGNvbnRyb2xsZXJzXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Q29tcG9uZW50LmdldENvbmZpZ0luc3RhbmNlQnlOdHlwZT8uKGNvbmZpZ05hbWUsIG50eXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcy5zdGF0ZVByb3ZpZGVyIG9yIHRoZSBjbG9zZXN0IHBhcmVudCBzdGF0ZVByb3ZpZGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtudHlwZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihudHlwZSkge1xuICAgICAgICBpZiAoIU5lby5pc1VzaW5nU3RhdGVQcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcHJvdmlkZXI7XG5cbiAgICAgICAgaWYgKCFudHlwZSkge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBtZVtjbG9zZXN0UHJvdmlkZXJdO1xuXG4gICAgICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb3ZpZGVyID0gbWUuZ2V0Q29uZmlnSW5zdGFuY2VCeU50eXBlKCdzdGF0ZVByb3ZpZGVyJywgbnR5cGUpO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIG1lW2Nsb3Nlc3RQcm92aWRlcl0gPSBwcm92aWRlclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBpbml0Q29uZmlnKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIuaW5pdENvbmZpZyguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCk/LmNyZWF0ZUJpbmRpbmdzKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblNjcm9sbENhcHR1cmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgdm5vZGU7XG5cbiAgICAgICAgaWYgKG1lLnZub2RlKSB7XG4gICAgICAgICAgICB2bm9kZSA9IFZOb2RlVXRpbC5nZXRCeUlkKG1lLnZub2RlLCBkYXRhLnRhcmdldC5pZCk7XG5cbiAgICAgICAgICAgIGlmICh2bm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIERpcmVjdGx5IHVwZGF0aW5nIHRoZSBwZXJzaXN0ZW50IHZub2RlIHN0YXRlIChwbGFpbiBvYmplY3QpLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgdHJpZ2dlciBhIFZET00gdXBkYXRlLCBidXQgZW5zdXJlcyB0aGUgc3RhdGUgaXMgcHJlc2VydmVkXG4gICAgICAgICAgICAgICAgLy8gZm9yIGZ1dHVyZSByZS1yZW5kZXJzIChlLmcuIHVubW91bnQvcmVtb3VudCkuXG4gICAgICAgICAgICAgICAgdm5vZGUuc2Nyb2xsVG9wICA9IGRhdGEuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHZub2RlLnNjcm9sbExlZnQgPSBkYXRhLnNjcm9sbExlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBtdWx0aXBsZSBjb25maWdzIGF0IG9uY2UsIGVuc3VyaW5nIHRoYXQgYWxsIGFmdGVyU2V0IG1ldGhvZHMgZ2V0IGFsbCBuZXcgYXNzaWduZWQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcz17fVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgc2V0KHZhbHVlcz17fSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgd2FzSGlkZGVuID0gbWUuaGlkZGVuO1xuXG4gICAgICAgIG1lLnNldFNpbGVudCh2YWx1ZXMpO1xuXG4gICAgICAgIGlmICghc2lsZW50ICYmIG1lLm5lZWRzVmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHdhc0hpZGRlbiAmJiAhbWUuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvdz8uKCk7IC8vIHNob3coKSBpcyBub3QgcGFydCBvZiB0aGUgYWJzdHJhY3QgYmFzZSBjbGFzc1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWUucHJvbWlzZVVwZGF0ZSgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbGVudCB2ZXJzaW9uIG9mIHNldCgpLCB3aGljaCBkb2VzIG5vdCB0cmlnZ2VyIGEgdmRvbSB1cGRhdGUgYXQgdGhlIGVuZC5cbiAgICAgKiBVc2VmdWwgZm9yIGJhdGNoaW5nIG11bHRpcGxlIGNvbmZpZyBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKi9cbiAgICBzZXRTaWxlbnQodmFsdWVzPXt9KSB7XG4gICAgICAgIHRoaXMuc2lsZW50VmRvbVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHN1cGVyLnNldCh2YWx1ZXMpO1xuICAgICAgICB0aGlzLnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBzZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBjb21wb25lbnQgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogRXh0ZW5kcyB0aGUgY29yZS5CYXNlIHNlcmlhbGl6YXRpb24gd2l0aCBjb21wb25lbnQtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBhcHBOYW1lICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgYmluZCAgICAgICAgIDogbWUuYmluZCA/IE9iamVjdC5rZXlzKG1lLmJpbmQpIDogbnVsbCxcbiAgICAgICAgICAgIG1vdW50ZWQgICAgICA6IG1lLm1vdW50ZWQsXG4gICAgICAgICAgICBwYXJlbnRJZCAgICAgOiBtZS5wYXJlbnRJZCxcbiAgICAgICAgICAgIHN0YXRlUHJvdmlkZXI6IG1lLnN0YXRlUHJvdmlkZXI/LnRvSlNPTigpLFxuICAgICAgICAgICAgd2luZG93SWQgICAgIDogbWUud2luZG93SWRcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQWJzdHJhY3QpO1xuIiwiaW1wb3J0IEFic3RyYWN0ICAgICAgICAgZnJvbSAnLi9BYnN0cmFjdC5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCAgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBLZXlOYXZpZ2F0aW9uICAgIGZyb20gJy4uL3V0aWwvS2V5TmF2aWdhdGlvbi5tanMnO1xuaW1wb3J0IExvZ2dlciAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9Mb2dnZXIubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBSZWN0YW5nbGUgICAgICAgIGZyb20gJy4uL3V0aWwvUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgU3R5bGUgICAgICAgICAgICBmcm9tICcuLi91dGlsL1N0eWxlLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcbmltcG9ydCBWTm9kZVV0aWwgICAgICAgIGZyb20gJy4uL3V0aWwvVk5vZGUubWpzJztcbmltcG9ydCB7aXNEZXNjcmlwdG9yfSAgIGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG5jb25zdFxuICAgIGFkZFVuaXRzICAgICAgICAgID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogaXNOYU4odmFsdWUpID8gdmFsdWUgOiBgJHt2YWx1ZX1weGAsXG4gICAgY2xvc2VzdENvbnRyb2xsZXIgPSBTeW1ib2wuZm9yKCdjbG9zZXN0Q29udHJvbGxlcicpLFxuICAgIGxlbmd0aFJFICAgICAgICAgID0gL15cXGQrXFx3KyQvO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBDb21wb25lbnRzIHdoaWNoIGhhdmUgYSBET00gcmVwcmVzZW50YXRpb25cbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQWJzdHJhY3RcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQWJzdHJhY3Qge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaGlkZU1vZGVcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaGlkZU1vZGVzPVsncmVtb3ZlRG9tJywndmlzaWJpbGl0eSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaGlkZU1vZGVzID0gWydyZW1vdmVEb20nLCAndmlzaWJpbGl0eSddXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbXBvbmVudC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlZmF1bHQgYWxpZ25tZW50IHNwZWNpZmljYXRpb24gdG8gcG9zaXRpb24gdGhpcyBDb21wb25lbnQgcmVsYXRpdmUgdG8gc29tZSBvdGhlclxuICAgICAgICAgKiBDb21wb25lbnQsIG9yIEVsZW1lbnQgb3IgUmVjdGFuZ2xlLiBPbmx5IGFwcGxpZXMgaW4gY2FzZSBmbG9hdGluZyA9IHRydWUuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd9IGFsaWduXz17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnZGVlcCcsIHZhbHVlOiB7ZWRnZUFsaWduOiAndC1iJyxjb25zdHJhaW5UbzogJ2RvY3VtZW50LmJvZHknfX1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbl86IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdkZWVwJyxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgZWRnZUFsaWduICA6ICd0LWInLFxuICAgICAgICAgICAgICAgIGNvbnN0cmFpblRvOiAnZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBzZWxlY3RvcnMgdG8gYXBwbHkgdG8gdGhlIHJvb3QgbGV2ZWwgbm9kZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYW5hZ2VyLkZvY3VzIHdpbGwgY2hhbmdlIHRoaXMgZmxhZyBvbiBmb2N1c2luICYgb3V0IGRvbSBldmVudHNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY29udGFpbnNGb2N1c189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5zRm9jdXNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2lnbiBhIGNvbXBvbmVudCBjb250cm9sbGVyIHRvIHRoaXMgY29tcG9uZW50IChwYXNzIGFuIGltcG9ydGVkIG1vZHVsZSBvciB0aGUgc3RyaW5nIGJhc2VkIGNsYXNzIG5hbWUpXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxTdHJpbmd9IGNvbnRyb2xsZXJfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sbGVyXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGNvbmZpZyB0byB0cnVlIHRvIGR5bmFtaWNhbGx5IGltcG9ydCBhIERyb3Bab25lIG1vZHVsZSAmIGNyZWF0ZSBhbiBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcm9wcGFibGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHBhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLkRyb3Bab25lfG51bGx9IGRyb3Bab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcm9wWm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wWm9uZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gbW91bnQgdGhpcyBjb21wb25lbnQgaW50byB0aGUgdmlld3BvcnQgb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnQgZmxvd1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmbG9hdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZmxvYXRpbmc6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB3aGljaCB3aWxsIGdldCBzZXQgdG8gdHJ1ZSBvbiBtb3VudFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNCZWVuTW91bnRlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoYXNCZWVuTW91bnRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCBmb3Igc3R5bGUuaGVpZ2h0LCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IGhlaWdodF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsIHNldHRpbmcgdG8gaGlkZSBvciBzaG93IHRoZSBjb21wb25lbnQgYW5kXG4gICAgICAgICAqIHlvdSBjYW4gdXNlIGVpdGhlciBoaWRlKCkvc2hvdygpIG9yIGNoYW5nZSB0aGlzIGNvbmZpZyBkaXJlY3RseSB0byBjaGFuZ2UgdGhlIGhpZGRlbiBzdGF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWRkZW5fPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZGVuXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciBoaWRlIGFuZCBzaG93IGFuZCBkZWZpbmVzIGlmIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogc2hvdWxkIHVzZSBjc3MgdmlzaWJpbGl0eTonaGlkZGVuJyBvciB2ZG9tOnJlbW92ZURvbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGhpZGVNb2RlXz0ncmVtb3ZlRG9tJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGhpZGVNb2RlXzogJ3JlbW92ZURvbScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdG9wIGxldmVsIGlubmVySFRNTCBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBodG1sXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaHRtbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIHRvIHNob3cgYSBzcGlubmVyIGNlbnRlcmVkIGluIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIFNldCB0byBhIHN0cmluZyB0byBzaG93IGEgbWVzc2FnZSBuZXh0IHRvIGEgc3Bpbm5lciBjZW50ZXJlZCBpbiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufFN0cmluZ30gaXNMb2FkaW5nPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0xvYWRpbmdfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzaW5nIHRoZSBrZXlzIGNvbmZpZyB3aWxsIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBOZW8udXRpbC5LZXlOYXZpZ2F0aW9uLlxuICAgICAgICAgKiBAc2VlIHtAbGluayBOZW8udXRpbC5LZXlOYXZpZ2F0aW9uIEtleU5hdmlnYXRpb259XG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0ga2V5c189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGtleXNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB1c2VkIGluc2lkZSBhZnRlclNldElzTG9hZGluZygpIHRvIGRlZmluZSB0aGUgQ1NTIGZvciB0aGUgbG9hZGluZyBzcGlubmVyIGljb25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGxvYWRpbmdTcGlubmVyQ2xzXz1bJ2ZhJywnZmEtc3Bpbm5lcicsJ2ZhLXNwaW4nXVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxvYWRpbmdTcGlubmVyQ2xzXzogWydmYScsICdmYS1zcGlubmVyJywgJ2ZhLXNwaW4nXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5tYXhIZWlnaHQsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gbWF4SGVpZ2h0Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4SGVpZ2h0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5tYXhXaWR0aCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtYXhXaWR0aF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1heFdpZHRoXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5taW5IZWlnaHQsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gbWluSGVpZ2h0Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWluSGVpZ2h0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5taW5XaWR0aCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtaW5XaWR0aF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1pbldpZHRoXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5IG9mIFBsdWdpbiBNb2R1bGVzIGFuZCAvIG9yIGNvbmZpZyBvYmplY3RzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IHBsdWdpbnNfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBsdWdpbnNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGEgcmVmZXJlbmNlIGZvciBhY2Nlc3NpbmcgdGhlIGNvbXBvbmVudCBpbnNpZGUgdmlldyBjb250cm9sbGVycy5cbiAgICAgICAgICogUmVmZXJlbmNlcyB3aWxsIGFsc28gZ2V0IG1hcHBlZCBpbnRvIHRoZSB2ZG9tIHJvb3QgKGRhdGEtcmVmOiB2YWx1ZSkuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSByZWZlcmVuY2VfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJlZmVyZW5jZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIHRoZSB2aWV3IFJlc3BvbnNpdmUgYnkgYWRkaW5nIGFsdGVybmF0aXZlIGNvbmZpZ3MuXG4gICAgICAgICAqIFRoZSBkZWZpbml0aW9uIGhhcHBlbnMgdmlhIHJlc3BvbnNpdmVDZmdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZXNwb25zaXZlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzcG9uc2l2ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgcm9sZSB0YWcgYXR0cmlidXRlIGZvciB0aGUgdmRvbSByb290LlxuICAgICAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FjY2Vzc2liaWxpdHkvQVJJQS9Sb2xlc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcm9sZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHJvbGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBmb3Igc3R5bGUgJ292ZXJmbG93OmF1dG8nLlxuICAgICAgICAgKiBTZXQgdGhpcyB0byAneCcgb3IgJ3knIHRvIGFkZCBzdHlsZSAnb3ZlcmZsb3cteCcgb3IgJ292ZXJmbG93LXknIHRvICdhdXRvJ1xuICAgICAgICAgKiBPdGhlciB0aGFuIGZhbHNlIHRoaXMgd2lsbCBhZGQgY2xzICduZW8tc2Nyb2xsYWJsZScuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW58XCJ4XCJ8XCJ5XCJ9IHNjcm9sbGFibGVfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsYWJsZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3R5bGUgYXR0cmlidXRlcyBhZGRlZCB0byB0aGlzIHZkb20gcm9vdC4gc2VlOiBnZXRWZG9tUm9vdCgpXG4gICAgICAgICAqXG4gICAgICAgICAqICoqSW1wb3J0YW50OioqIFdoZW4gYHZkb20gPT09IHZkb21Sb290YCAoc2luZ2xlIG5vZGUgY29tcG9uZW50KSwgdGhlIGB3cmFwcGVyU3R5bGVgIG1lY2hhbmlzbVxuICAgICAgICAgKiBjcmVhdGVzIGEgcGVyc2lzdGVudCBzdGF0ZSBsb29wIHRvIHN1cHBvcnQgcnVudGltZSBWRE9NIG11dGF0aW9ucy5cbiAgICAgICAgICogVGhpcyBtZWFucyB0aGF0IHRvICpyZW1vdmUqIGEgc3R5bGUgcHJvcGVydHkgeW91IHByZXZpb3VzbHkgc2V0LCB5b3UgTVVTVCBzZXQgaXQgdG8gYG51bGxgLlxuICAgICAgICAgKiBVc2luZyBgZGVsZXRlYCBvciBzZXR0aW5nIGB1bmRlZmluZWRgIHdpbGwgcmV2ZXJ0IHRvIHRoZSBcInByZXZpb3VzIHN0YXRlXCIsIHdoaWNoIHVuZm9ydHVuYXRlbHlcbiAgICAgICAgICogaW5jbHVkZXMgdGhlIHZlcnkgdmFsdWUgeW91IGFyZSB0cnlpbmcgdG8gcmVtb3ZlIGlmIGl0IGhhcyBsZWFrZWQgaW50byBgd3JhcHBlclN0eWxlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdHlsZT17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnc2hhbGxvdycsIHZhbHVlOiBudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGVfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnc2hhbGxvdycsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiBwYXNzIGEgdXNlZCB0aGVtZSBkaXJlY3RseSB0byBhbnkgY29tcG9uZW50LFxuICAgICAgICAgKiB0byBzdHlsZSBzcGVjaWZpYyBjb21wb25lbnQgdHJlZXMgZGlmZmVyZW50bHkgZnJvbSB5b3VyIG1haW4gdmlldy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHRoZW1lXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpbGUgaXQgaXMgcmVjb21tZW5kZWQgdG8gZGVmaW5lIHRhZ3MgaW5zaWRlIHRoZSB2ZG9tIG9mIGNsYXNzZXMsXG4gICAgICAgICAqIHRoaXMgc2hvcnRjdXQgZW5hYmxlcyB1cyB0byBjaGFuZ2UgdGhlIHZkb20gcm9vdCB0YWcgb24gaW5zdGFuY2UgbGV2ZWwuXG4gICAgICAgICAqIFVzZSBjYXNlczogc3dpdGNoIGEgVG9vbGJhciB0byBhIFwibmF2XCIgdGFnLCBzd2l0Y2ggYSBTaWRlTmF2IHRvIGFuIFwiYXNpZGVcIiB0YWcuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0YWdfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0YWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvcCBsZXZlbCB0ZXh0Q29udGVudCBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0ZXh0Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgdG9vbHRpcCBjb25maWcgb2JqZWN0IG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGRpc3BsYXkgdGV4dFxuICAgICAgICAgKiBTZWUgdG9vbHRpcC9CYXNlLm1qc1xuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBhIHNpbmdsZSwgc2hhcmVkIFRvb2x0aXAgaW5zdGFuY2UgaXMgdXNlZCBmb3IgYWxsIHdpZGdldHMgdGhhdCByZXF1ZXN0XG4gICAgICAgICAqIGEgdG9vbHRpcC4gSXQgcmVjb25maWd1cmVzIGl0c2VsZiBmcm9tIHRoZSB3aWRnZXQncyBkZWZpbml0aW9uIGp1c3QgYmVmb3JlIHNob3dpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgd2lkZ2V0IG5lZWRzIGl0cyBvd24gaW5zdGFuY2UgZm9yIGFueSByZWFzb24sIGluY2x1ZGUgdGhlIHByb3BlcnR5IGBvd25JbnN0YW5jZTogdHJ1ZWBcbiAgICAgICAgICogaW4gdGhlIHRvb2x0aXAgY29uZmlnIG9iamVjdC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ30gdG9vbHRpcF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRvb2x0aXBfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkICdwcmltYXJ5JyBhbmQgb3RoZXIgYXR0cmlidXRlcyB0byBtYWtlIGl0IGFuIG91dHN0YW5kaW5nIGRlc2lnblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdWlfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1aV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCBmb3Igc3R5bGUud2lkdGgsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gd2lkdGhfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxudWxsfSB3cmFwcGVyQ2xzXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlckNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcy4gVXNlZnVsIGluIGNhc2UgZ2V0VmRvbVJvb3QoKSBkb2VzIG5vdCBwb2ludCB0byB0aGUgdG9wIGxldmVsIERPTSBub2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5vdGU6KiogVGhlIGdldHRlciBmb3IgdGhpcyBjb25maWcgcmVhZHMgYHZkb20uc3R5bGVgIGFzIGEgZGVmYXVsdCB2YWx1ZSB0byBzdXBwb3J0IHJ1bnRpbWUgbXV0YXRpb25zLlxuICAgICAgICAgKiBUaGlzIGNyZWF0ZXMgdGhlIHBlcnNpc3RlbnQgc3RhdGUgbG9vcCBkZXNjcmliZWQgaW4gdGhlIGBzdHlsZV9gIGNvbmZpZyBkb2N1bWVudGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gd3JhcHBlclN0eWxlXz17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnc2hhbGxvdycsIHZhbHVlOiBudWxsfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBwZXJTdHlsZV86IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdzaGFsbG93JyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmRvbSBtYXJrdXAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbToge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihtZSwgJ192ZG9tJykgJiYgbWUuX3Zkb20pIHtcbiAgICAgICAgICAgIG1lLl92ZG9tID0gTmVvLmNsb25lKG1lLl92ZG9tLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBDb21wb25lbnQgaXMgZnVsbHkgdmlzaWJsZSwgdGhhdCBpcyBpdCBpcyBub3QgaGlkZGVuIGFuZCBoYXMgbm8gaGlkZGVuIGFuY2VzdG9yc1xuICAgICAqL1xuICAgIGdldCBpc1Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdW50ZWQgJiYgIXRoaXMuaGlkZGVuICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNWaXNpYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0dGVyIHdpbGwgaGFuZGxlIHZkb20gdXBkYXRlcyBhdXRvbWF0aWNhbGx5XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tPXRoaXMuX3Zkb21cbiAgICAgKi9cbiAgICBnZXQgdmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zkb21cbiAgICB9XG4gICAgc2V0IHZkb20odmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZnRlclNldFZkb20odmFsdWUsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBjbHMgdG8gdGhlIHZkb21Sb290XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgYWRkQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCB7Y2xzfSA9IHRoaXM7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgdmFsdWUpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIHN0cmluZyBsaWtlICdjb2xvcjogcmVkOyBiYWNrZ3JvdW5kLWNvbG9yOiBibHVlOydcbiAgICAgKiBvciBhbiBvYmplY3QgY29udGFpbmluZyBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFsbCBzdHlsZXMgb2YgdGhpcy5lbFxuICAgICAqL1xuICAgIGFkZFN0eWxlKHZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICBOZW8uY3JlYXRlU3R5bGVPYmplY3QodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvOiBhZGQgYSBjaGVjayBpZiBzb21ldGhpbmcgaGFzIGNoYW5nZWRcblxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA9IE9iamVjdC5hc3NpZ24odGhpcy5zdHlsZSwgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IHdyYXBwZXJDbHMgdG8gdGhlIHRvcCBsZXZlbCBub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgYWRkV3JhcHBlckNscyh2YWx1ZSkge1xuICAgICAgICBsZXQge3dyYXBwZXJDbHN9ID0gdGhpcztcblxuICAgICAgICBOZW9BcnJheS5hZGQod3JhcHBlckNscywgdmFsdWUpO1xuICAgICAgICB0aGlzLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlID0gb2xkVmFsdWUgfHwgW107XG5cbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIHZkb21Sb290ID0gbWUuZ2V0VmRvbVJvb3QoKSxcbiAgICAgICAgICAgIGNscztcblxuICAgICAgICBpZiAodmRvbSAhPT0gdmRvbVJvb3QpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSB1c2luZyBhIHdyYXBwZXIgbm9kZVxuICAgICAgICAgICAgdmRvbVJvb3QuY2xzID0gWy4uLnZhbHVlXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtZXJnZSBjaGFuZ2VzXG4gICAgICAgICAgICBjbHMgPSBOZW9BcnJheS51bmlvbihtZS53cmFwcGVyQ2xzLCB2YWx1ZSk7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBOZW9BcnJheS5kaWZmZXJlbmNlKG9sZFZhbHVlLCB2YWx1ZSkpO1xuICAgICAgICAgICAgdmRvbS5jbHMgPSBjbHNcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkaXNhYmxlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERpc2FibGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcm9wcGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcm9wcGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFtZS5kcm9wWm9uZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvRHJvcFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmRyb3Bab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5kcm9wWm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRIZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2hlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZGVuIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGlkZGVuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RhdGUgPSB2YWx1ZSA/ICdoaWRlJyA6ICdzaG93JztcblxuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBtZS5oaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScpIHtcbiAgICAgICAgICAgIG1lLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIHx8IG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lW3N0YXRlXSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBtZS5yZXZlcnRGb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZShzdGF0ZSwge2lkOiBtZS5pZH0pO1xuICAgICAgICBtZS5maXJlKCdoaWRkZW5DaGFuZ2UnLCB7aWQ6IG1lLmlkLCBvbGRWYWx1ZSwgdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaHRtbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SHRtbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnaHRtbCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuY29uZmlnc0FwcGxpZWQpIHtcbiAgICAgICAgICAgIG1lLmVuc3VyZVN0YWJsZUlkcygpO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNMb2FkaW5nIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc0xvYWRpbmcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSB8fCBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7d3JhcHBlckNscywgdmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBtYXNrSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZkb20uY24pIHtcbiAgICAgICAgICAgICAgICBtYXNrSW5kZXggPSB2ZG9tLmNuLmZpbmRMYXN0SW5kZXgoYyA9PiBjLmNscz8uaW5jbHVkZXMoJ25lby1sb2FkLW1hc2snKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxvYWQgbWFza1xuICAgICAgICAgICAgICAgIGlmIChtYXNrSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24uc3BsaWNlKG1hc2tJbmRleCwgMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghdmRvbS5jbikge1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuID0gW11cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2ZG9tLmNuLnB1c2gobWUuY3JlYXRlTG9hZGluZ01hc2sodmFsdWUpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW9BcnJheS50b2dnbGUod3JhcHBlckNscywgJ25lby1tYXNrZWQnLCB2YWx1ZSk7XG4gICAgICAgICAgICBtZS5zZXQoe3Zkb20sIHdyYXBwZXJDbHN9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXhIZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWF4SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRNYXhIZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21heEhlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWF4V2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWF4V2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1heFdpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdtYXhXaWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluSGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1pbkhlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkTWluSGVpZ2h0ID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdtaW5IZWlnaHQnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1pbldpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1pbldpZHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRNaW5XaWR0aCA9IGFkZFVuaXRzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnbWluV2lkdGgnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7IC8vIG1vdW50XG4gICAgICAgICAgICAgICAgbWUuaGFzQmVlbk1vdW50ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmZsb2F0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsaWduVG8oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb2N1cyB3aWxsIGJlIHB1c2hlZCBpbnRvIHRoZSBmaXJzdCBpbnB1dCBmaWVsZCBvciBvdGhlciBmb2N1c2FibGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICBtZS5mb2N1cyhtZS5pZCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdtb3VudGVkJywgbWUuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdW5tb3VudFxuICAgICAgICAgICAgICAgIG1lLnJldmVydEZvY3VzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVmZXJlbmNlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWZlcmVuY2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2RhdGEtcmVmJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZXNwb25zaXZlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldFJlc3BvbnNpdmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5nZXRQbHVnaW4oJ3Jlc3BvbnNpdmUnKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG1vZHVsZSAgPSBhd2FpdCBpbXBvcnQoYC4uLy4uL3NyYy9wbHVnaW4vUmVzcG9uc2l2ZS5tanNgKSxcbiAgICAgICAgICAgICAgICBwbHVnaW5zID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm9sZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um9sZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgncm9sZScsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2Nyb2xsYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW58bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTY3JvbGxhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBvbGRPdmVyZmxvd0tleSA9ICdvdmVyZmxvdyc7XG5cbiAgICAgICAgICAgIGlmICghTmVvLmlzQm9vbGVhbihvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRPdmVyZmxvd0tleSArPSBOZW8uY2FwaXRhbGl6ZShvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUucmVtb3ZlU3R5bGUoW29sZE92ZXJmbG93S2V5XSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmZsb3dLZXkgPSAnb3ZlcmZsb3cnO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgIU5lby5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dLZXkgKz0gTmVvLmNhcGl0YWxpemUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmFkZFN0eWxlKG92ZXJmbG93S2V5ICsgJzphdXRvJyk7XG4gICAgICAgICAgICAgICAgbWUuYWRkQ2xzKCduZW8tc2Nyb2xsYWJsZScpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnJlbW92ZUNscygnbmVvLXNjcm9sbGFibGUnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdHlsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdHlsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoIXZhbHVlICYmIG9sZFZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGFnIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUYWcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ3RhZycsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGhlbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgfHwgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7Y2xzfSAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAmJiBjbHMuaW5jbHVkZXMob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byBhZGQgYSBET00gYmFzZWQgQ1NTIHNlbGVjdG9yLCBpbiBjYXNlIHRoZSB0aGVtZSBpcyBhbHJlYWR5IGluaGVyaXRlZFxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBtZS5wYXJlbnQ/LnRoZW1lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgJiYgTmVvQXJyYXkuYWRkKGNscywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGV4dCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgndGV4dCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdG9vbHRpcCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRvb2x0aXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95Py4oKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChOZW8ubnMoJ05lby50b29sdGlwLkJhc2UnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0KCcuLi90b29sdGlwL0Jhc2UubWpzJykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHN0eWxpbmcgcHVycG9zZXMgb25seS5cbiAgICAgKiBUbyBkZWZpbmUgYnV0dG9uIHN0eWxlcyBvciBjb21wb25lbnQgc3R5bGVzLFxuICAgICAqIHRoaXMgd2lsbCBhZGQgYSBjc3MgY2xhc3M6IG5lby1udHlwZS12YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFVpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIGBuZW8tJHttZS5udHlwZX0tJHtvbGRWYWx1ZX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgYG5lby0ke21lLm50eXBlfS0ke3ZhbHVlfWApXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpZHRoIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpZHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRXaWR0aCA9IGFkZFVuaXRzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnd2lkdGgnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBjb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyO1xuXG4gICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd3JhcHBlckNscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdyYXBwZXJDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlID0gb2xkVmFsdWUgfHwgW107XG4gICAgICAgIHZhbHVlICAgID0gdmFsdWUgICAgfHwgW107XG5cbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2ZG9tfSAgID0gbWUsXG4gICAgICAgICAgICB2ZG9tUm9vdCA9IG1lLmdldFZkb21Sb290KCksXG4gICAgICAgICAgICBjbHMgICAgICA9IHZkb20uY2xzIHx8IFtdO1xuXG4gICAgICAgIGlmICh2ZG9tID09PSB2ZG9tUm9vdCkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtZXJnZSBjaGFuZ2VzXG4gICAgICAgICAgICBjbHMgPSBOZW9BcnJheS51bmlvbihjbHMsIHZhbHVlKTtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkVmFsdWUsIHZhbHVlKSk7XG4gICAgICAgICAgICB2ZG9tLmNscyA9IGNsc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCB1c2luZyBhIHdyYXBwZXIgPT4gY2xzICYgd3JhcHBlckNscyBzaGFyZSB0aGUgc2FtZSBub2RlXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBbXTtcblxuICAgICAgICAgICAgb2xkVmFsdWUgJiYgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgdmFsdWUpO1xuXG4gICAgICAgICAgICB2ZG9tLmNscyA9IGNsc1xuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdyYXBwZXJTdHlsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXcmFwcGVyU3R5bGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghKCF2YWx1ZSAmJiBvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlnbnMgdGhlIHRvcCBsZXZlbCBub2RlIGluc2lkZSB0aGUgbWFpbiB0aHJlYWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYz17fVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGFsaWduVG8oc3BlYz17fSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgYWxpZ24gPSB7XG4gICAgICAgICAgICAgICAgLi4ubWUuYWxpZ24sXG4gICAgICAgICAgICAgICAgLi4uc3BlYyxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkRmxleCAgICAgOiBtZS5jb25maWd1cmVkRmxleCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkV2lkdGggICAgOiBtZS5jb25maWd1cmVkV2lkdGgsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZEhlaWdodCAgIDogbWUuY29uZmlndXJlZEhlaWdodCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkTWluV2lkdGggOiBtZS5jb25maWd1cmVkTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZE1pbkhlaWdodDogbWUuY29uZmlndXJlZE1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkTWF4V2lkdGggOiBtZS5jb25maWd1cmVkTWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZE1heEhlaWdodDogbWUuY29uZmlndXJlZE1heEhlaWdodCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCAgICAgICAgICAgOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoYWxpZ24udGFyZ2V0KSB7XG4gICAgICAgICAgICBhd2FpdCBOZW8ubWFpbi5Eb21BY2Nlc3MuYWxpZ24oYWxpZ24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGNscyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldENscyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBbLi4udmFsdWVdIDogW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIHN0eWxlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRTdHlsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gey4uLnZhbHVlfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgd3JhcHBlckNscyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldFdyYXBwZXJDbHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gWy4uLnZhbHVlXSA6IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSB3cmFwcGVyU3R5bGUgY29uZmlnLlxuICAgICAqXG4gICAgICogSXQgbWVyZ2VzIHRoZSBjdXJyZW50IGB2ZG9tLnN0eWxlYCBpbnRvIHRoZSByZXN1bHQgdG8gZW5zdXJlIHRoYXQgcnVudGltZSBzdHlsZSBtdXRhdGlvbnNcbiAgICAgKiAoaGFja3MpIG9yIGluaXRpYWwgVkRPTSBzdHlsZXMgYXJlIHByZXNlcnZlZCBhbmQgbm90IG92ZXJ3cml0dGVuIGJ5IHRoZSBjb25maWcgdmFsdWUuXG4gICAgICpcbiAgICAgKiAqKldhcm5pbmc6KiogVGhpcyBjcmVhdGVzIHRoZSBwZXJzaXN0ZW50IHN0YXRlIGxvb3AgZGVzY3JpYmVkIGluIHRoZSBgc3R5bGVfYCBjb25maWcuXG4gICAgICogUmVhZGluZyB0aGUgb3V0cHV0IChgdmRvbS5zdHlsZWApIGFzIHRoZSBkZWZhdWx0IGZvciB0aGUgaW5wdXQgKGB3cmFwcGVyU3R5bGVgKSBtZWFuc1xuICAgICAqIG1lcmdlZCBzdHlsZXMgYmVjb21lIHBlcm1hbmVudCB1bmxlc3MgZXhwbGljaXRseSBjbGVhcmVkIHdpdGggYG51bGxgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldFdyYXBwZXJTdHlsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gey4uLk9iamVjdC5hc3NpZ24odGhpcy52ZG9tLnN0eWxlIHx8IHt9LCB2YWx1ZSl9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgYWxpZ24gY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0QWxpZ24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gSnVzdCBhIHNpbXBsZSAndC1iJ1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgZWRnZUFsaWduOiB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2xzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvQXJyYXkudW5pb24odmFsdWUgfHwgW10sIHRoaXMuYmFzZUNscywgdGhpcy5nZXRCYXNlQ2xhc3MoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY29udHJvbGxlciBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIENyZWF0ZXMgYSBjb250cm9sbGVyLkNvbXBvbmVudCBpbnN0YW5jZSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q29udHJvbGxlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsICdOZW8uY29udHJvbGxlci5Db21wb25lbnQnLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkIDogdGhpcy53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRvbUxpc3RlbmVycyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREb21MaXN0ZW5lcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGhpZGVNb2RlIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRIaWRlTW9kZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2hpZGVNb2RlJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBrZXlzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQ3JlYXRlcyBhIEtleU5hdmlnYXRpb24gaW5zdGFuY2UgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8udXRpbC5LZXlOYXZpZ2F0aW9ufG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEtleXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgS2V5TmF2aWdhdGlvbiwge1xuICAgICAgICAgICAgICAgIGtleURvd25FdmVudEJ1YmJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXlzICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGx1Z2lucyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnBsdWdpbi5CYXNlW119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFBsdWdpbnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UoaXRlbSwgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2lsZW50VmRvbVVwZGF0ZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U2lsZW50VmRvbVVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSA/IChvbGRWYWx1ZSArIDEpIDogMVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChOZW8uaXNOdW1iZXIob2xkVmFsdWUpICYmIG9sZFZhbHVlID4gMCkgPyAob2xkVmFsdWUgLSAxKSA6IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB1cGRhdGVEZXB0aCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFVwZGF0ZURlcHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2xkVmFsdWUgPT09IC0xIHx8IHZhbHVlID09PSAtMSA/IC0xIDogTWF0aC5tYXgodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlIG9mIGEgdmRvbSBvYmplY3QgYXR0cmlidXRlIG9yIHJlbW92ZXMgaXQgaW4gY2FzZSBpdCBoYXMgbm8gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ8T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqL1xuICAgIGNoYW5nZVZkb21Sb290S2V5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgcm9vdCA9IG1lLmdldFZkb21Sb290KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByb290W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHJvb3Rba2V5XVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBjYXNlIHlvdSBuZWVkIGRpZmZlcmVudCBtYXNrIG1hcmt1cHMuXG4gICAgICogVGhlIHJlbW92YWwgbG9naWMgcmVsaWVzIG9uIHRoZSB0b3AgbGV2ZWwgbm9kZSBoYXZpbmcgdGhlIGNscyAnbmVvLWxvYWQtbWFzaydcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBsb2FkaW5nTWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBjcmVhdGVMb2FkaW5nTWFzayhsb2FkaW5nTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xzOiBbJ25lby1sb2FkLW1hc2snXSxcbiAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLWxvYWQtbWFzay1ib2R5J10sXG4gICAgICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgICAgICBjbHM6IHRoaXMubG9hZGluZ1NwaW5uZXJDbHNcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogWyduZW8tbG9hZGluZy1tZXNzYWdlJ10sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogIU5lby5pc1N0cmluZyhsb2FkaW5nTWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIHRleHQgICAgIDogbG9hZGluZ01lc3NhZ2VcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHRvb2x0aXAgaW5zdGFuY2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVUb29sdGlwKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUub3duSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIG1lLl90b29sdGlwID0gTmVvLmNyZWF0ZSgnTmVvLnRvb2x0aXAuQmFzZScsIHtcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuX3Rvb2x0aXAgPSB2YWx1ZTtcbiAgICAgICAgICAgIE5lby50b29sdGlwLkJhc2UuY3JlYXRlU2luZ2xldG9uKG1lLmFwcCk7XG4gICAgICAgICAgICBtZS5hZGRDbHMoJ25lby11c2VzLXNoYXJlZC10b29sdGlwJyk7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciB0aGlzIGluc3RhbmNlIGZyb20gdGhlIENvbXBvbmVudE1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZVBhcmVudFZkb209ZmFsc2UgdHJ1ZSB0byByZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBwYXJlbnQgdmRvbSA9PiByZWFsIGRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlIHRydWUgdG8gdXBkYXRlIHRoZSB2ZG9tIHNpbGVudGx5ICh1c2VmdWwgZm9yIGRlc3Ryb3lpbmcgbXVsdGlwbGUgY2hpbGQgaXRlbXMgaW4gYSByb3cpXG4gICAgICogdG9kbzogdW5yZWdpc3RlciBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95KHVwZGF0ZVBhcmVudFZkb209ZmFsc2UsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnQsIHBhcmVudElkfSA9IG1lLFxuICAgICAgICAgICAgcGFyZW50VmRvbTtcblxuICAgICAgICBtZS5yZXZlcnRGb2N1cygpO1xuXG4gICAgICAgIG1lLmNvbnRyb2xsZXIgPSBudWxsOyAvLyB0cmlnZ2VycyBkZXN0cm95KClcblxuICAgICAgICBtZS5yZWZlcmVuY2UgJiYgbWUuZ2V0Q29udHJvbGxlcigpPy5yZW1vdmVSZWZlcmVuY2UobWUpOyAvLyByZW1vdmUgb3duIHJlZmVyZW5jZSBmcm9tIHBhcmVudCBjb250cm9sbGVyc1xuXG4gICAgICAgIG1lLnBsdWdpbnM/LmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVBhcmVudFZkb20gJiYgcGFyZW50SWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCB7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkOiBtZS52ZG9tLmlkfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50VmRvbSA9IHBhcmVudC52ZG9tO1xuXG4gICAgICAgICAgICAgICAgVkRvbVV0aWwucmVtb3ZlVmRvbUNoaWxkKHBhcmVudFZkb20sIG1lLnZkb20uaWQpO1xuICAgICAgICAgICAgICAgIHBhcmVudFtzaWxlbnQgPyAnX3Zkb20nIDogJ3Zkb20nXSA9IHBhcmVudFZkb21cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcblxuICAgICAgICAvLyBXZSBkbyB3YW50IHRvIHByZXZlbnQgZGVsYXllZCBjYWxscyBhZnRlciBhIGNvbXBvbmVudCBpbnN0YW5jZSBnb3QgZGVzdHJveWVkLlxuICAgICAgICBtZS5vbkZvY3VzTGVhdmUgPSBOZW8uZW1wdHlGbjtcbiAgICAgICAgbWUudW5tb3VudCAgICAgID0gTmVvLmVtcHR5Rm5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgTmVvLm1hbmFnZXIuQ29tcG9uZW50LmRvd25cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD10cnVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBUaGUgbWF0Y2hpbmcgaW5zdGFuY2Ugb3IgbnVsbFxuICAgICAqL1xuICAgIGRvd24oY29uZmlnLCByZXR1cm5GaXJzdE1hdGNoPXRydWUpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1hbmFnZXIuZG93bih0aGlzLCBjb25maWcsIHJldHVybkZpcnN0TWF0Y2gpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgZm9jdXMoKSBvbiB0aGUgdG9wIGxldmVsIERPTSBub2RlIG9mIHRoaXMgY29tcG9uZW50IG9yIG9uIGEgZ2l2ZW4gbm9kZSB2aWEgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQ9dGhpcy5pZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hpbGRyZW49ZmFsc2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZXZlbnRTY3JvbGxcbiAgICAgKi9cbiAgICBmb2N1cyhpZD10aGlzLmlkLCBjaGlsZHJlbj1mYWxzZSwgcHJldmVudFNjcm9sbCkge1xuICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3MuZm9jdXMoe2NoaWxkcmVuLCBpZCwgcHJldmVudFNjcm9sbCwgd2luZG93SWQ6IHRoaXMud2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBkeW5hbWljIHZhbHVlcyBpbnRvIHRoaXMuY2xzXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldEJhc2VDbGFzcygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZmxvYXRpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCduZW8tZmxvYXRpbmcnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcy5jb250cm9sbGVyIG9yIHRoZSBjbG9zZXN0IHBhcmVudCBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtudHlwZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29udHJvbGxlcihudHlwZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY29udHJvbGxlcjtcblxuICAgICAgICBpZiAoIW50eXBlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyID0gbWVbY2xvc2VzdENvbnRyb2xsZXJdO1xuXG4gICAgICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250cm9sbGVyID0gbWUuZ2V0Q29uZmlnSW5zdGFuY2VCeU50eXBlKCdjb250cm9sbGVyJywgbnR5cGUpO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIG1lW2Nsb3Nlc3RDb250cm9sbGVyXSA9IGNvbnRyb2xsZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250cm9sbGVyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gaWQ9dGhpcy5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aW5kb3dJZD10aGlzLndpbmRvd0lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLnV0aWwuUmVjdGFuZ2xlfE5lby51dGlsLlJlY3RhbmdsZVtdPn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXREb21SZWN0KGlkPXRoaXMuaWQsIHdpbmRvd0lkPXRoaXMud2luZG93SWQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMudHJhcChOZW8ubWFpbi5Eb21BY2Nlc3MuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHtpZCwgd2luZG93SWR9KSk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAocmVjdCA9PiBSZWN0YW5nbGUuY2xvbmUocmVjdCkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVjdGFuZ2xlLmNsb25lKHJlc3VsdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmVudCBjb21wb25lbnRzIGFzIGFuIGFycmF5XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGdldFBhcmVudHMoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHModGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7TmVvLnBsdWdpbi5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG9wdHMpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhvcHRzKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRzLnN0YXJ0c1dpdGgoJ3BsdWdpbi0nKSkge1xuICAgICAgICAgICAgICAgIG9wdHMgPSAncGx1Z2luLScgKyBvcHRzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdHMgPSB7bnR5cGU6IG9wdHN9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaGFzTWF0Y2g7XG5cbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgbWUucGx1Z2lucyB8fCBbXSkge1xuICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbltrZXldICE9PSBvcHRzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd24oe3JlZmVyZW5jZTogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhbGtzIHVwIHRoZSB2ZG9tIHRyZWUgYW5kIHJldHVybnMgdGhlIGNsb3Nlc3QgdGhlbWUgZm91bmRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFRoZW1lKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0aGVtZU1hdGNoID0gJ25lby10aGVtZS0nLFxuICAgICAgICAgICAgbWFpblZpZXcsIHBhcmVudE5vZGVzO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtZS5jbHMgfHwgW10pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnN0YXJ0c1dpdGgodGhlbWVNYXRjaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFpblZpZXcgPSBtZS5hcHA/Lm1haW5WaWV3O1xuXG4gICAgICAgIGlmIChtYWluVmlldykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZXMgPSBWRG9tVXRpbC5nZXRQYXJlbnROb2RlcyhtYWluVmlldy52ZG9tLCBtZS5pZCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBwYXJlbnROb2RlcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLmNscyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydHNXaXRoKHRoZW1lTWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5jb25maWcudGhlbWVzPy5bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBjb21wb25lbnQuXG4gICAgICogaGlkZU1vZGU6ICdyZW1vdmVEb20nICB1c2VzIHZkb20gcmVtb3ZlRG9tLlxuICAgICAqIGhpZGVNb2RlOiAndmlzaWJpbGl0eScgdXNlcyBjc3MgdmlzaWJpbGl0eS5cbiAgICAgKiBJZiBoaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScgeW91IGNhbiBwYXNzIGEgdGltZW91dCBmb3IgY3VzdG9tIGNzcyBjbGFzcyBoaWRpbmcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAgICAgKi9cbiAgICBoaWRlKHRpbWVvdXQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGlkZU1vZGUgIT09ICd2aXNpYmlsaXR5Jykge1xuICAgICAgICAgICAgbGV0IHJlbW92ZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChtZS5wYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudW5tb3VudCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQodGltZW91dCkudGhlbihyZW1vdmVGbilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRm4oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gbWUuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBtZS5zdHlsZSA9IHN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICBtZS5faGlkZGVuID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5hdXRvSW5pdFZub2RlICYmIHRoaXMuaW5pdFZub2RlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGNvbXBvbmVudCBvciBhbnkgb2YgaXRzIHBhcmVudHMgaXMgZmxvYXRpbmdcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Zsb2F0aW5nKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5mbG9hdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAgbWUucGFyZW50LmZsb2F0aW5nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAgICovXG4gICAgYXN5bmMgbWVhc3VyZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZW5ndGhSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxldCB7aWQsIHdpbmRvd0lkfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhd2FpdCB0aGlzLnRyYXAoTmVvLm1haW4uRG9tQWNjZXNzLm1lYXN1cmUoe2lkLCB2YWx1ZSwgd2luZG93SWR9KSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgb3JkZXIgY29uZmlncyBhcmUgYXBwbGllZCB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIG1lcmdlQ29uZmlnKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHN1cGVyLm1lcmdlQ29uZmlnKC4uLmFyZ3MpLFxuICAgICAgICAgICAgdmRvbSAgID0gY29uZmlnLnZkb20gfHwgY29uZmlnLl92ZG9tIHx8IHt9O1xuXG4gICAgICAgIC8vIEl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byBtb2RpZnkgcm9vdCBsZXZlbCB2ZG9tIGF0dHJpYnV0ZXMgb24gaW5zdGFuY2UgbGV2ZWwuXG4gICAgICAgIC8vIE5vdGUgdGhhdCB2ZG9tIGlzIG5vdCBhIHJlYWwgY29uZmlnLCBidXQgaW1wbGVtZW50ZWQgdmlhIGdldCgpICYgc2V0KCkuXG4gICAgICAgIHRoaXMuX3Zkb20gPSBOZW8uY2xvbmUoey4uLnZkb20sIC4uLnRoaXMuX3Zkb20gfHwge319LCB0cnVlKTtcblxuICAgICAgICB0aGlzLmVuc3VyZVN0YWJsZUlkcygpO1xuXG4gICAgICAgIGRlbGV0ZSBjb25maWcuX3Zkb207XG4gICAgICAgIGRlbGV0ZSBjb25maWcudmRvbTtcblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuIGdldCBjYWxsZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBnb3Qgdm5vZGVJbml0aWFsaXplZC4gU2VlIHRoZSBhdXRvTW91bnQgY29uZmlnIGFzIHdlbGwuXG4gICAgICogV2UgaGF2ZSBkZWNpZGVkIHRvIGFsd2F5cyBmb3JjZSBhIG5ldyBpbml0Vm5vZGUodHJ1ZSkgY2FsbCBoZXJlLlxuICAgICAqIFJhdGlvbmFsZTpcbiAgICAgKiAxLiBUaGUgb3ZlcmhlYWQgb2YgdHJhY2tpbmcgaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgb24gZXZlcnkgdmRvbSB1cGRhdGUgaXMgcmVtb3ZlZC5cbiAgICAgKiAyLiBUaGUgZWRnZSBjYXNlIG9mIG1vdW50aW5nIGEgcHJlLWNhbGN1bGF0ZWQgYnV0IHVudG91Y2hlZCB2bm9kZSB0cmVlIGlzIDwgMSUuXG4gICAgICogMy4gVGhlIGNvc3Qgb2YgcmUtZ2VuZXJhdGluZyB0aGUgdm5vZGUgdHJlZSBpcyBsb3cgZW5vdWdoIHRvIGp1c3RpZnkgdGhlIHJvYnVzdG5lc3MgYW5kIHNpbXBsaWNpdHkuXG4gICAgICogNC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIERPTSBpcyBhbHdheXMgbW91bnRlZCB3aXRoIHRoZSBtb3N0IHVwLXRvLWRhdGUgdmRvbSBzdGF0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdFZub2RlKHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG4gICAgICAgIHRoaXMua2V5cz8ucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU2Nyb2xsQ2FwdHVyZShkYXRhKSB7XG4gICAgICAgIHN1cGVyLm9uU2Nyb2xsQ2FwdHVyZShkYXRhKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5fdmRvbSkge1xuICAgICAgICAgICAgbGV0IHZkb21Ob2RlID0gVkRvbVV0aWwuZ2V0QnlJZChtZS5fdmRvbSwgZGF0YS50YXJnZXQuaWQpO1xuXG4gICAgICAgICAgICBpZiAodmRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICB2ZG9tTm9kZS5zY3JvbGxUb3AgID0gZGF0YS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdmRvbU5vZGUuc2Nyb2xsTGVmdCA9IGRhdGEuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkZvY3VzRW50ZXIoZGF0YSkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgaGlkZGVuLCBvciB1bm1vdW50ZWQgd2hpbGUgd2Ugc3RpbGwgY29udGFpbiBmb2N1cywgd2UgaGF2ZSB0byByZXZlcnRcbiAgICAgICAgLy8gZm9jdXMgdG8gd2hlcmUgaXQgY2FtZSBmcm9tIGlmIHBvc3NpYmxlXG4gICAgICAgIHRoaXMuZm9jdXNFbnRlckRhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICB0aGlzLmZvY3VzRW50ZXJEYXRhID0gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBtYW5hZ2VyLkZvY3VzXG4gICAgICogQG5hbWUgb25Gb2N1c0VudGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJ5IG1hbmFnZXIuRm9jdXNcbiAgICAgKiBAbmFtZSBvbkZvY3VzTGVhdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgbWFuYWdlci5Gb2N1c1xuICAgICAqIEBuYW1lIG9uRm9jdXNNb3ZlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5uZXdQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMub2xkUGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY2xzIGZyb20gdGhlIHZkb21Sb290XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgcmVtb3ZlQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIHN0cmluZyBsaWtlICdjb2xvcicgb3IgYW4gYXJyYXkgY29udGFpbmluZyBzdHlsZSBhdHRyaWJ1dGVzIHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB2YWx1ZSBjYW1lbENhc2Ugb25seVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFsbCBzdHlsZXMgb2YgdGhpcy5lbFxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHtzdHlsZX0gID0gdGhpcyxcbiAgICAgICAgICAgIGRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICAgICAgICAgICAgICAgIGRvVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZXZlcnRGb2N1cygpIHtcbiAgICAgICAgbGV0IHJlbGF0ZWRUYXJnZXQgPSB0aGlzLmZvY3VzRW50ZXJEYXRhPy5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zRm9jdXMgJiYgcmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgTmVvLmdldENvbXBvbmVudChyZWxhdGVkVGFyZ2V0LmlkKT8uZm9jdXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgY29tcG9uZW50LlxuICAgICAqIGhpZGVNb2RlOiAncmVtb3ZlRG9tJyAgdXNlcyB2ZG9tIHJlbW92ZURvbS5cbiAgICAgKiBoaWRlTW9kZTogJ3Zpc2liaWxpdHknIHVzZXMgY3NzIHZpc2liaWxpdHkuXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGlkZU1vZGUgIT09ICd2aXNpYmlsaXR5Jykge1xuICAgICAgICAgICAgZGVsZXRlIG1lLnZkb20ucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICBpZiAobWUuc2lsZW50VmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIG1lLm5lZWRzVmRvbVVwZGF0ZSA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWUucGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgICAgIG1lLnBhcmVudC51cGRhdGVEZXB0aCA9IC0xO1xuICAgICAgICAgICAgICAgIG1lLnBhcmVudC51cGRhdGUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAhbWUubW91bnRlZCAmJiBtZS5pbml0Vm5vZGUodHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IG1lLnN0eWxlO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzZXQgbnVsbCwgc2luY2UgdGhlIHN0eWxlIG1pZ2h0IGJlIGluc2lkZSB3cmFwcGVyU3R5bGUsXG4gICAgICAgICAgICAvLyB3aGljaCB3b3VsZCBnZXQgcmUtYXBwbGllZCBpbiBjYXNlIHdlIGp1c3QgZGVsZXRlIHRoZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSBudWxsO1xuICAgICAgICAgICAgbWUuc3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuX2hpZGRlbiA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIGEgY2xzIGluc2lkZSB0aGUgdmRvbVJvb3Qgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FkZF0gVXNlIHRoaXMgcGFyYW0gdG8gZW5mb3JjZSBhbiBhZGQoKSBvciByZW1vdmUoKSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgdG9nZ2xlQ2xzKHZhbHVlLCBhZGQpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnRvZ2dsZShjbHMsIHZhbHVlLCBhZGQpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbXBvbmVudCBET01cbiAgICAgKi9cbiAgICB1bm1vdW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZTtcblxuICAgICAgICBtZS5faGlkZGVuID0gdHJ1ZTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICBtZS5tb3VudGVkID0gZmFsc2U7XG5cbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCB7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkOiBtZS52ZG9tLmlkfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgTmVvLm1hbmFnZXIuQ29tcG9uZW50LnVwXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFRoZSBtYXRjaGluZyBpbnN0YW5jZSBvciBudWxsXG4gICAgICovXG4gICAgdXAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLnVwKHRoaXMuaWQsIGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBjb21wb25lbnQgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogRXh0ZW5kcyB0aGUgY29yZS5CYXNlIHNlcmlhbGl6YXRpb24gd2l0aCBjb21wb25lbnQtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBhbGlnbiAgICAgICA6IG1lLmFsaWduLFxuICAgICAgICAgICAgY2xzICAgICAgICAgOiBtZS5jbHMsXG4gICAgICAgICAgICBjb250cm9sbGVyICA6IG1lLmNvbnRyb2xsZXI/LnRvSlNPTigpLFxuICAgICAgICAgICAgZGlzYWJsZWQgICAgOiBtZS5kaXNhYmxlZCxcbiAgICAgICAgICAgIGhlaWdodCAgICAgIDogbWUuaGVpZ2h0LFxuICAgICAgICAgICAgaGlkZGVuICAgICAgOiBtZS5oaWRkZW4sXG4gICAgICAgICAgICBrZXlzICAgICAgICA6IG1lLmtleXM/LnRvSlNPTigpLFxuICAgICAgICAgICAgcmVmZXJlbmNlICAgOiBtZS5yZWZlcmVuY2UsXG4gICAgICAgICAgICByb2xlICAgICAgICA6IG1lLnJvbGUsXG4gICAgICAgICAgICBzdHlsZSAgICAgICA6IG1lLnN0eWxlLFxuICAgICAgICAgICAgdGhlbWUgICAgICAgOiBtZS50aGVtZSxcbiAgICAgICAgICAgIHVpICAgICAgICAgIDogbWUudWksXG4gICAgICAgICAgICB2ZG9tICAgICAgICA6IG1lLnZkb20sXG4gICAgICAgICAgICB2bm9kZSAgICAgICA6IG1lLnZub2RlLFxuICAgICAgICAgICAgd2lkdGggICAgICAgOiBtZS53aWR0aCxcbiAgICAgICAgICAgIHdyYXBwZXJDbHMgIDogbWUud3JhcHBlckNscyxcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZTogbWUud3JhcHBlclN0eWxlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZVN0eWxlKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3Zkb219ICAgPSBtZSxcbiAgICAgICAgICAgIHZkb21Sb290ID0gbWUuZ2V0VmRvbVJvb3QoKTtcblxuICAgICAgICBpZiAodmRvbSAhPT0gdmRvbVJvb3QpIHtcbiAgICAgICAgICAgIHZkb20gICAgLnN0eWxlID0gbWUud3JhcHBlclN0eWxlO1xuICAgICAgICAgICAgdmRvbVJvb3Quc3R5bGUgPSBtZS5zdHlsZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmRvbS5zdHlsZSA9IHsuLi5tZS53cmFwcGVyU3R5bGUsIC4uLm1lLnN0eWxlfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHlvdSBhcmUgc3VyZSBhIERPTVJlY3QgZXhpc3RzLCB1c2UgZ2V0RG9tUmVjdCgpXG4gICAgICogT3RoZXJ3aXNlIHlvdSBjYW4gd2FpdCBmb3IgaXQgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAgICogQGV4YW1wbGU6XG4gICAgICogICAgIGF3YWl0IHRoaXMuaW5pdFZub2RlKHRydWUpO1xuICAgICAqICAgICBhd2FpdCB0aGlzLndhaXRGb3JEb21SZWN0KCk7XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIG9wdHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgb3B0cy5hdHRlbXB0cz0xMCBSZXJ1bnMgaW4gY2FzZSB0aGUgcmVjdCBoZWlnaHQgb3Igd2lkdGggZXF1YWxzIDBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgb3B0cy5kZWxheT01MCAgICBUaW1lIGluIG1zIGJlZm9yZSBjaGVja2luZyBhZ2FpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBvcHRzLmlkPXRoaXMuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgb3B0cy53aW5kb3dJZD10aGlzLndpbmRvd0lkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLnV0aWwuUmVjdGFuZ2xlfE5lby51dGlsLlJlY3RhbmdsZVtdPn1cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRG9tUmVjdCh7YXR0ZW1wdHM9MTAsIGRlbGF5PTUwLCBpZD10aGlzLmlkLCB3aW5kb3dJZD10aGlzLndpbmRvd0lkfSA9IHt9KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChpZCksXG4gICAgICAgICAgICByZVJ1biAgPSBmYWxzZTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaChyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5oZWlnaHQgPCAxIHx8IHJlY3Qud2lkdGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlUnVuID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmhlaWdodCA8IDEgfHwgcmVzdWx0LndpZHRoIDwgMSkge1xuICAgICAgICAgICAgcmVSdW4gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVSdW4gJiYgYXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KGRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBtZS53YWl0Rm9yRG9tUmVjdCh7YXR0ZW1wdHM6IGF0dGVtcHRzLTEsIGRlbGF5LCBpZCwgd2luZG93SWR9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbn1cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCBhZnRlciBmb2N1c0VudGVyLCBmb2N1c0xlYXZlIG9yIGZvY3VzTW92ZVxuICogQGV2ZW50IGZvY3VzQ2hhbmdlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gW2RhdGEucGF0aF0gZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqIEBwYXJhbSB7T2JqZWN0W119IFtkYXRhLm9sZFBhdGhdIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgaW5jbHVkZWQgaW5zaWRlIHRoZSBkb20gaWQgcGF0aFxuICogQGV2ZW50IGZvY3VzRW50ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqL1xuXG4vKipcbiAqIG1hbmFnZXIuRm9jdXMgZmlyZXMgdGhlIGV2ZW50IHdoZW4gdGhlIGNvbXBvbmVudCBpZCBpcyBub3QgaW5jbHVkZWQgaW5zaWRlIHRoZSBkb20gaWQgcGF0aFxuICogQGV2ZW50IGZvY3VzTGVhdmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqL1xuXG4vKipcbiAqIG1hbmFnZXIuRm9jdXMgZmlyZXMgdGhlIGV2ZW50IHdoZW4gdGhlIGNvbXBvbmVudCBpZCBpcyBpbmNsdWRlZCBpbnNpZGUgdGhlIGRvbSBpZCBwYXRoLCBidXQgdGhlIHBhdGggaXRzZWxmIGNoYW5nZWRcbiAqIEBldmVudCBmb2N1c01vdmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEub2xkUGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbXBvbmVudCk7XG4iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcblxuLyoqXG4gKiBUaGUgVkRvbVVwZGF0ZSBtYW5hZ2VyIGlzIGEgc2luZ2xldG9uIHJlc3BvbnNpYmxlIGZvciBvcmNoZXN0cmF0aW5nIGFuZCBvcHRpbWl6aW5nXG4gKiBjb21wb25lbnQgVkRPTSB1cGRhdGVzIHdpdGhpbiB0aGUgTmVvLm1qcyBmcmFtZXdvcmsuIEl0IGFjdHMgYXMgYSBjZW50cmFsIGNvb3JkaW5hdG9yXG4gKiB0byBvcHRpbWl6ZSB0aGUgVkRPTSB1cGRhdGUgcHJvY2Vzcy4gSXRzIHByaW1hcnkgZ29hbCBpcyB0byByZWR1Y2UgdGhlIGFtb3VudCBvZlxuICogbWVzc2FnZSByb3VuZHRyaXBzIGJldHdlZW4gdGhlIGFwcGxpY2F0aW9uIGFuZCBWRE9NIHdvcmtlcnMgYnkgYWdncmVnYXRpbmcgbXVsdGlwbGVcbiAqIGNvbXBvbmVudCB1cGRhdGVzIGludG8gYSBzaW5nbGUsIG9wdGltaXplZCBWRE9NIHRyZWUuXG4gKlxuICogS2V5IFJlc3BvbnNpYmlsaXRpZXM6XG4gKiAxLiAqKlVwZGF0ZSBNZXJnaW5nICYgQWdncmVnYXRpb246KiogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhYnNvcmIgdGhlIHVwZGF0ZVxuICogICAgcmVxdWVzdHMgb2YgaXRzIGNoaWxkcmVuLiBJbnN0ZWFkIG9mIGVhY2ggY2hpbGQgdHJpZ2dlcmluZyBhIHNlcGFyYXRlIFZET00gdXBkYXRlXG4gKiAgICBtZXNzYWdlIHRvIHRoZSBWRE9NIHdvcmtlciwgdGhlIHBhcmVudCBzZW5kcyBhIHNpbmdsZSwgYWdncmVnYXRlZCBWRE9NIHRyZWUuIFRoaXNcbiAqICAgIHNpZ25pZmljYW50bHkgcmVkdWNlcyB0aGUgb3ZlcmhlYWQgb2Ygd29ya2VyIGNvbW11bmljYXRpb24gYW5kIGNhbiByZXN1bHQgaW4gc21hbGxlcixcbiAqICAgIG1vcmUgZm9jdXNlZCBkYXRhIGZvciB0aGUgVkRPTSB3b3JrZXIgdG8gcHJvY2Vzcy4gV2hpbGUgdGhlIGFtb3VudCBvZiBmaW5hbCBET01cbiAqICAgIG1vZGlmaWNhdGlvbnMgcmVtYWlucyB0aGUgc2FtZSwgdGhpcyBhZ2dyZWdhdGlvbiBpcyBrZXkgdG8gcGVyZm9ybWFuY2UuXG4gKlxuICogICAgKipUZWxlcG9ydGF0aW9uIChEaXNqb2ludCBVcGRhdGVzKToqKiBUaGUgbWFuYWdlciBub3cgc3VwcG9ydHMgcHJvY2Vzc2luZyBtdWx0aXBsZVxuICogICAgZGlzam9pbnQgY29tcG9uZW50cyBpbiBhIHNpbmdsZSBcIlRlbGVwb3J0YXRpb25cIiBiYXRjaC4gVGhpcyBhbGxvd3MgZGVlcCBkZXNjZW5kYW50c1xuICogICAgdG8gdXBkYXRlIGluIHBhcmFsbGVsIHdpdGggdGhlaXIgYW5jZXN0b3JzIHdpdGhvdXQgcmVxdWlyaW5nIHRoZSBhbmNlc3RvciB0byBcImJyaWRnZVwiXG4gKiAgICB0aGUgZ2FwLCBlbGltaW5hdGluZyBPKE4pIG92ZXJoZWFkIGZvciBkZWVwIHVwZGF0ZXMuXG4gKlxuICogMi4gKipBc3luY2hyb25vdXMgRmxvdyBDb250cm9sOioqIE1hbmFnZXMgdGhlIGFzeW5jaHJvbm91cyBuYXR1cmUgb2YgVkRPTSB1cGRhdGVzLCB3aGljaFxuICogICAgYXJlIG9mdGVuIHByb2Nlc3NlZCBpbiBhIHdvcmtlciB0aHJlYWQuIEl0IGVuc3VyZXMgdGhhdCBjb2RlIGF3YWl0aW5nIGFuIHVwZGF0ZVxuICogICAgKGUuZy4sIHZpYSBhIHJldHVybmVkIFByb21pc2UpIGlzIGNvcnJlY3RseSBub3RpZmllZCB1cG9uIGNvbXBsZXRpb24uXG4gKlxuICogMy4gKipEZXBlbmRlbmN5IENoYWluaW5nOioqIFByb3ZpZGVzIGEgXCJwb3N0LXVwZGF0ZVwiIHF1ZXVlLCBhbGxvd2luZyBvbmUgY29tcG9uZW50J3NcbiAqICAgIHVwZGF0ZSB0byBiZSBkZWNsYXJhdGl2ZWx5IGNoYWluZWQgdG8gYW5vdGhlcidzLCBlbnN1cmluZyBhIHByZWRpY3RhYmxlIG9yZGVyIG9mXG4gKiAgICBvcGVyYXRpb25zLlxuICpcbiAqIDQuICoqU3RhdGUgVHJhY2tpbmc6KiogS2VlcHMgdHJhY2sgb2YgdXBkYXRlcyB0aGF0IGFyZSBcImluLWZsaWdodFwiIChpLmUuLCBjdXJyZW50bHlcbiAqICAgIGJlaW5nIHByb2Nlc3NlZCksIHdoaWNoIGhlbHBzIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyBhbmQgcmVkdW5kYW50IHdvcmsuXG4gKlxuICogQnkgY2VudHJhbGl6aW5nIHRoZXNlIGNvbmNlcm5zLCBWRG9tVXBkYXRlIHBsYXlzIGEgY3JpdGljYWwgcm9sZSBpbiB0aGUgZnJhbWV3b3JrJ3NcbiAqIHBlcmZvcm1hbmNlIGFuZCByZW5kZXJpbmcgZWZmaWNpZW5jeS5cbiAqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuVkRvbVVwZGF0ZVxuICogQGV4dGVuZHMgTmVvLmNvbGxlY3Rpb24uQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBWRG9tVXBkYXRlIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5WRG9tVXBkYXRlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5WRG9tVXBkYXRlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29sbGVjdGlvbiB0aGF0IG1hcHMgYSBwYXJlbnQgY29tcG9uZW50J3MgSUQgKGBvd25lcklkYCkgdG8gdGhlIHNldCBvZiBjaGlsZFxuICAgICAgICAgKiBjb21wb25lbnRzIHdob3NlIFZET00gdXBkYXRlcyBoYXZlIGJlZW4gbWVyZ2VkIGludG8gdGhhdCBwYXJlbnQncyB1cGRhdGUgY3ljbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzdHJ1Y3R1cmUgZm9yIGVhY2ggZW50cnkgaXM6XG4gICAgICAgICAqIGB7IG93bmVySWQ6ICdwYXJlbnQtaWQnLCBjaGlsZHJlbjogTWFwPCdjaGlsZC1pZCcsIHtjaGlsZFVwZGF0ZURlcHRoLCBkaXN0YW5jZX0+IH1gXG4gICAgICAgICAqXG4gICAgICAgICAqIC0gYG93bmVySWRgOiBUaGUgYGlkYCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudCB0YWtpbmcgcmVzcG9uc2liaWxpdHkgZm9yIHRoZSB1cGRhdGUuXG4gICAgICAgICAqIC0gYGNoaWxkcmVuYDogQSBNYXAgd2hlcmUga2V5cyBhcmUgdGhlIGBpZGBzIG9mIHRoZSBtZXJnZWQgY2hpbGRyZW4gYW5kIHZhbHVlc1xuICAgICAgICAgKiAgIGFyZSBvYmplY3RzIGNvbnRhaW5pbmcgbWV0YWRhdGEgbmVlZGVkIHRvIGNhbGN1bGF0ZSB0aGUgdG90YWwgdXBkYXRlIHNjb3BlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IG1lcmdlZENhbGxiYWNrTWFwPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VkQ2FsbGJhY2tNYXA6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbGxlY3Rpb24gdGhhdCBxdWV1ZXMgY29tcG9uZW50cyB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZCBpbW1lZGlhdGVseSBhZnRlclxuICAgICAgICAgKiBhbm90aGVyIGNvbXBvbmVudCdzIHVwZGF0ZSBjeWNsZSBjb21wbGV0ZXMuIFRoaXMgaXMgdXNlZCB0byBoYW5kbGUgcmVuZGVyaW5nXG4gICAgICAgICAqIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHN0cnVjdHVyZSBmb3IgZWFjaCBlbnRyeSBpczpcbiAgICAgICAgICogYHsgb3duZXJJZDogJ2NvbXBvbmVudC1pZCcsIGNoaWxkcmVuOiBbe2NoaWxkSWQsIHJlc29sdmV9XSB9YFxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGBvd25lcklkYDogVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCB3aG9zZSB1cGRhdGUgY29tcGxldGlvbiB3aWxsIHRyaWdnZXIgdGhlIHF1ZXVlZCB1cGRhdGVzLlxuICAgICAgICAgKiAtIGBjaGlsZHJlbmA6IEFuIGFycmF5IG9mIG9iamVjdHMsIHdoZXJlIGBjaGlsZElkYCBpcyB0aGUgY29tcG9uZW50IHRvIHVwZGF0ZSBhbmRcbiAgICAgICAgICogICBgcmVzb2x2ZWAgaXMgdGhlIFByb21pc2UgcmVzb2x2ZXIgdG8gY2FsbCBhZnRlciB0aGF0IHN1YnNlcXVlbnQgdXBkYXRlIGlzIGRvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb2xsZWN0aW9uLkJhc2V8bnVsbH0gcG9zdFVwZGF0ZVF1ZXVlTWFwPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcG9zdFVwZGF0ZVF1ZXVlTWFwOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBNYXAgdGhhdCB0cmFja3MgdGhlIGluLWZsaWdodCB1cGRhdGUgc3RhdHVzIG9mIGRlc2NlbmRhbnRzIGZvciBlYWNoIGNvbXBvbmVudC5cbiAgICAgKiBUaGlzIFwiUmV2ZXJzZSBMb29rdXBcIiBtYXAgYWxsb3dzIGFuY2VzdG9yIGNvbXBvbmVudHMgdG8gY2hlY2sgaWYgYW55IG9mIHRoZWlyXG4gICAgICogZGVzY2VuZGFudHMgYXJlIGN1cnJlbnRseSB1cGRhdGluZyBpbiBPKDEpIHRpbWUsIHdpdGhvdXQgd2Fsa2luZyB0aGUgdHJlZSBkb3dud2FyZHMuXG4gICAgICpcbiAgICAgKiBLZXk6IGFuY2VzdG9ySWQsIFZhbHVlOiBNYXA8ZGVzY2VuZGFudElkLCB0cnVlPlxuICAgICAqXG4gICAgICogVGhpcyBpcyBjcnVjaWFsIGZvciB0aGUgYFZkb21MaWZlY3ljbGUuaXNDaGlsZFVwZGF0aW5nYCBndWFyZCwgd2hpY2ggcHJldmVudHNcbiAgICAgKiByYWNlIGNvbmRpdGlvbnMgd2hlcmUgYSBwYXJlbnQgdXBkYXRlIG1pZ2h0IGNsb2JiZXIgYSBjb25jdXJyZW50IGNoaWxkIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge01hcDxTdHJpbmcsIE1hcDxTdHJpbmcsIEJvb2xlYW4+Pn0gZGVzY2VuZGFudEluRmxpZ2h0TWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkZXNjZW5kYW50SW5GbGlnaHRNYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBBIE1hcCB0aGF0IHRyYWNrcyBWRE9NIHVwZGF0ZXMgdGhhdCBoYXZlIGJlZW4gZGlzcGF0Y2hlZCB0byB0aGUgVkRPTSB3b3JrZXIgYnV0XG4gICAgICogaGF2ZSBub3QgeWV0IGNvbXBsZXRlZC4gVGhpcyBwcmV2ZW50cyByZWR1bmRhbnQgdXBkYXRlcyBmb3IgdGhlIHNhbWUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogVGhlIHN0cnVjdHVyZSBpczogYE1hcDwnY29tcG9uZW50LWlkJywgdXBkYXRlRGVwdGg+YFxuICAgICAqXG4gICAgICogQG1lbWJlciB7TWFwfG51bGx9IGluRmxpZ2h0VXBkYXRlTWFwPW51bGxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5GbGlnaHRVcGRhdGVNYXAgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEEgTWFwIHRoYXQgc3RvcmVzIGNhbGxiYWNrcyB0byBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBhZnRlciBhIGNvbXBvbmVudCdzIFZET00gdXBkYXRlXG4gICAgICogZmluaXNoZXMsIGJ1dCBCRUZPUkUgdGhlIGBuZWVkc1Zkb21VcGRhdGVgIGNoZWNrIGZvciB0aGUgbmV4dCBjeWNsZS5cbiAgICAgKlxuICAgICAqIEtleTogY29tcG9uZW50SWQsIFZhbHVlOiBjYWxsYmFjayBGdW5jdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7TWFwPFN0cmluZywgRnVuY3Rpb24+fSBwcmVVcGRhdGVNYXA9bmV3IE1hcCgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByZVVwZGF0ZU1hcCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEEgTWFwIHRoYXQgc3RvcmVzIFByb21pc2UgYHJlc29sdmVgIGZ1bmN0aW9ucyBhc3NvY2lhdGVkIHdpdGggYSBjb21wb25lbnQncyB1cGRhdGUuXG4gICAgICogV2hlbiBhIGNvbXBvbmVudCdzIFZET00gdXBkYXRlIGlzIGZpbmFsaXplZCwgdGhlIGNhbGxiYWNrcyBmb3IgaXRzIElEIGFyZSBleGVjdXRlZCxcbiAgICAgKiByZXNvbHZpbmcgdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGNvbXBvbmVudCdzIGB1cGRhdGUoKWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogVGhlIHN0cnVjdHVyZSBpczogYE1hcDwnY29tcG9uZW50LWlkJywgW2NhbGxiYWNrMSwgY2FsbGJhY2syLCAuLi5dPmBcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge01hcHxudWxsfSBwcm9taXNlQ2FsbGJhY2tNYXA9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm9taXNlQ2FsbGJhY2tNYXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG1hbmFnZXIncyBpbnRlcm5hbCBjb2xsZWN0aW9ucyBhbmQgbWFwcy5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBpcyBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5pbkZsaWdodFVwZGF0ZU1hcCAgPSBuZXcgTWFwKCk7XG4gICAgICAgIG1lLm1lcmdlZENhbGxiYWNrTWFwICA9IE5lby5jcmVhdGUoQ29sbGVjdGlvbiwge2tleVByb3BlcnR5OiAnb3duZXJJZCd9KTtcbiAgICAgICAgbWUucG9zdFVwZGF0ZVF1ZXVlTWFwID0gTmVvLmNyZWF0ZShDb2xsZWN0aW9uLCB7a2V5UHJvcGVydHk6ICdvd25lcklkJ30pO1xuICAgICAgICBtZS5wcm9taXNlQ2FsbGJhY2tNYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBhIHNwZWNpZmljIGNvbXBvbmVudCdzXG4gICAgICogVkRPTSB1cGRhdGUgY29tcGxldGVzLiBUaGlzIGlzIHRoZSBtZWNoYW5pc20gdGhhdCByZXNvbHZlcyB0aGUgUHJvbWlzZVxuICAgICAqIHJldHVybmVkIGJ5IGBDb21wb25lbnQjdXBkYXRlKClgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIG93bmVySWQgIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgb3duaW5nIHRoZSB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgdXBvbiBjb21wbGV0aW9uLlxuICAgICAqL1xuICAgIGFkZFByb21pc2VDYWxsYmFjayhvd25lcklkLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUucHJvbWlzZUNhbGxiYWNrTWFwLmhhcyhvd25lcklkKSkge1xuICAgICAgICAgICAgbWUucHJvbWlzZUNhbGxiYWNrTWFwLnNldChvd25lcklkLCBbXSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnByb21pc2VDYWxsYmFja01hcC5nZXQob3duZXJJZCkucHVzaChjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhbGwgY2FsbGJhY2tzIGFzc29jaWF0ZWQgd2l0aCBhIGNvbXBsZXRlZCBWRE9NIHVwZGF0ZSBmb3IgYSBnaXZlbiBgb3duZXJJZGAuXG4gICAgICogVGhpcyBtZXRob2QgZmlyc3QgcHJvY2Vzc2VzIGNhbGxiYWNrcyBmb3IgYW55IGNoaWxkcmVuIHRoYXQgd2VyZSBtZXJnZWQgaW50byB0aGlzXG4gICAgICogdXBkYXRlIGN5Y2xlLCB0aGVuIGV4ZWN1dGVzIHRoZSBjYWxsYmFja3MgZm9yIHRoZSBgb3duZXJJZGAgaXRzZWxmLlxuICAgICAqXG4gICAgICogKipUZWxlcG9ydGF0aW9uIC8gQmF0Y2ggU3VwcG9ydDoqKlxuICAgICAqIFRoZSBgcHJvY2Vzc2VkQ2hpbGRJZHNgIGFyZ3VtZW50IGlzIGNydWNpYWwgZm9yIERpc2pvaW50IFVwZGF0ZXMuIEl0IGVuc3VyZXMgd2Ugb25seVxuICAgICAqIGV4ZWN1dGUgY2FsbGJhY2tzIGZvciBjaGlsZHJlbiB0aGF0IHdlcmUgKmFjdHVhbGx5KiBpbmNsdWRlZCBpbiB0aGUgVkRPTSBwYXlsb2FkLlxuICAgICAqIENoaWxkcmVuIHRoYXQgd2VyZSBmaWx0ZXJlZCBvdXQgKGUuZy4gZHVlIHRvIGNvbGxpc2lvbnMgd2l0aCBhIHBhcmVudCB1cGRhdGUpIHdpbGxcbiAgICAgKiBOT1QgaGF2ZSB0aGVpciBjYWxsYmFja3MgZXhlY3V0ZWQgaGVyZTsgdGhleSB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIGNvdmVyaW5nIHBhcmVudCdzIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCB3aG9zZSB1cGRhdGUgaGFzIGp1c3QgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gIE9wdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2tzLlxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gW3Byb2Nlc3NlZENoaWxkSWRzXSBJRHMgb2YgY2hpbGRyZW4gYWN0dWFsbHkgaW5jbHVkZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgICovXG4gICAgZXhlY3V0ZUNhbGxiYWNrcyhvd25lcklkLCBkYXRhLCBwcm9jZXNzZWRDaGlsZElkcykge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gICAgICAgICA9IG1lLm1lcmdlZENhbGxiYWNrTWFwLmdldChvd25lcklkKSxcbiAgICAgICAgICAgIGNhbGxiYWNrRGF0YSA9IGRhdGEgPyBbZGF0YV0gOiBbXTtcblxuICAgICAgICBpZiAoaXRlbSAmJiBwcm9jZXNzZWRDaGlsZElkcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZElkIG9mIHByb2Nlc3NlZENoaWxkSWRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4uaGFzKGNoaWxkSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmV4ZWN1dGVQcm9taXNlQ2FsbGJhY2tzKGNoaWxkSWQsIC4uLmNhbGxiYWNrRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZGVsZXRlKGNoaWxkSWQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbi5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUubWVyZ2VkQ2FsbGJhY2tNYXAucmVtb3ZlKG93bmVySWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5leGVjdXRlUHJvbWlzZUNhbGxiYWNrcyhvd25lcklkLCAuLi5jYWxsYmFja0RhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuZCBleGVjdXRlcyB0aGUgcmVnaXN0ZXJlZCBQcmUtVXBkYXRlIGNhbGxiYWNrIGZvciBhIGNvbXBvbmVudC5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBieSBWZG9tTGlmZWN5Y2xlIGp1c3QgYmVmb3JlIGNoZWNraW5nIGBuZWVkc1Zkb21VcGRhdGVgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgY29tcG9uZW50IElELlxuICAgICAqL1xuICAgIGV4ZWN1dGVQcmVVcGRhdGVzKGlkKSB7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IHRoaXMucHJlVXBkYXRlTWFwLmdldChpZCk7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnByZVVwZGF0ZU1hcC5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgaW52b2tlcyBhbGwgcmVnaXN0ZXJlZCBwcm9taXNlIGNhbGxiYWNrcyBmb3IgYSBnaXZlblxuICAgICAqIGNvbXBvbmVudCBJRCBhbmQgdGhlbiBjbGVhcnMgdGhlbSBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCBUaGUgYGlkYCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gIE9wdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2tzLlxuICAgICAqL1xuICAgIGV4ZWN1dGVQcm9taXNlQ2FsbGJhY2tzKG93bmVySWQsIGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjYWxsYmFja3MgPSBtZS5wcm9taXNlQ2FsbGJhY2tNYXAuZ2V0KG93bmVySWQpO1xuXG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0oZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lLnByb21pc2VDYWxsYmFja01hcC5kZWxldGUob3duZXJJZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSByZXF1aXJlZCBgdXBkYXRlRGVwdGhgIGZvciBhIHBhcmVudCBjb21wb25lbnQgYmFzZWQgb24gaXRzIG93blxuICAgICAqIG5lZWRzIGFuZCB0aGUgbmVlZHMgb2YgYWxsIGNoaWxkIGNvbXBvbmVudHMgd2hvc2UgdXBkYXRlcyBoYXZlIGJlZW4gbWVyZ2VkIGludG8gaXQuXG4gICAgICogVGhlIGZpbmFsIGRlcHRoIGlzIHRoZSBtYXhpbXVtIHJlcXVpcmVkIGRlcHRoIHRvIGVuc3VyZSBhbGwgY2hhbmdlcyBhcmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYSBwYXJlbnQgbmVlZHMgdG8gdXBkYXRlIGl0cyBkaXJlY3QgY29udGVudCAoYHVwZGF0ZURlcHRoOiAxYCkgYnV0XG4gICAgICogYSBtZXJnZWQgY2hpbGQgMyBsZXZlbHMgZG93biBuZWVkcyBhIGZ1bGwgc3VidHJlZSB1cGRhdGUgKGBjaGlsZFVwZGF0ZURlcHRoOiAtMWApLFxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIC0xLCBzaWduYWxpbmcgYSBmdWxsIHJlY3Vyc2l2ZSB1cGRhdGUgZnJvbSB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBwYXJlbnQgY29tcG9uZW50IHJpZ2h0IGJlZm9yZSBpdCBkaXNwYXRjaGVzIGl0cyBWRE9NIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCBUaGUgYGlkYCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfG51bGx9IFRoZSBhZGp1c3RlZCB1cGRhdGUgZGVwdGgsIG9yIGBudWxsYCBpZiBubyBtZXJnZWQgY2hpbGRyZW4gZXhpc3QuXG4gICAgICovXG4gICAgZ2V0QWRqdXN0ZWRVcGRhdGVEZXB0aChvd25lcklkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciAgICA9IE5lby5nZXRDb21wb25lbnQob3duZXJJZCksXG4gICAgICAgICAgICBpdGVtICAgICA9IG1lLm1lcmdlZENhbGxiYWNrTWFwLmdldChvd25lcklkKSxcbiAgICAgICAgICAgIG1heERlcHRoID0gb3duZXI/LnVwZGF0ZURlcHRoID8/IDEsXG4gICAgICAgICAgICBuZXdEZXB0aDtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVtLmNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNoaWxkVXBkYXRlRGVwdGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RlcHRoID0gLTFcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV3IGRlcHRoIGlzIHRoZSBkaXN0YW5jZSB0byB0aGUgY2hpbGQgcGx1cyB0aGUgY2hpbGQncyBvd24gcmVxdWlyZWQgdXBkYXRlIGRlcHRoLlxuICAgICAgICAgICAgICAgICAgICBuZXdEZXB0aCA9IHZhbHVlLmRpc3RhbmNlICsgdmFsdWUuY2hpbGRVcGRhdGVEZXB0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXdEZXB0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGggPSAtMVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF4RGVwdGggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIG5ld0RlcHRoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1heERlcHRoXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGNvbXBvbmVudCBoYXMgYW55IGRlc2NlbmRhbnRzIGN1cnJlbnRseSB1bmRlcmdvaW5nIGEgVkRPTSB1cGRhdGUuXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBieSBgVmRvbUxpZmVjeWNsZWAgdG8gZGV0ZWN0IHBvdGVudGlhbCByYWNlIGNvbmRpdGlvbnNcbiAgICAgKiBiZWZvcmUgc3RhcnRpbmcgYSBwYXJlbnQgdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFRoZSBjb21wb25lbnQgSUQgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgYW55IGRlc2NlbmRhbnQgaXMgaW4tZmxpZ2h0LlxuICAgICAqL1xuICAgIGhhc0luRmxpZ2h0RGVzY2VuZGFudHMob3duZXJJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXNjZW5kYW50SW5GbGlnaHRNYXAuaGFzKG93bmVySWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBgdXBkYXRlRGVwdGhgIGZvciBhIGNvbXBvbmVudCdzIHVwZGF0ZSB0aGF0IGlzIGN1cnJlbnRseSBpbi1mbGlnaHQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCBvd25pbmcgdGhlIHVwZGF0ZS5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfHVuZGVmaW5lZH0gVGhlIHVwZGF0ZSBkZXB0aCwgb3IgYHVuZGVmaW5lZGAgaWYgbm8gdXBkYXRlIGlzIGluLWZsaWdodC5cbiAgICAgKi9cbiAgICBnZXRJbkZsaWdodFVwZGF0ZURlcHRoKG93bmVySWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5GbGlnaHRVcGRhdGVNYXAuZ2V0KG93bmVySWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNldCBvZiBjaGlsZCBjb21wb25lbnQgSURzIHRoYXQgaGF2ZSBiZWVuIG1lcmdlZCBpbnRvIGEgcGFyZW50J3MgdXBkYXRlIGN5Y2xlLFxuICAgICAqIFBMVVMgYWxsIGludGVybWVkaWF0ZSBcIkJyaWRnZVwiIGNvbXBvbmVudHMgKGFuY2VzdG9ycykgcmVxdWlyZWQgdG8gcmVhY2ggdGhlbS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0IHNlcnZlcyBhcyBhbiBcIkFsbG93TGlzdFwiIGZvciBUcmVlQnVpbGRlci4gV2hlbiBhIHBhcmVudCB1cGRhdGVzIHdpdGggZGVwdGggPiAxLFxuICAgICAqIFRyZWVCdWlsZGVyIHdpbGwgdXNlIHRoaXMgc2V0IHRvIHBlcmZvcm0gKipTcGFyc2UgVHJlZSBHZW5lcmF0aW9uKio6XG4gICAgICogMS4gQ29tcG9uZW50cyBpbiB0aGlzIHNldCBhcmUgZXhwYW5kZWQgKHRyYXZlcnNlZCkuXG4gICAgICogMi4gQ29tcG9uZW50cyBOT1QgaW4gdGhpcyBzZXQgYXJlIHBydW5lZCAoc2VudCBhcyBwbGFjZWhvbGRlcnMpLCBldmVuIGlmIHRoZSBkZXB0aCBhbGxvd3MgZXhwYW5zaW9uLlxuICAgICAqXG4gICAgICogVGhpcyBvcHRpbWl6YXRpb24gYWxsb3dzIGNsZWFuIHNpYmxpbmdzIHRvIGJlIHNraXBwZWQsIHJlZHVjaW5nIHBheWxvYWQgc2l6ZSBhbmQgZW5hYmxpbmcgcGFyYWxsZWxpc20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCBUaGUgYGlkYCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7U2V0PFN0cmluZz58bnVsbH0gQSBTZXQgY29udGFpbmluZyBJRHMgb2YgbWVyZ2VkIGNoaWxkcmVuIEFORCBicmlkZ2UgYW5jZXN0b3JzLCBvciBgbnVsbGAuXG4gICAgICovXG4gICAgZ2V0TWVyZ2VkQ2hpbGRJZHMob3duZXJJZCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5tZXJnZWRDYWxsYmFja01hcC5nZXQob3duZXJJZCk7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoaXRlbS5jaGlsZHJlbi5rZXlzKCkpO1xuXG4gICAgICAgICAgICAvLyBBZGQgQnJpZGdlIFBhdGhzOiBXYWxrIHVwIGZyb20gZWFjaCBtZXJnZWQgY2hpbGQgdG8gdGhlIG93bmVyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZElkLCBtZXRhXSBvZiBpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGEuZGlzdGFuY2UgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGNoaWxkSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb21wb25lbnQgJiYgY29tcG9uZW50LnBhcmVudElkICYmIGNvbXBvbmVudC5wYXJlbnRJZCAhPT0gb3duZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChjb21wb25lbnQucGFyZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5hZGQoY29tcG9uZW50LmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaWRzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIGEgY29tcG9uZW50J3MgVkRPTSB1cGRhdGUgYXMgXCJpbi1mbGlnaHQsXCIgbWVhbmluZyBpdCBoYXMgYmVlbiBzZW50IHRvIHRoZVxuICAgICAqIHdvcmtlciBmb3IgcHJvY2Vzc2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCAgICAgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCBvd25pbmcgdGhlIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXBkYXRlRGVwdGggVGhlIGRlcHRoIG9mIHRoZSBpbi1mbGlnaHQgdXBkYXRlLlxuICAgICAqL1xuICAgIHJlZ2lzdGVySW5GbGlnaHRVcGRhdGUob3duZXJJZCwgdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgdGhpcy5pbkZsaWdodFVwZGF0ZU1hcC5zZXQob3duZXJJZCwgdXBkYXRlRGVwdGgpO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoaXMgY29tcG9uZW50IGFzIGFuIGluLWZsaWdodCBkZXNjZW5kYW50IGZvciBhbGwgaXRzIHBhcmVudHNcbiAgICAgICAgY29uc3QgcGFyZW50SWRzID0gTmVvLm1hbmFnZXIuQ29tcG9uZW50LmdldFBhcmVudElkcyhOZW8uZ2V0Q29tcG9uZW50KG93bmVySWQpKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFyZW50SWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50SWQgPSBwYXJlbnRJZHNbaV0sXG4gICAgICAgICAgICAgICAgbWFwICAgICAgPSB0aGlzLmRlc2NlbmRhbnRJbkZsaWdodE1hcC5nZXQocGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2NlbmRhbnRJbkZsaWdodE1hcC5zZXQocGFyZW50SWQsIG1hcClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFwLnNldChvd25lcklkLCB0cnVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2hpbGQncyB1cGRhdGUgcmVxdWVzdCB0byBiZSBtZXJnZWQgaW50byBpdHMgcGFyZW50J3MgdXBkYXRlIGN5Y2xlLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJ5IGEgY2hpbGQgY29tcG9uZW50IHdoZW4gaXQgZGV0ZXJtaW5lcyBpdCBjYW4gZGVsZWdhdGUgaXRzIHVwZGF0ZVxuICAgICAqIHRvIGFuIGFuY2VzdG9yIChzZWUgYFZkb21MaWZlY3ljbGUubWVyZ2VJbnRvUGFyZW50VXBkYXRlYCkuXG4gICAgICpcbiAgICAgKiAqKk1lcmdpbmcgTG9naWM6KipcbiAgICAgKiBNZXJnaW5nIHJlZHVjZXMgVkRPTSB3b3JrZXIgdHJhZmZpYyBieSBidW5kbGluZyBtdWx0aXBsZSBjb21wb25lbnQgdXBkYXRlcyBpbnRvXG4gICAgICogYSBzaW5nbGUgbWVzc2FnZS4gVGhlIGNoaWxkIGVmZmVjdGl2ZWx5IFwiY2FuY2Vsc1wiIGl0cyBvd24gc3RhbmRhbG9uZSB1cGRhdGUgYW5kXG4gICAgICogcGlnZ3liYWNrcyBvbiB0aGUgcGFyZW50J3MgcGVuZGluZyB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCAgICAgICAgICBUaGUgYGlkYCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudCB0aGF0IHdpbGwgb3duIHRoZSBtZXJnZWQgdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGlsZElkICAgICAgICAgIFRoZSBgaWRgIG9mIHRoZSBjaGlsZCBjb21wb25lbnQgcmVxdWVzdGluZyB0aGUgbWVyZ2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoaWxkVXBkYXRlRGVwdGggVGhlIHVwZGF0ZSBkZXB0aCByZXF1aXJlZCBieSB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlICAgICAgICAgVGhlIGNvbXBvbmVudCB0cmVlIGRpc3RhbmNlIChudW1iZXIgb2YgbGV2ZWxzKSBiZXR3ZWVuIHRoZSBwYXJlbnQgYW5kIGNoaWxkLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyTWVyZ2VkKG93bmVySWQsIGNoaWxkSWQsIGNoaWxkVXBkYXRlRGVwdGgsIGRpc3RhbmNlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5tZXJnZWRDYWxsYmFja01hcC5nZXQob3duZXJJZCk7XG5cbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBpdGVtID0ge293bmVySWQsIGNoaWxkcmVuOiBuZXcgTWFwKCl9O1xuICAgICAgICAgICAgbWUubWVyZ2VkQ2FsbGJhY2tNYXAuYWRkKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLmNoaWxkcmVuLnNldChjaGlsZElkLCB7Y2hpbGRVcGRhdGVEZXB0aCwgZGlzdGFuY2V9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyBhIGNvbXBvbmVudCB1cGRhdGUgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgYW5vdGhlciBjb21wb25lbnQncyB1cGRhdGUgaXMgY29tcGxldGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgICAgIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgdG8gd2FpdCBmb3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkSWQgICAgIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgdG8gdXBkYXRlIGFmdGVyd2FyZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV0gVGhlIFByb21pc2UgcmVzb2x2ZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGBjaGlsZElkYCdzIHN1YnNlcXVlbnQgdXBkYXRlIGZpbmlzaGVzLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyUG9zdFVwZGF0ZShvd25lcklkLCBjaGlsZElkLCByZXNvbHZlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5wb3N0VXBkYXRlUXVldWVNYXAuZ2V0KG93bmVySWQpO1xuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgaXRlbSA9IHtvd25lcklkLCBjaGlsZHJlbjogW119O1xuICAgICAgICAgICAgbWUucG9zdFVwZGF0ZVF1ZXVlTWFwLmFkZChpdGVtKVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5jaGlsZHJlbi5wdXNoKHtjaGlsZElkLCByZXNvbHZlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBmb3IgYSBjb21wb25lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXRzIGN1cnJlbnRcbiAgICAgKiBWRE9NIHVwZGF0ZSBmaW5pc2hlcywgYnV0IGJlZm9yZSB0aGUgbmV4dCB1cGRhdGUgY3ljbGUgYmVnaW5zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgY29tcG9uZW50IElELlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmVVcGRhdGUoaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucHJlVXBkYXRlTWFwLnNldChpZCwgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYWxsIHBlbmRpbmcgdXBkYXRlcyB0aGF0IHdlcmUgcXVldWVkIHRvIHJ1biBhZnRlciB0aGUgc3BlY2lmaWVkIGBvd25lcklkYCdzXG4gICAgICogdXBkYXRlIGhhcyBjb21wbGV0ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCB3aG9zZSB1cGRhdGUgaGFzIGp1c3QgZmluaXNoZWQuXG4gICAgICovXG4gICAgdHJpZ2dlclBvc3RVcGRhdGVzKG93bmVySWQpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLnBvc3RVcGRhdGVRdWV1ZU1hcC5nZXQob3duZXJJZCksXG4gICAgICAgICAgICBjb21wb25lbnQ7XG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVudHJ5ID0gaXRlbS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGVudHJ5LmNoaWxkSWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXNvbHZlICYmIG1lLmFkZFByb21pc2VDYWxsYmFjayhjb21wb25lbnQuaWQsIGVudHJ5LnJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQudXBkYXRlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnBvc3RVcGRhdGVRdWV1ZU1hcC5yZW1vdmUoaXRlbSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb21wb25lbnQncyB1cGRhdGUgZnJvbSB0aGUgXCJpbi1mbGlnaHRcIiByZWdpc3RyeS4gVGhpcyBpcyBjYWxsZWQgYWZ0ZXJcbiAgICAgKiB0aGUgVkRPTSB3b3JrZXIgY29uZmlybXMgdGhlIHVwZGF0ZSBoYXMgYmVlbiBwcm9jZXNzZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCBvd25pbmcgdGhlIHVwZGF0ZS5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVySW5GbGlnaHRVcGRhdGUob3duZXJJZCkge1xuICAgICAgICB0aGlzLmluRmxpZ2h0VXBkYXRlTWFwLmRlbGV0ZShvd25lcklkKTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBjb21wb25lbnQgZnJvbSB0aGUgaW4tZmxpZ2h0IGRlc2NlbmRhbnQgbWFwcyBvZiBhbGwgaXRzIHBhcmVudHNcbiAgICAgICAgLy8gV2UgbmVlZCB0byBpdGVyYXRlIGFsbCByZWdpc3RlcmVkIGFuY2VzdG9ycyB0byBlbnN1cmUgd2UgY2F0Y2ggY2FzZXMgd2hlcmVcbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCBtb3ZlZCAocmUtcGFyZW50ZWQpIGR1cmluZyB0aGUgdXBkYXRlLlxuICAgICAgICBmb3IgKGNvbnN0IFtwYXJlbnRJZCwgbWFwXSBvZiB0aGlzLmRlc2NlbmRhbnRJbkZsaWdodE1hcCkge1xuICAgICAgICAgICAgaWYgKG1hcC5oYXMob3duZXJJZCkpIHtcbiAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKG93bmVySWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hcC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzY2VuZGFudEluRmxpZ2h0TWFwLmRlbGV0ZShwYXJlbnRJZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZEb21VcGRhdGUpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBEb21FdmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Eb21FdmVudC5tanMnO1xuXG4vKipcbiAqIEEgbWl4aW4gcHJvdmlkaW5nIERPTSBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMgdG8gY29tcG9uZW50cy5cbiAqIFRoaXMgbWl4aW4gaXMgY29uc3VtZWQgYnkgYm90aCBOZW8uY29tcG9uZW50LkJhc2UgYW5kIE5lby5mdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlXG4gKiB0byBlbmFibGUgY29uc2lzdGVudCBtYW5hZ2VtZW50IG9mIERPTSBldmVudCBsaXN0ZW5lcnMgYWNyb3NzIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZXMuXG4gKiBAY2xhc3MgTmVvLm1peGluLkRvbUV2ZW50c1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBEb21FdmVudHMgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5taXhpbi5Eb21FdmVudHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5taXhpbi5Eb21FdmVudHMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgZG9tTGlzdGVuZXIgY29uZmlnc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxudWxsfSBkb21MaXN0ZW5lcnNfPW51bGxcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYWZ0ZXJTZXRTdGF5T25Ib3Zlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICogICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgKiAgICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFxuICAgICAgICAgKiAgICAgICAgICAgICB7bW91c2VlbnRlcjogbWUub25Nb3VzZUVudGVyLCBzY29wZTogbWV9LFxuICAgICAgICAgKiAgICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCBzY29wZTogbWV9XG4gICAgICAgICAqICAgICAgICAgKVxuICAgICAgICAgKiAgICB9XG4gICAgICAgICAqfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRvbUxpc3RlbmVyc186IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBhZGQgYWRkaXRpb25hbCBkb20gbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IHZhbHVlXG4gICAgICovXG4gICAgYWRkRG9tTGlzdGVuZXJzKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRvbUxpc3RlbmVycyA9IHRoaXMuZG9tTGlzdGVuZXJzO1xuXG4gICAgICAgIGRvbUxpc3RlbmVycy5wdXNoKC4uLnZhbHVlKTtcblxuICAgICAgICB0aGlzLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZG9tTGlzdGVuZXJzIGluc2lkZSB0aGUgTmVvLm1hbmFnZXIuRG9tRXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9tTGlzdGVuZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZT8uWzBdIHx8IG9sZFZhbHVlPy5bMF0pIHtcbiAgICAgICAgICAgIERvbUV2ZW50TWFuYWdlci51cGRhdGVEb21MaXN0ZW5lcnMobWUsIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRvbUxpc3RlbmVycyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREb21MaXN0ZW5lcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIERPTSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgaW5pdERvbUV2ZW50cygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLmRvbUxpc3RlbmVycz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gdG9kbzogdGhlIG1haW4gdGhyZWFkIHJlcGx5IG9mIG1vdW50IGFycml2ZXMgYWZ0ZXIgcHVzaGluZyB0aGUgdGFzayBpbnRvIHRoZSBxdWV1ZSB3aGljaCBkb2VzIG5vdCBlbnN1cmUgdGhlIGRvbSBpcyBtb3VudGVkXG4gICAgICAgICAgICBtZS50aW1lb3V0KDE1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgRG9tRXZlbnRNYW5hZ2VyLm1vdW50RG9tTGlzdGVuZXJzKG1lKVxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICE9PSBOZW8uaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgbW91bnRlZCBmbGFnIGZvciBsb2NhbCBkb21FdmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICByZXNldE1vdW50ZWREb21FdmVudHMoKSB7XG4gICAgICAgIERvbUV2ZW50TWFuYWdlci5yZXNldE1vdW50ZWREb21MaXN0ZW5lcnModGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBET00gZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIHJlbW92ZURvbUV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5kb21MaXN0ZW5lcnMgPSBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSB2YWx1ZVxuICAgICAqL1xuICAgIHJlbW92ZURvbUxpc3RlbmVycyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RvbUxpc3RlbmVyc30gPSBtZSxcbiAgICAgICAgICAgIGksIGxlbjtcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICBsZW4gPSBkb21MaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc0VxdWFsKGl0ZW0sIGRvbUxpc3RlbmVyc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVyc1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRG9tRXZlbnRzKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBUcmVlQnVpbGRlciAgICAgIGZyb20gJy4uL3V0aWwvdmRvbS9UcmVlQnVpbGRlci5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5pbXBvcnQgVkRvbVVwZGF0ZSAgICAgICBmcm9tICcuLi9tYW5hZ2VyL1ZEb21VcGRhdGUubWpzJztcbmltcG9ydCBWTm9kZVV0aWwgICAgICAgIGZyb20gJy4uL3V0aWwvVk5vZGUubWpzJztcbmltcG9ydCB7aXNEZXNjcmlwdG9yfSAgIGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG5jb25zdCB7Y3VycmVudFdvcmtlcn0gPSBOZW87XG5cbi8qKlxuICogQGNsYXNzIE5lby5taXhpbi5WZG9tTGlmZWN5Y2xlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFZkb21MaWZlY3ljbGUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5taXhpbi5WZG9tTGlmZWN5Y2xlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWl4aW4uVmRvbUxpZmVjeWNsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgaW5pdGlhbGl6ZXMgdGhlIHZub2RlIG9mIGEgY29tcG9uZW50IGFmdGVyIGJlaW5nIGNyZWF0ZWQgaW5zaWRlIHRoZSBpbml0IGNhbGwuXG4gICAgICAgICAqIFJlY29tbWVuZGVkIGZvciBkaWFsb2dzICYgZHJhZy1wcm94aWVzLlxuICAgICAgICAgKiBUb3AgbGV2ZWwgdmlld3Mgc2hvdWxkIGRlZmluaXRlbHkgdXNlIGZhbHNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvSW5pdFZub2RlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvSW5pdFZub2RlOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgYXV0b21hdGljYWxseSBtb3VudHMgYSBjb21wb25lbnQgYWZ0ZXIgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgICAqIFVzZSB0aGlzIGZvciB0aGUgdG9wIGxldmVsIGNvbXBvbmVudCBvZiB5b3VyIGFwcC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB3aGljaCB3aWxsIGdldCBzZXQgdG8gdHJ1ZSB3aGlsZSBhbiB1cGRhdGUgcmVxdWVzdCAod29ya2VyIG1lc3NhZ2VzKSBpcyBpbiBwcm9ncmVzc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc1Zkb21VcGRhdGluZ189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlzVmRvbVVwZGF0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsaXppbmcgdGhlIHZub2RlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVm5vZGVJbml0aWFsaXppbmdfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpc1Zub2RlSW5pdGlhbGl6aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIHRvIHRoZSBET01cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW91bnRlZF89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vdW50ZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgaW4gY2FzZSBhbiB1cGRhdGUgY2FsbCBhcnJpdmVzIHdoaWxlIGFub3RoZXIgdXBkYXRlIGlzIHJ1bm5pbmdcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbmVlZHNWZG9tVXBkYXRlXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbmVlZHNWZG9tVXBkYXRlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGZvciBidWxrIHVwZGF0ZXMuIEVuc3VyZSB0byBzZXQgaXQgYmFjayB0byBmYWxzZSBhZnRlcndhcmRzLlxuICAgICAgICAgKiBJbnRlcm5hbGx5IHRoZSB2YWx1ZSB3aWxsIGdldCBzYXZlZCBhcyBhIG51bWJlciB0byBlbnN1cmUgdGhhdCBjaGlsZCBtZXRob2RzIHdvbid0IHN0b3AgdGhlIHNpbGVudCBtb2RlIHRvbyBlYXJseS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2lsZW50VmRvbVVwZGF0ZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzaWxlbnRWZG9tVXBkYXRlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBkZXB0aCBvZiB0aGUgdmRvbSB0cmVlIGZvciB0aGUgbmV4dCB1cGRhdGUgY3ljbGUuXG4gICAgICAgICAqIC0gVGhlIHZhbHVlIDEgd2lsbCBvbmx5IHNlbmQgdGhlIGN1cnJlbnQgdmRvbSBzdHJ1Y3R1cmUgYXMgaXQgaXNcbiAgICAgICAgICogLSBUaGUgdmFsdWUgb2YgMiB3aWxsIGluY2x1ZGUgdGhlIHZkb20gb2YgZGlyZWN0IGNoaWxkcmVuXG4gICAgICAgICAqIC0gVGhlIHZhbHVlIG9mIDMgd2lsbCBpbmNsdWRlIHRoZSB2ZG9tIG9mIGdyYW5kY2hpbGRyZW5cbiAgICAgICAgICogLSBUaGUgdmFsdWUgb2YgLTEgd2lsbCBpbmNsdWRlIHRoZSBmdWxsIHRyZWUgb2YgYW55IGRlcHRoXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdXBkYXRlRGVwdGhfPTFcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEZXB0aF86IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29tcG9uZW50IHZub2RlIHRyZWUuIEF2YWlsYWJsZSBhZnRlciB0aGUgY29tcG9uZW50IGdvdCB2bm9kZUluaXRpYWxpemVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZub2RlXz09e1tpc0Rlc2NyaXB0b3JdOiB0cnVlLCB2YWx1ZTogbnVsbCwgaXNFcXVhbDogKGEsIGIpID0+IGEgPT09IGIsfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdm5vZGVfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIGNsb25lICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBjbG9uZU9uR2V0ICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaXNFcXVhbCAgICAgICA6IChhLCBiKSA9PiBhID09PSBiLCAvLyB2bm9kZSB0cmVlcyBjYW4gYmUgaHVnZSwgYW5kIHdpbGwgZ2V0IGNvbXBhcmVkIGJ5IHRoZSB2ZG9tIHdvcmtlci5cbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhZnRlciB0aGUgY29tcG9uZW50IGluaXRWbm9kZSgpIG1ldGhvZCB3YXMgY2FsbGVkLiBBbHNvIGZpcmVzIHRoZSB2bm9kZUluaXRpYWxpemVkIGV2ZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB2bm9kZUluaXRpYWxpemVkXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdm5vZGVJbml0aWFsaXplZF86IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2ZG9tIHBzZXVkby1jb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZkb20odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmRvbSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2bm9kZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZub2RlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnN5bmNWbm9kZVRyZWUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdm5vZGVJbml0aWFsaXplZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFZub2RlSW5pdGlhbGl6ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS5maXJlKCd2bm9kZUluaXRpYWxpemVkJywgbWUuaWQpO1xuXG4gICAgICAgICAgICBpZiAobWUubmVlZHNWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsaWdodHdlaWdodCwgc2VyaWFsaXphYmxlIHBsYWNlaG9sZGVyIGZvciB0aGlzIGNvbXBvbmVudCwgaW50ZW5kZWQgZm9yIGluamVjdGlvblxuICAgICAqIGludG8gdGhlIFZET00gb2Ygb3RoZXIgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlICoqb25seSByZWNvbW1lbmRlZCB3YXkqKiB0byBuZXN0IGEgY29tcG9uZW50IHdpdGhpbiBhbm90aGVyIGNvbXBvbmVudCdzIFZET00gdHJlZS5cbiAgICAgKiBEaXJlY3RseSBlbWJlZGRpbmcgb25lIGNvbXBvbmVudCdzIGZ1bGwgYHZkb21gIG9iamVjdCBpbnRvIGFub3RoZXIncyBpcyBhbiBhbnRpLXBhdHRlcm5cbiAgICAgKiB0aGF0IHZpb2xhdGVzIHRoZSBwcmluY2lwbGUgb2Ygc2NvcGVkIFZET00sIGxlYWRpbmcgdG8gdW5wcmVkaWN0YWJsZSByZW5kZXJpbmcgYmVoYXZpb3JcbiAgICAgKiBhbmQgbWFraW5nIHVwZGF0ZXMgaW5lZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBBdCBpdHMgY29yZSwgdGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyBhIGBjb21wb25lbnRJZGAgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIHRoZVxuICAgICAqIGNvbXBvbmVudCBpbnN0YW5jZS4gSW4gY2FzZXMgd2hlcmUgYSBjb21wb25lbnQncyBzdHJ1Y3R1cmUgaXMgd3JhcHBlZCBieSBhbm90aGVyIGVsZW1lbnRcbiAgICAgKiAoZS5nLiwgYSBCdXR0b24gaW4gYSBUYWJsZSBIZWFkZXIgYmVpbmcgd3JhcHBlZCBieSBhIGA8dGQ+YCksIHRoZSByZWZlcmVuY2Ugd2lsbCBhbHNvXG4gICAgICogaW5jbHVkZSB0aGUgd3JhcHBlcidzIGBpZGAuIFRoaXMgaGFwcGVucyB3aGVuIGEgY29tcG9uZW50IHVzZXMgYGdldFZkb21Sb290KClgIHRvXG4gICAgICogZGVzaWduYXRlIGEgZGVlcGVyIG5vZGUgYXMgaXRzIGxvZ2ljYWwgcm9vdCwgY2F1c2luZyB0aGUgY29tcG9uZW50J3MgYGlkYCBhbmQgaXRzXG4gICAgICogVkRPTSByb290J3MgYGlkYCB0byBkaWZmZXIuIFRoZSBmcmFtZXdvcmsgdXNlcyB0aGlzIGR1YWwtSUQgcmVmZXJlbmNlIHRvIGNvcnJlY3RseVxuICAgICAqIGFzc2VtYmxlIHRoZSBmaW5hbCBWRE9NIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e2NvbXBvbmVudElkOiBTdHJpbmcsIGlkOiBTdHJpbmd8dW5kZWZpbmVkfX0gVGhlIFZET00gcmVmZXJlbmNlIG9iamVjdC5cbiAgICAgKi9cbiAgICBjcmVhdGVWZG9tUmVmZXJlbmNlKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IHtjb21wb25lbnRJZDogbWUuaWR9LFxuICAgICAgICAgICAgdmRvbUlkICAgID0gbWUudmRvbS5pZDtcblxuICAgICAgICBpZiAodmRvbUlkICYmIG1lLmlkICE9PSB2ZG9tSWQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZS5pZCA9IHZkb21JZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgcm9vdCBWRE9NIG5vZGUgYW5kIGl0cyB3cmFwcGVyIChpZiBhbnkpIGhhdmUgc3RhYmxlLCB1bmlxdWUgSURzXG4gICAgICogZGVyaXZlZCBmcm9tIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgSUQuIFRoaXMgcHJldmVudHMgYXV0by1nZW5lcmF0ZWQgSUQgY29sbGlzaW9uc1xuICAgICAqIGluIGBDb21wb25lbnRNYW5hZ2VyLndyYXBwZXJOb2Rlc2AuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGVuc3VyZVN0YWJsZUlkcygpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIHZkb21Sb290ID0gbWUuZ2V0VmRvbVJvb3QoKTtcblxuICAgICAgICBpZiAodmRvbVJvb3QpIHtcbiAgICAgICAgICAgIHZkb21Sb290LmlkID0gbWUuaWQ7XG5cbiAgICAgICAgICAgIGlmICh2ZG9tICE9PSB2ZG9tUm9vdCkge1xuICAgICAgICAgICAgICAgIHZkb20uaWQgPSBtZS5pZCArICdfX3dyYXBwZXInXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gc2VuZCB1cGRhdGUgcmVxdWVzdHMgdG8gdGhlIHZkb20gd29ya2VyLlxuICAgICAqXG4gICAgICogKipUZWxlcG9ydGF0aW9uIC8gQmF0Y2hlZCBEaXNqb2ludCBVcGRhdGVzOioqXG4gICAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgY29yZSBsb2dpYyBmb3IgXCJUZWxlcG9ydGF0aW9uXCIuIEluc3RlYWQgb2YgbWVyZ2luZyBjaGlsZCB1cGRhdGVzXG4gICAgICogaW50byB0aGUgcGFyZW50J3MgVkRPTSB0cmVlICh3aGljaCByZXF1aXJlcyBleHBhbmRpbmcgdGhlIHBhcmVudCdzIHRyZWUgdG8gcmVhY2ggdGhlIGNoaWxkKSxcbiAgICAgKiB3ZSBjb2xsZWN0IGFsbCBtZXJnZWQgY2hpbGQgdXBkYXRlcyBhbmQgc2VuZCB0aGVtIGFzIGEgKipiYXRjaCBvZiBkaXNqb2ludCBwYXlsb2FkcyoqLlxuICAgICAqXG4gICAgICogMS4gKipSZWN1cnNpdmUgQ29sbGVjdGlvbjoqKiBXZSByZWN1cnNpdmVseSBjb2xsZWN0IGFsbCBgbWVyZ2VkQ2hpbGRJZHNgIGZyb20gdGhlIGNvbXBvbmVudFxuICAgICAqICAgIGFuZCBpdHMgZGVzY2VuZGFudHMuXG4gICAgICogMi4gKipEaXNqb2ludCBQYXlsb2FkczoqKiBGb3IgZWFjaCBjb21wb25lbnQgaW4gdGhlIGJhdGNoLCB3ZSBnZW5lcmF0ZSBhIFwic2VsZi1vbmx5XCIgVkRPTVxuICAgICAqICAgIHBheWxvYWQgKGB1cGRhdGVEZXB0aDogMWApLiBUaGlzIGFsbG93cyB0aGUgVkRPTSBlbmdpbmUgdG8gdXBkYXRlIHRoZSBjaGlsZCBkaXJlY3RseVxuICAgICAqICAgIHdpdGhvdXQgbmVlZGluZyB0aGUgcGFyZW50IHRvIFwiYnJpZGdlXCIgdG8gaXQuXG4gICAgICogMy4gKipDb2xsaXNpb24gRmlsdGVyaW5nOioqIFdlIGZpbHRlciBvdXQgY2hpbGQgdXBkYXRlcyB0aGF0IGFyZSBhbHJlYWR5IGNvdmVyZWQgYnkgYVxuICAgICAqICAgIHBhcmVudCB1cGRhdGUgaW4gdGhlIHNhbWUgYmF0Y2ggKGUuZy4sIGlmIHRoZSBwYXJlbnQgaXMgZG9pbmcgYSBmdWxsIHRyZWUgdXBkYXRlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXNvbHZlXSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZWplY3RdIHVzZWQgYnkgcHJvbWlzZVVwZGF0ZSgpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlVmRvbVVwZGF0ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXNvbHZlICYmIFZEb21VcGRhdGUuYWRkUHJvbWlzZUNhbGxiYWNrKG1lLmlkLCByZXNvbHZlKTtcblxuICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IHRydWU7XG4gICAgICAgIC8vIENlbnRyYWxpemUgaW4tZmxpZ2h0IHN0YXRlXG4gICAgICAgIFZEb21VcGRhdGUucmVnaXN0ZXJJbkZsaWdodFVwZGF0ZShtZS5pZCwgbWUudXBkYXRlRGVwdGgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSB0YXNrIHF1ZXVlIGlzIGVtcHR5IGJlZm9yZSBjb2xsZWN0aW5nIHBheWxvYWRzLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBjcml0aWNhbCBmb3IgY2FzZXMgd2hlcmUgYSBjb21wb25lbnQgc3RhdGUgY2hhbmdlICh0cmlnZ2VyaW5nIHVwZGF0ZSlcbiAgICAgICAgICAgIC8vIGlzIGZvbGxvd2VkIGltbWVkaWF0ZWx5IGJ5IGEgc3RydWN0dXJhbCBjaGFuZ2UgKGUuZy4gcmVtb3ZlKSBpbiB0aGUgc2FtZSB0aWNrLlxuICAgICAgICAgICAgLy8gVXNpbmcgc2V0VGltZW91dCBmb3JjZXMgYSBNYWNyb3Rhc2sgeWllbGQsIGVuc3VyaW5nIGFsbCBzeW5jIG9wZXJhdGlvbnMgY29tcGxldGUuXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMSkpO1xuXG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIHVwZGF0ZXMgICAgICAgICAgICAgICAgID0ge30sXG4gICAgICAgICAgICAgICAgZGVwdGhzICAgICAgICAgICAgICAgICAgPSBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkICAgICAgICAgICAgICAgPSBuZXcgU2V0KCksIC8vIFByZXZlbnQgZHVwbGljYXRlcyBhbmQgY3ljbGVzXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TWVyZ2VkQ2hpbGRyZW4gPSBuZXcgTWFwKCk7IC8vIFNuYXBzaG90IG9mIG1lcmdlZCBjaGlsZHJlbiBwcm9jZXNzZWQgaW4gdGhpcyBiYXRjaFxuXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0UGF5bG9hZHMgPSAoY29tcG9uZW50SWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkLmhhcyhjb21wb25lbnRJZCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQuYWRkKGNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoY29tcG9uZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50IHx8IGNvbXBvbmVudC5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bm1vdW50ZWQgY29tcG9uZW50cy4gVGhleSB3aWxsIGJlIGV4cGFuZGVkIGJ5IHRoZSBQYXJlbnQncyBUcmVlQnVpbGRlclxuICAgICAgICAgICAgICAgIC8vIGFuZCBoYW5kbGVkIHZpYSB0aGUgUGFyZW50J3MgcmVzb2x2ZVZkb21VcGRhdGUgLT4gc3luY1Zub2RlVHJlZS5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC52bm9kZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBJbiBhIG11bHRpLXdpbmRvdyBTaGFyZWRXb3JrZXIgZW52aXJvbm1lbnQsIHdlIG11c3QgTk9UIGJhdGNoXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyBmcm9tIGNvbXBvbmVudHMgdGhhdCBoYXZlIG1vdmVkIHRvIGEgZGlmZmVyZW50IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBEb2luZyBzbyB3b3VsZCBjYXVzZSBkZWx0YXMgbWVhbnQgZm9yIFdpbmRvdyBCIHRvIGJlIHNlbnQgdG8gV2luZG93IEEuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC53aW5kb3dJZCAhPT0gbWUud2luZG93SWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIEZvciBldmVyeSBjb21wb25lbnQsIHdlIGNoZWNrIGl0cyBvd24gbWVyZ2VkIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkQ2hpbGRJZHMgPSBWRG9tVXBkYXRlLmdldE1lcmdlZENoaWxkSWRzKGNvbXBvbmVudElkKTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIGRlcHRoIGZvciBjb2xsaXNpb24gZmlsdGVyaW5nXG4gICAgICAgICAgICAgICAgZGVwdGhzLnNldChjb21wb25lbnRJZCwgY29tcG9uZW50LnVwZGF0ZURlcHRoKTtcblxuICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHRoZSBtZXJnZWQgY2hpbGRyZW4gd2UgYXJlIGFib3V0IHRvIHByb2Nlc3MuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyByYWNlIGNvbmRpdGlvbnMgd2hlcmUgYSBjaGlsZCBtZXJnZXMgKmFmdGVyKiBjb2xsZWN0aW9uIGJ1dCAqYmVmb3JlKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIC8vIGNhdXNpbmcgaXQgdG8gYmUgYWNrbm93bGVkZ2VkL2NsZWFyZWQgd2l0aG91dCBhY3R1YWxseSBiZWluZyB1cGRhdGVkLlxuICAgICAgICAgICAgICAgIGlmIChtZXJnZWRDaGlsZElkcykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNZXJnZWRDaGlsZHJlbi5zZXQoY29tcG9uZW50SWQsIG1lcmdlZENoaWxkSWRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBwYXlsb2FkIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAvLyAtIERlcHRoIDEgKFRlbGVwb3J0YXRpb24pOiBQYXNzIGlkcz1udWxsIHRvIGZvcmNlIGRpc2pvaW50L3BydW5lZCBwYXlsb2FkLlxuICAgICAgICAgICAgICAgIC8vIC0gRGVwdGggPiAxIChIeWJyaWQpOiBQYXNzIGlkcz1tZXJnZWRDaGlsZElkcyB0byBlbmFibGUgU3BhcnNlIFRyZWUgZ2VuZXJhdGlvbiAocHJ1bmluZyBjbGVhbiBzaWJsaW5ncykuXG4gICAgICAgICAgICAgICAgLy8gICBOb3RlOiBEZXB0aCAtMSAoRnVsbCBUcmVlKSBpZ25vcmVzIGlkcyBhbmQgaXMgYWx3YXlzIERlbnNlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlkcyA9IGNvbXBvbmVudC51cGRhdGVEZXB0aCAhPT0gMSA/IG1lcmdlZENoaWxkSWRzIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIFdlIHBhc3MgbnVsbCBhcyB0aGUgc2Vjb25kIGFyZyB0byByZXNwZWN0IHRoZSBjb21wb25lbnQncyBjb25maWd1cmVkIHVwZGF0ZURlcHRoLlxuICAgICAgICAgICAgICAgIHVwZGF0ZXNbY29tcG9uZW50SWRdID0gY29tcG9uZW50LmdldFZkb21VcGRhdGVQYXlsb2FkKGlkcywgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb2xsZWN0IG1lcmdlZCBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGlmIChtZXJnZWRDaGlsZElkcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkSWQgb2YgbWVyZ2VkQ2hpbGRJZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RQYXlsb2FkcyhjaGlsZElkKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgY29sbGVjdGlvbiBmcm9tIHRoZSByb290IG9mIHRoZSB1cGRhdGUgKG1lKVxuICAgICAgICAgICAgY29sbGVjdFBheWxvYWRzKG1lLmlkKTtcblxuICAgICAgICAgICAgLy8gQ29sbGlzaW9uIEZpbHRlcmluZzpcbiAgICAgICAgICAgIC8vIElmIGEgcGFyZW50IHVwZGF0ZSBjb3ZlcnMgdGhpcyBjaGlsZCwgcmVtb3ZlIHRoZSBjaGlsZCBmcm9tIHRoZSBkaXNqb2ludCBiYXRjaFxuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBpbiB1cGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odXBkYXRlcywgaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgICA9IE5lby5nZXRDb21wb25lbnQoaWQpPy5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZXNbcGFyZW50LmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudERlcHRoID0gZGVwdGhzLmdldChwYXJlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHBhcmVudCBjb3ZlcnMgdGhpcyBjaGlsZCwgcmVtb3ZlIHRoZSBjaGlsZCBmcm9tIHRoZSBkaXNqb2ludCBiYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnREZXB0aCA9PT0gLTEgfHwgcGFyZW50RGVwdGggPiBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdXBkYXRlc1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBleGl0IHRoZSB3aGlsZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ICAgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UrK1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBiYXRjaERhdGEgPSB7dXBkYXRlc307XG5cbiAgICAgICAgICAgIC8vIENSSVRJQ0FMOiBTaGFyZWRXb3JrZXIgQ29udGV4dCBJbmplY3Rpb25cbiAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgTVVTVCBOT1QgYmUgcmVtb3ZlZCBvciBzaW1wbGlmaWVkLlxuICAgICAgICAgICAgLy8gSW4gYSBTaGFyZWRXb3JrZXIgZW52aXJvbm1lbnQsIHRoZSBWRE9NIHdvcmtlciBuZWVkcyB0byBrbm93IFdISUNIIHdpbmRvd1xuICAgICAgICAgICAgLy8gaW5pdGlhdGVkIHRoZSB1cGRhdGUgdG8gcm91dGUgdGhlIHJlcGx5IGFuZCBET00gZGVsdGFzIGNvcnJlY3RseS5cbiAgICAgICAgICAgIC8vIFdpdGhvdXQgYHdpbmRvd0lkYCBhbmQgYGFwcE5hbWVgLCBgUmVtb3RlTWV0aG9kQWNjZXNzYCBjYW5ub3QgZGV0ZXJtaW5lIHRoZSB0YXJnZXQsXG4gICAgICAgICAgICAvLyBjYXVzaW5nIGNyb3NzLXdpbmRvdyBvcGVyYXRpb25zIChsaWtlIGRyYWdnaW5nIGEgY29tcG9uZW50IHRvIGEgbmV3IHdpbmRvdykgdG8gZmFpbCBzaWxlbnRseS5cbiAgICAgICAgICAgIGlmIChjdXJyZW50V29ya2VyPy5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgICAgIGJhdGNoRGF0YS5hcHBOYW1lICA9IG1lLmFwcE5hbWU7XG4gICAgICAgICAgICAgICAgYmF0Y2hEYXRhLndpbmRvd0lkID0gbWUud2luZG93SWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoTmVvLnZkb20uSGVscGVyLnVwZGF0ZUJhdGNoKGJhdGNoRGF0YSkpO1xuXG4gICAgICAgICAgICAvLyBDb21wb25lbnQgY291bGQgYmUgZGVzdHJveWVkIHdoaWxlIHRoZSB1cGRhdGUgaXMgcnVubmluZ1xuICAgICAgICAgICAgaWYgKG1lLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBub3QgdXNpbmcgYSBWZG9tV29ya2VyLCB3ZSBuZWVkIHRvIGFwcGx5IHRoZSBkZWx0YXMgaW5zaWRlIHRoZSBBcHAgd29ya2VyXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uY29uZmlnLnVzZVZkb21Xb3JrZXIgJiYgcmVzcG9uc2UuZGVsdGFzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IE5lby5hcHBseURlbHRhcyhtZS53aW5kb3dJZCwgcmVzcG9uc2UuZGVsdGFzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgcmVzdWx0cyBiYWNrIHRvIEFMTCBjb21wb25lbnRzIGluIHRoZSBiYXRjaFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgaW4gcmVzcG9uc2Uudm5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHJlc3BvbnNlLnZub2RlcywgaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IHJlc3BvbnNlLnZub2Rlc1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiAhY29tcG9uZW50LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnZub2RlID0gdm5vZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSB1cGRhdGUgZm9yIHRoaXMgY29tcG9uZW50IGFuZCBpdHMgbWVyZ2VkIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogcmVzcG9uc2UuZGVsdGFzIGNvbnRhaW5zIHRoZSBhZ2dyZWdhdGVkIGRlbHRhcyBmb3IgdGhlIHdob2xlIGJhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlc29sdmVWZG9tVXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzOiByZXNwb25zZS5kZWx0YXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29tcG9uZW50TWVyZ2VkQ2hpbGRyZW4uZ2V0KGlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbWUuaXNWZG9tVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBzdGF0ZSBpcyBjbGVhbmVkIHVwIG9uIGVycm9yXG4gICAgICAgICAgICBWRG9tVXBkYXRlLnVucmVnaXN0ZXJJbkZsaWdodFVwZGF0ZShtZS5pZCk7XG4gICAgICAgICAgICByZWplY3Q/LihlcnIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb25vcnMgZGlmZmVyZW50IGl0ZW0gcm9vdHMgZm9yIG1vdW50IC8gcmVuZGVyIE9Qc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TW91bnRlZFBhcmVudElkKCkge1xuICAgICAgICBsZXQgcGFyZW50SWQgID0gdGhpcy5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudCAgICA9IE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpLFxuICAgICAgICAgICAgaXRlbXNSb290ID0gcGFyZW50Py5nZXRWZG9tSXRlbXNSb290Py4oKTtcblxuICAgICAgICByZXR1cm4gaXRlbXNSb290ID8gaXRlbXNSb290LmlkIDogcGFyZW50SWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHJlYWwgcGFyZW50SW5kZXggaW5zaWRlIHRoZSBET01cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRNb3VudGVkUGFyZW50SW5kZXgoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgICAgIGl0ZW1zICA9IHBhcmVudD8uaXRlbXMgfHwgW10sXG4gICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgaW5kZXggID0gMCxcbiAgICAgICAgICAgIGxlbiAgICA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWl0ZW0uaGlkZGVuICYmIGl0ZW0uaGlkZU1vZGUgPT09ICdyZW1vdmVEb20nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSB1cGRhdGUgcGF5bG9hZCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtTZXQ8U3RyaW5nPnxudWxsfSBtZXJnZWRDaGlsZElkc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVwdGhdIE92ZXJyaWRlIHRoZSB1cGRhdGUgZGVwdGhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgZ2V0VmRvbVVwZGF0ZVBheWxvYWQobWVyZ2VkQ2hpbGRJZHMsIGRlcHRoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB1cGRhdGVEZXB0aCA9IGRlcHRoID8/IG1lLnVwZGF0ZURlcHRoLFxuICAgICAgICAgICAge3Zkb20sIHZub2RlfSA9IG1lLFxuICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICB2ZG9tIDogVHJlZUJ1aWxkZXIuZ2V0VmRvbVRyZWUodmRvbSwgICB1cGRhdGVEZXB0aCwgbWVyZ2VkQ2hpbGRJZHMpLFxuICAgICAgICAgICAgICAgIHZub2RlOiBUcmVlQnVpbGRlci5nZXRWbm9kZVRyZWUodm5vZGUsIHVwZGF0ZURlcHRoLCBtZXJnZWRDaGlsZElkcylcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGN1cnJlbnRXb3JrZXI/LmlzU2hhcmVkV29ya2VyKSB7XG4gICAgICAgICAgICBvcHRzLmFwcE5hbWUgID0gbWUuYXBwTmFtZTtcbiAgICAgICAgICAgIG9wdHMud2luZG93SWQgPSBtZS53aW5kb3dJZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgY2Fubm90IHNldCB0aGUgY29uZmlnIGRpcmVjdGx5ID0+IGl0IGNvdWxkIGFscmVhZHkgYmUgZmFsc2UsXG4gICAgICAgIC8vIGFuZCB3ZSBzdGlsbCB3YW50IHRvIHBhc3MgaXQgZnVydGhlciBpbnRvIHN1YnRyZWVzXG4gICAgICAgIG1lLl9uZWVkc1Zkb21VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgbWUuYWZ0ZXJTZXROZWVkc1Zkb21VcGRhdGU/LihmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIHVwZGF0ZURlcHRoIHRvIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgbmV4dCB1cGRhdGUgY3ljbGVcbiAgICAgICAgbWUuX3VwZGF0ZURlcHRoID0gbWUuY29uc3RydWN0b3IuY29uZmlnLnVwZGF0ZURlcHRoO1xuXG4gICAgICAgIHJldHVybiBvcHRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGEgdmRvbSBjaGlsZCBub2RlIGJ5IGlkIGZvciBhIGdpdmVuIHZkb20gdHJlZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tPXRoaXMudmRvbVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmRvbUNoaWxkKGlkLCB2ZG9tPXRoaXMudmRvbSkge1xuICAgICAgICByZXR1cm4gVkRvbVV0aWwuZmluZCh2ZG9tLCBpZCk/LnZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZkb20gcm9vdCBpZiBuZWVkZWQgdG8gYXBwbHkgdGhlIHRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzIG9uIGEgZGlmZmVyZW50IGxldmVsLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgZ2V0Vm5vZGVSb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2ZG9tIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWZG9tUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdm5vZGUgcm9vdCBpZiBuZWVkZWQgdG8gYXBwbHkgdGhlIHRvcCBsZXZlbCBzdHlsZSBhdHRyaWJ1dGVzIG9uIGEgZGlmZmVyZW50IGxldmVsLlxuICAgICAqIE1ha2Ugc3VyZSB0byB1c2UgZ2V0VmRvbVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZub2RlIHJvb3RcbiAgICAgKi9cbiAgICBnZXRWbm9kZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZub2RlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgY2hpbGQgdXBkYXRlIGNhbiBiZSBtZXJnZWQgaW50byBhIHBhcmVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiAqKk1lcmdlIFN0cmF0ZWd5IChPcHRpbWl6YXRpb24pOioqXG4gICAgICogV2UgYWxsb3cgbWVyZ2luZyByZWdhcmRsZXNzIG9mIGRpc3RhbmNlIChUZWxlcG9ydGF0aW9uKS5cbiAgICAgKiBUaGUgYGV4ZWN1dGVWZG9tVXBkYXRlYCBsb2dpYyB3aWxsIGRpc3Rpbmd1aXNoIGJldHdlZW4gQ29ubmVjdGVkIChtZXJnZWQgaW50byB0cmVlKVxuICAgICAqIGFuZCBEaXNqb2ludCAoYmF0Y2hlZCBzZXBhcmF0ZWx5KSB1cGRhdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVwZGF0ZURlcHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY2FuTWVyZ2VVcGRhdGUodXBkYXRlRGVwdGgsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdXBkYXRlRGVwdGggJiBkaXN0YW5jZSB3b3VsZCByZXN1bHQgaW4gYW4gdXBkYXRlIGNvbGxpc2lvbi5cbiAgICAgKiBUaGUgY2hlY2sgbXVzdCB1c2UgYDxgIGJlY2F1c2UgYHVwZGF0ZURlcHRoYCBpcyAxLWJhc2VkLlxuICAgICAqXG4gICAgICogKipTY29wZWQgVkRPTSBVcGRhdGUgUmF0aW9uYWxlOioqXG4gICAgICogLSBgdXBkYXRlRGVwdGg6IDFgIG1lYW5zIHRoZSB1cGRhdGUgaXMgc2NvcGVkIHRvIHRoZSBjb21wb25lbnQgaXRzZWxmLlxuICAgICAqIC0gVGhlIFBhcmVudCdzIFZET00gcGF5bG9hZCBuYXR1cmFsbHkgY29udGFpbnMgb25seSBpdHMgb3duIHN0cnVjdHVyZSBhbmQgKipyZWZlcmVuY2Ugbm9kZXMqKlxuICAgICAqICAgKHBsYWNlaG9sZGVycykgZm9yIGl0cyBjaGlsZHJlbiAoZS5nLiBge2NvbXBvbmVudElkOiAnLi4uJ31gKS5cbiAgICAgKiAtIEF0IERlcHRoIDEsIHRoZXNlIHJlZmVyZW5jZXMgYXJlICoqbm90IGV4cGFuZGVkKiogaW50byB0aGUgY2hpbGRyZW4ncyBmdWxsIFZET00gdHJlZXMuXG4gICAgICogLSBUaGVyZWZvcmUsIGEgUGFyZW50IChEZXB0aCAxKSB1cGRhdGUgYW5kIGEgQ2hpbGQgdXBkYXRlIG9wZXJhdGUgb24gKipkaXNqb2ludCoqIHNldHMgb2YgRE9NIG5vZGVzLlxuICAgICAqIC0gVGhleSAqKmRvIG5vdCBjb2xsaWRlKiogYW5kICoqc2hvdWxkIG5vdCBtZXJnZSoqLiBUaGV5IHNob3VsZCBydW4gYXMgaW5kZXBlbmRlbnQsIHBhcmFsbGVsIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiAtIEEgZGlyZWN0IGNoaWxkIGlzIGF0IGBkaXN0YW5jZTogMWAuXG4gICAgICogVGhlcmVmb3JlLCBhbiB1cGRhdGUgd2l0aCBkZXB0aCAxIHNob3VsZCBOT1QgY29sbGlkZSB3aXRoIGEgY2hpbGQgYXQgZGlzdGFuY2UgMSAoMSA8IDEgaXMgZmFsc2UpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVwZGF0ZURlcHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzVXBkYXRlQ29sbGlzaW9uKHVwZGF0ZURlcHRoLCBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVwdGggPT09IC0xID8gdHJ1ZSA6IGRpc3RhbmNlIDwgdXBkYXRlRGVwdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB2bm9kZSB0cmVlIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgbW91bnRzIHRoZSBjb21wb25lbnQgaW4gY2FzZVxuICAgICAqIC0geW91IHBhc3MgdHJ1ZSBmb3IgdGhlIG1vdW50IHBhcmFtXG4gICAgICogLSBvciB0aGUgYXV0b01vdW50IGNvbmZpZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21vdW50XSBNb3VudCB0aGUgRE9NIGFmdGVyIHRoZSB2bm9kZSBnb3QgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IElmIGdldHRpbmcgdGhlcmUsIHdlIHJldHVybiB0aGUgZGF0YSBmcm9tIHZkb20uSGVscGVyOiBjcmVhdGUoKSwgY29udGFpbmluZyB0aGUgdm5vZGUuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdFZub2RlKG1vdW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYXV0b01vdW50ID0gbW91bnQgfHwgbWUuYXV0b01vdW50LFxuICAgICAgICAgICAge2FwcH0gICAgID0gbWUsXG4gICAgICAgICAgICB7YWxsb3dWZG9tVXBkYXRlc0luVGVzdHMsIHVuaXRUZXN0TW9kZSwgdXNlVmRvbVdvcmtlcn0gPSBOZW8uY29uZmlnO1xuXG4gICAgICAgIGlmICh1bml0VGVzdE1vZGUgJiYgIWFsbG93VmRvbVVwZGF0ZXNJblRlc3RzKSByZXR1cm47XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNyaXRpY2FsIHJlbmRlcmluZyBwYXRoID0+IENTUyBmaWxlcyBmb3IgdGhlIG5ldyB0cmVlIGlzIGluIHBsYWNlXG4gICAgICAgIGlmICghdW5pdFRlc3RNb2RlICYmIGF1dG9Nb3VudCAmJiBjdXJyZW50V29ya2VyLmNvdW50TG9hZGluZ1RoZW1lRmlsZXMgIT09IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIub24oJ3RoZW1lRmlsZXNMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAhbWUubW91bnRlZCAmJiBtZS5pbml0Vm5vZGUobW91bnQpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KTtcblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc1Zub2RlSW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWFwcC52bm9kZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBhcHAuaXNWbm9kZUluaXRpYWxpemluZyA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobWUudmRvbSkge1xuICAgICAgICAgICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIG1lLmVuc3VyZVN0YWJsZUlkcygpO1xuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNoaWxkIGNvbXBvbmVudHMgZG8gbm90IHRyaWdnZXIgdXBkYXRlcyB3aGlsZSB0aGUgdm5vZGUgZ2VuZXJhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIFZEb21VcGRhdGUucmVnaXN0ZXJJbkZsaWdodFVwZGF0ZShtZS5pZCwgLTEpO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lLnZkb20ucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICAgICAgbWUuX25lZWRzVmRvbVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1lLmFmdGVyU2V0TmVlZHNWZG9tVXBkYXRlPy4oZmFsc2UsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShOZW8udmRvbS5IZWxwZXIuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9Nb3VudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQgICA6IGF1dG9Nb3VudCA/IG1lLmdldE1vdW50ZWRQYXJlbnRJZCgpICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJbmRleDogYXV0b01vdW50ID8gbWUuZ2V0TW91bnRlZFBhcmVudEluZGV4KCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHZkb20gICAgICAgOiBUcmVlQnVpbGRlci5nZXRWZG9tVHJlZShtZS52ZG9tLCAtMSksXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIG1lLm9uSW5pdFZub2RlKGRhdGEudm5vZGUsIHVzZVZkb21Xb3JrZXIgPyBhdXRvTW91bnQgOiBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXV0b01vdW50ICYmICF1c2VWZG9tV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcnVubmluZyB3aXRob3V0IGEgVmRvbVdvcmtlciwgSGVscGVyLmNyZWF0ZSBpcyBsb2NhbCBhbmQgcmV0dXJucyBhIHBsYWluIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBtYW51YWxseSBzZW5kIHRoZSBpbnNlcnROb2RlIGRlbHRhIHRvIHRoZSBtYWluIHRocmVhZC5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgTmVvLmFwcGx5RGVsdGFzKG1lLndpbmRvd0lkLCBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uICAgOiAnaW5zZXJ0Tm9kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggICAgOiBtZS5nZXRNb3VudGVkUGFyZW50SW5kZXgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVySFRNTDogZGF0YS5vdXRlckhUTUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCA6IG1lLmdldE1vdW50ZWRQYXJlbnRJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUgICAgOiBkYXRhLnZub2RlXG4gICAgICAgICAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZGF0YS5kZWx0YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kZWx0YXMgPSBbXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnJlc29sdmVWZG9tVXBkYXRlKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdpbml0Vm5vZGUgZXJyb3InLCBlcnIsIG1lLmlkKTtcbiAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3luY2hyb25pemF0aW9uIEd1YXJkOiBDaGVja3MgaWYgYW55IGRlc2NlbmRhbnQgY29tcG9uZW50IGlzIGN1cnJlbnRseSB1cGRhdGluZyBpdHMgVkRPTS5cbiAgICAgKlxuICAgICAqIElmIGEgZGVzY2VuZGFudCBpcyBpbi1mbGlnaHQsIHRoaXMgbWV0aG9kIHJlZ2lzdGVycyBhIHBvc3QtdXBkYXRlIGNhbGxiYWNrIG9uIHRoZVxuICAgICAqIGJsb2NraW5nIGRlc2NlbmRhbnQgYW5kIHJldHVybnMgYHRydWVgLCBzaWduYWxpbmcgdGhlIGNhbGxlciAoYHVwZGF0ZVZkb21gKSB0byB5aWVsZC5cbiAgICAgKiBUaGlzIHByZXZlbnRzIHRoZSBQYXJlbnQgZnJvbSBzdGFydGluZyBhbiB1cGRhdGUgdGhhdCBtaWdodCBvdmVyd3JpdGUgb3IgY29uZmxpY3RcbiAgICAgKiB3aXRoIHRoZSBDaGlsZCdzIGNvbmN1cnJlbnQgd29yaywgZWZmZWN0aXZlbHkgc2VyaWFsaXppbmcgdGhlIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV0gR2V0cyBwYXNzZWQgYnkgdXBkYXRlVmRvbSgpIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgYmxvY2tpbmcgdXBkYXRlIGZpbmlzaGVzLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIGEgY2hpbGQgdXBkYXRlIGNvbmZsaWN0IGV4aXN0cyAoUGFyZW50IHNob3VsZCB5aWVsZCkuXG4gICAgICovXG4gICAgaXNDaGlsZFVwZGF0aW5nKHJlc29sdmUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoVkRvbVVwZGF0ZS5oYXNJbkZsaWdodERlc2NlbmRhbnRzKG1lLmlkKSkge1xuICAgICAgICAgICAgbGV0IG1hcCAgICAgICAgICA9IFZEb21VcGRhdGUuZGVzY2VuZGFudEluRmxpZ2h0TWFwLmdldChtZS5pZCksXG4gICAgICAgICAgICAgICAgZGVzY2VuZGFudElkID0gbWFwLmtleXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChOZW8uY29uZmlnLmxvZ1Zkb21VcGRhdGVDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCd2ZG9tIGNoaWxkIHVwZGF0ZSBjb25mbGljdCB3aXRoOicsIGRlc2NlbmRhbnRJZCwgJ2ZvcjonLCBtZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVkRvbVVwZGF0ZS5yZWdpc3RlclBvc3RVcGRhdGUoZGVzY2VuZGFudElkLCBtZS5pZCwgcmVzb2x2ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciB2ZG9tIHVwZGF0ZXMgaW5zaWRlIHRoZSBwYXJlbnQgY2hhaW4gYW5kIGlmIGZvdW5kLlxuICAgICAqIFJlZ2lzdGVycyB0aGUgY29tcG9uZW50IGZvciBhIHZkb20gdXBkYXRlIG9uY2UgZG9uZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWQ9dGhpcy5wYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXSBHZXRzIHBhc3NlZCBieSB1cGRhdGVWZG9tKClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2U9MSBEaXN0YW5jZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0cmVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQYXJlbnRVcGRhdGluZyhwYXJlbnRJZD10aGlzLnBhcmVudElkLCByZXNvbHZlLCBkaXN0YW5jZT0xKSB7XG4gICAgICAgIGlmIChwYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuaXNWZG9tVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbi1mbGlnaHQgdXBkYXRlIGRlcHRoIGZyb20gdGhlIGNlbnRyYWwgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRVcGRhdGVEZXB0aCA9IFZEb21VcGRhdGUuZ2V0SW5GbGlnaHRVcGRhdGVEZXB0aChwYXJlbnQuaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5oYXNVcGRhdGVDb2xsaXNpb24ocGFyZW50VXBkYXRlRGVwdGgsIGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5jb25maWcubG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3Zkb20gcGFyZW50IHVwZGF0ZSBjb25mbGljdCB3aXRoOicsIHBhcmVudCwgJ2ZvcjonLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgVkRvbVVwZGF0ZS5yZWdpc3RlclBvc3RVcGRhdGUocGFyZW50LmlkLCBtZS5pZCwgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gdXBkYXRlIGlzIHJ1bm5pbmcgYW5kIGRvZXMgbm90IGhhdmUgYSBjb2xsaXNpb24sIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgcGFyZW50c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWUuaXNQYXJlbnRVcGRhdGluZyhwYXJlbnQucGFyZW50SWQsIHJlc29sdmUsIGRpc3RhbmNlKzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHBhcmVudCBjaGFpbiB0byBmaW5kIGFuIGFuY2VzdG9yIHRoYXQgaXMgcGVuZGluZyBhIFZET00gdXBkYXRlLlxuICAgICAqIElmIGZvdW5kLCBhbmQgaWYgdGhlIHVwZGF0ZSBzY29wZSBhbGxvd3MgKHNlZSBgY2FuTWVyZ2VVcGRhdGVgKSwgdGhpcyBjb21wb25lbnQnc1xuICAgICAqIHVwZGF0ZSBpcyBtZXJnZWQgaW50byB0aGUgYW5jZXN0b3IncyBjeWNsZS5cbiAgICAgKlxuICAgICAqICoqUmVjdXJzaXZlIFRyYXZlcnNhbDoqKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlY3Vyc2l2ZWx5IHdhbGtzIHVwIHRoZSBjb21wb25lbnQgdHJlZSAoYGRpc3RhbmNlICsgMWApLiBUaGlzIGVuYWJsZXNcbiAgICAgKiB0cmFuc2l0aXZlIG1lcmdpbmcgKEdyYW5kY2hpbGQgLT4gQ2hpbGQgLT4gUGFyZW50KSBhbmQgbWVyZ2luZyBpbnRvIGFuY2VzdG9ycyBldmVuXG4gICAgICogaWYgaW50ZXJtZWRpYXRlIHBhcmVudHMgYXJlIG5vdCB1cGRhdGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRJZD10aGlzLnBhcmVudElkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdIGdldHMgcGFzc2VkIGJ5IHVwZGF0ZVZkb20oKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZT0xIERpc3RhbmNlIGluc2lkZSB0aGUgY29tcG9uZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXBkYXRlIHdhcyBzdWNjZXNzZnVsbHkgbWVyZ2VkLlxuICAgICAqL1xuICAgIG1lcmdlSW50b1BhcmVudFVwZGF0ZShwYXJlbnRJZD10aGlzLnBhcmVudElkLCBkaXN0YW5jZT0xKSB7XG4gICAgICAgIGlmIChwYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBjaGVja2luZyBmb3IgcGFyZW50LnVwZGF0ZURlcHRoLCBzaW5jZSB3ZSBjYXJlIGFib3V0IHRoZSBkZXB0aCBvZiB0aGUgbmV4dCB1cGRhdGUgY3ljbGVcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5lZWRzVmRvbVVwZGF0ZSAmJiBtZS5jYW5NZXJnZVVwZGF0ZShwYXJlbnQudXBkYXRlRGVwdGgsIGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBWRG9tVXBkYXRlLnJlZ2lzdGVyTWVyZ2VkKHBhcmVudC5pZCwgbWUuaWQsIG1lLnVwZGF0ZURlcHRoLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLm1lcmdlSW50b1BhcmVudFVwZGF0ZShwYXJlbnQucGFyZW50SWQsIGRpc3RhbmNlKzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCBmcm9tIHRoZSBpbml0Vm5vZGUoKSBwcm9taXNlIHN1Y2Nlc3MgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2bm9kZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXV0b01vdW50IE1vdW50IHRoZSBET00gYWZ0ZXIgdGhlIHZub2RlIGdvdCBjcmVhdGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uSW5pdFZub2RlKHZub2RlLCBhdXRvTW91bnQpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHB9ID0gbWU7XG5cbiAgICAgICAgbWUuaXNWbm9kZUluaXRpYWxpemluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIGFwcCBpcyBhIGNoZWNrIHRvIHNlZSBpZiB0aGUgQ29tcG9uZW50IGdvdCBkZXN0cm95ZWQgd2hpbGUgdm5vZGVJbml0aWFsaXNpbmcgPT4gYmVmb3JlIG9uSW5pdFZub2RlIGdvdCB0cmlnZ2VyZWRcbiAgICAgICAgaWYgKGFwcCkge1xuICAgICAgICAgICAgaWYgKCFhcHAudm5vZGVJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGFwcC5pc1Zub2RlSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYXBwLnZub2RlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFwcC5maXJlKCd2bm9kZUluaXRpYWxpemVkJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUudm5vZGUgPSB2bm9kZTtcblxuICAgICAgICAgICAgbGV0IGNoaWxkSWRzID0gQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZElkcyh2bm9kZSksXG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgID0gY2hpbGRJZHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNoaWxkO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBOZW8uZ2V0Q29tcG9uZW50KGNoaWxkSWRzW2ldKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC52bm9kZUluaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUudm5vZGVJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChhdXRvTW91bnQpIHtcbiAgICAgICAgICAgICAgICBtZS5tb3VudGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICghYXBwLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhcHAuZmlyZSgnbW91bnRlZCcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9taXNlVXBkYXRlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IFN5bWJvbCgpO1xuXG4gICAgICAgICAgICBtZS5yZWdpc3RlckFzeW5jKGlkLCByZWplY3QpO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVWZG9tKFxuICAgICAgICAgICAgICAgICh2YWwpID0+IHttZS51bnJlZ2lzdGVyQXN5bmMoaWQpOyByZXNvbHZlKHZhbCl9LFxuICAgICAgICAgICAgICAgIChlcnIpID0+IHttZS51bnJlZ2lzdGVyQXN5bmMoaWQpOyByZWplY3QoZXJyKX1cbiAgICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZm4gdG8gcmVzb2x2ZSB0aGUgUHJvbWlzZSBmb3IgdXBkYXRlVmRvbSgpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBUaGUgcmV0dXJuIHZhbHVlIG9mIHZkb20uSGVscGVyLnVwZGF0ZSgpXG4gICAgICogQHBhcmFtIHtTZXQ8U3RyaW5nPnxudWxsfSBbbWVyZ2VkQ2hpbGRJZHNdIElEcyBvZiBjaGlsZHJlbiBpbmNsdWRlZCBpbiB0aGlzIHVwZGF0ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZXNvbHZlVmRvbVVwZGF0ZShkYXRhLCBtZXJnZWRDaGlsZElkcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIG1lcmdlZCB1cGRhdGVzXG4gICAgICAgIFZEb21VcGRhdGUuZXhlY3V0ZUNhbGxiYWNrcyhtZS5pZCwgZGF0YSwgbWVyZ2VkQ2hpbGRJZHMpO1xuXG4gICAgICAgIC8vIFRoZSB1cGRhdGUgaXMgbm8gbG9uZ2VyIGluLWZsaWdodFxuICAgICAgICBWRG9tVXBkYXRlLnVucmVnaXN0ZXJJbkZsaWdodFVwZGF0ZShtZS5pZCk7XG5cbiAgICAgICAgLy8gVHJpZ2dlciB1cGRhdGVzIGZvciBjb21wb25lbnRzIHRoYXQgd2VyZSBpbi1mbGlnaHRcbiAgICAgICAgVkRvbVVwZGF0ZS50cmlnZ2VyUG9zdFVwZGF0ZXMobWUuaWQpO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2tzIHdoaWNoIHdhbnRlZCB0byBydW4gYmVmb3JlIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZVxuICAgICAgICBWRG9tVXBkYXRlLmV4ZWN1dGVQcmVVcGRhdGVzKG1lLmlkKTtcblxuICAgICAgICBpZiAobWUubmVlZHNWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBhbnkgbmV3IHByb21pc2UgY2FsbGJhY2tzIHdpbGwgZ2V0IHBpY2tlZCB1cCBieSB0aGUgbmV4dCB1cGRhdGUgY3ljbGVcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgZm9yIHV0aWwuVkRvbS5zeW5jVmRvbVN0YXRlIHRvIGFsbG93IG92ZXJyaWRpbmcgKGRpc2FibGluZykgaXRcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBbdm5vZGU9dGhpcy52bm9kZV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Zkb209dGhpcy52ZG9tXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2U9ZmFsc2VcbiAgICAgKi9cbiAgICBzeW5jVmRvbVN0YXRlKHZub2RlPXRoaXMudm5vZGUsIHZkb209dGhpcy52ZG9tLCBmb3JjZT1mYWxzZSkge1xuICAgICAgICBWRG9tVXRpbC5zeW5jVmRvbVN0YXRlKHZub2RlLCB2ZG9tLCBmb3JjZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIGEgY29tcG9uZW50IHJlY2VpdmVzIGEgbmV3IHZub2RlLCB3ZSB3YW50IHRvIGRvOlxuICAgICAqIC0gc3luYyB0aGUgdmRvbSBpZHNcbiAgICAgKiAtIHNldHRpbmcgdm5vZGVJbml0aWFsaXplZCB0byB0cnVlIGZvciBjaGlsZCBjb21wb25lbnRzXG4gICAgICogLSB1cGRhdGluZyB0aGUgcGFyZW50IGNvbXBvbmVudCB0byBlbnN1cmUgdGhhdCB0aGUgdm5vZGUgdHJlZSBzdGF5cyBwZXJzaXN0ZW50XG4gICAgICpcbiAgICAgKiAqKkltcGxlbWVudGF0aW9uIERldGFpbDoqKlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgYSB0d28tcGFzcyBzdHJhdGVneSB0byBoYW5kbGUgY2hpbGQgdXBkYXRlczpcbiAgICAgKiAxLiAqKlVwZGF0ZSBWaXNpYmxlIENoaWxkcmVuOioqIFdlIGl0ZXJhdGUgb3ZlciBjaGlsZHJlbiBmb3VuZCBkaXJlY3RseSBpbiB0aGUgbmV3IFZOb2RlIHN0cnVjdHVyZVxuICAgICAqICAgICh2aWEgYENvbXBvbmVudE1hbmFnZXIuZ2V0Q2hpbGRyZW5gKS4gVGhpcyBwcmVzZXJ2ZXMgdGhlIGJhc2VsaW5lIGJlaGF2aW9yIHdoZXJlIGZ1bGx5IGV4cGFuZGVkXG4gICAgICogICAgVk5vZGUgdHJlZXMgKGUuZy4sIGZyb20gYEhlbHBlci5jcmVhdGVgKSBhcmUgc3luY2VkIHdpdGhvdXQgdW5uZWNlc3NhcnkgXCJkb3duZ3JhZGluZ1wiIHRvIHJlZmVyZW5jZXMuXG4gICAgICogMi4gKipVbm1vdW50IE1pc3NpbmcgQ2hpbGRyZW46KiogV2UgaXRlcmF0ZSBvdmVyIEFMTCBsb2dpY2FsIGNoaWxkcmVuICh2aWEgYENvbXBvbmVudE1hbmFnZXIuZmluZGApXG4gICAgICogICAgdG8gZGV0ZWN0IGFueSB0aGF0IGFyZSBhYnNlbnQgZnJvbSB0aGUgbmV3IFZOb2RlIHRyZWUgKGUuZy4sIGByZW1vdmVEb206IHRydWVgKS5cbiAgICAgKiAgICBDcnVjaWFsbHksIHdlIHVzZSBgVk5vZGVVdGlsLmZpbmRgIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gYSBcIlBsYWNlaG9sZGVyXCIgKHZhbGlkLCBkbyBub3RoaW5nKVxuICAgICAqICAgIGFuZCBhIFwiUmVtb3ZhbFwiIChpbnZhbGlkLCB1bm1vdW50KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IFt2bm9kZT10aGlzLnZub2RlXVxuICAgICAqL1xuICAgIHN5bmNWbm9kZVRyZWUodm5vZGU9dGhpcy52bm9kZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNoaWxkQ29tcG9uZW50cyA9IENvbXBvbmVudE1hbmFnZXIuZ2V0Q2hpbGRyZW4obWUpLFxuICAgICAgICAgICAgZGVidWcgICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBtYXAgICAgICAgICAgICAgPSB7fSxcbiAgICAgICAgICAgIGNoaWxkVm5vZGUsIHN0YXJ0O1xuXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuc3luY1Zkb21TdGF0ZSgpO1xuXG4gICAgICAgIGlmICh2bm9kZSAmJiBtZS5pZCAhPT0gdm5vZGUuaWQpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXJXcmFwcGVyTm9kZSh2bm9kZS5pZCwgbWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBuZWVkIG9uZSBzZXBhcmF0ZSBpdGVyYXRpb24gZmlyc3QgdG8gZW5zdXJlIGFsbCB3cmFwcGVyIG5vZGVzIGdldCByZWdpc3RlcmVkXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjaGlsZENvbXBvbmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSBjaGlsZENvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBjaGlsZFZub2RlID0gVk5vZGVVdGlsLmZpbmQobWUudm5vZGUsIGNvbXBvbmVudC52ZG9tLmlkKT8udm5vZGU7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZFZub2RlKSB7XG4gICAgICAgICAgICAgICAgbWFwW2NvbXBvbmVudC5pZF0gPSBjaGlsZFZub2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5pZCAhPT0gY2hpbGRWbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyV3JhcHBlck5vZGUoY2hpbGRWbm9kZS5pZCwgY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlbGVnYXRlIHRoZSBsYXRlc3Qgbm9kZSB1cGRhdGVzIHRvIGFsbCBwb3NzaWJsZSBjaGlsZCBjb21wb25lbnRzIGZvdW5kIGluc2lkZSB0aGUgdm5vZGUgdHJlZVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hpbGRDb21wb25lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gY2hpbGRDb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgY2hpbGRWbm9kZSA9IG1hcFtjb21wb25lbnQuaWRdO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRWbm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuX3Zub2RlID0gQ29tcG9uZW50TWFuYWdlci5hZGRWbm9kZUNvbXBvbmVudFJlZmVyZW5jZXMoY2hpbGRWbm9kZSwgY29tcG9uZW50LmlkKTtcblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC52bm9kZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQubW91bnRlZCAgICAgICAgICA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzeW5jVm5vZGVUcmVlOiBDb3VsZCBub3QgcmVwbGFjZSB0aGUgY2hpbGQgdm5vZGUgZm9yJywgY29tcG9uZW50LmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmV3IGxvZ2ljIHRvIGhhbmRsZSB1bm1vdW50aW5nIG9mIHJlbW92ZWQgY2hpbGRyZW5cbiAgICAgICAgbGV0IGRpcmVjdENoaWxkcmVuID0gQ29tcG9uZW50TWFuYWdlci5nZXREaXJlY3RDaGlsZHJlbihtZS5pZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkaXJlY3RDaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudCA9IGRpcmVjdENoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKCFjaGlsZENvbXBvbmVudHMuaW5jbHVkZXMoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGNoaWxkVm5vZGUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgZXhpc3RzIGluIHRoZSB0cmVlIChhcyBwbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgVk5vZGVVdGlsLmZpbmQgd2hpY2ggcmVzb2x2ZXMgcGxhY2Vob2xkZXJzXG4gICAgICAgICAgICAgICAgaWYgKG1lLnZub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVm5vZGUgPSBWTm9kZVV0aWwuZmluZChtZS52bm9kZSwgY29tcG9uZW50LnZkb20uaWQpPy52bm9kZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY2hpbGRWbm9kZSAmJiAhY29tcG9uZW50LmZsb2F0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5fdm5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubW91bnRlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICBtZS5fdm5vZGUgPSB2bm9kZSA/IENvbXBvbmVudE1hbmFnZXIuYWRkVm5vZGVDb21wb25lbnRSZWZlcmVuY2VzKHZub2RlLCBtZS5pZCkgOiBudWxsO1xuXG4gICAgICAgIGRlYnVnICYmIGNvbnNvbGUubG9nKCdzeW5jVm5vZGVUcmVlJywgbWUuaWQsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuYWZ0ZXJTZXRWZG9tKHRoaXMudmRvbSwgbnVsbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgdmRvbSBjb25maWcgZ2V0cyBjaGFuZ2VkIGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBhbHJlYWR5IG1vdW50ZWQgKGRlbHRhIHVwZGF0ZXMpLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXNvbHZlXSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZWplY3RdIHVzZWQgYnkgcHJvbWlzZVVwZGF0ZSgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVZkb20ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICByZXNvbHZlPy4oKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttb3VudGVkLCBwYXJlbnRJZCwgdm5vZGV9ID0gbWUsXG4gICAgICAgICAgICB7Y29uZmlnfSAgICAgICAgICAgICAgICAgICA9IE5lbztcblxuICAgICAgICBpZiAoY29uZmlnLnVuaXRUZXN0TW9kZSAmJiAhY29uZmlnLmFsbG93VmRvbVVwZGF0ZXNJblRlc3RzKSB7XG4gICAgICAgICAgICByZWplY3Q/LigpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5lbnN1cmVTdGFibGVJZHMoKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcHJvbWlzZSwgcmVnaXN0ZXIgaXQgYWdhaW5zdCB0aGlzIGNvbXBvbmVudCdzIElEIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGUgbWFuYWdlciB3aWxsIGVuc3VyZSBpdCdzIGNhbGxlZCB3aGVuIHRoZSBhcHByb3ByaWF0ZSB1cGRhdGUgY3ljbGUgY29tcGxldGVzLlxuICAgICAgICByZXNvbHZlICYmIFZEb21VcGRhdGUuYWRkUHJvbWlzZUNhbGxiYWNrKG1lLmlkLCByZXNvbHZlKTtcblxuICAgICAgICAvLyBBdHRlbXB0IHRvIG1lcmdlIGludG8gYSBwYXJlbnQncyB1cGRhdGUgY3ljbGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgZXZlbiBpZiBzaWxlbnQsIHRvIGVuc3VyZSB3ZSBjYXRjaCB0aGUgYnVzIGlmIGEgcGFyZW50IGlzIGRlcGFydGluZy5cbiAgICAgICAgaWYgKG1lLm1lcmdlSW50b1BhcmVudFVwZGF0ZShwYXJlbnRJZCkpIHtcbiAgICAgICAgICAgIG1lLm5lZWRzVmRvbVVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5pc1Zkb21VcGRhdGluZyB8fCAhbWUudm5vZGVJbml0aWFsaXplZCB8fCBtZS5zaWxlbnRWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICBtZS5uZWVkc1Zkb21VcGRhdGUgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhbiB1cGRhdGUgaXMgdHJpZ2dlcmVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQsIHdlIG11c3Qgd2FpdCBmb3IgaXQgdG8gYmUgbW91bnRlZC5cbiAgICAgICAgICAgIGlmICghbW91bnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBhIGZsYWcgdG8gcHJldmVudCBzZXR0aW5nIHVwIG11bHRpcGxlIGB0aGVuYCBsaXN0ZW5lcnMgZm9yIHN1YnNlcXVlbnQgdXBkYXRlc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgbWlnaHQgYXJyaXZlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICAgICAgICAgICAgaWYgKCFtZS5pc0F3YWl0aW5nTW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNBd2FpdGluZ01vdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWUubW91bnRlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5pc0F3YWl0aW5nTW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIG1vdW50aW5nLCByZS10cmlnZ2VyIHRoZSB1cGRhdGUgY3ljbGUuIFRoZSBjYWNoZWQgY2FsbGJhY2tzIHdpbGwgYmUgcGlja2VkIHVwLlxuICAgICAgICAgICAgICAgICAgICAgICAgbWUudm5vZGUgJiYgbWUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIW1lLmlzUGFyZW50VXBkYXRpbmcocGFyZW50SWQsIHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgICYmICFtZS5pc0NoaWxkVXBkYXRpbmcocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgJiYgdm5vZGVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1lcmdlZCBjaGlsZCB1cGRhdGVzIGFuZCBhZGp1c3QgdGhlIHVwZGF0ZSBkZXB0aCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgYWRqdXN0ZWREZXB0aCA9IFZEb21VcGRhdGUuZ2V0QWRqdXN0ZWRVcGRhdGVEZXB0aChtZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChhZGp1c3RlZERlcHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBtZS51cGRhdGVEZXB0aCA9IGFkanVzdGVkRGVwdGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY3JpdGljYWwgcmVuZGVyaW5nIHBhdGggPT4gQ1NTIGZpbGVzIGZvciB0aGUgbmV3IHRyZWUgaXMgaW4gcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuaXNNaWRkbGV3YXJlICYmICFjb25maWcudW5pdFRlc3RNb2RlICYmIGN1cnJlbnRXb3JrZXIuY291bnRMb2FkaW5nVGhlbWVGaWxlcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmtlci5vbigndGhlbWVGaWxlc0xvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZVZkb20ocmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmV4ZWN1dGVWZG9tVXBkYXRlKG51bGwsIHJlamVjdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVmRvbUxpZmVjeWNsZSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5LZXlOYXZpZ2F0aW9uXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEtleU5hdmlnYXRpb24gZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLktleU5hdmlnYXRpb24nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLktleU5hdmlnYXRpb24nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0na2V5bmF2J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2tleW5hdicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbGx5IHN0b3JlcyB0aGUgY29tcG9uZW50IGlkIGluc2lkZSBfY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpbiBjYXNlIHRoZSBrZXlkb3duIGV2ZW50IGlzIHN1cHBvc2VkIHRvIGJ1YmJsZSB1cHdhcmRzIGluc2lkZSB0aGUgY29tcG9uZW50IHRyZWVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0ga2V5RG93bkV2ZW50QnViYmxlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBrZXlEb3duRXZlbnRCdWJibGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0ga2V5c189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGtleXNfOiBudWxsXG4gICAgfVxuXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2tleXMucHVzaCguLi50aGlzLnBhcnNlS2V5cyh2YWx1ZSkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V9XG4gICAgICovXG4gICAgYmVmb3JlR2V0Q29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gTmVvLmdldENvbXBvbmVudCh0aGlzLl9jb21wb25lbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBjb21wb25lbnQgaWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb21wb25lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlPy5pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25LZXlEb3duKGRhdGEpIHtcbiAgICAgICAgLy8gVXNpbmcgdGhlIGNocm9tZSBhdXRvLWZpbGwgZmVhdHVyZSBkb2VzIHRyaWdnZXIgYSBrZXlkb3duIGV2ZW50LCBub3QgY29udGFpbmluZyBhIGtleS4gU2VlOiAjNjRcbiAgICAgICAgaWYgKGRhdGEua2V5KSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB1cHBlckNhc2VLZXkgPSBkYXRhLmtleS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIHNjb3BlO1xuXG4gICAgICAgICAgICB1cHBlckNhc2VLZXkgPSBtZS5wYXJzZVVwcGVyQ2FzZUtleSh1cHBlckNhc2VLZXkpO1xuXG4gICAgICAgICAgICBtZS5rZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBzY29wZSA9IE5lby5pc1N0cmluZyhrZXkuc2NvcGUpID8gTmVvLmdldChrZXkuc2NvcGUpIDoga2V5LnNjb3BlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleS5rZXkudG9VcHBlckNhc2UoKSA9PT0gdXBwZXJDYXNlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNGdW5jdGlvbihrZXkuZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuZm4uYXBwbHkoc2NvcGUsIFtkYXRhLCBtZS5jb21wb25lbnRdKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVba2V5LmZuXT8uYXBwbHkoc2NvcGUsIFtkYXRhLCBtZS5jb21wb25lbnRdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgcGFyc2VLZXlzKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRJZCA9IHRoaXMuX2NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBrZXlBcnJheSAgICA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnc2NvcGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlBcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiAgIDogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogdmFsdWUuc2NvcGUgfHwgY29tcG9uZW50SWQgLy8gdG9kbzogc3VwcG9ydCBWQ3MgbGF0ZXIgb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0ga2V5QXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHNwZWNpZmljIGtleSBuYW1lcywgZS5nLiBcIiBcIiA9PiBTUEFDRVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBwYXJzZVVwcGVyQ2FzZUtleShrZXkpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgIGtleSA9ICdTUEFDRSc7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FSUk9XRE9XTic6XG4gICAgICAgICAgICAgICAga2V5ID0gJ0RPV04nO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV0xFRlQnOlxuICAgICAgICAgICAgICAgIGtleSA9ICdMRUZUJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVJST1dSSUdIVCc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ1JJR0hUJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVJST1dVUCc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ1VQJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICByZWdpc3Rlcihjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIG1lLmtleXMgICAgICA9IG1lLnBhcnNlS2V5cyhtZS5rZXlzKTtcblxuICAgICAgICBjb21wb25lbnQuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGtleWRvd246IHtcbiAgICAgICAgICAgICAgICBidWJibGU6IG1lLmtleURvd25FdmVudEJ1YmJsZSxcbiAgICAgICAgICAgICAgICBmbiAgICA6IG1lLm9uS2V5RG93bixcbiAgICAgICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEga2V5IGxpc3RlbmVyIHVzaW5nIHRoZSBzYW1lIGNvbmZpZyB1c2VkIHdoZW4gY3JlYXRpbmcgaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgcmVtb3ZlS2V5KGNvbmZpZykge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBrZXlzID0gbWUuX2tleXMsXG4gICAgICAgICAgICBpICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgICBpZiAoTmVvLmlzRXF1YWwoa2V5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBtdWx0aXBsZSBrZXkgbGlzdGVuZXJzIHBhc3NpbmcgYW4gYXJyYXkgb2YgY29uZmlnIGl0ZW1zXG4gICAgICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAgICAgKi9cbiAgICByZW1vdmVLZXlzKGl0ZW1zKSB7XG4gICAgICAgIEFycmF5LmlzQXJyYXkoaXRlbXMpICYmIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB0aGlzLnJlbW92ZUtleShpdGVtKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoKSB7XG4gICAgICAgIC8vIHRvZG86IHJlbW92ZSB0aGUgZG9tIGxpc3RlbmVyIGZyb20gdGhlIG93bmVyIGNvbXBvbmVudFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIEtleU5hdmlnYXRpb24gaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgY29tcG9uZW50OiBtZS5zZXJpYWxpemVDb25maWcobWUuY29tcG9uZW50KSxcbiAgICAgICAgICAgIGtleXMgICAgIDogbWUuc2VyaWFsaXplQ29uZmlnKG1lLmtleXMpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEtleU5hdmlnYXRpb24pO1xuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlN0eWxlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFN0eWxlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5TdHlsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuU3R5bGUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBkZWx0YSBvYmplY3QsIGNvbnRhaW5pbmcgdGhlIHN0eWxlcyBvZiBuZXdTdHlsZSB3aGljaCBhcmUgbm90IGluY2x1ZGVkIG9yIGRpZmZlcmVudCB0aGFuIGluIG9sZFN0eWxlXG4gICAgICogU3R5bGVzIGluY2x1ZGVkIGluIG9sZFN0eWxlIGJ1dCBtaXNzaW5nIGluIG5ld1N0eWxlIHdpbGwgZ2V0IGEgdmFsdWUgb2YgbnVsbFxuICAgICAqIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L3N0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuZXdTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb2xkU3R5bGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdHlsZSBkZWx0YVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlU3R5bGVzKG5ld1N0eWxlLCBvbGRTdHlsZSkge1xuICAgICAgICBsZXQgc3R5bGVzID0ge307XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhuZXdTdHlsZSkpIHtcbiAgICAgICAgICAgIG5ld1N0eWxlID0gTmVvLmNyZWF0ZVN0eWxlT2JqZWN0KG5ld1N0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhvbGRTdHlsZSkpIHtcbiAgICAgICAgICAgIG9sZFN0eWxlID0gTmVvLmNyZWF0ZVN0eWxlT2JqZWN0KG9sZFN0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXdTdHlsZSAmJiAhb2xkU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAoIW9sZFN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmNsb25lKG5ld1N0eWxlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3R5bGUgJiYgT2JqZWN0LmtleXMobmV3U3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb2xkU3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpIHx8IG9sZFN0eWxlW3N0eWxlXSAhPT0gbmV3U3R5bGVbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBuZXdTdHlsZVtzdHlsZV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMob2xkU3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbmV3U3R5bGUgIHx8ICFuZXdTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0eWxlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3R5bGUpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi8uLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEEgc2luZ2xldG9uIHV0aWxpdHkgY2xhc3MgcmVzcG9uc2libGUgZm9yIHJlY3Vyc2l2ZWx5IGJ1aWxkaW5nIFZET00gYW5kIFZOb2RlIHRyZWVzLlxuICogSXQgY2FuIGV4cGFuZCBjb21wb25lbnQgcmVmZXJlbmNlcyB3aXRoaW4gYSB0cmVlIHN0cnVjdHVyZSBpbnRvIHRoZWlyIGZ1bGwgVkRPTS9WTm9kZSByZXByZXNlbnRhdGlvbnMsXG4gKiBzdXBwb3J0aW5nIHNlbGVjdGl2ZSAoYXN5bW1ldHJpYykgdHJlZSBleHBhbnNpb24gZm9yIG9wdGltaXplZCB1cGRhdGVzLlxuICogQGNsYXNzIE5lby51dGlsLnZkb20uVHJlZUJ1aWxkZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgVHJlZUJ1aWxkZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLnZkb20uVHJlZUJ1aWxkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLnZkb20uVHJlZUJ1aWxkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBoZWxwZXIgdG8gcmVjdXJzaXZlbHkgYnVpbGQgYSB0cmVlLCBhYnN0cmFjdGluZyB0aGUgY2hpbGQgbm9kZSBrZXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgVGhlIHZkb20gb3Igdm5vZGUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVwdGggVGhlIGN1cnJlbnQgcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gbWVyZ2VkQ2hpbGRJZHMgQSBzZXQgb2YgY29tcG9uZW50IElEcyB0byBzZWxlY3RpdmVseSBleHBhbmQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkS2V5IFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBjaGlsZCBub2RlcyAoJ2NuJyBvciAnY2hpbGROb2RlcycpLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjYnVpbGRUcmVlKG5vZGUsIGRlcHRoLCBtZXJnZWRDaGlsZElkcywgY2hpbGRLZXkpIHtcbiAgICAgICAgLy8gV2UgY2FuIG5vdCB1c2UgTmVvLmlzT2JqZWN0KCkgaGVyZSwgc2luY2UgaW5zaWRlIHVuaXQtdGVzdCBzY2VuYXJpb3MsIHdlIHdpbGwgaW1wb3J0IHZkb20uSGVscGVyIGludG8gbWFpbiB0aHJlYWRzLlxuICAgICAgICAvLyBJbnNpZGUgdGhpcyBzY2VuYXJpbywgTmVvLmlzT2JqZWN0KCkgcmV0dXJucyBmYWxzZSBmb3IgVk5vZGUgaW5zdGFuY2VzXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEpJVCBJRCBHZW5lcmF0aW9uIChBcHAgQXV0aG9yaXR5KVxuICAgICAgICAvLyBJZiB3ZSBhcmUgcHJvY2Vzc2luZyBhIFZET00gdHJlZSAoY2hpbGRLZXkgPT09ICdjbicpIGFuZCB0aGUgbm9kZSBoYXMgbm8gSUQsXG4gICAgICAgIC8vIHdlIG11c3QgZ2VuZXJhdGUgb25lIG5vdyB0byBlbnN1cmUgZGV0ZXJtaW5pc3RpYyBpZGVudGl0eSBiZWZvcmUgdGhlIFZET00gbGVhdmVzIHRoZSBBcHAgV29ya2VyLlxuICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICdjbicgJiYgIW5vZGUuaWQpIHtcbiAgICAgICAgICAgIG5vZGUuaWQgPSBOZW8uZ2V0SWQobm9kZS52dHlwZSA9PT0gJ3RleHQnID8gJ3Z0ZXh0JyA6ICd2bm9kZScpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0ID0gey4uLm5vZGV9OyAvLyBTaGFsbG93IGNvcHlcblxuICAgICAgICBpZiAobm9kZVtjaGlsZEtleV0pIHtcbiAgICAgICAgICAgIG91dHB1dFtjaGlsZEtleV0gPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGVbY2hpbGRLZXldLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gICAgICAgID0gbm9kZVtjaGlsZEtleV1baV0sXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGREZXB0aDtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SXRlbS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBDb21wb25lbnRNYW5hZ2VyLmdldChjdXJyZW50SXRlbS5jb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3BhcnNlIFRyZWUgR2VuZXJhdGlvbiAmIFNjb3BlZCBVcGRhdGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHBydW5lIHRoZSBicmFuY2ggKHNlbmQgYSBwbGFjZWhvbGRlcikgaWY6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIFdlIGFyZSBhdCB0aGUgZGVwdGggYm91bmRhcnkgKGRlcHRoID09PSAxKSBBTkQgaXQncyBub3QgYSBtZXJnZWQgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBXZSBhcmUgaW4gYSBNZXJnZWQgVXBkYXRlIChtZXJnZWRDaGlsZElkcyBleGlzdHMpIEFORCB0aGlzIGNvbXBvbmVudCBpcyBub3QgaW4gdGhlIEFsbG93TGlzdCAobm90IGRpcnR5L2JyaWRnZSkuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbjogV2UgbmV2ZXIgcHJ1bmUgaWYgZGVwdGggaXMgLTEgKEZ1bGwgVHJlZSkgb3IgaWYgdGhlIGNvbXBvbmVudCBpcyBub3QgbW91bnRlZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCAhPT0gLTEgJiYgY29tcG9uZW50Py52bm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFeHBhbmRhYmxlID0gbWVyZ2VkQ2hpbGRJZHM/LmhhcyhjdXJyZW50SXRlbS5jb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGVwdGggPT09IDEgJiYgIWlzRXhwYW5kYWJsZSkgfHwgKG1lcmdlZENoaWxkSWRzICYmICFpc0V4cGFuZGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2NoaWxkS2V5XS5wdXNoKHsuLi5jdXJyZW50SXRlbSwgbmVvSWdub3JlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgLy8gU3RvcCBwcm9jZXNzaW5nIHRoaXMgYnJhbmNoLCBtb3ZlIHRvIG5leHQgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwYW5kIHRoZSBicmFuY2ggaWYgaXQncyBwYXJ0IG9mIGEgbWVyZ2VkIHVwZGF0ZSwgb3IgaWYgdGhlIGRlcHRoIHJlcXVpcmVzIGl0LCBPUiBpZiB0aGUgdm5vZGUgaXMgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPiAxIHx8IGRlcHRoID09PSAtMSB8fCBtZXJnZWRDaGlsZElkcz8uaGFzKGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKSB8fCAhY29tcG9uZW50Py52bm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBjb3JyZWN0IHRyZWUgdHlwZSBiYXNlZCBvbiB0aGUgY2hpbGRLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFRyZWUgPSBjaGlsZEtleSA9PT0gJ2NuJyA/IGNvbXBvbmVudD8udmRvbSA6IGNvbXBvbmVudD8udm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50VHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gY29tcG9uZW50VHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGREZXB0aCA9IChkZXB0aCA9PT0gLTEpID8gLTEgOiBNYXRoLm1heCgwLCBkZXB0aCAtIDEpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGREZXB0aCA9IGRlcHRoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3V0cHV0W2NoaWxkS2V5XS5wdXNoKHRoaXMuI2J1aWxkVHJlZShjdXJyZW50SXRlbSwgY2hpbGREZXB0aCwgbWVyZ2VkQ2hpbGRJZHMsIGNoaWxkS2V5KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIGdpdmVuIHZkb20gdHJlZSBhbmQgcmVwbGFjZXMgY2hpbGQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aCB0aGVpciB2ZG9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZXB0aD0tMV1cbiAgICAgKiBAcGFyYW0ge1NldDxTdHJpbmc+fG51bGx9IFttZXJnZWRDaGlsZElkcz1udWxsXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmRvbVRyZWUodmRvbSwgZGVwdGg9LTEsIG1lcmdlZENoaWxkSWRzPW51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1aWxkVHJlZSh2ZG9tLCBkZXB0aCwgbWVyZ2VkQ2hpbGRJZHMsICdjbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgZ2l2ZW4gdm5vZGUgdHJlZSBhbmQgcmVwbGFjZXMgY2hpbGQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aCB0aGVpciB2bm9kZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoPS0xXVxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gW21lcmdlZENoaWxkSWRzPW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVRyZWUodm5vZGUsIGRlcHRoPS0xLCBtZXJnZWRDaGlsZElkcz1udWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNidWlsZFRyZWUodm5vZGUsIGRlcHRoLCBtZXJnZWRDaGlsZElkcywgJ2NoaWxkTm9kZXMnKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVHJlZUJ1aWxkZXIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9