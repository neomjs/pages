"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_Base_mjs"],{

/***/ "./src/component/Base.mjs":
/*!********************************!*\
  !*** ./src/component/Base.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/KeyNavigation.mjs */ "./src/util/KeyNavigation.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_Style_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Style.mjs */ "./src/util/Style.mjs");
/* harmony import */ var _core_Util_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/Util.mjs */ "./src/core/Util.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");














const
    addUnits            = value => value == null ? value : isNaN(value) ? value : `${value}px`,
    closestController   = Symbol.for('closestController'),
    closestProvider     = Symbol.for('closestProvider'),
    {currentWorker}     = Neo,
    lengthRE            = /^\d+\w+$/,
    twoWayBindingSymbol = Symbol.for('twoWayBinding');

/**
 * Base class for all Components which have a DOM representation
 * @class Neo.component.Base
 * @extends Neo.core.Base
 */
class Component extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for hideMode
     * @member {String[]} hideModes=['removeDom','visibility']
     * @protected
     * @static
     */
    static hideModes = ['removeDom', 'visibility']
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.component.Base'
         * @protected
         */
        className: 'Neo.component.Base',
        /**
         * @member {String} ntype='component'
         * @protected
         */
        ntype: 'component',
        /**
         * The default alignment specification to position this Component relative to some other
         * Component, or Element or Rectangle. Only applies in case floating = true.
         * @member {Object|String} align_={edgeAlign:'t-b',constrainTo:'document.body'}
         */
        align_: {
            edgeAlign  : 't-b',
            constrainTo: 'document.body'
        },
        /**
         * The name of the App this component belongs to
         * @member {String|null} appName_=null
         */
        appName_: null,
        /**
         * True automatically mounts a component after being rendered.
         * Use this for the top level component of your app.
         * @member {Boolean} autoMount=false
         * @tutorial 02_ClassSystem
         */
        autoMount: false,
        /**
         * True automatically renders a component after being created inside the init call.
         * Use this for the top level component of your app.
         * @member {Boolean} autoRender=false
         * @see {@link Neo.component.Base#init init}
         * @tutorial 02_ClassSystem
         */
        autoRender: false,
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=[]
         */
        baseCls: [],
        /**
         * Bind configs to state.Provider data properties.
         * Example for a button.Base:
         * @example
         * bind: {
         *     iconCls: data => `fa fa-{$data.icon}`,
         *     text   : data => data.foo.bar
         * }
         * @see https://github.com/neomjs/neo/blob/dev/examples/stateProvider
         * @member {Object|null} bind=null
         */
        bind: null,
        /**
         * Custom CSS selectors to apply to the root level node of this component
         * You can override baseCls to remove default selectors.
         * @member {String[]} cls_=null
         */
        cls_: null,
        /**
         * manager.Focus will change this flag on focusin & out dom events
         * @member {Boolean} containsFocus_=false
         * @protected
         */
        containsFocus_: false,
        /**
         * Assign a component controller to this component (pass an imported module or the string based class name)
         * @member {Neo.controller.Component|String} controller_=null
         */
        controller_: null,
        /**
         * Convenience shortcut to access the data config of the closest state.Provider.
         * Read only.
         * @member {Object} data_=null
         * @protected
         */
        data_: null,
        /**
         * Disabled components will get the neo-disabled cls applied and won't receive DOM events
         * @member {Boolean} disabled_=false
         */
        disabled_: false,
        /**
         * An array of domListener configs
         * @member {Object[]|null} domListeners_=null
         * @example
         * afterSetStayOnHover(value, oldValue) {
         *     if (value) {
         *         let me = this;
         *
         *         me.addDomListeners(
         *             {mouseenter: me.onMouseEnter, scope: me},
         *             {mouseleave: me.onMouseLeave, scope: me}
         *         )
         *    }
         *}
         */
        domListeners_: null,
        /**
         * Set this config to true to dynamically import a DropZone module & create an instance
         * @member {Boolean} droppable_=false
         */
        droppable_: false,
        /**
         * @member {Neo.draggable.DropZone|null} dropZone=null
         */
        dropZone: null,
        /**
         * @member {Object} dropZoneConfig=null
         */
        dropZoneConfig: null,
        /**
         * True to render this component into the viewport outside of the document flow
         * @member {Boolean} floating
         */
        floating: false,
        /**
         * Internal flag which will get set to true on mount
         * @member {Boolean} hasBeenMounted=false
         * @protected
         */
        hasBeenMounted: false,
        /**
         * Internal flag
         * @member {Boolean} hasRenderingListener=false
         * @protected
         */
        hasRenderingListener: false,
        /**
         * Internal flag for vdom changes after a component got unmounted
         * (delta updates can no longer get applied & a new render call is required before re-mounting)
         * @member {Boolean} hasUnmountedVdomChanges_=false
         * @protected
         */
        hasUnmountedVdomChanges_: false,
        /**
         * Shortcut for style.height, defaults to px
         * @member {Number|String|null} height_=null
         */
        height_: null,
        /**
         * Initial setting to hide or show the component and
         * you can use either hide()/show() or change this config directly to change the hidden state
         * @member {Boolean} hidden_=false
         */
        hidden_: false,
        /**
         * Used for hide and show and defines if the component
         * should use css visibility:'hidden' or vdom:removeDom
         * @member {String} hideMode_='removeDom'
         */
        hideMode_: 'removeDom',
        /**
         * The top level innerHTML of the component
         * @member {String|null} html_=null
         */
        html_: null,
        /**
         * Set to `true` to show a spinner centered in the component.
         * Set to a string to show a message next to a spinner centered in the component.
         * @member {Boolean|String} isLoading=false
         */
        isLoading_: false,
        /**
         * Internal flag which will get set to true while an update request (worker messages) is in progress
         * @member {Boolean} isVdomUpdating_=false
         * @protected
         */
        isVdomUpdating_: false,
        /**
         * Using the keys config will create an instance of Neo.util.KeyNavigation.
         * @see {@link Neo.util.KeyNavigation KeyNavigation}
         * @member {Object} keys_=null
         */
        keys_: null,
        /**
         * Gets used inside afterSetIsLoading() to define the CSS for the loading spinner icon
         * @member {String[]} loadingSpinnerCls_=['fa','fa-spinner','fa-spin']
         */
        loadingSpinnerCls_: ['fa', 'fa-spinner', 'fa-spin'],
        /**
         * Shortcut for style.maxHeight, defaults to px
         * @member {Number|String|null} maxHeight_=null
         */
        maxHeight_: null,
        /**
         * Shortcut for style.maxWidth, defaults to px
         * @member {Number|String|null} maxWidth_=null
         */
        maxWidth_: null,
        /**
         * Shortcut for style.minHeight, defaults to px
         * @member {Number|String|null} minHeight_=null
         */
        minHeight_: null,
        /**
         * Shortcut for style.minWidth, defaults to px
         * @member {Number|String|null} minWidth_=null
         */
        minWidth_: null,
        /**
         * Override specific stateProvider data properties.
         * This will merge the content.
         * @member {Object|null} modelData=null
         */
        modelData: null,
        /**
         * True in case the component is mounted to the DOM
         * @member {Boolean} mounted_=false
         * @protected
         */
        mounted_: false,
        /**
         * Internal flag which will get set to true in case an update call arrives while another update is running
         * @member {Boolean} needsVdomUpdate_=false
         * @protected
         */
        needsVdomUpdate_: false,
        /**
         * If the parentId does not match a neo component id, you can manually set this value for finding
         * view controllers or state providers.
         * Use case: manually dropping components into a vdom structure
         * @member {Neo.component.Base|null} parentComponent_=null
         * @protected
         */
        parentComponent_: null,
        /**
         * The parent component id or document.body
         * @member {String} parentId_='document.body'
         */
        parentId_: 'document.body',
        /**
         * Array of Plugin Modules and / or config objects
         * @member {Array|null} plugins_=null
         * @protected
         */
        plugins_: null,
        /**
         * Set a reference for accessing the component inside view controllers.
         * References will also get mapped into the vdom root (data-ref: value).
         * @member {String|null} reference_=null
         * @protected
         */
        reference_: null,
        /**
         * Make the view Responsive by adding alternative configs.
         * The definition happens via responsiveCfg
         * @member {Object} responsive=null
         * @protected
         */
        responsive_: null,
        /**
         * True in case the component is rendering the vnode
         * @member {Boolean} rendering_=false
         * @protected
         */
        rendering_: false,
        /**
         * Specify a role tag attribute for the vdom root.
         * See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles
         * @member {String|null} role_=null
         */
        role_: null,
        /**
         * Set this to true for style 'overflow:auto'.
         * Set this to 'x' or 'y' to add style 'overflow-x' or 'overflow-y' to 'auto'
         * Other than false this will add cls 'neo-scrollable'.
         * @member {Boolean|"x"|"y"} scrollable_=false
         */
        scrollable_: false,
        /**
         * Set this to true for bulk updates. Ensure to set it back to false afterwards.
         * Internally the value will get saved as a number to ensure that child methods won't stop the silent mode too early.
         * @member {Boolean} silentVdomUpdate_=false
         */
        silentVdomUpdate_: false,
        /**
         * Optionally add a state.Provider to share state data with child components
         * @member {Object|null} stateProvider_=null
         */
        stateProvider_: null,
        /**
         * Style attributes added to this vdom root. see: getVdomRoot()
         * @member {Object} style_=null
         */
        style_: null,
        /**
         * You can pass an used theme directly to any component,
         * to style specific component trees differently from your main view.
         * @member {String|null} theme_=null
         */
        theme_: null,
        /**
         * While it is recommended to define tags inside the vdom of classes,
         * this shortcut enables us to change the vdom root tag on instance level.
         * Use cases: switch a Toolbar to a "nav" tag, switch a SideNav to an "aside" tag.
         * @member {String|null} tag_=null
         */
        tag_: null,
        /**
         * Add tooltip config object or a string containing the display text
         * See tooltip/Base.mjs
         *
         * By default, a single, shared Tooltip instance is used for all widgets which request
         * a tooltip. It reconfigures itself from the widget's definition just before showing.
         *
         * If a widget needs its own instance for any reason, inslude the property `ownInstance : true`
         * in the tooltip config object.
         * @member {Object|String} tooltip_=null
         */
        tooltip_: null,
        /**
         * Add 'primary' and other attributes to make it an outstanding design
         * @member {String|null} ui_=null
         */
        ui_: null,
        /**
         * Defines the depth of the vdom tree for the next update cycle.
         * - The value 1 will only send the current vdom structure as it is
         * - The value of 2 will include the vdom of direct children
         * - The value of 3 will include the vdom of grandchildren
         * - The value of -1 will include the full tree of any depth
         * @member {Number} updateDepth_=1
         */
        updateDepth_: 1,
        /**
         * The component vnode tree. Available after the component got rendered.
         * @member {Object} vnode_=null
         * @protected
         */
        vnode_: null,
        /**
         * Shortcut for style.width, defaults to px
         * @member {Number|String|null} width_=null
         */
        width_: null,
        /**
         * The custom windowIs (timestamp) this component belongs to
         * @member {Number|null} windowId_=null
         */
        windowId_: null,
        /**
         * @member {String[]|null} wrapperCls_=null
         */
        wrapperCls_: null,
        /**
         * Top level style attributes. Useful in case getVdomRoot() does not point to the top level DOM node.
         * @member {Object|null} wrapperStyle_=null
         */
        wrapperStyle_: null,
        /**
         * The vdom markup for this component.
         * @member {Object} _vdom={}
         */
        _vdom: {}
    }

    /**
     * If an update() gets called while a parent is updating, we store the id & distance of the
     * requesting component inside the childUpdateCache of the parent, to get resolved once the update is done.
     * e.g. childUpdateCache = {'neo-grid-view-1': {distance: 1, resolve: fn}}
     * @member {Object} childUpdateCache={}
     */
    childUpdateCache = {}
    /**
     * Stores the updateDepth while an update is running to enable checks for parent update collisions
     * @member {Number|null} currentUpdateDepth=null
     */
    currentUpdateDepth = null
    /**
     * @member {Function[]} resolveUpdateCache=[]
     */
    resolveUpdateCache = []

    /**
     * Convenience shortcut to access the App this component belongs to
     * @returns {Neo.controller.Application|null}
     */
    get app() {
        return Neo.apps[this.appName] || null
    }

    /**
     * Returns true if this Component is fully visible, that is it is not hidden and has no hidden ancestors
     */
    get isVisible() {
        return this.mounted && !this.hidden && (!this.parent || this.parent.isVisible);
    }

    /**
     * Apply component based listeners
     * @member {Object} listeners={}
     */
    get listeners() {
        return this._listeners || {}
    }
    set listeners(value) {
        this._listeners = value
    }

    /**
     * Convenience method to access the parent component
     * @returns {Neo.component.Base|null}
     */
    get parent() {
        let me = this;

        return me.parentComponent || me.parentId === 'document.body' ? null : Neo.getComponent(me.parentId)
    }

    /**
     * True after the component render() method was called. Also fires the rendered event.
     * @member {Boolean} rendered=false
     * @protected
     */
    get rendered() {
        return this._rendered || false
    }
    set rendered(value) {
        let me = this;

        me._rendered = value;

        if (value === true) {
            me.fire('rendered', me.id)
        }
    }

    /**
     * The setter will handle vdom updates automatically
     * @member {Object} vdom=this._vdom
     */
    get vdom() {
        return this._vdom
    }
    set vdom(value) {
        this.afterSetVdom(value, value)
    }

    /**
     * Add a new cls to the vdomRoot
     * @param {String} value
     */
    addCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);
        this.cls = cls
    }

    /**
     * Convenience shortcut to add additional dom listeners
     * @param {Object|Object[]} value
     */
    addDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let domListeners = this.domListeners;

        domListeners.push(...value);

        this.domListeners = domListeners
    }

    /**
     * Either a string like 'color: red; background-color: blue;'
     * or an object containing style attributes
     * @param {String|Object} value
     * @returns {Object} all styles of this.el
     */
    addStyle(value) {
        if (typeof value === 'string') {
            value = _core_Util_mjs__WEBPACK_IMPORTED_MODULE_10__["default"].createStyleObject(value);
        }

        // todo: add a check if something has changed

        return this.style = Object.assign(this.style, value)
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {

    }

    /**
     * Triggered after the cls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetCls(value, oldValue) {
        oldValue = oldValue || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls;

        if (vdom !== vdomRoot) {
            // we are using a wrapper node
            vdomRoot.cls = [...value]
        } else {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(me.wrapperCls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldValue, value));
            vdom.cls = cls
        }

        if (me.isVdomUpdating || me.silentVdomUpdate) {
            me.needsVdomUpdate = true
        } else if (me.mounted && me.vnode) {
            me.updateCls(value, oldValue, vdomRoot.id)
        }
    }

    /**
     * Triggered after any config got changed
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     * @protected
     */
    afterSetConfig(key, value, oldValue) {
        let me = this;

        if (currentWorker.isUsingStateProviders && me[twoWayBindingSymbol] && oldValue !== undefined) {
            let binding = me.bind?.[key];

            if (binding?.twoWay) {
                this.getStateProvider()?.setData(binding.key, value)
            }
        }
    }

    /**
     * Triggered after the disabled config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisabled(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"][value ? 'add' : 'remove'](cls, 'neo-disabled');
        this.cls = cls
    }

    /**
     * Registers the domListeners inside the Neo.manager.DomEvent
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetDomListeners(value, oldValue) {
        let me = this;

        if (value?.[0] || oldValue?.[0]) {
            me.getController()?.parseDomListeners(me);

            _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].updateDomListeners(me, value, oldValue)
        }
    }

    /**
     * Triggered after the droppable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDroppable(value, oldValue) {
        let me = this;

        if (value && !me.dropZone) {
            __webpack_require__.e(/*! import() */ "src_draggable_DropZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DropZone.mjs */ "./src/draggable/DropZone.mjs")).then(module => {
                me.dropZone = Neo.create({
                    module  : module.default,
                    appName : me.appName,
                    owner   : me,
                    windowId: me.windowId,
                    ...me.dropZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the flex config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetFlex(value, oldValue) {
        if (!isNaN(value)) {
            value = `${value} ${value} 0%`
        }

        this.configuredFlex = value;
        this.changeVdomRootKey('flex', value)
    }

    /**
     * Triggered after the hasUnmountedVdomChanges config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHasUnmountedVdomChanges(value, oldValue) {
        if (value || (!value && oldValue)) {
            let parentIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParentIds(this),
                i         = 0,
                len       = parentIds.length,
                parent;

            for (; i < len; i++) {
                parent = Neo.getComponent(parentIds[i]);

                if (parent) {
                    parent._hasUnmountedVdomChanges = value // silent update
                }
            }
        }
    }

    /**
     * Triggered after the height config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetHeight(value, oldValue) {
        this.configuredHeight = addUnits(value);
        this.changeVdomRootKey('height', value)
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let me    = this,
            state = value ? 'hide' : 'show';

        if (value && oldValue === undefined && me.hideMode === 'removeDom') {
            me.vdom.removeDom = true
        } else if (value || oldValue !== undefined) {
            me[state]()
        }

        if (!value) {
            me.revertFocus();
        }

        me.fire(state, {id: me.id});
        me.fire('hiddenChange', {id: me.id, oldValue, value})
    }

    /**
     * Triggered after the html config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetHtml(value, oldValue) {
        this.changeVdomRootKey('html', value)
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);
        this.changeVdomRootKey('id', value);

        oldValue && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(oldValue);
        value    && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].register(this)
    }

    /**
     * Triggered after the isLoading config got changed
     * @param {Boolean|String} value
     * @param {Boolean|String} oldValue
     * @protected
     */
    afterSetIsLoading(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me          = this,
                {cls, vdom} = me,
                maskIndex;

            if (oldValue !== undefined && vdom.cn) {
                maskIndex = vdom.cn.findLastIndex(c => c.cls?.includes('neo-load-mask'));

                // Remove the load mask
                if (maskIndex !== -1) {
                    vdom.cn.splice(maskIndex, 1)
                }
            }

            if (value) {
                if (!vdom.cn) {
                    vdom.cn = []
                }

                vdom.cn.push(me.createLoadingMask(value))
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].toggle(cls, 'neo-masked', value);
            me.set({cls, vdom})
        }
    }

    /**
     * Triggered after the isVdomUpdating config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetIsVdomUpdating(value, oldValue) {
        this.currentUpdateDepth = value ? this.updateDepth : null
    }

    /**
     * Triggered after the maxHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxHeight(value, oldValue) {
        this.configuredMaxHeight = addUnits(value);
        this.changeVdomRootKey('maxHeight', value)
    }

    /**
     * Triggered after the maxWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxWidth(value, oldValue) {
        this.configuredMaxWidth = addUnits(value);
        this.changeVdomRootKey('maxWidth', value)
    }

    /**
     * Triggered after the minHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinHeight(value, oldValue) {
        this.configuredMinHeight = addUnits(value);
        this.changeVdomRootKey('minHeight', value)
    }

    /**
     * Triggered after the minWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinWidth(value, oldValue) {
        this.configuredMinWidth = addUnits(value);
        this.changeVdomRootKey('minWidth', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            let me             = this,
                {id, windowId} = me;

            if (value) {
                me.hasBeenMounted = true;

                if (me.domListeners?.length > 0) {
                    // todo: the main thread reply of mount arrives after pushing the task into the queue which does not ensure the dom is mounted
                    me.timeout(150).then(() => {
                        _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].mountDomListeners(me)
                    })
                }

                me.doResolveUpdateCache();

                if (me.floating) {
                    me.alignTo();

                    // Focus will be pushed into the first input field or other focusable item
                    me.focus(id, true)
                }

                me.fire('mounted', me.id)
            } else {
                me.revertFocus()
            }
        }
    }

    /**
     * Triggered after the reference config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetReference(value, oldValue) {
        value && this.changeVdomRootKey('data-ref', value)
    }

    /**
     * Triggered after the responsive config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    async afterSetResponsive(value, oldValue) {
        if (value && !this.getPlugin('responsive')) {
            let me      = this,
                module  = await __webpack_require__.e(/*! import() */ "src_plugin_Responsive_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../../src/plugin/Responsive.mjs */ "./src/plugin/Responsive.mjs")),
                plugins = me.plugins || [];

            plugins.push({
                module : module.default,
                appName: me.appName,
                value
            });

            me.plugins = plugins
        }
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.changeVdomRootKey('role', value)
    }

    /**
     * Triggered after the scrollable config got changed
     * @param {String|Boolean} value
     * @param {String|Boolean|null} oldValue
     * @protected
     */
    afterSetScrollable(value, oldValue) {
        if (oldValue === undefined && !value) {
            return
        }

        let me = this;

        if (oldValue) {
            let oldOverflowKey = 'overflow';

            if (!Neo.isBoolean(oldValue)) {
                oldOverflowKey += Neo.capitalize(oldValue)
            }

            me.removeStyle([oldOverflowKey])
        }

        if (!Neo.isEmpty(value)) {
            let overflowKey = 'overflow';

            if (value && !Neo.isBoolean(value)) {
                overflowKey += Neo.capitalize(value)
            }

            if (value) {
                me.addStyle(overflowKey + ':auto');
                me.addCls('neo-scrollable')
            } else {
                me.removeCls('neo-scrollable')
            }
        }
    }

    /**
     * Triggered after the style config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle(value, oldValue)
        }
    }

    /**
     * Triggered after the tag config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTag(value, oldValue) {
        value && this.changeVdomRootKey('tag', value)
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me          = this,
                {cls}       = me,
                needsUpdate = false;

            if (oldValue && cls.includes(oldValue)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, oldValue);
                needsUpdate = true
            }

            // We do not need to add a DOM based CSS selector, in case the theme is already inherited
            if (value !== me.parent?.theme) {
                value && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);
                needsUpdate = true
            }

            if (needsUpdate) {
                me.cls = cls
            }
        }
    }

    /**
     * Triggered after the tooltip config got changed
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @protected
     */
    afterSetTooltip(value, oldValue) {
        oldValue?.destroy?.();

        if (value) {
            if (Neo.ns('Neo.tooltip.Base')) {
                this.createTooltip(value)
            } else {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_container_Base_mjs"), __webpack_require__.e("vendors-src_tooltip_Base_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../tooltip/Base.mjs */ "./src/tooltip/Base.mjs")).then(() => {
                    this.createTooltip(value)
                })
            }
        }
    }

    /**
     * For styling purposes only.
     * To define button styles or component styles,
     * this will add a css class: neo-ntype-value
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetUi(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, `neo-${me.ntype}-${oldValue}`);

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, `neo-${me.ntype}-${value}`)
        }

        me.cls = cls
    }

    /**
     * Triggered after the vdom pseudo-config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVdom(value, oldValue) {
        this.updateVdom(value)
    }

    /**
     * Triggered after the vnode config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVnode(value, oldValue) {
        oldValue !== undefined && this.syncVnodeTree()
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        this.configuredWidth = addUnits(value);
        this.changeVdomRootKey('width', value)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        let me         = this,
            controller = me.controller;

        if (value) {
            currentWorker.insertThemeFiles(value, me.__proto__);

            if (controller) {
                controller.windowId = value
            }
        }

        // If a component gets moved into a different window, an update cycle might still be running.
        // Since the update might no longer get mapped, we want to re-enable this instance for future updates.
        if (oldValue) {
            me.isVdomUpdating = false
        }
    }

    /**
     * Triggered after the wrapperCls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetWrapperCls(value, oldValue) {
        oldValue = oldValue || [];
        value    = value    || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls      = me.vdom?.cls || [];

        if (vdom === vdomRoot) {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(cls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldValue, value));
            vdom.cls = cls
        } else {
            // we are not using a wrapper => cls & wrapperCls share the same node
            value = value ? value : [];

            oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, oldValue);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);

            if (vdom) {
                vdom.cls = cls
            }
        }

        if (me.isVdomUpdating || me.silentVdomUpdate) {
            me.needsVdomUpdate = true
        } else if (me.mounted) {
            me.updateCls(value, oldValue)
        }
    }

    /**
     * Triggered after the wrapperStyle config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetWrapperStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            let me   = this,
                vdom = me.vdom;

            if (!vdom.id) {
                vdom.style = value;
                me.update()
            } else {
                me.updateStyle(value, oldValue, vdom.id)
            }
        }
    }

    /**
     * Aligns the top level node inside the main thread
     * @param {Object} spec={}
     * @returns {Promise<void>}
     */
    async alignTo(spec={}) {
        const
            me    = this,
            align = {
                ...me.align,
                ...spec,
                id                 : me.id,
                configuredFlex     : me.configuredFlex,
                configuredWidth    : me.configuredWidth,
                configuredHeight   : me.configuredHeight,
                configuredMinWidth : me.configuredMinWidth,
                configuredMinHeight: me.configuredMinHeight,
                configuredMaxWidth : me.configuredMaxWidth,
                configuredMaxHeight: me.configuredMaxHeight
            };

        if (align.target) {
            await Neo.main.DomAccess.align(align)
        }
    }

    /**
     * Triggered when accessing the cls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the data config
     * Convenience shortcut which is expensive to use, since it will generate a merged parent state providers data map.
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getStateProvider().getHierarchyData()
    }

    /**
     * Triggered when accessing the style config
     * @param {Object} value
     * @protected
     */
    beforeGetStyle(value) {
        return {...value}
    }

    /**
     * Triggered when accessing the wrapperCls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetWrapperCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the wrapperStyle config
     * @param {Object} value
     * @protected
     */
    beforeGetWrapperStyle(value) {
        return {...Object.assign(this.vdom.style || {}, value)}
    }

    /**
     * Triggered before the align config gets changed.
     * @param {Object|String} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        let me = this;

        // Just a simple 't-b'
        if (typeof value === 'string') {
            value = {
                edgeAlign: value
            }
        }

        // merge the incoming alignment specification into the configured default
        return Neo.merge({}, value, me.constructor.config.align)
    }

    /**
     * Triggered before the cls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(value || [], this.baseCls, this.getBaseClass());
    }

    /**
     * Triggered before the controller config gets changed.
     * Creates a controller.Component instance if needed.
     * @param {Neo.controller.Component|Object} value
     * @param {Neo.controller.Component|null} oldValue
     * @returns {Neo.controller.Component}
     * @protected
     */
    beforeSetController(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, null, {
                component: this,
                windowId : this.windowId
            })
        }

        return value
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Triggered before the hideMode config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetHideMode(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'hideMode')
    }

    /**
     * Triggered before the keys config gets changed.
     * Creates a KeyNavigation instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.util.KeyNavigation|null}
     * @protected
     */
    beforeSetKeys(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], {
                keyDownEventBubble: true,
                keys              : value
            })
        }

        return value
    }

    /**
     * Triggered before the stateProvider config gets changed.
     * Creates a state.Provider instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.state.Provider}
     * @protected
     */
    beforeSetStateProvider(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me            = this,
                defaultValues = {component: me};

            if (me.modelData) {
                defaultValues.data = me.modelData
            }

            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, 'Neo.state.Provider', defaultValues)
        }

        return null
    }

    /**
     * Triggered before the plugins config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @returns {Neo.plugin.Base[]}
     * @protected
     */
    beforeSetPlugins(value, oldValue) {
        if (Array.isArray(value)) {
            value.forEach((item, index) => {
                value[index] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(item, null, {
                    owner: this
                })
            })
        }

        return value
    }

    /**
     * Triggered before the silentVdomUpdate config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetSilentVdomUpdate(value, oldValue) {
        if (value === true) {
            return Neo.isNumber(oldValue) ? (oldValue + 1) : 1
        }

        return (Neo.isNumber(oldValue) && oldValue > 0) ? (oldValue - 1) : 0
    }

    /**
     * Triggered before the updateDepth config gets changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetUpdateDepth(value, oldValue) {
        if (oldValue === undefined) {
            return value
        }

        return oldValue === -1 || value === -1 ? -1 : Math.max(value, oldValue)
    }

    /**
     * Changes the value of a vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     */
    changeVdomRootKey(key, value) {
        let me   = this,
            root = me.getVdomRoot();

        if (value) {
            root[key] = value
        } else {
            delete root[key]
        }

        me.update()
    }

    /**
     * Override this method in case you need different mask markups.
     * The removal logic relies on the top level node having the cls 'neo-load-mask'
     * @param {Boolean|String} loadingMessage
     * @returns {Object} vdom
     */
    createLoadingMask(loadingMessage) {
        return {
            cls: ['neo-load-mask'],
            cn : [{
                cls: ['neo-load-mask-body'],
                cn : [{
                    cls: this.loadingSpinnerCls
                }, {
                    cls      : ['neo-loading-message'],
                    html     : loadingMessage,
                    removeDom: !Neo.isString(loadingMessage)
                }]
            }]
        }
    }

    /**
     * Creates the tooltip instances
     * @param {Object|String} value
     * @protected
     */
    createTooltip(value) {
        if (typeof value === 'string') {
            value = {
                text: value
            }
        }

        let me = this;

        if (value.ownInstance) {
            me._tooltip = Neo.create('Neo.tooltip.Base', {
                ...value,
                appName    : me.appName,
                componentId: me.id,
                windowId   : me.windowId
            })
        } else {
            me._tooltip = value;
            Neo.tooltip.Base.createSingleton(me.app);
            me.addCls('neo-uses-shared-tooltip');
            me.update()
        }
    }

    /**
     * Convenience shortcut to create a component reference
     * @returns {Object}
     */
    createVdomReference() {
        let me        = this,
            reference = {componentId: me.id},
            vdomId    = me.vdom.id;

        if (vdomId && me.id !== vdomId) {
            reference.id = vdomId
        }

        return reference
    }

    /**
     * Unregister this instance from the ComponentManager
     * @param {Boolean} updateParentVdom=false true to remove the component from the parent vdom => real dom
     * @param {Boolean} silent=false true to update the vdom silently (useful for destroying multiple child items in a row)
     * todo: unregister events
     */
    destroy(updateParentVdom=false, silent=false) {
        let me                  = this,
            {parent, parentId}  = me,
            parentStateProvider = parent?.getStateProvider(),
            parentVdom;

        me.revertFocus();

        me.domListeners = [];

        me.controller = null; // triggers destroy()

        me.reference && me.getController()?.removeReference(me); // remove own reference from parent controllers

        me.stateProvider = null; // triggers destroy()

        me.bind && parentStateProvider?.removeBindings(me.id);

        me.plugins?.forEach(plugin => {
            plugin.destroy()
        });

        if (updateParentVdom && parentId) {
            if (parentId === 'document.body') {
                Neo.applyDeltas(me.appName, {action: 'removeNode', id: me.vdom.id})
            } else {
                parentVdom = parent.vdom;

                _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].removeVdomChild(parentVdom, me.vdom.id);
                parent[silent ? '_vdom' : 'vdom'] = parentVdom
            }
        }

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(me);

        super.destroy();

        // We do want to prevent delayed calls after a component instance got destroyed.
        me.onFocusLeave = Neo.emptyFn;
        me.unmount      = Neo.emptyFn
    }

    /**
     * Triggers all stored resolve() callbacks
     */
    doResolveUpdateCache() {
        let me = this;

        if (me.resolveUpdateCache) {
            me.resolveUpdateCache.forEach(item => item());
            me.resolveUpdateCache = []
        }
    }

    /**
     * Convenience shortcut for Neo.manager.Component.down
     * @param {Object|String} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    down(config, returnFirstMatch=true) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].down(this, config, returnFirstMatch)
    }

    /**
     * Internal method to send update requests to the vdom worker
     * @param {Object} vdom
     * @param {Neo.vdom.VNode} vnode
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @private
     */
    #executeVdomUpdate(vdom, vnode, resolve, reject) {
        let me   = this,
            opts = {},
            deltas;

        if (currentWorker.isSharedWorker) {
            opts.appName  = me.appName;
            opts.windowId = me.windowId
        }

        me.isVdomUpdating = true;

        // we can not set the config directly => it could already be false,
        // and we still want to pass it further into subtrees
        me._needsVdomUpdate = false;
        me.afterSetNeedsVdomUpdate?.(false, true);

        opts.vdom  = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(vdom, me.updateDepth);
        opts.vnode = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVnodeTree(vnode, me.updateDepth);

        // Reset the updateDepth to the default value for the next update cycle
        me._updateDepth = me.constructor.config.updateDepth;

        Neo.vdom.Helper.update(opts).catch(err => {
            me.isVdomUpdating = false;
            console.log('Error attempting to update component dom', err, me);

            reject?.()
        }).then(data => {
            me.isVdomUpdating = false;

            // checking if the component got destroyed before the update cycle is done
            if (me.id) {
                me.vnode = data.vnode;

                deltas = data.deltas;

                if (!Neo.config.useVdomWorker && deltas.length > 0) {
                    Neo.applyDeltas(me.appName, deltas).then(() => {
                        me.resolveVdomUpdate(resolve)
                    })
                } else {
                    me.resolveVdomUpdate(resolve)
                }
            }
        })
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} id=this.id
     * @param {Boolean} children=false
     */
    focus(id=this.id, children=false) {
        Neo.main.DomAccess.focus({children, id, windowId: this.windowId})
    }

    /**
     * Override this method to add dynamic values into this.cls
     * @returns {String[]}
     */
    getBaseClass() {
        const result = [];

        if (this.floating) {
            result.push('neo-floating')
        }

        return result
    }

    /**
     * Find an instance stored inside a config via optionally passing a ntype.
     * Returns this[configName] or the closest parent component with a match.
     * Used by getController() & getStateProvider()
     * @param {String} configName
     * @param {String} [ntype]
     * @returns {Neo.core.Base|null}
     */
    getConfigInstanceByNtype(configName, ntype) {
        let me                = this,
            config            = me[configName],
            {parentComponent} = me;

        if (config && (!ntype || ntype === config.ntype)) {
            return config
        }

        if (!parentComponent && me.parentId) {
            parentComponent = me.parent || Neo.get(me.parentId);
        }

        if (parentComponent) {
            return parentComponent.getConfigInstanceByNtype(configName, ntype)
        }

        return null
    }

    /**
     * Returns this.controller or the closest parent controller
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        let me = this,
            controller;

        if (!ntype) {
            controller = me[closestController];

            if (controller) {
                return controller
            }
        }

        controller = me.getConfigInstanceByNtype('controller', ntype);

        if (!ntype) {
            me[closestController] = controller;
        }

        return controller
    }

    /**
     * Convenience shortcut
     * @param {String[]|String} id=this.id
     * @param {String} appName=this.appName
     * @returns {Promise<Neo.util.Rectangle>}
     */
    async getDomRect(id=this.id, appName=this.appName) {
        let result = await Neo.main.DomAccess.getBoundingClientRect({appName, id, windowId: this.windowId});

        if (Array.isArray(result)) {
            return result.map(rect => _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].clone(rect))
        }

        return _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].clone(result)
    }

    /**
     * Honors different item roots for mount / render OPs
     * @returns {String}
     */
    getMountedParentId() {
        let parentId  = this.parentId,
            parent    = Neo.getComponent(parentId),
            itemsRoot = parent?.getVdomItemsRoot?.();

        return itemsRoot ? itemsRoot.id : parentId
    }

    /**
     * Calculate the real parentIndex inside the DOM
     * @returns {Number|undefined}
     */
    getMountedParentIndex() {
        let parent = this.parent,
            items  = parent?.items || [],
            i      = 0,
            index  = 0,
            len    = items.length,
            item;

        for (; i < len; i++) {
            item = items[i];

            if (item === this) {
                return index
            }

            if (!item.hidden && item.hideMode === 'removeDom') {
                index++
            }
        }
    }

    /**
     * Get the parent components as an array
     * @returns {Neo.component.Base[]}
     */
    getParents() {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(this)
    }

    /**
     * @param {Object|String} opts
     * @returns {Neo.plugin.Base|null}
     */
    getPlugin(opts) {
        if (Neo.isString(opts)) {
            if (!opts.startsWith('plugin-')) {
                opts = 'plugin-' + opts
            }

            opts = {ntype: opts}
        }

        let me = this,
            hasMatch;

        for (const plugin of me.plugins || []) {
            hasMatch = true;

            for (const key in opts) {
                if (plugin[key] !== opts[key]) {
                    hasMatch = false;
                    break
                }
            }

            if (hasMatch) {
                return plugin
            }
        }

        return null
    }

    /**
     * convenience shortcut
     * @param {String} value
     * @returns {Neo.component.Base|null}
     */
    getReference(value) {
        return this.down({reference: value})
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * Returns this.stateProvider or the closest parent stateProvider
     * @param {String} [ntype]
     * @returns {Neo.state.Provider|null}
     */
    getStateProvider(ntype) {
        if (!currentWorker.isUsingStateProviders) {
            return null
        }

        let me = this,
            provider;

        if (!ntype) {
            provider = me[closestProvider];

            if (provider) {
                return provider
            }
        }

        provider = me.getConfigInstanceByNtype('stateProvider', ntype);

        if (!ntype) {
            me[closestProvider] = provider
        }

        return provider
    }

    /**
     * Walks up the vdom tree and returns the closest theme found
     * @returns {String}
     */
    getTheme() {
        let me         = this,
            themeMatch = 'neo-theme-',
            mainView, parentNodes;

        for (const item of me.cls || []) {
            if (item.startsWith(themeMatch)) {
                return item
            }
        }

        mainView = me.app?.mainView;

        if (mainView) {
            parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].getParentNodes(mainView.vdom, me.id);

            for (const node of parentNodes || []) {
                for (const item of node.cls || []) {
                    if (item.startsWith(themeMatch)) {
                        return item
                    }
                }
            }
        }

        return Neo.config.themes?.[0]
    }

    /**
     * Search a vdom child node by id for a given vdom tree
     * @param {String} id
     * @param {Object} vdom=this.vdom
     * @returns {Object}
     */
    getVdomChild(id, vdom=this.vdom) {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].find(vdom, id)?.vdom
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode
    }

    /**
     * Checks if a given updateDepth & distance would result in an update collision
     * @param {Number} updateDepth
     * @param {Number} distance
     * @returns {Boolean}
     */
    hasUpdateCollision(updateDepth, distance) {
        return updateDepth === -1 ? true : distance < updateDepth
    }

    /**
     * Hide the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     * If hideMode === 'removeDom' you can pass a timeout for custom css class hiding.
     * @param {Number} timeout
     */
    hide(timeout) {
        let me = this;

        if (me.hideMode !== 'visibility') {
            let removeFn = function () {
                if (me.parentId !== 'document.body') {
                    me.vdom.removeDom = true;
                    me.parent.updateDepth = 2;
                    me.parent.update()
                } else {
                    me.unmount()
                }
            }

            if (timeout) {
                me.timeout(timeout).then(removeFn)
            } else {
                removeFn()
            }
        } else {
            let style = me.style;
            style.visibility = 'hidden';
            me.style = style;
        }

        me._hidden = true
    }

    /**
     *
     */
    init() {
        this.autoRender && this.render()
    }

    /**
     * We are using this method as a ctor hook here to add the initial state.Provider & controller.Component parsing
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     */
    initConfig(config, preventOriginalConfig) {
        super.initConfig(config, preventOriginalConfig);

        let me = this;

        me.getController()   ?.parseConfig(me);
        me.getStateProvider()?.parseConfig(me)
    }

    /**
     * Checks for vdom updates inside the parent chain and if found.
     * Registers the component for a vdom update once done.
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] Gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean}
     */
    isParentUpdating(parentId=this.parentId, resolve, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                if (parent.isVdomUpdating) {
                    if (me.hasUpdateCollision(parent.currentUpdateDepth, distance)) {
                        if (Neo.config.logVdomUpdateCollisions) {
                            console.warn('vdom parent update conflict with:', parent, 'for:', me)
                        }

                        parent.childUpdateCache[me.id] = {distance, resolve};

                        // Adding the resolve fn to its own cache, since the parent will trigger
                        // a new update() directly on this cmp
                        resolve && me.resolveUpdateCache.push(resolve);
                        return true
                    }

                    // If an update is running and does not have a collision, we do not need to check further parents
                    return false
                }

                return me.isParentUpdating(parent.parentId, resolve, distance+1)
            }
        }

        return false
    }

    /**
     * @param {Number|String} value
     * @returns {Promise<number>}
     */
    async measure(value) {
        if (value != null) {
            if (value.endsWith('px')) {
                value = parseFloat(value)
            } else if (lengthRE.test(value)) {
                let {id, windowId} = this;
                value = await Neo.main.DomAccess.measure({id, value, windowId})
            } else if (!isNaN(value)) {
                value = parseFloat(value)
            }
        }

        return value
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let me     = this,
            config = super.mergeConfig(...args),

            // it should be possible to set custom configs for the vdom on instance level,
            // however there will be already added attributes (e.g. id), so a merge seems to be the best strategy.
            vdom = {...me._vdom || {}, ...config.vdom || {}};

        // avoid any interference on prototype level
        // does not clone existing Neo instances
        me._vdom = Neo.clone(vdom, true, true);

        if (config.style) {
            // If we are passed an object, merge it with the class's own style
            me.style = Neo.typeOf(config.style) === 'Object' ? {...config.style, ...me.constructor.config.style} : config.style
        }

        me.wrapperStyle = Neo.clone(config.wrapperStyle, false);

        delete config.style;
        delete config._vdom;
        delete config.vdom;
        delete config.wrapperStyle;

        return config
    }

    /**
     * Can get called after the component got rendered. See the autoMount config as well.
     */
    async mount() {
        let me = this,
            child, childIds;

        if (!me.vnode) {
            throw new Error('Component vnode must be generated before mounting, use Component.render()');
        }

        // In case the component was already mounted, got unmounted and received vdom changes afterwards,
        // a new render() call is mandatory since delta updates could not get applied.
        // We need to clear the hasUnmountedVdomChanges state for all child components
        if (me.hasUnmountedVdomChanges) {
            // todo: the hasUnmountedVdomChanges flag changes should happen on render
            me.hasUnmountedVdomChanges = false;

            childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(me.vnode);

            childIds.forEach(id => {
                child = Neo.getComponent(id);

                if (child) {
                    child._hasUnmountedVdomChanges = false; // silent update
                }
            });
            // end todo

            me.render(true)
        } else {
            await currentWorker.promiseMessage('main', {
                action     : 'mountDom',
                appName    : me.appName,
                id         : me.id,
                html       : me.vnode.outerHTML,
                parentId   : me.getMountedParentId(),
                parentIndex: me.getMountedParentIndex()
            });

            delete me.vdom.removeDom;

            await me.timeout(30);

            me.mounted = true
        }
    }

    /**
     * Checks the needsVdomUpdate config inside the parent tree
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean}
     */
    needsParentUpdate(parentId=this.parentId, resolve, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                // We are checking for parent.updateDepth, since we care about the depth of the next update cycle
                if (parent.needsVdomUpdate && me.hasUpdateCollision(parent.updateDepth, distance)) {
                    parent.resolveUpdateCache.push(...me.resolveUpdateCache);
                    resolve && parent.resolveUpdateCache.push(resolve);
                    me.resolveUpdateCache = [];
                    return true
                }

                return me.needsParentUpdate(parent.parentId, resolve, distance+1)
            }
        }

        return false
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.keys?.register(this)
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        // If we are hidden, or unmounted while we still contain focus, we have to revert
        // focus to where it came from if possible
        this.focusEnterData = data;
    }

    /**
     * @param {Object} data
     */
    onFocusLeave(data) {
        this.focusEnterData = null;
    }

    /**
     * Triggered by manager.Focus
     * @name onFocusEnter
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusLeave
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusMove
     * @function
     * @param {Object} opts
     * @param {Array}  opts.newPath dom element ids upwards
     * @param {Array}  opts.oldPath dom element ids upwards
     */

    /**
     * Gets called from the render() promise success handler
     * @param {Object} data
     * @param {Boolean} autoMount Mount the DOM after the vnode got created
     * @protected
     */
    onRender(data, autoMount) {
        let me    = this,
            {app} = me;

        me.rendering = false;

        // if app is a check to see if the Component got destroyed while rendering => before onRender got triggered
        if (app) {
            if (!app.rendered) {
                app.rendering = false;
                app.rendered = true;
                app.fire('render')
            }

            me.vnode = data;

            let childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(data),
                i        = 0,
                len      = childIds.length,
                child;

            for (; i < len; i++) {
                child = Neo.getComponent(childIds[i]);

                if (child) {
                    child.rendered = true
                }
            }

            me._rendered = true; // silent update
            me.fire('rendered', me.id);

            // console.log('rendered: ' + me.appName + ' ' + me.id, me);

            if (autoMount) {
                me.mounted = true;

                if (!app.mounted) {
                    app.mounted = true;
                    app.fire('mounted')
                }
            }
        }
    }

    /**
     * Promise based vdom update
     * @param {Object} vdom=this.vdom
     * @param {Neo.vdom.VNode} vnode= this.vnode
     * @returns {Promise<any>}
     */
    promiseUpdate(vdom=this.vdom, vnode=this.vnode) {
        return new Promise((resolve, reject) => {
            this.updateVdom(vdom, vnode, resolve, reject)
        })
    }

    /**
     * Remove a cls from the vdomRoot
     * @param {String} value
     */
    removeCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, value);
        this.cls = cls
    }

    /**
     * @param {Array|Object} value
     */
    removeDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value];
        }

        let me             = this,
            {domListeners} = me,
            i, len;

        value.forEach(item => {
            i = 0;
            len = domListeners.length;

            for (; i < len; i++) {
                if (Neo.isEqual(item, domListeners[i])) {
                    domListeners.splice(i, 1);
                    break
                }
            }
        });

        me.domListeners = domListeners
    }

    /**
     * Either a string like 'color' or an array containing style attributes to remove
     * @param {String|Array} value camelCase only
     * @returns {Object} all styles of this.el
     */
    removeStyle(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let {style}  = this,
            doUpdate = false;

        Object.keys(style).forEach(key => {
            if (value.indexOf(key) > -1) {
                delete style[key];
                doUpdate = true
            }
        });

        if (doUpdate) {
            this.style = style
        }

        return style
    }

    /**
     * Creates the vnode tree for this component and mounts the component in case
     * - you pass true for the mount param
     * - or the autoMount config is set to true
     * @param {Boolean} [mount] Mount the DOM after the vnode got created
     */
    async render(mount) {
        let me              = this,
            autoMount       = mount || me.autoMount,
            {app}           = me,
            {useVdomWorker} = Neo.config;

        // Verify that the critical rendering path => CSS files for the new tree is in place
        if (currentWorker.countLoadingThemeFiles !== 0) {
            currentWorker.on('themeFilesLoaded', function() {
                me.render(mount)
            }, me, {once: true});

            return
        }

        me.rendering = true;

        if (!app.rendered) {
            app.rendering = true
        }

        if (me.vdom) {
            me.isVdomUpdating = true;

            delete me.vdom.removeDom;

            me._needsVdomUpdate = false;
            me.afterSetNeedsVdomUpdate?.(false, true);

            const data = await Neo.vdom.Helper.create({
                appName    : me.appName,
                autoMount,
                parentId   : autoMount ? me.getMountedParentId()    : undefined,
                parentIndex: autoMount ? me.getMountedParentIndex() : undefined,
                windowId   : me.windowId,
                ..._manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(me.vdom)
            });

            me.onRender(data, useVdomWorker ? autoMount : false);
            me.isVdomUpdating = false;

            autoMount && !useVdomWorker && me.mount();

            me.resolveVdomUpdate()
        }
    }

    /**
     * Internal helper fn to resolve the Promise for updateVdom()
     * @param {Function|undefined} resolve
     * @protected
     */
    resolveVdomUpdate(resolve) {
        let me                  = this,
            hasChildUpdateCache = !Neo.isEmpty(me.childUpdateCache),
            component;

        me.doResolveUpdateCache();

        resolve?.();

        if (me.needsVdomUpdate) {
            if (hasChildUpdateCache) {
                Object.entries(me.childUpdateCache).forEach(([key, value]) => {
                    component = Neo.getComponent(key);

                    // The component might already got destroyed
                    if (component) {
                        // Pass callbacks to the resolver cache => getting executed once the following update is done
                        value.resolve && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(me.resolveUpdateCache, value.resolve);

                        // Adjust the updateDepth to include the depth of all merged child updates
                        if (me.updateDepth !== -1) {
                            if (component.updateDepth === -1) {
                                me.updateDepth = -1
                            } else {
                                // Since updateDepth is 1-based, we need to subtract 1 level
                                me.updateDepth = me.updateDepth + value.distance + component.updateDepth - 1
                            }
                        }
                    }
                });

                me.childUpdateCache = {}
            }

            me.update()
        } else if (hasChildUpdateCache) {
            Object.keys(me.childUpdateCache).forEach(key => {
                Neo.getComponent(key)?.update()
            });

            me.childUpdateCache = {}
        }
    }

    /**
     *
     */
    revertFocus() {
        let relatedTarget = this.focusEnterData?.relatedTarget;

        if (this.containsFocus && relatedTarget) {
            Neo.getComponent(relatedTarget.id)?.focus()
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} [silent=false]
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        let me             = this,
            needsRendering = values.hidden === false && values.hidden !== me.hidden;

        me.silentVdomUpdate = true;

        super.set(values);

        me.silentVdomUpdate = false;

        if (silent || !me.needsVdomUpdate) {
            return Promise.resolve()
        } else {
            if (needsRendering) {
                me.show();
                return Promise.resolve()
            }

            return me.promiseUpdate()
        }
    }

    /**
     * Convenience shortcut calling set() with the silent flag
     * @param {Object} values={}
     */
    setSilent(values = {}) {
        return this.set(values, true)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }

    /**
     * Show the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     */
    show() {
        let me = this;

        if (me.hideMode !== 'visibility') {
            delete me.vdom.removeDom;

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.parentId !== 'document.body') {
                me.parent.updateDepth = 2;
                me.parent.update()
            } else {
                !me.mounted && me.render(true)
            }
        } else {
            let style = me.style;
            delete style.visibility;
            me.style = style
        }

        me._hidden = false
    }

    /**
     * Placeholder method for util.VDom.syncVdomIds to allow overriding (disabling) it
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     * @param {Object} [vdom=this.vdom]
     * @param {Boolean} force=false
     */
    syncVdomIds(vnode=this.vnode, vdom=this.vdom, force=false) {
        _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].syncVdomIds(vnode, vdom, force)
    }

    /**
     * In case a component receives a new vnode, we want to do:
     * - sync the vdom ids
     * - setting rendered to true for child components
     * - updating the parent component to ensure that the vnode tree stays persistent
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     */
    syncVnodeTree(vnode=this.vnode) {
        let me              = this,
            childComponents = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildren(me),
            debug           = false,
            map             = {},
            childVnode, start;

        if (debug) {
            start = performance.now()
        }

        me.syncVdomIds();

        if (vnode && me.id !== vnode.id) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerWrapperNode(vnode.id, me)
        }

        // we need one separate iteration first to ensure all wrapper nodes get registered
        childComponents.forEach(component => {
            childVnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].find(me.vnode, component.vdom.id)?.vnode;

            if (childVnode) {
                map[component.id] = childVnode;

                if (component.id !== childVnode.id) {
                    _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerWrapperNode(childVnode.id, component)
                }
            }
        });

        // delegate the latest node updates to all possible child components found inside the vnode tree
        childComponents.forEach(component => {
            childVnode = map[component.id];

            if (childVnode) {
                // silent update
                component._vnode = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addVnodeComponentReferences(childVnode, component.id);

                if (!component.rendered) {
                    component._rendered = true;
                    component.fire('rendered', component.id)
                }

                component.mounted = true
            } else {
                console.warn('syncVnodeTree: Could not replace the child vnode for', component.id)
            }
        });

        // silent update
        me._vnode = vnode ? _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addVnodeComponentReferences(vnode, me.id) : null;

        debug && console.log('syncVnodeTree', me.id, performance.now() - start)
    }

    /**
     * Toggle a cls inside the vdomRoot of the component
     * @param {String} value
     * @param {Boolean} [add] Use this param to enforce an add() or remove() operation.
     */
    toggleCls(value, add) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].toggle(cls, value, add);
        this.cls = cls
    }

    /**
     * Removes the component DOM
     */
    unmount() {
        let me = this;

        me.vdom.removeDom = true;

        me._hidden = true; // silent update
        me.mounted = false;

        Neo.applyDeltas(me.appName, {action: 'removeNode', id: me.vdom.id})
    }

    /**
     * Convenience shortcut for Neo.manager.Component.up
     * @param {Object|String} config
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    up(config) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].up(this.id, config)
    }

    /**
     *
     */
    update() {
        this.afterSetVdom(this.vdom, null)
    }

    /**
     * Delta updates for the cls config. Gets called after the cls config gets changed in case the component is mounted.
     * @param {String[]} cls
     * @param {String[]} oldCls
     * @param {String} id=this.id
     * @protected
     */
    updateCls(cls, oldCls, id=this.id) {
        let me          = this,
            {vnode}     = me,
            vnodeTarget = vnode && _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].find(me.vnode, {id})?.vnode;

        if (vnode && !Neo.isEqual(cls, oldCls)) {
            if (vnodeTarget) {
                vnodeTarget.className = cls; // keep the vnode in sync
                me.vnode = vnode;
            }

            Neo.applyDeltas(me.appName, {
                id,
                cls: {
                    add   : _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(cls, oldCls),
                    remove: _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldCls, cls)
                }
            })
        }
    }

    /**
     * Creates the style deltas for newValue & oldValue and applies them directly to the DOM.
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @param {String} [id=this.id]
     * @protected
     */
    updateStyle(value, oldValue, id=this.id) {
        let me    = this,
            delta = _util_Style_mjs__WEBPACK_IMPORTED_MODULE_9__["default"].compareStyles(value, oldValue),
            opts, vdom, vnode, vnodeStyle;

        if (delta) {
            vdom  = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].find(me.vdom, id);
            vnode = me.vnode && _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].find(me.vnode, id);

            if (!me.hasUnmountedVdomChanges) {
                me.hasUnmountedVdomChanges = !me.mounted && me.hasBeenMounted
            }

            vdom.vdom.style = value; // keep the vdom in sync

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.mounted) {
                vnodeStyle = vnode.vnode.style;

                // keep the vnode in sync
                // we need the iteration since vdom shortcuts (height, width,...) live within the vnode style
                // using vnode.vnode.style = style would lose them.
                Object.entries(delta).forEach(([key, value]) => {
                    if (value === null) {
                        delete vnode.vnode.style[key]
                    } else {
                        vnodeStyle[key] = value
                    }
                });

                opts = {
                    action: 'updateDom',
                    deltas: [{id, style: delta}]
                };

                if (currentWorker.isSharedWorker) {
                    opts.appName = me.appName
                }

                currentWorker.sendMessage('main', opts)
            }
        }
    }

    /**
     * Gets called after the vdom config gets changed in case the component is already mounted (delta updates).
     * @param {Object} vdom=this.vdom
     * @param {Neo.vdom.VNode} vnode=this.vnode
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @protected
     */
    updateVdom(vdom=this.vdom, vnode=this.vnode, resolve, reject) {
        let me                       = this,
            {app, mounted, parentId} = me,
            listenerId;

        if (me.isVdomUpdating || me.silentVdomUpdate) {
            resolve && me.resolveUpdateCache.push(resolve);
            me.needsVdomUpdate = true
        } else {
            if (!mounted && me.isConstructed && !me.hasRenderingListener && app?.rendering === true) {
                me.hasRenderingListener = true;

                listenerId = app.on('mounted', () => {
                    app.un('mounted', listenerId);

                    me.timeout(50).then(() => {
                        me.vnode && me.updateVdom(me.vdom, me.vnode, resolve, reject)
                    })
                })
            } else {
                if (resolve && (!mounted || !vnode)) {
                    me.resolveUpdateCache.push(resolve)
                }

                if (
                    !me.needsParentUpdate(parentId, resolve)
                    && !me.isParentUpdating(parentId, resolve)
                    && mounted
                    && vnode
                ) {
                    // Verify that the critical rendering path => CSS files for the new tree is in place
                    if (currentWorker.countLoadingThemeFiles !== 0) {
                        currentWorker.on('themeFilesLoaded', function() {
                            me.updateVdom(vdom, vnode, resolve, reject)
                        }, me, {once: true})
                    } else {
                        me.#executeVdomUpdate(vdom, vnode, resolve, reject)
                    }
                }
            }
        }

        me.hasUnmountedVdomChanges = !mounted && me.hasBeenMounted
    }
}

/**
 * manager.Focus fires the event after focusEnter, focusLeave or focusMove
 * @event focusChange
 * @param {Object} data
 * @param {Object[]} [data.path] dom element ids upwards
 * @param {Object[]} [data.oldPath] dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path
 * @event focusEnter
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is not included inside the dom id path
 * @event focusLeave
 * @param {Object} data
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path, but the path itself changed
 * @event focusMove
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/util/KeyNavigation.mjs":
/*!************************************!*\
  !*** ./src/util/KeyNavigation.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.util.KeyNavigation
 * @extends Neo.core.Base
 */
class KeyNavigation extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.KeyNavigation'
         * @protected
         */
        className: 'Neo.util.KeyNavigation',
        /**
         * @member {String} ntype='keynav'
         * @protected
         */
        ntype: 'keynav',
        /**
         * Internally stores the component id inside _component
         * @member {Neo.component.Base|null} component_=null
         */
        component_: null,
        /**
         * Set this to true in case the keydown event is supposed to bubble upwards inside the component tree
         * @member {Boolean} keyDownEventBubble=false
         */
        keyDownEventBubble: false,
        /**
         * @member {Array|null} keys_=null
         */
        keys_: null
    }

    add(value) {
        this._keys.push(...this.parseKeys(value))
    }

    /**
     * @protected
     * @returns {Neo.component.Base}
     */
    beforeGetComponent() {
        return Neo.getComponent(this._component)
    }

    /**
     * @param {Neo.component.Base} value
     * @protected
     * @returns {String} the component id
     */
    beforeSetComponent(value) {
        return value?.id
    }

    /**
     *
     */
    destroy() {
        this.unregister();
        super.destroy()
    }

    /**
     * @param {Object} data
     */
    onKeyDown(data) {
        // Using the chrome auto-fill feature does trigger a keydown event, not containing a key. See: #64
        if (data.key) {
            let me           = this,
                upperCaseKey = data.key.toUpperCase(),
                scope;

            upperCaseKey = me.parseUpperCaseKey(upperCaseKey);

            me.keys.forEach(key => {
                scope = Neo.isString(key.scope) ? Neo.get(key.scope) : key.scope;

                if (key.key.toUpperCase() === upperCaseKey) {
                    if (Neo.isFunction(key.fn)) {
                        key.fn.apply(scope, [data, me.component])
                    } else {
                        scope[key.fn]?.apply(scope, [data, me.component])
                    }
                }
            })
        }
    }

    /**
     * @param {Object} value
     * @returns {Object}
     */
    parseKeys(value) {
        if (!Array.isArray(value)) {
            let componentId = this._component,
                keyArray    = [];

            if (componentId) {
                Object.entries(value).forEach(([key, val]) => {
                    if (key !== 'scope') {
                        keyArray.push({
                            fn   : val,
                            key,
                            scope: value.scope || componentId // todo: support VCs later on
                        })
                    }
                });

                value = keyArray
            }
        }

        return value
    }

    /**
     * Replaces specific key names, e.g. " " => SPACE
     * @param {String} key
     * @protected
     * @returns {String}
     */
    parseUpperCaseKey(key) {
        switch (key) {
            case ' ':
                key = 'SPACE';
                break
            case 'ARROWDOWN':
                key = 'DOWN';
                break
            case 'ARROWLEFT':
                key = 'LEFT';
                break
            case 'ARROWRIGHT':
                key = 'RIGHT';
                break
            case 'ARROWUP':
                key = 'UP';
                break
        }

        return key
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me = this;

        me.component = component;
        me.keys      = me.parseKeys(me.keys);

        component.addDomListeners({
            keydown: {
                bubble: me.keyDownEventBubble,
                fn    : me.onKeyDown,
                scope : me
            }
        })
    }

    /**
     * Remove a key listener using the same config used when creating it
     * @param {Object} config
     */
    removeKey(config) {
        let me   = this,
            keys = me._keys,
            i    = 0,
            len  = keys.length,
            key;

        for (; i < len; i++) {
            key = keys[i];

            if (Neo.isEqual(key, config)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(keys, key);
                break
            }
        }
    }

    /**
     * Remove multiple key listeners passing an array of config items
     * @param {Array} items
     */
    removeKeys(items) {
        Array.isArray(items) && items.forEach(item => this.removeKey(item))
    }

    /**
     *
     */
    unregister() {
        // todo: remove the dom listener from the owner component
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(KeyNavigation));


/***/ }),

/***/ "./src/util/Rectangle.mjs":
/*!********************************!*\
  !*** ./src/util/Rectangle.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Rectangle)
/* harmony export */ });
/**
 * The class contains utility methods for working with DOMRect Objects
 * @class Neo.util.Rectangle
 * @extends DOMRect
 */

const
    emptyArray = Object.freeze([]),
    // Convert edge array values into the [T,R,B,L] form.
    parseEdgeValue = (e = 0) => {
        if (!Array.isArray(e)) {
            e = [e];
        }
        switch (e.length) {
            case 1:
                e.length = 4;
                return e.fill(e[0], 1, 4);
            case 2:// top&bottom, left&right
                return [e[0], e[1], e[0], e[1]];
            case 3:// top, left&right, bottom
                return [e[0], e[1], e[2], e[1]];
        }
        return e;
    },
    parseEdgeAlign = edgeAlign => {
        const
            edgeParts     = edgeAlignRE.exec(edgeAlign),
            ourEdgeZone   = edgeZone[edgeParts[1]],
            theirEdgeZone = edgeZone[edgeParts[4]];

        return {
            ourEdge         : edgeParts[1],
            ourEdgeOffset   : parseInt(edgeParts[2] || 50),
            ourEdgeUnit     : edgeParts[3] || '%',
            ourEdgeZone,
            theirEdge       : edgeParts[4],
            theirEdgeOffset : parseInt(edgeParts[5] || 50),
            theirEdgeUnit   : edgeParts[6] || '%',
            theirEdgeZone,

            // Aligned to an edge, *outside* of the target.
            // A normal align as a combo dropdown might request
            edgeAligned     : (ourEdgeZone & 1) === (theirEdgeZone & 1) && ourEdgeZone !== theirEdgeZone
        }
    },
    // The opposite of parseEdgeAlign, and it has to flip the edges
    createReversedEdgeAlign = edges => {
        const
            ourEdge   = oppositeEdge[edges.ourEdge],
            theirEdge = oppositeEdge[edges.theirEdge];

        // reconstitute a rule string with the edges flipped to the opposite sides
        return `${ourEdge}${edges.ourEdgeOffset}${edges.ourEdgeUnit}-${theirEdge}${edges.theirEdgeOffset}${edges.theirEdgeUnit}`

    },
    getElRect = el => {
        const r = el instanceof DOMRect ? el : (el?.nodeType === 1 ? el : typeof el === 'string' ? document.getElementById(el) : null)?.getBoundingClientRect();

        // Convert DOMRect into Rectangle
        return r && new Rectangle(r.x, r.y, r.width, r.height);
    },
    oppositeEdge = {
        t : 'b',
        r : 'l',
        b : 't',
        l : 'r'
    },
    edgeZone = {
        t : 0,
        r : 1,
        b : 2,
        l : 3
    },
    zoneNames = ['top', 'right', 'bottom', 'left'],
    zoneEdges = ['t', 'r', 'b', 'l'],
    zoneDimension = ['width', 'height'],
    zoneCoord = [0, 1, 0, 1],
    zeroMargins = [0, 0, 0, 0],
    edgeAlignRE = /^([trblc])(\d*)(%|px)?-([trblc])(\d*)(%|px)?$/;

class Rectangle extends DOMRect {
    static config = {
        /**
         * @member {String} className='Neo.util.Rectangle'
         * @protected
         */
        className: 'Neo.util.Rectangle'
    }

    /**
     * @member {Number|null} minHeight=null
     */
    minHeight = null
    /**
     * @member {Number|null} minWidth=null
     */
    minWidth = null

    /**
     * Checks if rect1 does not have an intersection with rect2
     * !includes() is true for intersections as well
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static excludes(rect1, rect2) {
        return rect1.bottom < rect2.top     // rect2 is below rect1
            || rect1.left   > rect2.right   // rect2 is left of rect1
            || rect1.right  < rect2.left    // rect2 is right of rect1
            || rect1.top    > rect2.bottom; // rect2 is above rect1
    }

    /**
     * Returns the overlapping area of rect1 & rect2
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Number} The area (x * y)
     */
    static getIntersection(rect1, rect2) {
        return Rectangle.getIntersectionDetails(rect1, rect2).area;
    }

    /**
     * Returns the overlapping area of rect1 & rect2
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Object} x, y & area
     */
    static getIntersectionDetails(rect1, rect2) {
        let width  = Math.max(0, Math.min(rect1.right,  rect2.right)  - Math.max(rect1.left, rect2.left)),
            height = Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top,  rect2.top));

        return {
            area: height * width,
            height,
            width
        };
    }

    /**
     * Checks if rect2 is fully contained inside rect1
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static includes(rect1, rect2) {
        return rect1.bottom >= rect2.bottom
            && rect1.left   <= rect2.left
            && rect1.right  >= rect2.right
            && rect1.top    <= rect2.top;
    }

    /**
     * Checks if rect2 is not contained inside rect1.
     * This could be an intersection or being fully excluded.
     * @param {Object} rect1
     * @param {Object} rect2
     * @param {String} side bottom, left, right or top
     * @returns {Boolean}
     */
    static leavesSide(rect1, rect2, side) {
        if (Rectangle.includes(rect1, rect2)) {
            return false;
        }

        if (side === 'bottom') {
            return rect1.bottom < rect2.bottom;
        }

        if (side === 'left') {
            return rect1.left > rect2.left;
        }

        if (side === 'right') {
            return rect1.right < rect2.right;
        }

        if (side === 'top') {
            return rect1.top > rect2.top;
        }
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveBy(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  += x;
            movedRect.right += x;
            movedRect.x     += x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom += y;
            movedRect.top    += y;
            movedRect.y      += y;
        }

        return movedRect;
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveTo(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  = x;
            movedRect.right = x + movedRect.width;
            movedRect.x     = x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom = y + movedRect.height;
            movedRect.top    = y;
            movedRect.y      = y;
        }

        return movedRect;
    }

    set bottom(b) {
        this.height += b - this.bottom;
    }
    get bottom() {
        return super.bottom;
    }

    set right(r) {
        this.width += r - this.right;
    }
    get right() {
        return super.right;
    }

    // Change the x without moving the Rectangle. The left side moves and the right side doesn't
    changeX(x) {
        const widthDelta = this.x - x;

        this.x = x;
        this.width += widthDelta;
    }

    // Change the y without moving the Rectangle. The top side moves and the bottom side doesn't
    changeY(y) {
        const heightDelta = this.y - y;

        this.y = y;
        this.height += heightDelta;
    }

    clone() {
        return Rectangle.clone(this);
    }

    static clone(r) {
        const result = new Rectangle(r.x, r.y, r.width, r.height);

        result.minWidth = r.minWidth;
        result.minHeight = r.minHeight;

        return result;
    }

    intersects(other) {
        const me = this;

        if (other.height && other.width) {
            const
                left   = Math.max(me.x, other.x),
                top    = Math.max(me.y, other.y),
                right  = Math.min(me.x + me.width, other.x + other.width),
                bottom = Math.min(me.y + me.height, other.y + other.height);

            if (left >= right || top >= bottom) {
                return false;
            }

            return new Rectangle(left, top, right - left, bottom - top);
        }
        // We're dealing with a point here - zero dimensions
        else {
            return (other.x >= me.x && other.y >= me.y && other.right <= me.right && other.bottom <= me.bottom);
        }
    }

    /**
     * Checks if the other Rectangle is fully contained inside this Rectangle
     * @param {Object} other
     * @returns {Boolean}
     */
    contains(other) {
        return this.bottom >= other.bottom
            && this.left   <= other.left
            && this.right  >= other.right
            && this.top    <= other.top;
    }

    /**
     * Returns a clone of this Rectangle expanded according to the edges array.
     * @param {Number}Number[]} edges
     * @returns {Rectangle}
     */
    expand(edges) {
        edges = parseEdgeValue(edges);

        return new this.constructor(this.x - edges[3], this.y - edges[0], this.width + edges[1] + edges[3], this.height + edges[0] + edges[2]);
    }

    moveBy(x = 0, y = 0) {
        const result = this.clone();

        if (Array.isArray(x)) {
            y = x[1];
            x = x[0];
        }
        result.x += x;
        result.y += y;
        return result;
    }

    /**
     * Returns `true` if this Rectangle completely contains the other Rectangle
     * @param {Rectangle} other
     */
    contains(other) {
        return this.constructor.includes(this, other);
    }

    /**
     * Returns a copy of this Rectangle constrained to fit within the passed Rectangle
     * @param {Rectangle} constrainTo
     * @returns {Rectangle|Boolean} A new Rectangle constrained to te passed Rectangle, or false if it could not be constrained.
     */
    constrainTo(constrainTo) {
        const
            me        = this,
            minWidth  = me.minWidth  || me.width,
            minHeight = me.minHeight || me.height;

        // Not possible, even when shrunk to minima
        if (minHeight > constrainTo.height || minWidth > constrainTo.width) {
            return false;
        }

        // We do not mutate this Rectangle, but return a constrained version
        const result = me.clone();

        // Translate result so that the top and left are visible
        result.x = Math.max(me.x + Math.min(constrainTo.right  - result.right,  0), constrainTo.x);
        result.y = Math.max(me.y + Math.min(constrainTo.bottom - result.bottom, 0), constrainTo.y);

        // Pull in any resulting overflow
        result.bottom = Math.min(result.bottom, constrainTo.bottom);
        result.right = Math.min(result.right, constrainTo.right);

        return result;
    }

    alignTo(align) {
        const
            me             = this,
            {
                constrainTo,    // Element or Rectangle result must fit into
                target,         // Element or Rectangle to align to
                edgeAlign,      // t50-b50 type string
                axisLock,       // true for flip, 'flexible' for flip, then try the other edges
                offset,         // Final [x, y] vector to move the result by.
                matchSize
            }              = align,
            targetMargin   = align.targetMargin ? parseEdgeValue(align.targetMargin) : zeroMargins,
            targetRect     = getElRect(target),
            constrainRect  = getElRect(constrainTo),
            edges          = parseEdgeAlign(edgeAlign),
            matchDimension = zoneDimension[edges.theirEdgeZone & 1];

        let result = me.clone();

        if (matchSize) {
            result[matchDimension] = targetRect[matchDimension];
        }

        // Must do the calculations after the aligned side has been matched in size if requested.
        const
            myPoint     = result.getAnchorPoint(edges.ourEdgeZone, edges.ourEdgeOffset, edges.ourEdgeUnit),
            targetPoint = targetRect.getAnchorPoint(edges.theirEdgeZone, edges.theirEdgeOffset, edges.theirEdgeUnit, targetMargin),
            vector      = [targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]];

        result = result.moveBy(vector);

        // A useful property in the resulting rectangle which specifies which zone of the target
        // It is being places in, T,R,B or L - 0, 1, 2, 3
        // Some code may want to treat DOM elements differently depending on the zone
        result.zone = edges.theirEdgeZone;
        result.position = zoneNames[result.zone];

        // Now we create the four Rectangles around the target, into which we may be constrained
        // Zones T,R,B,L 0 9, 1, 2, 3:
        // +-----------------------------------------------------------------------------------+
        // | +-------------------------+------------------------+----------------------------+ |
        // | |          ^              |                        |             ^              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+---------Zone 0---------+-------------+---------->   | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | +----------+--------------+------------------------+-------------+--------------+ |
        // | |          |              | +--------------------+ |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |       Zone 3            | |                    | |          Zone 1            | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | +--------------------+ |             |              | |
        // | ++---------+--------------+------------------------+-------------+--------------+ |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+--------Zone 2----------+-------------+------------> | |
        // | |          |              |                        |             |              | |
        // | |          v              |                        |             v              | |
        // | ++------------------------+------------------------+----------------------------+ |
        // +-----------------------------------------------------------------------------------+
        if (constrainRect && !constrainRect.contains(result)) {
            // They asked to overlap the target, for example t0-t0
            // In these cases, we just return the result
            if (targetRect.intersects(result)) {
                return result;
            }

            // This is the zone we try to fit into first, the one that was asked for
            let zone = edges.theirEdgeZone;

            // We create an array of four rectangles into which we try to fit with appropriate align specs.
            // We must start with the requested zone, whatever that is.
            const zonesToTry = [{
                zone,
                edgeAlign
            }];

            if (axisLock) {
                // Flip to the opposite side for the second try.
                // The alignment string has to be reversed
                // so r20-l30 has to become l20-r30.
                // The other two zones revert to centered so are easier
                zonesToTry[1] = {
                    zone      : zone = (zone + 2) % 4,
                    edgeAlign : createReversedEdgeAlign(edges)
                }

                // Fall back to the other two zones.
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 1) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 3) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
            }
            else {
                // go through the other zones in order
                for (let i = 1; i < 4; i++) {
                    zonesToTry.push({
                        zone      : zone = (zone + 1) % 4,
                        edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                    });
                }
            }

            // Calculate the constraint Rectangle for each zone
            for (let i = 0; i < zonesToTry.length; i++) {
                // We clone the outer constraining rectangle
                // and move it into position
                const c = constrainRect.clone();

                switch (zonesToTry[i].zone) {
                    case 0:
                        // The zone i2 above the target - zone 0/T
                        c.bottom = targetRect.y - targetMargin[0];
                        break;
                    case 1:
                        // The zone is to the right of the target - zone 1/R
                        c.changeX(targetRect.right + targetMargin[1]);
                        break;
                    case 2:
                        // The zone is below the target - zone 2/B
                        c.changeY(targetRect.bottom + targetMargin[2]);
                        break;
                    case 3:
                        // The zone is to the left of the target - zone 3/L
                        c.right = targetRect.x - targetMargin[3];
                        break;
                }
                zonesToTry[i].constrainRect = c;
            }

            // Now try to constrain our result into each zone's constraintZone
            for (let i = 0; i < zonesToTry.length; i++) {
                const
                    {
                        zone,
                        edgeAlign,
                        constrainRect
                    }    = zonesToTry[i],
                    edge = zoneEdges[zone];

                if (matchSize) {
                    // If we are aligning to the requested edge, or it's opposite edge then
                    // match that edge size, else revert it to our own size
                    result[matchDimension] = edge === edges.theirEdge || edge == oppositeEdge[edges.theirEdge] ? targetRect[matchDimension] : me[matchDimension];
                }

                // Do a simple align to the current edge
                result = result.alignTo({
                    target : targetRect,
                    edgeAlign,
                    targetMargin
                });

                let solution = result.constrainTo(constrainRect);

                // As soon as we find a zone into which the result is willing to be constrained. return it
                if (solution) {
                    solution.zone = zone;
                    solution.position = zoneNames[zone];
                    return solution;
                }
            }
        }

        // Add the configurable finishing touch.
        if (offset) {
            result.moveBy(offset);
        }

        return result;
    }

    getAnchorPoint(edgeZone, edgeOffset, edgeUnit, margin = emptyArray) {
        const me = this;

        let result;

        // Edge zones go top, right, bottom, left
        // Each one calculates the start point of that edge then moves along it by
        // the edgeOffset, then moves *away* from it by the margin for that edge if there's a margin.
        switch (edgeZone) {
            case 0:
                result = [me.x, me.y - (margin[0] || 0), me.width, 0];
                break;
            case 1:
                result = [me.x + me.width + (margin[1] || 0), me.y, me.height, 1];
                break;
            case 2:
                result = [me.x, me.y + me.height + (margin[2] || 0), me.width, 0];
                break;
            case 3:
                result = [me.x - (margin[3] || 0), me.y, me.height, 1];
        }
        result[result[3]] += edgeUnit === '%' ? result[2] / 100 * edgeOffset : edgeOffset;
        result.length = 2;
        return result;
    }

    equals(other) {
        return other instanceof DOMRect &&
            other.x === this.x &&
            other.y === this.y &&
            other.height === this.height &&
            other.width === this.width;
    }

    // For debugging purposes only
    show(color = 'red') {
        const div = document.createElement('div');

        div.style = `
            position:absolute;
            transform:translate3d(${this.x}px, ${this.y}px, 0);
            height:${this.height}px;
            width:${this.width}px;
            background-color:${color}
        `;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 30000);
        return div;
    }

    /**
     * When using JSON.stringify(this), we want to add minHeight & minWidth to the output.
     * @returns {Object}
     */
    toJSON() {
        const {bottom, height, left, minHeight, minWidth, right, top, width, x, y} = this;
        return {bottom, height, left, minHeight, minWidth, right, top, width, x, y}
    }
}


/***/ }),

/***/ "./src/util/Style.mjs":
/*!****************************!*\
  !*** ./src/util/Style.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Style
 * @extends Neo.core.Base
 */
class Style extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Style'
         * @protected
         */
        className: 'Neo.util.Style'
    }

    /**
     * Creates an delta object, containing the styles of newStyle which are not included or different than in oldStyle
     * Styles included in oldStyle but missing in newStyle will get a value of null
     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
     * @param {Object|String} newStyle
     * @param {Object|String} oldStyle
     * @returns {Object} style delta
     */
    static compareStyles(newStyle, oldStyle) {
        let styles = {};

        if (Neo.isString(newStyle)) {
            newStyle = Neo.createStyleObject(newStyle)
        }

        if (Neo.isString(oldStyle)) {
            oldStyle = Neo.createStyleObject(oldStyle)
        }

        if (!newStyle && !oldStyle) {
            return null
        } else if (!oldStyle) {
            return Neo.clone(newStyle)
        } else if (!newStyle) {
            Object.keys(oldStyle).forEach(function(style) {
                styles[style] = null
            });
        } else {
            Object.keys(newStyle).forEach(style => {
                if (!oldStyle.hasOwnProperty(style) || oldStyle[style] !== newStyle[style]) {
                    styles[style] = newStyle[style]
                }
            });

            Object.keys(oldStyle).forEach(style => {
                if (!newStyle.hasOwnProperty(style)) {
                    styles[style] = null
                }
            });

            if (Object.keys(styles).length > 0) {
                return styles
            }

            return null
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Style));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDTztBQUNDO0FBQ0Q7QUFDRTtBQUNQO0FBQ0Q7QUFDSztBQUNEO0FBQ0o7QUFDRDtBQUNBO0FBQ0M7O0FBRWpEO0FBQ0EscUZBQXFGLE1BQU07QUFDM0Y7QUFDQTtBQUNBLEtBQUssbUJBQW1CO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBSTtBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixp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QzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy91dGlsL0tleU5hdmlnYXRpb24ubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9SZWN0YW5nbGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9TdHlsZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IERvbUV2ZW50TWFuYWdlciAgZnJvbSAnLi4vbWFuYWdlci9Eb21FdmVudC5tanMnO1xuaW1wb3J0IEtleU5hdmlnYXRpb24gICAgZnJvbSAnLi4vdXRpbC9LZXlOYXZpZ2F0aW9uLm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgICBmcm9tICcuLi91dGlsL0xvZ2dlci5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlICAgICAgICBmcm9tICcuLi91dGlsL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IFN0eWxlICAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9TdHlsZS5tanMnO1xuaW1wb3J0IFV0aWwgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9VdGlsLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcbmltcG9ydCBWTm9kZVV0aWwgICAgICAgIGZyb20gJy4uL3V0aWwvVk5vZGUubWpzJztcblxuY29uc3RcbiAgICBhZGRVbml0cyAgICAgICAgICAgID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogaXNOYU4odmFsdWUpID8gdmFsdWUgOiBgJHt2YWx1ZX1weGAsXG4gICAgY2xvc2VzdENvbnRyb2xsZXIgICA9IFN5bWJvbC5mb3IoJ2Nsb3Nlc3RDb250cm9sbGVyJyksXG4gICAgY2xvc2VzdFByb3ZpZGVyICAgICA9IFN5bWJvbC5mb3IoJ2Nsb3Nlc3RQcm92aWRlcicpLFxuICAgIHtjdXJyZW50V29ya2VyfSAgICAgPSBOZW8sXG4gICAgbGVuZ3RoUkUgICAgICAgICAgICA9IC9eXFxkK1xcdyskLyxcbiAgICB0d29XYXlCaW5kaW5nU3ltYm9sID0gU3ltYm9sLmZvcigndHdvV2F5QmluZGluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBDb21wb25lbnRzIHdoaWNoIGhhdmUgYSBET00gcmVwcmVzZW50YXRpb25cbiAqIEBjbGFzcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBoaWRlTW9kZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBoaWRlTW9kZXM9WydyZW1vdmVEb20nLCd2aXNpYmlsaXR5J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBoaWRlTW9kZXMgPSBbJ3JlbW92ZURvbScsICd2aXNpYmlsaXR5J11cbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdjb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGFsaWdubWVudCBzcGVjaWZpY2F0aW9uIHRvIHBvc2l0aW9uIHRoaXMgQ29tcG9uZW50IHJlbGF0aXZlIHRvIHNvbWUgb3RoZXJcbiAgICAgICAgICogQ29tcG9uZW50LCBvciBFbGVtZW50IG9yIFJlY3RhbmdsZS4gT25seSBhcHBsaWVzIGluIGNhc2UgZmxvYXRpbmcgPSB0cnVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfSBhbGlnbl89e2VkZ2VBbGlnbjondC1iJyxjb25zdHJhaW5UbzonZG9jdW1lbnQuYm9keSd9XG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbl86IHtcbiAgICAgICAgICAgIGVkZ2VBbGlnbiAgOiAndC1iJyxcbiAgICAgICAgICAgIGNvbnN0cmFpblRvOiAnZG9jdW1lbnQuYm9keSdcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBjb21wb25lbnQgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwTmFtZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwTmFtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgbW91bnRzIGEgY29tcG9uZW50IGFmdGVyIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICAgKiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbCBjb21wb25lbnQgb2YgeW91ciBhcHAuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Nb3VudD1mYWxzZVxuICAgICAgICAgKiBAdHV0b3JpYWwgMDJfQ2xhc3NTeXN0ZW1cbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgcmVuZGVycyBhIGNvbXBvbmVudCBhZnRlciBiZWluZyBjcmVhdGVkIGluc2lkZSB0aGUgaW5pdCBjYWxsLlxuICAgICAgICAgKiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbCBjb21wb25lbnQgb2YgeW91ciBhcHAuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9SZW5kZXI9ZmFsc2VcbiAgICAgICAgICogQHNlZSB7QGxpbmsgTmVvLmNvbXBvbmVudC5CYXNlI2luaXQgaW5pdH1cbiAgICAgICAgICogQHR1dG9yaWFsIDAyX0NsYXNzU3lzdGVtXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENTUyBzZWxlY3RvcnMgdG8gYXBwbHkgdG8gdGhlIHJvb3QgbGV2ZWwgbm9kZSBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kIGNvbmZpZ3MgdG8gc3RhdGUuUHJvdmlkZXIgZGF0YSBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBFeGFtcGxlIGZvciBhIGJ1dHRvbi5CYXNlOlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBiaW5kOiB7XG4gICAgICAgICAqICAgICBpY29uQ2xzOiBkYXRhID0+IGBmYSBmYS17JGRhdGEuaWNvbn1gLFxuICAgICAgICAgKiAgICAgdGV4dCAgIDogZGF0YSA9PiBkYXRhLmZvby5iYXJcbiAgICAgICAgICogfVxuICAgICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2Jsb2IvZGV2L2V4YW1wbGVzL3N0YXRlUHJvdmlkZXJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGJpbmQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBDU1Mgc2VsZWN0b3JzIHRvIGFwcGx5IHRvIHRoZSByb290IGxldmVsIG5vZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICogWW91IGNhbiBvdmVycmlkZSBiYXNlQ2xzIHRvIHJlbW92ZSBkZWZhdWx0IHNlbGVjdG9ycy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNsc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY2xzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hbmFnZXIuRm9jdXMgd2lsbCBjaGFuZ2UgdGhpcyBmbGFnIG9uIGZvY3VzaW4gJiBvdXQgZG9tIGV2ZW50c1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjb250YWluc0ZvY3VzXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluc0ZvY3VzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NpZ24gYSBjb21wb25lbnQgY29udHJvbGxlciB0byB0aGlzIGNvbXBvbmVudCAocGFzcyBhbiBpbXBvcnRlZCBtb2R1bGUgb3IgdGhlIHN0cmluZyBiYXNlZCBjbGFzcyBuYW1lKVxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8U3RyaW5nfSBjb250cm9sbGVyXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sbGVyXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHRvIGFjY2VzcyB0aGUgZGF0YSBjb25maWcgb2YgdGhlIGNsb3Nlc3Qgc3RhdGUuUHJvdmlkZXIuXG4gICAgICAgICAqIFJlYWQgb25seS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkYXRhXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZWQgY29tcG9uZW50cyB3aWxsIGdldCB0aGUgbmVvLWRpc2FibGVkIGNscyBhcHBsaWVkIGFuZCB3b24ndCByZWNlaXZlIERPTSBldmVudHNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZGlzYWJsZWRfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgZG9tTGlzdGVuZXIgY29uZmlnc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxudWxsfSBkb21MaXN0ZW5lcnNfPW51bGxcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYWZ0ZXJTZXRTdGF5T25Ib3Zlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICogICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgKiAgICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFxuICAgICAgICAgKiAgICAgICAgICAgICB7bW91c2VlbnRlcjogbWUub25Nb3VzZUVudGVyLCBzY29wZTogbWV9LFxuICAgICAgICAgKiAgICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCBzY29wZTogbWV9XG4gICAgICAgICAqICAgICAgICAgKVxuICAgICAgICAgKiAgICB9XG4gICAgICAgICAqfVxuICAgICAgICAgKi9cbiAgICAgICAgZG9tTGlzdGVuZXJzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGNvbmZpZyB0byB0cnVlIHRvIGR5bmFtaWNhbGx5IGltcG9ydCBhIERyb3Bab25lIG1vZHVsZSAmIGNyZWF0ZSBhbiBpbnN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkcm9wcGFibGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wcGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUuRHJvcFpvbmV8bnVsbH0gZHJvcFpvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcFpvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRyb3Bab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byByZW5kZXIgdGhpcyBjb21wb25lbnQgaW50byB0aGUgdmlld3BvcnQgb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnQgZmxvd1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmbG9hdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZmxvYXRpbmc6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB3aGljaCB3aWxsIGdldCBzZXQgdG8gdHJ1ZSBvbiBtb3VudFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNCZWVuTW91bnRlZD1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoYXNCZWVuTW91bnRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhhc1JlbmRlcmluZ0xpc3RlbmVyPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGhhc1JlbmRlcmluZ0xpc3RlbmVyOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgZm9yIHZkb20gY2hhbmdlcyBhZnRlciBhIGNvbXBvbmVudCBnb3QgdW5tb3VudGVkXG4gICAgICAgICAqIChkZWx0YSB1cGRhdGVzIGNhbiBubyBsb25nZXIgZ2V0IGFwcGxpZWQgJiBhIG5ldyByZW5kZXIgY2FsbCBpcyByZXF1aXJlZCBiZWZvcmUgcmUtbW91bnRpbmcpXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhhc1VubW91bnRlZFZkb21DaGFuZ2VzXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoYXNVbm1vdW50ZWRWZG9tQ2hhbmdlc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLmhlaWdodCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBoZWlnaHRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGhlaWdodF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsIHNldHRpbmcgdG8gaGlkZSBvciBzaG93IHRoZSBjb21wb25lbnQgYW5kXG4gICAgICAgICAqIHlvdSBjYW4gdXNlIGVpdGhlciBoaWRlKCkvc2hvdygpIG9yIGNoYW5nZSB0aGlzIGNvbmZpZyBkaXJlY3RseSB0byBjaGFuZ2UgdGhlIGhpZGRlbiBzdGF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoaWRkZW5fPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBoaWRkZW5fOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgZm9yIGhpZGUgYW5kIHNob3cgYW5kIGRlZmluZXMgaWYgdGhlIGNvbXBvbmVudFxuICAgICAgICAgKiBzaG91bGQgdXNlIGNzcyB2aXNpYmlsaXR5OidoaWRkZW4nIG9yIHZkb206cmVtb3ZlRG9tXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaGlkZU1vZGVfPSdyZW1vdmVEb20nXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlTW9kZV86ICdyZW1vdmVEb20nLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvcCBsZXZlbCBpbm5lckhUTUwgb2YgdGhlIGNvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gaHRtbF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgaHRtbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIHRvIHNob3cgYSBzcGlubmVyIGNlbnRlcmVkIGluIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIFNldCB0byBhIHN0cmluZyB0byBzaG93IGEgbWVzc2FnZSBuZXh0IHRvIGEgc3Bpbm5lciBjZW50ZXJlZCBpbiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufFN0cmluZ30gaXNMb2FkaW5nPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0xvYWRpbmdfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgd2hpbGUgYW4gdXBkYXRlIHJlcXVlc3QgKHdvcmtlciBtZXNzYWdlcykgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNWZG9tVXBkYXRpbmdfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlzVmRvbVVwZGF0aW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2luZyB0aGUga2V5cyBjb25maWcgd2lsbCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTmVvLnV0aWwuS2V5TmF2aWdhdGlvbi5cbiAgICAgICAgICogQHNlZSB7QGxpbmsgTmVvLnV0aWwuS2V5TmF2aWdhdGlvbiBLZXlOYXZpZ2F0aW9ufVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGtleXNfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGtleXNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB1c2VkIGluc2lkZSBhZnRlclNldElzTG9hZGluZygpIHRvIGRlZmluZSB0aGUgQ1NTIGZvciB0aGUgbG9hZGluZyBzcGlubmVyIGljb25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGxvYWRpbmdTcGlubmVyQ2xzXz1bJ2ZhJywnZmEtc3Bpbm5lcicsJ2ZhLXNwaW4nXVxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZGluZ1NwaW5uZXJDbHNfOiBbJ2ZhJywgJ2ZhLXNwaW5uZXInLCAnZmEtc3BpbiddLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1heEhlaWdodCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtYXhIZWlnaHRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1heEhlaWdodF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCBmb3Igc3R5bGUubWF4V2lkdGgsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gbWF4V2lkdGhfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1heFdpZHRoXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5taW5IZWlnaHQsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gbWluSGVpZ2h0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtaW5IZWlnaHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1pbldpZHRoLCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG1pbldpZHRoXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtaW5XaWR0aF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSBzcGVjaWZpYyBzdGF0ZVByb3ZpZGVyIGRhdGEgcHJvcGVydGllcy5cbiAgICAgICAgICogVGhpcyB3aWxsIG1lcmdlIHRoZSBjb250ZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbW9kZWxEYXRhPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsRGF0YTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgdG8gdGhlIERPTVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3VudGVkXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIGluIGNhc2UgYW4gdXBkYXRlIGNhbGwgYXJyaXZlcyB3aGlsZSBhbm90aGVyIHVwZGF0ZSBpcyBydW5uaW5nXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG5lZWRzVmRvbVVwZGF0ZV89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbmVlZHNWZG9tVXBkYXRlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcGFyZW50SWQgZG9lcyBub3QgbWF0Y2ggYSBuZW8gY29tcG9uZW50IGlkLCB5b3UgY2FuIG1hbnVhbGx5IHNldCB0aGlzIHZhbHVlIGZvciBmaW5kaW5nXG4gICAgICAgICAqIHZpZXcgY29udHJvbGxlcnMgb3Igc3RhdGUgcHJvdmlkZXJzLlxuICAgICAgICAgKiBVc2UgY2FzZTogbWFudWFsbHkgZHJvcHBpbmcgY29tcG9uZW50cyBpbnRvIGEgdmRvbSBzdHJ1Y3R1cmVcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IHBhcmVudENvbXBvbmVudF89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRDb21wb25lbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmVudCBjb21wb25lbnQgaWQgb3IgZG9jdW1lbnQuYm9keVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHBhcmVudElkXz0nZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudElkXzogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXkgb2YgUGx1Z2luIE1vZHVsZXMgYW5kIC8gb3IgY29uZmlnIG9iamVjdHNcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gcGx1Z2luc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBwbHVnaW5zXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBhIHJlZmVyZW5jZSBmb3IgYWNjZXNzaW5nIHRoZSBjb21wb25lbnQgaW5zaWRlIHZpZXcgY29udHJvbGxlcnMuXG4gICAgICAgICAqIFJlZmVyZW5jZXMgd2lsbCBhbHNvIGdldCBtYXBwZWQgaW50byB0aGUgdmRvbSByb290IChkYXRhLXJlZjogdmFsdWUpLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcmVmZXJlbmNlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlZmVyZW5jZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIHRoZSB2aWV3IFJlc3BvbnNpdmUgYnkgYWRkaW5nIGFsdGVybmF0aXZlIGNvbmZpZ3MuXG4gICAgICAgICAqIFRoZSBkZWZpbml0aW9uIGhhcHBlbnMgdmlhIHJlc3BvbnNpdmVDZmdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSByZXNwb25zaXZlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzcG9uc2l2ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJpbmcgdGhlIHZub2RlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbmRlcmluZ189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyaW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgcm9sZSB0YWcgYXR0cmlidXRlIGZvciB0aGUgdmRvbSByb290LlxuICAgICAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FjY2Vzc2liaWxpdHkvQVJJQS9Sb2xlc1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gcm9sZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGZvciBzdHlsZSAnb3ZlcmZsb3c6YXV0bycuXG4gICAgICAgICAqIFNldCB0aGlzIHRvICd4JyBvciAneScgdG8gYWRkIHN0eWxlICdvdmVyZmxvdy14JyBvciAnb3ZlcmZsb3cteScgdG8gJ2F1dG8nXG4gICAgICAgICAqIE90aGVyIHRoYW4gZmFsc2UgdGhpcyB3aWxsIGFkZCBjbHMgJ25lby1zY3JvbGxhYmxlJy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxcInhcInxcInlcIn0gc2Nyb2xsYWJsZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgZm9yIGJ1bGsgdXBkYXRlcy4gRW5zdXJlIHRvIHNldCBpdCBiYWNrIHRvIGZhbHNlIGFmdGVyd2FyZHMuXG4gICAgICAgICAqIEludGVybmFsbHkgdGhlIHZhbHVlIHdpbGwgZ2V0IHNhdmVkIGFzIGEgbnVtYmVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkIG1ldGhvZHMgd29uJ3Qgc3RvcCB0aGUgc2lsZW50IG1vZGUgdG9vIGVhcmx5LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWxlbnRWZG9tVXBkYXRlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50VmRvbVVwZGF0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWxseSBhZGQgYSBzdGF0ZS5Qcm92aWRlciB0byBzaGFyZSBzdGF0ZSBkYXRhIHdpdGggY2hpbGQgY29tcG9uZW50c1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc3RhdGVQcm92aWRlcl89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGVQcm92aWRlcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHlsZSBhdHRyaWJ1dGVzIGFkZGVkIHRvIHRoaXMgdmRvbSByb290LiBzZWU6IGdldFZkb21Sb290KClcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdHlsZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiBwYXNzIGFuIHVzZWQgdGhlbWUgZGlyZWN0bHkgdG8gYW55IGNvbXBvbmVudCxcbiAgICAgICAgICogdG8gc3R5bGUgc3BlY2lmaWMgY29tcG9uZW50IHRyZWVzIGRpZmZlcmVudGx5IGZyb20geW91ciBtYWluIHZpZXcuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0aGVtZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpbGUgaXQgaXMgcmVjb21tZW5kZWQgdG8gZGVmaW5lIHRhZ3MgaW5zaWRlIHRoZSB2ZG9tIG9mIGNsYXNzZXMsXG4gICAgICAgICAqIHRoaXMgc2hvcnRjdXQgZW5hYmxlcyB1cyB0byBjaGFuZ2UgdGhlIHZkb20gcm9vdCB0YWcgb24gaW5zdGFuY2UgbGV2ZWwuXG4gICAgICAgICAqIFVzZSBjYXNlczogc3dpdGNoIGEgVG9vbGJhciB0byBhIFwibmF2XCIgdGFnLCBzd2l0Y2ggYSBTaWRlTmF2IHRvIGFuIFwiYXNpZGVcIiB0YWcuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0YWdfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRhZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgdG9vbHRpcCBjb25maWcgb2JqZWN0IG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGRpc3BsYXkgdGV4dFxuICAgICAgICAgKiBTZWUgdG9vbHRpcC9CYXNlLm1qc1xuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBhIHNpbmdsZSwgc2hhcmVkIFRvb2x0aXAgaW5zdGFuY2UgaXMgdXNlZCBmb3IgYWxsIHdpZGdldHMgd2hpY2ggcmVxdWVzdFxuICAgICAgICAgKiBhIHRvb2x0aXAuIEl0IHJlY29uZmlndXJlcyBpdHNlbGYgZnJvbSB0aGUgd2lkZ2V0J3MgZGVmaW5pdGlvbiBqdXN0IGJlZm9yZSBzaG93aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIHdpZGdldCBuZWVkcyBpdHMgb3duIGluc3RhbmNlIGZvciBhbnkgcmVhc29uLCBpbnNsdWRlIHRoZSBwcm9wZXJ0eSBgb3duSW5zdGFuY2UgOiB0cnVlYFxuICAgICAgICAgKiBpbiB0aGUgdG9vbHRpcCBjb25maWcgb2JqZWN0LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfSB0b29sdGlwXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0b29sdGlwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCAncHJpbWFyeScgYW5kIG90aGVyIGF0dHJpYnV0ZXMgdG8gbWFrZSBpdCBhbiBvdXRzdGFuZGluZyBkZXNpZ25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHVpXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB1aV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBkZXB0aCBvZiB0aGUgdmRvbSB0cmVlIGZvciB0aGUgbmV4dCB1cGRhdGUgY3ljbGUuXG4gICAgICAgICAqIC0gVGhlIHZhbHVlIDEgd2lsbCBvbmx5IHNlbmQgdGhlIGN1cnJlbnQgdmRvbSBzdHJ1Y3R1cmUgYXMgaXQgaXNcbiAgICAgICAgICogLSBUaGUgdmFsdWUgb2YgMiB3aWxsIGluY2x1ZGUgdGhlIHZkb20gb2YgZGlyZWN0IGNoaWxkcmVuXG4gICAgICAgICAqIC0gVGhlIHZhbHVlIG9mIDMgd2lsbCBpbmNsdWRlIHRoZSB2ZG9tIG9mIGdyYW5kY2hpbGRyZW5cbiAgICAgICAgICogLSBUaGUgdmFsdWUgb2YgLTEgd2lsbCBpbmNsdWRlIHRoZSBmdWxsIHRyZWUgb2YgYW55IGRlcHRoXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdXBkYXRlRGVwdGhfPTFcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURlcHRoXzogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wb25lbnQgdm5vZGUgdHJlZS4gQXZhaWxhYmxlIGFmdGVyIHRoZSBjb21wb25lbnQgZ290IHJlbmRlcmVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZub2RlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZub2RlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS53aWR0aCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSB3aWR0aF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1c3RvbSB3aW5kb3dJcyAodGltZXN0YW1wKSB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118bnVsbH0gd3JhcHBlckNsc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlckNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcy4gVXNlZnVsIGluIGNhc2UgZ2V0VmRvbVJvb3QoKSBkb2VzIG5vdCBwb2ludCB0byB0aGUgdG9wIGxldmVsIERPTSBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gd3JhcHBlclN0eWxlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwcGVyU3R5bGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZkb20gbWFya3VwIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17fVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgYW4gdXBkYXRlKCkgZ2V0cyBjYWxsZWQgd2hpbGUgYSBwYXJlbnQgaXMgdXBkYXRpbmcsIHdlIHN0b3JlIHRoZSBpZCAmIGRpc3RhbmNlIG9mIHRoZVxuICAgICAqIHJlcXVlc3RpbmcgY29tcG9uZW50IGluc2lkZSB0aGUgY2hpbGRVcGRhdGVDYWNoZSBvZiB0aGUgcGFyZW50LCB0byBnZXQgcmVzb2x2ZWQgb25jZSB0aGUgdXBkYXRlIGlzIGRvbmUuXG4gICAgICogZS5nLiBjaGlsZFVwZGF0ZUNhY2hlID0geyduZW8tZ3JpZC12aWV3LTEnOiB7ZGlzdGFuY2U6IDEsIHJlc29sdmU6IGZufX1cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNoaWxkVXBkYXRlQ2FjaGU9e31cbiAgICAgKi9cbiAgICBjaGlsZFVwZGF0ZUNhY2hlID0ge31cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIHVwZGF0ZURlcHRoIHdoaWxlIGFuIHVwZGF0ZSBpcyBydW5uaW5nIHRvIGVuYWJsZSBjaGVja3MgZm9yIHBhcmVudCB1cGRhdGUgY29sbGlzaW9uc1xuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBjdXJyZW50VXBkYXRlRGVwdGg9bnVsbFxuICAgICAqL1xuICAgIGN1cnJlbnRVcGRhdGVEZXB0aCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbltdfSByZXNvbHZlVXBkYXRlQ2FjaGU9W11cbiAgICAgKi9cbiAgICByZXNvbHZlVXBkYXRlQ2FjaGUgPSBbXVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWNjZXNzIHRoZSBBcHAgdGhpcyBjb21wb25lbnQgYmVsb25ncyB0b1xuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5BcHBsaWNhdGlvbnxudWxsfVxuICAgICAqL1xuICAgIGdldCBhcHAoKSB7XG4gICAgICAgIHJldHVybiBOZW8uYXBwc1t0aGlzLmFwcE5hbWVdIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBDb21wb25lbnQgaXMgZnVsbHkgdmlzaWJsZSwgdGhhdCBpcyBpdCBpcyBub3QgaGlkZGVuIGFuZCBoYXMgbm8gaGlkZGVuIGFuY2VzdG9yc1xuICAgICAqL1xuICAgIGdldCBpc1Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdW50ZWQgJiYgIXRoaXMuaGlkZGVuICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNWaXNpYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBjb21wb25lbnQgYmFzZWQgbGlzdGVuZXJzXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBsaXN0ZW5lcnM9e31cbiAgICAgKi9cbiAgICBnZXQgbGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzIHx8IHt9XG4gICAgfVxuICAgIHNldCBsaXN0ZW5lcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWNjZXNzIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLnBhcmVudENvbXBvbmVudCB8fCBtZS5wYXJlbnRJZCA9PT0gJ2RvY3VtZW50LmJvZHknID8gbnVsbCA6IE5lby5nZXRDb21wb25lbnQobWUucGFyZW50SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBhZnRlciB0aGUgY29tcG9uZW50IHJlbmRlcigpIG1ldGhvZCB3YXMgY2FsbGVkLiBBbHNvIGZpcmVzIHRoZSByZW5kZXJlZCBldmVudC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJlZD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZCB8fCBmYWxzZVxuICAgIH1cbiAgICBzZXQgcmVuZGVyZWQodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fcmVuZGVyZWQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3JlbmRlcmVkJywgbWUuaWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0dGVyIHdpbGwgaGFuZGxlIHZkb20gdXBkYXRlcyBhdXRvbWF0aWNhbGx5XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tPXRoaXMuX3Zkb21cbiAgICAgKi9cbiAgICBnZXQgdmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zkb21cbiAgICB9XG4gICAgc2V0IHZkb20odmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZnRlclNldFZkb20odmFsdWUsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBjbHMgdG8gdGhlIHZkb21Sb290XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgYWRkQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWRkIGFkZGl0aW9uYWwgZG9tIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVycyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkb21MaXN0ZW5lcnMgPSB0aGlzLmRvbUxpc3RlbmVycztcblxuICAgICAgICBkb21MaXN0ZW5lcnMucHVzaCguLi52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFaXRoZXIgYSBzdHJpbmcgbGlrZSAnY29sb3I6IHJlZDsgYmFja2dyb3VuZC1jb2xvcjogYmx1ZTsnXG4gICAgICogb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgc3R5bGUgYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhbGwgc3R5bGVzIG9mIHRoaXMuZWxcbiAgICAgKi9cbiAgICBhZGRTdHlsZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBVdGlsLmNyZWF0ZVN0eWxlT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZG86IGFkZCBhIGNoZWNrIGlmIHNvbWV0aGluZyBoYXMgY2hhbmdlZFxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlID0gT2JqZWN0LmFzc2lnbih0aGlzLnN0eWxlLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgPSBvbGRWYWx1ZSB8fCBbXTtcblxuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmRvbSAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgdmRvbVJvb3QgPSBtZS5nZXRWZG9tUm9vdCgpLFxuICAgICAgICAgICAgY2xzO1xuXG4gICAgICAgIGlmICh2ZG9tICE9PSB2ZG9tUm9vdCkge1xuICAgICAgICAgICAgLy8gd2UgYXJlIHVzaW5nIGEgd3JhcHBlciBub2RlXG4gICAgICAgICAgICB2ZG9tUm9vdC5jbHMgPSBbLi4udmFsdWVdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIGNoYW5nZXNcbiAgICAgICAgICAgIGNscyA9IE5lb0FycmF5LnVuaW9uKG1lLndyYXBwZXJDbHMsIHZhbHVlKTtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkVmFsdWUsIHZhbHVlKSk7XG4gICAgICAgICAgICB2ZG9tLmNscyA9IGNsc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmlzVmRvbVVwZGF0aW5nIHx8IG1lLnNpbGVudFZkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIG1lLm5lZWRzVmRvbVVwZGF0ZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChtZS5tb3VudGVkICYmIG1lLnZub2RlKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVDbHModmFsdWUsIG9sZFZhbHVlLCB2ZG9tUm9vdC5pZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciBhbnkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29uZmlnKGtleSwgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRXb3JrZXIuaXNVc2luZ1N0YXRlUHJvdmlkZXJzICYmIG1lW3R3b1dheUJpbmRpbmdTeW1ib2xdICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBiaW5kaW5nID0gbWUuYmluZD8uW2tleV07XG5cbiAgICAgICAgICAgIGlmIChiaW5kaW5nPy50d29XYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKT8uc2V0RGF0YShiaW5kaW5nLmtleSwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpc2FibGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlzYWJsZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZG9tTGlzdGVuZXJzIGluc2lkZSB0aGUgTmVvLm1hbmFnZXIuRG9tRXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9tTGlzdGVuZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZT8uWzBdIHx8IG9sZFZhbHVlPy5bMF0pIHtcbiAgICAgICAgICAgIG1lLmdldENvbnRyb2xsZXIoKT8ucGFyc2VEb21MaXN0ZW5lcnMobWUpO1xuXG4gICAgICAgICAgICBEb21FdmVudE1hbmFnZXIudXBkYXRlRG9tTGlzdGVuZXJzKG1lLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyb3BwYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyb3BwYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLmRyb3Bab25lKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4uL2RyYWdnYWJsZS9Ecm9wWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZHJvcFpvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmRyb3Bab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZsZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmxleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7dmFsdWV9ICR7dmFsdWV9IDAlYFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25maWd1cmVkRmxleCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdmbGV4JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoYXNVbm1vdW50ZWRWZG9tQ2hhbmdlcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhhc1VubW91bnRlZFZkb21DaGFuZ2VzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgfHwgKCF2YWx1ZSAmJiBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRJZHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudElkcyh0aGlzKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgICA9IHBhcmVudElkcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZHNbaV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuX2hhc1VubW91bnRlZFZkb21DaGFuZ2VzID0gdmFsdWUgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkSGVpZ2h0ID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdoZWlnaHQnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGhpZGRlbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhpZGRlbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlID0gdmFsdWUgPyAnaGlkZScgOiAnc2hvdyc7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG9sZFZhbHVlID09PSB1bmRlZmluZWQgJiYgbWUuaGlkZU1vZGUgPT09ICdyZW1vdmVEb20nKSB7XG4gICAgICAgICAgICBtZS52ZG9tLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSB8fCBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZVtzdGF0ZV0oKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgbWUucmV2ZXJ0Rm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmZpcmUoc3RhdGUsIHtpZDogbWUuaWR9KTtcbiAgICAgICAgbWUuZmlyZSgnaGlkZGVuQ2hhbmdlJywge2lkOiBtZS5pZCwgb2xkVmFsdWUsIHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGh0bWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEh0bWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2h0bWwnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdpZCcsIHZhbHVlKTtcblxuICAgICAgICBvbGRWYWx1ZSAmJiBDb21wb25lbnRNYW5hZ2VyLnVucmVnaXN0ZXIob2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAgICAmJiBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc0xvYWRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzTG9hZGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIHx8IG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2NscywgdmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBtYXNrSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZkb20uY24pIHtcbiAgICAgICAgICAgICAgICBtYXNrSW5kZXggPSB2ZG9tLmNuLmZpbmRMYXN0SW5kZXgoYyA9PiBjLmNscz8uaW5jbHVkZXMoJ25lby1sb2FkLW1hc2snKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxvYWQgbWFza1xuICAgICAgICAgICAgICAgIGlmIChtYXNrSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24uc3BsaWNlKG1hc2tJbmRleCwgMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghdmRvbS5jbikge1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuID0gW11cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2ZG9tLmNuLnB1c2gobWUuY3JlYXRlTG9hZGluZ01hc2sodmFsdWUpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLW1hc2tlZCcsIHZhbHVlKTtcbiAgICAgICAgICAgIG1lLnNldCh7Y2xzLCB2ZG9tfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNWZG9tVXBkYXRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzVmRvbVVwZGF0aW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRVcGRhdGVEZXB0aCA9IHZhbHVlID8gdGhpcy51cGRhdGVEZXB0aCA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heEhlaWdodCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhIZWlnaHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1heEhlaWdodCA9IGFkZFVuaXRzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnbWF4SGVpZ2h0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXhXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkTWF4V2lkdGggPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21heFdpZHRoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtaW5IZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluSGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRNaW5IZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21pbkhlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluV2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluV2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1pbldpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdtaW5XaWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtpZCwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmhhc0JlZW5Nb3VudGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5kb21MaXN0ZW5lcnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogdGhlIG1haW4gdGhyZWFkIHJlcGx5IG9mIG1vdW50IGFycml2ZXMgYWZ0ZXIgcHVzaGluZyB0aGUgdGFzayBpbnRvIHRoZSBxdWV1ZSB3aGljaCBkb2VzIG5vdCBlbnN1cmUgdGhlIGRvbSBpcyBtb3VudGVkXG4gICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoMTUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERvbUV2ZW50TWFuYWdlci5tb3VudERvbUxpc3RlbmVycyhtZSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5kb1Jlc29sdmVVcGRhdGVDYWNoZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmZsb2F0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsaWduVG8oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb2N1cyB3aWxsIGJlIHB1c2hlZCBpbnRvIHRoZSBmaXJzdCBpbnB1dCBmaWVsZCBvciBvdGhlciBmb2N1c2FibGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICBtZS5mb2N1cyhpZCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdtb3VudGVkJywgbWUuaWQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnJldmVydEZvY3VzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVmZXJlbmNlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWZlcmVuY2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2RhdGEtcmVmJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZXNwb25zaXZlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldFJlc3BvbnNpdmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5nZXRQbHVnaW4oJ3Jlc3BvbnNpdmUnKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG1vZHVsZSAgPSBhd2FpdCBpbXBvcnQoYC4uLy4uL3NyYy9wbHVnaW4vUmVzcG9uc2l2ZS5tanNgKSxcbiAgICAgICAgICAgICAgICBwbHVnaW5zID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm9sZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um9sZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgncm9sZScsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2Nyb2xsYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW58bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTY3JvbGxhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBvbGRPdmVyZmxvd0tleSA9ICdvdmVyZmxvdyc7XG5cbiAgICAgICAgICAgIGlmICghTmVvLmlzQm9vbGVhbihvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRPdmVyZmxvd0tleSArPSBOZW8uY2FwaXRhbGl6ZShvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUucmVtb3ZlU3R5bGUoW29sZE92ZXJmbG93S2V5XSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmZsb3dLZXkgPSAnb3ZlcmZsb3cnO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgIU5lby5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dLZXkgKz0gTmVvLmNhcGl0YWxpemUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmFkZFN0eWxlKG92ZXJmbG93S2V5ICsgJzphdXRvJyk7XG4gICAgICAgICAgICAgICAgbWUuYWRkQ2xzKCduZW8tc2Nyb2xsYWJsZScpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnJlbW92ZUNscygnbmVvLXNjcm9sbGFibGUnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdHlsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdHlsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoIXZhbHVlICYmIG9sZFZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGFnIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUYWcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ3RhZycsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGhlbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgfHwgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7Y2xzfSAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAmJiBjbHMuaW5jbHVkZXMob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byBhZGQgYSBET00gYmFzZWQgQ1NTIHNlbGVjdG9yLCBpbiBjYXNlIHRoZSB0aGVtZSBpcyBhbHJlYWR5IGluaGVyaXRlZFxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBtZS5wYXJlbnQ/LnRoZW1lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgJiYgTmVvQXJyYXkuYWRkKGNscywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdG9vbHRpcCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRvb2x0aXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95Py4oKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChOZW8ubnMoJ05lby50b29sdGlwLkJhc2UnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0KCcuLi90b29sdGlwL0Jhc2UubWpzJykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHN0eWxpbmcgcHVycG9zZXMgb25seS5cbiAgICAgKiBUbyBkZWZpbmUgYnV0dG9uIHN0eWxlcyBvciBjb21wb25lbnQgc3R5bGVzLFxuICAgICAqIHRoaXMgd2lsbCBhZGQgYSBjc3MgY2xhc3M6IG5lby1udHlwZS12YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFVpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBgbmVvLSR7bWUubnR5cGV9LSR7b2xkVmFsdWV9YCk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgYG5lby0ke21lLm50eXBlfS0ke3ZhbHVlfWApXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZkb20gcHNldWRvLWNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmRvbSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWZG9tKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdm5vZGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWbm9kZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnN5bmNWbm9kZVRyZWUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZFdpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCd3aWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb250cm9sbGVyID0gbWUuY29udHJvbGxlcjtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgbWUuX19wcm90b19fKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgY29tcG9uZW50IGdldHMgbW92ZWQgaW50byBhIGRpZmZlcmVudCB3aW5kb3csIGFuIHVwZGF0ZSBjeWNsZSBtaWdodCBzdGlsbCBiZSBydW5uaW5nLlxuICAgICAgICAvLyBTaW5jZSB0aGUgdXBkYXRlIG1pZ2h0IG5vIGxvbmdlciBnZXQgbWFwcGVkLCB3ZSB3YW50IHRvIHJlLWVuYWJsZSB0aGlzIGluc3RhbmNlIGZvciBmdXR1cmUgdXBkYXRlcy5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdyYXBwZXJDbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXcmFwcGVyQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSA9IG9sZFZhbHVlIHx8IFtdO1xuICAgICAgICB2YWx1ZSAgICA9IHZhbHVlICAgIHx8IFtdO1xuXG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2ZG9tICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICB2ZG9tUm9vdCA9IG1lLmdldFZkb21Sb290KCksXG4gICAgICAgICAgICBjbHMgICAgICA9IG1lLnZkb20/LmNscyB8fCBbXTtcblxuICAgICAgICBpZiAodmRvbSA9PT0gdmRvbVJvb3QpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWVyZ2UgY2hhbmdlc1xuICAgICAgICAgICAgY2xzID0gTmVvQXJyYXkudW5pb24oY2xzLCB2YWx1ZSk7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBOZW9BcnJheS5kaWZmZXJlbmNlKG9sZFZhbHVlLCB2YWx1ZSkpO1xuICAgICAgICAgICAgdmRvbS5jbHMgPSBjbHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgYSB3cmFwcGVyID0+IGNscyAmIHdyYXBwZXJDbHMgc2hhcmUgdGhlIHNhbWUgbm9kZVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IHZhbHVlIDogW107XG5cbiAgICAgICAgICAgIG9sZFZhbHVlICYmIE5lb0FycmF5LnJlbW92ZShjbHMsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHZkb20pIHtcbiAgICAgICAgICAgICAgICB2ZG9tLmNscyA9IGNsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmlzVmRvbVVwZGF0aW5nIHx8IG1lLnNpbGVudFZkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIG1lLm5lZWRzVmRvbVVwZGF0ZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVDbHModmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3cmFwcGVyU3R5bGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V3JhcHBlclN0eWxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoISghdmFsdWUgJiYgb2xkVmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB2ZG9tID0gbWUudmRvbTtcblxuICAgICAgICAgICAgaWYgKCF2ZG9tLmlkKSB7XG4gICAgICAgICAgICAgICAgdmRvbS5zdHlsZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZVN0eWxlKHZhbHVlLCBvbGRWYWx1ZSwgdmRvbS5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWducyB0aGUgdG9wIGxldmVsIG5vZGUgaW5zaWRlIHRoZSBtYWluIHRocmVhZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjPXt9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgYWxpZ25UbyhzcGVjPXt9KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBhbGlnbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZS5hbGlnbixcbiAgICAgICAgICAgICAgICAuLi5zcGVjLFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRGbGV4ICAgICA6IG1lLmNvbmZpZ3VyZWRGbGV4LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRXaWR0aCAgICA6IG1lLmNvbmZpZ3VyZWRXaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkSGVpZ2h0ICAgOiBtZS5jb25maWd1cmVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNaW5XaWR0aCA6IG1lLmNvbmZpZ3VyZWRNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkTWluSGVpZ2h0OiBtZS5jb25maWd1cmVkTWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNYXhXaWR0aCA6IG1lLmNvbmZpZ3VyZWRNYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkTWF4SGVpZ2h0OiBtZS5jb25maWd1cmVkTWF4SGVpZ2h0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhbGlnbi50YXJnZXQpIHtcbiAgICAgICAgICAgIGF3YWl0IE5lby5tYWluLkRvbUFjY2Vzcy5hbGlnbihhbGlnbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgY2xzIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0Q2xzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFsuLi52YWx1ZV0gOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZGF0YSBjb25maWdcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB3aGljaCBpcyBleHBlbnNpdmUgdG8gdXNlLCBzaW5jZSBpdCB3aWxsIGdlbmVyYXRlIGEgbWVyZ2VkIHBhcmVudCBzdGF0ZSBwcm92aWRlcnMgZGF0YSBtYXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldERhdGEodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldEhpZXJhcmNoeURhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgc3R5bGUgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldFN0eWxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7Li4udmFsdWV9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSB3cmFwcGVyQ2xzIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0V3JhcHBlckNscyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBbLi4udmFsdWVdIDogW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIHdyYXBwZXJTdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0V3JhcHBlclN0eWxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7Li4uT2JqZWN0LmFzc2lnbih0aGlzLnZkb20uc3R5bGUgfHwge30sIHZhbHVlKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhbGlnbiBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBbGlnbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBKdXN0IGEgc2ltcGxlICd0LWInXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBlZGdlQWxpZ246IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtZXJnZSB0aGUgaW5jb21pbmcgYWxpZ25tZW50IHNwZWNpZmljYXRpb24gaW50byB0aGUgY29uZmlndXJlZCBkZWZhdWx0XG4gICAgICAgIHJldHVybiBOZW8ubWVyZ2Uoe30sIHZhbHVlLCBtZS5jb25zdHJ1Y3Rvci5jb25maWcuYWxpZ24pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2xzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvQXJyYXkudW5pb24odmFsdWUgfHwgW10sIHRoaXMuYmFzZUNscywgdGhpcy5nZXRCYXNlQ2xhc3MoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgY29udHJvbGxlciBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIENyZWF0ZXMgYSBjb250cm9sbGVyLkNvbXBvbmVudCBpbnN0YW5jZSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0Q29udHJvbGxlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIG51bGwsIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiB0aGlzLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZG9tTGlzdGVuZXJzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERvbUxpc3RlbmVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaGlkZU1vZGUgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEhpZGVNb2RlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnaGlkZU1vZGUnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGtleXMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBDcmVhdGVzIGEgS2V5TmF2aWdhdGlvbiBpbnN0YW5jZSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby51dGlsLktleU5hdmlnYXRpb258bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0S2V5cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBLZXlOYXZpZ2F0aW9uLCB7XG4gICAgICAgICAgICAgICAga2V5RG93bkV2ZW50QnViYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleXMgICAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdGF0ZVByb3ZpZGVyIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQ3JlYXRlcyBhIHN0YXRlLlByb3ZpZGVyIGluc3RhbmNlIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnN0YXRlLlByb3ZpZGVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdGF0ZVByb3ZpZGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXMgPSB7Y29tcG9uZW50OiBtZX07XG5cbiAgICAgICAgICAgIGlmIChtZS5tb2RlbERhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzLmRhdGEgPSBtZS5tb2RlbERhdGFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgJ05lby5zdGF0ZS5Qcm92aWRlcicsIGRlZmF1bHRWYWx1ZXMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHBsdWdpbnMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5wbHVnaW4uQmFzZVtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRQbHVnaW5zKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaW5kZXhdID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKGl0ZW0sIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHNpbGVudFZkb21VcGRhdGUgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFNpbGVudFZkb21VcGRhdGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE5lby5pc051bWJlcihvbGRWYWx1ZSkgPyAob2xkVmFsdWUgKyAxKSA6IDFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSAmJiBvbGRWYWx1ZSA+IDApID8gKG9sZFZhbHVlIC0gMSkgOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgdXBkYXRlRGVwdGggY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRVcGRhdGVEZXB0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9sZFZhbHVlID09PSAtMSB8fCB2YWx1ZSA9PT0gLTEgPyAtMSA6IE1hdGgubWF4KHZhbHVlLCBvbGRWYWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIHZkb20gb2JqZWN0IGF0dHJpYnV0ZSBvciByZW1vdmVzIGl0IGluIGNhc2UgaXQgaGFzIG5vIHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfE9iamVjdHxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKi9cbiAgICBjaGFuZ2VWZG9tUm9vdEtleShrZXksIHZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIHJvb3QgPSBtZS5nZXRWZG9tUm9vdCgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcm9vdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSByb290W2tleV1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gY2FzZSB5b3UgbmVlZCBkaWZmZXJlbnQgbWFzayBtYXJrdXBzLlxuICAgICAqIFRoZSByZW1vdmFsIGxvZ2ljIHJlbGllcyBvbiB0aGUgdG9wIGxldmVsIG5vZGUgaGF2aW5nIHRoZSBjbHMgJ25lby1sb2FkLW1hc2snXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gbG9hZGluZ01lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB2ZG9tXG4gICAgICovXG4gICAgY3JlYXRlTG9hZGluZ01hc2sobG9hZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsczogWyduZW8tbG9hZC1tYXNrJ10sXG4gICAgICAgICAgICBjbiA6IFt7XG4gICAgICAgICAgICAgICAgY2xzOiBbJ25lby1sb2FkLW1hc2stYm9keSddLFxuICAgICAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICAgICAgY2xzOiB0aGlzLmxvYWRpbmdTcGlubmVyQ2xzXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjbHMgICAgICA6IFsnbmVvLWxvYWRpbmctbWVzc2FnZSddLFxuICAgICAgICAgICAgICAgICAgICBodG1sICAgICA6IGxvYWRpbmdNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVEb206ICFOZW8uaXNTdHJpbmcobG9hZGluZ01lc3NhZ2UpXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB0b29sdGlwIGluc3RhbmNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlVG9vbHRpcCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlLm93bkluc3RhbmNlKSB7XG4gICAgICAgICAgICBtZS5fdG9vbHRpcCA9IE5lby5jcmVhdGUoJ05lby50b29sdGlwLkJhc2UnLCB7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50SWQ6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLl90b29sdGlwID0gdmFsdWU7XG4gICAgICAgICAgICBOZW8udG9vbHRpcC5CYXNlLmNyZWF0ZVNpbmdsZXRvbihtZS5hcHApO1xuICAgICAgICAgICAgbWUuYWRkQ2xzKCduZW8tdXNlcy1zaGFyZWQtdG9vbHRpcCcpO1xuICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIGNvbXBvbmVudCByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNyZWF0ZVZkb21SZWZlcmVuY2UoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0ge2NvbXBvbmVudElkOiBtZS5pZH0sXG4gICAgICAgICAgICB2ZG9tSWQgICAgPSBtZS52ZG9tLmlkO1xuXG4gICAgICAgIGlmICh2ZG9tSWQgJiYgbWUuaWQgIT09IHZkb21JZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlLmlkID0gdmRvbUlkXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciB0aGlzIGluc3RhbmNlIGZyb20gdGhlIENvbXBvbmVudE1hbmFnZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZVBhcmVudFZkb209ZmFsc2UgdHJ1ZSB0byByZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBwYXJlbnQgdmRvbSA9PiByZWFsIGRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlIHRydWUgdG8gdXBkYXRlIHRoZSB2ZG9tIHNpbGVudGx5ICh1c2VmdWwgZm9yIGRlc3Ryb3lpbmcgbXVsdGlwbGUgY2hpbGQgaXRlbXMgaW4gYSByb3cpXG4gICAgICogdG9kbzogdW5yZWdpc3RlciBldmVudHNcbiAgICAgKi9cbiAgICBkZXN0cm95KHVwZGF0ZVBhcmVudFZkb209ZmFsc2UsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50LCBwYXJlbnRJZH0gID0gbWUsXG4gICAgICAgICAgICBwYXJlbnRTdGF0ZVByb3ZpZGVyID0gcGFyZW50Py5nZXRTdGF0ZVByb3ZpZGVyKCksXG4gICAgICAgICAgICBwYXJlbnRWZG9tO1xuXG4gICAgICAgIG1lLnJldmVydEZvY3VzKCk7XG5cbiAgICAgICAgbWUuZG9tTGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgbWUuY29udHJvbGxlciA9IG51bGw7IC8vIHRyaWdnZXJzIGRlc3Ryb3koKVxuXG4gICAgICAgIG1lLnJlZmVyZW5jZSAmJiBtZS5nZXRDb250cm9sbGVyKCk/LnJlbW92ZVJlZmVyZW5jZShtZSk7IC8vIHJlbW92ZSBvd24gcmVmZXJlbmNlIGZyb20gcGFyZW50IGNvbnRyb2xsZXJzXG5cbiAgICAgICAgbWUuc3RhdGVQcm92aWRlciA9IG51bGw7IC8vIHRyaWdnZXJzIGRlc3Ryb3koKVxuXG4gICAgICAgIG1lLmJpbmQgJiYgcGFyZW50U3RhdGVQcm92aWRlcj8ucmVtb3ZlQmluZGluZ3MobWUuaWQpO1xuXG4gICAgICAgIG1lLnBsdWdpbnM/LmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVBhcmVudFZkb20gJiYgcGFyZW50SWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHthY3Rpb246ICdyZW1vdmVOb2RlJywgaWQ6IG1lLnZkb20uaWR9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRWZG9tID0gcGFyZW50LnZkb207XG5cbiAgICAgICAgICAgICAgICBWRG9tVXRpbC5yZW1vdmVWZG9tQ2hpbGQocGFyZW50VmRvbSwgbWUudmRvbS5pZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50W3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gcGFyZW50VmRvbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci51bnJlZ2lzdGVyKG1lKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG5cbiAgICAgICAgLy8gV2UgZG8gd2FudCB0byBwcmV2ZW50IGRlbGF5ZWQgY2FsbHMgYWZ0ZXIgYSBjb21wb25lbnQgaW5zdGFuY2UgZ290IGRlc3Ryb3llZC5cbiAgICAgICAgbWUub25Gb2N1c0xlYXZlID0gTmVvLmVtcHR5Rm47XG4gICAgICAgIG1lLnVubW91bnQgICAgICA9IE5lby5lbXB0eUZuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYWxsIHN0b3JlZCByZXNvbHZlKCkgY2FsbGJhY2tzXG4gICAgICovXG4gICAgZG9SZXNvbHZlVXBkYXRlQ2FjaGUoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnJlc29sdmVVcGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgbWUucmVzb2x2ZVVwZGF0ZUNhY2hlLmZvckVhY2goaXRlbSA9PiBpdGVtKCkpO1xuICAgICAgICAgICAgbWUucmVzb2x2ZVVwZGF0ZUNhY2hlID0gW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBOZW8ubWFuYWdlci5Db21wb25lbnQuZG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5GaXJzdE1hdGNoPXRydWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFRoZSBtYXRjaGluZyBpbnN0YW5jZSBvciBudWxsXG4gICAgICovXG4gICAgZG93bihjb25maWcsIHJldHVybkZpcnN0TWF0Y2g9dHJ1ZSkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5kb3duKHRoaXMsIGNvbmZpZywgcmV0dXJuRmlyc3RNYXRjaClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gc2VuZCB1cGRhdGUgcmVxdWVzdHMgdG8gdGhlIHZkb20gd29ya2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXNvbHZlXSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZWplY3RdIHVzZWQgYnkgcHJvbWlzZVVwZGF0ZSgpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjZXhlY3V0ZVZkb21VcGRhdGUodmRvbSwgdm5vZGUsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBvcHRzID0ge30sXG4gICAgICAgICAgICBkZWx0YXM7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRXb3JrZXIuaXNTaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgIG9wdHMuYXBwTmFtZSAgPSBtZS5hcHBOYW1lO1xuICAgICAgICAgICAgb3B0cy53aW5kb3dJZCA9IG1lLndpbmRvd0lkXG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IHRydWU7XG5cbiAgICAgICAgLy8gd2UgY2FuIG5vdCBzZXQgdGhlIGNvbmZpZyBkaXJlY3RseSA9PiBpdCBjb3VsZCBhbHJlYWR5IGJlIGZhbHNlLFxuICAgICAgICAvLyBhbmQgd2Ugc3RpbGwgd2FudCB0byBwYXNzIGl0IGZ1cnRoZXIgaW50byBzdWJ0cmVlc1xuICAgICAgICBtZS5fbmVlZHNWZG9tVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIG1lLmFmdGVyU2V0TmVlZHNWZG9tVXBkYXRlPy4oZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIG9wdHMudmRvbSAgPSBDb21wb25lbnRNYW5hZ2VyLmdldFZkb21UcmVlKHZkb20sIG1lLnVwZGF0ZURlcHRoKTtcbiAgICAgICAgb3B0cy52bm9kZSA9IENvbXBvbmVudE1hbmFnZXIuZ2V0Vm5vZGVUcmVlKHZub2RlLCBtZS51cGRhdGVEZXB0aCk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIHVwZGF0ZURlcHRoIHRvIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgbmV4dCB1cGRhdGUgY3ljbGVcbiAgICAgICAgbWUuX3VwZGF0ZURlcHRoID0gbWUuY29uc3RydWN0b3IuY29uZmlnLnVwZGF0ZURlcHRoO1xuXG4gICAgICAgIE5lby52ZG9tLkhlbHBlci51cGRhdGUob3B0cykuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgYXR0ZW1wdGluZyB0byB1cGRhdGUgY29tcG9uZW50IGRvbScsIGVyciwgbWUpO1xuXG4gICAgICAgICAgICByZWplY3Q/LigpXG4gICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBjaGVja2luZyBpZiB0aGUgY29tcG9uZW50IGdvdCBkZXN0cm95ZWQgYmVmb3JlIHRoZSB1cGRhdGUgY3ljbGUgaXMgZG9uZVxuICAgICAgICAgICAgaWYgKG1lLmlkKSB7XG4gICAgICAgICAgICAgICAgbWUudm5vZGUgPSBkYXRhLnZub2RlO1xuXG4gICAgICAgICAgICAgICAgZGVsdGFzID0gZGF0YS5kZWx0YXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIU5lby5jb25maWcudXNlVmRvbVdvcmtlciAmJiBkZWx0YXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwgZGVsdGFzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnJlc29sdmVWZG9tVXBkYXRlKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVzb2x2ZVZkb21VcGRhdGUocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgZm9jdXMoKSBvbiB0aGUgdG9wIGxldmVsIERPTSBub2RlIG9mIHRoaXMgY29tcG9uZW50IG9yIG9uIGEgZ2l2ZW4gbm9kZSB2aWEgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQ9dGhpcy5pZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hpbGRyZW49ZmFsc2VcbiAgICAgKi9cbiAgICBmb2N1cyhpZD10aGlzLmlkLCBjaGlsZHJlbj1mYWxzZSkge1xuICAgICAgICBOZW8ubWFpbi5Eb21BY2Nlc3MuZm9jdXMoe2NoaWxkcmVuLCBpZCwgd2luZG93SWQ6IHRoaXMud2luZG93SWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBkeW5hbWljIHZhbHVlcyBpbnRvIHRoaXMuY2xzXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldEJhc2VDbGFzcygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZmxvYXRpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCduZW8tZmxvYXRpbmcnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYW4gaW5zdGFuY2Ugc3RvcmVkIGluc2lkZSBhIGNvbmZpZyB2aWEgb3B0aW9uYWxseSBwYXNzaW5nIGEgbnR5cGUuXG4gICAgICogUmV0dXJucyB0aGlzW2NvbmZpZ05hbWVdIG9yIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCBhIG1hdGNoLlxuICAgICAqIFVzZWQgYnkgZ2V0Q29udHJvbGxlcigpICYgZ2V0U3RhdGVQcm92aWRlcigpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0Q29uZmlnSW5zdGFuY2VCeU50eXBlKGNvbmZpZ05hbWUsIG50eXBlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgICAgICAgICAgICA9IG1lW2NvbmZpZ05hbWVdLFxuICAgICAgICAgICAge3BhcmVudENvbXBvbmVudH0gPSBtZTtcblxuICAgICAgICBpZiAoY29uZmlnICYmICghbnR5cGUgfHwgbnR5cGUgPT09IGNvbmZpZy5udHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyZW50Q29tcG9uZW50ICYmIG1lLnBhcmVudElkKSB7XG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQgPSBtZS5wYXJlbnQgfHwgTmVvLmdldChtZS5wYXJlbnRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Q29tcG9uZW50LmdldENvbmZpZ0luc3RhbmNlQnlOdHlwZShjb25maWdOYW1lLCBudHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzLmNvbnRyb2xsZXIgb3IgdGhlIGNsb3Nlc3QgcGFyZW50IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyKG50eXBlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBjb250cm9sbGVyO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZVtjbG9zZXN0Q29udHJvbGxlcl07XG5cbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRyb2xsZXIgPSBtZS5nZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoJ2NvbnRyb2xsZXInLCBudHlwZSk7XG5cbiAgICAgICAgaWYgKCFudHlwZSkge1xuICAgICAgICAgICAgbWVbY2xvc2VzdENvbnRyb2xsZXJdID0gY29udHJvbGxlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250cm9sbGVyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gaWQ9dGhpcy5pZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBOYW1lPXRoaXMuYXBwTmFtZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby51dGlsLlJlY3RhbmdsZT59XG4gICAgICovXG4gICAgYXN5bmMgZ2V0RG9tUmVjdChpZD10aGlzLmlkLCBhcHBOYW1lPXRoaXMuYXBwTmFtZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7YXBwTmFtZSwgaWQsIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkfSk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAocmVjdCA9PiBSZWN0YW5nbGUuY2xvbmUocmVjdCkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVjdGFuZ2xlLmNsb25lKHJlc3VsdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb25vcnMgZGlmZmVyZW50IGl0ZW0gcm9vdHMgZm9yIG1vdW50IC8gcmVuZGVyIE9Qc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TW91bnRlZFBhcmVudElkKCkge1xuICAgICAgICBsZXQgcGFyZW50SWQgID0gdGhpcy5wYXJlbnRJZCxcbiAgICAgICAgICAgIHBhcmVudCAgICA9IE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpLFxuICAgICAgICAgICAgaXRlbXNSb290ID0gcGFyZW50Py5nZXRWZG9tSXRlbXNSb290Py4oKTtcblxuICAgICAgICByZXR1cm4gaXRlbXNSb290ID8gaXRlbXNSb290LmlkIDogcGFyZW50SWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHJlYWwgcGFyZW50SW5kZXggaW5zaWRlIHRoZSBET01cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRNb3VudGVkUGFyZW50SW5kZXgoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgICAgIGl0ZW1zICA9IHBhcmVudD8uaXRlbXMgfHwgW10sXG4gICAgICAgICAgICBpICAgICAgPSAwLFxuICAgICAgICAgICAgaW5kZXggID0gMCxcbiAgICAgICAgICAgIGxlbiAgICA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWl0ZW0uaGlkZGVuICYmIGl0ZW0uaGlkZU1vZGUgPT09ICdyZW1vdmVEb20nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJlbnQgY29tcG9uZW50cyBhcyBhbiBhcnJheVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKi9cbiAgICBnZXRQYXJlbnRzKCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5nZXRQYXJlbnRzKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRzXG4gICAgICogQHJldHVybnMge05lby5wbHVnaW4uQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldFBsdWdpbihvcHRzKSB7XG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcob3B0cykpIHtcbiAgICAgICAgICAgIGlmICghb3B0cy5zdGFydHNXaXRoKCdwbHVnaW4tJykpIHtcbiAgICAgICAgICAgICAgICBvcHRzID0gJ3BsdWdpbi0nICsgb3B0c1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRzID0ge250eXBlOiBvcHRzfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGhhc01hdGNoO1xuXG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIG1lLnBsdWdpbnMgfHwgW10pIHtcbiAgICAgICAgICAgIGhhc01hdGNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0cykge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5ba2V5XSAhPT0gb3B0c1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldFJlZmVyZW5jZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb3duKHtyZWZlcmVuY2U6IHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0RGF0YSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcy5zdGF0ZVByb3ZpZGVyIG9yIHRoZSBjbG9zZXN0IHBhcmVudCBzdGF0ZVByb3ZpZGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtudHlwZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0U3RhdGVQcm92aWRlcihudHlwZSkge1xuICAgICAgICBpZiAoIWN1cnJlbnRXb3JrZXIuaXNVc2luZ1N0YXRlUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHByb3ZpZGVyO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbWVbY2xvc2VzdFByb3ZpZGVyXTtcblxuICAgICAgICAgICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm92aWRlciA9IG1lLmdldENvbmZpZ0luc3RhbmNlQnlOdHlwZSgnc3RhdGVQcm92aWRlcicsIG50eXBlKTtcblxuICAgICAgICBpZiAoIW50eXBlKSB7XG4gICAgICAgICAgICBtZVtjbG9zZXN0UHJvdmlkZXJdID0gcHJvdmlkZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm92aWRlclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhbGtzIHVwIHRoZSB2ZG9tIHRyZWUgYW5kIHJldHVybnMgdGhlIGNsb3Nlc3QgdGhlbWUgZm91bmRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFRoZW1lKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0aGVtZU1hdGNoID0gJ25lby10aGVtZS0nLFxuICAgICAgICAgICAgbWFpblZpZXcsIHBhcmVudE5vZGVzO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtZS5jbHMgfHwgW10pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnN0YXJ0c1dpdGgodGhlbWVNYXRjaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFpblZpZXcgPSBtZS5hcHA/Lm1haW5WaWV3O1xuXG4gICAgICAgIGlmIChtYWluVmlldykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZXMgPSBWRG9tVXRpbC5nZXRQYXJlbnROb2RlcyhtYWluVmlldy52ZG9tLCBtZS5pZCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBwYXJlbnROb2RlcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLmNscyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydHNXaXRoKHRoZW1lTWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5jb25maWcudGhlbWVzPy5bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggYSB2ZG9tIGNoaWxkIG5vZGUgYnkgaWQgZm9yIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb209dGhpcy52ZG9tXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWZG9tQ2hpbGQoaWQsIHZkb209dGhpcy52ZG9tKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kKHZkb20sIGlkKT8udmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdmRvbSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWbm9kZVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZkb20gcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2bm9kZSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWZG9tUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdm5vZGUgcm9vdFxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiB1cGRhdGVEZXB0aCAmIGRpc3RhbmNlIHdvdWxkIHJlc3VsdCBpbiBhbiB1cGRhdGUgY29sbGlzaW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVwZGF0ZURlcHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzVXBkYXRlQ29sbGlzaW9uKHVwZGF0ZURlcHRoLCBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVwdGggPT09IC0xID8gdHJ1ZSA6IGRpc3RhbmNlIDwgdXBkYXRlRGVwdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBjb21wb25lbnQuXG4gICAgICogaGlkZU1vZGU6ICdyZW1vdmVEb20nICB1c2VzIHZkb20gcmVtb3ZlRG9tLlxuICAgICAqIGhpZGVNb2RlOiAndmlzaWJpbGl0eScgdXNlcyBjc3MgdmlzaWJpbGl0eS5cbiAgICAgKiBJZiBoaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScgeW91IGNhbiBwYXNzIGEgdGltZW91dCBmb3IgY3VzdG9tIGNzcyBjbGFzcyBoaWRpbmcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAgICAgKi9cbiAgICBoaWRlKHRpbWVvdXQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGlkZU1vZGUgIT09ICd2aXNpYmlsaXR5Jykge1xuICAgICAgICAgICAgbGV0IHJlbW92ZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChtZS5wYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudW5tb3VudCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQodGltZW91dCkudGhlbihyZW1vdmVGbilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRm4oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gbWUuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBtZS5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuX2hpZGRlbiA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuYXV0b1JlbmRlciAmJiB0aGlzLnJlbmRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgYXJlIHVzaW5nIHRoaXMgbWV0aG9kIGFzIGEgY3RvciBob29rIGhlcmUgdG8gYWRkIHRoZSBpbml0aWFsIHN0YXRlLlByb3ZpZGVyICYgY29udHJvbGxlci5Db21wb25lbnQgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50T3JpZ2luYWxDb25maWddIFRydWUgcHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gZ2V0dGluZyBhbiBvcmlnaW5hbENvbmZpZyBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGluaXRDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgc3VwZXIuaW5pdENvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5nZXRDb250cm9sbGVyKCkgICA/LnBhcnNlQ29uZmlnKG1lKTtcbiAgICAgICAgbWUuZ2V0U3RhdGVQcm92aWRlcigpPy5wYXJzZUNvbmZpZyhtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIHZkb20gdXBkYXRlcyBpbnNpZGUgdGhlIHBhcmVudCBjaGFpbiBhbmQgaWYgZm91bmQuXG4gICAgICogUmVnaXN0ZXJzIHRoZSBjb21wb25lbnQgZm9yIGEgdmRvbSB1cGRhdGUgb25jZSBkb25lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRJZD10aGlzLnBhcmVudElkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdIEdldHMgcGFzc2VkIGJ5IHVwZGF0ZVZkb20oKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZT0xIERpc3RhbmNlIGluc2lkZSB0aGUgY29tcG9uZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1BhcmVudFVwZGF0aW5nKHBhcmVudElkPXRoaXMucGFyZW50SWQsIHJlc29sdmUsIGRpc3RhbmNlPTEpIHtcbiAgICAgICAgaWYgKHBhcmVudElkICE9PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5pc1Zkb21VcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWUuaGFzVXBkYXRlQ29sbGlzaW9uKHBhcmVudC5jdXJyZW50VXBkYXRlRGVwdGgsIGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5jb25maWcubG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3Zkb20gcGFyZW50IHVwZGF0ZSBjb25mbGljdCB3aXRoOicsIHBhcmVudCwgJ2ZvcjonLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkVXBkYXRlQ2FjaGVbbWUuaWRdID0ge2Rpc3RhbmNlLCByZXNvbHZlfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSByZXNvbHZlIGZuIHRvIGl0cyBvd24gY2FjaGUsIHNpbmNlIHRoZSBwYXJlbnQgd2lsbCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIG5ldyB1cGRhdGUoKSBkaXJlY3RseSBvbiB0aGlzIGNtcFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSAmJiBtZS5yZXNvbHZlVXBkYXRlQ2FjaGUucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbiB1cGRhdGUgaXMgcnVubmluZyBhbmQgZG9lcyBub3QgaGF2ZSBhIGNvbGxpc2lvbiwgd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgZnVydGhlciBwYXJlbnRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtZS5pc1BhcmVudFVwZGF0aW5nKHBhcmVudC5wYXJlbnRJZCwgcmVzb2x2ZSwgZGlzdGFuY2UrMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgICAqL1xuICAgIGFzeW5jIG1lYXN1cmUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5lbmRzV2l0aCgncHgnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoUkUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQge2lkLCB3aW5kb3dJZH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLm1lYXN1cmUoe2lkLCB2YWx1ZSwgd2luZG93SWR9KVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBvcmRlciBjb25maWdzIGFyZSBhcHBsaWVkIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRPcmlnaW5hbENvbmZpZ10gVHJ1ZSBwcmV2ZW50cyB0aGUgaW5zdGFuY2UgZnJvbSBnZXR0aW5nIGFuIG9yaWdpbmFsQ29uZmlnIHByb3BlcnR5XG4gICAgICogQHJldHVybnMge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgbWVyZ2VDb25maWcoLi4uYXJncykge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyA9IHN1cGVyLm1lcmdlQ29uZmlnKC4uLmFyZ3MpLFxuXG4gICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gc2V0IGN1c3RvbSBjb25maWdzIGZvciB0aGUgdmRvbSBvbiBpbnN0YW5jZSBsZXZlbCxcbiAgICAgICAgICAgIC8vIGhvd2V2ZXIgdGhlcmUgd2lsbCBiZSBhbHJlYWR5IGFkZGVkIGF0dHJpYnV0ZXMgKGUuZy4gaWQpLCBzbyBhIG1lcmdlIHNlZW1zIHRvIGJlIHRoZSBiZXN0IHN0cmF0ZWd5LlxuICAgICAgICAgICAgdmRvbSA9IHsuLi5tZS5fdmRvbSB8fCB7fSwgLi4uY29uZmlnLnZkb20gfHwge319O1xuXG4gICAgICAgIC8vIGF2b2lkIGFueSBpbnRlcmZlcmVuY2Ugb24gcHJvdG90eXBlIGxldmVsXG4gICAgICAgIC8vIGRvZXMgbm90IGNsb25lIGV4aXN0aW5nIE5lbyBpbnN0YW5jZXNcbiAgICAgICAgbWUuX3Zkb20gPSBOZW8uY2xvbmUodmRvbSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHBhc3NlZCBhbiBvYmplY3QsIG1lcmdlIGl0IHdpdGggdGhlIGNsYXNzJ3Mgb3duIHN0eWxlXG4gICAgICAgICAgICBtZS5zdHlsZSA9IE5lby50eXBlT2YoY29uZmlnLnN0eWxlKSA9PT0gJ09iamVjdCcgPyB7Li4uY29uZmlnLnN0eWxlLCAuLi5tZS5jb25zdHJ1Y3Rvci5jb25maWcuc3R5bGV9IDogY29uZmlnLnN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICBtZS53cmFwcGVyU3R5bGUgPSBOZW8uY2xvbmUoY29uZmlnLndyYXBwZXJTdHlsZSwgZmFsc2UpO1xuXG4gICAgICAgIGRlbGV0ZSBjb25maWcuc3R5bGU7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX3Zkb207XG4gICAgICAgIGRlbGV0ZSBjb25maWcudmRvbTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy53cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbiBnZXQgY2FsbGVkIGFmdGVyIHRoZSBjb21wb25lbnQgZ290IHJlbmRlcmVkLiBTZWUgdGhlIGF1dG9Nb3VudCBjb25maWcgYXMgd2VsbC5cbiAgICAgKi9cbiAgICBhc3luYyBtb3VudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGNoaWxkLCBjaGlsZElkcztcblxuICAgICAgICBpZiAoIW1lLnZub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCB2bm9kZSBtdXN0IGJlIGdlbmVyYXRlZCBiZWZvcmUgbW91bnRpbmcsIHVzZSBDb21wb25lbnQucmVuZGVyKCknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIGNhc2UgdGhlIGNvbXBvbmVudCB3YXMgYWxyZWFkeSBtb3VudGVkLCBnb3QgdW5tb3VudGVkIGFuZCByZWNlaXZlZCB2ZG9tIGNoYW5nZXMgYWZ0ZXJ3YXJkcyxcbiAgICAgICAgLy8gYSBuZXcgcmVuZGVyKCkgY2FsbCBpcyBtYW5kYXRvcnkgc2luY2UgZGVsdGEgdXBkYXRlcyBjb3VsZCBub3QgZ2V0IGFwcGxpZWQuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2xlYXIgdGhlIGhhc1VubW91bnRlZFZkb21DaGFuZ2VzIHN0YXRlIGZvciBhbGwgY2hpbGQgY29tcG9uZW50c1xuICAgICAgICBpZiAobWUuaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMpIHtcbiAgICAgICAgICAgIC8vIHRvZG86IHRoZSBoYXNVbm1vdW50ZWRWZG9tQ2hhbmdlcyBmbGFnIGNoYW5nZXMgc2hvdWxkIGhhcHBlbiBvbiByZW5kZXJcbiAgICAgICAgICAgIG1lLmhhc1VubW91bnRlZFZkb21DaGFuZ2VzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNoaWxkSWRzID0gQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZElkcyhtZS52bm9kZSk7XG5cbiAgICAgICAgICAgIGNoaWxkSWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gTmVvLmdldENvbXBvbmVudChpZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX2hhc1VubW91bnRlZFZkb21DaGFuZ2VzID0gZmFsc2U7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVuZCB0b2RvXG5cbiAgICAgICAgICAgIG1lLnJlbmRlcih0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgY3VycmVudFdvcmtlci5wcm9taXNlTWVzc2FnZSgnbWFpbicsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gICAgIDogJ21vdW50RG9tJyxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBpZCAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgaHRtbCAgICAgICA6IG1lLnZub2RlLm91dGVySFRNTCxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCAgIDogbWUuZ2V0TW91bnRlZFBhcmVudElkKCksXG4gICAgICAgICAgICAgICAgcGFyZW50SW5kZXg6IG1lLmdldE1vdW50ZWRQYXJlbnRJbmRleCgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVsZXRlIG1lLnZkb20ucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTtcblxuICAgICAgICAgICAgbWUubW91bnRlZCA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgbmVlZHNWZG9tVXBkYXRlIGNvbmZpZyBpbnNpZGUgdGhlIHBhcmVudCB0cmVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudElkPXRoaXMucGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV0gZ2V0cyBwYXNzZWQgYnkgdXBkYXRlVmRvbSgpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlPTEgRGlzdGFuY2UgaW5zaWRlIHRoZSBjb21wb25lbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIG5lZWRzUGFyZW50VXBkYXRlKHBhcmVudElkPXRoaXMucGFyZW50SWQsIHJlc29sdmUsIGRpc3RhbmNlPTEpIHtcbiAgICAgICAgaWYgKHBhcmVudElkICE9PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IE5lby5nZXRDb21wb25lbnQocGFyZW50SWQpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGNoZWNraW5nIGZvciBwYXJlbnQudXBkYXRlRGVwdGgsIHNpbmNlIHdlIGNhcmUgYWJvdXQgdGhlIGRlcHRoIG9mIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubmVlZHNWZG9tVXBkYXRlICYmIG1lLmhhc1VwZGF0ZUNvbGxpc2lvbihwYXJlbnQudXBkYXRlRGVwdGgsIGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVzb2x2ZVVwZGF0ZUNhY2hlLnB1c2goLi4ubWUucmVzb2x2ZVVwZGF0ZUNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSAmJiBwYXJlbnQucmVzb2x2ZVVwZGF0ZUNhY2hlLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlc29sdmVVcGRhdGVDYWNoZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBtZS5uZWVkc1BhcmVudFVwZGF0ZShwYXJlbnQucGFyZW50SWQsIHJlc29sdmUsIGRpc3RhbmNlKzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgdGhpcy5rZXlzPy5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Gb2N1c0VudGVyKGRhdGEpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGhpZGRlbiwgb3IgdW5tb3VudGVkIHdoaWxlIHdlIHN0aWxsIGNvbnRhaW4gZm9jdXMsIHdlIGhhdmUgdG8gcmV2ZXJ0XG4gICAgICAgIC8vIGZvY3VzIHRvIHdoZXJlIGl0IGNhbWUgZnJvbSBpZiBwb3NzaWJsZVxuICAgICAgICB0aGlzLmZvY3VzRW50ZXJEYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZm9jdXNFbnRlckRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBtYW5hZ2VyLkZvY3VzXG4gICAgICogQG5hbWUgb25Gb2N1c0VudGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJ5IG1hbmFnZXIuRm9jdXNcbiAgICAgKiBAbmFtZSBvbkZvY3VzTGVhdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgbWFuYWdlci5Gb2N1c1xuICAgICAqIEBuYW1lIG9uRm9jdXNNb3ZlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5uZXdQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gIG9wdHMub2xkUGF0aCBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgZnJvbSB0aGUgcmVuZGVyKCkgcHJvbWlzZSBzdWNjZXNzIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXV0b01vdW50IE1vdW50IHRoZSBET00gYWZ0ZXIgdGhlIHZub2RlIGdvdCBjcmVhdGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUmVuZGVyKGRhdGEsIGF1dG9Nb3VudCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcH0gPSBtZTtcblxuICAgICAgICBtZS5yZW5kZXJpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBpZiBhcHAgaXMgYSBjaGVjayB0byBzZWUgaWYgdGhlIENvbXBvbmVudCBnb3QgZGVzdHJveWVkIHdoaWxlIHJlbmRlcmluZyA9PiBiZWZvcmUgb25SZW5kZXIgZ290IHRyaWdnZXJlZFxuICAgICAgICBpZiAoYXBwKSB7XG4gICAgICAgICAgICBpZiAoIWFwcC5yZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIGFwcC5yZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcHAucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFwcC5maXJlKCdyZW5kZXInKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS52bm9kZSA9IGRhdGE7XG5cbiAgICAgICAgICAgIGxldCBjaGlsZElkcyA9IENvbXBvbmVudE1hbmFnZXIuZ2V0Q2hpbGRJZHMoZGF0YSksXG4gICAgICAgICAgICAgICAgaSAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgID0gY2hpbGRJZHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNoaWxkO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBOZW8uZ2V0Q29tcG9uZW50KGNoaWxkSWRzW2ldKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZW5kZXJlZCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLl9yZW5kZXJlZCA9IHRydWU7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgICAgIG1lLmZpcmUoJ3JlbmRlcmVkJywgbWUuaWQpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVuZGVyZWQ6ICcgKyBtZS5hcHBOYW1lICsgJyAnICsgbWUuaWQsIG1lKTtcblxuICAgICAgICAgICAgaWYgKGF1dG9Nb3VudCkge1xuICAgICAgICAgICAgICAgIG1lLm1vdW50ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhcHAubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhcHAubW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5maXJlKCdtb3VudGVkJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9taXNlIGJhc2VkIHZkb20gdXBkYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb209dGhpcy52ZG9tXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gdm5vZGU9IHRoaXMudm5vZGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHByb21pc2VVcGRhdGUodmRvbT10aGlzLnZkb20sIHZub2RlPXRoaXMudm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmRvbSh2ZG9tLCB2bm9kZSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNscyBmcm9tIHRoZSB2ZG9tUm9vdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHJlbW92ZUNscyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgdmFsdWUpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSB2YWx1ZVxuICAgICAqL1xuICAgIHJlbW92ZURvbUxpc3RlbmVycyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2RvbUxpc3RlbmVyc30gPSBtZSxcbiAgICAgICAgICAgIGksIGxlbjtcblxuICAgICAgICB2YWx1ZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICBsZW4gPSBkb21MaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc0VxdWFsKGl0ZW0sIGRvbUxpc3RlbmVyc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIHN0cmluZyBsaWtlICdjb2xvcicgb3IgYW4gYXJyYXkgY29udGFpbmluZyBzdHlsZSBhdHRyaWJ1dGVzIHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB2YWx1ZSBjYW1lbENhc2Ugb25seVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFsbCBzdHlsZXMgb2YgdGhpcy5lbFxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHtzdHlsZX0gID0gdGhpcyxcbiAgICAgICAgICAgIGRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICAgICAgICAgICAgICAgIGRvVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgdm5vZGUgdHJlZSBmb3IgdGhpcyBjb21wb25lbnQgYW5kIG1vdW50cyB0aGUgY29tcG9uZW50IGluIGNhc2VcbiAgICAgKiAtIHlvdSBwYXNzIHRydWUgZm9yIHRoZSBtb3VudCBwYXJhbVxuICAgICAqIC0gb3IgdGhlIGF1dG9Nb3VudCBjb25maWcgaXMgc2V0IHRvIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttb3VudF0gTW91bnQgdGhlIERPTSBhZnRlciB0aGUgdm5vZGUgZ290IGNyZWF0ZWRcbiAgICAgKi9cbiAgICBhc3luYyByZW5kZXIobW91bnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhdXRvTW91bnQgICAgICAgPSBtb3VudCB8fCBtZS5hdXRvTW91bnQsXG4gICAgICAgICAgICB7YXBwfSAgICAgICAgICAgPSBtZSxcbiAgICAgICAgICAgIHt1c2VWZG9tV29ya2VyfSA9IE5lby5jb25maWc7XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNyaXRpY2FsIHJlbmRlcmluZyBwYXRoID0+IENTUyBmaWxlcyBmb3IgdGhlIG5ldyB0cmVlIGlzIGluIHBsYWNlXG4gICAgICAgIGlmIChjdXJyZW50V29ya2VyLmNvdW50TG9hZGluZ1RoZW1lRmlsZXMgIT09IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIub24oJ3RoZW1lRmlsZXNMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtZS5yZW5kZXIobW91bnQpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KTtcblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5yZW5kZXJpbmcgPSB0cnVlO1xuXG4gICAgICAgIGlmICghYXBwLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICBhcHAucmVuZGVyaW5nID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLnZkb20pIHtcbiAgICAgICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVsZXRlIG1lLnZkb20ucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICBtZS5fbmVlZHNWZG9tVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBtZS5hZnRlclNldE5lZWRzVmRvbVVwZGF0ZT8uKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IE5lby52ZG9tLkhlbHBlci5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGF1dG9Nb3VudCxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCAgIDogYXV0b01vdW50ID8gbWUuZ2V0TW91bnRlZFBhcmVudElkKCkgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcGFyZW50SW5kZXg6IGF1dG9Nb3VudCA/IG1lLmdldE1vdW50ZWRQYXJlbnRJbmRleCgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAuLi5Db21wb25lbnRNYW5hZ2VyLmdldFZkb21UcmVlKG1lLnZkb20pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUub25SZW5kZXIoZGF0YSwgdXNlVmRvbVdvcmtlciA/IGF1dG9Nb3VudCA6IGZhbHNlKTtcbiAgICAgICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGF1dG9Nb3VudCAmJiAhdXNlVmRvbVdvcmtlciAmJiBtZS5tb3VudCgpO1xuXG4gICAgICAgICAgICBtZS5yZXNvbHZlVmRvbVVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZm4gdG8gcmVzb2x2ZSB0aGUgUHJvbWlzZSBmb3IgdXBkYXRlVmRvbSgpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnx1bmRlZmluZWR9IHJlc29sdmVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVzb2x2ZVZkb21VcGRhdGUocmVzb2x2ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNDaGlsZFVwZGF0ZUNhY2hlID0gIU5lby5pc0VtcHR5KG1lLmNoaWxkVXBkYXRlQ2FjaGUpLFxuICAgICAgICAgICAgY29tcG9uZW50O1xuXG4gICAgICAgIG1lLmRvUmVzb2x2ZVVwZGF0ZUNhY2hlKCk7XG5cbiAgICAgICAgcmVzb2x2ZT8uKCk7XG5cbiAgICAgICAgaWYgKG1lLm5lZWRzVmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGhhc0NoaWxkVXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhtZS5jaGlsZFVwZGF0ZUNhY2hlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gTmVvLmdldENvbXBvbmVudChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb21wb25lbnQgbWlnaHQgYWxyZWFkeSBnb3QgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgY2FsbGJhY2tzIHRvIHRoZSByZXNvbHZlciBjYWNoZSA9PiBnZXR0aW5nIGV4ZWN1dGVkIG9uY2UgdGhlIGZvbGxvd2luZyB1cGRhdGUgaXMgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVzb2x2ZSAmJiBOZW9BcnJheS5hZGQobWUucmVzb2x2ZVVwZGF0ZUNhY2hlLCB2YWx1ZS5yZXNvbHZlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSB1cGRhdGVEZXB0aCB0byBpbmNsdWRlIHRoZSBkZXB0aCBvZiBhbGwgbWVyZ2VkIGNoaWxkIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZS51cGRhdGVEZXB0aCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnVwZGF0ZURlcHRoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVEZXB0aCA9IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdXBkYXRlRGVwdGggaXMgMS1iYXNlZCwgd2UgbmVlZCB0byBzdWJ0cmFjdCAxIGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gbWUudXBkYXRlRGVwdGggKyB2YWx1ZS5kaXN0YW5jZSArIGNvbXBvbmVudC51cGRhdGVEZXB0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLmNoaWxkVXBkYXRlQ2FjaGUgPSB7fVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9IGVsc2UgaWYgKGhhc0NoaWxkVXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1lLmNoaWxkVXBkYXRlQ2FjaGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KGtleSk/LnVwZGF0ZSgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuY2hpbGRVcGRhdGVDYWNoZSA9IHt9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJldmVydEZvY3VzKCkge1xuICAgICAgICBsZXQgcmVsYXRlZFRhcmdldCA9IHRoaXMuZm9jdXNFbnRlckRhdGE/LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNGb2N1cyAmJiByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KHJlbGF0ZWRUYXJnZXQuaWQpPy5mb2N1cygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgbXVsdGlwbGUgY29uZmlncyBhdCBvbmNlLCBlbnN1cmluZyB0aGF0IGFsbCBhZnRlclNldCBtZXRob2RzIGdldCBhbGwgbmV3IGFzc2lnbmVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gICAgICovXG4gICAgc2V0KHZhbHVlcz17fSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBuZWVkc1JlbmRlcmluZyA9IHZhbHVlcy5oaWRkZW4gPT09IGZhbHNlICYmIHZhbHVlcy5oaWRkZW4gIT09IG1lLmhpZGRlbjtcblxuICAgICAgICBtZS5zaWxlbnRWZG9tVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICBzdXBlci5zZXQodmFsdWVzKTtcblxuICAgICAgICBtZS5zaWxlbnRWZG9tVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNpbGVudCB8fCAhbWUubmVlZHNWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZWVkc1JlbmRlcmluZykge1xuICAgICAgICAgICAgICAgIG1lLnNob3coKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1lLnByb21pc2VVcGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgY2FsbGluZyBzZXQoKSB3aXRoIHRoZSBzaWxlbnQgZmxhZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKi9cbiAgICBzZXRTaWxlbnQodmFsdWVzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHZhbHVlcywgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgc2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5zZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgY29tcG9uZW50LlxuICAgICAqIGhpZGVNb2RlOiAncmVtb3ZlRG9tJyAgdXNlcyB2ZG9tIHJlbW92ZURvbS5cbiAgICAgKiBoaWRlTW9kZTogJ3Zpc2liaWxpdHknIHVzZXMgY3NzIHZpc2liaWxpdHkuXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGlkZU1vZGUgIT09ICd2aXNpYmlsaXR5Jykge1xuICAgICAgICAgICAgZGVsZXRlIG1lLnZkb20ucmVtb3ZlRG9tO1xuXG4gICAgICAgICAgICBpZiAobWUuc2lsZW50VmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIG1lLm5lZWRzVmRvbVVwZGF0ZSA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWUucGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgICAgIG1lLnBhcmVudC51cGRhdGVEZXB0aCA9IDI7XG4gICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICFtZS5tb3VudGVkICYmIG1lLnJlbmRlcih0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gbWUuc3R5bGU7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGUudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIG1lLnN0eWxlID0gc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLl9oaWRkZW4gPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIG1ldGhvZCBmb3IgdXRpbC5WRG9tLnN5bmNWZG9tSWRzIHRvIGFsbG93IG92ZXJyaWRpbmcgKGRpc2FibGluZykgaXRcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBbdm5vZGU9dGhpcy52bm9kZV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Zkb209dGhpcy52ZG9tXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2U9ZmFsc2VcbiAgICAgKi9cbiAgICBzeW5jVmRvbUlkcyh2bm9kZT10aGlzLnZub2RlLCB2ZG9tPXRoaXMudmRvbSwgZm9yY2U9ZmFsc2UpIHtcbiAgICAgICAgVkRvbVV0aWwuc3luY1Zkb21JZHModm5vZGUsIHZkb20sIGZvcmNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgYSBjb21wb25lbnQgcmVjZWl2ZXMgYSBuZXcgdm5vZGUsIHdlIHdhbnQgdG8gZG86XG4gICAgICogLSBzeW5jIHRoZSB2ZG9tIGlkc1xuICAgICAqIC0gc2V0dGluZyByZW5kZXJlZCB0byB0cnVlIGZvciBjaGlsZCBjb21wb25lbnRzXG4gICAgICogLSB1cGRhdGluZyB0aGUgcGFyZW50IGNvbXBvbmVudCB0byBlbnN1cmUgdGhhdCB0aGUgdm5vZGUgdHJlZSBzdGF5cyBwZXJzaXN0ZW50XG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gW3Zub2RlPXRoaXMudm5vZGVdXG4gICAgICovXG4gICAgc3luY1Zub2RlVHJlZSh2bm9kZT10aGlzLnZub2RlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2hpbGRDb21wb25lbnRzID0gQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZHJlbihtZSksXG4gICAgICAgICAgICBkZWJ1ZyAgICAgICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIG1hcCAgICAgICAgICAgICA9IHt9LFxuICAgICAgICAgICAgY2hpbGRWbm9kZSwgc3RhcnQ7XG5cbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIH1cblxuICAgICAgICBtZS5zeW5jVmRvbUlkcygpO1xuXG4gICAgICAgIGlmICh2bm9kZSAmJiBtZS5pZCAhPT0gdm5vZGUuaWQpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXJXcmFwcGVyTm9kZSh2bm9kZS5pZCwgbWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBuZWVkIG9uZSBzZXBhcmF0ZSBpdGVyYXRpb24gZmlyc3QgdG8gZW5zdXJlIGFsbCB3cmFwcGVyIG5vZGVzIGdldCByZWdpc3RlcmVkXG4gICAgICAgIGNoaWxkQ29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBjaGlsZFZub2RlID0gVk5vZGVVdGlsLmZpbmQobWUudm5vZGUsIGNvbXBvbmVudC52ZG9tLmlkKT8udm5vZGU7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZFZub2RlKSB7XG4gICAgICAgICAgICAgICAgbWFwW2NvbXBvbmVudC5pZF0gPSBjaGlsZFZub2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5pZCAhPT0gY2hpbGRWbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyV3JhcHBlck5vZGUoY2hpbGRWbm9kZS5pZCwgY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGVsZWdhdGUgdGhlIGxhdGVzdCBub2RlIHVwZGF0ZXMgdG8gYWxsIHBvc3NpYmxlIGNoaWxkIGNvbXBvbmVudHMgZm91bmQgaW5zaWRlIHRoZSB2bm9kZSB0cmVlXG4gICAgICAgIGNoaWxkQ29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBjaGlsZFZub2RlID0gbWFwW2NvbXBvbmVudC5pZF07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZFZub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5fdm5vZGUgPSBDb21wb25lbnRNYW5hZ2VyLmFkZFZub2RlQ29tcG9uZW50UmVmZXJlbmNlcyhjaGlsZFZub2RlLCBjb21wb25lbnQuaWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQucmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Ll9yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5maXJlKCdyZW5kZXJlZCcsIGNvbXBvbmVudC5pZClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQubW91bnRlZCA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzeW5jVm5vZGVUcmVlOiBDb3VsZCBub3QgcmVwbGFjZSB0aGUgY2hpbGQgdm5vZGUgZm9yJywgY29tcG9uZW50LmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgIG1lLl92bm9kZSA9IHZub2RlID8gQ29tcG9uZW50TWFuYWdlci5hZGRWbm9kZUNvbXBvbmVudFJlZmVyZW5jZXModm5vZGUsIG1lLmlkKSA6IG51bGw7XG5cbiAgICAgICAgZGVidWcgJiYgY29uc29sZS5sb2coJ3N5bmNWbm9kZVRyZWUnLCBtZS5pZCwgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgYSBjbHMgaW5zaWRlIHRoZSB2ZG9tUm9vdCBvZiB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWRkXSBVc2UgdGhpcyBwYXJhbSB0byBlbmZvcmNlIGFuIGFkZCgpIG9yIHJlbW92ZSgpIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICB0b2dnbGVDbHModmFsdWUsIGFkZCkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkudG9nZ2xlKGNscywgdmFsdWUsIGFkZCk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY29tcG9uZW50IERPTVxuICAgICAqL1xuICAgIHVubW91bnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmRvbS5yZW1vdmVEb20gPSB0cnVlO1xuXG4gICAgICAgIG1lLl9oaWRkZW4gPSB0cnVlOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgIG1lLm1vdW50ZWQgPSBmYWxzZTtcblxuICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwge2FjdGlvbjogJ3JlbW92ZU5vZGUnLCBpZDogbWUudmRvbS5pZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIE5lby5tYW5hZ2VyLkNvbXBvbmVudC51cFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29uZmlnXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBUaGUgbWF0Y2hpbmcgaW5zdGFuY2Ugb3IgbnVsbFxuICAgICAqL1xuICAgIHVwKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci51cCh0aGlzLmlkLCBjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuYWZ0ZXJTZXRWZG9tKHRoaXMudmRvbSwgbnVsbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWx0YSB1cGRhdGVzIGZvciB0aGUgY2xzIGNvbmZpZy4gR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGNscyBjb25maWcgZ2V0cyBjaGFuZ2VkIGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGNsc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZENsc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZD10aGlzLmlkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUNscyhjbHMsIG9sZENscywgaWQ9dGhpcy5pZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3Zub2RlfSAgICAgPSBtZSxcbiAgICAgICAgICAgIHZub2RlVGFyZ2V0ID0gdm5vZGUgJiYgVk5vZGVVdGlsLmZpbmQobWUudm5vZGUsIHtpZH0pPy52bm9kZTtcblxuICAgICAgICBpZiAodm5vZGUgJiYgIU5lby5pc0VxdWFsKGNscywgb2xkQ2xzKSkge1xuICAgICAgICAgICAgaWYgKHZub2RlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdm5vZGVUYXJnZXQuY2xhc3NOYW1lID0gY2xzOyAvLyBrZWVwIHRoZSB2bm9kZSBpbiBzeW5jXG4gICAgICAgICAgICAgICAgbWUudm5vZGUgPSB2bm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTmVvLmFwcGx5RGVsdGFzKG1lLmFwcE5hbWUsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBjbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkICAgOiBOZW9BcnJheS5kaWZmZXJlbmNlKGNscywgb2xkQ2xzKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlOiBOZW9BcnJheS5kaWZmZXJlbmNlKG9sZENscywgY2xzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBzdHlsZSBkZWx0YXMgZm9yIG5ld1ZhbHVlICYgb2xkVmFsdWUgYW5kIGFwcGxpZXMgdGhlbSBkaXJlY3RseSB0byB0aGUgRE9NLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtpZD10aGlzLmlkXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVTdHlsZSh2YWx1ZSwgb2xkVmFsdWUsIGlkPXRoaXMuaWQpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRlbHRhID0gU3R5bGUuY29tcGFyZVN0eWxlcyh2YWx1ZSwgb2xkVmFsdWUpLFxuICAgICAgICAgICAgb3B0cywgdmRvbSwgdm5vZGUsIHZub2RlU3R5bGU7XG5cbiAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICB2ZG9tICA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgaWQpO1xuICAgICAgICAgICAgdm5vZGUgPSBtZS52bm9kZSAmJiBWTm9kZVV0aWwuZmluZChtZS52bm9kZSwgaWQpO1xuXG4gICAgICAgICAgICBpZiAoIW1lLmhhc1VubW91bnRlZFZkb21DaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgPSAhbWUubW91bnRlZCAmJiBtZS5oYXNCZWVuTW91bnRlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZG9tLnZkb20uc3R5bGUgPSB2YWx1ZTsgLy8ga2VlcCB0aGUgdmRvbSBpbiBzeW5jXG5cbiAgICAgICAgICAgIGlmIChtZS5zaWxlbnRWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVTdHlsZSA9IHZub2RlLnZub2RlLnN0eWxlO1xuXG4gICAgICAgICAgICAgICAgLy8ga2VlcCB0aGUgdm5vZGUgaW4gc3luY1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhlIGl0ZXJhdGlvbiBzaW5jZSB2ZG9tIHNob3J0Y3V0cyAoaGVpZ2h0LCB3aWR0aCwuLi4pIGxpdmUgd2l0aGluIHRoZSB2bm9kZSBzdHlsZVxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHZub2RlLnZub2RlLnN0eWxlID0gc3R5bGUgd291bGQgbG9zZSB0aGVtLlxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRlbHRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdm5vZGUudm5vZGUuc3R5bGVba2V5XVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGVTdHlsZVtrZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAndXBkYXRlRG9tJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFzOiBbe2lkLCBzdHlsZTogZGVsdGF9XVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFdvcmtlci5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmFwcE5hbWUgPSBtZS5hcHBOYW1lXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudFdvcmtlci5zZW5kTWVzc2FnZSgnbWFpbicsIG9wdHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgdmRvbSBjb25maWcgZ2V0cyBjaGFuZ2VkIGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBhbHJlYWR5IG1vdW50ZWQgKGRlbHRhIHVwZGF0ZXMpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tPXRoaXMudmRvbVxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IHZub2RlPXRoaXMudm5vZGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVzb2x2ZV0gdXNlZCBieSBwcm9taXNlVXBkYXRlKClcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVqZWN0XSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVWZG9tKHZkb209dGhpcy52ZG9tLCB2bm9kZT10aGlzLnZub2RlLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwLCBtb3VudGVkLCBwYXJlbnRJZH0gPSBtZSxcbiAgICAgICAgICAgIGxpc3RlbmVySWQ7XG5cbiAgICAgICAgaWYgKG1lLmlzVmRvbVVwZGF0aW5nIHx8IG1lLnNpbGVudFZkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUgJiYgbWUucmVzb2x2ZVVwZGF0ZUNhY2hlLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgICBtZS5uZWVkc1Zkb21VcGRhdGUgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW1vdW50ZWQgJiYgbWUuaXNDb25zdHJ1Y3RlZCAmJiAhbWUuaGFzUmVuZGVyaW5nTGlzdGVuZXIgJiYgYXBwPy5yZW5kZXJpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBtZS5oYXNSZW5kZXJpbmdMaXN0ZW5lciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcklkID0gYXBwLm9uKCdtb3VudGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhcHAudW4oJ21vdW50ZWQnLCBsaXN0ZW5lcklkKTtcblxuICAgICAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnZub2RlICYmIG1lLnVwZGF0ZVZkb20obWUudmRvbSwgbWUudm5vZGUsIHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZSAmJiAoIW1vdW50ZWQgfHwgIXZub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5yZXNvbHZlVXBkYXRlQ2FjaGUucHVzaChyZXNvbHZlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIW1lLm5lZWRzUGFyZW50VXBkYXRlKHBhcmVudElkLCByZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAmJiAhbWUuaXNQYXJlbnRVcGRhdGluZyhwYXJlbnRJZCwgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgJiYgbW91bnRlZFxuICAgICAgICAgICAgICAgICAgICAmJiB2bm9kZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY3JpdGljYWwgcmVuZGVyaW5nIHBhdGggPT4gQ1NTIGZpbGVzIGZvciB0aGUgbmV3IHRyZWUgaXMgaW4gcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRXb3JrZXIuY291bnRMb2FkaW5nVGhlbWVGaWxlcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFdvcmtlci5vbigndGhlbWVGaWxlc0xvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZVZkb20odmRvbSwgdm5vZGUsIHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS4jZXhlY3V0ZVZkb21VcGRhdGUodmRvbSwgdm5vZGUsIHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmhhc1VubW91bnRlZFZkb21DaGFuZ2VzID0gIW1vdW50ZWQgJiYgbWUuaGFzQmVlbk1vdW50ZWRcbiAgICB9XG59XG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgYWZ0ZXIgZm9jdXNFbnRlciwgZm9jdXNMZWF2ZSBvciBmb2N1c01vdmVcbiAqIEBldmVudCBmb2N1c0NoYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0W119IFtkYXRhLnBhdGhdIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBbZGF0YS5vbGRQYXRoXSBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICovXG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlkIGlzIGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGhcbiAqIEBldmVudCBmb2N1c0VudGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgbm90IGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGhcbiAqIEBldmVudCBmb2N1c0xlYXZlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgaW5jbHVkZWQgaW5zaWRlIHRoZSBkb20gaWQgcGF0aCwgYnV0IHRoZSBwYXRoIGl0c2VsZiBjaGFuZ2VkXG4gKiBAZXZlbnQgZm9jdXNNb3ZlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuS2V5TmF2aWdhdGlvblxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBLZXlOYXZpZ2F0aW9uIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5LZXlOYXZpZ2F0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5LZXlOYXZpZ2F0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2tleW5hdidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdrZXluYXYnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWxseSBzdG9yZXMgdGhlIGNvbXBvbmVudCBpZCBpbnNpZGUgX2NvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpbiBjYXNlIHRoZSBrZXlkb3duIGV2ZW50IGlzIHN1cHBvc2VkIHRvIGJ1YmJsZSB1cHdhcmRzIGluc2lkZSB0aGUgY29tcG9uZW50IHRyZWVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0ga2V5RG93bkV2ZW50QnViYmxlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBrZXlEb3duRXZlbnRCdWJibGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0ga2V5c189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAga2V5c186IG51bGxcbiAgICB9XG5cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fa2V5cy5wdXNoKC4uLnRoaXMucGFyc2VLZXlzKHZhbHVlKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuX2NvbXBvbmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGNvbXBvbmVudCBpZFxuICAgICAqL1xuICAgIGJlZm9yZVNldENvbXBvbmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU/LmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd24oZGF0YSkge1xuICAgICAgICAvLyBVc2luZyB0aGUgY2hyb21lIGF1dG8tZmlsbCBmZWF0dXJlIGRvZXMgdHJpZ2dlciBhIGtleWRvd24gZXZlbnQsIG5vdCBjb250YWluaW5nIGEga2V5LiBTZWU6ICM2NFxuICAgICAgICBpZiAoZGF0YS5rZXkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHVwcGVyQ2FzZUtleSA9IGRhdGEua2V5LnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgc2NvcGU7XG5cbiAgICAgICAgICAgIHVwcGVyQ2FzZUtleSA9IG1lLnBhcnNlVXBwZXJDYXNlS2V5KHVwcGVyQ2FzZUtleSk7XG5cbiAgICAgICAgICAgIG1lLmtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gTmVvLmlzU3RyaW5nKGtleS5zY29wZSkgPyBOZW8uZ2V0KGtleS5zY29wZSkgOiBrZXkuc2NvcGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LmtleS50b1VwcGVyQ2FzZSgpID09PSB1cHBlckNhc2VLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKGtleS5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5mbi5hcHBseShzY29wZSwgW2RhdGEsIG1lLmNvbXBvbmVudF0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtrZXkuZm5dPy5hcHBseShzY29wZSwgW2RhdGEsIG1lLmNvbXBvbmVudF0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZUtleXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudElkID0gdGhpcy5fY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGtleUFycmF5ICAgID0gW107XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCB2YWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdzY29wZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUFycmF5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuICAgOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiB2YWx1ZS5zY29wZSB8fCBjb21wb25lbnRJZCAvLyB0b2RvOiBzdXBwb3J0IFZDcyBsYXRlciBvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBrZXlBcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgc3BlY2lmaWMga2V5IG5hbWVzLCBlLmcuIFwiIFwiID0+IFNQQUNFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHBhcnNlVXBwZXJDYXNlS2V5KGtleSkge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ1NQQUNFJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVJST1dET1dOJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnRE9XTic7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FSUk9XTEVGVCc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ0xFRlQnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV1JJR0hUJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnUklHSFQnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV1VQJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnVVAnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgbWUua2V5cyAgICAgID0gbWUucGFyc2VLZXlzKG1lLmtleXMpO1xuXG4gICAgICAgIGNvbXBvbmVudC5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAga2V5ZG93bjoge1xuICAgICAgICAgICAgICAgIGJ1YmJsZTogbWUua2V5RG93bkV2ZW50QnViYmxlLFxuICAgICAgICAgICAgICAgIGZuICAgIDogbWUub25LZXlEb3duLFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBrZXkgbGlzdGVuZXIgdXNpbmcgdGhlIHNhbWUgY29uZmlnIHVzZWQgd2hlbiBjcmVhdGluZyBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICByZW1vdmVLZXkoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleXMgPSBtZS5fa2V5cyxcbiAgICAgICAgICAgIGkgICAgPSAwLFxuICAgICAgICAgICAgbGVuICA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNFcXVhbChrZXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG11bHRpcGxlIGtleSBsaXN0ZW5lcnMgcGFzc2luZyBhbiBhcnJheSBvZiBjb25maWcgaXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICAgICAqL1xuICAgIHJlbW92ZUtleXMoaXRlbXMpIHtcbiAgICAgICAgQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMuZm9yRWFjaChpdGVtID0+IHRoaXMucmVtb3ZlS2V5KGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoZSBkb20gbGlzdGVuZXIgZnJvbSB0aGUgb3duZXIgY29tcG9uZW50XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhLZXlOYXZpZ2F0aW9uKTtcbiIsIi8qKlxuICogVGhlIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIERPTVJlY3QgT2JqZWN0c1xuICogQGNsYXNzIE5lby51dGlsLlJlY3RhbmdsZVxuICogQGV4dGVuZHMgRE9NUmVjdFxuICovXG5cbmNvbnN0XG4gICAgZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUoW10pLFxuICAgIC8vIENvbnZlcnQgZWRnZSBhcnJheSB2YWx1ZXMgaW50byB0aGUgW1QsUixCLExdIGZvcm0uXG4gICAgcGFyc2VFZGdlVmFsdWUgPSAoZSA9IDApID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICBlID0gW2VdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBlLmxlbmd0aCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZmlsbChlWzBdLCAxLCA0KTtcbiAgICAgICAgICAgIGNhc2UgMjovLyB0b3AmYm90dG9tLCBsZWZ0JnJpZ2h0XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlWzBdLCBlWzFdLCBlWzBdLCBlWzFdXTtcbiAgICAgICAgICAgIGNhc2UgMzovLyB0b3AsIGxlZnQmcmlnaHQsIGJvdHRvbVxuICAgICAgICAgICAgICAgIHJldHVybiBbZVswXSwgZVsxXSwgZVsyXSwgZVsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfSxcbiAgICBwYXJzZUVkZ2VBbGlnbiA9IGVkZ2VBbGlnbiA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBlZGdlUGFydHMgICAgID0gZWRnZUFsaWduUkUuZXhlYyhlZGdlQWxpZ24pLFxuICAgICAgICAgICAgb3VyRWRnZVpvbmUgICA9IGVkZ2Vab25lW2VkZ2VQYXJ0c1sxXV0sXG4gICAgICAgICAgICB0aGVpckVkZ2Vab25lID0gZWRnZVpvbmVbZWRnZVBhcnRzWzRdXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3VyRWRnZSAgICAgICAgIDogZWRnZVBhcnRzWzFdLFxuICAgICAgICAgICAgb3VyRWRnZU9mZnNldCAgIDogcGFyc2VJbnQoZWRnZVBhcnRzWzJdIHx8IDUwKSxcbiAgICAgICAgICAgIG91ckVkZ2VVbml0ICAgICA6IGVkZ2VQYXJ0c1szXSB8fCAnJScsXG4gICAgICAgICAgICBvdXJFZGdlWm9uZSxcbiAgICAgICAgICAgIHRoZWlyRWRnZSAgICAgICA6IGVkZ2VQYXJ0c1s0XSxcbiAgICAgICAgICAgIHRoZWlyRWRnZU9mZnNldCA6IHBhcnNlSW50KGVkZ2VQYXJ0c1s1XSB8fCA1MCksXG4gICAgICAgICAgICB0aGVpckVkZ2VVbml0ICAgOiBlZGdlUGFydHNbNl0gfHwgJyUnLFxuICAgICAgICAgICAgdGhlaXJFZGdlWm9uZSxcblxuICAgICAgICAgICAgLy8gQWxpZ25lZCB0byBhbiBlZGdlLCAqb3V0c2lkZSogb2YgdGhlIHRhcmdldC5cbiAgICAgICAgICAgIC8vIEEgbm9ybWFsIGFsaWduIGFzIGEgY29tYm8gZHJvcGRvd24gbWlnaHQgcmVxdWVzdFxuICAgICAgICAgICAgZWRnZUFsaWduZWQgICAgIDogKG91ckVkZ2Vab25lICYgMSkgPT09ICh0aGVpckVkZ2Vab25lICYgMSkgJiYgb3VyRWRnZVpvbmUgIT09IHRoZWlyRWRnZVpvbmVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gVGhlIG9wcG9zaXRlIG9mIHBhcnNlRWRnZUFsaWduLCBhbmQgaXQgaGFzIHRvIGZsaXAgdGhlIGVkZ2VzXG4gICAgY3JlYXRlUmV2ZXJzZWRFZGdlQWxpZ24gPSBlZGdlcyA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBvdXJFZGdlICAgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMub3VyRWRnZV0sXG4gICAgICAgICAgICB0aGVpckVkZ2UgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMudGhlaXJFZGdlXTtcblxuICAgICAgICAvLyByZWNvbnN0aXR1dGUgYSBydWxlIHN0cmluZyB3aXRoIHRoZSBlZGdlcyBmbGlwcGVkIHRvIHRoZSBvcHBvc2l0ZSBzaWRlc1xuICAgICAgICByZXR1cm4gYCR7b3VyRWRnZX0ke2VkZ2VzLm91ckVkZ2VPZmZzZXR9JHtlZGdlcy5vdXJFZGdlVW5pdH0tJHt0aGVpckVkZ2V9JHtlZGdlcy50aGVpckVkZ2VPZmZzZXR9JHtlZGdlcy50aGVpckVkZ2VVbml0fWBcblxuICAgIH0sXG4gICAgZ2V0RWxSZWN0ID0gZWwgPT4ge1xuICAgICAgICBjb25zdCByID0gZWwgaW5zdGFuY2VvZiBET01SZWN0ID8gZWwgOiAoZWw/Lm5vZGVUeXBlID09PSAxID8gZWwgOiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpIDogbnVsbCk/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgRE9NUmVjdCBpbnRvIFJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gciAmJiBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG4gICAgfSxcbiAgICBvcHBvc2l0ZUVkZ2UgPSB7XG4gICAgICAgIHQgOiAnYicsXG4gICAgICAgIHIgOiAnbCcsXG4gICAgICAgIGIgOiAndCcsXG4gICAgICAgIGwgOiAncidcbiAgICB9LFxuICAgIGVkZ2Vab25lID0ge1xuICAgICAgICB0IDogMCxcbiAgICAgICAgciA6IDEsXG4gICAgICAgIGIgOiAyLFxuICAgICAgICBsIDogM1xuICAgIH0sXG4gICAgem9uZU5hbWVzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgICB6b25lRWRnZXMgPSBbJ3QnLCAncicsICdiJywgJ2wnXSxcbiAgICB6b25lRGltZW5zaW9uID0gWyd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICB6b25lQ29vcmQgPSBbMCwgMSwgMCwgMV0sXG4gICAgemVyb01hcmdpbnMgPSBbMCwgMCwgMCwgMF0sXG4gICAgZWRnZUFsaWduUkUgPSAvXihbdHJibGNdKShcXGQqKSglfHB4KT8tKFt0cmJsY10pKFxcZCopKCV8cHgpPyQvO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBET01SZWN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLlJlY3RhbmdsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuUmVjdGFuZ2xlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtaW5IZWlnaHQ9bnVsbFxuICAgICAqL1xuICAgIG1pbkhlaWdodCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbWluV2lkdGg9bnVsbFxuICAgICAqL1xuICAgIG1pbldpZHRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QxIGRvZXMgbm90IGhhdmUgYW4gaW50ZXJzZWN0aW9uIHdpdGggcmVjdDJcbiAgICAgKiAhaW5jbHVkZXMoKSBpcyB0cnVlIGZvciBpbnRlcnNlY3Rpb25zIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhjbHVkZXMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIHJldHVybiByZWN0MS5ib3R0b20gPCByZWN0Mi50b3AgICAgIC8vIHJlY3QyIGlzIGJlbG93IHJlY3QxXG4gICAgICAgICAgICB8fCByZWN0MS5sZWZ0ICAgPiByZWN0Mi5yaWdodCAgIC8vIHJlY3QyIGlzIGxlZnQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnJpZ2h0ICA8IHJlY3QyLmxlZnQgICAgLy8gcmVjdDIgaXMgcmlnaHQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnRvcCAgICA+IHJlY3QyLmJvdHRvbTsgLy8gcmVjdDIgaXMgYWJvdmUgcmVjdDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGFwcGluZyBhcmVhIG9mIHJlY3QxICYgcmVjdDJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYXJlYSAoeCAqIHkpXG4gICAgICovXG4gICAgc3RhdGljIGdldEludGVyc2VjdGlvbihyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5nZXRJbnRlcnNlY3Rpb25EZXRhaWxzKHJlY3QxLCByZWN0MikuYXJlYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGFwcGluZyBhcmVhIG9mIHJlY3QxICYgcmVjdDJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB4LCB5ICYgYXJlYVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJbnRlcnNlY3Rpb25EZXRhaWxzKHJlY3QxLCByZWN0Mikge1xuICAgICAgICBsZXQgd2lkdGggID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdDEucmlnaHQsICByZWN0Mi5yaWdodCkgIC0gTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCkpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pIC0gTWF0aC5tYXgocmVjdDEudG9wLCAgcmVjdDIudG9wKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyZWE6IGhlaWdodCAqIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcmVjdDIgaXMgZnVsbHkgY29udGFpbmVkIGluc2lkZSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbmNsdWRlcyhyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QxLmJvdHRvbSA+PSByZWN0Mi5ib3R0b21cbiAgICAgICAgICAgICYmIHJlY3QxLmxlZnQgICA8PSByZWN0Mi5sZWZ0XG4gICAgICAgICAgICAmJiByZWN0MS5yaWdodCAgPj0gcmVjdDIucmlnaHRcbiAgICAgICAgICAgICYmIHJlY3QxLnRvcCAgICA8PSByZWN0Mi50b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QyIGlzIG5vdCBjb250YWluZWQgaW5zaWRlIHJlY3QxLlxuICAgICAqIFRoaXMgY291bGQgYmUgYW4gaW50ZXJzZWN0aW9uIG9yIGJlaW5nIGZ1bGx5IGV4Y2x1ZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlIGJvdHRvbSwgbGVmdCwgcmlnaHQgb3IgdG9wXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGxlYXZlc1NpZGUocmVjdDEsIHJlY3QyLCBzaWRlKSB7XG4gICAgICAgIGlmIChSZWN0YW5nbGUuaW5jbHVkZXMocmVjdDEsIHJlY3QyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEuYm90dG9tIDwgcmVjdDIuYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLmxlZnQgPiByZWN0Mi5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0MS5yaWdodCA8IHJlY3QyLnJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEudG9wID4gcmVjdDIudG9wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIERPTVJlY3Qgb2JqZWN0IHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeD1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5PW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH0gbW92ZWRSZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1vdmVCeShyZWN0LCB4PW51bGwsIHk9bnVsbCkge1xuICAgICAgICBsZXQgbW92ZWRSZWN0ID0gey4uLnJlY3R9O1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5sZWZ0ICArPSB4O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnJpZ2h0ICs9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QueCAgICAgKz0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5ib3R0b20gKz0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC50b3AgICAgKz0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC55ICAgICAgKz0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3ZlZFJlY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIERPTVJlY3Qgb2JqZWN0IHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeD1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5PW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH0gbW92ZWRSZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1vdmVUbyhyZWN0LCB4PW51bGwsIHk9bnVsbCkge1xuICAgICAgICBsZXQgbW92ZWRSZWN0ID0gey4uLnJlY3R9O1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5sZWZ0ICA9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QucmlnaHQgPSB4ICsgbW92ZWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgbW92ZWRSZWN0LnggICAgID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5ib3R0b20gPSB5ICsgbW92ZWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC50b3AgICAgPSB5O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnkgICAgICA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWRSZWN0O1xuICAgIH1cblxuICAgIHNldCBib3R0b20oYikge1xuICAgICAgICB0aGlzLmhlaWdodCArPSBiIC0gdGhpcy5ib3R0b207XG4gICAgfVxuICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5ib3R0b207XG4gICAgfVxuXG4gICAgc2V0IHJpZ2h0KHIpIHtcbiAgICAgICAgdGhpcy53aWR0aCArPSByIC0gdGhpcy5yaWdodDtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gc3VwZXIucmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSB4IHdpdGhvdXQgbW92aW5nIHRoZSBSZWN0YW5nbGUuIFRoZSBsZWZ0IHNpZGUgbW92ZXMgYW5kIHRoZSByaWdodCBzaWRlIGRvZXNuJ3RcbiAgICBjaGFuZ2VYKHgpIHtcbiAgICAgICAgY29uc3Qgd2lkdGhEZWx0YSA9IHRoaXMueCAtIHg7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy53aWR0aCArPSB3aWR0aERlbHRhO1xuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgeSB3aXRob3V0IG1vdmluZyB0aGUgUmVjdGFuZ2xlLiBUaGUgdG9wIHNpZGUgbW92ZXMgYW5kIHRoZSBib3R0b20gc2lkZSBkb2Vzbid0XG4gICAgY2hhbmdlWSh5KSB7XG4gICAgICAgIGNvbnN0IGhlaWdodERlbHRhID0gdGhpcy55IC0geTtcblxuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHREZWx0YTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5jbG9uZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xvbmUocikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG5cbiAgICAgICAgcmVzdWx0Lm1pbldpZHRoID0gci5taW5XaWR0aDtcbiAgICAgICAgcmVzdWx0Lm1pbkhlaWdodCA9IHIubWluSGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0cyhvdGhlcikge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG90aGVyLmhlaWdodCAmJiBvdGhlci53aWR0aCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBsZWZ0ICAgPSBNYXRoLm1heChtZS54LCBvdGhlci54KSxcbiAgICAgICAgICAgICAgICB0b3AgICAgPSBNYXRoLm1heChtZS55LCBvdGhlci55KSxcbiAgICAgICAgICAgICAgICByaWdodCAgPSBNYXRoLm1pbihtZS54ICsgbWUud2lkdGgsIG90aGVyLnggKyBvdGhlci53aWR0aCksXG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4obWUueSArIG1lLmhlaWdodCwgb3RoZXIueSArIG90aGVyLmhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0ID49IHJpZ2h0IHx8IHRvcCA+PSBib3R0b20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBhIHBvaW50IGhlcmUgLSB6ZXJvIGRpbWVuc2lvbnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKG90aGVyLnggPj0gbWUueCAmJiBvdGhlci55ID49IG1lLnkgJiYgb3RoZXIucmlnaHQgPD0gbWUucmlnaHQgJiYgb3RoZXIuYm90dG9tIDw9IG1lLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG90aGVyIFJlY3RhbmdsZSBpcyBmdWxseSBjb250YWluZWQgaW5zaWRlIHRoaXMgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY29udGFpbnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tID49IG90aGVyLmJvdHRvbVxuICAgICAgICAgICAgJiYgdGhpcy5sZWZ0ICAgPD0gb3RoZXIubGVmdFxuICAgICAgICAgICAgJiYgdGhpcy5yaWdodCAgPj0gb3RoZXIucmlnaHRcbiAgICAgICAgICAgICYmIHRoaXMudG9wICAgIDw9IG90aGVyLnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGUgZXhwYW5kZWQgYWNjb3JkaW5nIHRvIHRoZSBlZGdlcyBhcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn1OdW1iZXJbXX0gZWRnZXNcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIGV4cGFuZChlZGdlcykge1xuICAgICAgICBlZGdlcyA9IHBhcnNlRWRnZVZhbHVlKGVkZ2VzKTtcblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54IC0gZWRnZXNbM10sIHRoaXMueSAtIGVkZ2VzWzBdLCB0aGlzLndpZHRoICsgZWRnZXNbMV0gKyBlZGdlc1szXSwgdGhpcy5oZWlnaHQgKyBlZGdlc1swXSArIGVkZ2VzWzJdKTtcbiAgICB9XG5cbiAgICBtb3ZlQnkoeCA9IDAsIHkgPSAwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICAgICAgeSA9IHhbMV07XG4gICAgICAgICAgICB4ID0geFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQueCArPSB4O1xuICAgICAgICByZXN1bHQueSArPSB5O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgUmVjdGFuZ2xlIGNvbXBsZXRlbHkgY29udGFpbnMgdGhlIG90aGVyIFJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBvdGhlclxuICAgICAqL1xuICAgIGNvbnRhaW5zKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmluY2x1ZGVzKHRoaXMsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIFJlY3RhbmdsZSBjb25zdHJhaW5lZCB0byBmaXQgd2l0aGluIHRoZSBwYXNzZWQgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbnN0cmFpblRvXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZXxCb29sZWFufSBBIG5ldyBSZWN0YW5nbGUgY29uc3RyYWluZWQgdG8gdGUgcGFzc2VkIFJlY3RhbmdsZSwgb3IgZmFsc2UgaWYgaXQgY291bGQgbm90IGJlIGNvbnN0cmFpbmVkLlxuICAgICAqL1xuICAgIGNvbnN0cmFpblRvKGNvbnN0cmFpblRvKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbWluV2lkdGggID0gbWUubWluV2lkdGggIHx8IG1lLndpZHRoLFxuICAgICAgICAgICAgbWluSGVpZ2h0ID0gbWUubWluSGVpZ2h0IHx8IG1lLmhlaWdodDtcblxuICAgICAgICAvLyBOb3QgcG9zc2libGUsIGV2ZW4gd2hlbiBzaHJ1bmsgdG8gbWluaW1hXG4gICAgICAgIGlmIChtaW5IZWlnaHQgPiBjb25zdHJhaW5Uby5oZWlnaHQgfHwgbWluV2lkdGggPiBjb25zdHJhaW5Uby53aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZG8gbm90IG11dGF0ZSB0aGlzIFJlY3RhbmdsZSwgYnV0IHJldHVybiBhIGNvbnN0cmFpbmVkIHZlcnNpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbWUuY2xvbmUoKTtcblxuICAgICAgICAvLyBUcmFuc2xhdGUgcmVzdWx0IHNvIHRoYXQgdGhlIHRvcCBhbmQgbGVmdCBhcmUgdmlzaWJsZVxuICAgICAgICByZXN1bHQueCA9IE1hdGgubWF4KG1lLnggKyBNYXRoLm1pbihjb25zdHJhaW5Uby5yaWdodCAgLSByZXN1bHQucmlnaHQsICAwKSwgY29uc3RyYWluVG8ueCk7XG4gICAgICAgIHJlc3VsdC55ID0gTWF0aC5tYXgobWUueSArIE1hdGgubWluKGNvbnN0cmFpblRvLmJvdHRvbSAtIHJlc3VsdC5ib3R0b20sIDApLCBjb25zdHJhaW5Uby55KTtcblxuICAgICAgICAvLyBQdWxsIGluIGFueSByZXN1bHRpbmcgb3ZlcmZsb3dcbiAgICAgICAgcmVzdWx0LmJvdHRvbSA9IE1hdGgubWluKHJlc3VsdC5ib3R0b20sIGNvbnN0cmFpblRvLmJvdHRvbSk7XG4gICAgICAgIHJlc3VsdC5yaWdodCA9IE1hdGgubWluKHJlc3VsdC5yaWdodCwgY29uc3RyYWluVG8ucmlnaHQpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYWxpZ25UbyhhbGlnbikge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpblRvLCAgICAvLyBFbGVtZW50IG9yIFJlY3RhbmdsZSByZXN1bHQgbXVzdCBmaXQgaW50b1xuICAgICAgICAgICAgICAgIHRhcmdldCwgICAgICAgICAvLyBFbGVtZW50IG9yIFJlY3RhbmdsZSB0byBhbGlnbiB0b1xuICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiwgICAgICAvLyB0NTAtYjUwIHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgYXhpc0xvY2ssICAgICAgIC8vIHRydWUgZm9yIGZsaXAsICdmbGV4aWJsZScgZm9yIGZsaXAsIHRoZW4gdHJ5IHRoZSBvdGhlciBlZGdlc1xuICAgICAgICAgICAgICAgIG9mZnNldCwgICAgICAgICAvLyBGaW5hbCBbeCwgeV0gdmVjdG9yIHRvIG1vdmUgdGhlIHJlc3VsdCBieS5cbiAgICAgICAgICAgICAgICBtYXRjaFNpemVcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgID0gYWxpZ24sXG4gICAgICAgICAgICB0YXJnZXRNYXJnaW4gICA9IGFsaWduLnRhcmdldE1hcmdpbiA/IHBhcnNlRWRnZVZhbHVlKGFsaWduLnRhcmdldE1hcmdpbikgOiB6ZXJvTWFyZ2lucyxcbiAgICAgICAgICAgIHRhcmdldFJlY3QgICAgID0gZ2V0RWxSZWN0KHRhcmdldCksXG4gICAgICAgICAgICBjb25zdHJhaW5SZWN0ICA9IGdldEVsUmVjdChjb25zdHJhaW5UbyksXG4gICAgICAgICAgICBlZGdlcyAgICAgICAgICA9IHBhcnNlRWRnZUFsaWduKGVkZ2VBbGlnbiksXG4gICAgICAgICAgICBtYXRjaERpbWVuc2lvbiA9IHpvbmVEaW1lbnNpb25bZWRnZXMudGhlaXJFZGdlWm9uZSAmIDFdO1xuXG4gICAgICAgIGxldCByZXN1bHQgPSBtZS5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdFttYXRjaERpbWVuc2lvbl0gPSB0YXJnZXRSZWN0W21hdGNoRGltZW5zaW9uXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE11c3QgZG8gdGhlIGNhbGN1bGF0aW9ucyBhZnRlciB0aGUgYWxpZ25lZCBzaWRlIGhhcyBiZWVuIG1hdGNoZWQgaW4gc2l6ZSBpZiByZXF1ZXN0ZWQuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBteVBvaW50ICAgICA9IHJlc3VsdC5nZXRBbmNob3JQb2ludChlZGdlcy5vdXJFZGdlWm9uZSwgZWRnZXMub3VyRWRnZU9mZnNldCwgZWRnZXMub3VyRWRnZVVuaXQpLFxuICAgICAgICAgICAgdGFyZ2V0UG9pbnQgPSB0YXJnZXRSZWN0LmdldEFuY2hvclBvaW50KGVkZ2VzLnRoZWlyRWRnZVpvbmUsIGVkZ2VzLnRoZWlyRWRnZU9mZnNldCwgZWRnZXMudGhlaXJFZGdlVW5pdCwgdGFyZ2V0TWFyZ2luKSxcbiAgICAgICAgICAgIHZlY3RvciAgICAgID0gW3RhcmdldFBvaW50WzBdIC0gbXlQb2ludFswXSwgdGFyZ2V0UG9pbnRbMV0gLSBteVBvaW50WzFdXTtcblxuICAgICAgICByZXN1bHQgPSByZXN1bHQubW92ZUJ5KHZlY3Rvcik7XG5cbiAgICAgICAgLy8gQSB1c2VmdWwgcHJvcGVydHkgaW4gdGhlIHJlc3VsdGluZyByZWN0YW5nbGUgd2hpY2ggc3BlY2lmaWVzIHdoaWNoIHpvbmUgb2YgdGhlIHRhcmdldFxuICAgICAgICAvLyBJdCBpcyBiZWluZyBwbGFjZXMgaW4sIFQsUixCIG9yIEwgLSAwLCAxLCAyLCAzXG4gICAgICAgIC8vIFNvbWUgY29kZSBtYXkgd2FudCB0byB0cmVhdCBET00gZWxlbWVudHMgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHRoZSB6b25lXG4gICAgICAgIHJlc3VsdC56b25lID0gZWRnZXMudGhlaXJFZGdlWm9uZTtcbiAgICAgICAgcmVzdWx0LnBvc2l0aW9uID0gem9uZU5hbWVzW3Jlc3VsdC56b25lXTtcblxuICAgICAgICAvLyBOb3cgd2UgY3JlYXRlIHRoZSBmb3VyIFJlY3RhbmdsZXMgYXJvdW5kIHRoZSB0YXJnZXQsIGludG8gd2hpY2ggd2UgbWF5IGJlIGNvbnN0cmFpbmVkXG4gICAgICAgIC8vIFpvbmVzIFQsUixCLEwgMCA5LCAxLCAyLCAzOlxuICAgICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgIC8vIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIF4gICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIF4gICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgPC0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tWm9uZSAwLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLT4gICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKy0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgIFpvbmUgMyAgICAgICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgIFpvbmUgMSAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8ICsrLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgPC0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS1ab25lIDItLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tPiB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgdiAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgdiAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKystLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICBpZiAoY29uc3RyYWluUmVjdCAmJiAhY29uc3RyYWluUmVjdC5jb250YWlucyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAvLyBUaGV5IGFza2VkIHRvIG92ZXJsYXAgdGhlIHRhcmdldCwgZm9yIGV4YW1wbGUgdDAtdDBcbiAgICAgICAgICAgIC8vIEluIHRoZXNlIGNhc2VzLCB3ZSBqdXN0IHJldHVybiB0aGUgcmVzdWx0XG4gICAgICAgICAgICBpZiAodGFyZ2V0UmVjdC5pbnRlcnNlY3RzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSB6b25lIHdlIHRyeSB0byBmaXQgaW50byBmaXJzdCwgdGhlIG9uZSB0aGF0IHdhcyBhc2tlZCBmb3JcbiAgICAgICAgICAgIGxldCB6b25lID0gZWRnZXMudGhlaXJFZGdlWm9uZTtcblxuICAgICAgICAgICAgLy8gV2UgY3JlYXRlIGFuIGFycmF5IG9mIGZvdXIgcmVjdGFuZ2xlcyBpbnRvIHdoaWNoIHdlIHRyeSB0byBmaXQgd2l0aCBhcHByb3ByaWF0ZSBhbGlnbiBzcGVjcy5cbiAgICAgICAgICAgIC8vIFdlIG11c3Qgc3RhcnQgd2l0aCB0aGUgcmVxdWVzdGVkIHpvbmUsIHdoYXRldmVyIHRoYXQgaXMuXG4gICAgICAgICAgICBjb25zdCB6b25lc1RvVHJ5ID0gW3tcbiAgICAgICAgICAgICAgICB6b25lLFxuICAgICAgICAgICAgICAgIGVkZ2VBbGlnblxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGlmIChheGlzTG9jaykge1xuICAgICAgICAgICAgICAgIC8vIEZsaXAgdG8gdGhlIG9wcG9zaXRlIHNpZGUgZm9yIHRoZSBzZWNvbmQgdHJ5LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBhbGlnbm1lbnQgc3RyaW5nIGhhcyB0byBiZSByZXZlcnNlZFxuICAgICAgICAgICAgICAgIC8vIHNvIHIyMC1sMzAgaGFzIHRvIGJlY29tZSBsMjAtcjMwLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBvdGhlciB0d28gem9uZXMgcmV2ZXJ0IHRvIGNlbnRlcmVkIHNvIGFyZSBlYXNpZXJcbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5WzFdID0ge1xuICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKHpvbmUgKyAyKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGNyZWF0ZVJldmVyc2VkRWRnZUFsaWduKGVkZ2VzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgb3RoZXIgdHdvIHpvbmVzLlxuICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoZWRnZXMudGhlaXJFZGdlWm9uZSArIDEpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduIDogYCR7b3Bwb3NpdGVFZGdlW3pvbmVFZGdlc1t6b25lXV19LSR7em9uZUVkZ2VzW3pvbmVdfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKGVkZ2VzLnRoZWlyRWRnZVpvbmUgKyAzKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGAke29wcG9zaXRlRWRnZVt6b25lRWRnZXNbem9uZV1dfS0ke3pvbmVFZGdlc1t6b25lXX1gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBvdGhlciB6b25lcyBpbiBvcmRlclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lICAgICAgOiB6b25lID0gKHpvbmUgKyAxKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24gOiBgJHtvcHBvc2l0ZUVkZ2Vbem9uZUVkZ2VzW3pvbmVdXX0tJHt6b25lRWRnZXNbem9uZV19YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29uc3RyYWludCBSZWN0YW5nbGUgZm9yIGVhY2ggem9uZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6b25lc1RvVHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2xvbmUgdGhlIG91dGVyIGNvbnN0cmFpbmluZyByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAvLyBhbmQgbW92ZSBpdCBpbnRvIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNvbnN0cmFpblJlY3QuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoem9uZXNUb1RyeVtpXS56b25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGkyIGFib3ZlIHRoZSB0YXJnZXQgLSB6b25lIDAvVFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5ib3R0b20gPSB0YXJnZXRSZWN0LnkgLSB0YXJnZXRNYXJnaW5bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHpvbmUgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSB0YXJnZXQgLSB6b25lIDEvUlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFuZ2VYKHRhcmdldFJlY3QucmlnaHQgKyB0YXJnZXRNYXJnaW5bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGlzIGJlbG93IHRoZSB0YXJnZXQgLSB6b25lIDIvQlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jaGFuZ2VZKHRhcmdldFJlY3QuYm90dG9tICsgdGFyZ2V0TWFyZ2luWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgem9uZSBpcyB0byB0aGUgbGVmdCBvZiB0aGUgdGFyZ2V0IC0gem9uZSAzL0xcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSB0YXJnZXRSZWN0LnggLSB0YXJnZXRNYXJnaW5bM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgem9uZXNUb1RyeVtpXS5jb25zdHJhaW5SZWN0ID0gYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHRyeSB0byBjb25zdHJhaW4gb3VyIHJlc3VsdCBpbnRvIGVhY2ggem9uZSdzIGNvbnN0cmFpbnRab25lXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHpvbmVzVG9UcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWluUmVjdFxuICAgICAgICAgICAgICAgICAgICB9ICAgID0gem9uZXNUb1RyeVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZSA9IHpvbmVFZGdlc1t6b25lXTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGFsaWduaW5nIHRvIHRoZSByZXF1ZXN0ZWQgZWRnZSwgb3IgaXQncyBvcHBvc2l0ZSBlZGdlIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhhdCBlZGdlIHNpemUsIGVsc2UgcmV2ZXJ0IGl0IHRvIG91ciBvd24gc2l6ZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbWF0Y2hEaW1lbnNpb25dID0gZWRnZSA9PT0gZWRnZXMudGhlaXJFZGdlIHx8IGVkZ2UgPT0gb3Bwb3NpdGVFZGdlW2VkZ2VzLnRoZWlyRWRnZV0gPyB0YXJnZXRSZWN0W21hdGNoRGltZW5zaW9uXSA6IG1lW21hdGNoRGltZW5zaW9uXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBhIHNpbXBsZSBhbGlnbiB0byB0aGUgY3VycmVudCBlZGdlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFsaWduVG8oe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgOiB0YXJnZXRSZWN0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNvbHV0aW9uID0gcmVzdWx0LmNvbnN0cmFpblRvKGNvbnN0cmFpblJlY3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXMgc29vbiBhcyB3ZSBmaW5kIGEgem9uZSBpbnRvIHdoaWNoIHRoZSByZXN1bHQgaXMgd2lsbGluZyB0byBiZSBjb25zdHJhaW5lZC4gcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLnpvbmUgPSB6b25lO1xuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbi5wb3NpdGlvbiA9IHpvbmVOYW1lc1t6b25lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgY29uZmlndXJhYmxlIGZpbmlzaGluZyB0b3VjaC5cbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1vdmVCeShvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXRBbmNob3JQb2ludChlZGdlWm9uZSwgZWRnZU9mZnNldCwgZWRnZVVuaXQsIG1hcmdpbiA9IGVtcHR5QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgLy8gRWRnZSB6b25lcyBnbyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgICAgLy8gRWFjaCBvbmUgY2FsY3VsYXRlcyB0aGUgc3RhcnQgcG9pbnQgb2YgdGhhdCBlZGdlIHRoZW4gbW92ZXMgYWxvbmcgaXQgYnlcbiAgICAgICAgLy8gdGhlIGVkZ2VPZmZzZXQsIHRoZW4gbW92ZXMgKmF3YXkqIGZyb20gaXQgYnkgdGhlIG1hcmdpbiBmb3IgdGhhdCBlZGdlIGlmIHRoZXJlJ3MgYSBtYXJnaW4uXG4gICAgICAgIHN3aXRjaCAoZWRnZVpvbmUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCwgbWUueSAtIChtYXJnaW5bMF0gfHwgMCksIG1lLndpZHRoLCAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCArIG1lLndpZHRoICsgKG1hcmdpblsxXSB8fCAwKSwgbWUueSwgbWUuaGVpZ2h0LCAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCwgbWUueSArIG1lLmhlaWdodCArIChtYXJnaW5bMl0gfHwgMCksIG1lLndpZHRoLCAwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbbWUueCAtIChtYXJnaW5bM10gfHwgMCksIG1lLnksIG1lLmhlaWdodCwgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc3VsdFszXV0gKz0gZWRnZVVuaXQgPT09ICclJyA/IHJlc3VsdFsyXSAvIDEwMCAqIGVkZ2VPZmZzZXQgOiBlZGdlT2Zmc2V0O1xuICAgICAgICByZXN1bHQubGVuZ3RoID0gMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgRE9NUmVjdCAmJlxuICAgICAgICAgICAgb3RoZXIueCA9PT0gdGhpcy54ICYmXG4gICAgICAgICAgICBvdGhlci55ID09PSB0aGlzLnkgJiZcbiAgICAgICAgICAgIG90aGVyLmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgICAgICAgIG90aGVyLndpZHRoID09PSB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgb25seVxuICAgIHNob3coY29sb3IgPSAncmVkJykge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBkaXYuc3R5bGUgPSBgXG4gICAgICAgICAgICBwb3NpdGlvbjphYnNvbHV0ZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTp0cmFuc2xhdGUzZCgke3RoaXMueH1weCwgJHt0aGlzLnl9cHgsIDApO1xuICAgICAgICAgICAgaGVpZ2h0OiR7dGhpcy5oZWlnaHR9cHg7XG4gICAgICAgICAgICB3aWR0aDoke3RoaXMud2lkdGh9cHg7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiR7Y29sb3J9XG4gICAgICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBkaXYucmVtb3ZlKCksIDMwMDAwKTtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIEpTT04uc3RyaW5naWZ5KHRoaXMpLCB3ZSB3YW50IHRvIGFkZCBtaW5IZWlnaHQgJiBtaW5XaWR0aCB0byB0aGUgb3V0cHV0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIG1pbkhlaWdodCwgbWluV2lkdGgsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7Ym90dG9tLCBoZWlnaHQsIGxlZnQsIG1pbkhlaWdodCwgbWluV2lkdGgsIHJpZ2h0LCB0b3AsIHdpZHRoLCB4LCB5fVxuICAgIH1cbn1cbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5TdHlsZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTdHlsZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuU3R5bGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlN0eWxlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZGVsdGEgb2JqZWN0LCBjb250YWluaW5nIHRoZSBzdHlsZXMgb2YgbmV3U3R5bGUgd2hpY2ggYXJlIG5vdCBpbmNsdWRlZCBvciBkaWZmZXJlbnQgdGhhbiBpbiBvbGRTdHlsZVxuICAgICAqIFN0eWxlcyBpbmNsdWRlZCBpbiBvbGRTdHlsZSBidXQgbWlzc2luZyBpbiBuZXdTdHlsZSB3aWxsIGdldCBhIHZhbHVlIG9mIG51bGxcbiAgICAgKiBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9zdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmV3U3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9sZFN0eWxlXG4gICAgICogQHJldHVybnMge09iamVjdH0gc3R5bGUgZGVsdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVN0eWxlcyhuZXdTdHlsZSwgb2xkU3R5bGUpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IHt9O1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcobmV3U3R5bGUpKSB7XG4gICAgICAgICAgICBuZXdTdHlsZSA9IE5lby5jcmVhdGVTdHlsZU9iamVjdChuZXdTdHlsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcob2xkU3R5bGUpKSB7XG4gICAgICAgICAgICBvbGRTdHlsZSA9IE5lby5jcmVhdGVTdHlsZU9iamVjdChvbGRTdHlsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3U3R5bGUgJiYgIW9sZFN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKCFvbGRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIE5lby5jbG9uZShuZXdTdHlsZSlcbiAgICAgICAgfSBlbHNlIGlmICghbmV3U3R5bGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3U3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb2xkU3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpIHx8IG9sZFN0eWxlW3N0eWxlXSAhPT0gbmV3U3R5bGVbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBuZXdTdHlsZVtzdHlsZV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMob2xkU3R5bGUpLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbmV3U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFN0eWxlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==