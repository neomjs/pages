"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_Base_mjs"],{

/***/ "./src/component/Base.mjs":
/*!********************************!*\
  !*** ./src/component/Base.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");
/* harmony import */ var _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/KeyNavigation.mjs */ "./src/util/KeyNavigation.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_Style_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Style.mjs */ "./src/util/Style.mjs");
/* harmony import */ var _core_Util_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/Util.mjs */ "./src/core/Util.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");














const
    addUnits            = value => value == null ? value : isNaN(value) ? value : `${value}px`,
    closestController   = Symbol.for('closestController'),
    closestProvider     = Symbol.for('closestProvider'),
    {currentWorker}     = Neo,
    lengthRE            = /^\d+\w+$/,
    twoWayBindingSymbol = Symbol.for('twoWayBinding');

/**
 * Base class for all Components which have a DOM representation
 * @class Neo.component.Base
 * @extends Neo.core.Base
 */
class Component extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for hideMode
     * @member {String[]} hideModes=['removeDom','visibility']
     * @protected
     * @static
     */
    static hideModes = ['removeDom', 'visibility']
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.component.Base'
         * @protected
         */
        className: 'Neo.component.Base',
        /**
         * @member {String} ntype='component'
         * @protected
         */
        ntype: 'component',
        /**
         * The default alignment specification to position this Component relative to some other
         * Component, or Element or Rectangle. Only applies in case floating = true.
         * @member {Object|String} align_={edgeAlign:'t-b',constrainTo:'document.body'}
         */
        align_: {
            edgeAlign  : 't-b',
            constrainTo: 'document.body'
        },
        /**
         * The name of the App this component belongs to
         * @member {String|null} appName_=null
         */
        appName_: null,
        /**
         * True automatically mounts a component after being rendered.
         * Use this for the top level component of your app.
         * @member {Boolean} autoMount=false
         * @tutorial 02_ClassSystem
         */
        autoMount: false,
        /**
         * True automatically renders a component after being created inside the init call.
         * Use this for the top level component of your app.
         * @member {Boolean} autoRender=false
         * @see {@link Neo.component.Base#init init}
         * @tutorial 02_ClassSystem
         */
        autoRender: false,
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=[]
         */
        baseCls: [],
        /**
         * Bind configs to state.Provider data properties.
         * Example for a button.Base:
         * @example
         * bind: {
         *     iconCls: data => `fa fa-{$data.icon}`,
         *     text   : data => data.foo.bar
         * }
         * @see https://github.com/neomjs/neo/blob/dev/examples/stateProvider
         * @member {Object|null} bind=null
         */
        bind: null,
        /**
         * Custom CSS selectors to apply to the root level node of this component
         * You can override baseCls to remove default selectors.
         * @member {String[]} cls_=null
         */
        cls_: null,
        /**
         * manager.Focus will change this flag on focusin & out dom events
         * @member {Boolean} containsFocus_=false
         * @protected
         */
        containsFocus_: false,
        /**
         * Assign a component controller to this component (pass an imported module or the string based class name)
         * @member {Neo.controller.Component|String} controller_=null
         */
        controller_: null,
        /**
         * Convenience shortcut to access the data config of the closest state.Provider.
         * Read only.
         * @member {Object} data_=null
         * @protected
         */
        data_: null,
        /**
         * Disabled components will get the neo-disabled cls applied and won't receive DOM events
         * @member {Boolean} disabled_=false
         */
        disabled_: false,
        /**
         * An array of domListener configs
         * @member {Object[]|null} domListeners_=null
         * @example
         * afterSetStayOnHover(value, oldValue) {
         *     if (value) {
         *         let me = this;
         *
         *         me.addDomListeners(
         *             {mouseenter: me.onMouseEnter, scope: me},
         *             {mouseleave: me.onMouseLeave, scope: me}
         *         )
         *    }
         *}
         */
        domListeners_: null,
        /**
         * Set this config to true to dynamically import a DropZone module & create an instance
         * @member {Boolean} droppable_=false
         */
        droppable_: false,
        /**
         * @member {Neo.draggable.DropZone|null} dropZone=null
         */
        dropZone: null,
        /**
         * @member {Object} dropZoneConfig=null
         */
        dropZoneConfig: null,
        /**
         * True to render this component into the viewport outside of the document flow
         * @member {Boolean} floating
         */
        floating: false,
        /**
         * Internal flag which will get set to true on mount
         * @member {Boolean} hasBeenMounted=false
         * @protected
         */
        hasBeenMounted: false,
        /**
         * Internal flag
         * @member {Boolean} hasRenderingListener=false
         * @protected
         */
        hasRenderingListener: false,
        /**
         * Internal flag for vdom changes after a component got unmounted
         * (delta updates can no longer get applied & a new render call is required before re-mounting)
         * @member {Boolean} hasUnmountedVdomChanges_=false
         * @protected
         */
        hasUnmountedVdomChanges_: false,
        /**
         * Shortcut for style.height, defaults to px
         * @member {Number|String|null} height_=null
         */
        height_: null,
        /**
         * Initial setting to hide or show the component and
         * you can use either hide()/show() or change this config directly to change the hidden state
         * @member {Boolean} hidden_=false
         */
        hidden_: false,
        /**
         * Used for hide and show and defines if the component
         * should use css visibility:'hidden' or vdom:removeDom
         * @member {String} hideMode_='removeDom'
         */
        hideMode_: 'removeDom',
        /**
         * The top level innerHTML of the component
         * @member {String|null} html_=null
         */
        html_: null,
        /**
         * Set to `true` to show a spinner centered in the component.
         * Set to a string to show a message next to a spinner centered in the component.
         * @member {Boolean|String} isLoading=false
         */
        isLoading_: false,
        /**
         * Internal flag which will get set to true while an update request (worker messages) is in progress
         * @member {Boolean} isVdomUpdating_=false
         * @protected
         */
        isVdomUpdating_: false,
        /**
         * Using the keys config will create an instance of Neo.util.KeyNavigation.
         * @see {@link Neo.util.KeyNavigation KeyNavigation}
         * @member {Object} keys_=null
         */
        keys_: null,
        /**
         * Gets used inside afterSetIsLoading() to define the CSS for the loading spinner icon
         * @member {String[]} loadingSpinnerCls_=['fa','fa-spinner','fa-spin']
         */
        loadingSpinnerCls_: ['fa', 'fa-spinner', 'fa-spin'],
        /**
         * Shortcut for style.maxHeight, defaults to px
         * @member {Number|String|null} maxHeight_=null
         */
        maxHeight_: null,
        /**
         * Shortcut for style.maxWidth, defaults to px
         * @member {Number|String|null} maxWidth_=null
         */
        maxWidth_: null,
        /**
         * Shortcut for style.minHeight, defaults to px
         * @member {Number|String|null} minHeight_=null
         */
        minHeight_: null,
        /**
         * Shortcut for style.minWidth, defaults to px
         * @member {Number|String|null} minWidth_=null
         */
        minWidth_: null,
        /**
         * Override specific stateProvider data properties.
         * This will merge the content.
         * @member {Object|null} modelData=null
         */
        modelData: null,
        /**
         * True in case the component is mounted to the DOM
         * @member {Boolean} mounted_=false
         * @protected
         */
        mounted_: false,
        /**
         * Internal flag which will get set to true in case an update call arrives while another update is running
         * @member {Boolean} needsVdomUpdate_=false
         * @protected
         */
        needsVdomUpdate_: false,
        /**
         * If the parentId does not match a neo component id, you can manually set this value for finding
         * view controllers or state providers.
         * Use case: manually dropping components into a vdom structure
         * @member {Neo.component.Base|null} parentComponent_=null
         * @protected
         */
        parentComponent_: null,
        /**
         * The parent component id or document.body
         * @member {String} parentId_='document.body'
         */
        parentId_: 'document.body',
        /**
         * Array of Plugin Modules and / or config objects
         * @member {Array|null} plugins_=null
         * @protected
         */
        plugins_: null,
        /**
         * Set a reference for accessing the component inside view controllers.
         * References will also get mapped into the vdom root (data-ref: value).
         * @member {String|null} reference_=null
         * @protected
         */
        reference_: null,
        /**
         * Make the view Responsive by adding alternative configs.
         * The definition happens via responsiveCfg
         * @member {Object} responsive=null
         * @protected
         */
        responsive_: null,
        /**
         * True in case the component is rendering the vnode
         * @member {Boolean} rendering_=false
         * @protected
         */
        rendering_: false,
        /**
         * Specify a role tag attribute for the vdom root.
         * See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles
         * @member {String|null} role_=null
         */
        role_: null,
        /**
         * Set this to true for style 'overflow:auto'.
         * Set this to 'x' or 'y' to add style 'overflow-x' or 'overflow-y' to 'auto'
         * Other than false this will add cls 'neo-scrollable'.
         * @member {Boolean|"x"|"y"} scrollable_=false
         */
        scrollable_: false,
        /**
         * Set this to true for bulk updates. Ensure to set it back to false afterwards.
         * Internally the value will get saved as a number to ensure that child methods won't stop the silent mode too early.
         * @member {Boolean} silentVdomUpdate_=false
         */
        silentVdomUpdate_: false,
        /**
         * Optionally add a state.Provider to share state data with child components
         * @member {Object|null} stateProvider_=null
         */
        stateProvider_: null,
        /**
         * Style attributes added to this vdom root. see: getVdomRoot()
         * @member {Object} style_=null
         */
        style_: null,
        /**
         * You can pass a used theme directly to any component,
         * to style specific component trees differently from your main view.
         * @member {String|null} theme_=null
         */
        theme_: null,
        /**
         * While it is recommended to define tags inside the vdom of classes,
         * this shortcut enables us to change the vdom root tag on instance level.
         * Use cases: switch a Toolbar to a "nav" tag, switch a SideNav to an "aside" tag.
         * @member {String|null} tag_=null
         */
        tag_: null,
        /**
         * Add tooltip config object or a string containing the display text
         * See tooltip/Base.mjs
         *
         * By default, a single, shared Tooltip instance is used for all widgets which request
         * a tooltip. It reconfigures itself from the widget's definition just before showing.
         *
         * If a widget needs its own instance for any reason, inslude the property `ownInstance : true`
         * in the tooltip config object.
         * @member {Object|String} tooltip_=null
         */
        tooltip_: null,
        /**
         * Add 'primary' and other attributes to make it an outstanding design
         * @member {String|null} ui_=null
         */
        ui_: null,
        /**
         * Defines the depth of the vdom tree for the next update cycle.
         * - The value 1 will only send the current vdom structure as it is
         * - The value of 2 will include the vdom of direct children
         * - The value of 3 will include the vdom of grandchildren
         * - The value of -1 will include the full tree of any depth
         * @member {Number} updateDepth_=1
         */
        updateDepth_: 1,
        /**
         * The component vnode tree. Available after the component got rendered.
         * @member {Object} vnode_=null
         * @protected
         */
        vnode_: null,
        /**
         * Shortcut for style.width, defaults to px
         * @member {Number|String|null} width_=null
         */
        width_: null,
        /**
         * The custom windowIs (timestamp) this component belongs to
         * @member {Number|null} windowId_=null
         */
        windowId_: null,
        /**
         * @member {String[]|null} wrapperCls_=null
         */
        wrapperCls_: null,
        /**
         * Top level style attributes. Useful in case getVdomRoot() does not point to the top level DOM node.
         * @member {Object|null} wrapperStyle_=null
         */
        wrapperStyle_: null,
        /**
         * The vdom markup for this component.
         * @member {Object} _vdom={}
         */
        _vdom: {}
    }

    /**
     * If an update() gets called while a parent is updating, we store the id & distance of the
     * requesting component inside the childUpdateCache of the parent, to get resolved once the update is done.
     * e.g. childUpdateCache = {'neo-grid-view-1': {distance: 1, resolve: fn}}
     * @member {Object} childUpdateCache={}
     */
    childUpdateCache = {}
    /**
     * Stores the updateDepth while an update is running to enable checks for parent update collisions
     * @member {Number|null} currentUpdateDepth=null
     */
    currentUpdateDepth = null
    /**
     * @member {Function[]} resolveUpdateCache=[]
     */
    resolveUpdateCache = []

    /**
     * Convenience shortcut to access the App this component belongs to
     * @returns {Neo.controller.Application|null}
     */
    get app() {
        return Neo.apps[this.appName] || null
    }

    /**
     * Returns true if this Component is fully visible, that is it is not hidden and has no hidden ancestors
     */
    get isVisible() {
        return this.mounted && !this.hidden && (!this.parent || this.parent.isVisible);
    }

    /**
     * Apply component based listeners
     * @member {Object} listeners={}
     */
    get listeners() {
        return this._listeners || {}
    }
    set listeners(value) {
        this._listeners = value
    }

    /**
     * Convenience method to access the parent component
     * @returns {Neo.component.Base|null}
     */
    get parent() {
        let me = this;

        return me.parentComponent || me.parentId === 'document.body' ? null : Neo.getComponent(me.parentId)
    }

    /**
     * True after the component render() method was called. Also fires the rendered event.
     * @member {Boolean} rendered=false
     * @protected
     */
    get rendered() {
        return this._rendered || false
    }
    set rendered(value) {
        let me = this;

        me._rendered = value;

        if (value === true) {
            me.fire('rendered', me.id)
        }
    }

    /**
     * The setter will handle vdom updates automatically
     * @member {Object} vdom=this._vdom
     */
    get vdom() {
        return this._vdom
    }
    set vdom(value) {
        this.afterSetVdom(value, value)
    }

    /**
     * Add a new cls to the vdomRoot
     * @param {String} value
     */
    addCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);
        this.cls = cls
    }

    /**
     * Convenience shortcut to add additional dom listeners
     * @param {Object|Object[]} value
     */
    addDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let domListeners = this.domListeners;

        domListeners.push(...value);

        this.domListeners = domListeners
    }

    /**
     * Either a string like 'color: red; background-color: blue;'
     * or an object containing style attributes
     * @param {String|Object} value
     * @returns {Object} all styles of this.el
     */
    addStyle(value) {
        if (typeof value === 'string') {
            value = _core_Util_mjs__WEBPACK_IMPORTED_MODULE_10__["default"].createStyleObject(value);
        }

        // todo: add a check if something has changed

        return this.style = Object.assign(this.style, value)
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {

    }

    /**
     * Triggered after the cls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetCls(value, oldValue) {
        oldValue = oldValue || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls;

        if (vdom !== vdomRoot) {
            // we are using a wrapper node
            vdomRoot.cls = [...value]
        } else {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(me.wrapperCls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldValue, value));
            vdom.cls = cls
        }

        if (me.isVdomUpdating || me.silentVdomUpdate) {
            me.needsVdomUpdate = true
        } else if (me.mounted && me.vnode) {
            me.updateCls(value, oldValue, vdomRoot.id)
        }
    }

    /**
     * Triggered after any config got changed
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     * @protected
     */
    afterSetConfig(key, value, oldValue) {
        let me = this;

        if (currentWorker.isUsingStateProviders && me[twoWayBindingSymbol] && oldValue !== undefined) {
            let binding = me.bind?.[key];

            if (binding?.twoWay) {
                this.getStateProvider()?.setData(binding.key, value)
            }
        }
    }

    /**
     * Triggered after the disabled config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisabled(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"][value ? 'add' : 'remove'](cls, 'neo-disabled');
        this.cls = cls
    }

    /**
     * Registers the domListeners inside the Neo.manager.DomEvent
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetDomListeners(value, oldValue) {
        let me = this;

        if (value?.[0] || oldValue?.[0]) {
            me.getController()?.parseDomListeners(me);

            _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].updateDomListeners(me, value, oldValue)
        }
    }

    /**
     * Triggered after the droppable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDroppable(value, oldValue) {
        let me = this;

        if (value && !me.dropZone) {
            __webpack_require__.e(/*! import() */ "src_draggable_DropZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DropZone.mjs */ "./src/draggable/DropZone.mjs")).then(module => {
                me.dropZone = Neo.create({
                    module  : module.default,
                    appName : me.appName,
                    owner   : me,
                    windowId: me.windowId,
                    ...me.dropZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the flex config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetFlex(value, oldValue) {
        if (!isNaN(value)) {
            value = `${value} ${value} 0%`
        }

        this.configuredFlex = value;
        this.changeVdomRootKey('flex', value)
    }

    /**
     * Triggered after the hasUnmountedVdomChanges config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHasUnmountedVdomChanges(value, oldValue) {
        if (value || (!value && oldValue)) {
            let parentIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParentIds(this),
                i         = 0,
                len       = parentIds.length,
                parent;

            for (; i < len; i++) {
                parent = Neo.getComponent(parentIds[i]);

                if (parent) {
                    parent._hasUnmountedVdomChanges = value // silent update
                }
            }
        }
    }

    /**
     * Triggered after the height config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetHeight(value, oldValue) {
        this.configuredHeight = addUnits(value);
        this.changeVdomRootKey('height', value)
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let me    = this,
            state = value ? 'hide' : 'show';

        if (value && oldValue === undefined && me.hideMode === 'removeDom') {
            me.vdom.removeDom = true
        } else if (value || oldValue !== undefined) {
            me[state]()
        }

        if (!value) {
            me.revertFocus();
        }

        me.fire(state, {id: me.id});
        me.fire('hiddenChange', {id: me.id, oldValue, value})
    }

    /**
     * Triggered after the html config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetHtml(value, oldValue) {
        this.changeVdomRootKey('html', value)
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);
        this.changeVdomRootKey('id', value);

        oldValue && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(oldValue);
        value    && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].register(this)
    }

    /**
     * Triggered after the isLoading config got changed
     * @param {Boolean|String} value
     * @param {Boolean|String} oldValue
     * @protected
     */
    afterSetIsLoading(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me          = this,
                {cls, vdom} = me,
                maskIndex;

            if (oldValue !== undefined && vdom.cn) {
                maskIndex = vdom.cn.findLastIndex(c => c.cls?.includes('neo-load-mask'));

                // Remove the load mask
                if (maskIndex !== -1) {
                    vdom.cn.splice(maskIndex, 1)
                }
            }

            if (value) {
                if (!vdom.cn) {
                    vdom.cn = []
                }

                vdom.cn.push(me.createLoadingMask(value))
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].toggle(cls, 'neo-masked', value);
            me.set({cls, vdom})
        }
    }

    /**
     * Triggered after the isVdomUpdating config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetIsVdomUpdating(value, oldValue) {
        this.currentUpdateDepth = value ? this.updateDepth : null
    }

    /**
     * Triggered after the maxHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxHeight(value, oldValue) {
        this.configuredMaxHeight = addUnits(value);
        this.changeVdomRootKey('maxHeight', value)
    }

    /**
     * Triggered after the maxWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxWidth(value, oldValue) {
        this.configuredMaxWidth = addUnits(value);
        this.changeVdomRootKey('maxWidth', value)
    }

    /**
     * Triggered after the minHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinHeight(value, oldValue) {
        this.configuredMinHeight = addUnits(value);
        this.changeVdomRootKey('minHeight', value)
    }

    /**
     * Triggered after the minWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinWidth(value, oldValue) {
        this.configuredMinWidth = addUnits(value);
        this.changeVdomRootKey('minWidth', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            let me             = this,
                {id, windowId} = me;

            if (value) {
                me.hasBeenMounted = true;

                if (me.domListeners?.length > 0) {
                    // todo: the main thread reply of mount arrives after pushing the task into the queue which does not ensure the dom is mounted
                    me.timeout(150).then(() => {
                        _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].mountDomListeners(me)
                    })
                }

                me.doResolveUpdateCache();

                if (me.floating) {
                    me.alignTo();

                    // Focus will be pushed into the first input field or other focusable item
                    me.focus(id, true)
                }

                me.fire('mounted', me.id)
            } else {
                me.revertFocus()
            }
        }
    }

    /**
     * Triggered after the reference config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetReference(value, oldValue) {
        value && this.changeVdomRootKey('data-ref', value)
    }

    /**
     * Triggered after the responsive config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    async afterSetResponsive(value, oldValue) {
        if (value && !this.getPlugin('responsive')) {
            let me      = this,
                module  = await __webpack_require__.e(/*! import() */ "src_plugin_Responsive_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../../src/plugin/Responsive.mjs */ "./src/plugin/Responsive.mjs")),
                plugins = me.plugins || [];

            plugins.push({
                module : module.default,
                appName: me.appName,
                value
            });

            me.plugins = plugins
        }
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.changeVdomRootKey('role', value)
    }

    /**
     * Triggered after the scrollable config got changed
     * @param {String|Boolean} value
     * @param {String|Boolean|null} oldValue
     * @protected
     */
    afterSetScrollable(value, oldValue) {
        if (oldValue === undefined && !value) {
            return
        }

        let me = this;

        if (oldValue) {
            let oldOverflowKey = 'overflow';

            if (!Neo.isBoolean(oldValue)) {
                oldOverflowKey += Neo.capitalize(oldValue)
            }

            me.removeStyle([oldOverflowKey])
        }

        if (!Neo.isEmpty(value)) {
            let overflowKey = 'overflow';

            if (value && !Neo.isBoolean(value)) {
                overflowKey += Neo.capitalize(value)
            }

            if (value) {
                me.addStyle(overflowKey + ':auto');
                me.addCls('neo-scrollable')
            } else {
                me.removeCls('neo-scrollable')
            }
        }
    }

    /**
     * Triggered after the style config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle(value, oldValue)
        }
    }

    /**
     * Triggered after the tag config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTag(value, oldValue) {
        value && this.changeVdomRootKey('tag', value)
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me          = this,
                {cls}       = me,
                needsUpdate = false;

            if (oldValue && cls.includes(oldValue)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, oldValue);
                needsUpdate = true
            }

            // We do not need to add a DOM based CSS selector, in case the theme is already inherited
            if (value !== me.parent?.theme) {
                value && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);
                needsUpdate = true
            }

            if (needsUpdate) {
                me.cls = cls
            }
        }
    }

    /**
     * Triggered after the tooltip config got changed
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @protected
     */
    afterSetTooltip(value, oldValue) {
        oldValue?.destroy?.();

        if (value) {
            if (Neo.ns('Neo.tooltip.Base')) {
                this.createTooltip(value)
            } else {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_container_Base_mjs"), __webpack_require__.e("vendors-src_tooltip_Base_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../tooltip/Base.mjs */ "./src/tooltip/Base.mjs")).then(() => {
                    this.createTooltip(value)
                })
            }
        }
    }

    /**
     * For styling purposes only.
     * To define button styles or component styles,
     * this will add a css class: neo-ntype-value
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetUi(value, oldValue) {
        let me  = this,
            cls = me.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, `neo-${me.ntype}-${oldValue}`);

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, `neo-${me.ntype}-${value}`)
        }

        me.cls = cls
    }

    /**
     * Triggered after the vdom pseudo-config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVdom(value, oldValue) {
        this.updateVdom(value)
    }

    /**
     * Triggered after the vnode config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVnode(value, oldValue) {
        oldValue !== undefined && this.syncVnodeTree()
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        this.configuredWidth = addUnits(value);
        this.changeVdomRootKey('width', value)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        let me         = this,
            controller = me.controller;

        if (value) {
            currentWorker.insertThemeFiles(value, me.__proto__);

            if (controller) {
                controller.windowId = value
            }
        }

        // If a component gets moved into a different window, an update cycle might still be running.
        // Since the update might no longer get mapped, we want to re-enable this instance for future updates.
        if (oldValue) {
            me.isVdomUpdating = false
        }
    }

    /**
     * Triggered after the wrapperCls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetWrapperCls(value, oldValue) {
        oldValue = oldValue || [];
        value    = value    || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls      = me.vdom?.cls || [];

        if (vdom === vdomRoot) {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(cls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldValue, value));
            vdom.cls = cls
        } else {
            // we are not using a wrapper => cls & wrapperCls share the same node
            value = value ? value : [];

            oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, oldValue);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(cls, value);

            if (vdom) {
                vdom.cls = cls
            }
        }

        me.update()
    }

    /**
     * Triggered after the wrapperStyle config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetWrapperStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            let me   = this,
                vdom = me.vdom;

            if (!vdom.id) {
                vdom.style = value;
                me.update()
            } else {
                me.updateStyle(value, oldValue, vdom.id)
            }
        }
    }

    /**
     * Aligns the top level node inside the main thread
     * @param {Object} spec={}
     * @returns {Promise<void>}
     */
    async alignTo(spec={}) {
        const
            me    = this,
            align = {
                ...me.align,
                ...spec,
                id                 : me.id,
                configuredFlex     : me.configuredFlex,
                configuredWidth    : me.configuredWidth,
                configuredHeight   : me.configuredHeight,
                configuredMinWidth : me.configuredMinWidth,
                configuredMinHeight: me.configuredMinHeight,
                configuredMaxWidth : me.configuredMaxWidth,
                configuredMaxHeight: me.configuredMaxHeight
            };

        if (align.target) {
            await Neo.main.DomAccess.align(align)
        }
    }

    /**
     * Triggered when accessing the cls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the data config
     * Convenience shortcut which is expensive to use, since it will generate a merged parent state providers data map.
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getStateProvider().getHierarchyData()
    }

    /**
     * Triggered when accessing the style config
     * @param {Object} value
     * @protected
     */
    beforeGetStyle(value) {
        return {...value}
    }

    /**
     * Triggered when accessing the wrapperCls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetWrapperCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the wrapperStyle config
     * @param {Object} value
     * @protected
     */
    beforeGetWrapperStyle(value) {
        return {...Object.assign(this.vdom.style || {}, value)}
    }

    /**
     * Triggered before the align config gets changed.
     * @param {Object|String} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        let me = this;

        // Just a simple 't-b'
        if (typeof value === 'string') {
            value = {
                edgeAlign: value
            }
        }

        // merge the incoming alignment specification into the configured default
        return Neo.merge({}, value, me.constructor.config.align)
    }

    /**
     * Triggered before the cls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].union(value || [], this.baseCls, this.getBaseClass());
    }

    /**
     * Triggered before the controller config gets changed.
     * Creates a controller.Component instance if needed.
     * @param {Neo.controller.Component|Object} value
     * @param {Neo.controller.Component|null} oldValue
     * @returns {Neo.controller.Component}
     * @protected
     */
    beforeSetController(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, null, {
                component: this,
                windowId : this.windowId
            })
        }

        return value
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Triggered before the hideMode config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetHideMode(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'hideMode')
    }

    /**
     * Triggered before the keys config gets changed.
     * Creates a KeyNavigation instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.util.KeyNavigation|null}
     * @protected
     */
    beforeSetKeys(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], {
                keyDownEventBubble: true,
                keys              : value
            })
        }

        return value
    }

    /**
     * Triggered before the stateProvider config gets changed.
     * Creates a state.Provider instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.state.Provider}
     * @protected
     */
    beforeSetStateProvider(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me            = this,
                defaultValues = {component: me};

            if (me.modelData) {
                defaultValues.data = me.modelData
            }

            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, 'Neo.state.Provider', defaultValues)
        }

        return null
    }

    /**
     * Triggered before the plugins config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @returns {Neo.plugin.Base[]}
     * @protected
     */
    beforeSetPlugins(value, oldValue) {
        if (Array.isArray(value)) {
            value.forEach((item, index) => {
                value[index] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(item, null, {
                    owner: this
                })
            })
        }

        return value
    }

    /**
     * Triggered before the silentVdomUpdate config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetSilentVdomUpdate(value, oldValue) {
        if (value === true) {
            return Neo.isNumber(oldValue) ? (oldValue + 1) : 1
        }

        return (Neo.isNumber(oldValue) && oldValue > 0) ? (oldValue - 1) : 0
    }

    /**
     * Triggered before the updateDepth config gets changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetUpdateDepth(value, oldValue) {
        if (oldValue === undefined) {
            return value
        }

        return oldValue === -1 || value === -1 ? -1 : Math.max(value, oldValue)
    }

    /**
     * Changes the value of a vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     */
    changeVdomRootKey(key, value) {
        let me   = this,
            root = me.getVdomRoot();

        if (value) {
            root[key] = value
        } else {
            delete root[key]
        }

        me.update()
    }

    /**
     * Override this method in case you need different mask markups.
     * The removal logic relies on the top level node having the cls 'neo-load-mask'
     * @param {Boolean|String} loadingMessage
     * @returns {Object} vdom
     */
    createLoadingMask(loadingMessage) {
        return {
            cls: ['neo-load-mask'],
            cn : [{
                cls: ['neo-load-mask-body'],
                cn : [{
                    cls: this.loadingSpinnerCls
                }, {
                    cls      : ['neo-loading-message'],
                    html     : loadingMessage,
                    removeDom: !Neo.isString(loadingMessage)
                }]
            }]
        }
    }

    /**
     * Creates the tooltip instances
     * @param {Object|String} value
     * @protected
     */
    createTooltip(value) {
        if (typeof value === 'string') {
            value = {
                text: value
            }
        }

        let me = this;

        if (value.ownInstance) {
            me._tooltip = Neo.create('Neo.tooltip.Base', {
                ...value,
                appName    : me.appName,
                componentId: me.id,
                windowId   : me.windowId
            })
        } else {
            me._tooltip = value;
            Neo.tooltip.Base.createSingleton(me.app);
            me.addCls('neo-uses-shared-tooltip');
            me.update()
        }
    }

    /**
     * Convenience shortcut to create a component reference
     * @returns {Object}
     */
    createVdomReference() {
        let me        = this,
            reference = {componentId: me.id},
            vdomId    = me.vdom.id;

        if (vdomId && me.id !== vdomId) {
            reference.id = vdomId
        }

        return reference
    }

    /**
     * Unregister this instance from the ComponentManager
     * @param {Boolean} updateParentVdom=false true to remove the component from the parent vdom => real dom
     * @param {Boolean} silent=false true to update the vdom silently (useful for destroying multiple child items in a row)
     * todo: unregister events
     */
    destroy(updateParentVdom=false, silent=false) {
        let me                  = this,
            {parent, parentId}  = me,
            parentStateProvider = parent?.getStateProvider(),
            parentVdom;

        me.revertFocus();

        me.domListeners = [];

        me.controller = null; // triggers destroy()

        me.reference && me.getController()?.removeReference(me); // remove own reference from parent controllers

        me.stateProvider = null; // triggers destroy()

        me.bind && parentStateProvider?.removeBindings(me.id);

        me.plugins?.forEach(plugin => {
            plugin.destroy()
        });

        if (updateParentVdom && parentId) {
            if (parentId === 'document.body') {
                Neo.applyDeltas(me.appName, {action: 'removeNode', id: me.vdom.id})
            } else {
                parentVdom = parent.vdom;

                _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].removeVdomChild(parentVdom, me.vdom.id);
                parent[silent ? '_vdom' : 'vdom'] = parentVdom
            }
        }

        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(me);

        super.destroy();

        // We do want to prevent delayed calls after a component instance got destroyed.
        me.onFocusLeave = Neo.emptyFn;
        me.unmount      = Neo.emptyFn
    }

    /**
     * Triggers all stored resolve() callbacks
     */
    doResolveUpdateCache() {
        let me = this;

        if (me.resolveUpdateCache) {
            me.resolveUpdateCache.forEach(item => item());
            me.resolveUpdateCache = []
        }
    }

    /**
     * Convenience shortcut for Neo.manager.Component.down
     * @param {Object|String} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    down(config, returnFirstMatch=true) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].down(this, config, returnFirstMatch)
    }

    /**
     * Internal method to send update requests to the vdom worker
     * @param {Object} vdom
     * @param {Neo.vdom.VNode} vnode
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @private
     */
    #executeVdomUpdate(vdom, vnode, resolve, reject) {
        let me   = this,
            opts = {},
            deltas;

        if (currentWorker.isSharedWorker) {
            opts.appName  = me.appName;
            opts.windowId = me.windowId
        }

        me.isVdomUpdating = true;

        // we can not set the config directly => it could already be false,
        // and we still want to pass it further into subtrees
        me._needsVdomUpdate = false;
        me.afterSetNeedsVdomUpdate?.(false, true);

        opts.vdom  = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(vdom, me.updateDepth);
        opts.vnode = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVnodeTree(vnode, me.updateDepth);

        // Reset the updateDepth to the default value for the next update cycle
        me._updateDepth = me.constructor.config.updateDepth;

        Neo.vdom.Helper.update(opts).catch(err => {
            me.isVdomUpdating = false;
            console.log('Error attempting to update component dom', err, me);

            reject?.()
        }).then(data => {
            me.isVdomUpdating = false;

            // checking if the component got destroyed before the update cycle is done
            if (me.id) {
                me.vnode = data.vnode;

                deltas = data.deltas;

                if (!Neo.config.useVdomWorker && deltas.length > 0) {
                    Neo.applyDeltas(me.appName, deltas).then(() => {
                        me.resolveVdomUpdate(resolve)
                    })
                } else {
                    me.resolveVdomUpdate(resolve)
                }
            }
        })
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} id=this.id
     * @param {Boolean} children=false
     */
    focus(id=this.id, children=false) {
        Neo.main.DomAccess.focus({children, id, windowId: this.windowId})
    }

    /**
     * Override this method to add dynamic values into this.cls
     * @returns {String[]}
     */
    getBaseClass() {
        const result = [];

        if (this.floating) {
            result.push('neo-floating')
        }

        return result
    }

    /**
     * Find an instance stored inside a config via optionally passing a ntype.
     * Returns this[configName] or the closest parent component with a match.
     * Used by getController() & getStateProvider()
     * @param {String} configName
     * @param {String} [ntype]
     * @returns {Neo.core.Base|null}
     */
    getConfigInstanceByNtype(configName, ntype) {
        let me                = this,
            config            = me[configName],
            {parentComponent} = me;

        if (config && (!ntype || ntype === config.ntype)) {
            return config
        }

        if (!parentComponent && me.parentId) {
            parentComponent = me.parent || Neo.get(me.parentId);
        }

        if (parentComponent) {
            return parentComponent.getConfigInstanceByNtype(configName, ntype)
        }

        return null
    }

    /**
     * Returns this.controller or the closest parent controller
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        let me = this,
            controller;

        if (!ntype) {
            controller = me[closestController];

            if (controller) {
                return controller
            }
        }

        controller = me.getConfigInstanceByNtype('controller', ntype);

        if (!ntype) {
            me[closestController] = controller;
        }

        return controller
    }

    /**
     * Convenience shortcut
     * @param {String[]|String} id=this.id
     * @param {String} appName=this.appName
     * @returns {Promise<Neo.util.Rectangle|Neo.util.Rectangle[]>}
     */
    async getDomRect(id=this.id, appName=this.appName) {
        let result = await Neo.main.DomAccess.getBoundingClientRect({appName, id, windowId: this.windowId});

        if (Array.isArray(result)) {
            return result.map(rect => _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].clone(rect))
        }

        return _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].clone(result)
    }

    /**
     * Honors different item roots for mount / render OPs
     * @returns {String}
     */
    getMountedParentId() {
        let parentId  = this.parentId,
            parent    = Neo.getComponent(parentId),
            itemsRoot = parent?.getVdomItemsRoot?.();

        return itemsRoot ? itemsRoot.id : parentId
    }

    /**
     * Calculate the real parentIndex inside the DOM
     * @returns {Number|undefined}
     */
    getMountedParentIndex() {
        let parent = this.parent,
            items  = parent?.items || [],
            i      = 0,
            index  = 0,
            len    = items.length,
            item;

        for (; i < len; i++) {
            item = items[i];

            if (item === this) {
                return index
            }

            if (!item.hidden && item.hideMode === 'removeDom') {
                index++
            }
        }
    }

    /**
     * Get the parent components as an array
     * @returns {Neo.component.Base[]}
     */
    getParents() {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(this)
    }

    /**
     * @param {Object|String} opts
     * @returns {Neo.plugin.Base|null}
     */
    getPlugin(opts) {
        if (Neo.isString(opts)) {
            if (!opts.startsWith('plugin-')) {
                opts = 'plugin-' + opts
            }

            opts = {ntype: opts}
        }

        let me = this,
            hasMatch;

        for (const plugin of me.plugins || []) {
            hasMatch = true;

            for (const key in opts) {
                if (plugin[key] !== opts[key]) {
                    hasMatch = false;
                    break
                }
            }

            if (hasMatch) {
                return plugin
            }
        }

        return null
    }

    /**
     * convenience shortcut
     * @param {String} value
     * @returns {Neo.component.Base|null}
     */
    getReference(value) {
        return this.down({reference: value})
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * Returns this.stateProvider or the closest parent stateProvider
     * @param {String} [ntype]
     * @returns {Neo.state.Provider|null}
     */
    getStateProvider(ntype) {
        if (!currentWorker.isUsingStateProviders) {
            return null
        }

        let me = this,
            provider;

        if (!ntype) {
            provider = me[closestProvider];

            if (provider) {
                return provider
            }
        }

        provider = me.getConfigInstanceByNtype('stateProvider', ntype);

        if (!ntype) {
            me[closestProvider] = provider
        }

        return provider
    }

    /**
     * Walks up the vdom tree and returns the closest theme found
     * @returns {String}
     */
    getTheme() {
        let me         = this,
            themeMatch = 'neo-theme-',
            mainView, parentNodes;

        for (const item of me.cls || []) {
            if (item.startsWith(themeMatch)) {
                return item
            }
        }

        mainView = me.app?.mainView;

        if (mainView) {
            parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].getParentNodes(mainView.vdom, me.id);

            for (const node of parentNodes || []) {
                for (const item of node.cls || []) {
                    if (item.startsWith(themeMatch)) {
                        return item
                    }
                }
            }
        }

        return Neo.config.themes?.[0]
    }

    /**
     * Search a vdom child node by id for a given vdom tree
     * @param {String} id
     * @param {Object} vdom=this.vdom
     * @returns {Object}
     */
    getVdomChild(id, vdom=this.vdom) {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].find(vdom, id)?.vdom
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode
    }

    /**
     * Checks if a given updateDepth & distance would result in an update collision
     * @param {Number} updateDepth
     * @param {Number} distance
     * @returns {Boolean}
     */
    hasUpdateCollision(updateDepth, distance) {
        return updateDepth === -1 ? true : distance < updateDepth
    }

    /**
     * Hide the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     * If hideMode === 'removeDom' you can pass a timeout for custom css class hiding.
     * @param {Number} timeout
     */
    hide(timeout) {
        let me = this;

        if (me.hideMode !== 'visibility') {
            let removeFn = function () {
                if (me.parentId !== 'document.body') {
                    me.vdom.removeDom = true;
                    me.parent.updateDepth = 2;
                    me.parent.update()
                } else {
                    me.unmount()
                }
            }

            if (timeout) {
                me.timeout(timeout).then(removeFn)
            } else {
                removeFn()
            }
        } else {
            let style = me.style;
            style.visibility = 'hidden';
            me.style = style;
        }

        me._hidden = true
    }

    /**
     *
     */
    init() {
        this.autoRender && this.render()
    }

    /**
     * We are using this method as a ctor hook here to add the initial state.Provider & controller.Component parsing
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     */
    initConfig(config, preventOriginalConfig) {
        super.initConfig(config, preventOriginalConfig);

        let me = this;

        me.getController()   ?.parseConfig(me);
        me.getStateProvider()?.parseConfig(me)
    }

    /**
     * Checks for vdom updates inside the parent chain and if found.
     * Registers the component for a vdom update once done.
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] Gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean}
     */
    isParentUpdating(parentId=this.parentId, resolve, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                if (parent.isVdomUpdating) {
                    if (me.hasUpdateCollision(parent.currentUpdateDepth, distance)) {
                        if (Neo.config.logVdomUpdateCollisions) {
                            console.warn('vdom parent update conflict with:', parent, 'for:', me)
                        }

                        parent.childUpdateCache[me.id] = {distance, resolve};

                        // Adding the resolve fn to its own cache, since the parent will trigger
                        // a new update() directly on this cmp
                        resolve && me.resolveUpdateCache.push(resolve);
                        return true
                    }

                    // If an update is running and does not have a collision, we do not need to check further parents
                    return false
                }

                return me.isParentUpdating(parent.parentId, resolve, distance+1)
            }
        }

        return false
    }

    /**
     * @param {Number|String} value
     * @returns {Promise<number>}
     */
    async measure(value) {
        if (value != null) {
            if (value.endsWith('px')) {
                value = parseFloat(value)
            } else if (lengthRE.test(value)) {
                let {id, windowId} = this;
                value = await Neo.main.DomAccess.measure({id, value, windowId})
            } else if (!isNaN(value)) {
                value = parseFloat(value)
            }
        }

        return value
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let me     = this,
            config = super.mergeConfig(...args),

            // it should be possible to set custom configs for the vdom on instance level,
            // however there will be already added attributes (e.g. id), so a merge seems to be the best strategy.
            vdom = {...me._vdom || {}, ...config.vdom || {}};

        // avoid any interference on prototype level
        // does not clone existing Neo instances
        me._vdom = Neo.clone(vdom, true, true);

        if (config.style) {
            // If we are passed an object, merge it with the class's own style
            me.style = Neo.typeOf(config.style) === 'Object' ? {...config.style, ...me.constructor.config.style} : config.style
        }

        me.wrapperStyle = Neo.clone(config.wrapperStyle, false);

        delete config.style;
        delete config._vdom;
        delete config.vdom;
        delete config.wrapperStyle;

        return config
    }

    /**
     * Can get called after the component got rendered. See the autoMount config as well.
     */
    async mount() {
        let me = this,
            child, childIds;

        if (!me.vnode) {
            throw new Error('Component vnode must be generated before mounting, use Component.render()');
        }

        // In case the component was already mounted, got unmounted and received vdom changes afterwards,
        // a new render() call is mandatory since delta updates could not get applied.
        // We need to clear the hasUnmountedVdomChanges state for all child components
        if (me.hasUnmountedVdomChanges) {
            // todo: the hasUnmountedVdomChanges flag changes should happen on render
            me.hasUnmountedVdomChanges = false;

            childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(me.vnode);

            childIds.forEach(id => {
                child = Neo.getComponent(id);

                if (child) {
                    child._hasUnmountedVdomChanges = false; // silent update
                }
            });
            // end todo

            me.render(true)
        } else {
            await currentWorker.promiseMessage('main', {
                action     : 'mountDom',
                appName    : me.appName,
                id         : me.id,
                html       : me.vnode.outerHTML,
                parentId   : me.getMountedParentId(),
                parentIndex: me.getMountedParentIndex()
            });

            delete me.vdom.removeDom;

            await me.timeout(30);

            me.mounted = true
        }
    }

    /**
     * Checks the needsVdomUpdate config inside the parent tree
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean}
     */
    needsParentUpdate(parentId=this.parentId, resolve, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                // We are checking for parent.updateDepth, since we care about the depth of the next update cycle
                if (parent.needsVdomUpdate && me.hasUpdateCollision(parent.updateDepth, distance)) {
                    parent.resolveUpdateCache.push(...me.resolveUpdateCache);
                    resolve && parent.resolveUpdateCache.push(resolve);
                    me.resolveUpdateCache = [];
                    return true
                }

                return me.needsParentUpdate(parent.parentId, resolve, distance+1)
            }
        }

        return false
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.keys?.register(this)
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        // If we are hidden, or unmounted while we still contain focus, we have to revert
        // focus to where it came from if possible
        this.focusEnterData = data;
    }

    /**
     * @param {Object} data
     */
    onFocusLeave(data) {
        this.focusEnterData = null;
    }

    /**
     * Triggered by manager.Focus
     * @name onFocusEnter
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusLeave
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusMove
     * @function
     * @param {Object} opts
     * @param {Array}  opts.newPath dom element ids upwards
     * @param {Array}  opts.oldPath dom element ids upwards
     */

    /**
     * Gets called from the render() promise success handler
     * @param {Object} data
     * @param {Boolean} autoMount Mount the DOM after the vnode got created
     * @protected
     */
    onRender(data, autoMount) {
        let me    = this,
            {app} = me;

        me.rendering = false;

        // if app is a check to see if the Component got destroyed while rendering => before onRender got triggered
        if (app) {
            if (!app.rendered) {
                app.rendering = false;
                app.rendered = true;
                app.fire('render')
            }

            me.vnode = data;

            let childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildIds(data),
                i        = 0,
                len      = childIds.length,
                child;

            for (; i < len; i++) {
                child = Neo.getComponent(childIds[i]);

                if (child) {
                    child.rendered = true
                }
            }

            me._rendered = true; // silent update
            me.fire('rendered', me.id);

            // console.log('rendered: ' + me.appName + ' ' + me.id, me);

            if (autoMount) {
                me.mounted = true;

                if (!app.mounted) {
                    app.mounted = true;
                    app.fire('mounted')
                }
            }
        }
    }

    /**
     * Promise based vdom update
     * @param {Object} vdom=this.vdom
     * @param {Neo.vdom.VNode} vnode= this.vnode
     * @returns {Promise<any>}
     */
    promiseUpdate(vdom=this.vdom, vnode=this.vnode) {
        return new Promise((resolve, reject) => {
            this.updateVdom(vdom, vnode, resolve, reject)
        })
    }

    /**
     * Remove a cls from the vdomRoot
     * @param {String} value
     */
    removeCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].remove(cls, value);
        this.cls = cls
    }

    /**
     * @param {Array|Object} value
     */
    removeDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value];
        }

        let me             = this,
            {domListeners} = me,
            i, len;

        value.forEach(item => {
            i = 0;
            len = domListeners.length;

            for (; i < len; i++) {
                if (Neo.isEqual(item, domListeners[i])) {
                    domListeners.splice(i, 1);
                    break
                }
            }
        });

        me.domListeners = domListeners
    }

    /**
     * Either a string like 'color' or an array containing style attributes to remove
     * @param {String|Array} value camelCase only
     * @returns {Object} all styles of this.el
     */
    removeStyle(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let {style}  = this,
            doUpdate = false;

        Object.keys(style).forEach(key => {
            if (value.indexOf(key) > -1) {
                delete style[key];
                doUpdate = true
            }
        });

        if (doUpdate) {
            this.style = style
        }

        return style
    }

    /**
     * Creates the vnode tree for this component and mounts the component in case
     * - you pass true for the mount param
     * - or the autoMount config is set to true
     * @param {Boolean} [mount] Mount the DOM after the vnode got created
     */
    async render(mount) {
        let me              = this,
            autoMount       = mount || me.autoMount,
            {app}           = me,
            {useVdomWorker} = Neo.config;

        // Verify that the critical rendering path => CSS files for the new tree is in place
        if (currentWorker.countLoadingThemeFiles !== 0) {
            currentWorker.on('themeFilesLoaded', function() {
                me.render(mount)
            }, me, {once: true});

            return
        }

        me.rendering = true;

        if (!app.rendered) {
            app.rendering = true
        }

        if (me.vdom) {
            me.isVdomUpdating = true;

            delete me.vdom.removeDom;

            me._needsVdomUpdate = false;
            me.afterSetNeedsVdomUpdate?.(false, true);

            const data = await Neo.vdom.Helper.create({
                appName    : me.appName,
                autoMount,
                parentId   : autoMount ? me.getMountedParentId()    : undefined,
                parentIndex: autoMount ? me.getMountedParentIndex() : undefined,
                windowId   : me.windowId,
                ..._manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(me.vdom)
            });

            me.onRender(data, useVdomWorker ? autoMount : false);
            me.isVdomUpdating = false;

            autoMount && !useVdomWorker && me.mount();

            me.resolveVdomUpdate()
        }
    }

    /**
     * Internal helper fn to resolve the Promise for updateVdom()
     * @param {Function|undefined} resolve
     * @protected
     */
    resolveVdomUpdate(resolve) {
        let me                  = this,
            hasChildUpdateCache = !Neo.isEmpty(me.childUpdateCache),
            component;

        me.doResolveUpdateCache();

        resolve?.();

        if (me.needsVdomUpdate) {
            if (hasChildUpdateCache) {
                Object.entries(me.childUpdateCache).forEach(([key, value]) => {
                    component = Neo.getComponent(key);

                    // The component might already got destroyed
                    if (component) {
                        // Pass callbacks to the resolver cache => getting executed once the following update is done
                        value.resolve && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].add(me.resolveUpdateCache, value.resolve);

                        // Adjust the updateDepth to include the depth of all merged child updates
                        if (me.updateDepth !== -1) {
                            if (component.updateDepth === -1) {
                                me.updateDepth = -1
                            } else {
                                // Since updateDepth is 1-based, we need to subtract 1 level
                                me.updateDepth = me.updateDepth + value.distance + component.updateDepth - 1
                            }
                        }
                    }
                });

                me.childUpdateCache = {}
            }

            me.update()
        } else if (hasChildUpdateCache) {
            Object.keys(me.childUpdateCache).forEach(key => {
                Neo.getComponent(key)?.update()
            });

            me.childUpdateCache = {}
        }
    }

    /**
     *
     */
    revertFocus() {
        let relatedTarget = this.focusEnterData?.relatedTarget;

        if (this.containsFocus && relatedTarget) {
            Neo.getComponent(relatedTarget.id)?.focus()
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} [silent=false]
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        let me             = this,
            needsRendering = values.hidden === false && values.hidden !== me.hidden;

        me.silentVdomUpdate = true;

        super.set(values);

        me.silentVdomUpdate = false;

        if (silent || !me.needsVdomUpdate) {
            return Promise.resolve()
        } else {
            if (needsRendering) {
                me.show();
                return Promise.resolve()
            }

            return me.promiseUpdate()
        }
    }

    /**
     * Convenience shortcut calling set() with the silent flag
     * @param {Object} values={}
     */
    setSilent(values = {}) {
        return this.set(values, true)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }

    /**
     * Show the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     */
    show() {
        let me = this;

        if (me.hideMode !== 'visibility') {
            delete me.vdom.removeDom;

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.parentId !== 'document.body') {
                me.parent.updateDepth = 2;
                me.parent.update()
            } else {
                !me.mounted && me.render(true)
            }
        } else {
            let style = me.style;
            delete style.visibility;
            me.style = style
        }

        me._hidden = false
    }

    /**
     * Placeholder method for util.VDom.syncVdomIds to allow overriding (disabling) it
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     * @param {Object} [vdom=this.vdom]
     * @param {Boolean} force=false
     */
    syncVdomIds(vnode=this.vnode, vdom=this.vdom, force=false) {
        _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].syncVdomIds(vnode, vdom, force)
    }

    /**
     * In case a component receives a new vnode, we want to do:
     * - sync the vdom ids
     * - setting rendered to true for child components
     * - updating the parent component to ensure that the vnode tree stays persistent
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     */
    syncVnodeTree(vnode=this.vnode) {
        let me              = this,
            childComponents = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getChildren(me),
            debug           = false,
            map             = {},
            childVnode, start;

        if (debug) {
            start = performance.now()
        }

        me.syncVdomIds();

        if (vnode && me.id !== vnode.id) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerWrapperNode(vnode.id, me)
        }

        // we need one separate iteration first to ensure all wrapper nodes get registered
        childComponents.forEach(component => {
            childVnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].find(me.vnode, component.vdom.id)?.vnode;

            if (childVnode) {
                map[component.id] = childVnode;

                if (component.id !== childVnode.id) {
                    _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].registerWrapperNode(childVnode.id, component)
                }
            }
        });

        // delegate the latest node updates to all possible child components found inside the vnode tree
        childComponents.forEach(component => {
            childVnode = map[component.id];

            if (childVnode) {
                // silent update
                component._vnode = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addVnodeComponentReferences(childVnode, component.id);

                if (!component.rendered) {
                    component._rendered = true;
                    component.fire('rendered', component.id)
                }

                component.mounted = true
            } else {
                console.warn('syncVnodeTree: Could not replace the child vnode for', component.id)
            }
        });

        // silent update
        me._vnode = vnode ? _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].addVnodeComponentReferences(vnode, me.id) : null;

        debug && console.log('syncVnodeTree', me.id, performance.now() - start)
    }

    /**
     * Toggle a cls inside the vdomRoot of the component
     * @param {String} value
     * @param {Boolean} [add] Use this param to enforce an add() or remove() operation.
     */
    toggleCls(value, add) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].toggle(cls, value, add);
        this.cls = cls
    }

    /**
     * Removes the component DOM
     */
    unmount() {
        let me = this;

        me.vdom.removeDom = true;

        me._hidden = true; // silent update
        me.mounted = false;

        Neo.applyDeltas(me.appName, {action: 'removeNode', id: me.vdom.id})
    }

    /**
     * Convenience shortcut for Neo.manager.Component.up
     * @param {Object|String} config
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    up(config) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].up(this.id, config)
    }

    /**
     *
     */
    update() {
        this.afterSetVdom(this.vdom, null)
    }

    /**
     * Delta updates for the cls config. Gets called after the cls config gets changed in case the component is mounted.
     * @param {String[]} cls
     * @param {String[]} oldCls
     * @param {String} id=this.id
     * @protected
     */
    updateCls(cls, oldCls, id=this.id) {
        let me          = this,
            {vnode}     = me,
            vnodeTarget = vnode && _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].find(me.vnode, {id})?.vnode;

        if (vnode && !Neo.isEqual(cls, oldCls)) {
            if (vnodeTarget) {
                vnodeTarget.className = cls; // keep the vnode in sync
                me.vnode = vnode;
            }

            Neo.applyDeltas(me.appName, {
                id,
                cls: {
                    add   : _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(cls, oldCls),
                    remove: _util_Array_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].difference(oldCls, cls)
                }
            })
        }
    }

    /**
     * Creates the style deltas for newValue & oldValue and applies them directly to the DOM.
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @param {String} [id=this.id]
     * @protected
     */
    updateStyle(value, oldValue, id=this.id) {
        let me    = this,
            delta = _util_Style_mjs__WEBPACK_IMPORTED_MODULE_9__["default"].compareStyles(value, oldValue),
            opts, vdom, vnode, vnodeStyle;

        if (delta) {
            vdom  = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_11__["default"].find(me.vdom, id);
            vnode = me.vnode && _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_12__["default"].find(me.vnode, id);

            if (!me.hasUnmountedVdomChanges) {
                me.hasUnmountedVdomChanges = !me.mounted && me.hasBeenMounted
            }

            vdom.vdom.style = value; // keep the vdom in sync

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.mounted) {
                vnodeStyle = vnode.vnode.style;

                // keep the vnode in sync
                // we need the iteration since vdom shortcuts (height, width,...) live within the vnode style
                // using vnode.vnode.style = style would lose them.
                Object.entries(delta).forEach(([key, value]) => {
                    if (value === null) {
                        delete vnode.vnode.style[key]
                    } else {
                        vnodeStyle[key] = value
                    }
                });

                opts = {
                    action: 'updateDom',
                    deltas: [{id, style: delta}]
                };

                if (currentWorker.isSharedWorker) {
                    opts.appName = me.appName
                }

                currentWorker.sendMessage('main', opts)
            }
        }
    }

    /**
     * Gets called after the vdom config gets changed in case the component is already mounted (delta updates).
     * @param {Object} vdom=this.vdom
     * @param {Neo.vdom.VNode} vnode=this.vnode
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @protected
     */
    updateVdom(vdom=this.vdom, vnode=this.vnode, resolve, reject) {
        let me                       = this,
            {app, mounted, parentId} = me,
            listenerId;

        if (me.isVdomUpdating || me.silentVdomUpdate) {
            resolve && me.resolveUpdateCache.push(resolve);
            me.needsVdomUpdate = true
        } else {
            if (!mounted && me.isConstructed && !me.hasRenderingListener && app?.rendering === true) {
                me.hasRenderingListener = true;

                listenerId = app.on('mounted', () => {
                    app.un('mounted', listenerId);

                    me.timeout(50).then(() => {
                        me.vnode && me.updateVdom(me.vdom, me.vnode, resolve, reject)
                    })
                })
            } else {
                if (resolve && (!mounted || !vnode)) {
                    me.resolveUpdateCache.push(resolve)
                }

                if (
                    !me.needsParentUpdate(parentId, resolve)
                    && !me.isParentUpdating(parentId, resolve)
                    && mounted
                    && vnode
                ) {
                    // Verify that the critical rendering path => CSS files for the new tree is in place
                    if (currentWorker.countLoadingThemeFiles !== 0) {
                        currentWorker.on('themeFilesLoaded', function() {
                            me.updateVdom(vdom, vnode, resolve, reject)
                        }, me, {once: true})
                    } else {
                        me.#executeVdomUpdate(vdom, vnode, resolve, reject)
                    }
                }
            }
        }

        me.hasUnmountedVdomChanges = !mounted && me.hasBeenMounted
    }

    /**
     * In case you are sure a DOMRect exists, use getDomRect()
     * Otherwise you can wait for it using this method.
     * @example:
     *     await this.render(true);
     *     await this.waitForDomRect();
     * @param {Object}          opts
     * @param {String}          opts.appName=this.appName
     * @param {Number}          opts.attempts=10 Reruns in case the rect height or width equals 0
     * @param {Number}          opts.delay=50    Time in ms before checking again
     * @param {String[]|String} opts.id=this.id
     * @returns {Promise<Neo.util.Rectangle|Neo.util.Rectangle[]>}
     */
    async waitForDomRect({appName=this.appName, attempts=10, delay=50, id=this.id}) {
        let me     = this,
            result = await me.getDomRect(id, appName),
            reRun  = false;

        if (Array.isArray(result)) {
            result.forEach(rect => {
                if (rect.height < 1 || rect.width < 1) {
                    reRun = true
                }
            })
        } else if (result.height < 1 || result.width < 1) {
            reRun = true
        }

        if (reRun && attempts > 0) {
            await me.timeout(delay);
            return await me.waitForDomRect({appName, attempts: attempts-1, delay, id})
        }

        return result
    }
}

/**
 * manager.Focus fires the event after focusEnter, focusLeave or focusMove
 * @event focusChange
 * @param {Object} data
 * @param {Object[]} [data.path] dom element ids upwards
 * @param {Object[]} [data.oldPath] dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path
 * @event focusEnter
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is not included inside the dom id path
 * @event focusLeave
 * @param {Object} data
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path, but the path itself changed
 * @event focusMove
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ }),

/***/ "./src/util/KeyNavigation.mjs":
/*!************************************!*\
  !*** ./src/util/KeyNavigation.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.util.KeyNavigation
 * @extends Neo.core.Base
 */
class KeyNavigation extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.KeyNavigation'
         * @protected
         */
        className: 'Neo.util.KeyNavigation',
        /**
         * @member {String} ntype='keynav'
         * @protected
         */
        ntype: 'keynav',
        /**
         * Internally stores the component id inside _component
         * @member {Neo.component.Base|null} component_=null
         */
        component_: null,
        /**
         * Set this to true in case the keydown event is supposed to bubble upwards inside the component tree
         * @member {Boolean} keyDownEventBubble=false
         */
        keyDownEventBubble: false,
        /**
         * @member {Array|null} keys_=null
         */
        keys_: null
    }

    add(value) {
        this._keys.push(...this.parseKeys(value))
    }

    /**
     * @protected
     * @returns {Neo.component.Base}
     */
    beforeGetComponent() {
        return Neo.getComponent(this._component)
    }

    /**
     * @param {Neo.component.Base} value
     * @protected
     * @returns {String} the component id
     */
    beforeSetComponent(value) {
        return value?.id
    }

    /**
     *
     */
    destroy() {
        this.unregister();
        super.destroy()
    }

    /**
     * @param {Object} data
     */
    onKeyDown(data) {
        // Using the chrome auto-fill feature does trigger a keydown event, not containing a key. See: #64
        if (data.key) {
            let me           = this,
                upperCaseKey = data.key.toUpperCase(),
                scope;

            upperCaseKey = me.parseUpperCaseKey(upperCaseKey);

            me.keys.forEach(key => {
                scope = Neo.isString(key.scope) ? Neo.get(key.scope) : key.scope;

                if (key.key.toUpperCase() === upperCaseKey) {
                    if (Neo.isFunction(key.fn)) {
                        key.fn.apply(scope, [data, me.component])
                    } else {
                        scope[key.fn]?.apply(scope, [data, me.component])
                    }
                }
            })
        }
    }

    /**
     * @param {Object} value
     * @returns {Object}
     */
    parseKeys(value) {
        if (!Array.isArray(value)) {
            let componentId = this._component,
                keyArray    = [];

            if (componentId) {
                Object.entries(value).forEach(([key, val]) => {
                    if (key !== 'scope') {
                        keyArray.push({
                            fn   : val,
                            key,
                            scope: value.scope || componentId // todo: support VCs later on
                        })
                    }
                });

                value = keyArray
            }
        }

        return value
    }

    /**
     * Replaces specific key names, e.g. " " => SPACE
     * @param {String} key
     * @protected
     * @returns {String}
     */
    parseUpperCaseKey(key) {
        switch (key) {
            case ' ':
                key = 'SPACE';
                break
            case 'ARROWDOWN':
                key = 'DOWN';
                break
            case 'ARROWLEFT':
                key = 'LEFT';
                break
            case 'ARROWRIGHT':
                key = 'RIGHT';
                break
            case 'ARROWUP':
                key = 'UP';
                break
        }

        return key
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me = this;

        me.component = component;
        me.keys      = me.parseKeys(me.keys);

        component.addDomListeners({
            keydown: {
                bubble: me.keyDownEventBubble,
                fn    : me.onKeyDown,
                scope : me
            }
        })
    }

    /**
     * Remove a key listener using the same config used when creating it
     * @param {Object} config
     */
    removeKey(config) {
        let me   = this,
            keys = me._keys,
            i    = 0,
            len  = keys.length,
            key;

        for (; i < len; i++) {
            key = keys[i];

            if (Neo.isEqual(key, config)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(keys, key);
                break
            }
        }
    }

    /**
     * Remove multiple key listeners passing an array of config items
     * @param {Array} items
     */
    removeKeys(items) {
        Array.isArray(items) && items.forEach(item => this.removeKey(item))
    }

    /**
     *
     */
    unregister() {
        // todo: remove the dom listener from the owner component
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(KeyNavigation));


/***/ }),

/***/ "./src/util/Rectangle.mjs":
/*!********************************!*\
  !*** ./src/util/Rectangle.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Rectangle)
/* harmony export */ });
/**
 * The class contains utility methods for working with DOMRect Objects
 * @class Neo.util.Rectangle
 * @extends DOMRect
 */

const
    emptyArray = Object.freeze([]),
    // Convert edge array values into the [T,R,B,L] form.
    parseEdgeValue = (e = 0) => {
        if (!Array.isArray(e)) {
            e = [e];
        }
        switch (e.length) {
            case 1:
                e.length = 4;
                return e.fill(e[0], 1, 4);
            case 2:// top&bottom, left&right
                return [e[0], e[1], e[0], e[1]];
            case 3:// top, left&right, bottom
                return [e[0], e[1], e[2], e[1]];
        }
        return e;
    },
    parseEdgeAlign = edgeAlign => {
        const
            edgeParts     = edgeAlignRE.exec(edgeAlign),
            ourEdgeZone   = edgeZone[edgeParts[1]],
            theirEdgeZone = edgeZone[edgeParts[4]];

        return {
            ourEdge         : edgeParts[1],
            ourEdgeOffset   : parseInt(edgeParts[2] || 50),
            ourEdgeUnit     : edgeParts[3] || '%',
            ourEdgeZone,
            theirEdge       : edgeParts[4],
            theirEdgeOffset : parseInt(edgeParts[5] || 50),
            theirEdgeUnit   : edgeParts[6] || '%',
            theirEdgeZone,

            // Aligned to an edge, *outside* of the target.
            // A normal align as a combo dropdown might request
            edgeAligned     : (ourEdgeZone & 1) === (theirEdgeZone & 1) && ourEdgeZone !== theirEdgeZone
        }
    },
    // The opposite of parseEdgeAlign, and it has to flip the edges
    createReversedEdgeAlign = edges => {
        const
            ourEdge   = oppositeEdge[edges.ourEdge],
            theirEdge = oppositeEdge[edges.theirEdge];

        // reconstitute a rule string with the edges flipped to the opposite sides
        return `${ourEdge}${edges.ourEdgeOffset}${edges.ourEdgeUnit}-${theirEdge}${edges.theirEdgeOffset}${edges.theirEdgeUnit}`

    },
    getElRect = el => {
        const r = el instanceof DOMRect ? el : (el?.nodeType === 1 ? el : typeof el === 'string' ? document.getElementById(el) : null)?.getBoundingClientRect();

        // Convert DOMRect into Rectangle
        return r && new Rectangle(r.x, r.y, r.width, r.height);
    },
    oppositeEdge = {
        t : 'b',
        r : 'l',
        b : 't',
        l : 'r'
    },
    edgeZone = {
        t : 0,
        r : 1,
        b : 2,
        l : 3
    },
    zoneNames = ['top', 'right', 'bottom', 'left'],
    zoneEdges = ['t', 'r', 'b', 'l'],
    zoneDimension = ['width', 'height'],
    zoneCoord = [0, 1, 0, 1],
    zeroMargins = [0, 0, 0, 0],
    edgeAlignRE = /^([trblc])(\d*)(%|px)?-([trblc])(\d*)(%|px)?$/;

class Rectangle extends DOMRect {
    static config = {
        /**
         * @member {String} className='Neo.util.Rectangle'
         * @protected
         */
        className: 'Neo.util.Rectangle'
    }

    /**
     * @member {Number|null} minHeight=null
     */
    minHeight = null
    /**
     * @member {Number|null} minWidth=null
     */
    minWidth = null

    /**
     * Checks if rect1 does not have an intersection with rect2
     * !includes() is true for intersections as well
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static excludes(rect1, rect2) {
        return rect1.bottom < rect2.top     // rect2 is below rect1
            || rect1.left   > rect2.right   // rect2 is left of rect1
            || rect1.right  < rect2.left    // rect2 is right of rect1
            || rect1.top    > rect2.bottom; // rect2 is above rect1
    }

    /**
     * Returns the overlapping area of rect1 & rect2
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Number} The area (x * y)
     */
    static getIntersection(rect1, rect2) {
        return Rectangle.getIntersectionDetails(rect1, rect2).area;
    }

    /**
     * Returns the overlapping area of rect1 & rect2
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Object} x, y & area
     */
    static getIntersectionDetails(rect1, rect2) {
        let width  = Math.max(0, Math.min(rect1.right,  rect2.right)  - Math.max(rect1.left, rect2.left)),
            height = Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top,  rect2.top));

        return {
            area: height * width,
            height,
            width
        };
    }

    /**
     * Checks if rect2 is fully contained inside rect1
     * @param {Object} rect1
     * @param {Object} rect2
     * @returns {Boolean}
     */
    static includes(rect1, rect2) {
        return rect1.bottom >= rect2.bottom
            && rect1.left   <= rect2.left
            && rect1.right  >= rect2.right
            && rect1.top    <= rect2.top;
    }

    /**
     * Checks if rect2 is not contained inside rect1.
     * This could be an intersection or being fully excluded.
     * @param {Object} rect1
     * @param {Object} rect2
     * @param {String} side bottom, left, right or top
     * @returns {Boolean}
     */
    static leavesSide(rect1, rect2, side) {
        if (Rectangle.includes(rect1, rect2)) {
            return false;
        }

        if (side === 'bottom') {
            return rect1.bottom < rect2.bottom;
        }

        if (side === 'left') {
            return rect1.left > rect2.left;
        }

        if (side === 'right') {
            return rect1.right < rect2.right;
        }

        if (side === 'top') {
            return rect1.top > rect2.top;
        }
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveBy(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  += x;
            movedRect.right += x;
            movedRect.x     += x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom += y;
            movedRect.top    += y;
            movedRect.y      += y;
        }

        return movedRect;
    }

    /**
     * Adjusts a DOMRect object to a new position
     * @param {Object} rect
     * @param {Number|null} [x=null]
     * @param {Number|null} [y=null]
     * @returns {Object} movedRect
     */
    static moveTo(rect, x=null, y=null) {
        let movedRect = {...rect};

        if (Neo.isNumber(x)) {
            movedRect.left  = x;
            movedRect.right = x + movedRect.width;
            movedRect.x     = x;
        }

        if (Neo.isNumber(y)) {
            movedRect.bottom = y + movedRect.height;
            movedRect.top    = y;
            movedRect.y      = y;
        }

        return movedRect;
    }

    set bottom(b) {
        this.height += b - this.bottom;
    }
    get bottom() {
        return super.bottom;
    }

    set right(r) {
        this.width += r - this.right;
    }
    get right() {
        return super.right;
    }

    // Change the x without moving the Rectangle. The left side moves and the right side doesn't
    changeX(x) {
        const widthDelta = this.x - x;

        this.x = x;
        this.width += widthDelta;
    }

    // Change the y without moving the Rectangle. The top side moves and the bottom side doesn't
    changeY(y) {
        const heightDelta = this.y - y;

        this.y = y;
        this.height += heightDelta;
    }

    clone() {
        return Rectangle.clone(this);
    }

    static clone(r) {
        const result = new Rectangle(r.x, r.y, r.width, r.height);

        result.minWidth = r.minWidth;
        result.minHeight = r.minHeight;

        return result;
    }

    intersects(other) {
        const me = this;

        if (other.height && other.width) {
            const
                left   = Math.max(me.x, other.x),
                top    = Math.max(me.y, other.y),
                right  = Math.min(me.x + me.width, other.x + other.width),
                bottom = Math.min(me.y + me.height, other.y + other.height);

            if (left >= right || top >= bottom) {
                return false;
            }

            return new Rectangle(left, top, right - left, bottom - top);
        }
        // We're dealing with a point here - zero dimensions
        else {
            return (other.x >= me.x && other.y >= me.y && other.right <= me.right && other.bottom <= me.bottom);
        }
    }

    /**
     * Checks if the other Rectangle is fully contained inside this Rectangle
     * @param {Object} other
     * @returns {Boolean}
     */
    contains(other) {
        return this.bottom >= other.bottom
            && this.left   <= other.left
            && this.right  >= other.right
            && this.top    <= other.top;
    }

    /**
     * Returns a clone of this Rectangle expanded according to the edges array.
     * @param {Number[]} edges
     * @returns {Rectangle}
     */
    expand(edges) {
        edges = parseEdgeValue(edges);

        return new this.constructor(this.x - edges[3], this.y - edges[0], this.width + edges[1] + edges[3], this.height + edges[0] + edges[2]);
    }

    moveBy(x = 0, y = 0) {
        const result = this.clone();

        if (Array.isArray(x)) {
            y = x[1];
            x = x[0];
        }
        result.x += x;
        result.y += y;
        return result;
    }

    /**
     * Returns `true` if this Rectangle completely contains the other Rectangle
     * @param {Rectangle} other
     */
    contains(other) {
        return this.constructor.includes(this, other);
    }

    /**
     * Returns a copy of this Rectangle constrained to fit within the passed Rectangle
     * @param {Rectangle} constrainTo
     * @returns {Rectangle|Boolean} A new Rectangle constrained to te passed Rectangle, or false if it could not be constrained.
     */
    constrainTo(constrainTo) {
        const
            me        = this,
            minWidth  = me.minWidth  || me.width,
            minHeight = me.minHeight || me.height;

        // Not possible, even when shrunk to minima
        if (minHeight > constrainTo.height || minWidth > constrainTo.width) {
            return false;
        }

        // We do not mutate this Rectangle, but return a constrained version
        const result = me.clone();

        // Translate result so that the top and left are visible
        result.x = Math.max(me.x + Math.min(constrainTo.right  - result.right,  0), constrainTo.x);
        result.y = Math.max(me.y + Math.min(constrainTo.bottom - result.bottom, 0), constrainTo.y);

        // Pull in any resulting overflow
        result.bottom = Math.min(result.bottom, constrainTo.bottom);
        result.right = Math.min(result.right, constrainTo.right);

        return result;
    }

    alignTo(align) {
        const
            me             = this,
            {
                constrainTo,    // Element or Rectangle result must fit into
                target,         // Element or Rectangle to align to
                edgeAlign,      // t50-b50 type string
                axisLock,       // true for flip, 'flexible' for flip, then try the other edges
                offset,         // Final [x, y] vector to move the result by.
                matchSize
            }              = align,
            targetMargin   = align.targetMargin ? parseEdgeValue(align.targetMargin) : zeroMargins,
            targetRect     = getElRect(target),
            constrainRect  = getElRect(constrainTo),
            edges          = parseEdgeAlign(edgeAlign),
            matchDimension = zoneDimension[edges.theirEdgeZone & 1];

        let result = me.clone();

        if (matchSize) {
            result[matchDimension] = targetRect[matchDimension];
        }

        // Must do the calculations after the aligned side has been matched in size if requested.
        const
            myPoint     = result.getAnchorPoint(edges.ourEdgeZone, edges.ourEdgeOffset, edges.ourEdgeUnit),
            targetPoint = targetRect.getAnchorPoint(edges.theirEdgeZone, edges.theirEdgeOffset, edges.theirEdgeUnit, targetMargin),
            vector      = [targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]];

        result = result.moveBy(vector);

        // A useful property in the resulting rectangle which specifies which zone of the target
        // It is being places in, T,R,B or L - 0, 1, 2, 3
        // Some code may want to treat DOM elements differently depending on the zone
        result.zone = edges.theirEdgeZone;
        result.position = zoneNames[result.zone];

        // Now we create the four Rectangles around the target, into which we may be constrained
        // Zones T,R,B,L 0 9, 1, 2, 3:
        // +-----------------------------------------------------------------------------------+
        // | +-------------------------+------------------------+----------------------------+ |
        // | |          ^              |                        |             ^              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+---------Zone 0---------+-------------+---------->   | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | +----------+--------------+------------------------+-------------+--------------+ |
        // | |          |              | +--------------------+ |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |       Zone 3            | |                    | |          Zone 1            | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | |                    | |             |              | |
        // | |          |              | +--------------------+ |             |              | |
        // | ++---------+--------------+------------------------+-------------+--------------+ |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |          |              |                        |             |              | |
        // | |  <-------+--------------+--------Zone 2----------+-------------+------------> | |
        // | |          |              |                        |             |              | |
        // | |          v              |                        |             v              | |
        // | ++------------------------+------------------------+----------------------------+ |
        // +-----------------------------------------------------------------------------------+
        if (constrainRect && !constrainRect.contains(result)) {
            // They asked to overlap the target, for example t0-t0
            // In these cases, we just return the result
            if (targetRect.intersects(result)) {
                return result;
            }

            // This is the zone we try to fit into first, the one that was asked for
            let zone = edges.theirEdgeZone;

            // We create an array of four rectangles into which we try to fit with appropriate align specs.
            // We must start with the requested zone, whatever that is.
            const zonesToTry = [{
                zone,
                edgeAlign
            }];

            if (axisLock) {
                // Flip to the opposite side for the second try.
                // The alignment string has to be reversed
                // so r20-l30 has to become l20-r30.
                // The other two zones revert to centered so are easier
                zonesToTry[1] = {
                    zone      : zone = (zone + 2) % 4,
                    edgeAlign : createReversedEdgeAlign(edges)
                }

                // Fall back to the other two zones.
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 1) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
                zonesToTry.push({
                    zone      : zone = (edges.theirEdgeZone + 3) % 4,
                    edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                });
            }
            else {
                // go through the other zones in order
                for (let i = 1; i < 4; i++) {
                    zonesToTry.push({
                        zone      : zone = (zone + 1) % 4,
                        edgeAlign : `${oppositeEdge[zoneEdges[zone]]}-${zoneEdges[zone]}`
                    });
                }
            }

            // Calculate the constraint Rectangle for each zone
            for (let i = 0; i < zonesToTry.length; i++) {
                // We clone the outer constraining rectangle
                // and move it into position
                const c = constrainRect.clone();

                switch (zonesToTry[i].zone) {
                    case 0:
                        // The zone i2 above the target - zone 0/T
                        c.bottom = targetRect.y - targetMargin[0];
                        break;
                    case 1:
                        // The zone is to the right of the target - zone 1/R
                        c.changeX(targetRect.right + targetMargin[1]);
                        break;
                    case 2:
                        // The zone is below the target - zone 2/B
                        c.changeY(targetRect.bottom + targetMargin[2]);
                        break;
                    case 3:
                        // The zone is to the left of the target - zone 3/L
                        c.right = targetRect.x - targetMargin[3];
                        break;
                }
                zonesToTry[i].constrainRect = c;
            }

            // Now try to constrain our result into each zone's constraintZone
            for (let i = 0; i < zonesToTry.length; i++) {
                const
                    {
                        zone,
                        edgeAlign,
                        constrainRect
                    }    = zonesToTry[i],
                    edge = zoneEdges[zone];

                if (matchSize) {
                    // If we are aligning to the requested edge, or it's opposite edge then
                    // match that edge size, else revert it to our own size
                    result[matchDimension] = edge === edges.theirEdge || edge == oppositeEdge[edges.theirEdge] ? targetRect[matchDimension] : me[matchDimension];
                }

                // Do a simple align to the current edge
                result = result.alignTo({
                    target : targetRect,
                    edgeAlign,
                    targetMargin
                });

                let solution = result.constrainTo(constrainRect);

                // As soon as we find a zone into which the result is willing to be constrained. return it
                if (solution) {
                    solution.zone = zone;
                    solution.position = zoneNames[zone];
                    return solution;
                }
            }
        }

        // Add the configurable finishing touch.
        if (offset) {
            result.moveBy(offset);
        }

        return result;
    }

    getAnchorPoint(edgeZone, edgeOffset, edgeUnit, margin = emptyArray) {
        const me = this;

        let result;

        // Edge zones go top, right, bottom, left
        // Each one calculates the start point of that edge then moves along it by
        // the edgeOffset, then moves *away* from it by the margin for that edge if there's a margin.
        switch (edgeZone) {
            case 0:
                result = [me.x, me.y - (margin[0] || 0), me.width, 0];
                break;
            case 1:
                result = [me.x + me.width + (margin[1] || 0), me.y, me.height, 1];
                break;
            case 2:
                result = [me.x, me.y + me.height + (margin[2] || 0), me.width, 0];
                break;
            case 3:
                result = [me.x - (margin[3] || 0), me.y, me.height, 1];
        }
        result[result[3]] += edgeUnit === '%' ? result[2] / 100 * edgeOffset : edgeOffset;
        result.length = 2;
        return result;
    }

    equals(other) {
        return other instanceof DOMRect &&
            other.x === this.x &&
            other.y === this.y &&
            other.height === this.height &&
            other.width === this.width;
    }

    // For debugging purposes only
    show(color = 'red') {
        const div = document.createElement('div');

        div.style = `
            position:absolute;
            transform:translate3d(${this.x}px, ${this.y}px, 0);
            height:${this.height}px;
            width:${this.width}px;
            background-color:${color}
        `;
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 30000);
        return div;
    }

    /**
     * When using JSON.stringify(this), we want to add minHeight & minWidth to the output.
     * @returns {Object}
     */
    toJSON() {
        const {bottom, height, left, minHeight, minWidth, right, top, width, x, y} = this;
        return {bottom, height, left, minHeight, minWidth, right, top, width, x, y}
    }
}


/***/ }),

/***/ "./src/util/Style.mjs":
/*!****************************!*\
  !*** ./src/util/Style.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Style
 * @extends Neo.core.Base
 */
class Style extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Style'
         * @protected
         */
        className: 'Neo.util.Style'
    }

    /**
     * Creates an delta object, containing the styles of newStyle which are not included or different than in oldStyle
     * Styles included in oldStyle but missing in newStyle will get a value of null
     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
     * @param {Object|String} newStyle
     * @param {Object|String} oldStyle
     * @returns {Object} style delta
     */
    static compareStyles(newStyle, oldStyle) {
        let styles = {};

        if (Neo.isString(newStyle)) {
            newStyle = Neo.createStyleObject(newStyle)
        }

        if (Neo.isString(oldStyle)) {
            oldStyle = Neo.createStyleObject(oldStyle)
        }

        if (!newStyle && !oldStyle) {
            return null
        } else if (!oldStyle) {
            return Neo.clone(newStyle)
        } else if (!newStyle) {
            Object.keys(oldStyle).forEach(function(style) {
                styles[style] = null
            });
        } else {
            Object.keys(newStyle).forEach(style => {
                if (!oldStyle.hasOwnProperty(style) || oldStyle[style] !== newStyle[style]) {
                    styles[style] = newStyle[style]
                }
            });

            Object.keys(oldStyle).forEach(style => {
                if (!newStyle.hasOwnProperty(style)) {
                    styles[style] = null
                }
            });

            if (Object.keys(styles).length > 0) {
                return styles
            }

            return null
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Style));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDTztBQUNDO0FBQ0Q7QUFDRTtBQUNQO0FBQ0Q7QUFDSztBQUNEO0FBQ0o7QUFDRDtBQUNBO0FBQ0M7O0FBRWpEO0FBQ0EscUZBQXFGLE1BQU07QUFDM0Y7QUFDQTtBQUNBLEtBQUssbUJBQW1CO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBSTtBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixp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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsdURBQVE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWUsdURBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEIsR0FBRyxnQkFBZ0I7QUFDcEYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCLEdBQUcsZ0JBQWdCO0FBQ3BGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsdUNBQXVDLDhCQUE4QixHQUFHLGdCQUFnQjtBQUN4RixxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU8sTUFBTSxPQUFPO0FBQ3hELHFCQUFxQixZQUFZO0FBQ2pDLG9CQUFvQixXQUFXO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWUsb0VBQW9FO0FBQ25GLGdCQUFnQjtBQUNoQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL2xCb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFJO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9LZXlOYXZpZ2F0aW9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvUmVjdGFuZ2xlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvU3R5bGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCAgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcbmltcG9ydCBEb21FdmVudE1hbmFnZXIgIGZyb20gJy4uL21hbmFnZXIvRG9tRXZlbnQubWpzJztcbmltcG9ydCBLZXlOYXZpZ2F0aW9uICAgIGZyb20gJy4uL3V0aWwvS2V5TmF2aWdhdGlvbi5tanMnO1xuaW1wb3J0IExvZ2dlciAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9Mb2dnZXIubWpzJztcbmltcG9ydCBOZW9BcnJheSAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSAgICAgICAgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcbmltcG9ydCBTdHlsZSAgICAgICAgICAgIGZyb20gJy4uL3V0aWwvU3R5bGUubWpzJztcbmltcG9ydCBVdGlsICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvVXRpbC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5pbXBvcnQgVk5vZGVVdGlsICAgICAgICBmcm9tICcuLi91dGlsL1ZOb2RlLm1qcyc7XG5cbmNvbnN0XG4gICAgYWRkVW5pdHMgICAgICAgICAgICA9IHZhbHVlID0+IHZhbHVlID09IG51bGwgPyB2YWx1ZSA6IGlzTmFOKHZhbHVlKSA/IHZhbHVlIDogYCR7dmFsdWV9cHhgLFxuICAgIGNsb3Nlc3RDb250cm9sbGVyICAgPSBTeW1ib2wuZm9yKCdjbG9zZXN0Q29udHJvbGxlcicpLFxuICAgIGNsb3Nlc3RQcm92aWRlciAgICAgPSBTeW1ib2wuZm9yKCdjbG9zZXN0UHJvdmlkZXInKSxcbiAgICB7Y3VycmVudFdvcmtlcn0gICAgID0gTmVvLFxuICAgIGxlbmd0aFJFICAgICAgICAgICAgPSAvXlxcZCtcXHcrJC8sXG4gICAgdHdvV2F5QmluZGluZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ3R3b1dheUJpbmRpbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgQ29tcG9uZW50cyB3aGljaCBoYXZlIGEgRE9NIHJlcHJlc2VudGF0aW9uXG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgaGlkZU1vZGVcbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gaGlkZU1vZGVzPVsncmVtb3ZlRG9tJywndmlzaWJpbGl0eSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgaGlkZU1vZGVzID0gWydyZW1vdmVEb20nLCAndmlzaWJpbGl0eSddXG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBhbGlnbm1lbnQgc3BlY2lmaWNhdGlvbiB0byBwb3NpdGlvbiB0aGlzIENvbXBvbmVudCByZWxhdGl2ZSB0byBzb21lIG90aGVyXG4gICAgICAgICAqIENvbXBvbmVudCwgb3IgRWxlbWVudCBvciBSZWN0YW5nbGUuIE9ubHkgYXBwbGllcyBpbiBjYXNlIGZsb2F0aW5nID0gdHJ1ZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ30gYWxpZ25fPXtlZGdlQWxpZ246J3QtYicsY29uc3RyYWluVG86J2RvY3VtZW50LmJvZHknfVxuICAgICAgICAgKi9cbiAgICAgICAgYWxpZ25fOiB7XG4gICAgICAgICAgICBlZGdlQWxpZ24gIDogJ3QtYicsXG4gICAgICAgICAgICBjb25zdHJhaW5UbzogJ2RvY3VtZW50LmJvZHknXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgQXBwIHRoaXMgY29tcG9uZW50IGJlbG9uZ3MgdG9cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFwcE5hbWVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IG1vdW50cyBhIGNvbXBvbmVudCBhZnRlciBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgICogVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWwgY29tcG9uZW50IG9mIHlvdXIgYXBwLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9ZmFsc2VcbiAgICAgICAgICogQHR1dG9yaWFsIDAyX0NsYXNzU3lzdGVtXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTW91bnQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IHJlbmRlcnMgYSBjb21wb25lbnQgYWZ0ZXIgYmVpbmcgY3JlYXRlZCBpbnNpZGUgdGhlIGluaXQgY2FsbC5cbiAgICAgICAgICogVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWwgY29tcG9uZW50IG9mIHlvdXIgYXBwLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvUmVuZGVyPWZhbHNlXG4gICAgICAgICAqIEBzZWUge0BsaW5rIE5lby5jb21wb25lbnQuQmFzZSNpbml0IGluaXR9XG4gICAgICAgICAqIEB0dXRvcmlhbCAwMl9DbGFzc1N5c3RlbVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1JlbmRlcjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDU1Mgc2VsZWN0b3JzIHRvIGFwcGx5IHRvIHRoZSByb290IGxldmVsIG5vZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9W11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBjb25maWdzIHRvIHN0YXRlLlByb3ZpZGVyIGRhdGEgcHJvcGVydGllcy5cbiAgICAgICAgICogRXhhbXBsZSBmb3IgYSBidXR0b24uQmFzZTpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYmluZDoge1xuICAgICAgICAgKiAgICAgaWNvbkNsczogZGF0YSA9PiBgZmEgZmEteyRkYXRhLmljb259YCxcbiAgICAgICAgICogICAgIHRleHQgICA6IGRhdGEgPT4gZGF0YS5mb28uYmFyXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9ibG9iL2Rldi9leGFtcGxlcy9zdGF0ZVByb3ZpZGVyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBiaW5kPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXN0b20gQ1NTIHNlbGVjdG9ycyB0byBhcHBseSB0byB0aGUgcm9vdCBsZXZlbCBub2RlIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAqIFlvdSBjYW4gb3ZlcnJpZGUgYmFzZUNscyB0byByZW1vdmUgZGVmYXVsdCBzZWxlY3RvcnMuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHNfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYW5hZ2VyLkZvY3VzIHdpbGwgY2hhbmdlIHRoaXMgZmxhZyBvbiBmb2N1c2luICYgb3V0IGRvbSBldmVudHNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gY29udGFpbnNGb2N1c189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbnNGb2N1c186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzaWduIGEgY29tcG9uZW50IGNvbnRyb2xsZXIgdG8gdGhpcyBjb21wb25lbnQgKHBhc3MgYW4gaW1wb3J0ZWQgbW9kdWxlIG9yIHRoZSBzdHJpbmcgYmFzZWQgY2xhc3MgbmFtZSlcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fFN0cmluZ30gY29udHJvbGxlcl89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29udHJvbGxlcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBhY2Nlc3MgdGhlIGRhdGEgY29uZmlnIG9mIHRoZSBjbG9zZXN0IHN0YXRlLlByb3ZpZGVyLlxuICAgICAgICAgKiBSZWFkIG9ubHkuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVkIGNvbXBvbmVudHMgd2lsbCBnZXQgdGhlIG5lby1kaXNhYmxlZCBjbHMgYXBwbGllZCBhbmQgd29uJ3QgcmVjZWl2ZSBET00gZXZlbnRzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVkXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZWRfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGRvbUxpc3RlbmVyIGNvbmZpZ3NcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W118bnVsbH0gZG9tTGlzdGVuZXJzXz1udWxsXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFmdGVyU2V0U3RheU9uSG92ZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAqICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICogICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhcbiAgICAgICAgICogICAgICAgICAgICAge21vdXNlZW50ZXI6IG1lLm9uTW91c2VFbnRlciwgc2NvcGU6IG1lfSxcbiAgICAgICAgICogICAgICAgICAgICAge21vdXNlbGVhdmU6IG1lLm9uTW91c2VMZWF2ZSwgc2NvcGU6IG1lfVxuICAgICAgICAgKiAgICAgICAgIClcbiAgICAgICAgICogICAgfVxuICAgICAgICAgKn1cbiAgICAgICAgICovXG4gICAgICAgIGRvbUxpc3RlbmVyc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gdHJ1ZSB0byBkeW5hbWljYWxseSBpbXBvcnQgYSBEcm9wWm9uZSBtb2R1bGUgJiBjcmVhdGUgYW4gaW5zdGFuY2VcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZHJvcHBhYmxlXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcHBhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLkRyb3Bab25lfG51bGx9IGRyb3Bab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcm9wWm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wWm9uZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gcmVuZGVyIHRoaXMgY29tcG9uZW50IGludG8gdGhlIHZpZXdwb3J0IG91dHNpZGUgb2YgdGhlIGRvY3VtZW50IGZsb3dcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZmxvYXRpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZsb2F0aW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgb24gbW91bnRcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGFzQmVlbk1vdW50ZWQ9ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzQmVlbk1vdW50ZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNSZW5kZXJpbmdMaXN0ZW5lcj1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBoYXNSZW5kZXJpbmdMaXN0ZW5lcjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIGZvciB2ZG9tIGNoYW5nZXMgYWZ0ZXIgYSBjb21wb25lbnQgZ290IHVubW91bnRlZFxuICAgICAgICAgKiAoZGVsdGEgdXBkYXRlcyBjYW4gbm8gbG9uZ2VyIGdldCBhcHBsaWVkICYgYSBuZXcgcmVuZGVyIGNhbGwgaXMgcmVxdWlyZWQgYmVmb3JlIHJlLW1vdW50aW5nKVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNVbm1vdW50ZWRWZG9tQ2hhbmdlc189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaGFzVW5tb3VudGVkVmRvbUNoYW5nZXNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5oZWlnaHQsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gaGVpZ2h0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWlnaHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbCBzZXR0aW5nIHRvIGhpZGUgb3Igc2hvdyB0aGUgY29tcG9uZW50IGFuZFxuICAgICAgICAgKiB5b3UgY2FuIHVzZSBlaXRoZXIgaGlkZSgpL3Nob3coKSBvciBjaGFuZ2UgdGhpcyBjb25maWcgZGlyZWN0bHkgdG8gY2hhbmdlIHRoZSBoaWRkZW4gc3RhdGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGlkZGVuXz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZGVuXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciBoaWRlIGFuZCBzaG93IGFuZCBkZWZpbmVzIGlmIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogc2hvdWxkIHVzZSBjc3MgdmlzaWJpbGl0eTonaGlkZGVuJyBvciB2ZG9tOnJlbW92ZURvbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGhpZGVNb2RlXz0ncmVtb3ZlRG9tJ1xuICAgICAgICAgKi9cbiAgICAgICAgaGlkZU1vZGVfOiAncmVtb3ZlRG9tJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3AgbGV2ZWwgaW5uZXJIVE1MIG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGh0bWxfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGh0bWxfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGB0cnVlYCB0byBzaG93IGEgc3Bpbm5lciBjZW50ZXJlZCBpbiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBTZXQgdG8gYSBzdHJpbmcgdG8gc2hvdyBhIG1lc3NhZ2UgbmV4dCB0byBhIHNwaW5uZXIgY2VudGVyZWQgaW4gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxTdHJpbmd9IGlzTG9hZGluZz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNMb2FkaW5nXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIHdoaWxlIGFuIHVwZGF0ZSByZXF1ZXN0ICh3b3JrZXIgbWVzc2FnZXMpIGlzIGluIHByb2dyZXNzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVmRvbVVwZGF0aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpc1Zkb21VcGRhdGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNpbmcgdGhlIGtleXMgY29uZmlnIHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIE5lby51dGlsLktleU5hdmlnYXRpb24uXG4gICAgICAgICAqIEBzZWUge0BsaW5rIE5lby51dGlsLktleU5hdmlnYXRpb24gS2V5TmF2aWdhdGlvbn1cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBrZXlzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdXNlZCBpbnNpZGUgYWZ0ZXJTZXRJc0xvYWRpbmcoKSB0byBkZWZpbmUgdGhlIENTUyBmb3IgdGhlIGxvYWRpbmcgc3Bpbm5lciBpY29uXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBsb2FkaW5nU3Bpbm5lckNsc189WydmYScsJ2ZhLXNwaW5uZXInLCdmYS1zcGluJ11cbiAgICAgICAgICovXG4gICAgICAgIGxvYWRpbmdTcGlubmVyQ2xzXzogWydmYScsICdmYS1zcGlubmVyJywgJ2ZhLXNwaW4nXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5tYXhIZWlnaHQsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gbWF4SGVpZ2h0Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtYXhIZWlnaHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1heFdpZHRoLCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG1heFdpZHRoXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtYXhXaWR0aF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCBmb3Igc3R5bGUubWluSGVpZ2h0LCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG1pbkhlaWdodF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWluSGVpZ2h0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5taW5XaWR0aCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtaW5XaWR0aF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWluV2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgc3BlY2lmaWMgc3RhdGVQcm92aWRlciBkYXRhIHByb3BlcnRpZXMuXG4gICAgICAgICAqIFRoaXMgd2lsbCBtZXJnZSB0aGUgY29udGVudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IG1vZGVsRGF0YT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbERhdGE6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGluIGNhc2UgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIHRvIHRoZSBET01cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW91bnRlZF89ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB3aGljaCB3aWxsIGdldCBzZXQgdG8gdHJ1ZSBpbiBjYXNlIGFuIHVwZGF0ZSBjYWxsIGFycml2ZXMgd2hpbGUgYW5vdGhlciB1cGRhdGUgaXMgcnVubmluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBuZWVkc1Zkb21VcGRhdGVfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5lZWRzVmRvbVVwZGF0ZV86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHBhcmVudElkIGRvZXMgbm90IG1hdGNoIGEgbmVvIGNvbXBvbmVudCBpZCwgeW91IGNhbiBtYW51YWxseSBzZXQgdGhpcyB2YWx1ZSBmb3IgZmluZGluZ1xuICAgICAgICAgKiB2aWV3IGNvbnRyb2xsZXJzIG9yIHN0YXRlIHByb3ZpZGVycy5cbiAgICAgICAgICogVXNlIGNhc2U6IG1hbnVhbGx5IGRyb3BwaW5nIGNvbXBvbmVudHMgaW50byBhIHZkb20gc3RydWN0dXJlXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBwYXJlbnRDb21wb25lbnRfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50Q29tcG9uZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJlbnQgY29tcG9uZW50IGlkIG9yIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwYXJlbnRJZF89J2RvY3VtZW50LmJvZHknXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRJZF86ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFycmF5IG9mIFBsdWdpbiBNb2R1bGVzIGFuZCAvIG9yIGNvbmZpZyBvYmplY3RzXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IHBsdWdpbnNfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcGx1Z2luc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSByZWZlcmVuY2UgZm9yIGFjY2Vzc2luZyB0aGUgY29tcG9uZW50IGluc2lkZSB2aWV3IGNvbnRyb2xsZXJzLlxuICAgICAgICAgKiBSZWZlcmVuY2VzIHdpbGwgYWxzbyBnZXQgbWFwcGVkIGludG8gdGhlIHZkb20gcm9vdCAoZGF0YS1yZWY6IHZhbHVlKS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHJlZmVyZW5jZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZWZlcmVuY2VfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZSB0aGUgdmlldyBSZXNwb25zaXZlIGJ5IGFkZGluZyBhbHRlcm5hdGl2ZSBjb25maWdzLlxuICAgICAgICAgKiBUaGUgZGVmaW5pdGlvbiBoYXBwZW5zIHZpYSByZXNwb25zaXZlQ2ZnXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVzcG9uc2l2ZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlc3BvbnNpdmVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyaW5nIHRoZSB2bm9kZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJpbmdfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcmluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIHJvbGUgdGFnIGF0dHJpYnV0ZSBmb3IgdGhlIHZkb20gcm9vdC5cbiAgICAgICAgICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BY2Nlc3NpYmlsaXR5L0FSSUEvUm9sZXNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHJvbGVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHJvbGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBmb3Igc3R5bGUgJ292ZXJmbG93OmF1dG8nLlxuICAgICAgICAgKiBTZXQgdGhpcyB0byAneCcgb3IgJ3knIHRvIGFkZCBzdHlsZSAnb3ZlcmZsb3cteCcgb3IgJ292ZXJmbG93LXknIHRvICdhdXRvJ1xuICAgICAgICAgKiBPdGhlciB0aGFuIGZhbHNlIHRoaXMgd2lsbCBhZGQgY2xzICduZW8tc2Nyb2xsYWJsZScuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW58XCJ4XCJ8XCJ5XCJ9IHNjcm9sbGFibGVfPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGZvciBidWxrIHVwZGF0ZXMuIEVuc3VyZSB0byBzZXQgaXQgYmFjayB0byBmYWxzZSBhZnRlcndhcmRzLlxuICAgICAgICAgKiBJbnRlcm5hbGx5IHRoZSB2YWx1ZSB3aWxsIGdldCBzYXZlZCBhcyBhIG51bWJlciB0byBlbnN1cmUgdGhhdCBjaGlsZCBtZXRob2RzIHdvbid0IHN0b3AgdGhlIHNpbGVudCBtb2RlIHRvbyBlYXJseS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2lsZW50VmRvbVVwZGF0ZV89ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudFZkb21VcGRhdGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsbHkgYWRkIGEgc3RhdGUuUHJvdmlkZXIgdG8gc2hhcmUgc3RhdGUgZGF0YSB3aXRoIGNoaWxkIGNvbXBvbmVudHNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHN0YXRlUHJvdmlkZXJfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlUHJvdmlkZXJfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU3R5bGUgYXR0cmlidXRlcyBhZGRlZCB0byB0aGlzIHZkb20gcm9vdC4gc2VlOiBnZXRWZG9tUm9vdCgpXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gc3R5bGVfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHN0eWxlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gcGFzcyBhIHVzZWQgdGhlbWUgZGlyZWN0bHkgdG8gYW55IGNvbXBvbmVudCxcbiAgICAgICAgICogdG8gc3R5bGUgc3BlY2lmaWMgY29tcG9uZW50IHRyZWVzIGRpZmZlcmVudGx5IGZyb20geW91ciBtYWluIHZpZXcuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0aGVtZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpbGUgaXQgaXMgcmVjb21tZW5kZWQgdG8gZGVmaW5lIHRhZ3MgaW5zaWRlIHRoZSB2ZG9tIG9mIGNsYXNzZXMsXG4gICAgICAgICAqIHRoaXMgc2hvcnRjdXQgZW5hYmxlcyB1cyB0byBjaGFuZ2UgdGhlIHZkb20gcm9vdCB0YWcgb24gaW5zdGFuY2UgbGV2ZWwuXG4gICAgICAgICAqIFVzZSBjYXNlczogc3dpdGNoIGEgVG9vbGJhciB0byBhIFwibmF2XCIgdGFnLCBzd2l0Y2ggYSBTaWRlTmF2IHRvIGFuIFwiYXNpZGVcIiB0YWcuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0YWdfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRhZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgdG9vbHRpcCBjb25maWcgb2JqZWN0IG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGRpc3BsYXkgdGV4dFxuICAgICAgICAgKiBTZWUgdG9vbHRpcC9CYXNlLm1qc1xuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBhIHNpbmdsZSwgc2hhcmVkIFRvb2x0aXAgaW5zdGFuY2UgaXMgdXNlZCBmb3IgYWxsIHdpZGdldHMgd2hpY2ggcmVxdWVzdFxuICAgICAgICAgKiBhIHRvb2x0aXAuIEl0IHJlY29uZmlndXJlcyBpdHNlbGYgZnJvbSB0aGUgd2lkZ2V0J3MgZGVmaW5pdGlvbiBqdXN0IGJlZm9yZSBzaG93aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIHdpZGdldCBuZWVkcyBpdHMgb3duIGluc3RhbmNlIGZvciBhbnkgcmVhc29uLCBpbnNsdWRlIHRoZSBwcm9wZXJ0eSBgb3duSW5zdGFuY2UgOiB0cnVlYFxuICAgICAgICAgKiBpbiB0aGUgdG9vbHRpcCBjb25maWcgb2JqZWN0LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfSB0b29sdGlwXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0b29sdGlwXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCAncHJpbWFyeScgYW5kIG90aGVyIGF0dHJpYnV0ZXMgdG8gbWFrZSBpdCBhbiBvdXRzdGFuZGluZyBkZXNpZ25cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHVpXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB1aV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBkZXB0aCBvZiB0aGUgdmRvbSB0cmVlIGZvciB0aGUgbmV4dCB1cGRhdGUgY3ljbGUuXG4gICAgICAgICAqIC0gVGhlIHZhbHVlIDEgd2lsbCBvbmx5IHNlbmQgdGhlIGN1cnJlbnQgdmRvbSBzdHJ1Y3R1cmUgYXMgaXQgaXNcbiAgICAgICAgICogLSBUaGUgdmFsdWUgb2YgMiB3aWxsIGluY2x1ZGUgdGhlIHZkb20gb2YgZGlyZWN0IGNoaWxkcmVuXG4gICAgICAgICAqIC0gVGhlIHZhbHVlIG9mIDMgd2lsbCBpbmNsdWRlIHRoZSB2ZG9tIG9mIGdyYW5kY2hpbGRyZW5cbiAgICAgICAgICogLSBUaGUgdmFsdWUgb2YgLTEgd2lsbCBpbmNsdWRlIHRoZSBmdWxsIHRyZWUgb2YgYW55IGRlcHRoXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdXBkYXRlRGVwdGhfPTFcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURlcHRoXzogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wb25lbnQgdm5vZGUgdHJlZS4gQXZhaWxhYmxlIGFmdGVyIHRoZSBjb21wb25lbnQgZ290IHJlbmRlcmVkLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZub2RlXz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHZub2RlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS53aWR0aCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSB3aWR0aF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1c3RvbSB3aW5kb3dJcyAodGltZXN0YW1wKSB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW118bnVsbH0gd3JhcHBlckNsc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlckNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcy4gVXNlZnVsIGluIGNhc2UgZ2V0VmRvbVJvb3QoKSBkb2VzIG5vdCBwb2ludCB0byB0aGUgdG9wIGxldmVsIERPTSBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gd3JhcHBlclN0eWxlXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwcGVyU3R5bGVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZkb20gbWFya3VwIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17fVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgYW4gdXBkYXRlKCkgZ2V0cyBjYWxsZWQgd2hpbGUgYSBwYXJlbnQgaXMgdXBkYXRpbmcsIHdlIHN0b3JlIHRoZSBpZCAmIGRpc3RhbmNlIG9mIHRoZVxuICAgICAqIHJlcXVlc3RpbmcgY29tcG9uZW50IGluc2lkZSB0aGUgY2hpbGRVcGRhdGVDYWNoZSBvZiB0aGUgcGFyZW50LCB0byBnZXQgcmVzb2x2ZWQgb25jZSB0aGUgdXBkYXRlIGlzIGRvbmUuXG4gICAgICogZS5nLiBjaGlsZFVwZGF0ZUNhY2hlID0geyduZW8tZ3JpZC12aWV3LTEnOiB7ZGlzdGFuY2U6IDEsIHJlc29sdmU6IGZufX1cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNoaWxkVXBkYXRlQ2FjaGU9e31cbiAgICAgKi9cbiAgICBjaGlsZFVwZGF0ZUNhY2hlID0ge31cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIHVwZGF0ZURlcHRoIHdoaWxlIGFuIHVwZGF0ZSBpcyBydW5uaW5nIHRvIGVuYWJsZSBjaGVja3MgZm9yIHBhcmVudCB1cGRhdGUgY29sbGlzaW9uc1xuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBjdXJyZW50VXBkYXRlRGVwdGg9bnVsbFxuICAgICAqL1xuICAgIGN1cnJlbnRVcGRhdGVEZXB0aCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbltdfSByZXNvbHZlVXBkYXRlQ2FjaGU9W11cbiAgICAgKi9cbiAgICByZXNvbHZlVXBkYXRlQ2FjaGUgPSBbXVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWNjZXNzIHRoZSBBcHAgdGhpcyBjb21wb25lbnQgYmVsb25ncyB0b1xuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5BcHBsaWNhdGlvbnxudWxsfVxuICAgICAqL1xuICAgIGdldCBhcHAoKSB7XG4gICAgICAgIHJldHVybiBOZW8uYXBwc1t0aGlzLmFwcE5hbWVdIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBDb21wb25lbnQgaXMgZnVsbHkgdmlzaWJsZSwgdGhhdCBpcyBpdCBpcyBub3QgaGlkZGVuIGFuZCBoYXMgbm8gaGlkZGVuIGFuY2VzdG9yc1xuICAgICAqL1xuICAgIGdldCBpc1Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdW50ZWQgJiYgIXRoaXMuaGlkZGVuICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNWaXNpYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBjb21wb25lbnQgYmFzZWQgbGlzdGVuZXJzXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBsaXN0ZW5lcnM9e31cbiAgICAgKi9cbiAgICBnZXQgbGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzIHx8IHt9XG4gICAgfVxuICAgIHNldCBsaXN0ZW5lcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWNjZXNzIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLnBhcmVudENvbXBvbmVudCB8fCBtZS5wYXJlbnRJZCA9PT0gJ2RvY3VtZW50LmJvZHknID8gbnVsbCA6IE5lby5nZXRDb21wb25lbnQobWUucGFyZW50SWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBhZnRlciB0aGUgY29tcG9uZW50IHJlbmRlcigpIG1ldGhvZCB3YXMgY2FsbGVkLiBBbHNvIGZpcmVzIHRoZSByZW5kZXJlZCBldmVudC5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW5kZXJlZD1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZCB8fCBmYWxzZVxuICAgIH1cbiAgICBzZXQgcmVuZGVyZWQodmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fcmVuZGVyZWQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3JlbmRlcmVkJywgbWUuaWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0dGVyIHdpbGwgaGFuZGxlIHZkb20gdXBkYXRlcyBhdXRvbWF0aWNhbGx5XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tPXRoaXMuX3Zkb21cbiAgICAgKi9cbiAgICBnZXQgdmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zkb21cbiAgICB9XG4gICAgc2V0IHZkb20odmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZnRlclNldFZkb20odmFsdWUsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBjbHMgdG8gdGhlIHZkb21Sb290XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgYWRkQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gYWRkIGFkZGl0aW9uYWwgZG9tIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqL1xuICAgIGFkZERvbUxpc3RlbmVycyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkb21MaXN0ZW5lcnMgPSB0aGlzLmRvbUxpc3RlbmVycztcblxuICAgICAgICBkb21MaXN0ZW5lcnMucHVzaCguLi52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5kb21MaXN0ZW5lcnMgPSBkb21MaXN0ZW5lcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFaXRoZXIgYSBzdHJpbmcgbGlrZSAnY29sb3I6IHJlZDsgYmFja2dyb3VuZC1jb2xvcjogYmx1ZTsnXG4gICAgICogb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgc3R5bGUgYXR0cmlidXRlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhbGwgc3R5bGVzIG9mIHRoaXMuZWxcbiAgICAgKi9cbiAgICBhZGRTdHlsZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBVdGlsLmNyZWF0ZVN0eWxlT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZG86IGFkZCBhIGNoZWNrIGlmIHNvbWV0aGluZyBoYXMgY2hhbmdlZFxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlID0gT2JqZWN0LmFzc2lnbih0aGlzLnN0eWxlLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGNscyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgPSBvbGRWYWx1ZSB8fCBbXTtcblxuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgdmRvbSAgICAgPSBtZS52ZG9tLFxuICAgICAgICAgICAgdmRvbVJvb3QgPSBtZS5nZXRWZG9tUm9vdCgpLFxuICAgICAgICAgICAgY2xzO1xuXG4gICAgICAgIGlmICh2ZG9tICE9PSB2ZG9tUm9vdCkge1xuICAgICAgICAgICAgLy8gd2UgYXJlIHVzaW5nIGEgd3JhcHBlciBub2RlXG4gICAgICAgICAgICB2ZG9tUm9vdC5jbHMgPSBbLi4udmFsdWVdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIGNoYW5nZXNcbiAgICAgICAgICAgIGNscyA9IE5lb0FycmF5LnVuaW9uKG1lLndyYXBwZXJDbHMsIHZhbHVlKTtcbiAgICAgICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkVmFsdWUsIHZhbHVlKSk7XG4gICAgICAgICAgICB2ZG9tLmNscyA9IGNsc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmlzVmRvbVVwZGF0aW5nIHx8IG1lLnNpbGVudFZkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIG1lLm5lZWRzVmRvbVVwZGF0ZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChtZS5tb3VudGVkICYmIG1lLnZub2RlKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVDbHModmFsdWUsIG9sZFZhbHVlLCB2ZG9tUm9vdC5pZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciBhbnkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q29uZmlnKGtleSwgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRXb3JrZXIuaXNVc2luZ1N0YXRlUHJvdmlkZXJzICYmIG1lW3R3b1dheUJpbmRpbmdTeW1ib2xdICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBiaW5kaW5nID0gbWUuYmluZD8uW2tleV07XG5cbiAgICAgICAgICAgIGlmIChiaW5kaW5nPy50d29XYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKT8uc2V0RGF0YShiaW5kaW5nLmtleSwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpc2FibGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlzYWJsZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheVt2YWx1ZSA/ICdhZGQnIDogJ3JlbW92ZSddKGNscywgJ25lby1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZG9tTGlzdGVuZXJzIGluc2lkZSB0aGUgTmVvLm1hbmFnZXIuRG9tRXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9tTGlzdGVuZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZT8uWzBdIHx8IG9sZFZhbHVlPy5bMF0pIHtcbiAgICAgICAgICAgIG1lLmdldENvbnRyb2xsZXIoKT8ucGFyc2VEb21MaXN0ZW5lcnMobWUpO1xuXG4gICAgICAgICAgICBEb21FdmVudE1hbmFnZXIudXBkYXRlRG9tTGlzdGVuZXJzKG1lLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyb3BwYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERyb3BwYWJsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgIW1lLmRyb3Bab25lKSB7XG4gICAgICAgICAgICBpbXBvcnQoJy4uL2RyYWdnYWJsZS9Ecm9wWm9uZS5tanMnKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZHJvcFpvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlICA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3duZXIgICA6IG1lLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1lLmRyb3Bab25lQ29uZmlnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZsZXggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmxleCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7dmFsdWV9ICR7dmFsdWV9IDAlYFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25maWd1cmVkRmxleCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdmbGV4JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoYXNVbm1vdW50ZWRWZG9tQ2hhbmdlcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhhc1VubW91bnRlZFZkb21DaGFuZ2VzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgfHwgKCF2YWx1ZSAmJiBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRJZHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudElkcyh0aGlzKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgICA9IHBhcmVudElkcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZHNbaV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuX2hhc1VubW91bnRlZFZkb21DaGFuZ2VzID0gdmFsdWUgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGVpZ2h0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhlaWdodCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkSGVpZ2h0ID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdoZWlnaHQnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGhpZGRlbiBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEhpZGRlbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHN0YXRlID0gdmFsdWUgPyAnaGlkZScgOiAnc2hvdyc7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG9sZFZhbHVlID09PSB1bmRlZmluZWQgJiYgbWUuaGlkZU1vZGUgPT09ICdyZW1vdmVEb20nKSB7XG4gICAgICAgICAgICBtZS52ZG9tLnJlbW92ZURvbSA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSB8fCBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZVtzdGF0ZV0oKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgbWUucmV2ZXJ0Rm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmZpcmUoc3RhdGUsIHtpZDogbWUuaWR9KTtcbiAgICAgICAgbWUuZmlyZSgnaGlkZGVuQ2hhbmdlJywge2lkOiBtZS5pZCwgb2xkVmFsdWUsIHZhbHVlfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGh0bWwgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEh0bWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2h0bWwnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdpZCcsIHZhbHVlKTtcblxuICAgICAgICBvbGRWYWx1ZSAmJiBDb21wb25lbnRNYW5hZ2VyLnVucmVnaXN0ZXIob2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAgICAmJiBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc0xvYWRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzTG9hZGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIHx8IG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAge2NscywgdmRvbX0gPSBtZSxcbiAgICAgICAgICAgICAgICBtYXNrSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZkb20uY24pIHtcbiAgICAgICAgICAgICAgICBtYXNrSW5kZXggPSB2ZG9tLmNuLmZpbmRMYXN0SW5kZXgoYyA9PiBjLmNscz8uaW5jbHVkZXMoJ25lby1sb2FkLW1hc2snKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxvYWQgbWFza1xuICAgICAgICAgICAgICAgIGlmIChtYXNrSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24uc3BsaWNlKG1hc2tJbmRleCwgMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghdmRvbS5jbikge1xuICAgICAgICAgICAgICAgICAgICB2ZG9tLmNuID0gW11cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2ZG9tLmNuLnB1c2gobWUuY3JlYXRlTG9hZGluZ01hc2sodmFsdWUpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCAnbmVvLW1hc2tlZCcsIHZhbHVlKTtcbiAgICAgICAgICAgIG1lLnNldCh7Y2xzLCB2ZG9tfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNWZG9tVXBkYXRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzVmRvbVVwZGF0aW5nKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRVcGRhdGVEZXB0aCA9IHZhbHVlID8gdGhpcy51cGRhdGVEZXB0aCA6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heEhlaWdodCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhIZWlnaHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1heEhlaWdodCA9IGFkZFVuaXRzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnbWF4SGVpZ2h0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXhXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkTWF4V2lkdGggPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21heFdpZHRoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtaW5IZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluSGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRNaW5IZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21pbkhlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluV2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluV2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1pbldpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdtaW5XaWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtpZCwgd2luZG93SWR9ID0gbWU7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmhhc0JlZW5Nb3VudGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5kb21MaXN0ZW5lcnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogdGhlIG1haW4gdGhyZWFkIHJlcGx5IG9mIG1vdW50IGFycml2ZXMgYWZ0ZXIgcHVzaGluZyB0aGUgdGFzayBpbnRvIHRoZSBxdWV1ZSB3aGljaCBkb2VzIG5vdCBlbnN1cmUgdGhlIGRvbSBpcyBtb3VudGVkXG4gICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoMTUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERvbUV2ZW50TWFuYWdlci5tb3VudERvbUxpc3RlbmVycyhtZSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5kb1Jlc29sdmVVcGRhdGVDYWNoZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLmZsb2F0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsaWduVG8oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb2N1cyB3aWxsIGJlIHB1c2hlZCBpbnRvIHRoZSBmaXJzdCBpbnB1dCBmaWVsZCBvciBvdGhlciBmb2N1c2FibGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICBtZS5mb2N1cyhpZCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5maXJlKCdtb3VudGVkJywgbWUuaWQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnJldmVydEZvY3VzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVmZXJlbmNlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWZlcmVuY2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2RhdGEtcmVmJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZXNwb25zaXZlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBhZnRlclNldFJlc3BvbnNpdmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5nZXRQbHVnaW4oJ3Jlc3BvbnNpdmUnKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG1vZHVsZSAgPSBhd2FpdCBpbXBvcnQoYC4uLy4uL3NyYy9wbHVnaW4vUmVzcG9uc2l2ZS5tanNgKSxcbiAgICAgICAgICAgICAgICBwbHVnaW5zID0gbWUucGx1Z2lucyB8fCBbXTtcblxuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUucGx1Z2lucyA9IHBsdWdpbnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcm9sZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Um9sZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgncm9sZScsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2Nyb2xsYWJsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW58bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTY3JvbGxhYmxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBvbGRPdmVyZmxvd0tleSA9ICdvdmVyZmxvdyc7XG5cbiAgICAgICAgICAgIGlmICghTmVvLmlzQm9vbGVhbihvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRPdmVyZmxvd0tleSArPSBOZW8uY2FwaXRhbGl6ZShvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUucmVtb3ZlU3R5bGUoW29sZE92ZXJmbG93S2V5XSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghTmVvLmlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmZsb3dLZXkgPSAnb3ZlcmZsb3cnO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgIU5lby5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dLZXkgKz0gTmVvLmNhcGl0YWxpemUodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmFkZFN0eWxlKG92ZXJmbG93S2V5ICsgJzphdXRvJyk7XG4gICAgICAgICAgICAgICAgbWUuYWRkQ2xzKCduZW8tc2Nyb2xsYWJsZScpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnJlbW92ZUNscygnbmVvLXNjcm9sbGFibGUnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzdHlsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdHlsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoIXZhbHVlICYmIG9sZFZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGFnIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUYWcodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ3RhZycsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGhlbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRoZW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgfHwgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB7Y2xzfSAgICAgICA9IG1lLFxuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAmJiBjbHMuaW5jbHVkZXMob2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgb2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byBhZGQgYSBET00gYmFzZWQgQ1NTIHNlbGVjdG9yLCBpbiBjYXNlIHRoZSB0aGVtZSBpcyBhbHJlYWR5IGluaGVyaXRlZFxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBtZS5wYXJlbnQ/LnRoZW1lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgJiYgTmVvQXJyYXkuYWRkKGNscywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdG9vbHRpcCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRvb2x0aXAodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95Py4oKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChOZW8ubnMoJ05lby50b29sdGlwLkJhc2UnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0KCcuLi90b29sdGlwL0Jhc2UubWpzJykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHN0eWxpbmcgcHVycG9zZXMgb25seS5cbiAgICAgKiBUbyBkZWZpbmUgYnV0dG9uIHN0eWxlcyBvciBjb21wb25lbnQgc3R5bGVzLFxuICAgICAqIHRoaXMgd2lsbCBhZGQgYSBjc3MgY2xhc3M6IG5lby1udHlwZS12YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBhZnRlclNldFVpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgIGNscyA9IG1lLmNscztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBgbmVvLSR7bWUubnR5cGV9LSR7b2xkVmFsdWV9YCk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgYG5lby0ke21lLm50eXBlfS0ke3ZhbHVlfWApXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZkb20gcHNldWRvLWNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmRvbSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWZG9tKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdm5vZGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWbm9kZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnN5bmNWbm9kZVRyZWUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZFdpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCd3aWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb250cm9sbGVyID0gbWUuY29udHJvbGxlcjtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgbWUuX19wcm90b19fKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgY29tcG9uZW50IGdldHMgbW92ZWQgaW50byBhIGRpZmZlcmVudCB3aW5kb3csIGFuIHVwZGF0ZSBjeWNsZSBtaWdodCBzdGlsbCBiZSBydW5uaW5nLlxuICAgICAgICAvLyBTaW5jZSB0aGUgdXBkYXRlIG1pZ2h0IG5vIGxvbmdlciBnZXQgbWFwcGVkLCB3ZSB3YW50IHRvIHJlLWVuYWJsZSB0aGlzIGluc3RhbmNlIGZvciBmdXR1cmUgdXBkYXRlcy5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdyYXBwZXJDbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXcmFwcGVyQ2xzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSA9IG9sZFZhbHVlIHx8IFtdO1xuICAgICAgICB2YWx1ZSAgICA9IHZhbHVlICAgIHx8IFtdO1xuXG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB2ZG9tICAgICA9IG1lLnZkb20sXG4gICAgICAgICAgICB2ZG9tUm9vdCA9IG1lLmdldFZkb21Sb290KCksXG4gICAgICAgICAgICBjbHMgICAgICA9IG1lLnZkb20/LmNscyB8fCBbXTtcblxuICAgICAgICBpZiAodmRvbSA9PT0gdmRvbVJvb3QpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWVyZ2UgY2hhbmdlc1xuICAgICAgICAgICAgY2xzID0gTmVvQXJyYXkudW5pb24oY2xzLCB2YWx1ZSk7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBOZW9BcnJheS5kaWZmZXJlbmNlKG9sZFZhbHVlLCB2YWx1ZSkpO1xuICAgICAgICAgICAgdmRvbS5jbHMgPSBjbHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgYSB3cmFwcGVyID0+IGNscyAmIHdyYXBwZXJDbHMgc2hhcmUgdGhlIHNhbWUgbm9kZVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IHZhbHVlIDogW107XG5cbiAgICAgICAgICAgIG9sZFZhbHVlICYmIE5lb0FycmF5LnJlbW92ZShjbHMsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIE5lb0FycmF5LmFkZChjbHMsIHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHZkb20pIHtcbiAgICAgICAgICAgICAgICB2ZG9tLmNscyA9IGNsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdyYXBwZXJTdHlsZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXcmFwcGVyU3R5bGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghKCF2YWx1ZSAmJiBvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHZkb20gPSBtZS52ZG9tO1xuXG4gICAgICAgICAgICBpZiAoIXZkb20uaWQpIHtcbiAgICAgICAgICAgICAgICB2ZG9tLnN0eWxlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlU3R5bGUodmFsdWUsIG9sZFZhbHVlLCB2ZG9tLmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpZ25zIHRoZSB0b3AgbGV2ZWwgbm9kZSBpbnNpZGUgdGhlIG1haW4gdGhyZWFkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNwZWM9e31cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBhbGlnblRvKHNwZWM9e30pIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFsaWduID0ge1xuICAgICAgICAgICAgICAgIC4uLm1lLmFsaWduLFxuICAgICAgICAgICAgICAgIC4uLnNwZWMsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgICAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZEZsZXggICAgIDogbWUuY29uZmlndXJlZEZsZXgsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZFdpZHRoICAgIDogbWUuY29uZmlndXJlZFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRIZWlnaHQgICA6IG1lLmNvbmZpZ3VyZWRIZWlnaHQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZE1pbldpZHRoIDogbWUuY29uZmlndXJlZE1pbldpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNaW5IZWlnaHQ6IG1lLmNvbmZpZ3VyZWRNaW5IZWlnaHQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJlZE1heFdpZHRoIDogbWUuY29uZmlndXJlZE1heFdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNYXhIZWlnaHQ6IG1lLmNvbmZpZ3VyZWRNYXhIZWlnaHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFsaWduLnRhcmdldCkge1xuICAgICAgICAgICAgYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLmFsaWduKGFsaWduKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBjbHMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRDbHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gWy4uLnZhbHVlXSA6IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBkYXRhIGNvbmZpZ1xuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHdoaWNoIGlzIGV4cGVuc2l2ZSB0byB1c2UsIHNpbmNlIGl0IHdpbGwgZ2VuZXJhdGUgYSBtZXJnZWQgcGFyZW50IHN0YXRlIHByb3ZpZGVycyBkYXRhIG1hcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RGF0YSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0SGllcmFyY2h5RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBzdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0U3R5bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsuLi52YWx1ZX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIHdyYXBwZXJDbHMgY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRXcmFwcGVyQ2xzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFsuLi52YWx1ZV0gOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgd3JhcHBlclN0eWxlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXRXcmFwcGVyU3R5bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsuLi5PYmplY3QuYXNzaWduKHRoaXMudmRvbS5zdHlsZSB8fCB7fSwgdmFsdWUpfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGFsaWduIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEFsaWduKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIEp1c3QgYSBzaW1wbGUgJ3QtYidcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIGVkZ2VBbGlnbjogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1lcmdlIHRoZSBpbmNvbWluZyBhbGlnbm1lbnQgc3BlY2lmaWNhdGlvbiBpbnRvIHRoZSBjb25maWd1cmVkIGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIE5lby5tZXJnZSh7fSwgdmFsdWUsIG1lLmNvbnN0cnVjdG9yLmNvbmZpZy5hbGlnbilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjbHMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW9BcnJheS51bmlvbih2YWx1ZSB8fCBbXSwgdGhpcy5iYXNlQ2xzLCB0aGlzLmdldEJhc2VDbGFzcygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjb250cm9sbGVyIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQ3JlYXRlcyBhIGNvbnRyb2xsZXIuQ29tcG9uZW50IGluc3RhbmNlIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb250cm9sbGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgbnVsbCwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCA6IHRoaXMud2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBkb21MaXN0ZW5lcnMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RG9tTGlzdGVuZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgfHwgW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBoaWRlTW9kZSBjb25maWcgZ2V0cyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0SGlkZU1vZGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdoaWRlTW9kZScpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUga2V5cyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIENyZWF0ZXMgYSBLZXlOYXZpZ2F0aW9uIGluc3RhbmNlIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnV0aWwuS2V5TmF2aWdhdGlvbnxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRLZXlzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIEtleU5hdmlnYXRpb24sIHtcbiAgICAgICAgICAgICAgICBrZXlEb3duRXZlbnRCdWJibGU6IHRydWUsXG4gICAgICAgICAgICAgICAga2V5cyAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0YXRlUHJvdmlkZXIgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBDcmVhdGVzIGEgc3RhdGUuUHJvdmlkZXIgaW5zdGFuY2UgaWYgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uc3RhdGUuUHJvdmlkZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0YXRlUHJvdmlkZXIodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlcyA9IHtjb21wb25lbnQ6IG1lfTtcblxuICAgICAgICAgICAgaWYgKG1lLm1vZGVsRGF0YSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXMuZGF0YSA9IG1lLm1vZGVsRGF0YVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCAnTmVvLnN0YXRlLlByb3ZpZGVyJywgZGVmYXVsdFZhbHVlcylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGx1Z2lucyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnBsdWdpbi5CYXNlW119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFBsdWdpbnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpbmRleF0gPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UoaXRlbSwgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc2lsZW50VmRvbVVwZGF0ZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U2lsZW50VmRvbVVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmlzTnVtYmVyKG9sZFZhbHVlKSA/IChvbGRWYWx1ZSArIDEpIDogMVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChOZW8uaXNOdW1iZXIob2xkVmFsdWUpICYmIG9sZFZhbHVlID4gMCkgPyAob2xkVmFsdWUgLSAxKSA6IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSB1cGRhdGVEZXB0aCBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFVwZGF0ZURlcHRoKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2xkVmFsdWUgPT09IC0xIHx8IHZhbHVlID09PSAtMSA/IC0xIDogTWF0aC5tYXgodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlIG9mIGEgdmRvbSBvYmplY3QgYXR0cmlidXRlIG9yIHJlbW92ZXMgaXQgaW4gY2FzZSBpdCBoYXMgbm8gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ8T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqL1xuICAgIGNoYW5nZVZkb21Sb290S2V5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgcm9vdCA9IG1lLmdldFZkb21Sb290KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByb290W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHJvb3Rba2V5XVxuICAgICAgICB9XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBjYXNlIHlvdSBuZWVkIGRpZmZlcmVudCBtYXNrIG1hcmt1cHMuXG4gICAgICogVGhlIHJlbW92YWwgbG9naWMgcmVsaWVzIG9uIHRoZSB0b3AgbGV2ZWwgbm9kZSBoYXZpbmcgdGhlIGNscyAnbmVvLWxvYWQtbWFzaydcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBsb2FkaW5nTWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHZkb21cbiAgICAgKi9cbiAgICBjcmVhdGVMb2FkaW5nTWFzayhsb2FkaW5nTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xzOiBbJ25lby1sb2FkLW1hc2snXSxcbiAgICAgICAgICAgIGNuIDogW3tcbiAgICAgICAgICAgICAgICBjbHM6IFsnbmVvLWxvYWQtbWFzay1ib2R5J10sXG4gICAgICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgICAgICBjbHM6IHRoaXMubG9hZGluZ1NwaW5uZXJDbHNcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGNscyAgICAgIDogWyduZW8tbG9hZGluZy1tZXNzYWdlJ10sXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgICAgIDogbG9hZGluZ01lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZURvbTogIU5lby5pc1N0cmluZyhsb2FkaW5nTWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHRvb2x0aXAgaW5zdGFuY2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVUb29sdGlwKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUub3duSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIG1lLl90b29sdGlwID0gTmVvLmNyZWF0ZSgnTmVvLnRvb2x0aXAuQmFzZScsIHtcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuX3Rvb2x0aXAgPSB2YWx1ZTtcbiAgICAgICAgICAgIE5lby50b29sdGlwLkJhc2UuY3JlYXRlU2luZ2xldG9uKG1lLmFwcCk7XG4gICAgICAgICAgICBtZS5hZGRDbHMoJ25lby11c2VzLXNoYXJlZC10b29sdGlwJyk7XG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gY3JlYXRlIGEgY29tcG9uZW50IHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlVmRvbVJlZmVyZW5jZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSB7Y29tcG9uZW50SWQ6IG1lLmlkfSxcbiAgICAgICAgICAgIHZkb21JZCAgICA9IG1lLnZkb20uaWQ7XG5cbiAgICAgICAgaWYgKHZkb21JZCAmJiBtZS5pZCAhPT0gdmRvbUlkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2UuaWQgPSB2ZG9tSWRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZlcmVuY2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIHRoaXMgaW5zdGFuY2UgZnJvbSB0aGUgQ29tcG9uZW50TWFuYWdlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlUGFyZW50VmRvbT1mYWxzZSB0cnVlIHRvIHJlbW92ZSB0aGUgY29tcG9uZW50IGZyb20gdGhlIHBhcmVudCB2ZG9tID0+IHJlYWwgZG9tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2UgdHJ1ZSB0byB1cGRhdGUgdGhlIHZkb20gc2lsZW50bHkgKHVzZWZ1bCBmb3IgZGVzdHJveWluZyBtdWx0aXBsZSBjaGlsZCBpdGVtcyBpbiBhIHJvdylcbiAgICAgKiB0b2RvOiB1bnJlZ2lzdGVyIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbT1mYWxzZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtwYXJlbnQsIHBhcmVudElkfSAgPSBtZSxcbiAgICAgICAgICAgIHBhcmVudFN0YXRlUHJvdmlkZXIgPSBwYXJlbnQ/LmdldFN0YXRlUHJvdmlkZXIoKSxcbiAgICAgICAgICAgIHBhcmVudFZkb207XG5cbiAgICAgICAgbWUucmV2ZXJ0Rm9jdXMoKTtcblxuICAgICAgICBtZS5kb21MaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICBtZS5jb250cm9sbGVyID0gbnVsbDsgLy8gdHJpZ2dlcnMgZGVzdHJveSgpXG5cbiAgICAgICAgbWUucmVmZXJlbmNlICYmIG1lLmdldENvbnRyb2xsZXIoKT8ucmVtb3ZlUmVmZXJlbmNlKG1lKTsgLy8gcmVtb3ZlIG93biByZWZlcmVuY2UgZnJvbSBwYXJlbnQgY29udHJvbGxlcnNcblxuICAgICAgICBtZS5zdGF0ZVByb3ZpZGVyID0gbnVsbDsgLy8gdHJpZ2dlcnMgZGVzdHJveSgpXG5cbiAgICAgICAgbWUuYmluZCAmJiBwYXJlbnRTdGF0ZVByb3ZpZGVyPy5yZW1vdmVCaW5kaW5ncyhtZS5pZCk7XG5cbiAgICAgICAgbWUucGx1Z2lucz8uZm9yRWFjaChwbHVnaW4gPT4ge1xuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3koKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXBkYXRlUGFyZW50VmRvbSAmJiBwYXJlbnRJZCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudElkID09PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwge2FjdGlvbjogJ3JlbW92ZU5vZGUnLCBpZDogbWUudmRvbS5pZH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudFZkb20gPSBwYXJlbnQudmRvbTtcblxuICAgICAgICAgICAgICAgIFZEb21VdGlsLnJlbW92ZVZkb21DaGlsZChwYXJlbnRWZG9tLCBtZS52ZG9tLmlkKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRbc2lsZW50ID8gJ192ZG9tJyA6ICd2ZG9tJ10gPSBwYXJlbnRWZG9tXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBDb21wb25lbnRNYW5hZ2VyLnVucmVnaXN0ZXIobWUpO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcblxuICAgICAgICAvLyBXZSBkbyB3YW50IHRvIHByZXZlbnQgZGVsYXllZCBjYWxscyBhZnRlciBhIGNvbXBvbmVudCBpbnN0YW5jZSBnb3QgZGVzdHJveWVkLlxuICAgICAgICBtZS5vbkZvY3VzTGVhdmUgPSBOZW8uZW1wdHlGbjtcbiAgICAgICAgbWUudW5tb3VudCAgICAgID0gTmVvLmVtcHR5Rm5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhbGwgc3RvcmVkIHJlc29sdmUoKSBjYWxsYmFja3NcbiAgICAgKi9cbiAgICBkb1Jlc29sdmVVcGRhdGVDYWNoZSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucmVzb2x2ZVVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICBtZS5yZXNvbHZlVXBkYXRlQ2FjaGUuZm9yRWFjaChpdGVtID0+IGl0ZW0oKSk7XG4gICAgICAgICAgICBtZS5yZXNvbHZlVXBkYXRlQ2FjaGUgPSBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIE5lby5tYW5hZ2VyLkNvbXBvbmVudC5kb3duXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9dHJ1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gVGhlIG1hdGNoaW5nIGluc3RhbmNlIG9yIG51bGxcbiAgICAgKi9cbiAgICBkb3duKGNvbmZpZywgcmV0dXJuRmlyc3RNYXRjaD10cnVlKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLmRvd24odGhpcywgY29uZmlnLCByZXR1cm5GaXJzdE1hdGNoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBzZW5kIHVwZGF0ZSByZXF1ZXN0cyB0byB0aGUgdmRvbSB3b3JrZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IHZub2RlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Jlc29sdmVdIHVzZWQgYnkgcHJvbWlzZVVwZGF0ZSgpXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3JlamVjdF0gdXNlZCBieSBwcm9taXNlVXBkYXRlKClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNleGVjdXRlVmRvbVVwZGF0ZSh2ZG9tLCB2bm9kZSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIG9wdHMgPSB7fSxcbiAgICAgICAgICAgIGRlbHRhcztcblxuICAgICAgICBpZiAoY3VycmVudFdvcmtlci5pc1NoYXJlZFdvcmtlcikge1xuICAgICAgICAgICAgb3B0cy5hcHBOYW1lICA9IG1lLmFwcE5hbWU7XG4gICAgICAgICAgICBvcHRzLndpbmRvd0lkID0gbWUud2luZG93SWRcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyB3ZSBjYW4gbm90IHNldCB0aGUgY29uZmlnIGRpcmVjdGx5ID0+IGl0IGNvdWxkIGFscmVhZHkgYmUgZmFsc2UsXG4gICAgICAgIC8vIGFuZCB3ZSBzdGlsbCB3YW50IHRvIHBhc3MgaXQgZnVydGhlciBpbnRvIHN1YnRyZWVzXG4gICAgICAgIG1lLl9uZWVkc1Zkb21VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgbWUuYWZ0ZXJTZXROZWVkc1Zkb21VcGRhdGU/LihmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgb3B0cy52ZG9tICA9IENvbXBvbmVudE1hbmFnZXIuZ2V0VmRvbVRyZWUodmRvbSwgbWUudXBkYXRlRGVwdGgpO1xuICAgICAgICBvcHRzLnZub2RlID0gQ29tcG9uZW50TWFuYWdlci5nZXRWbm9kZVRyZWUodm5vZGUsIG1lLnVwZGF0ZURlcHRoKTtcblxuICAgICAgICAvLyBSZXNldCB0aGUgdXBkYXRlRGVwdGggdG8gdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZVxuICAgICAgICBtZS5fdXBkYXRlRGVwdGggPSBtZS5jb25zdHJ1Y3Rvci5jb25maWcudXBkYXRlRGVwdGg7XG5cbiAgICAgICAgTmVvLnZkb20uSGVscGVyLnVwZGF0ZShvcHRzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgbWUuaXNWZG9tVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBhdHRlbXB0aW5nIHRvIHVwZGF0ZSBjb21wb25lbnQgZG9tJywgZXJyLCBtZSk7XG5cbiAgICAgICAgICAgIHJlamVjdD8uKClcbiAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGNoZWNraW5nIGlmIHRoZSBjb21wb25lbnQgZ290IGRlc3Ryb3llZCBiZWZvcmUgdGhlIHVwZGF0ZSBjeWNsZSBpcyBkb25lXG4gICAgICAgICAgICBpZiAobWUuaWQpIHtcbiAgICAgICAgICAgICAgICBtZS52bm9kZSA9IGRhdGEudm5vZGU7XG5cbiAgICAgICAgICAgICAgICBkZWx0YXMgPSBkYXRhLmRlbHRhcztcblxuICAgICAgICAgICAgICAgIGlmICghTmVvLmNvbmZpZy51c2VWZG9tV29ya2VyICYmIGRlbHRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCBkZWx0YXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucmVzb2x2ZVZkb21VcGRhdGUocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5yZXNvbHZlVmRvbVVwZGF0ZShyZXNvbHZlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBmb2N1cygpIG9uIHRoZSB0b3AgbGV2ZWwgRE9NIG5vZGUgb2YgdGhpcyBjb21wb25lbnQgb3Igb24gYSBnaXZlbiBub2RlIHZpYSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZD10aGlzLmlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjaGlsZHJlbj1mYWxzZVxuICAgICAqL1xuICAgIGZvY3VzKGlkPXRoaXMuaWQsIGNoaWxkcmVuPWZhbHNlKSB7XG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5mb2N1cyh7Y2hpbGRyZW4sIGlkLCB3aW5kb3dJZDogdGhpcy53aW5kb3dJZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIGR5bmFtaWMgdmFsdWVzIGludG8gdGhpcy5jbHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0QmFzZUNsYXNzKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5mbG9hdGluZykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ25lby1mbG9hdGluZycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbiBpbnN0YW5jZSBzdG9yZWQgaW5zaWRlIGEgY29uZmlnIHZpYSBvcHRpb25hbGx5IHBhc3NpbmcgYSBudHlwZS5cbiAgICAgKiBSZXR1cm5zIHRoaXNbY29uZmlnTmFtZV0gb3IgdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIGEgbWF0Y2guXG4gICAgICogVXNlZCBieSBnZXRDb250cm9sbGVyKCkgJiBnZXRTdGF0ZVByb3ZpZGVyKClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoY29uZmlnTmFtZSwgbnR5cGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgICAgICAgICAgID0gbWVbY29uZmlnTmFtZV0sXG4gICAgICAgICAgICB7cGFyZW50Q29tcG9uZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChjb25maWcgJiYgKCFudHlwZSB8fCBudHlwZSA9PT0gY29uZmlnLm50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJlbnRDb21wb25lbnQgJiYgbWUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCA9IG1lLnBhcmVudCB8fCBOZW8uZ2V0KG1lLnBhcmVudElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRDb21wb25lbnQuZ2V0Q29uZmlnSW5zdGFuY2VCeU50eXBlKGNvbmZpZ05hbWUsIG50eXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMuY29udHJvbGxlciBvciB0aGUgY2xvc2VzdCBwYXJlbnQgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldENvbnRyb2xsZXIobnR5cGUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI7XG5cbiAgICAgICAgaWYgKCFudHlwZSkge1xuICAgICAgICAgICAgY29udHJvbGxlciA9IG1lW2Nsb3Nlc3RDb250cm9sbGVyXTtcblxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udHJvbGxlciA9IG1lLmdldENvbmZpZ0luc3RhbmNlQnlOdHlwZSgnY29udHJvbGxlcicsIG50eXBlKTtcblxuICAgICAgICBpZiAoIW50eXBlKSB7XG4gICAgICAgICAgICBtZVtjbG9zZXN0Q29udHJvbGxlcl0gPSBjb250cm9sbGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBpZD10aGlzLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFwcE5hbWU9dGhpcy5hcHBOYW1lXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLnV0aWwuUmVjdGFuZ2xlfE5lby51dGlsLlJlY3RhbmdsZVtdPn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXREb21SZWN0KGlkPXRoaXMuaWQsIGFwcE5hbWU9dGhpcy5hcHBOYW1lKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBOZW8ubWFpbi5Eb21BY2Nlc3MuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHthcHBOYW1lLCBpZCwgd2luZG93SWQ6IHRoaXMud2luZG93SWR9KTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChyZWN0ID0+IFJlY3RhbmdsZS5jbG9uZShyZWN0KSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWN0YW5nbGUuY2xvbmUocmVzdWx0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvbm9ycyBkaWZmZXJlbnQgaXRlbSByb290cyBmb3IgbW91bnQgLyByZW5kZXIgT1BzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRNb3VudGVkUGFyZW50SWQoKSB7XG4gICAgICAgIGxldCBwYXJlbnRJZCAgPSB0aGlzLnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50ICAgID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCksXG4gICAgICAgICAgICBpdGVtc1Jvb3QgPSBwYXJlbnQ/LmdldFZkb21JdGVtc1Jvb3Q/LigpO1xuXG4gICAgICAgIHJldHVybiBpdGVtc1Jvb3QgPyBpdGVtc1Jvb3QuaWQgOiBwYXJlbnRJZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcmVhbCBwYXJlbnRJbmRleCBpbnNpZGUgdGhlIERPTVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldE1vdW50ZWRQYXJlbnRJbmRleCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgICAgICAgaXRlbXMgID0gcGFyZW50Py5pdGVtcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICA9IDAsXG4gICAgICAgICAgICBpbmRleCAgPSAwLFxuICAgICAgICAgICAgbGVuICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXRlbS5oaWRkZW4gJiYgaXRlbS5oaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmVudCBjb21wb25lbnRzIGFzIGFuIGFycmF5XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGdldFBhcmVudHMoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHModGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7TmVvLnBsdWdpbi5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG9wdHMpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhvcHRzKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRzLnN0YXJ0c1dpdGgoJ3BsdWdpbi0nKSkge1xuICAgICAgICAgICAgICAgIG9wdHMgPSAncGx1Z2luLScgKyBvcHRzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdHMgPSB7bnR5cGU6IG9wdHN9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaGFzTWF0Y2g7XG5cbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgbWUucGx1Z2lucyB8fCBbXSkge1xuICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbltrZXldICE9PSBvcHRzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd24oe3JlZmVyZW5jZTogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzLnN0YXRlUHJvdmlkZXIgb3IgdGhlIGNsb3Nlc3QgcGFyZW50IHN0YXRlUHJvdmlkZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uc3RhdGUuUHJvdmlkZXJ8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZVByb3ZpZGVyKG50eXBlKSB7XG4gICAgICAgIGlmICghY3VycmVudFdvcmtlci5pc1VzaW5nU3RhdGVQcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgcHJvdmlkZXI7XG5cbiAgICAgICAgaWYgKCFudHlwZSkge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBtZVtjbG9zZXN0UHJvdmlkZXJdO1xuXG4gICAgICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb3ZpZGVyID0gbWUuZ2V0Q29uZmlnSW5zdGFuY2VCeU50eXBlKCdzdGF0ZVByb3ZpZGVyJywgbnR5cGUpO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIG1lW2Nsb3Nlc3RQcm92aWRlcl0gPSBwcm92aWRlclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Fsa3MgdXAgdGhlIHZkb20gdHJlZSBhbmQgcmV0dXJucyB0aGUgY2xvc2VzdCB0aGVtZSBmb3VuZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VGhlbWUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHRoZW1lTWF0Y2ggPSAnbmVvLXRoZW1lLScsXG4gICAgICAgICAgICBtYWluVmlldywgcGFyZW50Tm9kZXM7XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG1lLmNscyB8fCBbXSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhcnRzV2l0aCh0aGVtZU1hdGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYWluVmlldyA9IG1lLmFwcD8ubWFpblZpZXc7XG5cbiAgICAgICAgaWYgKG1haW5WaWV3KSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlcyA9IFZEb21VdGlsLmdldFBhcmVudE5vZGVzKG1haW5WaWV3LnZkb20sIG1lLmlkKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHBhcmVudE5vZGVzIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuY2xzIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0YXJ0c1dpdGgodGhlbWVNYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTmVvLmNvbmZpZy50aGVtZXM/LlswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBhIHZkb20gY2hpbGQgbm9kZSBieSBpZCBmb3IgYSBnaXZlbiB2ZG9tIHRyZWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbT10aGlzLnZkb21cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFZkb21DaGlsZChpZCwgdmRvbT10aGlzLnZkb20pIHtcbiAgICAgICAgcmV0dXJuIFZEb21VdGlsLmZpbmQodmRvbSwgaWQpPy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2ZG9tIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZub2RlUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdmRvbSByb290XG4gICAgICovXG4gICAgZ2V0VmRvbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZkb21cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgZGlmZmVyZW50IHZub2RlIHJvb3QgaWYgbmVlZGVkIHRvIGFwcGx5IHRoZSB0b3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcyBvbiBhIGRpZmZlcmVudCBsZXZlbC5cbiAgICAgKiBNYWtlIHN1cmUgdG8gdXNlIGdldFZkb21Sb290KCkgYXMgd2VsbCwgdG8ga2VlcCB0aGUgdmRvbSAmIHZub2RlIHRyZWVzIGluIHN5bmMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ldyB2bm9kZSByb290XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIHVwZGF0ZURlcHRoICYgZGlzdGFuY2Ugd291bGQgcmVzdWx0IGluIGFuIHVwZGF0ZSBjb2xsaXNpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXBkYXRlRGVwdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNVcGRhdGVDb2xsaXNpb24odXBkYXRlRGVwdGgsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZXB0aCA9PT0gLTEgPyB0cnVlIDogZGlzdGFuY2UgPCB1cGRhdGVEZXB0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBoaWRlTW9kZTogJ3JlbW92ZURvbScgIHVzZXMgdmRvbSByZW1vdmVEb20uXG4gICAgICogaGlkZU1vZGU6ICd2aXNpYmlsaXR5JyB1c2VzIGNzcyB2aXNpYmlsaXR5LlxuICAgICAqIElmIGhpZGVNb2RlID09PSAncmVtb3ZlRG9tJyB5b3UgY2FuIHBhc3MgYSB0aW1lb3V0IGZvciBjdXN0b20gY3NzIGNsYXNzIGhpZGluZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxuICAgICAqL1xuICAgIGhpZGUodGltZW91dCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5oaWRlTW9kZSAhPT0gJ3Zpc2liaWxpdHknKSB7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lLnBhcmVudElkICE9PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudmRvbS5yZW1vdmVEb20gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5wYXJlbnQudXBkYXRlRGVwdGggPSAyO1xuICAgICAgICAgICAgICAgICAgICBtZS5wYXJlbnQudXBkYXRlKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS51bm1vdW50KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgbWUudGltZW91dCh0aW1lb3V0KS50aGVuKHJlbW92ZUZuKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVGbigpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBtZS5zdHlsZTtcbiAgICAgICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIG1lLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5faGlkZGVuID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5hdXRvUmVuZGVyICYmIHRoaXMucmVuZGVyKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBhcmUgdXNpbmcgdGhpcyBtZXRob2QgYXMgYSBjdG9yIGhvb2sgaGVyZSB0byBhZGQgdGhlIGluaXRpYWwgc3RhdGUuUHJvdmlkZXIgJiBjb250cm9sbGVyLkNvbXBvbmVudCBwYXJzaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRPcmlnaW5hbENvbmZpZ10gVHJ1ZSBwcmV2ZW50cyB0aGUgaW5zdGFuY2UgZnJvbSBnZXR0aW5nIGFuIG9yaWdpbmFsQ29uZmlnIHByb3BlcnR5XG4gICAgICovXG4gICAgaW5pdENvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBzdXBlci5pbml0Q29uZmlnKGNvbmZpZywgcHJldmVudE9yaWdpbmFsQ29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmdldENvbnRyb2xsZXIoKSAgID8ucGFyc2VDb25maWcobWUpO1xuICAgICAgICBtZS5nZXRTdGF0ZVByb3ZpZGVyKCk/LnBhcnNlQ29uZmlnKG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgdmRvbSB1cGRhdGVzIGluc2lkZSB0aGUgcGFyZW50IGNoYWluIGFuZCBpZiBmb3VuZC5cbiAgICAgKiBSZWdpc3RlcnMgdGhlIGNvbXBvbmVudCBmb3IgYSB2ZG9tIHVwZGF0ZSBvbmNlIGRvbmUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudElkPXRoaXMucGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV0gR2V0cyBwYXNzZWQgYnkgdXBkYXRlVmRvbSgpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlPTEgRGlzdGFuY2UgaW5zaWRlIHRoZSBjb21wb25lbnQgdHJlZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUGFyZW50VXBkYXRpbmcocGFyZW50SWQ9dGhpcy5wYXJlbnRJZCwgcmVzb2x2ZSwgZGlzdGFuY2U9MSkge1xuICAgICAgICBpZiAocGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmlzVmRvbVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5oYXNVcGRhdGVDb2xsaXNpb24ocGFyZW50LmN1cnJlbnRVcGRhdGVEZXB0aCwgZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmNvbmZpZy5sb2dWZG9tVXBkYXRlQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndmRvbSBwYXJlbnQgdXBkYXRlIGNvbmZsaWN0IHdpdGg6JywgcGFyZW50LCAnZm9yOicsIG1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRVcGRhdGVDYWNoZVttZS5pZF0gPSB7ZGlzdGFuY2UsIHJlc29sdmV9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdGhlIHJlc29sdmUgZm4gdG8gaXRzIG93biBjYWNoZSwgc2luY2UgdGhlIHBhcmVudCB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgbmV3IHVwZGF0ZSgpIGRpcmVjdGx5IG9uIHRoaXMgY21wXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlICYmIG1lLnJlc29sdmVVcGRhdGVDYWNoZS5wdXNoKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFuIHVwZGF0ZSBpcyBydW5uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGEgY29sbGlzaW9uLCB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBmdXJ0aGVyIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLmlzUGFyZW50VXBkYXRpbmcocGFyZW50LnBhcmVudElkLCByZXNvbHZlLCBkaXN0YW5jZSsxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAgICovXG4gICAgYXN5bmMgbWVhc3VyZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZW5ndGhSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxldCB7aWQsIHdpbmRvd0lkfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhd2FpdCBOZW8ubWFpbi5Eb21BY2Nlc3MubWVhc3VyZSh7aWQsIHZhbHVlLCB3aW5kb3dJZH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIG9yZGVyIGNvbmZpZ3MgYXJlIGFwcGxpZWQgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyguLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0gc3VwZXIubWVyZ2VDb25maWcoLi4uYXJncyksXG5cbiAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byBzZXQgY3VzdG9tIGNvbmZpZ3MgZm9yIHRoZSB2ZG9tIG9uIGluc3RhbmNlIGxldmVsLFxuICAgICAgICAgICAgLy8gaG93ZXZlciB0aGVyZSB3aWxsIGJlIGFscmVhZHkgYWRkZWQgYXR0cmlidXRlcyAoZS5nLiBpZCksIHNvIGEgbWVyZ2Ugc2VlbXMgdG8gYmUgdGhlIGJlc3Qgc3RyYXRlZ3kuXG4gICAgICAgICAgICB2ZG9tID0gey4uLm1lLl92ZG9tIHx8IHt9LCAuLi5jb25maWcudmRvbSB8fCB7fX07XG5cbiAgICAgICAgLy8gYXZvaWQgYW55IGludGVyZmVyZW5jZSBvbiBwcm90b3R5cGUgbGV2ZWxcbiAgICAgICAgLy8gZG9lcyBub3QgY2xvbmUgZXhpc3RpbmcgTmVvIGluc3RhbmNlc1xuICAgICAgICBtZS5fdmRvbSA9IE5lby5jbG9uZSh2ZG9tLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICBpZiAoY29uZmlnLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgcGFzc2VkIGFuIG9iamVjdCwgbWVyZ2UgaXQgd2l0aCB0aGUgY2xhc3MncyBvd24gc3R5bGVcbiAgICAgICAgICAgIG1lLnN0eWxlID0gTmVvLnR5cGVPZihjb25maWcuc3R5bGUpID09PSAnT2JqZWN0JyA/IHsuLi5jb25maWcuc3R5bGUsIC4uLm1lLmNvbnN0cnVjdG9yLmNvbmZpZy5zdHlsZX0gOiBjb25maWcuc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLndyYXBwZXJTdHlsZSA9IE5lby5jbG9uZShjb25maWcud3JhcHBlclN0eWxlLCBmYWxzZSk7XG5cbiAgICAgICAgZGVsZXRlIGNvbmZpZy5zdHlsZTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5fdmRvbTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy52ZG9tO1xuICAgICAgICBkZWxldGUgY29uZmlnLndyYXBwZXJTdHlsZTtcblxuICAgICAgICByZXR1cm4gY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuIGdldCBjYWxsZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBnb3QgcmVuZGVyZWQuIFNlZSB0aGUgYXV0b01vdW50IGNvbmZpZyBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGFzeW5jIG1vdW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgY2hpbGQsIGNoaWxkSWRzO1xuXG4gICAgICAgIGlmICghbWUudm5vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHZub2RlIG11c3QgYmUgZ2VuZXJhdGVkIGJlZm9yZSBtb3VudGluZywgdXNlIENvbXBvbmVudC5yZW5kZXIoKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW4gY2FzZSB0aGUgY29tcG9uZW50IHdhcyBhbHJlYWR5IG1vdW50ZWQsIGdvdCB1bm1vdW50ZWQgYW5kIHJlY2VpdmVkIHZkb20gY2hhbmdlcyBhZnRlcndhcmRzLFxuICAgICAgICAvLyBhIG5ldyByZW5kZXIoKSBjYWxsIGlzIG1hbmRhdG9yeSBzaW5jZSBkZWx0YSB1cGRhdGVzIGNvdWxkIG5vdCBnZXQgYXBwbGllZC5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjbGVhciB0aGUgaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgc3RhdGUgZm9yIGFsbCBjaGlsZCBjb21wb25lbnRzXG4gICAgICAgIGlmIChtZS5oYXNVbm1vdW50ZWRWZG9tQ2hhbmdlcykge1xuICAgICAgICAgICAgLy8gdG9kbzogdGhlIGhhc1VubW91bnRlZFZkb21DaGFuZ2VzIGZsYWcgY2hhbmdlcyBzaG91bGQgaGFwcGVuIG9uIHJlbmRlclxuICAgICAgICAgICAgbWUuaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgY2hpbGRJZHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkSWRzKG1lLnZub2RlKTtcblxuICAgICAgICAgICAgY2hpbGRJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBOZW8uZ2V0Q29tcG9uZW50KGlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5faGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgPSBmYWxzZTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZW5kIHRvZG9cblxuICAgICAgICAgICAgbWUucmVuZGVyKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBjdXJyZW50V29ya2VyLnByb21pc2VNZXNzYWdlKCdtYWluJywge1xuICAgICAgICAgICAgICAgIGFjdGlvbiAgICAgOiAnbW91bnREb20nLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBodG1sICAgICAgIDogbWUudm5vZGUub3V0ZXJIVE1MLFxuICAgICAgICAgICAgICAgIHBhcmVudElkICAgOiBtZS5nZXRNb3VudGVkUGFyZW50SWQoKSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmRleDogbWUuZ2V0TW91bnRlZFBhcmVudEluZGV4KClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApO1xuXG4gICAgICAgICAgICBtZS5tb3VudGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBuZWVkc1Zkb21VcGRhdGUgY29uZmlnIGluc2lkZSB0aGUgcGFyZW50IHRyZWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWQ9dGhpcy5wYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXSBnZXRzIHBhc3NlZCBieSB1cGRhdGVWZG9tKClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2U9MSBEaXN0YW5jZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0cmVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgbmVlZHNQYXJlbnRVcGRhdGUocGFyZW50SWQ9dGhpcy5wYXJlbnRJZCwgcmVzb2x2ZSwgZGlzdGFuY2U9MSkge1xuICAgICAgICBpZiAocGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2hlY2tpbmcgZm9yIHBhcmVudC51cGRhdGVEZXB0aCwgc2luY2Ugd2UgY2FyZSBhYm91dCB0aGUgZGVwdGggb2YgdGhlIG5leHQgdXBkYXRlIGN5Y2xlXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5uZWVkc1Zkb21VcGRhdGUgJiYgbWUuaGFzVXBkYXRlQ29sbGlzaW9uKHBhcmVudC51cGRhdGVEZXB0aCwgZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZXNvbHZlVXBkYXRlQ2FjaGUucHVzaCguLi5tZS5yZXNvbHZlVXBkYXRlQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlICYmIHBhcmVudC5yZXNvbHZlVXBkYXRlQ2FjaGUucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVzb2x2ZVVwZGF0ZUNhY2hlID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLm5lZWRzUGFyZW50VXBkYXRlKHBhcmVudC5wYXJlbnRJZCwgcmVzb2x2ZSwgZGlzdGFuY2UrMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuICAgICAgICB0aGlzLmtleXM/LnJlZ2lzdGVyKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkZvY3VzRW50ZXIoZGF0YSkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgaGlkZGVuLCBvciB1bm1vdW50ZWQgd2hpbGUgd2Ugc3RpbGwgY29udGFpbiBmb2N1cywgd2UgaGF2ZSB0byByZXZlcnRcbiAgICAgICAgLy8gZm9jdXMgdG8gd2hlcmUgaXQgY2FtZSBmcm9tIGlmIHBvc3NpYmxlXG4gICAgICAgIHRoaXMuZm9jdXNFbnRlckRhdGEgPSBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5mb2N1c0VudGVyRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJ5IG1hbmFnZXIuRm9jdXNcbiAgICAgKiBAbmFtZSBvbkZvY3VzRW50ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgbWFuYWdlci5Gb2N1c1xuICAgICAqIEBuYW1lIG9uRm9jdXNMZWF2ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBtYW5hZ2VyLkZvY3VzXG4gICAgICogQG5hbWUgb25Gb2N1c01vdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLm5ld1BhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5vbGRQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCBmcm9tIHRoZSByZW5kZXIoKSBwcm9taXNlIHN1Y2Nlc3MgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhdXRvTW91bnQgTW91bnQgdGhlIERPTSBhZnRlciB0aGUgdm5vZGUgZ290IGNyZWF0ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25SZW5kZXIoZGF0YSwgYXV0b01vdW50KSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwfSA9IG1lO1xuXG4gICAgICAgIG1lLnJlbmRlcmluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIGFwcCBpcyBhIGNoZWNrIHRvIHNlZSBpZiB0aGUgQ29tcG9uZW50IGdvdCBkZXN0cm95ZWQgd2hpbGUgcmVuZGVyaW5nID0+IGJlZm9yZSBvblJlbmRlciBnb3QgdHJpZ2dlcmVkXG4gICAgICAgIGlmIChhcHApIHtcbiAgICAgICAgICAgIGlmICghYXBwLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgYXBwLnJlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFwcC5yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXBwLmZpcmUoJ3JlbmRlcicpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnZub2RlID0gZGF0YTtcblxuICAgICAgICAgICAgbGV0IGNoaWxkSWRzID0gQ29tcG9uZW50TWFuYWdlci5nZXRDaGlsZElkcyhkYXRhKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICAgICAgPSBjaGlsZElkcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2hpbGQ7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IE5lby5nZXRDb21wb25lbnQoY2hpbGRJZHNbaV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnJlbmRlcmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuX3JlbmRlcmVkID0gdHJ1ZTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgbWUuZmlyZSgncmVuZGVyZWQnLCBtZS5pZCk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW5kZXJlZDogJyArIG1lLmFwcE5hbWUgKyAnICcgKyBtZS5pZCwgbWUpO1xuXG4gICAgICAgICAgICBpZiAoYXV0b01vdW50KSB7XG4gICAgICAgICAgICAgICAgbWUubW91bnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFwcC5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXBwLmZpcmUoJ21vdW50ZWQnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb21pc2UgYmFzZWQgdmRvbSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbT10aGlzLnZkb21cbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSB2bm9kZT0gdGhpcy52bm9kZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJvbWlzZVVwZGF0ZSh2ZG9tPXRoaXMudmRvbSwgdm5vZGU9dGhpcy52bm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWZG9tKHZkb20sIHZub2RlLCByZXNvbHZlLCByZWplY3QpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY2xzIGZyb20gdGhlIHZkb21Sb290XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgcmVtb3ZlQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xzID0gY2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHZhbHVlXG4gICAgICovXG4gICAgcmVtb3ZlRG9tTGlzdGVuZXJzKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZG9tTGlzdGVuZXJzfSA9IG1lLFxuICAgICAgICAgICAgaSwgbGVuO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIGxlbiA9IGRvbUxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzRXF1YWwoaXRlbSwgZG9tTGlzdGVuZXJzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21MaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZG9tTGlzdGVuZXJzID0gZG9tTGlzdGVuZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgc3RyaW5nIGxpa2UgJ2NvbG9yJyBvciBhbiBhcnJheSBjb250YWluaW5nIHN0eWxlIGF0dHJpYnV0ZXMgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHZhbHVlIGNhbWVsQ2FzZSBvbmx5XG4gICAgICogQHJldHVybnMge09iamVjdH0gYWxsIHN0eWxlcyBvZiB0aGlzLmVsXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQge3N0eWxlfSAgPSB0aGlzLFxuICAgICAgICAgICAgZG9VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlW2tleV07XG4gICAgICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkb1VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB2bm9kZSB0cmVlIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgbW91bnRzIHRoZSBjb21wb25lbnQgaW4gY2FzZVxuICAgICAqIC0geW91IHBhc3MgdHJ1ZSBmb3IgdGhlIG1vdW50IHBhcmFtXG4gICAgICogLSBvciB0aGUgYXV0b01vdW50IGNvbmZpZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21vdW50XSBNb3VudCB0aGUgRE9NIGFmdGVyIHRoZSB2bm9kZSBnb3QgY3JlYXRlZFxuICAgICAqL1xuICAgIGFzeW5jIHJlbmRlcihtb3VudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGF1dG9Nb3VudCAgICAgICA9IG1vdW50IHx8IG1lLmF1dG9Nb3VudCxcbiAgICAgICAgICAgIHthcHB9ICAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAge3VzZVZkb21Xb3JrZXJ9ID0gTmVvLmNvbmZpZztcblxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY3JpdGljYWwgcmVuZGVyaW5nIHBhdGggPT4gQ1NTIGZpbGVzIGZvciB0aGUgbmV3IHRyZWUgaXMgaW4gcGxhY2VcbiAgICAgICAgaWYgKGN1cnJlbnRXb3JrZXIuY291bnRMb2FkaW5nVGhlbWVGaWxlcyAhPT0gMCkge1xuICAgICAgICAgICAgY3VycmVudFdvcmtlci5vbigndGhlbWVGaWxlc0xvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG1lLnJlbmRlcihtb3VudClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pO1xuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnJlbmRlcmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFhcHAucmVuZGVyZWQpIHtcbiAgICAgICAgICAgIGFwcC5yZW5kZXJpbmcgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUudmRvbSkge1xuICAgICAgICAgICAgbWUuaXNWZG9tVXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgICAgIG1lLl9uZWVkc1Zkb21VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLmFmdGVyU2V0TmVlZHNWZG9tVXBkYXRlPy4oZmFsc2UsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgTmVvLnZkb20uSGVscGVyLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgYXV0b01vdW50LFxuICAgICAgICAgICAgICAgIHBhcmVudElkICAgOiBhdXRvTW91bnQgPyBtZS5nZXRNb3VudGVkUGFyZW50SWQoKSAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmRleDogYXV0b01vdW50ID8gbWUuZ2V0TW91bnRlZFBhcmVudEluZGV4KCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgIC4uLkNvbXBvbmVudE1hbmFnZXIuZ2V0VmRvbVRyZWUobWUudmRvbSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5vblJlbmRlcihkYXRhLCB1c2VWZG9tV29ya2VyID8gYXV0b01vdW50IDogZmFsc2UpO1xuICAgICAgICAgICAgbWUuaXNWZG9tVXBkYXRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgYXV0b01vdW50ICYmICF1c2VWZG9tV29ya2VyICYmIG1lLm1vdW50KCk7XG5cbiAgICAgICAgICAgIG1lLnJlc29sdmVWZG9tVXBkYXRlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGhlbHBlciBmbiB0byByZXNvbHZlIHRoZSBQcm9taXNlIGZvciB1cGRhdGVWZG9tKClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHVuZGVmaW5lZH0gcmVzb2x2ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZXNvbHZlVmRvbVVwZGF0ZShyZXNvbHZlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGhhc0NoaWxkVXBkYXRlQ2FjaGUgPSAhTmVvLmlzRW1wdHkobWUuY2hpbGRVcGRhdGVDYWNoZSksXG4gICAgICAgICAgICBjb21wb25lbnQ7XG5cbiAgICAgICAgbWUuZG9SZXNvbHZlVXBkYXRlQ2FjaGUoKTtcblxuICAgICAgICByZXNvbHZlPy4oKTtcblxuICAgICAgICBpZiAobWUubmVlZHNWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGRVcGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG1lLmNoaWxkVXBkYXRlQ2FjaGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbXBvbmVudCBtaWdodCBhbHJlYWR5IGdvdCBkZXN0cm95ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBjYWxsYmFja3MgdG8gdGhlIHJlc29sdmVyIGNhY2hlID0+IGdldHRpbmcgZXhlY3V0ZWQgb25jZSB0aGUgZm9sbG93aW5nIHVwZGF0ZSBpcyBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXNvbHZlICYmIE5lb0FycmF5LmFkZChtZS5yZXNvbHZlVXBkYXRlQ2FjaGUsIHZhbHVlLnJlc29sdmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgdGhlIHVwZGF0ZURlcHRoIHRvIGluY2x1ZGUgdGhlIGRlcHRoIG9mIGFsbCBtZXJnZWQgY2hpbGQgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lLnVwZGF0ZURlcHRoICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQudXBkYXRlRGVwdGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB1cGRhdGVEZXB0aCBpcyAxLWJhc2VkLCB3ZSBuZWVkIHRvIHN1YnRyYWN0IDEgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlRGVwdGggPSBtZS51cGRhdGVEZXB0aCArIHZhbHVlLmRpc3RhbmNlICsgY29tcG9uZW50LnVwZGF0ZURlcHRoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUuY2hpbGRVcGRhdGVDYWNoZSA9IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ2hpbGRVcGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWUuY2hpbGRVcGRhdGVDYWNoZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIE5lby5nZXRDb21wb25lbnQoa2V5KT8udXBkYXRlKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5jaGlsZFVwZGF0ZUNhY2hlID0ge31cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmV2ZXJ0Rm9jdXMoKSB7XG4gICAgICAgIGxldCByZWxhdGVkVGFyZ2V0ID0gdGhpcy5mb2N1c0VudGVyRGF0YT8ucmVsYXRlZFRhcmdldDtcblxuICAgICAgICBpZiAodGhpcy5jb250YWluc0ZvY3VzICYmIHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIE5lby5nZXRDb21wb25lbnQocmVsYXRlZFRhcmdldC5pZCk/LmZvY3VzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBtdWx0aXBsZSBjb25maWdzIGF0IG9uY2UsIGVuc3VyaW5nIHRoYXQgYWxsIGFmdGVyU2V0IG1ldGhvZHMgZ2V0IGFsbCBuZXcgYXNzaWduZWQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcz17fVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTwqPn1cbiAgICAgKi9cbiAgICBzZXQodmFsdWVzPXt9LCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5lZWRzUmVuZGVyaW5nID0gdmFsdWVzLmhpZGRlbiA9PT0gZmFsc2UgJiYgdmFsdWVzLmhpZGRlbiAhPT0gbWUuaGlkZGVuO1xuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHN1cGVyLnNldCh2YWx1ZXMpO1xuXG4gICAgICAgIG1lLnNpbGVudFZkb21VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2lsZW50IHx8ICFtZS5uZWVkc1Zkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5lZWRzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgbWUuc2hvdygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWUucHJvbWlzZVVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBjYWxsaW5nIHNldCgpIHdpdGggdGhlIHNpbGVudCBmbGFnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcz17fVxuICAgICAqL1xuICAgIHNldFNpbGVudCh2YWx1ZXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQodmFsdWVzLCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBzZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLnNldERhdGEoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBjb21wb25lbnQuXG4gICAgICogaGlkZU1vZGU6ICdyZW1vdmVEb20nICB1c2VzIHZkb20gcmVtb3ZlRG9tLlxuICAgICAqIGhpZGVNb2RlOiAndmlzaWJpbGl0eScgdXNlcyBjc3MgdmlzaWJpbGl0eS5cbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5oaWRlTW9kZSAhPT0gJ3Zpc2liaWxpdHknKSB7XG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgICAgIGlmIChtZS5zaWxlbnRWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5wYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgICAgICAgICBtZS5wYXJlbnQudXBkYXRlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIW1lLm1vdW50ZWQgJiYgbWUucmVuZGVyKHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBtZS5zdHlsZTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZS52aXNpYmlsaXR5O1xuICAgICAgICAgICAgbWUuc3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuX2hpZGRlbiA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIGZvciB1dGlsLlZEb20uc3luY1Zkb21JZHMgdG8gYWxsb3cgb3ZlcnJpZGluZyAoZGlzYWJsaW5nKSBpdFxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IFt2bm9kZT10aGlzLnZub2RlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdmRvbT10aGlzLnZkb21dXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZT1mYWxzZVxuICAgICAqL1xuICAgIHN5bmNWZG9tSWRzKHZub2RlPXRoaXMudm5vZGUsIHZkb209dGhpcy52ZG9tLCBmb3JjZT1mYWxzZSkge1xuICAgICAgICBWRG9tVXRpbC5zeW5jVmRvbUlkcyh2bm9kZSwgdmRvbSwgZm9yY2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBhIGNvbXBvbmVudCByZWNlaXZlcyBhIG5ldyB2bm9kZSwgd2Ugd2FudCB0byBkbzpcbiAgICAgKiAtIHN5bmMgdGhlIHZkb20gaWRzXG4gICAgICogLSBzZXR0aW5nIHJlbmRlcmVkIHRvIHRydWUgZm9yIGNoaWxkIGNvbXBvbmVudHNcbiAgICAgKiAtIHVwZGF0aW5nIHRoZSBwYXJlbnQgY29tcG9uZW50IHRvIGVuc3VyZSB0aGF0IHRoZSB2bm9kZSB0cmVlIHN0YXlzIHBlcnNpc3RlbnRcbiAgICAgKiBAcGFyYW0ge05lby52ZG9tLlZOb2RlfSBbdm5vZGU9dGhpcy52bm9kZV1cbiAgICAgKi9cbiAgICBzeW5jVm5vZGVUcmVlKHZub2RlPXRoaXMudm5vZGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjaGlsZENvbXBvbmVudHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkcmVuKG1lKSxcbiAgICAgICAgICAgIGRlYnVnICAgICAgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgbWFwICAgICAgICAgICAgID0ge30sXG4gICAgICAgICAgICBjaGlsZFZub2RlLCBzdGFydDtcblxuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnN5bmNWZG9tSWRzKCk7XG5cbiAgICAgICAgaWYgKHZub2RlICYmIG1lLmlkICE9PSB2bm9kZS5pZCkge1xuICAgICAgICAgICAgQ29tcG9uZW50TWFuYWdlci5yZWdpc3RlcldyYXBwZXJOb2RlKHZub2RlLmlkLCBtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG5lZWQgb25lIHNlcGFyYXRlIGl0ZXJhdGlvbiBmaXJzdCB0byBlbnN1cmUgYWxsIHdyYXBwZXIgbm9kZXMgZ2V0IHJlZ2lzdGVyZWRcbiAgICAgICAgY2hpbGRDb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgIGNoaWxkVm5vZGUgPSBWTm9kZVV0aWwuZmluZChtZS52bm9kZSwgY29tcG9uZW50LnZkb20uaWQpPy52bm9kZTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkVm5vZGUpIHtcbiAgICAgICAgICAgICAgICBtYXBbY29tcG9uZW50LmlkXSA9IGNoaWxkVm5vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmlkICE9PSBjaGlsZFZub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXJXcmFwcGVyTm9kZShjaGlsZFZub2RlLmlkLCBjb21wb25lbnQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkZWxlZ2F0ZSB0aGUgbGF0ZXN0IG5vZGUgdXBkYXRlcyB0byBhbGwgcG9zc2libGUgY2hpbGQgY29tcG9uZW50cyBmb3VuZCBpbnNpZGUgdGhlIHZub2RlIHRyZWVcbiAgICAgICAgY2hpbGRDb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgICAgICAgIGNoaWxkVm5vZGUgPSBtYXBbY29tcG9uZW50LmlkXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkVm5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Ll92bm9kZSA9IENvbXBvbmVudE1hbmFnZXIuYWRkVm5vZGVDb21wb25lbnRSZWZlcmVuY2VzKGNoaWxkVm5vZGUsIGNvbXBvbmVudC5pZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5yZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmZpcmUoJ3JlbmRlcmVkJywgY29tcG9uZW50LmlkKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tb3VudGVkID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3N5bmNWbm9kZVRyZWU6IENvdWxkIG5vdCByZXBsYWNlIHRoZSBjaGlsZCB2bm9kZSBmb3InLCBjb21wb25lbnQuaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgbWUuX3Zub2RlID0gdm5vZGUgPyBDb21wb25lbnRNYW5hZ2VyLmFkZFZub2RlQ29tcG9uZW50UmVmZXJlbmNlcyh2bm9kZSwgbWUuaWQpIDogbnVsbDtcblxuICAgICAgICBkZWJ1ZyAmJiBjb25zb2xlLmxvZygnc3luY1Zub2RlVHJlZScsIG1lLmlkLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBhIGNscyBpbnNpZGUgdGhlIHZkb21Sb290IG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthZGRdIFVzZSB0aGlzIHBhcmFtIHRvIGVuZm9yY2UgYW4gYWRkKCkgb3IgcmVtb3ZlKCkgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHRvZ2dsZUNscyh2YWx1ZSwgYWRkKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCB2YWx1ZSwgYWRkKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjb21wb25lbnQgRE9NXG4gICAgICovXG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS52ZG9tLnJlbW92ZURvbSA9IHRydWU7XG5cbiAgICAgICAgbWUuX2hpZGRlbiA9IHRydWU7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgbWUubW91bnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCB7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkOiBtZS52ZG9tLmlkfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCBmb3IgTmVvLm1hbmFnZXIuQ29tcG9uZW50LnVwXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFRoZSBtYXRjaGluZyBpbnN0YW5jZSBvciBudWxsXG4gICAgICovXG4gICAgdXAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLnVwKHRoaXMuaWQsIGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5hZnRlclNldFZkb20odGhpcy52ZG9tLCBudWxsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbHRhIHVwZGF0ZXMgZm9yIHRoZSBjbHMgY29uZmlnLiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgY2xzIGNvbmZpZyBnZXRzIGNoYW5nZWQgaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gY2xzXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkQ2xzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkPXRoaXMuaWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdXBkYXRlQ2xzKGNscywgb2xkQ2xzLCBpZD10aGlzLmlkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dm5vZGV9ICAgICA9IG1lLFxuICAgICAgICAgICAgdm5vZGVUYXJnZXQgPSB2bm9kZSAmJiBWTm9kZVV0aWwuZmluZChtZS52bm9kZSwge2lkfSk/LnZub2RlO1xuXG4gICAgICAgIGlmICh2bm9kZSAmJiAhTmVvLmlzRXF1YWwoY2xzLCBvbGRDbHMpKSB7XG4gICAgICAgICAgICBpZiAodm5vZGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2bm9kZVRhcmdldC5jbGFzc05hbWUgPSBjbHM7IC8vIGtlZXAgdGhlIHZub2RlIGluIHN5bmNcbiAgICAgICAgICAgICAgICBtZS52bm9kZSA9IHZub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUuYXBwTmFtZSwge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGNsczoge1xuICAgICAgICAgICAgICAgICAgICBhZGQgICA6IE5lb0FycmF5LmRpZmZlcmVuY2UoY2xzLCBvbGRDbHMpLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IE5lb0FycmF5LmRpZmZlcmVuY2Uob2xkQ2xzLCBjbHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHN0eWxlIGRlbHRhcyBmb3IgbmV3VmFsdWUgJiBvbGRWYWx1ZSBhbmQgYXBwbGllcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSBET00uXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2lkPXRoaXMuaWRdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVN0eWxlKHZhbHVlLCBvbGRWYWx1ZSwgaWQ9dGhpcy5pZCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZGVsdGEgPSBTdHlsZS5jb21wYXJlU3R5bGVzKHZhbHVlLCBvbGRWYWx1ZSksXG4gICAgICAgICAgICBvcHRzLCB2ZG9tLCB2bm9kZSwgdm5vZGVTdHlsZTtcblxuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHZkb20gID0gVkRvbVV0aWwuZmluZChtZS52ZG9tLCBpZCk7XG4gICAgICAgICAgICB2bm9kZSA9IG1lLnZub2RlICYmIFZOb2RlVXRpbC5maW5kKG1lLnZub2RlLCBpZCk7XG5cbiAgICAgICAgICAgIGlmICghbWUuaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBtZS5oYXNVbm1vdW50ZWRWZG9tQ2hhbmdlcyA9ICFtZS5tb3VudGVkICYmIG1lLmhhc0JlZW5Nb3VudGVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZkb20udmRvbS5zdHlsZSA9IHZhbHVlOyAvLyBrZWVwIHRoZSB2ZG9tIGluIHN5bmNcblxuICAgICAgICAgICAgaWYgKG1lLnNpbGVudFZkb21VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS5uZWVkc1Zkb21VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICB2bm9kZVN0eWxlID0gdm5vZGUudm5vZGUuc3R5bGU7XG5cbiAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZSB2bm9kZSBpbiBzeW5jXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGUgaXRlcmF0aW9uIHNpbmNlIHZkb20gc2hvcnRjdXRzIChoZWlnaHQsIHdpZHRoLC4uLikgbGl2ZSB3aXRoaW4gdGhlIHZub2RlIHN0eWxlXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgdm5vZGUudm5vZGUuc3R5bGUgPSBzdHlsZSB3b3VsZCBsb3NlIHRoZW0uXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZGVsdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2bm9kZS52bm9kZS5zdHlsZVtrZXldXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZVN0eWxlW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICd1cGRhdGVEb20nLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YXM6IFt7aWQsIHN0eWxlOiBkZWx0YX1dXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V29ya2VyLmlzU2hhcmVkV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuYXBwTmFtZSA9IG1lLmFwcE5hbWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50V29ya2VyLnNlbmRNZXNzYWdlKCdtYWluJywgb3B0cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSB2ZG9tIGNvbmZpZyBnZXRzIGNoYW5nZWQgaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIGFscmVhZHkgbW91bnRlZCAoZGVsdGEgdXBkYXRlcykuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb209dGhpcy52ZG9tXG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gdm5vZGU9dGhpcy52bm9kZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXNvbHZlXSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZWplY3RdIHVzZWQgYnkgcHJvbWlzZVVwZGF0ZSgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZVZkb20odmRvbT10aGlzLnZkb20sIHZub2RlPXRoaXMudm5vZGUsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHthcHAsIG1vdW50ZWQsIHBhcmVudElkfSA9IG1lLFxuICAgICAgICAgICAgbGlzdGVuZXJJZDtcblxuICAgICAgICBpZiAobWUuaXNWZG9tVXBkYXRpbmcgfHwgbWUuc2lsZW50VmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSAmJiBtZS5yZXNvbHZlVXBkYXRlQ2FjaGUucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICAgIG1lLm5lZWRzVmRvbVVwZGF0ZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbW91bnRlZCAmJiBtZS5pc0NvbnN0cnVjdGVkICYmICFtZS5oYXNSZW5kZXJpbmdMaXN0ZW5lciAmJiBhcHA/LnJlbmRlcmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIG1lLmhhc1JlbmRlcmluZ0xpc3RlbmVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGxpc3RlbmVySWQgPSBhcHAub24oJ21vdW50ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC51bignbW91bnRlZCcsIGxpc3RlbmVySWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudm5vZGUgJiYgbWUudXBkYXRlVmRvbShtZS52ZG9tLCBtZS52bm9kZSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlICYmICghbW91bnRlZCB8fCAhdm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlc29sdmVVcGRhdGVDYWNoZS5wdXNoKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhbWUubmVlZHNQYXJlbnRVcGRhdGUocGFyZW50SWQsIHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgICYmICFtZS5pc1BhcmVudFVwZGF0aW5nKHBhcmVudElkLCByZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAmJiBtb3VudGVkXG4gICAgICAgICAgICAgICAgICAgICYmIHZub2RlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjcml0aWNhbCByZW5kZXJpbmcgcGF0aCA9PiBDU1MgZmlsZXMgZm9yIHRoZSBuZXcgdHJlZSBpcyBpbiBwbGFjZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFdvcmtlci5jb3VudExvYWRpbmdUaGVtZUZpbGVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29ya2VyLm9uKCd0aGVtZUZpbGVzTG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlVmRvbSh2ZG9tLCB2bm9kZSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLiNleGVjdXRlVmRvbVVwZGF0ZSh2ZG9tLCB2bm9kZSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaGFzVW5tb3VudGVkVmRvbUNoYW5nZXMgPSAhbW91bnRlZCAmJiBtZS5oYXNCZWVuTW91bnRlZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgeW91IGFyZSBzdXJlIGEgRE9NUmVjdCBleGlzdHMsIHVzZSBnZXREb21SZWN0KClcbiAgICAgKiBPdGhlcndpc2UgeW91IGNhbiB3YWl0IGZvciBpdCB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZTpcbiAgICAgKiAgICAgYXdhaXQgdGhpcy5yZW5kZXIodHJ1ZSk7XG4gICAgICogICAgIGF3YWl0IHRoaXMud2FpdEZvckRvbVJlY3QoKTtcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgb3B0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICBvcHRzLmFwcE5hbWU9dGhpcy5hcHBOYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIG9wdHMuYXR0ZW1wdHM9MTAgUmVydW5zIGluIGNhc2UgdGhlIHJlY3QgaGVpZ2h0IG9yIHdpZHRoIGVxdWFscyAwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIG9wdHMuZGVsYXk9NTAgICAgVGltZSBpbiBtcyBiZWZvcmUgY2hlY2tpbmcgYWdhaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gb3B0cy5pZD10aGlzLmlkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TmVvLnV0aWwuUmVjdGFuZ2xlfE5lby51dGlsLlJlY3RhbmdsZVtdPn1cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRG9tUmVjdCh7YXBwTmFtZT10aGlzLmFwcE5hbWUsIGF0dGVtcHRzPTEwLCBkZWxheT01MCwgaWQ9dGhpcy5pZH0pIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBtZS5nZXREb21SZWN0KGlkLCBhcHBOYW1lKSxcbiAgICAgICAgICAgIHJlUnVuICA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKHJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmhlaWdodCA8IDEgfHwgcmVjdC53aWR0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVSdW4gPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuaGVpZ2h0IDwgMSB8fCByZXN1bHQud2lkdGggPCAxKSB7XG4gICAgICAgICAgICByZVJ1biA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZVJ1biAmJiBhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoZGVsYXkpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG1lLndhaXRGb3JEb21SZWN0KHthcHBOYW1lLCBhdHRlbXB0czogYXR0ZW1wdHMtMSwgZGVsYXksIGlkfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG59XG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgYWZ0ZXIgZm9jdXNFbnRlciwgZm9jdXNMZWF2ZSBvciBmb2N1c01vdmVcbiAqIEBldmVudCBmb2N1c0NoYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0W119IFtkYXRhLnBhdGhdIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBbZGF0YS5vbGRQYXRoXSBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICovXG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlkIGlzIGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGhcbiAqIEBldmVudCBmb2N1c0VudGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgbm90IGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGhcbiAqIEBldmVudCBmb2N1c0xlYXZlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgaW5jbHVkZWQgaW5zaWRlIHRoZSBkb20gaWQgcGF0aCwgYnV0IHRoZSBwYXRoIGl0c2VsZiBjaGFuZ2VkXG4gKiBAZXZlbnQgZm9jdXNNb3ZlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJhc2UgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE5lb0FycmF5IGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnV0aWwuS2V5TmF2aWdhdGlvblxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBLZXlOYXZpZ2F0aW9uIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5LZXlOYXZpZ2F0aW9uJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC5LZXlOYXZpZ2F0aW9uJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2tleW5hdidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdrZXluYXYnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWxseSBzdG9yZXMgdGhlIGNvbXBvbmVudCBpZCBpbnNpZGUgX2NvbXBvbmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50Xz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpbiBjYXNlIHRoZSBrZXlkb3duIGV2ZW50IGlzIHN1cHBvc2VkIHRvIGJ1YmJsZSB1cHdhcmRzIGluc2lkZSB0aGUgY29tcG9uZW50IHRyZWVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0ga2V5RG93bkV2ZW50QnViYmxlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBrZXlEb3duRXZlbnRCdWJibGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0ga2V5c189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAga2V5c186IG51bGxcbiAgICB9XG5cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fa2V5cy5wdXNoKC4uLnRoaXMucGFyc2VLZXlzKHZhbHVlKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuX2NvbXBvbmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGNvbXBvbmVudCBpZFxuICAgICAqL1xuICAgIGJlZm9yZVNldENvbXBvbmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU/LmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd24oZGF0YSkge1xuICAgICAgICAvLyBVc2luZyB0aGUgY2hyb21lIGF1dG8tZmlsbCBmZWF0dXJlIGRvZXMgdHJpZ2dlciBhIGtleWRvd24gZXZlbnQsIG5vdCBjb250YWluaW5nIGEga2V5LiBTZWU6ICM2NFxuICAgICAgICBpZiAoZGF0YS5rZXkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHVwcGVyQ2FzZUtleSA9IGRhdGEua2V5LnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgc2NvcGU7XG5cbiAgICAgICAgICAgIHVwcGVyQ2FzZUtleSA9IG1lLnBhcnNlVXBwZXJDYXNlS2V5KHVwcGVyQ2FzZUtleSk7XG5cbiAgICAgICAgICAgIG1lLmtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gTmVvLmlzU3RyaW5nKGtleS5zY29wZSkgPyBOZW8uZ2V0KGtleS5zY29wZSkgOiBrZXkuc2NvcGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LmtleS50b1VwcGVyQ2FzZSgpID09PSB1cHBlckNhc2VLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKGtleS5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5mbi5hcHBseShzY29wZSwgW2RhdGEsIG1lLmNvbXBvbmVudF0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtrZXkuZm5dPy5hcHBseShzY29wZSwgW2RhdGEsIG1lLmNvbXBvbmVudF0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZUtleXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudElkID0gdGhpcy5fY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGtleUFycmF5ICAgID0gW107XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCB2YWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdzY29wZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUFycmF5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuICAgOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiB2YWx1ZS5zY29wZSB8fCBjb21wb25lbnRJZCAvLyB0b2RvOiBzdXBwb3J0IFZDcyBsYXRlciBvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBrZXlBcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgc3BlY2lmaWMga2V5IG5hbWVzLCBlLmcuIFwiIFwiID0+IFNQQUNFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHBhcnNlVXBwZXJDYXNlS2V5KGtleSkge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ1NQQUNFJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVJST1dET1dOJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnRE9XTic7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FSUk9XTEVGVCc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ0xFRlQnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV1JJR0hUJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnUklHSFQnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV1VQJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnVVAnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgbWUua2V5cyAgICAgID0gbWUucGFyc2VLZXlzKG1lLmtleXMpO1xuXG4gICAgICAgIGNvbXBvbmVudC5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAga2V5ZG93bjoge1xuICAgICAgICAgICAgICAgIGJ1YmJsZTogbWUua2V5RG93bkV2ZW50QnViYmxlLFxuICAgICAgICAgICAgICAgIGZuICAgIDogbWUub25LZXlEb3duLFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBrZXkgbGlzdGVuZXIgdXNpbmcgdGhlIHNhbWUgY29uZmlnIHVzZWQgd2hlbiBjcmVhdGluZyBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICByZW1vdmVLZXkoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleXMgPSBtZS5fa2V5cyxcbiAgICAgICAgICAgIGkgICAgPSAwLFxuICAgICAgICAgICAgbGVuICA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNFcXVhbChrZXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG11bHRpcGxlIGtleSBsaXN0ZW5lcnMgcGFzc2luZyBhbiBhcnJheSBvZiBjb25maWcgaXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICAgICAqL1xuICAgIHJlbW92ZUtleXMoaXRlbXMpIHtcbiAgICAgICAgQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMuZm9yRWFjaChpdGVtID0+IHRoaXMucmVtb3ZlS2V5KGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoZSBkb20gbGlzdGVuZXIgZnJvbSB0aGUgb3duZXIgY29tcG9uZW50XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhLZXlOYXZpZ2F0aW9uKTtcbiIsIi8qKlxuICogVGhlIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIERPTVJlY3QgT2JqZWN0c1xuICogQGNsYXNzIE5lby51dGlsLlJlY3RhbmdsZVxuICogQGV4dGVuZHMgRE9NUmVjdFxuICovXG5cbmNvbnN0XG4gICAgZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUoW10pLFxuICAgIC8vIENvbnZlcnQgZWRnZSBhcnJheSB2YWx1ZXMgaW50byB0aGUgW1QsUixCLExdIGZvcm0uXG4gICAgcGFyc2VFZGdlVmFsdWUgPSAoZSA9IDApID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICBlID0gW2VdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBlLmxlbmd0aCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZmlsbChlWzBdLCAxLCA0KTtcbiAgICAgICAgICAgIGNhc2UgMjovLyB0b3AmYm90dG9tLCBsZWZ0JnJpZ2h0XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlWzBdLCBlWzFdLCBlWzBdLCBlWzFdXTtcbiAgICAgICAgICAgIGNhc2UgMzovLyB0b3AsIGxlZnQmcmlnaHQsIGJvdHRvbVxuICAgICAgICAgICAgICAgIHJldHVybiBbZVswXSwgZVsxXSwgZVsyXSwgZVsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfSxcbiAgICBwYXJzZUVkZ2VBbGlnbiA9IGVkZ2VBbGlnbiA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBlZGdlUGFydHMgICAgID0gZWRnZUFsaWduUkUuZXhlYyhlZGdlQWxpZ24pLFxuICAgICAgICAgICAgb3VyRWRnZVpvbmUgICA9IGVkZ2Vab25lW2VkZ2VQYXJ0c1sxXV0sXG4gICAgICAgICAgICB0aGVpckVkZ2Vab25lID0gZWRnZVpvbmVbZWRnZVBhcnRzWzRdXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3VyRWRnZSAgICAgICAgIDogZWRnZVBhcnRzWzFdLFxuICAgICAgICAgICAgb3VyRWRnZU9mZnNldCAgIDogcGFyc2VJbnQoZWRnZVBhcnRzWzJdIHx8IDUwKSxcbiAgICAgICAgICAgIG91ckVkZ2VVbml0ICAgICA6IGVkZ2VQYXJ0c1szXSB8fCAnJScsXG4gICAgICAgICAgICBvdXJFZGdlWm9uZSxcbiAgICAgICAgICAgIHRoZWlyRWRnZSAgICAgICA6IGVkZ2VQYXJ0c1s0XSxcbiAgICAgICAgICAgIHRoZWlyRWRnZU9mZnNldCA6IHBhcnNlSW50KGVkZ2VQYXJ0c1s1XSB8fCA1MCksXG4gICAgICAgICAgICB0aGVpckVkZ2VVbml0ICAgOiBlZGdlUGFydHNbNl0gfHwgJyUnLFxuICAgICAgICAgICAgdGhlaXJFZGdlWm9uZSxcblxuICAgICAgICAgICAgLy8gQWxpZ25lZCB0byBhbiBlZGdlLCAqb3V0c2lkZSogb2YgdGhlIHRhcmdldC5cbiAgICAgICAgICAgIC8vIEEgbm9ybWFsIGFsaWduIGFzIGEgY29tYm8gZHJvcGRvd24gbWlnaHQgcmVxdWVzdFxuICAgICAgICAgICAgZWRnZUFsaWduZWQgICAgIDogKG91ckVkZ2Vab25lICYgMSkgPT09ICh0aGVpckVkZ2Vab25lICYgMSkgJiYgb3VyRWRnZVpvbmUgIT09IHRoZWlyRWRnZVpvbmVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gVGhlIG9wcG9zaXRlIG9mIHBhcnNlRWRnZUFsaWduLCBhbmQgaXQgaGFzIHRvIGZsaXAgdGhlIGVkZ2VzXG4gICAgY3JlYXRlUmV2ZXJzZWRFZGdlQWxpZ24gPSBlZGdlcyA9PiB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBvdXJFZGdlICAgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMub3VyRWRnZV0sXG4gICAgICAgICAgICB0aGVpckVkZ2UgPSBvcHBvc2l0ZUVkZ2VbZWRnZXMudGhlaXJFZGdlXTtcblxuICAgICAgICAvLyByZWNvbnN0aXR1dGUgYSBydWxlIHN0cmluZyB3aXRoIHRoZSBlZGdlcyBmbGlwcGVkIHRvIHRoZSBvcHBvc2l0ZSBzaWRlc1xuICAgICAgICByZXR1cm4gYCR7b3VyRWRnZX0ke2VkZ2VzLm91ckVkZ2VPZmZzZXR9JHtlZGdlcy5vdXJFZGdlVW5pdH0tJHt0aGVpckVkZ2V9JHtlZGdlcy50aGVpckVkZ2VPZmZzZXR9JHtlZGdlcy50aGVpckVkZ2VVbml0fWBcblxuICAgIH0sXG4gICAgZ2V0RWxSZWN0ID0gZWwgPT4ge1xuICAgICAgICBjb25zdCByID0gZWwgaW5zdGFuY2VvZiBET01SZWN0ID8gZWwgOiAoZWw/Lm5vZGVUeXBlID09PSAxID8gZWwgOiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpIDogbnVsbCk/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgRE9NUmVjdCBpbnRvIFJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gciAmJiBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG4gICAgfSxcbiAgICBvcHBvc2l0ZUVkZ2UgPSB7XG4gICAgICAgIHQgOiAnYicsXG4gICAgICAgIHIgOiAnbCcsXG4gICAgICAgIGIgOiAndCcsXG4gICAgICAgIGwgOiAncidcbiAgICB9LFxuICAgIGVkZ2Vab25lID0ge1xuICAgICAgICB0IDogMCxcbiAgICAgICAgciA6IDEsXG4gICAgICAgIGIgOiAyLFxuICAgICAgICBsIDogM1xuICAgIH0sXG4gICAgem9uZU5hbWVzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgICB6b25lRWRnZXMgPSBbJ3QnLCAncicsICdiJywgJ2wnXSxcbiAgICB6b25lRGltZW5zaW9uID0gWyd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICB6b25lQ29vcmQgPSBbMCwgMSwgMCwgMV0sXG4gICAgemVyb01hcmdpbnMgPSBbMCwgMCwgMCwgMF0sXG4gICAgZWRnZUFsaWduUkUgPSAvXihbdHJibGNdKShcXGQqKSglfHB4KT8tKFt0cmJsY10pKFxcZCopKCV8cHgpPyQvO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBET01SZWN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby51dGlsLlJlY3RhbmdsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuUmVjdGFuZ2xlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtaW5IZWlnaHQ9bnVsbFxuICAgICAqL1xuICAgIG1pbkhlaWdodCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gbWluV2lkdGg9bnVsbFxuICAgICAqL1xuICAgIG1pbldpZHRoID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QxIGRvZXMgbm90IGhhdmUgYW4gaW50ZXJzZWN0aW9uIHdpdGggcmVjdDJcbiAgICAgKiAhaW5jbHVkZXMoKSBpcyB0cnVlIGZvciBpbnRlcnNlY3Rpb25zIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhjbHVkZXMocmVjdDEsIHJlY3QyKSB7XG4gICAgICAgIHJldHVybiByZWN0MS5ib3R0b20gPCByZWN0Mi50b3AgICAgIC8vIHJlY3QyIGlzIGJlbG93IHJlY3QxXG4gICAgICAgICAgICB8fCByZWN0MS5sZWZ0ICAgPiByZWN0Mi5yaWdodCAgIC8vIHJlY3QyIGlzIGxlZnQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnJpZ2h0ICA8IHJlY3QyLmxlZnQgICAgLy8gcmVjdDIgaXMgcmlnaHQgb2YgcmVjdDFcbiAgICAgICAgICAgIHx8IHJlY3QxLnRvcCAgICA+IHJlY3QyLmJvdHRvbTsgLy8gcmVjdDIgaXMgYWJvdmUgcmVjdDFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGFwcGluZyBhcmVhIG9mIHJlY3QxICYgcmVjdDJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYXJlYSAoeCAqIHkpXG4gICAgICovXG4gICAgc3RhdGljIGdldEludGVyc2VjdGlvbihyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5nZXRJbnRlcnNlY3Rpb25EZXRhaWxzKHJlY3QxLCByZWN0MikuYXJlYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVybGFwcGluZyBhcmVhIG9mIHJlY3QxICYgcmVjdDJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdDJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB4LCB5ICYgYXJlYVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJbnRlcnNlY3Rpb25EZXRhaWxzKHJlY3QxLCByZWN0Mikge1xuICAgICAgICBsZXQgd2lkdGggID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdDEucmlnaHQsICByZWN0Mi5yaWdodCkgIC0gTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCkpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pIC0gTWF0aC5tYXgocmVjdDEudG9wLCAgcmVjdDIudG9wKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyZWE6IGhlaWdodCAqIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcmVjdDIgaXMgZnVsbHkgY29udGFpbmVkIGluc2lkZSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpbmNsdWRlcyhyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QxLmJvdHRvbSA+PSByZWN0Mi5ib3R0b21cbiAgICAgICAgICAgICYmIHJlY3QxLmxlZnQgICA8PSByZWN0Mi5sZWZ0XG4gICAgICAgICAgICAmJiByZWN0MS5yaWdodCAgPj0gcmVjdDIucmlnaHRcbiAgICAgICAgICAgICYmIHJlY3QxLnRvcCAgICA8PSByZWN0Mi50b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHJlY3QyIGlzIG5vdCBjb250YWluZWQgaW5zaWRlIHJlY3QxLlxuICAgICAqIFRoaXMgY291bGQgYmUgYW4gaW50ZXJzZWN0aW9uIG9yIGJlaW5nIGZ1bGx5IGV4Y2x1ZGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0MlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlIGJvdHRvbSwgbGVmdCwgcmlnaHQgb3IgdG9wXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGxlYXZlc1NpZGUocmVjdDEsIHJlY3QyLCBzaWRlKSB7XG4gICAgICAgIGlmIChSZWN0YW5nbGUuaW5jbHVkZXMocmVjdDEsIHJlY3QyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEuYm90dG9tIDwgcmVjdDIuYm90dG9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QxLmxlZnQgPiByZWN0Mi5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0MS5yaWdodCA8IHJlY3QyLnJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdDEudG9wID4gcmVjdDIudG9wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIERPTVJlY3Qgb2JqZWN0IHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeD1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5PW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH0gbW92ZWRSZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1vdmVCeShyZWN0LCB4PW51bGwsIHk9bnVsbCkge1xuICAgICAgICBsZXQgbW92ZWRSZWN0ID0gey4uLnJlY3R9O1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5sZWZ0ICArPSB4O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnJpZ2h0ICs9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QueCAgICAgKz0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5ib3R0b20gKz0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC50b3AgICAgKz0geTtcbiAgICAgICAgICAgIG1vdmVkUmVjdC55ICAgICAgKz0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3ZlZFJlY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyBhIERPTVJlY3Qgb2JqZWN0IHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBbeD1udWxsXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IFt5PW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH0gbW92ZWRSZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1vdmVUbyhyZWN0LCB4PW51bGwsIHk9bnVsbCkge1xuICAgICAgICBsZXQgbW92ZWRSZWN0ID0gey4uLnJlY3R9O1xuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeCkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5sZWZ0ICA9IHg7XG4gICAgICAgICAgICBtb3ZlZFJlY3QucmlnaHQgPSB4ICsgbW92ZWRSZWN0LndpZHRoO1xuICAgICAgICAgICAgbW92ZWRSZWN0LnggICAgID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNOdW1iZXIoeSkpIHtcbiAgICAgICAgICAgIG1vdmVkUmVjdC5ib3R0b20gPSB5ICsgbW92ZWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIG1vdmVkUmVjdC50b3AgICAgPSB5O1xuICAgICAgICAgICAgbW92ZWRSZWN0LnkgICAgICA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWRSZWN0O1xuICAgIH1cblxuICAgIHNldCBib3R0b20oYikge1xuICAgICAgICB0aGlzLmhlaWdodCArPSBiIC0gdGhpcy5ib3R0b207XG4gICAgfVxuICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5ib3R0b207XG4gICAgfVxuXG4gICAgc2V0IHJpZ2h0KHIpIHtcbiAgICAgICAgdGhpcy53aWR0aCArPSByIC0gdGhpcy5yaWdodDtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gc3VwZXIucmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSB4IHdpdGhvdXQgbW92aW5nIHRoZSBSZWN0YW5nbGUuIFRoZSBsZWZ0IHNpZGUgbW92ZXMgYW5kIHRoZSByaWdodCBzaWRlIGRvZXNuJ3RcbiAgICBjaGFuZ2VYKHgpIHtcbiAgICAgICAgY29uc3Qgd2lkdGhEZWx0YSA9IHRoaXMueCAtIHg7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy53aWR0aCArPSB3aWR0aERlbHRhO1xuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgeSB3aXRob3V0IG1vdmluZyB0aGUgUmVjdGFuZ2xlLiBUaGUgdG9wIHNpZGUgbW92ZXMgYW5kIHRoZSBib3R0b20gc2lkZSBkb2Vzbid0XG4gICAgY2hhbmdlWSh5KSB7XG4gICAgICAgIGNvbnN0IGhlaWdodERlbHRhID0gdGhpcy55IC0geTtcblxuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHREZWx0YTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlY3RhbmdsZS5jbG9uZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xvbmUocikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG5cbiAgICAgICAgcmVzdWx0Lm1pbldpZHRoID0gci5taW5XaWR0aDtcbiAgICAgICAgcmVzdWx0Lm1pbkhlaWdodCA9IHIubWluSGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0cyhvdGhlcikge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG90aGVyLmhlaWdodCAmJiBvdGhlci53aWR0aCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBsZWZ0ICAgPSBNYXRoLm1heChtZS54LCBvdGhlci54KSxcbiAgICAgICAgICAgICAgICB0b3AgICAgPSBNYXRoLm1heChtZS55LCBvdGhlci55KSxcbiAgICAgICAgICAgICAgICByaWdodCAgPSBNYXRoLm1pbihtZS54ICsgbWUud2lkdGgsIG90aGVyLnggKyBvdGhlci53aWR0aCksXG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4obWUueSArIG1lLmhlaWdodCwgb3RoZXIueSArIG90aGVyLmhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0ID49IHJpZ2h0IHx8IHRvcCA+PSBib3R0b20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBhIHBvaW50IGhlcmUgLSB6ZXJvIGRpbWVuc2lvbnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKG90aGVyLnggPj0gbWUueCAmJiBvdGhlci55ID49IG1lLnkgJiYgb3RoZXIucmlnaHQgPD0gbWUucmlnaHQgJiYgb3RoZXIuYm90dG9tIDw9IG1lLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG90aGVyIFJlY3RhbmdsZSBpcyBmdWxseSBjb250YWluZWQgaW5zaWRlIHRoaXMgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgY29udGFpbnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tID49IG90aGVyLmJvdHRvbVxuICAgICAgICAgICAgJiYgdGhpcy5sZWZ0ICAgPD0gb3RoZXIubGVmdFxuICAgICAgICAgICAgJiYgdGhpcy5yaWdodCAgPj0gb3RoZXIucmlnaHRcbiAgICAgICAgICAgICYmIHRoaXMudG9wICAgIDw9IG90aGVyLnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGUgZXhwYW5kZWQgYWNjb3JkaW5nIHRvIHRoZSBlZGdlcyBhcnJheS5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBlZGdlc1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9XG4gICAgICovXG4gICAgZXhwYW5kKGVkZ2VzKSB7XG4gICAgICAgIGVkZ2VzID0gcGFyc2VFZGdlVmFsdWUoZWRnZXMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnggLSBlZGdlc1szXSwgdGhpcy55IC0gZWRnZXNbMF0sIHRoaXMud2lkdGggKyBlZGdlc1sxXSArIGVkZ2VzWzNdLCB0aGlzLmhlaWdodCArIGVkZ2VzWzBdICsgZWRnZXNbMl0pO1xuICAgIH1cblxuICAgIG1vdmVCeSh4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgICAgICB5ID0geFsxXTtcbiAgICAgICAgICAgIHggPSB4WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC54ICs9IHg7XG4gICAgICAgIHJlc3VsdC55ICs9IHk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBSZWN0YW5nbGUgY29tcGxldGVseSBjb250YWlucyB0aGUgb3RoZXIgUmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IG90aGVyXG4gICAgICovXG4gICAgY29udGFpbnMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuaW5jbHVkZXModGhpcywgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgUmVjdGFuZ2xlIGNvbnN0cmFpbmVkIHRvIGZpdCB3aXRoaW4gdGhlIHBhc3NlZCBSZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uc3RyYWluVG9cbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfEJvb2xlYW59IEEgbmV3IFJlY3RhbmdsZSBjb25zdHJhaW5lZCB0byB0ZSBwYXNzZWQgUmVjdGFuZ2xlLCBvciBmYWxzZSBpZiBpdCBjb3VsZCBub3QgYmUgY29uc3RyYWluZWQuXG4gICAgICovXG4gICAgY29uc3RyYWluVG8oY29uc3RyYWluVG8pIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBtaW5XaWR0aCAgPSBtZS5taW5XaWR0aCAgfHwgbWUud2lkdGgsXG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBtZS5taW5IZWlnaHQgfHwgbWUuaGVpZ2h0O1xuXG4gICAgICAgIC8vIE5vdCBwb3NzaWJsZSwgZXZlbiB3aGVuIHNocnVuayB0byBtaW5pbWFcbiAgICAgICAgaWYgKG1pbkhlaWdodCA+IGNvbnN0cmFpblRvLmhlaWdodCB8fCBtaW5XaWR0aCA+IGNvbnN0cmFpblRvLndpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBkbyBub3QgbXV0YXRlIHRoaXMgUmVjdGFuZ2xlLCBidXQgcmV0dXJuIGEgY29uc3RyYWluZWQgdmVyc2lvblxuICAgICAgICBjb25zdCByZXN1bHQgPSBtZS5jbG9uZSgpO1xuXG4gICAgICAgIC8vIFRyYW5zbGF0ZSByZXN1bHQgc28gdGhhdCB0aGUgdG9wIGFuZCBsZWZ0IGFyZSB2aXNpYmxlXG4gICAgICAgIHJlc3VsdC54ID0gTWF0aC5tYXgobWUueCArIE1hdGgubWluKGNvbnN0cmFpblRvLnJpZ2h0ICAtIHJlc3VsdC5yaWdodCwgIDApLCBjb25zdHJhaW5Uby54KTtcbiAgICAgICAgcmVzdWx0LnkgPSBNYXRoLm1heChtZS55ICsgTWF0aC5taW4oY29uc3RyYWluVG8uYm90dG9tIC0gcmVzdWx0LmJvdHRvbSwgMCksIGNvbnN0cmFpblRvLnkpO1xuXG4gICAgICAgIC8vIFB1bGwgaW4gYW55IHJlc3VsdGluZyBvdmVyZmxvd1xuICAgICAgICByZXN1bHQuYm90dG9tID0gTWF0aC5taW4ocmVzdWx0LmJvdHRvbSwgY29uc3RyYWluVG8uYm90dG9tKTtcbiAgICAgICAgcmVzdWx0LnJpZ2h0ID0gTWF0aC5taW4ocmVzdWx0LnJpZ2h0LCBjb25zdHJhaW5Uby5yaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhbGlnblRvKGFsaWduKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWluVG8sICAgIC8vIEVsZW1lbnQgb3IgUmVjdGFuZ2xlIHJlc3VsdCBtdXN0IGZpdCBpbnRvXG4gICAgICAgICAgICAgICAgdGFyZ2V0LCAgICAgICAgIC8vIEVsZW1lbnQgb3IgUmVjdGFuZ2xlIHRvIGFsaWduIHRvXG4gICAgICAgICAgICAgICAgZWRnZUFsaWduLCAgICAgIC8vIHQ1MC1iNTAgdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICBheGlzTG9jaywgICAgICAgLy8gdHJ1ZSBmb3IgZmxpcCwgJ2ZsZXhpYmxlJyBmb3IgZmxpcCwgdGhlbiB0cnkgdGhlIG90aGVyIGVkZ2VzXG4gICAgICAgICAgICAgICAgb2Zmc2V0LCAgICAgICAgIC8vIEZpbmFsIFt4LCB5XSB2ZWN0b3IgdG8gbW92ZSB0aGUgcmVzdWx0IGJ5LlxuICAgICAgICAgICAgICAgIG1hdGNoU2l6ZVxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgPSBhbGlnbixcbiAgICAgICAgICAgIHRhcmdldE1hcmdpbiAgID0gYWxpZ24udGFyZ2V0TWFyZ2luID8gcGFyc2VFZGdlVmFsdWUoYWxpZ24udGFyZ2V0TWFyZ2luKSA6IHplcm9NYXJnaW5zLFxuICAgICAgICAgICAgdGFyZ2V0UmVjdCAgICAgPSBnZXRFbFJlY3QodGFyZ2V0KSxcbiAgICAgICAgICAgIGNvbnN0cmFpblJlY3QgID0gZ2V0RWxSZWN0KGNvbnN0cmFpblRvKSxcbiAgICAgICAgICAgIGVkZ2VzICAgICAgICAgID0gcGFyc2VFZGdlQWxpZ24oZWRnZUFsaWduKSxcbiAgICAgICAgICAgIG1hdGNoRGltZW5zaW9uID0gem9uZURpbWVuc2lvbltlZGdlcy50aGVpckVkZ2Vab25lICYgMV07XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IG1lLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoU2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0W21hdGNoRGltZW5zaW9uXSA9IHRhcmdldFJlY3RbbWF0Y2hEaW1lbnNpb25dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTXVzdCBkbyB0aGUgY2FsY3VsYXRpb25zIGFmdGVyIHRoZSBhbGlnbmVkIHNpZGUgaGFzIGJlZW4gbWF0Y2hlZCBpbiBzaXplIGlmIHJlcXVlc3RlZC5cbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG15UG9pbnQgICAgID0gcmVzdWx0LmdldEFuY2hvclBvaW50KGVkZ2VzLm91ckVkZ2Vab25lLCBlZGdlcy5vdXJFZGdlT2Zmc2V0LCBlZGdlcy5vdXJFZGdlVW5pdCksXG4gICAgICAgICAgICB0YXJnZXRQb2ludCA9IHRhcmdldFJlY3QuZ2V0QW5jaG9yUG9pbnQoZWRnZXMudGhlaXJFZGdlWm9uZSwgZWRnZXMudGhlaXJFZGdlT2Zmc2V0LCBlZGdlcy50aGVpckVkZ2VVbml0LCB0YXJnZXRNYXJnaW4pLFxuICAgICAgICAgICAgdmVjdG9yICAgICAgPSBbdGFyZ2V0UG9pbnRbMF0gLSBteVBvaW50WzBdLCB0YXJnZXRQb2ludFsxXSAtIG15UG9pbnRbMV1dO1xuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tb3ZlQnkodmVjdG9yKTtcblxuICAgICAgICAvLyBBIHVzZWZ1bCBwcm9wZXJ0eSBpbiB0aGUgcmVzdWx0aW5nIHJlY3RhbmdsZSB3aGljaCBzcGVjaWZpZXMgd2hpY2ggem9uZSBvZiB0aGUgdGFyZ2V0XG4gICAgICAgIC8vIEl0IGlzIGJlaW5nIHBsYWNlcyBpbiwgVCxSLEIgb3IgTCAtIDAsIDEsIDIsIDNcbiAgICAgICAgLy8gU29tZSBjb2RlIG1heSB3YW50IHRvIHRyZWF0IERPTSBlbGVtZW50cyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gdGhlIHpvbmVcbiAgICAgICAgcmVzdWx0LnpvbmUgPSBlZGdlcy50aGVpckVkZ2Vab25lO1xuICAgICAgICByZXN1bHQucG9zaXRpb24gPSB6b25lTmFtZXNbcmVzdWx0LnpvbmVdO1xuXG4gICAgICAgIC8vIE5vdyB3ZSBjcmVhdGUgdGhlIGZvdXIgUmVjdGFuZ2xlcyBhcm91bmQgdGhlIHRhcmdldCwgaW50byB3aGljaCB3ZSBtYXkgYmUgY29uc3RyYWluZWRcbiAgICAgICAgLy8gWm9uZXMgVCxSLEIsTCAwIDksIDEsIDIsIDM6XG4gICAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgLy8gfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgXiAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgXiAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICA8LS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS1ab25lIDAtLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tPiAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCArLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgWm9uZSAzICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICAgICB8IHwgICAgICAgICAgWm9uZSAxICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8IHwgICAgICAgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfCAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgKystLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgLy8gfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCB8ICA8LS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLVpvbmUgMi0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0+IHwgfFxuICAgICAgICAvLyB8IHwgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCB8XG4gICAgICAgIC8vIHwgfCAgICAgICAgICB2ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICB2ICAgICAgICAgICAgICB8IHxcbiAgICAgICAgLy8gfCArKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgIGlmIChjb25zdHJhaW5SZWN0ICYmICFjb25zdHJhaW5SZWN0LmNvbnRhaW5zKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXkgYXNrZWQgdG8gb3ZlcmxhcCB0aGUgdGFyZ2V0LCBmb3IgZXhhbXBsZSB0MC10MFxuICAgICAgICAgICAgLy8gSW4gdGhlc2UgY2FzZXMsIHdlIGp1c3QgcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICh0YXJnZXRSZWN0LmludGVyc2VjdHMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHpvbmUgd2UgdHJ5IHRvIGZpdCBpbnRvIGZpcnN0LCB0aGUgb25lIHRoYXQgd2FzIGFza2VkIGZvclxuICAgICAgICAgICAgbGV0IHpvbmUgPSBlZGdlcy50aGVpckVkZ2Vab25lO1xuXG4gICAgICAgICAgICAvLyBXZSBjcmVhdGUgYW4gYXJyYXkgb2YgZm91ciByZWN0YW5nbGVzIGludG8gd2hpY2ggd2UgdHJ5IHRvIGZpdCB3aXRoIGFwcHJvcHJpYXRlIGFsaWduIHNwZWNzLlxuICAgICAgICAgICAgLy8gV2UgbXVzdCBzdGFydCB3aXRoIHRoZSByZXF1ZXN0ZWQgem9uZSwgd2hhdGV2ZXIgdGhhdCBpcy5cbiAgICAgICAgICAgIGNvbnN0IHpvbmVzVG9UcnkgPSBbe1xuICAgICAgICAgICAgICAgIHpvbmUsXG4gICAgICAgICAgICAgICAgZWRnZUFsaWduXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgaWYgKGF4aXNMb2NrKSB7XG4gICAgICAgICAgICAgICAgLy8gRmxpcCB0byB0aGUgb3Bwb3NpdGUgc2lkZSBmb3IgdGhlIHNlY29uZCB0cnkuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFsaWdubWVudCBzdHJpbmcgaGFzIHRvIGJlIHJldmVyc2VkXG4gICAgICAgICAgICAgICAgLy8gc28gcjIwLWwzMCBoYXMgdG8gYmVjb21lIGwyMC1yMzAuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG90aGVyIHR3byB6b25lcyByZXZlcnQgdG8gY2VudGVyZWQgc28gYXJlIGVhc2llclxuICAgICAgICAgICAgICAgIHpvbmVzVG9UcnlbMV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoem9uZSArIDIpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduIDogY3JlYXRlUmV2ZXJzZWRFZGdlQWxpZ24oZWRnZXMpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBvdGhlciB0d28gem9uZXMuXG4gICAgICAgICAgICAgICAgem9uZXNUb1RyeS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgem9uZSAgICAgIDogem9uZSA9IChlZGdlcy50aGVpckVkZ2Vab25lICsgMSkgJSA0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24gOiBgJHtvcHBvc2l0ZUVkZ2Vbem9uZUVkZ2VzW3pvbmVdXX0tJHt6b25lRWRnZXNbem9uZV19YFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHpvbmVzVG9UcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoZWRnZXMudGhlaXJFZGdlWm9uZSArIDMpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgZWRnZUFsaWduIDogYCR7b3Bwb3NpdGVFZGdlW3pvbmVFZGdlc1t6b25lXV19LSR7em9uZUVkZ2VzW3pvbmVdfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG90aGVyIHpvbmVzIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgem9uZXNUb1RyeS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvbmUgICAgICA6IHpvbmUgPSAoem9uZSArIDEpICUgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbiA6IGAke29wcG9zaXRlRWRnZVt6b25lRWRnZXNbem9uZV1dfS0ke3pvbmVFZGdlc1t6b25lXX1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb25zdHJhaW50IFJlY3RhbmdsZSBmb3IgZWFjaCB6b25lXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHpvbmVzVG9UcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjbG9uZSB0aGUgb3V0ZXIgY29uc3RyYWluaW5nIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIC8vIGFuZCBtb3ZlIGl0IGludG8gcG9zaXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBjID0gY29uc3RyYWluUmVjdC5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh6b25lc1RvVHJ5W2ldLnpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHpvbmUgaTIgYWJvdmUgdGhlIHRhcmdldCAtIHpvbmUgMC9UXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmJvdHRvbSA9IHRhcmdldFJlY3QueSAtIHRhcmdldE1hcmdpblswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgem9uZSBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIHRhcmdldCAtIHpvbmUgMS9SXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNoYW5nZVgodGFyZ2V0UmVjdC5yaWdodCArIHRhcmdldE1hcmdpblsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHpvbmUgaXMgYmVsb3cgdGhlIHRhcmdldCAtIHpvbmUgMi9CXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNoYW5nZVkodGFyZ2V0UmVjdC5ib3R0b20gKyB0YXJnZXRNYXJnaW5bMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB6b25lIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSB0YXJnZXQgLSB6b25lIDMvTFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5yaWdodCA9IHRhcmdldFJlY3QueCAtIHRhcmdldE1hcmdpblszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6b25lc1RvVHJ5W2ldLmNvbnN0cmFpblJlY3QgPSBjO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3cgdHJ5IHRvIGNvbnN0cmFpbiBvdXIgcmVzdWx0IGludG8gZWFjaCB6b25lJ3MgY29uc3RyYWludFpvbmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgem9uZXNUb1RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW5SZWN0XG4gICAgICAgICAgICAgICAgICAgIH0gICAgPSB6b25lc1RvVHJ5W2ldLFxuICAgICAgICAgICAgICAgICAgICBlZGdlID0gem9uZUVkZ2VzW3pvbmVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYWxpZ25pbmcgdG8gdGhlIHJlcXVlc3RlZCBlZGdlLCBvciBpdCdzIG9wcG9zaXRlIGVkZ2UgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCB0aGF0IGVkZ2Ugc2l6ZSwgZWxzZSByZXZlcnQgaXQgdG8gb3VyIG93biBzaXplXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFttYXRjaERpbWVuc2lvbl0gPSBlZGdlID09PSBlZGdlcy50aGVpckVkZ2UgfHwgZWRnZSA9PSBvcHBvc2l0ZUVkZ2VbZWRnZXMudGhlaXJFZGdlXSA/IHRhcmdldFJlY3RbbWF0Y2hEaW1lbnNpb25dIDogbWVbbWF0Y2hEaW1lbnNpb25dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIGEgc2ltcGxlIGFsaWduIHRvIHRoZSBjdXJyZW50IGVkZ2VcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWxpZ25Ubyh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA6IHRhcmdldFJlY3QsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc29sdXRpb24gPSByZXN1bHQuY29uc3RyYWluVG8oY29uc3RyYWluUmVjdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcyBzb29uIGFzIHdlIGZpbmQgYSB6b25lIGludG8gd2hpY2ggdGhlIHJlc3VsdCBpcyB3aWxsaW5nIHRvIGJlIGNvbnN0cmFpbmVkLiByZXR1cm4gaXRcbiAgICAgICAgICAgICAgICBpZiAoc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24uem9uZSA9IHpvbmU7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLnBvc2l0aW9uID0gem9uZU5hbWVzW3pvbmVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29sdXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSBjb25maWd1cmFibGUgZmluaXNoaW5nIHRvdWNoLlxuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXN1bHQubW92ZUJ5KG9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldEFuY2hvclBvaW50KGVkZ2Vab25lLCBlZGdlT2Zmc2V0LCBlZGdlVW5pdCwgbWFyZ2luID0gZW1wdHlBcnJheSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAvLyBFZGdlIHpvbmVzIGdvIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuICAgICAgICAvLyBFYWNoIG9uZSBjYWxjdWxhdGVzIHRoZSBzdGFydCBwb2ludCBvZiB0aGF0IGVkZ2UgdGhlbiBtb3ZlcyBhbG9uZyBpdCBieVxuICAgICAgICAvLyB0aGUgZWRnZU9mZnNldCwgdGhlbiBtb3ZlcyAqYXdheSogZnJvbSBpdCBieSB0aGUgbWFyZ2luIGZvciB0aGF0IGVkZ2UgaWYgdGhlcmUncyBhIG1hcmdpbi5cbiAgICAgICAgc3dpdGNoIChlZGdlWm9uZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFttZS54LCBtZS55IC0gKG1hcmdpblswXSB8fCAwKSwgbWUud2lkdGgsIDBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFttZS54ICsgbWUud2lkdGggKyAobWFyZ2luWzFdIHx8IDApLCBtZS55LCBtZS5oZWlnaHQsIDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFttZS54LCBtZS55ICsgbWUuaGVpZ2h0ICsgKG1hcmdpblsyXSB8fCAwKSwgbWUud2lkdGgsIDBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFttZS54IC0gKG1hcmdpblszXSB8fCAwKSwgbWUueSwgbWUuaGVpZ2h0LCAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzdWx0WzNdXSArPSBlZGdlVW5pdCA9PT0gJyUnID8gcmVzdWx0WzJdIC8gMTAwICogZWRnZU9mZnNldCA6IGVkZ2VPZmZzZXQ7XG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSAyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBET01SZWN0ICYmXG4gICAgICAgICAgICBvdGhlci54ID09PSB0aGlzLnggJiZcbiAgICAgICAgICAgIG90aGVyLnkgPT09IHRoaXMueSAmJlxuICAgICAgICAgICAgb3RoZXIuaGVpZ2h0ID09PSB0aGlzLmhlaWdodCAmJlxuICAgICAgICAgICAgb3RoZXIud2lkdGggPT09IHRoaXMud2lkdGg7XG4gICAgfVxuXG4gICAgLy8gRm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBvbmx5XG4gICAgc2hvdyhjb2xvciA9ICdyZWQnKSB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIGRpdi5zdHlsZSA9IGBcbiAgICAgICAgICAgIHBvc2l0aW9uOmFic29sdXRlO1xuICAgICAgICAgICAgdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKCR7dGhpcy54fXB4LCAke3RoaXMueX1weCwgMCk7XG4gICAgICAgICAgICBoZWlnaHQ6JHt0aGlzLmhlaWdodH1weDtcbiAgICAgICAgICAgIHdpZHRoOiR7dGhpcy53aWR0aH1weDtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6JHtjb2xvcn1cbiAgICAgICAgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGRpdi5yZW1vdmUoKSwgMzAwMDApO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgSlNPTi5zdHJpbmdpZnkodGhpcyksIHdlIHdhbnQgdG8gYWRkIG1pbkhlaWdodCAmIG1pbldpZHRoIHRvIHRoZSBvdXRwdXQuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHtib3R0b20sIGhlaWdodCwgbGVmdCwgbWluSGVpZ2h0LCBtaW5XaWR0aCwgcmlnaHQsIHRvcCwgd2lkdGgsIHgsIHl9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtib3R0b20sIGhlaWdodCwgbGVmdCwgbWluSGVpZ2h0LCBtaW5XaWR0aCwgcmlnaHQsIHRvcCwgd2lkdGgsIHgsIHl9XG4gICAgfVxufVxuIiwiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLlN0eWxlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFN0eWxlIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC5TdHlsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuU3R5bGUnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBkZWx0YSBvYmplY3QsIGNvbnRhaW5pbmcgdGhlIHN0eWxlcyBvZiBuZXdTdHlsZSB3aGljaCBhcmUgbm90IGluY2x1ZGVkIG9yIGRpZmZlcmVudCB0aGFuIGluIG9sZFN0eWxlXG4gICAgICogU3R5bGVzIGluY2x1ZGVkIGluIG9sZFN0eWxlIGJ1dCBtaXNzaW5nIGluIG5ld1N0eWxlIHdpbGwgZ2V0IGEgdmFsdWUgb2YgbnVsbFxuICAgICAqIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50L3N0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBuZXdTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb2xkU3R5bGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdHlsZSBkZWx0YVxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlU3R5bGVzKG5ld1N0eWxlLCBvbGRTdHlsZSkge1xuICAgICAgICBsZXQgc3R5bGVzID0ge307XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhuZXdTdHlsZSkpIHtcbiAgICAgICAgICAgIG5ld1N0eWxlID0gTmVvLmNyZWF0ZVN0eWxlT2JqZWN0KG5ld1N0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhvbGRTdHlsZSkpIHtcbiAgICAgICAgICAgIG9sZFN0eWxlID0gTmVvLmNyZWF0ZVN0eWxlT2JqZWN0KG9sZFN0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXdTdHlsZSAmJiAhb2xkU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAoIW9sZFN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gTmVvLmNsb25lKG5ld1N0eWxlKVxuICAgICAgICB9IGVsc2UgaWYgKCFuZXdTdHlsZSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMob2xkU3R5bGUpLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNbc3R5bGVdID0gbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXdTdHlsZSkuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkgfHwgb2xkU3R5bGVbc3R5bGVdICE9PSBuZXdTdHlsZVtzdHlsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IG5ld1N0eWxlW3N0eWxlXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvbGRTdHlsZSkuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlXSA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0eWxlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3R5bGUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9