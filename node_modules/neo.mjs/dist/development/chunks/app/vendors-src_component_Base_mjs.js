"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_component_Base_mjs"],{

/***/ "./src/component/Abstract.mjs"
/*!************************************!*\
  !*** ./src/component/Abstract.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _mixin_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mixin/DomEvents.mjs */ "./src/mixin/DomEvents.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _mixin_VdomLifecycle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mixin/VdomLifecycle.mjs */ "./src/mixin/VdomLifecycle.mjs");
/* harmony import */ var _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../manager/VDomUpdate.mjs */ "./src/manager/VDomUpdate.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");









const
    closestController   = Symbol.for('closestController'),
    closestProvider     = Symbol.for('closestProvider'),
    twoWayBindingSymbol = Symbol.for('twoWayBinding');

/**
 * @class Neo.component.Abstract
 * @extends Neo.core.Base
 * @mixes Neo.component.mixin.DomEvents
 * @mixes Neo.core.Observable
 * @mixes Neo.component.mixin.VdomLifecycle
 */
class Abstract extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Abstract'
         * @protected
         */
        className: 'Neo.component.Abstract',
        /**
         * @member {String} ntype='abstract-component'
         * @protected
         */
        ntype: 'abstract-component',
        /**
         * Additional namespaces to load theme files for.
         * @member {String[]|null} additionalThemeFiles=null
         * @example ['AgentOSStrategy.view.Viewport']
         */
        additionalThemeFiles: null,
        /**
         * The name of the App this component belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * Bind configs to state.Provider data properties.
         * @member {Object|null} bind=null
         */
        bind: null,
        /**
         * Custom CSS selectors to apply to the root level node of this component
         * @member {String[]} cls_=null
         * @reactive
         */
        cls_: null,
        /**
         * Convenience shortcut to access the data config of the closest state.Provider.
         * Read only.
         * @member {Object} data_=null
         * @protected
         * @reactive
         */
        data_: null,
        /**
         * Disabled components will get the neo-disabled cls applied and won't receive DOM events
         * @member {Boolean} disabled_=false
         * @reactive
         */
        disabled_: false,
        /**
         * @member {Neo.core.Base[]} mixins=[DomEvents, Observable, VdomLifecycle]
         */
        mixins: [_mixin_DomEvents_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], _mixin_VdomLifecycle_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]],
        /**
         * Override specific stateProvider data properties.
         * This will merge the content.
         * @member {Object|null} modelData=null
         */
        modelData: null,
        /**
         * True after the component initVnode() method was called. Also fires the rendered event.
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * If the parentId does not match a neo component id, you can manually set this value for finding
         * view controllers or state providers.
         * Use case: manually dropping components into a vdom structure
         * @member {Neo.component.Base|null} parentComponent_=null
         * @protected
         * @reactive
         */
        parentComponent_: null,
        /**
         * The parent component id or document.body
         * @member {String} parentId_='document.body'
         * @reactive
         */
        parentId_: 'document.body',
        /**
         * @member {Boolean} saveScrollPosition=true
         */
        saveScrollPosition: true,
        /**
         * Optionally add a state.Provider to share state data with child components
         * @member {Object|null} stateProvider_=null
         * @reactive
         */
        stateProvider_: null,
        /**
         * The custom windowIs (timestamp) this component belongs to
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * Internal flag which will get set to true while a component is waiting for its mountedPromise
     * @member {Boolean} isAwaitingMount=false
     * @protected
     */
    isAwaitingMount = false

    /**
     * Convenience shortcut to access the App this component belongs to
     * @returns {Neo.controller.Application|null}
     */
    get app() {
        // We need Neo.appsByName as a fallback for Playwright-based unit testing
        return Neo.apps[this.windowId] || Neo.appsByName[this.appName]?.[0] || null
    }

    /**
     * A Promise that resolves when the component is mounted to the DOM.
     * This provides a convenient way to wait for the component to be fully
     * available and interactive before executing subsequent logic.
     *
     * It also handles unmounting by resetting the promise, so it can be safely
     * awaited again if the component is remounted.
     * @returns {Promise<Neo.component.Base>}
     */
    get mountedPromise() {
        let me = this;

        if (!me._mountedPromise) {
            me._mountedPromise = new Promise(resolve => {
                if (me.mounted) {
                    resolve(me);
                } else {
                    me.mountedPromiseResolve = resolve
                }
            })
        }

        return me._mountedPromise
    }

    /**
     * Convenience method to access the parent component
     * @returns {Neo.component.Base|null}
     */
    get parent() {
        let me = this;

        return me.parentComponent || (me.parentId === 'document.body' ? null : Neo.getComponent(me.parentId))
    }

    /**
     * Triggered after any config got changed
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     * @protected
     */
    afterSetConfig(key, value, oldValue) {
        let me = this;

        if (Neo.isUsingStateProviders && me[twoWayBindingSymbol]) {
            // When a component config is updated by its state provider, this flag is set to the config's key.
            // This prevents circular updates in two-way data bindings by skipping the push back to the state provider.
            if (me._skipTwoWayPush === key) {
                return;
            }
            let binding = me.bind?.[key];

            if (binding?.twoWay) {
                this.getStateProvider()?.setData(binding.key, value)
            }
        }
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);

        oldValue && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(oldValue);
        value    && _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].register(this)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        if (oldValue !== undefined) {
            const me = this;

            if (value) { // mount
                me.initDomEvents?.();
                me.mountedPromiseResolve?.(this);
                delete me.mountedPromiseResolve;

                // When a component becomes mounted, it might have pending VDOM update promises
                // (e.g. from a set() call that was deferred because the component wasn't mounted yet).
                // If the mount happened because a Parent component updated (implicitly covering this component),
                // this component's own pending update cycle might be skipped or not yet triggered.
                // We explicitly execute the callbacks here to ensure those pending promises are resolved immediately
                // upon mount, preventing deadlocks where code awaits a VDOM update that effectively already happened.
                _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].executeCallbacks(me.id)
            } else { // unmount
                delete me._mountedPromise
            }
        }
    }

    /**
     * Triggered after the stateProvider config got changed
     * @param {Neo.state.Provider} value
     * @param {Object|Neo.state.Provider|null} oldValue
     * @protected
     */
    afterSetStateProvider(value, oldValue) {
        value?.createBindings(this)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        const me = this;

        if (value) {
            me.controller    && (me.controller.windowId    = value);
            me.stateProvider && (me.stateProvider.windowId = value);

            Neo.currentWorker.insertThemeFiles(value, me.__proto__)
        }

        // If a component gets moved into a different window, an update cycle might still be running.
        // Since the update might no longer get mapped, we want to re-enable this instance for future updates.
        if (oldValue) {
            me.isVdomUpdating = false
        }
    }

    /**
     * Triggered when accessing the data config
     * Convenience shortcut which is expensive to use, since it will generate a merged parent state providers data map.
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getStateProvider()?.getHierarchyData()
    }

    /**
     * Triggered before the stateProvider config gets changed.
     * Creates a state.Provider instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.state.Provider}
     * @protected
     */
    beforeSetStateProvider(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            let me            = this,
                defaultValues = {component: me, windowId: me.windowId};

            if (me.modelData) {
                defaultValues.data = me.modelData
            }

            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, 'Neo.state.Provider', defaultValues)
        }

        return null
    }

    /**
     *
     */
    destroy() {
        this.removeDomEvents();
        _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].unregister(this);
        this.stateProvider = null; // triggers destroy()
        super.destroy()
    }

    /**
     * Find an instance stored inside a config via optionally passing a ntype.
     * Returns this[configName] or the closest parent component with a match.
     * Used by getController() & getStateProvider()
     * @param {String} configName
     * @param {String} [ntype]
     * @returns {Neo.core.Base|null}
     */
    getConfigInstanceByNtype(configName, ntype) {
        let me                = this,
            config            = me[configName],
            {parentComponent} = me;

        if (config && (!ntype || ntype === config.ntype)) {
            return config
        }

        if (!parentComponent && me.parentId) {
            parentComponent = me.parent || Neo.get(me.parentId);
        }

        if (parentComponent) {
            // todo: We need ?. until functional.component.Base supports controllers
            return parentComponent.getConfigInstanceByNtype?.(configName, ntype)
        }

        return null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * Returns this.stateProvider or the closest parent stateProvider
     * @param {String} [ntype]
     * @returns {Neo.state.Provider|null}
     */
    getStateProvider(ntype) {
        if (!Neo.isUsingStateProviders) {
            return null
        }

        let me = this,
            provider;

        if (!ntype) {
            provider = me[closestProvider];

            if (provider) {
                return provider
            }
        }

        provider = me.getConfigInstanceByNtype('stateProvider', ntype);

        if (!ntype) {
            me[closestProvider] = provider
        }

        return provider
    }

    /**
     * @param args
     */
    initConfig(...args) {
        super.initConfig(...args);
        this.getStateProvider()?.createBindings(this)
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        let me    = this,
            vnode;

        if (me.vnode) {
            vnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].getById(me.vnode, data.target.id);

            if (vnode) {
                // Directly updating the persistent vnode state (plain object).
                // This does not trigger a VDOM update, but ensures the state is preserved
                // for future re-renders (e.g. unmount/remount).
                vnode.scrollTop  = data.scrollTop;
                vnode.scrollLeft = data.scrollLeft
            }
        }
    }

    /**
     * Change multiple configs at once, ensuring that all afterSet methods get all new assigned values
     * @param {Object} values={}
     * @param {Boolean} silent=false
     * @returns {Promise<*>}
     */
    set(values={}, silent=false) {
        const
            me        = this,
            wasHidden = me.hidden;

        me.setSilent(values);

        if (!silent && me.needsVdomUpdate) {
            if (wasHidden && !me.hidden) {
                me.show?.(); // show() is not part of the abstract base class
                return Promise.resolve()
            }

            return me.promiseUpdate()
        }

        return Promise.resolve()
    }

    /**
     * A silent version of set(), which does not trigger a vdom update at the end.
     * Useful for batching multiple config changes.
     * @param {Object} values={}
     */
    setSilent(values={}) {
        this.silentVdomUpdate = true;
        super.set(values);
        this.silentVdomUpdate = false
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Abstract));


/***/ },

/***/ "./src/component/Base.mjs"
/*!********************************!*\
  !*** ./src/component/Base.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Abstract.mjs */ "./src/component/Abstract.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/KeyNavigation.mjs */ "./src/util/KeyNavigation.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Rectangle.mjs */ "./src/util/Rectangle.mjs");
/* harmony import */ var _util_Style_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Style.mjs */ "./src/util/Style.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");












const
    addUnits          = value => value == null ? value : isNaN(value) ? value : `${value}px`,
    closestController = Symbol.for('closestController'),
    lengthRE          = /^\d+\w+$/;

/**
 * Base class for all Components which have a DOM representation
 * @class Neo.component.Base
 * @extends Neo.component.Abstract
 */
class Component extends _Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Valid values for hideMode
     * @member {String[]} hideModes=['removeDom','visibility']
     * @protected
     * @static
     */
    static hideModes = ['removeDom', 'visibility']

    static config = {
        /**
         * @member {String} className='Neo.component.Base'
         * @protected
         */
        className: 'Neo.component.Base',
        /**
         * @member {String} ntype='component'
         * @protected
         */
        ntype: 'component',
        /**
         * The default alignment specification to position this Component relative to some other
         * Component, or Element or Rectangle. Only applies in case floating = true.
         * @member {Object|String} align_={[isDescriptor]: true, merge: 'deep', value: {edgeAlign: 't-b',constrainTo: 'document.body'}}
         * @reactive
         */
        align_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'deep',
            value: {
                edgeAlign  : 't-b',
                constrainTo: 'document.body'
            }
        },
        /**
         * CSS selectors to apply to the root level node of this component
         * @member {String[]} baseCls=[]
         */
        baseCls: [],
        /**
         * manager.Focus will change this flag on focusin & out dom events
         * @member {Boolean} containsFocus_=false
         * @protected
         * @reactive
         */
        containsFocus_: false,
        /**
         * Assign a component controller to this component (pass an imported module or the string based class name)
         * @member {Neo.controller.Component|String} controller_=null
         * @reactive
         */
        controller_: null,
        /**
         * Set this config to true to dynamically import a DropZone module & create an instance
         * @member {Boolean} droppable_=false
         * @reactive
         */
        droppable_: false,
        /**
         * @member {Neo.draggable.DropZone|null} dropZone=null
         */
        dropZone: null,
        /**
         * @member {Object} dropZoneConfig=null
         */
        dropZoneConfig: null,
        /**
         * True to mount this component into the viewport outside of the document flow
         * @member {Boolean} floating
         */
        floating: false,
        /**
         * Internal flag which will get set to true on mount
         * @member {Boolean} hasBeenMounted=false
         * @protected
         */
        hasBeenMounted: false,
        /**
         * Shortcut for style.height, defaults to px
         * @member {Number|String|null} height_=null
         * @reactive
         */
        height_: null,
        /**
         * Initial setting to hide or show the component and
         * you can use either hide()/show() or change this config directly to change the hidden state
         * @member {Boolean} hidden_=false
         * @reactive
         */
        hidden_: false,
        /**
         * Used for hide and show and defines if the component
         * should use css visibility:'hidden' or vdom:removeDom
         * @member {String} hideMode_='removeDom'
         * @reactive
         */
        hideMode_: 'removeDom',
        /**
         * The top level innerHTML of the component
         * @member {String|null} html_=null
         * @reactive
         */
        html_: null,
        /**
         * Set to `true` to show a spinner centered in the component.
         * Set to a string to show a message next to a spinner centered in the component.
         * @member {Boolean|String} isLoading=false
         */
        isLoading_: false,
        /**
         * Using the keys config will create an instance of Neo.util.KeyNavigation.
         * @see {@link Neo.util.KeyNavigation KeyNavigation}
         * @member {Object} keys_=null
         * @reactive
         */
        keys_: null,
        /**
         * Gets used inside afterSetIsLoading() to define the CSS for the loading spinner icon
         * @member {String[]} loadingSpinnerCls_=['fa','fa-spinner','fa-spin']
         * @reactive
         */
        loadingSpinnerCls_: ['fa', 'fa-spinner', 'fa-spin'],
        /**
         * Shortcut for style.maxHeight, defaults to px
         * @member {Number|String|null} maxHeight_=null
         * @reactive
         */
        maxHeight_: null,
        /**
         * Shortcut for style.maxWidth, defaults to px
         * @member {Number|String|null} maxWidth_=null
         * @reactive
         */
        maxWidth_: null,
        /**
         * Shortcut for style.minHeight, defaults to px
         * @member {Number|String|null} minHeight_=null
         * @reactive
         */
        minHeight_: null,
        /**
         * Shortcut for style.minWidth, defaults to px
         * @member {Number|String|null} minWidth_=null
         * @reactive
         */
        minWidth_: null,
        /**
         * Array of Plugin Modules and / or config objects
         * @member {Array|null} plugins_=null
         * @protected
         * @reactive
         */
        plugins_: null,
        /**
         * Set a reference for accessing the component inside view controllers.
         * References will also get mapped into the vdom root (data-ref: value).
         * @member {String|null} reference_=null
         * @protected
         * @reactive
         */
        reference_: null,
        /**
         * Make the view Responsive by adding alternative configs.
         * The definition happens via responsiveCfg
         * @member {Object} responsive=null
         * @protected
         */
        responsive_: null,
        /**
         * Specify a role tag attribute for the vdom root.
         * See: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles
         * @member {String|null} role_=null
         * @reactive
         */
        role_: null,
        /**
         * Set this to true for style 'overflow:auto'.
         * Set this to 'x' or 'y' to add style 'overflow-x' or 'overflow-y' to 'auto'
         * Other than false this will add cls 'neo-scrollable'.
         * @member {Boolean|"x"|"y"} scrollable_=false
         * @reactive
         */
        scrollable_: false,
        /**
         * Style attributes added to this vdom root. see: getVdomRoot()
         * @member {Object} style={[isDescriptor]: true, merge: 'shallow', value: null}
         */
        style_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'shallow',
            value         : null
        },
        /**
         * You can pass a used theme directly to any component,
         * to style specific component trees differently from your main view.
         * @member {String|null} theme_=null
         * @reactive
         */
        theme_: null,
        /**
         * While it is recommended to define tags inside the vdom of classes,
         * this shortcut enables us to change the vdom root tag on instance level.
         * Use cases: switch a Toolbar to a "nav" tag, switch a SideNav to an "aside" tag.
         * @member {String|null} tag_=null
         * @reactive
         */
        tag_: null,
        /**
         * The top level textContent of the component
         * @member {String|null} text_=null
         * @reactive
         */
        text_: null,
        /**
         * Add tooltip config object or a string containing the display text
         * See tooltip/Base.mjs
         *
         * By default, a single, shared Tooltip instance is used for all widgets that request
         * a tooltip. It reconfigures itself from the widget's definition just before showing.
         *
         * If a widget needs its own instance for any reason, include the property `ownInstance: true`
         * in the tooltip config object.
         * @member {Object|String} tooltip_=null
         * @reactive
         */
        tooltip_: null,
        /**
         * Add 'primary' and other attributes to make it an outstanding design
         * @member {String|null} ui_=null
         * @reactive
         */
        ui_: null,
        /**
         * Shortcut for style.width, defaults to px
         * @member {Number|String|null} width_=null
         * @reactive
         */
        width_: null,
        /**
         * @member {String[]|null} wrapperCls_=null
         * @reactive
         */
        wrapperCls_: null,
        /**
         * Top level style attributes. Useful in case getVdomRoot() does not point to the top level DOM node.
         * @member {Object|null} wrapperStyle_={[isDescriptor]: true, merge: 'shallow', value: null}
         * @reactive
         */
        wrapperStyle_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_10__.isDescriptor]: true,
            merge         : 'shallow',
            value         : null
        },
        /**
         * The vdom markup for this component.
         * @member {Object} _vdom={}
         */
        _vdom: {}
    }

    /**
     * Returns true if this Component is fully visible, that is it is not hidden and has no hidden ancestors
     */
    get isVisible() {
        return this.mounted && !this.hidden && (!this.parent || this.parent.isVisible);
    }

    /**
     * The setter will handle vdom updates automatically
     * @member {Object} vdom=this._vdom
     */
    get vdom() {
        return this._vdom
    }
    set vdom(value) {
        this.afterSetVdom(value, value)
    }

    /**
     * Add a new cls to the vdomRoot
     * @param {String} value
     */
    addCls(value) {
        let {cls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);
        this.cls = cls
    }

    /**
     * Either a string like 'color: red; background-color: blue;'
     * or an object containing style attributes
     * @param {String|Object} value
     * @returns {Object} all styles of this.el
     */
    addStyle(value) {
        if (Neo.isString(value)) {
            value =  Neo.createStyleObject(value)
        }

        // todo: add a check if something has changed

        return this.style = Object.assign(this.style, value)
    }

    /**
     * Add a new wrapperCls to the top level node
     * @param {String} value
     */
    addWrapperCls(value) {
        let {wrapperCls} = this;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(wrapperCls, value);
        this.wrapperCls = wrapperCls
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {

    }

    /**
     * Triggered after the cls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetCls(value, oldValue) {
        oldValue = oldValue || [];

        let me       = this,
            vdom     = me.vdom,
            vdomRoot = me.getVdomRoot(),
            cls;

        if (vdom !== vdomRoot) {
            // we are using a wrapper node
            vdomRoot.cls = [...value]
        } else {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(me.wrapperCls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].difference(oldValue, value));
            vdom.cls = cls
        }

        me.update()
    }

    /**
     * Triggered after the disabled config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisabled(value, oldValue) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"][value ? 'add' : 'remove'](cls, 'neo-disabled');
        this.cls = cls
    }



    /**
     * Triggered after the droppable config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDroppable(value, oldValue) {
        let me = this;

        if (value && !me.dropZone) {
            __webpack_require__.e(/*! import() */ "src_draggable_DropZone_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../draggable/DropZone.mjs */ "./src/draggable/DropZone.mjs")).then(module => {
                me.dropZone = Neo.create({
                    module  : module.default,
                    appName : me.appName,
                    owner   : me,
                    windowId: me.windowId,
                    ...me.dropZoneConfig
                })
            })
        }
    }

    /**
     * Triggered after the height config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetHeight(value, oldValue) {
        this.configuredHeight = addUnits(value);
        this.changeVdomRootKey('height', value)
    }

    /**
     * Triggered after the hidden config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetHidden(value, oldValue) {
        let me    = this,
            state = value ? 'hide' : 'show';

        if (value && oldValue === undefined && me.hideMode === 'removeDom') {
            me.vdom.removeDom = true
        } else if (value || oldValue !== undefined) {
            me[state]()
        }

        if (!value) {
            me.revertFocus();
        }

        me.fire(state, {id: me.id});
        me.fire('hiddenChange', {id: me.id, oldValue, value})
    }

    /**
     * Triggered after the html config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetHtml(value, oldValue) {
        this.changeVdomRootKey('html', value)
    }

    /**
     * Triggered after the id config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetId(value, oldValue) {
        super.afterSetId(value, oldValue);
        this.changeVdomRootKey('id', value)
    }

    /**
     * Triggered after the isLoading config got changed
     * @param {Boolean|String} value
     * @param {Boolean|String} oldValue
     * @protected
     */
    afterSetIsLoading(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me                 = this,
                {wrapperCls, vdom} = me,
                maskIndex;

            if (oldValue !== undefined && vdom.cn) {
                maskIndex = vdom.cn.findLastIndex(c => c.cls?.includes('neo-load-mask'));

                // Remove the load mask
                if (maskIndex !== -1) {
                    vdom.cn.splice(maskIndex, 1)
                }
            }

            if (value) {
                if (!vdom.cn) {
                    vdom.cn = []
                }

                vdom.cn.push(me.createLoadingMask(value))
            }

            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].toggle(wrapperCls, 'neo-masked', value);
            me.set({vdom, wrapperCls})
        }
    }

    /**
     * Triggered after the maxHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxHeight(value, oldValue) {
        this.configuredMaxHeight = addUnits(value);
        this.changeVdomRootKey('maxHeight', value)
    }

    /**
     * Triggered after the maxWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMaxWidth(value, oldValue) {
        this.configuredMaxWidth = addUnits(value);
        this.changeVdomRootKey('maxWidth', value)
    }

    /**
     * Triggered after the minHeight config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinHeight(value, oldValue) {
        this.configuredMinHeight = addUnits(value);
        this.changeVdomRootKey('minHeight', value)
    }

    /**
     * Triggered after the minWidth config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetMinWidth(value, oldValue) {
        this.configuredMinWidth = addUnits(value);
        this.changeVdomRootKey('minWidth', value)
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (oldValue !== undefined) {
            let me = this;

            if (value) { // mount
                me.hasBeenMounted = true;

                if (me.floating) {
                    me.alignTo();

                    // Focus will be pushed into the first input field or other focusable item
                    me.focus(me.id, true)
                }

                me.fire('mounted', me.id);
            } else { // unmount
                me.revertFocus()
            }
        }
    }

    /**
     * Triggered after the reference config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetReference(value, oldValue) {
        value && this.changeVdomRootKey('data-ref', value)
    }

    /**
     * Triggered after the responsive config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    async afterSetResponsive(value, oldValue) {
        if (value && !this.getPlugin('responsive')) {
            let me      = this,
                module  = await __webpack_require__.e(/*! import() */ "src_plugin_Responsive_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../../src/plugin/Responsive.mjs */ "./src/plugin/Responsive.mjs")),
                plugins = me.plugins || [];

            plugins.push({
                module : module.default,
                appName: me.appName,
                value
            });

            me.plugins = plugins
        }
    }

    /**
     * Triggered after the role config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetRole(value, oldValue) {
        this.changeVdomRootKey('role', value)
    }

    /**
     * Triggered after the scrollable config got changed
     * @param {String|Boolean} value
     * @param {String|Boolean|null} oldValue
     * @protected
     */
    afterSetScrollable(value, oldValue) {
        if (oldValue === undefined && !value) {
            return
        }

        let me = this;

        if (oldValue) {
            let oldOverflowKey = 'overflow';

            if (!Neo.isBoolean(oldValue)) {
                oldOverflowKey += Neo.capitalize(oldValue)
            }

            me.removeStyle([oldOverflowKey])
        }

        if (!Neo.isEmpty(value)) {
            let overflowKey = 'overflow';

            if (value && !Neo.isBoolean(value)) {
                overflowKey += Neo.capitalize(value)
            }

            if (value) {
                me.addStyle(overflowKey + ':auto');
                me.addCls('neo-scrollable')
            } else {
                me.removeCls('neo-scrollable')
            }
        }
    }

    /**
     * Triggered after the style config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle()
        }
    }

    /**
     * Triggered after the tag config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTag(value, oldValue) {
        value && this.changeVdomRootKey('tag', value)
    }

    /**
     * Triggered after the theme config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        if (value || oldValue !== undefined) {
            let me          = this,
                {cls}       = me,
                needsUpdate = false;

            if (oldValue && cls.includes(oldValue)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, oldValue);
                needsUpdate = true
            }

            // We do not need to add a DOM based CSS selector, in case the theme is already inherited
            if (value !== me.parent?.theme) {
                value && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);
                needsUpdate = true
            }

            if (needsUpdate) {
                me.cls = cls
            }
        }
    }

    /**
     * Triggered after the text config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetText(value, oldValue) {
        this.changeVdomRootKey('text', value)
    }

    /**
     * Triggered after the tooltip config got changed
     * @param {Object|String} value
     * @param {Object|String} oldValue
     * @protected
     */
    afterSetTooltip(value, oldValue) {
        oldValue?.destroy?.();

        if (value) {
            if (Neo.ns('Neo.tooltip.Base')) {
                this.createTooltip(value)
            } else {
                Promise.all(/*! import() */[__webpack_require__.e("vendors-src_container_Base_mjs"), __webpack_require__.e("vendors-src_tooltip_Base_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../tooltip/Base.mjs */ "./src/tooltip/Base.mjs")).then(() => {
                    this.createTooltip(value)
                })
            }
        }
    }

    /**
     * For styling purposes only.
     * To define button styles or component styles,
     * this will add a css class: neo-ntype-value
     * @param {String|null} value
     * @param {String|null} oldValue
     */
    afterSetUi(value, oldValue) {
        let me  = this,
            cls = me.cls;

        if (oldValue) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, `neo-${me.ntype}-${oldValue}`)
        }

        if (value && value !== '') {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, `neo-${me.ntype}-${value}`)
        }

        me.cls = cls
    }

    /**
     * Triggered after the width config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @protected
     */
    afterSetWidth(value, oldValue) {
        this.configuredWidth = addUnits(value);
        this.changeVdomRootKey('width', value)
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        let controller = this.controller;

        if (controller) {
            controller.windowId = value
        }
    }

    /**
     * Triggered after the wrapperCls config got changed
     * @param {String[]|null} value
     * @param {String[]|null} oldValue
     * @protected
     */
    afterSetWrapperCls(value, oldValue) {
        oldValue = oldValue || [];
        value    = value    || [];

        let me       = this,
            {vdom}   = me,
            vdomRoot = me.getVdomRoot(),
            cls      = vdom.cls || [];

        if (vdom === vdomRoot) {
            // we need to merge changes
            cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(cls, value);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].difference(oldValue, value));
            vdom.cls = cls
        } else {
            // we are not using a wrapper => cls & wrapperCls share the same node
            value = value ? value : [];

            oldValue && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, oldValue);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].add(cls, value);

            vdom.cls = cls
        }

        me.update()
    }

    /**
     * Triggered after the wrapperStyle config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetWrapperStyle(value, oldValue) {
        if (!(!value && oldValue === undefined)) {
            this.updateStyle()
        }
    }

    /**
     * Aligns the top level node inside the main thread
     * @param {Object} spec={}
     * @returns {Promise<void>}
     */
    async alignTo(spec={}) {
        const
            me    = this,
            align = {
                ...me.align,
                ...spec,
                id                 : me.id,
                configuredFlex     : me.configuredFlex,
                configuredWidth    : me.configuredWidth,
                configuredHeight   : me.configuredHeight,
                configuredMinWidth : me.configuredMinWidth,
                configuredMinHeight: me.configuredMinHeight,
                configuredMaxWidth : me.configuredMaxWidth,
                configuredMaxHeight: me.configuredMaxHeight,
                windowId           : me.windowId
            };

        if (align.target) {
            await Neo.main.DomAccess.align(align)
        }
    }

    /**
     * Triggered when accessing the cls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the style config
     * @param {Object} value
     * @protected
     */
    beforeGetStyle(value) {
        return {...value}
    }

    /**
     * Triggered when accessing the wrapperCls config
     * @param {String[]|null} value
     * @protected
     */
    beforeGetWrapperCls(value) {
        return value ? [...value] : []
    }

    /**
     * Triggered when accessing the wrapperStyle config
     * @param {Object} value
     * @protected
     */
    beforeGetWrapperStyle(value) {
        return {...Object.assign(this.vdom.style || {}, value)}
    }

    /**
     * Triggered before the align config gets changed.
     * @param {Object|String} value
     * @param {Object} oldValue
     * @returns {Object}
     * @protected
     */
    beforeSetAlign(value, oldValue) {
        let me = this;

        // Just a simple 't-b'
        if (typeof value === 'string') {
            value = {
                edgeAlign: value
            }
        }

        return value
    }

    /**
     * Triggered before the cls config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetCls(value, oldValue) {
        return _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].union(value || [], this.baseCls, this.getBaseClass());
    }

    /**
     * Triggered before the controller config gets changed.
     * Creates a controller.Component instance if needed.
     * @param {Neo.controller.Component|Object} value
     * @param {Neo.controller.Component|null} oldValue
     * @returns {Neo.controller.Component}
     * @protected
     */
    beforeSetController(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, 'Neo.controller.Component', {
                component: this,
                windowId : this.windowId
            })
        }

        return value
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Triggered before the hideMode config gets changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {String}
     * @protected
     */
    beforeSetHideMode(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'hideMode')
    }

    /**
     * Triggered before the keys config gets changed.
     * Creates a KeyNavigation instance if needed.
     * @param {Object} value
     * @param {Object} oldValue
     * @returns {Neo.util.KeyNavigation|null}
     * @protected
     */
    beforeSetKeys(value, oldValue) {
        oldValue?.destroy();

        if (value) {
            value = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _util_KeyNavigation_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], {
                keyDownEventBubble: true,
                keys              : value
            })
        }

        return value
    }

    /**
     * Triggered before the plugins config gets changed.
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @returns {Neo.plugin.Base[]}
     * @protected
     */
    beforeSetPlugins(value, oldValue) {
        if (Array.isArray(value)) {
            value.forEach((item, index) => {
                value[index] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(item, null, {
                    owner: this
                })
            })
        }

        return value
    }

    /**
     * Triggered before the silentVdomUpdate config gets changed.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetSilentVdomUpdate(value, oldValue) {
        if (value === true) {
            return Neo.isNumber(oldValue) ? (oldValue + 1) : 1
        }

        return (Neo.isNumber(oldValue) && oldValue > 0) ? (oldValue - 1) : 0
    }

    /**
     * Triggered before the updateDepth config gets changed.
     * @param {Number} value
     * @param {Number} oldValue
     * @returns {Number}
     * @protected
     */
    beforeSetUpdateDepth(value, oldValue) {
        if (oldValue === undefined) {
            return value
        }

        return oldValue === -1 || value === -1 ? -1 : Math.max(value, oldValue)
    }

    /**
     * Changes the value of a vdom object attribute or removes it in case it has no value
     * @param {String} key
     * @param {Array|Number|Object|String|null} value
     */
    changeVdomRootKey(key, value) {
        let me   = this,
            root = me.getVdomRoot();

        if (value) {
            root[key] = value
        } else {
            delete root[key]
        }

        me.update()
    }

    /**
     * Override this method in case you need different mask markups.
     * The removal logic relies on the top level node having the cls 'neo-load-mask'
     * @param {Boolean|String} loadingMessage
     * @returns {Object} vdom
     */
    createLoadingMask(loadingMessage) {
        return {
            cls: ['neo-load-mask'],
            cn : [{
                cls: ['neo-load-mask-body'],
                cn : [{
                    cls: this.loadingSpinnerCls
                }, {
                    cls      : ['neo-loading-message'],
                    removeDom: !Neo.isString(loadingMessage),
                    text     : loadingMessage
                }]
            }]
        }
    }

    /**
     * Creates the tooltip instances
     * @param {Object|String} value
     * @protected
     */
    createTooltip(value) {
        if (typeof value === 'string') {
            value = {
                text: value
            }
        }

        let me = this;

        if (value.ownInstance) {
            me._tooltip = Neo.create('Neo.tooltip.Base', {
                ...value,
                appName    : me.appName,
                componentId: me.id,
                windowId   : me.windowId
            })
        } else {
            me._tooltip = value;
            Neo.tooltip.Base.createSingleton(me.app);
            me.addCls('neo-uses-shared-tooltip');
            me.update()
        }
    }

    /**
     * Unregister this instance from the ComponentManager
     * @param {Boolean} updateParentVdom=false true to remove the component from the parent vdom => real dom
     * @param {Boolean} silent=false true to update the vdom silently (useful for destroying multiple child items in a row)
     * todo: unregister events
     */
    destroy(updateParentVdom=false, silent=false) {
        let me                 = this,
            {parent, parentId} = me,
            parentVdom;

        me.revertFocus();

        me.controller = null; // triggers destroy()

        me.reference && me.getController()?.removeReference(me); // remove own reference from parent controllers

        me.plugins?.forEach(plugin => {
            plugin.destroy()
        });

        if (updateParentVdom && parentId) {
            if (parentId === 'document.body') {
                Neo.applyDeltas(me.windowId, {action: 'removeNode', id: me.vdom.id})
            } else {
                parentVdom = parent.vdom;

                _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].removeVdomChild(parentVdom, me.vdom.id);
                parent[silent ? '_vdom' : 'vdom'] = parentVdom
            }
        }

        super.destroy();

        // We do want to prevent delayed calls after a component instance got destroyed.
        me.onFocusLeave = Neo.emptyFn;
        me.unmount      = Neo.emptyFn
    }

    /**
     * Convenience shortcut for Neo.manager.Component.down
     * @param {Object|String} config
     * @param {Boolean} returnFirstMatch=true
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    down(config, returnFirstMatch=true) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].down(this, config, returnFirstMatch)
    }

    /**
     * Calls focus() on the top level DOM node of this component or on a given node via id
     * @param {String} id=this.id
     * @param {Boolean} children=false
     */
    focus(id=this.id, children=false) {
        Neo.main.DomAccess.focus({children, id, windowId: this.windowId})
    }

    /**
     * Override this method to add dynamic values into this.cls
     * @returns {String[]}
     */
    getBaseClass() {
        const result = [];

        if (this.floating) {
            result.push('neo-floating')
        }

        return result
    }

    /**
     * Returns this.controller or the closest parent controller
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        let me = this,
            controller;

        if (!ntype) {
            controller = me[closestController];

            if (controller) {
                return controller
            }
        }

        controller = me.getConfigInstanceByNtype('controller', ntype);

        if (!ntype) {
            me[closestController] = controller
        }

        return controller
    }

    /**
     * Convenience shortcut
     * @param {String[]|String} id=this.id
     * @param {String} windowId=this.windowId
     * @returns {Promise<Neo.util.Rectangle|Neo.util.Rectangle[]>}
     */
    async getDomRect(id=this.id, windowId=this.windowId) {
        let result = await Neo.main.DomAccess.getBoundingClientRect({id, windowId});

        if (Array.isArray(result)) {
            return result.map(rect => _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].clone(rect))
        }

        return _util_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].clone(result)
    }

    /**
     * Get the parent components as an array
     * @returns {Neo.component.Base[]}
     */
    getParents() {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParents(this)
    }

    /**
     * @param {Object|String} opts
     * @returns {Neo.plugin.Base|null}
     */
    getPlugin(opts) {
        if (Neo.isString(opts)) {
            if (!opts.startsWith('plugin-')) {
                opts = 'plugin-' + opts
            }

            opts = {ntype: opts}
        }

        let me = this,
            hasMatch;

        for (const plugin of me.plugins || []) {
            hasMatch = true;

            for (const key in opts) {
                if (plugin[key] !== opts[key]) {
                    hasMatch = false;
                    break
                }
            }

            if (hasMatch) {
                return plugin
            }
        }

        return null
    }

    /**
     * convenience shortcut
     * @param {String} value
     * @returns {Neo.component.Base|null}
     */
    getReference(value) {
        return this.down({reference: value})
    }

    /**
     * Walks up the vdom tree and returns the closest theme found
     * @returns {String}
     */
    getTheme() {
        let me         = this,
            themeMatch = 'neo-theme-',
            mainView, parentNodes;

        for (const item of me.cls || []) {
            if (item.startsWith(themeMatch)) {
                return item
            }
        }

        mainView = me.app?.mainView;

        if (mainView) {
            parentNodes = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].getParentNodes(mainView.vdom, me.id);

            for (const node of parentNodes || []) {
                for (const item of node.cls || []) {
                    if (item.startsWith(themeMatch)) {
                        return item
                    }
                }
            }
        }

        return Neo.config.themes?.[0]
    }

    /**
     * Hide the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     * If hideMode === 'removeDom' you can pass a timeout for custom css class hiding.
     * @param {Number} timeout
     */
    hide(timeout) {
        let me = this;

        if (me.hideMode !== 'visibility') {
            let removeFn = function () {
                if (me.parentId !== 'document.body') {
                    me.vdom.removeDom = true;
                    me.parent.updateDepth = 2;
                    me.parent.update()
                } else {
                    me.unmount()
                }
            }

            if (timeout) {
                me.timeout(timeout).then(removeFn)
            } else {
                removeFn()
            }
        } else {
            let style = me.style;
            style.visibility = 'hidden';
            me.style = style
        }

        me._hidden = true
    }

    /**
     *
     */
    init() {
        this.autoInitVnode && this.initVnode()
    }

    /**
     * Check if this component or any of its parents is floating
     * @returns {Boolean}
     */
    isFloating() {
        let me = this;

        if (me.floating) {
            return true
        }

        if (!me.parent) {
            return false
        }

        return  me.parent.floating
    }

    /**
     * @param {Number|String} value
     * @returns {Promise<number>}
     */
    async measure(value) {
        if (value != null) {
            if (value.endsWith('px')) {
                value = parseFloat(value)
            } else if (lengthRE.test(value)) {
                let {id, windowId} = this;
                value = await Neo.main.DomAccess.measure({id, value, windowId})
            } else if (!isNaN(value)) {
                value = parseFloat(value)
            }
        }

        return value
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(...args) {
        let config = super.mergeConfig(...args),
            vdom   = config.vdom || config._vdom || {};

        // It should be possible to modify root level vdom attributes on instance level.
        // Note that vdom is not a real config, but implemented via get() & set().
        this._vdom = Neo.clone({...vdom, ...this._vdom || {}}, true);

        delete config._vdom;
        delete config.vdom;

        return config
    }

    /**
     * Can get called after the component got vnodeInitialized. See the autoMount config as well.
     * We have decided to always force a new initVnode(true) call here.
     * Rationale:
     * 1. The overhead of tracking hasUnmountedVdomChanges on every vdom update is removed.
     * 2. The edge case of mounting a pre-calculated but untouched vnode tree is < 1%.
     * 3. The cost of re-generating the vnode tree is low enough to justify the robustness and simplicity.
     * 4. This ensures that the DOM is always mounted with the most up-to-date vdom state.
     */
    async mount() {
        return this.initVnode(true)
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();
        this.keys?.register(this)
    }

    /**
     * @param {Object} data
     */
    onScrollCapture(data) {
        super.onScrollCapture(data);

        let me = this;

        if (me._vdom) {
            let vdomNode = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_8__["default"].getById(me._vdom, data.target.id);

            if (vdomNode) {
                vdomNode.scrollTop  = data.scrollTop;
                vdomNode.scrollLeft = data.scrollLeft
            }
        }
    }

    /**
     * @param {Object} data
     */
    onFocusEnter(data) {
        // If we are hidden, or unmounted while we still contain focus, we have to revert
        // focus to where it came from if possible
        this.focusEnterData = data
    }

    /**
     * @param {Object} data
     */
    onFocusLeave(data) {
        this.focusEnterData = null
    }

    /**
     * Triggered by manager.Focus
     * @name onFocusEnter
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusLeave
     * @function
     * @param {Array} path dom element ids upwards
     */

    /**
     * Triggered by manager.Focus
     * @name onFocusMove
     * @function
     * @param {Object} opts
     * @param {Array}  opts.newPath dom element ids upwards
     * @param {Array}  opts.oldPath dom element ids upwards
     */

    /**
     * Remove a cls from the vdomRoot
     * @param {String} value
     */
    removeCls(value) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].remove(cls, value);
        this.cls = cls
    }



    /**
     * Either a string like 'color' or an array containing style attributes to remove
     * @param {String|Array} value camelCase only
     * @returns {Object} all styles of this.el
     */
    removeStyle(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let {style}  = this,
            doUpdate = false;

        Object.keys(style).forEach(key => {
            if (value.indexOf(key) > -1) {
                delete style[key];
                doUpdate = true
            }
        });

        if (doUpdate) {
            this.style = style
        }

        return style
    }

    /**
     *
     */
    revertFocus() {
        let relatedTarget = this.focusEnterData?.relatedTarget;

        if (this.containsFocus && relatedTarget) {
            Neo.getComponent(relatedTarget.id)?.focus()
        }
    }

    /**
     * Show the component.
     * hideMode: 'removeDom'  uses vdom removeDom.
     * hideMode: 'visibility' uses css visibility.
     */
    show() {
        let me = this;

        if (me.hideMode !== 'visibility') {
            delete me.vdom.removeDom;

            if (me.silentVdomUpdate) {
                me.needsVdomUpdate = true
            } else if (me.parentId !== 'document.body') {
                me.parent.updateDepth = -1;
                me.parent.update()
            } else {
                !me.mounted && me.initVnode(true)
            }
        } else {
            let style = me.style;
            delete style.visibility;
            me.style = style
        }

        me._hidden = false
    }

    /**
     * Toggle a cls inside the vdomRoot of the component
     * @param {String} value
     * @param {Boolean} [add] Use this param to enforce an add() or remove() operation.
     */
    toggleCls(value, add) {
        let cls = this.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].toggle(cls, value, add);
        this.cls = cls
    }

    /**
     * Removes the component DOM
     */
    unmount() {
        let me = this;

        me.vdom.removeDom = true;

        me._hidden = true; // silent update
        me.mounted = false;

        Neo.applyDeltas(me.windowId, {action: 'removeNode', id: me.vdom.id})
    }

    /**
     * Convenience shortcut for Neo.manager.Component.up
     * @param {Object|String} config
     * @returns {Neo.component.Base|null} The matching instance or null
     */
    up(config) {
        return _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].up(this.id, config)
    }

    /**
     *
     */
    updateStyle() {
        let me       = this,
            {vdom}   = me,
            vdomRoot = me.getVdomRoot();

        if (vdom !== vdomRoot) {
            vdom    .style = me.wrapperStyle;
            vdomRoot.style = me.style
        } else {
            vdom.style = {...me.wrapperStyle, ...me.style}
        }

        me.update()
    }

    /**
     * In case you are sure a DOMRect exists, use getDomRect()
     * Otherwise you can wait for it using this method.
     * @example:
     *     await this.initVnode(true);
     *     await this.waitForDomRect();
     * @param {Object}          opts
     * @param {Number}          opts.attempts=10 Reruns in case the rect height or width equals 0
     * @param {Number}          opts.delay=50    Time in ms before checking again
     * @param {String[]|String} opts.id=this.id
     * @param {String}          opts.windowId=this.windowId
     * @returns {Promise<Neo.util.Rectangle|Neo.util.Rectangle[]>}
     */
    async waitForDomRect({attempts=10, delay=50, id=this.id, windowId=this.windowId} = {}) {
        let me     = this,
            result = await me.getDomRect(id),
            reRun  = false;

        if (Array.isArray(result)) {
            result.forEach(rect => {
                if (rect.height < 1 || rect.width < 1) {
                    reRun = true
                }
            })
        } else if (result.height < 1 || result.width < 1) {
            reRun = true
        }

        if (reRun && attempts > 0) {
            await me.timeout(delay);
            return await me.waitForDomRect({attempts: attempts-1, delay, id, windowId})
        }

        return result
    }
}

/**
 * manager.Focus fires the event after focusEnter, focusLeave or focusMove
 * @event focusChange
 * @param {Object} data
 * @param {Object[]} [data.path] dom element ids upwards
 * @param {Object[]} [data.oldPath] dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path
 * @event focusEnter
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is not included inside the dom id path
 * @event focusLeave
 * @param {Object} data
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/**
 * manager.Focus fires the event when the component id is included inside the dom id path, but the path itself changed
 * @event focusMove
 * @param {Object} data
 * @param {Object[]} data.path dom element ids upwards
 * @param {Object[]} data.oldPath dom element ids upwards
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/manager/VDomUpdate.mjs"
/*!************************************!*\
  !*** ./src/manager/VDomUpdate.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");


/**
 * The VDomUpdate manager is a singleton responsible for orchestrating and optimizing
 * component VDOM updates within the Neo.mjs framework. It acts as a central coordinator
 * to optimize the VDOM update process. Its primary goal is to reduce the amount of
 * message roundtrips between the application and VDOM workers by aggregating multiple
 * component updates into a single, optimized VDOM tree.
 *
 * Key Responsibilities:
 * 1. **Update Merging & Aggregation:** Allows a parent component to absorb the update
 *    requests of its children. Instead of each child triggering a separate VDOM update
 *    message to the VDOM worker, the parent sends a single, aggregated VDOM tree. This
 *    significantly reduces the overhead of worker communication and can result in smaller,
 *    more focused data for the VDOM worker to process. While the amount of final DOM
 *    modifications remains the same, this aggregation is key to performance.
 *
 * 2. **Asynchronous Flow Control:** Manages the asynchronous nature of VDOM updates, which
 *    are often processed in a worker thread. It ensures that code awaiting an update
 *    (e.g., via a returned Promise) is correctly notified upon completion.
 *
 * 3. **Dependency Chaining:** Provides a "post-update" queue, allowing one component's
 *    update to be declaratively chained to another's, ensuring a predictable order of
 *    operations.
 *
 * 4. **State Tracking:** Keeps track of updates that are "in-flight" (i.e., currently
 *    being processed), which helps to avoid race conditions and redundant work.
 *
 * By centralizing these concerns, VDomUpdate plays a critical role in the framework's
 * performance and rendering efficiency.
 *
 * @class Neo.manager.VDomUpdate
 * @extends Neo.collection.Base
 * @singleton
 */
class VDomUpdate extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.VDomUpdate'
         * @protected
         */
        className: 'Neo.manager.VDomUpdate',
        /**
         * A collection that maps a parent component's ID (`ownerId`) to the set of child
         * components whose VDOM updates have been merged into that parent's update cycle.
         *
         * The structure for each entry is:
         * `{ ownerId: 'parent-id', children: Map<'child-id', {childUpdateDepth, distance}> }`
         *
         * - `ownerId`: The `id` of the parent component taking responsibility for the update.
         * - `children`: A Map where keys are the `id`s of the merged children and values
         *   are objects containing metadata needed to calculate the total update scope.
         *
         * @member {Neo.collection.Base|null} mergedCallbackMap=null
         * @protected
         */
        mergedCallbackMap: null,
        /**
         * A collection that queues components that need to be updated immediately after
         * another component's update cycle completes. This is used to handle rendering
         * dependencies.
         *
         * The structure for each entry is:
         * `{ ownerId: 'component-id', children: [{childId, resolve}] }`
         *
         * - `ownerId`: The `id` of the component whose update completion will trigger the queued updates.
         * - `children`: An array of objects, where `childId` is the component to update and
         *   `resolve` is the Promise resolver to call after that subsequent update is done.
         *
         * @member {Neo.collection.Base|null} postUpdateQueueMap=null
         * @protected
         */
        postUpdateQueueMap: null,
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * A Map that tracks VDOM updates that have been dispatched to the VDOM worker but
     * have not yet completed. This prevents redundant updates for the same component.
     *
     * The structure is: `Map<'component-id', updateDepth>`
     *
     * @member {Map|null} inFlightUpdateMap=null
     * @protected
     */
    inFlightUpdateMap = null;
    /**
     * A Map that stores Promise `resolve` functions associated with a component's update.
     * When a component's VDOM update is finalized, the callbacks for its ID are executed,
     * resolving the Promise returned by the component's `update()` method.
     *
     * The structure is: `Map<'component-id', [callback1, callback2, ...]>`
     *
     * @member {Map|null} promiseCallbackMap=null
     * @protected
     */
    promiseCallbackMap = null;

    /**
     * Initializes the manager's internal collections and maps.
     * This is called automatically when the singleton instance is created.
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        const me = this;

        me.inFlightUpdateMap  = new Map();
        me.mergedCallbackMap  = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], {keyProperty: 'ownerId'});
        me.postUpdateQueueMap = Neo.create(_collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], {keyProperty: 'ownerId'});
        me.promiseCallbackMap = new Map();
    }

    /**
     * Registers a callback function to be executed when a specific component's
     * VDOM update completes. This is the mechanism that resolves the Promise
     * returned by `Component#update()`.
     * @param {String}   ownerId  The `id` of the component owning the update.
     * @param {Function} callback The function to execute upon completion.
     */
    addPromiseCallback(ownerId, callback) {
        let me = this;

        if (!me.promiseCallbackMap.has(ownerId)) {
            me.promiseCallbackMap.set(ownerId, [])
        }

        me.promiseCallbackMap.get(ownerId).push(callback)
    }

    /**
     * Executes all callbacks associated with a completed VDOM update for a given `ownerId`.
     * This method first processes callbacks for any children that were merged into this
     * update cycle, then executes the callbacks for the `ownerId` itself.
     * @param {String} ownerId The `id` of the component whose update has just completed.
     * @param {Object} [data]  Optional data to pass to the callbacks.
     */
    executeCallbacks(ownerId, data) {
        let me           = this,
            item         = me.mergedCallbackMap.get(ownerId),
            callbackData = data ? [data] : [];

        if (item) {
            item.children.forEach((value, key) => {
                me.executePromiseCallbacks(key, ...callbackData)
            });
            me.mergedCallbackMap.remove(item);
        }

        me.executePromiseCallbacks(ownerId, ...callbackData)
    }

    /**
     * A helper method that invokes all registered promise callbacks for a given
     * component ID and then clears them from the queue.
     * @param {String} ownerId The `id` of the component.
     * @param {Object} [data]  Optional data to pass to the callbacks.
     */
    executePromiseCallbacks(ownerId, data) {
        let me        = this,
            callbacks = me.promiseCallbackMap.get(ownerId);

        callbacks?.forEach(callback => callback(data));
        me.promiseCallbackMap.delete(ownerId);
    }

    /**
     * Calculates the required `updateDepth` for a parent component based on its own
     * needs and the needs of all child components whose updates have been merged into it.
     * The final depth is the maximum required depth to ensure all changes are rendered.
     *
     * For example, if a parent needs to update its direct content (`updateDepth: 1`) but
     * a merged child 3 levels down needs a full subtree update (`childUpdateDepth: -1`),
     * this method will return -1, signaling a full recursive update from the parent.
     *
     * This method is called by the parent component right before it dispatches its VDOM update.
     * @param {String} ownerId The `id` of the parent component.
     * @returns {Number|null} The adjusted update depth, or `null` if no merged children exist.
     */
    getAdjustedUpdateDepth(ownerId) {
        let me       = this,
            owner    = Neo.getComponent(ownerId),
            item     = me.mergedCallbackMap.get(ownerId),
            maxDepth = owner?.updateDepth ?? 1,
            newDepth;

        if (item) {
            item.children.forEach(value => {
                if (value.childUpdateDepth === -1) {
                    newDepth = -1
                } else {
                    // The new depth is the distance to the child plus the child's own required update depth.
                    newDepth = value.distance + value.childUpdateDepth
                }

                if (newDepth === -1) {
                    maxDepth = -1
                } else if (maxDepth !== -1) {
                    maxDepth = Math.max(maxDepth, newDepth)
                }
            });

            return maxDepth
        }

        return null
    }

    /**
     * Retrieves the `updateDepth` for a component's update that is currently in-flight.
     * @param {String} ownerId The `id` of the component owning the update.
     * @returns {Number|undefined} The update depth, or `undefined` if no update is in-flight.
     */
    getInFlightUpdateDepth(ownerId) {
        return this.inFlightUpdateMap.get(ownerId)
    }

    /**
     * Returns a Set of child component IDs that have been merged into a parent's update cycle.
     * This is used by the parent to know which children it is responsible for updating.
     * @param {String} ownerId The `id` of the parent component.
     * @returns {Set<String>|null} A Set containing the IDs of the merged children, or `null`.
     */
    getMergedChildIds(ownerId) {
        const item = this.mergedCallbackMap.get(ownerId);
        if (item) {
            return new Set(item.children.keys())
        }
        return null
    }

    /**
     * Marks a component's VDOM update as "in-flight," meaning it has been sent to the
     * worker for processing.
     * @param {String} ownerId     The `id` of the component owning the update.
     * @param {Number} updateDepth The depth of the in-flight update.
     */
    registerInFlightUpdate(ownerId, updateDepth) {
        this.inFlightUpdateMap.set(ownerId, updateDepth)
    }

    /**
     * Registers a child's update request to be merged into its parent's update cycle.
     * This is called by a child component when it determines it can delegate its update
     * to an ancestor.
     * @param {String} ownerId          The `id` of the parent component that will own the merged update.
     * @param {String} childId          The `id` of the child component requesting the merge.
     * @param {Number} childUpdateDepth The update depth required by the child.
     * @param {Number} distance         The component tree distance (number of levels) between the parent and child.
     */
    registerMerged(ownerId, childId, childUpdateDepth, distance) {
        let me   = this,
            item = me.mergedCallbackMap.get(ownerId);

        if (!item) {
            item = {ownerId, children: new Map()};
            me.mergedCallbackMap.add(item)
        }

        item.children.set(childId, {childUpdateDepth, distance})
    }

    /**
     * Queues a component update to be executed after another component's update is complete.
     * @param {String} ownerId     The `id` of the component to wait for.
     * @param {String} childId     The `id` of the component to update afterward.
     * @param {Function} [resolve] The Promise resolver to be called when the `childId`'s subsequent update finishes.
     */
    registerPostUpdate(ownerId, childId, resolve) {
        let me   = this,
            item = me.postUpdateQueueMap.get(ownerId);

        if (!item) {
            item = {ownerId, children: []};
            me.postUpdateQueueMap.add(item)
        }

        item.children.push({childId, resolve})
    }

    /**
     * Triggers all pending updates that were queued to run after the specified `ownerId`'s
     * update has completed.
     * @param {String} ownerId The `id` of the component whose update has just finished.
     */
    triggerPostUpdates(ownerId) {
        let me   = this,
            item = me.postUpdateQueueMap.get(ownerId),
            component;

        if (item) {
            item.children.forEach(entry => {
                component = Neo.getComponent(entry.childId);

                if (component) {
                    entry.resolve && me.addPromiseCallback(component.id, entry.resolve);
                    component.update()
                }
            });

            me.postUpdateQueueMap.remove(item)
        }
    }

    /**
     * Removes a component's update from the "in-flight" registry. This is called after
     * the VDOM worker confirms the update has been processed.
     * @param {String} ownerId The `id` of the component owning the update.
     */
    unregisterInFlightUpdate(ownerId) {
        this.inFlightUpdateMap.delete(ownerId)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VDomUpdate));


/***/ },

/***/ "./src/mixin/DomEvents.mjs"
/*!*********************************!*\
  !*** ./src/mixin/DomEvents.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/DomEvent.mjs */ "./src/manager/DomEvent.mjs");



/**
 * A mixin providing DOM event handling capabilities to components.
 * This mixin is consumed by both Neo.component.Base and Neo.functional.component.Base
 * to enable consistent management of DOM event listeners across different component types.
 * @class Neo.mixin.DomEvents
 * @extends Neo.core.Base
 */
class DomEvents extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.mixin.DomEvents'
         * @protected
         */
        className: 'Neo.mixin.DomEvents',
        /**
         * An array of domListener configs
         * @member {Object[]|null} domListeners_=null
         * @example
         * afterSetStayOnHover(value, oldValue) {
         *     if (value) {
         *         let me = this;
         *
         *         me.addDomListeners(
         *             {mouseenter: me.onMouseEnter, scope: me},
         *             {mouseleave: me.onMouseLeave, scope: me}
         *         )
         *    }
         *}
         * @reactive
         */
        domListeners_: null
    }

    /**
     * Convenience shortcut to add additional dom listeners
     * @param {Object|Object[]} value
     */
    addDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value]
        }

        let domListeners = this.domListeners;

        domListeners.push(...value);

        this.domListeners = domListeners
    }

    /**
     * Registers the domListeners inside the Neo.manager.DomEvent
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetDomListeners(value, oldValue) {
        let me = this;

        if (value?.[0] || oldValue?.[0]) {
            _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].updateDomListeners(me, value, oldValue)
        }
    }

    /**
     * Triggered before the domListeners config gets changed.
     * @param {Object|Object[]} value
     * @param {Object[]} oldValue
     * @returns {Object[]}
     * @protected
     */
    beforeSetDomListeners(value, oldValue) {
        if (Neo.isObject(value)) {
            value = [value]
        }

        return value || []
    }

    /**
     * Initializes DOM event listeners.
     */
    initDomEvents() {
        let me = this;
        if (me.domListeners?.length > 0) {
            // todo: the main thread reply of mount arrives after pushing the task into the queue which does not ensure the dom is mounted
            me.timeout(150).then(() => {
                _manager_DomEvent_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mountDomListeners(me)
            })
        }
    }

    /**
     * Destroys DOM event listeners.
     */
    removeDomEvents() {
        this.domListeners = []
    }

    /**
     * @param {Array|Object} value
     */
    removeDomListeners(value) {
        if (!Array.isArray(value)) {
            value = [value];
        }

        let me             = this,
            {domListeners} = me,
            i, len;

        value.forEach(item => {
            i = 0;
            len = domListeners.length;

            for (; i < len; i++) {
                if (Neo.isEqual(item, domListeners[i])) {
                    domListeners.splice(i, 1);
                    break
                }
            }
        });

        me.domListeners = domListeners
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(DomEvents));


/***/ },

/***/ "./src/mixin/VdomLifecycle.mjs"
/*!*************************************!*\
  !*** ./src/mixin/VdomLifecycle.mjs ***!
  \*************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/Component.mjs */ "./src/manager/Component.mjs");
/* harmony import */ var _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/vdom/TreeBuilder.mjs */ "./src/util/vdom/TreeBuilder.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../manager/VDomUpdate.mjs */ "./src/manager/VDomUpdate.mjs");
/* harmony import */ var _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/VNode.mjs */ "./src/util/VNode.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");








const {currentWorker} = Neo;

/**
 * @class Neo.mixin.VdomLifecycle
 * @extends Neo.core.Base
 */
class VdomLifecycle extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.mixin.VdomLifecycle'
         * @protected
         */
        className: 'Neo.mixin.VdomLifecycle',
        /**
         * True automatically initializes the vnode of a component after being created inside the init call.
         * Recommended for dialogs & drag-proxies.
         * Top level views should definitely use false.
         * @member {Boolean} autoInitVnode=false
         */
        autoInitVnode: false,
        /**
         * True automatically mounts a component after being rendered.
         * Use this for the top level component of your app.
         * @member {Boolean} autoMount=false
         */
        autoMount: false,
        /**
         * Internal flag which will get set to true while an update request (worker messages) is in progress
         * @member {Boolean} isVdomUpdating_=false
         * @protected
         * @reactive
         */
        isVdomUpdating_: false,
        /**
         * True in case the component is initializing the vnode
         * @member {Boolean} isVnodeInitializing_=false
         * @protected
         * @reactive
         */
        isVnodeInitializing_: false,
        /**
         * True in case the component is mounted to the DOM
         * @member {Boolean} mounted_=false
         * @protected
         * @reactive
         */
        mounted_: false,
        /**
         * Internal flag which will get set to true in case an update call arrives while another update is running
         * @member {Boolean} needsVdomUpdate_=false
         * @protected
         * @reactive
         */
        needsVdomUpdate_: false,
        /**
         * Set this to true for bulk updates. Ensure to set it back to false afterwards.
         * Internally the value will get saved as a number to ensure that child methods won't stop the silent mode too early.
         * @member {Boolean} silentVdomUpdate_=false
         * @reactive
         */
        silentVdomUpdate_: false,
        /**
         * Defines the depth of the vdom tree for the next update cycle.
         * - The value 1 will only send the current vdom structure as it is
         * - The value of 2 will include the vdom of direct children
         * - The value of 3 will include the vdom of grandchildren
         * - The value of -1 will include the full tree of any depth
         * @member {Number} updateDepth_=1
         * @reactive
         */
        updateDepth_: 1,
        /**
         * The component vnode tree. Available after the component got vnodeInitialized.
         * @member {Object} vnode_=={[isDescriptor]: true, value: null, isEqual: (a, b) => a === b,}
         * @protected
         * @reactive
         */
        vnode_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_6__.isDescriptor]: true,
            clone         : 'none',
            cloneOnGet    : 'none',
            isEqual       : (a, b) => a === b, // vnode trees can be huge, and will get compared by the vdom worker.
            value         : null,
        },
        /**
         * True after the component initVnode() method was called. Also fires the vnodeInitialized event.
         * @member {Boolean} vnodeInitialized_=false
         * @protected
         * @reactive
         */
        vnodeInitialized_: false
    }

    /**
     * Triggered after the vdom pseudo-config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVdom(value, oldValue) {
        this.updateVdom()
    }

    /**
     * Triggered after the vnode config got changed
     * @param {Object} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetVnode(value, oldValue) {
        value && this.syncVnodeTree()
    }

    /**
     * Triggered after the vnodeInitialized config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetVnodeInitialized(value, oldValue) {
        let me = this;

        if (value) {
            me.fire('vnodeInitialized', me.id);

            if (me.needsVdomUpdate) {
                me.update()
            }
        }
    }

    /**
     * Creates a lightweight, serializable placeholder for this component, intended for injection
     * into the VDOM of other components.
     *
     * This is the **only recommended way** to nest a component within another component's VDOM tree.
     * Directly embedding one component's full `vdom` object into another's is an anti-pattern
     * that violates the principle of scoped VDOM, leading to unpredictable rendering behavior
     * and making updates inefficient.
     *
     * At its core, the returned object contains a `componentId` that uniquely identifies the
     * component instance. In cases where a component's structure is wrapped by another element
     * (e.g., a Button in a Table Header being wrapped by a `<td>`), the reference will also
     * include the wrapper's `id`. This happens when a component uses `getVdomRoot()` to
     * designate a deeper node as its logical root, causing the component's `id` and its
     * VDOM root's `id` to differ. The framework uses this dual-ID reference to correctly
     * assemble the final VDOM tree.
     *
     * @returns {{componentId: String, id: String|undefined}} The VDOM reference object.
     */
    createVdomReference() {
        let me        = this,
            reference = {componentId: me.id},
            vdomId    = me.vdom.id;

        if (vdomId && me.id !== vdomId) {
            reference.id = vdomId
        }

        return reference
    }

    /**
     * Internal method to send update requests to the vdom worker
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @private
     */
    async executeVdomUpdate(resolve, reject) {
        let me = this;

        resolve && _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addPromiseCallback(me.id, resolve);

        me.isVdomUpdating = true;
        // Centralize in-flight state
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerInFlightUpdate(me.id, me.updateDepth);

        try {
            const
                {vdom, vnode} = me,
                mergedChildIds = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getMergedChildIds(me.id),
                opts = {
                    vdom : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(vdom,   me.updateDepth, mergedChildIds),
                    vnode: _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVnodeTree(vnode, me.updateDepth, mergedChildIds)
                };

            if (currentWorker?.isSharedWorker) {
                opts.appName  = me.appName;
                opts.windowId = me.windowId;
            }

            // We cannot set the config directly => it could already be false,
            // and we still want to pass it further into subtrees
            me._needsVdomUpdate = false;
            me.afterSetNeedsVdomUpdate?.(false, true);

            // Reset the updateDepth to the default value for the next update cycle
            me._updateDepth = me.constructor.config.updateDepth;

            const data = await Promise.resolve(Neo.vdom.Helper.update(opts));

            // Component could be destroyed while the update is running
            if (me.id) {
                // It is crucial to delegate the vnode tree before resolving the cycle
                me.vnode = data.vnode;

                // When not using a VdomWorker, we need to apply the deltas inside the App worker
                if (!Neo.config.useVdomWorker && data.deltas?.length > 0) {
                    await Neo.applyDeltas(me.windowId, data.deltas)
                }

                me.resolveVdomUpdate(data)
            }
        } catch (err) {
            me.isVdomUpdating = false;
            // Ensure state is cleaned up on error
            _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].unregisterInFlightUpdate(me.id);
            reject?.(err)
        }
    }

    /**
     * Honors different item roots for mount / render OPs
     * @returns {String}
     */
    getMountedParentId() {
        let parentId  = this.parentId,
            parent    = Neo.getComponent(parentId),
            itemsRoot = parent?.getVdomItemsRoot?.();

        return itemsRoot ? itemsRoot.id : parentId
    }

    /**
     * Calculate the real parentIndex inside the DOM
     * @returns {Number|undefined}
     */
    getMountedParentIndex() {
        let parent = this.parent,
            items  = parent?.items || [],
            i      = 0,
            index  = 0,
            len    = items.length,
            item;

        for (; i < len; i++) {
            item = items[i];

            if (item === this) {
                return index
            }

            if (!item.hidden && item.hideMode === 'removeDom') {
                index++
            }
        }
    }

    /**
     * Search a vdom child node by id for a given vdom tree
     * @param {String} id
     * @param {Object} vdom=this.vdom
     * @returns {Object}
     */
    getVdomChild(id, vdom=this.vdom) {
        return _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].find(vdom, id)?.vdom
    }

    /**
     * Specify a different vdom root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVnodeRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vdom root
     */
    getVdomRoot() {
        return this.vdom
    }

    /**
     * Specify a different vnode root if needed to apply the top level style attributes on a different level.
     * Make sure to use getVdomRoot() as well, to keep the vdom & vnode trees in sync.
     * @returns {Object} The new vnode root
     */
    getVnodeRoot() {
        return this.vnode
    }

    /**
     * Checks if a given updateDepth & distance would result in an update collision.
     * The check must use `<` because `updateDepth` is 1-based.
     * - `updateDepth: 1` means the update is scoped to the component itself.
     * - A direct child is at `distance: 1`.
     * Therefore, an update with depth 1 should NOT collide with a child at distance 1 (1 < 1 is false).
     * @param {Number} updateDepth
     * @param {Number} distance
     * @returns {Boolean}
     */
    hasUpdateCollision(updateDepth, distance) {
        return updateDepth === -1 ? true : distance < updateDepth
    }

    /**
     * Creates the vnode tree for this component and mounts the component in case
     * - you pass true for the mount param
     * - or the autoMount config is set to true
     * @param {Boolean} [mount] Mount the DOM after the vnode got created
     * @returns {Promise<any>} If getting there, we return the data from vdom.Helper: create(), containing the vnode.
     */
    async initVnode(mount) {
        let me        = this,
            autoMount = mount || me.autoMount,
            {app}     = me,
            {allowVdomUpdatesInTests, unitTestMode, useVdomWorker} = Neo.config;

        if (unitTestMode && !allowVdomUpdatesInTests) return;

        // Verify that the critical rendering path => CSS files for the new tree is in place
        if (!unitTestMode && autoMount && currentWorker.countLoadingThemeFiles !== 0) {
            currentWorker.on('themeFilesLoaded', function() {
                !me.mounted && me.initVnode(mount)
            }, me, {once: true});

            return
        }

        me.isVnodeInitializing = true;

        if (!app.vnodeInitialized) {
            app.isVnodeInitializing = true
        }

        if (me.vdom) {
            me.isVdomUpdating = true;

            // Ensure child components do not trigger updates while the vnode generation is in progress
            _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerInFlightUpdate(me.id, -1);

            delete me.vdom.removeDom;

            me._needsVdomUpdate = false;
            me.afterSetNeedsVdomUpdate?.(false, true);

            const data = await Promise.resolve(Neo.vdom.Helper.create({
                appName    : me.appName,
                autoMount,
                parentId   : autoMount ? me.getMountedParentId()    : undefined,
                parentIndex: autoMount ? me.getMountedParentIndex() : undefined,
                vdom       : _util_vdom_TreeBuilder_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getVdomTree(me.vdom, -1),
                windowId   : me.windowId
            }));

            me.onInitVnode(data.vnode, useVdomWorker ? autoMount : false);

            if (autoMount && !useVdomWorker) {
                // When running without a VdomWorker, Helper.create is local and returns a plain object.
                // We must manually send the insertNode delta to the main thread.
                await Neo.applyDeltas(me.windowId, [{
                    action   : 'insertNode',
                    id       : me.id,
                    index    : me.getMountedParentIndex(),
                    outerHTML: data.outerHTML,
                    parentId : me.getMountedParentId(),
                    vnode    : data.vnode
                }]);

                me.mounted = true
            }

            me.resolveVdomUpdate();

            return data
        }
    }

    /**
     * Checks for vdom updates inside the parent chain and if found.
     * Registers the component for a vdom update once done.
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] Gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean}
     */
    isParentUpdating(parentId=this.parentId, resolve, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                if (parent.isVdomUpdating) {
                    // Get the in-flight update depth from the central manager
                    const parentUpdateDepth = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getInFlightUpdateDepth(parent.id);

                    if (me.hasUpdateCollision(parentUpdateDepth, distance)) {
                        if (Neo.config.logVdomUpdateCollisions) {
                            console.warn('vdom parent update conflict with:', parent, 'for:', me)
                        }

                        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerPostUpdate(parent.id, me.id, resolve);
                        return true
                    }

                    // If an update is running and does not have a collision, we do not need to check further parents
                    return false
                }

                return me.isParentUpdating(parent.parentId, resolve, distance+1)
            }
        }

        return false
    }

    /**
     * Checks the needsVdomUpdate config inside the parent tree
     * @param {String} parentId=this.parentId
     * @param {Function} [resolve] gets passed by updateVdom()
     * @param {Number} distance=1 Distance inside the component tree
     * @returns {Boolean}
     */
    mergeIntoParentUpdate(parentId=this.parentId, distance=1) {
        if (parentId !== 'document.body') {
            let me     = this,
                parent = Neo.getComponent(parentId);

            if (parent) {
                // We are checking for parent.updateDepth, since we care about the depth of the next update cycle
                if (parent.needsVdomUpdate && me.hasUpdateCollision(parent.updateDepth, distance)) {
                    _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].registerMerged(parent.id, me.id, me.updateDepth, distance);
                    return true
                }

                return me.mergeIntoParentUpdate(parent.parentId, distance+1)
            }
        }

        return false
    }

    /**
     * Gets called from the initVnode() promise success handler
     * @param {Object} vnode
     * @param {Boolean} autoMount Mount the DOM after the vnode got created
     * @protected
     */
    onInitVnode(vnode, autoMount) {
        let me    = this,
            {app} = me;

        me.isVnodeInitializing = false;

        // if app is a check to see if the Component got destroyed while vnodeInitialising => before onInitVnode got triggered
        if (app) {
            if (!app.vnodeInitialized) {
                app.isVnodeInitializing = false;
                app.vnodeInitialized = true;
                app.fire('vnodeInitialized')
            }

            me.vnode = vnode;

            let childIds = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildIds(vnode),
                i        = 0,
                len      = childIds.length,
                child;

            for (; i < len; i++) {
                child = Neo.getComponent(childIds[i]);

                if (child) {
                    child.vnodeInitialized = true
                }
            }

            me.vnodeInitialized = true;

            if (autoMount) {
                me.mounted = true;

                if (!app.mounted) {
                    app.mounted = true;
                    app.fire('mounted')
                }
            }
        }
    }

    /**
     * Promise based vdom update
     * @returns {Promise<any>}
     */
    promiseUpdate() {
        return new Promise((resolve, reject) => {
            this.updateVdom(resolve, reject)
        })
    }

    /**
     * Internal helper fn to resolve the Promise for updateVdom()
     * @param {Object}   [data] The return value of vdom.Helper.update()
     * @protected
     */
    resolveVdomUpdate(data) {
        let me = this;

        me.isVdomUpdating = false;

        // Execute callbacks for merged updates
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].executeCallbacks(me.id, data);

        // The update is no longer in-flight
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].unregisterInFlightUpdate(me.id);

        // Trigger updates for components that were in-flight
        _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].triggerPostUpdates(me.id);

        if (me.needsVdomUpdate) {
            // any new promise callbacks will get picked up by the next update cycle
            me.update()
        }
    }

    /**
     * Placeholder method for util.VDom.syncVdomState to allow overriding (disabling) it
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     * @param {Object} [vdom=this.vdom]
     * @param {Boolean} force=false
     */
    syncVdomState(vnode=this.vnode, vdom=this.vdom, force=false) {
        _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].syncVdomState(vnode, vdom, force)
    }

    /**
     * In case a component receives a new vnode, we want to do:
     * - sync the vdom ids
     * - setting vnodeInitialized to true for child components
     * - updating the parent component to ensure that the vnode tree stays persistent
     * @param {Neo.vdom.VNode} [vnode=this.vnode]
     */
    syncVnodeTree(vnode=this.vnode) {
        let me              = this,
            childComponents = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getChildren(me),
            debug           = false,
            map             = {},
            childVnode, start;

        if (debug) {
            start = performance.now()
        }

        me.syncVdomState();

        if (vnode && me.id !== vnode.id) {
            _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].registerWrapperNode(vnode.id, me)
        }

        // we need one separate iteration first to ensure all wrapper nodes get registered
        childComponents.forEach(component => {
            childVnode = _util_VNode_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].find(me.vnode, component.vdom.id)?.vnode;

            if (childVnode) {
                map[component.id] = childVnode;

                if (component.id !== childVnode.id) {
                    _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].registerWrapperNode(childVnode.id, component)
                }
            }
        });

        // delegate the latest node updates to all possible child components found inside the vnode tree
        childComponents.forEach(component => {
            childVnode = map[component.id];

            if (childVnode) {
                // silent update
                component._vnode = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addVnodeComponentReferences(childVnode, component.id);

                component.vnodeInitialized = true;
                component.mounted          = true
            } else {
                console.warn('syncVnodeTree: Could not replace the child vnode for', component.id)
            }
        });

        // silent update
        me._vnode = vnode ? _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].addVnodeComponentReferences(vnode, me.id) : null;

        debug && console.log('syncVnodeTree', me.id, performance.now() - start)
    }

    /**
     *
     */
    update() {
        this.afterSetVdom(this.vdom, null)
    }

    /**
     * Gets called after the vdom config gets changed in case the component is already mounted (delta updates).
     * @param {function} [resolve] used by promiseUpdate()
     * @param {function} [reject] used by promiseUpdate()
     * @protected
     */
    updateVdom(resolve, reject) {
        if (!this.isConstructed) {
            resolve?.();
            return
        }

        let me                         = this,
            {mounted, parentId, vnode} = me,
            {config}                   = Neo;

        if (config.unitTestMode && !config.allowVdomUpdatesInTests) {
            reject?.();
            return
        }

        if (me.isVdomUpdating || !me.vnodeInitialized || me.silentVdomUpdate) {
            resolve && _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addPromiseCallback(me.id, resolve);
            me.needsVdomUpdate = true
        } else {
            // If there's a promise, register it against this component's ID immediately.
            // The manager will ensure it's called when the appropriate update cycle completes.
            resolve && _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addPromiseCallback(me.id, resolve);

            // If an update is triggered on an unmounted component, we must wait for it to be mounted.
            if (!mounted) {
                // Use a flag to prevent setting up multiple `then` listeners for subsequent updates
                // that might arrive before the component is mounted.
                if (!me.isAwaitingMount) {
                    me.isAwaitingMount = true;
                    me.mountedPromise.then(() => {
                        me.isAwaitingMount = false;
                        // After mounting, re-trigger the update cycle. The cached callbacks will be picked up.
                        me.vnode && me.update();
                    });
                }
            } else {
                if (
                    !me.mergeIntoParentUpdate(parentId)
                    && !me.isParentUpdating(parentId, resolve)
                    && mounted
                    && vnode
                ) {
                    // Check for merged child updates and adjust the update depth accordingly
                    let adjustedDepth = _manager_VDomUpdate_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].getAdjustedUpdateDepth(me.id);

                    if (adjustedDepth !== null) {
                        me.updateDepth = adjustedDepth;
                    }

                    // Verify that the critical rendering path => CSS files for the new tree is in place
                    if (!config.isMiddleware && !config.unitTestMode && currentWorker.countLoadingThemeFiles !== 0) {
                        currentWorker.on('themeFilesLoaded', function() {
                            me.updateVdom(resolve, reject)
                        }, me, {once: true})
                    } else {
                        me.executeVdomUpdate(null, reject)
                    }
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(VdomLifecycle));


/***/ },

/***/ "./src/util/KeyNavigation.mjs"
/*!************************************!*\
  !*** ./src/util/KeyNavigation.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");



/**
 * @class Neo.util.KeyNavigation
 * @extends Neo.core.Base
 */
class KeyNavigation extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.KeyNavigation'
         * @protected
         */
        className: 'Neo.util.KeyNavigation',
        /**
         * @member {String} ntype='keynav'
         * @protected
         */
        ntype: 'keynav',
        /**
         * Internally stores the component id inside _component
         * @member {Neo.component.Base|null} component_=null
         * @reactive
         */
        component_: null,
        /**
         * Set this to true in case the keydown event is supposed to bubble upwards inside the component tree
         * @member {Boolean} keyDownEventBubble=false
         */
        keyDownEventBubble: false,
        /**
         * @member {Array|null} keys_=null
         * @reactive
         */
        keys_: null
    }

    add(value) {
        this._keys.push(...this.parseKeys(value))
    }

    /**
     * @protected
     * @returns {Neo.component.Base}
     */
    beforeGetComponent() {
        return Neo.getComponent(this._component)
    }

    /**
     * @param {Neo.component.Base} value
     * @protected
     * @returns {String} the component id
     */
    beforeSetComponent(value) {
        return value?.id
    }

    /**
     *
     */
    destroy() {
        this.unregister();
        super.destroy()
    }

    /**
     * @param {Object} data
     */
    onKeyDown(data) {
        // Using the chrome auto-fill feature does trigger a keydown event, not containing a key. See: #64
        if (data.key) {
            let me           = this,
                upperCaseKey = data.key.toUpperCase(),
                scope;

            upperCaseKey = me.parseUpperCaseKey(upperCaseKey);

            me.keys.forEach(key => {
                scope = Neo.isString(key.scope) ? Neo.get(key.scope) : key.scope;

                if (key.key.toUpperCase() === upperCaseKey) {
                    if (Neo.isFunction(key.fn)) {
                        key.fn.apply(scope, [data, me.component])
                    } else {
                        scope[key.fn]?.apply(scope, [data, me.component])
                    }
                }
            })
        }
    }

    /**
     * @param {Object} value
     * @returns {Object}
     */
    parseKeys(value) {
        if (!Array.isArray(value)) {
            let componentId = this._component,
                keyArray    = [];

            if (componentId) {
                Object.entries(value).forEach(([key, val]) => {
                    if (key !== 'scope') {
                        keyArray.push({
                            fn   : val,
                            key,
                            scope: value.scope || componentId // todo: support VCs later on
                        })
                    }
                });

                value = keyArray
            }
        }

        return value
    }

    /**
     * Replaces specific key names, e.g. " " => SPACE
     * @param {String} key
     * @protected
     * @returns {String}
     */
    parseUpperCaseKey(key) {
        switch (key) {
            case ' ':
                key = 'SPACE';
                break
            case 'ARROWDOWN':
                key = 'DOWN';
                break
            case 'ARROWLEFT':
                key = 'LEFT';
                break
            case 'ARROWRIGHT':
                key = 'RIGHT';
                break
            case 'ARROWUP':
                key = 'UP';
                break
        }

        return key
    }

    /**
     * @param {Neo.component.Base} component
     */
    register(component) {
        let me = this;

        me.component = component;
        me.keys      = me.parseKeys(me.keys);

        component.addDomListeners({
            keydown: {
                bubble: me.keyDownEventBubble,
                fn    : me.onKeyDown,
                scope : me
            }
        })
    }

    /**
     * Remove a key listener using the same config used when creating it
     * @param {Object} config
     */
    removeKey(config) {
        let me   = this,
            keys = me._keys,
            i    = 0,
            len  = keys.length,
            key;

        for (; i < len; i++) {
            key = keys[i];

            if (Neo.isEqual(key, config)) {
                _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(keys, key);
                break
            }
        }
    }

    /**
     * Remove multiple key listeners passing an array of config items
     * @param {Array} items
     */
    removeKeys(items) {
        Array.isArray(items) && items.forEach(item => this.removeKey(item))
    }

    /**
     *
     */
    unregister() {
        // todo: remove the dom listener from the owner component
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(KeyNavigation));


/***/ },

/***/ "./src/util/Style.mjs"
/*!****************************!*\
  !*** ./src/util/Style.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * @class Neo.util.Style
 * @extends Neo.core.Base
 */
class Style extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.Style'
         * @protected
         */
        className: 'Neo.util.Style'
    }

    /**
     * Creates an delta object, containing the styles of newStyle which are not included or different than in oldStyle
     * Styles included in oldStyle but missing in newStyle will get a value of null
     * see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
     * @param {Object|String} newStyle
     * @param {Object|String} oldStyle
     * @returns {Object} style delta
     */
    static compareStyles(newStyle, oldStyle) {
        let styles = {};

        if (Neo.isString(newStyle)) {
            newStyle = Neo.createStyleObject(newStyle)
        }

        if (Neo.isString(oldStyle)) {
            oldStyle = Neo.createStyleObject(oldStyle)
        }

        if (!newStyle && !oldStyle) {
            return null
        } else if (!oldStyle) {
            return Neo.clone(newStyle)
        } else {
            newStyle && Object.keys(newStyle).forEach(style => {
                if (!oldStyle.hasOwnProperty(style) || oldStyle[style] !== newStyle[style]) {
                    styles[style] = newStyle[style]
                }
            });

            Object.keys(oldStyle).forEach(style => {
                if (!newStyle  || !newStyle.hasOwnProperty(style)) {
                    styles[style] = null
                }
            });

            if (Object.keys(styles).length > 0) {
                return styles
            }

            return null
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Style));


/***/ },

/***/ "./src/util/vdom/TreeBuilder.mjs"
/*!***************************************!*\
  !*** ./src/util/vdom/TreeBuilder.mjs ***!
  \***************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../manager/Component.mjs */ "./src/manager/Component.mjs");



/**
 * A singleton utility class responsible for recursively building VDOM and VNode trees.
 * It can expand component references within a tree structure into their full VDOM/VNode representations,
 * supporting selective (asymmetric) tree expansion for optimized updates.
 * @class Neo.util.vdom.TreeBuilder
 * @extends Neo.core.Base
 * @singleton
 */
class TreeBuilder extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.util.vdom.TreeBuilder'
         * @protected
         */
        className: 'Neo.util.vdom.TreeBuilder',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Private helper to recursively build a tree, abstracting the child node key.
     * @param {Object} node The vdom or vnode to process.
     * @param {Number} depth The current recursion depth.
     * @param {Set<String>|null} mergedChildIds A set of component IDs to selectively expand.
     * @param {String} childKey The property name for child nodes ('cn' or 'childNodes').
     * @returns {Object}
     * @private
     */
    #buildTree(node, depth, mergedChildIds, childKey) {
        // We can not use Neo.isObject() here, since inside unit-test scenarios, we will import vdom.Helper into main threads.
        // Inside this scenario, Neo.isObject() returns false for VNode instances
        if (typeof node !== 'object' || node === null) {
            return node
        }

        let output = {...node}; // Shallow copy

        if (node[childKey]) {
            output[childKey] = [];

            node[childKey].forEach(item => {
                let currentItem = item,
                    childDepth;

                if (currentItem.componentId) {
                    // Prune the branch only if we are at the boundary AND the child is not part of a merged update
                    if (depth === 1 && !mergedChildIds?.has(currentItem.componentId)) {
                        output[childKey].push({...currentItem, neoIgnore: true});
                        return // Stop processing this branch
                    }
                    // Expand the branch if it's part of a merged update, or if the depth requires it
                    else if (depth > 1 || depth === -1 || mergedChildIds?.has(currentItem.componentId)) {
                        const component = _manager_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].get(currentItem.componentId);
                        // Use the correct tree type based on the childKey
                        const componentTree = childKey === 'cn' ? component?.vdom : component?.vnode;
                        if (componentTree) {
                            currentItem = componentTree
                        }
                    }
                }

                if (item.componentId) {
                    childDepth = (depth === -1) ? -1 : Math.max(0, depth - 1)
                } else {
                    childDepth = depth
                }

                output[childKey].push(this.#buildTree(currentItem, childDepth, mergedChildIds, childKey))
            })
        }

        return output
    }


    /**
     * Copies a given vdom tree and replaces child component references with their vdom.
     * @param {Object} vdom
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVdomTree(vdom, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vdom, depth, mergedChildIds, 'cn')
    }

    /**
     * Copies a given vnode tree and replaces child component references with their vnode.
     * @param {Object} vnode
     * @param {Number} [depth=-1]
     * @param {Set<String>|null} [mergedChildIds=null]
     * @returns {Object}
     */
    getVnodeTree(vnode, depth=-1, mergedChildIds=null) {
        return this.#buildTree(vnode, depth, mergedChildIds, 'childNodes')
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(TreeBuilder));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19jb21wb25lbnRfQmFzZV9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ087QUFDQztBQUNGO0FBQ0E7QUFDSTtBQUNEO0FBQ1I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0EsaUJBQWlCLDREQUFTLEVBQUUsNERBQVUsRUFBRSxnRUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FB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bWpzLy4vc3JjL2NvbXBvbmVudC9BYnN0cmFjdC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1ZEb21VcGRhdGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWl4aW4vRG9tRXZlbnRzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL21peGluL1Zkb21MaWZlY3ljbGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC9LZXlOYXZpZ2F0aW9uLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3V0aWwvU3R5bGUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdXRpbC92ZG9tL1RyZWVCdWlsZGVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXIvQ29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgRG9tRXZlbnRzICAgICAgICBmcm9tICcuLi9taXhpbi9Eb21FdmVudHMubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFZkb21MaWZlY3ljbGUgICAgZnJvbSAnLi4vbWl4aW4vVmRvbUxpZmVjeWNsZS5tanMnO1xuaW1wb3J0IFZEb21VcGRhdGUgICAgICAgZnJvbSAnLi4vbWFuYWdlci9WRG9tVXBkYXRlLm1qcyc7XG5pbXBvcnQgVk5vZGVVdGlsICAgICAgICBmcm9tICcuLi91dGlsL1ZOb2RlLm1qcyc7XG5cbmNvbnN0XG4gICAgY2xvc2VzdENvbnRyb2xsZXIgICA9IFN5bWJvbC5mb3IoJ2Nsb3Nlc3RDb250cm9sbGVyJyksXG4gICAgY2xvc2VzdFByb3ZpZGVyICAgICA9IFN5bWJvbC5mb3IoJ2Nsb3Nlc3RQcm92aWRlcicpLFxuICAgIHR3b1dheUJpbmRpbmdTeW1ib2wgPSBTeW1ib2wuZm9yKCd0d29XYXlCaW5kaW5nJyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQWJzdHJhY3RcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29tcG9uZW50Lm1peGluLkRvbUV2ZW50c1xuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqIEBtaXhlcyBOZW8uY29tcG9uZW50Lm1peGluLlZkb21MaWZlY3ljbGVcbiAqL1xuY2xhc3MgQWJzdHJhY3QgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb21wb25lbnQuQWJzdHJhY3QnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuQWJzdHJhY3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nYWJzdHJhY3QtY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Fic3RyYWN0LWNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIG5hbWVzcGFjZXMgdG8gbG9hZCB0aGVtZSBmaWxlcyBmb3IuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGFkZGl0aW9uYWxUaGVtZUZpbGVzPW51bGxcbiAgICAgICAgICogQGV4YW1wbGUgWydBZ2VudE9TU3RyYXRlZ3kudmlldy5WaWV3cG9ydCddXG4gICAgICAgICAqL1xuICAgICAgICBhZGRpdGlvbmFsVGhlbWVGaWxlczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBjb21wb25lbnQgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwTmFtZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFwcE5hbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBjb25maWdzIHRvIHN0YXRlLlByb3ZpZGVyIGRhdGEgcHJvcGVydGllcy5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGJpbmQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBDU1Mgc2VsZWN0b3JzIHRvIGFwcGx5IHRvIHRoZSByb290IGxldmVsIG5vZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGNsc189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBhY2Nlc3MgdGhlIGRhdGEgY29uZmlnIG9mIHRoZSBjbG9zZXN0IHN0YXRlLlByb3ZpZGVyLlxuICAgICAgICAgKiBSZWFkIG9ubHkuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGF0YV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlZCBjb21wb25lbnRzIHdpbGwgZ2V0IHRoZSBuZW8tZGlzYWJsZWQgY2xzIGFwcGxpZWQgYW5kIHdvbid0IHJlY2VpdmUgRE9NIGV2ZW50c1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvcmUuQmFzZVtdfSBtaXhpbnM9W0RvbUV2ZW50cywgT2JzZXJ2YWJsZSwgVmRvbUxpZmVjeWNsZV1cbiAgICAgICAgICovXG4gICAgICAgIG1peGluczogW0RvbUV2ZW50cywgT2JzZXJ2YWJsZSwgVmRvbUxpZmVjeWNsZV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSBzcGVjaWZpYyBzdGF0ZVByb3ZpZGVyIGRhdGEgcHJvcGVydGllcy5cbiAgICAgICAgICogVGhpcyB3aWxsIG1lcmdlIHRoZSBjb250ZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbW9kZWxEYXRhPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsRGF0YTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpbml0Vm5vZGUoKSBtZXRob2Qgd2FzIGNhbGxlZC4gQWxzbyBmaXJlcyB0aGUgcmVuZGVyZWQgZXZlbnQuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdW50ZWRfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcGFyZW50SWQgZG9lcyBub3QgbWF0Y2ggYSBuZW8gY29tcG9uZW50IGlkLCB5b3UgY2FuIG1hbnVhbGx5IHNldCB0aGlzIHZhbHVlIGZvciBmaW5kaW5nXG4gICAgICAgICAqIHZpZXcgY29udHJvbGxlcnMgb3Igc3RhdGUgcHJvdmlkZXJzLlxuICAgICAgICAgKiBVc2UgY2FzZTogbWFudWFsbHkgZHJvcHBpbmcgY29tcG9uZW50cyBpbnRvIGEgdmRvbSBzdHJ1Y3R1cmVcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IHBhcmVudENvbXBvbmVudF89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50Q29tcG9uZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJlbnQgY29tcG9uZW50IGlkIG9yIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwYXJlbnRJZF89J2RvY3VtZW50LmJvZHknXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50SWRfOiAnZG9jdW1lbnQuYm9keScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzYXZlU2Nyb2xsUG9zaXRpb249dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2F2ZVNjcm9sbFBvc2l0aW9uOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWxseSBhZGQgYSBzdGF0ZS5Qcm92aWRlciB0byBzaGFyZSBzdGF0ZSBkYXRhIHdpdGggY2hpbGQgY29tcG9uZW50c1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc3RhdGVQcm92aWRlcl89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlUHJvdmlkZXJfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1c3RvbSB3aW5kb3dJcyAodGltZXN0YW1wKSB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZsYWcgd2hpY2ggd2lsbCBnZXQgc2V0IHRvIHRydWUgd2hpbGUgYSBjb21wb25lbnQgaXMgd2FpdGluZyBmb3IgaXRzIG1vdW50ZWRQcm9taXNlXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNBd2FpdGluZ01vdW50PWZhbHNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzQXdhaXRpbmdNb3VudCA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBhY2Nlc3MgdGhlIEFwcCB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkFwcGxpY2F0aW9ufG51bGx9XG4gICAgICovXG4gICAgZ2V0IGFwcCgpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBOZW8uYXBwc0J5TmFtZSBhcyBhIGZhbGxiYWNrIGZvciBQbGF5d3JpZ2h0LWJhc2VkIHVuaXQgdGVzdGluZ1xuICAgICAgICByZXR1cm4gTmVvLmFwcHNbdGhpcy53aW5kb3dJZF0gfHwgTmVvLmFwcHNCeU5hbWVbdGhpcy5hcHBOYW1lXT8uWzBdIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCB0byB0aGUgRE9NLlxuICAgICAqIFRoaXMgcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byB3YWl0IGZvciB0aGUgY29tcG9uZW50IHRvIGJlIGZ1bGx5XG4gICAgICogYXZhaWxhYmxlIGFuZCBpbnRlcmFjdGl2ZSBiZWZvcmUgZXhlY3V0aW5nIHN1YnNlcXVlbnQgbG9naWMuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGhhbmRsZXMgdW5tb3VudGluZyBieSByZXNldHRpbmcgdGhlIHByb21pc2UsIHNvIGl0IGNhbiBiZSBzYWZlbHlcbiAgICAgKiBhd2FpdGVkIGFnYWluIGlmIHRoZSBjb21wb25lbnQgaXMgcmVtb3VudGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby5jb21wb25lbnQuQmFzZT59XG4gICAgICovXG4gICAgZ2V0IG1vdW50ZWRQcm9taXNlKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICghbWUuX21vdW50ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICBtZS5fbW91bnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5tb3VudGVkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5fbW91bnRlZFByb21pc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWNjZXNzIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG1lLnBhcmVudENvbXBvbmVudCB8fCAobWUucGFyZW50SWQgPT09ICdkb2N1bWVudC5ib2R5JyA/IG51bGwgOiBOZW8uZ2V0Q29tcG9uZW50KG1lLnBhcmVudElkKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgYW55IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENvbmZpZyhrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChOZW8uaXNVc2luZ1N0YXRlUHJvdmlkZXJzICYmIG1lW3R3b1dheUJpbmRpbmdTeW1ib2xdKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgY29tcG9uZW50IGNvbmZpZyBpcyB1cGRhdGVkIGJ5IGl0cyBzdGF0ZSBwcm92aWRlciwgdGhpcyBmbGFnIGlzIHNldCB0byB0aGUgY29uZmlnJ3Mga2V5LlxuICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBjaXJjdWxhciB1cGRhdGVzIGluIHR3by13YXkgZGF0YSBiaW5kaW5ncyBieSBza2lwcGluZyB0aGUgcHVzaCBiYWNrIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICAgIGlmIChtZS5fc2tpcFR3b1dheVB1c2ggPT09IGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiaW5kaW5nID0gbWUuYmluZD8uW2tleV07XG5cbiAgICAgICAgICAgIGlmIChiaW5kaW5nPy50d29XYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKT8uc2V0RGF0YShiaW5kaW5nLmtleSwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIG9sZFZhbHVlICYmIENvbXBvbmVudE1hbmFnZXIudW5yZWdpc3RlcihvbGRWYWx1ZSk7XG4gICAgICAgIHZhbHVlICAgICYmIENvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHsgLy8gbW91bnRcbiAgICAgICAgICAgICAgICBtZS5pbml0RG9tRXZlbnRzPy4oKTtcbiAgICAgICAgICAgICAgICBtZS5tb3VudGVkUHJvbWlzZVJlc29sdmU/Lih0aGlzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWUubW91bnRlZFByb21pc2VSZXNvbHZlO1xuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIGNvbXBvbmVudCBiZWNvbWVzIG1vdW50ZWQsIGl0IG1pZ2h0IGhhdmUgcGVuZGluZyBWRE9NIHVwZGF0ZSBwcm9taXNlc1xuICAgICAgICAgICAgICAgIC8vIChlLmcuIGZyb20gYSBzZXQoKSBjYWxsIHRoYXQgd2FzIGRlZmVycmVkIGJlY2F1c2UgdGhlIGNvbXBvbmVudCB3YXNuJ3QgbW91bnRlZCB5ZXQpLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBtb3VudCBoYXBwZW5lZCBiZWNhdXNlIGEgUGFyZW50IGNvbXBvbmVudCB1cGRhdGVkIChpbXBsaWNpdGx5IGNvdmVyaW5nIHRoaXMgY29tcG9uZW50KSxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCdzIG93biBwZW5kaW5nIHVwZGF0ZSBjeWNsZSBtaWdodCBiZSBza2lwcGVkIG9yIG5vdCB5ZXQgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIGhlcmUgdG8gZW5zdXJlIHRob3NlIHBlbmRpbmcgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgLy8gdXBvbiBtb3VudCwgcHJldmVudGluZyBkZWFkbG9ja3Mgd2hlcmUgY29kZSBhd2FpdHMgYSBWRE9NIHVwZGF0ZSB0aGF0IGVmZmVjdGl2ZWx5IGFscmVhZHkgaGFwcGVuZWQuXG4gICAgICAgICAgICAgICAgVkRvbVVwZGF0ZS5leGVjdXRlQ2FsbGJhY2tzKG1lLmlkKVxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdW5tb3VudFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZS5fbW91bnRlZFByb21pc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc3RhdGVQcm92aWRlciBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uc3RhdGUuUHJvdmlkZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTdGF0ZVByb3ZpZGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZT8uY3JlYXRlQmluZGluZ3ModGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUuY29udHJvbGxlciAgICAmJiAobWUuY29udHJvbGxlci53aW5kb3dJZCAgICA9IHZhbHVlKTtcbiAgICAgICAgICAgIG1lLnN0YXRlUHJvdmlkZXIgJiYgKG1lLnN0YXRlUHJvdmlkZXIud2luZG93SWQgPSB2YWx1ZSk7XG5cbiAgICAgICAgICAgIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIG1lLl9fcHJvdG9fXylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgY29tcG9uZW50IGdldHMgbW92ZWQgaW50byBhIGRpZmZlcmVudCB3aW5kb3csIGFuIHVwZGF0ZSBjeWNsZSBtaWdodCBzdGlsbCBiZSBydW5uaW5nLlxuICAgICAgICAvLyBTaW5jZSB0aGUgdXBkYXRlIG1pZ2h0IG5vIGxvbmdlciBnZXQgbWFwcGVkLCB3ZSB3YW50IHRvIHJlLWVuYWJsZSB0aGlzIGluc3RhbmNlIGZvciBmdXR1cmUgdXBkYXRlcy5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGRhdGEgY29uZmlnXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgd2hpY2ggaXMgZXhwZW5zaXZlIHRvIHVzZSwgc2luY2UgaXQgd2lsbCBnZW5lcmF0ZSBhIG1lcmdlZCBwYXJlbnQgc3RhdGUgcHJvdmlkZXJzIGRhdGEgbWFwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXREYXRhKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKT8uZ2V0SGllcmFyY2h5RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RhdGVQcm92aWRlciBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIENyZWF0ZXMgYSBzdGF0ZS5Qcm92aWRlciBpbnN0YW5jZSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby5zdGF0ZS5Qcm92aWRlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RhdGVQcm92aWRlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzID0ge2NvbXBvbmVudDogbWUsIHdpbmRvd0lkOiBtZS53aW5kb3dJZH07XG5cbiAgICAgICAgICAgIGlmIChtZS5tb2RlbERhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVzLmRhdGEgPSBtZS5tb2RlbERhdGFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgJ05lby5zdGF0ZS5Qcm92aWRlcicsIGRlZmF1bHRWYWx1ZXMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVEb21FdmVudHMoKTtcbiAgICAgICAgQ29tcG9uZW50TWFuYWdlci51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXRlUHJvdmlkZXIgPSBudWxsOyAvLyB0cmlnZ2VycyBkZXN0cm95KClcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbiBpbnN0YW5jZSBzdG9yZWQgaW5zaWRlIGEgY29uZmlnIHZpYSBvcHRpb25hbGx5IHBhc3NpbmcgYSBudHlwZS5cbiAgICAgKiBSZXR1cm5zIHRoaXNbY29uZmlnTmFtZV0gb3IgdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIGEgbWF0Y2guXG4gICAgICogVXNlZCBieSBnZXRDb250cm9sbGVyKCkgJiBnZXRTdGF0ZVByb3ZpZGVyKClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoY29uZmlnTmFtZSwgbnR5cGUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyAgICAgICAgICAgID0gbWVbY29uZmlnTmFtZV0sXG4gICAgICAgICAgICB7cGFyZW50Q29tcG9uZW50fSA9IG1lO1xuXG4gICAgICAgIGlmIChjb25maWcgJiYgKCFudHlwZSB8fCBudHlwZSA9PT0gY29uZmlnLm50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJlbnRDb21wb25lbnQgJiYgbWUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCA9IG1lLnBhcmVudCB8fCBOZW8uZ2V0KG1lLnBhcmVudElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIHRvZG86IFdlIG5lZWQgPy4gdW50aWwgZnVuY3Rpb25hbC5jb21wb25lbnQuQmFzZSBzdXBwb3J0cyBjb250cm9sbGVyc1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudENvbXBvbmVudC5nZXRDb25maWdJbnN0YW5jZUJ5TnR5cGU/Lihjb25maWdOYW1lLCBudHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpLmdldERhdGEoLi4uYXJncylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMuc3RhdGVQcm92aWRlciBvciB0aGUgY2xvc2VzdCBwYXJlbnQgc3RhdGVQcm92aWRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5zdGF0ZS5Qcm92aWRlcnxudWxsfVxuICAgICAqL1xuICAgIGdldFN0YXRlUHJvdmlkZXIobnR5cGUpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNVc2luZ1N0YXRlUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHByb3ZpZGVyO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbWVbY2xvc2VzdFByb3ZpZGVyXTtcblxuICAgICAgICAgICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm92aWRlciA9IG1lLmdldENvbmZpZ0luc3RhbmNlQnlOdHlwZSgnc3RhdGVQcm92aWRlcicsIG50eXBlKTtcblxuICAgICAgICBpZiAoIW50eXBlKSB7XG4gICAgICAgICAgICBtZVtjbG9zZXN0UHJvdmlkZXJdID0gcHJvdmlkZXJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm92aWRlclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgaW5pdENvbmZpZyguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyLmluaXRDb25maWcoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGVQcm92aWRlcigpPy5jcmVhdGVCaW5kaW5ncyh0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TY3JvbGxDYXB0dXJlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIHZub2RlO1xuXG4gICAgICAgIGlmIChtZS52bm9kZSkge1xuICAgICAgICAgICAgdm5vZGUgPSBWTm9kZVV0aWwuZ2V0QnlJZChtZS52bm9kZSwgZGF0YS50YXJnZXQuaWQpO1xuXG4gICAgICAgICAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBEaXJlY3RseSB1cGRhdGluZyB0aGUgcGVyc2lzdGVudCB2bm9kZSBzdGF0ZSAocGxhaW4gb2JqZWN0KS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGRvZXMgbm90IHRyaWdnZXIgYSBWRE9NIHVwZGF0ZSwgYnV0IGVuc3VyZXMgdGhlIHN0YXRlIGlzIHByZXNlcnZlZFxuICAgICAgICAgICAgICAgIC8vIGZvciBmdXR1cmUgcmUtcmVuZGVycyAoZS5nLiB1bm1vdW50L3JlbW91bnQpLlxuICAgICAgICAgICAgICAgIHZub2RlLnNjcm9sbFRvcCAgPSBkYXRhLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB2bm9kZS5zY3JvbGxMZWZ0ID0gZGF0YS5zY3JvbGxMZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgbXVsdGlwbGUgY29uZmlncyBhdCBvbmNlLCBlbnN1cmluZyB0aGF0IGFsbCBhZnRlclNldCBtZXRob2RzIGdldCBhbGwgbmV3IGFzc2lnbmVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXM9e31cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIHNldCh2YWx1ZXM9e30sIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHdhc0hpZGRlbiA9IG1lLmhpZGRlbjtcblxuICAgICAgICBtZS5zZXRTaWxlbnQodmFsdWVzKTtcblxuICAgICAgICBpZiAoIXNpbGVudCAmJiBtZS5uZWVkc1Zkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh3YXNIaWRkZW4gJiYgIW1lLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIG1lLnNob3c/LigpOyAvLyBzaG93KCkgaXMgbm90IHBhcnQgb2YgdGhlIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1lLnByb21pc2VVcGRhdGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaWxlbnQgdmVyc2lvbiBvZiBzZXQoKSwgd2hpY2ggZG9lcyBub3QgdHJpZ2dlciBhIHZkb20gdXBkYXRlIGF0IHRoZSBlbmQuXG4gICAgICogVXNlZnVsIGZvciBiYXRjaGluZyBtdWx0aXBsZSBjb25maWcgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzPXt9XG4gICAgICovXG4gICAgc2V0U2lsZW50KHZhbHVlcz17fSkge1xuICAgICAgICB0aGlzLnNpbGVudFZkb21VcGRhdGUgPSB0cnVlO1xuICAgICAgICBzdXBlci5zZXQodmFsdWVzKTtcbiAgICAgICAgdGhpcy5zaWxlbnRWZG9tVXBkYXRlID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgc2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5zZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhBYnN0cmFjdCk7XG4iLCJpbXBvcnQgQWJzdHJhY3QgICAgICAgICBmcm9tICcuL0Fic3RyYWN0Lm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IEtleU5hdmlnYXRpb24gICAgZnJvbSAnLi4vdXRpbC9LZXlOYXZpZ2F0aW9uLm1qcyc7XG5pbXBvcnQgTG9nZ2VyICAgICAgICAgICBmcm9tICcuLi91dGlsL0xvZ2dlci5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFJlY3RhbmdsZSAgICAgICAgZnJvbSAnLi4vdXRpbC9SZWN0YW5nbGUubWpzJztcbmltcG9ydCBTdHlsZSAgICAgICAgICAgIGZyb20gJy4uL3V0aWwvU3R5bGUubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgIGZyb20gJy4uL3V0aWwvVkRvbS5tanMnO1xuaW1wb3J0IFZOb2RlVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WTm9kZS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbmNvbnN0XG4gICAgYWRkVW5pdHMgICAgICAgICAgPSB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBpc05hTih2YWx1ZSkgPyB2YWx1ZSA6IGAke3ZhbHVlfXB4YCxcbiAgICBjbG9zZXN0Q29udHJvbGxlciA9IFN5bWJvbC5mb3IoJ2Nsb3Nlc3RDb250cm9sbGVyJyksXG4gICAgbGVuZ3RoUkUgICAgICAgICAgPSAvXlxcZCtcXHcrJC87XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIENvbXBvbmVudHMgd2hpY2ggaGF2ZSBhIERPTSByZXByZXNlbnRhdGlvblxuICogQGNsYXNzIE5lby5jb21wb25lbnQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5BYnN0cmFjdFxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBBYnN0cmFjdCB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBoaWRlTW9kZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBoaWRlTW9kZXM9WydyZW1vdmVEb20nLCd2aXNpYmlsaXR5J11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBoaWRlTW9kZXMgPSBbJ3JlbW92ZURvbScsICd2aXNpYmlsaXR5J11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBhbGlnbm1lbnQgc3BlY2lmaWNhdGlvbiB0byBwb3NpdGlvbiB0aGlzIENvbXBvbmVudCByZWxhdGl2ZSB0byBzb21lIG90aGVyXG4gICAgICAgICAqIENvbXBvbmVudCwgb3IgRWxlbWVudCBvciBSZWN0YW5nbGUuIE9ubHkgYXBwbGllcyBpbiBjYXNlIGZsb2F0aW5nID0gdHJ1ZS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ30gYWxpZ25fPXtbaXNEZXNjcmlwdG9yXTogdHJ1ZSwgbWVyZ2U6ICdkZWVwJywgdmFsdWU6IHtlZGdlQWxpZ246ICd0LWInLGNvbnN0cmFpblRvOiAnZG9jdW1lbnQuYm9keSd9fVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGFsaWduXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXAnLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBlZGdlQWxpZ24gIDogJ3QtYicsXG4gICAgICAgICAgICAgICAgY29uc3RyYWluVG86ICdkb2N1bWVudC5ib2R5J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIHNlbGVjdG9ycyB0byBhcHBseSB0byB0aGUgcm9vdCBsZXZlbCBub2RlIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVtdXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hbmFnZXIuRm9jdXMgd2lsbCBjaGFuZ2UgdGhpcyBmbGFnIG9uIGZvY3VzaW4gJiBvdXQgZG9tIGV2ZW50c1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBjb250YWluc0ZvY3VzXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbnNGb2N1c186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzaWduIGEgY29tcG9uZW50IGNvbnRyb2xsZXIgdG8gdGhpcyBjb21wb25lbnQgKHBhc3MgYW4gaW1wb3J0ZWQgbW9kdWxlIG9yIHRoZSBzdHJpbmcgYmFzZWQgY2xhc3MgbmFtZSlcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fFN0cmluZ30gY29udHJvbGxlcl89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRyb2xsZXJfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgdG8gZHluYW1pY2FsbHkgaW1wb3J0IGEgRHJvcFpvbmUgbW9kdWxlICYgY3JlYXRlIGFuIGluc3RhbmNlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRyb3BwYWJsZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkcm9wcGFibGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kcmFnZ2FibGUuRHJvcFpvbmV8bnVsbH0gZHJvcFpvbmU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJvcFpvbmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGRyb3Bab25lQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBtb3VudCB0aGlzIGNvbXBvbmVudCBpbnRvIHRoZSB2aWV3cG9ydCBvdXRzaWRlIG9mIHRoZSBkb2N1bWVudCBmbG93XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGZsb2F0aW5nXG4gICAgICAgICAqL1xuICAgICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIG9uIG1vdW50XG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhhc0JlZW5Nb3VudGVkPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGhhc0JlZW5Nb3VudGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IGZvciBzdHlsZS5oZWlnaHQsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gaGVpZ2h0Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGVpZ2h0XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWwgc2V0dGluZyB0byBoaWRlIG9yIHNob3cgdGhlIGNvbXBvbmVudCBhbmRcbiAgICAgICAgICogeW91IGNhbiB1c2UgZWl0aGVyIGhpZGUoKS9zaG93KCkgb3IgY2hhbmdlIHRoaXMgY29uZmlnIGRpcmVjdGx5IHRvIGNoYW5nZSB0aGUgaGlkZGVuIHN0YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhpZGRlbl89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBoaWRkZW5fOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgZm9yIGhpZGUgYW5kIHNob3cgYW5kIGRlZmluZXMgaWYgdGhlIGNvbXBvbmVudFxuICAgICAgICAgKiBzaG91bGQgdXNlIGNzcyB2aXNpYmlsaXR5OidoaWRkZW4nIG9yIHZkb206cmVtb3ZlRG9tXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gaGlkZU1vZGVfPSdyZW1vdmVEb20nXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZU1vZGVfOiAncmVtb3ZlRG9tJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0b3AgbGV2ZWwgaW5uZXJIVE1MIG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGh0bWxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBodG1sXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gc2hvdyBhIHNwaW5uZXIgY2VudGVyZWQgaW4gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogU2V0IHRvIGEgc3RyaW5nIHRvIHNob3cgYSBtZXNzYWdlIG5leHQgdG8gYSBzcGlubmVyIGNlbnRlcmVkIGluIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW58U3RyaW5nfSBpc0xvYWRpbmc9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzTG9hZGluZ186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNpbmcgdGhlIGtleXMgY29uZmlnIHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIE5lby51dGlsLktleU5hdmlnYXRpb24uXG4gICAgICAgICAqIEBzZWUge0BsaW5rIE5lby51dGlsLktleU5hdmlnYXRpb24gS2V5TmF2aWdhdGlvbn1cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBrZXlzXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5c186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHVzZWQgaW5zaWRlIGFmdGVyU2V0SXNMb2FkaW5nKCkgdG8gZGVmaW5lIHRoZSBDU1MgZm9yIHRoZSBsb2FkaW5nIHNwaW5uZXIgaWNvblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gbG9hZGluZ1NwaW5uZXJDbHNfPVsnZmEnLCdmYS1zcGlubmVyJywnZmEtc3BpbiddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZGluZ1NwaW5uZXJDbHNfOiBbJ2ZhJywgJ2ZhLXNwaW5uZXInLCAnZmEtc3BpbiddLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1heEhlaWdodCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtYXhIZWlnaHRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtYXhIZWlnaHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1heFdpZHRoLCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG1heFdpZHRoXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWF4V2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1pbkhlaWdodCwgZGVmYXVsdHMgdG8gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfFN0cmluZ3xudWxsfSBtaW5IZWlnaHRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtaW5IZWlnaHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgZm9yIHN0eWxlLm1pbldpZHRoLCBkZWZhdWx0cyB0byBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG1pbldpZHRoXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWluV2lkdGhfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQXJyYXkgb2YgUGx1Z2luIE1vZHVsZXMgYW5kIC8gb3IgY29uZmlnIG9iamVjdHNcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gcGx1Z2luc189bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGx1Z2luc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgYSByZWZlcmVuY2UgZm9yIGFjY2Vzc2luZyB0aGUgY29tcG9uZW50IGluc2lkZSB2aWV3IGNvbnRyb2xsZXJzLlxuICAgICAgICAgKiBSZWZlcmVuY2VzIHdpbGwgYWxzbyBnZXQgbWFwcGVkIGludG8gdGhlIHZkb20gcm9vdCAoZGF0YS1yZWY6IHZhbHVlKS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHJlZmVyZW5jZV89bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXJlbmNlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2UgdGhlIHZpZXcgUmVzcG9uc2l2ZSBieSBhZGRpbmcgYWx0ZXJuYXRpdmUgY29uZmlncy5cbiAgICAgICAgICogVGhlIGRlZmluaXRpb24gaGFwcGVucyB2aWEgcmVzcG9uc2l2ZUNmZ1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHJlc3BvbnNpdmU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zaXZlXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSByb2xlIHRhZyBhdHRyaWJ1dGUgZm9yIHRoZSB2ZG9tIHJvb3QuXG4gICAgICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQWNjZXNzaWJpbGl0eS9BUklBL1JvbGVzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSByb2xlXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGZvciBzdHlsZSAnb3ZlcmZsb3c6YXV0bycuXG4gICAgICAgICAqIFNldCB0aGlzIHRvICd4JyBvciAneScgdG8gYWRkIHN0eWxlICdvdmVyZmxvdy14JyBvciAnb3ZlcmZsb3cteScgdG8gJ2F1dG8nXG4gICAgICAgICAqIE90aGVyIHRoYW4gZmFsc2UgdGhpcyB3aWxsIGFkZCBjbHMgJ25lby1zY3JvbGxhYmxlJy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbnxcInhcInxcInlcIn0gc2Nyb2xsYWJsZV89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxhYmxlXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHlsZSBhdHRyaWJ1dGVzIGFkZGVkIHRvIHRoaXMgdmRvbSByb290LiBzZWU6IGdldFZkb21Sb290KClcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBzdHlsZT17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnc2hhbGxvdycsIHZhbHVlOiBudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgc3R5bGVfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnc2hhbGxvdycsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiBwYXNzIGEgdXNlZCB0aGVtZSBkaXJlY3RseSB0byBhbnkgY29tcG9uZW50LFxuICAgICAgICAgKiB0byBzdHlsZSBzcGVjaWZpYyBjb21wb25lbnQgdHJlZXMgZGlmZmVyZW50bHkgZnJvbSB5b3VyIG1haW4gdmlldy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHRoZW1lXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWVfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hpbGUgaXQgaXMgcmVjb21tZW5kZWQgdG8gZGVmaW5lIHRhZ3MgaW5zaWRlIHRoZSB2ZG9tIG9mIGNsYXNzZXMsXG4gICAgICAgICAqIHRoaXMgc2hvcnRjdXQgZW5hYmxlcyB1cyB0byBjaGFuZ2UgdGhlIHZkb20gcm9vdCB0YWcgb24gaW5zdGFuY2UgbGV2ZWwuXG4gICAgICAgICAqIFVzZSBjYXNlczogc3dpdGNoIGEgVG9vbGJhciB0byBhIFwibmF2XCIgdGFnLCBzd2l0Y2ggYSBTaWRlTmF2IHRvIGFuIFwiYXNpZGVcIiB0YWcuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0YWdfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0YWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvcCBsZXZlbCB0ZXh0Q29udGVudCBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB0ZXh0Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgdG9vbHRpcCBjb25maWcgb2JqZWN0IG9yIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGRpc3BsYXkgdGV4dFxuICAgICAgICAgKiBTZWUgdG9vbHRpcC9CYXNlLm1qc1xuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBhIHNpbmdsZSwgc2hhcmVkIFRvb2x0aXAgaW5zdGFuY2UgaXMgdXNlZCBmb3IgYWxsIHdpZGdldHMgdGhhdCByZXF1ZXN0XG4gICAgICAgICAqIGEgdG9vbHRpcC4gSXQgcmVjb25maWd1cmVzIGl0c2VsZiBmcm9tIHRoZSB3aWRnZXQncyBkZWZpbml0aW9uIGp1c3QgYmVmb3JlIHNob3dpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgd2lkZ2V0IG5lZWRzIGl0cyBvd24gaW5zdGFuY2UgZm9yIGFueSByZWFzb24sIGluY2x1ZGUgdGhlIHByb3BlcnR5IGBvd25JbnN0YW5jZTogdHJ1ZWBcbiAgICAgICAgICogaW4gdGhlIHRvb2x0aXAgY29uZmlnIG9iamVjdC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ30gdG9vbHRpcF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHRvb2x0aXBfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkICdwcmltYXJ5JyBhbmQgb3RoZXIgYXR0cmlidXRlcyB0byBtYWtlIGl0IGFuIG91dHN0YW5kaW5nIGRlc2lnblxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdWlfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1aV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCBmb3Igc3R5bGUud2lkdGgsIGRlZmF1bHRzIHRvIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxTdHJpbmd8bnVsbH0gd2lkdGhfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3aWR0aF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXXxudWxsfSB3cmFwcGVyQ2xzXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd3JhcHBlckNsc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3AgbGV2ZWwgc3R5bGUgYXR0cmlidXRlcy4gVXNlZnVsIGluIGNhc2UgZ2V0VmRvbVJvb3QoKSBkb2VzIG5vdCBwb2ludCB0byB0aGUgdG9wIGxldmVsIERPTSBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gd3JhcHBlclN0eWxlXz17W2lzRGVzY3JpcHRvcl06IHRydWUsIG1lcmdlOiAnc2hhbGxvdycsIHZhbHVlOiBudWxsfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdyYXBwZXJTdHlsZV86IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdzaGFsbG93JyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmRvbSBtYXJrdXAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tPXt9XG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbToge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBDb21wb25lbnQgaXMgZnVsbHkgdmlzaWJsZSwgdGhhdCBpcyBpdCBpcyBub3QgaGlkZGVuIGFuZCBoYXMgbm8gaGlkZGVuIGFuY2VzdG9yc1xuICAgICAqL1xuICAgIGdldCBpc1Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdW50ZWQgJiYgIXRoaXMuaGlkZGVuICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNWaXNpYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0dGVyIHdpbGwgaGFuZGxlIHZkb20gdXBkYXRlcyBhdXRvbWF0aWNhbGx5XG4gICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tPXRoaXMuX3Zkb21cbiAgICAgKi9cbiAgICBnZXQgdmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zkb21cbiAgICB9XG4gICAgc2V0IHZkb20odmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZnRlclNldFZkb20odmFsdWUsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBjbHMgdG8gdGhlIHZkb21Sb290XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgYWRkQ2xzKHZhbHVlKSB7XG4gICAgICAgIGxldCB7Y2xzfSA9IHRoaXM7XG5cbiAgICAgICAgTmVvQXJyYXkuYWRkKGNscywgdmFsdWUpO1xuICAgICAgICB0aGlzLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVpdGhlciBhIHN0cmluZyBsaWtlICdjb2xvcjogcmVkOyBiYWNrZ3JvdW5kLWNvbG9yOiBibHVlOydcbiAgICAgKiBvciBhbiBvYmplY3QgY29udGFpbmluZyBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFsbCBzdHlsZXMgb2YgdGhpcy5lbFxuICAgICAqL1xuICAgIGFkZFN0eWxlKHZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICBOZW8uY3JlYXRlU3R5bGVPYmplY3QodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvOiBhZGQgYSBjaGVjayBpZiBzb21ldGhpbmcgaGFzIGNoYW5nZWRcblxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA9IE9iamVjdC5hc3NpZ24odGhpcy5zdHlsZSwgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IHdyYXBwZXJDbHMgdG8gdGhlIHRvcCBsZXZlbCBub2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICovXG4gICAgYWRkV3JhcHBlckNscyh2YWx1ZSkge1xuICAgICAgICBsZXQge3dyYXBwZXJDbHN9ID0gdGhpcztcblxuICAgICAgICBOZW9BcnJheS5hZGQod3JhcHBlckNscywgdmFsdWUpO1xuICAgICAgICB0aGlzLndyYXBwZXJDbHMgPSB3cmFwcGVyQ2xzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjbHMgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlID0gb2xkVmFsdWUgfHwgW107XG5cbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHZkb20gICAgID0gbWUudmRvbSxcbiAgICAgICAgICAgIHZkb21Sb290ID0gbWUuZ2V0VmRvbVJvb3QoKSxcbiAgICAgICAgICAgIGNscztcblxuICAgICAgICBpZiAodmRvbSAhPT0gdmRvbVJvb3QpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSB1c2luZyBhIHdyYXBwZXIgbm9kZVxuICAgICAgICAgICAgdmRvbVJvb3QuY2xzID0gWy4uLnZhbHVlXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtZXJnZSBjaGFuZ2VzXG4gICAgICAgICAgICBjbHMgPSBOZW9BcnJheS51bmlvbihtZS53cmFwcGVyQ2xzLCB2YWx1ZSk7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBOZW9BcnJheS5kaWZmZXJlbmNlKG9sZFZhbHVlLCB2YWx1ZSkpO1xuICAgICAgICAgICAgdmRvbS5jbHMgPSBjbHNcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkaXNhYmxlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERpc2FibGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXlbdmFsdWUgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMsICduZW8tZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkcm9wcGFibGUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREcm9wcGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmICFtZS5kcm9wWm9uZSkge1xuICAgICAgICAgICAgaW1wb3J0KCcuLi9kcmFnZ2FibGUvRHJvcFpvbmUubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmRyb3Bab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZSA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyICAgOiBtZSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgICAgICAuLi5tZS5kcm9wWm9uZUNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBoZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRIZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2hlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaGlkZGVuIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SGlkZGVuKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgc3RhdGUgPSB2YWx1ZSA/ICdoaWRlJyA6ICdzaG93JztcblxuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBtZS5oaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScpIHtcbiAgICAgICAgICAgIG1lLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIHx8IG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lW3N0YXRlXSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBtZS5yZXZlcnRGb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWUuZmlyZShzdGF0ZSwge2lkOiBtZS5pZH0pO1xuICAgICAgICBtZS5maXJlKCdoaWRkZW5DaGFuZ2UnLCB7aWQ6IG1lLmlkLCBvbGRWYWx1ZSwgdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaHRtbCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SHRtbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnaHRtbCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldElkKHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ2lkJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc0xvYWRpbmcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzTG9hZGluZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIHx8IG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHt3cmFwcGVyQ2xzLCB2ZG9tfSA9IG1lLFxuICAgICAgICAgICAgICAgIG1hc2tJbmRleDtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmRvbS5jbikge1xuICAgICAgICAgICAgICAgIG1hc2tJbmRleCA9IHZkb20uY24uZmluZExhc3RJbmRleChjID0+IGMuY2xzPy5pbmNsdWRlcygnbmVvLWxvYWQtbWFzaycpKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbG9hZCBtYXNrXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbS5jbi5zcGxpY2UobWFza0luZGV4LCAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2ZG9tLmNuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20uY24gPSBbXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZkb20uY24ucHVzaChtZS5jcmVhdGVMb2FkaW5nTWFzayh2YWx1ZSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5lb0FycmF5LnRvZ2dsZSh3cmFwcGVyQ2xzLCAnbmVvLW1hc2tlZCcsIHZhbHVlKTtcbiAgICAgICAgICAgIG1lLnNldCh7dmRvbSwgd3JhcHBlckNsc30pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1heEhlaWdodCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhIZWlnaHQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1heEhlaWdodCA9IGFkZFVuaXRzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnbWF4SGVpZ2h0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXhXaWR0aCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNYXhXaWR0aCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmVkTWF4V2lkdGggPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21heFdpZHRoJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtaW5IZWlnaHQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluSGVpZ2h0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZWRNaW5IZWlnaHQgPSBhZGRVbml0cyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlVmRvbVJvb3RLZXkoJ21pbkhlaWdodCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWluV2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWluV2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZE1pbldpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdtaW5XaWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHsgLy8gbW91bnRcbiAgICAgICAgICAgICAgICBtZS5oYXNCZWVuTW91bnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobWUuZmxvYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWxpZ25UbygpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvY3VzIHdpbGwgYmUgcHVzaGVkIGludG8gdGhlIGZpcnN0IGlucHV0IGZpZWxkIG9yIG90aGVyIGZvY3VzYWJsZSBpdGVtXG4gICAgICAgICAgICAgICAgICAgIG1lLmZvY3VzKG1lLmlkLCB0cnVlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ21vdW50ZWQnLCBtZS5pZCk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB1bm1vdW50XG4gICAgICAgICAgICAgICAgbWUucmV2ZXJ0Rm9jdXMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByZWZlcmVuY2UgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJlZmVyZW5jZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgnZGF0YS1yZWYnLCB2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlc3BvbnNpdmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGFmdGVyU2V0UmVzcG9uc2l2ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmdldFBsdWdpbigncmVzcG9uc2l2ZScpKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbW9kdWxlICA9IGF3YWl0IGltcG9ydChgLi4vLi4vc3JjL3BsdWdpbi9SZXNwb25zaXZlLm1qc2ApLFxuICAgICAgICAgICAgICAgIHBsdWdpbnMgPSBtZS5wbHVnaW5zIHx8IFtdO1xuXG4gICAgICAgICAgICBwbHVnaW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IG1vZHVsZS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIGFwcE5hbWU6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5wbHVnaW5zID0gcGx1Z2luc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSByb2xlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSb2xlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCdyb2xlJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBzY3JvbGxhYmxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNjcm9sbGFibGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IG9sZE92ZXJmbG93S2V5ID0gJ292ZXJmbG93JztcblxuICAgICAgICAgICAgaWYgKCFOZW8uaXNCb29sZWFuKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9sZE92ZXJmbG93S2V5ICs9IE5lby5jYXBpdGFsaXplKG9sZFZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5yZW1vdmVTdHlsZShbb2xkT3ZlcmZsb3dLZXldKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFOZW8uaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBvdmVyZmxvd0tleSA9ICdvdmVyZmxvdyc7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhTmVvLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd0tleSArPSBOZW8uY2FwaXRhbGl6ZSh2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUuYWRkU3R5bGUob3ZlcmZsb3dLZXkgKyAnOmF1dG8nKTtcbiAgICAgICAgICAgICAgICBtZS5hZGRDbHMoJ25lby1zY3JvbGxhYmxlJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUucmVtb3ZlQ2xzKCduZW8tc2Nyb2xsYWJsZScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHN0eWxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFN0eWxlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoISghdmFsdWUgJiYgb2xkVmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0YWcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFRhZyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5jaGFuZ2VWZG9tUm9vdEtleSgndGFnJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0aGVtZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSB8fCBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHtjbHN9ICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlICYmIGNscy5pbmNsdWRlcyhvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIGFkZCBhIERPTSBiYXNlZCBDU1Mgc2VsZWN0b3IsIGluIGNhc2UgdGhlIHRoZW1lIGlzIGFscmVhZHkgaW5oZXJpdGVkXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG1lLnBhcmVudD8udGhlbWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJiBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIG1lLmNscyA9IGNsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0ZXh0IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCd0ZXh0JywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB0b29sdGlwIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VG9vbHRpcCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3k/LigpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKE5lby5ucygnTmVvLnRvb2x0aXAuQmFzZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4uL3Rvb2x0aXAvQmFzZS5tanMnKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKHZhbHVlKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3Igc3R5bGluZyBwdXJwb3NlcyBvbmx5LlxuICAgICAqIFRvIGRlZmluZSBidXR0b24gc3R5bGVzIG9yIGNvbXBvbmVudCBzdHlsZXMsXG4gICAgICogdGhpcyB3aWxsIGFkZCBhIGNzcyBjbGFzczogbmVvLW50eXBlLXZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIGFmdGVyU2V0VWkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgY2xzID0gbWUuY2xzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgYG5lby0ke21lLm50eXBlfS0ke29sZFZhbHVlfWApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCBgbmVvLSR7bWUubnR5cGV9LSR7dmFsdWV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNscyA9IGNsc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2lkdGggY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2lkdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlZFdpZHRoID0gYWRkVW5pdHModmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZVZkb21Sb290S2V5KCd3aWR0aCcsIHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IGNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXI7XG5cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3cmFwcGVyQ2xzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V3JhcHBlckNscyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgPSBvbGRWYWx1ZSB8fCBbXTtcbiAgICAgICAgdmFsdWUgICAgPSB2YWx1ZSAgICB8fCBbXTtcblxuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3Zkb219ICAgPSBtZSxcbiAgICAgICAgICAgIHZkb21Sb290ID0gbWUuZ2V0VmRvbVJvb3QoKSxcbiAgICAgICAgICAgIGNscyAgICAgID0gdmRvbS5jbHMgfHwgW107XG5cbiAgICAgICAgaWYgKHZkb20gPT09IHZkb21Sb290KSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1lcmdlIGNoYW5nZXNcbiAgICAgICAgICAgIGNscyA9IE5lb0FycmF5LnVuaW9uKGNscywgdmFsdWUpO1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgTmVvQXJyYXkuZGlmZmVyZW5jZShvbGRWYWx1ZSwgdmFsdWUpKTtcbiAgICAgICAgICAgIHZkb20uY2xzID0gY2xzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIGEgd3JhcHBlciA9PiBjbHMgJiB3cmFwcGVyQ2xzIHNoYXJlIHRoZSBzYW1lIG5vZGVcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyB2YWx1ZSA6IFtdO1xuXG4gICAgICAgICAgICBvbGRWYWx1ZSAmJiBOZW9BcnJheS5yZW1vdmUoY2xzLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICBOZW9BcnJheS5hZGQoY2xzLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHZkb20uY2xzID0gY2xzXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd3JhcHBlclN0eWxlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdyYXBwZXJTdHlsZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCEoIXZhbHVlICYmIG9sZFZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWducyB0aGUgdG9wIGxldmVsIG5vZGUgaW5zaWRlIHRoZSBtYWluIHRocmVhZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjPXt9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgYWxpZ25UbyhzcGVjPXt9KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBhbGlnbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5tZS5hbGlnbixcbiAgICAgICAgICAgICAgICAuLi5zcGVjLFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRGbGV4ICAgICA6IG1lLmNvbmZpZ3VyZWRGbGV4LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRXaWR0aCAgICA6IG1lLmNvbmZpZ3VyZWRXaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkSGVpZ2h0ICAgOiBtZS5jb25maWd1cmVkSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNaW5XaWR0aCA6IG1lLmNvbmZpZ3VyZWRNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkTWluSGVpZ2h0OiBtZS5jb25maWd1cmVkTWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWRNYXhXaWR0aCA6IG1lLmNvbmZpZ3VyZWRNYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmVkTWF4SGVpZ2h0OiBtZS5jb25maWd1cmVkTWF4SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICAgICAgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhbGlnbi50YXJnZXQpIHtcbiAgICAgICAgICAgIGF3YWl0IE5lby5tYWluLkRvbUFjY2Vzcy5hbGlnbihhbGlnbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgY2xzIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0Q2xzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFsuLi52YWx1ZV0gOiBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgc3R5bGUgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldFN0eWxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7Li4udmFsdWV9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSB3cmFwcGVyQ2xzIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0V3JhcHBlckNscyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBbLi4udmFsdWVdIDogW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIHdyYXBwZXJTdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0V3JhcHBlclN0eWxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7Li4uT2JqZWN0LmFzc2lnbih0aGlzLnZkb20uc3R5bGUgfHwge30sIHZhbHVlKX1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBhbGlnbiBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRBbGlnbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBKdXN0IGEgc2ltcGxlICd0LWInXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBlZGdlQWxpZ246IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjbHMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDbHModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW9BcnJheS51bmlvbih2YWx1ZSB8fCBbXSwgdGhpcy5iYXNlQ2xzLCB0aGlzLmdldEJhc2VDbGFzcygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBjb250cm9sbGVyIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQ3JlYXRlcyBhIGNvbnRyb2xsZXIuQ29tcG9uZW50IGluc3RhbmNlIGlmIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRDb250cm9sbGVyKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgJ05lby5jb250cm9sbGVyLkNvbXBvbmVudCcsIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgd2luZG93SWQgOiB0aGlzLndpbmRvd0lkXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZG9tTGlzdGVuZXJzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERvbUxpc3RlbmVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgaGlkZU1vZGUgY29uZmlnIGdldHMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldEhpZGVNb2RlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnaGlkZU1vZGUnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGtleXMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBDcmVhdGVzIGEgS2V5TmF2aWdhdGlvbiBpbnN0YW5jZSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge05lby51dGlsLktleU5hdmlnYXRpb258bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0S2V5cyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBLZXlOYXZpZ2F0aW9uLCB7XG4gICAgICAgICAgICAgICAga2V5RG93bkV2ZW50QnViYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleXMgICAgICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBwbHVnaW5zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8ucGx1Z2luLkJhc2VbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0UGx1Z2lucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlW2luZGV4XSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZShpdGVtLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzaWxlbnRWZG9tVXBkYXRlIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTaWxlbnRWZG9tVXBkYXRlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBOZW8uaXNOdW1iZXIob2xkVmFsdWUpID8gKG9sZFZhbHVlICsgMSkgOiAxXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKE5lby5pc051bWJlcihvbGRWYWx1ZSkgJiYgb2xkVmFsdWUgPiAwKSA/IChvbGRWYWx1ZSAtIDEpIDogMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHVwZGF0ZURlcHRoIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0VXBkYXRlRGVwdGgodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvbGRWYWx1ZSA9PT0gLTEgfHwgdmFsdWUgPT09IC0xID8gLTEgOiBNYXRoLm1heCh2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWUgb2YgYSB2ZG9tIG9iamVjdCBhdHRyaWJ1dGUgb3IgcmVtb3ZlcyBpdCBpbiBjYXNlIGl0IGhhcyBubyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fE51bWJlcnxPYmplY3R8U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICovXG4gICAgY2hhbmdlVmRvbVJvb3RLZXkoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICByb290ID0gbWUuZ2V0VmRvbVJvb3QoKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJvb3Rba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgcm9vdFtrZXldXG4gICAgICAgIH1cblxuICAgICAgICBtZS51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluIGNhc2UgeW91IG5lZWQgZGlmZmVyZW50IG1hc2sgbWFya3Vwcy5cbiAgICAgKiBUaGUgcmVtb3ZhbCBsb2dpYyByZWxpZXMgb24gdGhlIHRvcCBsZXZlbCBub2RlIGhhdmluZyB0aGUgY2xzICduZW8tbG9hZC1tYXNrJ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IGxvYWRpbmdNZXNzYWdlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdmRvbVxuICAgICAqL1xuICAgIGNyZWF0ZUxvYWRpbmdNYXNrKGxvYWRpbmdNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbHM6IFsnbmVvLWxvYWQtbWFzayddLFxuICAgICAgICAgICAgY24gOiBbe1xuICAgICAgICAgICAgICAgIGNsczogWyduZW8tbG9hZC1tYXNrLWJvZHknXSxcbiAgICAgICAgICAgICAgICBjbiA6IFt7XG4gICAgICAgICAgICAgICAgICAgIGNsczogdGhpcy5sb2FkaW5nU3Bpbm5lckNsc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzICAgICAgOiBbJ25lby1sb2FkaW5nLW1lc3NhZ2UnXSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRG9tOiAhTmVvLmlzU3RyaW5nKGxvYWRpbmdNZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCAgICAgOiBsb2FkaW5nTWVzc2FnZVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgdG9vbHRpcCBpbnN0YW5jZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZVRvb2x0aXAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZS5vd25JbnN0YW5jZSkge1xuICAgICAgICAgICAgbWUuX3Rvb2x0aXAgPSBOZW8uY3JlYXRlKCdOZW8udG9vbHRpcC5CYXNlJywge1xuICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudElkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCAgIDogbWUud2luZG93SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5fdG9vbHRpcCA9IHZhbHVlO1xuICAgICAgICAgICAgTmVvLnRvb2x0aXAuQmFzZS5jcmVhdGVTaW5nbGV0b24obWUuYXBwKTtcbiAgICAgICAgICAgIG1lLmFkZENscygnbmVvLXVzZXMtc2hhcmVkLXRvb2x0aXAnKTtcbiAgICAgICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIHRoaXMgaW5zdGFuY2UgZnJvbSB0aGUgQ29tcG9uZW50TWFuYWdlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlUGFyZW50VmRvbT1mYWxzZSB0cnVlIHRvIHJlbW92ZSB0aGUgY29tcG9uZW50IGZyb20gdGhlIHBhcmVudCB2ZG9tID0+IHJlYWwgZG9tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnQ9ZmFsc2UgdHJ1ZSB0byB1cGRhdGUgdGhlIHZkb20gc2lsZW50bHkgKHVzZWZ1bCBmb3IgZGVzdHJveWluZyBtdWx0aXBsZSBjaGlsZCBpdGVtcyBpbiBhIHJvdylcbiAgICAgKiB0b2RvOiB1bnJlZ2lzdGVyIGV2ZW50c1xuICAgICAqL1xuICAgIGRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbT1mYWxzZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudCwgcGFyZW50SWR9ID0gbWUsXG4gICAgICAgICAgICBwYXJlbnRWZG9tO1xuXG4gICAgICAgIG1lLnJldmVydEZvY3VzKCk7XG5cbiAgICAgICAgbWUuY29udHJvbGxlciA9IG51bGw7IC8vIHRyaWdnZXJzIGRlc3Ryb3koKVxuXG4gICAgICAgIG1lLnJlZmVyZW5jZSAmJiBtZS5nZXRDb250cm9sbGVyKCk/LnJlbW92ZVJlZmVyZW5jZShtZSk7IC8vIHJlbW92ZSBvd24gcmVmZXJlbmNlIGZyb20gcGFyZW50IGNvbnRyb2xsZXJzXG5cbiAgICAgICAgbWUucGx1Z2lucz8uZm9yRWFjaChwbHVnaW4gPT4ge1xuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3koKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXBkYXRlUGFyZW50VmRvbSAmJiBwYXJlbnRJZCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudElkID09PSAnZG9jdW1lbnQuYm9keScpIHtcbiAgICAgICAgICAgICAgICBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIHthY3Rpb246ICdyZW1vdmVOb2RlJywgaWQ6IG1lLnZkb20uaWR9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRWZG9tID0gcGFyZW50LnZkb207XG5cbiAgICAgICAgICAgICAgICBWRG9tVXRpbC5yZW1vdmVWZG9tQ2hpbGQocGFyZW50VmRvbSwgbWUudmRvbS5pZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50W3NpbGVudCA/ICdfdmRvbScgOiAndmRvbSddID0gcGFyZW50VmRvbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIFdlIGRvIHdhbnQgdG8gcHJldmVudCBkZWxheWVkIGNhbGxzIGFmdGVyIGEgY29tcG9uZW50IGluc3RhbmNlIGdvdCBkZXN0cm95ZWQuXG4gICAgICAgIG1lLm9uRm9jdXNMZWF2ZSA9IE5lby5lbXB0eUZuO1xuICAgICAgICBtZS51bm1vdW50ICAgICAgPSBOZW8uZW1wdHlGblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBOZW8ubWFuYWdlci5Db21wb25lbnQuZG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5GaXJzdE1hdGNoPXRydWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IFRoZSBtYXRjaGluZyBpbnN0YW5jZSBvciBudWxsXG4gICAgICovXG4gICAgZG93bihjb25maWcsIHJldHVybkZpcnN0TWF0Y2g9dHJ1ZSkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5kb3duKHRoaXMsIGNvbmZpZywgcmV0dXJuRmlyc3RNYXRjaClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBmb2N1cygpIG9uIHRoZSB0b3AgbGV2ZWwgRE9NIG5vZGUgb2YgdGhpcyBjb21wb25lbnQgb3Igb24gYSBnaXZlbiBub2RlIHZpYSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZD10aGlzLmlkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjaGlsZHJlbj1mYWxzZVxuICAgICAqL1xuICAgIGZvY3VzKGlkPXRoaXMuaWQsIGNoaWxkcmVuPWZhbHNlKSB7XG4gICAgICAgIE5lby5tYWluLkRvbUFjY2Vzcy5mb2N1cyh7Y2hpbGRyZW4sIGlkLCB3aW5kb3dJZDogdGhpcy53aW5kb3dJZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIGR5bmFtaWMgdmFsdWVzIGludG8gdGhpcy5jbHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0QmFzZUNsYXNzKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5mbG9hdGluZykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ25lby1mbG9hdGluZycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzLmNvbnRyb2xsZXIgb3IgdGhlIGNsb3Nlc3QgcGFyZW50IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyKG50eXBlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBjb250cm9sbGVyO1xuXG4gICAgICAgIGlmICghbnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZVtjbG9zZXN0Q29udHJvbGxlcl07XG5cbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRyb2xsZXIgPSBtZS5nZXRDb25maWdJbnN0YW5jZUJ5TnR5cGUoJ2NvbnRyb2xsZXInLCBudHlwZSk7XG5cbiAgICAgICAgaWYgKCFudHlwZSkge1xuICAgICAgICAgICAgbWVbY2xvc2VzdENvbnRyb2xsZXJdID0gY29udHJvbGxlclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBpZD10aGlzLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdpbmRvd0lkPXRoaXMud2luZG93SWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOZW8udXRpbC5SZWN0YW5nbGV8TmVvLnV0aWwuUmVjdGFuZ2xlW10+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldERvbVJlY3QoaWQ9dGhpcy5pZCwgd2luZG93SWQ9dGhpcy53aW5kb3dJZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgTmVvLm1haW4uRG9tQWNjZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7aWQsIHdpbmRvd0lkfSk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAocmVjdCA9PiBSZWN0YW5nbGUuY2xvbmUocmVjdCkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVjdGFuZ2xlLmNsb25lKHJlc3VsdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmVudCBjb21wb25lbnRzIGFzIGFuIGFycmF5XG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGdldFBhcmVudHMoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLmdldFBhcmVudHModGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7TmVvLnBsdWdpbi5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG9wdHMpIHtcbiAgICAgICAgaWYgKE5lby5pc1N0cmluZyhvcHRzKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRzLnN0YXJ0c1dpdGgoJ3BsdWdpbi0nKSkge1xuICAgICAgICAgICAgICAgIG9wdHMgPSAncGx1Z2luLScgKyBvcHRzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdHMgPSB7bnR5cGU6IG9wdHN9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgaGFzTWF0Y2g7XG5cbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgbWUucGx1Z2lucyB8fCBbXSkge1xuICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbltrZXldICE9PSBvcHRzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9XG4gICAgICovXG4gICAgZ2V0UmVmZXJlbmNlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd24oe3JlZmVyZW5jZTogdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhbGtzIHVwIHRoZSB2ZG9tIHRyZWUgYW5kIHJldHVybnMgdGhlIGNsb3Nlc3QgdGhlbWUgZm91bmRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFRoZW1lKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB0aGVtZU1hdGNoID0gJ25lby10aGVtZS0nLFxuICAgICAgICAgICAgbWFpblZpZXcsIHBhcmVudE5vZGVzO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBtZS5jbHMgfHwgW10pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnN0YXJ0c1dpdGgodGhlbWVNYXRjaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFpblZpZXcgPSBtZS5hcHA/Lm1haW5WaWV3O1xuXG4gICAgICAgIGlmIChtYWluVmlldykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZXMgPSBWRG9tVXRpbC5nZXRQYXJlbnROb2RlcyhtYWluVmlldy52ZG9tLCBtZS5pZCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBwYXJlbnROb2RlcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLmNscyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydHNXaXRoKHRoZW1lTWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5lby5jb25maWcudGhlbWVzPy5bMF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBjb21wb25lbnQuXG4gICAgICogaGlkZU1vZGU6ICdyZW1vdmVEb20nICB1c2VzIHZkb20gcmVtb3ZlRG9tLlxuICAgICAqIGhpZGVNb2RlOiAndmlzaWJpbGl0eScgdXNlcyBjc3MgdmlzaWJpbGl0eS5cbiAgICAgKiBJZiBoaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScgeW91IGNhbiBwYXNzIGEgdGltZW91dCBmb3IgY3VzdG9tIGNzcyBjbGFzcyBoaWRpbmcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAgICAgKi9cbiAgICBoaWRlKHRpbWVvdXQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGlkZU1vZGUgIT09ICd2aXNpYmlsaXR5Jykge1xuICAgICAgICAgICAgbGV0IHJlbW92ZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChtZS5wYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZURlcHRoID0gMjtcbiAgICAgICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZSgpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudW5tb3VudCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQodGltZW91dCkudGhlbihyZW1vdmVGbilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRm4oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gbWUuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBtZS5zdHlsZSA9IHN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICBtZS5faGlkZGVuID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5hdXRvSW5pdFZub2RlICYmIHRoaXMuaW5pdFZub2RlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGNvbXBvbmVudCBvciBhbnkgb2YgaXRzIHBhcmVudHMgaXMgZmxvYXRpbmdcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Zsb2F0aW5nKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5mbG9hdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAgbWUucGFyZW50LmZsb2F0aW5nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XG4gICAgICovXG4gICAgYXN5bmMgbWVhc3VyZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZW5ndGhSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxldCB7aWQsIHdpbmRvd0lkfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhd2FpdCBOZW8ubWFpbi5Eb21BY2Nlc3MubWVhc3VyZSh7aWQsIHZhbHVlLCB3aW5kb3dJZH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIG9yZGVyIGNvbmZpZ3MgYXJlIGFwcGxpZWQgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyguLi5hcmdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBzdXBlci5tZXJnZUNvbmZpZyguLi5hcmdzKSxcbiAgICAgICAgICAgIHZkb20gICA9IGNvbmZpZy52ZG9tIHx8IGNvbmZpZy5fdmRvbSB8fCB7fTtcblxuICAgICAgICAvLyBJdCBzaG91bGQgYmUgcG9zc2libGUgdG8gbW9kaWZ5IHJvb3QgbGV2ZWwgdmRvbSBhdHRyaWJ1dGVzIG9uIGluc3RhbmNlIGxldmVsLlxuICAgICAgICAvLyBOb3RlIHRoYXQgdmRvbSBpcyBub3QgYSByZWFsIGNvbmZpZywgYnV0IGltcGxlbWVudGVkIHZpYSBnZXQoKSAmIHNldCgpLlxuICAgICAgICB0aGlzLl92ZG9tID0gTmVvLmNsb25lKHsuLi52ZG9tLCAuLi50aGlzLl92ZG9tIHx8IHt9fSwgdHJ1ZSk7XG5cbiAgICAgICAgZGVsZXRlIGNvbmZpZy5fdmRvbTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy52ZG9tO1xuXG4gICAgICAgIHJldHVybiBjb25maWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW4gZ2V0IGNhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGdvdCB2bm9kZUluaXRpYWxpemVkLiBTZWUgdGhlIGF1dG9Nb3VudCBjb25maWcgYXMgd2VsbC5cbiAgICAgKiBXZSBoYXZlIGRlY2lkZWQgdG8gYWx3YXlzIGZvcmNlIGEgbmV3IGluaXRWbm9kZSh0cnVlKSBjYWxsIGhlcmUuXG4gICAgICogUmF0aW9uYWxlOlxuICAgICAqIDEuIFRoZSBvdmVyaGVhZCBvZiB0cmFja2luZyBoYXNVbm1vdW50ZWRWZG9tQ2hhbmdlcyBvbiBldmVyeSB2ZG9tIHVwZGF0ZSBpcyByZW1vdmVkLlxuICAgICAqIDIuIFRoZSBlZGdlIGNhc2Ugb2YgbW91bnRpbmcgYSBwcmUtY2FsY3VsYXRlZCBidXQgdW50b3VjaGVkIHZub2RlIHRyZWUgaXMgPCAxJS5cbiAgICAgKiAzLiBUaGUgY29zdCBvZiByZS1nZW5lcmF0aW5nIHRoZSB2bm9kZSB0cmVlIGlzIGxvdyBlbm91Z2ggdG8ganVzdGlmeSB0aGUgcm9idXN0bmVzcyBhbmQgc2ltcGxpY2l0eS5cbiAgICAgKiA0LiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgRE9NIGlzIGFsd2F5cyBtb3VudGVkIHdpdGggdGhlIG1vc3QgdXAtdG8tZGF0ZSB2ZG9tIHN0YXRlLlxuICAgICAqL1xuICAgIGFzeW5jIG1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0Vm5vZGUodHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcbiAgICAgICAgdGhpcy5rZXlzPy5yZWdpc3Rlcih0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TY3JvbGxDYXB0dXJlKGRhdGEpIHtcbiAgICAgICAgc3VwZXIub25TY3JvbGxDYXB0dXJlKGRhdGEpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLl92ZG9tKSB7XG4gICAgICAgICAgICBsZXQgdmRvbU5vZGUgPSBWRG9tVXRpbC5nZXRCeUlkKG1lLl92ZG9tLCBkYXRhLnRhcmdldC5pZCk7XG5cbiAgICAgICAgICAgIGlmICh2ZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgIHZkb21Ob2RlLnNjcm9sbFRvcCAgPSBkYXRhLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB2ZG9tTm9kZS5zY3JvbGxMZWZ0ID0gZGF0YS5zY3JvbGxMZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXNFbnRlcihkYXRhKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBoaWRkZW4sIG9yIHVubW91bnRlZCB3aGlsZSB3ZSBzdGlsbCBjb250YWluIGZvY3VzLCB3ZSBoYXZlIHRvIHJldmVydFxuICAgICAgICAvLyBmb2N1cyB0byB3aGVyZSBpdCBjYW1lIGZyb20gaWYgcG9zc2libGVcbiAgICAgICAgdGhpcy5mb2N1c0VudGVyRGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZm9jdXNFbnRlckRhdGEgPSBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJ5IG1hbmFnZXIuRm9jdXNcbiAgICAgKiBAbmFtZSBvbkZvY3VzRW50ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgbWFuYWdlci5Gb2N1c1xuICAgICAqIEBuYW1lIG9uRm9jdXNMZWF2ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBtYW5hZ2VyLkZvY3VzXG4gICAgICogQG5hbWUgb25Gb2N1c01vdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBvcHRzLm5ld1BhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgb3B0cy5vbGRQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjbHMgZnJvbSB0aGUgdmRvbVJvb3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICByZW1vdmVDbHModmFsdWUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuY2xzO1xuXG4gICAgICAgIE5lb0FycmF5LnJlbW92ZShjbHMsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgc3RyaW5nIGxpa2UgJ2NvbG9yJyBvciBhbiBhcnJheSBjb250YWluaW5nIHN0eWxlIGF0dHJpYnV0ZXMgdG8gcmVtb3ZlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHZhbHVlIGNhbWVsQ2FzZSBvbmx5XG4gICAgICogQHJldHVybnMge09iamVjdH0gYWxsIHN0eWxlcyBvZiB0aGlzLmVsXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgIH1cblxuICAgICAgICBsZXQge3N0eWxlfSAgPSB0aGlzLFxuICAgICAgICAgICAgZG9VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlW2tleV07XG4gICAgICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkb1VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJldmVydEZvY3VzKCkge1xuICAgICAgICBsZXQgcmVsYXRlZFRhcmdldCA9IHRoaXMuZm9jdXNFbnRlckRhdGE/LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNGb2N1cyAmJiByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICBOZW8uZ2V0Q29tcG9uZW50KHJlbGF0ZWRUYXJnZXQuaWQpPy5mb2N1cygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBjb21wb25lbnQuXG4gICAgICogaGlkZU1vZGU6ICdyZW1vdmVEb20nICB1c2VzIHZkb20gcmVtb3ZlRG9tLlxuICAgICAqIGhpZGVNb2RlOiAndmlzaWJpbGl0eScgdXNlcyBjc3MgdmlzaWJpbGl0eS5cbiAgICAgKi9cbiAgICBzaG93KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5oaWRlTW9kZSAhPT0gJ3Zpc2liaWxpdHknKSB7XG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgICAgIGlmIChtZS5zaWxlbnRWZG9tVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5wYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZURlcHRoID0gLTE7XG4gICAgICAgICAgICAgICAgbWUucGFyZW50LnVwZGF0ZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICFtZS5tb3VudGVkICYmIG1lLmluaXRWbm9kZSh0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gbWUuc3R5bGU7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGUudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIG1lLnN0eWxlID0gc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLl9oaWRkZW4gPSBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBhIGNscyBpbnNpZGUgdGhlIHZkb21Sb290IG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthZGRdIFVzZSB0aGlzIHBhcmFtIHRvIGVuZm9yY2UgYW4gYWRkKCkgb3IgcmVtb3ZlKCkgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHRvZ2dsZUNscyh2YWx1ZSwgYWRkKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLmNscztcblxuICAgICAgICBOZW9BcnJheS50b2dnbGUoY2xzLCB2YWx1ZSwgYWRkKTtcbiAgICAgICAgdGhpcy5jbHMgPSBjbHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjb21wb25lbnQgRE9NXG4gICAgICovXG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS52ZG9tLnJlbW92ZURvbSA9IHRydWU7XG5cbiAgICAgICAgbWUuX2hpZGRlbiA9IHRydWU7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgbWUubW91bnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIE5lby5hcHBseURlbHRhcyhtZS53aW5kb3dJZCwge2FjdGlvbjogJ3JlbW92ZU5vZGUnLCBpZDogbWUudmRvbS5pZH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgZm9yIE5lby5tYW5hZ2VyLkNvbXBvbmVudC51cFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gY29uZmlnXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBUaGUgbWF0Y2hpbmcgaW5zdGFuY2Ugb3IgbnVsbFxuICAgICAqL1xuICAgIHVwKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci51cCh0aGlzLmlkLCBjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVTdHlsZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2ZG9tfSAgID0gbWUsXG4gICAgICAgICAgICB2ZG9tUm9vdCA9IG1lLmdldFZkb21Sb290KCk7XG5cbiAgICAgICAgaWYgKHZkb20gIT09IHZkb21Sb290KSB7XG4gICAgICAgICAgICB2ZG9tICAgIC5zdHlsZSA9IG1lLndyYXBwZXJTdHlsZTtcbiAgICAgICAgICAgIHZkb21Sb290LnN0eWxlID0gbWUuc3R5bGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZkb20uc3R5bGUgPSB7Li4ubWUud3JhcHBlclN0eWxlLCAuLi5tZS5zdHlsZX1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB5b3UgYXJlIHN1cmUgYSBET01SZWN0IGV4aXN0cywgdXNlIGdldERvbVJlY3QoKVxuICAgICAqIE90aGVyd2lzZSB5b3UgY2FuIHdhaXQgZm9yIGl0IHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlOlxuICAgICAqICAgICBhd2FpdCB0aGlzLmluaXRWbm9kZSh0cnVlKTtcbiAgICAgKiAgICAgYXdhaXQgdGhpcy53YWl0Rm9yRG9tUmVjdCgpO1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBvcHRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIG9wdHMuYXR0ZW1wdHM9MTAgUmVydW5zIGluIGNhc2UgdGhlIHJlY3QgaGVpZ2h0IG9yIHdpZHRoIGVxdWFscyAwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIG9wdHMuZGVsYXk9NTAgICAgVGltZSBpbiBtcyBiZWZvcmUgY2hlY2tpbmcgYWdhaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ30gb3B0cy5pZD10aGlzLmlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgIG9wdHMud2luZG93SWQ9dGhpcy53aW5kb3dJZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE5lby51dGlsLlJlY3RhbmdsZXxOZW8udXRpbC5SZWN0YW5nbGVbXT59XG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvckRvbVJlY3Qoe2F0dGVtcHRzPTEwLCBkZWxheT01MCwgaWQ9dGhpcy5pZCwgd2luZG93SWQ9dGhpcy53aW5kb3dJZH0gPSB7fSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IG1lLmdldERvbVJlY3QoaWQpLFxuICAgICAgICAgICAgcmVSdW4gID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2gocmVjdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QuaGVpZ2h0IDwgMSB8fCByZWN0LndpZHRoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByZVJ1biA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5oZWlnaHQgPCAxIHx8IHJlc3VsdC53aWR0aCA8IDEpIHtcbiAgICAgICAgICAgIHJlUnVuID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlUnVuICYmIGF0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dChkZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgbWUud2FpdEZvckRvbVJlY3Qoe2F0dGVtcHRzOiBhdHRlbXB0cy0xLCBkZWxheSwgaWQsIHdpbmRvd0lkfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG59XG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgYWZ0ZXIgZm9jdXNFbnRlciwgZm9jdXNMZWF2ZSBvciBmb2N1c01vdmVcbiAqIEBldmVudCBmb2N1c0NoYW5nZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0W119IFtkYXRhLnBhdGhdIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBbZGF0YS5vbGRQYXRoXSBkb20gZWxlbWVudCBpZHMgdXB3YXJkc1xuICovXG5cbi8qKlxuICogbWFuYWdlci5Gb2N1cyBmaXJlcyB0aGUgZXZlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlkIGlzIGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGhcbiAqIEBldmVudCBmb2N1c0VudGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgbm90IGluY2x1ZGVkIGluc2lkZSB0aGUgZG9tIGlkIHBhdGhcbiAqIEBldmVudCBmb2N1c0xlYXZlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5vbGRQYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKi9cblxuLyoqXG4gKiBtYW5hZ2VyLkZvY3VzIGZpcmVzIHRoZSBldmVudCB3aGVuIHRoZSBjb21wb25lbnQgaWQgaXMgaW5jbHVkZWQgaW5zaWRlIHRoZSBkb20gaWQgcGF0aCwgYnV0IHRoZSBwYXRoIGl0c2VsZiBjaGFuZ2VkXG4gKiBAZXZlbnQgZm9jdXNNb3ZlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoIGRvbSBlbGVtZW50IGlkcyB1cHdhcmRzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLm9sZFBhdGggZG9tIGVsZW1lbnQgaWRzIHVwd2FyZHNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5cbi8qKlxuICogVGhlIFZEb21VcGRhdGUgbWFuYWdlciBpcyBhIHNpbmdsZXRvbiByZXNwb25zaWJsZSBmb3Igb3JjaGVzdHJhdGluZyBhbmQgb3B0aW1pemluZ1xuICogY29tcG9uZW50IFZET00gdXBkYXRlcyB3aXRoaW4gdGhlIE5lby5tanMgZnJhbWV3b3JrLiBJdCBhY3RzIGFzIGEgY2VudHJhbCBjb29yZGluYXRvclxuICogdG8gb3B0aW1pemUgdGhlIFZET00gdXBkYXRlIHByb2Nlc3MuIEl0cyBwcmltYXJ5IGdvYWwgaXMgdG8gcmVkdWNlIHRoZSBhbW91bnQgb2ZcbiAqIG1lc3NhZ2Ugcm91bmR0cmlwcyBiZXR3ZWVuIHRoZSBhcHBsaWNhdGlvbiBhbmQgVkRPTSB3b3JrZXJzIGJ5IGFnZ3JlZ2F0aW5nIG11bHRpcGxlXG4gKiBjb21wb25lbnQgdXBkYXRlcyBpbnRvIGEgc2luZ2xlLCBvcHRpbWl6ZWQgVkRPTSB0cmVlLlxuICpcbiAqIEtleSBSZXNwb25zaWJpbGl0aWVzOlxuICogMS4gKipVcGRhdGUgTWVyZ2luZyAmIEFnZ3JlZ2F0aW9uOioqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWJzb3JiIHRoZSB1cGRhdGVcbiAqICAgIHJlcXVlc3RzIG9mIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCBvZiBlYWNoIGNoaWxkIHRyaWdnZXJpbmcgYSBzZXBhcmF0ZSBWRE9NIHVwZGF0ZVxuICogICAgbWVzc2FnZSB0byB0aGUgVkRPTSB3b3JrZXIsIHRoZSBwYXJlbnQgc2VuZHMgYSBzaW5nbGUsIGFnZ3JlZ2F0ZWQgVkRPTSB0cmVlLiBUaGlzXG4gKiAgICBzaWduaWZpY2FudGx5IHJlZHVjZXMgdGhlIG92ZXJoZWFkIG9mIHdvcmtlciBjb21tdW5pY2F0aW9uIGFuZCBjYW4gcmVzdWx0IGluIHNtYWxsZXIsXG4gKiAgICBtb3JlIGZvY3VzZWQgZGF0YSBmb3IgdGhlIFZET00gd29ya2VyIHRvIHByb2Nlc3MuIFdoaWxlIHRoZSBhbW91bnQgb2YgZmluYWwgRE9NXG4gKiAgICBtb2RpZmljYXRpb25zIHJlbWFpbnMgdGhlIHNhbWUsIHRoaXMgYWdncmVnYXRpb24gaXMga2V5IHRvIHBlcmZvcm1hbmNlLlxuICpcbiAqIDIuICoqQXN5bmNocm9ub3VzIEZsb3cgQ29udHJvbDoqKiBNYW5hZ2VzIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIFZET00gdXBkYXRlcywgd2hpY2hcbiAqICAgIGFyZSBvZnRlbiBwcm9jZXNzZWQgaW4gYSB3b3JrZXIgdGhyZWFkLiBJdCBlbnN1cmVzIHRoYXQgY29kZSBhd2FpdGluZyBhbiB1cGRhdGVcbiAqICAgIChlLmcuLCB2aWEgYSByZXR1cm5lZCBQcm9taXNlKSBpcyBjb3JyZWN0bHkgbm90aWZpZWQgdXBvbiBjb21wbGV0aW9uLlxuICpcbiAqIDMuICoqRGVwZW5kZW5jeSBDaGFpbmluZzoqKiBQcm92aWRlcyBhIFwicG9zdC11cGRhdGVcIiBxdWV1ZSwgYWxsb3dpbmcgb25lIGNvbXBvbmVudCdzXG4gKiAgICB1cGRhdGUgdG8gYmUgZGVjbGFyYXRpdmVseSBjaGFpbmVkIHRvIGFub3RoZXIncywgZW5zdXJpbmcgYSBwcmVkaWN0YWJsZSBvcmRlciBvZlxuICogICAgb3BlcmF0aW9ucy5cbiAqXG4gKiA0LiAqKlN0YXRlIFRyYWNraW5nOioqIEtlZXBzIHRyYWNrIG9mIHVwZGF0ZXMgdGhhdCBhcmUgXCJpbi1mbGlnaHRcIiAoaS5lLiwgY3VycmVudGx5XG4gKiAgICBiZWluZyBwcm9jZXNzZWQpLCB3aGljaCBoZWxwcyB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgYW5kIHJlZHVuZGFudCB3b3JrLlxuICpcbiAqIEJ5IGNlbnRyYWxpemluZyB0aGVzZSBjb25jZXJucywgVkRvbVVwZGF0ZSBwbGF5cyBhIGNyaXRpY2FsIHJvbGUgaW4gdGhlIGZyYW1ld29yaydzXG4gKiBwZXJmb3JtYW5jZSBhbmQgcmVuZGVyaW5nIGVmZmljaWVuY3kuXG4gKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLlZEb21VcGRhdGVcbiAqIEBleHRlbmRzIE5lby5jb2xsZWN0aW9uLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgVkRvbVVwZGF0ZSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1hbmFnZXIuVkRvbVVwZGF0ZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuVkRvbVVwZGF0ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbGxlY3Rpb24gdGhhdCBtYXBzIGEgcGFyZW50IGNvbXBvbmVudCdzIElEIChgb3duZXJJZGApIHRvIHRoZSBzZXQgb2YgY2hpbGRcbiAgICAgICAgICogY29tcG9uZW50cyB3aG9zZSBWRE9NIHVwZGF0ZXMgaGF2ZSBiZWVuIG1lcmdlZCBpbnRvIHRoYXQgcGFyZW50J3MgdXBkYXRlIGN5Y2xlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc3RydWN0dXJlIGZvciBlYWNoIGVudHJ5IGlzOlxuICAgICAgICAgKiBgeyBvd25lcklkOiAncGFyZW50LWlkJywgY2hpbGRyZW46IE1hcDwnY2hpbGQtaWQnLCB7Y2hpbGRVcGRhdGVEZXB0aCwgZGlzdGFuY2V9PiB9YFxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGBvd25lcklkYDogVGhlIGBpZGAgb2YgdGhlIHBhcmVudCBjb21wb25lbnQgdGFraW5nIHJlc3BvbnNpYmlsaXR5IGZvciB0aGUgdXBkYXRlLlxuICAgICAgICAgKiAtIGBjaGlsZHJlbmA6IEEgTWFwIHdoZXJlIGtleXMgYXJlIHRoZSBgaWRgcyBvZiB0aGUgbWVyZ2VkIGNoaWxkcmVuIGFuZCB2YWx1ZXNcbiAgICAgICAgICogICBhcmUgb2JqZWN0cyBjb250YWluaW5nIG1ldGFkYXRhIG5lZWRlZCB0byBjYWxjdWxhdGUgdGhlIHRvdGFsIHVwZGF0ZSBzY29wZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbGxlY3Rpb24uQmFzZXxudWxsfSBtZXJnZWRDYWxsYmFja01hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlZENhbGxiYWNrTWFwOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb2xsZWN0aW9uIHRoYXQgcXVldWVzIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGJlIHVwZGF0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXJcbiAgICAgICAgICogYW5vdGhlciBjb21wb25lbnQncyB1cGRhdGUgY3ljbGUgY29tcGxldGVzLiBUaGlzIGlzIHVzZWQgdG8gaGFuZGxlIHJlbmRlcmluZ1xuICAgICAgICAgKiBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzdHJ1Y3R1cmUgZm9yIGVhY2ggZW50cnkgaXM6XG4gICAgICAgICAqIGB7IG93bmVySWQ6ICdjb21wb25lbnQtaWQnLCBjaGlsZHJlbjogW3tjaGlsZElkLCByZXNvbHZlfV0gfWBcbiAgICAgICAgICpcbiAgICAgICAgICogLSBgb3duZXJJZGA6IFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgd2hvc2UgdXBkYXRlIGNvbXBsZXRpb24gd2lsbCB0cmlnZ2VyIHRoZSBxdWV1ZWQgdXBkYXRlcy5cbiAgICAgICAgICogLSBgY2hpbGRyZW5gOiBBbiBhcnJheSBvZiBvYmplY3RzLCB3aGVyZSBgY2hpbGRJZGAgaXMgdGhlIGNvbXBvbmVudCB0byB1cGRhdGUgYW5kXG4gICAgICAgICAqICAgYHJlc29sdmVgIGlzIHRoZSBQcm9taXNlIHJlc29sdmVyIHRvIGNhbGwgYWZ0ZXIgdGhhdCBzdWJzZXF1ZW50IHVwZGF0ZSBpcyBkb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29sbGVjdGlvbi5CYXNlfG51bGx9IHBvc3RVcGRhdGVRdWV1ZU1hcD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHBvc3RVcGRhdGVRdWV1ZU1hcDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgTWFwIHRoYXQgdHJhY2tzIFZET00gdXBkYXRlcyB0aGF0IGhhdmUgYmVlbiBkaXNwYXRjaGVkIHRvIHRoZSBWRE9NIHdvcmtlciBidXRcbiAgICAgKiBoYXZlIG5vdCB5ZXQgY29tcGxldGVkLiBUaGlzIHByZXZlbnRzIHJlZHVuZGFudCB1cGRhdGVzIGZvciB0aGUgc2FtZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBUaGUgc3RydWN0dXJlIGlzOiBgTWFwPCdjb21wb25lbnQtaWQnLCB1cGRhdGVEZXB0aD5gXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtNYXB8bnVsbH0gaW5GbGlnaHRVcGRhdGVNYXA9bnVsbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbkZsaWdodFVwZGF0ZU1hcCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQSBNYXAgdGhhdCBzdG9yZXMgUHJvbWlzZSBgcmVzb2x2ZWAgZnVuY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCBhIGNvbXBvbmVudCdzIHVwZGF0ZS5cbiAgICAgKiBXaGVuIGEgY29tcG9uZW50J3MgVkRPTSB1cGRhdGUgaXMgZmluYWxpemVkLCB0aGUgY2FsbGJhY2tzIGZvciBpdHMgSUQgYXJlIGV4ZWN1dGVkLFxuICAgICAqIHJlc29sdmluZyB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSB0aGUgY29tcG9uZW50J3MgYHVwZGF0ZSgpYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBUaGUgc3RydWN0dXJlIGlzOiBgTWFwPCdjb21wb25lbnQtaWQnLCBbY2FsbGJhY2sxLCBjYWxsYmFjazIsIC4uLl0+YFxuICAgICAqXG4gICAgICogQG1lbWJlciB7TWFwfG51bGx9IHByb21pc2VDYWxsYmFja01hcD1udWxsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb21pc2VDYWxsYmFja01hcCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbWFuYWdlcidzIGludGVybmFsIGNvbGxlY3Rpb25zIGFuZCBtYXBzLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgc2luZ2xldG9uIGluc3RhbmNlIGlzIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmluRmxpZ2h0VXBkYXRlTWFwICA9IG5ldyBNYXAoKTtcbiAgICAgICAgbWUubWVyZ2VkQ2FsbGJhY2tNYXAgID0gTmVvLmNyZWF0ZShDb2xsZWN0aW9uLCB7a2V5UHJvcGVydHk6ICdvd25lcklkJ30pO1xuICAgICAgICBtZS5wb3N0VXBkYXRlUXVldWVNYXAgPSBOZW8uY3JlYXRlKENvbGxlY3Rpb24sIHtrZXlQcm9wZXJ0eTogJ293bmVySWQnfSk7XG4gICAgICAgIG1lLnByb21pc2VDYWxsYmFja01hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIGEgc3BlY2lmaWMgY29tcG9uZW50J3NcbiAgICAgKiBWRE9NIHVwZGF0ZSBjb21wbGV0ZXMuIFRoaXMgaXMgdGhlIG1lY2hhbmlzbSB0aGF0IHJlc29sdmVzIHRoZSBQcm9taXNlXG4gICAgICogcmV0dXJuZWQgYnkgYENvbXBvbmVudCN1cGRhdGUoKWAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3duZXJJZCAgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCBvd25pbmcgdGhlIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB1cG9uIGNvbXBsZXRpb24uXG4gICAgICovXG4gICAgYWRkUHJvbWlzZUNhbGxiYWNrKG93bmVySWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5wcm9taXNlQ2FsbGJhY2tNYXAuaGFzKG93bmVySWQpKSB7XG4gICAgICAgICAgICBtZS5wcm9taXNlQ2FsbGJhY2tNYXAuc2V0KG93bmVySWQsIFtdKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUucHJvbWlzZUNhbGxiYWNrTWFwLmdldChvd25lcklkKS5wdXNoKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGFsbCBjYWxsYmFja3MgYXNzb2NpYXRlZCB3aXRoIGEgY29tcGxldGVkIFZET00gdXBkYXRlIGZvciBhIGdpdmVuIGBvd25lcklkYC5cbiAgICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBwcm9jZXNzZXMgY2FsbGJhY2tzIGZvciBhbnkgY2hpbGRyZW4gdGhhdCB3ZXJlIG1lcmdlZCBpbnRvIHRoaXNcbiAgICAgKiB1cGRhdGUgY3ljbGUsIHRoZW4gZXhlY3V0ZXMgdGhlIGNhbGxiYWNrcyBmb3IgdGhlIGBvd25lcklkYCBpdHNlbGYuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCB3aG9zZSB1cGRhdGUgaGFzIGp1c3QgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gIE9wdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2tzLlxuICAgICAqL1xuICAgIGV4ZWN1dGVDYWxsYmFja3Mob3duZXJJZCwgZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gICAgICAgICA9IG1lLm1lcmdlZENhbGxiYWNrTWFwLmdldChvd25lcklkKSxcbiAgICAgICAgICAgIGNhbGxiYWNrRGF0YSA9IGRhdGEgPyBbZGF0YV0gOiBbXTtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5jaGlsZHJlbi5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZXhlY3V0ZVByb21pc2VDYWxsYmFja3Moa2V5LCAuLi5jYWxsYmFja0RhdGEpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1lLm1lcmdlZENhbGxiYWNrTWFwLnJlbW92ZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmV4ZWN1dGVQcm9taXNlQ2FsbGJhY2tzKG93bmVySWQsIC4uLmNhbGxiYWNrRGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBpbnZva2VzIGFsbCByZWdpc3RlcmVkIHByb21pc2UgY2FsbGJhY2tzIGZvciBhIGdpdmVuXG4gICAgICogY29tcG9uZW50IElEIGFuZCB0aGVuIGNsZWFycyB0aGVtIGZyb20gdGhlIHF1ZXVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSAgT3B0aW9uYWwgZGF0YSB0byBwYXNzIHRvIHRoZSBjYWxsYmFja3MuXG4gICAgICovXG4gICAgZXhlY3V0ZVByb21pc2VDYWxsYmFja3Mob3duZXJJZCwgZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IG1lLnByb21pc2VDYWxsYmFja01hcC5nZXQob3duZXJJZCk7XG5cbiAgICAgICAgY2FsbGJhY2tzPy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGRhdGEpKTtcbiAgICAgICAgbWUucHJvbWlzZUNhbGxiYWNrTWFwLmRlbGV0ZShvd25lcklkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSByZXF1aXJlZCBgdXBkYXRlRGVwdGhgIGZvciBhIHBhcmVudCBjb21wb25lbnQgYmFzZWQgb24gaXRzIG93blxuICAgICAqIG5lZWRzIGFuZCB0aGUgbmVlZHMgb2YgYWxsIGNoaWxkIGNvbXBvbmVudHMgd2hvc2UgdXBkYXRlcyBoYXZlIGJlZW4gbWVyZ2VkIGludG8gaXQuXG4gICAgICogVGhlIGZpbmFsIGRlcHRoIGlzIHRoZSBtYXhpbXVtIHJlcXVpcmVkIGRlcHRoIHRvIGVuc3VyZSBhbGwgY2hhbmdlcyBhcmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYSBwYXJlbnQgbmVlZHMgdG8gdXBkYXRlIGl0cyBkaXJlY3QgY29udGVudCAoYHVwZGF0ZURlcHRoOiAxYCkgYnV0XG4gICAgICogYSBtZXJnZWQgY2hpbGQgMyBsZXZlbHMgZG93biBuZWVkcyBhIGZ1bGwgc3VidHJlZSB1cGRhdGUgKGBjaGlsZFVwZGF0ZURlcHRoOiAtMWApLFxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIC0xLCBzaWduYWxpbmcgYSBmdWxsIHJlY3Vyc2l2ZSB1cGRhdGUgZnJvbSB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBwYXJlbnQgY29tcG9uZW50IHJpZ2h0IGJlZm9yZSBpdCBkaXNwYXRjaGVzIGl0cyBWRE9NIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCBUaGUgYGlkYCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfG51bGx9IFRoZSBhZGp1c3RlZCB1cGRhdGUgZGVwdGgsIG9yIGBudWxsYCBpZiBubyBtZXJnZWQgY2hpbGRyZW4gZXhpc3QuXG4gICAgICovXG4gICAgZ2V0QWRqdXN0ZWRVcGRhdGVEZXB0aChvd25lcklkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciAgICA9IE5lby5nZXRDb21wb25lbnQob3duZXJJZCksXG4gICAgICAgICAgICBpdGVtICAgICA9IG1lLm1lcmdlZENhbGxiYWNrTWFwLmdldChvd25lcklkKSxcbiAgICAgICAgICAgIG1heERlcHRoID0gb3duZXI/LnVwZGF0ZURlcHRoID8/IDEsXG4gICAgICAgICAgICBuZXdEZXB0aDtcblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5jaGlsZHJlbi5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuY2hpbGRVcGRhdGVEZXB0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVwdGggPSAtMVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXcgZGVwdGggaXMgdGhlIGRpc3RhbmNlIHRvIHRoZSBjaGlsZCBwbHVzIHRoZSBjaGlsZCdzIG93biByZXF1aXJlZCB1cGRhdGUgZGVwdGguXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlcHRoID0gdmFsdWUuZGlzdGFuY2UgKyB2YWx1ZS5jaGlsZFVwZGF0ZURlcHRoXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RlcHRoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhEZXB0aCA9IC0xXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXhEZXB0aCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgbmV3RGVwdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXhEZXB0aFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGB1cGRhdGVEZXB0aGAgZm9yIGEgY29tcG9uZW50J3MgdXBkYXRlIHRoYXQgaXMgY3VycmVudGx5IGluLWZsaWdodC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCBUaGUgYGlkYCBvZiB0aGUgY29tcG9uZW50IG93bmluZyB0aGUgdXBkYXRlLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8dW5kZWZpbmVkfSBUaGUgdXBkYXRlIGRlcHRoLCBvciBgdW5kZWZpbmVkYCBpZiBubyB1cGRhdGUgaXMgaW4tZmxpZ2h0LlxuICAgICAqL1xuICAgIGdldEluRmxpZ2h0VXBkYXRlRGVwdGgob3duZXJJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbkZsaWdodFVwZGF0ZU1hcC5nZXQob3duZXJJZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU2V0IG9mIGNoaWxkIGNvbXBvbmVudCBJRHMgdGhhdCBoYXZlIGJlZW4gbWVyZ2VkIGludG8gYSBwYXJlbnQncyB1cGRhdGUgY3ljbGUuXG4gICAgICogVGhpcyBpcyB1c2VkIGJ5IHRoZSBwYXJlbnQgdG8ga25vdyB3aGljaCBjaGlsZHJlbiBpdCBpcyByZXNwb25zaWJsZSBmb3IgdXBkYXRpbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG93bmVySWQgVGhlIGBpZGAgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gICAgICogQHJldHVybnMge1NldDxTdHJpbmc+fG51bGx9IEEgU2V0IGNvbnRhaW5pbmcgdGhlIElEcyBvZiB0aGUgbWVyZ2VkIGNoaWxkcmVuLCBvciBgbnVsbGAuXG4gICAgICovXG4gICAgZ2V0TWVyZ2VkQ2hpbGRJZHMob3duZXJJZCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5tZXJnZWRDYWxsYmFja01hcC5nZXQob3duZXJJZCk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldChpdGVtLmNoaWxkcmVuLmtleXMoKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIGEgY29tcG9uZW50J3MgVkRPTSB1cGRhdGUgYXMgXCJpbi1mbGlnaHQsXCIgbWVhbmluZyBpdCBoYXMgYmVlbiBzZW50IHRvIHRoZVxuICAgICAqIHdvcmtlciBmb3IgcHJvY2Vzc2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCAgICAgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCBvd25pbmcgdGhlIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXBkYXRlRGVwdGggVGhlIGRlcHRoIG9mIHRoZSBpbi1mbGlnaHQgdXBkYXRlLlxuICAgICAqL1xuICAgIHJlZ2lzdGVySW5GbGlnaHRVcGRhdGUob3duZXJJZCwgdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgdGhpcy5pbkZsaWdodFVwZGF0ZU1hcC5zZXQob3duZXJJZCwgdXBkYXRlRGVwdGgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2hpbGQncyB1cGRhdGUgcmVxdWVzdCB0byBiZSBtZXJnZWQgaW50byBpdHMgcGFyZW50J3MgdXBkYXRlIGN5Y2xlLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJ5IGEgY2hpbGQgY29tcG9uZW50IHdoZW4gaXQgZGV0ZXJtaW5lcyBpdCBjYW4gZGVsZWdhdGUgaXRzIHVwZGF0ZVxuICAgICAqIHRvIGFuIGFuY2VzdG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkICAgICAgICAgIFRoZSBgaWRgIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50IHRoYXQgd2lsbCBvd24gdGhlIG1lcmdlZCB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkSWQgICAgICAgICAgVGhlIGBpZGAgb2YgdGhlIGNoaWxkIGNvbXBvbmVudCByZXF1ZXN0aW5nIHRoZSBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hpbGRVcGRhdGVEZXB0aCBUaGUgdXBkYXRlIGRlcHRoIHJlcXVpcmVkIGJ5IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgICAgICAgICBUaGUgY29tcG9uZW50IHRyZWUgZGlzdGFuY2UgKG51bWJlciBvZiBsZXZlbHMpIGJldHdlZW4gdGhlIHBhcmVudCBhbmQgY2hpbGQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJNZXJnZWQob3duZXJJZCwgY2hpbGRJZCwgY2hpbGRVcGRhdGVEZXB0aCwgZGlzdGFuY2UpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLm1lcmdlZENhbGxiYWNrTWFwLmdldChvd25lcklkKTtcblxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB7b3duZXJJZCwgY2hpbGRyZW46IG5ldyBNYXAoKX07XG4gICAgICAgICAgICBtZS5tZXJnZWRDYWxsYmFja01hcC5hZGQoaXRlbSlcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0uY2hpbGRyZW4uc2V0KGNoaWxkSWQsIHtjaGlsZFVwZGF0ZURlcHRoLCBkaXN0YW5jZX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVldWVzIGEgY29tcG9uZW50IHVwZGF0ZSB0byBiZSBleGVjdXRlZCBhZnRlciBhbm90aGVyIGNvbXBvbmVudCdzIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3duZXJJZCAgICAgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCB0byB3YWl0IGZvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hpbGRJZCAgICAgVGhlIGBpZGAgb2YgdGhlIGNvbXBvbmVudCB0byB1cGRhdGUgYWZ0ZXJ3YXJkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXSBUaGUgUHJvbWlzZSByZXNvbHZlciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgYGNoaWxkSWRgJ3Mgc3Vic2VxdWVudCB1cGRhdGUgZmluaXNoZXMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJQb3N0VXBkYXRlKG93bmVySWQsIGNoaWxkSWQsIHJlc29sdmUpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IG1lLnBvc3RVcGRhdGVRdWV1ZU1hcC5nZXQob3duZXJJZCk7XG5cbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBpdGVtID0ge293bmVySWQsIGNoaWxkcmVuOiBbXX07XG4gICAgICAgICAgICBtZS5wb3N0VXBkYXRlUXVldWVNYXAuYWRkKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLmNoaWxkcmVuLnB1c2goe2NoaWxkSWQsIHJlc29sdmV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFsbCBwZW5kaW5nIHVwZGF0ZXMgdGhhdCB3ZXJlIHF1ZXVlZCB0byBydW4gYWZ0ZXIgdGhlIHNwZWNpZmllZCBgb3duZXJJZGAnc1xuICAgICAqIHVwZGF0ZSBoYXMgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgd2hvc2UgdXBkYXRlIGhhcyBqdXN0IGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHRyaWdnZXJQb3N0VXBkYXRlcyhvd25lcklkKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBtZS5wb3N0VXBkYXRlUXVldWVNYXAuZ2V0KG93bmVySWQpLFxuICAgICAgICAgICAgY29tcG9uZW50O1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmNoaWxkcmVuLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IE5lby5nZXRDb21wb25lbnQoZW50cnkuY2hpbGRJZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlc29sdmUgJiYgbWUuYWRkUHJvbWlzZUNhbGxiYWNrKGNvbXBvbmVudC5pZCwgZW50cnkucmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC51cGRhdGUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5wb3N0VXBkYXRlUXVldWVNYXAucmVtb3ZlKGl0ZW0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9uZW50J3MgdXBkYXRlIGZyb20gdGhlIFwiaW4tZmxpZ2h0XCIgcmVnaXN0cnkuIFRoaXMgaXMgY2FsbGVkIGFmdGVyXG4gICAgICogdGhlIFZET00gd29ya2VyIGNvbmZpcm1zIHRoZSB1cGRhdGUgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvd25lcklkIFRoZSBgaWRgIG9mIHRoZSBjb21wb25lbnQgb3duaW5nIHRoZSB1cGRhdGUuXG4gICAgICovXG4gICAgdW5yZWdpc3RlckluRmxpZ2h0VXBkYXRlKG93bmVySWQpIHtcbiAgICAgICAgdGhpcy5pbkZsaWdodFVwZGF0ZU1hcC5kZWxldGUob3duZXJJZClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZEb21VcGRhdGUpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBEb21FdmVudE1hbmFnZXIgZnJvbSAnLi4vbWFuYWdlci9Eb21FdmVudC5tanMnO1xuXG4vKipcbiAqIEEgbWl4aW4gcHJvdmlkaW5nIERPTSBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMgdG8gY29tcG9uZW50cy5cbiAqIFRoaXMgbWl4aW4gaXMgY29uc3VtZWQgYnkgYm90aCBOZW8uY29tcG9uZW50LkJhc2UgYW5kIE5lby5mdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlXG4gKiB0byBlbmFibGUgY29uc2lzdGVudCBtYW5hZ2VtZW50IG9mIERPTSBldmVudCBsaXN0ZW5lcnMgYWNyb3NzIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZXMuXG4gKiBAY2xhc3MgTmVvLm1peGluLkRvbUV2ZW50c1xuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBEb21FdmVudHMgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5taXhpbi5Eb21FdmVudHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5taXhpbi5Eb21FdmVudHMnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgZG9tTGlzdGVuZXIgY29uZmlnc1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxudWxsfSBkb21MaXN0ZW5lcnNfPW51bGxcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYWZ0ZXJTZXRTdGF5T25Ib3Zlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICogICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgKiAgICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFxuICAgICAgICAgKiAgICAgICAgICAgICB7bW91c2VlbnRlcjogbWUub25Nb3VzZUVudGVyLCBzY29wZTogbWV9LFxuICAgICAgICAgKiAgICAgICAgICAgICB7bW91c2VsZWF2ZTogbWUub25Nb3VzZUxlYXZlLCBzY29wZTogbWV9XG4gICAgICAgICAqICAgICAgICAgKVxuICAgICAgICAgKiAgICB9XG4gICAgICAgICAqfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRvbUxpc3RlbmVyc186IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBhZGQgYWRkaXRpb25hbCBkb20gbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IHZhbHVlXG4gICAgICovXG4gICAgYWRkRG9tTGlzdGVuZXJzKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRvbUxpc3RlbmVycyA9IHRoaXMuZG9tTGlzdGVuZXJzO1xuXG4gICAgICAgIGRvbUxpc3RlbmVycy5wdXNoKC4uLnZhbHVlKTtcblxuICAgICAgICB0aGlzLmRvbUxpc3RlbmVycyA9IGRvbUxpc3RlbmVyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZG9tTGlzdGVuZXJzIGluc2lkZSB0aGUgTmVvLm1hbmFnZXIuRG9tRXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9tTGlzdGVuZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZT8uWzBdIHx8IG9sZFZhbHVlPy5bMF0pIHtcbiAgICAgICAgICAgIERvbUV2ZW50TWFuYWdlci51cGRhdGVEb21MaXN0ZW5lcnMobWUsIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGRvbUxpc3RlbmVycyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREb21MaXN0ZW5lcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCBbXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIERPTSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgaW5pdERvbUV2ZW50cygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgaWYgKG1lLmRvbUxpc3RlbmVycz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gdG9kbzogdGhlIG1haW4gdGhyZWFkIHJlcGx5IG9mIG1vdW50IGFycml2ZXMgYWZ0ZXIgcHVzaGluZyB0aGUgdGFzayBpbnRvIHRoZSBxdWV1ZSB3aGljaCBkb2VzIG5vdCBlbnN1cmUgdGhlIGRvbSBpcyBtb3VudGVkXG4gICAgICAgICAgICBtZS50aW1lb3V0KDE1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgRG9tRXZlbnRNYW5hZ2VyLm1vdW50RG9tTGlzdGVuZXJzKG1lKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIERPTSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgcmVtb3ZlRG9tRXZlbnRzKCkge1xuICAgICAgICB0aGlzLmRvbUxpc3RlbmVycyA9IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHZhbHVlXG4gICAgICovXG4gICAgcmVtb3ZlRG9tTGlzdGVuZXJzKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZG9tTGlzdGVuZXJzfSA9IG1lLFxuICAgICAgICAgICAgaSwgbGVuO1xuXG4gICAgICAgIHZhbHVlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIGxlbiA9IGRvbUxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzRXF1YWwoaXRlbSwgZG9tTGlzdGVuZXJzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21MaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZG9tTGlzdGVuZXJzID0gZG9tTGlzdGVuZXJzXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhEb21FdmVudHMpO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9tYW5hZ2VyL0NvbXBvbmVudC5tanMnO1xuaW1wb3J0IFRyZWVCdWlsZGVyICAgICAgZnJvbSAnLi4vdXRpbC92ZG9tL1RyZWVCdWlsZGVyLm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICBmcm9tICcuLi91dGlsL1ZEb20ubWpzJztcbmltcG9ydCBWRG9tVXBkYXRlICAgICAgIGZyb20gJy4uL21hbmFnZXIvVkRvbVVwZGF0ZS5tanMnO1xuaW1wb3J0IFZOb2RlVXRpbCAgICAgICAgZnJvbSAnLi4vdXRpbC9WTm9kZS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbmNvbnN0IHtjdXJyZW50V29ya2VyfSA9IE5lbztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1peGluLlZkb21MaWZlY3ljbGVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgVmRvbUxpZmVjeWNsZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLm1peGluLlZkb21MaWZlY3ljbGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5taXhpbi5WZG9tTGlmZWN5Y2xlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgYXV0b21hdGljYWxseSBpbml0aWFsaXplcyB0aGUgdm5vZGUgb2YgYSBjb21wb25lbnQgYWZ0ZXIgYmVpbmcgY3JlYXRlZCBpbnNpZGUgdGhlIGluaXQgY2FsbC5cbiAgICAgICAgICogUmVjb21tZW5kZWQgZm9yIGRpYWxvZ3MgJiBkcmFnLXByb3hpZXMuXG4gICAgICAgICAqIFRvcCBsZXZlbCB2aWV3cyBzaG91bGQgZGVmaW5pdGVseSB1c2UgZmFsc2UuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Jbml0Vm5vZGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0Vm5vZGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IG1vdW50cyBhIGNvbXBvbmVudCBhZnRlciBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgICogVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWwgY29tcG9uZW50IG9mIHlvdXIgYXBwLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvTW91bnQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBmbGFnIHdoaWNoIHdpbGwgZ2V0IHNldCB0byB0cnVlIHdoaWxlIGFuIHVwZGF0ZSByZXF1ZXN0ICh3b3JrZXIgbWVzc2FnZXMpIGlzIGluIHByb2dyZXNzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzVmRvbVVwZGF0aW5nXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNWZG9tVXBkYXRpbmdfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxpemluZyB0aGUgdm5vZGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNWbm9kZUluaXRpYWxpemluZ189ZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGlzVm5vZGVJbml0aWFsaXppbmdfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgdG8gdGhlIERPTVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3VudGVkXz1mYWxzZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbW91bnRlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgZmxhZyB3aGljaCB3aWxsIGdldCBzZXQgdG8gdHJ1ZSBpbiBjYXNlIGFuIHVwZGF0ZSBjYWxsIGFycml2ZXMgd2hpbGUgYW5vdGhlciB1cGRhdGUgaXMgcnVubmluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBuZWVkc1Zkb21VcGRhdGVfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBuZWVkc1Zkb21VcGRhdGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgZm9yIGJ1bGsgdXBkYXRlcy4gRW5zdXJlIHRvIHNldCBpdCBiYWNrIHRvIGZhbHNlIGFmdGVyd2FyZHMuXG4gICAgICAgICAqIEludGVybmFsbHkgdGhlIHZhbHVlIHdpbGwgZ2V0IHNhdmVkIGFzIGEgbnVtYmVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkIG1ldGhvZHMgd29uJ3Qgc3RvcCB0aGUgc2lsZW50IG1vZGUgdG9vIGVhcmx5LlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaWxlbnRWZG9tVXBkYXRlXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudFZkb21VcGRhdGVfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGRlcHRoIG9mIHRoZSB2ZG9tIHRyZWUgZm9yIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZS5cbiAgICAgICAgICogLSBUaGUgdmFsdWUgMSB3aWxsIG9ubHkgc2VuZCB0aGUgY3VycmVudCB2ZG9tIHN0cnVjdHVyZSBhcyBpdCBpc1xuICAgICAgICAgKiAtIFRoZSB2YWx1ZSBvZiAyIHdpbGwgaW5jbHVkZSB0aGUgdmRvbSBvZiBkaXJlY3QgY2hpbGRyZW5cbiAgICAgICAgICogLSBUaGUgdmFsdWUgb2YgMyB3aWxsIGluY2x1ZGUgdGhlIHZkb20gb2YgZ3JhbmRjaGlsZHJlblxuICAgICAgICAgKiAtIFRoZSB2YWx1ZSBvZiAtMSB3aWxsIGluY2x1ZGUgdGhlIGZ1bGwgdHJlZSBvZiBhbnkgZGVwdGhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB1cGRhdGVEZXB0aF89MVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURlcHRoXzogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb21wb25lbnQgdm5vZGUgdHJlZS4gQXZhaWxhYmxlIGFmdGVyIHRoZSBjb21wb25lbnQgZ290IHZub2RlSW5pdGlhbGl6ZWQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdm5vZGVfPT17W2lzRGVzY3JpcHRvcl06IHRydWUsIHZhbHVlOiBudWxsLCBpc0VxdWFsOiAoYSwgYikgPT4gYSA9PT0gYix9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2bm9kZV86IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgY2xvbmUgICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgIGNsb25lT25HZXQgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBpc0VxdWFsICAgICAgIDogKGEsIGIpID0+IGEgPT09IGIsIC8vIHZub2RlIHRyZWVzIGNhbiBiZSBodWdlLCBhbmQgd2lsbCBnZXQgY29tcGFyZWQgYnkgdGhlIHZkb20gd29ya2VyLlxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGFmdGVyIHRoZSBjb21wb25lbnQgaW5pdFZub2RlKCkgbWV0aG9kIHdhcyBjYWxsZWQuIEFsc28gZmlyZXMgdGhlIHZub2RlSW5pdGlhbGl6ZWQgZXZlbnQuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHZub2RlSW5pdGlhbGl6ZWRfPWZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2bm9kZUluaXRpYWxpemVkXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZkb20gcHNldWRvLWNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmRvbSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWZG9tKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZub2RlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Vm5vZGUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuc3luY1Zub2RlVHJlZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB2bm9kZUluaXRpYWxpemVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Vm5vZGVJbml0aWFsaXplZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ3Zub2RlSW5pdGlhbGl6ZWQnLCBtZS5pZCk7XG5cbiAgICAgICAgICAgIGlmIChtZS5uZWVkc1Zkb21VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxpZ2h0d2VpZ2h0LCBzZXJpYWxpemFibGUgcGxhY2Vob2xkZXIgZm9yIHRoaXMgY29tcG9uZW50LCBpbnRlbmRlZCBmb3IgaW5qZWN0aW9uXG4gICAgICogaW50byB0aGUgVkRPTSBvZiBvdGhlciBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgKipvbmx5IHJlY29tbWVuZGVkIHdheSoqIHRvIG5lc3QgYSBjb21wb25lbnQgd2l0aGluIGFub3RoZXIgY29tcG9uZW50J3MgVkRPTSB0cmVlLlxuICAgICAqIERpcmVjdGx5IGVtYmVkZGluZyBvbmUgY29tcG9uZW50J3MgZnVsbCBgdmRvbWAgb2JqZWN0IGludG8gYW5vdGhlcidzIGlzIGFuIGFudGktcGF0dGVyblxuICAgICAqIHRoYXQgdmlvbGF0ZXMgdGhlIHByaW5jaXBsZSBvZiBzY29wZWQgVkRPTSwgbGVhZGluZyB0byB1bnByZWRpY3RhYmxlIHJlbmRlcmluZyBiZWhhdmlvclxuICAgICAqIGFuZCBtYWtpbmcgdXBkYXRlcyBpbmVmZmljaWVudC5cbiAgICAgKlxuICAgICAqIEF0IGl0cyBjb3JlLCB0aGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIGEgYGNvbXBvbmVudElkYCB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlXG4gICAgICogY29tcG9uZW50IGluc3RhbmNlLiBJbiBjYXNlcyB3aGVyZSBhIGNvbXBvbmVudCdzIHN0cnVjdHVyZSBpcyB3cmFwcGVkIGJ5IGFub3RoZXIgZWxlbWVudFxuICAgICAqIChlLmcuLCBhIEJ1dHRvbiBpbiBhIFRhYmxlIEhlYWRlciBiZWluZyB3cmFwcGVkIGJ5IGEgYDx0ZD5gKSwgdGhlIHJlZmVyZW5jZSB3aWxsIGFsc29cbiAgICAgKiBpbmNsdWRlIHRoZSB3cmFwcGVyJ3MgYGlkYC4gVGhpcyBoYXBwZW5zIHdoZW4gYSBjb21wb25lbnQgdXNlcyBgZ2V0VmRvbVJvb3QoKWAgdG9cbiAgICAgKiBkZXNpZ25hdGUgYSBkZWVwZXIgbm9kZSBhcyBpdHMgbG9naWNhbCByb290LCBjYXVzaW5nIHRoZSBjb21wb25lbnQncyBgaWRgIGFuZCBpdHNcbiAgICAgKiBWRE9NIHJvb3QncyBgaWRgIHRvIGRpZmZlci4gVGhlIGZyYW1ld29yayB1c2VzIHRoaXMgZHVhbC1JRCByZWZlcmVuY2UgdG8gY29ycmVjdGx5XG4gICAgICogYXNzZW1ibGUgdGhlIGZpbmFsIFZET00gdHJlZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7Y29tcG9uZW50SWQ6IFN0cmluZywgaWQ6IFN0cmluZ3x1bmRlZmluZWR9fSBUaGUgVkRPTSByZWZlcmVuY2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGNyZWF0ZVZkb21SZWZlcmVuY2UoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0ge2NvbXBvbmVudElkOiBtZS5pZH0sXG4gICAgICAgICAgICB2ZG9tSWQgICAgPSBtZS52ZG9tLmlkO1xuXG4gICAgICAgIGlmICh2ZG9tSWQgJiYgbWUuaWQgIT09IHZkb21JZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlLmlkID0gdmRvbUlkXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIHNlbmQgdXBkYXRlIHJlcXVlc3RzIHRvIHRoZSB2ZG9tIHdvcmtlclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZXNvbHZlXSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtyZWplY3RdIHVzZWQgYnkgcHJvbWlzZVVwZGF0ZSgpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlVmRvbVVwZGF0ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXNvbHZlICYmIFZEb21VcGRhdGUuYWRkUHJvbWlzZUNhbGxiYWNrKG1lLmlkLCByZXNvbHZlKTtcblxuICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IHRydWU7XG4gICAgICAgIC8vIENlbnRyYWxpemUgaW4tZmxpZ2h0IHN0YXRlXG4gICAgICAgIFZEb21VcGRhdGUucmVnaXN0ZXJJbkZsaWdodFVwZGF0ZShtZS5pZCwgbWUudXBkYXRlRGVwdGgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIHt2ZG9tLCB2bm9kZX0gPSBtZSxcbiAgICAgICAgICAgICAgICBtZXJnZWRDaGlsZElkcyA9IFZEb21VcGRhdGUuZ2V0TWVyZ2VkQ2hpbGRJZHMobWUuaWQpLFxuICAgICAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZkb20gOiBUcmVlQnVpbGRlci5nZXRWZG9tVHJlZSh2ZG9tLCAgIG1lLnVwZGF0ZURlcHRoLCBtZXJnZWRDaGlsZElkcyksXG4gICAgICAgICAgICAgICAgICAgIHZub2RlOiBUcmVlQnVpbGRlci5nZXRWbm9kZVRyZWUodm5vZGUsIG1lLnVwZGF0ZURlcHRoLCBtZXJnZWRDaGlsZElkcylcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFdvcmtlcj8uaXNTaGFyZWRXb3JrZXIpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmFwcE5hbWUgID0gbWUuYXBwTmFtZTtcbiAgICAgICAgICAgICAgICBvcHRzLndpbmRvd0lkID0gbWUud2luZG93SWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBzZXQgdGhlIGNvbmZpZyBkaXJlY3RseSA9PiBpdCBjb3VsZCBhbHJlYWR5IGJlIGZhbHNlLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHN0aWxsIHdhbnQgdG8gcGFzcyBpdCBmdXJ0aGVyIGludG8gc3VidHJlZXNcbiAgICAgICAgICAgIG1lLl9uZWVkc1Zkb21VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLmFmdGVyU2V0TmVlZHNWZG9tVXBkYXRlPy4oZmFsc2UsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgdXBkYXRlRGVwdGggdG8gdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZVxuICAgICAgICAgICAgbWUuX3VwZGF0ZURlcHRoID0gbWUuY29uc3RydWN0b3IuY29uZmlnLnVwZGF0ZURlcHRoO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKE5lby52ZG9tLkhlbHBlci51cGRhdGUob3B0cykpO1xuXG4gICAgICAgICAgICAvLyBDb21wb25lbnQgY291bGQgYmUgZGVzdHJveWVkIHdoaWxlIHRoZSB1cGRhdGUgaXMgcnVubmluZ1xuICAgICAgICAgICAgaWYgKG1lLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgY3J1Y2lhbCB0byBkZWxlZ2F0ZSB0aGUgdm5vZGUgdHJlZSBiZWZvcmUgcmVzb2x2aW5nIHRoZSBjeWNsZVxuICAgICAgICAgICAgICAgIG1lLnZub2RlID0gZGF0YS52bm9kZTtcblxuICAgICAgICAgICAgICAgIC8vIFdoZW4gbm90IHVzaW5nIGEgVmRvbVdvcmtlciwgd2UgbmVlZCB0byBhcHBseSB0aGUgZGVsdGFzIGluc2lkZSB0aGUgQXBwIHdvcmtlclxuICAgICAgICAgICAgICAgIGlmICghTmVvLmNvbmZpZy51c2VWZG9tV29ya2VyICYmIGRhdGEuZGVsdGFzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IE5lby5hcHBseURlbHRhcyhtZS53aW5kb3dJZCwgZGF0YS5kZWx0YXMpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUucmVzb2x2ZVZkb21VcGRhdGUoZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHN0YXRlIGlzIGNsZWFuZWQgdXAgb24gZXJyb3JcbiAgICAgICAgICAgIFZEb21VcGRhdGUudW5yZWdpc3RlckluRmxpZ2h0VXBkYXRlKG1lLmlkKTtcbiAgICAgICAgICAgIHJlamVjdD8uKGVycilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvbm9ycyBkaWZmZXJlbnQgaXRlbSByb290cyBmb3IgbW91bnQgLyByZW5kZXIgT1BzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRNb3VudGVkUGFyZW50SWQoKSB7XG4gICAgICAgIGxldCBwYXJlbnRJZCAgPSB0aGlzLnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50ICAgID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCksXG4gICAgICAgICAgICBpdGVtc1Jvb3QgPSBwYXJlbnQ/LmdldFZkb21JdGVtc1Jvb3Q/LigpO1xuXG4gICAgICAgIHJldHVybiBpdGVtc1Jvb3QgPyBpdGVtc1Jvb3QuaWQgOiBwYXJlbnRJZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcmVhbCBwYXJlbnRJbmRleCBpbnNpZGUgdGhlIERPTVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldE1vdW50ZWRQYXJlbnRJbmRleCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LFxuICAgICAgICAgICAgaXRlbXMgID0gcGFyZW50Py5pdGVtcyB8fCBbXSxcbiAgICAgICAgICAgIGkgICAgICA9IDAsXG4gICAgICAgICAgICBpbmRleCAgPSAwLFxuICAgICAgICAgICAgbGVuICAgID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXRlbS5oaWRkZW4gJiYgaXRlbS5oaWRlTW9kZSA9PT0gJ3JlbW92ZURvbScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggYSB2ZG9tIGNoaWxkIG5vZGUgYnkgaWQgZm9yIGEgZ2l2ZW4gdmRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb209dGhpcy52ZG9tXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWZG9tQ2hpbGQoaWQsIHZkb209dGhpcy52ZG9tKSB7XG4gICAgICAgIHJldHVybiBWRG9tVXRpbC5maW5kKHZkb20sIGlkKT8udmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgYSBkaWZmZXJlbnQgdmRvbSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWbm9kZVJvb3QoKSBhcyB3ZWxsLCB0byBrZWVwIHRoZSB2ZG9tICYgdm5vZGUgdHJlZXMgaW4gc3luYy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3IHZkb20gcm9vdFxuICAgICAqL1xuICAgIGdldFZkb21Sb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZG9tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhIGRpZmZlcmVudCB2bm9kZSByb290IGlmIG5lZWRlZCB0byBhcHBseSB0aGUgdG9wIGxldmVsIHN0eWxlIGF0dHJpYnV0ZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwuXG4gICAgICogTWFrZSBzdXJlIHRvIHVzZSBnZXRWZG9tUm9vdCgpIGFzIHdlbGwsIHRvIGtlZXAgdGhlIHZkb20gJiB2bm9kZSB0cmVlcyBpbiBzeW5jLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXcgdm5vZGUgcm9vdFxuICAgICAqL1xuICAgIGdldFZub2RlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudm5vZGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiB1cGRhdGVEZXB0aCAmIGRpc3RhbmNlIHdvdWxkIHJlc3VsdCBpbiBhbiB1cGRhdGUgY29sbGlzaW9uLlxuICAgICAqIFRoZSBjaGVjayBtdXN0IHVzZSBgPGAgYmVjYXVzZSBgdXBkYXRlRGVwdGhgIGlzIDEtYmFzZWQuXG4gICAgICogLSBgdXBkYXRlRGVwdGg6IDFgIG1lYW5zIHRoZSB1cGRhdGUgaXMgc2NvcGVkIHRvIHRoZSBjb21wb25lbnQgaXRzZWxmLlxuICAgICAqIC0gQSBkaXJlY3QgY2hpbGQgaXMgYXQgYGRpc3RhbmNlOiAxYC5cbiAgICAgKiBUaGVyZWZvcmUsIGFuIHVwZGF0ZSB3aXRoIGRlcHRoIDEgc2hvdWxkIE5PVCBjb2xsaWRlIHdpdGggYSBjaGlsZCBhdCBkaXN0YW5jZSAxICgxIDwgMSBpcyBmYWxzZSkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHVwZGF0ZURlcHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzVXBkYXRlQ29sbGlzaW9uKHVwZGF0ZURlcHRoLCBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVwdGggPT09IC0xID8gdHJ1ZSA6IGRpc3RhbmNlIDwgdXBkYXRlRGVwdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB2bm9kZSB0cmVlIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgbW91bnRzIHRoZSBjb21wb25lbnQgaW4gY2FzZVxuICAgICAqIC0geW91IHBhc3MgdHJ1ZSBmb3IgdGhlIG1vdW50IHBhcmFtXG4gICAgICogLSBvciB0aGUgYXV0b01vdW50IGNvbmZpZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21vdW50XSBNb3VudCB0aGUgRE9NIGFmdGVyIHRoZSB2bm9kZSBnb3QgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IElmIGdldHRpbmcgdGhlcmUsIHdlIHJldHVybiB0aGUgZGF0YSBmcm9tIHZkb20uSGVscGVyOiBjcmVhdGUoKSwgY29udGFpbmluZyB0aGUgdm5vZGUuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdFZub2RlKG1vdW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYXV0b01vdW50ID0gbW91bnQgfHwgbWUuYXV0b01vdW50LFxuICAgICAgICAgICAge2FwcH0gICAgID0gbWUsXG4gICAgICAgICAgICB7YWxsb3dWZG9tVXBkYXRlc0luVGVzdHMsIHVuaXRUZXN0TW9kZSwgdXNlVmRvbVdvcmtlcn0gPSBOZW8uY29uZmlnO1xuXG4gICAgICAgIGlmICh1bml0VGVzdE1vZGUgJiYgIWFsbG93VmRvbVVwZGF0ZXNJblRlc3RzKSByZXR1cm47XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNyaXRpY2FsIHJlbmRlcmluZyBwYXRoID0+IENTUyBmaWxlcyBmb3IgdGhlIG5ldyB0cmVlIGlzIGluIHBsYWNlXG4gICAgICAgIGlmICghdW5pdFRlc3RNb2RlICYmIGF1dG9Nb3VudCAmJiBjdXJyZW50V29ya2VyLmNvdW50TG9hZGluZ1RoZW1lRmlsZXMgIT09IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRXb3JrZXIub24oJ3RoZW1lRmlsZXNMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAhbWUubW91bnRlZCAmJiBtZS5pbml0Vm5vZGUobW91bnQpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KTtcblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtZS5pc1Zub2RlSW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWFwcC52bm9kZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBhcHAuaXNWbm9kZUluaXRpYWxpemluZyA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS52ZG9tKSB7XG4gICAgICAgICAgICBtZS5pc1Zkb21VcGRhdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBjaGlsZCBjb21wb25lbnRzIGRvIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgd2hpbGUgdGhlIHZub2RlIGdlbmVyYXRpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIFZEb21VcGRhdGUucmVnaXN0ZXJJbkZsaWdodFVwZGF0ZShtZS5pZCwgLTEpO1xuXG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbS5yZW1vdmVEb207XG5cbiAgICAgICAgICAgIG1lLl9uZWVkc1Zkb21VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLmFmdGVyU2V0TmVlZHNWZG9tVXBkYXRlPy4oZmFsc2UsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKE5lby52ZG9tLkhlbHBlci5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWUgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGF1dG9Nb3VudCxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCAgIDogYXV0b01vdW50ID8gbWUuZ2V0TW91bnRlZFBhcmVudElkKCkgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcGFyZW50SW5kZXg6IGF1dG9Nb3VudCA/IG1lLmdldE1vdW50ZWRQYXJlbnRJbmRleCgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHZkb20gICAgICAgOiBUcmVlQnVpbGRlci5nZXRWZG9tVHJlZShtZS52ZG9tLCAtMSksXG4gICAgICAgICAgICAgICAgd2luZG93SWQgICA6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIG1lLm9uSW5pdFZub2RlKGRhdGEudm5vZGUsIHVzZVZkb21Xb3JrZXIgPyBhdXRvTW91bnQgOiBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmIChhdXRvTW91bnQgJiYgIXVzZVZkb21Xb3JrZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHJ1bm5pbmcgd2l0aG91dCBhIFZkb21Xb3JrZXIsIEhlbHBlci5jcmVhdGUgaXMgbG9jYWwgYW5kIHJldHVybnMgYSBwbGFpbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBtYW51YWxseSBzZW5kIHRoZSBpbnNlcnROb2RlIGRlbHRhIHRvIHRoZSBtYWluIHRocmVhZC5cbiAgICAgICAgICAgICAgICBhd2FpdCBOZW8uYXBwbHlEZWx0YXMobWUud2luZG93SWQsIFt7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiAgIDogJ2luc2VydE5vZGUnLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCAgICA6IG1lLmdldE1vdW50ZWRQYXJlbnRJbmRleCgpLFxuICAgICAgICAgICAgICAgICAgICBvdXRlckhUTUw6IGRhdGEub3V0ZXJIVE1MLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCA6IG1lLmdldE1vdW50ZWRQYXJlbnRJZCgpLFxuICAgICAgICAgICAgICAgICAgICB2bm9kZSAgICA6IGRhdGEudm5vZGVcbiAgICAgICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgICAgICBtZS5tb3VudGVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5yZXNvbHZlVmRvbVVwZGF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciB2ZG9tIHVwZGF0ZXMgaW5zaWRlIHRoZSBwYXJlbnQgY2hhaW4gYW5kIGlmIGZvdW5kLlxuICAgICAqIFJlZ2lzdGVycyB0aGUgY29tcG9uZW50IGZvciBhIHZkb20gdXBkYXRlIG9uY2UgZG9uZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWQ9dGhpcy5wYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXSBHZXRzIHBhc3NlZCBieSB1cGRhdGVWZG9tKClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2U9MSBEaXN0YW5jZSBpbnNpZGUgdGhlIGNvbXBvbmVudCB0cmVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQYXJlbnRVcGRhdGluZyhwYXJlbnRJZD10aGlzLnBhcmVudElkLCByZXNvbHZlLCBkaXN0YW5jZT0xKSB7XG4gICAgICAgIGlmIChwYXJlbnRJZCAhPT0gJ2RvY3VtZW50LmJvZHknKSB7XG4gICAgICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBOZW8uZ2V0Q29tcG9uZW50KHBhcmVudElkKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuaXNWZG9tVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbi1mbGlnaHQgdXBkYXRlIGRlcHRoIGZyb20gdGhlIGNlbnRyYWwgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRVcGRhdGVEZXB0aCA9IFZEb21VcGRhdGUuZ2V0SW5GbGlnaHRVcGRhdGVEZXB0aChwYXJlbnQuaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5oYXNVcGRhdGVDb2xsaXNpb24ocGFyZW50VXBkYXRlRGVwdGgsIGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5jb25maWcubG9nVmRvbVVwZGF0ZUNvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3Zkb20gcGFyZW50IHVwZGF0ZSBjb25mbGljdCB3aXRoOicsIHBhcmVudCwgJ2ZvcjonLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgVkRvbVVwZGF0ZS5yZWdpc3RlclBvc3RVcGRhdGUocGFyZW50LmlkLCBtZS5pZCwgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gdXBkYXRlIGlzIHJ1bm5pbmcgYW5kIGRvZXMgbm90IGhhdmUgYSBjb2xsaXNpb24sIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgcGFyZW50c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWUuaXNQYXJlbnRVcGRhdGluZyhwYXJlbnQucGFyZW50SWQsIHJlc29sdmUsIGRpc3RhbmNlKzEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIG5lZWRzVmRvbVVwZGF0ZSBjb25maWcgaW5zaWRlIHRoZSBwYXJlbnQgdHJlZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRJZD10aGlzLnBhcmVudElkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdIGdldHMgcGFzc2VkIGJ5IHVwZGF0ZVZkb20oKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZT0xIERpc3RhbmNlIGluc2lkZSB0aGUgY29tcG9uZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBtZXJnZUludG9QYXJlbnRVcGRhdGUocGFyZW50SWQ9dGhpcy5wYXJlbnRJZCwgZGlzdGFuY2U9MSkge1xuICAgICAgICBpZiAocGFyZW50SWQgIT09ICdkb2N1bWVudC5ib2R5Jykge1xuICAgICAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gTmVvLmdldENvbXBvbmVudChwYXJlbnRJZCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2hlY2tpbmcgZm9yIHBhcmVudC51cGRhdGVEZXB0aCwgc2luY2Ugd2UgY2FyZSBhYm91dCB0aGUgZGVwdGggb2YgdGhlIG5leHQgdXBkYXRlIGN5Y2xlXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5uZWVkc1Zkb21VcGRhdGUgJiYgbWUuaGFzVXBkYXRlQ29sbGlzaW9uKHBhcmVudC51cGRhdGVEZXB0aCwgZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIFZEb21VcGRhdGUucmVnaXN0ZXJNZXJnZWQocGFyZW50LmlkLCBtZS5pZCwgbWUudXBkYXRlRGVwdGgsIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWUubWVyZ2VJbnRvUGFyZW50VXBkYXRlKHBhcmVudC5wYXJlbnRJZCwgZGlzdGFuY2UrMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIGZyb20gdGhlIGluaXRWbm9kZSgpIHByb21pc2Ugc3VjY2VzcyBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZub2RlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhdXRvTW91bnQgTW91bnQgdGhlIERPTSBhZnRlciB0aGUgdm5vZGUgZ290IGNyZWF0ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25Jbml0Vm5vZGUodm5vZGUsIGF1dG9Nb3VudCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcH0gPSBtZTtcblxuICAgICAgICBtZS5pc1Zub2RlSW5pdGlhbGl6aW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgYXBwIGlzIGEgY2hlY2sgdG8gc2VlIGlmIHRoZSBDb21wb25lbnQgZ290IGRlc3Ryb3llZCB3aGlsZSB2bm9kZUluaXRpYWxpc2luZyA9PiBiZWZvcmUgb25Jbml0Vm5vZGUgZ290IHRyaWdnZXJlZFxuICAgICAgICBpZiAoYXBwKSB7XG4gICAgICAgICAgICBpZiAoIWFwcC52bm9kZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgYXBwLmlzVm5vZGVJbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcHAudm5vZGVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXBwLmZpcmUoJ3Zub2RlSW5pdGlhbGl6ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS52bm9kZSA9IHZub2RlO1xuXG4gICAgICAgICAgICBsZXQgY2hpbGRJZHMgPSBDb21wb25lbnRNYW5hZ2VyLmdldENoaWxkSWRzKHZub2RlKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICAgICAgPSBjaGlsZElkcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2hpbGQ7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IE5lby5nZXRDb21wb25lbnQoY2hpbGRJZHNbaV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnZub2RlSW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS52bm9kZUluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGF1dG9Nb3VudCkge1xuICAgICAgICAgICAgICAgIG1lLm1vdW50ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhcHAubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhcHAubW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5maXJlKCdtb3VudGVkJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9taXNlIGJhc2VkIHZkb20gdXBkYXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9taXNlVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWZG9tKHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZm4gdG8gcmVzb2x2ZSB0aGUgUHJvbWlzZSBmb3IgdXBkYXRlVmRvbSgpXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgW2RhdGFdIFRoZSByZXR1cm4gdmFsdWUgb2YgdmRvbS5IZWxwZXIudXBkYXRlKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVzb2x2ZVZkb21VcGRhdGUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmlzVmRvbVVwZGF0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIG1lcmdlZCB1cGRhdGVzXG4gICAgICAgIFZEb21VcGRhdGUuZXhlY3V0ZUNhbGxiYWNrcyhtZS5pZCwgZGF0YSk7XG5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZSBpcyBubyBsb25nZXIgaW4tZmxpZ2h0XG4gICAgICAgIFZEb21VcGRhdGUudW5yZWdpc3RlckluRmxpZ2h0VXBkYXRlKG1lLmlkKTtcblxuICAgICAgICAvLyBUcmlnZ2VyIHVwZGF0ZXMgZm9yIGNvbXBvbmVudHMgdGhhdCB3ZXJlIGluLWZsaWdodFxuICAgICAgICBWRG9tVXBkYXRlLnRyaWdnZXJQb3N0VXBkYXRlcyhtZS5pZCk7XG5cbiAgICAgICAgaWYgKG1lLm5lZWRzVmRvbVVwZGF0ZSkge1xuICAgICAgICAgICAgLy8gYW55IG5ldyBwcm9taXNlIGNhbGxiYWNrcyB3aWxsIGdldCBwaWNrZWQgdXAgYnkgdGhlIG5leHQgdXBkYXRlIGN5Y2xlXG4gICAgICAgICAgICBtZS51cGRhdGUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgbWV0aG9kIGZvciB1dGlsLlZEb20uc3luY1Zkb21TdGF0ZSB0byBhbGxvdyBvdmVycmlkaW5nIChkaXNhYmxpbmcpIGl0XG4gICAgICogQHBhcmFtIHtOZW8udmRvbS5WTm9kZX0gW3Zub2RlPXRoaXMudm5vZGVdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFt2ZG9tPXRoaXMudmRvbV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlPWZhbHNlXG4gICAgICovXG4gICAgc3luY1Zkb21TdGF0ZSh2bm9kZT10aGlzLnZub2RlLCB2ZG9tPXRoaXMudmRvbSwgZm9yY2U9ZmFsc2UpIHtcbiAgICAgICAgVkRvbVV0aWwuc3luY1Zkb21TdGF0ZSh2bm9kZSwgdmRvbSwgZm9yY2UpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBhIGNvbXBvbmVudCByZWNlaXZlcyBhIG5ldyB2bm9kZSwgd2Ugd2FudCB0byBkbzpcbiAgICAgKiAtIHN5bmMgdGhlIHZkb20gaWRzXG4gICAgICogLSBzZXR0aW5nIHZub2RlSW5pdGlhbGl6ZWQgdG8gdHJ1ZSBmb3IgY2hpbGQgY29tcG9uZW50c1xuICAgICAqIC0gdXBkYXRpbmcgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gZW5zdXJlIHRoYXQgdGhlIHZub2RlIHRyZWUgc3RheXMgcGVyc2lzdGVudFxuICAgICAqIEBwYXJhbSB7TmVvLnZkb20uVk5vZGV9IFt2bm9kZT10aGlzLnZub2RlXVxuICAgICAqL1xuICAgIHN5bmNWbm9kZVRyZWUodm5vZGU9dGhpcy52bm9kZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNoaWxkQ29tcG9uZW50cyA9IENvbXBvbmVudE1hbmFnZXIuZ2V0Q2hpbGRyZW4obWUpLFxuICAgICAgICAgICAgZGVidWcgICAgICAgICAgID0gZmFsc2UsXG4gICAgICAgICAgICBtYXAgICAgICAgICAgICAgPSB7fSxcbiAgICAgICAgICAgIGNoaWxkVm5vZGUsIHN0YXJ0O1xuXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuc3luY1Zkb21TdGF0ZSgpO1xuXG4gICAgICAgIGlmICh2bm9kZSAmJiBtZS5pZCAhPT0gdm5vZGUuaWQpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXJXcmFwcGVyTm9kZSh2bm9kZS5pZCwgbWUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBuZWVkIG9uZSBzZXBhcmF0ZSBpdGVyYXRpb24gZmlyc3QgdG8gZW5zdXJlIGFsbCB3cmFwcGVyIG5vZGVzIGdldCByZWdpc3RlcmVkXG4gICAgICAgIGNoaWxkQ29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBjaGlsZFZub2RlID0gVk5vZGVVdGlsLmZpbmQobWUudm5vZGUsIGNvbXBvbmVudC52ZG9tLmlkKT8udm5vZGU7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZFZub2RlKSB7XG4gICAgICAgICAgICAgICAgbWFwW2NvbXBvbmVudC5pZF0gPSBjaGlsZFZub2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5pZCAhPT0gY2hpbGRWbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyV3JhcHBlck5vZGUoY2hpbGRWbm9kZS5pZCwgY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGVsZWdhdGUgdGhlIGxhdGVzdCBub2RlIHVwZGF0ZXMgdG8gYWxsIHBvc3NpYmxlIGNoaWxkIGNvbXBvbmVudHMgZm91bmQgaW5zaWRlIHRoZSB2bm9kZSB0cmVlXG4gICAgICAgIGNoaWxkQ29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICAgICAgICBjaGlsZFZub2RlID0gbWFwW2NvbXBvbmVudC5pZF07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZFZub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5fdm5vZGUgPSBDb21wb25lbnRNYW5hZ2VyLmFkZFZub2RlQ29tcG9uZW50UmVmZXJlbmNlcyhjaGlsZFZub2RlLCBjb21wb25lbnQuaWQpO1xuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnZub2RlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tb3VudGVkICAgICAgICAgID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3N5bmNWbm9kZVRyZWU6IENvdWxkIG5vdCByZXBsYWNlIHRoZSBjaGlsZCB2bm9kZSBmb3InLCBjb21wb25lbnQuaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgbWUuX3Zub2RlID0gdm5vZGUgPyBDb21wb25lbnRNYW5hZ2VyLmFkZFZub2RlQ29tcG9uZW50UmVmZXJlbmNlcyh2bm9kZSwgbWUuaWQpIDogbnVsbDtcblxuICAgICAgICBkZWJ1ZyAmJiBjb25zb2xlLmxvZygnc3luY1Zub2RlVHJlZScsIG1lLmlkLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmFmdGVyU2V0VmRvbSh0aGlzLnZkb20sIG51bGwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIHZkb20gY29uZmlnIGdldHMgY2hhbmdlZCBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgYWxyZWFkeSBtb3VudGVkIChkZWx0YSB1cGRhdGVzKS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVzb2x2ZV0gdXNlZCBieSBwcm9taXNlVXBkYXRlKClcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcmVqZWN0XSB1c2VkIGJ5IHByb21pc2VVcGRhdGUoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGVWZG9tKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgcmVzb2x2ZT8uKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW91bnRlZCwgcGFyZW50SWQsIHZub2RlfSA9IG1lLFxuICAgICAgICAgICAge2NvbmZpZ30gICAgICAgICAgICAgICAgICAgPSBOZW87XG5cbiAgICAgICAgaWYgKGNvbmZpZy51bml0VGVzdE1vZGUgJiYgIWNvbmZpZy5hbGxvd1Zkb21VcGRhdGVzSW5UZXN0cykge1xuICAgICAgICAgICAgcmVqZWN0Py4oKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmlzVmRvbVVwZGF0aW5nIHx8ICFtZS52bm9kZUluaXRpYWxpemVkIHx8IG1lLnNpbGVudFZkb21VcGRhdGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUgJiYgVkRvbVVwZGF0ZS5hZGRQcm9taXNlQ2FsbGJhY2sobWUuaWQsIHJlc29sdmUpO1xuICAgICAgICAgICAgbWUubmVlZHNWZG9tVXBkYXRlID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHByb21pc2UsIHJlZ2lzdGVyIGl0IGFnYWluc3QgdGhpcyBjb21wb25lbnQncyBJRCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIC8vIFRoZSBtYW5hZ2VyIHdpbGwgZW5zdXJlIGl0J3MgY2FsbGVkIHdoZW4gdGhlIGFwcHJvcHJpYXRlIHVwZGF0ZSBjeWNsZSBjb21wbGV0ZXMuXG4gICAgICAgICAgICByZXNvbHZlICYmIFZEb21VcGRhdGUuYWRkUHJvbWlzZUNhbGxiYWNrKG1lLmlkLCByZXNvbHZlKTtcblxuICAgICAgICAgICAgLy8gSWYgYW4gdXBkYXRlIGlzIHRyaWdnZXJlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LCB3ZSBtdXN0IHdhaXQgZm9yIGl0IHRvIGJlIG1vdW50ZWQuXG4gICAgICAgICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBmbGFnIHRvIHByZXZlbnQgc2V0dGluZyB1cCBtdWx0aXBsZSBgdGhlbmAgbGlzdGVuZXJzIGZvciBzdWJzZXF1ZW50IHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGFycml2ZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAgICAgICAgICAgIGlmICghbWUuaXNBd2FpdGluZ01vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzQXdhaXRpbmdNb3VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1vdW50ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuaXNBd2FpdGluZ01vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciBtb3VudGluZywgcmUtdHJpZ2dlciB0aGUgdXBkYXRlIGN5Y2xlLiBUaGUgY2FjaGVkIGNhbGxiYWNrcyB3aWxsIGJlIHBpY2tlZCB1cC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnZub2RlICYmIG1lLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIW1lLm1lcmdlSW50b1BhcmVudFVwZGF0ZShwYXJlbnRJZClcbiAgICAgICAgICAgICAgICAgICAgJiYgIW1lLmlzUGFyZW50VXBkYXRpbmcocGFyZW50SWQsIHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgICYmIG1vdW50ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgdm5vZGVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1lcmdlZCBjaGlsZCB1cGRhdGVzIGFuZCBhZGp1c3QgdGhlIHVwZGF0ZSBkZXB0aCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAgICBsZXQgYWRqdXN0ZWREZXB0aCA9IFZEb21VcGRhdGUuZ2V0QWRqdXN0ZWRVcGRhdGVEZXB0aChtZS5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdGVkRGVwdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gYWRqdXN0ZWREZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjcml0aWNhbCByZW5kZXJpbmcgcGF0aCA9PiBDU1MgZmlsZXMgZm9yIHRoZSBuZXcgdHJlZSBpcyBpbiBwbGFjZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5pc01pZGRsZXdhcmUgJiYgIWNvbmZpZy51bml0VGVzdE1vZGUgJiYgY3VycmVudFdvcmtlci5jb3VudExvYWRpbmdUaGVtZUZpbGVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50V29ya2VyLm9uKCd0aGVtZUZpbGVzTG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudXBkYXRlVmRvbShyZXNvbHZlLCByZWplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuZXhlY3V0ZVZkb21VcGRhdGUobnVsbCwgcmVqZWN0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhWZG9tTGlmZWN5Y2xlKTtcbiIsImltcG9ydCBCYXNlICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBOZW9BcnJheSBmcm9tICcuLi91dGlsL0FycmF5Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby51dGlsLktleU5hdmlnYXRpb25cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgS2V5TmF2aWdhdGlvbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuS2V5TmF2aWdhdGlvbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnV0aWwuS2V5TmF2aWdhdGlvbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdrZXluYXYnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAna2V5bmF2JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsbHkgc3RvcmVzIHRoZSBjb21wb25lbnQgaWQgaW5zaWRlIF9jb21wb25lbnRcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGluIGNhc2UgdGhlIGtleWRvd24gZXZlbnQgaXMgc3VwcG9zZWQgdG8gYnViYmxlIHVwd2FyZHMgaW5zaWRlIHRoZSBjb21wb25lbnQgdHJlZVxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBrZXlEb3duRXZlbnRCdWJibGU9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGtleURvd25FdmVudEJ1YmJsZTogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBrZXlzXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5c186IG51bGxcbiAgICB9XG5cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fa2V5cy5wdXNoKC4uLnRoaXMucGFyc2VLZXlzKHZhbHVlKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZX1cbiAgICAgKi9cbiAgICBiZWZvcmVHZXRDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBOZW8uZ2V0Q29tcG9uZW50KHRoaXMuX2NvbXBvbmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGNvbXBvbmVudCBpZFxuICAgICAqL1xuICAgIGJlZm9yZVNldENvbXBvbmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU/LmlkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbktleURvd24oZGF0YSkge1xuICAgICAgICAvLyBVc2luZyB0aGUgY2hyb21lIGF1dG8tZmlsbCBmZWF0dXJlIGRvZXMgdHJpZ2dlciBhIGtleWRvd24gZXZlbnQsIG5vdCBjb250YWluaW5nIGEga2V5LiBTZWU6ICM2NFxuICAgICAgICBpZiAoZGF0YS5rZXkpIHtcbiAgICAgICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHVwcGVyQ2FzZUtleSA9IGRhdGEua2V5LnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgc2NvcGU7XG5cbiAgICAgICAgICAgIHVwcGVyQ2FzZUtleSA9IG1lLnBhcnNlVXBwZXJDYXNlS2V5KHVwcGVyQ2FzZUtleSk7XG5cbiAgICAgICAgICAgIG1lLmtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gTmVvLmlzU3RyaW5nKGtleS5zY29wZSkgPyBOZW8uZ2V0KGtleS5zY29wZSkgOiBrZXkuc2NvcGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LmtleS50b1VwcGVyQ2FzZSgpID09PSB1cHBlckNhc2VLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKGtleS5mbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5mbi5hcHBseShzY29wZSwgW2RhdGEsIG1lLmNvbXBvbmVudF0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtrZXkuZm5dPy5hcHBseShzY29wZSwgW2RhdGEsIG1lLmNvbXBvbmVudF0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZUtleXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudElkID0gdGhpcy5fY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGtleUFycmF5ICAgID0gW107XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCB2YWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdzY29wZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUFycmF5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuICAgOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiB2YWx1ZS5zY29wZSB8fCBjb21wb25lbnRJZCAvLyB0b2RvOiBzdXBwb3J0IFZDcyBsYXRlciBvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBrZXlBcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgc3BlY2lmaWMga2V5IG5hbWVzLCBlLmcuIFwiIFwiID0+IFNQQUNFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHBhcnNlVXBwZXJDYXNlS2V5KGtleSkge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ1NQQUNFJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQVJST1dET1dOJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnRE9XTic7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0FSUk9XTEVGVCc6XG4gICAgICAgICAgICAgICAga2V5ID0gJ0xFRlQnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV1JJR0hUJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnUklHSFQnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdBUlJPV1VQJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnVVAnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgbWUua2V5cyAgICAgID0gbWUucGFyc2VLZXlzKG1lLmtleXMpO1xuXG4gICAgICAgIGNvbXBvbmVudC5hZGREb21MaXN0ZW5lcnMoe1xuICAgICAgICAgICAga2V5ZG93bjoge1xuICAgICAgICAgICAgICAgIGJ1YmJsZTogbWUua2V5RG93bkV2ZW50QnViYmxlLFxuICAgICAgICAgICAgICAgIGZuICAgIDogbWUub25LZXlEb3duLFxuICAgICAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBrZXkgbGlzdGVuZXIgdXNpbmcgdGhlIHNhbWUgY29uZmlnIHVzZWQgd2hlbiBjcmVhdGluZyBpdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICByZW1vdmVLZXkoY29uZmlnKSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleXMgPSBtZS5fa2V5cyxcbiAgICAgICAgICAgIGkgICAgPSAwLFxuICAgICAgICAgICAgbGVuICA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNFcXVhbChrZXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG11bHRpcGxlIGtleSBsaXN0ZW5lcnMgcGFzc2luZyBhbiBhcnJheSBvZiBjb25maWcgaXRlbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICAgICAqL1xuICAgIHJlbW92ZUtleXMoaXRlbXMpIHtcbiAgICAgICAgQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMuZm9yRWFjaChpdGVtID0+IHRoaXMucmVtb3ZlS2V5KGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHRoZSBkb20gbGlzdGVuZXIgZnJvbSB0aGUgb3duZXIgY29tcG9uZW50XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhLZXlOYXZpZ2F0aW9uKTtcbiIsImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udXRpbC5TdHlsZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBTdHlsZSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnV0aWwuU3R5bGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby51dGlsLlN0eWxlJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZGVsdGEgb2JqZWN0LCBjb250YWluaW5nIHRoZSBzdHlsZXMgb2YgbmV3U3R5bGUgd2hpY2ggYXJlIG5vdCBpbmNsdWRlZCBvciBkaWZmZXJlbnQgdGhhbiBpbiBvbGRTdHlsZVxuICAgICAqIFN0eWxlcyBpbmNsdWRlZCBpbiBvbGRTdHlsZSBidXQgbWlzc2luZyBpbiBuZXdTdHlsZSB3aWxsIGdldCBhIHZhbHVlIG9mIG51bGxcbiAgICAgKiBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9zdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbmV3U3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9sZFN0eWxlXG4gICAgICogQHJldHVybnMge09iamVjdH0gc3R5bGUgZGVsdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVN0eWxlcyhuZXdTdHlsZSwgb2xkU3R5bGUpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IHt9O1xuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcobmV3U3R5bGUpKSB7XG4gICAgICAgICAgICBuZXdTdHlsZSA9IE5lby5jcmVhdGVTdHlsZU9iamVjdChuZXdTdHlsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOZW8uaXNTdHJpbmcob2xkU3R5bGUpKSB7XG4gICAgICAgICAgICBvbGRTdHlsZSA9IE5lby5jcmVhdGVTdHlsZU9iamVjdChvbGRTdHlsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3U3R5bGUgJiYgIW9sZFN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKCFvbGRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIE5lby5jbG9uZShuZXdTdHlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1N0eWxlICYmIE9iamVjdC5rZXlzKG5ld1N0eWxlKS5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSB8fCBvbGRTdHlsZVtzdHlsZV0gIT09IG5ld1N0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNbc3R5bGVdID0gbmV3U3R5bGVbc3R5bGVdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFN0eWxlKS5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld1N0eWxlICB8fCAhbmV3U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzdHlsZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFN0eWxlKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlci9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBBIHNpbmdsZXRvbiB1dGlsaXR5IGNsYXNzIHJlc3BvbnNpYmxlIGZvciByZWN1cnNpdmVseSBidWlsZGluZyBWRE9NIGFuZCBWTm9kZSB0cmVlcy5cbiAqIEl0IGNhbiBleHBhbmQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aGluIGEgdHJlZSBzdHJ1Y3R1cmUgaW50byB0aGVpciBmdWxsIFZET00vVk5vZGUgcmVwcmVzZW50YXRpb25zLFxuICogc3VwcG9ydGluZyBzZWxlY3RpdmUgKGFzeW1tZXRyaWMpIHRyZWUgZXhwYW5zaW9uIGZvciBvcHRpbWl6ZWQgdXBkYXRlcy5cbiAqIEBjbGFzcyBOZW8udXRpbC52ZG9tLlRyZWVCdWlsZGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFRyZWVCdWlsZGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udXRpbC52ZG9tLlRyZWVCdWlsZGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udXRpbC52ZG9tLlRyZWVCdWlsZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaGVscGVyIHRvIHJlY3Vyc2l2ZWx5IGJ1aWxkIGEgdHJlZSwgYWJzdHJhY3RpbmcgdGhlIGNoaWxkIG5vZGUga2V5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIFRoZSB2ZG9tIG9yIHZub2RlIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIFRoZSBjdXJyZW50IHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge1NldDxTdHJpbmc+fG51bGx9IG1lcmdlZENoaWxkSWRzIEEgc2V0IG9mIGNvbXBvbmVudCBJRHMgdG8gc2VsZWN0aXZlbHkgZXhwYW5kLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGlsZEtleSBUaGUgcHJvcGVydHkgbmFtZSBmb3IgY2hpbGQgbm9kZXMgKCdjbicgb3IgJ2NoaWxkTm9kZXMnKS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2J1aWxkVHJlZShub2RlLCBkZXB0aCwgbWVyZ2VkQ2hpbGRJZHMsIGNoaWxkS2V5KSB7XG4gICAgICAgIC8vIFdlIGNhbiBub3QgdXNlIE5lby5pc09iamVjdCgpIGhlcmUsIHNpbmNlIGluc2lkZSB1bml0LXRlc3Qgc2NlbmFyaW9zLCB3ZSB3aWxsIGltcG9ydCB2ZG9tLkhlbHBlciBpbnRvIG1haW4gdGhyZWFkcy5cbiAgICAgICAgLy8gSW5zaWRlIHRoaXMgc2NlbmFyaW8sIE5lby5pc09iamVjdCgpIHJldHVybnMgZmFsc2UgZm9yIFZOb2RlIGluc3RhbmNlc1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0ID0gey4uLm5vZGV9OyAvLyBTaGFsbG93IGNvcHlcblxuICAgICAgICBpZiAobm9kZVtjaGlsZEtleV0pIHtcbiAgICAgICAgICAgIG91dHB1dFtjaGlsZEtleV0gPSBbXTtcblxuICAgICAgICAgICAgbm9kZVtjaGlsZEtleV0uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJdGVtLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBydW5lIHRoZSBicmFuY2ggb25seSBpZiB3ZSBhcmUgYXQgdGhlIGJvdW5kYXJ5IEFORCB0aGUgY2hpbGQgaXMgbm90IHBhcnQgb2YgYSBtZXJnZWQgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMSAmJiAhbWVyZ2VkQ2hpbGRJZHM/LmhhcyhjdXJyZW50SXRlbS5jb21wb25lbnRJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtjaGlsZEtleV0ucHVzaCh7Li4uY3VycmVudEl0ZW0sIG5lb0lnbm9yZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8vIFN0b3AgcHJvY2Vzc2luZyB0aGlzIGJyYW5jaFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgYnJhbmNoIGlmIGl0J3MgcGFydCBvZiBhIG1lcmdlZCB1cGRhdGUsIG9yIGlmIHRoZSBkZXB0aCByZXF1aXJlcyBpdFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA+IDEgfHwgZGVwdGggPT09IC0xIHx8IG1lcmdlZENoaWxkSWRzPy5oYXMoY3VycmVudEl0ZW0uY29tcG9uZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBDb21wb25lbnRNYW5hZ2VyLmdldChjdXJyZW50SXRlbS5jb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGNvcnJlY3QgdHJlZSB0eXBlIGJhc2VkIG9uIHRoZSBjaGlsZEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50VHJlZSA9IGNoaWxkS2V5ID09PSAnY24nID8gY29tcG9uZW50Py52ZG9tIDogY29tcG9uZW50Py52bm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEl0ZW0gPSBjb21wb25lbnRUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoID0gKGRlcHRoID09PSAtMSkgPyAtMSA6IE1hdGgubWF4KDAsIGRlcHRoIC0gMSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZERlcHRoID0gZGVwdGhcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRwdXRbY2hpbGRLZXldLnB1c2godGhpcy4jYnVpbGRUcmVlKGN1cnJlbnRJdGVtLCBjaGlsZERlcHRoLCBtZXJnZWRDaGlsZElkcywgY2hpbGRLZXkpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIGdpdmVuIHZkb20gdHJlZSBhbmQgcmVwbGFjZXMgY2hpbGQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aCB0aGVpciB2ZG9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtkZXB0aD0tMV1cbiAgICAgKiBAcGFyYW0ge1NldDxTdHJpbmc+fG51bGx9IFttZXJnZWRDaGlsZElkcz1udWxsXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0VmRvbVRyZWUodmRvbSwgZGVwdGg9LTEsIG1lcmdlZENoaWxkSWRzPW51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1aWxkVHJlZSh2ZG9tLCBkZXB0aCwgbWVyZ2VkQ2hpbGRJZHMsICdjbicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgZ2l2ZW4gdm5vZGUgdHJlZSBhbmQgcmVwbGFjZXMgY2hpbGQgY29tcG9uZW50IHJlZmVyZW5jZXMgd2l0aCB0aGVpciB2bm9kZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdm5vZGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlcHRoPS0xXVxuICAgICAqIEBwYXJhbSB7U2V0PFN0cmluZz58bnVsbH0gW21lcmdlZENoaWxkSWRzPW51bGxdXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWbm9kZVRyZWUodm5vZGUsIGRlcHRoPS0xLCBtZXJnZWRDaGlsZElkcz1udWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNidWlsZFRyZWUodm5vZGUsIGRlcHRoLCBtZXJnZWRDaGlsZElkcywgJ2NoaWxkTm9kZXMnKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVHJlZUJ1aWxkZXIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==