"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_plugin_Resizable_mjs"],{

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ }),

/***/ "./src/plugin/Resizable.mjs":
/*!**********************************!*\
  !*** ./src/plugin/Resizable.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Base.mjs */ "./src/plugin/Base.mjs");




/**
 * @class Neo.plugin.Resizable
 * @extends Neo.plugin.Base
 */
class Resizable extends _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Resize cursor styles use north, south based names, so we need a mapping.
     * The order has to match the static positions array.
     * @member {String[]} cursorPositions=['s','sw','se','w','e','n','nw','ne']
     * @protected
     * @static
     */
    static cursorPositions = ['s', 'sw', 'se', 'w', 'e', 'n', 'nw', 'ne']
    /**
     * remove - chars
     * @member {RegExp} nameRegEx=/-([a-z])/g
     * @protected
     * @static
     */
    static nameRegEx = /-([a-z])/g
    /**
     * Internal position names
     * @member {String[]} validDirections=['bottom','bottom-left','bottom-right','left','right','top','top-left','top-right']
     * @static
     */
    static positions = ['bottom', 'bottom-left', 'bottom-right', 'left', 'right', 'top', 'top-left', 'top-right']
    /**
     * Directions into which you want to drag => resize
     * @member {String[]} validDirections=['b','bl','br','l','r','t','tl','tr']
     * @static
     */
    static validDirections = ['b', 'bl', 'br', 'l', 'r', 't', 'tl', 'tr']

    static config = {
        /**
         * @member {String} className='Neo.plugin.Resizable'
         * @protected
         */
        className: 'Neo.plugin.Resizable',
        /**
         * @member {String} ntype='plugin-resizable'
         * @protected
         */
        ntype: 'plugin-resizable',
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName_=null
         * @reactive
         */
        appName_: null,
        /**
         * @member {String|null} boundaryContainerId='document.body'
         */
        boundaryContainerId: 'document.body',
        /**
         * The DOMRect of the boundaryContainer if set (measured on drag:start)
         * @member {Object} boundaryContainerRect=null
         * @protected
         */
        boundaryContainerRect: null,
        /**
         * @member {String} currentNodeName=null
         * @protected
         */
        currentNodeName: null,
        /**
         * Must be set by each owner
         * @member {String} delegationCls=null
         */
        delegationCls: null,
        /**
         * Directions into which you want to drag => resize
         * @member {String[]} directions_=['b','bl','br','l','r','t','tl','tr']
         * @reactive
         */
        directions_: ['b', 'bl', 'br', 'l', 'r', 't', 'tl', 'tr'],
        /**
         * @member {Neo.draggable.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * @member {Number} gap=10
         * @protected
         */
        gap: 10,
        /**
         * The DOMRect of the element to drag (measured on drag:start)
         * @member {Object} initialRect=null
         * @protected
         */
        initialRect: null,
        /**
         * @member {Boolean} isDragging=false
         */
        isDragging: false,
        /**
         * maximum height when resizing in px
         * @member {Number|null} maxHeight=null
         */
        maxHeight: null,
        /**
         * maximum width when resizing in px
         * @member {Number|null} maxWidth=null
         */
        maxWidth: null,
        /**
         * minimum height when resizing in px
         * @member {Number} minHeight=200
         */
        minHeight: 200,
        /**
         * minimum width when resizing in px
         * @member {Number} minWidth=200
         */
        minWidth: 200,
        /**
         * @member {Object} nodeBottom=null
         * @protected
         */
        nodeBottom: null,
        /**
         * @member {Object} nodeBottomLeft=null
         * @protected
         */
        nodeBottomLeft: null,
        /**
         * @member {Object} nodeBottomRight=null
         * @protected
         */
        nodeBottomRight: null,
        /**
         * @member {Object} nodeLeft=null
         * @protected
         */
        nodeLeft: null,
        /**
         * @member {Object} nodeRight=null
         * @protected
         */
        nodeRight: null,
        /**
         * @member {Object} nodeTop=null
         * @protected
         */
        nodeTop: null,
        /**
         * @member {Object} nodeTopLeft=null
         * @protected
         */
        nodeTopLeft: null,
        /**
         * @member {Object} nodeTopRight=null
         * @protected
         */
        nodeTopRight: null,
        /**
         * vdom node which matches the delegationCls to add resize handles
         * @member {Object} targetNode=null
         * @protected
         */
        targetNode: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.owner.addDomListeners([
            {'drag:end'  : me.onDragEnd,    scope: me, delegate: '.neo-resizable'},
            {'drag:move' : me.onDragMove,   scope: me, delegate: '.neo-resizable'},
            {'drag:start': me.onDragStart,  scope: me, delegate: '.neo-resizable'},
            {mousedown   : me.onMouseDown,  scope: me, delegate: '.neo-resizable'},
            {mousemove   : me.onMouseMove,  scope: me, local   : true},
            {mouseleave  : me.onMouseLeave, scope: me, delegate: `.${me.delegationCls}`},
            {mouseup     : me.onMouseUp,    scope: me, delegate: '.neo-resizable'}
        ])
    }

    /**
     *
     */
    addBodyCursorCls() {
        Neo.applyDeltas(this.appName, {
            id : 'document.body',
            cls: {
                add   : [`neo-cursor-${Resizable.cursorPositions[Resizable.positions.indexOf(this.currentNodeName)]}-resize`],
                remove: []
            }
        })
    }

    /**
     * @param {String} name
     * @returns {Boolean} true
     */
    addNode(name) {
        let me           = this,
            nodeName     = 'node' + Neo.capitalize(name.replace(Resizable.nameRegEx, (str, letter) => letter.toUpperCase())),
            {targetNode} = me;

        if (targetNode) {
            me.currentNodeName = name;
            me[nodeName] = {cls: ['neo-resizable', `neo-resizable-${name}`]};

            targetNode.cn = targetNode.cn || [];
            targetNode.cn.push(me[nodeName]);

            return true
        }

        return false
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        if (this.dragZone) {
            this.dragZone.appName = value
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        let me = this;

        value && Neo.currentWorker.insertThemeFiles(value, me.__proto__);

        if (me.dragZone) {
            me.dragZone.windowId = value
        }
    }

    /**
     * Triggered before the directions config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetDirections(value, oldValue) {
        if (Array.isArray(value)) {
            let i   = 0,
                len = value.length;

            for (; i < len; i++) {
                if (this.beforeSetEnumValue(value[i], oldValue, 'directions', 'validDirections') !== value[i]) {
                    return oldValue
                }
            }
        }

        return value
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        let me      = this,
            {owner} = me,
            style   = owner.wrapperStyle; // todo: delegation target

        Object.assign(me, {
            boundaryContainerRect: null,
            initialRect          : null,
            isDragging           : false
        });

        Object.assign(style, {
            opacity  : 1,
            transform: 'none',
            ...me.dragZone.dragProxy.wrapperStyle
        });

        owner.wrapperStyle = style;

        me.removeBodyCursorCls();

        me.dragZone.dragEnd();
        me.removeAllNodes();

        owner.focus(owner.id, true)
    }

    /**
     * @param {Object} data
     */
    onDragMove(data) {
        let me     = this,
            node   = me.currentNodeName,
            ctRect = me.boundaryContainerRect,
            {maxHeight, maxWidth, minHeight, minWidth} = me,
            rect   = me.initialRect,
            dist, size, style;

        if (!node) {
            me.onDragEnd({})
        } else if (me.dragZone.dragProxy) {
            style = me.dragZone.dragProxy.wrapperStyle;

            if (node.includes('bottom')) {
                size = Math.max(minHeight, data.clientY - rect.top);

                if (maxHeight) {
                    size = Math.min(size, maxHeight);
                }

                if (ctRect) {
                    size = Math.min(size, ctRect.bottom - rect.top);
                }

                style.height = `${size}px`
            } else if (node.includes('top')) {
                dist = Math.min(rect.bottom - minHeight, data.clientY);
                size = Math.max(minHeight, rect.height + rect.top - data.clientY);

                if (maxHeight) {
                    dist = Math.max(dist, rect.bottom - maxHeight);
                    size = Math.min(size, maxHeight)
                }

                if (ctRect) {
                    dist = Math.max(dist, ctRect.top);
                    size = Math.min(size, rect.bottom - ctRect.top)
                }

                style.height = `${size}px`;
                style.top    = `${dist}px`
            }

            if (node.includes('left')) {
                dist = Math.min(rect.right - minWidth, data.clientX);
                size = Math.max(minWidth, rect.width + rect.left - data.clientX);

                if (maxWidth) {
                    dist = Math.max(dist, rect.right - maxWidth);
                    size = Math.min(size, maxWidth)
                }

                if (ctRect) {
                    dist = Math.max(dist, ctRect.left);
                    size = Math.min(size, rect.right - ctRect.left)
                }

                style.left  = `${dist}px`;
                style.width = `${size}px`
            } else if (node.includes('right')) {
                size = Math.max(minWidth, rect.width - rect.right + data.clientX);

                if (maxWidth) {
                    size = Math.min(size, maxWidth)
                }

                if (ctRect) {
                    size = Math.min(size, ctRect.right - rect.left)
                }

                style.width = `${size}px`
            }

            me.dragZone.dragProxy.wrapperStyle = style
        }
    }

    /**
     * @param {Object} data
     */
    onDragStart(data) {
        let me                         = this,
            containerId                = me.boundaryContainerId,
            i                          = 0,
            len                        = data.path.length,
            {appName, owner, windowId} = me,
            style                      = owner.wrapperStyle, // todo: delegation target
            target, vdom, vdomStyle;

        me.isDragging = true;

        style.opacity = 0.3;
        owner.wrapperStyle = style;

        for (; i < len; i++) {
            target = data.path[i];

            if (target.cls.includes(me.delegationCls)) {
                me.initialRect = target.rect
            }

            if (containerId) {
                if (containerId === 'document.body' && target.tagName === 'body' || containerId === target.id) {
                    me.boundaryContainerRect = target.rect;
                    break // assuming that the dragEl is not outside of the container
                }
            }
        }

        if (!me.boundaryContainerRect) {
            owner.getDomRect(me.boundaryContainerRect).then(rect => {
                me.boundaryContainerRect = rect
            })
        }

        me.addBodyCursorCls();

        if (!me.dragZone) {
            vdom      = Neo.clone(owner.vdom, true);
            vdomStyle = vdom.style;

            delete vdom.height;
            delete vdom.width;

            delete vdomStyle.height;
            delete vdomStyle.left;
            delete vdomStyle.top;
            delete vdomStyle.width;

            vdomStyle.opacity = 0.7;

            me.dragZone = Neo.create({
                module             : _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                appName,
                boundaryContainerId: owner.boundaryContainerId,
                dragElement        : vdom,
                moveInMainThread   : false,
                owner,
                windowId,
                ...me.dragZoneConfig
            })
        } else {
            me.dragZone.boundaryContainerId = owner.boundaryContainerId
        }

        me.dragZone.dragStart(data)
    }

    /**
     * See: https://github.com/neomjs/neo/issues/2431
     * @param {Object} data
     */
    onMouseDown(data) {
        this.isDragging = true
    }

    /**
     * @param {Object} data
     */
    onMouseMove(data) {
        let me  = this,
            dir = me.directions,
            i   = 0,
            {gap, owner, targetNode} = me,
            h   = false,
            len = data.path.length,
            bottom, left, right, target, top;

        if (!me.isDragging && !owner.isDragging) {
            for (; i < len; i++) {
                if (data.path[i].cls.includes(me.delegationCls)) {
                    target = data.path[i];
                    break
                }
            }

            if (target) {
                if (target.id !== targetNode?.id) {
                    if (targetNode) {
                        me.removeAllNodes()
                    }

                    me.targetNode = owner.getVdomChild(target.id)
                }

                bottom = data.clientY >= target.rect.y - gap + target.rect.height;
                left   = data.clientX <= target.rect.x + gap;
                right  = data.clientX >= target.rect.x - gap + target.rect.width;
                top    = data.clientY <= target.rect.y + gap;

                if (me.nodeBottom && (!bottom || bottom && left  || bottom && right)) {h = me.removeNode('bottom')}
                if (me.nodeLeft   && (!left   || bottom && left  || top    && left))  {h = me.removeNode('left')}
                if (me.nodeRight  && (!right  || bottom && right || top    && right)) {h = me.removeNode('right')}
                if (me.nodeTop    && (!top    || top    && left  || top    && right)) {h = me.removeNode('top')}

                if (me.nodeBottomLeft  && (!bottom || !left))  {h = me.removeNode('bottom-left')}
                if (me.nodeBottomRight && (!bottom || !right)) {h = me.removeNode('bottom-right')}
                if (me.nodeTopLeft     && (!top    || !left))  {h = me.removeNode('top-left')}
                if (me.nodeTopRight    && (!top    || !right)) {h = me.removeNode('top-right')}

                if      (dir.includes('bl') && bottom && left)  {if (!me.nodeBottomLeft)  {h = me.addNode('bottom-left')}}
                else if (dir.includes('br') && bottom && right) {if (!me.nodeBottomRight) {h = me.addNode('bottom-right')}}
                else if (dir.includes('tl') && top    && left)  {if (!me.nodeTopLeft)     {h = me.addNode('top-left')}}
                else if (dir.includes('tr') && top    && right) {if (!me.nodeTopRight)    {h = me.addNode('top-right')}}
                else if (dir.includes('b')  && bottom)          {if (!me.nodeBottom)      {h = me.addNode('bottom')}}
                else if (dir.includes('l')  && left)            {if (!me.nodeLeft)        {h = me.addNode('left')}}
                else if (dir.includes('r')  && right)           {if (!me.nodeRight)       {h = me.addNode('right')}}
                else if (dir.includes('t')  && top)             {if (!me.nodeTop)         {h = me.addNode('top')}}

                h && owner.update()
            }
        }
    }

    /**
     * @param {Object} data
     */
    onMouseLeave(data) {
        let me = this;

        if (!me.isDragging && !me.owner.isDragging) {
            // limit the event to delegation targets
            if (data.path[0].cls.includes(me.delegationCls)) {
                me.removeAllNodes()
            }
        }
    }

    /**
     * See: https://github.com/neomjs/neo/issues/2431
     * @param {Object} data
     */
    onMouseUp(data) {
        this.isDragging = false
    }

    /**
     * There should be max 1 node (resize handle) at any given time.
     * see: /issues/1139
     */
    removeAllNodes() {
        let me = this;

        if (me.currentNodeName) {
            me.removeNode(me.currentNodeName);
            me.owner.update();

            me.currentNodeName = null;
            me.targetNode      = null
        }
    }

    /**
     *
     */
    removeBodyCursorCls() {
        Neo.applyDeltas(this.appName, {
            id : 'document.body',
            cls: {
                add   : [],
                remove: [`neo-cursor-${Resizable.cursorPositions[Resizable.positions.indexOf(this.currentNodeName)]}-resize`]
            }
        })
    }

    /**
     * @param {String} name
     * @returns {Boolean} true in case the node existed
     */
    removeNode(name) {
        let me       = this,
            nodeName = 'node' + Neo.capitalize(name.replace(Resizable.nameRegEx, (str, letter) => letter.toUpperCase()));

        if (me[nodeName]) {
            me.currentNodeName = null;
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].remove(me.targetNode.cn, me[nodeName]);
            me[nodeName] = null;

            return true
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Resizable));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19wbHVnaW5fUmVzaXphYmxlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUk7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZGVztBQUNSO0FBQ1A7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Is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WUFBWSx1REFBUTtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx5QkFBeUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL1Jlc2l6YWJsZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgcGx1Z2luIGltcGxlbWVudGF0aW9ucy5cbiAqIFBsdWdpbnMgYXJlIGludGVuZGVkIHRvIGdldCBwdXQgaW50byB0aGUgcGx1Z2lucyBjb25maWcgb2YgY29tcG9uZW50LkJhc2VcbiAqIHRvIGVuaGFuY2UgdGhlbSBvciBhZGQgYWRkaXRpb25hbCBmZWF0dXJlc1xuICogQGNsYXNzIE5lby5wbHVnaW4uQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBQbHVnaW4gZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5wbHVnaW4uQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnBsdWdpbi5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBwbHVnaW4gbnR5cGVzIG5lZWQgdG8gc3RhcnQgd2l0aCAncGx1Z2luLScgdG8gZW5zdXJlIHRoYXQgY29tcG9uZW50LkJhc2U6IGdldFBsdWdpbigpIGNhbiBmaW5kIHRoZW1cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V9IG93bmVyPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ8bnVsbH0gd2luZG93SWRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZF86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWU7XG5cbiAgICAgICAgaWYgKG93bmVyLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJDb25zdHJ1Y3RlZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUub25Pd25lckNvbnN0cnVjdGVkKClcbiAgICAgICAgICAgIH0sIG1lLCB7b25jZTogdHJ1ZX0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3duZXIubW91bnRlZCkge1xuICAgICAgICAgICAgbWUub25Pd25lck1vdW50ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyLm9uKCdtb3VudGVkJywgbWUub25Pd25lck1vdW50ZWQsIG1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKHZhbHVlLCB0aGlzLl9fcHJvdG9fXylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBpcyBjb25zdHJ1Y3RlZFxuICAgICAqL1xuICAgIG9uT3duZXJDb25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgbGV0IHtvd25lcn0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChvd25lci53aW5kb3dJZCkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dJZCA9IG93bmVyLndpbmRvd0lkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvd25lciBDb21wb25lbnQgd2hlbiBpdCBkb2VzIGdldCBtb3VudGVkXG4gICAgICovXG4gICAgb25Pd25lck1vdW50ZWQoKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFBsdWdpbik7XG4iLCJpbXBvcnQgRHJhZ1pvbmUgZnJvbSAnLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFBsdWdpbiAgIGZyb20gJy4vQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ucGx1Z2luLlJlc2l6YWJsZVxuICogQGV4dGVuZHMgTmVvLnBsdWdpbi5CYXNlXG4gKi9cbmNsYXNzIFJlc2l6YWJsZSBleHRlbmRzIFBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogUmVzaXplIGN1cnNvciBzdHlsZXMgdXNlIG5vcnRoLCBzb3V0aCBiYXNlZCBuYW1lcywgc28gd2UgbmVlZCBhIG1hcHBpbmcuXG4gICAgICogVGhlIG9yZGVyIGhhcyB0byBtYXRjaCB0aGUgc3RhdGljIHBvc2l0aW9ucyBhcnJheS5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gY3Vyc29yUG9zaXRpb25zPVsncycsJ3N3Jywnc2UnLCd3JywnZScsJ24nLCdudycsJ25lJ11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBjdXJzb3JQb3NpdGlvbnMgPSBbJ3MnLCAnc3cnLCAnc2UnLCAndycsICdlJywgJ24nLCAnbncnLCAnbmUnXVxuICAgIC8qKlxuICAgICAqIHJlbW92ZSAtIGNoYXJzXG4gICAgICogQG1lbWJlciB7UmVnRXhwfSBuYW1lUmVnRXg9Ly0oW2Etel0pL2dcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBuYW1lUmVnRXggPSAvLShbYS16XSkvZ1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIHBvc2l0aW9uIG5hbWVzXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHZhbGlkRGlyZWN0aW9ucz1bJ2JvdHRvbScsJ2JvdHRvbS1sZWZ0JywnYm90dG9tLXJpZ2h0JywnbGVmdCcsJ3JpZ2h0JywndG9wJywndG9wLWxlZnQnLCd0b3AtcmlnaHQnXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgcG9zaXRpb25zID0gWydib3R0b20nLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0JywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCddXG4gICAgLyoqXG4gICAgICogRGlyZWN0aW9ucyBpbnRvIHdoaWNoIHlvdSB3YW50IHRvIGRyYWcgPT4gcmVzaXplXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHZhbGlkRGlyZWN0aW9ucz1bJ2InLCdibCcsJ2JyJywnbCcsJ3InLCd0JywndGwnLCd0ciddXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyB2YWxpZERpcmVjdGlvbnMgPSBbJ2InLCAnYmwnLCAnYnInLCAnbCcsICdyJywgJ3QnLCAndGwnLCAndHInXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLlJlc2l6YWJsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnBsdWdpbi5SZXNpemFibGUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luLXJlc2l6YWJsZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4tcmVzaXphYmxlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBBcHAgdGhpcyBpbnN0YW5jZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBhcHBOYW1lXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwTmFtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYm91bmRhcnlDb250YWluZXJJZD0nZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICovXG4gICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBET01SZWN0IG9mIHRoZSBib3VuZGFyeUNvbnRhaW5lciBpZiBzZXQgKG1lYXN1cmVkIG9uIGRyYWc6c3RhcnQpXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYm91bmRhcnlDb250YWluZXJSZWN0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYm91bmRhcnlDb250YWluZXJSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjdXJyZW50Tm9kZU5hbWU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50Tm9kZU5hbWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXN0IGJlIHNldCBieSBlYWNoIG93bmVyXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGVsZWdhdGlvbkNscz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxlZ2F0aW9uQ2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGlyZWN0aW9ucyBpbnRvIHdoaWNoIHlvdSB3YW50IHRvIGRyYWcgPT4gcmVzaXplXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkaXJlY3Rpb25zXz1bJ2InLCdibCcsJ2JyJywnbCcsJ3InLCd0JywndGwnLCd0ciddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlyZWN0aW9uc186IFsnYicsICdibCcsICdicicsICdsJywgJ3InLCAndCcsICd0bCcsICd0ciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRyYWdnYWJsZS5EcmFnWm9uZXxudWxsfSBkcmFnWm9uZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnWm9uZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZHJhZ1pvbmVDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1pvbmVDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGdhcD0xMFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBnYXA6IDEwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIERPTVJlY3Qgb2YgdGhlIGVsZW1lbnQgdG8gZHJhZyAobWVhc3VyZWQgb24gZHJhZzpzdGFydClcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpbml0aWFsUmVjdD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNEcmFnZ2luZz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXhpbXVtIGhlaWdodCB3aGVuIHJlc2l6aW5nIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtYXhIZWlnaHQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgbWF4SGVpZ2h0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4aW11bSB3aWR0aCB3aGVuIHJlc2l6aW5nIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtYXhXaWR0aD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtYXhXaWR0aDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltdW0gaGVpZ2h0IHdoZW4gcmVzaXppbmcgaW4gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBtaW5IZWlnaHQ9MjAwXG4gICAgICAgICAqL1xuICAgICAgICBtaW5IZWlnaHQ6IDIwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltdW0gd2lkdGggd2hlbiByZXNpemluZyBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbldpZHRoPTIwMFxuICAgICAgICAgKi9cbiAgICAgICAgbWluV2lkdGg6IDIwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZUJvdHRvbT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5vZGVCb3R0b206IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG5vZGVCb3R0b21MZWZ0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZUJvdHRvbUxlZnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG5vZGVCb3R0b21SaWdodD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5vZGVCb3R0b21SaWdodDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZUxlZnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBub2RlTGVmdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZVJpZ2h0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZVJpZ2h0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBub2RlVG9wPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZVRvcDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZVRvcExlZnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBub2RlVG9wTGVmdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZVRvcFJpZ2h0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZVRvcFJpZ2h0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogdmRvbSBub2RlIHdoaWNoIG1hdGNoZXMgdGhlIGRlbGVnYXRpb25DbHMgdG8gYWRkIHJlc2l6ZSBoYW5kbGVzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdGFyZ2V0Tm9kZT1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRhcmdldE5vZGU6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLm93bmVyLmFkZERvbUxpc3RlbmVycyhbXG4gICAgICAgICAgICB7J2RyYWc6ZW5kJyAgOiBtZS5vbkRyYWdFbmQsICAgIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLXJlc2l6YWJsZSd9LFxuICAgICAgICAgICAgeydkcmFnOm1vdmUnIDogbWUub25EcmFnTW92ZSwgICBzY29wZTogbWUsIGRlbGVnYXRlOiAnLm5lby1yZXNpemFibGUnfSxcbiAgICAgICAgICAgIHsnZHJhZzpzdGFydCc6IG1lLm9uRHJhZ1N0YXJ0LCAgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tcmVzaXphYmxlJ30sXG4gICAgICAgICAgICB7bW91c2Vkb3duICAgOiBtZS5vbk1vdXNlRG93biwgIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLXJlc2l6YWJsZSd9LFxuICAgICAgICAgICAge21vdXNlbW92ZSAgIDogbWUub25Nb3VzZU1vdmUsICBzY29wZTogbWUsIGxvY2FsICAgOiB0cnVlfSxcbiAgICAgICAgICAgIHttb3VzZWxlYXZlICA6IG1lLm9uTW91c2VMZWF2ZSwgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogYC4ke21lLmRlbGVnYXRpb25DbHN9YH0sXG4gICAgICAgICAgICB7bW91c2V1cCAgICAgOiBtZS5vbk1vdXNlVXAsICAgIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLXJlc2l6YWJsZSd9XG4gICAgICAgIF0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGRCb2R5Q3Vyc29yQ2xzKCkge1xuICAgICAgICBOZW8uYXBwbHlEZWx0YXModGhpcy5hcHBOYW1lLCB7XG4gICAgICAgICAgICBpZCA6ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgICAgIGNsczoge1xuICAgICAgICAgICAgICAgIGFkZCAgIDogW2BuZW8tY3Vyc29yLSR7UmVzaXphYmxlLmN1cnNvclBvc2l0aW9uc1tSZXNpemFibGUucG9zaXRpb25zLmluZGV4T2YodGhpcy5jdXJyZW50Tm9kZU5hbWUpXX0tcmVzaXplYF0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWVcbiAgICAgKi9cbiAgICBhZGROb2RlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBub2RlTmFtZSAgICAgPSAnbm9kZScgKyBOZW8uY2FwaXRhbGl6ZShuYW1lLnJlcGxhY2UoUmVzaXphYmxlLm5hbWVSZWdFeCwgKHN0ciwgbGV0dGVyKSA9PiBsZXR0ZXIudG9VcHBlckNhc2UoKSkpLFxuICAgICAgICAgICAge3RhcmdldE5vZGV9ID0gbWU7XG5cbiAgICAgICAgaWYgKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIG1lLmN1cnJlbnROb2RlTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBtZVtub2RlTmFtZV0gPSB7Y2xzOiBbJ25lby1yZXNpemFibGUnLCBgbmVvLXJlc2l6YWJsZS0ke25hbWV9YF19O1xuXG4gICAgICAgICAgICB0YXJnZXROb2RlLmNuID0gdGFyZ2V0Tm9kZS5jbiB8fCBbXTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUuY24ucHVzaChtZVtub2RlTmFtZV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5kcmFnWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnWm9uZS5hcHBOYW1lID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICB2YWx1ZSAmJiBOZW8uY3VycmVudFdvcmtlci5pbnNlcnRUaGVtZUZpbGVzKHZhbHVlLCBtZS5fX3Byb3RvX18pO1xuXG4gICAgICAgIGlmIChtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgbWUuZHJhZ1pvbmUud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgZGlyZWN0aW9ucyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERpcmVjdGlvbnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IGkgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlW2ldLCBvbGRWYWx1ZSwgJ2RpcmVjdGlvbnMnLCAndmFsaWREaXJlY3Rpb25zJykgIT09IHZhbHVlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnRW5kKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lLFxuICAgICAgICAgICAgc3R5bGUgICA9IG93bmVyLndyYXBwZXJTdHlsZTsgLy8gdG9kbzogZGVsZWdhdGlvbiB0YXJnZXRcblxuICAgICAgICBPYmplY3QuYXNzaWduKG1lLCB7XG4gICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lclJlY3Q6IG51bGwsXG4gICAgICAgICAgICBpbml0aWFsUmVjdCAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICBpc0RyYWdnaW5nICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHtcbiAgICAgICAgICAgIG9wYWNpdHkgIDogMSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ25vbmUnLFxuICAgICAgICAgICAgLi4ubWUuZHJhZ1pvbmUuZHJhZ1Byb3h5LndyYXBwZXJTdHlsZVxuICAgICAgICB9KTtcblxuICAgICAgICBvd25lci53cmFwcGVyU3R5bGUgPSBzdHlsZTtcblxuICAgICAgICBtZS5yZW1vdmVCb2R5Q3Vyc29yQ2xzKCk7XG5cbiAgICAgICAgbWUuZHJhZ1pvbmUuZHJhZ0VuZCgpO1xuICAgICAgICBtZS5yZW1vdmVBbGxOb2RlcygpO1xuXG4gICAgICAgIG93bmVyLmZvY3VzKG93bmVyLmlkLCB0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSAgID0gbWUuY3VycmVudE5vZGVOYW1lLFxuICAgICAgICAgICAgY3RSZWN0ID0gbWUuYm91bmRhcnlDb250YWluZXJSZWN0LFxuICAgICAgICAgICAge21heEhlaWdodCwgbWF4V2lkdGgsIG1pbkhlaWdodCwgbWluV2lkdGh9ID0gbWUsXG4gICAgICAgICAgICByZWN0ICAgPSBtZS5pbml0aWFsUmVjdCxcbiAgICAgICAgICAgIGRpc3QsIHNpemUsIHN0eWxlO1xuXG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgbWUub25EcmFnRW5kKHt9KVxuICAgICAgICB9IGVsc2UgaWYgKG1lLmRyYWdab25lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgc3R5bGUgPSBtZS5kcmFnWm9uZS5kcmFnUHJveHkud3JhcHBlclN0eWxlO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5pbmNsdWRlcygnYm90dG9tJykpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5tYXgobWluSGVpZ2h0LCBkYXRhLmNsaWVudFkgLSByZWN0LnRvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdFJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIGN0UmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7c2l6ZX1weGBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pbmNsdWRlcygndG9wJykpIHtcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5taW4ocmVjdC5ib3R0b20gLSBtaW5IZWlnaHQsIGRhdGEuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KG1pbkhlaWdodCwgcmVjdC5oZWlnaHQgKyByZWN0LnRvcCAtIGRhdGEuY2xpZW50WSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLm1heChkaXN0LCByZWN0LmJvdHRvbSAtIG1heEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCBtYXhIZWlnaHQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5tYXgoZGlzdCwgY3RSZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCByZWN0LmJvdHRvbSAtIGN0UmVjdC50b3ApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7c2l6ZX1weGA7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wICAgID0gYCR7ZGlzdH1weGBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUuaW5jbHVkZXMoJ2xlZnQnKSkge1xuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLm1pbihyZWN0LnJpZ2h0IC0gbWluV2lkdGgsIGRhdGEuY2xpZW50WCk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KG1pbldpZHRoLCByZWN0LndpZHRoICsgcmVjdC5sZWZ0IC0gZGF0YS5jbGllbnRYKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5tYXgoZGlzdCwgcmVjdC5yaWdodCAtIG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIG1heFdpZHRoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdFJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGgubWF4KGRpc3QsIGN0UmVjdC5sZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIHJlY3QucmlnaHQgLSBjdFJlY3QubGVmdClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ICA9IGAke2Rpc3R9cHhgO1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gYCR7c2l6ZX1weGBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pbmNsdWRlcygncmlnaHQnKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1heChtaW5XaWR0aCwgcmVjdC53aWR0aCAtIHJlY3QucmlnaHQgKyBkYXRhLmNsaWVudFgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCBtYXhXaWR0aClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY3RSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCBjdFJlY3QucmlnaHQgLSByZWN0LmxlZnQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHtzaXplfXB4YFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5kcmFnWm9uZS5kcmFnUHJveHkud3JhcHBlclN0eWxlID0gc3R5bGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EcmFnU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29udGFpbmVySWQgICAgICAgICAgICAgICAgPSBtZS5ib3VuZGFyeUNvbnRhaW5lcklkLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuICAgICAgICAgICAgICAgICAgICAgICAgPSBkYXRhLnBhdGgubGVuZ3RoLFxuICAgICAgICAgICAge2FwcE5hbWUsIG93bmVyLCB3aW5kb3dJZH0gPSBtZSxcbiAgICAgICAgICAgIHN0eWxlICAgICAgICAgICAgICAgICAgICAgID0gb3duZXIud3JhcHBlclN0eWxlLCAvLyB0b2RvOiBkZWxlZ2F0aW9uIHRhcmdldFxuICAgICAgICAgICAgdGFyZ2V0LCB2ZG9tLCB2ZG9tU3R5bGU7XG5cbiAgICAgICAgbWUuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuMztcbiAgICAgICAgb3duZXIud3JhcHBlclN0eWxlID0gc3R5bGU7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gZGF0YS5wYXRoW2ldO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNscy5pbmNsdWRlcyhtZS5kZWxlZ2F0aW9uQ2xzKSkge1xuICAgICAgICAgICAgICAgIG1lLmluaXRpYWxSZWN0ID0gdGFyZ2V0LnJlY3RcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcklkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcklkID09PSAnZG9jdW1lbnQuYm9keScgJiYgdGFyZ2V0LnRhZ05hbWUgPT09ICdib2R5JyB8fCBjb250YWluZXJJZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCA9IHRhcmdldC5yZWN0O1xuICAgICAgICAgICAgICAgICAgICBicmVhayAvLyBhc3N1bWluZyB0aGF0IHRoZSBkcmFnRWwgaXMgbm90IG91dHNpZGUgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUuYm91bmRhcnlDb250YWluZXJSZWN0KSB7XG4gICAgICAgICAgICBvd25lci5nZXREb21SZWN0KG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBtZS5ib3VuZGFyeUNvbnRhaW5lclJlY3QgPSByZWN0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuYWRkQm9keUN1cnNvckNscygpO1xuXG4gICAgICAgIGlmICghbWUuZHJhZ1pvbmUpIHtcbiAgICAgICAgICAgIHZkb20gICAgICA9IE5lby5jbG9uZShvd25lci52ZG9tLCB0cnVlKTtcbiAgICAgICAgICAgIHZkb21TdHlsZSA9IHZkb20uc3R5bGU7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB2ZG9tLmhlaWdodDtcbiAgICAgICAgICAgIGRlbGV0ZSB2ZG9tLndpZHRoO1xuXG4gICAgICAgICAgICBkZWxldGUgdmRvbVN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgIGRlbGV0ZSB2ZG9tU3R5bGUubGVmdDtcbiAgICAgICAgICAgIGRlbGV0ZSB2ZG9tU3R5bGUudG9wO1xuICAgICAgICAgICAgZGVsZXRlIHZkb21TdHlsZS53aWR0aDtcblxuICAgICAgICAgICAgdmRvbVN0eWxlLm9wYWNpdHkgPSAwLjc7XG5cbiAgICAgICAgICAgIG1lLmRyYWdab25lID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgIDogRHJhZ1pvbmUsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeUNvbnRhaW5lcklkOiBvd25lci5ib3VuZGFyeUNvbnRhaW5lcklkLFxuICAgICAgICAgICAgICAgIGRyYWdFbGVtZW50ICAgICAgICA6IHZkb20sXG4gICAgICAgICAgICAgICAgbW92ZUluTWFpblRocmVhZCAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgICAgICAgLi4ubWUuZHJhZ1pvbmVDb25maWdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5kcmFnWm9uZS5ib3VuZGFyeUNvbnRhaW5lcklkID0gb3duZXIuYm91bmRhcnlDb250YWluZXJJZFxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZHJhZ1pvbmUuZHJhZ1N0YXJ0KGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjQzMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZURvd24oZGF0YSkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgZGlyID0gbWUuZGlyZWN0aW9ucyxcbiAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICB7Z2FwLCBvd25lciwgdGFyZ2V0Tm9kZX0gPSBtZSxcbiAgICAgICAgICAgIGggICA9IGZhbHNlLFxuICAgICAgICAgICAgbGVuID0gZGF0YS5wYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIGJvdHRvbSwgbGVmdCwgcmlnaHQsIHRhcmdldCwgdG9wO1xuXG4gICAgICAgIGlmICghbWUuaXNEcmFnZ2luZyAmJiAhb3duZXIuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnBhdGhbaV0uY2xzLmluY2x1ZGVzKG1lLmRlbGVnYXRpb25DbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGRhdGEucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlkICE9PSB0YXJnZXROb2RlPy5pZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUucmVtb3ZlQWxsTm9kZXMoKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWUudGFyZ2V0Tm9kZSA9IG93bmVyLmdldFZkb21DaGlsZCh0YXJnZXQuaWQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm90dG9tID0gZGF0YS5jbGllbnRZID49IHRhcmdldC5yZWN0LnkgLSBnYXAgKyB0YXJnZXQucmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGVmdCAgID0gZGF0YS5jbGllbnRYIDw9IHRhcmdldC5yZWN0LnggKyBnYXA7XG4gICAgICAgICAgICAgICAgcmlnaHQgID0gZGF0YS5jbGllbnRYID49IHRhcmdldC5yZWN0LnggLSBnYXAgKyB0YXJnZXQucmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB0b3AgICAgPSBkYXRhLmNsaWVudFkgPD0gdGFyZ2V0LnJlY3QueSArIGdhcDtcblxuICAgICAgICAgICAgICAgIGlmIChtZS5ub2RlQm90dG9tICYmICghYm90dG9tIHx8IGJvdHRvbSAmJiBsZWZ0ICB8fCBib3R0b20gJiYgcmlnaHQpKSB7aCA9IG1lLnJlbW92ZU5vZGUoJ2JvdHRvbScpfVxuICAgICAgICAgICAgICAgIGlmIChtZS5ub2RlTGVmdCAgICYmICghbGVmdCAgIHx8IGJvdHRvbSAmJiBsZWZ0ICB8fCB0b3AgICAgJiYgbGVmdCkpICB7aCA9IG1lLnJlbW92ZU5vZGUoJ2xlZnQnKX1cbiAgICAgICAgICAgICAgICBpZiAobWUubm9kZVJpZ2h0ICAmJiAoIXJpZ2h0ICB8fCBib3R0b20gJiYgcmlnaHQgfHwgdG9wICAgICYmIHJpZ2h0KSkge2ggPSBtZS5yZW1vdmVOb2RlKCdyaWdodCcpfVxuICAgICAgICAgICAgICAgIGlmIChtZS5ub2RlVG9wICAgICYmICghdG9wICAgIHx8IHRvcCAgICAmJiBsZWZ0ICB8fCB0b3AgICAgJiYgcmlnaHQpKSB7aCA9IG1lLnJlbW92ZU5vZGUoJ3RvcCcpfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1lLm5vZGVCb3R0b21MZWZ0ICAmJiAoIWJvdHRvbSB8fCAhbGVmdCkpICB7aCA9IG1lLnJlbW92ZU5vZGUoJ2JvdHRvbS1sZWZ0Jyl9XG4gICAgICAgICAgICAgICAgaWYgKG1lLm5vZGVCb3R0b21SaWdodCAmJiAoIWJvdHRvbSB8fCAhcmlnaHQpKSB7aCA9IG1lLnJlbW92ZU5vZGUoJ2JvdHRvbS1yaWdodCcpfVxuICAgICAgICAgICAgICAgIGlmIChtZS5ub2RlVG9wTGVmdCAgICAgJiYgKCF0b3AgICAgfHwgIWxlZnQpKSAge2ggPSBtZS5yZW1vdmVOb2RlKCd0b3AtbGVmdCcpfVxuICAgICAgICAgICAgICAgIGlmIChtZS5ub2RlVG9wUmlnaHQgICAgJiYgKCF0b3AgICAgfHwgIXJpZ2h0KSkge2ggPSBtZS5yZW1vdmVOb2RlKCd0b3AtcmlnaHQnKX1cblxuICAgICAgICAgICAgICAgIGlmICAgICAgKGRpci5pbmNsdWRlcygnYmwnKSAmJiBib3R0b20gJiYgbGVmdCkgIHtpZiAoIW1lLm5vZGVCb3R0b21MZWZ0KSAge2ggPSBtZS5hZGROb2RlKCdib3R0b20tbGVmdCcpfX1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXIuaW5jbHVkZXMoJ2JyJykgJiYgYm90dG9tICYmIHJpZ2h0KSB7aWYgKCFtZS5ub2RlQm90dG9tUmlnaHQpIHtoID0gbWUuYWRkTm9kZSgnYm90dG9tLXJpZ2h0Jyl9fVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpci5pbmNsdWRlcygndGwnKSAmJiB0b3AgICAgJiYgbGVmdCkgIHtpZiAoIW1lLm5vZGVUb3BMZWZ0KSAgICAge2ggPSBtZS5hZGROb2RlKCd0b3AtbGVmdCcpfX1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXIuaW5jbHVkZXMoJ3RyJykgJiYgdG9wICAgICYmIHJpZ2h0KSB7aWYgKCFtZS5ub2RlVG9wUmlnaHQpICAgIHtoID0gbWUuYWRkTm9kZSgndG9wLXJpZ2h0Jyl9fVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpci5pbmNsdWRlcygnYicpICAmJiBib3R0b20pICAgICAgICAgIHtpZiAoIW1lLm5vZGVCb3R0b20pICAgICAge2ggPSBtZS5hZGROb2RlKCdib3R0b20nKX19XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyLmluY2x1ZGVzKCdsJykgICYmIGxlZnQpICAgICAgICAgICAge2lmICghbWUubm9kZUxlZnQpICAgICAgICB7aCA9IG1lLmFkZE5vZGUoJ2xlZnQnKX19XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyLmluY2x1ZGVzKCdyJykgICYmIHJpZ2h0KSAgICAgICAgICAge2lmICghbWUubm9kZVJpZ2h0KSAgICAgICB7aCA9IG1lLmFkZE5vZGUoJ3JpZ2h0Jyl9fVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpci5pbmNsdWRlcygndCcpICAmJiB0b3ApICAgICAgICAgICAgIHtpZiAoIW1lLm5vZGVUb3ApICAgICAgICAge2ggPSBtZS5hZGROb2RlKCd0b3AnKX19XG5cbiAgICAgICAgICAgICAgICBoICYmIG93bmVyLnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VMZWF2ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5pc0RyYWdnaW5nICYmICFtZS5vd25lci5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAvLyBsaW1pdCB0aGUgZXZlbnQgdG8gZGVsZWdhdGlvbiB0YXJnZXRzXG4gICAgICAgICAgICBpZiAoZGF0YS5wYXRoWzBdLmNscy5pbmNsdWRlcyhtZS5kZWxlZ2F0aW9uQ2xzKSkge1xuICAgICAgICAgICAgICAgIG1lLnJlbW92ZUFsbE5vZGVzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzI0MzFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VVcChkYXRhKSB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlcmUgc2hvdWxkIGJlIG1heCAxIG5vZGUgKHJlc2l6ZSBoYW5kbGUpIGF0IGFueSBnaXZlbiB0aW1lLlxuICAgICAqIHNlZTogL2lzc3Vlcy8xMTM5XG4gICAgICovXG4gICAgcmVtb3ZlQWxsTm9kZXMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmN1cnJlbnROb2RlTmFtZSkge1xuICAgICAgICAgICAgbWUucmVtb3ZlTm9kZShtZS5jdXJyZW50Tm9kZU5hbWUpO1xuICAgICAgICAgICAgbWUub3duZXIudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIG1lLmN1cnJlbnROb2RlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICBtZS50YXJnZXROb2RlICAgICAgPSBudWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUJvZHlDdXJzb3JDbHMoKSB7XG4gICAgICAgIE5lby5hcHBseURlbHRhcyh0aGlzLmFwcE5hbWUsIHtcbiAgICAgICAgICAgIGlkIDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgYWRkICAgOiBbXSxcbiAgICAgICAgICAgICAgICByZW1vdmU6IFtgbmVvLWN1cnNvci0ke1Jlc2l6YWJsZS5jdXJzb3JQb3NpdGlvbnNbUmVzaXphYmxlLnBvc2l0aW9ucy5pbmRleE9mKHRoaXMuY3VycmVudE5vZGVOYW1lKV19LXJlc2l6ZWBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpbiBjYXNlIHRoZSBub2RlIGV4aXN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVOb2RlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGVOYW1lID0gJ25vZGUnICsgTmVvLmNhcGl0YWxpemUobmFtZS5yZXBsYWNlKFJlc2l6YWJsZS5uYW1lUmVnRXgsIChzdHIsIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpKTtcblxuICAgICAgICBpZiAobWVbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgICBtZS5jdXJyZW50Tm9kZU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgTmVvQXJyYXkucmVtb3ZlKG1lLnRhcmdldE5vZGUuY24sIG1lW25vZGVOYW1lXSk7XG4gICAgICAgICAgICBtZVtub2RlTmFtZV0gPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhSZXNpemFibGUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9