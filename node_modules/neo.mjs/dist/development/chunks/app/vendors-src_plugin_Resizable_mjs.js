"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_plugin_Resizable_mjs"],{

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Base extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.owner.mounted) {
            me.onOwnerMounted();
        } else {
            me.owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Base));


/***/ }),

/***/ "./src/plugin/Resizable.mjs":
/*!**********************************!*\
  !*** ./src/plugin/Resizable.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../draggable/DragZone.mjs */ "./src/draggable/DragZone.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");




/**
 * @class Neo.plugin.Resizable
 * @extends Neo.plugin.Base
 */
class Resizable extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Resize cursor styles use north, south based names, so we need a mapping.
     * The order has to match the static positions array.
     * @member {String[]} cursorPositions=['s','sw','se','w','e','n','nw','ne']
     * @protected
     * @static
     */
    static cursorPositions = ['s', 'sw', 'se', 'w', 'e', 'n', 'nw', 'ne']
    /**
     * remove - chars
     * @member {RegExp} nameRegEx=/-([a-z])/g
     * @protected
     * @static
     */
    static nameRegEx = /-([a-z])/g
    /**
     * Internal position names
     * @member {String[]} validDirections=['bottom','bottom-left','bottom-right','left','right','top','top-left','top-right']
     * @static
     */
    static positions = ['bottom', 'bottom-left', 'bottom-right', 'left', 'right', 'top', 'top-left', 'top-right']
    /**
     * Directions into which you want to drag => resize
     * @member {String[]} validDirections=['b','bl','br','l','r','t','tl','tr']
     * @static
     */
    static validDirections = ['b', 'bl', 'br', 'l', 'r', 't', 'tl', 'tr']

    static config = {
        /**
         * @member {String} className='Neo.plugin.Resizable'
         * @protected
         */
        className: 'Neo.plugin.Resizable',
        /**
         * @member {String} ntype='plugin-resizable'
         * @protected
         */
        ntype: 'plugin-resizable',
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName_=null
         */
        appName_: null,
        /**
         * @member {String|null} boundaryContainerId='document.body'
         */
        boundaryContainerId: 'document.body',
        /**
         * The DOMRect of the boundaryContainer if set (measured on drag:start)
         * @member {Object} boundaryContainerRect=null
         * @protected
         */
        boundaryContainerRect: null,
        /**
         * @member {String} currentNodeName=null
         * @protected
         */
        currentNodeName: null,
        /**
         * Must be set by each owner
         * @member {String} delegationCls=null
         */
        delegationCls: null,
        /**
         * Directions into which you want to drag => resize
         * @member {String[]} directions_=['b','bl','br','l','r','t','tl','tr']
         */
        directions_: ['b', 'bl', 'br', 'l', 'r', 't', 'tl', 'tr'],
        /**
         * @member {Neo.draggable.DragZone|null} dragZone=null
         */
        dragZone: null,
        /**
         * @member {Object} dragZoneConfig=null
         */
        dragZoneConfig: null,
        /**
         * @member {Number} gap=10
         * @protected
         */
        gap: 10,
        /**
         * The DOMRect of the element to drag (measured on drag:start)
         * @member {Object} initialRect=null
         * @protected
         */
        initialRect: null,
        /**
         * @member {Boolean} isDragging=false
         */
        isDragging: false,
        /**
         * maximum height when resizing in px
         * @member {Number|null} maxHeight=null
         */
        maxHeight: null,
        /**
         * maximum width when resizing in px
         * @member {Number|null} maxWidth=null
         */
        maxWidth: null,
        /**
         * minimum height when resizing in px
         * @member {Number} minHeight=200
         */
        minHeight: 200,
        /**
         * minimum width when resizing in px
         * @member {Number} minWidth=200
         */
        minWidth: 200,
        /**
         * @member {Object} nodeBottom=null
         * @protected
         */
        nodeBottom: null,
        /**
         * @member {Object} nodeBottomLeft=null
         * @protected
         */
        nodeBottomLeft: null,
        /**
         * @member {Object} nodeBottomRight=null
         * @protected
         */
        nodeBottomRight: null,
        /**
         * @member {Object} nodeLeft=null
         * @protected
         */
        nodeLeft: null,
        /**
         * @member {Object} nodeRight=null
         * @protected
         */
        nodeRight: null,
        /**
         * @member {Object} nodeTop=null
         * @protected
         */
        nodeTop: null,
        /**
         * @member {Object} nodeTopLeft=null
         * @protected
         */
        nodeTopLeft: null,
        /**
         * @member {Object} nodeTopRight=null
         * @protected
         */
        nodeTopRight: null,
        /**
         * vdom node which matches the delegationCls to add resize handles
         * @member {Object} targetNode=null
         * @protected
         */
        targetNode: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.owner.addDomListeners([
            {'drag:end'  : me.onDragEnd,    scope: me, delegate: '.neo-resizable'},
            {'drag:move' : me.onDragMove,   scope: me, delegate: '.neo-resizable'},
            {'drag:start': me.onDragStart,  scope: me, delegate: '.neo-resizable'},
            {mousedown   : me.onMouseDown,  scope: me, delegate: '.neo-resizable'},
            {mousemove   : me.onMouseMove,  scope: me, local   : true},
            {mouseleave  : me.onMouseLeave, scope: me, delegate: `.${me.delegationCls}`},
            {mouseup     : me.onMouseUp,    scope: me, delegate: '.neo-resizable'}
        ])
    }

    /**
     *
     */
    addBodyCursorCls() {
        Neo.applyDeltas(this.appName, {
            id : 'document.body',
            cls: {
                add   : [`neo-cursor-${Resizable.cursorPositions[Resizable.positions.indexOf(this.currentNodeName)]}-resize`],
                remove: []
            }
        })
    }

    /**
     * @param {String} name
     * @returns {Boolean} true
     */
    addNode(name) {
        let me           = this,
            nodeName     = 'node' + Neo.capitalize(name.replace(Resizable.nameRegEx, (str, letter) => letter.toUpperCase())),
            {targetNode} = me;

        if (targetNode) {
            me.currentNodeName = name;
            me[nodeName] = {cls: ['neo-resizable', `neo-resizable-${name}`]};

            targetNode.cn = targetNode.cn || [];
            targetNode.cn.push(me[nodeName]);

            return true
        }

        return false
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        if (this.dragZone) {
            this.dragZone.appName = value
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        let me = this;

        value && Neo.currentWorker.insertThemeFiles(value, me.__proto__);

        if (me.dragZone) {
            me.dragZone.windowId = value
        }
    }

    /**
     * Triggered before the directions config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @returns {String[]}
     * @protected
     */
    beforeSetDirections(value, oldValue) {
        if (Array.isArray(value)) {
            let i   = 0,
                len = value.length;

            for (; i < len; i++) {
                if (this.beforeSetEnumValue(value[i], oldValue, 'directions', 'validDirections') !== value[i]) {
                    return oldValue
                }
            }
        }

        return value
    }

    /**
     * @param {Object} data
     */
    onDragEnd(data) {
        let me      = this,
            {owner} = me,
            style   = owner.wrapperStyle; // todo: delegation target

        Object.assign(me, {
            boundaryContainerRect: null,
            initialRect          : null,
            isDragging           : false
        });

        Object.assign(style, {
            opacity  : 1,
            transform: 'none',
            ...me.dragZone.dragProxy.wrapperStyle
        });

        owner.wrapperStyle = style;

        me.removeBodyCursorCls();

        me.dragZone.dragEnd();
        me.removeAllNodes();

        owner.focus(owner.id, true)
    }

    /**
     * @param {Object} data
     */
    onDragMove(data) {
        let me     = this,
            node   = me.currentNodeName,
            ctRect = me.boundaryContainerRect,
            {maxHeight, maxWidth, minHeight, minWidth} = me,
            rect   = me.initialRect,
            dist, size, style;

        if (!node) {
            me.onDragEnd({})
        } else if (me.dragZone.dragProxy) {
            style = me.dragZone.dragProxy.wrapperStyle;

            if (node.includes('bottom')) {
                size = Math.max(minHeight, data.clientY - rect.top);

                if (maxHeight) {
                    size = Math.min(size, maxHeight);
                }

                if (ctRect) {
                    size = Math.min(size, ctRect.bottom - rect.top);
                }

                style.height = `${size}px`
            } else if (node.includes('top')) {
                dist = Math.min(rect.bottom - minHeight, data.clientY);
                size = Math.max(minHeight, rect.height + rect.top - data.clientY);

                if (maxHeight) {
                    dist = Math.max(dist, rect.bottom - maxHeight);
                    size = Math.min(size, maxHeight)
                }

                if (ctRect) {
                    dist = Math.max(dist, ctRect.top);
                    size = Math.min(size, rect.bottom - ctRect.top)
                }

                style.height = `${size}px`;
                style.top    = `${dist}px`
            }

            if (node.includes('left')) {
                dist = Math.min(rect.right - minWidth, data.clientX);
                size = Math.max(minWidth, rect.width + rect.left - data.clientX);

                if (maxWidth) {
                    dist = Math.max(dist, rect.right - maxWidth);
                    size = Math.min(size, maxWidth)
                }

                if (ctRect) {
                    dist = Math.max(dist, ctRect.left);
                    size = Math.min(size, rect.right - ctRect.left)
                }

                style.left  = `${dist}px`;
                style.width = `${size}px`
            } else if (node.includes('right')) {
                size = Math.max(minWidth, rect.width - rect.right + data.clientX);

                if (maxWidth) {
                    size = Math.min(size, maxWidth)
                }

                if (ctRect) {
                    size = Math.min(size, ctRect.right - rect.left)
                }

                style.width = `${size}px`
            }

            me.dragZone.dragProxy.wrapperStyle = style
        }
    }

    /**
     * @param {Object} data
     */
    onDragStart(data) {
        let me                         = this,
            containerId                = me.boundaryContainerId,
            i                          = 0,
            len                        = data.path.length,
            {appName, owner, windowId} = me,
            style                      = owner.wrapperStyle, // todo: delegation target
            target, vdom, vdomStyle;

        me.isDragging = true;

        style.opacity = 0.3;
        owner.wrapperStyle = style;

        for (; i < len; i++) {
            target = data.path[i];

            if (target.cls.includes(me.delegationCls)) {
                me.initialRect = target.rect
            }

            if (containerId) {
                if (containerId === 'document.body' && target.tagName === 'body' || containerId === target.id) {
                    me.boundaryContainerRect = target.rect;
                    break // assuming that the dragEl is not outside of the container
                }
            }
        }

        if (!me.boundaryContainerRect) {
            owner.getDomRect(me.boundaryContainerRect).then(rect => {
                me.boundaryContainerRect = rect
            })
        }

        me.addBodyCursorCls();

        if (!me.dragZone) {
            vdom      = Neo.clone(owner.vdom, true);
            vdomStyle = vdom.style;

            delete vdom.height;
            delete vdom.width;

            delete vdomStyle.height;
            delete vdomStyle.left;
            delete vdomStyle.top;
            delete vdomStyle.width;

            vdomStyle.opacity = 0.7;

            me.dragZone = Neo.create({
                module             : _draggable_DragZone_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                appName,
                boundaryContainerId: owner.boundaryContainerId,
                dragElement        : vdom,
                moveInMainThread   : false,
                owner,
                windowId,
                ...me.dragZoneConfig
            })
        } else {
            me.dragZone.boundaryContainerId = owner.boundaryContainerId
        }

        me.dragZone.dragStart(data)
    }

    /**
     * See: https://github.com/neomjs/neo/issues/2431
     * @param {Object} data
     */
    onMouseDown(data) {
        this.isDragging = true
    }

    /**
     * @param {Object} data
     */
    onMouseMove(data) {
        let me  = this,
            dir = me.directions,
            i   = 0,
            {gap, owner, targetNode} = me,
            h   = false,
            len = data.path.length,
            bottom, left, right, target, top;

        if (!me.isDragging && !owner.isDragging) {
            for (; i < len; i++) {
                if (data.path[i].cls.includes(me.delegationCls)) {
                    target = data.path[i];
                    break
                }
            }

            if (target) {
                if (target.id !== targetNode?.id) {
                    if (targetNode) {
                        me.removeAllNodes()
                    }

                    me.targetNode = owner.getVdomChild(target.id)
                }

                bottom = data.clientY >= target.rect.y - gap + target.rect.height;
                left   = data.clientX <= target.rect.x + gap;
                right  = data.clientX >= target.rect.x - gap + target.rect.width;
                top    = data.clientY <= target.rect.y + gap;

                if (me.nodeBottom && (!bottom || bottom && left  || bottom && right)) {h = me.removeNode('bottom')}
                if (me.nodeLeft   && (!left   || bottom && left  || top    && left))  {h = me.removeNode('left')}
                if (me.nodeRight  && (!right  || bottom && right || top    && right)) {h = me.removeNode('right')}
                if (me.nodeTop    && (!top    || top    && left  || top    && right)) {h = me.removeNode('top')}

                if (me.nodeBottomLeft  && (!bottom || !left))  {h = me.removeNode('bottom-left')}
                if (me.nodeBottomRight && (!bottom || !right)) {h = me.removeNode('bottom-right')}
                if (me.nodeTopLeft     && (!top    || !left))  {h = me.removeNode('top-left')}
                if (me.nodeTopRight    && (!top    || !right)) {h = me.removeNode('top-right')}

                if      (dir.includes('bl') && bottom && left)  {if (!me.nodeBottomLeft)  {h = me.addNode('bottom-left')}}
                else if (dir.includes('br') && bottom && right) {if (!me.nodeBottomRight) {h = me.addNode('bottom-right')}}
                else if (dir.includes('tl') && top    && left)  {if (!me.nodeTopLeft)     {h = me.addNode('top-left')}}
                else if (dir.includes('tr') && top    && right) {if (!me.nodeTopRight)    {h = me.addNode('top-right')}}
                else if (dir.includes('b')  && bottom)          {if (!me.nodeBottom)      {h = me.addNode('bottom')}}
                else if (dir.includes('l')  && left)            {if (!me.nodeLeft)        {h = me.addNode('left')}}
                else if (dir.includes('r')  && right)           {if (!me.nodeRight)       {h = me.addNode('right')}}
                else if (dir.includes('t')  && top)             {if (!me.nodeTop)         {h = me.addNode('top')}}

                h && owner.update()
            }
        }
    }

    /**
     * @param {Object} data
     */
    onMouseLeave(data) {
        let me = this;

        if (!me.isDragging && !me.owner.isDragging) {
            // limit the event to delegation targets
            if (data.path[0].cls.includes(me.delegationCls)) {
                me.removeAllNodes()
            }
        }
    }

    /**
     * See: https://github.com/neomjs/neo/issues/2431
     * @param {Object} data
     */
    onMouseUp(data) {
        this.isDragging = false
    }

    /**
     * There should be max 1 node (resize handle) at any given time.
     * see: /issues/1139
     */
    removeAllNodes() {
        let me = this;

        if (me.currentNodeName) {
            me.removeNode(me.currentNodeName);
            me.owner.update();

            me.currentNodeName = null;
            me.targetNode      = null
        }
    }

    /**
     *
     */
    removeBodyCursorCls() {
        Neo.applyDeltas(this.appName, {
            id : 'document.body',
            cls: {
                add   : [],
                remove: [`neo-cursor-${Resizable.cursorPositions[Resizable.positions.indexOf(this.currentNodeName)]}-resize`]
            }
        })
    }

    /**
     * @param {String} name
     * @returns {Boolean} true in case the node existed
     */
    removeNode(name) {
        let me       = this,
            nodeName = 'node' + Neo.capitalize(name.replace(Resizable.nameRegEx, (str, letter) => letter.toUpperCase()));

        if (me[nodeName]) {
            me.currentNodeName = null;
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].remove(me.targetNode.cn, me[nodeName]);
            me[nodeName] = null;

            return true
        }

        return false
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Resizable));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19wbHVnaW5fUmVzaXphYmxlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQVE7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxvQkFBb0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEVGO0FBQ2U7QUFDUjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7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Q3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVGQUF1RjtBQUN2Rix1RkFBdUY7QUFDdkYsdUZBQXVGO0FBQ3ZGLHVGQUF1Rjs7QUFFdkYsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEUsZ0VBQWdFOztBQUVoRSxpRUFBaUUsMEJBQTBCO0FBQzNGLGlFQUFpRSwwQkFBMEI7QUFDM0YsaUVBQWlFLDBCQUEwQjtBQUMzRixpRUFBaUUsMEJBQTBCO0FBQzNGLGlFQUFpRSwwQkFBMEI7QUFDM0YsaUVBQWlFLDBCQUEwQjtBQUMzRixpRUFBaUUsMEJBQTBCO0FBQzNGLGlFQUFpRSwwQkFBMEI7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2RUFBNkU7QUFDcEg7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksdURBQVE7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUseUJBQXlCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9SZXNpemFibGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb3JlQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwbHVnaW4gaW1wbGVtZW50YXRpb25zLlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIEJhc2UgZXh0ZW5kcyBDb3JlQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgcGx1Z2luIG50eXBlcyBuZWVkIHRvIHN0YXJ0IHdpdGggJ3BsdWdpbi0nIHRvIGVuc3VyZSB0aGF0IGNvbXBvbmVudC5CYXNlOiBnZXRQbHVnaW4oKSBjYW4gZmluZCB0aGVtXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3dJZF86IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5vd25lci5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyTW91bnRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUub3duZXIub24oJ21vdW50ZWQnLCBtZS5vbk93bmVyTW91bnRlZCwgbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMuX19wcm90b19fKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG93bmVyIENvbXBvbmVudCB3aGVuIGl0IGRvZXMgZ2V0IG1vdW50ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyTW91bnRlZCgpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQmFzZSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ1pvbmUgZnJvbSAnLi4vZHJhZ2dhYmxlL0RyYWdab25lLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8ucGx1Z2luLlJlc2l6YWJsZVxuICogQGV4dGVuZHMgTmVvLnBsdWdpbi5CYXNlXG4gKi9cbmNsYXNzIFJlc2l6YWJsZSBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBjdXJzb3Igc3R5bGVzIHVzZSBub3J0aCwgc291dGggYmFzZWQgbmFtZXMsIHNvIHdlIG5lZWQgYSBtYXBwaW5nLlxuICAgICAqIFRoZSBvcmRlciBoYXMgdG8gbWF0Y2ggdGhlIHN0YXRpYyBwb3NpdGlvbnMgYXJyYXkuXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGN1cnNvclBvc2l0aW9ucz1bJ3MnLCdzdycsJ3NlJywndycsJ2UnLCduJywnbncnLCduZSddXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3Vyc29yUG9zaXRpb25zID0gWydzJywgJ3N3JywgJ3NlJywgJ3cnLCAnZScsICduJywgJ253JywgJ25lJ11cbiAgICAvKipcbiAgICAgKiByZW1vdmUgLSBjaGFyc1xuICAgICAqIEBtZW1iZXIge1JlZ0V4cH0gbmFtZVJlZ0V4PS8tKFthLXpdKS9nXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgbmFtZVJlZ0V4ID0gLy0oW2Etel0pL2dcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBwb3NpdGlvbiBuYW1lc1xuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB2YWxpZERpcmVjdGlvbnM9Wydib3R0b20nLCdib3R0b20tbGVmdCcsJ2JvdHRvbS1yaWdodCcsJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ3RvcC1sZWZ0JywndG9wLXJpZ2h0J11cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHBvc2l0aW9ucyA9IFsnYm90dG9tJywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICd0b3AtbGVmdCcsICd0b3AtcmlnaHQnXVxuICAgIC8qKlxuICAgICAqIERpcmVjdGlvbnMgaW50byB3aGljaCB5b3Ugd2FudCB0byBkcmFnID0+IHJlc2l6ZVxuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSB2YWxpZERpcmVjdGlvbnM9WydiJywnYmwnLCdicicsJ2wnLCdyJywndCcsJ3RsJywndHInXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWREaXJlY3Rpb25zID0gWydiJywgJ2JsJywgJ2JyJywgJ2wnLCAncicsICd0JywgJ3RsJywgJ3RyJ11cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5SZXNpemFibGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uUmVzaXphYmxlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbi1yZXNpemFibGUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luLXJlc2l6YWJsZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgQXBwIHRoaXMgaW5zdGFuY2UgYmVsb25ncyB0b1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYXBwTmFtZV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwTmFtZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gYm91bmRhcnlDb250YWluZXJJZD0nZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICovXG4gICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBET01SZWN0IG9mIHRoZSBib3VuZGFyeUNvbnRhaW5lciBpZiBzZXQgKG1lYXN1cmVkIG9uIGRyYWc6c3RhcnQpXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYm91bmRhcnlDb250YWluZXJSZWN0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYm91bmRhcnlDb250YWluZXJSZWN0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjdXJyZW50Tm9kZU5hbWU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50Tm9kZU5hbWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXN0IGJlIHNldCBieSBlYWNoIG93bmVyXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZGVsZWdhdGlvbkNscz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxlZ2F0aW9uQ2xzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGlyZWN0aW9ucyBpbnRvIHdoaWNoIHlvdSB3YW50IHRvIGRyYWcgPT4gcmVzaXplXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkaXJlY3Rpb25zXz1bJ2InLCdibCcsJ2JyJywnbCcsJ3InLCd0JywndGwnLCd0ciddXG4gICAgICAgICAqL1xuICAgICAgICBkaXJlY3Rpb25zXzogWydiJywgJ2JsJywgJ2JyJywgJ2wnLCAncicsICd0JywgJ3RsJywgJ3RyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZHJhZ2dhYmxlLkRyYWdab25lfG51bGx9IGRyYWdab25lPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdab25lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkcmFnWm9uZUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnWm9uZUNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gZ2FwPTEwXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGdhcDogMTAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRE9NUmVjdCBvZiB0aGUgZWxlbWVudCB0byBkcmFnIChtZWFzdXJlZCBvbiBkcmFnOnN0YXJ0KVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGluaXRpYWxSZWN0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbFJlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0RyYWdnaW5nPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heGltdW0gaGVpZ2h0IHdoZW4gcmVzaXppbmcgaW4gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG1heEhlaWdodD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtYXhIZWlnaHQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXhpbXVtIHdpZHRoIHdoZW4gcmVzaXppbmcgaW4gcHhcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG1heFdpZHRoPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1heFdpZHRoOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW11bSBoZWlnaHQgd2hlbiByZXNpemluZyBpbiBweFxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbkhlaWdodD0yMDBcbiAgICAgICAgICovXG4gICAgICAgIG1pbkhlaWdodDogMjAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW11bSB3aWR0aCB3aGVuIHJlc2l6aW5nIGluIHB4XG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gbWluV2lkdGg9MjAwXG4gICAgICAgICAqL1xuICAgICAgICBtaW5XaWR0aDogMjAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBub2RlQm90dG9tPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZUJvdHRvbTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZUJvdHRvbUxlZnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBub2RlQm90dG9tTGVmdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gbm9kZUJvdHRvbVJpZ2h0PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZUJvdHRvbVJpZ2h0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBub2RlTGVmdD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5vZGVMZWZ0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBub2RlUmlnaHQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBub2RlUmlnaHQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG5vZGVUb3A9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBub2RlVG9wOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBub2RlVG9wTGVmdD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG5vZGVUb3BMZWZ0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBub2RlVG9wUmlnaHQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBub2RlVG9wUmlnaHQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2ZG9tIG5vZGUgd2hpY2ggbWF0Y2hlcyB0aGUgZGVsZWdhdGlvbkNscyB0byBhZGQgcmVzaXplIGhhbmRsZXNcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB0YXJnZXROb2RlPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0Tm9kZTogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUub3duZXIuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgIHsnZHJhZzplbmQnICA6IG1lLm9uRHJhZ0VuZCwgICAgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tcmVzaXphYmxlJ30sXG4gICAgICAgICAgICB7J2RyYWc6bW92ZScgOiBtZS5vbkRyYWdNb3ZlLCAgIHNjb3BlOiBtZSwgZGVsZWdhdGU6ICcubmVvLXJlc2l6YWJsZSd9LFxuICAgICAgICAgICAgeydkcmFnOnN0YXJ0JzogbWUub25EcmFnU3RhcnQsICBzY29wZTogbWUsIGRlbGVnYXRlOiAnLm5lby1yZXNpemFibGUnfSxcbiAgICAgICAgICAgIHttb3VzZWRvd24gICA6IG1lLm9uTW91c2VEb3duLCAgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tcmVzaXphYmxlJ30sXG4gICAgICAgICAgICB7bW91c2Vtb3ZlICAgOiBtZS5vbk1vdXNlTW92ZSwgIHNjb3BlOiBtZSwgbG9jYWwgICA6IHRydWV9LFxuICAgICAgICAgICAge21vdXNlbGVhdmUgIDogbWUub25Nb3VzZUxlYXZlLCBzY29wZTogbWUsIGRlbGVnYXRlOiBgLiR7bWUuZGVsZWdhdGlvbkNsc31gfSxcbiAgICAgICAgICAgIHttb3VzZXVwICAgICA6IG1lLm9uTW91c2VVcCwgICAgc2NvcGU6IG1lLCBkZWxlZ2F0ZTogJy5uZW8tcmVzaXphYmxlJ31cbiAgICAgICAgXSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEJvZHlDdXJzb3JDbHMoKSB7XG4gICAgICAgIE5lby5hcHBseURlbHRhcyh0aGlzLmFwcE5hbWUsIHtcbiAgICAgICAgICAgIGlkIDogJ2RvY3VtZW50LmJvZHknLFxuICAgICAgICAgICAgY2xzOiB7XG4gICAgICAgICAgICAgICAgYWRkICAgOiBbYG5lby1jdXJzb3ItJHtSZXNpemFibGUuY3Vyc29yUG9zaXRpb25zW1Jlc2l6YWJsZS5wb3NpdGlvbnMuaW5kZXhPZih0aGlzLmN1cnJlbnROb2RlTmFtZSldfS1yZXNpemVgXSxcbiAgICAgICAgICAgICAgICByZW1vdmU6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZVxuICAgICAqL1xuICAgIGFkZE5vZGUobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGVOYW1lICAgICA9ICdub2RlJyArIE5lby5jYXBpdGFsaXplKG5hbWUucmVwbGFjZShSZXNpemFibGUubmFtZVJlZ0V4LCAoc3RyLCBsZXR0ZXIpID0+IGxldHRlci50b1VwcGVyQ2FzZSgpKSksXG4gICAgICAgICAgICB7dGFyZ2V0Tm9kZX0gPSBtZTtcblxuICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgbWUuY3VycmVudE5vZGVOYW1lID0gbmFtZTtcbiAgICAgICAgICAgIG1lW25vZGVOYW1lXSA9IHtjbHM6IFsnbmVvLXJlc2l6YWJsZScsIGBuZW8tcmVzaXphYmxlLSR7bmFtZX1gXX07XG5cbiAgICAgICAgICAgIHRhcmdldE5vZGUuY24gPSB0YXJnZXROb2RlLmNuIHx8IFtdO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5jbi5wdXNoKG1lW25vZGVOYW1lXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFwcE5hbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdab25lKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdab25lLmFwcE5hbWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIG1lLl9fcHJvdG9fXyk7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdab25lKSB7XG4gICAgICAgICAgICBtZS5kcmFnWm9uZS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBkaXJlY3Rpb25zIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0RGlyZWN0aW9ucyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgaSAgID0gMCxcbiAgICAgICAgICAgICAgICBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWVbaV0sIG9sZFZhbHVlLCAnZGlyZWN0aW9ucycsICd2YWxpZERpcmVjdGlvbnMnKSAhPT0gdmFsdWVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWUsXG4gICAgICAgICAgICBzdHlsZSAgID0gb3duZXIud3JhcHBlclN0eWxlOyAvLyB0b2RvOiBkZWxlZ2F0aW9uIHRhcmdldFxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVyUmVjdDogbnVsbCxcbiAgICAgICAgICAgIGluaXRpYWxSZWN0ICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIGlzRHJhZ2dpbmcgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwge1xuICAgICAgICAgICAgb3BhY2l0eSAgOiAxLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAnbm9uZScsXG4gICAgICAgICAgICAuLi5tZS5kcmFnWm9uZS5kcmFnUHJveHkud3JhcHBlclN0eWxlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG93bmVyLndyYXBwZXJTdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgIG1lLnJlbW92ZUJvZHlDdXJzb3JDbHMoKTtcblxuICAgICAgICBtZS5kcmFnWm9uZS5kcmFnRW5kKCk7XG4gICAgICAgIG1lLnJlbW92ZUFsbE5vZGVzKCk7XG5cbiAgICAgICAgb3duZXIuZm9jdXMob3duZXIuaWQsIHRydWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBub2RlICAgPSBtZS5jdXJyZW50Tm9kZU5hbWUsXG4gICAgICAgICAgICBjdFJlY3QgPSBtZS5ib3VuZGFyeUNvbnRhaW5lclJlY3QsXG4gICAgICAgICAgICB7bWF4SGVpZ2h0LCBtYXhXaWR0aCwgbWluSGVpZ2h0LCBtaW5XaWR0aH0gPSBtZSxcbiAgICAgICAgICAgIHJlY3QgICA9IG1lLmluaXRpYWxSZWN0LFxuICAgICAgICAgICAgZGlzdCwgc2l6ZSwgc3R5bGU7XG5cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBtZS5vbkRyYWdFbmQoe30pXG4gICAgICAgIH0gZWxzZSBpZiAobWUuZHJhZ1pvbmUuZHJhZ1Byb3h5KSB7XG4gICAgICAgICAgICBzdHlsZSA9IG1lLmRyYWdab25lLmRyYWdQcm94eS53cmFwcGVyU3R5bGU7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmluY2x1ZGVzKCdib3R0b20nKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1heChtaW5IZWlnaHQsIGRhdGEuY2xpZW50WSAtIHJlY3QudG9wKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIG1heEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgY3RSZWN0LmJvdHRvbSAtIHJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtzaXplfXB4YFxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmluY2x1ZGVzKCd0b3AnKSkge1xuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLm1pbihyZWN0LmJvdHRvbSAtIG1pbkhlaWdodCwgZGF0YS5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5tYXgobWluSGVpZ2h0LCByZWN0LmhlaWdodCArIHJlY3QudG9wIC0gZGF0YS5jbGllbnRZKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IE1hdGgubWF4KGRpc3QsIHJlY3QuYm90dG9tIC0gbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIG1heEhlaWdodClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY3RSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLm1heChkaXN0LCBjdFJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIHJlY3QuYm90dG9tIC0gY3RSZWN0LnRvcClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBgJHtzaXplfXB4YDtcbiAgICAgICAgICAgICAgICBzdHlsZS50b3AgICAgPSBgJHtkaXN0fXB4YFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5pbmNsdWRlcygnbGVmdCcpKSB7XG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSBtaW5XaWR0aCwgZGF0YS5jbGllbnRYKTtcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5tYXgobWluV2lkdGgsIHJlY3Qud2lkdGggKyByZWN0LmxlZnQgLSBkYXRhLmNsaWVudFgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLm1heChkaXN0LCByZWN0LnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgbWF4V2lkdGgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5tYXgoZGlzdCwgY3RSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgcmVjdC5yaWdodCAtIGN0UmVjdC5sZWZ0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgID0gYCR7ZGlzdH1weGA7XG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSBgJHtzaXplfXB4YFxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmluY2x1ZGVzKCdyaWdodCcpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KG1pbldpZHRoLCByZWN0LndpZHRoIC0gcmVjdC5yaWdodCArIGRhdGEuY2xpZW50WCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIG1heFdpZHRoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdFJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKHNpemUsIGN0UmVjdC5yaWdodCAtIHJlY3QubGVmdClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IGAke3NpemV9cHhgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmRyYWdab25lLmRyYWdQcm94eS53cmFwcGVyU3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb250YWluZXJJZCAgICAgICAgICAgICAgICA9IG1lLmJvdW5kYXJ5Q29udGFpbmVySWQsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgICAgICAgICAgICAgICA9IGRhdGEucGF0aC5sZW5ndGgsXG4gICAgICAgICAgICB7YXBwTmFtZSwgb3duZXIsIHdpbmRvd0lkfSA9IG1lLFxuICAgICAgICAgICAgc3R5bGUgICAgICAgICAgICAgICAgICAgICAgPSBvd25lci53cmFwcGVyU3R5bGUsIC8vIHRvZG86IGRlbGVnYXRpb24gdGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQsIHZkb20sIHZkb21TdHlsZTtcblxuICAgICAgICBtZS5pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC4zO1xuICAgICAgICBvd25lci53cmFwcGVyU3R5bGUgPSBzdHlsZTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBkYXRhLnBhdGhbaV07XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQuY2xzLmluY2x1ZGVzKG1lLmRlbGVnYXRpb25DbHMpKSB7XG4gICAgICAgICAgICAgICAgbWUuaW5pdGlhbFJlY3QgPSB0YXJnZXQucmVjdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29udGFpbmVySWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVySWQgPT09ICdkb2N1bWVudC5ib2R5JyAmJiB0YXJnZXQudGFnTmFtZSA9PT0gJ2JvZHknIHx8IGNvbnRhaW5lcklkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYm91bmRhcnlDb250YWluZXJSZWN0ID0gdGFyZ2V0LnJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIC8vIGFzc3VtaW5nIHRoYXQgdGhlIGRyYWdFbCBpcyBub3Qgb3V0c2lkZSBvZiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZS5ib3VuZGFyeUNvbnRhaW5lclJlY3QpIHtcbiAgICAgICAgICAgIG93bmVyLmdldERvbVJlY3QobWUuYm91bmRhcnlDb250YWluZXJSZWN0KS50aGVuKHJlY3QgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmJvdW5kYXJ5Q29udGFpbmVyUmVjdCA9IHJlY3RcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBtZS5hZGRCb2R5Q3Vyc29yQ2xzKCk7XG5cbiAgICAgICAgaWYgKCFtZS5kcmFnWm9uZSkge1xuICAgICAgICAgICAgdmRvbSAgICAgID0gTmVvLmNsb25lKG93bmVyLnZkb20sIHRydWUpO1xuICAgICAgICAgICAgdmRvbVN0eWxlID0gdmRvbS5zdHlsZTtcblxuICAgICAgICAgICAgZGVsZXRlIHZkb20uaGVpZ2h0O1xuICAgICAgICAgICAgZGVsZXRlIHZkb20ud2lkdGg7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB2ZG9tU3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgZGVsZXRlIHZkb21TdHlsZS5sZWZ0O1xuICAgICAgICAgICAgZGVsZXRlIHZkb21TdHlsZS50b3A7XG4gICAgICAgICAgICBkZWxldGUgdmRvbVN0eWxlLndpZHRoO1xuXG4gICAgICAgICAgICB2ZG9tU3R5bGUub3BhY2l0eSA9IDAuNztcblxuICAgICAgICAgICAgbWUuZHJhZ1pvbmUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgOiBEcmFnWm9uZSxcbiAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG93bmVyLmJvdW5kYXJ5Q29udGFpbmVySWQsXG4gICAgICAgICAgICAgICAgZHJhZ0VsZW1lbnQgICAgICAgIDogdmRvbSxcbiAgICAgICAgICAgICAgICBtb3ZlSW5NYWluVGhyZWFkICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAuLi5tZS5kcmFnWm9uZUNvbmZpZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmRyYWdab25lLmJvdW5kYXJ5Q29udGFpbmVySWQgPSBvd25lci5ib3VuZGFyeUNvbnRhaW5lcklkXG4gICAgICAgIH1cblxuICAgICAgICBtZS5kcmFnWm9uZS5kcmFnU3RhcnQoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yNDMxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bihkYXRhKSB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICA9IHRoaXMsXG4gICAgICAgICAgICBkaXIgPSBtZS5kaXJlY3Rpb25zLFxuICAgICAgICAgICAgaSAgID0gMCxcbiAgICAgICAgICAgIHtnYXAsIG93bmVyLCB0YXJnZXROb2RlfSA9IG1lLFxuICAgICAgICAgICAgaCAgID0gZmFsc2UsXG4gICAgICAgICAgICBsZW4gPSBkYXRhLnBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgYm90dG9tLCBsZWZ0LCByaWdodCwgdGFyZ2V0LCB0b3A7XG5cbiAgICAgICAgaWYgKCFtZS5pc0RyYWdnaW5nICYmICFvd25lci5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGF0aFtpXS5jbHMuaW5jbHVkZXMobWUuZGVsZWdhdGlvbkNscykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gZGF0YS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaWQgIT09IHRhcmdldE5vZGU/LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5yZW1vdmVBbGxOb2RlcygpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtZS50YXJnZXROb2RlID0gb3duZXIuZ2V0VmRvbUNoaWxkKHRhcmdldC5pZClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib3R0b20gPSBkYXRhLmNsaWVudFkgPj0gdGFyZ2V0LnJlY3QueSAtIGdhcCArIHRhcmdldC5yZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBsZWZ0ICAgPSBkYXRhLmNsaWVudFggPD0gdGFyZ2V0LnJlY3QueCArIGdhcDtcbiAgICAgICAgICAgICAgICByaWdodCAgPSBkYXRhLmNsaWVudFggPj0gdGFyZ2V0LnJlY3QueCAtIGdhcCArIHRhcmdldC5yZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHRvcCAgICA9IGRhdGEuY2xpZW50WSA8PSB0YXJnZXQucmVjdC55ICsgZ2FwO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1lLm5vZGVCb3R0b20gJiYgKCFib3R0b20gfHwgYm90dG9tICYmIGxlZnQgIHx8IGJvdHRvbSAmJiByaWdodCkpIHtoID0gbWUucmVtb3ZlTm9kZSgnYm90dG9tJyl9XG4gICAgICAgICAgICAgICAgaWYgKG1lLm5vZGVMZWZ0ICAgJiYgKCFsZWZ0ICAgfHwgYm90dG9tICYmIGxlZnQgIHx8IHRvcCAgICAmJiBsZWZ0KSkgIHtoID0gbWUucmVtb3ZlTm9kZSgnbGVmdCcpfVxuICAgICAgICAgICAgICAgIGlmIChtZS5ub2RlUmlnaHQgICYmICghcmlnaHQgIHx8IGJvdHRvbSAmJiByaWdodCB8fCB0b3AgICAgJiYgcmlnaHQpKSB7aCA9IG1lLnJlbW92ZU5vZGUoJ3JpZ2h0Jyl9XG4gICAgICAgICAgICAgICAgaWYgKG1lLm5vZGVUb3AgICAgJiYgKCF0b3AgICAgfHwgdG9wICAgICYmIGxlZnQgIHx8IHRvcCAgICAmJiByaWdodCkpIHtoID0gbWUucmVtb3ZlTm9kZSgndG9wJyl9XG5cbiAgICAgICAgICAgICAgICBpZiAobWUubm9kZUJvdHRvbUxlZnQgICYmICghYm90dG9tIHx8ICFsZWZ0KSkgIHtoID0gbWUucmVtb3ZlTm9kZSgnYm90dG9tLWxlZnQnKX1cbiAgICAgICAgICAgICAgICBpZiAobWUubm9kZUJvdHRvbVJpZ2h0ICYmICghYm90dG9tIHx8ICFyaWdodCkpIHtoID0gbWUucmVtb3ZlTm9kZSgnYm90dG9tLXJpZ2h0Jyl9XG4gICAgICAgICAgICAgICAgaWYgKG1lLm5vZGVUb3BMZWZ0ICAgICAmJiAoIXRvcCAgICB8fCAhbGVmdCkpICB7aCA9IG1lLnJlbW92ZU5vZGUoJ3RvcC1sZWZ0Jyl9XG4gICAgICAgICAgICAgICAgaWYgKG1lLm5vZGVUb3BSaWdodCAgICAmJiAoIXRvcCAgICB8fCAhcmlnaHQpKSB7aCA9IG1lLnJlbW92ZU5vZGUoJ3RvcC1yaWdodCcpfVxuXG4gICAgICAgICAgICAgICAgaWYgICAgICAoZGlyLmluY2x1ZGVzKCdibCcpICYmIGJvdHRvbSAmJiBsZWZ0KSAge2lmICghbWUubm9kZUJvdHRvbUxlZnQpICB7aCA9IG1lLmFkZE5vZGUoJ2JvdHRvbS1sZWZ0Jyl9fVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpci5pbmNsdWRlcygnYnInKSAmJiBib3R0b20gJiYgcmlnaHQpIHtpZiAoIW1lLm5vZGVCb3R0b21SaWdodCkge2ggPSBtZS5hZGROb2RlKCdib3R0b20tcmlnaHQnKX19XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyLmluY2x1ZGVzKCd0bCcpICYmIHRvcCAgICAmJiBsZWZ0KSAge2lmICghbWUubm9kZVRvcExlZnQpICAgICB7aCA9IG1lLmFkZE5vZGUoJ3RvcC1sZWZ0Jyl9fVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpci5pbmNsdWRlcygndHInKSAmJiB0b3AgICAgJiYgcmlnaHQpIHtpZiAoIW1lLm5vZGVUb3BSaWdodCkgICAge2ggPSBtZS5hZGROb2RlKCd0b3AtcmlnaHQnKX19XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyLmluY2x1ZGVzKCdiJykgICYmIGJvdHRvbSkgICAgICAgICAge2lmICghbWUubm9kZUJvdHRvbSkgICAgICB7aCA9IG1lLmFkZE5vZGUoJ2JvdHRvbScpfX1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXIuaW5jbHVkZXMoJ2wnKSAgJiYgbGVmdCkgICAgICAgICAgICB7aWYgKCFtZS5ub2RlTGVmdCkgICAgICAgIHtoID0gbWUuYWRkTm9kZSgnbGVmdCcpfX1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXIuaW5jbHVkZXMoJ3InKSAgJiYgcmlnaHQpICAgICAgICAgICB7aWYgKCFtZS5ub2RlUmlnaHQpICAgICAgIHtoID0gbWUuYWRkTm9kZSgncmlnaHQnKX19XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyLmluY2x1ZGVzKCd0JykgICYmIHRvcCkgICAgICAgICAgICAge2lmICghbWUubm9kZVRvcCkgICAgICAgICB7aCA9IG1lLmFkZE5vZGUoJ3RvcCcpfX1cblxuICAgICAgICAgICAgICAgIGggJiYgb3duZXIudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZUxlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmlzRHJhZ2dpbmcgJiYgIW1lLm93bmVyLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIC8vIGxpbWl0IHRoZSBldmVudCB0byBkZWxlZ2F0aW9uIHRhcmdldHNcbiAgICAgICAgICAgIGlmIChkYXRhLnBhdGhbMF0uY2xzLmluY2x1ZGVzKG1lLmRlbGVnYXRpb25DbHMpKSB7XG4gICAgICAgICAgICAgICAgbWUucmVtb3ZlQWxsTm9kZXMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjQzMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Nb3VzZVVwKGRhdGEpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBzaG91bGQgYmUgbWF4IDEgbm9kZSAocmVzaXplIGhhbmRsZSkgYXQgYW55IGdpdmVuIHRpbWUuXG4gICAgICogc2VlOiAvaXNzdWVzLzExMzlcbiAgICAgKi9cbiAgICByZW1vdmVBbGxOb2RlcygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuY3VycmVudE5vZGVOYW1lKSB7XG4gICAgICAgICAgICBtZS5yZW1vdmVOb2RlKG1lLmN1cnJlbnROb2RlTmFtZSk7XG4gICAgICAgICAgICBtZS5vd25lci51cGRhdGUoKTtcblxuICAgICAgICAgICAgbWUuY3VycmVudE5vZGVOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIG1lLnRhcmdldE5vZGUgICAgICA9IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlQm9keUN1cnNvckNscygpIHtcbiAgICAgICAgTmVvLmFwcGx5RGVsdGFzKHRoaXMuYXBwTmFtZSwge1xuICAgICAgICAgICAgaWQgOiAnZG9jdW1lbnQuYm9keScsXG4gICAgICAgICAgICBjbHM6IHtcbiAgICAgICAgICAgICAgICBhZGQgICA6IFtdLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogW2BuZW8tY3Vyc29yLSR7UmVzaXphYmxlLmN1cnNvclBvc2l0aW9uc1tSZXNpemFibGUucG9zaXRpb25zLmluZGV4T2YodGhpcy5jdXJyZW50Tm9kZU5hbWUpXX0tcmVzaXplYF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgdGhlIG5vZGUgZXhpc3RlZFxuICAgICAqL1xuICAgIHJlbW92ZU5vZGUobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZU5hbWUgPSAnbm9kZScgKyBOZW8uY2FwaXRhbGl6ZShuYW1lLnJlcGxhY2UoUmVzaXphYmxlLm5hbWVSZWdFeCwgKHN0ciwgbGV0dGVyKSA9PiBsZXR0ZXIudG9VcHBlckNhc2UoKSkpO1xuXG4gICAgICAgIGlmIChtZVtub2RlTmFtZV0pIHtcbiAgICAgICAgICAgIG1lLmN1cnJlbnROb2RlTmFtZSA9IG51bGw7XG4gICAgICAgICAgICBOZW9BcnJheS5yZW1vdmUobWUudGFyZ2V0Tm9kZS5jbiwgbWVbbm9kZU5hbWVdKTtcbiAgICAgICAgICAgIG1lW25vZGVOYW1lXSA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFJlc2l6YWJsZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=