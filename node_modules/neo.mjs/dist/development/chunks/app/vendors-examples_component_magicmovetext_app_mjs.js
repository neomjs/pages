"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_component_magicmovetext_app_mjs"],{

/***/ "./examples/component/magicmovetext/MainContainer.mjs":
/*!************************************************************!*\
  !*** ./examples/component/magicmovetext/MainContainer.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ConfigurationViewport.mjs */ "./examples/ConfigurationViewport.mjs");
/* harmony import */ var _src_component_MagicMoveText_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/component/MagicMoveText.mjs */ "./src/component/MagicMoveText.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/form/field/Text.mjs */ "./src/form/field/Text.mjs");






/**
 * @class Neo.examples.component.magicmovetext.MainContainer
 * @extends Neo.examples.ConfigurationViewport
 */
class MainContainer extends _ConfigurationViewport_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        className           : 'Neo.examples.component.magicmovetext.MainContainer',
        configItemLabelWidth: 150,
        configItemWidth     : 250,
        configPanelMaxWidth : 300,
        configPanelMinWidth : 300,
        layout              : {ntype: 'hbox', align: 'stretch'}
    }

    createConfigurationComponents() {
        let me                 = this,
            {exampleComponent} = me;

        return [{
            module   : _src_form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            checked  : exampleComponent.autoCycle,
            labelText: 'autoCycle',
            listeners: {change: me.onConfigChange.bind(me, 'autoCycle')}
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable: false,
            labelText: 'autoCycleInterval',
            listeners: {change: me.onConfigChange.bind(me, 'autoCycleInterval')},
            maxValue : 10000,
            minValue : 0,
            stepSize : 1000,
            style    : {marginTop: '10px'},
            value    : exampleComponent.autoCycleInterval
        }, {
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            labelText: 'colorFadeIn',
            listeners: {change: me.onConfigChange.bind(me, 'colorFadeIn')},
            value    : exampleComponent.colorFadeIn
        }, {
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            labelText: 'colorFadeOut',
            listeners: {change: me.onConfigChange.bind(me, 'colorFadeOut')},
            value    : exampleComponent.colorFadeOut
        }, {
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            labelText: 'colorMove',
            listeners: {change: me.onConfigChange.bind(me, 'colorMove')},
            value    : exampleComponent.colorMove
        }, {
            module   : _src_form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            clearable: false,
            labelText: 'fontFamily',
            listeners: {change: me.onConfigChange.bind(me, 'fontFamily')},
            value    : exampleComponent.fontFamily,
            width    : 280
        }, {
            module   : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            clearable: false,
            labelText: 'transitionTime',
            listeners: {change: me.onConfigChange.bind(me, 'transitionTime')},
            maxValue : 900,
            minValue : 50,
            stepSize : 50,
            value    : exampleComponent.transitionTime
        }]
    }

    createExampleComponent() {
        return {
            module: _src_component_MagicMoveText_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],

            cycleTexts: [
                'Magic Move',
                'Move characters like magic',
                'Animate between strings',
                'Just like that',
                'Simple to use',
                'Would you use it?'
            ]
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ }),

/***/ "./examples/component/magicmovetext/app.mjs":
/*!**************************************************!*\
  !*** ./examples/component/magicmovetext/app.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/magicmovetext/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.magicmovetext'
});


/***/ }),

/***/ "./src/component/MagicMoveText.mjs":
/*!*****************************************!*\
  !*** ./src/component/MagicMoveText.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");


/**
 * Deeply inspired by https://github.com/yangshun 's video on LinkedIn
 * as well as Apple's Keynote Magic Move effect
 * @class Neo.component.MagicMoveText
 * @extends Neo.component.Base
 */
class MagicMoveText extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.MagicMoveText'
         * @protected
         */
        className: 'Neo.component.MagicMoveText',
        /**
         * @member {String} ntype='magic-move-text'
         * @protected
         */
        ntype: 'magic-move-text',
        /**
         * @member {Boolean} autoCycle_=true
         */
        autoCycle_: true,
        /**
         * @member {Number} autoCycleInterval_=2000
         */
        autoCycleInterval_: 2000,
        /**
         * @member {String[]} baseCls=['neo-magic-move-text']
         * @protected
         */
        baseCls: ['neo-magic-move-text'],
        /**
         * @member {String|null} colorMove=null
         */
        colorMove: null,
        /**
         * @member {String|null} colorFadeIn=null
         */
        colorFadeIn: null,
        /**
         * @member {String|null} colorFadeOut=null
         */
        colorFadeOut: null,
        /**
         * @member {String[]|null} cycleTexts=null
         */
        cycleTexts: null,
        /**
         * @member {String} fontFamily_='Helvetica Neue'
         */
        fontFamily_: 'Helvetica Neue',
        /**
         * @member {String} text_=null
         */
        text_: null,
        /**
         * Time in ms for the fadeIn, fadeOut and move character OPs
         * @member {Number} transitionTime_=500
         */
        transitionTime_: 500,
        /**
         * @member {Object} _vdom
         */
        _vdom:
        {style: {}, cn: [
            {cls: ['neo-content'], cn: []},
            {cls: ['neo-measure-element-wrapper'], removeDom: true, cn: [
                {cls: ['neo-measure-element'], cn:[]}
            ]}
        ]}
    }

    /**
     * @member {Object[]} chars=[]
     */
    chars = []
    /**
     * @member {Number} currentIndex=0
     */
    currentIndex = 0
    /**
     * @member {Number|null} intervalId=null
     */
    intervalId = null
    /**
     * @member {Object[]} previousChars=[]
     */
    previousChars = []
    /**
     * @member {Object} measureElement
     */
    get measureElement() {
        return this.vdom.cn[1].cn[0]
    }

    /**
     * Triggered after the autoCycle config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetAutoCycle(value, oldValue) {
        this.mounted && this.startAutoCycle(value)
    }

    /**
     * Triggered after the autoCycleInterval config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetAutoCycleInterval(value, oldValue) {
        let me = this;

        if (oldValue && me.mounted) {
            me.startAutoCycle(false);
            me.startAutoCycle()
        }
    }

    /**
     * Triggered after the fontFamily config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetFontFamily(value, oldValue) {
        this.vdom.style.fontFamily = value;
        this.update()
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        this.autoCycle && this.startAutoCycle(value)
    }

    /**
     * Triggered after the text config got changed
     * @param {String} value
     * @param {String} oldValue
     * @returns {Promise<void>}
     * @protected
     */
    async afterSetText(value, oldValue) {
        let me               = this,
            {measureElement} = me;

        if (oldValue) {
            me.previousChars = me.chars
        }

        if (value) {
            me.chars = [];
            measureElement.cn = [];

            value?.split('').forEach(char => {
                me.chars.push({name: char});

                if (char === ' ') {
                    char = '&nbsp;'
                }

                measureElement.cn.push({tag: 'span', html: char})
            });

            if (me.mounted) {
                await me.measureChars()
            }

            await me.updateChars()
        }
    }

    /**
     * Triggered after the transitionTime config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetTransitionTime(value, oldValue) {
        this.vdom.style['--neo-transition-time'] = value + 'ms';
        this.update()
    }

    /**
     * @returns {Promise<void>}
     */
    async measureChars() {
        let me = this,
            {measureElement} = me,
            parentRect, rects;

        delete me.vdom.cn[1].removeDom;

        await me.promiseUpdate();
        await me.timeout(20);

        rects      = await me.getDomRect([me.vdom.cn[1].id, ...measureElement.cn.map(node => node.id)]);
        parentRect = rects.shift();

        rects.forEach((rect, index) => {
            me.chars[index].left = `${rect.left - parentRect.left}px`;
            me.chars[index].top  = `${rect.top  - parentRect.top }px`;
        });

        me.vdom.cn[1].removeDom = true;
        await me.promiseUpdate()
    }

    /**
     * @param {Boolean} start=true
     */
    startAutoCycle(start=true) {
        let me = this;

        if (start) {
            me.intervalId = setInterval(() => {
                me.text         = me.cycleTexts[me.currentIndex];
                me.currentIndex = (me.currentIndex + 1) % me.cycleTexts.length
            }, me.autoCycleInterval)

            me.text && me.measureChars()
        } else {
            clearInterval(me.intervalId)
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async updateChars() {
        let me                     = this,
            {chars, previousChars} = me,
            charsContainer         = me.vdom.cn[0].cn,
            letters                = chars.map(char => char.name),
            char, charNode, index;

        previousChars.forEach((previousChar, previousIndex) => {
            index = letters.indexOf(previousChar.name);

            if (index > -1) {
                charNode = charsContainer[previousIndex];

                charNode.style.color = me.colorMove;
                charNode.style.left  = chars[index].left;
                letters[index] = null
            } else {
                charNode = charsContainer[previousIndex];

                charNode.flag = 'remove'
            }
        });

        letters.forEach((letter, index) => {
            if (letter !== null) {
                char = chars[index];

                charsContainer.push({
                    html : char.name,
                    style: {color: me.colorFadeIn, left: char.left, opacity: 0, top: char.top}
                })
            }
        });

        await me.promiseUpdate();

        charsContainer.forEach(charNode => {
            if (charNode.flag === 'remove') {
                charNode.style.color   = me.colorFadeOut;
                charNode.style.opacity = 0
            } else {
                charNode.style.opacity = 1
            }
        });

        await me.promiseUpdate();
        await me.timeout(me.transitionTime);

        charsContainer.sort((a, b) => parseFloat(a.style.left) - parseFloat(b.style.left));

        index = charsContainer.length - 1;

        for (; index >= 0; index--) {
            charNode = charsContainer[index];

            delete charNode.flag;
            delete charNode.style.color;

            if (charNode.style.opacity === 0) {
                charsContainer.splice(index, 1)
            }
        }

        await me.promiseUpdate()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MagicMoveText));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF9tYWdpY21vdmV0ZXh0X2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlFO0FBQ0w7QUFDUztBQUNOO0FBQ0Y7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCOztBQUUvQjtBQUNBLHVCQUF1QixvRUFBUTtBQUMvQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVCx1QkFBdUIsa0VBQVc7QUFDbEM7QUFDQTtBQUNBLHdCQUF3Qix3REFBd0Q7QUFDaEY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLFNBQVM7QUFDVCx1QkFBdUIsZ0VBQVM7QUFDaEM7QUFDQSx3QkFBd0Isa0RBQWtEO0FBQzFFO0FBQ0EsU0FBUztBQUNULHVCQUF1QixnRUFBUztBQUNoQztBQUNBLHdCQUF3QixtREFBbUQ7QUFDM0U7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLGdFQUFTO0FBQ2hDO0FBQ0Esd0JBQXdCLGdEQUFnRDtBQUN4RTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsZ0VBQVM7QUFDaEM7QUFDQTtBQUNBLHdCQUF3QixpREFBaUQ7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsa0VBQVc7QUFDbEM7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix3RUFBYTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSw2QkFBNkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pGRzs7QUFFekM7QUFDUCxjQUFjLDBEQUFh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OztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLFlBQVk7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY29tcG9uZW50L21hZ2ljbW92ZXRleHQvTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NvbXBvbmVudC9tYWdpY21vdmV0ZXh0L2FwcC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvTWFnaWNNb3ZlVGV4dC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENoZWNrQm94ICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9DaGVja0JveC5tanMnO1xuaW1wb3J0IENvbmZpZ3VyYXRpb25WaWV3cG9ydCBmcm9tICcuLi8uLi9Db25maWd1cmF0aW9uVmlld3BvcnQubWpzJztcbmltcG9ydCBNYWdpY01vdmVUZXh0ICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBvbmVudC9NYWdpY01vdmVUZXh0Lm1qcyc7XG5pbXBvcnQgTnVtYmVyRmllbGQgICAgICAgICAgIGZyb20gJy4uLy4uLy4uL3NyYy9mb3JtL2ZpZWxkL051bWJlci5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5leGFtcGxlcy5jb21wb25lbnQubWFnaWNtb3ZldGV4dC5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uZXhhbXBsZXMuQ29uZmlndXJhdGlvblZpZXdwb3J0XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBDb25maWd1cmF0aW9uVmlld3BvcnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIGNsYXNzTmFtZSAgICAgICAgICAgOiAnTmVvLmV4YW1wbGVzLmNvbXBvbmVudC5tYWdpY21vdmV0ZXh0Lk1haW5Db250YWluZXInLFxuICAgICAgICBjb25maWdJdGVtTGFiZWxXaWR0aDogMTUwLFxuICAgICAgICBjb25maWdJdGVtV2lkdGggICAgIDogMjUwLFxuICAgICAgICBjb25maWdQYW5lbE1heFdpZHRoIDogMzAwLFxuICAgICAgICBjb25maWdQYW5lbE1pbldpZHRoIDogMzAwLFxuICAgICAgICBsYXlvdXQgICAgICAgICAgICAgIDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9XG4gICAgfVxuXG4gICAgY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudHMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2V4YW1wbGVDb21wb25lbnR9ID0gbWU7XG5cbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICBtb2R1bGUgICA6IENoZWNrQm94LFxuICAgICAgICAgICAgY2hlY2tlZCAgOiBleGFtcGxlQ29tcG9uZW50LmF1dG9DeWNsZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ2F1dG9DeWNsZScsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdhdXRvQ3ljbGUnKX1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBOdW1iZXJGaWVsZCxcbiAgICAgICAgICAgIGNsZWFyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdhdXRvQ3ljbGVJbnRlcnZhbCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdhdXRvQ3ljbGVJbnRlcnZhbCcpfSxcbiAgICAgICAgICAgIG1heFZhbHVlIDogMTAwMDAsXG4gICAgICAgICAgICBtaW5WYWx1ZSA6IDAsXG4gICAgICAgICAgICBzdGVwU2l6ZSA6IDEwMDAsXG4gICAgICAgICAgICBzdHlsZSAgICA6IHttYXJnaW5Ub3A6ICcxMHB4J30sXG4gICAgICAgICAgICB2YWx1ZSAgICA6IGV4YW1wbGVDb21wb25lbnQuYXV0b0N5Y2xlSW50ZXJ2YWxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBUZXh0RmllbGQsXG4gICAgICAgICAgICBsYWJlbFRleHQ6ICdjb2xvckZhZGVJbicsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdjb2xvckZhZGVJbicpfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogZXhhbXBsZUNvbXBvbmVudC5jb2xvckZhZGVJblxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ2NvbG9yRmFkZU91dCcsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdjb2xvckZhZGVPdXQnKX0sXG4gICAgICAgICAgICB2YWx1ZSAgICA6IGV4YW1wbGVDb21wb25lbnQuY29sb3JGYWRlT3V0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnY29sb3JNb3ZlJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ2NvbG9yTW92ZScpfSxcbiAgICAgICAgICAgIHZhbHVlICAgIDogZXhhbXBsZUNvbXBvbmVudC5jb2xvck1vdmVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbW9kdWxlICAgOiBUZXh0RmllbGQsXG4gICAgICAgICAgICBjbGVhcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnZm9udEZhbWlseScsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtjaGFuZ2U6IG1lLm9uQ29uZmlnQ2hhbmdlLmJpbmQobWUsICdmb250RmFtaWx5Jyl9LFxuICAgICAgICAgICAgdmFsdWUgICAgOiBleGFtcGxlQ29tcG9uZW50LmZvbnRGYW1pbHksXG4gICAgICAgICAgICB3aWR0aCAgICA6IDI4MFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IE51bWJlckZpZWxkLFxuICAgICAgICAgICAgY2xlYXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ3RyYW5zaXRpb25UaW1lJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25Db25maWdDaGFuZ2UuYmluZChtZSwgJ3RyYW5zaXRpb25UaW1lJyl9LFxuICAgICAgICAgICAgbWF4VmFsdWUgOiA5MDAsXG4gICAgICAgICAgICBtaW5WYWx1ZSA6IDUwLFxuICAgICAgICAgICAgc3RlcFNpemUgOiA1MCxcbiAgICAgICAgICAgIHZhbHVlICAgIDogZXhhbXBsZUNvbXBvbmVudC50cmFuc2l0aW9uVGltZVxuICAgICAgICB9XVxuICAgIH1cblxuICAgIGNyZWF0ZUV4YW1wbGVDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2R1bGU6IE1hZ2ljTW92ZVRleHQsXG5cbiAgICAgICAgICAgIGN5Y2xlVGV4dHM6IFtcbiAgICAgICAgICAgICAgICAnTWFnaWMgTW92ZScsXG4gICAgICAgICAgICAgICAgJ01vdmUgY2hhcmFjdGVycyBsaWtlIG1hZ2ljJyxcbiAgICAgICAgICAgICAgICAnQW5pbWF0ZSBiZXR3ZWVuIHN0cmluZ3MnLFxuICAgICAgICAgICAgICAgICdKdXN0IGxpa2UgdGhhdCcsXG4gICAgICAgICAgICAgICAgJ1NpbXBsZSB0byB1c2UnLFxuICAgICAgICAgICAgICAgICdXb3VsZCB5b3UgdXNlIGl0PydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgTWFpbkNvbnRhaW5lciBmcm9tICcuL01haW5Db250YWluZXIubWpzJztcblxuZXhwb3J0IGNvbnN0IG9uU3RhcnQgPSAoKSA9PiBOZW8uYXBwKHtcbiAgICBtYWluVmlldzogTWFpbkNvbnRhaW5lcixcbiAgICBuYW1lICAgIDogJ05lby5leGFtcGxlcy5jb21wb25lbnQubWFnaWNtb3ZldGV4dCdcbn0pO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuXG4vKipcbiAqIERlZXBseSBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20veWFuZ3NodW4gJ3MgdmlkZW8gb24gTGlua2VkSW5cbiAqIGFzIHdlbGwgYXMgQXBwbGUncyBLZXlub3RlIE1hZ2ljIE1vdmUgZWZmZWN0XG4gKiBAY2xhc3MgTmVvLmNvbXBvbmVudC5NYWdpY01vdmVUZXh0XG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgTWFnaWNNb3ZlVGV4dCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50Lk1hZ2ljTW92ZVRleHQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQuTWFnaWNNb3ZlVGV4dCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdtYWdpYy1tb3ZlLXRleHQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbWFnaWMtbW92ZS10ZXh0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9DeWNsZV89dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0N5Y2xlXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gYXV0b0N5Y2xlSW50ZXJ2YWxfPTIwMDBcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9DeWNsZUludGVydmFsXzogMjAwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLW1hZ2ljLW1vdmUtdGV4dCddXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLW1hZ2ljLW1vdmUtdGV4dCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbG9yTW92ZT1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBjb2xvck1vdmU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29sb3JGYWRlSW49bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGYWRlSW46IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gY29sb3JGYWRlT3V0PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmFkZU91dDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfG51bGx9IGN5Y2xlVGV4dHM9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY3ljbGVUZXh0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gZm9udEZhbWlseV89J0hlbHZldGljYSBOZXVlJ1xuICAgICAgICAgKi9cbiAgICAgICAgZm9udEZhbWlseV86ICdIZWx2ZXRpY2EgTmV1ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRleHRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRleHRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGltZSBpbiBtcyBmb3IgdGhlIGZhZGVJbiwgZmFkZU91dCBhbmQgbW92ZSBjaGFyYWN0ZXIgT1BzXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdHJhbnNpdGlvblRpbWVfPTUwMFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNpdGlvblRpbWVfOiA1MDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IF92ZG9tXG4gICAgICAgICAqL1xuICAgICAgICBfdmRvbTpcbiAgICAgICAge3N0eWxlOiB7fSwgY246IFtcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLWNvbnRlbnQnXSwgY246IFtdfSxcbiAgICAgICAgICAgIHtjbHM6IFsnbmVvLW1lYXN1cmUtZWxlbWVudC13cmFwcGVyJ10sIHJlbW92ZURvbTogdHJ1ZSwgY246IFtcbiAgICAgICAgICAgICAgICB7Y2xzOiBbJ25lby1tZWFzdXJlLWVsZW1lbnQnXSwgY246W119XG4gICAgICAgICAgICBdfVxuICAgICAgICBdfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBjaGFycz1bXVxuICAgICAqL1xuICAgIGNoYXJzID0gW11cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRJbmRleD0wXG4gICAgICovXG4gICAgY3VycmVudEluZGV4ID0gMFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBpbnRlcnZhbElkPW51bGxcbiAgICAgKi9cbiAgICBpbnRlcnZhbElkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdFtdfSBwcmV2aW91c0NoYXJzPVtdXG4gICAgICovXG4gICAgcHJldmlvdXNDaGFycyA9IFtdXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtZWFzdXJlRWxlbWVudFxuICAgICAqL1xuICAgIGdldCBtZWFzdXJlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbS5jblsxXS5jblswXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgYXV0b0N5Y2xlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QXV0b0N5Y2xlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLm1vdW50ZWQgJiYgdGhpcy5zdGFydEF1dG9DeWNsZSh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGF1dG9DeWNsZUludGVydmFsIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEF1dG9DeWNsZUludGVydmFsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChvbGRWYWx1ZSAmJiBtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5zdGFydEF1dG9DeWNsZShmYWxzZSk7XG4gICAgICAgICAgICBtZS5zdGFydEF1dG9DeWNsZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZvbnRGYW1pbHkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Rm9udEZhbWlseSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZG9tLnN0eWxlLmZvbnRGYW1pbHkgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB0aGlzLmF1dG9DeWNsZSAmJiB0aGlzLnN0YXJ0QXV0b0N5Y2xlKHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGV4dCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgYWZ0ZXJTZXRUZXh0KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bWVhc3VyZUVsZW1lbnR9ID0gbWU7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBtZS5wcmV2aW91c0NoYXJzID0gbWUuY2hhcnNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbWUuY2hhcnMgPSBbXTtcbiAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50LmNuID0gW107XG5cbiAgICAgICAgICAgIHZhbHVlPy5zcGxpdCgnJykuZm9yRWFjaChjaGFyID0+IHtcbiAgICAgICAgICAgICAgICBtZS5jaGFycy5wdXNoKHtuYW1lOiBjaGFyfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPSAnJm5ic3A7J1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lYXN1cmVFbGVtZW50LmNuLnB1c2goe3RhZzogJ3NwYW4nLCBodG1sOiBjaGFyfSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobWUubW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLm1lYXN1cmVDaGFycygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLnVwZGF0ZUNoYXJzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdHJhbnNpdGlvblRpbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VHJhbnNpdGlvblRpbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmRvbS5zdHlsZVsnLS1uZW8tdHJhbnNpdGlvbi10aW1lJ10gPSB2YWx1ZSArICdtcyc7XG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBtZWFzdXJlQ2hhcnMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7bWVhc3VyZUVsZW1lbnR9ID0gbWUsXG4gICAgICAgICAgICBwYXJlbnRSZWN0LCByZWN0cztcblxuICAgICAgICBkZWxldGUgbWUudmRvbS5jblsxXS5yZW1vdmVEb207XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwKTtcblxuICAgICAgICByZWN0cyAgICAgID0gYXdhaXQgbWUuZ2V0RG9tUmVjdChbbWUudmRvbS5jblsxXS5pZCwgLi4ubWVhc3VyZUVsZW1lbnQuY24ubWFwKG5vZGUgPT4gbm9kZS5pZCldKTtcbiAgICAgICAgcGFyZW50UmVjdCA9IHJlY3RzLnNoaWZ0KCk7XG5cbiAgICAgICAgcmVjdHMuZm9yRWFjaCgocmVjdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIG1lLmNoYXJzW2luZGV4XS5sZWZ0ID0gYCR7cmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0fXB4YDtcbiAgICAgICAgICAgIG1lLmNoYXJzW2luZGV4XS50b3AgID0gYCR7cmVjdC50b3AgIC0gcGFyZW50UmVjdC50b3AgfXB4YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudmRvbS5jblsxXS5yZW1vdmVEb20gPSB0cnVlO1xuICAgICAgICBhd2FpdCBtZS5wcm9taXNlVXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXJ0PXRydWVcbiAgICAgKi9cbiAgICBzdGFydEF1dG9DeWNsZShzdGFydD10cnVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBtZS5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLnRleHQgICAgICAgICA9IG1lLmN5Y2xlVGV4dHNbbWUuY3VycmVudEluZGV4XTtcbiAgICAgICAgICAgICAgICBtZS5jdXJyZW50SW5kZXggPSAobWUuY3VycmVudEluZGV4ICsgMSkgJSBtZS5jeWNsZVRleHRzLmxlbmd0aFxuICAgICAgICAgICAgfSwgbWUuYXV0b0N5Y2xlSW50ZXJ2YWwpXG5cbiAgICAgICAgICAgIG1lLnRleHQgJiYgbWUubWVhc3VyZUNoYXJzKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobWUuaW50ZXJ2YWxJZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUNoYXJzKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2hhcnMsIHByZXZpb3VzQ2hhcnN9ID0gbWUsXG4gICAgICAgICAgICBjaGFyc0NvbnRhaW5lciAgICAgICAgID0gbWUudmRvbS5jblswXS5jbixcbiAgICAgICAgICAgIGxldHRlcnMgICAgICAgICAgICAgICAgPSBjaGFycy5tYXAoY2hhciA9PiBjaGFyLm5hbWUpLFxuICAgICAgICAgICAgY2hhciwgY2hhck5vZGUsIGluZGV4O1xuXG4gICAgICAgIHByZXZpb3VzQ2hhcnMuZm9yRWFjaCgocHJldmlvdXNDaGFyLCBwcmV2aW91c0luZGV4KSA9PiB7XG4gICAgICAgICAgICBpbmRleCA9IGxldHRlcnMuaW5kZXhPZihwcmV2aW91c0NoYXIubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUgPSBjaGFyc0NvbnRhaW5lcltwcmV2aW91c0luZGV4XTtcblxuICAgICAgICAgICAgICAgIGNoYXJOb2RlLnN0eWxlLmNvbG9yID0gbWUuY29sb3JNb3ZlO1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlLnN0eWxlLmxlZnQgID0gY2hhcnNbaW5kZXhdLmxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0dGVyc1tpbmRleF0gPSBudWxsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlID0gY2hhcnNDb250YWluZXJbcHJldmlvdXNJbmRleF07XG5cbiAgICAgICAgICAgICAgICBjaGFyTm9kZS5mbGFnID0gJ3JlbW92ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0dGVycy5mb3JFYWNoKChsZXR0ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAobGV0dGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IGNoYXJzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBodG1sIDogY2hhci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge2NvbG9yOiBtZS5jb2xvckZhZGVJbiwgbGVmdDogY2hhci5sZWZ0LCBvcGFjaXR5OiAwLCB0b3A6IGNoYXIudG9wfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5mb3JFYWNoKGNoYXJOb2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFyTm9kZS5mbGFnID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICAgIGNoYXJOb2RlLnN0eWxlLmNvbG9yICAgPSBtZS5jb2xvckZhZGVPdXQ7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUuc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhck5vZGUuc3R5bGUub3BhY2l0eSA9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgbWUucHJvbWlzZVVwZGF0ZSgpO1xuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KG1lLnRyYW5zaXRpb25UaW1lKTtcblxuICAgICAgICBjaGFyc0NvbnRhaW5lci5zb3J0KChhLCBiKSA9PiBwYXJzZUZsb2F0KGEuc3R5bGUubGVmdCkgLSBwYXJzZUZsb2F0KGIuc3R5bGUubGVmdCkpO1xuXG4gICAgICAgIGluZGV4ID0gY2hhcnNDb250YWluZXIubGVuZ3RoIC0gMTtcblxuICAgICAgICBmb3IgKDsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgICAgICAgY2hhck5vZGUgPSBjaGFyc0NvbnRhaW5lcltpbmRleF07XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjaGFyTm9kZS5mbGFnO1xuICAgICAgICAgICAgZGVsZXRlIGNoYXJOb2RlLnN0eWxlLmNvbG9yO1xuXG4gICAgICAgICAgICBpZiAoY2hhck5vZGUuc3R5bGUub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNoYXJzQ29udGFpbmVyLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IG1lLnByb21pc2VVcGRhdGUoKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFnaWNNb3ZlVGV4dCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=