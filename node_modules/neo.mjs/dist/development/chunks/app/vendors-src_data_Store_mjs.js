"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_data_Store_mjs"],{

/***/ "./src/data/Model.mjs":
/*!****************************!*\
  !*** ./src/data/Model.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");



/**
 * @class Neo.data.Model
 * @extends Neo.core.Base
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.Model'
         * @protected
         */
        className: 'Neo.data.Model',
        /**
         * @member {String} ntype='model'
         * @protected
         */
        ntype: 'model',
        /**
         * @member {Object[]|null} fields_=null
         */
        fields_: null,
        /**
         * @member {String} keyProperty_='id'
         */
        keyProperty_: 'id',
        /**
         * @member {String|null} storeId=null
         * @protected
         */
        storeId: null,
        /**
         * Set this config to true in case you want to track modified fields.
         * Be aware that this will double the amount of data inside each record,
         * since each field will get an original value flag.
         * @member {Boolean} trackModifiedFields=false
         */
        trackModifiedFields: false
    }

    /**
     * @member {Map} fieldsMap=new Map()
     * @protected
     */
    fieldsMap = new Map()
    /**
     * @member {Boolean} hasNestedFields=false
     * @protected
     */
    hasNestedFields = false

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createRecordClass(this)
    }

    /**
     Triggered after the fields config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetFields(value, oldValue) {
        if (value) {
            let me = this;

            me.updateFieldsMap(value);

            // Fields can get changed multiple times before the model instance is getting constructed.
            // We only need the latest state before construction & honor run-time changes.
            if (me.isConstructed) {
                _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createRecordClass(me, true)
            }
        }
    }

    /**
     * Finds a field config by a given field name
     * @param {String} name
     * @returns {Object|null} The field config object or null if no match was found
     */
    getField(name) {
        return this.fieldsMap.get(name) || null
    }

    /**
     * @param {Object[]} fields
     * @param {Boolean} isRoot=true
     * @param {String} path=''
     */
    updateFieldsMap(fields, isRoot=true, path='') {
        let me          = this,
            {fieldsMap} = me,
            fieldName;

        if (isRoot) {
            fieldsMap.clear();
            me.hasNestedFields = false
        }

        fields.forEach(field => {
            fieldName = path + field.name

            // Assuming that nested fields contain the full path as the name, we do not need a prefix.
            if (field.fields) {
                me.hasNestedFields = true;
                me.updateFieldsMap(field.fields, false, field.name + '.')
            } else {
                fieldsMap.set(fieldName, field)
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ }),

/***/ "./src/data/RecordFactory.mjs":
/*!************************************!*\
  !*** ./src/data/RecordFactory.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Logger.mjs */ "./src/util/Logger.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");




const
    dataSymbol         = Symbol.for('data'),
    originalDataSymbol = Symbol.for('originalData');

let instance;

/**
 * @class Neo.data.RecordFactory
 * @extends Neo.core.Base
 * @singleton
 */
class RecordFactory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.RecordFactory'
         * @protected
         */
        className: 'Neo.data.RecordFactory',
        /**
         * @member {String} recordNamespace='Neo.data.record'
         */
        recordNamespace: 'Neo.data.record',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Assigns model based default values to a data object
     * @param {Object}         data
     * @param {Record}         record
     * @param {Neo.data.Model} model
     * @returns {Object}
     */
    assignDefaultValues(data, record, model) {
        let {hasNestedFields} = model,
            scope;

        model.fieldsMap.forEach((field, fieldName) => {
            if (Object.hasOwn(field, 'defaultValue')) {
                if (hasNestedFields && fieldName.includes('.')) {
                    let nsArray = fieldName.split('.');

                    fieldName = nsArray.pop();
                    scope     = Neo.ns(nsArray, true, data)
                } else {
                    scope = data
                }

                if (scope[fieldName] === undefined) {
                    scope[fieldName] = field.defaultValue
                }
            }
        });

        return data
    }

    /**
     * @param {Object} data
     * @param {Object} data.field
     * @param {Neo.data.RecordFactory} data.me
     * @param {Neo.data.Model} data.model
     * @param {String} data.path=''
     */
    createField({field, me, model, path=''}) {
        let fieldName = field.name,
            fieldPath = path === '' ? fieldName : `${path}.${fieldName}`,
            properties;

        if (field.fields) {
            field.fields.forEach(childField => {
                this.createField({field: childField, me, model, path: fieldPath})
            })
        } else {
            properties = {
                [fieldPath]: {
                    configurable: true,
                    enumerable  : true,
                    get() {
                        if (model.hasNestedFields) {
                            return Neo.ns(fieldPath, false, this[dataSymbol])
                        }

                        return this[dataSymbol][fieldName]
                    },
                    set(value) {
                        let me       = this,
                            oldValue = me[dataSymbol][fieldName];

                        value = instance.parseRecordValue(me, field, value);

                        if (!Neo.isEqual(value, oldValue)) {
                            instance.setRecordData({fieldName: fieldPath, model, record: me, value});

                            me._isModified = me.isModified;

                            instance.onRecordChange({
                                fields: [{name: fieldPath, oldValue, value}],
                                model,
                                record: me
                            })
                        }
                    }
                }
            };

            Object.defineProperties(me, properties)
        }
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Object} config
     * @returns {Object}
     */
    createRecord(model, config) {
        let recordClass = Neo.ns(`${this.recordNamespace}.${model.className}.${model.id}`);

        if (!recordClass) {
            recordClass = this.createRecordClass(model)
        }

        return new recordClass(config)
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Boolean} overwrite=false
     * @returns {Object}
     */
    createRecordClass(model, overwrite=false) {
        if (model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            let className = `${this.recordNamespace}.${model.className}.${model.id}`,
                ns        = Neo.ns(className),
                key, nsArray, cls;

            if (!ns || overwrite) {
                nsArray = className.split('.');
                key     = nsArray.pop();
                ns      = Neo.ns(nsArray, true);
                cls     = ns[key] = class Record {
                    // We do not want to minify the ctor class name in dist/production
                    static name = 'Record';

                    [dataSymbol] = {}

                    get isModified() {
                        let me = this;

                        if (model.trackModifiedFields) {
                            return Neo.isEqual(me[dataSymbol], me[originalDataSymbol])
                        }

                        return me._isModified
                    }

                    /**
                     * @param {Object} config
                     */
                    constructor(config) {
                        let me = this;

                        config = instance.assignDefaultValues(config, me, model);

                        if (model.trackModifiedFields) {
                            me[originalDataSymbol] = {};
                            me.setOriginal(config)
                        }

                        me.setSilent(config); // We do not want to fire change events when constructing
                        me._isModified = false
                    }

                    /**
                     * @param {String} fieldName
                     * @returns {Boolean|null} null in case the model does not use trackModifiedFields, true in case a change was found
                     */
                    isModifiedField(fieldName) {
                        let me = this;

                        // Check if the field getter does exist
                        if (!me.__proto__.hasOwnProperty(fieldName)) {
                            _util_Logger_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].logError('The record does not contain the field', fieldName, me)
                        }

                        if (model.trackModifiedFields) {
                            let dataScope, originalDataScope;

                            if (model.hasNestedFields && fieldName.includes('.')) {
                                let nsArray = fieldName.split('.');

                                fieldName         = nsArray.pop();
                                dataScope         = Neo.ns(nsArray, false, me[dataSymbol]);
                                originalDataScope = Neo.ns(nsArray, false, me[originalDataSymbol])
                            } else {
                                dataScope         = me[dataSymbol];
                                originalDataScope = me[originalDataSymbol]
                            }

                            return !Neo.isEqual(dataScope[fieldName], originalDataScope[fieldName])
                        }

                        return null
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    set(fields) {
                        instance.setRecordFields({fields, model, record: this})
                    }

                    /**
                     * If the model uses trackModifiedFields, we will store the original data
                     * for tracking the dirty state (changed fields)
                     * @param {Object} fields
                     * @protected
                     */
                    setOriginal(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true, useOriginalData: true})
                    }

                    /**
                     * Bulk-update multiple record fields at once without triggering a change event
                     * @param {Object} fields
                     */
                    setSilent(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true})
                    }

                    /**
                     * When using JSON.stringify(this), we want to get the raw data
                     * @returns {Object}
                     */
                    toJSON() {
                        return this[dataSymbol]
                    }
                };

                if (Array.isArray(model.fields)) {
                    model.fields.forEach(field => {
                        instance.createField({field, me: cls.prototype, model})
                    })
                }

                Object.defineProperty(cls.prototype, 'isRecord', {value: true});
                Object.defineProperty(cls, 'isClass', {value: true});

                return ns[key]
            }

            return ns
        }
    }

    /**
     * @param {Object} record
     * @returns {Boolean} true in case a change was found
     */
    isModified(record) {
        return record.isModified
    }

    /**
     * @param {Object} record
     * @param {String} fieldName
     * @returns {Boolean|null} null in case the model does not use trackModifiedFields, true in case a change was found
     */
    isModifiedField(record, fieldName) {
        return record.isModifiedField(fieldName)
    }

    /**
     * Tests if a given object is an instance of a class created by this factory
     * @param {Object} record
     * @returns {Boolean}
     */
    isRecord(record) {
        return record?.isRecord || false
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onRecordChange(opts) {
        Neo.get(opts.model.storeId)?.onRecordChange(opts)
    }

    /**
     * todo: parse value for more field types
     * @param {Object} record
     * @param {Object} field
     * @param {*} value
     * @param {Object} recordConfig=null
     * @returns {*}
     */
    parseRecordValue(record, field, value, recordConfig=null) {
        if (field.calculate) {
            return field.calculate(record, field, recordConfig)
        }

        if (field.convert) {
            value = field.convert(value)
        }

        let fieldName = field.name,
            {mapping, maxLength, minLength, nullable} = field,
            oldValue  = recordConfig?.[fieldName] || record[fieldName],
            type      = field.type?.toLowerCase();

        // only trigger mappings for initial values
        // dynamic changes of a field will not pass the recordConfig
        if (mapping && recordConfig) {
            let ns  = mapping.split('.'),
                key = ns.pop();

            ns    = Neo.ns(ns, true, recordConfig);
            value = ns[key]
        }

        if (Object.hasOwn(field, 'maxLength')) {
            if (value?.toString().length > maxLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with maxLength: ${maxLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'minLength')) {
            if (value?.toString().length < minLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with minLength: ${minLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'nullable')) {
            if (nullable === false && value === null) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with nullable: ${nullable}`);
                return oldValue
            }
        }

        if (type === 'date' && Neo.typeOf(value) !== 'Date') {
            return new Date(value)
        }

        else if (type === 'float' && value) {
            value = parseFloat(value)
        }

        else if (type === 'html' && value) {
            value = value + ''
        }

        else if ((type === 'int' || type === 'integer') && value) {
            value = parseInt(value)
        }

        else if (type === 'string' && value) {
            value = value + '';
            value =  value.replace(/(<([^>]+)>)/ig, '')
        }

        return value
    }

    /**
     * @param {Object}         data
     * @param {String}         data.fieldName
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     * @param {*}              data.value
     * @protected
     */
    setRecordData({fieldName, model, record, useOriginalData=false, value}) {
        let scope = useOriginalData ? originalDataSymbol : dataSymbol;

        if (model.hasNestedFields && fieldName.includes('.')) {
            let ns, nsArray;

            nsArray   = fieldName.split('.');
            fieldName = nsArray.pop();
            ns        = Neo.ns(nsArray, true, record[scope]);

            ns[fieldName] = value
        } else {
            record[scope][fieldName] = value
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.changedFields=[] Internal flag
     * @param {Object}         data.fields
     * @param {Neo.data.Model} data.model
     * @param {Object}         data.record
     * @param {Boolean}        data.silent=false
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     */
    setRecordFields({changedFields=[], fields, model, record, silent=false, useOriginalData=false}) {
        let {fieldsMap} = model,
            fieldExists, oldValue;

        Object.entries(fields).forEach(([key, value]) => {
            fieldExists = fieldsMap.has(key);

            if (Neo.isObject(value) && !fieldExists) {
                Object.entries(value).forEach(([childKey, childValue]) => {
                    this.setRecordFields({
                        changedFields,
                        fields: {[`${key}.${childKey}`]: childValue},
                        model,
                        record,
                        silent: true,
                        useOriginalData
                    })
                })
            } else if (fieldExists) {
                oldValue = record[key];
                value    = instance.parseRecordValue(record, model.getField(key), value);

                if (!Neo.isEqual(oldValue, value)) {
                    instance.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    if (!useOriginalData) {
                        record._isModified = true
                    }

                    changedFields.push({name: key, oldValue, value})
                }
            }
        });

        if (!silent && Object.keys(changedFields).length > 0) {
            Neo.get(model.storeId)?.onRecordChange({fields: changedFields, model, record})
        }
    }
}

instance = Neo.setupClass(RecordFactory);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ }),

/***/ "./src/data/Store.mjs":
/*!****************************!*\
  !*** ./src/data/Store.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");






/**
 * @class Neo.data.Store
 * @extends Neo.collection.Base
 */
class Store extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.Store'
         * @protected
         */
        className: 'Neo.data.Store',
        /**
         * @member {String} ntype='store'
         * @protected
         */
        ntype: 'store',
        /**
         * Instead of setting an url, you can define the RPC BE API methods.
         * In case the 4 methods are using the same service and this service is using the CRUD based fn-names,
         * you can switch to a string based shortcut.
         * The following 2 examples are equivalent.
         * @example
         * api: {
         *    create : 'MyApp.backend.UserService.create',
         *    destroy: 'MyApp.backend.UserService.destroy',
         *    read   : 'MyApp.backend.UserService.read',
         *    update : 'MyApp.backend.UserService.update'
         * }
         * @example
         * api: 'MyApp.backend.UserService'
         * @member {Object|String|null} api_=null
         */
        api_: null,
        /**
         * @member {Boolean} autoLoad=false
         */
        autoLoad: false,
        /**
         * @member {Number} currentPage_=1
         */
        currentPage_: 1,
        /**
         * @member {Array|null} data_=null
         */
        data_: null,
        /**
         * @member {Array|null} initialData_=null
         */
        initialData_: null,
        /**
         * @member {Boolean} isGrouped=false
         */
        isGrouped: false,
        /**
         * @member {Boolean} isLoaded=false
         */
        isLoaded: false,
        /**
         * @member {Boolean} isLoading=false
         */
        isLoading: false,
        /**
         * @member {Neo.data.Model} model_=null
         */
        model_: null,
        /**
         * Use a value of 0 to not limit the pageSize
         * @member {Number} pageSize_=0
         */
        pageSize_: 0,
        /**
         * True to let the backend handle the filtering.
         * Useful for buffered stores
         * @member {Boolean} remoteFilter=false
         */
        remoteFilter: false,
        /**
         * True to let the backend handle the sorting.
         * Useful for buffered stores
         * @member {Boolean} remoteSort=false
         */
        remoteSort: false,
        /**
         * Add a path to the root of your data.
         * If the responseRoot is 'data' this is optional.
         * @member {String} responseRoot='data'
         */
        responseRoot: 'data',
        /**
         * @member {Number} totalCount=0
         */
        totalCount: 0,
        /**
         * Url for Ajax requests
         * @member {String|null} url=null
         */
        url: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // todo
        me.on({
            mutate: me.onCollectionMutate,
            sort  : me.onCollectionSort,
            scope : me
        });
    }

    /**
     * Overrides collection.Base: add() to convert items into records if needed
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    add(item) {
        return super.add(this.beforeSetData(item))
    }

    /**
     * Triggered after the currentPage config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCurrentPage(value, oldValue) {
        oldValue && this.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        let me = this;

        if (me.configsApplied) {
            if (value) {
                if (oldValue) {
                    me.clear()
                } else {
                    me.initialData = [...value]
                }

                me.add(value)
            }
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        super.afterSetFilters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteFilter && me.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetInitialData(value, oldValue) {
        // console.log('afterSetInitialData', value, oldValue);
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetModel(value, oldValue) {
        if (value) {
            value.storeId = this.id
        }
    }

    /**
     * Triggered after the pageSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPageSize(value, oldValue) {
        if (oldValue) {
            this._currentPage = 1; // silent update
            this.load()
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        super.afterSetSorters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteSort && me.load()
    }

    /**
     * @param {Object|String|null} value
     * @param {Object|String|null} oldValue
     * @protected
     * @returns {Object|null}
     */
    beforeSetApi(value, oldValue) {
        if (Neo.typeOf(value) === 'String') {
            value = {
                create : value + '.create',
                destroy: value + '.destroy',
                read   : value + '.read',
                update : value + '.update'
            }
        }

        return value
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     * @returns {*}
     */
    beforeSetData(value, oldValue) {
        if (value) {
            if (!Array.isArray(value)) {
                value = [value]
            }

            let me  = this,
                i   = 0,
                len = value.length,
                item;

            for (; i < len; i++) {
                item = value[i]

                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
                    value[i] = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item)
                }
            }
        }

        return value
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     * @returns {*}
     */
    beforeSetInitialData(value, oldValue) {
        if (!value && oldValue) {
            return oldValue
        }

        return value
    }

    /**
     * @param {Neo.data.Model|Object} value
     * @param {Neo.data.Model|Object} oldValue
     * @protected
     * @returns {Neo.data.Model}
     */
    beforeSetModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _Model_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * @param {Object} config
     */
    createRecord(config) {
        _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(config)
    }

    /**
     * @returns {String}
     */
    getKeyProperty() {
        return this.keyProperty || this.model.keyProperty
    }

    /**
     * @param {Object} opts={}
     * @param {Object} opts.data
     * @param {Object} opts.headers
     * @param {String} opts.method DELETE, GET, POST, PUT
     * @param {Object} opts.params
     * @param {String} opts.responseType
     * @param {Object} opts.scope
     * @param {String} opts.url
     * @protected
     */
    load(opts={}) {
        let me     = this,
            params = {page: me.currentPage, pageSize: me.pageSize, ...opts.params};

        if (me.remoteFilter) {
            params.filters = me.exportFilters()
        }

        if (me.remoteSort) {
            params.sorters = me.exportSorters()
        }

        if (me.api) {
            let apiArray = me.api.read.split('.'),
                fn       = apiArray.pop(),
                service  = Neo.ns(apiArray.join('.'));

            if (!service) {
                console.log('Api is not defined', this)
            } else {
                service[fn](params).then(response => {
                    response = Neo.ns(me.responseRoot, false, response);

                    if (response.success) {
                        me.totalCount = response.totalCount;
                        me.data       = Neo.ns(me.responseRoot, false, response); // fires the load event
                    }
                })
            }
        } else {
            opts.url ??= me.url;

            Neo.Xhr.promiseJson(opts).catch(err => {
                console.log('Error for Neo.Xhr.request', err, me.id)
            }).then(data => {
                me.data = Neo.ns(me.responseRoot, false, data.json) || data.json
                // we do not need to fire a load event => onCollectionMutate()
            })
        }
    }

    /**
     * @param {Object} opts
     */
    onCollectionMutate(opts) {
        let me = this;

        if (me.configsApplied) {
            // console.log('onCollectionMutate', opts);
            me.fire('load', me.items)
        }
    }

    /**
     * todo: add will fire mutate and sort right after another
     */
    onCollectionSort() {
        let me = this;

        if (me.configsApplied) {
            // console.log('onCollectionSort', me.collection.items);
            // me.fire('load', me.items);
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.data) {
            me.afterSetData(me.data);
        }

        if (me.autoLoad) {
            me.timeout(100).then(() => { // todo
                me.load()
            })
        }
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        let me = this;

        if (me.remoteFilter) {
            me._currentPage = 1; // silent update
            me.load()
        } else {
            super.onFilterChange(opts)
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object} data.record
     */
    onRecordChange(data) {
        this.fire('recordChange', {
            ...data,
            index: this.indexOf(data.record)
        })
    }

    /**
     * @param {Object} opts={}
     * @param {String} opts.direction
     * @param {String} opts.property
     */
    sort(opts={}) {
        let me = this;

        me._currentPage = 1; // silent update

        if (me.configsApplied) {
            if (opts.direction) {
                me.sorters = [{
                    direction: opts.direction,
                    property : opts.property
                }]
            } else {
                if (!me.remoteSort) {
                    me.startUpdate();
                    me.clear()
                }

                me.sorters = [];

                if (!me.remoteSort) {
                    me.add([...me.initialData]);
                    me.endUpdate();
                    me.fire('sort')
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDRzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWE7QUFDckI7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWE7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUs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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL01vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvUmVjb3JkRmFjdG9yeS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL1N0b3JlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBSZWNvcmRGYWN0b3J5IGZyb20gJy4vUmVjb3JkRmFjdG9yeS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGF0YS5Nb2RlbFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBNb2RlbCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXRhLk1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfG51bGx9IGZpZWxkc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHlfPSdpZCdcbiAgICAgICAgICovXG4gICAgICAgIGtleVByb3BlcnR5XzogJ2lkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzdG9yZUlkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGNvbmZpZyB0byB0cnVlIGluIGNhc2UgeW91IHdhbnQgdG8gdHJhY2sgbW9kaWZpZWQgZmllbGRzLlxuICAgICAgICAgKiBCZSBhd2FyZSB0aGF0IHRoaXMgd2lsbCBkb3VibGUgdGhlIGFtb3VudCBvZiBkYXRhIGluc2lkZSBlYWNoIHJlY29yZCxcbiAgICAgICAgICogc2luY2UgZWFjaCBmaWVsZCB3aWxsIGdldCBhbiBvcmlnaW5hbCB2YWx1ZSBmbGFnLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB0cmFja01vZGlmaWVkRmllbGRzPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0cmFja01vZGlmaWVkRmllbGRzOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge01hcH0gZmllbGRzTWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaWVsZHNNYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNOZXN0ZWRGaWVsZHM9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaGFzTmVzdGVkRmllbGRzID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuICAgICAgICBSZWNvcmRGYWN0b3J5LmNyZWF0ZVJlY29yZENsYXNzKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgIFRyaWdnZXJlZCBhZnRlciB0aGUgZmllbGRzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmllbGRzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZUZpZWxkc01hcCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIEZpZWxkcyBjYW4gZ2V0IGNoYW5nZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHRoZSBtb2RlbCBpbnN0YW5jZSBpcyBnZXR0aW5nIGNvbnN0cnVjdGVkLlxuICAgICAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRoZSBsYXRlc3Qgc3RhdGUgYmVmb3JlIGNvbnN0cnVjdGlvbiAmIGhvbm9yIHJ1bi10aW1lIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAobWUuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgICAgIFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkQ2xhc3MobWUsIHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIGZpZWxkIGNvbmZpZyBieSBhIGdpdmVuIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGZpZWxkIGNvbmZpZyBvYmplY3Qgb3IgbnVsbCBpZiBubyBtYXRjaCB3YXMgZm91bmRcbiAgICAgKi9cbiAgICBnZXRGaWVsZChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkc01hcC5nZXQobmFtZSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGZpZWxkc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSb290PXRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aD0nJ1xuICAgICAqL1xuICAgIHVwZGF0ZUZpZWxkc01hcChmaWVsZHMsIGlzUm9vdD10cnVlLCBwYXRoPScnKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZmllbGRzTWFwfSA9IG1lLFxuICAgICAgICAgICAgZmllbGROYW1lO1xuXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgIGZpZWxkc01hcC5jbGVhcigpO1xuICAgICAgICAgICAgbWUuaGFzTmVzdGVkRmllbGRzID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGZpZWxkTmFtZSA9IHBhdGggKyBmaWVsZC5uYW1lXG5cbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIHRoYXQgbmVzdGVkIGZpZWxkcyBjb250YWluIHRoZSBmdWxsIHBhdGggYXMgdGhlIG5hbWUsIHdlIGRvIG5vdCBuZWVkIGEgcHJlZml4LlxuICAgICAgICAgICAgaWYgKGZpZWxkLmZpZWxkcykge1xuICAgICAgICAgICAgICAgIG1lLmhhc05lc3RlZEZpZWxkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlRmllbGRzTWFwKGZpZWxkLmZpZWxkcywgZmFsc2UsIGZpZWxkLm5hbWUgKyAnLicpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkc01hcC5zZXQoZmllbGROYW1lLCBmaWVsZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1vZGVsKTtcbiIsImltcG9ydCBCYXNlICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL3V0aWwvTG9nZ2VyLm1qcyc7XG5pbXBvcnQgTW9kZWwgIGZyb20gJy4vTW9kZWwubWpzJztcblxuY29uc3RcbiAgICBkYXRhU3ltYm9sICAgICAgICAgPSBTeW1ib2wuZm9yKCdkYXRhJyksXG4gICAgb3JpZ2luYWxEYXRhU3ltYm9sID0gU3ltYm9sLmZvcignb3JpZ2luYWxEYXRhJyk7XG5cbmxldCBpbnN0YW5jZTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuUmVjb3JkRmFjdG9yeVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBSZWNvcmRGYWN0b3J5IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGF0YS5SZWNvcmRGYWN0b3J5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5SZWNvcmRGYWN0b3J5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVjb3JkTmFtZXNwYWNlPSdOZW8uZGF0YS5yZWNvcmQnXG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmROYW1lc3BhY2U6ICdOZW8uZGF0YS5yZWNvcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBtb2RlbCBiYXNlZCBkZWZhdWx0IHZhbHVlcyB0byBhIGRhdGEgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSAgICAgICAgIHJlY29yZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3NpZ25EZWZhdWx0VmFsdWVzKGRhdGEsIHJlY29yZCwgbW9kZWwpIHtcbiAgICAgICAgbGV0IHtoYXNOZXN0ZWRGaWVsZHN9ID0gbW9kZWwsXG4gICAgICAgICAgICBzY29wZTtcblxuICAgICAgICBtb2RlbC5maWVsZHNNYXAuZm9yRWFjaCgoZmllbGQsIGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNOZXN0ZWRGaWVsZHMgJiYgZmllbGROYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5zQXJyYXkgPSBmaWVsZE5hbWUuc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZSAgICAgPSBOZW8ubnMobnNBcnJheSwgdHJ1ZSwgZGF0YSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IGRhdGFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVbZmllbGROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlW2ZpZWxkTmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5maWVsZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuUmVjb3JkRmFjdG9yeX0gZGF0YS5tZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5wYXRoPScnXG4gICAgICovXG4gICAgY3JlYXRlRmllbGQoe2ZpZWxkLCBtZSwgbW9kZWwsIHBhdGg9Jyd9KSB7XG4gICAgICAgIGxldCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgZmllbGRQYXRoID0gcGF0aCA9PT0gJycgPyBmaWVsZE5hbWUgOiBgJHtwYXRofS4ke2ZpZWxkTmFtZX1gLFxuICAgICAgICAgICAgcHJvcGVydGllcztcblxuICAgICAgICBpZiAoZmllbGQuZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZC5maWVsZHMuZm9yRWFjaChjaGlsZEZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZpZWxkKHtmaWVsZDogY2hpbGRGaWVsZCwgbWUsIG1vZGVsLCBwYXRoOiBmaWVsZFBhdGh9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgW2ZpZWxkUGF0aF06IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5oYXNOZXN0ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVvLm5zKGZpZWxkUGF0aCwgZmFsc2UsIHRoaXNbZGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2RhdGFTeW1ib2xdW2ZpZWxkTmFtZV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbWVbZGF0YVN5bWJvbF1bZmllbGROYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpbnN0YW5jZS5wYXJzZVJlY29yZFZhbHVlKG1lLCBmaWVsZCwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRSZWNvcmREYXRhKHtmaWVsZE5hbWU6IGZpZWxkUGF0aCwgbW9kZWwsIHJlY29yZDogbWUsIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5faXNNb2RpZmllZCA9IG1lLmlzTW9kaWZpZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5vblJlY29yZENoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczogW3tuYW1lOiBmaWVsZFBhdGgsIG9sZFZhbHVlLCB2YWx1ZX1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkOiBtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZSwgcHJvcGVydGllcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKG1vZGVsLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHJlY29yZENsYXNzID0gTmVvLm5zKGAke3RoaXMucmVjb3JkTmFtZXNwYWNlfS4ke21vZGVsLmNsYXNzTmFtZX0uJHttb2RlbC5pZH1gKTtcblxuICAgICAgICBpZiAoIXJlY29yZENsYXNzKSB7XG4gICAgICAgICAgICByZWNvcmRDbGFzcyA9IHRoaXMuY3JlYXRlUmVjb3JkQ2xhc3MobW9kZWwpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IHJlY29yZENsYXNzKGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBtb2RlbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlPWZhbHNlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGVSZWNvcmRDbGFzcyhtb2RlbCwgb3ZlcndyaXRlPWZhbHNlKSB7XG4gICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gYCR7dGhpcy5yZWNvcmROYW1lc3BhY2V9LiR7bW9kZWwuY2xhc3NOYW1lfS4ke21vZGVsLmlkfWAsXG4gICAgICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAga2V5LCBuc0FycmF5LCBjbHM7XG5cbiAgICAgICAgICAgIGlmICghbnMgfHwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgbnNBcnJheSA9IGNsYXNzTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIGtleSAgICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgIG5zICAgICAgPSBOZW8ubnMobnNBcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2xzICAgICA9IG5zW2tleV0gPSBjbGFzcyBSZWNvcmQge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBtaW5pZnkgdGhlIGN0b3IgY2xhc3MgbmFtZSBpbiBkaXN0L3Byb2R1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgc3RhdGljIG5hbWUgPSAnUmVjb3JkJztcblxuICAgICAgICAgICAgICAgICAgICBbZGF0YVN5bWJvbF0gPSB7fVxuXG4gICAgICAgICAgICAgICAgICAgIGdldCBpc01vZGlmaWVkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVvLmlzRXF1YWwobWVbZGF0YVN5bWJvbF0sIG1lW29yaWdpbmFsRGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5faXNNb2RpZmllZFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gaW5zdGFuY2UuYXNzaWduRGVmYXVsdFZhbHVlcyhjb25maWcsIG1lLCBtb2RlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC50cmFja01vZGlmaWVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVbb3JpZ2luYWxEYXRhU3ltYm9sXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldE9yaWdpbmFsKGNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0U2lsZW50KGNvbmZpZyk7IC8vIFdlIGRvIG5vdCB3YW50IHRvIGZpcmUgY2hhbmdlIGV2ZW50cyB3aGVuIGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX2lzTW9kaWZpZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gbnVsbCBpbiBjYXNlIHRoZSBtb2RlbCBkb2VzIG5vdCB1c2UgdHJhY2tNb2RpZmllZEZpZWxkcywgdHJ1ZSBpbiBjYXNlIGEgY2hhbmdlIHdhcyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaXNNb2RpZmllZEZpZWxkKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpZWxkIGdldHRlciBkb2VzIGV4aXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lLl9fcHJvdG9fXy5oYXNPd25Qcm9wZXJ0eShmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9yKCdUaGUgcmVjb3JkIGRvZXMgbm90IGNvbnRhaW4gdGhlIGZpZWxkJywgZmllbGROYW1lLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVNjb3BlLCBvcmlnaW5hbERhdGFTY29wZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5oYXNOZXN0ZWRGaWVsZHMgJiYgZmllbGROYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5zQXJyYXkgPSBmaWVsZE5hbWUuc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgICAgICAgICA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTY29wZSAgICAgICAgID0gTmVvLm5zKG5zQXJyYXksIGZhbHNlLCBtZVtkYXRhU3ltYm9sXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRGF0YVNjb3BlID0gTmVvLm5zKG5zQXJyYXksIGZhbHNlLCBtZVtvcmlnaW5hbERhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTY29wZSAgICAgICAgID0gbWVbZGF0YVN5bWJvbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRGF0YVNjb3BlID0gbWVbb3JpZ2luYWxEYXRhU3ltYm9sXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhTmVvLmlzRXF1YWwoZGF0YVNjb3BlW2ZpZWxkTmFtZV0sIG9yaWdpbmFsRGF0YVNjb3BlW2ZpZWxkTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQnVsay11cGRhdGUgbXVsdGlwbGUgcmVjb3JkIGZpZWxkcyBhdCBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNldChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcyh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbW9kZWwgdXNlcyB0cmFja01vZGlmaWVkRmllbGRzLCB3ZSB3aWxsIHN0b3JlIHRoZSBvcmlnaW5hbCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAqIGZvciB0cmFja2luZyB0aGUgZGlydHkgc3RhdGUgKGNoYW5nZWQgZmllbGRzKVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNldE9yaWdpbmFsKGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UmVjb3JkRmllbGRzKHtmaWVsZHMsIG1vZGVsLCByZWNvcmQ6IHRoaXMsIHNpbGVudDogdHJ1ZSwgdXNlT3JpZ2luYWxEYXRhOiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBCdWxrLXVwZGF0ZSBtdWx0aXBsZSByZWNvcmQgZmllbGRzIGF0IG9uY2Ugd2l0aG91dCB0cmlnZ2VyaW5nIGEgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNldFNpbGVudChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcyh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzLCBzaWxlbnQ6IHRydWV9KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFdoZW4gdXNpbmcgSlNPTi5zdHJpbmdpZnkodGhpcyksIHdlIHdhbnQgdG8gZ2V0IHRoZSByYXcgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZGF0YVN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbC5maWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNyZWF0ZUZpZWxkKHtmaWVsZCwgbWU6IGNscy5wcm90b3R5cGUsIG1vZGVsfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xzLnByb3RvdHlwZSwgJ2lzUmVjb3JkJywge3ZhbHVlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNscywgJ2lzQ2xhc3MnLCB7dmFsdWU6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuc1trZXldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGluIGNhc2UgYSBjaGFuZ2Ugd2FzIGZvdW5kXG4gICAgICovXG4gICAgaXNNb2RpZmllZChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZC5pc01vZGlmaWVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxudWxsfSBudWxsIGluIGNhc2UgdGhlIG1vZGVsIGRvZXMgbm90IHVzZSB0cmFja01vZGlmaWVkRmllbGRzLCB0cnVlIGluIGNhc2UgYSBjaGFuZ2Ugd2FzIGZvdW5kXG4gICAgICovXG4gICAgaXNNb2RpZmllZEZpZWxkKHJlY29yZCwgZmllbGROYW1lKSB7XG4gICAgICAgIHJldHVybiByZWNvcmQuaXNNb2RpZmllZEZpZWxkKGZpZWxkTmFtZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBhIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBhIGNsYXNzIGNyZWF0ZWQgYnkgdGhpcyBmYWN0b3J5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUmVjb3JkKHJlY29yZCkge1xuICAgICAgICByZXR1cm4gcmVjb3JkPy5pc1JlY29yZCB8fCBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhIHJlY29yZCBmaWVsZC5cbiAgICAgKiBFLmcuIG15UmVjb3JkLmZvbyA9ICdiYXInO1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb3B0cy5maWVsZHMgRWFjaCBmaWVsZCBvYmplY3QgY29udGFpbnMgdGhlIGtleXM6IG5hbWUsIG9sZFZhbHVlLCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG9wdHMubW9kZWwgVGhlIG1vZGVsIGluc3RhbmNlIG9mIHRoZSBjaGFuZ2VkIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnJlY29yZFxuICAgICAqL1xuICAgIG9uUmVjb3JkQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgTmVvLmdldChvcHRzLm1vZGVsLnN0b3JlSWQpPy5vblJlY29yZENoYW5nZShvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IHBhcnNlIHZhbHVlIGZvciBtb3JlIGZpZWxkIHR5cGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkQ29uZmlnPW51bGxcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBwYXJzZVJlY29yZFZhbHVlKHJlY29yZCwgZmllbGQsIHZhbHVlLCByZWNvcmRDb25maWc9bnVsbCkge1xuICAgICAgICBpZiAoZmllbGQuY2FsY3VsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQuY2FsY3VsYXRlKHJlY29yZCwgZmllbGQsIHJlY29yZENvbmZpZylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWVsZC5jb252ZXJ0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLmNvbnZlcnQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmllbGROYW1lID0gZmllbGQubmFtZSxcbiAgICAgICAgICAgIHttYXBwaW5nLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCwgbnVsbGFibGV9ID0gZmllbGQsXG4gICAgICAgICAgICBvbGRWYWx1ZSAgPSByZWNvcmRDb25maWc/LltmaWVsZE5hbWVdIHx8IHJlY29yZFtmaWVsZE5hbWVdLFxuICAgICAgICAgICAgdHlwZSAgICAgID0gZmllbGQudHlwZT8udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBvbmx5IHRyaWdnZXIgbWFwcGluZ3MgZm9yIGluaXRpYWwgdmFsdWVzXG4gICAgICAgIC8vIGR5bmFtaWMgY2hhbmdlcyBvZiBhIGZpZWxkIHdpbGwgbm90IHBhc3MgdGhlIHJlY29yZENvbmZpZ1xuICAgICAgICBpZiAobWFwcGluZyAmJiByZWNvcmRDb25maWcpIHtcbiAgICAgICAgICAgIGxldCBucyAgPSBtYXBwaW5nLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAga2V5ID0gbnMucG9wKCk7XG5cbiAgICAgICAgICAgIG5zICAgID0gTmVvLm5zKG5zLCB0cnVlLCByZWNvcmRDb25maWcpO1xuICAgICAgICAgICAgdmFsdWUgPSBuc1trZXldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ21heExlbmd0aCcpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWU/LnRvU3RyaW5nKCkubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXR0aW5nIHJlY29yZCBmaWVsZDogJHtmaWVsZE5hbWV9IHZhbHVlOiAke3ZhbHVlfSBjb25mbGljdHMgd2l0aCBtYXhMZW5ndGg6ICR7bWF4TGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdtaW5MZW5ndGgnKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlPy50b1N0cmluZygpLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0dGluZyByZWNvcmQgZmllbGQ6ICR7ZmllbGROYW1lfSB2YWx1ZTogJHt2YWx1ZX0gY29uZmxpY3RzIHdpdGggbWluTGVuZ3RoOiAke21pbkxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCAnbnVsbGFibGUnKSkge1xuICAgICAgICAgICAgaWYgKG51bGxhYmxlID09PSBmYWxzZSAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0dGluZyByZWNvcmQgZmllbGQ6ICR7ZmllbGROYW1lfSB2YWx1ZTogJHt2YWx1ZX0gY29uZmxpY3RzIHdpdGggbnVsbGFibGU6ICR7bnVsbGFibGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RhdGUnICYmIE5lby50eXBlT2YodmFsdWUpICE9PSAnRGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmbG9hdCcgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdodG1sJyAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICcnXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICgodHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ2ludGVnZXInKSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJyc7XG4gICAgICAgICAgICB2YWx1ZSA9ICB2YWx1ZS5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgZGF0YS5maWVsZE5hbWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtSZWNvcmR9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICBkYXRhLnVzZU9yaWdpbmFsRGF0YT1mYWxzZSB0cnVlIHdpbGwgYXBwbHkgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWxEYXRhIHN5bWJvbFxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgICAgICAgIGRhdGEudmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0UmVjb3JkRGF0YSh7ZmllbGROYW1lLCBtb2RlbCwgcmVjb3JkLCB1c2VPcmlnaW5hbERhdGE9ZmFsc2UsIHZhbHVlfSkge1xuICAgICAgICBsZXQgc2NvcGUgPSB1c2VPcmlnaW5hbERhdGEgPyBvcmlnaW5hbERhdGFTeW1ib2wgOiBkYXRhU3ltYm9sO1xuXG4gICAgICAgIGlmIChtb2RlbC5oYXNOZXN0ZWRGaWVsZHMgJiYgZmllbGROYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIGxldCBucywgbnNBcnJheTtcblxuICAgICAgICAgICAgbnNBcnJheSAgID0gZmllbGROYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBmaWVsZE5hbWUgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKG5zQXJyYXksIHRydWUsIHJlY29yZFtzY29wZV0pO1xuXG4gICAgICAgICAgICBuc1tmaWVsZE5hbWVdID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY29yZFtzY29wZV1bZmllbGROYW1lXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gICAgICAgZGF0YS5jaGFuZ2VkRmllbGRzPVtdIEludGVybmFsIGZsYWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLmZpZWxkc1xuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEuc2lsZW50PWZhbHNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2UgdHJ1ZSB3aWxsIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsRGF0YSBzeW1ib2xcbiAgICAgKi9cbiAgICBzZXRSZWNvcmRGaWVsZHMoe2NoYW5nZWRGaWVsZHM9W10sIGZpZWxkcywgbW9kZWwsIHJlY29yZCwgc2lsZW50PWZhbHNlLCB1c2VPcmlnaW5hbERhdGE9ZmFsc2V9KSB7XG4gICAgICAgIGxldCB7ZmllbGRzTWFwfSA9IG1vZGVsLFxuICAgICAgICAgICAgZmllbGRFeGlzdHMsIG9sZFZhbHVlO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBmaWVsZEV4aXN0cyA9IGZpZWxkc01hcC5oYXMoa2V5KTtcblxuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgIWZpZWxkRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtjaGlsZEtleSwgY2hpbGRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSZWNvcmRGaWVsZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczoge1tgJHtrZXl9LiR7Y2hpbGRLZXl9YF06IGNoaWxkVmFsdWV9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VPcmlnaW5hbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZEV4aXN0cykge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVjb3JkW2tleV07XG4gICAgICAgICAgICAgICAgdmFsdWUgICAgPSBpbnN0YW5jZS5wYXJzZVJlY29yZFZhbHVlKHJlY29yZCwgbW9kZWwuZ2V0RmllbGQoa2V5KSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChvbGRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZERhdGEoe2ZpZWxkTmFtZToga2V5LCBtb2RlbCwgcmVjb3JkLCB1c2VPcmlnaW5hbERhdGEsIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VPcmlnaW5hbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5faXNNb2RpZmllZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHMucHVzaCh7bmFtZToga2V5LCBvbGRWYWx1ZSwgdmFsdWV9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQgJiYgT2JqZWN0LmtleXMoY2hhbmdlZEZpZWxkcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgTmVvLmdldChtb2RlbC5zdG9yZUlkKT8ub25SZWNvcmRDaGFuZ2Uoe2ZpZWxkczogY2hhbmdlZEZpZWxkcywgbW9kZWwsIHJlY29yZH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmluc3RhbmNlID0gTmVvLnNldHVwQ2xhc3MoUmVjb3JkRmFjdG9yeSk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IE1vZGVsICAgICAgICAgICBmcm9tICcuL01vZGVsLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFJlY29yZEZhY3RvcnkgICBmcm9tICcuL1JlY29yZEZhY3RvcnkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuU3RvcmVcbiAqIEBleHRlbmRzIE5lby5jb2xsZWN0aW9uLkJhc2VcbiAqL1xuY2xhc3MgU3RvcmUgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGF0YS5TdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhdGEuU3RvcmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc3RvcmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc3RvcmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGVhZCBvZiBzZXR0aW5nIGFuIHVybCwgeW91IGNhbiBkZWZpbmUgdGhlIFJQQyBCRSBBUEkgbWV0aG9kcy5cbiAgICAgICAgICogSW4gY2FzZSB0aGUgNCBtZXRob2RzIGFyZSB1c2luZyB0aGUgc2FtZSBzZXJ2aWNlIGFuZCB0aGlzIHNlcnZpY2UgaXMgdXNpbmcgdGhlIENSVUQgYmFzZWQgZm4tbmFtZXMsXG4gICAgICAgICAqIHlvdSBjYW4gc3dpdGNoIHRvIGEgc3RyaW5nIGJhc2VkIHNob3J0Y3V0LlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIDIgZXhhbXBsZXMgYXJlIGVxdWl2YWxlbnQuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFwaToge1xuICAgICAgICAgKiAgICBjcmVhdGUgOiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZS5jcmVhdGUnLFxuICAgICAgICAgKiAgICBkZXN0cm95OiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZS5kZXN0cm95JyxcbiAgICAgICAgICogICAgcmVhZCAgIDogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UucmVhZCcsXG4gICAgICAgICAqICAgIHVwZGF0ZSA6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLnVwZGF0ZSdcbiAgICAgICAgICogfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBhcGk6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlJ1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8U3RyaW5nfG51bGx9IGFwaV89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYXBpXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Mb2FkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTG9hZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRQYWdlXz0xXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50UGFnZV86IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBkYXRhXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGluaXRpYWxEYXRhXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsRGF0YV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0dyb3VwZWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzR3JvdXBlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0xvYWRlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNMb2FkZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNMb2FkaW5nPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgYSB2YWx1ZSBvZiAwIHRvIG5vdCBsaW1pdCB0aGUgcGFnZVNpemVcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBwYWdlU2l6ZV89MFxuICAgICAgICAgKi9cbiAgICAgICAgcGFnZVNpemVfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBsZXQgdGhlIGJhY2tlbmQgaGFuZGxlIHRoZSBmaWx0ZXJpbmcuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgYnVmZmVyZWQgc3RvcmVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW90ZUZpbHRlcj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlRmlsdGVyOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gbGV0IHRoZSBiYWNrZW5kIGhhbmRsZSB0aGUgc29ydGluZy5cbiAgICAgICAgICogVXNlZnVsIGZvciBidWZmZXJlZCBzdG9yZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3RlU29ydD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlU29ydDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBwYXRoIHRvIHRoZSByb290IG9mIHlvdXIgZGF0YS5cbiAgICAgICAgICogSWYgdGhlIHJlc3BvbnNlUm9vdCBpcyAnZGF0YScgdGhpcyBpcyBvcHRpb25hbC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZXNwb25zZVJvb3Q9J2RhdGEnXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zZVJvb3Q6ICdkYXRhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdG90YWxDb3VudD0wXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbENvdW50OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXJsIGZvciBBamF4IHJlcXVlc3RzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB1cmw9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdXJsOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvXG4gICAgICAgIG1lLm9uKHtcbiAgICAgICAgICAgIG11dGF0ZTogbWUub25Db2xsZWN0aW9uTXV0YXRlLFxuICAgICAgICAgICAgc29ydCAgOiBtZS5vbkNvbGxlY3Rpb25Tb3J0LFxuICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOiBhZGQoKSB0byBjb252ZXJ0IGl0ZW1zIGludG8gcmVjb3JkcyBpZiBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbSBUaGUgaXRlbShzKSB0byBhZGRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY29sbGVjdGlvbiBjb3VudFxuICAgICAqL1xuICAgIGFkZChpdGVtKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGQodGhpcy5iZWZvcmVTZXREYXRhKGl0ZW0pKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY3VycmVudFBhZ2UgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Q3VycmVudFBhZ2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMubG9hZCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuY29uZmlnc0FwcGxpZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5jbGVhcigpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaW5pdGlhbERhdGEgPSBbLi4udmFsdWVdXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuYWRkKHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgIG9sZFZhbHVlICYmIG1lLnJlbW90ZUZpbHRlciAmJiBtZS5sb2FkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbml0aWFsRGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2FmdGVyU2V0SW5pdGlhbERhdGEnLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLnN0b3JlSWQgPSB0aGlzLmlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHBhZ2VTaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhZ2VTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5sb2FkKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFNvcnRlcnModmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5yZW1vdGVTb3J0ICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgYmVmb3JlU2V0QXBpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGUgOiB2YWx1ZSArICcuY3JlYXRlJyxcbiAgICAgICAgICAgICAgICBkZXN0cm95OiB2YWx1ZSArICcuZGVzdHJveScsXG4gICAgICAgICAgICAgICAgcmVhZCAgIDogdmFsdWUgKyAnLnJlYWQnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZSA6IHZhbHVlICsgJy51cGRhdGUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYmVmb3JlU2V0RGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGl0ZW07XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbaV1cblxuICAgICAgICAgICAgICAgIGlmICghUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRJbml0aWFsRGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfE9iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfE9iamVjdH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge05lby5kYXRhLk1vZGVsfVxuICAgICAqL1xuICAgIGJlZm9yZVNldE1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZT8uZGVzdHJveSgpO1xuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIE1vZGVsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjcmVhdGVSZWNvcmQoY29uZmlnKSB7XG4gICAgICAgIFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEtleVByb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlQcm9wZXJ0eSB8fCB0aGlzLm1vZGVsLmtleVByb3BlcnR5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuaGVhZGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLm1ldGhvZCBERUxFVEUsIEdFVCwgUE9TVCwgUFVUXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucmVzcG9uc2VUeXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy51cmxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbG9hZChvcHRzPXt9KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcGFyYW1zID0ge3BhZ2U6IG1lLmN1cnJlbnRQYWdlLCBwYWdlU2l6ZTogbWUucGFnZVNpemUsIC4uLm9wdHMucGFyYW1zfTtcblxuICAgICAgICBpZiAobWUucmVtb3RlRmlsdGVyKSB7XG4gICAgICAgICAgICBwYXJhbXMuZmlsdGVycyA9IG1lLmV4cG9ydEZpbHRlcnMoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLnJlbW90ZVNvcnQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zb3J0ZXJzID0gbWUuZXhwb3J0U29ydGVycygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuYXBpKSB7XG4gICAgICAgICAgICBsZXQgYXBpQXJyYXkgPSBtZS5hcGkucmVhZC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGZuICAgICAgID0gYXBpQXJyYXkucG9wKCksXG4gICAgICAgICAgICAgICAgc2VydmljZSAgPSBOZW8ubnMoYXBpQXJyYXkuam9pbignLicpKTtcblxuICAgICAgICAgICAgaWYgKCFzZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FwaSBpcyBub3QgZGVmaW5lZCcsIHRoaXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcnZpY2VbZm5dKHBhcmFtcykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gTmVvLm5zKG1lLnJlc3BvbnNlUm9vdCwgZmFsc2UsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUudG90YWxDb3VudCA9IHJlc3BvbnNlLnRvdGFsQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5kYXRhICAgICAgID0gTmVvLm5zKG1lLnJlc3BvbnNlUm9vdCwgZmFsc2UsIHJlc3BvbnNlKTsgLy8gZmlyZXMgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRzLnVybCA/Pz0gbWUudXJsO1xuXG4gICAgICAgICAgICBOZW8uWGhyLnByb21pc2VKc29uKG9wdHMpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGZvciBOZW8uWGhyLnJlcXVlc3QnLCBlcnIsIG1lLmlkKVxuICAgICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBtZS5kYXRhID0gTmVvLm5zKG1lLnJlc3BvbnNlUm9vdCwgZmFsc2UsIGRhdGEuanNvbikgfHwgZGF0YS5qc29uXG4gICAgICAgICAgICAgICAgLy8gd2UgZG8gbm90IG5lZWQgdG8gZmlyZSBhIGxvYWQgZXZlbnQgPT4gb25Db2xsZWN0aW9uTXV0YXRlKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIG9uQ29sbGVjdGlvbk11dGF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnb25Db2xsZWN0aW9uTXV0YXRlJywgb3B0cyk7XG4gICAgICAgICAgICBtZS5maXJlKCdsb2FkJywgbWUuaXRlbXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiBhZGQgd2lsbCBmaXJlIG11dGF0ZSBhbmQgc29ydCByaWdodCBhZnRlciBhbm90aGVyXG4gICAgICovXG4gICAgb25Db2xsZWN0aW9uU29ydCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuY29uZmlnc0FwcGxpZWQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdvbkNvbGxlY3Rpb25Tb3J0JywgbWUuY29sbGVjdGlvbi5pdGVtcyk7XG4gICAgICAgICAgICAvLyBtZS5maXJlKCdsb2FkJywgbWUuaXRlbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuZGF0YSkge1xuICAgICAgICAgICAgbWUuYWZ0ZXJTZXREYXRhKG1lLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmF1dG9Mb2FkKSB7XG4gICAgICAgICAgICBtZS50aW1lb3V0KDEwMCkudGhlbigoKSA9PiB7IC8vIHRvZG9cbiAgICAgICAgICAgICAgICBtZS5sb2FkKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZpbHRlckNoYW5nZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnJlbW90ZUZpbHRlcikge1xuICAgICAgICAgICAgbWUuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgbWUubG9hZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5vbkZpbHRlckNoYW5nZShvcHRzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgY2hhbmdpbmcgdGhlIHZhbHVlIG9mIGEgcmVjb3JkIGZpZWxkLlxuICAgICAqIEUuZy4gbXlSZWNvcmQuZm9vID0gJ2Jhcic7XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbCBUaGUgbW9kZWwgaW5zdGFuY2Ugb2YgdGhlIGNoYW5nZWQgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICovXG4gICAgb25SZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3JlY29yZENoYW5nZScsIHtcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleE9mKGRhdGEucmVjb3JkKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzPXt9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucHJvcGVydHlcbiAgICAgKi9cbiAgICBzb3J0KG9wdHM9e30pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgaWYgKG1lLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBtZS5zb3J0ZXJzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBvcHRzLmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgOiBvcHRzLnByb3BlcnR5XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZS5yZW1vdGVTb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnN0YXJ0VXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNsZWFyKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5zb3J0ZXJzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1lLnJlbW90ZVNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWRkKFsuLi5tZS5pbml0aWFsRGF0YV0pO1xuICAgICAgICAgICAgICAgICAgICBtZS5lbmRVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuZmlyZSgnc29ydCcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdG9yZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=