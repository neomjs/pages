export const __webpack_esm_id__ = "vendors-src_data_Store_mjs";
export const __webpack_esm_ids__ = ["vendors-src_data_Store_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/data/Model.mjs"
/*!****************************!*\
  !*** ./src/data/Model.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");




/**
 * @class Neo.data.Model
 * @extends Neo.core.Base
 *
 * @summary Defines the schema and data processing logic for records in a Store.
 *
 * Models define the `fields` array, which maps raw data keys to canonical field names, handles
 * data conversion, and defines computed values.
 *
 * ### Calculated Fields & Dependencies
 *
 * Fields can dynamically compute their values using a `calculate` function. 
 * If a calculated field relies on other calculated fields, you **MUST** declare them in the `depends` array.
 *
 * This is critical for performance when the Store operates in "Turbo Mode" (`autoInitRecords: false`).
 * In Turbo Mode, the Store performs "Soft Hydration" on raw JSON objects. Declaring `depends` ensures
 * the Store recursively resolves and caches the dependencies before executing your calculate function,
 * preventing massive performance bottlenecks (like redundant array reductions).
 *
 * @example
 * fields: [{
 *     name: 'total',
 *     type: 'Integer',
 *     calculate: data => data.a + data.b
 * }, {
 *     name: 'ratio',
 *     type: 'Float',
 *     depends: ['total'], // Crucial for Turbo Mode performance!
 *     calculate: data => data.total === 0 ? 0 : data.a / data.total
 * }]
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.Model'
         * @protected
         */
        className: 'Neo.data.Model',
        /**
         * @member {String} ntype='model'
         * @protected
         */
        ntype: 'model',
        /**
         * @member {Object[]|null} fields_
         * @reactive
         */
        fields_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__.isDescriptor]: true,
            merge         : 'deepArrays',
            value         : null
        },
        /**
         * @member {String} keyProperty_='id'
         * @reactive
         */
        keyProperty_: 'id',
        /**
         * @member {String|null} storeId=null
         * @protected
         */
        storeId: null,
        /**
         * Set this config to true in case you want to track modified fields.
         * Be aware that this will double the amount of data inside each record,
         * since each field will get an original value flag.
         * @member {Boolean} trackModifiedFields=false
         */
        trackModifiedFields: false
    }

    /**
     * Internally storing all fields, which have a calculate property
     * @member {Map} calculatedFieldsMap=new Map()
     * @protected
     */
    calculatedFieldsMap = new Map()
    /**
     * Internally storing all fields inside a flat map => nested fields included
     * @member {Map} fieldsMap=new Map()
     * @protected
     */
    fieldsMap = new Map()
    /**
     * @member {Boolean} hasComplexFields=false
     * @protected
     */
    hasComplexFields = false
    /**
     * @member {Boolean} hasNestedFields=false
     * @protected
     */
    hasNestedFields = false

    /**
     Triggered after the fields config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetFields(value, oldValue) {
        if (value) {
            let me = this;

            me.updateFieldsMap(value);

            // Fields can get changed multiple times before the model instance is getting constructed.
            // We only need the latest state before construction & honor run-time changes.
            if (me.isConstructed) {
                _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createRecordClass(me, true)
            }
        }
    }

    /**
     * Finds a field config by a given field name
     * @param {String} name
     * @returns {Object|null} The field config object or null if no match was found
     */
    getField(name) {
        return this.fieldsMap.get(name) || null
    }

    /**
     * Finds a field type by a given field name
     * @param {String} name
     * @returns {String|null} The lowercase field type or null if no match was found
     */
    getFieldType(name) {
        return this.getField(name)?.type?.toLowerCase() || null
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            fields             : me.serializeConfig(me.fields),
            keyProperty        : me.keyProperty,
            storeId            : me.storeId,
            trackModifiedFields: me.trackModifiedFields
        }
    }

    /**
     * @param {Object[]} fields
     * @param {Boolean} isRoot=true
     * @param {String} path=''
     */
    updateFieldsMap(fields, isRoot=true, path='') {
        let me = this,
            {calculatedFieldsMap, fieldsMap} = me,
            fieldName;

        if (isRoot) {
            calculatedFieldsMap.clear();
            fieldsMap.clear();
            me.hasComplexFields = false; // Reset flag
            me.hasNestedFields  = false
        }

        fields.forEach(field => {
            fieldName = path + field.name

            if (field.fields) {
                me.hasNestedFields = true;
                me.updateFieldsMap(field.fields, false, field.name + '.')
            } else {
                fieldsMap.set(fieldName, field);

                if (field.calculate) {
                    calculatedFieldsMap.set(fieldName, field)
                }

                // Check for complex fields (Soft Hydration Optimization)
                if (field.calculate || field.convert || field.mapping) {
                    me.hasComplexFields = true
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/data/RecordFactory.mjs"
/*!************************************!*\
  !*** ./src/data/RecordFactory.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");




const
    dataSymbol         = Symbol.for('data'),
    initialIndexSymbol = Symbol.for('initialIndex'),
    isModifiedSymbol   = Symbol.for('isModified'),
    originalDataSymbol = Symbol.for('originalData'),
    versionSymbol      = Symbol.for('version');

let instance;

/**
 * @class Neo.data.RecordFactory
 * @extends Neo.core.Base
 * @singleton
 */
class RecordFactory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.RecordFactory'
         * @protected
         */
        className: 'Neo.data.RecordFactory',
        /**
         * @member {String} recordNamespace='Neo.data.record'
         */
        recordNamespace: 'Neo.data.record',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Assigns model-based default values to a data object
     * @param {Object}         data
     * @param {Neo.data.Model} model
     * @returns {Object}
     */
    assignDefaultValues(data, model) {
        model.fieldsMap.forEach((field, fieldName) => {
            if (field.virtual) return;

            if (field.mapping && !Object.hasOwn(data, fieldName)) {
                let ns  = field.mapping.split('.'),
                    key = ns.pop(),
                    source;

                if (ns.length > 0) {
                    source = Neo.ns(ns, false, data)
                } else {
                    source = data
                }

                if (source && Object.hasOwn(source, key)) {
                    data[fieldName] = source[key]
                }
            }

            if (Object.hasOwn(field, 'defaultValue')) {
                const defaultValue = Neo.isFunction(field.defaultValue) ? field.defaultValue() : field.defaultValue;

                // We could always use Neo.assignToNs() => the check is just for improving the performance
                if (model.hasNestedFields) {
                    Neo.assignToNs(fieldName, defaultValue, data, false)
                } else if (data[fieldName] === undefined) {
                    data[fieldName] = defaultValue
                }
            }
        });

        return data
    }

    /**
     * @param {Object} data
     * @param {Object} data.field
     * @param {Neo.data.Model} data.model
     * @param {String} data.path=''
     * @param {Object} data.proto
     */
    createField({field, model, path='', proto}) {
        let fieldName = field.name,
            fieldPath = path === '' ? fieldName : `${path}.${fieldName}`,
            properties;

        if (field.fields) {
            field.fields.forEach(childField => {
                this.createField({field: childField, model, path: fieldPath, proto})
            })
        } else {
            if (field.virtual) {
                properties = {
                    [fieldPath]: {
                        configurable: true,
                        enumerable  : true,
                        get() {
                            return field.calculate(this[dataSymbol], this)
                        }
                    }
                }
            } else {
                properties = {
                    [fieldPath]: {
                        configurable: true,
                        enumerable  : true,
                        get() {
                            if (model.hasNestedFields) {
                                return Neo.ns(fieldPath, false, this[dataSymbol])
                            }

                            return this[dataSymbol][fieldName]
                        },
                        set(value) {
                            this.notifyChange({
                                fields: {[fieldPath]: instance.parseRecordValue({record: this, field, value})},
                                model,
                                record: this
                            })
                        }
                    }
                }
            }

            Object.defineProperties(proto, properties)
        }
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Object} config
     * @returns {Object}
     */
    createRecord(model, config) {
        let recordClass = Neo.ns(`${this.recordNamespace}.${model.className}.${model.id}`);

        if (!recordClass) {
            recordClass = this.createRecordClass(model)
        }

        return new recordClass(config)
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Boolean} overwrite=false
     * @returns {Object}
     */
    createRecordClass(model, overwrite=false) {
        if (model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]) {
            let className = `${this.recordNamespace}.${model.className}.${model.id}`,
                ns        = Neo.ns(className),
                key, nsArray, cls;

            if (!ns || overwrite) {
                nsArray = className.split('.');
                key     = nsArray.pop();
                ns      = Neo.ns(nsArray, true);
                cls     = ns[key] = class Record {
                    // We do not want to minify the ctor class name in dist/production
                    static name = 'Record';

                    [dataSymbol]         = {};
                    [initialIndexSymbol] = null;
                    /**
                     * The current version of the record. Increments on every modification.
                     * Used for change tracking and optimization (e.g. short-circuiting grid rendering).
                     * @member {Number} [versionSymbol]=0
                     */
                    [versionSymbol] = 0;

                    /**
                     * The stable, globally unique internal ID for this record instance.
                     * @member {String} internalId
                     */
                    [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId] = Neo.getId('record');

                    get isModified() {
                        let me = this;

                        if (model.trackModifiedFields) {
                            return !Neo.isEqual(me[dataSymbol], me[originalDataSymbol])
                        }

                        return me[isModifiedSymbol]
                    }

                    /**
                     * Returns the current version of the record.
                     * @returns {Number}
                     */
                    get version() {
                        return this[versionSymbol]
                    }

                    /**
                     * @param {Object} config
                     */
                    constructor(config) {
                        let me = this;

                        if (Object.hasOwn(config, initialIndexSymbol)) {
                            me[initialIndexSymbol] = config[initialIndexSymbol];
                            delete config[initialIndexSymbol]
                        }

                        config = instance.assignDefaultValues(config, model);

                        if (model.trackModifiedFields) {
                            me[originalDataSymbol] = {};
                            me.setOriginal(config)
                        } else {
                            me[isModifiedSymbol] = false
                        }

                        me.setSilent(config) // We do not want to fire change events when constructing
                    }

                    /**
                     * @param {String} field
                     * @returns {*}
                     */
                    get(field) {
                        if (model.getField(field)) {
                            return this[field]
                        }

                        if (field.includes('.')) {
                            return Neo.ns(field, false, this[dataSymbol])
                        }

                        return this[dataSymbol][field]
                    }

                    /**
                     * @param {String} fieldName
                     * @returns {Boolean|null} null in case the model does not use trackModifiedFields, true in case a change was found
                     */
                    isModifiedField(fieldName) {
                        let me = this;

                        if (model.trackModifiedFields) {
                            let dataScope, originalDataScope;

                            if (model.hasNestedFields && fieldName?.includes('.')) {
                                let nsArray = fieldName.split('.');

                                fieldName         = nsArray.pop();
                                dataScope         = Neo.ns(nsArray, false, me[dataSymbol]);
                                originalDataScope = Neo.ns(nsArray, false, me[originalDataSymbol])
                            } else {
                                dataScope         = me[dataSymbol];
                                originalDataScope = me[originalDataSymbol]
                            }

                            // Check if the field exists
                            if (
                                !model.getField(fieldName) &&        // Check for leaf fields (could be excluded inside the real data)
                                !Object.hasOwn(dataScope, fieldName) // Check the data tree
                            ) {
                                console.error('The record does not contain the field', fieldName, me)
                            }

                            return !Neo.isEqual(dataScope[fieldName], originalDataScope[fieldName])
                        }

                        return null
                    }

                    /**
                     * The single source of truth for record field changes.
                     * Executes instance.setRecordFields(), and can get used via:
                     * - Neo.util.Function:createSequence()
                     * - Neo.util.Function:intercept(),
                     * to "listen" to field changes
                     * @param {Object}         data
                     * @param {Object}         data.fields
                     * @param {Neo.data.Model} data.model
                     * @param {Object}         data.record
                     * @param {Boolean}        silent=false
                     * @returns {Object}
                     */
                    notifyChange(data, silent=false) {
                        const param = {...data, silent}
                        instance.setRecordFields(param);
                        return param
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    reset(fields) {
                        this.setOriginal(fields);
                        this.set(fields)
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    set(fields) {
                        this.notifyChange({fields, model, record: this})
                    }

                    /**
                     * If the model uses trackModifiedFields, we will store the original data
                     * for tracking the dirty state (changed fields)
                     * @param {Object} fields
                     * @protected
                     */
                    setOriginal(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true, useOriginalData: true})
                    }

                    /**
                     * Bulk-update multiple record fields at once without triggering a change event
                     * @param {Object} fields
                     */
                    setSilent(fields) {
                        this.notifyChange({fields, model, record: this}, true)
                    }

                    /**
                     * When using JSON.stringify(this), we want to get the raw data
                     * @returns {Object}
                     */
                    toJSON() {
                        return structuredClone(this[dataSymbol])
                    }
                };

                if (Array.isArray(model.fields)) {
                    model.fields.forEach(field => {
                        instance.createField({field, model, proto: cls.prototype})
                    })
                }

                Object.defineProperty(cls.prototype, 'isRecord', {value: true});
                Object.defineProperty(cls, 'isClass', {value: true});

                return ns[key]
            }

            return ns
        }
    }

    /**
     * Tests if a given object is an instance of a class created by this factory
     * @param {Object} record
     * @returns {Boolean}
     */
    isRecord(record) {
        return record?.isRecord || false
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onRecordChange(opts) {
        Neo.get(opts.model.storeId)?.onRecordChange(opts)
    }

    /**
     * @param {Object}  data
     * @param {Object}  data.record
     * @param {Object}  data.field
     * @param {*}       [data.value=null]
     * @param {Object}  [data.recordConfig=null]
     * @param {Boolean} [data.useOriginalData=false]
     * @returns {*}
     */
    parseRecordValue({record, field, value=null, recordConfig=null, useOriginalData=false}) {
        if (field.calculate) {
            return field.calculate(record[useOriginalData ? originalDataSymbol : dataSymbol], field)
        }

        if (field.convert) {
            value = field.convert(value, record)
        }

        let fieldName = field.name,
            {mapping, maxLength, minLength, nullable} = field,
            oldValue  = recordConfig?.[fieldName] || record[fieldName],
            type      = field.type?.toLowerCase();

        // only trigger mappings for initial values
        // dynamic changes of a field will not pass the recordConfig
        if (mapping && recordConfig) {
            let ns  = mapping.split('.'),
                key = ns.pop();

            ns    = Neo.ns(ns, true, recordConfig);
            value = ns[key]
        }

        if (Object.hasOwn(field, 'maxLength')) {
            if (value?.toString().length > maxLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with maxLength: ${maxLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'minLength')) {
            if (value?.toString().length < minLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with minLength: ${minLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'nullable')) {
            if (nullable === false && value === null) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with nullable: ${nullable}`);
                return oldValue
            }
        }

        if (type === 'date' && Neo.typeOf(value) !== 'Date') {
            return new Date(value)
        }

        else if (type === 'float' && value) {
            value = parseFloat(value)
        }

        else if (type === 'html' && value) {
            value = value + ''
        }

        else if ((type === 'int' || type === 'integer') && value) {
            value = parseInt(value)
        }

        else if (type === 'string' && value) {
            value = value + '';
            value =  value.replace(/(<([^>]+)>)/ig, '')
        }

        return value
    }

    /**
     * @param {Object}         data
     * @param {String}         data.fieldName
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     * @param {*}              data.value
     * @protected
     */
    setRecordData({fieldName, model, record, useOriginalData=false, value}) {
        if (useOriginalData && !model.trackModifiedFields) {
            return
        }

        let scope = useOriginalData ? originalDataSymbol : dataSymbol;

        if (model.hasNestedFields && fieldName.includes('.')) {
            let ns, nsArray;

            nsArray   = fieldName.split('.');
            fieldName = nsArray.pop();
            ns        = Neo.ns(nsArray, true, record[scope]);

            ns[fieldName] = value
        } else {
            record[scope][fieldName] = value
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.changedFields=[] Internal flag
     * @param {Object}         data.fields
     * @param {Neo.data.Model} data.model
     * @param {Object}         data.record
     * @param {Boolean}        data.silent=false
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     */
    setRecordFields({changedFields=[], fields, model, record, silent=false, useOriginalData=false}) {
        let me = this,
            {calculatedFieldsMap, fieldsMap, trackModifiedFields} = model,
            fieldExists, hasChangedFields, oldValue;

        if (!trackModifiedFields && useOriginalData) {
            return
        }

        Object.entries(fields).forEach(([key, value]) => {
            fieldExists = fieldsMap.has(key);

            if (Neo.isObject(value) && !fieldExists) {
                Object.entries(value).forEach(([childKey, childValue]) => {
                    me.setRecordFields({
                        changedFields,
                        fields: {[`${key}.${childKey}`]: childValue},
                        model,
                        record,
                        silent: true,
                        useOriginalData
                    })
                })
            } else if (fieldExists) {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), value});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    if (!trackModifiedFields && !useOriginalData) {
                        record[isModifiedSymbol] = true
                    }

                    changedFields.push({name: key, oldValue, value})
                }
            }
        });

        hasChangedFields = Object.keys(changedFields).length > 0;

        if (hasChangedFields) {
            record[versionSymbol]++;

            calculatedFieldsMap.forEach((value, key) => {
                if (value.virtual) return;

                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), useOriginalData});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    changedFields.push({name: key, oldValue, value})
                }
            })
        }

        if (!silent && !useOriginalData && hasChangedFields) {
            me.onRecordChange({fields: changedFields, model, record})
        }
    }
}

instance = Neo.setupClass(RecordFactory);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ },

/***/ "./src/data/Store.mjs"
/*!****************************!*\
  !*** ./src/data/Store.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");
/* harmony import */ var _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../manager/Store.mjs */ "./src/manager/Store.mjs");








const initialIndexSymbol = Symbol.for('initialIndex');

/**
 * @class Neo.data.Store
 * @extends Neo.collection.Base
 * @mixes Neo.core.Observable
 *
 * @summary A powerful, observable collection that manages a set of data records.
 *
 * Neo.data.Store is the central data management class in the framework. It handles the lifecycle of
 * data records, including loading, filtering, sorting, and synchronization with backend APIs.
 *
 * ### Record Instantiation Strategies: Eager vs. Lazy ("Turbo Mode")
 *
 * The Store supports two distinct strategies for handling record creation, controlled by the `autoInitRecords` config
 * (which defaults to `true`) and the `init` parameter in methods like `add()` and `insert()`.
 *
 * **1. Eager Instantiation (Default: `autoInitRecords: true`)**
 *    - **Behavior**: Raw data objects are immediately converted into `Neo.data.Model` instances.
 *    - **Use Case**: Standard operations, adding single items, interactive edits.
 *    - **Pros**: Returns usable Record instances immediately. High Developer Experience (DX).
 *    - **Cons**: Can be slow for massive datasets (10k+ records).
 *
 * **2. Lazy Instantiation ("Turbo Mode")**
 *    - **Behavior**: Raw data objects are stored directly. `Neo.data.Model` instances are created
 *      "just-in-time" only when they are accessed via `get()`, `getAt()`, or iteration.
 *    - **Use Case**: Bulk loading large datasets (e.g., grids, charts with thousands of points).
 *    - **Pros**: Massive performance gains for initial data load. Enables internal "chunking" to prevent UI freezes.
 *    - **Cons**: `add()` returns a count instead of records. Records are not available until accessed.
 *    - **How to enable**:
 *      - **Global**: Set `autoInitRecords: false` on the Store config.
 *      - **Per-call**: Pass `false` as the second argument to `add()` or `insert()`.
 *      ```javascript
 *      // Global setting
 *      Neo.create(Store, {
 *          autoInitRecords: false,
 *          data: hugeArrayOfData
 *      });
 *
 *      // Per-call override
 *      store.add(hugeArrayOfData, false);
 *      ```
 *
 * ### Soft Hydration & Field Dependencies
 *
 * When operating in Turbo Mode (`autoInitRecords: false`), the Store sorts and filters using raw JSON objects.
 * If a sort or filter operation requires a calculated field that isn't present on the raw object, the Store
 * performs **Soft Hydration** via `resolveField()`. It dynamically calculates the field value and auto-caches
 * it on the raw object.
 *
 * If a calculated field relies on other calculated fields, the Model definition must declare a `depends: []` array.
 * The Store uses this array to recursively resolve and cache all dependencies before executing the main calculation,
 * preventing severe performance bottlenecks (like redundant array reductions).
 *
 * ### Progressive Loading (Streaming)
 *
 * When using a `proxy` (e.g., {@link Neo.data.proxy.Stream}), the Store supports **Progressive Loading**.
 * Instead of waiting for the entire dataset to load, the Store updates itself incrementally as chunks of data arrive.
 *
 * - **Events:** The `load` event fires multiple times (once per chunk) with the cumulative `total`.
 * - **UI Integration:** Components like `Neo.grid.Container` listen to these events to update their scrollbars and render rows immediately.
 */
class Store extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.Store'
         * @protected
         */
        className: 'Neo.data.Store',
        /**
         * @member {String} ntype='store'
         * @protected
         */
        ntype: 'store',
        /**
         * Instead of setting an url, you can define the RPC BE API methods.
         * In case the 4 methods are using the same service and this service is using the CRUD based fn-names,
         * you can switch to a string based shortcut.
         * The following 2 examples are equivalent.
         * @example
         * api: {
         *    create : 'MyApp.backend.UserService.create',
         *    destroy: 'MyApp.backend.UserService.destroy',
         *    read   : 'MyApp.backend.UserService.read',
         *    update : 'MyApp.backend.UserService.update'
         * }
         * @example
         * api: 'MyApp.backend.UserService'
         * @member {Object|String|null} api_=null
         * @reactive
         */
        api_: null,
        /**
         * True to automatically create record instances when adding items.
         * Set to false to enable "Turbo Mode" (Lazy Instantiation) globally for this store.
         * @member {Boolean} autoInitRecords=true
         */
        autoInitRecords: true,
        /**
         * @member {Boolean} autoLoad=false
         */
        autoLoad: false,
        /**
         * @member {Number} currentPage_=1
         * @reactive
         */
        currentPage_: 1,
        /**
         * @member {Array|null} data_=null
         * @reactive
         */
        data_: null,
        /**
         * The initial chunk size for adding large datasets. Set to 0 to disable chunking.
         * @member {Number} initialChunkSize=0
         */
        initialChunkSize: 0,
        /**
         * @member {Boolean} isGrouped=false
         */
        isGrouped: false,
        /**
         * @member {Boolean} isLoaded=false
         */
        isLoaded: false,
        /**
         * @member {Boolean} isLoading=false
         */
        isLoading: false,
        /**
         * @member {Neo.data.Model} model_=null
         * @reactive
         */
        model_: null,
        /**
         * Use a value of 0 to not limit the pageSize
         * @member {Number} pageSize_=0
         * @reactive
         */
        pageSize_: 0,
        /**
         * @member {Object|Neo.data.proxy.Base|null} proxy_=null
         * @reactive
         */
        proxy_: null,
        /**
         * True to let the backend handle the filtering.
         * Useful for buffered stores
         * @member {Boolean} remoteFilter=false
         */
        remoteFilter: false,
        /**
         * True to let the backend handle the sorting.
         * Useful for buffered stores
         * @member {Boolean} remoteSort=false
         */
        remoteSort: false,
        /**
         * Add a path to the root of your data.
         * If the responseRoot is 'data' this is optional.
         * @member {String} responseRoot='data'
         */
        responseRoot: 'data',
        /**
         * @member {Number} totalCount=0
         */
        totalCount: 0,
        /**
         * True to track internalIds in a separate map for O(1) lookup
         * @member {Boolean} trackInternalId=true
         */
        trackInternalId: true,
        /**
         * Url for Ajax requests
         * @member {String|null} url=null
         */
        url: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        config = config || {};
        config.itemFactory = this.assignInternalId.bind(this);

        super.construct(config);

        let me = this;

        // todo
        me.on({
            mutate: me.onCollectionMutate,
            sort  : me.onCollectionSort,
            scope : me
        });

        _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].register(me)
    }

    /**
     *
     */
    destroy() {
        _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].unregister(this);

        super.destroy()
    }

    /**
     * Identity Provider Hook.
     * Assigns a stable, globally unique 'internalId' to items (Records or Raw Objects).
     * This ensures DOM stability and security by decoupling the DOM ID from the data ID.
     * @param {Object} item
     */
    assignInternalId(item) {
        if (!item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId]) {
            item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId] = Neo.getId('record')
        }
    }

    /**
     * Aborts the current proxy operation if the proxy supports it.
     */
    abort() {
        this.proxy?.abort?.()
    }

    /**
     * Overrides collection.Base: add() to convert items into records if needed.
     *
     * **1. Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **2. Lazy Mode (`init=false`):**
     * Adds raw data directly for maximum performance. Instantiates records only on access.
     *
     * - **Chunking Active**: If `initialChunkSize > 0` and `items.length > threshold`:
     *   Adds items in chunks to prevent blocking the App Worker (Main Actor).
     *   Returns the new collection `count` (Number).
     *
     * - **No Chunking**: If `initialChunkSize === 0` or `items.length <= threshold`:
     *   Adds raw items directly.
     *   Returns an `Array` of the added raw data objects.
     *
     * @example
     * // 1. Default: Get records immediately
     * const [newRecord] = store.add({name: 'New Item'});
     *
     * @example
     * // 2. Turbo Mode (No Chunking): Get raw objects
     * const [rawObject] = store.add({name: 'Item'}, false);
     *
     * @example
     * // 3. Turbo Mode (Chunking): Get new count
     * store.initialChunkSize = 1000;
     * const newCount = store.add(hugeDataArray, false);
     *
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records, false for "Turbo Mode"
     * @returns {Number|Object[]|Neo.data.Model[]} The collection count, raw items, or created records
     */
    add(item, init=this.autoInitRecords) {
        let me        = this,
            items     = Array.isArray(item) ? item : [item],
            threshold = me.initialChunkSize;

        if (init) {
            super.add(items);

            me.isLoaded = true;

            return items.map(i => me.get(me.getKey(i)))
        }

        if (threshold > 0 && items.length > threshold) {
            const total = me.count + items.length,
                  chunk = items.splice(0, threshold);

            me.chunkingTotal = total;

            // 1. Add the first chunk. This fires 'mutate' -> 'load' (via onCollectionMutate)
            //    and triggers the initial grid render. The 'load' event will contain the final total count.
            super.add(chunk); // Pass raw chunk directly

            // 2. Suspend events to prevent the next 'add' from firing 'load'.
            me.suspendEvents = true;

            // 3. Add the rest of the items silently.
            super.add(items); // Pass raw items directly

            // 4. Resume events.
            me.suspendEvents = false;

            // 5. Manually fire a final 'load' event to update the grid's scrollbar and notify other listeners.
            me.fire('load', {items: me.items, postChunkLoad: true, total: me.chunkingTotal});

            delete me.chunkingTotal;

            return me.count
        }

        const returnValue = super.add(items);

        // If we use add() initially instead of setting `data`, we need to set the loaded flag here.
        me.isLoaded = true;

        return returnValue // Pass raw item directly
    }

    /**
     * Triggered after the currentPage config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCurrentPage(value, oldValue) {
        oldValue && this.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        let me = this;

        if (me.configsApplied) {
            if (value) {
                if (oldValue) {
                    me.clear()
                }

                me.isLoading = false;

                me.add(value, me.autoInitRecords)
            }
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        super.afterSetFilters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteFilter && me.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetModel(value, oldValue) {
        if (value) {
            value.storeId = this.id
        }
    }

    /**
     * Triggered after the pageSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPageSize(value, oldValue) {
        if (oldValue) {
            this._currentPage = 1; // silent update
            this.load()
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        super.afterSetSorters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteSort && me.load()
    }

    /**
     * @param {Object|String|null} value
     * @param {Object|String|null} oldValue
     * @protected
     * @returns {Object|null}
     */
    beforeSetApi(value, oldValue) {
        if (Neo.typeOf(value) === 'String') {
            value = {
                create : value + '.create',
                destroy: value + '.destroy',
                read   : value + '.read',
                update : value + '.update'
            }
        }

        return value
    }

    /**
     * @param {Object|Neo.data.proxy.Base} value
     * @param {Object|Neo.data.proxy.Base} oldValue
     * @protected
     * @returns {Neo.data.proxy.Base}
     */
    beforeSetProxy(value, oldValue) {
        if (oldValue) {
            oldValue.destroy();
        }

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, null, {
            store: this
        });
    }

    /**
     * @param {Object[]|Neo.data.Model[]} value
     * @param {Object[]|Neo.data.Model[]} oldValue
     * @protected
     * @returns {Object[]|Neo.data.Model[]}
     */
    beforeSetData(value, oldValue) {
        if (value) {
            this.isLoading = true
        }

        return value
    }



    /**
     * @param {Neo.data.Model|Object} value
     * @param {Neo.data.Model|Object} oldValue
     * @protected
     * @returns {Neo.data.Model}
     */
    beforeSetModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _Model_mjs__WEBPACK_IMPORTED_MODULE_3__["default"])
    }

    /**
     * Overrides collection.Base to prevent the allItems collection from auto-loading
     * @param {Object} config
     * @returns {Neo.collection.Base}
     * @protected
     */
    createAllItems(config) {
        config.autoLoad = false;
        return super.createAllItems(config)
    }

    /**
     * Converts an object or array of objects into records
     * @param {Object|Object[]} config
     * @returns {Object|Object[]} Array in case an array was passed
     */
    createRecord(config) {
        let isArray = true;

        if (config) {
            if (!Array.isArray(config)) {
                isArray = false;
                config  = [config]
            }

            let me  = this,
                i   = 0,
                len = config.length,
                item;

            for (; i < len; i++) {
                item = config[i]

                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
                    config[i] = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].createRecord(me.model, item)
                }
            }
        }

        return isArray ? config : config[0]
    }

    /**
     * Overrides collection.Base:find() to ensure the returned item(s) are Record instances.
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]|null}
     */
    find(property, value, returnFirstMatch=false) {
        const result = super.find(property, value, returnFirstMatch);

        if (returnFirstMatch) {
            return result ? this.get(this.getKey(result)) : null;
        } else {
            return result.map(item => this.get(this.getKey(item)));
        }
    }

    /**
     * Overrides collection.Base:findBy() to ensure the returned item(s) are Record instances.
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.count The end index (up to, last value excluded)
     * @returns {Array}
     */
    findBy(fn, scope=this, start=0, end=this.count) {
        const result = super.findBy(fn, scope, start, end);
        return result.map(item => this.get(this.getKey(item)));
    }

    /**
     * Overrides collection.Base:forEach() to ensure the iterated item is a Record instance.
     * @param {Function} fn The function to execute for each record.
     * @param {Object} [scope] Value to use as `this` when executing `fn`.
     */
    forEach(fn, scope) {
        const me = this;
        for (let i = 0; i < me.count; i++) {
            fn.call(scope || me, me.getAt(i), i, me.items);
        }
    }

    /**
     * Overrides collection.Base:get() to ensure the returned item is a Record instance.
     * @param {Number|String} key
     * @returns {Object|null}
     */
    get(key) {
        let me   = this,
            item = super.get(key); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].createRecord(me.model, item);
            const index  = me.indexOf(item);
            const pk     = record[me.keyProperty]; // Use the actual PK from the record

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(pk, record);

            if (index !== -1) {
                me._items[index] = record
            }

            // If we are tracking internalIds, we need to update the map to point to the new record
            // instead of the raw object
            if (me.trackInternalId) {
                const internalKey = me.getInternalKey(record);
                if (internalKey) {
                    me.internalIdMap.set(internalKey, record)
                }
            }

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(pk, record);
                    me.allItems._items[masterIndex] = record;

                    if (me.allItems.trackInternalId) {
                        const internalKey = me.getInternalKey(record);
                        if (internalKey) {
                            me.allItems.internalIdMap.set(internalKey, record)
                        }
                    }
                }
            }
            return record
        }
        return item // Already a record or null
    }

    /**
     * Overrides collection.Base:getAt() to ensure the returned item is a Record instance.
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        let me   = this,
            item = super.getAt(index); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].createRecord(me.model, item);

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(record[me.keyProperty], record);
            me._items[index] = record;

            // If we are tracking internalIds, we need to update the map to point to the new record
            // instead of the raw object
            if (me.trackInternalId) {
                const internalKey = me.getInternalKey(record);
                if (internalKey) {
                    me.internalIdMap.set(internalKey, record)
                }
            }

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(record[me.keyProperty], record);
                    me.allItems._items[masterIndex] = record;

                    if (me.allItems.trackInternalId) {
                        const internalKey = me.getInternalKey(record);
                        if (internalKey) {
                            me.allItems.internalIdMap.set(internalKey, record)
                        }
                    }
                }
            }
            return record
        }
        return item // Already a record or undefined
    }

    /**
     * Retrieves the stable internal ID of an item.
     * @param {Object|Neo.data.Record} item
     * @returns {String} e.g. 'neo-record-1'
     */
    getInternalId(item) {
        if (!item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId]) {
            item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId] = Neo.getId('record')
        }

        return item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId]
    }

    /**
     * Hook to get the internal key of an item.
     * @param {Object} item
     * @returns {String|Number|null}
     */
    getInternalKey(item) {
        return item[_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_0__.internalId]
    }

    /**
     * @returns {String}
     */
    getKeyProperty() {
        return this.keyProperty || this.model.keyProperty
    }

    /**
     * Convenience shortcut to check for int based keyProperties
     * @returns {String|null} lowercase value of the model field type
     */
    getKeyType() {
        let me       = this,
            {model}  = me,
            keyField = model?.getField(me.getKeyProperty());

        return keyField?.type?.toLowerCase() || null
    }

    /**
     * Converts a data object into a Record instance or returns it if it is already one.
     * This method is called by add() and insert() when init=true (default).
     * @param {Object} data The data object or Record instance
     * @returns {Object} The Record instance
     */
    initRecord(data) {
        if (_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(data)) {
            return data
        }

        return this.get(this.getKey(data))
    }

    /**
     * Overrides collection.Base: insert() to convert items into records if needed.
     *
     * **Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **Lazy Mode (`init=false`):**
     * Inserts raw data directly. Instantiates records only on access.
     * Returns an `Array` of the inserted raw data objects.
     *
     * @param {Number} index The index to insert at
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records
     * @returns {Object[]|Neo.data.Model[]} The inserted raw items or created records
     */
    insert(index, item, init=this.autoInitRecords) {
        let me    = this,
            items = super.insert(index, item);

        if (init) {
            return items.map(i => me.get(me.getKey(i)))
        }

        return items
    }

    /**
     * @param {Object} opts={}
     * @param {Object} opts.data
     * @param {Object} opts.headers
     * @param {String} opts.method DELETE, GET, POST, PUT
     * @param {Object} opts.params
     * @param {String} opts.responseType
     * @param {Object} opts.scope
     * @param {String} opts.url
     * @returns {Promise<Object|Object[]>}
     * @protected
     */
    async load(opts={}) {
        let me     = this,
            params = {page: me.currentPage, pageSize: me.pageSize, ...opts.params};

        if (me.remoteFilter) {
            params.filters = me.exportFilters()
        }

        if (me.remoteSort) {
            params.sorters = me.exportSorters()
        }

        if (me.api) {
            let apiArray = me.api.read.split('.'),
                fn       = apiArray.pop(),
                service  = Neo.ns(apiArray.join('.'));

            if (!service) {
                console.error('Api is not defined', this)
            } else {
                const response = await me.trap(service[fn](params));

                if (response.success) {
                    me.totalCount = response.totalCount;
                    me.data       = Neo.ns(me.responseRoot, false, response); // fires the load event
                    me.isLoaded   = true;

                    return me.data
                }

                return null
            }
        } else if (me.proxy) {
            if (me.items.length > 0 && !opts.append) {
                me.clear();
            }

            me.isLoading = true;

            const onData = (data) => {
                me.add(data);

                // Progressive Rendering:
                // As soon as we have data, we want the grid to render.
                if (me.isLoading) {
                    me.isLoading = false
                }

                // We do not need to fire a load event here, since onCollectionMutate will handle this.
            };

            const onProgress = (data) => {
                me.fire('progress', data)
            };

            me.proxy.on({
                data    : onData,
                progress: onProgress
            });

            try {
                // params.url can override proxy url
                if (opts.url) {
                    params.url = opts.url;
                }

                const response = await me.proxy.read(params);

                me.proxy.un({
                    data    : onData,
                    progress: onProgress
                });

                if (response.success) {
                    me.totalCount = response.totalCount || me.count;
                    me.isLoaded   = true;
                    me.isLoading  = false; // Ensure it's false at the end
                    me.fire('load', {
                        isLoading    : false,
                        items        : me.items,
                        postChunkLoad: me.proxy?.ntype === 'proxy-stream',
                        total        : me.totalCount
                    });
                    return me.items
                } else {
                    me.isLoading = false;
                    return null
                }
            } catch (e) {
                me.proxy.un({
                    data    : onData,
                    progress: onProgress
                });
                me.isLoading = false;
                throw e
            }
        } else {
            opts.url ??= me.url;

            try {
                let data;

                // Fallback for non-browser based envs like nodejs
                if (globalThis.process?.release) {
                    const { readFile } = await import(/* webpackIgnore: true */ 'fs/promises');
                    const content = await me.trap(readFile(opts.url, 'utf-8'));
                    data = {json: JSON.parse(content)};
                } else {
                    data = await me.trap(Neo.Xhr.promiseJson(opts));
                }

                if (data) {
                    me.data = Neo.ns(me.responseRoot, false, data.json) || data.json // fires the load event
                }

                me.isLoaded = true;

                return data?.json || null
            } catch(err) {
                if (err === Neo.isDestroyed) {
                    throw err
                }

                console.error('Error for Neo.Xhr.request', {id: me.id, error: err, url: opts.url});
                return null
            }
        }
    }

    /**
     * @param {Object} opts
     */
    onCollectionMutate(opts) {
        let me = this;

        if (me.isConstructed && !me.isLoading) {
            const isFirstChunk = opts.addedItems && me.count === opts.addedItems.length;

            me.fire('load', {
                isLoading    : !!me.isStreaming,
                items        : me.items,
                postChunkLoad: !!me.isStreaming && !isFirstChunk,
                total        : me.chunkingTotal
            });
        }
    }

    /**
     *
     */
    onCollectionSort() {
        let me = this;

        if (me.isConstructed) {
            me.fire('load', {items: me.items})
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.data) {
            me.afterSetData(me.data)
        }

        // Being constructed does not mean that related afterSetStore() methods got executed
        // => break the sync flow to ensure potential listeners got applied
        Promise.resolve().then(() => {
            if (me.isLoaded) {
                me.fire('load', {items: me.items})
            } else if (me.autoLoad) {
                me.load()
            }
        })
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        let me = this;

        if (me.remoteFilter) {
            me._currentPage = 1; // silent update
            me.load()
        } else {
            super.onFilterChange(opts)
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object} data.record
     */
    onRecordChange(data) {
        this.fire('recordChange', {
            ...data,
            index: this.indexOf(data.record)
        })
    }

    /**
     * @param {Object} opts={}
     * @param {String} opts.direction
     * @param {String} opts.property
     */
    sort(opts={}) {
        let me = this;

        me._currentPage = 1; // silent update

        if (me.configsApplied) {
            if (opts.direction) {
                me.sorters = [{
                    direction: opts.direction,
                    property : opts.property
                }]
            } else {
                if (!me.remoteSort) {
                    me.sorters = [{
                        direction: 'ASC',
                        property : initialIndexSymbol
                    }]
                }
            }
        }
    }

    /**
     * Overrides collection.Base:doSort() to handle "Turbo Mode" (autoInitRecords: false).
     * In this mode, items are raw objects which may lack the canonical field names used by Sorters.
     * This method "soft hydrates" the raw items by resolving and caching the sort values.
     * @param {Object[]} items
     * @param {Boolean} silent
     * @protected
     */
    doSort(items=this._items, silent=false) {
        let me = this;

        if (!me.autoInitRecords && me.model?.hasComplexFields && me.sorters.length > 0) {
            const
                sortProperties = me.sorters.map(s => s.property),
                len            = sortProperties.length;

            items.forEach(item => {
                // Ensure item is not already a Record (mixed mode safety)
                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
                    for (let i = 0; i < len; i++) {
                        const property = sortProperties[i];

                        // Only resolve if the property is missing on the raw object
                        if (!Object.hasOwn(item, property)) {
                            item[property] = me.resolveField(item, property)
                        }
                    }
                }
            })
        }

        super.doSort(items, silent)
    }

    /**
     * Overrides collection.Base:filter() to handle "Turbo Mode" (autoInitRecords: false).
     * In this mode, items are raw objects which may lack the canonical field names used by Filters.
     * This method "soft hydrates" the raw items by resolving and caching the filter values.
     * @protected
     */
    filter() {
        let me = this;

        if (!me.autoInitRecords && me.model?.hasComplexFields && me.filters.length > 0) {
            const
                activeFilters    = me.filters.filter(f => !f.disabled && f.value !== null),
                filterProperties = activeFilters.map(f => f.property),
                len              = filterProperties.length;

            if (len > 0) {
                // We iterate over allItems (unfiltered source) or current items depending on state,
                // but Collection.filter() uses allItems if it exists. Ideally we hydrate the source.
                // Since we can't easily know which source Collection.filter will use without duplicating logic,
                // we will hydrate both if they exist, or just the active one.
                // Safest bet: Hydrate the source that filter() will use.
                // Collection.filter uses: items = me.allItems?._items || me._items
                const itemsToHydrate = me.allItems ? me.allItems._items : me._items;

                itemsToHydrate.forEach(item => {
                    if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
                        for (let i = 0; i < len; i++) {
                            const property = filterProperties[i];

                            if (!Object.hasOwn(item, property)) {
                                item[property] = me.resolveField(item, property)
                            }
                        }
                    }
                })
            }
        }

        super.filter()
    }

    /**
     * Overrides collection.Base:isFilteredItem() to handle "Turbo Mode" (autoInitRecords: false).
     * In this mode, items are raw objects which may lack the canonical field names used by Filters.
     * This method "soft hydrates" the raw item by resolving and caching the filter values.
     * @param {Object} item
     * @returns {boolean}
     * @protected
     */
    isFilteredItem(item) {
        let me = this;

        if (!me.autoInitRecords && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item) && me.filters.length > 0) {
            me.filters.forEach(filter => {
                if (!filter.disabled && filter.value !== null && !Object.hasOwn(item, filter.property)) {
                    item[filter.property] = me.resolveField(item, filter.property)
                }
            })
        }

        return super.isFilteredItem(item)
    }

    /**
     * Helper to resolve a field value from a raw data object using the Model definition.
     * Handles mapping, calculate, and convert.
     *
     * **Limitations & "Turbo-Safe" Requirement:**
     * This method resolves a *single* field in isolation. It does **not** recursively resolve dependencies.
     *
     * If Field A relies on Field B (e.g., via `calculate` or `convert`), and Field B is also a mapped/calculated field:
     * - **On a Record:** Field B is accessible via its getter.
     * - **On a Raw Object:** Field B is `undefined`.
     *
     * Therefore, Model logic (calculate/convert functions) MUST be written to be "Turbo-Safe" / "Polymorphic".
     * They must check for both the canonical field name (for Records) AND the raw data key (for Turbo Mode).
     *
     * @example
     * calculate: data => (data.mappedName || data.rawKey) + 1
     *
     * @param {Object} item The raw data object
     * @param {String} fieldName The canonical field name
     * @returns {*} The resolved value
     * @protected
     */
    resolveField(item, fieldName) {
        let me    = this,
            field = me.model.getField(fieldName),
            value;

        if (!field) return undefined;

        if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item) && field.depends) {
            let deps = field.depends,
                i    = 0,
                len  = deps.length,
                dep;

            for (; i < len; i++) {
                dep = deps[i];
                if (item[dep] === undefined) {
                    item[dep] = me.resolveField(item, dep);
                }
            }
        }

        if (field.calculate) {
            value = field.calculate(item)
        } else {
            // Handle Mapping
            if (field.mapping) {
                let ns     = field.mapping.split('.'),
                    key    = ns.pop(),
                    source = ns.length > 0 ? Neo.ns(ns, false, item) : item;

                if (source && Object.hasOwn(source, key)) {
                    value = source[key]
                }
            } else {
                value = item[fieldName]
            }

            // Handle Convert
            if (field.convert) {
                value = field.convert(value, item)
            }

            // Handle Default Value
            if (value === undefined && Object.hasOwn(field, 'defaultValue')) {
                value = Neo.isFunction(field.defaultValue) ? field.defaultValue() : field.defaultValue
            }
        }

        if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
            item[fieldName] = value;
        }

        return value
    }

    /**
     * Resolves the key of a given item, supporting both raw data objects and Record instances.
     * This handles the edge case where `keyProperty` refers to a mapped source key (e.g. 'l')
     * which exists on the raw object but not on the Record instance (where it is mapped to e.g. 'login').
     * @param {Object|Neo.data.Record} item
     * @returns {String|Number}
     */
    getKey(item) {
        let me          = this,
            keyProperty = me.getKeyProperty(),
            value;

        if (_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].isRecord(item)) {
            return item.get(keyProperty)
        }

        if (keyProperty.includes('.')) {
            value = Neo.ns(keyProperty, false, item)
        } else {
            value = item[keyProperty]
        }

        // If direct access failed, check for mapping (Reverse Lookup)
        if (value === undefined && me.model) {
            let field = me.model.getField(keyProperty);
            if (field?.mapping) {
                let mapping = field.mapping;
                if (mapping.includes('.')) {
                    value = Neo.ns(mapping, false, item)
                } else {
                    value = item[mapping]
                }
            }
        }

        return value
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            autoInitRecords : me.autoInitRecords,
            autoLoad        : me.autoLoad,
            currentPage     : me.currentPage,
            initialChunkSize: me.initialChunkSize,
            isGrouped       : me.isGrouped,
            isLoaded        : me.isLoaded,
            isLoading       : me.isLoading,
            model           : me.model?.toJSON(),
            pageSize        : me.pageSize,
            remoteFilter    : me.remoteFilter,
            remoteSort      : me.remoteSort,
            totalCount      : me.totalCount,
            url             : me.url
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/manager/Store.mjs"
/*!*******************************!*\
  !*** ./src/manager/Store.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.Store
 * @extends Neo.manager.Base
 * @singleton
 */
class Store extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Store'
         * @protected
         */
        className: 'Neo.manager.Store',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        
        // Alias Neo.getStore to this manager?
        // Neo.getStore = this.get.bind(this);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNHO0FBQ007O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixzREFBSTtBQUN4QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQVk7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFhO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlC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QUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZzQ0o7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQU87QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZGF0YS9Nb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL1JlY29yZEZhY3RvcnkubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZGF0YS9TdG9yZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1N0b3JlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgUmVjb3JkRmFjdG9yeSAgZnJvbSAnLi9SZWNvcmRGYWN0b3J5Lm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKlxuICogQHN1bW1hcnkgRGVmaW5lcyB0aGUgc2NoZW1hIGFuZCBkYXRhIHByb2Nlc3NpbmcgbG9naWMgZm9yIHJlY29yZHMgaW4gYSBTdG9yZS5cbiAqXG4gKiBNb2RlbHMgZGVmaW5lIHRoZSBgZmllbGRzYCBhcnJheSwgd2hpY2ggbWFwcyByYXcgZGF0YSBrZXlzIHRvIGNhbm9uaWNhbCBmaWVsZCBuYW1lcywgaGFuZGxlc1xuICogZGF0YSBjb252ZXJzaW9uLCBhbmQgZGVmaW5lcyBjb21wdXRlZCB2YWx1ZXMuXG4gKlxuICogIyMjIENhbGN1bGF0ZWQgRmllbGRzICYgRGVwZW5kZW5jaWVzXG4gKlxuICogRmllbGRzIGNhbiBkeW5hbWljYWxseSBjb21wdXRlIHRoZWlyIHZhbHVlcyB1c2luZyBhIGBjYWxjdWxhdGVgIGZ1bmN0aW9uLiBcbiAqIElmIGEgY2FsY3VsYXRlZCBmaWVsZCByZWxpZXMgb24gb3RoZXIgY2FsY3VsYXRlZCBmaWVsZHMsIHlvdSAqKk1VU1QqKiBkZWNsYXJlIHRoZW0gaW4gdGhlIGBkZXBlbmRzYCBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIGNyaXRpY2FsIGZvciBwZXJmb3JtYW5jZSB3aGVuIHRoZSBTdG9yZSBvcGVyYXRlcyBpbiBcIlR1cmJvIE1vZGVcIiAoYGF1dG9Jbml0UmVjb3JkczogZmFsc2VgKS5cbiAqIEluIFR1cmJvIE1vZGUsIHRoZSBTdG9yZSBwZXJmb3JtcyBcIlNvZnQgSHlkcmF0aW9uXCIgb24gcmF3IEpTT04gb2JqZWN0cy4gRGVjbGFyaW5nIGBkZXBlbmRzYCBlbnN1cmVzXG4gKiB0aGUgU3RvcmUgcmVjdXJzaXZlbHkgcmVzb2x2ZXMgYW5kIGNhY2hlcyB0aGUgZGVwZW5kZW5jaWVzIGJlZm9yZSBleGVjdXRpbmcgeW91ciBjYWxjdWxhdGUgZnVuY3Rpb24sXG4gKiBwcmV2ZW50aW5nIG1hc3NpdmUgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MgKGxpa2UgcmVkdW5kYW50IGFycmF5IHJlZHVjdGlvbnMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBmaWVsZHM6IFt7XG4gKiAgICAgbmFtZTogJ3RvdGFsJyxcbiAqICAgICB0eXBlOiAnSW50ZWdlcicsXG4gKiAgICAgY2FsY3VsYXRlOiBkYXRhID0+IGRhdGEuYSArIGRhdGEuYlxuICogfSwge1xuICogICAgIG5hbWU6ICdyYXRpbycsXG4gKiAgICAgdHlwZTogJ0Zsb2F0JyxcbiAqICAgICBkZXBlbmRzOiBbJ3RvdGFsJ10sIC8vIENydWNpYWwgZm9yIFR1cmJvIE1vZGUgcGVyZm9ybWFuY2UhXG4gKiAgICAgY2FsY3VsYXRlOiBkYXRhID0+IGRhdGEudG90YWwgPT09IDAgPyAwIDogZGF0YS5hIC8gZGF0YS50b3RhbFxuICogfV1cbiAqL1xuY2xhc3MgTW9kZWwgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLk1vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5Nb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdtb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdtb2RlbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXXxudWxsfSBmaWVsZHNfXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzXzoge1xuICAgICAgICAgICAgW2lzRGVzY3JpcHRvcl06IHRydWUsXG4gICAgICAgICAgICBtZXJnZSAgICAgICAgIDogJ2RlZXBBcnJheXMnLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHlfPSdpZCdcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBrZXlQcm9wZXJ0eV86ICdpZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc3RvcmVJZD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlSWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhpcyBjb25maWcgdG8gdHJ1ZSBpbiBjYXNlIHlvdSB3YW50IHRvIHRyYWNrIG1vZGlmaWVkIGZpZWxkcy5cbiAgICAgICAgICogQmUgYXdhcmUgdGhhdCB0aGlzIHdpbGwgZG91YmxlIHRoZSBhbW91bnQgb2YgZGF0YSBpbnNpZGUgZWFjaCByZWNvcmQsXG4gICAgICAgICAqIHNpbmNlIGVhY2ggZmllbGQgd2lsbCBnZXQgYW4gb3JpZ2luYWwgdmFsdWUgZmxhZy5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdHJhY2tNb2RpZmllZEZpZWxkcz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhY2tNb2RpZmllZEZpZWxkczogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHN0b3JpbmcgYWxsIGZpZWxkcywgd2hpY2ggaGF2ZSBhIGNhbGN1bGF0ZSBwcm9wZXJ0eVxuICAgICAqIEBtZW1iZXIge01hcH0gY2FsY3VsYXRlZEZpZWxkc01hcD1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FsY3VsYXRlZEZpZWxkc01hcCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgc3RvcmluZyBhbGwgZmllbGRzIGluc2lkZSBhIGZsYXQgbWFwID0+IG5lc3RlZCBmaWVsZHMgaW5jbHVkZWRcbiAgICAgKiBAbWVtYmVyIHtNYXB9IGZpZWxkc01hcD1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZmllbGRzTWFwID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaGFzQ29tcGxleEZpZWxkcz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBoYXNDb21wbGV4RmllbGRzID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNOZXN0ZWRGaWVsZHM9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaGFzTmVzdGVkRmllbGRzID0gZmFsc2VcblxuICAgIC8qKlxuICAgICBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZpZWxkcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpZWxkcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVGaWVsZHNNYXAodmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBGaWVsZHMgY2FuIGdldCBjaGFuZ2VkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB0aGUgbW9kZWwgaW5zdGFuY2UgaXMgZ2V0dGluZyBjb25zdHJ1Y3RlZC5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0aGUgbGF0ZXN0IHN0YXRlIGJlZm9yZSBjb25zdHJ1Y3Rpb24gJiBob25vciBydW4tdGltZSBjaGFuZ2VzLlxuICAgICAgICAgICAgaWYgKG1lLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBSZWNvcmRGYWN0b3J5LmNyZWF0ZVJlY29yZENsYXNzKG1lLCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYSBmaWVsZCBjb25maWcgYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaWVsZCBjb25maWcgb2JqZWN0IG9yIG51bGwgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgZ2V0RmllbGQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHNNYXAuZ2V0KG5hbWUpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIGZpZWxkIHR5cGUgYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFRoZSBsb3dlcmNhc2UgZmllbGQgdHlwZSBvciBudWxsIGlmIG5vIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIGdldEZpZWxkVHlwZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkKG5hbWUpPy50eXBlPy50b0xvd2VyQ2FzZSgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBpbnN0YW5jZSBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdCBmb3IgdGhlIE5ldXJhbCBMaW5rLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGZpZWxkcyAgICAgICAgICAgICA6IG1lLnNlcmlhbGl6ZUNvbmZpZyhtZS5maWVsZHMpLFxuICAgICAgICAgICAga2V5UHJvcGVydHkgICAgICAgIDogbWUua2V5UHJvcGVydHksXG4gICAgICAgICAgICBzdG9yZUlkICAgICAgICAgICAgOiBtZS5zdG9yZUlkLFxuICAgICAgICAgICAgdHJhY2tNb2RpZmllZEZpZWxkczogbWUudHJhY2tNb2RpZmllZEZpZWxkc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1Jvb3Q9dHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoPScnXG4gICAgICovXG4gICAgdXBkYXRlRmllbGRzTWFwKGZpZWxkcywgaXNSb290PXRydWUsIHBhdGg9JycpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHtjYWxjdWxhdGVkRmllbGRzTWFwLCBmaWVsZHNNYXB9ID0gbWUsXG4gICAgICAgICAgICBmaWVsZE5hbWU7XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgICAgY2FsY3VsYXRlZEZpZWxkc01hcC5jbGVhcigpO1xuICAgICAgICAgICAgZmllbGRzTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBtZS5oYXNDb21wbGV4RmllbGRzID0gZmFsc2U7IC8vIFJlc2V0IGZsYWdcbiAgICAgICAgICAgIG1lLmhhc05lc3RlZEZpZWxkcyAgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgZmllbGROYW1lID0gcGF0aCArIGZpZWxkLm5hbWVcblxuICAgICAgICAgICAgaWYgKGZpZWxkLmZpZWxkcykge1xuICAgICAgICAgICAgICAgIG1lLmhhc05lc3RlZEZpZWxkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlRmllbGRzTWFwKGZpZWxkLmZpZWxkcywgZmFsc2UsIGZpZWxkLm5hbWUgKyAnLicpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkc01hcC5zZXQoZmllbGROYW1lLCBmaWVsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuY2FsY3VsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRGaWVsZHNNYXAuc2V0KGZpZWxkTmFtZSwgZmllbGQpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbXBsZXggZmllbGRzIChTb2Z0IEh5ZHJhdGlvbiBPcHRpbWl6YXRpb24pXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmNhbGN1bGF0ZSB8fCBmaWVsZC5jb252ZXJ0IHx8IGZpZWxkLm1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaGFzQ29tcGxleEZpZWxkcyA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNb2RlbCk7XG4iLCJpbXBvcnQge2ludGVybmFsSWR9IGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuaW1wb3J0IEJhc2UgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBNb2RlbCAgICAgICAgZnJvbSAnLi9Nb2RlbC5tanMnO1xuXG5jb25zdFxuICAgIGRhdGFTeW1ib2wgICAgICAgICA9IFN5bWJvbC5mb3IoJ2RhdGEnKSxcbiAgICBpbml0aWFsSW5kZXhTeW1ib2wgPSBTeW1ib2wuZm9yKCdpbml0aWFsSW5kZXgnKSxcbiAgICBpc01vZGlmaWVkU3ltYm9sICAgPSBTeW1ib2wuZm9yKCdpc01vZGlmaWVkJyksXG4gICAgb3JpZ2luYWxEYXRhU3ltYm9sID0gU3ltYm9sLmZvcignb3JpZ2luYWxEYXRhJyksXG4gICAgdmVyc2lvblN5bWJvbCAgICAgID0gU3ltYm9sLmZvcigndmVyc2lvbicpO1xuXG5sZXQgaW5zdGFuY2U7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLlJlY29yZEZhY3RvcnlcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgUmVjb3JkRmFjdG9yeSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuUmVjb3JkRmFjdG9yeSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhdGEuUmVjb3JkRmFjdG9yeScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlY29yZE5hbWVzcGFjZT0nTmVvLmRhdGEucmVjb3JkJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVjb3JkTmFtZXNwYWNlOiAnTmVvLmRhdGEucmVjb3JkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbW9kZWwtYmFzZWQgZGVmYXVsdCB2YWx1ZXMgdG8gYSBkYXRhIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBtb2RlbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXNzaWduRGVmYXVsdFZhbHVlcyhkYXRhLCBtb2RlbCkge1xuICAgICAgICBtb2RlbC5maWVsZHNNYXAuZm9yRWFjaCgoZmllbGQsIGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLnZpcnR1YWwpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGZpZWxkLm1hcHBpbmcgJiYgIU9iamVjdC5oYXNPd24oZGF0YSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCBucyAgPSBmaWVsZC5tYXBwaW5nLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5zLnBvcCgpLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U7XG5cbiAgICAgICAgICAgICAgICBpZiAobnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBOZW8ubnMobnMsIGZhbHNlLCBkYXRhKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGRhdGFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlICYmIE9iamVjdC5oYXNPd24oc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbZmllbGROYW1lXSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gTmVvLmlzRnVuY3Rpb24oZmllbGQuZGVmYXVsdFZhbHVlKSA/IGZpZWxkLmRlZmF1bHRWYWx1ZSgpIDogZmllbGQuZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgYWx3YXlzIHVzZSBOZW8uYXNzaWduVG9OcygpID0+IHRoZSBjaGVjayBpcyBqdXN0IGZvciBpbXByb3ZpbmcgdGhlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmhhc05lc3RlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXNzaWduVG9OcyhmaWVsZE5hbWUsIGRlZmF1bHRWYWx1ZSwgZGF0YSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW2ZpZWxkTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gPSBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5maWVsZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5wYXRoPScnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucHJvdG9cbiAgICAgKi9cbiAgICBjcmVhdGVGaWVsZCh7ZmllbGQsIG1vZGVsLCBwYXRoPScnLCBwcm90b30pIHtcbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICBmaWVsZFBhdGggPSBwYXRoID09PSAnJyA/IGZpZWxkTmFtZSA6IGAke3BhdGh9LiR7ZmllbGROYW1lfWAsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChmaWVsZC5maWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkLmZpZWxkcy5mb3JFYWNoKGNoaWxkRmllbGQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRmllbGQoe2ZpZWxkOiBjaGlsZEZpZWxkLCBtb2RlbCwgcGF0aDogZmllbGRQYXRoLCBwcm90b30pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLnZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICBbZmllbGRQYXRoXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZSAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5jYWxjdWxhdGUodGhpc1tkYXRhU3ltYm9sXSwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2ZpZWxkUGF0aF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGUgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZW8ubnMoZmllbGRQYXRoLCBmYWxzZSwgdGhpc1tkYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tkYXRhU3ltYm9sXVtmaWVsZE5hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHtbZmllbGRQYXRoXTogaW5zdGFuY2UucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkOiB0aGlzLCBmaWVsZCwgdmFsdWV9KX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQ6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKG1vZGVsLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHJlY29yZENsYXNzID0gTmVvLm5zKGAke3RoaXMucmVjb3JkTmFtZXNwYWNlfS4ke21vZGVsLmNsYXNzTmFtZX0uJHttb2RlbC5pZH1gKTtcblxuICAgICAgICBpZiAoIXJlY29yZENsYXNzKSB7XG4gICAgICAgICAgICByZWNvcmRDbGFzcyA9IHRoaXMuY3JlYXRlUmVjb3JkQ2xhc3MobW9kZWwpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IHJlY29yZENsYXNzKGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBtb2RlbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlPWZhbHNlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGVSZWNvcmRDbGFzcyhtb2RlbCwgb3ZlcndyaXRlPWZhbHNlKSB7XG4gICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gYCR7dGhpcy5yZWNvcmROYW1lc3BhY2V9LiR7bW9kZWwuY2xhc3NOYW1lfS4ke21vZGVsLmlkfWAsXG4gICAgICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAga2V5LCBuc0FycmF5LCBjbHM7XG5cbiAgICAgICAgICAgIGlmICghbnMgfHwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgbnNBcnJheSA9IGNsYXNzTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIGtleSAgICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgIG5zICAgICAgPSBOZW8ubnMobnNBcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2xzICAgICA9IG5zW2tleV0gPSBjbGFzcyBSZWNvcmQge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBtaW5pZnkgdGhlIGN0b3IgY2xhc3MgbmFtZSBpbiBkaXN0L3Byb2R1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgc3RhdGljIG5hbWUgPSAnUmVjb3JkJztcblxuICAgICAgICAgICAgICAgICAgICBbZGF0YVN5bWJvbF0gICAgICAgICA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBbaW5pdGlhbEluZGV4U3ltYm9sXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSByZWNvcmQuIEluY3JlbWVudHMgb24gZXZlcnkgbW9kaWZpY2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBVc2VkIGZvciBjaGFuZ2UgdHJhY2tpbmcgYW5kIG9wdGltaXphdGlvbiAoZS5nLiBzaG9ydC1jaXJjdWl0aW5nIGdyaWQgcmVuZGVyaW5nKS5cbiAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBbdmVyc2lvblN5bWJvbF09MFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgW3ZlcnNpb25TeW1ib2xdID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHN0YWJsZSwgZ2xvYmFsbHkgdW5pcXVlIGludGVybmFsIElEIGZvciB0aGlzIHJlY29yZCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBpbnRlcm5hbElkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBbaW50ZXJuYWxJZF0gPSBOZW8uZ2V0SWQoJ3JlY29yZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdldCBpc01vZGlmaWVkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIU5lby5pc0VxdWFsKG1lW2RhdGFTeW1ib2xdLCBtZVtvcmlnaW5hbERhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVbaXNNb2RpZmllZFN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIHJlY29yZC5cbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdmVyc2lvblN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGNvbmZpZywgaW5pdGlhbEluZGV4U3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW2luaXRpYWxJbmRleFN5bWJvbF0gPSBjb25maWdbaW5pdGlhbEluZGV4U3ltYm9sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnW2luaXRpYWxJbmRleFN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gaW5zdGFuY2UuYXNzaWduRGVmYXVsdFZhbHVlcyhjb25maWcsIG1vZGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtvcmlnaW5hbERhdGFTeW1ib2xdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0T3JpZ2luYWwoY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtpc01vZGlmaWVkU3ltYm9sXSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldFNpbGVudChjb25maWcpIC8vIFdlIGRvIG5vdCB3YW50IHRvIGZpcmUgY2hhbmdlIGV2ZW50cyB3aGVuIGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGdldChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmdldEZpZWxkKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZW8ubnMoZmllbGQsIGZhbHNlLCB0aGlzW2RhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tkYXRhU3ltYm9sXVtmaWVsZF1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IG51bGwgaW4gY2FzZSB0aGUgbW9kZWwgZG9lcyBub3QgdXNlIHRyYWNrTW9kaWZpZWRGaWVsZHMsIHRydWUgaW4gY2FzZSBhIGNoYW5nZSB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlzTW9kaWZpZWRGaWVsZChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC50cmFja01vZGlmaWVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFTY29wZSwgb3JpZ2luYWxEYXRhU2NvcGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzICYmIGZpZWxkTmFtZT8uaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbnNBcnJheSA9IGZpZWxkTmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAgICAgICAgID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNjb3BlICAgICAgICAgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW2RhdGFTeW1ib2xdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhU2NvcGUgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW29yaWdpbmFsRGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNjb3BlICAgICAgICAgPSBtZVtkYXRhU3ltYm9sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhU2NvcGUgPSBtZVtvcmlnaW5hbERhdGFTeW1ib2xdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpZWxkIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmdldEZpZWxkKGZpZWxkTmFtZSkgJiYgICAgICAgIC8vIENoZWNrIGZvciBsZWFmIGZpZWxkcyAoY291bGQgYmUgZXhjbHVkZWQgaW5zaWRlIHRoZSByZWFsIGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFPYmplY3QuaGFzT3duKGRhdGFTY29wZSwgZmllbGROYW1lKSAvLyBDaGVjayB0aGUgZGF0YSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSByZWNvcmQgZG9lcyBub3QgY29udGFpbiB0aGUgZmllbGQnLCBmaWVsZE5hbWUsIG1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhTmVvLmlzRXF1YWwoZGF0YVNjb3BlW2ZpZWxkTmFtZV0sIG9yaWdpbmFsRGF0YVNjb3BlW2ZpZWxkTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHJlY29yZCBmaWVsZCBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICAgKiBFeGVjdXRlcyBpbnN0YW5jZS5zZXRSZWNvcmRGaWVsZHMoKSwgYW5kIGNhbiBnZXQgdXNlZCB2aWE6XG4gICAgICAgICAgICAgICAgICAgICAqIC0gTmVvLnV0aWwuRnVuY3Rpb246Y3JlYXRlU2VxdWVuY2UoKVxuICAgICAgICAgICAgICAgICAgICAgKiAtIE5lby51dGlsLkZ1bmN0aW9uOmludGVyY2VwdCgpLFxuICAgICAgICAgICAgICAgICAgICAgKiB0byBcImxpc3RlblwiIHRvIGZpZWxkIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLmZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIHNpbGVudD1mYWxzZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5Q2hhbmdlKGRhdGEsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW0gPSB7Li4uZGF0YSwgc2lsZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UmVjb3JkRmllbGRzKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEJ1bGstdXBkYXRlIG11bHRpcGxlIHJlY29yZCBmaWVsZHMgYXQgb25jZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICByZXNldChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0T3JpZ2luYWwoZmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBCdWxrLXVwZGF0ZSBtdWx0aXBsZSByZWNvcmQgZmllbGRzIGF0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgc2V0KGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2Uoe2ZpZWxkcywgbW9kZWwsIHJlY29yZDogdGhpc30pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIG1vZGVsIHVzZXMgdHJhY2tNb2RpZmllZEZpZWxkcywgd2Ugd2lsbCBzdG9yZSB0aGUgb3JpZ2luYWwgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBmb3IgdHJhY2tpbmcgdGhlIGRpcnR5IHN0YXRlIChjaGFuZ2VkIGZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRPcmlnaW5hbChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcyh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzLCBzaWxlbnQ6IHRydWUsIHVzZU9yaWdpbmFsRGF0YTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQnVsay11cGRhdGUgbXVsdGlwbGUgcmVjb3JkIGZpZWxkcyBhdCBvbmNlIHdpdGhvdXQgdHJpZ2dlcmluZyBhIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRTaWxlbnQoZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZSh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzfSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIHVzaW5nIEpTT04uc3RyaW5naWZ5KHRoaXMpLCB3ZSB3YW50IHRvIGdldCB0aGUgcmF3IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpc1tkYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbC5maWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNyZWF0ZUZpZWxkKHtmaWVsZCwgbW9kZWwsIHByb3RvOiBjbHMucHJvdG90eXBlfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xzLnByb3RvdHlwZSwgJ2lzUmVjb3JkJywge3ZhbHVlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNscywgJ2lzQ2xhc3MnLCB7dmFsdWU6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuc1trZXldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgYSBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyBjcmVhdGVkIGJ5IHRoaXMgZmFjdG9yeVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlY29yZChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZD8uaXNSZWNvcmQgfHwgZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdHMuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBvcHRzLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZWNvcmRcbiAgICAgKi9cbiAgICBvblJlY29yZENoYW5nZShvcHRzKSB7XG4gICAgICAgIE5lby5nZXQob3B0cy5tb2RlbC5zdG9yZUlkKT8ub25SZWNvcmRDaGFuZ2Uob3B0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhLmZpZWxkXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBbZGF0YS52YWx1ZT1udWxsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgW2RhdGEucmVjb3JkQ29uZmlnPW51bGxdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2VdXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgcGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZCwgdmFsdWU9bnVsbCwgcmVjb3JkQ29uZmlnPW51bGwsIHVzZU9yaWdpbmFsRGF0YT1mYWxzZX0pIHtcbiAgICAgICAgaWYgKGZpZWxkLmNhbGN1bGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmNhbGN1bGF0ZShyZWNvcmRbdXNlT3JpZ2luYWxEYXRhID8gb3JpZ2luYWxEYXRhU3ltYm9sIDogZGF0YVN5bWJvbF0sIGZpZWxkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkLmNvbnZlcnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuY29udmVydCh2YWx1ZSwgcmVjb3JkKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICB7bWFwcGluZywgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIG51bGxhYmxlfSA9IGZpZWxkLFxuICAgICAgICAgICAgb2xkVmFsdWUgID0gcmVjb3JkQ29uZmlnPy5bZmllbGROYW1lXSB8fCByZWNvcmRbZmllbGROYW1lXSxcbiAgICAgICAgICAgIHR5cGUgICAgICA9IGZpZWxkLnR5cGU/LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG1hcHBpbmdzIGZvciBpbml0aWFsIHZhbHVlc1xuICAgICAgICAvLyBkeW5hbWljIGNoYW5nZXMgb2YgYSBmaWVsZCB3aWxsIG5vdCBwYXNzIHRoZSByZWNvcmRDb25maWdcbiAgICAgICAgaWYgKG1hcHBpbmcgJiYgcmVjb3JkQ29uZmlnKSB7XG4gICAgICAgICAgICBsZXQgbnMgID0gbWFwcGluZy5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGtleSA9IG5zLnBvcCgpO1xuXG4gICAgICAgICAgICBucyAgICA9IE5lby5ucyhucywgdHJ1ZSwgcmVjb3JkQ29uZmlnKTtcbiAgICAgICAgICAgIHZhbHVlID0gbnNba2V5XVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdtYXhMZW5ndGgnKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlPy50b1N0cmluZygpLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0dGluZyByZWNvcmQgZmllbGQ6ICR7ZmllbGROYW1lfSB2YWx1ZTogJHt2YWx1ZX0gY29uZmxpY3RzIHdpdGggbWF4TGVuZ3RoOiAke21heExlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCAnbWluTGVuZ3RoJykpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZT8udG9TdHJpbmcoKS5sZW5ndGggPCBtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldHRpbmcgcmVjb3JkIGZpZWxkOiAke2ZpZWxkTmFtZX0gdmFsdWU6ICR7dmFsdWV9IGNvbmZsaWN0cyB3aXRoIG1pbkxlbmd0aDogJHttaW5MZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ251bGxhYmxlJykpIHtcbiAgICAgICAgICAgIGlmIChudWxsYWJsZSA9PT0gZmFsc2UgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldHRpbmcgcmVjb3JkIGZpZWxkOiAke2ZpZWxkTmFtZX0gdmFsdWU6ICR7dmFsdWV9IGNvbmZsaWN0cyB3aXRoIG51bGxhYmxlOiAke251bGxhYmxlfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkYXRlJyAmJiBOZW8udHlwZU9mKHZhbHVlKSAhPT0gJ0RhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZmxvYXQnICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnaHRtbCcgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAoKHR5cGUgPT09ICdpbnQnIHx8IHR5cGUgPT09ICdpbnRlZ2VyJykgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICcnO1xuICAgICAgICAgICAgdmFsdWUgPSAgdmFsdWUucmVwbGFjZSgvKDwoW14+XSspPikvaWcsICcnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgIGRhdGEuZmllbGROYW1lXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbFxuICAgICAqIEBwYXJhbSB7UmVjb3JkfSAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2UgdHJ1ZSB3aWxsIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsRGF0YSBzeW1ib2xcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgICBkYXRhLnZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldFJlY29yZERhdGEoe2ZpZWxkTmFtZSwgbW9kZWwsIHJlY29yZCwgdXNlT3JpZ2luYWxEYXRhPWZhbHNlLCB2YWx1ZX0pIHtcbiAgICAgICAgaWYgKHVzZU9yaWdpbmFsRGF0YSAmJiAhbW9kZWwudHJhY2tNb2RpZmllZEZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2NvcGUgPSB1c2VPcmlnaW5hbERhdGEgPyBvcmlnaW5hbERhdGFTeW1ib2wgOiBkYXRhU3ltYm9sO1xuXG4gICAgICAgIGlmIChtb2RlbC5oYXNOZXN0ZWRGaWVsZHMgJiYgZmllbGROYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIGxldCBucywgbnNBcnJheTtcblxuICAgICAgICAgICAgbnNBcnJheSAgID0gZmllbGROYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBmaWVsZE5hbWUgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKG5zQXJyYXksIHRydWUsIHJlY29yZFtzY29wZV0pO1xuXG4gICAgICAgICAgICBuc1tmaWVsZE5hbWVdID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY29yZFtzY29wZV1bZmllbGROYW1lXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gICAgICAgZGF0YS5jaGFuZ2VkRmllbGRzPVtdIEludGVybmFsIGZsYWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLmZpZWxkc1xuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEuc2lsZW50PWZhbHNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2UgdHJ1ZSB3aWxsIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsRGF0YSBzeW1ib2xcbiAgICAgKi9cbiAgICBzZXRSZWNvcmRGaWVsZHMoe2NoYW5nZWRGaWVsZHM9W10sIGZpZWxkcywgbW9kZWwsIHJlY29yZCwgc2lsZW50PWZhbHNlLCB1c2VPcmlnaW5hbERhdGE9ZmFsc2V9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7Y2FsY3VsYXRlZEZpZWxkc01hcCwgZmllbGRzTWFwLCB0cmFja01vZGlmaWVkRmllbGRzfSA9IG1vZGVsLFxuICAgICAgICAgICAgZmllbGRFeGlzdHMsIGhhc0NoYW5nZWRGaWVsZHMsIG9sZFZhbHVlO1xuXG4gICAgICAgIGlmICghdHJhY2tNb2RpZmllZEZpZWxkcyAmJiB1c2VPcmlnaW5hbERhdGEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZmllbGRzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGZpZWxkRXhpc3RzID0gZmllbGRzTWFwLmhhcyhrZXkpO1xuXG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiAhZmllbGRFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2NoaWxkS2V5LCBjaGlsZFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZXRSZWNvcmRGaWVsZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczoge1tgJHtrZXl9LiR7Y2hpbGRLZXl9YF06IGNoaWxkVmFsdWV9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VPcmlnaW5hbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZEV4aXN0cykge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVjb3JkW2tleV07XG4gICAgICAgICAgICAgICAgdmFsdWUgICAgPSBtZS5wYXJzZVJlY29yZFZhbHVlKHtyZWNvcmQsIGZpZWxkOiBtb2RlbC5nZXRGaWVsZChrZXkpLCB2YWx1ZX0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChvbGRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNldFJlY29yZERhdGEoe2ZpZWxkTmFtZToga2V5LCBtb2RlbCwgcmVjb3JkLCB1c2VPcmlnaW5hbERhdGEsIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFja01vZGlmaWVkRmllbGRzICYmICF1c2VPcmlnaW5hbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZFtpc01vZGlmaWVkU3ltYm9sXSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHMucHVzaCh7bmFtZToga2V5LCBvbGRWYWx1ZSwgdmFsdWV9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaGFzQ2hhbmdlZEZpZWxkcyA9IE9iamVjdC5rZXlzKGNoYW5nZWRGaWVsZHMpLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgaWYgKGhhc0NoYW5nZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIHJlY29yZFt2ZXJzaW9uU3ltYm9sXSsrO1xuXG4gICAgICAgICAgICBjYWxjdWxhdGVkRmllbGRzTWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudmlydHVhbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZWNvcmRba2V5XTtcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IG1lLnBhcnNlUmVjb3JkVmFsdWUoe3JlY29yZCwgZmllbGQ6IG1vZGVsLmdldEZpZWxkKGtleSksIHVzZU9yaWdpbmFsRGF0YX0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChvbGRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNldFJlY29yZERhdGEoe2ZpZWxkTmFtZToga2V5LCBtb2RlbCwgcmVjb3JkLCB1c2VPcmlnaW5hbERhdGEsIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkcy5wdXNoKHtuYW1lOiBrZXksIG9sZFZhbHVlLCB2YWx1ZX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2lsZW50ICYmICF1c2VPcmlnaW5hbERhdGEgJiYgaGFzQ2hhbmdlZEZpZWxkcykge1xuICAgICAgICAgICAgbWUub25SZWNvcmRDaGFuZ2Uoe2ZpZWxkczogY2hhbmdlZEZpZWxkcywgbW9kZWwsIHJlY29yZH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmluc3RhbmNlID0gTmVvLnNldHVwQ2xhc3MoUmVjb3JkRmFjdG9yeSk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIiwiaW1wb3J0IHtpbnRlcm5hbElkfSAgICBmcm9tICcuLi9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gICAgICBmcm9tICcuLi9jb2xsZWN0aW9uL0Jhc2UubWpzJztcbmltcG9ydCBNb2RlbCAgICAgICAgICAgZnJvbSAnLi9Nb2RlbC5tanMnO1xuaW1wb3J0IE9ic2VydmFibGUgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCBSZWNvcmRGYWN0b3J5ICAgZnJvbSAnLi9SZWNvcmRGYWN0b3J5Lm1qcyc7XG5pbXBvcnQgU3RvcmVNYW5hZ2VyICAgIGZyb20gJy4uL21hbmFnZXIvU3RvcmUubWpzJztcblxuY29uc3QgaW5pdGlhbEluZGV4U3ltYm9sID0gU3ltYm9sLmZvcignaW5pdGlhbEluZGV4Jyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLlN0b3JlXG4gKiBAZXh0ZW5kcyBOZW8uY29sbGVjdGlvbi5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICpcbiAqIEBzdW1tYXJ5IEEgcG93ZXJmdWwsIG9ic2VydmFibGUgY29sbGVjdGlvbiB0aGF0IG1hbmFnZXMgYSBzZXQgb2YgZGF0YSByZWNvcmRzLlxuICpcbiAqIE5lby5kYXRhLlN0b3JlIGlzIHRoZSBjZW50cmFsIGRhdGEgbWFuYWdlbWVudCBjbGFzcyBpbiB0aGUgZnJhbWV3b3JrLiBJdCBoYW5kbGVzIHRoZSBsaWZlY3ljbGUgb2ZcbiAqIGRhdGEgcmVjb3JkcywgaW5jbHVkaW5nIGxvYWRpbmcsIGZpbHRlcmluZywgc29ydGluZywgYW5kIHN5bmNocm9uaXphdGlvbiB3aXRoIGJhY2tlbmQgQVBJcy5cbiAqXG4gKiAjIyMgUmVjb3JkIEluc3RhbnRpYXRpb24gU3RyYXRlZ2llczogRWFnZXIgdnMuIExhenkgKFwiVHVyYm8gTW9kZVwiKVxuICpcbiAqIFRoZSBTdG9yZSBzdXBwb3J0cyB0d28gZGlzdGluY3Qgc3RyYXRlZ2llcyBmb3IgaGFuZGxpbmcgcmVjb3JkIGNyZWF0aW9uLCBjb250cm9sbGVkIGJ5IHRoZSBgYXV0b0luaXRSZWNvcmRzYCBjb25maWdcbiAqICh3aGljaCBkZWZhdWx0cyB0byBgdHJ1ZWApIGFuZCB0aGUgYGluaXRgIHBhcmFtZXRlciBpbiBtZXRob2RzIGxpa2UgYGFkZCgpYCBhbmQgYGluc2VydCgpYC5cbiAqXG4gKiAqKjEuIEVhZ2VyIEluc3RhbnRpYXRpb24gKERlZmF1bHQ6IGBhdXRvSW5pdFJlY29yZHM6IHRydWVgKSoqXG4gKiAgICAtICoqQmVoYXZpb3IqKjogUmF3IGRhdGEgb2JqZWN0cyBhcmUgaW1tZWRpYXRlbHkgY29udmVydGVkIGludG8gYE5lby5kYXRhLk1vZGVsYCBpbnN0YW5jZXMuXG4gKiAgICAtICoqVXNlIENhc2UqKjogU3RhbmRhcmQgb3BlcmF0aW9ucywgYWRkaW5nIHNpbmdsZSBpdGVtcywgaW50ZXJhY3RpdmUgZWRpdHMuXG4gKiAgICAtICoqUHJvcyoqOiBSZXR1cm5zIHVzYWJsZSBSZWNvcmQgaW5zdGFuY2VzIGltbWVkaWF0ZWx5LiBIaWdoIERldmVsb3BlciBFeHBlcmllbmNlIChEWCkuXG4gKiAgICAtICoqQ29ucyoqOiBDYW4gYmUgc2xvdyBmb3IgbWFzc2l2ZSBkYXRhc2V0cyAoMTBrKyByZWNvcmRzKS5cbiAqXG4gKiAqKjIuIExhenkgSW5zdGFudGlhdGlvbiAoXCJUdXJibyBNb2RlXCIpKipcbiAqICAgIC0gKipCZWhhdmlvcioqOiBSYXcgZGF0YSBvYmplY3RzIGFyZSBzdG9yZWQgZGlyZWN0bHkuIGBOZW8uZGF0YS5Nb2RlbGAgaW5zdGFuY2VzIGFyZSBjcmVhdGVkXG4gKiAgICAgIFwianVzdC1pbi10aW1lXCIgb25seSB3aGVuIHRoZXkgYXJlIGFjY2Vzc2VkIHZpYSBgZ2V0KClgLCBgZ2V0QXQoKWAsIG9yIGl0ZXJhdGlvbi5cbiAqICAgIC0gKipVc2UgQ2FzZSoqOiBCdWxrIGxvYWRpbmcgbGFyZ2UgZGF0YXNldHMgKGUuZy4sIGdyaWRzLCBjaGFydHMgd2l0aCB0aG91c2FuZHMgb2YgcG9pbnRzKS5cbiAqICAgIC0gKipQcm9zKio6IE1hc3NpdmUgcGVyZm9ybWFuY2UgZ2FpbnMgZm9yIGluaXRpYWwgZGF0YSBsb2FkLiBFbmFibGVzIGludGVybmFsIFwiY2h1bmtpbmdcIiB0byBwcmV2ZW50IFVJIGZyZWV6ZXMuXG4gKiAgICAtICoqQ29ucyoqOiBgYWRkKClgIHJldHVybnMgYSBjb3VudCBpbnN0ZWFkIG9mIHJlY29yZHMuIFJlY29yZHMgYXJlIG5vdCBhdmFpbGFibGUgdW50aWwgYWNjZXNzZWQuXG4gKiAgICAtICoqSG93IHRvIGVuYWJsZSoqOlxuICogICAgICAtICoqR2xvYmFsKio6IFNldCBgYXV0b0luaXRSZWNvcmRzOiBmYWxzZWAgb24gdGhlIFN0b3JlIGNvbmZpZy5cbiAqICAgICAgLSAqKlBlci1jYWxsKio6IFBhc3MgYGZhbHNlYCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBhZGQoKWAgb3IgYGluc2VydCgpYC5cbiAqICAgICAgYGBgamF2YXNjcmlwdFxuICogICAgICAvLyBHbG9iYWwgc2V0dGluZ1xuICogICAgICBOZW8uY3JlYXRlKFN0b3JlLCB7XG4gKiAgICAgICAgICBhdXRvSW5pdFJlY29yZHM6IGZhbHNlLFxuICogICAgICAgICAgZGF0YTogaHVnZUFycmF5T2ZEYXRhXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gUGVyLWNhbGwgb3ZlcnJpZGVcbiAqICAgICAgc3RvcmUuYWRkKGh1Z2VBcnJheU9mRGF0YSwgZmFsc2UpO1xuICogICAgICBgYGBcbiAqXG4gKiAjIyMgU29mdCBIeWRyYXRpb24gJiBGaWVsZCBEZXBlbmRlbmNpZXNcbiAqXG4gKiBXaGVuIG9wZXJhdGluZyBpbiBUdXJibyBNb2RlIChgYXV0b0luaXRSZWNvcmRzOiBmYWxzZWApLCB0aGUgU3RvcmUgc29ydHMgYW5kIGZpbHRlcnMgdXNpbmcgcmF3IEpTT04gb2JqZWN0cy5cbiAqIElmIGEgc29ydCBvciBmaWx0ZXIgb3BlcmF0aW9uIHJlcXVpcmVzIGEgY2FsY3VsYXRlZCBmaWVsZCB0aGF0IGlzbid0IHByZXNlbnQgb24gdGhlIHJhdyBvYmplY3QsIHRoZSBTdG9yZVxuICogcGVyZm9ybXMgKipTb2Z0IEh5ZHJhdGlvbioqIHZpYSBgcmVzb2x2ZUZpZWxkKClgLiBJdCBkeW5hbWljYWxseSBjYWxjdWxhdGVzIHRoZSBmaWVsZCB2YWx1ZSBhbmQgYXV0by1jYWNoZXNcbiAqIGl0IG9uIHRoZSByYXcgb2JqZWN0LlxuICpcbiAqIElmIGEgY2FsY3VsYXRlZCBmaWVsZCByZWxpZXMgb24gb3RoZXIgY2FsY3VsYXRlZCBmaWVsZHMsIHRoZSBNb2RlbCBkZWZpbml0aW9uIG11c3QgZGVjbGFyZSBhIGBkZXBlbmRzOiBbXWAgYXJyYXkuXG4gKiBUaGUgU3RvcmUgdXNlcyB0aGlzIGFycmF5IHRvIHJlY3Vyc2l2ZWx5IHJlc29sdmUgYW5kIGNhY2hlIGFsbCBkZXBlbmRlbmNpZXMgYmVmb3JlIGV4ZWN1dGluZyB0aGUgbWFpbiBjYWxjdWxhdGlvbixcbiAqIHByZXZlbnRpbmcgc2V2ZXJlIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzIChsaWtlIHJlZHVuZGFudCBhcnJheSByZWR1Y3Rpb25zKS5cbiAqXG4gKiAjIyMgUHJvZ3Jlc3NpdmUgTG9hZGluZyAoU3RyZWFtaW5nKVxuICpcbiAqIFdoZW4gdXNpbmcgYSBgcHJveHlgIChlLmcuLCB7QGxpbmsgTmVvLmRhdGEucHJveHkuU3RyZWFtfSksIHRoZSBTdG9yZSBzdXBwb3J0cyAqKlByb2dyZXNzaXZlIExvYWRpbmcqKi5cbiAqIEluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIGVudGlyZSBkYXRhc2V0IHRvIGxvYWQsIHRoZSBTdG9yZSB1cGRhdGVzIGl0c2VsZiBpbmNyZW1lbnRhbGx5IGFzIGNodW5rcyBvZiBkYXRhIGFycml2ZS5cbiAqXG4gKiAtICoqRXZlbnRzOioqIFRoZSBgbG9hZGAgZXZlbnQgZmlyZXMgbXVsdGlwbGUgdGltZXMgKG9uY2UgcGVyIGNodW5rKSB3aXRoIHRoZSBjdW11bGF0aXZlIGB0b3RhbGAuXG4gKiAtICoqVUkgSW50ZWdyYXRpb246KiogQ29tcG9uZW50cyBsaWtlIGBOZW8uZ3JpZC5Db250YWluZXJgIGxpc3RlbiB0byB0aGVzZSBldmVudHMgdG8gdXBkYXRlIHRoZWlyIHNjcm9sbGJhcnMgYW5kIHJlbmRlciByb3dzIGltbWVkaWF0ZWx5LlxuICovXG5jbGFzcyBTdG9yZSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLlN0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5TdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0ZWFkIG9mIHNldHRpbmcgYW4gdXJsLCB5b3UgY2FuIGRlZmluZSB0aGUgUlBDIEJFIEFQSSBtZXRob2RzLlxuICAgICAgICAgKiBJbiBjYXNlIHRoZSA0IG1ldGhvZHMgYXJlIHVzaW5nIHRoZSBzYW1lIHNlcnZpY2UgYW5kIHRoaXMgc2VydmljZSBpcyB1c2luZyB0aGUgQ1JVRCBiYXNlZCBmbi1uYW1lcyxcbiAgICAgICAgICogeW91IGNhbiBzd2l0Y2ggdG8gYSBzdHJpbmcgYmFzZWQgc2hvcnRjdXQuXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgMiBleGFtcGxlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYXBpOiB7XG4gICAgICAgICAqICAgIGNyZWF0ZSA6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmNyZWF0ZScsXG4gICAgICAgICAqICAgIGRlc3Ryb3k6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmRlc3Ryb3knLFxuICAgICAgICAgKiAgICByZWFkICAgOiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZS5yZWFkJyxcbiAgICAgICAgICogICAgdXBkYXRlIDogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UudXBkYXRlJ1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFwaTogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UnXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd8bnVsbH0gYXBpXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBpXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgcmVjb3JkIGluc3RhbmNlcyB3aGVuIGFkZGluZyBpdGVtcy5cbiAgICAgICAgICogU2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBcIlR1cmJvIE1vZGVcIiAoTGF6eSBJbnN0YW50aWF0aW9uKSBnbG9iYWxseSBmb3IgdGhpcyBzdG9yZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0luaXRSZWNvcmRzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0UmVjb3JkczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Mb2FkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTG9hZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRQYWdlXz0xXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudFBhZ2VfOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gZGF0YV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgY2h1bmsgc2l6ZSBmb3IgYWRkaW5nIGxhcmdlIGRhdGFzZXRzLiBTZXQgdG8gMCB0byBkaXNhYmxlIGNodW5raW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGluaXRpYWxDaHVua1NpemU9MFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbENodW5rU2l6ZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzR3JvdXBlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNHcm91cGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTG9hZGVkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0xvYWRpbmc9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgYSB2YWx1ZSBvZiAwIHRvIG5vdCBsaW1pdCB0aGUgcGFnZVNpemVcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBwYWdlU2l6ZV89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VTaXplXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxOZW8uZGF0YS5wcm94eS5CYXNlfG51bGx9IHByb3h5Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJveHlfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBsZXQgdGhlIGJhY2tlbmQgaGFuZGxlIHRoZSBmaWx0ZXJpbmcuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgYnVmZmVyZWQgc3RvcmVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW90ZUZpbHRlcj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlRmlsdGVyOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gbGV0IHRoZSBiYWNrZW5kIGhhbmRsZSB0aGUgc29ydGluZy5cbiAgICAgICAgICogVXNlZnVsIGZvciBidWZmZXJlZCBzdG9yZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3RlU29ydD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlU29ydDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBwYXRoIHRvIHRoZSByb290IG9mIHlvdXIgZGF0YS5cbiAgICAgICAgICogSWYgdGhlIHJlc3BvbnNlUm9vdCBpcyAnZGF0YScgdGhpcyBpcyBvcHRpb25hbC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZXNwb25zZVJvb3Q9J2RhdGEnXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zZVJvb3Q6ICdkYXRhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdG90YWxDb3VudD0wXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbENvdW50OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byB0cmFjayBpbnRlcm5hbElkcyBpbiBhIHNlcGFyYXRlIG1hcCBmb3IgTygxKSBsb29rdXBcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdHJhY2tJbnRlcm5hbElkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRyYWNrSW50ZXJuYWxJZDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVybCBmb3IgQWpheCByZXF1ZXN0c1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdXJsPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHVybDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgY29uZmlnLml0ZW1GYWN0b3J5ID0gdGhpcy5hc3NpZ25JbnRlcm5hbElkLmJpbmQodGhpcyk7XG5cbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvXG4gICAgICAgIG1lLm9uKHtcbiAgICAgICAgICAgIG11dGF0ZTogbWUub25Db2xsZWN0aW9uTXV0YXRlLFxuICAgICAgICAgICAgc29ydCAgOiBtZS5vbkNvbGxlY3Rpb25Tb3J0LFxuICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBTdG9yZU1hbmFnZXIucmVnaXN0ZXIobWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBTdG9yZU1hbmFnZXIudW5yZWdpc3Rlcih0aGlzKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGl0eSBQcm92aWRlciBIb29rLlxuICAgICAqIEFzc2lnbnMgYSBzdGFibGUsIGdsb2JhbGx5IHVuaXF1ZSAnaW50ZXJuYWxJZCcgdG8gaXRlbXMgKFJlY29yZHMgb3IgUmF3IE9iamVjdHMpLlxuICAgICAqIFRoaXMgZW5zdXJlcyBET00gc3RhYmlsaXR5IGFuZCBzZWN1cml0eSBieSBkZWNvdXBsaW5nIHRoZSBET00gSUQgZnJvbSB0aGUgZGF0YSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqL1xuICAgIGFzc2lnbkludGVybmFsSWQoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW1baW50ZXJuYWxJZF0pIHtcbiAgICAgICAgICAgIGl0ZW1baW50ZXJuYWxJZF0gPSBOZW8uZ2V0SWQoJ3JlY29yZCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhlIGN1cnJlbnQgcHJveHkgb3BlcmF0aW9uIGlmIHRoZSBwcm94eSBzdXBwb3J0cyBpdC5cbiAgICAgKi9cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5wcm94eT8uYWJvcnQ/LigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTogYWRkKCkgdG8gY29udmVydCBpdGVtcyBpbnRvIHJlY29yZHMgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogKioxLiBFYWdlciBNb2RlIChgaW5pdD10cnVlYCAtIERlZmF1bHQpOioqXG4gICAgICogSW1tZWRpYXRlbHkgY29udmVydHMgcmF3IGRhdGEgaW50byBgTmVvLmRhdGEuTW9kZWxgIGluc3RhbmNlcy5cbiAgICAgKiBSZXR1cm5zIGFuIGBBcnJheWAgb2YgdGhlIGNyZWF0ZWQgcmVjb3Jkcy5cbiAgICAgKlxuICAgICAqICoqMi4gTGF6eSBNb2RlIChgaW5pdD1mYWxzZWApOioqXG4gICAgICogQWRkcyByYXcgZGF0YSBkaXJlY3RseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gSW5zdGFudGlhdGVzIHJlY29yZHMgb25seSBvbiBhY2Nlc3MuXG4gICAgICpcbiAgICAgKiAtICoqQ2h1bmtpbmcgQWN0aXZlKio6IElmIGBpbml0aWFsQ2h1bmtTaXplID4gMGAgYW5kIGBpdGVtcy5sZW5ndGggPiB0aHJlc2hvbGRgOlxuICAgICAqICAgQWRkcyBpdGVtcyBpbiBjaHVua3MgdG8gcHJldmVudCBibG9ja2luZyB0aGUgQXBwIFdvcmtlciAoTWFpbiBBY3RvcikuXG4gICAgICogICBSZXR1cm5zIHRoZSBuZXcgY29sbGVjdGlvbiBgY291bnRgIChOdW1iZXIpLlxuICAgICAqXG4gICAgICogLSAqKk5vIENodW5raW5nKio6IElmIGBpbml0aWFsQ2h1bmtTaXplID09PSAwYCBvciBgaXRlbXMubGVuZ3RoIDw9IHRocmVzaG9sZGA6XG4gICAgICogICBBZGRzIHJhdyBpdGVtcyBkaXJlY3RseS5cbiAgICAgKiAgIFJldHVybnMgYW4gYEFycmF5YCBvZiB0aGUgYWRkZWQgcmF3IGRhdGEgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gMS4gRGVmYXVsdDogR2V0IHJlY29yZHMgaW1tZWRpYXRlbHlcbiAgICAgKiBjb25zdCBbbmV3UmVjb3JkXSA9IHN0b3JlLmFkZCh7bmFtZTogJ05ldyBJdGVtJ30pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyAyLiBUdXJibyBNb2RlIChObyBDaHVua2luZyk6IEdldCByYXcgb2JqZWN0c1xuICAgICAqIGNvbnN0IFtyYXdPYmplY3RdID0gc3RvcmUuYWRkKHtuYW1lOiAnSXRlbSd9LCBmYWxzZSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIDMuIFR1cmJvIE1vZGUgKENodW5raW5nKTogR2V0IG5ldyBjb3VudFxuICAgICAqIHN0b3JlLmluaXRpYWxDaHVua1NpemUgPSAxMDAwO1xuICAgICAqIGNvbnN0IG5ld0NvdW50ID0gc3RvcmUuYWRkKGh1Z2VEYXRhQXJyYXksIGZhbHNlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHNdIFRydWUgdG8gcmV0dXJuIHRoZSBjcmVhdGVkIHJlY29yZHMsIGZhbHNlIGZvciBcIlR1cmJvIE1vZGVcIlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8T2JqZWN0W118TmVvLmRhdGEuTW9kZWxbXX0gVGhlIGNvbGxlY3Rpb24gY291bnQsIHJhdyBpdGVtcywgb3IgY3JlYXRlZCByZWNvcmRzXG4gICAgICovXG4gICAgYWRkKGl0ZW0sIGluaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyAgICAgPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXSxcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IG1lLmluaXRpYWxDaHVua1NpemU7XG5cbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgIHN1cGVyLmFkZChpdGVtcyk7XG5cbiAgICAgICAgICAgIG1lLmlzTG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChpID0+IG1lLmdldChtZS5nZXRLZXkoaSkpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZCA+IDAgJiYgaXRlbXMubGVuZ3RoID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IG1lLmNvdW50ICsgaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgY2h1bmsgPSBpdGVtcy5zcGxpY2UoMCwgdGhyZXNob2xkKTtcblxuICAgICAgICAgICAgbWUuY2h1bmtpbmdUb3RhbCA9IHRvdGFsO1xuXG4gICAgICAgICAgICAvLyAxLiBBZGQgdGhlIGZpcnN0IGNodW5rLiBUaGlzIGZpcmVzICdtdXRhdGUnIC0+ICdsb2FkJyAodmlhIG9uQ29sbGVjdGlvbk11dGF0ZSlcbiAgICAgICAgICAgIC8vICAgIGFuZCB0cmlnZ2VycyB0aGUgaW5pdGlhbCBncmlkIHJlbmRlci4gVGhlICdsb2FkJyBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGZpbmFsIHRvdGFsIGNvdW50LlxuICAgICAgICAgICAgc3VwZXIuYWRkKGNodW5rKTsgLy8gUGFzcyByYXcgY2h1bmsgZGlyZWN0bHlcblxuICAgICAgICAgICAgLy8gMi4gU3VzcGVuZCBldmVudHMgdG8gcHJldmVudCB0aGUgbmV4dCAnYWRkJyBmcm9tIGZpcmluZyAnbG9hZCcuXG4gICAgICAgICAgICBtZS5zdXNwZW5kRXZlbnRzID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gMy4gQWRkIHRoZSByZXN0IG9mIHRoZSBpdGVtcyBzaWxlbnRseS5cbiAgICAgICAgICAgIHN1cGVyLmFkZChpdGVtcyk7IC8vIFBhc3MgcmF3IGl0ZW1zIGRpcmVjdGx5XG5cbiAgICAgICAgICAgIC8vIDQuIFJlc3VtZSBldmVudHMuXG4gICAgICAgICAgICBtZS5zdXNwZW5kRXZlbnRzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIDUuIE1hbnVhbGx5IGZpcmUgYSBmaW5hbCAnbG9hZCcgZXZlbnQgdG8gdXBkYXRlIHRoZSBncmlkJ3Mgc2Nyb2xsYmFyIGFuZCBub3RpZnkgb3RoZXIgbGlzdGVuZXJzLlxuICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXMsIHBvc3RDaHVua0xvYWQ6IHRydWUsIHRvdGFsOiBtZS5jaHVua2luZ1RvdGFsfSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZS5jaHVua2luZ1RvdGFsO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUuY291bnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gc3VwZXIuYWRkKGl0ZW1zKTtcblxuICAgICAgICAvLyBJZiB3ZSB1c2UgYWRkKCkgaW5pdGlhbGx5IGluc3RlYWQgb2Ygc2V0dGluZyBgZGF0YWAsIHdlIG5lZWQgdG8gc2V0IHRoZSBsb2FkZWQgZmxhZyBoZXJlLlxuICAgICAgICBtZS5pc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlIC8vIFBhc3MgcmF3IGl0ZW0gZGlyZWN0bHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGN1cnJlbnRQYWdlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnRQYWdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2xlYXIoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgbWUuYWRkKHZhbHVlLCBtZS5hdXRvSW5pdFJlY29yZHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgb2xkVmFsdWUgJiYgbWUucmVtb3RlRmlsdGVyICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLnN0b3JlSWQgPSB0aGlzLmlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHBhZ2VTaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhZ2VTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5sb2FkKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFNvcnRlcnModmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5yZW1vdGVTb3J0ICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgYmVmb3JlU2V0QXBpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGUgOiB2YWx1ZSArICcuY3JlYXRlJyxcbiAgICAgICAgICAgICAgICBkZXN0cm95OiB2YWx1ZSArICcuZGVzdHJveScsXG4gICAgICAgICAgICAgICAgcmVhZCAgIDogdmFsdWUgKyAnLnJlYWQnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZSA6IHZhbHVlICsgJy51cGRhdGUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOZW8uZGF0YS5wcm94eS5CYXNlfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5lby5kYXRhLnByb3h5LkJhc2V9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5wcm94eS5CYXNlfVxuICAgICAqL1xuICAgIGJlZm9yZVNldFByb3h5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2UodmFsdWUsIG51bGwsIHtcbiAgICAgICAgICAgIHN0b3JlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118TmVvLmRhdGEuTW9kZWxbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfE5lby5kYXRhLk1vZGVsW119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXXxOZW8uZGF0YS5Nb2RlbFtdfVxuICAgICAqL1xuICAgIGJlZm9yZVNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5Nb2RlbH1cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlIHRvIHByZXZlbnQgdGhlIGFsbEl0ZW1zIGNvbGxlY3Rpb24gZnJvbSBhdXRvLWxvYWRpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHJldHVybnMge05lby5jb2xsZWN0aW9uLkJhc2V9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUFsbEl0ZW1zKGNvbmZpZykge1xuICAgICAgICBjb25maWcuYXV0b0xvYWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUFsbEl0ZW1zKGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIHJlY29yZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXX0gQXJyYXkgaW4gY2FzZSBhbiBhcnJheSB3YXMgcGFzc2VkXG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKGNvbmZpZykge1xuICAgICAgICBsZXQgaXNBcnJheSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uZmlnICA9IFtjb25maWddXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gY29uZmlnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGNvbmZpZ1tpXVxuXG4gICAgICAgICAgICAgICAgaWYgKCFSZWNvcmRGYWN0b3J5LmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tpXSA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0FycmF5ID8gY29uZmlnIDogY29uZmlnWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmaW5kKCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtKHMpIGFyZSBSZWNvcmQgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFt2YWx1ZV0gT25seSByZXF1aXJlZCBpbiBjYXNlIHRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5maW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaCk7XG5cbiAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyB0aGlzLmdldCh0aGlzLmdldEtleShyZXN1bHQpKSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChpdGVtID0+IHRoaXMuZ2V0KHRoaXMuZ2V0S2V5KGl0ZW0pKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmZpbmRCeSgpIHRvIGVuc3VyZSB0aGUgcmV0dXJuZWQgaXRlbShzKSBhcmUgUmVjb3JkIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcnVuIGZvciBlYWNoIGl0ZW0gaW5zaWRlIHRoZSBzdGFydC1lbmQgcmFuZ2UuIFJldHVybiB0cnVlIGZvciBhIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZT10aGlzIFRoZSBzY29wZSBpbiB3aGljaCB0aGUgcGFzc2VkIGZ1bmN0aW9uIGdldHMgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQ9MCBUaGUgc3RhcnQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kPXRoaXMuY291bnQgVGhlIGVuZCBpbmRleCAodXAgdG8sIGxhc3QgdmFsdWUgZXhjbHVkZWQpXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGZpbmRCeShmbiwgc2NvcGU9dGhpcywgc3RhcnQ9MCwgZW5kPXRoaXMuY291bnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZmluZEJ5KGZuLCBzY29wZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKGl0ZW0gPT4gdGhpcy5nZXQodGhpcy5nZXRLZXkoaXRlbSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmZvckVhY2goKSB0byBlbnN1cmUgdGhlIGl0ZXJhdGVkIGl0ZW0gaXMgYSBSZWNvcmQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggcmVjb3JkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGZuYC5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGZuLCBzY29wZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWUuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChzY29wZSB8fCBtZSwgbWUuZ2V0QXQoaSksIGksIG1lLml0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBjb2xsZWN0aW9uLkJhc2U6Z2V0KCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtIGlzIGEgUmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IHN1cGVyLmdldChrZXkpOyAvLyBHZXQgaXRlbSBmcm9tIENvbGxlY3Rpb24uQmFzZSAoY291bGQgYmUgcmF3IGRhdGEpXG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ICA9IG1lLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICBjb25zdCBwayAgICAgPSByZWNvcmRbbWUua2V5UHJvcGVydHldOyAvLyBVc2UgdGhlIGFjdHVhbCBQSyBmcm9tIHRoZSByZWNvcmRcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcmF3IGRhdGEgd2l0aCB0aGUgcmVjb3JkIGluc3RhbmNlIGluIHRoZSBjdXJyZW50IChmaWx0ZXJlZCkgY29sbGVjdGlvblxuICAgICAgICAgICAgbWUubWFwLnNldChwaywgcmVjb3JkKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1lLl9pdGVtc1tpbmRleF0gPSByZWNvcmRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHRyYWNraW5nIGludGVybmFsSWRzLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbWFwIHRvIHBvaW50IHRvIHRoZSBuZXcgcmVjb3JkXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSByYXcgb2JqZWN0XG4gICAgICAgICAgICBpZiAobWUudHJhY2tJbnRlcm5hbElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBtZS5nZXRJbnRlcm5hbEtleShyZWNvcmQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbEtleSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5pbnRlcm5hbElkTWFwLnNldChpbnRlcm5hbEtleSwgcmVjb3JkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkLCB3ZSBtdXN0IGFsc28gdXBkYXRlIHRoZSBtYXN0ZXIgJ2FsbEl0ZW1zJyBjb2xsZWN0aW9uXG4gICAgICAgICAgICBpZiAobWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXN0ZXJJbmRleCA9IG1lLmFsbEl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5tYXAuc2V0KHBrLCByZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5faXRlbXNbbWFzdGVySW5kZXhdID0gcmVjb3JkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5hbGxJdGVtcy50cmFja0ludGVybmFsSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gbWUuZ2V0SW50ZXJuYWxLZXkocmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zLmludGVybmFsSWRNYXAuc2V0KGludGVybmFsS2V5LCByZWNvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0gLy8gQWxyZWFkeSBhIHJlY29yZCBvciBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpnZXRBdCgpIHRvIGVuc3VyZSB0aGUgcmV0dXJuZWQgaXRlbSBpcyBhIFJlY29yZCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRBdChpbmRleCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gc3VwZXIuZ2V0QXQoaW5kZXgpOyAvLyBHZXQgaXRlbSBmcm9tIENvbGxlY3Rpb24uQmFzZSAoY291bGQgYmUgcmF3IGRhdGEpXG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcmF3IGRhdGEgd2l0aCB0aGUgcmVjb3JkIGluc3RhbmNlIGluIHRoZSBjdXJyZW50IChmaWx0ZXJlZCkgY29sbGVjdGlvblxuICAgICAgICAgICAgbWUubWFwLnNldChyZWNvcmRbbWUua2V5UHJvcGVydHldLCByZWNvcmQpO1xuICAgICAgICAgICAgbWUuX2l0ZW1zW2luZGV4XSA9IHJlY29yZDtcblxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHRyYWNraW5nIGludGVybmFsSWRzLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbWFwIHRvIHBvaW50IHRvIHRoZSBuZXcgcmVjb3JkXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSByYXcgb2JqZWN0XG4gICAgICAgICAgICBpZiAobWUudHJhY2tJbnRlcm5hbElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBtZS5nZXRJbnRlcm5hbEtleShyZWNvcmQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbEtleSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5pbnRlcm5hbElkTWFwLnNldChpbnRlcm5hbEtleSwgcmVjb3JkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkLCB3ZSBtdXN0IGFsc28gdXBkYXRlIHRoZSBtYXN0ZXIgJ2FsbEl0ZW1zJyBjb2xsZWN0aW9uXG4gICAgICAgICAgICBpZiAobWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXN0ZXJJbmRleCA9IG1lLmFsbEl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5tYXAuc2V0KHJlY29yZFttZS5rZXlQcm9wZXJ0eV0sIHJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zLl9pdGVtc1ttYXN0ZXJJbmRleF0gPSByZWNvcmQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmFsbEl0ZW1zLnRyYWNrSW50ZXJuYWxJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBtZS5nZXRJbnRlcm5hbEtleShyZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuYWxsSXRlbXMuaW50ZXJuYWxJZE1hcC5zZXQoaW50ZXJuYWxLZXksIHJlY29yZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbSAvLyBBbHJlYWR5IGEgcmVjb3JkIG9yIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc3RhYmxlIGludGVybmFsIElEIG9mIGFuIGl0ZW0uXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuUmVjb3JkfSBpdGVtXG4gICAgICogQHJldHVybnMge1N0cmluZ30gZS5nLiAnbmVvLXJlY29yZC0xJ1xuICAgICAqL1xuICAgIGdldEludGVybmFsSWQoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW1baW50ZXJuYWxJZF0pIHtcbiAgICAgICAgICAgIGl0ZW1baW50ZXJuYWxJZF0gPSBOZW8uZ2V0SWQoJ3JlY29yZCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbVtpbnRlcm5hbElkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvb2sgdG8gZ2V0IHRoZSBpbnRlcm5hbCBrZXkgb2YgYW4gaXRlbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0SW50ZXJuYWxLZXkoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbVtpbnRlcm5hbElkXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0S2V5UHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleVByb3BlcnR5IHx8IHRoaXMubW9kZWwua2V5UHJvcGVydHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBjaGVjayBmb3IgaW50IGJhc2VkIGtleVByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IGxvd2VyY2FzZSB2YWx1ZSBvZiB0aGUgbW9kZWwgZmllbGQgdHlwZVxuICAgICAqL1xuICAgIGdldEtleVR5cGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW9kZWx9ICA9IG1lLFxuICAgICAgICAgICAga2V5RmllbGQgPSBtb2RlbD8uZ2V0RmllbGQobWUuZ2V0S2V5UHJvcGVydHkoKSk7XG5cbiAgICAgICAgcmV0dXJuIGtleUZpZWxkPy50eXBlPy50b0xvd2VyQ2FzZSgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRhdGEgb2JqZWN0IGludG8gYSBSZWNvcmQgaW5zdGFuY2Ugb3IgcmV0dXJucyBpdCBpZiBpdCBpcyBhbHJlYWR5IG9uZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgYWRkKCkgYW5kIGluc2VydCgpIHdoZW4gaW5pdD10cnVlIChkZWZhdWx0KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3Qgb3IgUmVjb3JkIGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIFJlY29yZCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGluaXRSZWNvcmQoZGF0YSkge1xuICAgICAgICBpZiAoUmVjb3JkRmFjdG9yeS5pc1JlY29yZChkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLmdldEtleShkYXRhKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOiBpbnNlcnQoKSB0byBjb252ZXJ0IGl0ZW1zIGludG8gcmVjb3JkcyBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiAqKkVhZ2VyIE1vZGUgKGBpbml0PXRydWVgIC0gRGVmYXVsdCk6KipcbiAgICAgKiBJbW1lZGlhdGVseSBjb252ZXJ0cyByYXcgZGF0YSBpbnRvIGBOZW8uZGF0YS5Nb2RlbGAgaW5zdGFuY2VzLlxuICAgICAqIFJldHVybnMgYW4gYEFycmF5YCBvZiB0aGUgY3JlYXRlZCByZWNvcmRzLlxuICAgICAqXG4gICAgICogKipMYXp5IE1vZGUgKGBpbml0PWZhbHNlYCk6KipcbiAgICAgKiBJbnNlcnRzIHJhdyBkYXRhIGRpcmVjdGx5LiBJbnN0YW50aWF0ZXMgcmVjb3JkcyBvbmx5IG9uIGFjY2Vzcy5cbiAgICAgKiBSZXR1cm5zIGFuIGBBcnJheWAgb2YgdGhlIGluc2VydGVkIHJhdyBkYXRhIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBhdFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHNdIFRydWUgdG8gcmV0dXJuIHRoZSBjcmVhdGVkIHJlY29yZHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W118TmVvLmRhdGEuTW9kZWxbXX0gVGhlIGluc2VydGVkIHJhdyBpdGVtcyBvciBjcmVhdGVkIHJlY29yZHNcbiAgICAgKi9cbiAgICBpbnNlcnQoaW5kZXgsIGl0ZW0sIGluaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHMpIHtcbiAgICAgICAgbGV0IG1lICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zID0gc3VwZXIuaW5zZXJ0KGluZGV4LCBpdGVtKTtcblxuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChpID0+IG1lLmdldChtZS5nZXRLZXkoaSkpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuaGVhZGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLm1ldGhvZCBERUxFVEUsIEdFVCwgUE9TVCwgUFVUXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucmVzcG9uc2VUeXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy51cmxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8T2JqZWN0W10+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkKG9wdHM9e30pIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJhbXMgPSB7cGFnZTogbWUuY3VycmVudFBhZ2UsIHBhZ2VTaXplOiBtZS5wYWdlU2l6ZSwgLi4ub3B0cy5wYXJhbXN9O1xuXG4gICAgICAgIGlmIChtZS5yZW1vdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIHBhcmFtcy5maWx0ZXJzID0gbWUuZXhwb3J0RmlsdGVycygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUucmVtb3RlU29ydCkge1xuICAgICAgICAgICAgcGFyYW1zLnNvcnRlcnMgPSBtZS5leHBvcnRTb3J0ZXJzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5hcGkpIHtcbiAgICAgICAgICAgIGxldCBhcGlBcnJheSA9IG1lLmFwaS5yZWFkLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgZm4gICAgICAgPSBhcGlBcnJheS5wb3AoKSxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlICA9IE5lby5ucyhhcGlBcnJheS5qb2luKCcuJykpO1xuXG4gICAgICAgICAgICBpZiAoIXNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBcGkgaXMgbm90IGRlZmluZWQnLCB0aGlzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1lLnRyYXAoc2VydmljZVtmbl0ocGFyYW1zKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBtZS50b3RhbENvdW50ID0gcmVzcG9uc2UudG90YWxDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgbWUuZGF0YSAgICAgICA9IE5lby5ucyhtZS5yZXNwb25zZVJvb3QsIGZhbHNlLCByZXNwb25zZSk7IC8vIGZpcmVzIHRoZSBsb2FkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzTG9hZGVkICAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5kYXRhXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtZS5wcm94eSkge1xuICAgICAgICAgICAgaWYgKG1lLml0ZW1zLmxlbmd0aCA+IDAgJiYgIW9wdHMuYXBwZW5kKSB7XG4gICAgICAgICAgICAgICAgbWUuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWUuaXNMb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgY29uc3Qgb25EYXRhID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5hZGQoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9ncmVzc2l2ZSBSZW5kZXJpbmc6XG4gICAgICAgICAgICAgICAgLy8gQXMgc29vbiBhcyB3ZSBoYXZlIGRhdGEsIHdlIHdhbnQgdGhlIGdyaWQgdG8gcmVuZGVyLlxuICAgICAgICAgICAgICAgIGlmIChtZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNMb2FkaW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byBmaXJlIGEgbG9hZCBldmVudCBoZXJlLCBzaW5jZSBvbkNvbGxlY3Rpb25NdXRhdGUgd2lsbCBoYW5kbGUgdGhpcy5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IG9uUHJvZ3Jlc3MgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ3Byb2dyZXNzJywgZGF0YSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1lLnByb3h5Lm9uKHtcbiAgICAgICAgICAgICAgICBkYXRhICAgIDogb25EYXRhLFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiBvblByb2dyZXNzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBwYXJhbXMudXJsIGNhbiBvdmVycmlkZSBwcm94eSB1cmxcbiAgICAgICAgICAgICAgICBpZiAob3B0cy51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IG9wdHMudXJsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWUucHJveHkucmVhZChwYXJhbXMpO1xuXG4gICAgICAgICAgICAgICAgbWUucHJveHkudW4oe1xuICAgICAgICAgICAgICAgICAgICBkYXRhICAgIDogb25EYXRhLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogb25Qcm9ncmVzc1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUudG90YWxDb3VudCA9IHJlc3BvbnNlLnRvdGFsQ291bnQgfHwgbWUuY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzTG9hZGVkICAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5pc0xvYWRpbmcgID0gZmFsc2U7IC8vIEVuc3VyZSBpdCdzIGZhbHNlIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTG9hZGluZyAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgICAgICAgIDogbWUuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0Q2h1bmtMb2FkOiBtZS5wcm94eT8ubnR5cGUgPT09ICdwcm94eS1zdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgICAgICAgIDogbWUudG90YWxDb3VudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLml0ZW1zXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG1lLnByb3h5LnVuKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSAgICA6IG9uRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IG9uUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZS5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRzLnVybCA/Pz0gbWUudXJsO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1icm93c2VyIGJhc2VkIGVudnMgbGlrZSBub2RlanNcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsVGhpcy5wcm9jZXNzPy5yZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVhZEZpbGUgfSA9IGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovICdmcy9wcm9taXNlcycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgbWUudHJhcChyZWFkRmlsZShvcHRzLnVybCwgJ3V0Zi04JykpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge2pzb246IEpTT04ucGFyc2UoY29udGVudCl9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCBtZS50cmFwKE5lby5YaHIucHJvbWlzZUpzb24ob3B0cykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRhdGEgPSBOZW8ubnMobWUucmVzcG9uc2VSb290LCBmYWxzZSwgZGF0YS5qc29uKSB8fCBkYXRhLmpzb24gLy8gZmlyZXMgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5pc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YT8uanNvbiB8fCBudWxsXG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgPT09IE5lby5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmb3IgTmVvLlhoci5yZXF1ZXN0Jywge2lkOiBtZS5pZCwgZXJyb3I6IGVyciwgdXJsOiBvcHRzLnVybH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIG9uQ29sbGVjdGlvbk11dGF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzQ29uc3RydWN0ZWQgJiYgIW1lLmlzTG9hZGluZykge1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdENodW5rID0gb3B0cy5hZGRlZEl0ZW1zICYmIG1lLmNvdW50ID09PSBvcHRzLmFkZGVkSXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBtZS5maXJlKCdsb2FkJywge1xuICAgICAgICAgICAgICAgIGlzTG9hZGluZyAgICA6ICEhbWUuaXNTdHJlYW1pbmcsXG4gICAgICAgICAgICAgICAgaXRlbXMgICAgICAgIDogbWUuaXRlbXMsXG4gICAgICAgICAgICAgICAgcG9zdENodW5rTG9hZDogISFtZS5pc1N0cmVhbWluZyAmJiAhaXNGaXJzdENodW5rLFxuICAgICAgICAgICAgICAgIHRvdGFsICAgICAgICA6IG1lLmNodW5raW5nVG90YWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbGxlY3Rpb25Tb3J0KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdsb2FkJywge2l0ZW1zOiBtZS5pdGVtc30pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5kYXRhKSB7XG4gICAgICAgICAgICBtZS5hZnRlclNldERhdGEobWUuZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlaW5nIGNvbnN0cnVjdGVkIGRvZXMgbm90IG1lYW4gdGhhdCByZWxhdGVkIGFmdGVyU2V0U3RvcmUoKSBtZXRob2RzIGdvdCBleGVjdXRlZFxuICAgICAgICAvLyA9PiBicmVhayB0aGUgc3luYyBmbG93IHRvIGVuc3VyZSBwb3RlbnRpYWwgbGlzdGVuZXJzIGdvdCBhcHBsaWVkXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lLmlzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXN9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5hdXRvTG9hZCkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRmlsdGVyQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucmVtb3RlRmlsdGVyKSB7XG4gICAgICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICBtZS5sb2FkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLm9uRmlsdGVyQ2hhbmdlKG9wdHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBvblJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVjb3JkQ2hhbmdlJywge1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4T2YoZGF0YS5yZWNvcmQpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e31cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5kaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5wcm9wZXJ0eVxuICAgICAqL1xuICAgIHNvcnQob3B0cz17fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBpZiAobWUuY29uZmlnc0FwcGxpZWQpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRlcnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IG9wdHMuZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA6IG9wdHMucHJvcGVydHlcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLnJlbW90ZVNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc29ydGVycyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdBU0MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgOiBpbml0aWFsSW5kZXhTeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmRvU29ydCgpIHRvIGhhbmRsZSBcIlR1cmJvIE1vZGVcIiAoYXV0b0luaXRSZWNvcmRzOiBmYWxzZSkuXG4gICAgICogSW4gdGhpcyBtb2RlLCBpdGVtcyBhcmUgcmF3IG9iamVjdHMgd2hpY2ggbWF5IGxhY2sgdGhlIGNhbm9uaWNhbCBmaWVsZCBuYW1lcyB1c2VkIGJ5IFNvcnRlcnMuXG4gICAgICogVGhpcyBtZXRob2QgXCJzb2Z0IGh5ZHJhdGVzXCIgdGhlIHJhdyBpdGVtcyBieSByZXNvbHZpbmcgYW5kIGNhY2hpbmcgdGhlIHNvcnQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZG9Tb3J0KGl0ZW1zPXRoaXMuX2l0ZW1zLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmF1dG9Jbml0UmVjb3JkcyAmJiBtZS5tb2RlbD8uaGFzQ29tcGxleEZpZWxkcyAmJiBtZS5zb3J0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgc29ydFByb3BlcnRpZXMgPSBtZS5zb3J0ZXJzLm1hcChzID0+IHMucHJvcGVydHkpLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgICAgICAgID0gc29ydFByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBpdGVtIGlzIG5vdCBhbHJlYWR5IGEgUmVjb3JkIChtaXhlZCBtb2RlIHNhZmV0eSlcbiAgICAgICAgICAgICAgICBpZiAoIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzb3J0UHJvcGVydGllc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXNvbHZlIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nIG9uIHRoZSByYXcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oaXRlbSwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtwcm9wZXJ0eV0gPSBtZS5yZXNvbHZlRmllbGQoaXRlbSwgcHJvcGVydHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZG9Tb3J0KGl0ZW1zLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmaWx0ZXIoKSB0byBoYW5kbGUgXCJUdXJibyBNb2RlXCIgKGF1dG9Jbml0UmVjb3JkczogZmFsc2UpLlxuICAgICAqIEluIHRoaXMgbW9kZSwgaXRlbXMgYXJlIHJhdyBvYmplY3RzIHdoaWNoIG1heSBsYWNrIHRoZSBjYW5vbmljYWwgZmllbGQgbmFtZXMgdXNlZCBieSBGaWx0ZXJzLlxuICAgICAqIFRoaXMgbWV0aG9kIFwic29mdCBoeWRyYXRlc1wiIHRoZSByYXcgaXRlbXMgYnkgcmVzb2x2aW5nIGFuZCBjYWNoaW5nIHRoZSBmaWx0ZXIgdmFsdWVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaWx0ZXIoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5hdXRvSW5pdFJlY29yZHMgJiYgbWUubW9kZWw/Lmhhc0NvbXBsZXhGaWVsZHMgJiYgbWUuZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIGFjdGl2ZUZpbHRlcnMgICAgPSBtZS5maWx0ZXJzLmZpbHRlcihmID0+ICFmLmRpc2FibGVkICYmIGYudmFsdWUgIT09IG51bGwpLFxuICAgICAgICAgICAgICAgIGZpbHRlclByb3BlcnRpZXMgPSBhY3RpdmVGaWx0ZXJzLm1hcChmID0+IGYucHJvcGVydHkpLFxuICAgICAgICAgICAgICAgIGxlbiAgICAgICAgICAgICAgPSBmaWx0ZXJQcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBpdGVyYXRlIG92ZXIgYWxsSXRlbXMgKHVuZmlsdGVyZWQgc291cmNlKSBvciBjdXJyZW50IGl0ZW1zIGRlcGVuZGluZyBvbiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgQ29sbGVjdGlvbi5maWx0ZXIoKSB1c2VzIGFsbEl0ZW1zIGlmIGl0IGV4aXN0cy4gSWRlYWxseSB3ZSBoeWRyYXRlIHRoZSBzb3VyY2UuXG4gICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZWFzaWx5IGtub3cgd2hpY2ggc291cmNlIENvbGxlY3Rpb24uZmlsdGVyIHdpbGwgdXNlIHdpdGhvdXQgZHVwbGljYXRpbmcgbG9naWMsXG4gICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBoeWRyYXRlIGJvdGggaWYgdGhleSBleGlzdCwgb3IganVzdCB0aGUgYWN0aXZlIG9uZS5cbiAgICAgICAgICAgICAgICAvLyBTYWZlc3QgYmV0OiBIeWRyYXRlIHRoZSBzb3VyY2UgdGhhdCBmaWx0ZXIoKSB3aWxsIHVzZS5cbiAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9uLmZpbHRlciB1c2VzOiBpdGVtcyA9IG1lLmFsbEl0ZW1zPy5faXRlbXMgfHwgbWUuX2l0ZW1zXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXNUb0h5ZHJhdGUgPSBtZS5hbGxJdGVtcyA/IG1lLmFsbEl0ZW1zLl9pdGVtcyA6IG1lLl9pdGVtcztcblxuICAgICAgICAgICAgICAgIGl0ZW1zVG9IeWRyYXRlLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gZmlsdGVyUHJvcGVydGllc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihpdGVtLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtwcm9wZXJ0eV0gPSBtZS5yZXNvbHZlRmllbGQoaXRlbSwgcHJvcGVydHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmZpbHRlcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTppc0ZpbHRlcmVkSXRlbSgpIHRvIGhhbmRsZSBcIlR1cmJvIE1vZGVcIiAoYXV0b0luaXRSZWNvcmRzOiBmYWxzZSkuXG4gICAgICogSW4gdGhpcyBtb2RlLCBpdGVtcyBhcmUgcmF3IG9iamVjdHMgd2hpY2ggbWF5IGxhY2sgdGhlIGNhbm9uaWNhbCBmaWVsZCBuYW1lcyB1c2VkIGJ5IEZpbHRlcnMuXG4gICAgICogVGhpcyBtZXRob2QgXCJzb2Z0IGh5ZHJhdGVzXCIgdGhlIHJhdyBpdGVtIGJ5IHJlc29sdmluZyBhbmQgY2FjaGluZyB0aGUgZmlsdGVyIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0ZpbHRlcmVkSXRlbShpdGVtKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5hdXRvSW5pdFJlY29yZHMgJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkgJiYgbWUuZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZS5maWx0ZXJzLmZvckVhY2goZmlsdGVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlci5kaXNhYmxlZCAmJiBmaWx0ZXIudmFsdWUgIT09IG51bGwgJiYgIU9iamVjdC5oYXNPd24oaXRlbSwgZmlsdGVyLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW2ZpbHRlci5wcm9wZXJ0eV0gPSBtZS5yZXNvbHZlRmllbGQoaXRlbSwgZmlsdGVyLnByb3BlcnR5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuaXNGaWx0ZXJlZEl0ZW0oaXRlbSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gcmVzb2x2ZSBhIGZpZWxkIHZhbHVlIGZyb20gYSByYXcgZGF0YSBvYmplY3QgdXNpbmcgdGhlIE1vZGVsIGRlZmluaXRpb24uXG4gICAgICogSGFuZGxlcyBtYXBwaW5nLCBjYWxjdWxhdGUsIGFuZCBjb252ZXJ0LlxuICAgICAqXG4gICAgICogKipMaW1pdGF0aW9ucyAmIFwiVHVyYm8tU2FmZVwiIFJlcXVpcmVtZW50OioqXG4gICAgICogVGhpcyBtZXRob2QgcmVzb2x2ZXMgYSAqc2luZ2xlKiBmaWVsZCBpbiBpc29sYXRpb24uIEl0IGRvZXMgKipub3QqKiByZWN1cnNpdmVseSByZXNvbHZlIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIElmIEZpZWxkIEEgcmVsaWVzIG9uIEZpZWxkIEIgKGUuZy4sIHZpYSBgY2FsY3VsYXRlYCBvciBgY29udmVydGApLCBhbmQgRmllbGQgQiBpcyBhbHNvIGEgbWFwcGVkL2NhbGN1bGF0ZWQgZmllbGQ6XG4gICAgICogLSAqKk9uIGEgUmVjb3JkOioqIEZpZWxkIEIgaXMgYWNjZXNzaWJsZSB2aWEgaXRzIGdldHRlci5cbiAgICAgKiAtICoqT24gYSBSYXcgT2JqZWN0OioqIEZpZWxkIEIgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBUaGVyZWZvcmUsIE1vZGVsIGxvZ2ljIChjYWxjdWxhdGUvY29udmVydCBmdW5jdGlvbnMpIE1VU1QgYmUgd3JpdHRlbiB0byBiZSBcIlR1cmJvLVNhZmVcIiAvIFwiUG9seW1vcnBoaWNcIi5cbiAgICAgKiBUaGV5IG11c3QgY2hlY2sgZm9yIGJvdGggdGhlIGNhbm9uaWNhbCBmaWVsZCBuYW1lIChmb3IgUmVjb3JkcykgQU5EIHRoZSByYXcgZGF0YSBrZXkgKGZvciBUdXJibyBNb2RlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY2FsY3VsYXRlOiBkYXRhID0+IChkYXRhLm1hcHBlZE5hbWUgfHwgZGF0YS5yYXdLZXkpICsgMVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHJhdyBkYXRhIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWUgVGhlIGNhbm9uaWNhbCBmaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMgeyp9IFRoZSByZXNvbHZlZCB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZXNvbHZlRmllbGQoaXRlbSwgZmllbGROYW1lKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBmaWVsZCA9IG1lLm1vZGVsLmdldEZpZWxkKGZpZWxkTmFtZSksXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSAmJiBmaWVsZC5kZXBlbmRzKSB7XG4gICAgICAgICAgICBsZXQgZGVwcyA9IGZpZWxkLmRlcGVuZHMsXG4gICAgICAgICAgICAgICAgaSAgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuICA9IGRlcHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGRlcDtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1bZGVwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bZGVwXSA9IG1lLnJlc29sdmVGaWVsZChpdGVtLCBkZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWVsZC5jYWxjdWxhdGUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuY2FsY3VsYXRlKGl0ZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgTWFwcGluZ1xuICAgICAgICAgICAgaWYgKGZpZWxkLm1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnMgICAgID0gZmllbGQubWFwcGluZy5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgICAgICBrZXkgICAgPSBucy5wb3AoKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbnMubGVuZ3RoID4gMCA/IE5lby5ucyhucywgZmFsc2UsIGl0ZW0pIDogaXRlbTtcblxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgJiYgT2JqZWN0Lmhhc093bihzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtW2ZpZWxkTmFtZV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIENvbnZlcnRcbiAgICAgICAgICAgIGlmIChmaWVsZC5jb252ZXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC5jb252ZXJ0KHZhbHVlLCBpdGVtKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgRGVmYXVsdCBWYWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgT2JqZWN0Lmhhc093bihmaWVsZCwgJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBOZW8uaXNGdW5jdGlvbihmaWVsZC5kZWZhdWx0VmFsdWUpID8gZmllbGQuZGVmYXVsdFZhbHVlKCkgOiBmaWVsZC5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgaXRlbVtmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUga2V5IG9mIGEgZ2l2ZW4gaXRlbSwgc3VwcG9ydGluZyBib3RoIHJhdyBkYXRhIG9iamVjdHMgYW5kIFJlY29yZCBpbnN0YW5jZXMuXG4gICAgICogVGhpcyBoYW5kbGVzIHRoZSBlZGdlIGNhc2Ugd2hlcmUgYGtleVByb3BlcnR5YCByZWZlcnMgdG8gYSBtYXBwZWQgc291cmNlIGtleSAoZS5nLiAnbCcpXG4gICAgICogd2hpY2ggZXhpc3RzIG9uIHRoZSByYXcgb2JqZWN0IGJ1dCBub3Qgb24gdGhlIFJlY29yZCBpbnN0YW5jZSAod2hlcmUgaXQgaXMgbWFwcGVkIHRvIGUuZy4gJ2xvZ2luJykuXG4gICAgICogQHBhcmFtIHtPYmplY3R8TmVvLmRhdGEuUmVjb3JkfSBpdGVtXG4gICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0S2V5KGl0ZW0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleVByb3BlcnR5ID0gbWUuZ2V0S2V5UHJvcGVydHkoKSxcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmIChSZWNvcmRGYWN0b3J5LmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5nZXQoa2V5UHJvcGVydHkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5UHJvcGVydHkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBOZW8ubnMoa2V5UHJvcGVydHksIGZhbHNlLCBpdGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBpdGVtW2tleVByb3BlcnR5XVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgZGlyZWN0IGFjY2VzcyBmYWlsZWQsIGNoZWNrIGZvciBtYXBwaW5nIChSZXZlcnNlIExvb2t1cClcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgbWUubW9kZWwpIHtcbiAgICAgICAgICAgIGxldCBmaWVsZCA9IG1lLm1vZGVsLmdldEZpZWxkKGtleVByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChmaWVsZD8ubWFwcGluZykge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwaW5nID0gZmllbGQubWFwcGluZztcbiAgICAgICAgICAgICAgICBpZiAobWFwcGluZy5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTmVvLm5zKG1hcHBpbmcsIGZhbHNlLCBpdGVtKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRlbVttYXBwaW5nXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgYXV0b0luaXRSZWNvcmRzIDogbWUuYXV0b0luaXRSZWNvcmRzLFxuICAgICAgICAgICAgYXV0b0xvYWQgICAgICAgIDogbWUuYXV0b0xvYWQsXG4gICAgICAgICAgICBjdXJyZW50UGFnZSAgICAgOiBtZS5jdXJyZW50UGFnZSxcbiAgICAgICAgICAgIGluaXRpYWxDaHVua1NpemU6IG1lLmluaXRpYWxDaHVua1NpemUsXG4gICAgICAgICAgICBpc0dyb3VwZWQgICAgICAgOiBtZS5pc0dyb3VwZWQsXG4gICAgICAgICAgICBpc0xvYWRlZCAgICAgICAgOiBtZS5pc0xvYWRlZCxcbiAgICAgICAgICAgIGlzTG9hZGluZyAgICAgICA6IG1lLmlzTG9hZGluZyxcbiAgICAgICAgICAgIG1vZGVsICAgICAgICAgICA6IG1lLm1vZGVsPy50b0pTT04oKSxcbiAgICAgICAgICAgIHBhZ2VTaXplICAgICAgICA6IG1lLnBhZ2VTaXplLFxuICAgICAgICAgICAgcmVtb3RlRmlsdGVyICAgIDogbWUucmVtb3RlRmlsdGVyLFxuICAgICAgICAgICAgcmVtb3RlU29ydCAgICAgIDogbWUucmVtb3RlU29ydCxcbiAgICAgICAgICAgIHRvdGFsQ291bnQgICAgICA6IG1lLnRvdGFsQ291bnQsXG4gICAgICAgICAgICB1cmwgICAgICAgICAgICAgOiBtZS51cmxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3RvcmUpO1xuIiwiaW1wb3J0IE1hbmFnZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5tYW5hZ2VyLlN0b3JlXG4gKiBAZXh0ZW5kcyBOZW8ubWFuYWdlci5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFN0b3JlIGV4dGVuZHMgTWFuYWdlciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ubWFuYWdlci5TdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLm1hbmFnZXIuU3RvcmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIFxuICAgICAgICAvLyBBbGlhcyBOZW8uZ2V0U3RvcmUgdG8gdGhpcyBtYW5hZ2VyP1xuICAgICAgICAvLyBOZW8uZ2V0U3RvcmUgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3RvcmUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9