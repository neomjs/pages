export const __webpack_esm_id__ = "vendors-src_data_Store_mjs";
export const __webpack_esm_ids__ = ["vendors-src_data_Store_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/data/Model.mjs"
/*!****************************!*\
  !*** ./src/data/Model.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");




/**
 * @class Neo.data.Model
 * @extends Neo.core.Base
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.Model'
         * @protected
         */
        className: 'Neo.data.Model',
        /**
         * @member {String} ntype='model'
         * @protected
         */
        ntype: 'model',
        /**
         * @member {Object[]|null} fields_
         * @reactive
         */
        fields_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__.isDescriptor]: true,
            merge         : 'deepArrays',
            value         : null
        },
        /**
         * @member {String} keyProperty_='id'
         * @reactive
         */
        keyProperty_: 'id',
        /**
         * @member {String|null} storeId=null
         * @protected
         */
        storeId: null,
        /**
         * Set this config to true in case you want to track modified fields.
         * Be aware that this will double the amount of data inside each record,
         * since each field will get an original value flag.
         * @member {Boolean} trackModifiedFields=false
         */
        trackModifiedFields: false
    }

    /**
     * Internally storing all fields, which have a calculate property
     * @member {Map} calculatedFieldsMap=new Map()
     * @protected
     */
    calculatedFieldsMap = new Map()
    /**
     * Internally storing all fields inside a flat map => nested fields included
     * @member {Map} fieldsMap=new Map()
     * @protected
     */
    fieldsMap = new Map()
    /**
     * @member {Boolean} hasNestedFields=false
     * @protected
     */
    hasNestedFields = false

    /**
     Triggered after the fields config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetFields(value, oldValue) {
        if (value) {
            let me = this;

            me.updateFieldsMap(value);

            // Fields can get changed multiple times before the model instance is getting constructed.
            // We only need the latest state before construction & honor run-time changes.
            if (me.isConstructed) {
                _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createRecordClass(me, true)
            }
        }
    }

    /**
     * Finds a field config by a given field name
     * @param {String} name
     * @returns {Object|null} The field config object or null if no match was found
     */
    getField(name) {
        return this.fieldsMap.get(name) || null
    }

    /**
     * Finds a field type by a given field name
     * @param {String} name
     * @returns {String|null} The lowercase field type or null if no match was found
     */
    getFieldType(name) {
        return this.getField(name)?.type?.toLowerCase() || null
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            fields             : me.serializeConfig(me.fields),
            keyProperty        : me.keyProperty,
            storeId            : me.storeId,
            trackModifiedFields: me.trackModifiedFields
        }
    }

    /**
     * @param {Object[]} fields
     * @param {Boolean} isRoot=true
     * @param {String} path=''
     */
    updateFieldsMap(fields, isRoot=true, path='') {
        let me = this,
            {calculatedFieldsMap, fieldsMap} = me,
            fieldName;

        if (isRoot) {
            calculatedFieldsMap.clear();
            fieldsMap.clear();
            me.hasNestedFields = false
        }

        fields.forEach(field => {
            fieldName = path + field.name

            if (field.fields) {
                me.hasNestedFields = true;
                me.updateFieldsMap(field.fields, false, field.name + '.')
            } else {
                fieldsMap.set(fieldName, field);

                if (field.calculate) {
                    calculatedFieldsMap.set(fieldName, field)
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/data/RecordFactory.mjs"
/*!************************************!*\
  !*** ./src/data/RecordFactory.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");



const
    dataSymbol         = Symbol.for('data'),
    initialIndexSymbol = Symbol.for('initialIndex'),
    isModifiedSymbol   = Symbol.for('isModified'),
    originalDataSymbol = Symbol.for('originalData');

let instance;

/**
 * @class Neo.data.RecordFactory
 * @extends Neo.core.Base
 * @singleton
 */
class RecordFactory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.RecordFactory'
         * @protected
         */
        className: 'Neo.data.RecordFactory',
        /**
         * @member {String} recordNamespace='Neo.data.record'
         */
        recordNamespace: 'Neo.data.record',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Assigns model-based default values to a data object
     * @param {Object}         data
     * @param {Neo.data.Model} model
     * @returns {Object}
     */
    assignDefaultValues(data, model) {
        model.fieldsMap.forEach((field, fieldName) => {
            if (Object.hasOwn(field, 'defaultValue')) {
                const defaultValue = Neo.isFunction(field.defaultValue) ? field.defaultValue() : field.defaultValue;

                // We could always use Neo.assignToNs() => the check is just for improving the performance
                if (model.hasNestedFields) {
                    Neo.assignToNs(fieldName, defaultValue, data, false)
                } else if (data[fieldName] === undefined) {
                    data[fieldName] = defaultValue
                }
            }
        });

        return data
    }

    /**
     * @param {Object} data
     * @param {Object} data.field
     * @param {Neo.data.Model} data.model
     * @param {String} data.path=''
     * @param {Object} data.proto
     */
    createField({field, model, path='', proto}) {
        let fieldName = field.name,
            fieldPath = path === '' ? fieldName : `${path}.${fieldName}`,
            properties;

        if (field.fields) {
            field.fields.forEach(childField => {
                this.createField({field: childField, model, path: fieldPath, proto})
            })
        } else {
            properties = {
                [fieldPath]: {
                    configurable: true,
                    enumerable  : true,
                    get() {
                        if (model.hasNestedFields) {
                            return Neo.ns(fieldPath, false, this[dataSymbol])
                        }

                        return this[dataSymbol][fieldName]
                    },
                    set(value) {
                        this.notifyChange({
                            fields: {[fieldPath]: instance.parseRecordValue({record: this, field, value})},
                            model,
                            record: this
                        })
                    }
                }
            };

            Object.defineProperties(proto, properties)
        }
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Object} config
     * @returns {Object}
     */
    createRecord(model, config) {
        let recordClass = Neo.ns(`${this.recordNamespace}.${model.className}.${model.id}`);

        if (!recordClass) {
            recordClass = this.createRecordClass(model)
        }

        return new recordClass(config)
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Boolean} overwrite=false
     * @returns {Object}
     */
    createRecordClass(model, overwrite=false) {
        if (model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            let className = `${this.recordNamespace}.${model.className}.${model.id}`,
                ns        = Neo.ns(className),
                key, nsArray, cls;

            if (!ns || overwrite) {
                nsArray = className.split('.');
                key     = nsArray.pop();
                ns      = Neo.ns(nsArray, true);
                cls     = ns[key] = class Record {
                    // We do not want to minify the ctor class name in dist/production
                    static name = 'Record';

                    [dataSymbol]         = {};
                    [initialIndexSymbol] = null

                    get isModified() {
                        let me = this;

                        if (model.trackModifiedFields) {
                            return !Neo.isEqual(me[dataSymbol], me[originalDataSymbol])
                        }

                        return me[isModifiedSymbol]
                    }

                    /**
                     * @param {Object} config
                     */
                    constructor(config) {
                        let me = this;

                        if (Object.hasOwn(config, initialIndexSymbol)) {
                            me[initialIndexSymbol] = config[initialIndexSymbol];
                            delete config[initialIndexSymbol]
                        }

                        config = instance.assignDefaultValues(config, model);

                        if (model.trackModifiedFields) {
                            me[originalDataSymbol] = {};
                            me.setOriginal(config)
                        } else {
                            me[isModifiedSymbol] = false
                        }

                        me.setSilent(config) // We do not want to fire change events when constructing
                    }

                    /**
                     * @param {String} fieldName
                     * @returns {Boolean|null} null in case the model does not use trackModifiedFields, true in case a change was found
                     */
                    isModifiedField(fieldName) {
                        let me = this;

                        if (model.trackModifiedFields) {
                            let dataScope, originalDataScope;

                            if (model.hasNestedFields && fieldName?.includes('.')) {
                                let nsArray = fieldName.split('.');

                                fieldName         = nsArray.pop();
                                dataScope         = Neo.ns(nsArray, false, me[dataSymbol]);
                                originalDataScope = Neo.ns(nsArray, false, me[originalDataSymbol])
                            } else {
                                dataScope         = me[dataSymbol];
                                originalDataScope = me[originalDataSymbol]
                            }

                            // Check if the field exists
                            if (
                                !model.getField(fieldName) &&        // Check for leaf fields (could be excluded inside the real data)
                                !Object.hasOwn(dataScope, fieldName) // Check the data tree
                            ) {
                                console.error('The record does not contain the field', fieldName, me)
                            }

                            return !Neo.isEqual(dataScope[fieldName], originalDataScope[fieldName])
                        }

                        return null
                    }

                    /**
                     * The single source of truth for record field changes.
                     * Executes instance.setRecordFields(), and can get used via:
                     * - Neo.util.Function:createSequence()
                     * - Neo.util.Function:intercept(),
                     * to "listen" to field changes
                     * @param {Object}         data
                     * @param {Object}         data.fields
                     * @param {Neo.data.Model} data.model
                     * @param {Object}         data.record
                     * @param {Boolean}        silent=false
                     * @returns {Object}
                     */
                    notifyChange(data, silent=false) {
                        const param = {...data, silent}
                        instance.setRecordFields(param);
                        return param
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    reset(fields) {
                        this.setOriginal(fields);
                        this.set(fields)
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    set(fields) {
                        this.notifyChange({fields, model, record: this})
                    }

                    /**
                     * If the model uses trackModifiedFields, we will store the original data
                     * for tracking the dirty state (changed fields)
                     * @param {Object} fields
                     * @protected
                     */
                    setOriginal(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true, useOriginalData: true})
                    }

                    /**
                     * Bulk-update multiple record fields at once without triggering a change event
                     * @param {Object} fields
                     */
                    setSilent(fields) {
                        this.notifyChange({fields, model, record: this}, true)
                    }

                    /**
                     * When using JSON.stringify(this), we want to get the raw data
                     * @returns {Object}
                     */
                    toJSON() {
                        return structuredClone(this[dataSymbol])
                    }
                };

                if (Array.isArray(model.fields)) {
                    model.fields.forEach(field => {
                        instance.createField({field, model, proto: cls.prototype})
                    })
                }

                Object.defineProperty(cls.prototype, 'isRecord', {value: true});
                Object.defineProperty(cls, 'isClass', {value: true});

                return ns[key]
            }

            return ns
        }
    }

    /**
     * Tests if a given object is an instance of a class created by this factory
     * @param {Object} record
     * @returns {Boolean}
     */
    isRecord(record) {
        return record?.isRecord || false
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onRecordChange(opts) {
        Neo.get(opts.model.storeId)?.onRecordChange(opts)
    }

    /**
     * @param {Object}  data
     * @param {Object}  data.record
     * @param {Object}  data.field
     * @param {*}       [data.value=null]
     * @param {Object}  [data.recordConfig=null]
     * @param {Boolean} [data.useOriginalData=false]
     * @returns {*}
     */
    parseRecordValue({record, field, value=null, recordConfig=null, useOriginalData=false}) {
        if (field.calculate) {
            return field.calculate(record[useOriginalData ? originalDataSymbol : dataSymbol], field)
        }

        if (field.convert) {
            value = field.convert(value, record)
        }

        let fieldName = field.name,
            {mapping, maxLength, minLength, nullable} = field,
            oldValue  = recordConfig?.[fieldName] || record[fieldName],
            type      = field.type?.toLowerCase();

        // only trigger mappings for initial values
        // dynamic changes of a field will not pass the recordConfig
        if (mapping && recordConfig) {
            let ns  = mapping.split('.'),
                key = ns.pop();

            ns    = Neo.ns(ns, true, recordConfig);
            value = ns[key]
        }

        if (Object.hasOwn(field, 'maxLength')) {
            if (value?.toString().length > maxLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with maxLength: ${maxLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'minLength')) {
            if (value?.toString().length < minLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with minLength: ${minLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'nullable')) {
            if (nullable === false && value === null) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with nullable: ${nullable}`);
                return oldValue
            }
        }

        if (type === 'date' && Neo.typeOf(value) !== 'Date') {
            return new Date(value)
        }

        else if (type === 'float' && value) {
            value = parseFloat(value)
        }

        else if (type === 'html' && value) {
            value = value + ''
        }

        else if ((type === 'int' || type === 'integer') && value) {
            value = parseInt(value)
        }

        else if (type === 'string' && value) {
            value = value + '';
            value =  value.replace(/(<([^>]+)>)/ig, '')
        }

        return value
    }

    /**
     * @param {Object}         data
     * @param {String}         data.fieldName
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     * @param {*}              data.value
     * @protected
     */
    setRecordData({fieldName, model, record, useOriginalData=false, value}) {
        if (useOriginalData && !model.trackModifiedFields) {
            return
        }

        let scope = useOriginalData ? originalDataSymbol : dataSymbol;

        if (model.hasNestedFields && fieldName.includes('.')) {
            let ns, nsArray;

            nsArray   = fieldName.split('.');
            fieldName = nsArray.pop();
            ns        = Neo.ns(nsArray, true, record[scope]);

            ns[fieldName] = value
        } else {
            record[scope][fieldName] = value
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.changedFields=[] Internal flag
     * @param {Object}         data.fields
     * @param {Neo.data.Model} data.model
     * @param {Object}         data.record
     * @param {Boolean}        data.silent=false
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     */
    setRecordFields({changedFields=[], fields, model, record, silent=false, useOriginalData=false}) {
        let me = this,
            {calculatedFieldsMap, fieldsMap, trackModifiedFields} = model,
            fieldExists, hasChangedFields, oldValue;

        if (!trackModifiedFields && useOriginalData) {
            return
        }

        Object.entries(fields).forEach(([key, value]) => {
            fieldExists = fieldsMap.has(key);

            if (Neo.isObject(value) && !fieldExists) {
                Object.entries(value).forEach(([childKey, childValue]) => {
                    me.setRecordFields({
                        changedFields,
                        fields: {[`${key}.${childKey}`]: childValue},
                        model,
                        record,
                        silent: true,
                        useOriginalData
                    })
                })
            } else if (fieldExists) {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), value});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    if (!trackModifiedFields && !useOriginalData) {
                        record[isModifiedSymbol] = true
                    }

                    changedFields.push({name: key, oldValue, value})
                }
            }
        });

        hasChangedFields = Object.keys(changedFields).length > 0;

        if (hasChangedFields) {
            calculatedFieldsMap.forEach((value, key) => {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), useOriginalData});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    changedFields.push({name: key, oldValue, value})
                }
            })
        }

        if (!silent && !useOriginalData && hasChangedFields) {
            me.onRecordChange({fields: changedFields, model, record})
        }
    }
}

instance = Neo.setupClass(RecordFactory);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ },

/***/ "./src/data/Store.mjs"
/*!****************************!*\
  !*** ./src/data/Store.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");
/* harmony import */ var _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../manager/Store.mjs */ "./src/manager/Store.mjs");







const initialIndexSymbol = Symbol.for('initialIndex');

/**
 * @class Neo.data.Store
 * @extends Neo.collection.Base
 * @mixes Neo.core.Observable
 *
 * @summary A powerful, observable collection that manages a set of data records.
 *
 * Neo.data.Store is the central data management class in the framework. It handles the lifecycle of
 * data records, including loading, filtering, sorting, and synchronization with backend APIs.
 *
 * ### Record Instantiation Strategies: Eager vs. Lazy ("Turbo Mode")
 *
 * The Store supports two distinct strategies for handling record creation, controlled by the `autoInitRecords` config
 * (which defaults to `true`) and the `init` parameter in methods like `add()` and `insert()`.
 *
 * **1. Eager Instantiation (Default: `autoInitRecords: true`)**
 *    - **Behavior**: Raw data objects are immediately converted into `Neo.data.Model` instances.
 *    - **Use Case**: Standard operations, adding single items, interactive edits.
 *    - **Pros**: Returns usable Record instances immediately. High Developer Experience (DX).
 *    - **Cons**: Can be slow for massive datasets (10k+ records).
 *
 * **2. Lazy Instantiation ("Turbo Mode")**
 *    - **Behavior**: Raw data objects are stored directly. `Neo.data.Model` instances are created
 *      "just-in-time" only when they are accessed via `get()`, `getAt()`, or iteration.
 *    - **Use Case**: Bulk loading large datasets (e.g., grids, charts with thousands of points).
 *    - **Pros**: Massive performance gains for initial data load. Enables internal "chunking" to prevent UI freezes.
 *    - **Cons**: `add()` returns a count instead of records. Records are not available until accessed.
 *    - **How to enable**:
 *      - **Global**: Set `autoInitRecords: false` on the Store config.
 *      - **Per-call**: Pass `false` as the second argument to `add()` or `insert()`.
 *      ```javascript
 *      // Global setting
 *      Neo.create(Store, {
 *          autoInitRecords: false,
 *          data: hugeArrayOfData
 *      });
 *
 *      // Per-call override
 *      store.add(hugeArrayOfData, false);
 *      ```
 */
class Store extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.Store'
         * @protected
         */
        className: 'Neo.data.Store',
        /**
         * @member {String} ntype='store'
         * @protected
         */
        ntype: 'store',
        /**
         * Instead of setting an url, you can define the RPC BE API methods.
         * In case the 4 methods are using the same service and this service is using the CRUD based fn-names,
         * you can switch to a string based shortcut.
         * The following 2 examples are equivalent.
         * @example
         * api: {
         *    create : 'MyApp.backend.UserService.create',
         *    destroy: 'MyApp.backend.UserService.destroy',
         *    read   : 'MyApp.backend.UserService.read',
         *    update : 'MyApp.backend.UserService.update'
         * }
         * @example
         * api: 'MyApp.backend.UserService'
         * @member {Object|String|null} api_=null
         * @reactive
         */
        api_: null,
        /**
         * True to automatically create record instances when adding items.
         * Set to false to enable "Turbo Mode" (Lazy Instantiation) globally for this store.
         * @member {Boolean} autoInitRecords=true
         */
        autoInitRecords: true,
        /**
         * @member {Boolean} autoLoad=false
         */
        autoLoad: false,
        /**
         * @member {Number} currentPage_=1
         * @reactive
         */
        currentPage_: 1,
        /**
         * @member {Array|null} data_=null
         * @reactive
         */
        data_: null,
        /**
         * The initial chunk size for adding large datasets. Set to 0 to disable chunking.
         * @member {Number} initialChunkSize=0
         */
        initialChunkSize: 0,
        /**
         * @member {Boolean} isGrouped=false
         */
        isGrouped: false,
        /**
         * @member {Boolean} isLoaded=false
         */
        isLoaded: false,
        /**
         * @member {Boolean} isLoading=false
         */
        isLoading: false,
        /**
         * @member {Neo.data.Model} model_=null
         * @reactive
         */
        model_: null,
        /**
         * Use a value of 0 to not limit the pageSize
         * @member {Number} pageSize_=0
         * @reactive
         */
        pageSize_: 0,
        /**
         * True to let the backend handle the filtering.
         * Useful for buffered stores
         * @member {Boolean} remoteFilter=false
         */
        remoteFilter: false,
        /**
         * True to let the backend handle the sorting.
         * Useful for buffered stores
         * @member {Boolean} remoteSort=false
         */
        remoteSort: false,
        /**
         * Add a path to the root of your data.
         * If the responseRoot is 'data' this is optional.
         * @member {String} responseRoot='data'
         */
        responseRoot: 'data',
        /**
         * @member {Number} totalCount=0
         */
        totalCount: 0,
        /**
         * Url for Ajax requests
         * @member {String|null} url=null
         */
        url: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // todo
        me.on({
            mutate: me.onCollectionMutate,
            sort  : me.onCollectionSort,
            scope : me
        });

        _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].register(me)
    }

    /**
     *
     */
    destroy() {
        _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].unregister(this);

        super.destroy()
    }

    /**
     * Overrides collection.Base: add() to convert items into records if needed.
     *
     * **1. Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **2. Lazy Mode (`init=false`):**
     * Adds raw data directly for maximum performance. Instantiates records only on access.
     *
     * - **Chunking Active**: If `initialChunkSize > 0` and `items.length > threshold`:
     *   Adds items in chunks to prevent blocking the App Worker (Main Actor).
     *   Returns the new collection `count` (Number).
     *
     * - **No Chunking**: If `initialChunkSize === 0` or `items.length <= threshold`:
     *   Adds raw items directly.
     *   Returns an `Array` of the added raw data objects.
     *
     * @example
     * // 1. Default: Get records immediately
     * const [newRecord] = store.add({name: 'New Item'});
     *
     * @example
     * // 2. Turbo Mode (No Chunking): Get raw objects
     * const [rawObject] = store.add({name: 'Item'}, false);
     *
     * @example
     * // 3. Turbo Mode (Chunking): Get new count
     * store.initialChunkSize = 1000;
     * const newCount = store.add(hugeDataArray, false);
     *
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records, false for "Turbo Mode"
     * @returns {Number|Object[]|Neo.data.Model[]} The collection count, raw items, or created records
     */
    add(item, init=this.autoInitRecords) {
        let me        = this,
            items     = Array.isArray(item) ? item : [item],
            threshold = me.initialChunkSize;

        if (init) {
            super.add(items);

            me.isLoaded = true;

            return items.map(i => me.get(i[me.getKeyProperty()]))
        }

        if (threshold > 0 && items.length > threshold) {
            const total = me.count + items.length,
                  chunk = items.splice(0, threshold);

            me.chunkingTotal = total;

            // 1. Add the first chunk. This fires 'mutate' -> 'load' (via onCollectionMutate)
            //    and triggers the initial grid render. The 'load' event will contain the final total count.
            super.add(chunk); // Pass raw chunk directly

            // 2. Suspend events to prevent the next 'add' from firing 'load'.
            me.suspendEvents = true;

            // 3. Add the rest of the items silently.
            super.add(items); // Pass raw items directly

            // 4. Resume events.
            me.suspendEvents = false;

            // 5. Manually fire a final 'load' event to update the grid's scrollbar and notify other listeners.
            me.fire('load', {items: me.items, postChunkLoad: true, total: me.chunkingTotal});

            delete me.chunkingTotal;

            return me.count
        }

        const returnValue = super.add(items);

        // If we use add() initially instead of setting `data`, we need to set the loaded flag here.
        me.isLoaded = true;

        return returnValue // Pass raw item directly
    }

    /**
     * Triggered after the currentPage config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCurrentPage(value, oldValue) {
        oldValue && this.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        let me = this;

        if (me.configsApplied) {
            if (value) {
                if (oldValue) {
                    me.clear()
                }

                me.isLoading = false;

                me.add(value, me.autoInitRecords)
            }
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        super.afterSetFilters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteFilter && me.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetModel(value, oldValue) {
        if (value) {
            value.storeId = this.id
        }
    }

    /**
     * Triggered after the pageSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPageSize(value, oldValue) {
        if (oldValue) {
            this._currentPage = 1; // silent update
            this.load()
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        super.afterSetSorters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteSort && me.load()
    }

    /**
     * @param {Object|String|null} value
     * @param {Object|String|null} oldValue
     * @protected
     * @returns {Object|null}
     */
    beforeSetApi(value, oldValue) {
        if (Neo.typeOf(value) === 'String') {
            value = {
                create : value + '.create',
                destroy: value + '.destroy',
                read   : value + '.read',
                update : value + '.update'
            }
        }

        return value
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     * @returns {*}
     */
    beforeSetData(value, oldValue) {
        if (value) {
            this.isLoading = true;

            // value = this.createRecord(value)
        }

        return value
    }



    /**
     * @param {Neo.data.Model|Object} value
     * @param {Neo.data.Model|Object} oldValue
     * @protected
     * @returns {Neo.data.Model}
     */
    beforeSetModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _Model_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Converts an object or array of objects into records
     * @param {Object|Object[]} config
     * @returns {Object|Object[]} Array in case an array was passed
     */
    createRecord(config) {
        let isArray = true;

        if (config) {
            if (!Array.isArray(config)) {
                isArray = false;
                config  = [config]
            }

            let me  = this,
                i   = 0,
                len = config.length,
                item;

            for (; i < len; i++) {
                item = config[i]

                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
                    config[i] = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item)
                }
            }
        }

        return isArray ? config : config[0]
    }

    /**
     * Overrides collection.Base:find() to ensure the returned item(s) are Record instances.
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]|null}
     */
    find(property, value, returnFirstMatch=false) {
        const result = super.find(property, value, returnFirstMatch);

        if (returnFirstMatch) {
            return result ? this.get(result[this.keyProperty]) : null;
        } else {
            return result.map(item => this.get(item[this.keyProperty]));
        }
    }

    /**
     * Overrides collection.Base:findBy() to ensure the returned item(s) are Record instances.
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.count The end index (up to, last value excluded)
     * @returns {Array}
     */
    findBy(fn, scope=this, start=0, end=this.count) {
        const result = super.findBy(fn, scope, start, end);
        return result.map(item => this.get(item[this.keyProperty]));
    }

    /**
     * Overrides collection.Base:forEach() to ensure the iterated item is a Record instance.
     * @param {Function} fn The function to execute for each record.
     * @param {Object} [scope] Value to use as `this` when executing `fn`.
     */
    forEach(fn, scope) {
        const me = this;
        for (let i = 0; i < me.count; i++) {
            fn.call(scope || me, me.getAt(i), i, me.items);
        }
    }

    /**
     * Overrides collection.Base:get() to ensure the returned item is a Record instance.
     * @param {Number|String} key
     * @returns {Object|null}
     */
    get(key) {
        let me   = this,
            item = super.get(key); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item);
            const index  = me.indexOf(item);

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(key, record);
            if (index !== -1) {
                me._items[index] = record
            }

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(key, record);
                    me.allItems._items[masterIndex] = record
                }
            }
            return record
        }
        return item // Already a record or null
    }

    /**
     * Overrides collection.Base:getAt() to ensure the returned item is a Record instance.
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        let me   = this,
            item = super.getAt(index); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item);

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(record[me.keyProperty], record);
            me._items[index] = record;

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(record[me.keyProperty], record);
                    me.allItems._items[masterIndex] = record
                }
            }
            return record
        }
        return item // Already a record or undefined
    }

    /**
     * @returns {String}
     */
    getKeyProperty() {
        return this.keyProperty || this.model.keyProperty
    }

    /**
     * Convenience shortcut to check for int based keyProperties
     * @returns {String|null} lowercase value of the model field type
     */
    getKeyType() {
        let me       = this,
            {model}  = me,
            keyField = model?.getField(me.getKeyProperty());

        return keyField?.type?.toLowerCase() || null
    }

    /**
     * Converts a data object into a Record instance or returns it if it is already one.
     * This method is called by add() and insert() when init=true (default).
     * @param {Object} data The data object or Record instance
     * @returns {Object} The Record instance
     */
    initRecord(data) {
        if (_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(data)) {
            return data
        }

        return this.get(data[this.getKeyProperty()])
    }

    /**
     * Overrides collection.Base: insert() to convert items into records if needed.
     *
     * **Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **Lazy Mode (`init=false`):**
     * Inserts raw data directly. Instantiates records only on access.
     * Returns an `Array` of the inserted raw data objects.
     *
     * @param {Number} index The index to insert at
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records
     * @returns {Object[]|Neo.data.Model[]} The inserted raw items or created records
     */
    insert(index, item, init=this.autoInitRecords) {
        let me    = this,
            items = super.insert(index, item);

        if (init) {
            return items.map(i => me.get(i[me.getKeyProperty()]))
        }

        return items
    }

    /**
     * @param {Object} opts={}
     * @param {Object} opts.data
     * @param {Object} opts.headers
     * @param {String} opts.method DELETE, GET, POST, PUT
     * @param {Object} opts.params
     * @param {String} opts.responseType
     * @param {Object} opts.scope
     * @param {String} opts.url
     * @returns {Promise<Object|Object[]>}
     * @protected
     */
    async load(opts={}) {
        let me     = this,
            params = {page: me.currentPage, pageSize: me.pageSize, ...opts.params};

        if (me.remoteFilter) {
            params.filters = me.exportFilters()
        }

        if (me.remoteSort) {
            params.sorters = me.exportSorters()
        }

        if (me.api) {
            let apiArray = me.api.read.split('.'),
                fn       = apiArray.pop(),
                service  = Neo.ns(apiArray.join('.'));

            if (!service) {
                console.error('Api is not defined', this)
            } else {
                const response = await me.trap(service[fn](params));

                if (response.success) {
                    me.totalCount = response.totalCount;
                    me.data       = Neo.ns(me.responseRoot, false, response); // fires the load event
                    me.isLoaded   = true;

                    return me.data
                }

                return null
            }
        } else {
            opts.url ??= me.url;

            try {
                let data;

                // Fallback for non-browser based envs like nodejs
                if (globalThis.process?.release) {
                    const { readFile } = await import(/* webpackIgnore: true */ 'fs/promises');
                    const content = await me.trap(readFile(opts.url, 'utf-8'));
                    data = {json: JSON.parse(content)};
                } else {
                    data = await me.trap(Neo.Xhr.promiseJson(opts));
                }

                if (data) {
                    me.data = Neo.ns(me.responseRoot, false, data.json) || data.json // fires the load event
                }

                me.isLoaded = true;

                return data?.json || null
            } catch(err) {
                if (err === Neo.isDestroyed) {
                    throw err
                }

                console.error('Error for Neo.Xhr.request', {id: me.id, error: err, url: opts.url});
                return null
            }
        }
    }

    /**
     * @param {Object} opts
     */
    onCollectionMutate(opts) {
        let me = this;

        if (me.isConstructed && !me.isLoading) {
            me.fire('load', {items: me.items, total: me.chunkingTotal});
        }
    }

    /**
     *
     */
    onCollectionSort() {
        let me = this;

        if (me.isConstructed) {
            me.fire('load', {items: me.items})
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.data) {
            me.afterSetData(me.data)
        }

        // Being constructed does not mean that related afterSetStore() methods got executed
        // => break the sync flow to ensure potential listeners got applied
        Promise.resolve().then(() => {
            if (me.isLoaded) {
                me.fire('load', {items: me.items})
            } else if (me.autoLoad) {
                me.load()
            }
        })
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        let me = this;

        if (me.remoteFilter) {
            me._currentPage = 1; // silent update
            me.load()
        } else {
            super.onFilterChange(opts)
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object} data.record
     */
    onRecordChange(data) {
        this.fire('recordChange', {
            ...data,
            index: this.indexOf(data.record)
        })
    }

    /**
     * @param {Object} opts={}
     * @param {String} opts.direction
     * @param {String} opts.property
     */
    sort(opts={}) {
        let me = this;

        me._currentPage = 1; // silent update

        if (me.configsApplied) {
            if (opts.direction) {
                me.sorters = [{
                    direction: opts.direction,
                    property : opts.property
                }]
            } else {
                if (!me.remoteSort) {
                    me.sorters = [{
                        direction: 'ASC',
                        property : initialIndexSymbol
                    }]
                }
            }
        }
    }
    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            autoInitRecords : me.autoInitRecords,
            autoLoad        : me.autoLoad,
            currentPage     : me.currentPage,
            initialChunkSize: me.initialChunkSize,
            isGrouped       : me.isGrouped,
            isLoaded        : me.isLoaded,
            isLoading       : me.isLoading,
            model           : me.model?.toJSON(),
            pageSize        : me.pageSize,
            remoteFilter    : me.remoteFilter,
            remoteSort      : me.remoteSort,
            totalCount      : me.totalCount,
            url             : me.url
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/manager/Store.mjs"
/*!*******************************!*\
  !*** ./src/manager/Store.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.Store
 * @extends Neo.manager.Base
 * @singleton
 */
class Store extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Store'
         * @protected
         */
        className: 'Neo.manager.Store',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        
        // Alias Neo.getStore to this manager?
        // Neo.getStore = this.get.bind(this);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNHO0FBQ007O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFJO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBWTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFhO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxxQkFBcUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvZGF0YS9Nb2RlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL1JlY29yZEZhY3RvcnkubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZGF0YS9TdG9yZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9tYW5hZ2VyL1N0b3JlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgUmVjb3JkRmFjdG9yeSAgZnJvbSAnLi9SZWNvcmRGYWN0b3J5Lm1qcyc7XG5pbXBvcnQge2lzRGVzY3JpcHRvcn0gZnJvbSAnLi4vY29yZS9Db25maWdTeW1ib2xzLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLk1vZGVsXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIE1vZGVsIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGF0YS5Nb2RlbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhdGEuTW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nbW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnbW9kZWwnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W118bnVsbH0gZmllbGRzX1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkc186IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdkZWVwQXJyYXlzJyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGtleVByb3BlcnR5Xz0naWQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHlfOiAnaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHN0b3JlSWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZUlkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgaW4gY2FzZSB5b3Ugd2FudCB0byB0cmFjayBtb2RpZmllZCBmaWVsZHMuXG4gICAgICAgICAqIEJlIGF3YXJlIHRoYXQgdGhpcyB3aWxsIGRvdWJsZSB0aGUgYW1vdW50IG9mIGRhdGEgaW5zaWRlIGVhY2ggcmVjb3JkLFxuICAgICAgICAgKiBzaW5jZSBlYWNoIGZpZWxkIHdpbGwgZ2V0IGFuIG9yaWdpbmFsIHZhbHVlIGZsYWcuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHRyYWNrTW9kaWZpZWRGaWVsZHM9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRyYWNrTW9kaWZpZWRGaWVsZHM6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBzdG9yaW5nIGFsbCBmaWVsZHMsIHdoaWNoIGhhdmUgYSBjYWxjdWxhdGUgcHJvcGVydHlcbiAgICAgKiBAbWVtYmVyIHtNYXB9IGNhbGN1bGF0ZWRGaWVsZHNNYXA9bmV3IE1hcCgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhbGN1bGF0ZWRGaWVsZHNNYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHN0b3JpbmcgYWxsIGZpZWxkcyBpbnNpZGUgYSBmbGF0IG1hcCA9PiBuZXN0ZWQgZmllbGRzIGluY2x1ZGVkXG4gICAgICogQG1lbWJlciB7TWFwfSBmaWVsZHNNYXA9bmV3IE1hcCgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZpZWxkc01hcCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhhc05lc3RlZEZpZWxkcz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBoYXNOZXN0ZWRGaWVsZHMgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgIFRyaWdnZXJlZCBhZnRlciB0aGUgZmllbGRzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmllbGRzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZUZpZWxkc01hcCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIEZpZWxkcyBjYW4gZ2V0IGNoYW5nZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHRoZSBtb2RlbCBpbnN0YW5jZSBpcyBnZXR0aW5nIGNvbnN0cnVjdGVkLlxuICAgICAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRoZSBsYXRlc3Qgc3RhdGUgYmVmb3JlIGNvbnN0cnVjdGlvbiAmIGhvbm9yIHJ1bi10aW1lIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAobWUuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgICAgIFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkQ2xhc3MobWUsIHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIGZpZWxkIGNvbmZpZyBieSBhIGdpdmVuIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGZpZWxkIGNvbmZpZyBvYmplY3Qgb3IgbnVsbCBpZiBubyBtYXRjaCB3YXMgZm91bmRcbiAgICAgKi9cbiAgICBnZXRGaWVsZChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkc01hcC5nZXQobmFtZSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgZmllbGQgdHlwZSBieSBhIGdpdmVuIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gVGhlIGxvd2VyY2FzZSBmaWVsZCB0eXBlIG9yIG51bGwgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgZ2V0RmllbGRUeXBlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGQobmFtZSk/LnR5cGU/LnRvTG93ZXJDYXNlKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGluc3RhbmNlIGludG8gYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0IGZvciB0aGUgTmV1cmFsIExpbmsuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgZmllbGRzICAgICAgICAgICAgIDogbWUuc2VyaWFsaXplQ29uZmlnKG1lLmZpZWxkcyksXG4gICAgICAgICAgICBrZXlQcm9wZXJ0eSAgICAgICAgOiBtZS5rZXlQcm9wZXJ0eSxcbiAgICAgICAgICAgIHN0b3JlSWQgICAgICAgICAgICA6IG1lLnN0b3JlSWQsXG4gICAgICAgICAgICB0cmFja01vZGlmaWVkRmllbGRzOiBtZS50cmFja01vZGlmaWVkRmllbGRzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBmaWVsZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUm9vdD10cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGg9JydcbiAgICAgKi9cbiAgICB1cGRhdGVGaWVsZHNNYXAoZmllbGRzLCBpc1Jvb3Q9dHJ1ZSwgcGF0aD0nJykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2NhbGN1bGF0ZWRGaWVsZHNNYXAsIGZpZWxkc01hcH0gPSBtZSxcbiAgICAgICAgICAgIGZpZWxkTmFtZTtcblxuICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgICBjYWxjdWxhdGVkRmllbGRzTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBmaWVsZHNNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIG1lLmhhc05lc3RlZEZpZWxkcyA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBmaWVsZE5hbWUgPSBwYXRoICsgZmllbGQubmFtZVxuXG4gICAgICAgICAgICBpZiAoZmllbGQuZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFzTmVzdGVkRmllbGRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVGaWVsZHNNYXAoZmllbGQuZmllbGRzLCBmYWxzZSwgZmllbGQubmFtZSArICcuJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGRzTWFwLnNldChmaWVsZE5hbWUsIGZpZWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5jYWxjdWxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZEZpZWxkc01hcC5zZXQoZmllbGROYW1lLCBmaWVsZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNb2RlbCk7XG4iLCJpbXBvcnQgQmFzZSAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi9Nb2RlbC5tanMnO1xuXG5jb25zdFxuICAgIGRhdGFTeW1ib2wgICAgICAgICA9IFN5bWJvbC5mb3IoJ2RhdGEnKSxcbiAgICBpbml0aWFsSW5kZXhTeW1ib2wgPSBTeW1ib2wuZm9yKCdpbml0aWFsSW5kZXgnKSxcbiAgICBpc01vZGlmaWVkU3ltYm9sICAgPSBTeW1ib2wuZm9yKCdpc01vZGlmaWVkJyksXG4gICAgb3JpZ2luYWxEYXRhU3ltYm9sID0gU3ltYm9sLmZvcignb3JpZ2luYWxEYXRhJyk7XG5cbmxldCBpbnN0YW5jZTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuUmVjb3JkRmFjdG9yeVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBSZWNvcmRGYWN0b3J5IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGF0YS5SZWNvcmRGYWN0b3J5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5SZWNvcmRGYWN0b3J5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVjb3JkTmFtZXNwYWNlPSdOZW8uZGF0YS5yZWNvcmQnXG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmROYW1lc3BhY2U6ICdOZW8uZGF0YS5yZWNvcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBtb2RlbC1iYXNlZCBkZWZhdWx0IHZhbHVlcyB0byBhIGRhdGEgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3NpZ25EZWZhdWx0VmFsdWVzKGRhdGEsIG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmZpZWxkc01hcC5mb3JFYWNoKChmaWVsZCwgZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gTmVvLmlzRnVuY3Rpb24oZmllbGQuZGVmYXVsdFZhbHVlKSA/IGZpZWxkLmRlZmF1bHRWYWx1ZSgpIDogZmllbGQuZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgYWx3YXlzIHVzZSBOZW8uYXNzaWduVG9OcygpID0+IHRoZSBjaGVjayBpcyBqdXN0IGZvciBpbXByb3ZpbmcgdGhlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmhhc05lc3RlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXNzaWduVG9OcyhmaWVsZE5hbWUsIGRlZmF1bHRWYWx1ZSwgZGF0YSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW2ZpZWxkTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gPSBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5maWVsZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5wYXRoPScnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucHJvdG9cbiAgICAgKi9cbiAgICBjcmVhdGVGaWVsZCh7ZmllbGQsIG1vZGVsLCBwYXRoPScnLCBwcm90b30pIHtcbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICBmaWVsZFBhdGggPSBwYXRoID09PSAnJyA/IGZpZWxkTmFtZSA6IGAke3BhdGh9LiR7ZmllbGROYW1lfWAsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChmaWVsZC5maWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkLmZpZWxkcy5mb3JFYWNoKGNoaWxkRmllbGQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRmllbGQoe2ZpZWxkOiBjaGlsZEZpZWxkLCBtb2RlbCwgcGF0aDogZmllbGRQYXRoLCBwcm90b30pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICBbZmllbGRQYXRoXToge1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGUgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmhhc05lc3RlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZW8ubnMoZmllbGRQYXRoLCBmYWxzZSwgdGhpc1tkYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZGF0YVN5bWJvbF1bZmllbGROYW1lXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHtbZmllbGRQYXRoXTogaW5zdGFuY2UucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkOiB0aGlzLCBmaWVsZCwgdmFsdWV9KX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBtb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNyZWF0ZVJlY29yZChtb2RlbCwgY29uZmlnKSB7XG4gICAgICAgIGxldCByZWNvcmRDbGFzcyA9IE5lby5ucyhgJHt0aGlzLnJlY29yZE5hbWVzcGFjZX0uJHttb2RlbC5jbGFzc05hbWV9LiR7bW9kZWwuaWR9YCk7XG5cbiAgICAgICAgaWYgKCFyZWNvcmRDbGFzcykge1xuICAgICAgICAgICAgcmVjb3JkQ2xhc3MgPSB0aGlzLmNyZWF0ZVJlY29yZENsYXNzKG1vZGVsKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyByZWNvcmRDbGFzcyhjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG92ZXJ3cml0ZT1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkQ2xhc3MobW9kZWwsIG92ZXJ3cml0ZT1mYWxzZSkge1xuICAgICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IGAke3RoaXMucmVjb3JkTmFtZXNwYWNlfS4ke21vZGVsLmNsYXNzTmFtZX0uJHttb2RlbC5pZH1gLFxuICAgICAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhjbGFzc05hbWUpLFxuICAgICAgICAgICAgICAgIGtleSwgbnNBcnJheSwgY2xzO1xuXG4gICAgICAgICAgICBpZiAoIW5zIHx8IG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIG5zQXJyYXkgPSBjbGFzc05hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBrZXkgICAgID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgICAgICBucyAgICAgID0gTmVvLm5zKG5zQXJyYXksIHRydWUpO1xuICAgICAgICAgICAgICAgIGNscyAgICAgPSBuc1trZXldID0gY2xhc3MgUmVjb3JkIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gbWluaWZ5IHRoZSBjdG9yIGNsYXNzIG5hbWUgaW4gZGlzdC9wcm9kdWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpYyBuYW1lID0gJ1JlY29yZCc7XG5cbiAgICAgICAgICAgICAgICAgICAgW2RhdGFTeW1ib2xdICAgICAgICAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgW2luaXRpYWxJbmRleFN5bWJvbF0gPSBudWxsXG5cbiAgICAgICAgICAgICAgICAgICAgZ2V0IGlzTW9kaWZpZWQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudHJhY2tNb2RpZmllZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhTmVvLmlzRXF1YWwobWVbZGF0YVN5bWJvbF0sIG1lW29yaWdpbmFsRGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZVtpc01vZGlmaWVkU3ltYm9sXVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oY29uZmlnLCBpbml0aWFsSW5kZXhTeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVbaW5pdGlhbEluZGV4U3ltYm9sXSA9IGNvbmZpZ1tpbml0aWFsSW5kZXhTeW1ib2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWdbaW5pdGlhbEluZGV4U3ltYm9sXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBpbnN0YW5jZS5hc3NpZ25EZWZhdWx0VmFsdWVzKGNvbmZpZywgbW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudHJhY2tNb2RpZmllZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW29yaWdpbmFsRGF0YVN5bWJvbF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXRPcmlnaW5hbChjb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW2lzTW9kaWZpZWRTeW1ib2xdID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0U2lsZW50KGNvbmZpZykgLy8gV2UgZG8gbm90IHdhbnQgdG8gZmlyZSBjaGFuZ2UgZXZlbnRzIHdoZW4gY29uc3RydWN0aW5nXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxudWxsfSBudWxsIGluIGNhc2UgdGhlIG1vZGVsIGRvZXMgbm90IHVzZSB0cmFja01vZGlmaWVkRmllbGRzLCB0cnVlIGluIGNhc2UgYSBjaGFuZ2Ugd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpc01vZGlmaWVkRmllbGQoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudHJhY2tNb2RpZmllZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhU2NvcGUsIG9yaWdpbmFsRGF0YVNjb3BlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmhhc05lc3RlZEZpZWxkcyAmJiBmaWVsZE5hbWU/LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5zQXJyYXkgPSBmaWVsZE5hbWUuc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgICAgICAgICA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTY29wZSAgICAgICAgID0gTmVvLm5zKG5zQXJyYXksIGZhbHNlLCBtZVtkYXRhU3ltYm9sXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRGF0YVNjb3BlID0gTmVvLm5zKG5zQXJyYXksIGZhbHNlLCBtZVtvcmlnaW5hbERhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTY29wZSAgICAgICAgID0gbWVbZGF0YVN5bWJvbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRGF0YVNjb3BlID0gbWVbb3JpZ2luYWxEYXRhU3ltYm9sXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaWVsZCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFtb2RlbC5nZXRGaWVsZChmaWVsZE5hbWUpICYmICAgICAgICAvLyBDaGVjayBmb3IgbGVhZiBmaWVsZHMgKGNvdWxkIGJlIGV4Y2x1ZGVkIGluc2lkZSB0aGUgcmVhbCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhT2JqZWN0Lmhhc093bihkYXRhU2NvcGUsIGZpZWxkTmFtZSkgLy8gQ2hlY2sgdGhlIGRhdGEgdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgcmVjb3JkIGRvZXMgbm90IGNvbnRhaW4gdGhlIGZpZWxkJywgZmllbGROYW1lLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIU5lby5pc0VxdWFsKGRhdGFTY29wZVtmaWVsZE5hbWVdLCBvcmlnaW5hbERhdGFTY29wZVtmaWVsZE5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBzaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciByZWNvcmQgZmllbGQgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgICogRXhlY3V0ZXMgaW5zdGFuY2Uuc2V0UmVjb3JkRmllbGRzKCksIGFuZCBjYW4gZ2V0IHVzZWQgdmlhOlxuICAgICAgICAgICAgICAgICAgICAgKiAtIE5lby51dGlsLkZ1bmN0aW9uOmNyZWF0ZVNlcXVlbmNlKClcbiAgICAgICAgICAgICAgICAgICAgICogLSBOZW8udXRpbC5GdW5jdGlvbjppbnRlcmNlcHQoKSxcbiAgICAgICAgICAgICAgICAgICAgICogdG8gXCJsaXN0ZW5cIiB0byBmaWVsZCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5maWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbFxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICBzaWxlbnQ9ZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeUNoYW5nZShkYXRhLCBzaWxlbnQ9ZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gey4uLmRhdGEsIHNpbGVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcyhwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBCdWxrLXVwZGF0ZSBtdWx0aXBsZSByZWNvcmQgZmllbGRzIGF0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgcmVzZXQoZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE9yaWdpbmFsKGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChmaWVsZHMpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQnVsay11cGRhdGUgbXVsdGlwbGUgcmVjb3JkIGZpZWxkcyBhdCBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNldChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlKHtmaWVsZHMsIG1vZGVsLCByZWNvcmQ6IHRoaXN9KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBtb2RlbCB1c2VzIHRyYWNrTW9kaWZpZWRGaWVsZHMsIHdlIHdpbGwgc3RvcmUgdGhlIG9yaWdpbmFsIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogZm9yIHRyYWNraW5nIHRoZSBkaXJ0eSBzdGF0ZSAoY2hhbmdlZCBmaWVsZHMpXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgc2V0T3JpZ2luYWwoZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRSZWNvcmRGaWVsZHMoe2ZpZWxkcywgbW9kZWwsIHJlY29yZDogdGhpcywgc2lsZW50OiB0cnVlLCB1c2VPcmlnaW5hbERhdGE6IHRydWV9KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEJ1bGstdXBkYXRlIG11bHRpcGxlIHJlY29yZCBmaWVsZHMgYXQgb25jZSB3aXRob3V0IHRyaWdnZXJpbmcgYSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgc2V0U2lsZW50KGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2Uoe2ZpZWxkcywgbW9kZWwsIHJlY29yZDogdGhpc30sIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogV2hlbiB1c2luZyBKU09OLnN0cmluZ2lmeSh0aGlzKSwgd2Ugd2FudCB0byBnZXQgdGhlIHJhdyBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0b0pTT04oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXNbZGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwuZmllbGRzKSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jcmVhdGVGaWVsZCh7ZmllbGQsIG1vZGVsLCBwcm90bzogY2xzLnByb3RvdHlwZX0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNscy5wcm90b3R5cGUsICdpc1JlY29yZCcsIHt2YWx1ZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbHMsICdpc0NsYXNzJywge3ZhbHVlOiB0cnVlfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnNba2V5XVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIGEgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIGEgY2xhc3MgY3JlYXRlZCBieSB0aGlzIGZhY3RvcnlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWNvcmQocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiByZWNvcmQ/LmlzUmVjb3JkIHx8IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgY2hhbmdpbmcgdGhlIHZhbHVlIG9mIGEgcmVjb3JkIGZpZWxkLlxuICAgICAqIEUuZy4gbXlSZWNvcmQuZm9vID0gJ2Jhcic7XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvcHRzLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gb3B0cy5tb2RlbCBUaGUgbW9kZWwgaW5zdGFuY2Ugb2YgdGhlIGNoYW5nZWQgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucmVjb3JkXG4gICAgICovXG4gICAgb25SZWNvcmRDaGFuZ2Uob3B0cykge1xuICAgICAgICBOZW8uZ2V0KG9wdHMubW9kZWwuc3RvcmVJZCk/Lm9uUmVjb3JkQ2hhbmdlKG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YS5maWVsZFxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgW2RhdGEudmFsdWU9bnVsbF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIFtkYXRhLnJlY29yZENvbmZpZz1udWxsXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RhdGEudXNlT3JpZ2luYWxEYXRhPWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHBhcnNlUmVjb3JkVmFsdWUoe3JlY29yZCwgZmllbGQsIHZhbHVlPW51bGwsIHJlY29yZENvbmZpZz1udWxsLCB1c2VPcmlnaW5hbERhdGE9ZmFsc2V9KSB7XG4gICAgICAgIGlmIChmaWVsZC5jYWxjdWxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5jYWxjdWxhdGUocmVjb3JkW3VzZU9yaWdpbmFsRGF0YSA/IG9yaWdpbmFsRGF0YVN5bWJvbCA6IGRhdGFTeW1ib2xdLCBmaWVsZClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWVsZC5jb252ZXJ0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLmNvbnZlcnQodmFsdWUsIHJlY29yZClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lLFxuICAgICAgICAgICAge21hcHBpbmcsIG1heExlbmd0aCwgbWluTGVuZ3RoLCBudWxsYWJsZX0gPSBmaWVsZCxcbiAgICAgICAgICAgIG9sZFZhbHVlICA9IHJlY29yZENvbmZpZz8uW2ZpZWxkTmFtZV0gfHwgcmVjb3JkW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgICB0eXBlICAgICAgPSBmaWVsZC50eXBlPy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIG9ubHkgdHJpZ2dlciBtYXBwaW5ncyBmb3IgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgLy8gZHluYW1pYyBjaGFuZ2VzIG9mIGEgZmllbGQgd2lsbCBub3QgcGFzcyB0aGUgcmVjb3JkQ29uZmlnXG4gICAgICAgIGlmIChtYXBwaW5nICYmIHJlY29yZENvbmZpZykge1xuICAgICAgICAgICAgbGV0IG5zICA9IG1hcHBpbmcuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBucy5wb3AoKTtcblxuICAgICAgICAgICAgbnMgICAgPSBOZW8ubnMobnMsIHRydWUsIHJlY29yZENvbmZpZyk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5zW2tleV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCAnbWF4TGVuZ3RoJykpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZT8udG9TdHJpbmcoKS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldHRpbmcgcmVjb3JkIGZpZWxkOiAke2ZpZWxkTmFtZX0gdmFsdWU6ICR7dmFsdWV9IGNvbmZsaWN0cyB3aXRoIG1heExlbmd0aDogJHttYXhMZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ21pbkxlbmd0aCcpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWU/LnRvU3RyaW5nKCkubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXR0aW5nIHJlY29yZCBmaWVsZDogJHtmaWVsZE5hbWV9IHZhbHVlOiAke3ZhbHVlfSBjb25mbGljdHMgd2l0aCBtaW5MZW5ndGg6ICR7bWluTGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdudWxsYWJsZScpKSB7XG4gICAgICAgICAgICBpZiAobnVsbGFibGUgPT09IGZhbHNlICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXR0aW5nIHJlY29yZCBmaWVsZDogJHtmaWVsZE5hbWV9IHZhbHVlOiAke3ZhbHVlfSBjb25mbGljdHMgd2l0aCBudWxsYWJsZTogJHtudWxsYWJsZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnZGF0ZScgJiYgTmVvLnR5cGVPZih2YWx1ZSkgIT09ICdEYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Zsb2F0JyAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2h0bWwnICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJydcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSAnaW50JyB8fCB0eXBlID09PSAnaW50ZWdlcicpICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJztcbiAgICAgICAgICAgIHZhbHVlID0gIHZhbHVlLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICBkYXRhLmZpZWxkTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEudXNlT3JpZ2luYWxEYXRhPWZhbHNlIHRydWUgd2lsbCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvcmlnaW5hbERhdGEgc3ltYm9sXG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgICAgICAgZGF0YS52YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRSZWNvcmREYXRhKHtmaWVsZE5hbWUsIG1vZGVsLCByZWNvcmQsIHVzZU9yaWdpbmFsRGF0YT1mYWxzZSwgdmFsdWV9KSB7XG4gICAgICAgIGlmICh1c2VPcmlnaW5hbERhdGEgJiYgIW1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNjb3BlID0gdXNlT3JpZ2luYWxEYXRhID8gb3JpZ2luYWxEYXRhU3ltYm9sIDogZGF0YVN5bWJvbDtcblxuICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzICYmIGZpZWxkTmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBsZXQgbnMsIG5zQXJyYXk7XG5cbiAgICAgICAgICAgIG5zQXJyYXkgICA9IGZpZWxkTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgZmllbGROYW1lID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhuc0FycmF5LCB0cnVlLCByZWNvcmRbc2NvcGVdKTtcblxuICAgICAgICAgICAgbnNbZmllbGROYW1lXSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRbc2NvcGVdW2ZpZWxkTmFtZV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgICAgIGRhdGEuY2hhbmdlZEZpZWxkcz1bXSBJbnRlcm5hbCBmbGFnXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5maWVsZHNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICBkYXRhLnNpbGVudD1mYWxzZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEudXNlT3JpZ2luYWxEYXRhPWZhbHNlIHRydWUgd2lsbCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvcmlnaW5hbERhdGEgc3ltYm9sXG4gICAgICovXG4gICAgc2V0UmVjb3JkRmllbGRzKHtjaGFuZ2VkRmllbGRzPVtdLCBmaWVsZHMsIG1vZGVsLCByZWNvcmQsIHNpbGVudD1mYWxzZSwgdXNlT3JpZ2luYWxEYXRhPWZhbHNlfSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2NhbGN1bGF0ZWRGaWVsZHNNYXAsIGZpZWxkc01hcCwgdHJhY2tNb2RpZmllZEZpZWxkc30gPSBtb2RlbCxcbiAgICAgICAgICAgIGZpZWxkRXhpc3RzLCBoYXNDaGFuZ2VkRmllbGRzLCBvbGRWYWx1ZTtcblxuICAgICAgICBpZiAoIXRyYWNrTW9kaWZpZWRGaWVsZHMgJiYgdXNlT3JpZ2luYWxEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBmaWVsZEV4aXN0cyA9IGZpZWxkc01hcC5oYXMoa2V5KTtcblxuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgIWZpZWxkRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtjaGlsZEtleSwgY2hpbGRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2V0UmVjb3JkRmllbGRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHtbYCR7a2V5fS4ke2NoaWxkS2V5fWBdOiBjaGlsZFZhbHVlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlT3JpZ2luYWxEYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGRFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgID0gbWUucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZDogbW9kZWwuZ2V0RmllbGQoa2V5KSwgdmFsdWV9KTtcblxuICAgICAgICAgICAgICAgIGlmICghTmVvLmlzRXF1YWwob2xkVmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZXRSZWNvcmREYXRhKHtmaWVsZE5hbWU6IGtleSwgbW9kZWwsIHJlY29yZCwgdXNlT3JpZ2luYWxEYXRhLCB2YWx1ZX0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2tNb2RpZmllZEZpZWxkcyAmJiAhdXNlT3JpZ2luYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRbaXNNb2RpZmllZFN5bWJvbF0gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzLnB1c2goe25hbWU6IGtleSwgb2xkVmFsdWUsIHZhbHVlfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhhc0NoYW5nZWRGaWVsZHMgPSBPYmplY3Qua2V5cyhjaGFuZ2VkRmllbGRzKS5sZW5ndGggPiAwO1xuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkRmllbGRzKSB7XG4gICAgICAgICAgICBjYWxjdWxhdGVkRmllbGRzTWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgID0gbWUucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZDogbW9kZWwuZ2V0RmllbGQoa2V5KSwgdXNlT3JpZ2luYWxEYXRhfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKG9sZFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2V0UmVjb3JkRGF0YSh7ZmllbGROYW1lOiBrZXksIG1vZGVsLCByZWNvcmQsIHVzZU9yaWdpbmFsRGF0YSwgdmFsdWV9KTtcblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzLnB1c2goe25hbWU6IGtleSwgb2xkVmFsdWUsIHZhbHVlfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaWxlbnQgJiYgIXVzZU9yaWdpbmFsRGF0YSAmJiBoYXNDaGFuZ2VkRmllbGRzKSB7XG4gICAgICAgICAgICBtZS5vblJlY29yZENoYW5nZSh7ZmllbGRzOiBjaGFuZ2VkRmllbGRzLCBtb2RlbCwgcmVjb3JkfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW5zdGFuY2UgPSBOZW8uc2V0dXBDbGFzcyhSZWNvcmRGYWN0b3J5KTtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFuY2U7XG4iLCJpbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb2xsZWN0aW9uICAgICAgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5pbXBvcnQgTW9kZWwgICAgICAgICAgIGZyb20gJy4vTW9kZWwubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgUmVjb3JkRmFjdG9yeSAgIGZyb20gJy4vUmVjb3JkRmFjdG9yeS5tanMnO1xuaW1wb3J0IFN0b3JlTWFuYWdlciAgICBmcm9tICcuLi9tYW5hZ2VyL1N0b3JlLm1qcyc7XG5cbmNvbnN0IGluaXRpYWxJbmRleFN5bWJvbCA9IFN5bWJvbC5mb3IoJ2luaXRpYWxJbmRleCcpO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGF0YS5TdG9yZVxuICogQGV4dGVuZHMgTmVvLmNvbGxlY3Rpb24uQmFzZVxuICogQG1peGVzIE5lby5jb3JlLk9ic2VydmFibGVcbiAqXG4gKiBAc3VtbWFyeSBBIHBvd2VyZnVsLCBvYnNlcnZhYmxlIGNvbGxlY3Rpb24gdGhhdCBtYW5hZ2VzIGEgc2V0IG9mIGRhdGEgcmVjb3Jkcy5cbiAqXG4gKiBOZW8uZGF0YS5TdG9yZSBpcyB0aGUgY2VudHJhbCBkYXRhIG1hbmFnZW1lbnQgY2xhc3MgaW4gdGhlIGZyYW1ld29yay4gSXQgaGFuZGxlcyB0aGUgbGlmZWN5Y2xlIG9mXG4gKiBkYXRhIHJlY29yZHMsIGluY2x1ZGluZyBsb2FkaW5nLCBmaWx0ZXJpbmcsIHNvcnRpbmcsIGFuZCBzeW5jaHJvbml6YXRpb24gd2l0aCBiYWNrZW5kIEFQSXMuXG4gKlxuICogIyMjIFJlY29yZCBJbnN0YW50aWF0aW9uIFN0cmF0ZWdpZXM6IEVhZ2VyIHZzLiBMYXp5IChcIlR1cmJvIE1vZGVcIilcbiAqXG4gKiBUaGUgU3RvcmUgc3VwcG9ydHMgdHdvIGRpc3RpbmN0IHN0cmF0ZWdpZXMgZm9yIGhhbmRsaW5nIHJlY29yZCBjcmVhdGlvbiwgY29udHJvbGxlZCBieSB0aGUgYGF1dG9Jbml0UmVjb3Jkc2AgY29uZmlnXG4gKiAod2hpY2ggZGVmYXVsdHMgdG8gYHRydWVgKSBhbmQgdGhlIGBpbml0YCBwYXJhbWV0ZXIgaW4gbWV0aG9kcyBsaWtlIGBhZGQoKWAgYW5kIGBpbnNlcnQoKWAuXG4gKlxuICogKioxLiBFYWdlciBJbnN0YW50aWF0aW9uIChEZWZhdWx0OiBgYXV0b0luaXRSZWNvcmRzOiB0cnVlYCkqKlxuICogICAgLSAqKkJlaGF2aW9yKio6IFJhdyBkYXRhIG9iamVjdHMgYXJlIGltbWVkaWF0ZWx5IGNvbnZlcnRlZCBpbnRvIGBOZW8uZGF0YS5Nb2RlbGAgaW5zdGFuY2VzLlxuICogICAgLSAqKlVzZSBDYXNlKio6IFN0YW5kYXJkIG9wZXJhdGlvbnMsIGFkZGluZyBzaW5nbGUgaXRlbXMsIGludGVyYWN0aXZlIGVkaXRzLlxuICogICAgLSAqKlByb3MqKjogUmV0dXJucyB1c2FibGUgUmVjb3JkIGluc3RhbmNlcyBpbW1lZGlhdGVseS4gSGlnaCBEZXZlbG9wZXIgRXhwZXJpZW5jZSAoRFgpLlxuICogICAgLSAqKkNvbnMqKjogQ2FuIGJlIHNsb3cgZm9yIG1hc3NpdmUgZGF0YXNldHMgKDEwaysgcmVjb3JkcykuXG4gKlxuICogKioyLiBMYXp5IEluc3RhbnRpYXRpb24gKFwiVHVyYm8gTW9kZVwiKSoqXG4gKiAgICAtICoqQmVoYXZpb3IqKjogUmF3IGRhdGEgb2JqZWN0cyBhcmUgc3RvcmVkIGRpcmVjdGx5LiBgTmVvLmRhdGEuTW9kZWxgIGluc3RhbmNlcyBhcmUgY3JlYXRlZFxuICogICAgICBcImp1c3QtaW4tdGltZVwiIG9ubHkgd2hlbiB0aGV5IGFyZSBhY2Nlc3NlZCB2aWEgYGdldCgpYCwgYGdldEF0KClgLCBvciBpdGVyYXRpb24uXG4gKiAgICAtICoqVXNlIENhc2UqKjogQnVsayBsb2FkaW5nIGxhcmdlIGRhdGFzZXRzIChlLmcuLCBncmlkcywgY2hhcnRzIHdpdGggdGhvdXNhbmRzIG9mIHBvaW50cykuXG4gKiAgICAtICoqUHJvcyoqOiBNYXNzaXZlIHBlcmZvcm1hbmNlIGdhaW5zIGZvciBpbml0aWFsIGRhdGEgbG9hZC4gRW5hYmxlcyBpbnRlcm5hbCBcImNodW5raW5nXCIgdG8gcHJldmVudCBVSSBmcmVlemVzLlxuICogICAgLSAqKkNvbnMqKjogYGFkZCgpYCByZXR1cm5zIGEgY291bnQgaW5zdGVhZCBvZiByZWNvcmRzLiBSZWNvcmRzIGFyZSBub3QgYXZhaWxhYmxlIHVudGlsIGFjY2Vzc2VkLlxuICogICAgLSAqKkhvdyB0byBlbmFibGUqKjpcbiAqICAgICAgLSAqKkdsb2JhbCoqOiBTZXQgYGF1dG9Jbml0UmVjb3JkczogZmFsc2VgIG9uIHRoZSBTdG9yZSBjb25maWcuXG4gKiAgICAgIC0gKipQZXItY2FsbCoqOiBQYXNzIGBmYWxzZWAgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgYWRkKClgIG9yIGBpbnNlcnQoKWAuXG4gKiAgICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICAgLy8gR2xvYmFsIHNldHRpbmdcbiAqICAgICAgTmVvLmNyZWF0ZShTdG9yZSwge1xuICogICAgICAgICAgYXV0b0luaXRSZWNvcmRzOiBmYWxzZSxcbiAqICAgICAgICAgIGRhdGE6IGh1Z2VBcnJheU9mRGF0YVxuICogICAgICB9KTtcbiAqXG4gKiAgICAgIC8vIFBlci1jYWxsIG92ZXJyaWRlXG4gKiAgICAgIHN0b3JlLmFkZChodWdlQXJyYXlPZkRhdGEsIGZhbHNlKTtcbiAqICAgICAgYGBgXG4gKi9cbmNsYXNzIFN0b3JlIGV4dGVuZHMgQ29sbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuU3RvcmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXRhLlN0b3JlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3N0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3N0b3JlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RlYWQgb2Ygc2V0dGluZyBhbiB1cmwsIHlvdSBjYW4gZGVmaW5lIHRoZSBSUEMgQkUgQVBJIG1ldGhvZHMuXG4gICAgICAgICAqIEluIGNhc2UgdGhlIDQgbWV0aG9kcyBhcmUgdXNpbmcgdGhlIHNhbWUgc2VydmljZSBhbmQgdGhpcyBzZXJ2aWNlIGlzIHVzaW5nIHRoZSBDUlVEIGJhc2VkIGZuLW5hbWVzLFxuICAgICAgICAgKiB5b3UgY2FuIHN3aXRjaCB0byBhIHN0cmluZyBiYXNlZCBzaG9ydGN1dC5cbiAgICAgICAgICogVGhlIGZvbGxvd2luZyAyIGV4YW1wbGVzIGFyZSBlcXVpdmFsZW50LlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBhcGk6IHtcbiAgICAgICAgICogICAgY3JlYXRlIDogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UuY3JlYXRlJyxcbiAgICAgICAgICogICAgZGVzdHJveTogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UuZGVzdHJveScsXG4gICAgICAgICAqICAgIHJlYWQgICA6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLnJlYWQnLFxuICAgICAgICAgKiAgICB1cGRhdGUgOiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZS51cGRhdGUnXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYXBpOiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZSdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fFN0cmluZ3xudWxsfSBhcGlfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBhcGlfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGNyZWF0ZSByZWNvcmQgaW5zdGFuY2VzIHdoZW4gYWRkaW5nIGl0ZW1zLlxuICAgICAgICAgKiBTZXQgdG8gZmFsc2UgdG8gZW5hYmxlIFwiVHVyYm8gTW9kZVwiIChMYXp5IEluc3RhbnRpYXRpb24pIGdsb2JhbGx5IGZvciB0aGlzIHN0b3JlLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBhdXRvSW5pdFJlY29yZHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b0luaXRSZWNvcmRzOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0xvYWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Mb2FkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY3VycmVudFBhZ2VfPTFcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50UGFnZV86IDEsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheXxudWxsfSBkYXRhXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5pdGlhbCBjaHVuayBzaXplIGZvciBhZGRpbmcgbGFyZ2UgZGF0YXNldHMuIFNldCB0byAwIHRvIGRpc2FibGUgY2h1bmtpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gaW5pdGlhbENodW5rU2l6ZT0wXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsQ2h1bmtTaXplOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNHcm91cGVkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0dyb3VwZWQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gaXNMb2FkZWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzTG9hZGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTG9hZGluZz1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5kYXRhLk1vZGVsfSBtb2RlbF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBhIHZhbHVlIG9mIDAgdG8gbm90IGxpbWl0IHRoZSBwYWdlU2l6ZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHBhZ2VTaXplXz0wXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGFnZVNpemVfOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBsZXQgdGhlIGJhY2tlbmQgaGFuZGxlIHRoZSBmaWx0ZXJpbmcuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgYnVmZmVyZWQgc3RvcmVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW90ZUZpbHRlcj1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlRmlsdGVyOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gbGV0IHRoZSBiYWNrZW5kIGhhbmRsZSB0aGUgc29ydGluZy5cbiAgICAgICAgICogVXNlZnVsIGZvciBidWZmZXJlZCBzdG9yZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3RlU29ydD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3RlU29ydDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBwYXRoIHRvIHRoZSByb290IG9mIHlvdXIgZGF0YS5cbiAgICAgICAgICogSWYgdGhlIHJlc3BvbnNlUm9vdCBpcyAnZGF0YScgdGhpcyBpcyBvcHRpb25hbC5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZXNwb25zZVJvb3Q9J2RhdGEnXG4gICAgICAgICAqL1xuICAgICAgICByZXNwb25zZVJvb3Q6ICdkYXRhJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gdG90YWxDb3VudD0wXG4gICAgICAgICAqL1xuICAgICAgICB0b3RhbENvdW50OiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXJsIGZvciBBamF4IHJlcXVlc3RzXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSB1cmw9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdXJsOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvXG4gICAgICAgIG1lLm9uKHtcbiAgICAgICAgICAgIG11dGF0ZTogbWUub25Db2xsZWN0aW9uTXV0YXRlLFxuICAgICAgICAgICAgc29ydCAgOiBtZS5vbkNvbGxlY3Rpb25Tb3J0LFxuICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICBTdG9yZU1hbmFnZXIucmVnaXN0ZXIobWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBTdG9yZU1hbmFnZXIudW5yZWdpc3Rlcih0aGlzKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOiBhZGQoKSB0byBjb252ZXJ0IGl0ZW1zIGludG8gcmVjb3JkcyBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiAqKjEuIEVhZ2VyIE1vZGUgKGBpbml0PXRydWVgIC0gRGVmYXVsdCk6KipcbiAgICAgKiBJbW1lZGlhdGVseSBjb252ZXJ0cyByYXcgZGF0YSBpbnRvIGBOZW8uZGF0YS5Nb2RlbGAgaW5zdGFuY2VzLlxuICAgICAqIFJldHVybnMgYW4gYEFycmF5YCBvZiB0aGUgY3JlYXRlZCByZWNvcmRzLlxuICAgICAqXG4gICAgICogKioyLiBMYXp5IE1vZGUgKGBpbml0PWZhbHNlYCk6KipcbiAgICAgKiBBZGRzIHJhdyBkYXRhIGRpcmVjdGx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBJbnN0YW50aWF0ZXMgcmVjb3JkcyBvbmx5IG9uIGFjY2Vzcy5cbiAgICAgKlxuICAgICAqIC0gKipDaHVua2luZyBBY3RpdmUqKjogSWYgYGluaXRpYWxDaHVua1NpemUgPiAwYCBhbmQgYGl0ZW1zLmxlbmd0aCA+IHRocmVzaG9sZGA6XG4gICAgICogICBBZGRzIGl0ZW1zIGluIGNodW5rcyB0byBwcmV2ZW50IGJsb2NraW5nIHRoZSBBcHAgV29ya2VyIChNYWluIEFjdG9yKS5cbiAgICAgKiAgIFJldHVybnMgdGhlIG5ldyBjb2xsZWN0aW9uIGBjb3VudGAgKE51bWJlcikuXG4gICAgICpcbiAgICAgKiAtICoqTm8gQ2h1bmtpbmcqKjogSWYgYGluaXRpYWxDaHVua1NpemUgPT09IDBgIG9yIGBpdGVtcy5sZW5ndGggPD0gdGhyZXNob2xkYDpcbiAgICAgKiAgIEFkZHMgcmF3IGl0ZW1zIGRpcmVjdGx5LlxuICAgICAqICAgUmV0dXJucyBhbiBgQXJyYXlgIG9mIHRoZSBhZGRlZCByYXcgZGF0YSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyAxLiBEZWZhdWx0OiBHZXQgcmVjb3JkcyBpbW1lZGlhdGVseVxuICAgICAqIGNvbnN0IFtuZXdSZWNvcmRdID0gc3RvcmUuYWRkKHtuYW1lOiAnTmV3IEl0ZW0nfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIDIuIFR1cmJvIE1vZGUgKE5vIENodW5raW5nKTogR2V0IHJhdyBvYmplY3RzXG4gICAgICogY29uc3QgW3Jhd09iamVjdF0gPSBzdG9yZS5hZGQoe25hbWU6ICdJdGVtJ30sIGZhbHNlKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gMy4gVHVyYm8gTW9kZSAoQ2h1bmtpbmcpOiBHZXQgbmV3IGNvdW50XG4gICAgICogc3RvcmUuaW5pdGlhbENodW5rU2l6ZSA9IDEwMDA7XG4gICAgICogY29uc3QgbmV3Q291bnQgPSBzdG9yZS5hZGQoaHVnZURhdGFBcnJheSwgZmFsc2UpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0ocykgdG8gYWRkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdD10aGlzLmF1dG9Jbml0UmVjb3Jkc10gVHJ1ZSB0byByZXR1cm4gdGhlIGNyZWF0ZWQgcmVjb3JkcywgZmFsc2UgZm9yIFwiVHVyYm8gTW9kZVwiXG4gICAgICogQHJldHVybnMge051bWJlcnxPYmplY3RbXXxOZW8uZGF0YS5Nb2RlbFtdfSBUaGUgY29sbGVjdGlvbiBjb3VudCwgcmF3IGl0ZW1zLCBvciBjcmVhdGVkIHJlY29yZHNcbiAgICAgKi9cbiAgICBhZGQoaXRlbSwgaW5pdD10aGlzLmF1dG9Jbml0UmVjb3Jkcykge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICAgICA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dLFxuICAgICAgICAgICAgdGhyZXNob2xkID0gbWUuaW5pdGlhbENodW5rU2l6ZTtcblxuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgc3VwZXIuYWRkKGl0ZW1zKTtcblxuICAgICAgICAgICAgbWUuaXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gaXRlbXMubWFwKGkgPT4gbWUuZ2V0KGlbbWUuZ2V0S2V5UHJvcGVydHkoKV0pKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZCA+IDAgJiYgaXRlbXMubGVuZ3RoID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IG1lLmNvdW50ICsgaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgY2h1bmsgPSBpdGVtcy5zcGxpY2UoMCwgdGhyZXNob2xkKTtcblxuICAgICAgICAgICAgbWUuY2h1bmtpbmdUb3RhbCA9IHRvdGFsO1xuXG4gICAgICAgICAgICAvLyAxLiBBZGQgdGhlIGZpcnN0IGNodW5rLiBUaGlzIGZpcmVzICdtdXRhdGUnIC0+ICdsb2FkJyAodmlhIG9uQ29sbGVjdGlvbk11dGF0ZSlcbiAgICAgICAgICAgIC8vICAgIGFuZCB0cmlnZ2VycyB0aGUgaW5pdGlhbCBncmlkIHJlbmRlci4gVGhlICdsb2FkJyBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGZpbmFsIHRvdGFsIGNvdW50LlxuICAgICAgICAgICAgc3VwZXIuYWRkKGNodW5rKTsgLy8gUGFzcyByYXcgY2h1bmsgZGlyZWN0bHlcblxuICAgICAgICAgICAgLy8gMi4gU3VzcGVuZCBldmVudHMgdG8gcHJldmVudCB0aGUgbmV4dCAnYWRkJyBmcm9tIGZpcmluZyAnbG9hZCcuXG4gICAgICAgICAgICBtZS5zdXNwZW5kRXZlbnRzID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gMy4gQWRkIHRoZSByZXN0IG9mIHRoZSBpdGVtcyBzaWxlbnRseS5cbiAgICAgICAgICAgIHN1cGVyLmFkZChpdGVtcyk7IC8vIFBhc3MgcmF3IGl0ZW1zIGRpcmVjdGx5XG5cbiAgICAgICAgICAgIC8vIDQuIFJlc3VtZSBldmVudHMuXG4gICAgICAgICAgICBtZS5zdXNwZW5kRXZlbnRzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIDUuIE1hbnVhbGx5IGZpcmUgYSBmaW5hbCAnbG9hZCcgZXZlbnQgdG8gdXBkYXRlIHRoZSBncmlkJ3Mgc2Nyb2xsYmFyIGFuZCBub3RpZnkgb3RoZXIgbGlzdGVuZXJzLlxuICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXMsIHBvc3RDaHVua0xvYWQ6IHRydWUsIHRvdGFsOiBtZS5jaHVua2luZ1RvdGFsfSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZS5jaHVua2luZ1RvdGFsO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUuY291bnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gc3VwZXIuYWRkKGl0ZW1zKTtcblxuICAgICAgICAvLyBJZiB3ZSB1c2UgYWRkKCkgaW5pdGlhbGx5IGluc3RlYWQgb2Ygc2V0dGluZyBgZGF0YWAsIHdlIG5lZWQgdG8gc2V0IHRoZSBsb2FkZWQgZmxhZyBoZXJlLlxuICAgICAgICBtZS5pc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlIC8vIFBhc3MgcmF3IGl0ZW0gZGlyZWN0bHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGN1cnJlbnRQYWdlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnRQYWdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2xlYXIoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgbWUuYWRkKHZhbHVlLCBtZS5hdXRvSW5pdFJlY29yZHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgb2xkVmFsdWUgJiYgbWUucmVtb3RlRmlsdGVyICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLnN0b3JlSWQgPSB0aGlzLmlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHBhZ2VTaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhZ2VTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5sb2FkKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFNvcnRlcnModmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5yZW1vdGVTb3J0ICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgYmVmb3JlU2V0QXBpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGUgOiB2YWx1ZSArICcuY3JlYXRlJyxcbiAgICAgICAgICAgICAgICBkZXN0cm95OiB2YWx1ZSArICcuZGVzdHJveScsXG4gICAgICAgICAgICAgICAgcmVhZCAgIDogdmFsdWUgKyAnLnJlYWQnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZSA6IHZhbHVlICsgJy51cGRhdGUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYmVmb3JlU2V0RGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHZhbHVlID0gdGhpcy5jcmVhdGVSZWNvcmQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5Nb2RlbH1cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIHJlY29yZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXX0gQXJyYXkgaW4gY2FzZSBhbiBhcnJheSB3YXMgcGFzc2VkXG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKGNvbmZpZykge1xuICAgICAgICBsZXQgaXNBcnJheSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uZmlnICA9IFtjb25maWddXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gY29uZmlnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGNvbmZpZ1tpXVxuXG4gICAgICAgICAgICAgICAgaWYgKCFSZWNvcmRGYWN0b3J5LmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tpXSA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0FycmF5ID8gY29uZmlnIDogY29uZmlnWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmaW5kKCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtKHMpIGFyZSBSZWNvcmQgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFt2YWx1ZV0gT25seSByZXF1aXJlZCBpbiBjYXNlIHRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5maW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaCk7XG5cbiAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyB0aGlzLmdldChyZXN1bHRbdGhpcy5rZXlQcm9wZXJ0eV0pIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubWFwKGl0ZW0gPT4gdGhpcy5nZXQoaXRlbVt0aGlzLmtleVByb3BlcnR5XSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmaW5kQnkoKSB0byBlbnN1cmUgdGhlIHJldHVybmVkIGl0ZW0ocykgYXJlIFJlY29yZCBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJ1biBmb3IgZWFjaCBpdGVtIGluc2lkZSB0aGUgc3RhcnQtZW5kIHJhbmdlLiBSZXR1cm4gdHJ1ZSBmb3IgYSBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGhpcyBUaGUgc2NvcGUgaW4gd2hpY2ggdGhlIHBhc3NlZCBmdW5jdGlvbiBnZXRzIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0PTAgVGhlIHN0YXJ0IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZD10aGlzLmNvdW50IFRoZSBlbmQgaW5kZXggKHVwIHRvLCBsYXN0IHZhbHVlIGV4Y2x1ZGVkKVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBmaW5kQnkoZm4sIHNjb3BlPXRoaXMsIHN0YXJ0PTAsIGVuZD10aGlzLmNvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmZpbmRCeShmbiwgc2NvcGUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChpdGVtID0+IHRoaXMuZ2V0KGl0ZW1bdGhpcy5rZXlQcm9wZXJ0eV0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmZvckVhY2goKSB0byBlbnN1cmUgdGhlIGl0ZXJhdGVkIGl0ZW0gaXMgYSBSZWNvcmQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggcmVjb3JkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGZuYC5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGZuLCBzY29wZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWUuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChzY29wZSB8fCBtZSwgbWUuZ2V0QXQoaSksIGksIG1lLml0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBjb2xsZWN0aW9uLkJhc2U6Z2V0KCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtIGlzIGEgUmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IHN1cGVyLmdldChrZXkpOyAvLyBHZXQgaXRlbSBmcm9tIENvbGxlY3Rpb24uQmFzZSAoY291bGQgYmUgcmF3IGRhdGEpXG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ICA9IG1lLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHJhdyBkYXRhIHdpdGggdGhlIHJlY29yZCBpbnN0YW5jZSBpbiB0aGUgY3VycmVudCAoZmlsdGVyZWQpIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIG1lLm1hcC5zZXQoa2V5LCByZWNvcmQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1lLl9pdGVtc1tpbmRleF0gPSByZWNvcmRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkLCB3ZSBtdXN0IGFsc28gdXBkYXRlIHRoZSBtYXN0ZXIgJ2FsbEl0ZW1zJyBjb2xsZWN0aW9uXG4gICAgICAgICAgICBpZiAobWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXN0ZXJJbmRleCA9IG1lLmFsbEl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5tYXAuc2V0KGtleSwgcmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWxsSXRlbXMuX2l0ZW1zW21hc3RlckluZGV4XSA9IHJlY29yZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbSAvLyBBbHJlYWR5IGEgcmVjb3JkIG9yIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmdldEF0KCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtIGlzIGEgUmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldEF0KGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBzdXBlci5nZXRBdChpbmRleCk7IC8vIEdldCBpdGVtIGZyb20gQ29sbGVjdGlvbi5CYXNlIChjb3VsZCBiZSByYXcgZGF0YSlcblxuICAgICAgICBpZiAoaXRlbSAmJiAhUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gUmVjb3JkRmFjdG9yeS5jcmVhdGVSZWNvcmQobWUubW9kZWwsIGl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSByYXcgZGF0YSB3aXRoIHRoZSByZWNvcmQgaW5zdGFuY2UgaW4gdGhlIGN1cnJlbnQgKGZpbHRlcmVkKSBjb2xsZWN0aW9uXG4gICAgICAgICAgICBtZS5tYXAuc2V0KHJlY29yZFttZS5rZXlQcm9wZXJ0eV0sIHJlY29yZCk7XG4gICAgICAgICAgICBtZS5faXRlbXNbaW5kZXhdID0gcmVjb3JkO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGNvbGxlY3Rpb24gaXMgZmlsdGVyZWQsIHdlIG11c3QgYWxzbyB1cGRhdGUgdGhlIG1hc3RlciAnYWxsSXRlbXMnIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIGlmIChtZS5hbGxJdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hc3RlckluZGV4ID0gbWUuYWxsSXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAobWFzdGVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zLm1hcC5zZXQocmVjb3JkW21lLmtleVByb3BlcnR5XSwgcmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWxsSXRlbXMuX2l0ZW1zW21hc3RlckluZGV4XSA9IHJlY29yZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbSAvLyBBbHJlYWR5IGEgcmVjb3JkIG9yIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0S2V5UHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleVByb3BlcnR5IHx8IHRoaXMubW9kZWwua2V5UHJvcGVydHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBjaGVjayBmb3IgaW50IGJhc2VkIGtleVByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IGxvd2VyY2FzZSB2YWx1ZSBvZiB0aGUgbW9kZWwgZmllbGQgdHlwZVxuICAgICAqL1xuICAgIGdldEtleVR5cGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW9kZWx9ICA9IG1lLFxuICAgICAgICAgICAga2V5RmllbGQgPSBtb2RlbD8uZ2V0RmllbGQobWUuZ2V0S2V5UHJvcGVydHkoKSk7XG5cbiAgICAgICAgcmV0dXJuIGtleUZpZWxkPy50eXBlPy50b0xvd2VyQ2FzZSgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRhdGEgb2JqZWN0IGludG8gYSBSZWNvcmQgaW5zdGFuY2Ugb3IgcmV0dXJucyBpdCBpZiBpdCBpcyBhbHJlYWR5IG9uZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgYWRkKCkgYW5kIGluc2VydCgpIHdoZW4gaW5pdD10cnVlIChkZWZhdWx0KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3Qgb3IgUmVjb3JkIGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIFJlY29yZCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGluaXRSZWNvcmQoZGF0YSkge1xuICAgICAgICBpZiAoUmVjb3JkRmFjdG9yeS5pc1JlY29yZChkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldChkYXRhW3RoaXMuZ2V0S2V5UHJvcGVydHkoKV0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTogaW5zZXJ0KCkgdG8gY29udmVydCBpdGVtcyBpbnRvIHJlY29yZHMgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogKipFYWdlciBNb2RlIChgaW5pdD10cnVlYCAtIERlZmF1bHQpOioqXG4gICAgICogSW1tZWRpYXRlbHkgY29udmVydHMgcmF3IGRhdGEgaW50byBgTmVvLmRhdGEuTW9kZWxgIGluc3RhbmNlcy5cbiAgICAgKiBSZXR1cm5zIGFuIGBBcnJheWAgb2YgdGhlIGNyZWF0ZWQgcmVjb3Jkcy5cbiAgICAgKlxuICAgICAqICoqTGF6eSBNb2RlIChgaW5pdD1mYWxzZWApOioqXG4gICAgICogSW5zZXJ0cyByYXcgZGF0YSBkaXJlY3RseS4gSW5zdGFudGlhdGVzIHJlY29yZHMgb25seSBvbiBhY2Nlc3MuXG4gICAgICogUmV0dXJucyBhbiBgQXJyYXlgIG9mIHRoZSBpbnNlcnRlZCByYXcgZGF0YSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgYXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbSBUaGUgaXRlbShzKSB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbml0PXRoaXMuYXV0b0luaXRSZWNvcmRzXSBUcnVlIHRvIHJldHVybiB0aGUgY3JlYXRlZCByZWNvcmRzXG4gICAgICogQHJldHVybnMge09iamVjdFtdfE5lby5kYXRhLk1vZGVsW119IFRoZSBpbnNlcnRlZCByYXcgaXRlbXMgb3IgY3JlYXRlZCByZWNvcmRzXG4gICAgICovXG4gICAgaW5zZXJ0KGluZGV4LCBpdGVtLCBpbml0PXRoaXMuYXV0b0luaXRSZWNvcmRzKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyA9IHN1cGVyLmluc2VydChpbmRleCwgaXRlbSk7XG5cbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5tYXAoaSA9PiBtZS5nZXQoaVttZS5nZXRLZXlQcm9wZXJ0eSgpXSkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cz17fVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5oZWFkZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMubWV0aG9kIERFTEVURSwgR0VULCBQT1NULCBQVVRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5yZXNwb25zZVR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5zY29wZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnVybFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxPYmplY3RbXT59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGxvYWQob3B0cz17fSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHtwYWdlOiBtZS5jdXJyZW50UGFnZSwgcGFnZVNpemU6IG1lLnBhZ2VTaXplLCAuLi5vcHRzLnBhcmFtc307XG5cbiAgICAgICAgaWYgKG1lLnJlbW90ZUZpbHRlcikge1xuICAgICAgICAgICAgcGFyYW1zLmZpbHRlcnMgPSBtZS5leHBvcnRGaWx0ZXJzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5yZW1vdGVTb3J0KSB7XG4gICAgICAgICAgICBwYXJhbXMuc29ydGVycyA9IG1lLmV4cG9ydFNvcnRlcnMoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmFwaSkge1xuICAgICAgICAgICAgbGV0IGFwaUFycmF5ID0gbWUuYXBpLnJlYWQuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBmbiAgICAgICA9IGFwaUFycmF5LnBvcCgpLFxuICAgICAgICAgICAgICAgIHNlcnZpY2UgID0gTmVvLm5zKGFwaUFycmF5LmpvaW4oJy4nKSk7XG5cbiAgICAgICAgICAgIGlmICghc2VydmljZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FwaSBpcyBub3QgZGVmaW5lZCcsIHRoaXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWUudHJhcChzZXJ2aWNlW2ZuXShwYXJhbXMpKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRvdGFsQ291bnQgPSByZXNwb25zZS50b3RhbENvdW50O1xuICAgICAgICAgICAgICAgICAgICBtZS5kYXRhICAgICAgID0gTmVvLm5zKG1lLnJlc3BvbnNlUm9vdCwgZmFsc2UsIHJlc3BvbnNlKTsgLy8gZmlyZXMgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNMb2FkZWQgICA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLmRhdGFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cy51cmwgPz89IG1lLnVybDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBub24tYnJvd3NlciBiYXNlZCBlbnZzIGxpa2Ugbm9kZWpzXG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbFRoaXMucHJvY2Vzcz8ucmVsZWFzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlYWRGaWxlIH0gPSBhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyAnZnMvcHJvbWlzZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IG1lLnRyYXAocmVhZEZpbGUob3B0cy51cmwsICd1dGYtOCcpKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtqc29uOiBKU09OLnBhcnNlKGNvbnRlbnQpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgbWUudHJhcChOZW8uWGhyLnByb21pc2VKc29uKG9wdHMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5kYXRhID0gTmVvLm5zKG1lLnJlc3BvbnNlUm9vdCwgZmFsc2UsIGRhdGEuanNvbikgfHwgZGF0YS5qc29uIC8vIGZpcmVzIHRoZSBsb2FkIGV2ZW50XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuaXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE/Lmpzb24gfHwgbnVsbFxuICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBOZW8uaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZm9yIE5lby5YaHIucmVxdWVzdCcsIHtpZDogbWUuaWQsIGVycm9yOiBlcnIsIHVybDogb3B0cy51cmx9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkNvbGxlY3Rpb25NdXRhdGUob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkICYmICFtZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2xvYWQnLCB7aXRlbXM6IG1lLml0ZW1zLCB0b3RhbDogbWUuY2h1bmtpbmdUb3RhbH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbGxlY3Rpb25Tb3J0KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdsb2FkJywge2l0ZW1zOiBtZS5pdGVtc30pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5kYXRhKSB7XG4gICAgICAgICAgICBtZS5hZnRlclNldERhdGEobWUuZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlaW5nIGNvbnN0cnVjdGVkIGRvZXMgbm90IG1lYW4gdGhhdCByZWxhdGVkIGFmdGVyU2V0U3RvcmUoKSBtZXRob2RzIGdvdCBleGVjdXRlZFxuICAgICAgICAvLyA9PiBicmVhayB0aGUgc3luYyBmbG93IHRvIGVuc3VyZSBwb3RlbnRpYWwgbGlzdGVuZXJzIGdvdCBhcHBsaWVkXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lLmlzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXN9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5hdXRvTG9hZCkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRmlsdGVyQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucmVtb3RlRmlsdGVyKSB7XG4gICAgICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICBtZS5sb2FkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLm9uRmlsdGVyQ2hhbmdlKG9wdHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBvblJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVjb3JkQ2hhbmdlJywge1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4T2YoZGF0YS5yZWNvcmQpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e31cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5kaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5wcm9wZXJ0eVxuICAgICAqL1xuICAgIHNvcnQob3B0cz17fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBpZiAobWUuY29uZmlnc0FwcGxpZWQpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRlcnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IG9wdHMuZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA6IG9wdHMucHJvcGVydHlcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLnJlbW90ZVNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc29ydGVycyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdBU0MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgOiBpbml0aWFsSW5kZXhTeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBhdXRvSW5pdFJlY29yZHMgOiBtZS5hdXRvSW5pdFJlY29yZHMsXG4gICAgICAgICAgICBhdXRvTG9hZCAgICAgICAgOiBtZS5hdXRvTG9hZCxcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlICAgICA6IG1lLmN1cnJlbnRQYWdlLFxuICAgICAgICAgICAgaW5pdGlhbENodW5rU2l6ZTogbWUuaW5pdGlhbENodW5rU2l6ZSxcbiAgICAgICAgICAgIGlzR3JvdXBlZCAgICAgICA6IG1lLmlzR3JvdXBlZCxcbiAgICAgICAgICAgIGlzTG9hZGVkICAgICAgICA6IG1lLmlzTG9hZGVkLFxuICAgICAgICAgICAgaXNMb2FkaW5nICAgICAgIDogbWUuaXNMb2FkaW5nLFxuICAgICAgICAgICAgbW9kZWwgICAgICAgICAgIDogbWUubW9kZWw/LnRvSlNPTigpLFxuICAgICAgICAgICAgcGFnZVNpemUgICAgICAgIDogbWUucGFnZVNpemUsXG4gICAgICAgICAgICByZW1vdGVGaWx0ZXIgICAgOiBtZS5yZW1vdGVGaWx0ZXIsXG4gICAgICAgICAgICByZW1vdGVTb3J0ICAgICAgOiBtZS5yZW1vdGVTb3J0LFxuICAgICAgICAgICAgdG90YWxDb3VudCAgICAgIDogbWUudG90YWxDb3VudCxcbiAgICAgICAgICAgIHVybCAgICAgICAgICAgICA6IG1lLnVybFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdG9yZSk7XG4iLCJpbXBvcnQgTWFuYWdlciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuU3RvcmVcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgU3RvcmUgZXh0ZW5kcyBNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLlN0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5TdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFsaWFzIE5lby5nZXRTdG9yZSB0byB0aGlzIG1hbmFnZXI/XG4gICAgICAgIC8vIE5lby5nZXRTdG9yZSA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdG9yZSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9