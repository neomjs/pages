"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_data_Store_mjs"],{

/***/ "./src/data/Model.mjs"
/*!****************************!*\
  !*** ./src/data/Model.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");




/**
 * @class Neo.data.Model
 * @extends Neo.core.Base
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.Model'
         * @protected
         */
        className: 'Neo.data.Model',
        /**
         * @member {String} ntype='model'
         * @protected
         */
        ntype: 'model',
        /**
         * @member {Object[]|null} fields_
         * @reactive
         */
        fields_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_2__.isDescriptor]: true,
            merge         : 'deepArrays',
            value         : null
        },
        /**
         * @member {String} keyProperty_='id'
         * @reactive
         */
        keyProperty_: 'id',
        /**
         * @member {String|null} storeId=null
         * @protected
         */
        storeId: null,
        /**
         * Set this config to true in case you want to track modified fields.
         * Be aware that this will double the amount of data inside each record,
         * since each field will get an original value flag.
         * @member {Boolean} trackModifiedFields=false
         */
        trackModifiedFields: false
    }

    /**
     * Internally storing all fields, which have a calculate property
     * @member {Map} calculatedFieldsMap=new Map()
     * @protected
     */
    calculatedFieldsMap = new Map()
    /**
     * Internally storing all fields inside a flat map => nested fields included
     * @member {Map} fieldsMap=new Map()
     * @protected
     */
    fieldsMap = new Map()
    /**
     * @member {Boolean} hasNestedFields=false
     * @protected
     */
    hasNestedFields = false

    /**
     Triggered after the fields config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetFields(value, oldValue) {
        if (value) {
            let me = this;

            me.updateFieldsMap(value);

            // Fields can get changed multiple times before the model instance is getting constructed.
            // We only need the latest state before construction & honor run-time changes.
            if (me.isConstructed) {
                _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createRecordClass(me, true)
            }
        }
    }

    /**
     * Finds a field config by a given field name
     * @param {String} name
     * @returns {Object|null} The field config object or null if no match was found
     */
    getField(name) {
        return this.fieldsMap.get(name) || null
    }

    /**
     * Finds a field type by a given field name
     * @param {String} name
     * @returns {String|null} The lowercase field type or null if no match was found
     */
    getFieldType(name) {
        return this.getField(name)?.type?.toLowerCase() || null
    }

    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            fields             : me.serializeConfig(me.fields),
            keyProperty        : me.keyProperty,
            storeId            : me.storeId,
            trackModifiedFields: me.trackModifiedFields
        }
    }

    /**
     * @param {Object[]} fields
     * @param {Boolean} isRoot=true
     * @param {String} path=''
     */
    updateFieldsMap(fields, isRoot=true, path='') {
        let me = this,
            {calculatedFieldsMap, fieldsMap} = me,
            fieldName;

        if (isRoot) {
            calculatedFieldsMap.clear();
            fieldsMap.clear();
            me.hasNestedFields = false
        }

        fields.forEach(field => {
            fieldName = path + field.name

            if (field.fields) {
                me.hasNestedFields = true;
                me.updateFieldsMap(field.fields, false, field.name + '.')
            } else {
                fieldsMap.set(fieldName, field);

                if (field.calculate) {
                    calculatedFieldsMap.set(fieldName, field)
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/data/RecordFactory.mjs"
/*!************************************!*\
  !*** ./src/data/RecordFactory.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");



const
    dataSymbol         = Symbol.for('data'),
    initialIndexSymbol = Symbol.for('initialIndex'),
    isModifiedSymbol   = Symbol.for('isModified'),
    originalDataSymbol = Symbol.for('originalData');

let instance;

/**
 * @class Neo.data.RecordFactory
 * @extends Neo.core.Base
 * @singleton
 */
class RecordFactory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.RecordFactory'
         * @protected
         */
        className: 'Neo.data.RecordFactory',
        /**
         * @member {String} recordNamespace='Neo.data.record'
         */
        recordNamespace: 'Neo.data.record',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Assigns model-based default values to a data object
     * @param {Object}         data
     * @param {Neo.data.Model} model
     * @returns {Object}
     */
    assignDefaultValues(data, model) {
        model.fieldsMap.forEach((field, fieldName) => {
            if (Object.hasOwn(field, 'defaultValue')) {
                const defaultValue = Neo.isFunction(field.defaultValue) ? field.defaultValue() : field.defaultValue;

                // We could always use Neo.assignToNs() => the check is just for improving the performance
                if (model.hasNestedFields) {
                    Neo.assignToNs(fieldName, defaultValue, data, false)
                } else if (data[fieldName] === undefined) {
                    data[fieldName] = defaultValue
                }
            }
        });

        return data
    }

    /**
     * @param {Object} data
     * @param {Object} data.field
     * @param {Neo.data.Model} data.model
     * @param {String} data.path=''
     * @param {Object} data.proto
     */
    createField({field, model, path='', proto}) {
        let fieldName = field.name,
            fieldPath = path === '' ? fieldName : `${path}.${fieldName}`,
            properties;

        if (field.fields) {
            field.fields.forEach(childField => {
                this.createField({field: childField, model, path: fieldPath, proto})
            })
        } else {
            properties = {
                [fieldPath]: {
                    configurable: true,
                    enumerable  : true,
                    get() {
                        if (model.hasNestedFields) {
                            return Neo.ns(fieldPath, false, this[dataSymbol])
                        }

                        return this[dataSymbol][fieldName]
                    },
                    set(value) {
                        this.notifyChange({
                            fields: {[fieldPath]: instance.parseRecordValue({record: this, field, value})},
                            model,
                            record: this
                        })
                    }
                }
            };

            Object.defineProperties(proto, properties)
        }
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Object} config
     * @returns {Object}
     */
    createRecord(model, config) {
        let recordClass = Neo.ns(`${this.recordNamespace}.${model.className}.${model.id}`);

        if (!recordClass) {
            recordClass = this.createRecordClass(model)
        }

        return new recordClass(config)
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Boolean} overwrite=false
     * @returns {Object}
     */
    createRecordClass(model, overwrite=false) {
        if (model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            let className = `${this.recordNamespace}.${model.className}.${model.id}`,
                ns        = Neo.ns(className),
                key, nsArray, cls;

            if (!ns || overwrite) {
                nsArray = className.split('.');
                key     = nsArray.pop();
                ns      = Neo.ns(nsArray, true);
                cls     = ns[key] = class Record {
                    // We do not want to minify the ctor class name in dist/production
                    static name = 'Record';

                    [dataSymbol]         = {};
                    [initialIndexSymbol] = null

                    get isModified() {
                        let me = this;

                        if (model.trackModifiedFields) {
                            return !Neo.isEqual(me[dataSymbol], me[originalDataSymbol])
                        }

                        return me[isModifiedSymbol]
                    }

                    /**
                     * @param {Object} config
                     */
                    constructor(config) {
                        let me = this;

                        if (Object.hasOwn(config, initialIndexSymbol)) {
                            me[initialIndexSymbol] = config[initialIndexSymbol];
                            delete config[initialIndexSymbol]
                        }

                        config = instance.assignDefaultValues(config, model);

                        if (model.trackModifiedFields) {
                            me[originalDataSymbol] = {};
                            me.setOriginal(config)
                        } else {
                            me[isModifiedSymbol] = false
                        }

                        me.setSilent(config) // We do not want to fire change events when constructing
                    }

                    /**
                     * @param {String} fieldName
                     * @returns {Boolean|null} null in case the model does not use trackModifiedFields, true in case a change was found
                     */
                    isModifiedField(fieldName) {
                        let me = this;

                        if (model.trackModifiedFields) {
                            let dataScope, originalDataScope;

                            if (model.hasNestedFields && fieldName?.includes('.')) {
                                let nsArray = fieldName.split('.');

                                fieldName         = nsArray.pop();
                                dataScope         = Neo.ns(nsArray, false, me[dataSymbol]);
                                originalDataScope = Neo.ns(nsArray, false, me[originalDataSymbol])
                            } else {
                                dataScope         = me[dataSymbol];
                                originalDataScope = me[originalDataSymbol]
                            }

                            // Check if the field exists
                            if (
                                !model.getField(fieldName) &&        // Check for leaf fields (could be excluded inside the real data)
                                !Object.hasOwn(dataScope, fieldName) // Check the data tree
                            ) {
                                console.error('The record does not contain the field', fieldName, me)
                            }

                            return !Neo.isEqual(dataScope[fieldName], originalDataScope[fieldName])
                        }

                        return null
                    }

                    /**
                     * The single source of truth for record field changes.
                     * Executes instance.setRecordFields(), and can get used via:
                     * - Neo.util.Function:createSequence()
                     * - Neo.util.Function:intercept(),
                     * to "listen" to field changes
                     * @param {Object}         data
                     * @param {Object}         data.fields
                     * @param {Neo.data.Model} data.model
                     * @param {Object}         data.record
                     * @param {Boolean}        silent=false
                     * @returns {Object}
                     */
                    notifyChange(data, silent=false) {
                        const param = {...data, silent}
                        instance.setRecordFields(param);
                        return param
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    reset(fields) {
                        this.setOriginal(fields);
                        this.set(fields)
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    set(fields) {
                        this.notifyChange({fields, model, record: this})
                    }

                    /**
                     * If the model uses trackModifiedFields, we will store the original data
                     * for tracking the dirty state (changed fields)
                     * @param {Object} fields
                     * @protected
                     */
                    setOriginal(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true, useOriginalData: true})
                    }

                    /**
                     * Bulk-update multiple record fields at once without triggering a change event
                     * @param {Object} fields
                     */
                    setSilent(fields) {
                        this.notifyChange({fields, model, record: this}, true)
                    }

                    /**
                     * When using JSON.stringify(this), we want to get the raw data
                     * @returns {Object}
                     */
                    toJSON() {
                        return structuredClone(this[dataSymbol])
                    }
                };

                if (Array.isArray(model.fields)) {
                    model.fields.forEach(field => {
                        instance.createField({field, model, proto: cls.prototype})
                    })
                }

                Object.defineProperty(cls.prototype, 'isRecord', {value: true});
                Object.defineProperty(cls, 'isClass', {value: true});

                return ns[key]
            }

            return ns
        }
    }

    /**
     * Tests if a given object is an instance of a class created by this factory
     * @param {Object} record
     * @returns {Boolean}
     */
    isRecord(record) {
        return record?.isRecord || false
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onRecordChange(opts) {
        Neo.get(opts.model.storeId)?.onRecordChange(opts)
    }

    /**
     * @param {Object}  data
     * @param {Object}  data.record
     * @param {Object}  data.field
     * @param {*}       [data.value=null]
     * @param {Object}  [data.recordConfig=null]
     * @param {Boolean} [data.useOriginalData=false]
     * @returns {*}
     */
    parseRecordValue({record, field, value=null, recordConfig=null, useOriginalData=false}) {
        if (field.calculate) {
            return field.calculate(record[useOriginalData ? originalDataSymbol : dataSymbol], field)
        }

        if (field.convert) {
            value = field.convert(value, record)
        }

        let fieldName = field.name,
            {mapping, maxLength, minLength, nullable} = field,
            oldValue  = recordConfig?.[fieldName] || record[fieldName],
            type      = field.type?.toLowerCase();

        // only trigger mappings for initial values
        // dynamic changes of a field will not pass the recordConfig
        if (mapping && recordConfig) {
            let ns  = mapping.split('.'),
                key = ns.pop();

            ns    = Neo.ns(ns, true, recordConfig);
            value = ns[key]
        }

        if (Object.hasOwn(field, 'maxLength')) {
            if (value?.toString().length > maxLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with maxLength: ${maxLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'minLength')) {
            if (value?.toString().length < minLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with minLength: ${minLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'nullable')) {
            if (nullable === false && value === null) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with nullable: ${nullable}`);
                return oldValue
            }
        }

        if (type === 'date' && Neo.typeOf(value) !== 'Date') {
            return new Date(value)
        }

        else if (type === 'float' && value) {
            value = parseFloat(value)
        }

        else if (type === 'html' && value) {
            value = value + ''
        }

        else if ((type === 'int' || type === 'integer') && value) {
            value = parseInt(value)
        }

        else if (type === 'string' && value) {
            value = value + '';
            value =  value.replace(/(<([^>]+)>)/ig, '')
        }

        return value
    }

    /**
     * @param {Object}         data
     * @param {String}         data.fieldName
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     * @param {*}              data.value
     * @protected
     */
    setRecordData({fieldName, model, record, useOriginalData=false, value}) {
        if (useOriginalData && !model.trackModifiedFields) {
            return
        }

        let scope = useOriginalData ? originalDataSymbol : dataSymbol;

        if (model.hasNestedFields && fieldName.includes('.')) {
            let ns, nsArray;

            nsArray   = fieldName.split('.');
            fieldName = nsArray.pop();
            ns        = Neo.ns(nsArray, true, record[scope]);

            ns[fieldName] = value
        } else {
            record[scope][fieldName] = value
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.changedFields=[] Internal flag
     * @param {Object}         data.fields
     * @param {Neo.data.Model} data.model
     * @param {Object}         data.record
     * @param {Boolean}        data.silent=false
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     */
    setRecordFields({changedFields=[], fields, model, record, silent=false, useOriginalData=false}) {
        let me = this,
            {calculatedFieldsMap, fieldsMap, trackModifiedFields} = model,
            fieldExists, hasChangedFields, oldValue;

        if (!trackModifiedFields && useOriginalData) {
            return
        }

        Object.entries(fields).forEach(([key, value]) => {
            fieldExists = fieldsMap.has(key);

            if (Neo.isObject(value) && !fieldExists) {
                Object.entries(value).forEach(([childKey, childValue]) => {
                    me.setRecordFields({
                        changedFields,
                        fields: {[`${key}.${childKey}`]: childValue},
                        model,
                        record,
                        silent: true,
                        useOriginalData
                    })
                })
            } else if (fieldExists) {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), value});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    if (!trackModifiedFields && !useOriginalData) {
                        record[isModifiedSymbol] = true
                    }

                    changedFields.push({name: key, oldValue, value})
                }
            }
        });

        hasChangedFields = Object.keys(changedFields).length > 0;

        if (hasChangedFields) {
            calculatedFieldsMap.forEach((value, key) => {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), useOriginalData});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    changedFields.push({name: key, oldValue, value})
                }
            })
        }

        if (!silent && !useOriginalData && hasChangedFields) {
            me.onRecordChange({fields: changedFields, model, record})
        }
    }
}

instance = Neo.setupClass(RecordFactory);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ },

/***/ "./src/data/Store.mjs"
/*!****************************!*\
  !*** ./src/data/Store.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");
/* harmony import */ var _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../manager/Store.mjs */ "./src/manager/Store.mjs");







const initialIndexSymbol = Symbol.for('initialIndex');

/**
 * @class Neo.data.Store
 * @extends Neo.collection.Base
 * @mixes Neo.core.Observable
 *
 * @summary A powerful, observable collection that manages a set of data records.
 *
 * Neo.data.Store is the central data management class in the framework. It handles the lifecycle of
 * data records, including loading, filtering, sorting, and synchronization with backend APIs.
 *
 * ### Record Instantiation Strategies: Eager vs. Lazy ("Turbo Mode")
 *
 * The Store supports two distinct strategies for handling record creation, controlled by the `autoInitRecords` config
 * (which defaults to `true`) and the `init` parameter in methods like `add()` and `insert()`.
 *
 * **1. Eager Instantiation (Default: `autoInitRecords: true`)**
 *    - **Behavior**: Raw data objects are immediately converted into `Neo.data.Model` instances.
 *    - **Use Case**: Standard operations, adding single items, interactive edits.
 *    - **Pros**: Returns usable Record instances immediately. High Developer Experience (DX).
 *    - **Cons**: Can be slow for massive datasets (10k+ records).
 *
 * **2. Lazy Instantiation ("Turbo Mode")**
 *    - **Behavior**: Raw data objects are stored directly. `Neo.data.Model` instances are created
 *      "just-in-time" only when they are accessed via `get()`, `getAt()`, or iteration.
 *    - **Use Case**: Bulk loading large datasets (e.g., grids, charts with thousands of points).
 *    - **Pros**: Massive performance gains for initial data load. Enables internal "chunking" to prevent UI freezes.
 *    - **Cons**: `add()` returns a count instead of records. Records are not available until accessed.
 *    - **How to enable**:
 *      - **Global**: Set `autoInitRecords: false` on the Store config.
 *      - **Per-call**: Pass `false` as the second argument to `add()` or `insert()`.
 *      ```javascript
 *      // Global setting
 *      Neo.create(Store, {
 *          autoInitRecords: false,
 *          data: hugeArrayOfData
 *      });
 *
 *      // Per-call override
 *      store.add(hugeArrayOfData, false);
 *      ```
 */
class Store extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.Store'
         * @protected
         */
        className: 'Neo.data.Store',
        /**
         * @member {String} ntype='store'
         * @protected
         */
        ntype: 'store',
        /**
         * Instead of setting an url, you can define the RPC BE API methods.
         * In case the 4 methods are using the same service and this service is using the CRUD based fn-names,
         * you can switch to a string based shortcut.
         * The following 2 examples are equivalent.
         * @example
         * api: {
         *    create : 'MyApp.backend.UserService.create',
         *    destroy: 'MyApp.backend.UserService.destroy',
         *    read   : 'MyApp.backend.UserService.read',
         *    update : 'MyApp.backend.UserService.update'
         * }
         * @example
         * api: 'MyApp.backend.UserService'
         * @member {Object|String|null} api_=null
         * @reactive
         */
        api_: null,
        /**
         * True to automatically create record instances when adding items.
         * Set to false to enable "Turbo Mode" (Lazy Instantiation) globally for this store.
         * @member {Boolean} autoInitRecords=true
         */
        autoInitRecords: true,
        /**
         * @member {Boolean} autoLoad=false
         */
        autoLoad: false,
        /**
         * @member {Number} currentPage_=1
         * @reactive
         */
        currentPage_: 1,
        /**
         * @member {Array|null} data_=null
         * @reactive
         */
        data_: null,
        /**
         * The initial chunk size for adding large datasets. Set to 0 to disable chunking.
         * @member {Number} initialChunkSize=0
         */
        initialChunkSize: 0,
        /**
         * @member {Boolean} isGrouped=false
         */
        isGrouped: false,
        /**
         * @member {Boolean} isLoaded=false
         */
        isLoaded: false,
        /**
         * @member {Boolean} isLoading=false
         */
        isLoading: false,
        /**
         * @member {Neo.data.Model} model_=null
         * @reactive
         */
        model_: null,
        /**
         * Use a value of 0 to not limit the pageSize
         * @member {Number} pageSize_=0
         * @reactive
         */
        pageSize_: 0,
        /**
         * True to let the backend handle the filtering.
         * Useful for buffered stores
         * @member {Boolean} remoteFilter=false
         */
        remoteFilter: false,
        /**
         * True to let the backend handle the sorting.
         * Useful for buffered stores
         * @member {Boolean} remoteSort=false
         */
        remoteSort: false,
        /**
         * Add a path to the root of your data.
         * If the responseRoot is 'data' this is optional.
         * @member {String} responseRoot='data'
         */
        responseRoot: 'data',
        /**
         * @member {Number} totalCount=0
         */
        totalCount: 0,
        /**
         * Url for Ajax requests
         * @member {String|null} url=null
         */
        url: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // todo
        me.on({
            mutate: me.onCollectionMutate,
            sort  : me.onCollectionSort,
            scope : me
        });

        _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].register(me)
    }

    /**
     *
     */
    destroy() {
        _manager_Store_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].unregister(this);

        super.destroy()
    }

    /**
     * Overrides collection.Base: add() to convert items into records if needed.
     *
     * **1. Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **2. Lazy Mode (`init=false`):**
     * Adds raw data directly for maximum performance. Instantiates records only on access.
     *
     * - **Chunking Active**: If `initialChunkSize > 0` and `items.length > threshold`:
     *   Adds items in chunks to prevent blocking the App Worker (Main Actor).
     *   Returns the new collection `count` (Number).
     *
     * - **No Chunking**: If `initialChunkSize === 0` or `items.length <= threshold`:
     *   Adds raw items directly.
     *   Returns an `Array` of the added raw data objects.
     *
     * @example
     * // 1. Default: Get records immediately
     * const [newRecord] = store.add({name: 'New Item'});
     *
     * @example
     * // 2. Turbo Mode (No Chunking): Get raw objects
     * const [rawObject] = store.add({name: 'Item'}, false);
     *
     * @example
     * // 3. Turbo Mode (Chunking): Get new count
     * store.initialChunkSize = 1000;
     * const newCount = store.add(hugeDataArray, false);
     *
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records, false for "Turbo Mode"
     * @returns {Number|Object[]|Neo.data.Model[]} The collection count, raw items, or created records
     */
    add(item, init=this.autoInitRecords) {
        let me        = this,
            items     = Array.isArray(item) ? item : [item],
            threshold = me.initialChunkSize;

        if (init) {
            super.add(items);

            me.isLoaded = true;

            return items.map(i => me.get(i[me.getKeyProperty()]))
        }

        if (threshold > 0 && items.length > threshold) {
            const total = me.count + items.length,
                  chunk = items.splice(0, threshold);

            me.chunkingTotal = total;

            // 1. Add the first chunk. This fires 'mutate' -> 'load' (via onCollectionMutate)
            //    and triggers the initial grid render. The 'load' event will contain the final total count.
            super.add(chunk); // Pass raw chunk directly

            // 2. Suspend events to prevent the next 'add' from firing 'load'.
            me.suspendEvents = true;

            // 3. Add the rest of the items silently.
            super.add(items); // Pass raw items directly

            // 4. Resume events.
            me.suspendEvents = false;

            // 5. Manually fire a final 'load' event to update the grid's scrollbar and notify other listeners.
            me.fire('load', {items: me.items, postChunkLoad: true, total: me.chunkingTotal});

            delete me.chunkingTotal;

            return me.count
        }

        const returnValue = super.add(items);

        // If we use add() initially instead of setting `data`, we need to set the loaded flag here.
        me.isLoaded = true;

        return returnValue // Pass raw item directly
    }

    /**
     * Triggered after the currentPage config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCurrentPage(value, oldValue) {
        oldValue && this.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        let me = this;

        if (me.configsApplied) {
            if (value) {
                if (oldValue) {
                    me.clear()
                }

                me.isLoading = false;

                me.add(value, me.autoInitRecords)
            }
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        super.afterSetFilters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteFilter && me.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetModel(value, oldValue) {
        if (value) {
            value.storeId = this.id
        }
    }

    /**
     * Triggered after the pageSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPageSize(value, oldValue) {
        if (oldValue) {
            this._currentPage = 1; // silent update
            this.load()
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        super.afterSetSorters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteSort && me.load()
    }

    /**
     * @param {Object|String|null} value
     * @param {Object|String|null} oldValue
     * @protected
     * @returns {Object|null}
     */
    beforeSetApi(value, oldValue) {
        if (Neo.typeOf(value) === 'String') {
            value = {
                create : value + '.create',
                destroy: value + '.destroy',
                read   : value + '.read',
                update : value + '.update'
            }
        }

        return value
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     * @returns {*}
     */
    beforeSetData(value, oldValue) {
        if (value) {
            this.isLoading = true;

            // value = this.createRecord(value)
        }

        return value
    }



    /**
     * @param {Neo.data.Model|Object} value
     * @param {Neo.data.Model|Object} oldValue
     * @protected
     * @returns {Neo.data.Model}
     */
    beforeSetModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _Model_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Converts an object or array of objects into records
     * @param {Object|Object[]} config
     * @returns {Object|Object[]} Array in case an array was passed
     */
    createRecord(config) {
        let isArray = true;

        if (config) {
            if (!Array.isArray(config)) {
                isArray = false;
                config  = [config]
            }

            let me  = this,
                i   = 0,
                len = config.length,
                item;

            for (; i < len; i++) {
                item = config[i]

                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
                    config[i] = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item)
                }
            }
        }

        return isArray ? config : config[0]
    }

    /**
     * Overrides collection.Base:find() to ensure the returned item(s) are Record instances.
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]|null}
     */
    find(property, value, returnFirstMatch=false) {
        const result = super.find(property, value, returnFirstMatch);

        if (returnFirstMatch) {
            return result ? this.get(result[this.keyProperty]) : null;
        } else {
            return result.map(item => this.get(item[this.keyProperty]));
        }
    }

    /**
     * Overrides collection.Base:findBy() to ensure the returned item(s) are Record instances.
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.count The end index (up to, last value excluded)
     * @returns {Array}
     */
    findBy(fn, scope=this, start=0, end=this.count) {
        const result = super.findBy(fn, scope, start, end);
        return result.map(item => this.get(item[this.keyProperty]));
    }

    /**
     * Overrides collection.Base:forEach() to ensure the iterated item is a Record instance.
     * @param {Function} fn The function to execute for each record.
     * @param {Object} [scope] Value to use as `this` when executing `fn`.
     */
    forEach(fn, scope) {
        const me = this;
        for (let i = 0; i < me.count; i++) {
            fn.call(scope || me, me.getAt(i), i, me.items);
        }
    }

    /**
     * Overrides collection.Base:get() to ensure the returned item is a Record instance.
     * @param {Number|String} key
     * @returns {Object|null}
     */
    get(key) {
        let me   = this,
            item = super.get(key); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item);
            const index  = me.indexOf(item);

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(key, record);
            if (index !== -1) {
                me._items[index] = record
            }

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(key, record);
                    me.allItems._items[masterIndex] = record
                }
            }
            return record
        }
        return item // Already a record or null
    }

    /**
     * Overrides collection.Base:getAt() to ensure the returned item is a Record instance.
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        let me   = this,
            item = super.getAt(index); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item);

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(record[me.keyProperty], record);
            me._items[index] = record;

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(record[me.keyProperty], record);
                    me.allItems._items[masterIndex] = record
                }
            }
            return record
        }
        return item // Already a record or undefined
    }

    /**
     * @returns {String}
     */
    getKeyProperty() {
        return this.keyProperty || this.model.keyProperty
    }

    /**
     * Convenience shortcut to check for int based keyProperties
     * @returns {String|null} lowercase value of the model field type
     */
    getKeyType() {
        let me       = this,
            {model}  = me,
            keyField = model?.getField(me.getKeyProperty());

        return keyField?.type?.toLowerCase() || null
    }

    /**
     * Converts a data object into a Record instance or returns it if it is already one.
     * This method is called by add() and insert() when init=true (default).
     * @param {Object} data The data object or Record instance
     * @returns {Object} The Record instance
     */
    initRecord(data) {
        if (_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(data)) {
            return data
        }

        return this.get(data[this.getKeyProperty()])
    }

    /**
     * Overrides collection.Base: insert() to convert items into records if needed.
     *
     * **Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **Lazy Mode (`init=false`):**
     * Inserts raw data directly. Instantiates records only on access.
     * Returns an `Array` of the inserted raw data objects.
     *
     * @param {Number} index The index to insert at
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records
     * @returns {Object[]|Neo.data.Model[]} The inserted raw items or created records
     */
    insert(index, item, init=this.autoInitRecords) {
        let me    = this,
            items = super.insert(index, item);

        if (init) {
            return items.map(i => me.get(i[me.getKeyProperty()]))
        }

        return items
    }

    /**
     * @param {Object} opts={}
     * @param {Object} opts.data
     * @param {Object} opts.headers
     * @param {String} opts.method DELETE, GET, POST, PUT
     * @param {Object} opts.params
     * @param {String} opts.responseType
     * @param {Object} opts.scope
     * @param {String} opts.url
     * @returns {Promise<Object|Object[]>}
     * @protected
     */
    async load(opts={}) {
        let me     = this,
            params = {page: me.currentPage, pageSize: me.pageSize, ...opts.params};

        if (me.remoteFilter) {
            params.filters = me.exportFilters()
        }

        if (me.remoteSort) {
            params.sorters = me.exportSorters()
        }

        if (me.api) {
            let apiArray = me.api.read.split('.'),
                fn       = apiArray.pop(),
                service  = Neo.ns(apiArray.join('.'));

            if (!service) {
                console.error('Api is not defined', this)
            } else {
                const response = await service[fn](params);

                if (response.success) {
                    me.totalCount = response.totalCount;
                    me.data       = Neo.ns(me.responseRoot, false, response); // fires the load event
                    me.isLoaded   = true;

                    return me.data
                }

                return null
            }
        } else {
            opts.url ??= me.url;

            try {
                let data;

                // Fallback for non-browser based envs like nodejs
                if (globalThis.process?.release) {
                    const { readFile } = await import(/* webpackIgnore: true */ 'fs/promises');
                    const content = await readFile(opts.url, 'utf-8');
                    data = {json: JSON.parse(content)};
                } else {
                    data = await Neo.Xhr.promiseJson(opts);
                }

                if (data) {
                    me.data = Neo.ns(me.responseRoot, false, data.json) || data.json // fires the load event
                }

                me.isLoaded = true;

                return data?.json || null
            } catch(err) {
                console.error('Error for Neo.Xhr.request', {id: me.id, error: err, url: opts.url});
                return null
            }
        }
    }

    /**
     * @param {Object} opts
     */
    onCollectionMutate(opts) {
        let me = this;

        if (me.isConstructed && !me.isLoading) {
            me.fire('load', {items: me.items, total: me.chunkingTotal});
        }
    }

    /**
     *
     */
    onCollectionSort() {
        let me = this;

        if (me.isConstructed) {
            me.fire('load', {items: me.items})
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.data) {
            me.afterSetData(me.data)
        }

        // Being constructed does not mean that related afterSetStore() methods got executed
        // => break the sync flow to ensure potential listeners got applied
        Promise.resolve().then(() => {
            if (me.isLoaded) {
                me.fire('load', {items: me.items})
            } else if (me.autoLoad) {
                me.load()
            }
        })
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        let me = this;

        if (me.remoteFilter) {
            me._currentPage = 1; // silent update
            me.load()
        } else {
            super.onFilterChange(opts)
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object} data.record
     */
    onRecordChange(data) {
        this.fire('recordChange', {
            ...data,
            index: this.indexOf(data.record)
        })
    }

    /**
     * @param {Object} opts={}
     * @param {String} opts.direction
     * @param {String} opts.property
     */
    sort(opts={}) {
        let me = this;

        me._currentPage = 1; // silent update

        if (me.configsApplied) {
            if (opts.direction) {
                me.sorters = [{
                    direction: opts.direction,
                    property : opts.property
                }]
            } else {
                if (!me.remoteSort) {
                    me.sorters = [{
                        direction: 'ASC',
                        property : initialIndexSymbol
                    }]
                }
            }
        }
    }
    /**
     * Serializes the instance into a JSON-compatible object for the Neural Link.
     * @returns {Object}
     */
    toJSON() {
        let me = this;

        return {
            ...super.toJSON(),
            autoInitRecords : me.autoInitRecords,
            autoLoad        : me.autoLoad,
            currentPage     : me.currentPage,
            initialChunkSize: me.initialChunkSize,
            isGrouped       : me.isGrouped,
            isLoaded        : me.isLoaded,
            isLoading       : me.isLoading,
            model           : me.model?.toJSON(),
            pageSize        : me.pageSize,
            remoteFilter    : me.remoteFilter,
            remoteSort      : me.remoteSort,
            totalCount      : me.totalCount,
            url             : me.url
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ },

/***/ "./src/manager/Store.mjs"
/*!*******************************!*\
  !*** ./src/manager/Store.mjs ***!
  \*******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/manager/Base.mjs");


/**
 * @class Neo.manager.Store
 * @extends Neo.manager.Base
 * @singleton
 */
class Store extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.manager.Store'
         * @protected
         */
        className: 'Neo.manager.Store',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);
        
        // Alias Neo.getStore to this manager?
        // Neo.getStore = this.get.bind(this);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ0c7QUFDTTs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFZO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWE7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUscUJBQXFCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvTW9kZWwubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZGF0YS9SZWNvcmRGYWN0b3J5Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvU3RvcmUubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbWFuYWdlci9TdG9yZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IFJlY29yZEZhY3RvcnkgIGZyb20gJy4vUmVjb3JkRmFjdG9yeS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9IGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGF0YS5Nb2RlbFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBNb2RlbCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXRhLk1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfG51bGx9IGZpZWxkc19cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBmaWVsZHNfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnZGVlcEFycmF5cycsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBrZXlQcm9wZXJ0eV89J2lkJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGtleVByb3BlcnR5XzogJ2lkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzdG9yZUlkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGNvbmZpZyB0byB0cnVlIGluIGNhc2UgeW91IHdhbnQgdG8gdHJhY2sgbW9kaWZpZWQgZmllbGRzLlxuICAgICAgICAgKiBCZSBhd2FyZSB0aGF0IHRoaXMgd2lsbCBkb3VibGUgdGhlIGFtb3VudCBvZiBkYXRhIGluc2lkZSBlYWNoIHJlY29yZCxcbiAgICAgICAgICogc2luY2UgZWFjaCBmaWVsZCB3aWxsIGdldCBhbiBvcmlnaW5hbCB2YWx1ZSBmbGFnLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB0cmFja01vZGlmaWVkRmllbGRzPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0cmFja01vZGlmaWVkRmllbGRzOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgc3RvcmluZyBhbGwgZmllbGRzLCB3aGljaCBoYXZlIGEgY2FsY3VsYXRlIHByb3BlcnR5XG4gICAgICogQG1lbWJlciB7TWFwfSBjYWxjdWxhdGVkRmllbGRzTWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVkRmllbGRzTWFwID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBzdG9yaW5nIGFsbCBmaWVsZHMgaW5zaWRlIGEgZmxhdCBtYXAgPT4gbmVzdGVkIGZpZWxkcyBpbmNsdWRlZFxuICAgICAqIEBtZW1iZXIge01hcH0gZmllbGRzTWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaWVsZHNNYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNOZXN0ZWRGaWVsZHM9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaGFzTmVzdGVkRmllbGRzID0gZmFsc2VcblxuICAgIC8qKlxuICAgICBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZpZWxkcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpZWxkcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVGaWVsZHNNYXAodmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBGaWVsZHMgY2FuIGdldCBjaGFuZ2VkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB0aGUgbW9kZWwgaW5zdGFuY2UgaXMgZ2V0dGluZyBjb25zdHJ1Y3RlZC5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0aGUgbGF0ZXN0IHN0YXRlIGJlZm9yZSBjb25zdHJ1Y3Rpb24gJiBob25vciBydW4tdGltZSBjaGFuZ2VzLlxuICAgICAgICAgICAgaWYgKG1lLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBSZWNvcmRGYWN0b3J5LmNyZWF0ZVJlY29yZENsYXNzKG1lLCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYSBmaWVsZCBjb25maWcgYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaWVsZCBjb25maWcgb2JqZWN0IG9yIG51bGwgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgZ2V0RmllbGQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHNNYXAuZ2V0KG5hbWUpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIGZpZWxkIHR5cGUgYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFRoZSBsb3dlcmNhc2UgZmllbGQgdHlwZSBvciBudWxsIGlmIG5vIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIGdldEZpZWxkVHlwZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkKG5hbWUpPy50eXBlPy50b0xvd2VyQ2FzZSgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBpbnN0YW5jZSBpbnRvIGEgSlNPTi1jb21wYXRpYmxlIG9iamVjdCBmb3IgdGhlIE5ldXJhbCBMaW5rLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGZpZWxkcyAgICAgICAgICAgICA6IG1lLnNlcmlhbGl6ZUNvbmZpZyhtZS5maWVsZHMpLFxuICAgICAgICAgICAga2V5UHJvcGVydHkgICAgICAgIDogbWUua2V5UHJvcGVydHksXG4gICAgICAgICAgICBzdG9yZUlkICAgICAgICAgICAgOiBtZS5zdG9yZUlkLFxuICAgICAgICAgICAgdHJhY2tNb2RpZmllZEZpZWxkczogbWUudHJhY2tNb2RpZmllZEZpZWxkc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZmllbGRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1Jvb3Q9dHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoPScnXG4gICAgICovXG4gICAgdXBkYXRlRmllbGRzTWFwKGZpZWxkcywgaXNSb290PXRydWUsIHBhdGg9JycpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHtjYWxjdWxhdGVkRmllbGRzTWFwLCBmaWVsZHNNYXB9ID0gbWUsXG4gICAgICAgICAgICBmaWVsZE5hbWU7XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgICAgY2FsY3VsYXRlZEZpZWxkc01hcC5jbGVhcigpO1xuICAgICAgICAgICAgZmllbGRzTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBtZS5oYXNOZXN0ZWRGaWVsZHMgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgZmllbGROYW1lID0gcGF0aCArIGZpZWxkLm5hbWVcblxuICAgICAgICAgICAgaWYgKGZpZWxkLmZpZWxkcykge1xuICAgICAgICAgICAgICAgIG1lLmhhc05lc3RlZEZpZWxkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlRmllbGRzTWFwKGZpZWxkLmZpZWxkcywgZmFsc2UsIGZpZWxkLm5hbWUgKyAnLicpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkc01hcC5zZXQoZmllbGROYW1lLCBmaWVsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmllbGQuY2FsY3VsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRGaWVsZHNNYXAuc2V0KGZpZWxkTmFtZSwgZmllbGQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTW9kZWwpO1xuIiwiaW1wb3J0IEJhc2UgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IE1vZGVsIGZyb20gJy4vTW9kZWwubWpzJztcblxuY29uc3RcbiAgICBkYXRhU3ltYm9sICAgICAgICAgPSBTeW1ib2wuZm9yKCdkYXRhJyksXG4gICAgaW5pdGlhbEluZGV4U3ltYm9sID0gU3ltYm9sLmZvcignaW5pdGlhbEluZGV4JyksXG4gICAgaXNNb2RpZmllZFN5bWJvbCAgID0gU3ltYm9sLmZvcignaXNNb2RpZmllZCcpLFxuICAgIG9yaWdpbmFsRGF0YVN5bWJvbCA9IFN5bWJvbC5mb3IoJ29yaWdpbmFsRGF0YScpO1xuXG5sZXQgaW5zdGFuY2U7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kYXRhLlJlY29yZEZhY3RvcnlcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgUmVjb3JkRmFjdG9yeSBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuUmVjb3JkRmFjdG9yeSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRhdGEuUmVjb3JkRmFjdG9yeScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlY29yZE5hbWVzcGFjZT0nTmVvLmRhdGEucmVjb3JkJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVjb3JkTmFtZXNwYWNlOiAnTmVvLmRhdGEucmVjb3JkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNpbmdsZXRvbj10cnVlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbW9kZWwtYmFzZWQgZGVmYXVsdCB2YWx1ZXMgdG8gYSBkYXRhIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBtb2RlbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgYXNzaWduRGVmYXVsdFZhbHVlcyhkYXRhLCBtb2RlbCkge1xuICAgICAgICBtb2RlbC5maWVsZHNNYXAuZm9yRWFjaCgoZmllbGQsIGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IE5lby5pc0Z1bmN0aW9uKGZpZWxkLmRlZmF1bHRWYWx1ZSkgPyBmaWVsZC5kZWZhdWx0VmFsdWUoKSA6IGZpZWxkLmRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIGFsd2F5cyB1c2UgTmVvLmFzc2lnblRvTnMoKSA9PiB0aGUgY2hlY2sgaXMganVzdCBmb3IgaW1wcm92aW5nIHRoZSBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5oYXNOZXN0ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgTmVvLmFzc2lnblRvTnMoZmllbGROYW1lLCBkZWZhdWx0VmFsdWUsIGRhdGEsIGZhbHNlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVtmaWVsZE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtmaWVsZE5hbWVdID0gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEuZmllbGRcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEucGF0aD0nJ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnByb3RvXG4gICAgICovXG4gICAgY3JlYXRlRmllbGQoe2ZpZWxkLCBtb2RlbCwgcGF0aD0nJywgcHJvdG99KSB7XG4gICAgICAgIGxldCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lLFxuICAgICAgICAgICAgZmllbGRQYXRoID0gcGF0aCA9PT0gJycgPyBmaWVsZE5hbWUgOiBgJHtwYXRofS4ke2ZpZWxkTmFtZX1gLFxuICAgICAgICAgICAgcHJvcGVydGllcztcblxuICAgICAgICBpZiAoZmllbGQuZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZC5maWVsZHMuZm9yRWFjaChjaGlsZEZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZpZWxkKHtmaWVsZDogY2hpbGRGaWVsZCwgbW9kZWwsIHBhdGg6IGZpZWxkUGF0aCwgcHJvdG99KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgW2ZpZWxkUGF0aF06IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5oYXNOZXN0ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmVvLm5zKGZpZWxkUGF0aCwgZmFsc2UsIHRoaXNbZGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2RhdGFTeW1ib2xdW2ZpZWxkTmFtZV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzOiB7W2ZpZWxkUGF0aF06IGluc3RhbmNlLnBhcnNlUmVjb3JkVmFsdWUoe3JlY29yZDogdGhpcywgZmllbGQsIHZhbHVlfSl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZDogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGVSZWNvcmQobW9kZWwsIGNvbmZpZykge1xuICAgICAgICBsZXQgcmVjb3JkQ2xhc3MgPSBOZW8ubnMoYCR7dGhpcy5yZWNvcmROYW1lc3BhY2V9LiR7bW9kZWwuY2xhc3NOYW1lfS4ke21vZGVsLmlkfWApO1xuXG4gICAgICAgIGlmICghcmVjb3JkQ2xhc3MpIHtcbiAgICAgICAgICAgIHJlY29yZENsYXNzID0gdGhpcy5jcmVhdGVSZWNvcmRDbGFzcyhtb2RlbClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgcmVjb3JkQ2xhc3MoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGU9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNyZWF0ZVJlY29yZENsYXNzKG1vZGVsLCBvdmVyd3JpdGU9ZmFsc2UpIHtcbiAgICAgICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBgJHt0aGlzLnJlY29yZE5hbWVzcGFjZX0uJHttb2RlbC5jbGFzc05hbWV9LiR7bW9kZWwuaWR9YCxcbiAgICAgICAgICAgICAgICBucyAgICAgICAgPSBOZW8ubnMoY2xhc3NOYW1lKSxcbiAgICAgICAgICAgICAgICBrZXksIG5zQXJyYXksIGNscztcblxuICAgICAgICAgICAgaWYgKCFucyB8fCBvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICBuc0FycmF5ID0gY2xhc3NOYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAga2V5ICAgICA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICAgICAgbnMgICAgICA9IE5lby5ucyhuc0FycmF5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjbHMgICAgID0gbnNba2V5XSA9IGNsYXNzIFJlY29yZCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIG1pbmlmeSB0aGUgY3RvciBjbGFzcyBuYW1lIGluIGRpc3QvcHJvZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0aWMgbmFtZSA9ICdSZWNvcmQnO1xuXG4gICAgICAgICAgICAgICAgICAgIFtkYXRhU3ltYm9sXSAgICAgICAgID0ge307XG4gICAgICAgICAgICAgICAgICAgIFtpbml0aWFsSW5kZXhTeW1ib2xdID0gbnVsbFxuXG4gICAgICAgICAgICAgICAgICAgIGdldCBpc01vZGlmaWVkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIU5lby5pc0VxdWFsKG1lW2RhdGFTeW1ib2xdLCBtZVtvcmlnaW5hbERhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVbaXNNb2RpZmllZFN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGNvbmZpZywgaW5pdGlhbEluZGV4U3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lW2luaXRpYWxJbmRleFN5bWJvbF0gPSBjb25maWdbaW5pdGlhbEluZGV4U3ltYm9sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnW2luaXRpYWxJbmRleFN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gaW5zdGFuY2UuYXNzaWduRGVmYXVsdFZhbHVlcyhjb25maWcsIG1vZGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtvcmlnaW5hbERhdGFTeW1ib2xdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0T3JpZ2luYWwoY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtpc01vZGlmaWVkU3ltYm9sXSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldFNpbGVudChjb25maWcpIC8vIFdlIGRvIG5vdCB3YW50IHRvIGZpcmUgY2hhbmdlIGV2ZW50cyB3aGVuIGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gbnVsbCBpbiBjYXNlIHRoZSBtb2RlbCBkb2VzIG5vdCB1c2UgdHJhY2tNb2RpZmllZEZpZWxkcywgdHJ1ZSBpbiBjYXNlIGEgY2hhbmdlIHdhcyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaXNNb2RpZmllZEZpZWxkKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVNjb3BlLCBvcmlnaW5hbERhdGFTY29wZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5oYXNOZXN0ZWRGaWVsZHMgJiYgZmllbGROYW1lPy5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuc0FycmF5ID0gZmllbGROYW1lLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICAgICAgICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhU2NvcGUgICAgICAgICA9IE5lby5ucyhuc0FycmF5LCBmYWxzZSwgbWVbZGF0YVN5bWJvbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbERhdGFTY29wZSA9IE5lby5ucyhuc0FycmF5LCBmYWxzZSwgbWVbb3JpZ2luYWxEYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhU2NvcGUgICAgICAgICA9IG1lW2RhdGFTeW1ib2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbERhdGFTY29wZSA9IG1lW29yaWdpbmFsRGF0YVN5bWJvbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmllbGQgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbW9kZWwuZ2V0RmllbGQoZmllbGROYW1lKSAmJiAgICAgICAgLy8gQ2hlY2sgZm9yIGxlYWYgZmllbGRzIChjb3VsZCBiZSBleGNsdWRlZCBpbnNpZGUgdGhlIHJlYWwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5oYXNPd24oZGF0YVNjb3BlLCBmaWVsZE5hbWUpIC8vIENoZWNrIHRoZSBkYXRhIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGhlIHJlY29yZCBkb2VzIG5vdCBjb250YWluIHRoZSBmaWVsZCcsIGZpZWxkTmFtZSwgbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFOZW8uaXNFcXVhbChkYXRhU2NvcGVbZmllbGROYW1lXSwgb3JpZ2luYWxEYXRhU2NvcGVbZmllbGROYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgc2luZ2xlIHNvdXJjZSBvZiB0cnV0aCBmb3IgcmVjb3JkIGZpZWxkIGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgICAqIEV4ZWN1dGVzIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcygpLCBhbmQgY2FuIGdldCB1c2VkIHZpYTpcbiAgICAgICAgICAgICAgICAgICAgICogLSBOZW8udXRpbC5GdW5jdGlvbjpjcmVhdGVTZXF1ZW5jZSgpXG4gICAgICAgICAgICAgICAgICAgICAqIC0gTmVvLnV0aWwuRnVuY3Rpb246aW50ZXJjZXB0KCksXG4gICAgICAgICAgICAgICAgICAgICAqIHRvIFwibGlzdGVuXCIgdG8gZmllbGQgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGEuZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgc2lsZW50PWZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBub3RpZnlDaGFuZ2UoZGF0YSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbSA9IHsuLi5kYXRhLCBzaWxlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRSZWNvcmRGaWVsZHMocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQnVsay11cGRhdGUgbXVsdGlwbGUgcmVjb3JkIGZpZWxkcyBhdCBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0KGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPcmlnaW5hbChmaWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoZmllbGRzKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEJ1bGstdXBkYXRlIG11bHRpcGxlIHJlY29yZCBmaWVsZHMgYXQgb25jZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXQoZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZSh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbW9kZWwgdXNlcyB0cmFja01vZGlmaWVkRmllbGRzLCB3ZSB3aWxsIHN0b3JlIHRoZSBvcmlnaW5hbCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAqIGZvciB0cmFja2luZyB0aGUgZGlydHkgc3RhdGUgKGNoYW5nZWQgZmllbGRzKVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNldE9yaWdpbmFsKGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UmVjb3JkRmllbGRzKHtmaWVsZHMsIG1vZGVsLCByZWNvcmQ6IHRoaXMsIHNpbGVudDogdHJ1ZSwgdXNlT3JpZ2luYWxEYXRhOiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBCdWxrLXVwZGF0ZSBtdWx0aXBsZSByZWNvcmQgZmllbGRzIGF0IG9uY2Ugd2l0aG91dCB0cmlnZ2VyaW5nIGEgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHNldFNpbGVudChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlKHtmaWVsZHMsIG1vZGVsLCByZWNvcmQ6IHRoaXN9LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFdoZW4gdXNpbmcgSlNPTi5zdHJpbmdpZnkodGhpcyksIHdlIHdhbnQgdG8gZ2V0IHRoZSByYXcgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh0aGlzW2RhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1vZGVsLmZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY3JlYXRlRmllbGQoe2ZpZWxkLCBtb2RlbCwgcHJvdG86IGNscy5wcm90b3R5cGV9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbHMucHJvdG90eXBlLCAnaXNSZWNvcmQnLCB7dmFsdWU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xzLCAnaXNDbGFzcycsIHt2YWx1ZTogdHJ1ZX0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5zW2tleV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBhIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBhIGNsYXNzIGNyZWF0ZWQgYnkgdGhpcyBmYWN0b3J5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUmVjb3JkKHJlY29yZCkge1xuICAgICAgICByZXR1cm4gcmVjb3JkPy5pc1JlY29yZCB8fCBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhIHJlY29yZCBmaWVsZC5cbiAgICAgKiBFLmcuIG15UmVjb3JkLmZvbyA9ICdiYXInO1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb3B0cy5maWVsZHMgRWFjaCBmaWVsZCBvYmplY3QgY29udGFpbnMgdGhlIGtleXM6IG5hbWUsIG9sZFZhbHVlLCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG9wdHMubW9kZWwgVGhlIG1vZGVsIGluc3RhbmNlIG9mIHRoZSBjaGFuZ2VkIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnJlY29yZFxuICAgICAqL1xuICAgIG9uUmVjb3JkQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgTmVvLmdldChvcHRzLm1vZGVsLnN0b3JlSWQpPy5vblJlY29yZENoYW5nZShvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGEuZmllbGRcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgIFtkYXRhLnZhbHVlPW51bGxdXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBbZGF0YS5yZWNvcmRDb25maWc9bnVsbF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkYXRhLnVzZU9yaWdpbmFsRGF0YT1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBwYXJzZVJlY29yZFZhbHVlKHtyZWNvcmQsIGZpZWxkLCB2YWx1ZT1udWxsLCByZWNvcmRDb25maWc9bnVsbCwgdXNlT3JpZ2luYWxEYXRhPWZhbHNlfSkge1xuICAgICAgICBpZiAoZmllbGQuY2FsY3VsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQuY2FsY3VsYXRlKHJlY29yZFt1c2VPcmlnaW5hbERhdGEgPyBvcmlnaW5hbERhdGFTeW1ib2wgOiBkYXRhU3ltYm9sXSwgZmllbGQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmllbGQuY29udmVydCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC5jb252ZXJ0KHZhbHVlLCByZWNvcmQpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmllbGROYW1lID0gZmllbGQubmFtZSxcbiAgICAgICAgICAgIHttYXBwaW5nLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCwgbnVsbGFibGV9ID0gZmllbGQsXG4gICAgICAgICAgICBvbGRWYWx1ZSAgPSByZWNvcmRDb25maWc/LltmaWVsZE5hbWVdIHx8IHJlY29yZFtmaWVsZE5hbWVdLFxuICAgICAgICAgICAgdHlwZSAgICAgID0gZmllbGQudHlwZT8udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBvbmx5IHRyaWdnZXIgbWFwcGluZ3MgZm9yIGluaXRpYWwgdmFsdWVzXG4gICAgICAgIC8vIGR5bmFtaWMgY2hhbmdlcyBvZiBhIGZpZWxkIHdpbGwgbm90IHBhc3MgdGhlIHJlY29yZENvbmZpZ1xuICAgICAgICBpZiAobWFwcGluZyAmJiByZWNvcmRDb25maWcpIHtcbiAgICAgICAgICAgIGxldCBucyAgPSBtYXBwaW5nLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAga2V5ID0gbnMucG9wKCk7XG5cbiAgICAgICAgICAgIG5zICAgID0gTmVvLm5zKG5zLCB0cnVlLCByZWNvcmRDb25maWcpO1xuICAgICAgICAgICAgdmFsdWUgPSBuc1trZXldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ21heExlbmd0aCcpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWU/LnRvU3RyaW5nKCkubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXR0aW5nIHJlY29yZCBmaWVsZDogJHtmaWVsZE5hbWV9IHZhbHVlOiAke3ZhbHVlfSBjb25mbGljdHMgd2l0aCBtYXhMZW5ndGg6ICR7bWF4TGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdtaW5MZW5ndGgnKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlPy50b1N0cmluZygpLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0dGluZyByZWNvcmQgZmllbGQ6ICR7ZmllbGROYW1lfSB2YWx1ZTogJHt2YWx1ZX0gY29uZmxpY3RzIHdpdGggbWluTGVuZ3RoOiAke21pbkxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCAnbnVsbGFibGUnKSkge1xuICAgICAgICAgICAgaWYgKG51bGxhYmxlID09PSBmYWxzZSAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0dGluZyByZWNvcmQgZmllbGQ6ICR7ZmllbGROYW1lfSB2YWx1ZTogJHt2YWx1ZX0gY29uZmxpY3RzIHdpdGggbnVsbGFibGU6ICR7bnVsbGFibGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RhdGUnICYmIE5lby50eXBlT2YodmFsdWUpICE9PSAnRGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmbG9hdCcgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdodG1sJyAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICcnXG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICgodHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ2ludGVnZXInKSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJyc7XG4gICAgICAgICAgICB2YWx1ZSA9ICB2YWx1ZS5yZXBsYWNlKC8oPChbXj5dKyk+KS9pZywgJycpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgZGF0YS5maWVsZE5hbWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtSZWNvcmR9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICBkYXRhLnVzZU9yaWdpbmFsRGF0YT1mYWxzZSB0cnVlIHdpbGwgYXBwbHkgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWxEYXRhIHN5bWJvbFxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgICAgICAgIGRhdGEudmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0UmVjb3JkRGF0YSh7ZmllbGROYW1lLCBtb2RlbCwgcmVjb3JkLCB1c2VPcmlnaW5hbERhdGE9ZmFsc2UsIHZhbHVlfSkge1xuICAgICAgICBpZiAodXNlT3JpZ2luYWxEYXRhICYmICFtb2RlbC50cmFja01vZGlmaWVkRmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzY29wZSA9IHVzZU9yaWdpbmFsRGF0YSA/IG9yaWdpbmFsRGF0YVN5bWJvbCA6IGRhdGFTeW1ib2w7XG5cbiAgICAgICAgaWYgKG1vZGVsLmhhc05lc3RlZEZpZWxkcyAmJiBmaWVsZE5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgbGV0IG5zLCBuc0FycmF5O1xuXG4gICAgICAgICAgICBuc0FycmF5ICAgPSBmaWVsZE5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGZpZWxkTmFtZSA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICBucyAgICAgICAgPSBOZW8ubnMobnNBcnJheSwgdHJ1ZSwgcmVjb3JkW3Njb3BlXSk7XG5cbiAgICAgICAgICAgIG5zW2ZpZWxkTmFtZV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjb3JkW3Njb3BlXVtmaWVsZE5hbWVdID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSAgICAgICBkYXRhLmNoYW5nZWRGaWVsZHM9W10gSW50ZXJuYWwgZmxhZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGEuZmllbGRzXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICAgZGF0YS5zaWxlbnQ9ZmFsc2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICBkYXRhLnVzZU9yaWdpbmFsRGF0YT1mYWxzZSB0cnVlIHdpbGwgYXBwbHkgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWxEYXRhIHN5bWJvbFxuICAgICAqL1xuICAgIHNldFJlY29yZEZpZWxkcyh7Y2hhbmdlZEZpZWxkcz1bXSwgZmllbGRzLCBtb2RlbCwgcmVjb3JkLCBzaWxlbnQ9ZmFsc2UsIHVzZU9yaWdpbmFsRGF0YT1mYWxzZX0pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHtjYWxjdWxhdGVkRmllbGRzTWFwLCBmaWVsZHNNYXAsIHRyYWNrTW9kaWZpZWRGaWVsZHN9ID0gbW9kZWwsXG4gICAgICAgICAgICBmaWVsZEV4aXN0cywgaGFzQ2hhbmdlZEZpZWxkcywgb2xkVmFsdWU7XG5cbiAgICAgICAgaWYgKCF0cmFja01vZGlmaWVkRmllbGRzICYmIHVzZU9yaWdpbmFsRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZW50cmllcyhmaWVsZHMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgZmllbGRFeGlzdHMgPSBmaWVsZHNNYXAuaGFzKGtleSk7XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpICYmICFmaWVsZEV4aXN0cykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbY2hpbGRLZXksIGNoaWxkVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNldFJlY29yZEZpZWxkcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzOiB7W2Ake2tleX0uJHtjaGlsZEtleX1gXTogY2hpbGRWYWx1ZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZU9yaWdpbmFsRGF0YVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZWNvcmRba2V5XTtcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IG1lLnBhcnNlUmVjb3JkVmFsdWUoe3JlY29yZCwgZmllbGQ6IG1vZGVsLmdldEZpZWxkKGtleSksIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKG9sZFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2V0UmVjb3JkRGF0YSh7ZmllbGROYW1lOiBrZXksIG1vZGVsLCByZWNvcmQsIHVzZU9yaWdpbmFsRGF0YSwgdmFsdWV9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrTW9kaWZpZWRGaWVsZHMgJiYgIXVzZU9yaWdpbmFsRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkW2lzTW9kaWZpZWRTeW1ib2xdID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkcy5wdXNoKHtuYW1lOiBrZXksIG9sZFZhbHVlLCB2YWx1ZX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBoYXNDaGFuZ2VkRmllbGRzID0gT2JqZWN0LmtleXMoY2hhbmdlZEZpZWxkcykubGVuZ3RoID4gMDtcblxuICAgICAgICBpZiAoaGFzQ2hhbmdlZEZpZWxkcykge1xuICAgICAgICAgICAgY2FsY3VsYXRlZEZpZWxkc01hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZWNvcmRba2V5XTtcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IG1lLnBhcnNlUmVjb3JkVmFsdWUoe3JlY29yZCwgZmllbGQ6IG1vZGVsLmdldEZpZWxkKGtleSksIHVzZU9yaWdpbmFsRGF0YX0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChvbGRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNldFJlY29yZERhdGEoe2ZpZWxkTmFtZToga2V5LCBtb2RlbCwgcmVjb3JkLCB1c2VPcmlnaW5hbERhdGEsIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkcy5wdXNoKHtuYW1lOiBrZXksIG9sZFZhbHVlLCB2YWx1ZX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2lsZW50ICYmICF1c2VPcmlnaW5hbERhdGEgJiYgaGFzQ2hhbmdlZEZpZWxkcykge1xuICAgICAgICAgICAgbWUub25SZWNvcmRDaGFuZ2Uoe2ZpZWxkczogY2hhbmdlZEZpZWxkcywgbW9kZWwsIHJlY29yZH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmluc3RhbmNlID0gTmVvLnNldHVwQ2xhc3MoUmVjb3JkRmFjdG9yeSk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbmNlO1xuIiwiaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiAgICAgIGZyb20gJy4uL2NvbGxlY3Rpb24vQmFzZS5tanMnO1xuaW1wb3J0IE1vZGVsICAgICAgICAgICBmcm9tICcuL01vZGVsLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgIGZyb20gJy4uL2NvcmUvT2JzZXJ2YWJsZS5tanMnO1xuaW1wb3J0IFJlY29yZEZhY3RvcnkgICBmcm9tICcuL1JlY29yZEZhY3RvcnkubWpzJztcbmltcG9ydCBTdG9yZU1hbmFnZXIgICAgZnJvbSAnLi4vbWFuYWdlci9TdG9yZS5tanMnO1xuXG5jb25zdCBpbml0aWFsSW5kZXhTeW1ib2wgPSBTeW1ib2wuZm9yKCdpbml0aWFsSW5kZXgnKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuU3RvcmVcbiAqIEBleHRlbmRzIE5lby5jb2xsZWN0aW9uLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKlxuICogQHN1bW1hcnkgQSBwb3dlcmZ1bCwgb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIHRoYXQgbWFuYWdlcyBhIHNldCBvZiBkYXRhIHJlY29yZHMuXG4gKlxuICogTmVvLmRhdGEuU3RvcmUgaXMgdGhlIGNlbnRyYWwgZGF0YSBtYW5hZ2VtZW50IGNsYXNzIGluIHRoZSBmcmFtZXdvcmsuIEl0IGhhbmRsZXMgdGhlIGxpZmVjeWNsZSBvZlxuICogZGF0YSByZWNvcmRzLCBpbmNsdWRpbmcgbG9hZGluZywgZmlsdGVyaW5nLCBzb3J0aW5nLCBhbmQgc3luY2hyb25pemF0aW9uIHdpdGggYmFja2VuZCBBUElzLlxuICpcbiAqICMjIyBSZWNvcmQgSW5zdGFudGlhdGlvbiBTdHJhdGVnaWVzOiBFYWdlciB2cy4gTGF6eSAoXCJUdXJibyBNb2RlXCIpXG4gKlxuICogVGhlIFN0b3JlIHN1cHBvcnRzIHR3byBkaXN0aW5jdCBzdHJhdGVnaWVzIGZvciBoYW5kbGluZyByZWNvcmQgY3JlYXRpb24sIGNvbnRyb2xsZWQgYnkgdGhlIGBhdXRvSW5pdFJlY29yZHNgIGNvbmZpZ1xuICogKHdoaWNoIGRlZmF1bHRzIHRvIGB0cnVlYCkgYW5kIHRoZSBgaW5pdGAgcGFyYW1ldGVyIGluIG1ldGhvZHMgbGlrZSBgYWRkKClgIGFuZCBgaW5zZXJ0KClgLlxuICpcbiAqICoqMS4gRWFnZXIgSW5zdGFudGlhdGlvbiAoRGVmYXVsdDogYGF1dG9Jbml0UmVjb3JkczogdHJ1ZWApKipcbiAqICAgIC0gKipCZWhhdmlvcioqOiBSYXcgZGF0YSBvYmplY3RzIGFyZSBpbW1lZGlhdGVseSBjb252ZXJ0ZWQgaW50byBgTmVvLmRhdGEuTW9kZWxgIGluc3RhbmNlcy5cbiAqICAgIC0gKipVc2UgQ2FzZSoqOiBTdGFuZGFyZCBvcGVyYXRpb25zLCBhZGRpbmcgc2luZ2xlIGl0ZW1zLCBpbnRlcmFjdGl2ZSBlZGl0cy5cbiAqICAgIC0gKipQcm9zKio6IFJldHVybnMgdXNhYmxlIFJlY29yZCBpbnN0YW5jZXMgaW1tZWRpYXRlbHkuIEhpZ2ggRGV2ZWxvcGVyIEV4cGVyaWVuY2UgKERYKS5cbiAqICAgIC0gKipDb25zKio6IENhbiBiZSBzbG93IGZvciBtYXNzaXZlIGRhdGFzZXRzICgxMGsrIHJlY29yZHMpLlxuICpcbiAqICoqMi4gTGF6eSBJbnN0YW50aWF0aW9uIChcIlR1cmJvIE1vZGVcIikqKlxuICogICAgLSAqKkJlaGF2aW9yKio6IFJhdyBkYXRhIG9iamVjdHMgYXJlIHN0b3JlZCBkaXJlY3RseS4gYE5lby5kYXRhLk1vZGVsYCBpbnN0YW5jZXMgYXJlIGNyZWF0ZWRcbiAqICAgICAgXCJqdXN0LWluLXRpbWVcIiBvbmx5IHdoZW4gdGhleSBhcmUgYWNjZXNzZWQgdmlhIGBnZXQoKWAsIGBnZXRBdCgpYCwgb3IgaXRlcmF0aW9uLlxuICogICAgLSAqKlVzZSBDYXNlKio6IEJ1bGsgbG9hZGluZyBsYXJnZSBkYXRhc2V0cyAoZS5nLiwgZ3JpZHMsIGNoYXJ0cyB3aXRoIHRob3VzYW5kcyBvZiBwb2ludHMpLlxuICogICAgLSAqKlByb3MqKjogTWFzc2l2ZSBwZXJmb3JtYW5jZSBnYWlucyBmb3IgaW5pdGlhbCBkYXRhIGxvYWQuIEVuYWJsZXMgaW50ZXJuYWwgXCJjaHVua2luZ1wiIHRvIHByZXZlbnQgVUkgZnJlZXplcy5cbiAqICAgIC0gKipDb25zKio6IGBhZGQoKWAgcmV0dXJucyBhIGNvdW50IGluc3RlYWQgb2YgcmVjb3Jkcy4gUmVjb3JkcyBhcmUgbm90IGF2YWlsYWJsZSB1bnRpbCBhY2Nlc3NlZC5cbiAqICAgIC0gKipIb3cgdG8gZW5hYmxlKio6XG4gKiAgICAgIC0gKipHbG9iYWwqKjogU2V0IGBhdXRvSW5pdFJlY29yZHM6IGZhbHNlYCBvbiB0aGUgU3RvcmUgY29uZmlnLlxuICogICAgICAtICoqUGVyLWNhbGwqKjogUGFzcyBgZmFsc2VgIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGFkZCgpYCBvciBgaW5zZXJ0KClgLlxuICogICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgIC8vIEdsb2JhbCBzZXR0aW5nXG4gKiAgICAgIE5lby5jcmVhdGUoU3RvcmUsIHtcbiAqICAgICAgICAgIGF1dG9Jbml0UmVjb3JkczogZmFsc2UsXG4gKiAgICAgICAgICBkYXRhOiBodWdlQXJyYXlPZkRhdGFcbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBQZXItY2FsbCBvdmVycmlkZVxuICogICAgICBzdG9yZS5hZGQoaHVnZUFycmF5T2ZEYXRhLCBmYWxzZSk7XG4gKiAgICAgIGBgYFxuICovXG5jbGFzcyBTdG9yZSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLlN0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5TdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0ZWFkIG9mIHNldHRpbmcgYW4gdXJsLCB5b3UgY2FuIGRlZmluZSB0aGUgUlBDIEJFIEFQSSBtZXRob2RzLlxuICAgICAgICAgKiBJbiBjYXNlIHRoZSA0IG1ldGhvZHMgYXJlIHVzaW5nIHRoZSBzYW1lIHNlcnZpY2UgYW5kIHRoaXMgc2VydmljZSBpcyB1c2luZyB0aGUgQ1JVRCBiYXNlZCBmbi1uYW1lcyxcbiAgICAgICAgICogeW91IGNhbiBzd2l0Y2ggdG8gYSBzdHJpbmcgYmFzZWQgc2hvcnRjdXQuXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgMiBleGFtcGxlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYXBpOiB7XG4gICAgICAgICAqICAgIGNyZWF0ZSA6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmNyZWF0ZScsXG4gICAgICAgICAqICAgIGRlc3Ryb3k6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmRlc3Ryb3knLFxuICAgICAgICAgKiAgICByZWFkICAgOiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZS5yZWFkJyxcbiAgICAgICAgICogICAgdXBkYXRlIDogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UudXBkYXRlJ1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFwaTogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UnXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd8bnVsbH0gYXBpXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBpXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgcmVjb3JkIGluc3RhbmNlcyB3aGVuIGFkZGluZyBpdGVtcy5cbiAgICAgICAgICogU2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBcIlR1cmJvIE1vZGVcIiAoTGF6eSBJbnN0YW50aWF0aW9uKSBnbG9iYWxseSBmb3IgdGhpcyBzdG9yZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0luaXRSZWNvcmRzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0UmVjb3JkczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Mb2FkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTG9hZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRQYWdlXz0xXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudFBhZ2VfOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gZGF0YV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgY2h1bmsgc2l6ZSBmb3IgYWRkaW5nIGxhcmdlIGRhdGFzZXRzLiBTZXQgdG8gMCB0byBkaXNhYmxlIGNodW5raW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGluaXRpYWxDaHVua1NpemU9MFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbENodW5rU2l6ZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzR3JvdXBlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNHcm91cGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTG9hZGVkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0xvYWRpbmc9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgYSB2YWx1ZSBvZiAwIHRvIG5vdCBsaW1pdCB0aGUgcGFnZVNpemVcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBwYWdlU2l6ZV89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VTaXplXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gbGV0IHRoZSBiYWNrZW5kIGhhbmRsZSB0aGUgZmlsdGVyaW5nLlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGJ1ZmZlcmVkIHN0b3Jlc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW1vdGVGaWx0ZXI9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZUZpbHRlcjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIGxldCB0aGUgYmFja2VuZCBoYW5kbGUgdGhlIHNvcnRpbmcuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgYnVmZmVyZWQgc3RvcmVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW90ZVNvcnQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZVNvcnQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgcGF0aCB0byB0aGUgcm9vdCBvZiB5b3VyIGRhdGEuXG4gICAgICAgICAqIElmIHRoZSByZXNwb25zZVJvb3QgaXMgJ2RhdGEnIHRoaXMgaXMgb3B0aW9uYWwuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVzcG9uc2VSb290PSdkYXRhJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVzcG9uc2VSb290OiAnZGF0YScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRvdGFsQ291bnQ9MFxuICAgICAgICAgKi9cbiAgICAgICAgdG90YWxDb3VudDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVybCBmb3IgQWpheCByZXF1ZXN0c1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdXJsPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHVybDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gdG9kb1xuICAgICAgICBtZS5vbih7XG4gICAgICAgICAgICBtdXRhdGU6IG1lLm9uQ29sbGVjdGlvbk11dGF0ZSxcbiAgICAgICAgICAgIHNvcnQgIDogbWUub25Db2xsZWN0aW9uU29ydCxcbiAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgU3RvcmVNYW5hZ2VyLnJlZ2lzdGVyKG1lKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgU3RvcmVNYW5hZ2VyLnVucmVnaXN0ZXIodGhpcyk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTogYWRkKCkgdG8gY29udmVydCBpdGVtcyBpbnRvIHJlY29yZHMgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogKioxLiBFYWdlciBNb2RlIChgaW5pdD10cnVlYCAtIERlZmF1bHQpOioqXG4gICAgICogSW1tZWRpYXRlbHkgY29udmVydHMgcmF3IGRhdGEgaW50byBgTmVvLmRhdGEuTW9kZWxgIGluc3RhbmNlcy5cbiAgICAgKiBSZXR1cm5zIGFuIGBBcnJheWAgb2YgdGhlIGNyZWF0ZWQgcmVjb3Jkcy5cbiAgICAgKlxuICAgICAqICoqMi4gTGF6eSBNb2RlIChgaW5pdD1mYWxzZWApOioqXG4gICAgICogQWRkcyByYXcgZGF0YSBkaXJlY3RseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gSW5zdGFudGlhdGVzIHJlY29yZHMgb25seSBvbiBhY2Nlc3MuXG4gICAgICpcbiAgICAgKiAtICoqQ2h1bmtpbmcgQWN0aXZlKio6IElmIGBpbml0aWFsQ2h1bmtTaXplID4gMGAgYW5kIGBpdGVtcy5sZW5ndGggPiB0aHJlc2hvbGRgOlxuICAgICAqICAgQWRkcyBpdGVtcyBpbiBjaHVua3MgdG8gcHJldmVudCBibG9ja2luZyB0aGUgQXBwIFdvcmtlciAoTWFpbiBBY3RvcikuXG4gICAgICogICBSZXR1cm5zIHRoZSBuZXcgY29sbGVjdGlvbiBgY291bnRgIChOdW1iZXIpLlxuICAgICAqXG4gICAgICogLSAqKk5vIENodW5raW5nKio6IElmIGBpbml0aWFsQ2h1bmtTaXplID09PSAwYCBvciBgaXRlbXMubGVuZ3RoIDw9IHRocmVzaG9sZGA6XG4gICAgICogICBBZGRzIHJhdyBpdGVtcyBkaXJlY3RseS5cbiAgICAgKiAgIFJldHVybnMgYW4gYEFycmF5YCBvZiB0aGUgYWRkZWQgcmF3IGRhdGEgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gMS4gRGVmYXVsdDogR2V0IHJlY29yZHMgaW1tZWRpYXRlbHlcbiAgICAgKiBjb25zdCBbbmV3UmVjb3JkXSA9IHN0b3JlLmFkZCh7bmFtZTogJ05ldyBJdGVtJ30pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyAyLiBUdXJibyBNb2RlIChObyBDaHVua2luZyk6IEdldCByYXcgb2JqZWN0c1xuICAgICAqIGNvbnN0IFtyYXdPYmplY3RdID0gc3RvcmUuYWRkKHtuYW1lOiAnSXRlbSd9LCBmYWxzZSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIDMuIFR1cmJvIE1vZGUgKENodW5raW5nKTogR2V0IG5ldyBjb3VudFxuICAgICAqIHN0b3JlLmluaXRpYWxDaHVua1NpemUgPSAxMDAwO1xuICAgICAqIGNvbnN0IG5ld0NvdW50ID0gc3RvcmUuYWRkKGh1Z2VEYXRhQXJyYXksIGZhbHNlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHNdIFRydWUgdG8gcmV0dXJuIHRoZSBjcmVhdGVkIHJlY29yZHMsIGZhbHNlIGZvciBcIlR1cmJvIE1vZGVcIlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8T2JqZWN0W118TmVvLmRhdGEuTW9kZWxbXX0gVGhlIGNvbGxlY3Rpb24gY291bnQsIHJhdyBpdGVtcywgb3IgY3JlYXRlZCByZWNvcmRzXG4gICAgICovXG4gICAgYWRkKGl0ZW0sIGluaXQ9dGhpcy5hdXRvSW5pdFJlY29yZHMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyAgICAgPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXSxcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IG1lLmluaXRpYWxDaHVua1NpemU7XG5cbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgIHN1cGVyLmFkZChpdGVtcyk7XG5cbiAgICAgICAgICAgIG1lLmlzTG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcChpID0+IG1lLmdldChpW21lLmdldEtleVByb3BlcnR5KCldKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aHJlc2hvbGQgPiAwICYmIGl0ZW1zLmxlbmd0aCA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSBtZS5jb3VudCArIGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIGNodW5rID0gaXRlbXMuc3BsaWNlKDAsIHRocmVzaG9sZCk7XG5cbiAgICAgICAgICAgIG1lLmNodW5raW5nVG90YWwgPSB0b3RhbDtcblxuICAgICAgICAgICAgLy8gMS4gQWRkIHRoZSBmaXJzdCBjaHVuay4gVGhpcyBmaXJlcyAnbXV0YXRlJyAtPiAnbG9hZCcgKHZpYSBvbkNvbGxlY3Rpb25NdXRhdGUpXG4gICAgICAgICAgICAvLyAgICBhbmQgdHJpZ2dlcnMgdGhlIGluaXRpYWwgZ3JpZCByZW5kZXIuIFRoZSAnbG9hZCcgZXZlbnQgd2lsbCBjb250YWluIHRoZSBmaW5hbCB0b3RhbCBjb3VudC5cbiAgICAgICAgICAgIHN1cGVyLmFkZChjaHVuayk7IC8vIFBhc3MgcmF3IGNodW5rIGRpcmVjdGx5XG5cbiAgICAgICAgICAgIC8vIDIuIFN1c3BlbmQgZXZlbnRzIHRvIHByZXZlbnQgdGhlIG5leHQgJ2FkZCcgZnJvbSBmaXJpbmcgJ2xvYWQnLlxuICAgICAgICAgICAgbWUuc3VzcGVuZEV2ZW50cyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIDMuIEFkZCB0aGUgcmVzdCBvZiB0aGUgaXRlbXMgc2lsZW50bHkuXG4gICAgICAgICAgICBzdXBlci5hZGQoaXRlbXMpOyAvLyBQYXNzIHJhdyBpdGVtcyBkaXJlY3RseVxuXG4gICAgICAgICAgICAvLyA0LiBSZXN1bWUgZXZlbnRzLlxuICAgICAgICAgICAgbWUuc3VzcGVuZEV2ZW50cyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyA1LiBNYW51YWxseSBmaXJlIGEgZmluYWwgJ2xvYWQnIGV2ZW50IHRvIHVwZGF0ZSB0aGUgZ3JpZCdzIHNjcm9sbGJhciBhbmQgbm90aWZ5IG90aGVyIGxpc3RlbmVycy5cbiAgICAgICAgICAgIG1lLmZpcmUoJ2xvYWQnLCB7aXRlbXM6IG1lLml0ZW1zLCBwb3N0Q2h1bmtMb2FkOiB0cnVlLCB0b3RhbDogbWUuY2h1bmtpbmdUb3RhbH0pO1xuXG4gICAgICAgICAgICBkZWxldGUgbWUuY2h1bmtpbmdUb3RhbDtcblxuICAgICAgICAgICAgcmV0dXJuIG1lLmNvdW50XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IHN1cGVyLmFkZChpdGVtcyk7XG5cbiAgICAgICAgLy8gSWYgd2UgdXNlIGFkZCgpIGluaXRpYWxseSBpbnN0ZWFkIG9mIHNldHRpbmcgYGRhdGFgLCB3ZSBuZWVkIHRvIHNldCB0aGUgbG9hZGVkIGZsYWcgaGVyZS5cbiAgICAgICAgbWUuaXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZSAvLyBQYXNzIHJhdyBpdGVtIGRpcmVjdGx5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBjdXJyZW50UGFnZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRDdXJyZW50UGFnZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgdGhpcy5sb2FkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREYXRhKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5jb25maWdzQXBwbGllZCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNsZWFyKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIG1lLmFkZCh2YWx1ZSwgbWUuYXV0b0luaXRSZWNvcmRzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgIG9sZFZhbHVlICYmIG1lLnJlbW90ZUZpbHRlciAmJiBtZS5sb2FkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZS5zdG9yZUlkID0gdGhpcy5pZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBwYWdlU2l6ZSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRQYWdlU2l6ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgICAgIHRoaXMubG9hZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U29ydGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgb2xkVmFsdWUgJiYgbWUucmVtb3RlU29ydCAmJiBtZS5sb2FkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGJlZm9yZVNldEFwaSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnU3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlIDogdmFsdWUgKyAnLmNyZWF0ZScsXG4gICAgICAgICAgICAgICAgZGVzdHJveTogdmFsdWUgKyAnLmRlc3Ryb3knLFxuICAgICAgICAgICAgICAgIHJlYWQgICA6IHZhbHVlICsgJy5yZWFkJyxcbiAgICAgICAgICAgICAgICB1cGRhdGUgOiB2YWx1ZSArICcudXBkYXRlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGJlZm9yZVNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyB2YWx1ZSA9IHRoaXMuY3JlYXRlUmVjb3JkKHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx8T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx8T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuTW9kZWx9XG4gICAgICovXG4gICAgYmVmb3JlU2V0TW9kZWwodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlPy5kZXN0cm95KCk7XG5cbiAgICAgICAgcmV0dXJuIENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZSh2YWx1ZSwgTW9kZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IG9yIGFycmF5IG9mIG9iamVjdHMgaW50byByZWNvcmRzXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W119IEFycmF5IGluIGNhc2UgYW4gYXJyYXkgd2FzIHBhc3NlZFxuICAgICAqL1xuICAgIGNyZWF0ZVJlY29yZChjb25maWcpIHtcbiAgICAgICAgbGV0IGlzQXJyYXkgPSB0cnVlO1xuXG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbmZpZyAgPSBbY29uZmlnXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbWUgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpICAgPSAwLFxuICAgICAgICAgICAgICAgIGxlbiA9IGNvbmZpZy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaXRlbTtcblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBjb25maWdbaV1cblxuICAgICAgICAgICAgICAgIGlmICghUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWdbaV0gPSBSZWNvcmRGYWN0b3J5LmNyZWF0ZVJlY29yZChtZS5tb2RlbCwgaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNBcnJheSA/IGNvbmZpZyA6IGNvbmZpZ1swXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBjb2xsZWN0aW9uLkJhc2U6ZmluZCgpIHRvIGVuc3VyZSB0aGUgcmV0dXJuZWQgaXRlbShzKSBhcmUgUmVjb3JkIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbdmFsdWVdIE9ubHkgcmVxdWlyZWQgaW4gY2FzZSB0aGUgZmlyc3QgcGFyYW0gaXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVybkZpcnN0TWF0Y2g9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfG51bGx9XG4gICAgICovXG4gICAgZmluZChwcm9wZXJ0eSwgdmFsdWUsIHJldHVybkZpcnN0TWF0Y2g9ZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZmluZChwcm9wZXJ0eSwgdmFsdWUsIHJldHVybkZpcnN0TWF0Y2gpO1xuXG4gICAgICAgIGlmIChyZXR1cm5GaXJzdE1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID8gdGhpcy5nZXQocmVzdWx0W3RoaXMua2V5UHJvcGVydHldKSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChpdGVtID0+IHRoaXMuZ2V0KGl0ZW1bdGhpcy5rZXlQcm9wZXJ0eV0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBjb2xsZWN0aW9uLkJhc2U6ZmluZEJ5KCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtKHMpIGFyZSBSZWNvcmQgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBydW4gZm9yIGVhY2ggaXRlbSBpbnNpZGUgdGhlIHN0YXJ0LWVuZCByYW5nZS4gUmV0dXJuIHRydWUgZm9yIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlPXRoaXMgVGhlIHNjb3BlIGluIHdoaWNoIHRoZSBwYXNzZWQgZnVuY3Rpb24gZ2V0cyBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydD0wIFRoZSBzdGFydCBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQ9dGhpcy5jb3VudCBUaGUgZW5kIGluZGV4ICh1cCB0bywgbGFzdCB2YWx1ZSBleGNsdWRlZClcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZmluZEJ5KGZuLCBzY29wZT10aGlzLCBzdGFydD0wLCBlbmQ9dGhpcy5jb3VudCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5maW5kQnkoZm4sIHNjb3BlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoaXRlbSA9PiB0aGlzLmdldChpdGVtW3RoaXMua2V5UHJvcGVydHldKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmb3JFYWNoKCkgdG8gZW5zdXJlIHRoZSBpdGVyYXRlZCBpdGVtIGlzIGEgUmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIHJlY29yZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBmbmAuXG4gICAgICovXG4gICAgZm9yRWFjaChmbiwgc2NvcGUpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLmNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoc2NvcGUgfHwgbWUsIG1lLmdldEF0KGkpLCBpLCBtZS5pdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmdldCgpIHRvIGVuc3VyZSB0aGUgcmV0dXJuZWQgaXRlbSBpcyBhIFJlY29yZCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBzdXBlci5nZXQoa2V5KTsgLy8gR2V0IGl0ZW0gZnJvbSBDb2xsZWN0aW9uLkJhc2UgKGNvdWxkIGJlIHJhdyBkYXRhKVxuXG4gICAgICAgIGlmIChpdGVtICYmICFSZWNvcmRGYWN0b3J5LmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmQgPSBSZWNvcmRGYWN0b3J5LmNyZWF0ZVJlY29yZChtZS5tb2RlbCwgaXRlbSk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCAgPSBtZS5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSByYXcgZGF0YSB3aXRoIHRoZSByZWNvcmQgaW5zdGFuY2UgaW4gdGhlIGN1cnJlbnQgKGZpbHRlcmVkKSBjb2xsZWN0aW9uXG4gICAgICAgICAgICBtZS5tYXAuc2V0KGtleSwgcmVjb3JkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtZS5faXRlbXNbaW5kZXhdID0gcmVjb3JkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgY29sbGVjdGlvbiBpcyBmaWx0ZXJlZCwgd2UgbXVzdCBhbHNvIHVwZGF0ZSB0aGUgbWFzdGVyICdhbGxJdGVtcycgY29sbGVjdGlvblxuICAgICAgICAgICAgaWYgKG1lLmFsbEl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFzdGVySW5kZXggPSBtZS5hbGxJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXN0ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWxsSXRlbXMubWFwLnNldChrZXksIHJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zLl9pdGVtc1ttYXN0ZXJJbmRleF0gPSByZWNvcmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0gLy8gQWxyZWFkeSBhIHJlY29yZCBvciBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpnZXRBdCgpIHRvIGVuc3VyZSB0aGUgcmV0dXJuZWQgaXRlbSBpcyBhIFJlY29yZCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRBdChpbmRleCkge1xuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtID0gc3VwZXIuZ2V0QXQoaW5kZXgpOyAvLyBHZXQgaXRlbSBmcm9tIENvbGxlY3Rpb24uQmFzZSAoY291bGQgYmUgcmF3IGRhdGEpXG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcmF3IGRhdGEgd2l0aCB0aGUgcmVjb3JkIGluc3RhbmNlIGluIHRoZSBjdXJyZW50IChmaWx0ZXJlZCkgY29sbGVjdGlvblxuICAgICAgICAgICAgbWUubWFwLnNldChyZWNvcmRbbWUua2V5UHJvcGVydHldLCByZWNvcmQpO1xuICAgICAgICAgICAgbWUuX2l0ZW1zW2luZGV4XSA9IHJlY29yZDtcblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkLCB3ZSBtdXN0IGFsc28gdXBkYXRlIHRoZSBtYXN0ZXIgJ2FsbEl0ZW1zJyBjb2xsZWN0aW9uXG4gICAgICAgICAgICBpZiAobWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXN0ZXJJbmRleCA9IG1lLmFsbEl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5tYXAuc2V0KHJlY29yZFttZS5rZXlQcm9wZXJ0eV0sIHJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zLl9pdGVtc1ttYXN0ZXJJbmRleF0gPSByZWNvcmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0gLy8gQWxyZWFkeSBhIHJlY29yZCBvciB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEtleVByb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlQcm9wZXJ0eSB8fCB0aGlzLm1vZGVsLmtleVByb3BlcnR5XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXQgdG8gY2hlY2sgZm9yIGludCBiYXNlZCBrZXlQcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSBsb3dlcmNhc2UgdmFsdWUgb2YgdGhlIG1vZGVsIGZpZWxkIHR5cGVcbiAgICAgKi9cbiAgICBnZXRLZXlUeXBlKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge21vZGVsfSAgPSBtZSxcbiAgICAgICAgICAgIGtleUZpZWxkID0gbW9kZWw/LmdldEZpZWxkKG1lLmdldEtleVByb3BlcnR5KCkpO1xuXG4gICAgICAgIHJldHVybiBrZXlGaWVsZD8udHlwZT8udG9Mb3dlckNhc2UoKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBkYXRhIG9iamVjdCBpbnRvIGEgUmVjb3JkIGluc3RhbmNlIG9yIHJldHVybnMgaXQgaWYgaXQgaXMgYWxyZWFkeSBvbmUuXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGFkZCgpIGFuZCBpbnNlcnQoKSB3aGVuIGluaXQ9dHJ1ZSAoZGVmYXVsdCkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2JqZWN0IG9yIFJlY29yZCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBSZWNvcmQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBpbml0UmVjb3JkKGRhdGEpIHtcbiAgICAgICAgaWYgKFJlY29yZEZhY3RvcnkuaXNSZWNvcmQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoZGF0YVt0aGlzLmdldEtleVByb3BlcnR5KCldKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBjb2xsZWN0aW9uLkJhc2U6IGluc2VydCgpIHRvIGNvbnZlcnQgaXRlbXMgaW50byByZWNvcmRzIGlmIG5lZWRlZC5cbiAgICAgKlxuICAgICAqICoqRWFnZXIgTW9kZSAoYGluaXQ9dHJ1ZWAgLSBEZWZhdWx0KToqKlxuICAgICAqIEltbWVkaWF0ZWx5IGNvbnZlcnRzIHJhdyBkYXRhIGludG8gYE5lby5kYXRhLk1vZGVsYCBpbnN0YW5jZXMuXG4gICAgICogUmV0dXJucyBhbiBgQXJyYXlgIG9mIHRoZSBjcmVhdGVkIHJlY29yZHMuXG4gICAgICpcbiAgICAgKiAqKkxhenkgTW9kZSAoYGluaXQ9ZmFsc2VgKToqKlxuICAgICAqIEluc2VydHMgcmF3IGRhdGEgZGlyZWN0bHkuIEluc3RhbnRpYXRlcyByZWNvcmRzIG9ubHkgb24gYWNjZXNzLlxuICAgICAqIFJldHVybnMgYW4gYEFycmF5YCBvZiB0aGUgaW5zZXJ0ZWQgcmF3IGRhdGEgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IGF0XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0ocykgdG8gYWRkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdD10aGlzLmF1dG9Jbml0UmVjb3Jkc10gVHJ1ZSB0byByZXR1cm4gdGhlIGNyZWF0ZWQgcmVjb3Jkc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXXxOZW8uZGF0YS5Nb2RlbFtdfSBUaGUgaW5zZXJ0ZWQgcmF3IGl0ZW1zIG9yIGNyZWF0ZWQgcmVjb3Jkc1xuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSwgaW5pdD10aGlzLmF1dG9Jbml0UmVjb3Jkcykge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbXMgPSBzdXBlci5pbnNlcnQoaW5kZXgsIGl0ZW0pO1xuXG4gICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXMubWFwKGkgPT4gbWUuZ2V0KGlbbWUuZ2V0S2V5UHJvcGVydHkoKV0pKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuaGVhZGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLm1ldGhvZCBERUxFVEUsIEdFVCwgUE9TVCwgUFVUXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucmVzcG9uc2VUeXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuc2NvcGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy51cmxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3R8T2JqZWN0W10+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkKG9wdHM9e30pIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICBwYXJhbXMgPSB7cGFnZTogbWUuY3VycmVudFBhZ2UsIHBhZ2VTaXplOiBtZS5wYWdlU2l6ZSwgLi4ub3B0cy5wYXJhbXN9O1xuXG4gICAgICAgIGlmIChtZS5yZW1vdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIHBhcmFtcy5maWx0ZXJzID0gbWUuZXhwb3J0RmlsdGVycygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUucmVtb3RlU29ydCkge1xuICAgICAgICAgICAgcGFyYW1zLnNvcnRlcnMgPSBtZS5leHBvcnRTb3J0ZXJzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5hcGkpIHtcbiAgICAgICAgICAgIGxldCBhcGlBcnJheSA9IG1lLmFwaS5yZWFkLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgZm4gICAgICAgPSBhcGlBcnJheS5wb3AoKSxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlICA9IE5lby5ucyhhcGlBcnJheS5qb2luKCcuJykpO1xuXG4gICAgICAgICAgICBpZiAoIXNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBcGkgaXMgbm90IGRlZmluZWQnLCB0aGlzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlcnZpY2VbZm5dKHBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBtZS50b3RhbENvdW50ID0gcmVzcG9uc2UudG90YWxDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgbWUuZGF0YSAgICAgICA9IE5lby5ucyhtZS5yZXNwb25zZVJvb3QsIGZhbHNlLCByZXNwb25zZSk7IC8vIGZpcmVzIHRoZSBsb2FkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIG1lLmlzTG9hZGVkICAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5kYXRhXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMudXJsID8/PSBtZS51cmw7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3Igbm9uLWJyb3dzZXIgYmFzZWQgZW52cyBsaWtlIG5vZGVqc1xuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzLnByb2Nlc3M/LnJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWFkRmlsZSB9ID0gYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gJ2ZzL3Byb21pc2VzJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZShvcHRzLnVybCwgJ3V0Zi04Jyk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7anNvbjogSlNPTi5wYXJzZShjb250ZW50KX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IE5lby5YaHIucHJvbWlzZUpzb24ob3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuZGF0YSA9IE5lby5ucyhtZS5yZXNwb25zZVJvb3QsIGZhbHNlLCBkYXRhLmpzb24pIHx8IGRhdGEuanNvbiAvLyBmaXJlcyB0aGUgbG9hZCBldmVudFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmlzTG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhPy5qc29uIHx8IG51bGxcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZm9yIE5lby5YaHIucmVxdWVzdCcsIHtpZDogbWUuaWQsIGVycm9yOiBlcnIsIHVybDogb3B0cy51cmx9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkNvbGxlY3Rpb25NdXRhdGUob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkICYmICFtZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2xvYWQnLCB7aXRlbXM6IG1lLml0ZW1zLCB0b3RhbDogbWUuY2h1bmtpbmdUb3RhbH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbGxlY3Rpb25Tb3J0KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5maXJlKCdsb2FkJywge2l0ZW1zOiBtZS5pdGVtc30pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5kYXRhKSB7XG4gICAgICAgICAgICBtZS5hZnRlclNldERhdGEobWUuZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlaW5nIGNvbnN0cnVjdGVkIGRvZXMgbm90IG1lYW4gdGhhdCByZWxhdGVkIGFmdGVyU2V0U3RvcmUoKSBtZXRob2RzIGdvdCBleGVjdXRlZFxuICAgICAgICAvLyA9PiBicmVhayB0aGUgc3luYyBmbG93IHRvIGVuc3VyZSBwb3RlbnRpYWwgbGlzdGVuZXJzIGdvdCBhcHBsaWVkXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lLmlzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXN9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZS5hdXRvTG9hZCkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRmlsdGVyQ2hhbmdlKG9wdHMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUucmVtb3RlRmlsdGVyKSB7XG4gICAgICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG4gICAgICAgICAgICBtZS5sb2FkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLm9uRmlsdGVyQ2hhbmdlKG9wdHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5yZWNvcmRcbiAgICAgKi9cbiAgICBvblJlY29yZENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVjb3JkQ2hhbmdlJywge1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4T2YoZGF0YS5yZWNvcmQpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHM9e31cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5kaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5wcm9wZXJ0eVxuICAgICAqL1xuICAgIHNvcnQob3B0cz17fSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBpZiAobWUuY29uZmlnc0FwcGxpZWQpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIG1lLnNvcnRlcnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IG9wdHMuZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA6IG9wdHMucHJvcGVydHlcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLnJlbW90ZVNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc29ydGVycyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdBU0MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgOiBpbml0aWFsSW5kZXhTeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaW5zdGFuY2UgaW50byBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QgZm9yIHRoZSBOZXVyYWwgTGluay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBhdXRvSW5pdFJlY29yZHMgOiBtZS5hdXRvSW5pdFJlY29yZHMsXG4gICAgICAgICAgICBhdXRvTG9hZCAgICAgICAgOiBtZS5hdXRvTG9hZCxcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlICAgICA6IG1lLmN1cnJlbnRQYWdlLFxuICAgICAgICAgICAgaW5pdGlhbENodW5rU2l6ZTogbWUuaW5pdGlhbENodW5rU2l6ZSxcbiAgICAgICAgICAgIGlzR3JvdXBlZCAgICAgICA6IG1lLmlzR3JvdXBlZCxcbiAgICAgICAgICAgIGlzTG9hZGVkICAgICAgICA6IG1lLmlzTG9hZGVkLFxuICAgICAgICAgICAgaXNMb2FkaW5nICAgICAgIDogbWUuaXNMb2FkaW5nLFxuICAgICAgICAgICAgbW9kZWwgICAgICAgICAgIDogbWUubW9kZWw/LnRvSlNPTigpLFxuICAgICAgICAgICAgcGFnZVNpemUgICAgICAgIDogbWUucGFnZVNpemUsXG4gICAgICAgICAgICByZW1vdGVGaWx0ZXIgICAgOiBtZS5yZW1vdGVGaWx0ZXIsXG4gICAgICAgICAgICByZW1vdGVTb3J0ICAgICAgOiBtZS5yZW1vdGVTb3J0LFxuICAgICAgICAgICAgdG90YWxDb3VudCAgICAgIDogbWUudG90YWxDb3VudCxcbiAgICAgICAgICAgIHVybCAgICAgICAgICAgICA6IG1lLnVybFxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdG9yZSk7XG4iLCJpbXBvcnQgTWFuYWdlciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLm1hbmFnZXIuU3RvcmVcbiAqIEBleHRlbmRzIE5lby5tYW5hZ2VyLkJhc2VcbiAqIEBzaW5nbGV0b25cbiAqL1xuY2xhc3MgU3RvcmUgZXh0ZW5kcyBNYW5hZ2VyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5tYW5hZ2VyLlN0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ubWFuYWdlci5TdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFsaWFzIE5lby5nZXRTdG9yZSB0byB0aGlzIG1hbmFnZXI/XG4gICAgICAgIC8vIE5lby5nZXRTdG9yZSA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdG9yZSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9