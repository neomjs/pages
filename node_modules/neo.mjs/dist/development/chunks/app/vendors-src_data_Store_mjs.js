"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_data_Store_mjs"],{

/***/ "./src/data/Model.mjs":
/*!****************************!*\
  !*** ./src/data/Model.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");



/**
 * @class Neo.data.Model
 * @extends Neo.core.Base
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.Model'
         * @protected
         */
        className: 'Neo.data.Model',
        /**
         * @member {String} ntype='model'
         * @protected
         */
        ntype: 'model',
        /**
         * @member {Object[]|null} fields_=null
         */
        fields_: null,
        /**
         * @member {String} keyProperty_='id'
         */
        keyProperty_: 'id',
        /**
         * @member {String|null} storeId=null
         * @protected
         */
        storeId: null,
        /**
         * Set this config to true in case you want to track modified fields.
         * Be aware that this will double the amount of data inside each record,
         * since each field will get an original value flag.
         * @member {Boolean} trackModifiedFields=false
         */
        trackModifiedFields: false
    }

    /**
     * Internally storing all fields, which have a calculate property
     * @member {Map} calculatedFieldsMap=new Map()
     * @protected
     */
    calculatedFieldsMap = new Map()
    /**
     * Internally storing all fields inside a flat map => nested fields included
     * @member {Map} fieldsMap=new Map()
     * @protected
     */
    fieldsMap = new Map()
    /**
     * @member {Boolean} hasNestedFields=false
     * @protected
     */
    hasNestedFields = false

    /**
     Triggered after the fields config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetFields(value, oldValue) {
        if (value) {
            let me = this;

            me.updateFieldsMap(value);

            // Fields can get changed multiple times before the model instance is getting constructed.
            // We only need the latest state before construction & honor run-time changes.
            if (me.isConstructed) {
                _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createRecordClass(me, true)
            }
        }
    }

    /**
     * Finds a field config by a given field name
     * @param {String} name
     * @returns {Object|null} The field config object or null if no match was found
     */
    getField(name) {
        return this.fieldsMap.get(name) || null
    }

    /**
     * Finds a field type by a given field name
     * @param {String} name
     * @returns {String|null} The lowercase field type or null if no match was found
     */
    getFieldType(name) {
        return this.getField(name)?.type?.toLowerCase() || null
    }

    /**
     * @param {Object[]} fields
     * @param {Boolean} isRoot=true
     * @param {String} path=''
     */
    updateFieldsMap(fields, isRoot=true, path='') {
        let me = this,
            {calculatedFieldsMap, fieldsMap} = me,
            fieldName;

        if (isRoot) {
            calculatedFieldsMap.clear();
            fieldsMap.clear();
            me.hasNestedFields = false
        }

        fields.forEach(field => {
            fieldName = path + field.name

            if (field.fields) {
                me.hasNestedFields = true;
                me.updateFieldsMap(field.fields, false, field.name + '.')
            } else {
                fieldsMap.set(fieldName, field);

                if (field.calculate) {
                    calculatedFieldsMap.set(fieldName, field)
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ }),

/***/ "./src/data/RecordFactory.mjs":
/*!************************************!*\
  !*** ./src/data/RecordFactory.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");



const
    dataSymbol         = Symbol.for('data'),
    isModifiedSymbol   = Symbol.for('isModified'),
    originalDataSymbol = Symbol.for('originalData');

let instance;

/**
 * @class Neo.data.RecordFactory
 * @extends Neo.core.Base
 * @singleton
 */
class RecordFactory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.RecordFactory'
         * @protected
         */
        className: 'Neo.data.RecordFactory',
        /**
         * @member {String} recordNamespace='Neo.data.record'
         */
        recordNamespace: 'Neo.data.record',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Assigns model based default values to a data object
     * @param {Object}         data
     * @param {Neo.data.Model} model
     * @returns {Object}
     */
    assignDefaultValues(data, model) {
        model.fieldsMap.forEach((field, fieldName) => {
            if (Object.hasOwn(field, 'defaultValue')) {
                // We could always use Neo.assignToNs() => the check is just for improving the performance
                if (model.hasNestedFields) {
                    Neo.assignToNs(fieldName, field.defaultValue, data, false)
                } else if (data[fieldName] === undefined) {
                    data[fieldName] = field.defaultValue
                }
            }
        });

        return data
    }

    /**
     * @param {Object} data
     * @param {Object} data.field
     * @param {Neo.data.Model} data.model
     * @param {String} data.path=''
     * @param {Object} data.proto
     */
    createField({field, model, path='', proto}) {
        let fieldName = field.name,
            fieldPath = path === '' ? fieldName : `${path}.${fieldName}`,
            properties;

        if (field.fields) {
            field.fields.forEach(childField => {
                this.createField({field: childField, model, path: fieldPath, proto})
            })
        } else {
            properties = {
                [fieldPath]: {
                    configurable: true,
                    enumerable  : true,
                    get() {
                        if (model.hasNestedFields) {
                            return Neo.ns(fieldPath, false, this[dataSymbol])
                        }

                        return this[dataSymbol][fieldName]
                    },
                    set(value) {
                        instance.setRecordFields({
                            fields: {[fieldPath]: instance.parseRecordValue({record: this, field, value})},
                            model,
                            record: this
                        })
                    }
                }
            };

            Object.defineProperties(proto, properties)
        }
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Object} config
     * @returns {Object}
     */
    createRecord(model, config) {
        let recordClass = Neo.ns(`${this.recordNamespace}.${model.className}.${model.id}`);

        if (!recordClass) {
            recordClass = this.createRecordClass(model)
        }

        return new recordClass(config)
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Boolean} overwrite=false
     * @returns {Object}
     */
    createRecordClass(model, overwrite=false) {
        if (model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            let className = `${this.recordNamespace}.${model.className}.${model.id}`,
                ns        = Neo.ns(className),
                key, nsArray, cls;

            if (!ns || overwrite) {
                nsArray = className.split('.');
                key     = nsArray.pop();
                ns      = Neo.ns(nsArray, true);
                cls     = ns[key] = class Record {
                    // We do not want to minify the ctor class name in dist/production
                    static name = 'Record';

                    [dataSymbol] = {}

                    get isModified() {
                        let me = this;

                        if (model.trackModifiedFields) {
                            return !Neo.isEqual(me[dataSymbol], me[originalDataSymbol])
                        }

                        return me[isModifiedSymbol]
                    }

                    /**
                     * @param {Object} config
                     */
                    constructor(config) {
                        let me = this;

                        config = instance.assignDefaultValues(config, model);

                        if (model.trackModifiedFields) {
                            me[originalDataSymbol] = {};
                            me.setOriginal(config)
                        } else {
                            me[isModifiedSymbol] = false
                        }

                        me.setSilent(config); // We do not want to fire change events when constructing
                    }

                    /**
                     * @param {String} fieldName
                     * @returns {Boolean|null} null in case the model does not use trackModifiedFields, true in case a change was found
                     */
                    isModifiedField(fieldName) {
                        let me = this;

                        if (model.trackModifiedFields) {
                            let dataScope, originalDataScope;

                            if (model.hasNestedFields && fieldName?.includes('.')) {
                                let nsArray = fieldName.split('.');

                                fieldName         = nsArray.pop();
                                dataScope         = Neo.ns(nsArray, false, me[dataSymbol]);
                                originalDataScope = Neo.ns(nsArray, false, me[originalDataSymbol])
                            } else {
                                dataScope         = me[dataSymbol];
                                originalDataScope = me[originalDataSymbol]
                            }

                            // Check if the field exists
                            if (
                                !model.getField(fieldName) &&        // Check for leaf fields (could be excluded inside the real data)
                                !Object.hasOwn(dataScope, fieldName) // Check the data tree
                            ) {
                                console.error('The record does not contain the field', fieldName, me)
                            }

                            return !Neo.isEqual(dataScope[fieldName], originalDataScope[fieldName])
                        }

                        return null
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    reset(fields) {
                        this.setOriginal(fields);
                        this.set(fields)
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    set(fields) {
                        instance.setRecordFields({fields, model, record: this})
                    }

                    /**
                     * If the model uses trackModifiedFields, we will store the original data
                     * for tracking the dirty state (changed fields)
                     * @param {Object} fields
                     * @protected
                     */
                    setOriginal(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true, useOriginalData: true})
                    }

                    /**
                     * Bulk-update multiple record fields at once without triggering a change event
                     * @param {Object} fields
                     */
                    setSilent(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true})
                    }

                    /**
                     * When using JSON.stringify(this), we want to get the raw data
                     * @returns {Object}
                     */
                    toJSON() {
                        return structuredClone(this[dataSymbol])
                    }
                };

                if (Array.isArray(model.fields)) {
                    model.fields.forEach(field => {
                        instance.createField({field, model, proto: cls.prototype})
                    })
                }

                Object.defineProperty(cls.prototype, 'isRecord', {value: true});
                Object.defineProperty(cls, 'isClass', {value: true});

                return ns[key]
            }

            return ns
        }
    }

    /**
     * Tests if a given object is an instance of a class created by this factory
     * @param {Object} record
     * @returns {Boolean}
     */
    isRecord(record) {
        return record?.isRecord || false
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onRecordChange(opts) {
        Neo.get(opts.model.storeId)?.onRecordChange(opts)
    }

    /**
     * @param {Object}  data
     * @param {Object}  data.record
     * @param {Object}  data.field
     * @param {*}       [data.value=null]
     * @param {Object}  [data.recordConfig=null]
     * @param {Boolean} [data.useOriginalData=false]
     * @returns {*}
     */
    parseRecordValue({record, field, value=null, recordConfig=null, useOriginalData=false}) {
        if (field.calculate) {
            return field.calculate(record[useOriginalData ? originalDataSymbol : dataSymbol], field)
        }

        if (field.convert) {
            value = field.convert(value)
        }

        let fieldName = field.name,
            {mapping, maxLength, minLength, nullable} = field,
            oldValue  = recordConfig?.[fieldName] || record[fieldName],
            type      = field.type?.toLowerCase();

        // only trigger mappings for initial values
        // dynamic changes of a field will not pass the recordConfig
        if (mapping && recordConfig) {
            let ns  = mapping.split('.'),
                key = ns.pop();

            ns    = Neo.ns(ns, true, recordConfig);
            value = ns[key]
        }

        if (Object.hasOwn(field, 'maxLength')) {
            if (value?.toString().length > maxLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with maxLength: ${maxLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'minLength')) {
            if (value?.toString().length < minLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with minLength: ${minLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'nullable')) {
            if (nullable === false && value === null) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with nullable: ${nullable}`);
                return oldValue
            }
        }

        if (type === 'date' && Neo.typeOf(value) !== 'Date') {
            return new Date(value)
        }

        else if (type === 'float' && value) {
            value = parseFloat(value)
        }

        else if (type === 'html' && value) {
            value = value + ''
        }

        else if ((type === 'int' || type === 'integer') && value) {
            value = parseInt(value)
        }

        else if (type === 'string' && value) {
            value = value + '';
            value =  value.replace(/(<([^>]+)>)/ig, '')
        }

        return value
    }

    /**
     * @param {Object}         data
     * @param {String}         data.fieldName
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     * @param {*}              data.value
     * @protected
     */
    setRecordData({fieldName, model, record, useOriginalData=false, value}) {
        if (useOriginalData && !model.trackModifiedFields) {
            return
        }

        let scope = useOriginalData ? originalDataSymbol : dataSymbol;

        if (model.hasNestedFields && fieldName.includes('.')) {
            let ns, nsArray;

            nsArray   = fieldName.split('.');
            fieldName = nsArray.pop();
            ns        = Neo.ns(nsArray, true, record[scope]);

            ns[fieldName] = value
        } else {
            record[scope][fieldName] = value
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.changedFields=[] Internal flag
     * @param {Object}         data.fields
     * @param {Neo.data.Model} data.model
     * @param {Object}         data.record
     * @param {Boolean}        data.silent=false
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     */
    setRecordFields({changedFields=[], fields, model, record, silent=false, useOriginalData=false}) {
        let me = this,
            {calculatedFieldsMap, fieldsMap, trackModifiedFields} = model,
            fieldExists, hasChangedFields, oldValue;

        if (!trackModifiedFields && useOriginalData) {
            return
        }

        Object.entries(fields).forEach(([key, value]) => {
            fieldExists = fieldsMap.has(key);

            if (Neo.isObject(value) && !fieldExists) {
                Object.entries(value).forEach(([childKey, childValue]) => {
                    me.setRecordFields({
                        changedFields,
                        fields: {[`${key}.${childKey}`]: childValue},
                        model,
                        record,
                        silent: true,
                        useOriginalData
                    })
                })
            } else if (fieldExists) {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), value});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    if (!trackModifiedFields && !useOriginalData) {
                        record[isModifiedSymbol] = true
                    }

                    changedFields.push({name: key, oldValue, value})
                }
            }
        });

        hasChangedFields = Object.keys(changedFields).length > 0;

        if (hasChangedFields) {
            calculatedFieldsMap.forEach((value, key) => {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), useOriginalData});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    changedFields.push({name: key, oldValue, value})
                }
            })
        }

        if (!silent && !useOriginalData && hasChangedFields) {
            me.onRecordChange({fields: changedFields, model, record})
        }
    }
}

instance = Neo.setupClass(RecordFactory);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ }),

/***/ "./src/data/Store.mjs":
/*!****************************!*\
  !*** ./src/data/Store.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");






/**
 * @class Neo.data.Store
 * @extends Neo.collection.Base
 */
class Store extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.Store'
         * @protected
         */
        className: 'Neo.data.Store',
        /**
         * @member {String} ntype='store'
         * @protected
         */
        ntype: 'store',
        /**
         * Instead of setting an url, you can define the RPC BE API methods.
         * In case the 4 methods are using the same service and this service is using the CRUD based fn-names,
         * you can switch to a string based shortcut.
         * The following 2 examples are equivalent.
         * @example
         * api: {
         *    create : 'MyApp.backend.UserService.create',
         *    destroy: 'MyApp.backend.UserService.destroy',
         *    read   : 'MyApp.backend.UserService.read',
         *    update : 'MyApp.backend.UserService.update'
         * }
         * @example
         * api: 'MyApp.backend.UserService'
         * @member {Object|String|null} api_=null
         */
        api_: null,
        /**
         * @member {Boolean} autoLoad=false
         */
        autoLoad: false,
        /**
         * @member {Number} currentPage_=1
         */
        currentPage_: 1,
        /**
         * @member {Array|null} data_=null
         */
        data_: null,
        /**
         * @member {Array|null} initialData_=null
         */
        initialData_: null,
        /**
         * @member {Boolean} isGrouped=false
         */
        isGrouped: false,
        /**
         * @member {Boolean} isLoaded=false
         */
        isLoaded: false,
        /**
         * @member {Boolean} isLoading=false
         */
        isLoading: false,
        /**
         * @member {Neo.data.Model} model_=null
         */
        model_: null,
        /**
         * Use a value of 0 to not limit the pageSize
         * @member {Number} pageSize_=0
         */
        pageSize_: 0,
        /**
         * True to let the backend handle the filtering.
         * Useful for buffered stores
         * @member {Boolean} remoteFilter=false
         */
        remoteFilter: false,
        /**
         * True to let the backend handle the sorting.
         * Useful for buffered stores
         * @member {Boolean} remoteSort=false
         */
        remoteSort: false,
        /**
         * Add a path to the root of your data.
         * If the responseRoot is 'data' this is optional.
         * @member {String} responseRoot='data'
         */
        responseRoot: 'data',
        /**
         * @member {Number} totalCount=0
         */
        totalCount: 0,
        /**
         * Url for Ajax requests
         * @member {String|null} url=null
         */
        url: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // todo
        me.on({
            mutate: me.onCollectionMutate,
            sort  : me.onCollectionSort,
            scope : me
        });
    }

    /**
     * Overrides collection.Base: add() to convert items into records if needed
     * @param {Array|Object} item The item(s) to add
     * @returns {Number} the collection count
     */
    add(item) {
        return super.add(this.createRecord(item))
    }

    /**
     * Triggered after the currentPage config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCurrentPage(value, oldValue) {
        oldValue && this.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        let me = this;

        if (me.configsApplied) {
            if (value) {
                if (oldValue) {
                    me.clear()
                } else {
                    me.initialData = [...value]
                }

                me.isLoading = false;

                me.add(value)
            }
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        super.afterSetFilters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteFilter && me.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetInitialData(value, oldValue) {
        // console.log('afterSetInitialData', value, oldValue);
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetModel(value, oldValue) {
        if (value) {
            value.storeId = this.id
        }
    }

    /**
     * Triggered after the pageSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPageSize(value, oldValue) {
        if (oldValue) {
            this._currentPage = 1; // silent update
            this.load()
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        super.afterSetSorters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteSort && me.load()
    }

    /**
     * @param {Object|String|null} value
     * @param {Object|String|null} oldValue
     * @protected
     * @returns {Object|null}
     */
    beforeSetApi(value, oldValue) {
        if (Neo.typeOf(value) === 'String') {
            value = {
                create : value + '.create',
                destroy: value + '.destroy',
                read   : value + '.read',
                update : value + '.update'
            }
        }

        return value
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     * @returns {*}
     */
    beforeSetData(value, oldValue) {
        if (value) {
            this.isLoading = true;

            value = this.createRecord(value)
        }

        return value
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     * @returns {*}
     */
    beforeSetInitialData(value, oldValue) {
        if (!value && oldValue) {
            return oldValue
        }

        return value
    }

    /**
     * @param {Neo.data.Model|Object} value
     * @param {Neo.data.Model|Object} oldValue
     * @protected
     * @returns {Neo.data.Model}
     */
    beforeSetModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _Model_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Converts an object or array of objects into records
     * @param {Object|Object[]} config
     * @returns {Object|Object[]} Array in case an array was passed
     */
    createRecord(config) {
        let isArray = true;

        if (config) {
            if (!Array.isArray(config)) {
                isArray = false;
                config  = [config]
            }

            let me  = this,
                i   = 0,
                len = config.length,
                item;

            for (; i < len; i++) {
                item = config[i]

                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
                    config[i] = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item)
                }
            }
        }

        return isArray ? config : config[0]
    }

    /**
     * @returns {String}
     */
    getKeyProperty() {
        return this.keyProperty || this.model.keyProperty
    }

    /**
     * Convenience shortcut to check for int based keyProperties
     * @returns {String|null} lowercase value of the model field type
     */
    getKeyType() {
        let me       = this,
            {model}  = me,
            keyField = model?.getField(me.getKeyProperty());

        return keyField?.type?.toLowerCase() || null
    }

    /**
     * @param {Object} opts={}
     * @param {Object} opts.data
     * @param {Object} opts.headers
     * @param {String} opts.method DELETE, GET, POST, PUT
     * @param {Object} opts.params
     * @param {String} opts.responseType
     * @param {Object} opts.scope
     * @param {String} opts.url
     * @protected
     */
    load(opts={}) {
        let me     = this,
            params = {page: me.currentPage, pageSize: me.pageSize, ...opts.params};

        if (me.remoteFilter) {
            params.filters = me.exportFilters()
        }

        if (me.remoteSort) {
            params.sorters = me.exportSorters()
        }

        if (me.api) {
            let apiArray = me.api.read.split('.'),
                fn       = apiArray.pop(),
                service  = Neo.ns(apiArray.join('.'));

            if (!service) {
                console.log('Api is not defined', this)
            } else {
                service[fn](params).then(response => {
                    response = Neo.ns(me.responseRoot, false, response);

                    if (response.success) {
                        me.totalCount = response.totalCount;
                        me.data       = Neo.ns(me.responseRoot, false, response); // fires the load event
                    }
                })
            }
        } else {
            opts.url ??= me.url;

            Neo.Xhr.promiseJson(opts).catch(err => {
                console.log('Error for Neo.Xhr.request', err, me.id)
            }).then(data => {
                me.data = Neo.ns(me.responseRoot, false, data.json) || data.json
                // we do not need to fire a load event => onCollectionMutate()
            })
        }
    }

    /**
     * @param {Object} opts
     */
    onCollectionMutate(opts) {
        let me = this;

        if (me.isConstructed && !me.isLoading) {
            me.fire('load', me.items)
        }
    }

    /**
     * todo: add will fire mutate and sort right after another
     */
    onCollectionSort() {
        let me = this;

        if (me.isConstructed) {
            //me.fire('load', me.items)
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.data) {
            me.afterSetData(me.data)
        }

        // Being constructed does not mean that related afterSetStore() methods got executed
        // => break the sync flow to ensure potential listeners got applied
        me.timeout(1).then(() => {
            if (me.getCount() > 0) {
                me.fire('load', me.items)
            } else if (me.autoLoad) {
                me.load()
            }
        })
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        let me = this;

        if (me.remoteFilter) {
            me._currentPage = 1; // silent update
            me.load()
        } else {
            super.onFilterChange(opts)
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object} data.record
     */
    onRecordChange(data) {
        this.fire('recordChange', {
            ...data,
            index: this.indexOf(data.record)
        })
    }

    /**
     * @param {Object} opts={}
     * @param {String} opts.direction
     * @param {String} opts.property
     */
    sort(opts={}) {
        let me = this;

        me._currentPage = 1; // silent update

        if (me.configsApplied) {
            if (opts.direction) {
                me.sorters = [{
                    direction: opts.direction,
                    property : opts.property
                }]
            } else {
                if (!me.remoteSort) {
                    me.startUpdate();
                    me.clear()
                }

                me.sorters = [];

                if (!me.remoteSort) {
                    me.add([...me.initialData]);
                    me.endUpdate();
                    me.fire('sort')
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDRzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFhO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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Q3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL01vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvUmVjb3JkRmFjdG9yeS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL1N0b3JlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBSZWNvcmRGYWN0b3J5IGZyb20gJy4vUmVjb3JkRmFjdG9yeS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGF0YS5Nb2RlbFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBNb2RlbCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXRhLk1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfG51bGx9IGZpZWxkc189bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZmllbGRzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30ga2V5UHJvcGVydHlfPSdpZCdcbiAgICAgICAgICovXG4gICAgICAgIGtleVByb3BlcnR5XzogJ2lkJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBzdG9yZUlkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcmVJZDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGlzIGNvbmZpZyB0byB0cnVlIGluIGNhc2UgeW91IHdhbnQgdG8gdHJhY2sgbW9kaWZpZWQgZmllbGRzLlxuICAgICAgICAgKiBCZSBhd2FyZSB0aGF0IHRoaXMgd2lsbCBkb3VibGUgdGhlIGFtb3VudCBvZiBkYXRhIGluc2lkZSBlYWNoIHJlY29yZCxcbiAgICAgICAgICogc2luY2UgZWFjaCBmaWVsZCB3aWxsIGdldCBhbiBvcmlnaW5hbCB2YWx1ZSBmbGFnLlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB0cmFja01vZGlmaWVkRmllbGRzPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0cmFja01vZGlmaWVkRmllbGRzOiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgc3RvcmluZyBhbGwgZmllbGRzLCB3aGljaCBoYXZlIGEgY2FsY3VsYXRlIHByb3BlcnR5XG4gICAgICogQG1lbWJlciB7TWFwfSBjYWxjdWxhdGVkRmllbGRzTWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVkRmllbGRzTWFwID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBzdG9yaW5nIGFsbCBmaWVsZHMgaW5zaWRlIGEgZmxhdCBtYXAgPT4gbmVzdGVkIGZpZWxkcyBpbmNsdWRlZFxuICAgICAqIEBtZW1iZXIge01hcH0gZmllbGRzTWFwPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaWVsZHNNYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBoYXNOZXN0ZWRGaWVsZHM9ZmFsc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaGFzTmVzdGVkRmllbGRzID0gZmFsc2VcblxuICAgIC8qKlxuICAgICBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZpZWxkcyBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpZWxkcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS51cGRhdGVGaWVsZHNNYXAodmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBGaWVsZHMgY2FuIGdldCBjaGFuZ2VkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB0aGUgbW9kZWwgaW5zdGFuY2UgaXMgZ2V0dGluZyBjb25zdHJ1Y3RlZC5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0aGUgbGF0ZXN0IHN0YXRlIGJlZm9yZSBjb25zdHJ1Y3Rpb24gJiBob25vciBydW4tdGltZSBjaGFuZ2VzLlxuICAgICAgICAgICAgaWYgKG1lLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBSZWNvcmRGYWN0b3J5LmNyZWF0ZVJlY29yZENsYXNzKG1lLCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYSBmaWVsZCBjb25maWcgYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBmaWVsZCBjb25maWcgb2JqZWN0IG9yIG51bGwgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgZ2V0RmllbGQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHNNYXAuZ2V0KG5hbWUpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIGZpZWxkIHR5cGUgYnkgYSBnaXZlbiBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFRoZSBsb3dlcmNhc2UgZmllbGQgdHlwZSBvciBudWxsIGlmIG5vIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIGdldEZpZWxkVHlwZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkKG5hbWUpPy50eXBlPy50b0xvd2VyQ2FzZSgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBmaWVsZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUm9vdD10cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGg9JydcbiAgICAgKi9cbiAgICB1cGRhdGVGaWVsZHNNYXAoZmllbGRzLCBpc1Jvb3Q9dHJ1ZSwgcGF0aD0nJykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2NhbGN1bGF0ZWRGaWVsZHNNYXAsIGZpZWxkc01hcH0gPSBtZSxcbiAgICAgICAgICAgIGZpZWxkTmFtZTtcblxuICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgICBjYWxjdWxhdGVkRmllbGRzTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBmaWVsZHNNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIG1lLmhhc05lc3RlZEZpZWxkcyA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBmaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBmaWVsZE5hbWUgPSBwYXRoICsgZmllbGQubmFtZVxuXG4gICAgICAgICAgICBpZiAoZmllbGQuZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbWUuaGFzTmVzdGVkRmllbGRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVGaWVsZHNNYXAoZmllbGQuZmllbGRzLCBmYWxzZSwgZmllbGQubmFtZSArICcuJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGRzTWFwLnNldChmaWVsZE5hbWUsIGZpZWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5jYWxjdWxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZEZpZWxkc01hcC5zZXQoZmllbGROYW1lLCBmaWVsZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNb2RlbCk7XG4iLCJpbXBvcnQgQmFzZSAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi9Nb2RlbC5tanMnO1xuXG5jb25zdFxuICAgIGRhdGFTeW1ib2wgICAgICAgICA9IFN5bWJvbC5mb3IoJ2RhdGEnKSxcbiAgICBpc01vZGlmaWVkU3ltYm9sICAgPSBTeW1ib2wuZm9yKCdpc01vZGlmaWVkJyksXG4gICAgb3JpZ2luYWxEYXRhU3ltYm9sID0gU3ltYm9sLmZvcignb3JpZ2luYWxEYXRhJyk7XG5cbmxldCBpbnN0YW5jZTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuUmVjb3JkRmFjdG9yeVxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICogQHNpbmdsZXRvblxuICovXG5jbGFzcyBSZWNvcmRGYWN0b3J5IGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZGF0YS5SZWNvcmRGYWN0b3J5J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5SZWNvcmRGYWN0b3J5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVjb3JkTmFtZXNwYWNlPSdOZW8uZGF0YS5yZWNvcmQnXG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmROYW1lc3BhY2U6ICdOZW8uZGF0YS5yZWNvcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2luZ2xldG9uPXRydWVcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xldG9uOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBtb2RlbCBiYXNlZCBkZWZhdWx0IHZhbHVlcyB0byBhIGRhdGEgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBhc3NpZ25EZWZhdWx0VmFsdWVzKGRhdGEsIG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmZpZWxkc01hcC5mb3JFYWNoKChmaWVsZCwgZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgYWx3YXlzIHVzZSBOZW8uYXNzaWduVG9OcygpID0+IHRoZSBjaGVjayBpcyBqdXN0IGZvciBpbXByb3ZpbmcgdGhlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmhhc05lc3RlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBOZW8uYXNzaWduVG9OcyhmaWVsZE5hbWUsIGZpZWxkLmRlZmF1bHRWYWx1ZSwgZGF0YSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW2ZpZWxkTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5maWVsZFxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5wYXRoPScnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucHJvdG9cbiAgICAgKi9cbiAgICBjcmVhdGVGaWVsZCh7ZmllbGQsIG1vZGVsLCBwYXRoPScnLCBwcm90b30pIHtcbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IGZpZWxkLm5hbWUsXG4gICAgICAgICAgICBmaWVsZFBhdGggPSBwYXRoID09PSAnJyA/IGZpZWxkTmFtZSA6IGAke3BhdGh9LiR7ZmllbGROYW1lfWAsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzO1xuXG4gICAgICAgIGlmIChmaWVsZC5maWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkLmZpZWxkcy5mb3JFYWNoKGNoaWxkRmllbGQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRmllbGQoe2ZpZWxkOiBjaGlsZEZpZWxkLCBtb2RlbCwgcGF0aDogZmllbGRQYXRoLCBwcm90b30pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICBbZmllbGRQYXRoXToge1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGUgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmhhc05lc3RlZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZW8ubnMoZmllbGRQYXRoLCBmYWxzZSwgdGhpc1tkYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZGF0YVN5bWJvbF1bZmllbGROYW1lXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzOiB7W2ZpZWxkUGF0aF06IGluc3RhbmNlLnBhcnNlUmVjb3JkVmFsdWUoe3JlY29yZDogdGhpcywgZmllbGQsIHZhbHVlfSl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZDogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGVSZWNvcmQobW9kZWwsIGNvbmZpZykge1xuICAgICAgICBsZXQgcmVjb3JkQ2xhc3MgPSBOZW8ubnMoYCR7dGhpcy5yZWNvcmROYW1lc3BhY2V9LiR7bW9kZWwuY2xhc3NOYW1lfS4ke21vZGVsLmlkfWApO1xuXG4gICAgICAgIGlmICghcmVjb3JkQ2xhc3MpIHtcbiAgICAgICAgICAgIHJlY29yZENsYXNzID0gdGhpcy5jcmVhdGVSZWNvcmRDbGFzcyhtb2RlbClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgcmVjb3JkQ2xhc3MoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGU9ZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNyZWF0ZVJlY29yZENsYXNzKG1vZGVsLCBvdmVyd3JpdGU9ZmFsc2UpIHtcbiAgICAgICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBgJHt0aGlzLnJlY29yZE5hbWVzcGFjZX0uJHttb2RlbC5jbGFzc05hbWV9LiR7bW9kZWwuaWR9YCxcbiAgICAgICAgICAgICAgICBucyAgICAgICAgPSBOZW8ubnMoY2xhc3NOYW1lKSxcbiAgICAgICAgICAgICAgICBrZXksIG5zQXJyYXksIGNscztcblxuICAgICAgICAgICAgaWYgKCFucyB8fCBvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICBuc0FycmF5ID0gY2xhc3NOYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAga2V5ICAgICA9IG5zQXJyYXkucG9wKCk7XG4gICAgICAgICAgICAgICAgbnMgICAgICA9IE5lby5ucyhuc0FycmF5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjbHMgICAgID0gbnNba2V5XSA9IGNsYXNzIFJlY29yZCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIG1pbmlmeSB0aGUgY3RvciBjbGFzcyBuYW1lIGluIGRpc3QvcHJvZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICBzdGF0aWMgbmFtZSA9ICdSZWNvcmQnO1xuXG4gICAgICAgICAgICAgICAgICAgIFtkYXRhU3ltYm9sXSA9IHt9XG5cbiAgICAgICAgICAgICAgICAgICAgZ2V0IGlzTW9kaWZpZWQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwudHJhY2tNb2RpZmllZEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhTmVvLmlzRXF1YWwobWVbZGF0YVN5bWJvbF0sIG1lW29yaWdpbmFsRGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZVtpc01vZGlmaWVkU3ltYm9sXVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gaW5zdGFuY2UuYXNzaWduRGVmYXVsdFZhbHVlcyhjb25maWcsIG1vZGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtvcmlnaW5hbERhdGFTeW1ib2xdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0T3JpZ2luYWwoY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtpc01vZGlmaWVkU3ltYm9sXSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldFNpbGVudChjb25maWcpOyAvLyBXZSBkbyBub3Qgd2FudCB0byBmaXJlIGNoYW5nZSBldmVudHMgd2hlbiBjb25zdHJ1Y3RpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IG51bGwgaW4gY2FzZSB0aGUgbW9kZWwgZG9lcyBub3QgdXNlIHRyYWNrTW9kaWZpZWRGaWVsZHMsIHRydWUgaW4gY2FzZSBhIGNoYW5nZSB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlzTW9kaWZpZWRGaWVsZChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC50cmFja01vZGlmaWVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFTY29wZSwgb3JpZ2luYWxEYXRhU2NvcGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzICYmIGZpZWxkTmFtZT8uaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbnNBcnJheSA9IGZpZWxkTmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAgICAgICAgID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNjb3BlICAgICAgICAgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW2RhdGFTeW1ib2xdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhU2NvcGUgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW29yaWdpbmFsRGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNjb3BlICAgICAgICAgPSBtZVtkYXRhU3ltYm9sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhU2NvcGUgPSBtZVtvcmlnaW5hbERhdGFTeW1ib2xdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpZWxkIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmdldEZpZWxkKGZpZWxkTmFtZSkgJiYgICAgICAgIC8vIENoZWNrIGZvciBsZWFmIGZpZWxkcyAoY291bGQgYmUgZXhjbHVkZWQgaW5zaWRlIHRoZSByZWFsIGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFPYmplY3QuaGFzT3duKGRhdGFTY29wZSwgZmllbGROYW1lKSAvLyBDaGVjayB0aGUgZGF0YSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSByZWNvcmQgZG9lcyBub3QgY29udGFpbiB0aGUgZmllbGQnLCBmaWVsZE5hbWUsIG1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhTmVvLmlzRXF1YWwoZGF0YVNjb3BlW2ZpZWxkTmFtZV0sIG9yaWdpbmFsRGF0YVNjb3BlW2ZpZWxkTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQnVsay11cGRhdGUgbXVsdGlwbGUgcmVjb3JkIGZpZWxkcyBhdCBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0KGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPcmlnaW5hbChmaWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoZmllbGRzKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEJ1bGstdXBkYXRlIG11bHRpcGxlIHJlY29yZCBmaWVsZHMgYXQgb25jZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXQoZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRSZWNvcmRGaWVsZHMoe2ZpZWxkcywgbW9kZWwsIHJlY29yZDogdGhpc30pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIG1vZGVsIHVzZXMgdHJhY2tNb2RpZmllZEZpZWxkcywgd2Ugd2lsbCBzdG9yZSB0aGUgb3JpZ2luYWwgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBmb3IgdHJhY2tpbmcgdGhlIGRpcnR5IHN0YXRlIChjaGFuZ2VkIGZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRPcmlnaW5hbChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcyh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzLCBzaWxlbnQ6IHRydWUsIHVzZU9yaWdpbmFsRGF0YTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQnVsay11cGRhdGUgbXVsdGlwbGUgcmVjb3JkIGZpZWxkcyBhdCBvbmNlIHdpdGhvdXQgdHJpZ2dlcmluZyBhIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRTaWxlbnQoZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRSZWNvcmRGaWVsZHMoe2ZpZWxkcywgbW9kZWwsIHJlY29yZDogdGhpcywgc2lsZW50OiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIHVzaW5nIEpTT04uc3RyaW5naWZ5KHRoaXMpLCB3ZSB3YW50IHRvIGdldCB0aGUgcmF3IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpc1tkYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbC5maWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNyZWF0ZUZpZWxkKHtmaWVsZCwgbW9kZWwsIHByb3RvOiBjbHMucHJvdG90eXBlfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xzLnByb3RvdHlwZSwgJ2lzUmVjb3JkJywge3ZhbHVlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNscywgJ2lzQ2xhc3MnLCB7dmFsdWU6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuc1trZXldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgYSBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyBjcmVhdGVkIGJ5IHRoaXMgZmFjdG9yeVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlY29yZChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZD8uaXNSZWNvcmQgfHwgZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdHMuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBvcHRzLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZWNvcmRcbiAgICAgKi9cbiAgICBvblJlY29yZENoYW5nZShvcHRzKSB7XG4gICAgICAgIE5lby5nZXQob3B0cy5tb2RlbC5zdG9yZUlkKT8ub25SZWNvcmRDaGFuZ2Uob3B0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhLmZpZWxkXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBbZGF0YS52YWx1ZT1udWxsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgW2RhdGEucmVjb3JkQ29uZmlnPW51bGxdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2VdXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgcGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZCwgdmFsdWU9bnVsbCwgcmVjb3JkQ29uZmlnPW51bGwsIHVzZU9yaWdpbmFsRGF0YT1mYWxzZX0pIHtcbiAgICAgICAgaWYgKGZpZWxkLmNhbGN1bGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmNhbGN1bGF0ZShyZWNvcmRbdXNlT3JpZ2luYWxEYXRhID8gb3JpZ2luYWxEYXRhU3ltYm9sIDogZGF0YVN5bWJvbF0sIGZpZWxkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkLmNvbnZlcnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuY29udmVydCh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lLFxuICAgICAgICAgICAge21hcHBpbmcsIG1heExlbmd0aCwgbWluTGVuZ3RoLCBudWxsYWJsZX0gPSBmaWVsZCxcbiAgICAgICAgICAgIG9sZFZhbHVlICA9IHJlY29yZENvbmZpZz8uW2ZpZWxkTmFtZV0gfHwgcmVjb3JkW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgICB0eXBlICAgICAgPSBmaWVsZC50eXBlPy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIG9ubHkgdHJpZ2dlciBtYXBwaW5ncyBmb3IgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgLy8gZHluYW1pYyBjaGFuZ2VzIG9mIGEgZmllbGQgd2lsbCBub3QgcGFzcyB0aGUgcmVjb3JkQ29uZmlnXG4gICAgICAgIGlmIChtYXBwaW5nICYmIHJlY29yZENvbmZpZykge1xuICAgICAgICAgICAgbGV0IG5zICA9IG1hcHBpbmcuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBucy5wb3AoKTtcblxuICAgICAgICAgICAgbnMgICAgPSBOZW8ubnMobnMsIHRydWUsIHJlY29yZENvbmZpZyk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5zW2tleV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCAnbWF4TGVuZ3RoJykpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZT8udG9TdHJpbmcoKS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldHRpbmcgcmVjb3JkIGZpZWxkOiAke2ZpZWxkTmFtZX0gdmFsdWU6ICR7dmFsdWV9IGNvbmZsaWN0cyB3aXRoIG1heExlbmd0aDogJHttYXhMZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ21pbkxlbmd0aCcpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWU/LnRvU3RyaW5nKCkubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXR0aW5nIHJlY29yZCBmaWVsZDogJHtmaWVsZE5hbWV9IHZhbHVlOiAke3ZhbHVlfSBjb25mbGljdHMgd2l0aCBtaW5MZW5ndGg6ICR7bWluTGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdudWxsYWJsZScpKSB7XG4gICAgICAgICAgICBpZiAobnVsbGFibGUgPT09IGZhbHNlICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXR0aW5nIHJlY29yZCBmaWVsZDogJHtmaWVsZE5hbWV9IHZhbHVlOiAke3ZhbHVlfSBjb25mbGljdHMgd2l0aCBudWxsYWJsZTogJHtudWxsYWJsZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnZGF0ZScgJiYgTmVvLnR5cGVPZih2YWx1ZSkgIT09ICdEYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Zsb2F0JyAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2h0bWwnICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJydcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSAnaW50JyB8fCB0eXBlID09PSAnaW50ZWdlcicpICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJztcbiAgICAgICAgICAgIHZhbHVlID0gIHZhbHVlLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICBkYXRhLmZpZWxkTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEudXNlT3JpZ2luYWxEYXRhPWZhbHNlIHRydWUgd2lsbCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvcmlnaW5hbERhdGEgc3ltYm9sXG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgICAgICAgZGF0YS52YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRSZWNvcmREYXRhKHtmaWVsZE5hbWUsIG1vZGVsLCByZWNvcmQsIHVzZU9yaWdpbmFsRGF0YT1mYWxzZSwgdmFsdWV9KSB7XG4gICAgICAgIGlmICh1c2VPcmlnaW5hbERhdGEgJiYgIW1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNjb3BlID0gdXNlT3JpZ2luYWxEYXRhID8gb3JpZ2luYWxEYXRhU3ltYm9sIDogZGF0YVN5bWJvbDtcblxuICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzICYmIGZpZWxkTmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBsZXQgbnMsIG5zQXJyYXk7XG5cbiAgICAgICAgICAgIG5zQXJyYXkgICA9IGZpZWxkTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgZmllbGROYW1lID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhuc0FycmF5LCB0cnVlLCByZWNvcmRbc2NvcGVdKTtcblxuICAgICAgICAgICAgbnNbZmllbGROYW1lXSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRbc2NvcGVdW2ZpZWxkTmFtZV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgICAgIGRhdGEuY2hhbmdlZEZpZWxkcz1bXSBJbnRlcm5hbCBmbGFnXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5maWVsZHNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICBkYXRhLnNpbGVudD1mYWxzZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEudXNlT3JpZ2luYWxEYXRhPWZhbHNlIHRydWUgd2lsbCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvcmlnaW5hbERhdGEgc3ltYm9sXG4gICAgICovXG4gICAgc2V0UmVjb3JkRmllbGRzKHtjaGFuZ2VkRmllbGRzPVtdLCBmaWVsZHMsIG1vZGVsLCByZWNvcmQsIHNpbGVudD1mYWxzZSwgdXNlT3JpZ2luYWxEYXRhPWZhbHNlfSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2NhbGN1bGF0ZWRGaWVsZHNNYXAsIGZpZWxkc01hcCwgdHJhY2tNb2RpZmllZEZpZWxkc30gPSBtb2RlbCxcbiAgICAgICAgICAgIGZpZWxkRXhpc3RzLCBoYXNDaGFuZ2VkRmllbGRzLCBvbGRWYWx1ZTtcblxuICAgICAgICBpZiAoIXRyYWNrTW9kaWZpZWRGaWVsZHMgJiYgdXNlT3JpZ2luYWxEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBmaWVsZEV4aXN0cyA9IGZpZWxkc01hcC5oYXMoa2V5KTtcblxuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgIWZpZWxkRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtjaGlsZEtleSwgY2hpbGRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2V0UmVjb3JkRmllbGRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHtbYCR7a2V5fS4ke2NoaWxkS2V5fWBdOiBjaGlsZFZhbHVlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlT3JpZ2luYWxEYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGRFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgID0gbWUucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZDogbW9kZWwuZ2V0RmllbGQoa2V5KSwgdmFsdWV9KTtcblxuICAgICAgICAgICAgICAgIGlmICghTmVvLmlzRXF1YWwob2xkVmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZXRSZWNvcmREYXRhKHtmaWVsZE5hbWU6IGtleSwgbW9kZWwsIHJlY29yZCwgdXNlT3JpZ2luYWxEYXRhLCB2YWx1ZX0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2tNb2RpZmllZEZpZWxkcyAmJiAhdXNlT3JpZ2luYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRbaXNNb2RpZmllZFN5bWJvbF0gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzLnB1c2goe25hbWU6IGtleSwgb2xkVmFsdWUsIHZhbHVlfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhhc0NoYW5nZWRGaWVsZHMgPSBPYmplY3Qua2V5cyhjaGFuZ2VkRmllbGRzKS5sZW5ndGggPiAwO1xuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkRmllbGRzKSB7XG4gICAgICAgICAgICBjYWxjdWxhdGVkRmllbGRzTWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgID0gbWUucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZDogbW9kZWwuZ2V0RmllbGQoa2V5KSwgdXNlT3JpZ2luYWxEYXRhfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKG9sZFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2V0UmVjb3JkRGF0YSh7ZmllbGROYW1lOiBrZXksIG1vZGVsLCByZWNvcmQsIHVzZU9yaWdpbmFsRGF0YSwgdmFsdWV9KTtcblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzLnB1c2goe25hbWU6IGtleSwgb2xkVmFsdWUsIHZhbHVlfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaWxlbnQgJiYgIXVzZU9yaWdpbmFsRGF0YSAmJiBoYXNDaGFuZ2VkRmllbGRzKSB7XG4gICAgICAgICAgICBtZS5vblJlY29yZENoYW5nZSh7ZmllbGRzOiBjaGFuZ2VkRmllbGRzLCBtb2RlbCwgcmVjb3JkfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW5zdGFuY2UgPSBOZW8uc2V0dXBDbGFzcyhSZWNvcmRGYWN0b3J5KTtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFuY2U7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgIGZyb20gJy4uL2NvbGxlY3Rpb24vQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgTW9kZWwgICAgICAgICAgIGZyb20gJy4vTW9kZWwubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgUmVjb3JkRmFjdG9yeSAgIGZyb20gJy4vUmVjb3JkRmFjdG9yeS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGF0YS5TdG9yZVxuICogQGV4dGVuZHMgTmVvLmNvbGxlY3Rpb24uQmFzZVxuICovXG5jbGFzcyBTdG9yZSBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLlN0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5TdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0ZWFkIG9mIHNldHRpbmcgYW4gdXJsLCB5b3UgY2FuIGRlZmluZSB0aGUgUlBDIEJFIEFQSSBtZXRob2RzLlxuICAgICAgICAgKiBJbiBjYXNlIHRoZSA0IG1ldGhvZHMgYXJlIHVzaW5nIHRoZSBzYW1lIHNlcnZpY2UgYW5kIHRoaXMgc2VydmljZSBpcyB1c2luZyB0aGUgQ1JVRCBiYXNlZCBmbi1uYW1lcyxcbiAgICAgICAgICogeW91IGNhbiBzd2l0Y2ggdG8gYSBzdHJpbmcgYmFzZWQgc2hvcnRjdXQuXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgMiBleGFtcGxlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYXBpOiB7XG4gICAgICAgICAqICAgIGNyZWF0ZSA6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmNyZWF0ZScsXG4gICAgICAgICAqICAgIGRlc3Ryb3k6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmRlc3Ryb3knLFxuICAgICAgICAgKiAgICByZWFkICAgOiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZS5yZWFkJyxcbiAgICAgICAgICogICAgdXBkYXRlIDogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UudXBkYXRlJ1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFwaTogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UnXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd8bnVsbH0gYXBpXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBhcGlfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0xvYWQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Mb2FkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gY3VycmVudFBhZ2VfPTFcbiAgICAgICAgICovXG4gICAgICAgIGN1cnJlbnRQYWdlXzogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fG51bGx9IGRhdGFfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gaW5pdGlhbERhdGFfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxEYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzR3JvdXBlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNHcm91cGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTG9hZGVkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0xvYWRpbmc9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1vZGVsXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBhIHZhbHVlIG9mIDAgdG8gbm90IGxpbWl0IHRoZSBwYWdlU2l6ZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHBhZ2VTaXplXz0wXG4gICAgICAgICAqL1xuICAgICAgICBwYWdlU2l6ZV86IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIGxldCB0aGUgYmFja2VuZCBoYW5kbGUgdGhlIGZpbHRlcmluZy5cbiAgICAgICAgICogVXNlZnVsIGZvciBidWZmZXJlZCBzdG9yZXNcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gcmVtb3RlRmlsdGVyPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGVGaWx0ZXI6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBsZXQgdGhlIGJhY2tlbmQgaGFuZGxlIHRoZSBzb3J0aW5nLlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGJ1ZmZlcmVkIHN0b3Jlc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW1vdGVTb3J0PWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdGVTb3J0OiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIHBhdGggdG8gdGhlIHJvb3Qgb2YgeW91ciBkYXRhLlxuICAgICAgICAgKiBJZiB0aGUgcmVzcG9uc2VSb290IGlzICdkYXRhJyB0aGlzIGlzIG9wdGlvbmFsLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHJlc3BvbnNlUm9vdD0nZGF0YSdcbiAgICAgICAgICovXG4gICAgICAgIHJlc3BvbnNlUm9vdDogJ2RhdGEnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB0b3RhbENvdW50PTBcbiAgICAgICAgICovXG4gICAgICAgIHRvdGFsQ291bnQ6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcmwgZm9yIEFqYXggcmVxdWVzdHNcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHVybD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB1cmw6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIHRvZG9cbiAgICAgICAgbWUub24oe1xuICAgICAgICAgICAgbXV0YXRlOiBtZS5vbkNvbGxlY3Rpb25NdXRhdGUsXG4gICAgICAgICAgICBzb3J0ICA6IG1lLm9uQ29sbGVjdGlvblNvcnQsXG4gICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBjb2xsZWN0aW9uLkJhc2U6IGFkZCgpIHRvIGNvbnZlcnQgaXRlbXMgaW50byByZWNvcmRzIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBpdGVtIFRoZSBpdGVtKHMpIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjb2xsZWN0aW9uIGNvdW50XG4gICAgICovXG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmFkZCh0aGlzLmNyZWF0ZVJlY29yZChpdGVtKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGN1cnJlbnRQYWdlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnRQYWdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2xlYXIoKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmluaXRpYWxEYXRhID0gWy4uLnZhbHVlXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgbWUuYWRkKHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZpbHRlcnModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgIG9sZFZhbHVlICYmIG1lLnJlbW90ZUZpbHRlciAmJiBtZS5sb2FkKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJbml0aWFsRGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2FmdGVyU2V0SW5pdGlhbERhdGEnLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLnN0b3JlSWQgPSB0aGlzLmlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHBhZ2VTaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhZ2VTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5sb2FkKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFNvcnRlcnModmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5yZW1vdGVTb3J0ICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgYmVmb3JlU2V0QXBpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGUgOiB2YWx1ZSArICcuY3JlYXRlJyxcbiAgICAgICAgICAgICAgICBkZXN0cm95OiB2YWx1ZSArICcuZGVzdHJveScsXG4gICAgICAgICAgICAgICAgcmVhZCAgIDogdmFsdWUgKyAnLnJlYWQnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZSA6IHZhbHVlICsgJy51cGRhdGUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYmVmb3JlU2V0RGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jcmVhdGVSZWNvcmQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYmVmb3JlU2V0SW5pdGlhbERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5Nb2RlbH1cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIHJlY29yZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXX0gQXJyYXkgaW4gY2FzZSBhbiBhcnJheSB3YXMgcGFzc2VkXG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKGNvbmZpZykge1xuICAgICAgICBsZXQgaXNBcnJheSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uZmlnICA9IFtjb25maWddXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gY29uZmlnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGNvbmZpZ1tpXVxuXG4gICAgICAgICAgICAgICAgaWYgKCFSZWNvcmRGYWN0b3J5LmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tpXSA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0FycmF5ID8gY29uZmlnIDogY29uZmlnWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRLZXlQcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5UHJvcGVydHkgfHwgdGhpcy5tb2RlbC5rZXlQcm9wZXJ0eVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IHRvIGNoZWNrIGZvciBpbnQgYmFzZWQga2V5UHJvcGVydGllc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gbG93ZXJjYXNlIHZhbHVlIG9mIHRoZSBtb2RlbCBmaWVsZCB0eXBlXG4gICAgICovXG4gICAgZ2V0S2V5VHlwZSgpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHttb2RlbH0gID0gbWUsXG4gICAgICAgICAgICBrZXlGaWVsZCA9IG1vZGVsPy5nZXRGaWVsZChtZS5nZXRLZXlQcm9wZXJ0eSgpKTtcblxuICAgICAgICByZXR1cm4ga2V5RmllbGQ/LnR5cGU/LnRvTG93ZXJDYXNlKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzPXt9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmhlYWRlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5tZXRob2QgREVMRVRFLCBHRVQsIFBPU1QsIFBVVFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnJlc3BvbnNlVHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnNjb3BlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMudXJsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGxvYWQob3B0cz17fSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHtwYWdlOiBtZS5jdXJyZW50UGFnZSwgcGFnZVNpemU6IG1lLnBhZ2VTaXplLCAuLi5vcHRzLnBhcmFtc307XG5cbiAgICAgICAgaWYgKG1lLnJlbW90ZUZpbHRlcikge1xuICAgICAgICAgICAgcGFyYW1zLmZpbHRlcnMgPSBtZS5leHBvcnRGaWx0ZXJzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5yZW1vdGVTb3J0KSB7XG4gICAgICAgICAgICBwYXJhbXMuc29ydGVycyA9IG1lLmV4cG9ydFNvcnRlcnMoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmFwaSkge1xuICAgICAgICAgICAgbGV0IGFwaUFycmF5ID0gbWUuYXBpLnJlYWQuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBmbiAgICAgICA9IGFwaUFycmF5LnBvcCgpLFxuICAgICAgICAgICAgICAgIHNlcnZpY2UgID0gTmVvLm5zKGFwaUFycmF5LmpvaW4oJy4nKSk7XG5cbiAgICAgICAgICAgIGlmICghc2VydmljZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBcGkgaXMgbm90IGRlZmluZWQnLCB0aGlzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlW2ZuXShwYXJhbXMpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IE5lby5ucyhtZS5yZXNwb25zZVJvb3QsIGZhbHNlLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRvdGFsQ291bnQgPSByZXNwb25zZS50b3RhbENvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuZGF0YSAgICAgICA9IE5lby5ucyhtZS5yZXNwb25zZVJvb3QsIGZhbHNlLCByZXNwb25zZSk7IC8vIGZpcmVzIHRoZSBsb2FkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cy51cmwgPz89IG1lLnVybDtcblxuICAgICAgICAgICAgTmVvLlhoci5wcm9taXNlSnNvbihvcHRzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBmb3IgTmVvLlhoci5yZXF1ZXN0JywgZXJyLCBtZS5pZClcbiAgICAgICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuZGF0YSA9IE5lby5ucyhtZS5yZXNwb25zZVJvb3QsIGZhbHNlLCBkYXRhLmpzb24pIHx8IGRhdGEuanNvblxuICAgICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCBuZWVkIHRvIGZpcmUgYSBsb2FkIGV2ZW50ID0+IG9uQ29sbGVjdGlvbk11dGF0ZSgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBvbkNvbGxlY3Rpb25NdXRhdGUob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkICYmICFtZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2xvYWQnLCBtZS5pdGVtcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZG86IGFkZCB3aWxsIGZpcmUgbXV0YXRlIGFuZCBzb3J0IHJpZ2h0IGFmdGVyIGFub3RoZXJcbiAgICAgKi9cbiAgICBvbkNvbGxlY3Rpb25Tb3J0KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICAvL21lLmZpcmUoJ2xvYWQnLCBtZS5pdGVtcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmRhdGEpIHtcbiAgICAgICAgICAgIG1lLmFmdGVyU2V0RGF0YShtZS5kYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmVpbmcgY29uc3RydWN0ZWQgZG9lcyBub3QgbWVhbiB0aGF0IHJlbGF0ZWQgYWZ0ZXJTZXRTdG9yZSgpIG1ldGhvZHMgZ290IGV4ZWN1dGVkXG4gICAgICAgIC8vID0+IGJyZWFrIHRoZSBzeW5jIGZsb3cgdG8gZW5zdXJlIHBvdGVudGlhbCBsaXN0ZW5lcnMgZ290IGFwcGxpZWRcbiAgICAgICAgbWUudGltZW91dCgxKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChtZS5nZXRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgIG1lLmZpcmUoJ2xvYWQnLCBtZS5pdGVtcylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWUuYXV0b0xvYWQpIHtcbiAgICAgICAgICAgICAgICBtZS5sb2FkKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkZpbHRlckNoYW5nZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLnJlbW90ZUZpbHRlcikge1xuICAgICAgICAgICAgbWUuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgbWUubG9hZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5vbkZpbHRlckNoYW5nZShvcHRzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgYWZ0ZXIgY2hhbmdpbmcgdGhlIHZhbHVlIG9mIGEgcmVjb3JkIGZpZWxkLlxuICAgICAqIEUuZy4gbXlSZWNvcmQuZm9vID0gJ2Jhcic7XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLmZpZWxkcyBFYWNoIGZpZWxkIG9iamVjdCBjb250YWlucyB0aGUga2V5czogbmFtZSwgb2xkVmFsdWUsIHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbCBUaGUgbW9kZWwgaW5zdGFuY2Ugb2YgdGhlIGNoYW5nZWQgcmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEucmVjb3JkXG4gICAgICovXG4gICAgb25SZWNvcmRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3JlY29yZENoYW5nZScsIHtcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleE9mKGRhdGEucmVjb3JkKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzPXt9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMucHJvcGVydHlcbiAgICAgKi9cbiAgICBzb3J0KG9wdHM9e30pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgaWYgKG1lLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBtZS5zb3J0ZXJzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBvcHRzLmRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgOiBvcHRzLnByb3BlcnR5XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZS5yZW1vdGVTb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnN0YXJ0VXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNsZWFyKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5zb3J0ZXJzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1lLnJlbW90ZVNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWRkKFsuLi5tZS5pbml0aWFsRGF0YV0pO1xuICAgICAgICAgICAgICAgICAgICBtZS5lbmRVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuZmlyZSgnc29ydCcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhTdG9yZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=