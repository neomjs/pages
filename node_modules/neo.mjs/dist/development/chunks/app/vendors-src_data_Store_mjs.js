"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_data_Store_mjs"],{

/***/ "./src/data/Model.mjs"
/*!****************************!*\
  !*** ./src/data/Model.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");



/**
 * @class Neo.data.Model
 * @extends Neo.core.Base
 */
class Model extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.Model'
         * @protected
         */
        className: 'Neo.data.Model',
        /**
         * @member {String} ntype='model'
         * @protected
         */
        ntype: 'model',
        /**
         * @member {Object[]|null} fields_=null
         * @reactive
         */
        fields_: null,
        /**
         * @member {String} keyProperty_='id'
         * @reactive
         */
        keyProperty_: 'id',
        /**
         * @member {String|null} storeId=null
         * @protected
         */
        storeId: null,
        /**
         * Set this config to true in case you want to track modified fields.
         * Be aware that this will double the amount of data inside each record,
         * since each field will get an original value flag.
         * @member {Boolean} trackModifiedFields=false
         */
        trackModifiedFields: false
    }

    /**
     * Internally storing all fields, which have a calculate property
     * @member {Map} calculatedFieldsMap=new Map()
     * @protected
     */
    calculatedFieldsMap = new Map()
    /**
     * Internally storing all fields inside a flat map => nested fields included
     * @member {Map} fieldsMap=new Map()
     * @protected
     */
    fieldsMap = new Map()
    /**
     * @member {Boolean} hasNestedFields=false
     * @protected
     */
    hasNestedFields = false

    /**
     Triggered after the fields config got changed
     * @param {Object[]|null} value
     * @param {Object[]|null} oldValue
     * @protected
     */
    afterSetFields(value, oldValue) {
        if (value) {
            let me = this;

            me.updateFieldsMap(value);

            // Fields can get changed multiple times before the model instance is getting constructed.
            // We only need the latest state before construction & honor run-time changes.
            if (me.isConstructed) {
                _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].createRecordClass(me, true)
            }
        }
    }

    /**
     * Finds a field config by a given field name
     * @param {String} name
     * @returns {Object|null} The field config object or null if no match was found
     */
    getField(name) {
        return this.fieldsMap.get(name) || null
    }

    /**
     * Finds a field type by a given field name
     * @param {String} name
     * @returns {String|null} The lowercase field type or null if no match was found
     */
    getFieldType(name) {
        return this.getField(name)?.type?.toLowerCase() || null
    }

    /**
     * @param {Object[]} fields
     * @param {Boolean} isRoot=true
     * @param {String} path=''
     */
    updateFieldsMap(fields, isRoot=true, path='') {
        let me = this,
            {calculatedFieldsMap, fieldsMap} = me,
            fieldName;

        if (isRoot) {
            calculatedFieldsMap.clear();
            fieldsMap.clear();
            me.hasNestedFields = false
        }

        fields.forEach(field => {
            fieldName = path + field.name

            if (field.fields) {
                me.hasNestedFields = true;
                me.updateFieldsMap(field.fields, false, field.name + '.')
            } else {
                fieldsMap.set(fieldName, field);

                if (field.calculate) {
                    calculatedFieldsMap.set(fieldName, field)
                }
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Model));


/***/ },

/***/ "./src/data/RecordFactory.mjs"
/*!************************************!*\
  !*** ./src/data/RecordFactory.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");



const
    dataSymbol         = Symbol.for('data'),
    initialIndexSymbol = Symbol.for('initialIndex'),
    isModifiedSymbol   = Symbol.for('isModified'),
    originalDataSymbol = Symbol.for('originalData');

let instance;

/**
 * @class Neo.data.RecordFactory
 * @extends Neo.core.Base
 * @singleton
 */
class RecordFactory extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.data.RecordFactory'
         * @protected
         */
        className: 'Neo.data.RecordFactory',
        /**
         * @member {String} recordNamespace='Neo.data.record'
         */
        recordNamespace: 'Neo.data.record',
        /**
         * @member {Boolean} singleton=true
         * @protected
         */
        singleton: true
    }

    /**
     * Assigns model-based default values to a data object
     * @param {Object}         data
     * @param {Neo.data.Model} model
     * @returns {Object}
     */
    assignDefaultValues(data, model) {
        model.fieldsMap.forEach((field, fieldName) => {
            if (Object.hasOwn(field, 'defaultValue')) {
                const defaultValue = Neo.isFunction(field.defaultValue) ? field.defaultValue() : field.defaultValue;

                // We could always use Neo.assignToNs() => the check is just for improving the performance
                if (model.hasNestedFields) {
                    Neo.assignToNs(fieldName, defaultValue, data, false)
                } else if (data[fieldName] === undefined) {
                    data[fieldName] = defaultValue
                }
            }
        });

        return data
    }

    /**
     * @param {Object} data
     * @param {Object} data.field
     * @param {Neo.data.Model} data.model
     * @param {String} data.path=''
     * @param {Object} data.proto
     */
    createField({field, model, path='', proto}) {
        let fieldName = field.name,
            fieldPath = path === '' ? fieldName : `${path}.${fieldName}`,
            properties;

        if (field.fields) {
            field.fields.forEach(childField => {
                this.createField({field: childField, model, path: fieldPath, proto})
            })
        } else {
            properties = {
                [fieldPath]: {
                    configurable: true,
                    enumerable  : true,
                    get() {
                        if (model.hasNestedFields) {
                            return Neo.ns(fieldPath, false, this[dataSymbol])
                        }

                        return this[dataSymbol][fieldName]
                    },
                    set(value) {
                        this.notifyChange({
                            fields: {[fieldPath]: instance.parseRecordValue({record: this, field, value})},
                            model,
                            record: this
                        })
                    }
                }
            };

            Object.defineProperties(proto, properties)
        }
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Object} config
     * @returns {Object}
     */
    createRecord(model, config) {
        let recordClass = Neo.ns(`${this.recordNamespace}.${model.className}.${model.id}`);

        if (!recordClass) {
            recordClass = this.createRecordClass(model)
        }

        return new recordClass(config)
    }

    /**
     * @param {Neo.data.Model} model
     * @param {Boolean} overwrite=false
     * @returns {Object}
     */
    createRecordClass(model, overwrite=false) {
        if (model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            let className = `${this.recordNamespace}.${model.className}.${model.id}`,
                ns        = Neo.ns(className),
                key, nsArray, cls;

            if (!ns || overwrite) {
                nsArray = className.split('.');
                key     = nsArray.pop();
                ns      = Neo.ns(nsArray, true);
                cls     = ns[key] = class Record {
                    // We do not want to minify the ctor class name in dist/production
                    static name = 'Record';

                    [dataSymbol]         = {};
                    [initialIndexSymbol] = null

                    get isModified() {
                        let me = this;

                        if (model.trackModifiedFields) {
                            return !Neo.isEqual(me[dataSymbol], me[originalDataSymbol])
                        }

                        return me[isModifiedSymbol]
                    }

                    /**
                     * @param {Object} config
                     */
                    constructor(config) {
                        let me = this;

                        if (Object.hasOwn(config, initialIndexSymbol)) {
                            me[initialIndexSymbol] = config[initialIndexSymbol];
                            delete config[initialIndexSymbol]
                        }

                        config = instance.assignDefaultValues(config, model);

                        if (model.trackModifiedFields) {
                            me[originalDataSymbol] = {};
                            me.setOriginal(config)
                        } else {
                            me[isModifiedSymbol] = false
                        }

                        me.setSilent(config) // We do not want to fire change events when constructing
                    }

                    /**
                     * @param {String} fieldName
                     * @returns {Boolean|null} null in case the model does not use trackModifiedFields, true in case a change was found
                     */
                    isModifiedField(fieldName) {
                        let me = this;

                        if (model.trackModifiedFields) {
                            let dataScope, originalDataScope;

                            if (model.hasNestedFields && fieldName?.includes('.')) {
                                let nsArray = fieldName.split('.');

                                fieldName         = nsArray.pop();
                                dataScope         = Neo.ns(nsArray, false, me[dataSymbol]);
                                originalDataScope = Neo.ns(nsArray, false, me[originalDataSymbol])
                            } else {
                                dataScope         = me[dataSymbol];
                                originalDataScope = me[originalDataSymbol]
                            }

                            // Check if the field exists
                            if (
                                !model.getField(fieldName) &&        // Check for leaf fields (could be excluded inside the real data)
                                !Object.hasOwn(dataScope, fieldName) // Check the data tree
                            ) {
                                console.error('The record does not contain the field', fieldName, me)
                            }

                            return !Neo.isEqual(dataScope[fieldName], originalDataScope[fieldName])
                        }

                        return null
                    }

                    /**
                     * The single source of truth for record field changes.
                     * Executes instance.setRecordFields(), and can get used via:
                     * - Neo.util.Function:createSequence()
                     * - Neo.util.Function:intercept(),
                     * to "listen" to field changes
                     * @param {Object}         data
                     * @param {Object}         data.fields
                     * @param {Neo.data.Model} data.model
                     * @param {Object}         data.record
                     * @param {Boolean}        silent=false
                     * @returns {Object}
                     */
                    notifyChange(data, silent=false) {
                        const param = {...data, silent}
                        instance.setRecordFields(param);
                        return param
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    reset(fields) {
                        this.setOriginal(fields);
                        this.set(fields)
                    }

                    /**
                     * Bulk-update multiple record fields at once
                     * @param {Object} fields
                     */
                    set(fields) {
                        this.notifyChange({fields, model, record: this})
                    }

                    /**
                     * If the model uses trackModifiedFields, we will store the original data
                     * for tracking the dirty state (changed fields)
                     * @param {Object} fields
                     * @protected
                     */
                    setOriginal(fields) {
                        instance.setRecordFields({fields, model, record: this, silent: true, useOriginalData: true})
                    }

                    /**
                     * Bulk-update multiple record fields at once without triggering a change event
                     * @param {Object} fields
                     */
                    setSilent(fields) {
                        this.notifyChange({fields, model, record: this}, true)
                    }

                    /**
                     * When using JSON.stringify(this), we want to get the raw data
                     * @returns {Object}
                     */
                    toJSON() {
                        return structuredClone(this[dataSymbol])
                    }
                };

                if (Array.isArray(model.fields)) {
                    model.fields.forEach(field => {
                        instance.createField({field, model, proto: cls.prototype})
                    })
                }

                Object.defineProperty(cls.prototype, 'isRecord', {value: true});
                Object.defineProperty(cls, 'isClass', {value: true});

                return ns[key]
            }

            return ns
        }
    }

    /**
     * Tests if a given object is an instance of a class created by this factory
     * @param {Object} record
     * @returns {Boolean}
     */
    isRecord(record) {
        return record?.isRecord || false
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} opts
     * @param {Object[]} opts.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} opts.model The model instance of the changed record
     * @param {Object} opts.record
     */
    onRecordChange(opts) {
        Neo.get(opts.model.storeId)?.onRecordChange(opts)
    }

    /**
     * @param {Object}  data
     * @param {Object}  data.record
     * @param {Object}  data.field
     * @param {*}       [data.value=null]
     * @param {Object}  [data.recordConfig=null]
     * @param {Boolean} [data.useOriginalData=false]
     * @returns {*}
     */
    parseRecordValue({record, field, value=null, recordConfig=null, useOriginalData=false}) {
        if (field.calculate) {
            return field.calculate(record[useOriginalData ? originalDataSymbol : dataSymbol], field)
        }

        if (field.convert) {
            value = field.convert(value)
        }

        let fieldName = field.name,
            {mapping, maxLength, minLength, nullable} = field,
            oldValue  = recordConfig?.[fieldName] || record[fieldName],
            type      = field.type?.toLowerCase();

        // only trigger mappings for initial values
        // dynamic changes of a field will not pass the recordConfig
        if (mapping && recordConfig) {
            let ns  = mapping.split('.'),
                key = ns.pop();

            ns    = Neo.ns(ns, true, recordConfig);
            value = ns[key]
        }

        if (Object.hasOwn(field, 'maxLength')) {
            if (value?.toString().length > maxLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with maxLength: ${maxLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'minLength')) {
            if (value?.toString().length < minLength) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with minLength: ${minLength}`);
                return oldValue
            }
        }

        if (Object.hasOwn(field, 'nullable')) {
            if (nullable === false && value === null) {
                console.warn(`Setting record field: ${fieldName} value: ${value} conflicts with nullable: ${nullable}`);
                return oldValue
            }
        }

        if (type === 'date' && Neo.typeOf(value) !== 'Date') {
            return new Date(value)
        }

        else if (type === 'float' && value) {
            value = parseFloat(value)
        }

        else if (type === 'html' && value) {
            value = value + ''
        }

        else if ((type === 'int' || type === 'integer') && value) {
            value = parseInt(value)
        }

        else if (type === 'string' && value) {
            value = value + '';
            value =  value.replace(/(<([^>]+)>)/ig, '')
        }

        return value
    }

    /**
     * @param {Object}         data
     * @param {String}         data.fieldName
     * @param {Neo.data.Model} data.model
     * @param {Record}         data.record
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     * @param {*}              data.value
     * @protected
     */
    setRecordData({fieldName, model, record, useOriginalData=false, value}) {
        if (useOriginalData && !model.trackModifiedFields) {
            return
        }

        let scope = useOriginalData ? originalDataSymbol : dataSymbol;

        if (model.hasNestedFields && fieldName.includes('.')) {
            let ns, nsArray;

            nsArray   = fieldName.split('.');
            fieldName = nsArray.pop();
            ns        = Neo.ns(nsArray, true, record[scope]);

            ns[fieldName] = value
        } else {
            record[scope][fieldName] = value
        }
    }

    /**
     * @param {Object}         data
     * @param {Object[]}       data.changedFields=[] Internal flag
     * @param {Object}         data.fields
     * @param {Neo.data.Model} data.model
     * @param {Object}         data.record
     * @param {Boolean}        data.silent=false
     * @param {Boolean}        data.useOriginalData=false true will apply changes to the originalData symbol
     */
    setRecordFields({changedFields=[], fields, model, record, silent=false, useOriginalData=false}) {
        let me = this,
            {calculatedFieldsMap, fieldsMap, trackModifiedFields} = model,
            fieldExists, hasChangedFields, oldValue;

        if (!trackModifiedFields && useOriginalData) {
            return
        }

        Object.entries(fields).forEach(([key, value]) => {
            fieldExists = fieldsMap.has(key);

            if (Neo.isObject(value) && !fieldExists) {
                Object.entries(value).forEach(([childKey, childValue]) => {
                    me.setRecordFields({
                        changedFields,
                        fields: {[`${key}.${childKey}`]: childValue},
                        model,
                        record,
                        silent: true,
                        useOriginalData
                    })
                })
            } else if (fieldExists) {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), value});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    if (!trackModifiedFields && !useOriginalData) {
                        record[isModifiedSymbol] = true
                    }

                    changedFields.push({name: key, oldValue, value})
                }
            }
        });

        hasChangedFields = Object.keys(changedFields).length > 0;

        if (hasChangedFields) {
            calculatedFieldsMap.forEach((value, key) => {
                oldValue = record[key];
                value    = me.parseRecordValue({record, field: model.getField(key), useOriginalData});

                if (!Neo.isEqual(oldValue, value)) {
                    me.setRecordData({fieldName: key, model, record, useOriginalData, value});

                    changedFields.push({name: key, oldValue, value})
                }
            })
        }

        if (!silent && !useOriginalData && hasChangedFields) {
            me.onRecordChange({fields: changedFields, model, record})
        }
    }
}

instance = Neo.setupClass(RecordFactory);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);


/***/ },

/***/ "./src/data/Store.mjs"
/*!****************************!*\
  !*** ./src/data/Store.mjs ***!
  \****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collection/Base.mjs */ "./src/collection/Base.mjs");
/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ "./src/data/Model.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RecordFactory.mjs */ "./src/data/RecordFactory.mjs");






const initialIndexSymbol = Symbol.for('initialIndex');

/**
 * @class Neo.data.Store
 * @extends Neo.collection.Base
 * @mixes Neo.core.Observable
 *
 * @summary A powerful, observable collection that manages a set of data records.
 *
 * Neo.data.Store is the central data management class in the framework. It handles the lifecycle of
 * data records, including loading, filtering, sorting, and synchronization with backend APIs.
 *
 * ### Record Instantiation Strategies: Eager vs. Lazy ("Turbo Mode")
 *
 * The Store supports two distinct strategies for handling record creation, controlled by the `autoInitRecords` config
 * (which defaults to `true`) and the `init` parameter in methods like `add()` and `insert()`.
 *
 * **1. Eager Instantiation (Default: `autoInitRecords: true`)**
 *    - **Behavior**: Raw data objects are immediately converted into `Neo.data.Model` instances.
 *    - **Use Case**: Standard operations, adding single items, interactive edits.
 *    - **Pros**: Returns usable Record instances immediately. High Developer Experience (DX).
 *    - **Cons**: Can be slow for massive datasets (10k+ records).
 *
 * **2. Lazy Instantiation ("Turbo Mode")**
 *    - **Behavior**: Raw data objects are stored directly. `Neo.data.Model` instances are created
 *      "just-in-time" only when they are accessed via `get()`, `getAt()`, or iteration.
 *    - **Use Case**: Bulk loading large datasets (e.g., grids, charts with thousands of points).
 *    - **Pros**: Massive performance gains for initial data load. Enables internal "chunking" to prevent UI freezes.
 *    - **Cons**: `add()` returns a count instead of records. Records are not available until accessed.
 *    - **How to enable**:
 *      - **Global**: Set `autoInitRecords: false` on the Store config.
 *      - **Per-call**: Pass `false` as the second argument to `add()` or `insert()`.
 *      ```javascript
 *      // Global setting
 *      Neo.create(Store, {
 *          autoInitRecords: false,
 *          data: hugeArrayOfData
 *      });
 *
 *      // Per-call override
 *      store.add(hugeArrayOfData, false);
 *      ```
 */
class Store extends _collection_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.data.Store'
         * @protected
         */
        className: 'Neo.data.Store',
        /**
         * @member {String} ntype='store'
         * @protected
         */
        ntype: 'store',
        /**
         * Instead of setting an url, you can define the RPC BE API methods.
         * In case the 4 methods are using the same service and this service is using the CRUD based fn-names,
         * you can switch to a string based shortcut.
         * The following 2 examples are equivalent.
         * @example
         * api: {
         *    create : 'MyApp.backend.UserService.create',
         *    destroy: 'MyApp.backend.UserService.destroy',
         *    read   : 'MyApp.backend.UserService.read',
         *    update : 'MyApp.backend.UserService.update'
         * }
         * @example
         * api: 'MyApp.backend.UserService'
         * @member {Object|String|null} api_=null
         * @reactive
         */
        api_: null,
        /**
         * True to automatically create record instances when adding items.
         * Set to false to enable "Turbo Mode" (Lazy Instantiation) globally for this store.
         * @member {Boolean} autoInitRecords=true
         */
        autoInitRecords: true,
        /**
         * @member {Boolean} autoLoad=false
         */
        autoLoad: false,
        /**
         * @member {Number} currentPage_=1
         * @reactive
         */
        currentPage_: 1,
        /**
         * @member {Array|null} data_=null
         * @reactive
         */
        data_: null,
        /**
         * The initial chunk size for adding large datasets. Set to 0 to disable chunking.
         * @member {Number} initialChunkSize=0
         */
        initialChunkSize: 0,
        /**
         * @member {Boolean} isGrouped=false
         */
        isGrouped: false,
        /**
         * @member {Boolean} isLoaded=false
         */
        isLoaded: false,
        /**
         * @member {Boolean} isLoading=false
         */
        isLoading: false,
        /**
         * @member {Neo.data.Model} model_=null
         * @reactive
         */
        model_: null,
        /**
         * Use a value of 0 to not limit the pageSize
         * @member {Number} pageSize_=0
         * @reactive
         */
        pageSize_: 0,
        /**
         * True to let the backend handle the filtering.
         * Useful for buffered stores
         * @member {Boolean} remoteFilter=false
         */
        remoteFilter: false,
        /**
         * True to let the backend handle the sorting.
         * Useful for buffered stores
         * @member {Boolean} remoteSort=false
         */
        remoteSort: false,
        /**
         * Add a path to the root of your data.
         * If the responseRoot is 'data' this is optional.
         * @member {String} responseRoot='data'
         */
        responseRoot: 'data',
        /**
         * @member {Number} totalCount=0
         */
        totalCount: 0,
        /**
         * Url for Ajax requests
         * @member {String|null} url=null
         */
        url: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        // todo
        me.on({
            mutate: me.onCollectionMutate,
            sort  : me.onCollectionSort,
            scope : me
        })
    }

    /**
     * Overrides collection.Base: add() to convert items into records if needed.
     *
     * **1. Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **2. Lazy Mode (`init=false`):**
     * Adds raw data directly for maximum performance. Instantiates records only on access.
     *
     * - **Chunking Active**: If `initialChunkSize > 0` and `items.length > threshold`:
     *   Adds items in chunks to prevent blocking the App Worker (Main Actor).
     *   Returns the new collection `count` (Number).
     *
     * - **No Chunking**: If `initialChunkSize === 0` or `items.length <= threshold`:
     *   Adds raw items directly.
     *   Returns an `Array` of the added raw data objects.
     *
     * @example
     * // 1. Default: Get records immediately
     * const [newRecord] = store.add({name: 'New Item'});
     *
     * @example
     * // 2. Turbo Mode (No Chunking): Get raw objects
     * const [rawObject] = store.add({name: 'Item'}, false);
     *
     * @example
     * // 3. Turbo Mode (Chunking): Get new count
     * store.initialChunkSize = 1000;
     * const newCount = store.add(hugeDataArray, false);
     *
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records, false for "Turbo Mode"
     * @returns {Number|Object[]|Neo.data.Model[]} The collection count, raw items, or created records
     */
    add(item, init=this.autoInitRecords) {
        let me        = this,
            items     = Array.isArray(item) ? item : [item],
            threshold = me.initialChunkSize;

        if (init) {
            super.add(items);

            me.isLoaded = true;

            return items.map(i => me.get(i[me.getKeyProperty()]))
        }

        if (threshold > 0 && items.length > threshold) {
            const total = me.count + items.length,
                  chunk = items.splice(0, threshold);

            me.chunkingTotal = total;

            // 1. Add the first chunk. This fires 'mutate' -> 'load' (via onCollectionMutate)
            //    and triggers the initial grid render. The 'load' event will contain the final total count.
            super.add(chunk); // Pass raw chunk directly

            // 2. Suspend events to prevent the next 'add' from firing 'load'.
            me.suspendEvents = true;

            // 3. Add the rest of the items silently.
            super.add(items); // Pass raw items directly

            // 4. Resume events.
            me.suspendEvents = false;

            // 5. Manually fire a final 'load' event to update the grid's scrollbar and notify other listeners.
            me.fire('load', {items: me.items, postChunkLoad: true, total: me.chunkingTotal});

            delete me.chunkingTotal;

            return me.count
        }

        const returnValue = super.add(items);

        // If we use add() initially instead of setting `data`, we need to set the loaded flag here.
        me.isLoaded = true;

        return returnValue // Pass raw item directly
    }

    /**
     * Triggered after the currentPage config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetCurrentPage(value, oldValue) {
        oldValue && this.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        let me = this;

        if (me.configsApplied) {
            if (value) {
                if (oldValue) {
                    me.clear()
                }

                me.isLoading = false;

                me.add(value, me.autoInitRecords)
            }
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetFilters(value, oldValue) {
        super.afterSetFilters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteFilter && me.load()
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     */
    afterSetModel(value, oldValue) {
        if (value) {
            value.storeId = this.id
        }
    }

    /**
     * Triggered after the pageSize config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetPageSize(value, oldValue) {
        if (oldValue) {
            this._currentPage = 1; // silent update
            this.load()
        }
    }

    /**
     * @param {Object[]} value
     * @param {Object[]} oldValue
     * @protected
     */
    afterSetSorters(value, oldValue) {
        super.afterSetSorters(value, oldValue);

        let me = this;

        me._currentPage = 1; // silent update

        oldValue && me.remoteSort && me.load()
    }

    /**
     * @param {Object|String|null} value
     * @param {Object|String|null} oldValue
     * @protected
     * @returns {Object|null}
     */
    beforeSetApi(value, oldValue) {
        if (Neo.typeOf(value) === 'String') {
            value = {
                create : value + '.create',
                destroy: value + '.destroy',
                read   : value + '.read',
                update : value + '.update'
            }
        }

        return value
    }

    /**
     * @param value
     * @param oldValue
     * @protected
     * @returns {*}
     */
    beforeSetData(value, oldValue) {
        if (value) {
            this.isLoading = true;

            // value = this.createRecord(value)
        }

        return value
    }



    /**
     * @param {Neo.data.Model|Object} value
     * @param {Neo.data.Model|Object} oldValue
     * @protected
     * @returns {Neo.data.Model}
     */
    beforeSetModel(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].beforeSetInstance(value, _Model_mjs__WEBPACK_IMPORTED_MODULE_2__["default"])
    }

    /**
     * Converts an object or array of objects into records
     * @param {Object|Object[]} config
     * @returns {Object|Object[]} Array in case an array was passed
     */
    createRecord(config) {
        let isArray = true;

        if (config) {
            if (!Array.isArray(config)) {
                isArray = false;
                config  = [config]
            }

            let me  = this,
                i   = 0,
                len = config.length,
                item;

            for (; i < len; i++) {
                item = config[i]

                if (!_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
                    config[i] = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item)
                }
            }
        }

        return isArray ? config : config[0]
    }

    /**
     * Overrides collection.Base:find() to ensure the returned item(s) are Record instances.
     * @param {Object|String} property
     * @param {String|Number} [value] Only required in case the first param is a string
     * @param {Boolean} returnFirstMatch=false
     * @returns {Object|Object[]|null}
     */
    find(property, value, returnFirstMatch=false) {
        const result = super.find(property, value, returnFirstMatch);

        if (returnFirstMatch) {
            return result ? this.get(result[this.keyProperty]) : null;
        } else {
            return result.map(item => this.get(item[this.keyProperty]));
        }
    }

    /**
     * Overrides collection.Base:findBy() to ensure the returned item(s) are Record instances.
     * @param {function} fn The function to run for each item inside the start-end range. Return true for a match.
     * @param {Object} scope=this The scope in which the passed function gets executed
     * @param {Number} start=0 The start index
     * @param {Number} end=this.count The end index (up to, last value excluded)
     * @returns {Array}
     */
    findBy(fn, scope=this, start=0, end=this.count) {
        const result = super.findBy(fn, scope, start, end);
        return result.map(item => this.get(item[this.keyProperty]));
    }

    /**
     * Overrides collection.Base:forEach() to ensure the iterated item is a Record instance.
     * @param {Function} fn The function to execute for each record.
     * @param {Object} [scope] Value to use as `this` when executing `fn`.
     */
    forEach(fn, scope) {
        const me = this;
        for (let i = 0; i < me.count; i++) {
            fn.call(scope || me, me.getAt(i), i, me.items);
        }
    }

    /**
     * Overrides collection.Base:get() to ensure the returned item is a Record instance.
     * @param {Number|String} key
     * @returns {Object|null}
     */
    get(key) {
        let me   = this,
            item = super.get(key); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item);
            const index  = me.indexOf(item);

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(key, record);
            if (index !== -1) {
                me._items[index] = record
            }

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(key, record);
                    me.allItems._items[masterIndex] = record
                }
            }
            return record
        }
        return item // Already a record or null
    }

    /**
     * Overrides collection.Base:getAt() to ensure the returned item is a Record instance.
     * @param {Number} index
     * @returns {Object|undefined}
     */
    getAt(index) {
        let me   = this,
            item = super.getAt(index); // Get item from Collection.Base (could be raw data)

        if (item && !_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(item)) {
            const record = _RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].createRecord(me.model, item);

            // Replace the raw data with the record instance in the current (filtered) collection
            me.map.set(record[me.keyProperty], record);
            me._items[index] = record;

            // If this collection is filtered, we must also update the master 'allItems' collection
            if (me.allItems) {
                const masterIndex = me.allItems.indexOf(item);
                if (masterIndex !== -1) {
                    me.allItems.map.set(record[me.keyProperty], record);
                    me.allItems._items[masterIndex] = record
                }
            }
            return record
        }
        return item // Already a record or undefined
    }

    /**
     * @returns {String}
     */
    getKeyProperty() {
        return this.keyProperty || this.model.keyProperty
    }

    /**
     * Convenience shortcut to check for int based keyProperties
     * @returns {String|null} lowercase value of the model field type
     */
    getKeyType() {
        let me       = this,
            {model}  = me,
            keyField = model?.getField(me.getKeyProperty());

        return keyField?.type?.toLowerCase() || null
    }

    /**
     * Converts a data object into a Record instance or returns it if it is already one.
     * This method is called by add() and insert() when init=true (default).
     * @param {Object} data The data object or Record instance
     * @returns {Object} The Record instance
     */
    initRecord(data) {
        if (_RecordFactory_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].isRecord(data)) {
            return data
        }

        return this.get(data[this.getKeyProperty()])
    }

    /**
     * Overrides collection.Base: insert() to convert items into records if needed.
     *
     * **Eager Mode (`init=true` - Default):**
     * Immediately converts raw data into `Neo.data.Model` instances.
     * Returns an `Array` of the created records.
     *
     * **Lazy Mode (`init=false`):**
     * Inserts raw data directly. Instantiates records only on access.
     * Returns an `Array` of the inserted raw data objects.
     *
     * @param {Number} index The index to insert at
     * @param {Array|Object} item The item(s) to add
     * @param {Boolean} [init=this.autoInitRecords] True to return the created records
     * @returns {Object[]|Neo.data.Model[]} The inserted raw items or created records
     */
    insert(index, item, init=this.autoInitRecords) {
        let me    = this,
            items = super.insert(index, item);

        if (init) {
            return items.map(i => me.get(i[me.getKeyProperty()]))
        }

        return items
    }

    /**
     * @param {Object} opts={}
     * @param {Object} opts.data
     * @param {Object} opts.headers
     * @param {String} opts.method DELETE, GET, POST, PUT
     * @param {Object} opts.params
     * @param {String} opts.responseType
     * @param {Object} opts.scope
     * @param {String} opts.url
     * @returns {Promise<Object|Object[]>}
     * @protected
     */
    async load(opts={}) {
        let me     = this,
            params = {page: me.currentPage, pageSize: me.pageSize, ...opts.params};

        if (me.remoteFilter) {
            params.filters = me.exportFilters()
        }

        if (me.remoteSort) {
            params.sorters = me.exportSorters()
        }

        if (me.api) {
            let apiArray = me.api.read.split('.'),
                fn       = apiArray.pop(),
                service  = Neo.ns(apiArray.join('.'));

            if (!service) {
                console.error('Api is not defined', this)
            } else {
                const response = await service[fn](params);

                if (response.success) {
                    me.totalCount = response.totalCount;
                    me.data       = Neo.ns(me.responseRoot, false, response); // fires the load event
                    me.isLoaded   = true;

                    return me.data
                }

                return null
            }
        } else {
            opts.url ??= me.url;

            try {
                let data;

                // Fallback for non-browser based envs like nodejs
                if (globalThis.process?.release) {
                    const { readFile } = await import(/* webpackIgnore: true */ 'fs/promises');
                    const content = await readFile(opts.url, 'utf-8');
                    data = {json: JSON.parse(content)};
                } else {
                    data = await Neo.Xhr.promiseJson(opts);
                }

                if (data) {
                    me.data = Neo.ns(me.responseRoot, false, data.json) || data.json // fires the load event
                }

                me.isLoaded = true;

                return data?.json || null
            } catch(err) {
                console.error('Error for Neo.Xhr.request', {id: me.id, error: err, url: opts.url});
                return null
            }
        }
    }

    /**
     * @param {Object} opts
     */
    onCollectionMutate(opts) {
        let me = this;

        if (me.isConstructed && !me.isLoading) {
            me.fire('load', {items: me.items, total: me.chunkingTotal});
        }
    }

    /**
     *
     */
    onCollectionSort() {
        let me = this;

        if (me.isConstructed) {
            me.fire('load', {items: me.items})
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me = this;

        if (me.data) {
            me.afterSetData(me.data)
        }

        // Being constructed does not mean that related afterSetStore() methods got executed
        // => break the sync flow to ensure potential listeners got applied
        Promise.resolve().then(() => {
            if (me.isLoaded) {
                me.fire('load', {items: me.items})
            } else if (me.autoLoad) {
                me.load()
            }
        })
    }

    /**
     * @param {Object} opts
     * @protected
     */
    onFilterChange(opts) {
        let me = this;

        if (me.remoteFilter) {
            me._currentPage = 1; // silent update
            me.load()
        } else {
            super.onFilterChange(opts)
        }
    }

    /**
     * Gets triggered after changing the value of a record field.
     * E.g. myRecord.foo = 'bar';
     * @param {Object} data
     * @param {Object[]} data.fields Each field object contains the keys: name, oldValue, value
     * @param {Neo.data.Model} data.model The model instance of the changed record
     * @param {Object} data.record
     */
    onRecordChange(data) {
        this.fire('recordChange', {
            ...data,
            index: this.indexOf(data.record)
        })
    }

    /**
     * @param {Object} opts={}
     * @param {String} opts.direction
     * @param {String} opts.property
     */
    sort(opts={}) {
        let me = this;

        me._currentPage = 1; // silent update

        if (me.configsApplied) {
            if (opts.direction) {
                me.sorters = [{
                    direction: opts.direction,
                    property : opts.property
                }]
            } else {
                if (!me.remoteSort) {
                    me.sorters = [{
                        direction: 'ASC',
                        property : initialIndexSymbol
                    }]
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Store));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19kYXRhX1N0b3JlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDRzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUk7QUFDeEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBYTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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QTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL01vZGVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2RhdGEvUmVjb3JkRmFjdG9yeS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9kYXRhL1N0b3JlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBSZWNvcmRGYWN0b3J5IGZyb20gJy4vUmVjb3JkRmFjdG9yeS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGF0YS5Nb2RlbFxuICogQGV4dGVuZHMgTmVvLmNvcmUuQmFzZVxuICovXG5jbGFzcyBNb2RlbCBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRhdGEuTW9kZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXRhLk1vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J21vZGVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ21vZGVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfG51bGx9IGZpZWxkc189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGZpZWxkc186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGtleVByb3BlcnR5Xz0naWQnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAga2V5UHJvcGVydHlfOiAnaWQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHN0b3JlSWQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZUlkOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgY29uZmlnIHRvIHRydWUgaW4gY2FzZSB5b3Ugd2FudCB0byB0cmFjayBtb2RpZmllZCBmaWVsZHMuXG4gICAgICAgICAqIEJlIGF3YXJlIHRoYXQgdGhpcyB3aWxsIGRvdWJsZSB0aGUgYW1vdW50IG9mIGRhdGEgaW5zaWRlIGVhY2ggcmVjb3JkLFxuICAgICAgICAgKiBzaW5jZSBlYWNoIGZpZWxkIHdpbGwgZ2V0IGFuIG9yaWdpbmFsIHZhbHVlIGZsYWcuXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHRyYWNrTW9kaWZpZWRGaWVsZHM9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRyYWNrTW9kaWZpZWRGaWVsZHM6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSBzdG9yaW5nIGFsbCBmaWVsZHMsIHdoaWNoIGhhdmUgYSBjYWxjdWxhdGUgcHJvcGVydHlcbiAgICAgKiBAbWVtYmVyIHtNYXB9IGNhbGN1bGF0ZWRGaWVsZHNNYXA9bmV3IE1hcCgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhbGN1bGF0ZWRGaWVsZHNNYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHN0b3JpbmcgYWxsIGZpZWxkcyBpbnNpZGUgYSBmbGF0IG1hcCA9PiBuZXN0ZWQgZmllbGRzIGluY2x1ZGVkXG4gICAgICogQG1lbWJlciB7TWFwfSBmaWVsZHNNYXA9bmV3IE1hcCgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZpZWxkc01hcCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGhhc05lc3RlZEZpZWxkcz1mYWxzZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBoYXNOZXN0ZWRGaWVsZHMgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgIFRyaWdnZXJlZCBhZnRlciB0aGUgZmllbGRzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmllbGRzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLnVwZGF0ZUZpZWxkc01hcCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIEZpZWxkcyBjYW4gZ2V0IGNoYW5nZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHRoZSBtb2RlbCBpbnN0YW5jZSBpcyBnZXR0aW5nIGNvbnN0cnVjdGVkLlxuICAgICAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRoZSBsYXRlc3Qgc3RhdGUgYmVmb3JlIGNvbnN0cnVjdGlvbiAmIGhvbm9yIHJ1bi10aW1lIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAobWUuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgICAgIFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkQ2xhc3MobWUsIHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIGZpZWxkIGNvbmZpZyBieSBhIGdpdmVuIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gVGhlIGZpZWxkIGNvbmZpZyBvYmplY3Qgb3IgbnVsbCBpZiBubyBtYXRjaCB3YXMgZm91bmRcbiAgICAgKi9cbiAgICBnZXRGaWVsZChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkc01hcC5nZXQobmFtZSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgZmllbGQgdHlwZSBieSBhIGdpdmVuIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gVGhlIGxvd2VyY2FzZSBmaWVsZCB0eXBlIG9yIG51bGwgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgZ2V0RmllbGRUeXBlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGQobmFtZSk/LnR5cGU/LnRvTG93ZXJDYXNlKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGZpZWxkc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSb290PXRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aD0nJ1xuICAgICAqL1xuICAgIHVwZGF0ZUZpZWxkc01hcChmaWVsZHMsIGlzUm9vdD10cnVlLCBwYXRoPScnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICB7Y2FsY3VsYXRlZEZpZWxkc01hcCwgZmllbGRzTWFwfSA9IG1lLFxuICAgICAgICAgICAgZmllbGROYW1lO1xuXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRGaWVsZHNNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIGZpZWxkc01hcC5jbGVhcigpO1xuICAgICAgICAgICAgbWUuaGFzTmVzdGVkRmllbGRzID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGZpZWxkTmFtZSA9IHBhdGggKyBmaWVsZC5uYW1lXG5cbiAgICAgICAgICAgIGlmIChmaWVsZC5maWVsZHMpIHtcbiAgICAgICAgICAgICAgICBtZS5oYXNOZXN0ZWRGaWVsZHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1lLnVwZGF0ZUZpZWxkc01hcChmaWVsZC5maWVsZHMsIGZhbHNlLCBmaWVsZC5uYW1lICsgJy4nKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHNNYXAuc2V0KGZpZWxkTmFtZSwgZmllbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmNhbGN1bGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkRmllbGRzTWFwLnNldChmaWVsZE5hbWUsIGZpZWxkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1vZGVsKTtcbiIsImltcG9ydCBCYXNlICBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcbmltcG9ydCBNb2RlbCBmcm9tICcuL01vZGVsLm1qcyc7XG5cbmNvbnN0XG4gICAgZGF0YVN5bWJvbCAgICAgICAgID0gU3ltYm9sLmZvcignZGF0YScpLFxuICAgIGluaXRpYWxJbmRleFN5bWJvbCA9IFN5bWJvbC5mb3IoJ2luaXRpYWxJbmRleCcpLFxuICAgIGlzTW9kaWZpZWRTeW1ib2wgICA9IFN5bWJvbC5mb3IoJ2lzTW9kaWZpZWQnKSxcbiAgICBvcmlnaW5hbERhdGFTeW1ib2wgPSBTeW1ib2wuZm9yKCdvcmlnaW5hbERhdGEnKTtcblxubGV0IGluc3RhbmNlO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZGF0YS5SZWNvcmRGYWN0b3J5XG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAc2luZ2xldG9uXG4gKi9cbmNsYXNzIFJlY29yZEZhY3RvcnkgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLlJlY29yZEZhY3RvcnknXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kYXRhLlJlY29yZEZhY3RvcnknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSByZWNvcmROYW1lc3BhY2U9J05lby5kYXRhLnJlY29yZCdcbiAgICAgICAgICovXG4gICAgICAgIHJlY29yZE5hbWVzcGFjZTogJ05lby5kYXRhLnJlY29yZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBzaW5nbGV0b249dHJ1ZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzaW5nbGV0b246IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG1vZGVsLWJhc2VkIGRlZmF1bHQgdmFsdWVzIHRvIGEgZGF0YSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGFzc2lnbkRlZmF1bHRWYWx1ZXMoZGF0YSwgbW9kZWwpIHtcbiAgICAgICAgbW9kZWwuZmllbGRzTWFwLmZvckVhY2goKGZpZWxkLCBmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCAnZGVmYXVsdFZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBOZW8uaXNGdW5jdGlvbihmaWVsZC5kZWZhdWx0VmFsdWUpID8gZmllbGQuZGVmYXVsdFZhbHVlKCkgOiBmaWVsZC5kZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCBhbHdheXMgdXNlIE5lby5hc3NpZ25Ub05zKCkgPT4gdGhlIGNoZWNrIGlzIGp1c3QgZm9yIGltcHJvdmluZyB0aGUgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIE5lby5hc3NpZ25Ub05zKGZpZWxkTmFtZSwgZGVmYXVsdFZhbHVlLCBkYXRhLCBmYWxzZSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFbZmllbGROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbZmllbGROYW1lXSA9IGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLmZpZWxkXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbH0gZGF0YS5tb2RlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLnBhdGg9JydcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5wcm90b1xuICAgICAqL1xuICAgIGNyZWF0ZUZpZWxkKHtmaWVsZCwgbW9kZWwsIHBhdGg9JycsIHByb3RvfSkge1xuICAgICAgICBsZXQgZmllbGROYW1lID0gZmllbGQubmFtZSxcbiAgICAgICAgICAgIGZpZWxkUGF0aCA9IHBhdGggPT09ICcnID8gZmllbGROYW1lIDogYCR7cGF0aH0uJHtmaWVsZE5hbWV9YCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKGZpZWxkLmZpZWxkcykge1xuICAgICAgICAgICAgZmllbGQuZmllbGRzLmZvckVhY2goY2hpbGRGaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGaWVsZCh7ZmllbGQ6IGNoaWxkRmllbGQsIG1vZGVsLCBwYXRoOiBmaWVsZFBhdGgsIHByb3RvfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgIFtmaWVsZFBhdGhdOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZSAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5lby5ucyhmaWVsZFBhdGgsIGZhbHNlLCB0aGlzW2RhdGFTeW1ib2xdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tkYXRhU3ltYm9sXVtmaWVsZE5hbWVdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczoge1tmaWVsZFBhdGhdOiBpbnN0YW5jZS5wYXJzZVJlY29yZFZhbHVlKHtyZWNvcmQ6IHRoaXMsIGZpZWxkLCB2YWx1ZX0pfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQ6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IG1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKG1vZGVsLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHJlY29yZENsYXNzID0gTmVvLm5zKGAke3RoaXMucmVjb3JkTmFtZXNwYWNlfS4ke21vZGVsLmNsYXNzTmFtZX0uJHttb2RlbC5pZH1gKTtcblxuICAgICAgICBpZiAoIXJlY29yZENsYXNzKSB7XG4gICAgICAgICAgICByZWNvcmRDbGFzcyA9IHRoaXMuY3JlYXRlUmVjb3JkQ2xhc3MobW9kZWwpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IHJlY29yZENsYXNzKGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBtb2RlbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlPWZhbHNlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGVSZWNvcmRDbGFzcyhtb2RlbCwgb3ZlcndyaXRlPWZhbHNlKSB7XG4gICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gYCR7dGhpcy5yZWNvcmROYW1lc3BhY2V9LiR7bW9kZWwuY2xhc3NOYW1lfS4ke21vZGVsLmlkfWAsXG4gICAgICAgICAgICAgICAgbnMgICAgICAgID0gTmVvLm5zKGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAga2V5LCBuc0FycmF5LCBjbHM7XG5cbiAgICAgICAgICAgIGlmICghbnMgfHwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgbnNBcnJheSA9IGNsYXNzTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIGtleSAgICAgPSBuc0FycmF5LnBvcCgpO1xuICAgICAgICAgICAgICAgIG5zICAgICAgPSBOZW8ubnMobnNBcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2xzICAgICA9IG5zW2tleV0gPSBjbGFzcyBSZWNvcmQge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBtaW5pZnkgdGhlIGN0b3IgY2xhc3MgbmFtZSBpbiBkaXN0L3Byb2R1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgc3RhdGljIG5hbWUgPSAnUmVjb3JkJztcblxuICAgICAgICAgICAgICAgICAgICBbZGF0YVN5bWJvbF0gICAgICAgICA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBbaW5pdGlhbEluZGV4U3ltYm9sXSA9IG51bGxcblxuICAgICAgICAgICAgICAgICAgICBnZXQgaXNNb2RpZmllZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC50cmFja01vZGlmaWVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFOZW8uaXNFcXVhbChtZVtkYXRhU3ltYm9sXSwgbWVbb3JpZ2luYWxEYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lW2lzTW9kaWZpZWRTeW1ib2xdXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihjb25maWcsIGluaXRpYWxJbmRleFN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZVtpbml0aWFsSW5kZXhTeW1ib2xdID0gY29uZmlnW2luaXRpYWxJbmRleFN5bWJvbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZ1tpbml0aWFsSW5kZXhTeW1ib2xdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGluc3RhbmNlLmFzc2lnbkRlZmF1bHRWYWx1ZXMoY29uZmlnLCBtb2RlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC50cmFja01vZGlmaWVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVbb3JpZ2luYWxEYXRhU3ltYm9sXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldE9yaWdpbmFsKGNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVbaXNNb2RpZmllZFN5bWJvbF0gPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXRTaWxlbnQoY29uZmlnKSAvLyBXZSBkbyBub3Qgd2FudCB0byBmaXJlIGNoYW5nZSBldmVudHMgd2hlbiBjb25zdHJ1Y3RpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IG51bGwgaW4gY2FzZSB0aGUgbW9kZWwgZG9lcyBub3QgdXNlIHRyYWNrTW9kaWZpZWRGaWVsZHMsIHRydWUgaW4gY2FzZSBhIGNoYW5nZSB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlzTW9kaWZpZWRGaWVsZChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC50cmFja01vZGlmaWVkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFTY29wZSwgb3JpZ2luYWxEYXRhU2NvcGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzICYmIGZpZWxkTmFtZT8uaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbnNBcnJheSA9IGZpZWxkTmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAgICAgICAgID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNjb3BlICAgICAgICAgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW2RhdGFTeW1ib2xdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhU2NvcGUgPSBOZW8ubnMobnNBcnJheSwgZmFsc2UsIG1lW29yaWdpbmFsRGF0YVN5bWJvbF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNjb3BlICAgICAgICAgPSBtZVtkYXRhU3ltYm9sXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxEYXRhU2NvcGUgPSBtZVtvcmlnaW5hbERhdGFTeW1ib2xdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpZWxkIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW1vZGVsLmdldEZpZWxkKGZpZWxkTmFtZSkgJiYgICAgICAgIC8vIENoZWNrIGZvciBsZWFmIGZpZWxkcyAoY291bGQgYmUgZXhjbHVkZWQgaW5zaWRlIHRoZSByZWFsIGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFPYmplY3QuaGFzT3duKGRhdGFTY29wZSwgZmllbGROYW1lKSAvLyBDaGVjayB0aGUgZGF0YSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSByZWNvcmQgZG9lcyBub3QgY29udGFpbiB0aGUgZmllbGQnLCBmaWVsZE5hbWUsIG1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhTmVvLmlzRXF1YWwoZGF0YVNjb3BlW2ZpZWxkTmFtZV0sIG9yaWdpbmFsRGF0YVNjb3BlW2ZpZWxkTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHNpbmdsZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHJlY29yZCBmaWVsZCBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICAgKiBFeGVjdXRlcyBpbnN0YW5jZS5zZXRSZWNvcmRGaWVsZHMoKSwgYW5kIGNhbiBnZXQgdXNlZCB2aWE6XG4gICAgICAgICAgICAgICAgICAgICAqIC0gTmVvLnV0aWwuRnVuY3Rpb246Y3JlYXRlU2VxdWVuY2UoKVxuICAgICAgICAgICAgICAgICAgICAgKiAtIE5lby51dGlsLkZ1bmN0aW9uOmludGVyY2VwdCgpLFxuICAgICAgICAgICAgICAgICAgICAgKiB0byBcImxpc3RlblwiIHRvIGZpZWxkIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLmZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIHNpbGVudD1mYWxzZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5Q2hhbmdlKGRhdGEsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW0gPSB7Li4uZGF0YSwgc2lsZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UmVjb3JkRmllbGRzKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEJ1bGstdXBkYXRlIG11bHRpcGxlIHJlY29yZCBmaWVsZHMgYXQgb25jZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICByZXNldChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0T3JpZ2luYWwoZmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBCdWxrLXVwZGF0ZSBtdWx0aXBsZSByZWNvcmQgZmllbGRzIGF0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgc2V0KGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2Uoe2ZpZWxkcywgbW9kZWwsIHJlY29yZDogdGhpc30pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIG1vZGVsIHVzZXMgdHJhY2tNb2RpZmllZEZpZWxkcywgd2Ugd2lsbCBzdG9yZSB0aGUgb3JpZ2luYWwgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgKiBmb3IgdHJhY2tpbmcgdGhlIGRpcnR5IHN0YXRlIChjaGFuZ2VkIGZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRPcmlnaW5hbChmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldFJlY29yZEZpZWxkcyh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzLCBzaWxlbnQ6IHRydWUsIHVzZU9yaWdpbmFsRGF0YTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQnVsay11cGRhdGUgbXVsdGlwbGUgcmVjb3JkIGZpZWxkcyBhdCBvbmNlIHdpdGhvdXQgdHJpZ2dlcmluZyBhIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRTaWxlbnQoZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZSh7ZmllbGRzLCBtb2RlbCwgcmVjb3JkOiB0aGlzfSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIHVzaW5nIEpTT04uc3RyaW5naWZ5KHRoaXMpLCB3ZSB3YW50IHRvIGdldCB0aGUgcmF3IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpc1tkYXRhU3ltYm9sXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbC5maWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNyZWF0ZUZpZWxkKHtmaWVsZCwgbW9kZWwsIHByb3RvOiBjbHMucHJvdG90eXBlfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xzLnByb3RvdHlwZSwgJ2lzUmVjb3JkJywge3ZhbHVlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNscywgJ2lzQ2xhc3MnLCB7dmFsdWU6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuc1trZXldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgYSBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyBjcmVhdGVkIGJ5IHRoaXMgZmFjdG9yeVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlY29yZChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZD8uaXNSZWNvcmQgfHwgZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBhZnRlciBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgYSByZWNvcmQgZmllbGQuXG4gICAgICogRS5nLiBteVJlY29yZC5mb28gPSAnYmFyJztcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdHMuZmllbGRzIEVhY2ggZmllbGQgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzOiBuYW1lLCBvbGRWYWx1ZSwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBvcHRzLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSBvZiB0aGUgY2hhbmdlZCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZWNvcmRcbiAgICAgKi9cbiAgICBvblJlY29yZENoYW5nZShvcHRzKSB7XG4gICAgICAgIE5lby5nZXQob3B0cy5tb2RlbC5zdG9yZUlkKT8ub25SZWNvcmRDaGFuZ2Uob3B0cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGEucmVjb3JkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhLmZpZWxkXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBbZGF0YS52YWx1ZT1udWxsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgW2RhdGEucmVjb3JkQ29uZmlnPW51bGxdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGF0YS51c2VPcmlnaW5hbERhdGE9ZmFsc2VdXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgcGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZCwgdmFsdWU9bnVsbCwgcmVjb3JkQ29uZmlnPW51bGwsIHVzZU9yaWdpbmFsRGF0YT1mYWxzZX0pIHtcbiAgICAgICAgaWYgKGZpZWxkLmNhbGN1bGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmNhbGN1bGF0ZShyZWNvcmRbdXNlT3JpZ2luYWxEYXRhID8gb3JpZ2luYWxEYXRhU3ltYm9sIDogZGF0YVN5bWJvbF0sIGZpZWxkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkLmNvbnZlcnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQuY29udmVydCh2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lLFxuICAgICAgICAgICAge21hcHBpbmcsIG1heExlbmd0aCwgbWluTGVuZ3RoLCBudWxsYWJsZX0gPSBmaWVsZCxcbiAgICAgICAgICAgIG9sZFZhbHVlICA9IHJlY29yZENvbmZpZz8uW2ZpZWxkTmFtZV0gfHwgcmVjb3JkW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgICB0eXBlICAgICAgPSBmaWVsZC50eXBlPy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIG9ubHkgdHJpZ2dlciBtYXBwaW5ncyBmb3IgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgLy8gZHluYW1pYyBjaGFuZ2VzIG9mIGEgZmllbGQgd2lsbCBub3QgcGFzcyB0aGUgcmVjb3JkQ29uZmlnXG4gICAgICAgIGlmIChtYXBwaW5nICYmIHJlY29yZENvbmZpZykge1xuICAgICAgICAgICAgbGV0IG5zICA9IG1hcHBpbmcuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBucy5wb3AoKTtcblxuICAgICAgICAgICAgbnMgICAgPSBOZW8ubnMobnMsIHRydWUsIHJlY29yZENvbmZpZyk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5zW2tleV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCAnbWF4TGVuZ3RoJykpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZT8udG9TdHJpbmcoKS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNldHRpbmcgcmVjb3JkIGZpZWxkOiAke2ZpZWxkTmFtZX0gdmFsdWU6ICR7dmFsdWV9IGNvbmZsaWN0cyB3aXRoIG1heExlbmd0aDogJHttYXhMZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZCwgJ21pbkxlbmd0aCcpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWU/LnRvU3RyaW5nKCkubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXR0aW5nIHJlY29yZCBmaWVsZDogJHtmaWVsZE5hbWV9IHZhbHVlOiAke3ZhbHVlfSBjb25mbGljdHMgd2l0aCBtaW5MZW5ndGg6ICR7bWluTGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsICdudWxsYWJsZScpKSB7XG4gICAgICAgICAgICBpZiAobnVsbGFibGUgPT09IGZhbHNlICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXR0aW5nIHJlY29yZCBmaWVsZDogJHtmaWVsZE5hbWV9IHZhbHVlOiAke3ZhbHVlfSBjb25mbGljdHMgd2l0aCBudWxsYWJsZTogJHtudWxsYWJsZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnZGF0ZScgJiYgTmVvLnR5cGVPZih2YWx1ZSkgIT09ICdEYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Zsb2F0JyAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2h0bWwnICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJydcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSAnaW50JyB8fCB0eXBlID09PSAnaW50ZWdlcicpICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJztcbiAgICAgICAgICAgIHZhbHVlID0gIHZhbHVlLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCAnJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICBkYXRhLmZpZWxkTmFtZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWxcbiAgICAgKiBAcGFyYW0ge1JlY29yZH0gICAgICAgICBkYXRhLnJlY29yZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEudXNlT3JpZ2luYWxEYXRhPWZhbHNlIHRydWUgd2lsbCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvcmlnaW5hbERhdGEgc3ltYm9sXG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgICAgICAgZGF0YS52YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRSZWNvcmREYXRhKHtmaWVsZE5hbWUsIG1vZGVsLCByZWNvcmQsIHVzZU9yaWdpbmFsRGF0YT1mYWxzZSwgdmFsdWV9KSB7XG4gICAgICAgIGlmICh1c2VPcmlnaW5hbERhdGEgJiYgIW1vZGVsLnRyYWNrTW9kaWZpZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNjb3BlID0gdXNlT3JpZ2luYWxEYXRhID8gb3JpZ2luYWxEYXRhU3ltYm9sIDogZGF0YVN5bWJvbDtcblxuICAgICAgICBpZiAobW9kZWwuaGFzTmVzdGVkRmllbGRzICYmIGZpZWxkTmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBsZXQgbnMsIG5zQXJyYXk7XG5cbiAgICAgICAgICAgIG5zQXJyYXkgICA9IGZpZWxkTmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgZmllbGROYW1lID0gbnNBcnJheS5wb3AoKTtcbiAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhuc0FycmF5LCB0cnVlLCByZWNvcmRbc2NvcGVdKTtcblxuICAgICAgICAgICAgbnNbZmllbGROYW1lXSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRbc2NvcGVdW2ZpZWxkTmFtZV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119ICAgICAgIGRhdGEuY2hhbmdlZEZpZWxkcz1bXSBJbnRlcm5hbCBmbGFnXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5maWVsZHNcbiAgICAgKiBAcGFyYW0ge05lby5kYXRhLk1vZGVsfSBkYXRhLm1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICBkYXRhLnNpbGVudD1mYWxzZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgIGRhdGEudXNlT3JpZ2luYWxEYXRhPWZhbHNlIHRydWUgd2lsbCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBvcmlnaW5hbERhdGEgc3ltYm9sXG4gICAgICovXG4gICAgc2V0UmVjb3JkRmllbGRzKHtjaGFuZ2VkRmllbGRzPVtdLCBmaWVsZHMsIG1vZGVsLCByZWNvcmQsIHNpbGVudD1mYWxzZSwgdXNlT3JpZ2luYWxEYXRhPWZhbHNlfSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAge2NhbGN1bGF0ZWRGaWVsZHNNYXAsIGZpZWxkc01hcCwgdHJhY2tNb2RpZmllZEZpZWxkc30gPSBtb2RlbCxcbiAgICAgICAgICAgIGZpZWxkRXhpc3RzLCBoYXNDaGFuZ2VkRmllbGRzLCBvbGRWYWx1ZTtcblxuICAgICAgICBpZiAoIXRyYWNrTW9kaWZpZWRGaWVsZHMgJiYgdXNlT3JpZ2luYWxEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBmaWVsZEV4aXN0cyA9IGZpZWxkc01hcC5oYXMoa2V5KTtcblxuICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgIWZpZWxkRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtjaGlsZEtleSwgY2hpbGRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2V0UmVjb3JkRmllbGRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRGaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHtbYCR7a2V5fS4ke2NoaWxkS2V5fWBdOiBjaGlsZFZhbHVlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlT3JpZ2luYWxEYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGRFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgID0gbWUucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZDogbW9kZWwuZ2V0RmllbGQoa2V5KSwgdmFsdWV9KTtcblxuICAgICAgICAgICAgICAgIGlmICghTmVvLmlzRXF1YWwob2xkVmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zZXRSZWNvcmREYXRhKHtmaWVsZE5hbWU6IGtleSwgbW9kZWwsIHJlY29yZCwgdXNlT3JpZ2luYWxEYXRhLCB2YWx1ZX0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2tNb2RpZmllZEZpZWxkcyAmJiAhdXNlT3JpZ2luYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRbaXNNb2RpZmllZFN5bWJvbF0gPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzLnB1c2goe25hbWU6IGtleSwgb2xkVmFsdWUsIHZhbHVlfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhhc0NoYW5nZWRGaWVsZHMgPSBPYmplY3Qua2V5cyhjaGFuZ2VkRmllbGRzKS5sZW5ndGggPiAwO1xuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkRmllbGRzKSB7XG4gICAgICAgICAgICBjYWxjdWxhdGVkRmllbGRzTWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgID0gbWUucGFyc2VSZWNvcmRWYWx1ZSh7cmVjb3JkLCBmaWVsZDogbW9kZWwuZ2V0RmllbGQoa2V5KSwgdXNlT3JpZ2luYWxEYXRhfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKG9sZFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuc2V0UmVjb3JkRGF0YSh7ZmllbGROYW1lOiBrZXksIG1vZGVsLCByZWNvcmQsIHVzZU9yaWdpbmFsRGF0YSwgdmFsdWV9KTtcblxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzLnB1c2goe25hbWU6IGtleSwgb2xkVmFsdWUsIHZhbHVlfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaWxlbnQgJiYgIXVzZU9yaWdpbmFsRGF0YSAmJiBoYXNDaGFuZ2VkRmllbGRzKSB7XG4gICAgICAgICAgICBtZS5vblJlY29yZENoYW5nZSh7ZmllbGRzOiBjaGFuZ2VkRmllbGRzLCBtb2RlbCwgcmVjb3JkfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW5zdGFuY2UgPSBOZW8uc2V0dXBDbGFzcyhSZWNvcmRGYWN0b3J5KTtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFuY2U7XG4iLCJpbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb2xsZWN0aW9uICAgICAgZnJvbSAnLi4vY29sbGVjdGlvbi9CYXNlLm1qcyc7XG5pbXBvcnQgTW9kZWwgICAgICAgICAgIGZyb20gJy4vTW9kZWwubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQgUmVjb3JkRmFjdG9yeSAgIGZyb20gJy4vUmVjb3JkRmFjdG9yeS5tanMnO1xuXG5jb25zdCBpbml0aWFsSW5kZXhTeW1ib2wgPSBTeW1ib2wuZm9yKCdpbml0aWFsSW5kZXgnKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRhdGEuU3RvcmVcbiAqIEBleHRlbmRzIE5lby5jb2xsZWN0aW9uLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKlxuICogQHN1bW1hcnkgQSBwb3dlcmZ1bCwgb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIHRoYXQgbWFuYWdlcyBhIHNldCBvZiBkYXRhIHJlY29yZHMuXG4gKlxuICogTmVvLmRhdGEuU3RvcmUgaXMgdGhlIGNlbnRyYWwgZGF0YSBtYW5hZ2VtZW50IGNsYXNzIGluIHRoZSBmcmFtZXdvcmsuIEl0IGhhbmRsZXMgdGhlIGxpZmVjeWNsZSBvZlxuICogZGF0YSByZWNvcmRzLCBpbmNsdWRpbmcgbG9hZGluZywgZmlsdGVyaW5nLCBzb3J0aW5nLCBhbmQgc3luY2hyb25pemF0aW9uIHdpdGggYmFja2VuZCBBUElzLlxuICpcbiAqICMjIyBSZWNvcmQgSW5zdGFudGlhdGlvbiBTdHJhdGVnaWVzOiBFYWdlciB2cy4gTGF6eSAoXCJUdXJibyBNb2RlXCIpXG4gKlxuICogVGhlIFN0b3JlIHN1cHBvcnRzIHR3byBkaXN0aW5jdCBzdHJhdGVnaWVzIGZvciBoYW5kbGluZyByZWNvcmQgY3JlYXRpb24sIGNvbnRyb2xsZWQgYnkgdGhlIGBhdXRvSW5pdFJlY29yZHNgIGNvbmZpZ1xuICogKHdoaWNoIGRlZmF1bHRzIHRvIGB0cnVlYCkgYW5kIHRoZSBgaW5pdGAgcGFyYW1ldGVyIGluIG1ldGhvZHMgbGlrZSBgYWRkKClgIGFuZCBgaW5zZXJ0KClgLlxuICpcbiAqICoqMS4gRWFnZXIgSW5zdGFudGlhdGlvbiAoRGVmYXVsdDogYGF1dG9Jbml0UmVjb3JkczogdHJ1ZWApKipcbiAqICAgIC0gKipCZWhhdmlvcioqOiBSYXcgZGF0YSBvYmplY3RzIGFyZSBpbW1lZGlhdGVseSBjb252ZXJ0ZWQgaW50byBgTmVvLmRhdGEuTW9kZWxgIGluc3RhbmNlcy5cbiAqICAgIC0gKipVc2UgQ2FzZSoqOiBTdGFuZGFyZCBvcGVyYXRpb25zLCBhZGRpbmcgc2luZ2xlIGl0ZW1zLCBpbnRlcmFjdGl2ZSBlZGl0cy5cbiAqICAgIC0gKipQcm9zKio6IFJldHVybnMgdXNhYmxlIFJlY29yZCBpbnN0YW5jZXMgaW1tZWRpYXRlbHkuIEhpZ2ggRGV2ZWxvcGVyIEV4cGVyaWVuY2UgKERYKS5cbiAqICAgIC0gKipDb25zKio6IENhbiBiZSBzbG93IGZvciBtYXNzaXZlIGRhdGFzZXRzICgxMGsrIHJlY29yZHMpLlxuICpcbiAqICoqMi4gTGF6eSBJbnN0YW50aWF0aW9uIChcIlR1cmJvIE1vZGVcIikqKlxuICogICAgLSAqKkJlaGF2aW9yKio6IFJhdyBkYXRhIG9iamVjdHMgYXJlIHN0b3JlZCBkaXJlY3RseS4gYE5lby5kYXRhLk1vZGVsYCBpbnN0YW5jZXMgYXJlIGNyZWF0ZWRcbiAqICAgICAgXCJqdXN0LWluLXRpbWVcIiBvbmx5IHdoZW4gdGhleSBhcmUgYWNjZXNzZWQgdmlhIGBnZXQoKWAsIGBnZXRBdCgpYCwgb3IgaXRlcmF0aW9uLlxuICogICAgLSAqKlVzZSBDYXNlKio6IEJ1bGsgbG9hZGluZyBsYXJnZSBkYXRhc2V0cyAoZS5nLiwgZ3JpZHMsIGNoYXJ0cyB3aXRoIHRob3VzYW5kcyBvZiBwb2ludHMpLlxuICogICAgLSAqKlByb3MqKjogTWFzc2l2ZSBwZXJmb3JtYW5jZSBnYWlucyBmb3IgaW5pdGlhbCBkYXRhIGxvYWQuIEVuYWJsZXMgaW50ZXJuYWwgXCJjaHVua2luZ1wiIHRvIHByZXZlbnQgVUkgZnJlZXplcy5cbiAqICAgIC0gKipDb25zKio6IGBhZGQoKWAgcmV0dXJucyBhIGNvdW50IGluc3RlYWQgb2YgcmVjb3Jkcy4gUmVjb3JkcyBhcmUgbm90IGF2YWlsYWJsZSB1bnRpbCBhY2Nlc3NlZC5cbiAqICAgIC0gKipIb3cgdG8gZW5hYmxlKio6XG4gKiAgICAgIC0gKipHbG9iYWwqKjogU2V0IGBhdXRvSW5pdFJlY29yZHM6IGZhbHNlYCBvbiB0aGUgU3RvcmUgY29uZmlnLlxuICogICAgICAtICoqUGVyLWNhbGwqKjogUGFzcyBgZmFsc2VgIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGFkZCgpYCBvciBgaW5zZXJ0KClgLlxuICogICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgIC8vIEdsb2JhbCBzZXR0aW5nXG4gKiAgICAgIE5lby5jcmVhdGUoU3RvcmUsIHtcbiAqICAgICAgICAgIGF1dG9Jbml0UmVjb3JkczogZmFsc2UsXG4gKiAgICAgICAgICBkYXRhOiBodWdlQXJyYXlPZkRhdGFcbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBQZXItY2FsbCBvdmVycmlkZVxuICogICAgICBzdG9yZS5hZGQoaHVnZUFycmF5T2ZEYXRhLCBmYWxzZSk7XG4gKiAgICAgIGBgYFxuICovXG5jbGFzcyBTdG9yZSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5kYXRhLlN0b3JlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZGF0YS5TdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzdG9yZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzdG9yZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0ZWFkIG9mIHNldHRpbmcgYW4gdXJsLCB5b3UgY2FuIGRlZmluZSB0aGUgUlBDIEJFIEFQSSBtZXRob2RzLlxuICAgICAgICAgKiBJbiBjYXNlIHRoZSA0IG1ldGhvZHMgYXJlIHVzaW5nIHRoZSBzYW1lIHNlcnZpY2UgYW5kIHRoaXMgc2VydmljZSBpcyB1c2luZyB0aGUgQ1JVRCBiYXNlZCBmbi1uYW1lcyxcbiAgICAgICAgICogeW91IGNhbiBzd2l0Y2ggdG8gYSBzdHJpbmcgYmFzZWQgc2hvcnRjdXQuXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgMiBleGFtcGxlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYXBpOiB7XG4gICAgICAgICAqICAgIGNyZWF0ZSA6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmNyZWF0ZScsXG4gICAgICAgICAqICAgIGRlc3Ryb3k6ICdNeUFwcC5iYWNrZW5kLlVzZXJTZXJ2aWNlLmRlc3Ryb3knLFxuICAgICAgICAgKiAgICByZWFkICAgOiAnTXlBcHAuYmFja2VuZC5Vc2VyU2VydmljZS5yZWFkJyxcbiAgICAgICAgICogICAgdXBkYXRlIDogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UudXBkYXRlJ1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGFwaTogJ015QXBwLmJhY2tlbmQuVXNlclNlcnZpY2UnXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxTdHJpbmd8bnVsbH0gYXBpXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBpXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgcmVjb3JkIGluc3RhbmNlcyB3aGVuIGFkZGluZyBpdGVtcy5cbiAgICAgICAgICogU2V0IHRvIGZhbHNlIHRvIGVuYWJsZSBcIlR1cmJvIE1vZGVcIiAoTGF6eSBJbnN0YW50aWF0aW9uKSBnbG9iYWxseSBmb3IgdGhpcyBzdG9yZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b0luaXRSZWNvcmRzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Jbml0UmVjb3JkczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9Mb2FkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvTG9hZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGN1cnJlbnRQYWdlXz0xXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudFBhZ2VfOiAxLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXl8bnVsbH0gZGF0YV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgY2h1bmsgc2l6ZSBmb3IgYWRkaW5nIGxhcmdlIGRhdGFzZXRzLiBTZXQgdG8gMCB0byBkaXNhYmxlIGNodW5raW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IGluaXRpYWxDaHVua1NpemU9MFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbENodW5rU2l6ZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzR3JvdXBlZD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNHcm91cGVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGlzTG9hZGVkPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpc0xvYWRlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBpc0xvYWRpbmc9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5Nb2RlbH0gbW9kZWxfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgYSB2YWx1ZSBvZiAwIHRvIG5vdCBsaW1pdCB0aGUgcGFnZVNpemVcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBwYWdlU2l6ZV89MFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VTaXplXzogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgdG8gbGV0IHRoZSBiYWNrZW5kIGhhbmRsZSB0aGUgZmlsdGVyaW5nLlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGJ1ZmZlcmVkIHN0b3Jlc1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSByZW1vdGVGaWx0ZXI9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZUZpbHRlcjogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIHRvIGxldCB0aGUgYmFja2VuZCBoYW5kbGUgdGhlIHNvcnRpbmcuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgYnVmZmVyZWQgc3RvcmVzXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW90ZVNvcnQ9ZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbW90ZVNvcnQ6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgcGF0aCB0byB0aGUgcm9vdCBvZiB5b3VyIGRhdGEuXG4gICAgICAgICAqIElmIHRoZSByZXNwb25zZVJvb3QgaXMgJ2RhdGEnIHRoaXMgaXMgb3B0aW9uYWwuXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gcmVzcG9uc2VSb290PSdkYXRhJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVzcG9uc2VSb290OiAnZGF0YScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHRvdGFsQ291bnQ9MFxuICAgICAgICAgKi9cbiAgICAgICAgdG90YWxDb3VudDogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVybCBmb3IgQWpheCByZXF1ZXN0c1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gdXJsPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHVybDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gdG9kb1xuICAgICAgICBtZS5vbih7XG4gICAgICAgICAgICBtdXRhdGU6IG1lLm9uQ29sbGVjdGlvbk11dGF0ZSxcbiAgICAgICAgICAgIHNvcnQgIDogbWUub25Db2xsZWN0aW9uU29ydCxcbiAgICAgICAgICAgIHNjb3BlIDogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOiBhZGQoKSB0byBjb252ZXJ0IGl0ZW1zIGludG8gcmVjb3JkcyBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiAqKjEuIEVhZ2VyIE1vZGUgKGBpbml0PXRydWVgIC0gRGVmYXVsdCk6KipcbiAgICAgKiBJbW1lZGlhdGVseSBjb252ZXJ0cyByYXcgZGF0YSBpbnRvIGBOZW8uZGF0YS5Nb2RlbGAgaW5zdGFuY2VzLlxuICAgICAqIFJldHVybnMgYW4gYEFycmF5YCBvZiB0aGUgY3JlYXRlZCByZWNvcmRzLlxuICAgICAqXG4gICAgICogKioyLiBMYXp5IE1vZGUgKGBpbml0PWZhbHNlYCk6KipcbiAgICAgKiBBZGRzIHJhdyBkYXRhIGRpcmVjdGx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBJbnN0YW50aWF0ZXMgcmVjb3JkcyBvbmx5IG9uIGFjY2Vzcy5cbiAgICAgKlxuICAgICAqIC0gKipDaHVua2luZyBBY3RpdmUqKjogSWYgYGluaXRpYWxDaHVua1NpemUgPiAwYCBhbmQgYGl0ZW1zLmxlbmd0aCA+IHRocmVzaG9sZGA6XG4gICAgICogICBBZGRzIGl0ZW1zIGluIGNodW5rcyB0byBwcmV2ZW50IGJsb2NraW5nIHRoZSBBcHAgV29ya2VyIChNYWluIEFjdG9yKS5cbiAgICAgKiAgIFJldHVybnMgdGhlIG5ldyBjb2xsZWN0aW9uIGBjb3VudGAgKE51bWJlcikuXG4gICAgICpcbiAgICAgKiAtICoqTm8gQ2h1bmtpbmcqKjogSWYgYGluaXRpYWxDaHVua1NpemUgPT09IDBgIG9yIGBpdGVtcy5sZW5ndGggPD0gdGhyZXNob2xkYDpcbiAgICAgKiAgIEFkZHMgcmF3IGl0ZW1zIGRpcmVjdGx5LlxuICAgICAqICAgUmV0dXJucyBhbiBgQXJyYXlgIG9mIHRoZSBhZGRlZCByYXcgZGF0YSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyAxLiBEZWZhdWx0OiBHZXQgcmVjb3JkcyBpbW1lZGlhdGVseVxuICAgICAqIGNvbnN0IFtuZXdSZWNvcmRdID0gc3RvcmUuYWRkKHtuYW1lOiAnTmV3IEl0ZW0nfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIDIuIFR1cmJvIE1vZGUgKE5vIENodW5raW5nKTogR2V0IHJhdyBvYmplY3RzXG4gICAgICogY29uc3QgW3Jhd09iamVjdF0gPSBzdG9yZS5hZGQoe25hbWU6ICdJdGVtJ30sIGZhbHNlKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gMy4gVHVyYm8gTW9kZSAoQ2h1bmtpbmcpOiBHZXQgbmV3IGNvdW50XG4gICAgICogc3RvcmUuaW5pdGlhbENodW5rU2l6ZSA9IDEwMDA7XG4gICAgICogY29uc3QgbmV3Q291bnQgPSBzdG9yZS5hZGQoaHVnZURhdGFBcnJheSwgZmFsc2UpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0ocykgdG8gYWRkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdD10aGlzLmF1dG9Jbml0UmVjb3Jkc10gVHJ1ZSB0byByZXR1cm4gdGhlIGNyZWF0ZWQgcmVjb3JkcywgZmFsc2UgZm9yIFwiVHVyYm8gTW9kZVwiXG4gICAgICogQHJldHVybnMge051bWJlcnxPYmplY3RbXXxOZW8uZGF0YS5Nb2RlbFtdfSBUaGUgY29sbGVjdGlvbiBjb3VudCwgcmF3IGl0ZW1zLCBvciBjcmVhdGVkIHJlY29yZHNcbiAgICAgKi9cbiAgICBhZGQoaXRlbSwgaW5pdD10aGlzLmF1dG9Jbml0UmVjb3Jkcykge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW1zICAgICA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dLFxuICAgICAgICAgICAgdGhyZXNob2xkID0gbWUuaW5pdGlhbENodW5rU2l6ZTtcblxuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgc3VwZXIuYWRkKGl0ZW1zKTtcblxuICAgICAgICAgICAgbWUuaXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gaXRlbXMubWFwKGkgPT4gbWUuZ2V0KGlbbWUuZ2V0S2V5UHJvcGVydHkoKV0pKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZCA+IDAgJiYgaXRlbXMubGVuZ3RoID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IG1lLmNvdW50ICsgaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgY2h1bmsgPSBpdGVtcy5zcGxpY2UoMCwgdGhyZXNob2xkKTtcblxuICAgICAgICAgICAgbWUuY2h1bmtpbmdUb3RhbCA9IHRvdGFsO1xuXG4gICAgICAgICAgICAvLyAxLiBBZGQgdGhlIGZpcnN0IGNodW5rLiBUaGlzIGZpcmVzICdtdXRhdGUnIC0+ICdsb2FkJyAodmlhIG9uQ29sbGVjdGlvbk11dGF0ZSlcbiAgICAgICAgICAgIC8vICAgIGFuZCB0cmlnZ2VycyB0aGUgaW5pdGlhbCBncmlkIHJlbmRlci4gVGhlICdsb2FkJyBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGZpbmFsIHRvdGFsIGNvdW50LlxuICAgICAgICAgICAgc3VwZXIuYWRkKGNodW5rKTsgLy8gUGFzcyByYXcgY2h1bmsgZGlyZWN0bHlcblxuICAgICAgICAgICAgLy8gMi4gU3VzcGVuZCBldmVudHMgdG8gcHJldmVudCB0aGUgbmV4dCAnYWRkJyBmcm9tIGZpcmluZyAnbG9hZCcuXG4gICAgICAgICAgICBtZS5zdXNwZW5kRXZlbnRzID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gMy4gQWRkIHRoZSByZXN0IG9mIHRoZSBpdGVtcyBzaWxlbnRseS5cbiAgICAgICAgICAgIHN1cGVyLmFkZChpdGVtcyk7IC8vIFBhc3MgcmF3IGl0ZW1zIGRpcmVjdGx5XG5cbiAgICAgICAgICAgIC8vIDQuIFJlc3VtZSBldmVudHMuXG4gICAgICAgICAgICBtZS5zdXNwZW5kRXZlbnRzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIDUuIE1hbnVhbGx5IGZpcmUgYSBmaW5hbCAnbG9hZCcgZXZlbnQgdG8gdXBkYXRlIHRoZSBncmlkJ3Mgc2Nyb2xsYmFyIGFuZCBub3RpZnkgb3RoZXIgbGlzdGVuZXJzLlxuICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXMsIHBvc3RDaHVua0xvYWQ6IHRydWUsIHRvdGFsOiBtZS5jaHVua2luZ1RvdGFsfSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtZS5jaHVua2luZ1RvdGFsO1xuXG4gICAgICAgICAgICByZXR1cm4gbWUuY291bnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gc3VwZXIuYWRkKGl0ZW1zKTtcblxuICAgICAgICAvLyBJZiB3ZSB1c2UgYWRkKCkgaW5pdGlhbGx5IGluc3RlYWQgb2Ygc2V0dGluZyBgZGF0YWAsIHdlIG5lZWQgdG8gc2V0IHRoZSBsb2FkZWQgZmxhZyBoZXJlLlxuICAgICAgICBtZS5pc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlIC8vIFBhc3MgcmF3IGl0ZW0gZGlyZWN0bHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGN1cnJlbnRQYWdlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEN1cnJlbnRQYWdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBvbGRWYWx1ZSAmJiB0aGlzLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmNvbmZpZ3NBcHBsaWVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2xlYXIoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgbWUuYWRkKHZhbHVlLCBtZS5hdXRvSW5pdFJlY29yZHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RmlsdGVycyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRGaWx0ZXJzKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5fY3VycmVudFBhZ2UgPSAxOyAvLyBzaWxlbnQgdXBkYXRlXG5cbiAgICAgICAgb2xkVmFsdWUgJiYgbWUucmVtb3RlRmlsdGVyICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vZGVsKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlLnN0b3JlSWQgPSB0aGlzLmlkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHBhZ2VTaXplIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFBhZ2VTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy5sb2FkKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRTb3J0ZXJzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFNvcnRlcnModmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICBvbGRWYWx1ZSAmJiBtZS5yZW1vdGVTb3J0ICYmIG1lLmxvYWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgYmVmb3JlU2V0QXBpKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBjcmVhdGUgOiB2YWx1ZSArICcuY3JlYXRlJyxcbiAgICAgICAgICAgICAgICBkZXN0cm95OiB2YWx1ZSArICcuZGVzdHJveScsXG4gICAgICAgICAgICAgICAgcmVhZCAgIDogdmFsdWUgKyAnLnJlYWQnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZSA6IHZhbHVlICsgJy51cGRhdGUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYmVmb3JlU2V0RGF0YSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHZhbHVlID0gdGhpcy5jcmVhdGVSZWNvcmQodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uZGF0YS5Nb2RlbHxPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5Nb2RlbH1cbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNb2RlbCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBNb2RlbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIHJlY29yZHNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gY29uZmlnXG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXX0gQXJyYXkgaW4gY2FzZSBhbiBhcnJheSB3YXMgcGFzc2VkXG4gICAgICovXG4gICAgY3JlYXRlUmVjb3JkKGNvbmZpZykge1xuICAgICAgICBsZXQgaXNBcnJheSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uZmlnICA9IFtjb25maWddXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtZSAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgICA9IDAsXG4gICAgICAgICAgICAgICAgbGVuID0gY29uZmlnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpdGVtO1xuXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGNvbmZpZ1tpXVxuXG4gICAgICAgICAgICAgICAgaWYgKCFSZWNvcmRGYWN0b3J5LmlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tpXSA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0FycmF5ID8gY29uZmlnIDogY29uZmlnWzBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmaW5kKCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtKHMpIGFyZSBSZWNvcmQgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFt2YWx1ZV0gT25seSByZXF1aXJlZCBpbiBjYXNlIHRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRmlyc3RNYXRjaD1mYWxzZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8T2JqZWN0W118bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaD1mYWxzZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5maW5kKHByb3BlcnR5LCB2YWx1ZSwgcmV0dXJuRmlyc3RNYXRjaCk7XG5cbiAgICAgICAgaWYgKHJldHVybkZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyB0aGlzLmdldChyZXN1bHRbdGhpcy5rZXlQcm9wZXJ0eV0pIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubWFwKGl0ZW0gPT4gdGhpcy5nZXQoaXRlbVt0aGlzLmtleVByb3BlcnR5XSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTpmaW5kQnkoKSB0byBlbnN1cmUgdGhlIHJldHVybmVkIGl0ZW0ocykgYXJlIFJlY29yZCBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJ1biBmb3IgZWFjaCBpdGVtIGluc2lkZSB0aGUgc3RhcnQtZW5kIHJhbmdlLiBSZXR1cm4gdHJ1ZSBmb3IgYSBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGU9dGhpcyBUaGUgc2NvcGUgaW4gd2hpY2ggdGhlIHBhc3NlZCBmdW5jdGlvbiBnZXRzIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0PTAgVGhlIHN0YXJ0IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZD10aGlzLmNvdW50IFRoZSBlbmQgaW5kZXggKHVwIHRvLCBsYXN0IHZhbHVlIGV4Y2x1ZGVkKVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBmaW5kQnkoZm4sIHNjb3BlPXRoaXMsIHN0YXJ0PTAsIGVuZD10aGlzLmNvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmZpbmRCeShmbiwgc2NvcGUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChpdGVtID0+IHRoaXMuZ2V0KGl0ZW1bdGhpcy5rZXlQcm9wZXJ0eV0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmZvckVhY2goKSB0byBlbnN1cmUgdGhlIGl0ZXJhdGVkIGl0ZW0gaXMgYSBSZWNvcmQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggcmVjb3JkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGZuYC5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGZuLCBzY29wZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWUuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChzY29wZSB8fCBtZSwgbWUuZ2V0QXQoaSksIGksIG1lLml0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBjb2xsZWN0aW9uLkJhc2U6Z2V0KCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtIGlzIGEgUmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgaXRlbSA9IHN1cGVyLmdldChrZXkpOyAvLyBHZXQgaXRlbSBmcm9tIENvbGxlY3Rpb24uQmFzZSAoY291bGQgYmUgcmF3IGRhdGEpXG5cbiAgICAgICAgaWYgKGl0ZW0gJiYgIVJlY29yZEZhY3RvcnkuaXNSZWNvcmQoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IFJlY29yZEZhY3RvcnkuY3JlYXRlUmVjb3JkKG1lLm1vZGVsLCBpdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ICA9IG1lLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHJhdyBkYXRhIHdpdGggdGhlIHJlY29yZCBpbnN0YW5jZSBpbiB0aGUgY3VycmVudCAoZmlsdGVyZWQpIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIG1lLm1hcC5zZXQoa2V5LCByZWNvcmQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1lLl9pdGVtc1tpbmRleF0gPSByZWNvcmRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBjb2xsZWN0aW9uIGlzIGZpbHRlcmVkLCB3ZSBtdXN0IGFsc28gdXBkYXRlIHRoZSBtYXN0ZXIgJ2FsbEl0ZW1zJyBjb2xsZWN0aW9uXG4gICAgICAgICAgICBpZiAobWUuYWxsSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXN0ZXJJbmRleCA9IG1lLmFsbEl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc3RlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5hbGxJdGVtcy5tYXAuc2V0KGtleSwgcmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWxsSXRlbXMuX2l0ZW1zW21hc3RlckluZGV4XSA9IHJlY29yZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbSAvLyBBbHJlYWR5IGEgcmVjb3JkIG9yIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgY29sbGVjdGlvbi5CYXNlOmdldEF0KCkgdG8gZW5zdXJlIHRoZSByZXR1cm5lZCBpdGVtIGlzIGEgUmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldEF0KGluZGV4KSB7XG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIGl0ZW0gPSBzdXBlci5nZXRBdChpbmRleCk7IC8vIEdldCBpdGVtIGZyb20gQ29sbGVjdGlvbi5CYXNlIChjb3VsZCBiZSByYXcgZGF0YSlcblxuICAgICAgICBpZiAoaXRlbSAmJiAhUmVjb3JkRmFjdG9yeS5pc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gUmVjb3JkRmFjdG9yeS5jcmVhdGVSZWNvcmQobWUubW9kZWwsIGl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSByYXcgZGF0YSB3aXRoIHRoZSByZWNvcmQgaW5zdGFuY2UgaW4gdGhlIGN1cnJlbnQgKGZpbHRlcmVkKSBjb2xsZWN0aW9uXG4gICAgICAgICAgICBtZS5tYXAuc2V0KHJlY29yZFttZS5rZXlQcm9wZXJ0eV0sIHJlY29yZCk7XG4gICAgICAgICAgICBtZS5faXRlbXNbaW5kZXhdID0gcmVjb3JkO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGNvbGxlY3Rpb24gaXMgZmlsdGVyZWQsIHdlIG11c3QgYWxzbyB1cGRhdGUgdGhlIG1hc3RlciAnYWxsSXRlbXMnIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIGlmIChtZS5hbGxJdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hc3RlckluZGV4ID0gbWUuYWxsSXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAobWFzdGVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFsbEl0ZW1zLm1hcC5zZXQocmVjb3JkW21lLmtleVByb3BlcnR5XSwgcmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuYWxsSXRlbXMuX2l0ZW1zW21hc3RlckluZGV4XSA9IHJlY29yZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbSAvLyBBbHJlYWR5IGEgcmVjb3JkIG9yIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0S2V5UHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleVByb3BlcnR5IHx8IHRoaXMubW9kZWwua2V5UHJvcGVydHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dCB0byBjaGVjayBmb3IgaW50IGJhc2VkIGtleVByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IGxvd2VyY2FzZSB2YWx1ZSBvZiB0aGUgbW9kZWwgZmllbGQgdHlwZVxuICAgICAqL1xuICAgIGdldEtleVR5cGUoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7bW9kZWx9ICA9IG1lLFxuICAgICAgICAgICAga2V5RmllbGQgPSBtb2RlbD8uZ2V0RmllbGQobWUuZ2V0S2V5UHJvcGVydHkoKSk7XG5cbiAgICAgICAgcmV0dXJuIGtleUZpZWxkPy50eXBlPy50b0xvd2VyQ2FzZSgpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRhdGEgb2JqZWN0IGludG8gYSBSZWNvcmQgaW5zdGFuY2Ugb3IgcmV0dXJucyBpdCBpZiBpdCBpcyBhbHJlYWR5IG9uZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgYWRkKCkgYW5kIGluc2VydCgpIHdoZW4gaW5pdD10cnVlIChkZWZhdWx0KS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3Qgb3IgUmVjb3JkIGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIFJlY29yZCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGluaXRSZWNvcmQoZGF0YSkge1xuICAgICAgICBpZiAoUmVjb3JkRmFjdG9yeS5pc1JlY29yZChkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldChkYXRhW3RoaXMuZ2V0S2V5UHJvcGVydHkoKV0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGNvbGxlY3Rpb24uQmFzZTogaW5zZXJ0KCkgdG8gY29udmVydCBpdGVtcyBpbnRvIHJlY29yZHMgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogKipFYWdlciBNb2RlIChgaW5pdD10cnVlYCAtIERlZmF1bHQpOioqXG4gICAgICogSW1tZWRpYXRlbHkgY29udmVydHMgcmF3IGRhdGEgaW50byBgTmVvLmRhdGEuTW9kZWxgIGluc3RhbmNlcy5cbiAgICAgKiBSZXR1cm5zIGFuIGBBcnJheWAgb2YgdGhlIGNyZWF0ZWQgcmVjb3Jkcy5cbiAgICAgKlxuICAgICAqICoqTGF6eSBNb2RlIChgaW5pdD1mYWxzZWApOioqXG4gICAgICogSW5zZXJ0cyByYXcgZGF0YSBkaXJlY3RseS4gSW5zdGFudGlhdGVzIHJlY29yZHMgb25seSBvbiBhY2Nlc3MuXG4gICAgICogUmV0dXJucyBhbiBgQXJyYXlgIG9mIHRoZSBpbnNlcnRlZCByYXcgZGF0YSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgYXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbSBUaGUgaXRlbShzKSB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbml0PXRoaXMuYXV0b0luaXRSZWNvcmRzXSBUcnVlIHRvIHJldHVybiB0aGUgY3JlYXRlZCByZWNvcmRzXG4gICAgICogQHJldHVybnMge09iamVjdFtdfE5lby5kYXRhLk1vZGVsW119IFRoZSBpbnNlcnRlZCByYXcgaXRlbXMgb3IgY3JlYXRlZCByZWNvcmRzXG4gICAgICovXG4gICAgaW5zZXJ0KGluZGV4LCBpdGVtLCBpbml0PXRoaXMuYXV0b0luaXRSZWNvcmRzKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBpdGVtcyA9IHN1cGVyLmluc2VydChpbmRleCwgaXRlbSk7XG5cbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5tYXAoaSA9PiBtZS5nZXQoaVttZS5nZXRLZXlQcm9wZXJ0eSgpXSkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cz17fVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5oZWFkZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdHMubWV0aG9kIERFTEVURSwgR0VULCBQT1NULCBQVVRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5yZXNwb25zZVR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5zY29wZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnVybFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdHxPYmplY3RbXT59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGxvYWQob3B0cz17fSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHtwYWdlOiBtZS5jdXJyZW50UGFnZSwgcGFnZVNpemU6IG1lLnBhZ2VTaXplLCAuLi5vcHRzLnBhcmFtc307XG5cbiAgICAgICAgaWYgKG1lLnJlbW90ZUZpbHRlcikge1xuICAgICAgICAgICAgcGFyYW1zLmZpbHRlcnMgPSBtZS5leHBvcnRGaWx0ZXJzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5yZW1vdGVTb3J0KSB7XG4gICAgICAgICAgICBwYXJhbXMuc29ydGVycyA9IG1lLmV4cG9ydFNvcnRlcnMoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lLmFwaSkge1xuICAgICAgICAgICAgbGV0IGFwaUFycmF5ID0gbWUuYXBpLnJlYWQuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBmbiAgICAgICA9IGFwaUFycmF5LnBvcCgpLFxuICAgICAgICAgICAgICAgIHNlcnZpY2UgID0gTmVvLm5zKGFwaUFycmF5LmpvaW4oJy4nKSk7XG5cbiAgICAgICAgICAgIGlmICghc2VydmljZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FwaSBpcyBub3QgZGVmaW5lZCcsIHRoaXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VydmljZVtmbl0ocGFyYW1zKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnRvdGFsQ291bnQgPSByZXNwb25zZS50b3RhbENvdW50O1xuICAgICAgICAgICAgICAgICAgICBtZS5kYXRhICAgICAgID0gTmVvLm5zKG1lLnJlc3BvbnNlUm9vdCwgZmFsc2UsIHJlc3BvbnNlKTsgLy8gZmlyZXMgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgbWUuaXNMb2FkZWQgICA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lLmRhdGFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cy51cmwgPz89IG1lLnVybDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBub24tYnJvd3NlciBiYXNlZCBlbnZzIGxpa2Ugbm9kZWpzXG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbFRoaXMucHJvY2Vzcz8ucmVsZWFzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlYWRGaWxlIH0gPSBhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyAnZnMvcHJvbWlzZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlKG9wdHMudXJsLCAndXRmLTgnKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtqc29uOiBKU09OLnBhcnNlKGNvbnRlbnQpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgTmVvLlhoci5wcm9taXNlSnNvbihvcHRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5kYXRhID0gTmVvLm5zKG1lLnJlc3BvbnNlUm9vdCwgZmFsc2UsIGRhdGEuanNvbikgfHwgZGF0YS5qc29uIC8vIGZpcmVzIHRoZSBsb2FkIGV2ZW50XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuaXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE/Lmpzb24gfHwgbnVsbFxuICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmb3IgTmVvLlhoci5yZXF1ZXN0Jywge2lkOiBtZS5pZCwgZXJyb3I6IGVyciwgdXJsOiBvcHRzLnVybH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIG9uQ29sbGVjdGlvbk11dGF0ZShvcHRzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzQ29uc3RydWN0ZWQgJiYgIW1lLmlzTG9hZGluZykge1xuICAgICAgICAgICAgbWUuZmlyZSgnbG9hZCcsIHtpdGVtczogbWUuaXRlbXMsIHRvdGFsOiBtZS5jaHVua2luZ1RvdGFsfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29sbGVjdGlvblNvcnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIG1lLmZpcmUoJ2xvYWQnLCB7aXRlbXM6IG1lLml0ZW1zfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmRhdGEpIHtcbiAgICAgICAgICAgIG1lLmFmdGVyU2V0RGF0YShtZS5kYXRhKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmVpbmcgY29uc3RydWN0ZWQgZG9lcyBub3QgbWVhbiB0aGF0IHJlbGF0ZWQgYWZ0ZXJTZXRTdG9yZSgpIG1ldGhvZHMgZ290IGV4ZWN1dGVkXG4gICAgICAgIC8vID0+IGJyZWFrIHRoZSBzeW5jIGZsb3cgdG8gZW5zdXJlIHBvdGVudGlhbCBsaXN0ZW5lcnMgZ290IGFwcGxpZWRcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAobWUuaXNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICBtZS5maXJlKCdsb2FkJywge2l0ZW1zOiBtZS5pdGVtc30pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lLmF1dG9Mb2FkKSB7XG4gICAgICAgICAgICAgICAgbWUubG9hZCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25GaWx0ZXJDaGFuZ2Uob3B0cykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5yZW1vdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIG1lLl9jdXJyZW50UGFnZSA9IDE7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgICAgIG1lLmxvYWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIub25GaWx0ZXJDaGFuZ2Uob3B0cylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGFmdGVyIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBhIHJlY29yZCBmaWVsZC5cbiAgICAgKiBFLmcuIG15UmVjb3JkLmZvbyA9ICdiYXInO1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5maWVsZHMgRWFjaCBmaWVsZCBvYmplY3QgY29udGFpbnMgdGhlIGtleXM6IG5hbWUsIG9sZFZhbHVlLCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuTW9kZWx9IGRhdGEubW9kZWwgVGhlIG1vZGVsIGluc3RhbmNlIG9mIHRoZSBjaGFuZ2VkIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnJlY29yZFxuICAgICAqL1xuICAgIG9uUmVjb3JkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdyZWNvcmRDaGFuZ2UnLCB7XG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXhPZihkYXRhLnJlY29yZClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cz17fVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnByb3BlcnR5XG4gICAgICovXG4gICAgc29ydChvcHRzPXt9KSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuX2N1cnJlbnRQYWdlID0gMTsgLy8gc2lsZW50IHVwZGF0ZVxuXG4gICAgICAgIGlmIChtZS5jb25maWdzQXBwbGllZCkge1xuICAgICAgICAgICAgaWYgKG9wdHMuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWUuc29ydGVycyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogb3B0cy5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5IDogb3B0cy5wcm9wZXJ0eVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbWUucmVtb3RlU29ydCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zb3J0ZXJzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ0FTQycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA6IGluaXRpYWxJbmRleFN5bWJvbFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoU3RvcmUpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==