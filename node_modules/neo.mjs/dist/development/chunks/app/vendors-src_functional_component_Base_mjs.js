export const __webpack_esm_id__ = "vendors-src_functional_component_Base_mjs";
export const __webpack_esm_ids__ = ["vendors-src_functional_component_Base_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/core/Effect.mjs"
/*!*****************************!*\
  !*** ./src/core/Effect.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");




/**
 * Creates a reactive effect that automatically tracks its dependencies and re-runs when any of them change.
 * This is a lightweight, plain JavaScript class for performance.
 * It serves as a core reactive primitive, enabling automatic and dynamic dependency tracking.
 * @class Neo.core.Effect
 */
class Effect {
    /**
     * The optional component id this effect belongs to.
     * @member {String|null} componentId=null
     */
    componentId = null
    /**
     * A Map containing Config instances as keys and their cleanup functions as values.
     * @member {Map} dependencies=new Map()
     * @protected
     */
    dependencies = new Map()
    /**
     * The function to execute.
     * @member {Function|null} _fn=null
     */
    _fn = null
    /**
     * The unique identifier for this effect instance.
     * @member {String|null}
     */
    id = _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getId('effect')
    /**
     * @member {Boolean}
     * @protected
     */
    isDestroyed = false
    /**
     * @member {Neo.core.Config}
     * @protected
     */
    isRunning = null

    /**
     * @member fn
     */
    get fn() {
        return this._fn
    }
    set fn(value) {
        this._fn = value;
        // Assigning a new function to `fn` automatically triggers a re-run.
        // This ensures that the effect immediately re-evaluates its dependencies
        // based on the new function's logic, clearing old dependencies and establishing new ones.
        this.run()
    }

    /**
     * @param {Function|Object}  fn              - The function to execute, or a config object for the effect.
     * @param {Function}        [fn.fn]          - The function to execute for the effect (if the first argument is an object).
     * @param {String}          [fn.componentId] - The component id this effect belongs to.
     * @param {Boolean}         [fn.lazy=false]  - If true, the effect will not run immediately upon creation.
     * @param {Object|Object[]} [fn.subscriber]  - A single subscriber or an array of subscribers for the isRunning config.
     * @param {Object}          [options={}]     - Optional. Used if the first argument is a function, this object contains the options.
     * @example
     * // Signature 1: Function and Options
     * const myEffect = new Effect(() => console.log('Run'), {lazy: true});
     * @example
     * // Signature 2: Single Config Object
     * const myEffect = new Effect({fn: () => console.log('Run'), lazy: true});
     */
    constructor(fn, options={}) {
        const me = this;

        const {
              fn: effectFn,
              componentId,
              lazy = false,
              subscriber
        } = (typeof fn === 'function') ? { ...options, fn } : (fn || {});

        if (componentId) {
            me.componentId = componentId
        }

        me.isRunning = new _Config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](false);

        if (subscriber) {
            [].concat(subscriber).forEach(sub => me.isRunning.subscribe(sub))
        }

        if (lazy) {
            me._fn = effectFn
        } else {
            me.fn = effectFn
        }
    }

    /**
     * Cleans up all subscriptions and destroys the effect.
     */
    destroy() {
        const me = this;

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        me.isDestroyed = true
    }

    /**
     * Executes the effect function, re-evaluating its dependencies.
     * If the EffectManager is paused (e.g., inside a batch), it queues itself to be run later.
     * @protected
     */
    run() {
        const me = this;

        if (me.isDestroyed) {
            return
        }

        // Check if already running without creating a dependency on `isRunning`.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        const isRunning = me.isRunning.get();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        if (isRunning) {
            return
        }

        // If the manager is globally paused for batching, queue this effect and stop.
        if (_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isPaused()) {
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].queue(me);
            return
        }

        // Set `isRunning` to true without creating a dependency.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        me.isRunning.set(true);
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        // Clear old dependencies and set this as the active effect.
        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].push(me);

        try {
            // Execute the function, which will collect new dependencies.
            me.fn()
        } finally {
            // Clean up after the run.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pop();

            // Set `isRunning` to false without creating a dependency.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
            me.isRunning.set(false);
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking()
        }
    }

    /**
     * Adds a `Neo.core.Config` instance as a dependency for this effect.
     * @param {Neo.core.Config} config The config instance to subscribe to.
     * @protected
     */
    addDependency(config) {
        const me = this;

        if (!me.dependencies.has(config)) {
            const cleanup = config.subscribe({
                id: me.id,
                fn: me.run.bind(me)
            });

            me.dependencies.set(config, cleanup)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Effect, 'Neo.core.Effect', () => {
    /**
     * Factory shortcut to create a new Neo.core.Effect instance.
     * @function Neo.effect
     * @param {Function|Object} fn - The function to execute, or a config object for the effect.
     * @param {Object} [options] - Optional. Used if the first argument is a function.
     * @returns {Neo.core.Effect}
     */
    Neo.effect = (fn, options) => new Effect(fn, options)
}));


/***/ },

/***/ "./src/functional/component/Base.mjs"
/*!*******************************************!*\
  !*** ./src/functional/component/Base.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Abstract.mjs */ "./src/component/Abstract.mjs");
/* harmony import */ var _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/Effect.mjs */ "./src/core/Effect.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_html_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/html.mjs */ "./src/functional/util/html.mjs");






const
    activeDomListenersSymbol = Symbol.for('activeDomListeners'),
    hookIndexSymbol          = Symbol.for('hookIndex'),
    hooksSymbol              = Symbol.for('hooks'),
    pendingDomEventsSymbol   = Symbol.for('pendingDomEvents'),
    vdomToApplySymbol        = Symbol('vdomToApply');

/**
 * @class Neo.functional.component.Base
 * @extends Neo.component.Abstract
 */
class FunctionalBase extends _component_Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.functional.component.Base'
         * @protected
         */
        className: 'Neo.functional.component.Base',
        /**
         * @member {Boolean} enableHtmlTemplates_=false
         * @reactive
         * Set this to true to enable using tagged template literals for VDOM creation
         * via the render() method. This will lazy load the html parser.
         */
        enableHtmlTemplates_: false,
        /**
         * @member {String} ntype='functional-component'
         * @protected
         */
        ntype: 'functional-component',
        /**
         * The vdom markup for this component.
         * @member {Object} vdom={}
         */
        vdom: {}
    }

    /**
     * Neo component instances, which got defined inside createVdom()
     * @member {Map|null} childComponents=null
     */
    childComponents = null
    /**
     * @member {Neo.functional.util.HtmlTemplateProcessor|null} htmlTemplateProcessor=null
     * @private
     */
    htmlTemplateProcessor = Neo.ns('Neo.functional.util.HtmlTemplateProcessor')
    /**
     * Internal Map to store the next set of components after the createVdom() Effect has run.
     * @member {Map|null} nextChildComponents=null
     * @private
     */
    #nextChildComponents = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me   = this,
            opts = {configurable: true, enumerable: false, writable: true};

        // The build process will replace `render()` with `createVdom()`.
        if (Neo.config.environment !== 'development') {
            me.enableHtmlTemplates = false
        }

        Object.defineProperties(me, {
            [activeDomListenersSymbol]: {...opts, value: []},
            [hookIndexSymbol]         : {...opts, value: 0},
            [hooksSymbol]             : {...opts, value: []},
            [pendingDomEventsSymbol]  : {...opts, value: []},
            [vdomToApplySymbol]       : {...opts, value: null}
        });

        // Creates a reactive effect that re-executes createVdom() when dependencies change.
        me.vdomEffect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]({
            fn: () => {
                me[hookIndexSymbol]        = 0;
                me[pendingDomEventsSymbol] = []; // Clear pending events for new render
                me[vdomToApplySymbol]      = me.createVdom(me)
            },
            componentId: me.id,
            subscriber : {
                id   : me.id,
                fn   : me.onEffectRunStateChange,
                scope: me
            }
        })
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        super.afterSetIsReady(value, oldValue);

        const me = this;

        if (value && me.missedReadyState) {
            me.vdomEffect.run();
            delete me.missedReadyState
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && oldValue !== undefined) {
            // Initial registration of DOM event listeners when component mounts
            this.applyPendingDomListeners()
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        this.childComponents?.forEach(childData => {
            childData.instance.windowId = value
        })
    }

    /**
     * Applies the pending DOM event listeners and updates the active list.
     * @private
     */
    applyPendingDomListeners() {
        const
            me            = this,
            activeEvents  = me[activeDomListenersSymbol],
            pendingEvents = me[pendingDomEventsSymbol];

        if (pendingEvents.length > 0) {
            if (!Neo.isEqual(activeEvents, pendingEvents)) {
                if (activeEvents?.length > 0) {
                    // Remove old dynamic listeners
                    me.removeDomListeners(me[activeDomListenersSymbol])
                }

                me.addDomListeners([...pendingEvents]);

                me[activeDomListenersSymbol] = [...pendingEvents]
            }

            // Clear pending events for next `createVdom()` Effect run
            me[pendingDomEventsSymbol] = []
        }
    }

    /**
     * A lifecycle hook that runs after a state change has been detected but before the
     * VDOM update is dispatched. It provides a dedicated place for logic that needs to
     * execute before rendering, such as calculating derived data or caching values.
     *
     * You can prevent the VDOM update by returning `false` from this method. This is
     * useful for advanced cases where you might want to manually trigger a different
     * update after modifying other component configs.
     *
     * **IMPORTANT**: Do not change the value of any config that is used as a dependency
     * within the `createVdom` method from inside this hook, as it will cause an
     * infinite update loop. This hook is for one-way data flow, not for triggering
     * cascading reactive changes.
     *
     * @returns {Boolean|undefined} Return `false` to cancel the upcoming VDOM update.
     * @example
     * beforeUpdate() {
     *     // Perform an expensive calculation and cache the result on the instance
     *     this.processedData = this.processRawData(this.rawData);
     *
     *     // Example of conditionally cancelling an update
     *     if (this.processedData.length === 0 && this.vdom.cn?.length === 0) {
     *         return false; // Don't re-render if there's nothing to show
     *     }
     * }
     */
    beforeUpdate() {
        // This method can be overridden by subclasses
    }

    /**
     * This method is called by the HtmlTemplateProcessor after the async parsing is complete.
     * It then continues the component update lifecycle.
     * @param {Object} parsedVdom The VDOM object received from the parser addon.
     * @protected
     */
    continueUpdateWithVdom(parsedVdom) {
        const me = this;

        // Create a new map for components instantiated in this render cycle
        me.#nextChildComponents = new Map();

        // Process the newVdom to instantiate components
        // The parentId for these components will be the functional component's id
        const processedVdom = me.processVdomForComponents(parsedVdom, me.id);

        // Destroy components that are no longer present in the new VDOM
        if (me.childComponents?.size > 0) {
            [...me.childComponents].forEach(([key, childData]) => {
                if (!me.#nextChildComponents.has(key)) {
                    me.childComponents.delete(key);
                    childData.instance.destroy()
                }
            })
        }

        // If this component created other classic or functional components,
        // include their full vdom into the next update cycle.
        const oldKeys = me.childComponents ? new Set(me.childComponents.keys()) : new Set();
        let hasNewChildren = false;

        for (const newKey of me.#nextChildComponents.keys()) {
            if (!oldKeys.has(newKey)) {
                hasNewChildren = true;
                break
            }
        }

        if (hasNewChildren) {
            // When new child components are created, we need to send their full VDOM
            // to the vdom-worker, so they can get rendered.
            // Subsequent updates will be granular via diffAndSet() => set() on the child.
            me.updateDepth = -1;
        }

        // Update the main map of instantiated components
        me.childComponents = me.#nextChildComponents;

        // Clear the old vdom properties
        for (const key in me.vdom) {
            delete me.vdom[key]
        }

        // Assign the new properties
        Object.assign(me.vdom, processedVdom); // Use processedVdom here

        me[vdomToApplySymbol] = null;

        const root = me.getVdomRoot();

        if (me.cls) {
            root.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].union(me.cls, root.cls)
        }

        if (me.id) {
            root.id = me.id
        }

        // Re-hydrate the new vdom with stable IDs from the previous vnode tree.
        // This is crucial for functional components where the vdom is recreated on every render,
        // ensuring the diffing algorithm can track nodes correctly.
        me.syncVdomState();

        if (me.beforeUpdate() !== false) {
            me.updateVdom()
        }

        // Update DOM event listeners based on the new render
        if (me.mounted) {
            me.applyPendingDomListeners()
        }
    }

    /**
     * Override this method in your functional component to return its VDOM structure.
     * This method will be automatically re-executed when any of the component's configs change.
     * To access data from a state provider, use `config.data`.
     * @param {Neo.functional.component.Base} config - Mental model: while it contains the instance, it makes it clear to access configs
     * @returns {Object} The VDOM structure for the component.
     */
    createVdom(config) {
        const me = this;

        if (me.enableHtmlTemplates && typeof me.render === 'function') {
            return me.render(config)
        }

        return {}
    }

    /**
     * Destroys the functional component
     * @param {Boolean} [updateParentVdom=false] true to remove the component from the parent vdom => real dom
     * @param {Boolean} [silent=false] true to update the vdom silently (useful for destroying multiple child items in a row)
     */
    destroy(updateParentVdom=false, silent=false) {
        const me = this;

        me.vdomEffect?.destroy();

        // Destroy all classic components instantiated by this functional component
        me.childComponents?.forEach(childData => {
            childData.instance.destroy(false, true) // Pass silent=true
        });
        me.childComponents?.clear();

        // Remove any pending DOM event listeners that might not have been mounted
        me[pendingDomEventsSymbol] = null;

        super.destroy(updateParentVdom, silent)
    }

    /**
     * This method recursively compares the new VDOM config with the last applied config
     * for a given component instance and its sub-instances.
     * @param {Neo.core.Base} instance The component instance to update.
     * @param {Object} newConfig The new configuration object from the VDOM.
     * @param {Object} lastConfig The last applied configuration object.
     * @private
     */
    diffAndSet(instance, newConfig, lastConfig) {
        const deltaConfig = {};

        for (const key in newConfig) {
            const newValue = newConfig[key],
                  oldValue = lastConfig[key];

            if (!Neo.isEqual(newValue, oldValue)) {
                // If the config property is an object and it maps to a sub-component instance, recurse.
                if (Neo.typeOf(newValue) === 'Object' && Neo.typeOf(instance[key]) === 'NeoInstance') {
                    this.diffAndSet(instance[key], newValue, oldValue || {})
                } else {
                    // Otherwise, add it to the delta to be set on the current instance.
                    deltaConfig[key] = newValue
                }
            }
        }

        // Only call set() if there are actual changes for the current instance.
        if (Object.keys(deltaConfig).length > 0) {
            instance.set(deltaConfig)
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        if (this.enableHtmlTemplates && Neo.config.environment === 'development') {
            if (!Neo.ns('Neo.functional.util.HtmlTemplateProcessor')) {
                const module = await __webpack_require__.e(/*! import() */ "vendors-src_functional_util_HtmlTemplateProcessor_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../util/HtmlTemplateProcessor.mjs */ "./src/functional/util/HtmlTemplateProcessor.mjs"));
                this.htmlTemplateProcessor = module.default
            }
        }
    }

    /**
     * This handler runs when the effect's `isRunning` state changes.
     * It runs outside the effect's tracking scope, preventing feedback loops.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    onEffectRunStateChange(value, oldValue) {
        // When the effect has just finished running...
        if (value === false) {
            const me      = this,
                  newVdom = me[vdomToApplySymbol];

            if (newVdom) {
                // If the result is an HtmlTemplate, hand it off to the processor
                if (newVdom[_util_html_mjs__WEBPACK_IMPORTED_MODULE_4__.isHtmlTemplate]) {
                    if (me.htmlTemplateProcessor) {
                        me.htmlTemplateProcessor.process(newVdom, me)
                    } else {
                        me.missedReadyState = true;
                        // By calling this with an empty object, we ensure that the parent container
                        // renders a placeholder DOM node for this component, which we can then
                        // populate later once the template processor is ready.
                        me.continueUpdateWithVdom({})
                    }
                    return // Stop execution, the processor will call back
                }

                // Continue with the standard JSON-based VDOM update
                me.continueUpdateWithVdom(newVdom)
            }
        }
    }

    /**
     * Recursively processes a VDOM node to instantiate components defined within it.
     * @param {Object} vdomTree The VDOM node to process.
     * @param {String} parentId The ID of the parent component (the functional component hosting it).
     * @param {Number} [parentIndex] The index of the vdomNode within its parent's children.
     * @returns {Object} The processed VDOM node, potentially replaced with a component reference.
     * @private
     */
    processVdomForComponents(vdomTree, parentId, parentIndex) {
        if (!vdomTree) {
            return vdomTree
        }

        // If it's already a component reference, no need to process further
        if (vdomTree.componentId) {
            return vdomTree
        }

        const me = this;

        // Check if it's a component definition (functional or classic)
        if (vdomTree.className || vdomTree.module || vdomTree.ntype) {
            // Components are reconciled based on their `id` property in the VDOM definition.
            // If no `id` is provided, a new instance will be created on every render.
            const componentKey = vdomTree.id;

            if (!componentKey) {
                console.error([
                        'Component definition in functional component VDOM is missing an "id". For stable reconciliation, ',
                        'especially in dynamic lists, provide a unique "id" property.'
                    ].join(''),
                    vdomTree
                )
            }

            let childData = me.childComponents?.get(componentKey),
                newConfig = {...vdomTree}, // Shallow copy
                instance;

            delete newConfig.className;
            delete newConfig.id;
            delete newConfig.module;
            delete newConfig.ntype;

            if (!childData) {
                me.childComponents ??= new Map();

                // Instantiate the component
                instance = Neo[(vdomTree.className || vdomTree.module) ? 'create' : 'ntype']({
                    ...vdomTree,
                    parentId,
                    parentIndex,
                    windowId: me.windowId
                });
            } else {
                instance = childData.instance;

                // Recursively diff and set configs
                this.diffAndSet(instance, newConfig, childData.lastConfig);
            }

            // Add to the new map for tracking in this render cycle
            me.#nextChildComponents.set(componentKey, {
                instance,
                lastConfig: newConfig
            });

            // Replace the definition with a reference using the component's own method
            return instance.createVdomReference();
        }

        // Recursively process children
        if (vdomTree.cn && Array.isArray(vdomTree.cn)) {
            vdomTree.cn = vdomTree.cn.map((child, index) =>
                me.processVdomForComponents(child, parentId, index)
            )
        }

        return vdomTree
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(FunctionalBase));


/***/ },

/***/ "./src/functional/util/html.mjs"
/*!**************************************!*\
  !*** ./src/functional/util/html.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HtmlTemplate: () => (/* binding */ HtmlTemplate),
/* harmony export */   html: () => (/* binding */ html),
/* harmony export */   isHtmlTemplate: () => (/* binding */ isHtmlTemplate)
/* harmony export */ });
const isHtmlTemplate = Symbol.for('neo.isHtmlTemplate');

/**
 * A container for the result of an `html` tagged template literal.
 * It holds the static strings and the dynamic values of the template.
 * @class Neo.functional.util.HtmlTemplate
 */
class HtmlTemplate {
    /**
     * @param {Array<String>} strings The static parts of the template
     * @param {Array<*>} values The dynamic values of the template
     */
    constructor(strings, values) {
        this.strings = strings;
        this.values  = values;
        this[isHtmlTemplate] = true;
    }
}

/**
 * A tagged template literal function that creates an `HtmlTemplate` instance.
 * This function does not perform any parsing or string concatenation itself.
 * It simply captures the template's parts for later processing.
 * @param {Array<String>} strings
 * @param {Array<*>} values
 * @returns {Neo.functional.util.HtmlTemplate} An instance of HtmlTemplate
 */
const html = (strings, ...values) => {
    return new HtmlTemplate(strings, values);
};




/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mdW5jdGlvbmFsX2NvbXBvbmVudF9CYXNlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNPO0FBQ0Y7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsU0FBUyx3REFBVztBQUNwQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQixXQUFXO0FBQzNDO0FBQ0E7QUFDQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUF5QztBQUM3RTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUMsaUJBQWlCLFdBQVc7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbURBQU07O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQWM7QUFDMUM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDhCQUE4QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BlOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQixhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvRWZmZWN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Z1bmN0aW9uYWwvY29tcG9uZW50L0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZnVuY3Rpb25hbC91dGlsL2h0bWwubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb25maWcgICAgICAgIGZyb20gJy4vQ29uZmlnLm1qcyc7XG5pbXBvcnQgRWZmZWN0TWFuYWdlciBmcm9tICcuL0VmZmVjdE1hbmFnZXIubWpzJztcbmltcG9ydCBJZEdlbmVyYXRvciAgIGZyb20gJy4vSWRHZW5lcmF0b3IubWpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgYXV0b21hdGljYWxseSB0cmFja3MgaXRzIGRlcGVuZGVuY2llcyBhbmQgcmUtcnVucyB3aGVuIGFueSBvZiB0aGVtIGNoYW5nZS5cbiAqIFRoaXMgaXMgYSBsaWdodHdlaWdodCwgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcyBmb3IgcGVyZm9ybWFuY2UuXG4gKiBJdCBzZXJ2ZXMgYXMgYSBjb3JlIHJlYWN0aXZlIHByaW1pdGl2ZSwgZW5hYmxpbmcgYXV0b21hdGljIGFuZCBkeW5hbWljIGRlcGVuZGVuY3kgdHJhY2tpbmcuXG4gKiBAY2xhc3MgTmVvLmNvcmUuRWZmZWN0XG4gKi9cbmNsYXNzIEVmZmVjdCB7XG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGNvbXBvbmVudCBpZCB0aGlzIGVmZmVjdCBiZWxvbmdzIHRvLlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb21wb25lbnRJZD1udWxsXG4gICAgICovXG4gICAgY29tcG9uZW50SWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQSBNYXAgY29udGFpbmluZyBDb25maWcgaW5zdGFuY2VzIGFzIGtleXMgYW5kIHRoZWlyIGNsZWFudXAgZnVuY3Rpb25zIGFzIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyIHtNYXB9IGRlcGVuZGVuY2llcz1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb258bnVsbH0gX2ZuPW51bGxcbiAgICAgKi9cbiAgICBfZm4gPSBudWxsXG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGVmZmVjdCBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBpZCA9IElkR2VuZXJhdG9yLmdldElkKCdlZmZlY3QnKVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzRGVzdHJveWVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5Db25maWd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzUnVubmluZyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgZm5cbiAgICAgKi9cbiAgICBnZXQgZm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mblxuICAgIH1cbiAgICBzZXQgZm4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZm4gPSB2YWx1ZTtcbiAgICAgICAgLy8gQXNzaWduaW5nIGEgbmV3IGZ1bmN0aW9uIHRvIGBmbmAgYXV0b21hdGljYWxseSB0cmlnZ2VycyBhIHJlLXJ1bi5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGVmZmVjdCBpbW1lZGlhdGVseSByZS1ldmFsdWF0ZXMgaXRzIGRlcGVuZGVuY2llc1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgbmV3IGZ1bmN0aW9uJ3MgbG9naWMsIGNsZWFyaW5nIG9sZCBkZXBlbmRlbmNpZXMgYW5kIGVzdGFibGlzaGluZyBuZXcgb25lcy5cbiAgICAgICAgdGhpcy5ydW4oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSAgZm4gICAgICAgICAgICAgIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIG9yIGEgY29uZmlnIG9iamVjdCBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgW2ZuLmZuXSAgICAgICAgICAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciB0aGUgZWZmZWN0IChpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0KS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgW2ZuLmNvbXBvbmVudElkXSAtIFRoZSBjb21wb25lbnQgaWQgdGhpcyBlZmZlY3QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW2ZuLmxhenk9ZmFsc2VdICAtIElmIHRydWUsIHRoZSBlZmZlY3Qgd2lsbCBub3QgcnVuIGltbWVkaWF0ZWx5IHVwb24gY3JlYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IFtmbi5zdWJzY3JpYmVyXSAgLSBBIHNpbmdsZSBzdWJzY3JpYmVyIG9yIGFuIGFycmF5IG9mIHN1YnNjcmliZXJzIGZvciB0aGUgaXNSdW5uaW5nIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnM9e31dICAgICAtIE9wdGlvbmFsLiBVc2VkIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCB0aGlzIG9iamVjdCBjb250YWlucyB0aGUgb3B0aW9ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNpZ25hdHVyZSAxOiBGdW5jdGlvbiBhbmQgT3B0aW9uc1xuICAgICAqIGNvbnN0IG15RWZmZWN0ID0gbmV3IEVmZmVjdCgoKSA9PiBjb25zb2xlLmxvZygnUnVuJyksIHtsYXp5OiB0cnVlfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaWduYXR1cmUgMjogU2luZ2xlIENvbmZpZyBPYmplY3RcbiAgICAgKiBjb25zdCBteUVmZmVjdCA9IG5ldyBFZmZlY3Qoe2ZuOiAoKSA9PiBjb25zb2xlLmxvZygnUnVuJyksIGxhenk6IHRydWV9KTtcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihmbiwgb3B0aW9ucz17fSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBmbjogZWZmZWN0Rm4sXG4gICAgICAgICAgICAgIGNvbXBvbmVudElkLFxuICAgICAgICAgICAgICBsYXp5ID0gZmFsc2UsXG4gICAgICAgICAgICAgIHN1YnNjcmliZXJcbiAgICAgICAgfSA9ICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpID8geyAuLi5vcHRpb25zLCBmbiB9IDogKGZuIHx8IHt9KTtcblxuICAgICAgICBpZiAoY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIG1lLmNvbXBvbmVudElkID0gY29tcG9uZW50SWRcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzUnVubmluZyA9IG5ldyBDb25maWcoZmFsc2UpO1xuXG4gICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBbXS5jb25jYXQoc3Vic2NyaWJlcikuZm9yRWFjaChzdWIgPT4gbWUuaXNSdW5uaW5nLnN1YnNjcmliZShzdWIpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhenkpIHtcbiAgICAgICAgICAgIG1lLl9mbiA9IGVmZmVjdEZuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5mbiA9IGVmZmVjdEZuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGRlc3Ryb3lzIHRoZSBlZmZlY3QuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIG1lLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBlZmZlY3QgZnVuY3Rpb24sIHJlLWV2YWx1YXRpbmcgaXRzIGRlcGVuZGVuY2llcy5cbiAgICAgKiBJZiB0aGUgRWZmZWN0TWFuYWdlciBpcyBwYXVzZWQgKGUuZy4sIGluc2lkZSBhIGJhdGNoKSwgaXQgcXVldWVzIGl0c2VsZiB0byBiZSBydW4gbGF0ZXIuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHJ1bm5pbmcgd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kgb24gYGlzUnVubmluZ2AuXG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2VUcmFja2luZygpO1xuICAgICAgICBjb25zdCBpc1J1bm5pbmcgPSBtZS5pc1J1bm5pbmcuZ2V0KCk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lVHJhY2tpbmcoKTtcblxuICAgICAgICBpZiAoaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBtYW5hZ2VyIGlzIGdsb2JhbGx5IHBhdXNlZCBmb3IgYmF0Y2hpbmcsIHF1ZXVlIHRoaXMgZWZmZWN0IGFuZCBzdG9wLlxuICAgICAgICBpZiAoRWZmZWN0TWFuYWdlci5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnF1ZXVlKG1lKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGBpc1J1bm5pbmdgIHRvIHRydWUgd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kuXG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2VUcmFja2luZygpO1xuICAgICAgICBtZS5pc1J1bm5pbmcuc2V0KHRydWUpO1xuICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZVRyYWNraW5nKCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgb2xkIGRlcGVuZGVuY2llcyBhbmQgc2V0IHRoaXMgYXMgdGhlIGFjdGl2ZSBlZmZlY3QuXG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucHVzaChtZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGNvbGxlY3QgbmV3IGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgIG1lLmZuKClcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFmdGVyIHRoZSBydW4uXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnBvcCgpO1xuXG4gICAgICAgICAgICAvLyBTZXQgYGlzUnVubmluZ2AgdG8gZmFsc2Ugd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kuXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICAgIG1lLmlzUnVubmluZy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWVUcmFja2luZygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYE5lby5jb3JlLkNvbmZpZ2AgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGlzIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkNvbmZpZ30gY29uZmlnIFRoZSBjb25maWcgaW5zdGFuY2UgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZGREZXBlbmRlbmN5KGNvbmZpZykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5kZXBlbmRlbmNpZXMuaGFzKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBjb25maWcuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBpZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgZm46IG1lLnJ1bi5iaW5kKG1lKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmRlcGVuZGVuY2llcy5zZXQoY29uZmlnLCBjbGVhbnVwKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uZ2F0ZWtlZXAoRWZmZWN0LCAnTmVvLmNvcmUuRWZmZWN0JywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEZhY3Rvcnkgc2hvcnRjdXQgdG8gY3JlYXRlIGEgbmV3IE5lby5jb3JlLkVmZmVjdCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gTmVvLmVmZmVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBmbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLCBvciBhIGNvbmZpZyBvYmplY3QgZm9yIHRoZSBlZmZlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsLiBVc2VkIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5FZmZlY3R9XG4gICAgICovXG4gICAgTmVvLmVmZmVjdCA9IChmbiwgb3B0aW9ucykgPT4gbmV3IEVmZmVjdChmbiwgb3B0aW9ucylcbn0pO1xuIiwiaW1wb3J0IEFic3RyYWN0ICAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Fic3RyYWN0Lm1qcyc7XG5pbXBvcnQgRWZmZWN0ICAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0VmZmVjdC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IFZEb21VdGlsICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5pbXBvcnQge2lzSHRtbFRlbXBsYXRlfSBmcm9tICcuLi91dGlsL2h0bWwubWpzJztcblxuY29uc3RcbiAgICBhY3RpdmVEb21MaXN0ZW5lcnNTeW1ib2wgPSBTeW1ib2wuZm9yKCdhY3RpdmVEb21MaXN0ZW5lcnMnKSxcbiAgICBob29rSW5kZXhTeW1ib2wgICAgICAgICAgPSBTeW1ib2wuZm9yKCdob29rSW5kZXgnKSxcbiAgICBob29rc1N5bWJvbCAgICAgICAgICAgICAgPSBTeW1ib2wuZm9yKCdob29rcycpLFxuICAgIHBlbmRpbmdEb21FdmVudHNTeW1ib2wgICA9IFN5bWJvbC5mb3IoJ3BlbmRpbmdEb21FdmVudHMnKSxcbiAgICB2ZG9tVG9BcHBseVN5bWJvbCAgICAgICAgPSBTeW1ib2woJ3Zkb21Ub0FwcGx5Jyk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5mdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkFic3RyYWN0XG4gKi9cbmNsYXNzIEZ1bmN0aW9uYWxCYXNlIGV4dGVuZHMgQWJzdHJhY3Qge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGVuYWJsZUh0bWxUZW1wbGF0ZXNfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKiBTZXQgdGhpcyB0byB0cnVlIHRvIGVuYWJsZSB1c2luZyB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMgZm9yIFZET00gY3JlYXRpb25cbiAgICAgICAgICogdmlhIHRoZSByZW5kZXIoKSBtZXRob2QuIFRoaXMgd2lsbCBsYXp5IGxvYWQgdGhlIGh0bWwgcGFyc2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlSHRtbFRlbXBsYXRlc186IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nZnVuY3Rpb25hbC1jb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZnVuY3Rpb25hbC1jb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZkb20gbWFya3VwIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSB2ZG9tPXt9XG4gICAgICAgICAqL1xuICAgICAgICB2ZG9tOiB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lbyBjb21wb25lbnQgaW5zdGFuY2VzLCB3aGljaCBnb3QgZGVmaW5lZCBpbnNpZGUgY3JlYXRlVmRvbSgpXG4gICAgICogQG1lbWJlciB7TWFwfG51bGx9IGNoaWxkQ29tcG9uZW50cz1udWxsXG4gICAgICovXG4gICAgY2hpbGRDb21wb25lbnRzID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5mdW5jdGlvbmFsLnV0aWwuSHRtbFRlbXBsYXRlUHJvY2Vzc29yfG51bGx9IGh0bWxUZW1wbGF0ZVByb2Nlc3Nvcj1udWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBodG1sVGVtcGxhdGVQcm9jZXNzb3IgPSBOZW8ubnMoJ05lby5mdW5jdGlvbmFsLnV0aWwuSHRtbFRlbXBsYXRlUHJvY2Vzc29yJylcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBNYXAgdG8gc3RvcmUgdGhlIG5leHQgc2V0IG9mIGNvbXBvbmVudHMgYWZ0ZXIgdGhlIGNyZWF0ZVZkb20oKSBFZmZlY3QgaGFzIHJ1bi5cbiAgICAgKiBAbWVtYmVyIHtNYXB8bnVsbH0gbmV4dENoaWxkQ29tcG9uZW50cz1udWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjbmV4dENoaWxkQ29tcG9uZW50cyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgID0gdGhpcyxcbiAgICAgICAgICAgIG9wdHMgPSB7Y29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWV9O1xuXG4gICAgICAgIC8vIFRoZSBidWlsZCBwcm9jZXNzIHdpbGwgcmVwbGFjZSBgcmVuZGVyKClgIHdpdGggYGNyZWF0ZVZkb20oKWAuXG4gICAgICAgIGlmIChOZW8uY29uZmlnLmVudmlyb25tZW50ICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBtZS5lbmFibGVIdG1sVGVtcGxhdGVzID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG1lLCB7XG4gICAgICAgICAgICBbYWN0aXZlRG9tTGlzdGVuZXJzU3ltYm9sXTogey4uLm9wdHMsIHZhbHVlOiBbXX0sXG4gICAgICAgICAgICBbaG9va0luZGV4U3ltYm9sXSAgICAgICAgIDogey4uLm9wdHMsIHZhbHVlOiAwfSxcbiAgICAgICAgICAgIFtob29rc1N5bWJvbF0gICAgICAgICAgICAgOiB7Li4ub3B0cywgdmFsdWU6IFtdfSxcbiAgICAgICAgICAgIFtwZW5kaW5nRG9tRXZlbnRzU3ltYm9sXSAgOiB7Li4ub3B0cywgdmFsdWU6IFtdfSxcbiAgICAgICAgICAgIFt2ZG9tVG9BcHBseVN5bWJvbF0gICAgICAgOiB7Li4ub3B0cywgdmFsdWU6IG51bGx9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCByZS1leGVjdXRlcyBjcmVhdGVWZG9tKCkgd2hlbiBkZXBlbmRlbmNpZXMgY2hhbmdlLlxuICAgICAgICBtZS52ZG9tRWZmZWN0ID0gbmV3IEVmZmVjdCh7XG4gICAgICAgICAgICBmbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lW2hvb2tJbmRleFN5bWJvbF0gICAgICAgID0gMDtcbiAgICAgICAgICAgICAgICBtZVtwZW5kaW5nRG9tRXZlbnRzU3ltYm9sXSA9IFtdOyAvLyBDbGVhciBwZW5kaW5nIGV2ZW50cyBmb3IgbmV3IHJlbmRlclxuICAgICAgICAgICAgICAgIG1lW3Zkb21Ub0FwcGx5U3ltYm9sXSAgICAgID0gbWUuY3JlYXRlVmRvbShtZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wb25lbnRJZDogbWUuaWQsXG4gICAgICAgICAgICBzdWJzY3JpYmVyIDoge1xuICAgICAgICAgICAgICAgIGlkICAgOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBmbiAgIDogbWUub25FZmZlY3RSdW5TdGF0ZUNoYW5nZSxcbiAgICAgICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGlzUmVhZHkgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRJc1JlYWR5KHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldElzUmVhZHkodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG1lLm1pc3NlZFJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIG1lLnZkb21FZmZlY3QucnVuKCk7XG4gICAgICAgICAgICBkZWxldGUgbWUubWlzc2VkUmVhZHlTdGF0ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWwgcmVnaXN0cmF0aW9uIG9mIERPTSBldmVudCBsaXN0ZW5lcnMgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gICAgICAgICAgICB0aGlzLmFwcGx5UGVuZGluZ0RvbUxpc3RlbmVycygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIHRoaXMuY2hpbGRDb21wb25lbnRzPy5mb3JFYWNoKGNoaWxkRGF0YSA9PiB7XG4gICAgICAgICAgICBjaGlsZERhdGEuaW5zdGFuY2Uud2luZG93SWQgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHBlbmRpbmcgRE9NIGV2ZW50IGxpc3RlbmVycyBhbmQgdXBkYXRlcyB0aGUgYWN0aXZlIGxpc3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhcHBseVBlbmRpbmdEb21MaXN0ZW5lcnMoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGFjdGl2ZUV2ZW50cyAgPSBtZVthY3RpdmVEb21MaXN0ZW5lcnNTeW1ib2xdLFxuICAgICAgICAgICAgcGVuZGluZ0V2ZW50cyA9IG1lW3BlbmRpbmdEb21FdmVudHNTeW1ib2xdO1xuXG4gICAgICAgIGlmIChwZW5kaW5nRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghTmVvLmlzRXF1YWwoYWN0aXZlRXZlbnRzLCBwZW5kaW5nRXZlbnRzKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFdmVudHM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBkeW5hbWljIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICBtZS5yZW1vdmVEb21MaXN0ZW5lcnMobWVbYWN0aXZlRG9tTGlzdGVuZXJzU3ltYm9sXSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZS5hZGREb21MaXN0ZW5lcnMoWy4uLnBlbmRpbmdFdmVudHNdKTtcblxuICAgICAgICAgICAgICAgIG1lW2FjdGl2ZURvbUxpc3RlbmVyc1N5bWJvbF0gPSBbLi4ucGVuZGluZ0V2ZW50c11cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xlYXIgcGVuZGluZyBldmVudHMgZm9yIG5leHQgYGNyZWF0ZVZkb20oKWAgRWZmZWN0IHJ1blxuICAgICAgICAgICAgbWVbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF0gPSBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBsaWZlY3ljbGUgaG9vayB0aGF0IHJ1bnMgYWZ0ZXIgYSBzdGF0ZSBjaGFuZ2UgaGFzIGJlZW4gZGV0ZWN0ZWQgYnV0IGJlZm9yZSB0aGVcbiAgICAgKiBWRE9NIHVwZGF0ZSBpcyBkaXNwYXRjaGVkLiBJdCBwcm92aWRlcyBhIGRlZGljYXRlZCBwbGFjZSBmb3IgbG9naWMgdGhhdCBuZWVkcyB0b1xuICAgICAqIGV4ZWN1dGUgYmVmb3JlIHJlbmRlcmluZywgc3VjaCBhcyBjYWxjdWxhdGluZyBkZXJpdmVkIGRhdGEgb3IgY2FjaGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHByZXZlbnQgdGhlIFZET00gdXBkYXRlIGJ5IHJldHVybmluZyBgZmFsc2VgIGZyb20gdGhpcyBtZXRob2QuIFRoaXMgaXNcbiAgICAgKiB1c2VmdWwgZm9yIGFkdmFuY2VkIGNhc2VzIHdoZXJlIHlvdSBtaWdodCB3YW50IHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBkaWZmZXJlbnRcbiAgICAgKiB1cGRhdGUgYWZ0ZXIgbW9kaWZ5aW5nIG90aGVyIGNvbXBvbmVudCBjb25maWdzLlxuICAgICAqXG4gICAgICogKipJTVBPUlRBTlQqKjogRG8gbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgYW55IGNvbmZpZyB0aGF0IGlzIHVzZWQgYXMgYSBkZXBlbmRlbmN5XG4gICAgICogd2l0aGluIHRoZSBgY3JlYXRlVmRvbWAgbWV0aG9kIGZyb20gaW5zaWRlIHRoaXMgaG9vaywgYXMgaXQgd2lsbCBjYXVzZSBhblxuICAgICAqIGluZmluaXRlIHVwZGF0ZSBsb29wLiBUaGlzIGhvb2sgaXMgZm9yIG9uZS13YXkgZGF0YSBmbG93LCBub3QgZm9yIHRyaWdnZXJpbmdcbiAgICAgKiBjYXNjYWRpbmcgcmVhY3RpdmUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufHVuZGVmaW5lZH0gUmV0dXJuIGBmYWxzZWAgdG8gY2FuY2VsIHRoZSB1cGNvbWluZyBWRE9NIHVwZGF0ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICAgKiAgICAgLy8gUGVyZm9ybSBhbiBleHBlbnNpdmUgY2FsY3VsYXRpb24gYW5kIGNhY2hlIHRoZSByZXN1bHQgb24gdGhlIGluc3RhbmNlXG4gICAgICogICAgIHRoaXMucHJvY2Vzc2VkRGF0YSA9IHRoaXMucHJvY2Vzc1Jhd0RhdGEodGhpcy5yYXdEYXRhKTtcbiAgICAgKlxuICAgICAqICAgICAvLyBFeGFtcGxlIG9mIGNvbmRpdGlvbmFsbHkgY2FuY2VsbGluZyBhbiB1cGRhdGVcbiAgICAgKiAgICAgaWYgKHRoaXMucHJvY2Vzc2VkRGF0YS5sZW5ndGggPT09IDAgJiYgdGhpcy52ZG9tLmNuPy5sZW5ndGggPT09IDApIHtcbiAgICAgKiAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRG9uJ3QgcmUtcmVuZGVyIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICovXG4gICAgYmVmb3JlVXBkYXRlKCkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBIdG1sVGVtcGxhdGVQcm9jZXNzb3IgYWZ0ZXIgdGhlIGFzeW5jIHBhcnNpbmcgaXMgY29tcGxldGUuXG4gICAgICogSXQgdGhlbiBjb250aW51ZXMgdGhlIGNvbXBvbmVudCB1cGRhdGUgbGlmZWN5Y2xlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWRWZG9tIFRoZSBWRE9NIG9iamVjdCByZWNlaXZlZCBmcm9tIHRoZSBwYXJzZXIgYWRkb24uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnRpbnVlVXBkYXRlV2l0aFZkb20ocGFyc2VkVmRvbSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBmb3IgY29tcG9uZW50cyBpbnN0YW50aWF0ZWQgaW4gdGhpcyByZW5kZXIgY3ljbGVcbiAgICAgICAgbWUuI25leHRDaGlsZENvbXBvbmVudHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgbmV3VmRvbSB0byBpbnN0YW50aWF0ZSBjb21wb25lbnRzXG4gICAgICAgIC8vIFRoZSBwYXJlbnRJZCBmb3IgdGhlc2UgY29tcG9uZW50cyB3aWxsIGJlIHRoZSBmdW5jdGlvbmFsIGNvbXBvbmVudCdzIGlkXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFZkb20gPSBtZS5wcm9jZXNzVmRvbUZvckNvbXBvbmVudHMocGFyc2VkVmRvbSwgbWUuaWQpO1xuXG4gICAgICAgIC8vIERlc3Ryb3kgY29tcG9uZW50cyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCBpbiB0aGUgbmV3IFZET01cbiAgICAgICAgaWYgKG1lLmNoaWxkQ29tcG9uZW50cz8uc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIFsuLi5tZS5jaGlsZENvbXBvbmVudHNdLmZvckVhY2goKFtrZXksIGNoaWxkRGF0YV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lLiNuZXh0Q2hpbGRDb21wb25lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNoaWxkQ29tcG9uZW50cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGREYXRhLmluc3RhbmNlLmRlc3Ryb3koKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGNvbXBvbmVudCBjcmVhdGVkIG90aGVyIGNsYXNzaWMgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLFxuICAgICAgICAvLyBpbmNsdWRlIHRoZWlyIGZ1bGwgdmRvbSBpbnRvIHRoZSBuZXh0IHVwZGF0ZSBjeWNsZS5cbiAgICAgICAgY29uc3Qgb2xkS2V5cyA9IG1lLmNoaWxkQ29tcG9uZW50cyA/IG5ldyBTZXQobWUuY2hpbGRDb21wb25lbnRzLmtleXMoKSkgOiBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBoYXNOZXdDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoY29uc3QgbmV3S2V5IG9mIG1lLiNuZXh0Q2hpbGRDb21wb25lbnRzLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKCFvbGRLZXlzLmhhcyhuZXdLZXkpKSB7XG4gICAgICAgICAgICAgICAgaGFzTmV3Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbmV3IGNoaWxkIGNvbXBvbmVudHMgYXJlIGNyZWF0ZWQsIHdlIG5lZWQgdG8gc2VuZCB0aGVpciBmdWxsIFZET01cbiAgICAgICAgICAgIC8vIHRvIHRoZSB2ZG9tLXdvcmtlciwgc28gdGhleSBjYW4gZ2V0IHJlbmRlcmVkLlxuICAgICAgICAgICAgLy8gU3Vic2VxdWVudCB1cGRhdGVzIHdpbGwgYmUgZ3JhbnVsYXIgdmlhIGRpZmZBbmRTZXQoKSA9PiBzZXQoKSBvbiB0aGUgY2hpbGQuXG4gICAgICAgICAgICBtZS51cGRhdGVEZXB0aCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtYWluIG1hcCBvZiBpbnN0YW50aWF0ZWQgY29tcG9uZW50c1xuICAgICAgICBtZS5jaGlsZENvbXBvbmVudHMgPSBtZS4jbmV4dENoaWxkQ29tcG9uZW50cztcblxuICAgICAgICAvLyBDbGVhciB0aGUgb2xkIHZkb20gcHJvcGVydGllc1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZS52ZG9tKSB7XG4gICAgICAgICAgICBkZWxldGUgbWUudmRvbVtrZXldXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBc3NpZ24gdGhlIG5ldyBwcm9wZXJ0aWVzXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUudmRvbSwgcHJvY2Vzc2VkVmRvbSk7IC8vIFVzZSBwcm9jZXNzZWRWZG9tIGhlcmVcblxuICAgICAgICBtZVt2ZG9tVG9BcHBseVN5bWJvbF0gPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IHJvb3QgPSBtZS5nZXRWZG9tUm9vdCgpO1xuXG4gICAgICAgIGlmIChtZS5jbHMpIHtcbiAgICAgICAgICAgIHJvb3QuY2xzID0gTmVvQXJyYXkudW5pb24obWUuY2xzLCByb290LmNscylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5pZCkge1xuICAgICAgICAgICAgcm9vdC5pZCA9IG1lLmlkXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZS1oeWRyYXRlIHRoZSBuZXcgdmRvbSB3aXRoIHN0YWJsZSBJRHMgZnJvbSB0aGUgcHJldmlvdXMgdm5vZGUgdHJlZS5cbiAgICAgICAgLy8gVGhpcyBpcyBjcnVjaWFsIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMgd2hlcmUgdGhlIHZkb20gaXMgcmVjcmVhdGVkIG9uIGV2ZXJ5IHJlbmRlcixcbiAgICAgICAgLy8gZW5zdXJpbmcgdGhlIGRpZmZpbmcgYWxnb3JpdGhtIGNhbiB0cmFjayBub2RlcyBjb3JyZWN0bHkuXG4gICAgICAgIG1lLnN5bmNWZG9tU3RhdGUoKTtcblxuICAgICAgICBpZiAobWUuYmVmb3JlVXBkYXRlKCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVWZG9tKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBET00gZXZlbnQgbGlzdGVuZXJzIGJhc2VkIG9uIHRoZSBuZXcgcmVuZGVyXG4gICAgICAgIGlmIChtZS5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5hcHBseVBlbmRpbmdEb21MaXN0ZW5lcnMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4geW91ciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0byByZXR1cm4gaXRzIFZET00gc3RydWN0dXJlLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgYXV0b21hdGljYWxseSByZS1leGVjdXRlZCB3aGVuIGFueSBvZiB0aGUgY29tcG9uZW50J3MgY29uZmlncyBjaGFuZ2UuXG4gICAgICogVG8gYWNjZXNzIGRhdGEgZnJvbSBhIHN0YXRlIHByb3ZpZGVyLCB1c2UgYGNvbmZpZy5kYXRhYC5cbiAgICAgKiBAcGFyYW0ge05lby5mdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlfSBjb25maWcgLSBNZW50YWwgbW9kZWw6IHdoaWxlIGl0IGNvbnRhaW5zIHRoZSBpbnN0YW5jZSwgaXQgbWFrZXMgaXQgY2xlYXIgdG8gYWNjZXNzIGNvbmZpZ3NcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgVkRPTSBzdHJ1Y3R1cmUgZm9yIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgY3JlYXRlVmRvbShjb25maWcpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5lbmFibGVIdG1sVGVtcGxhdGVzICYmIHR5cGVvZiBtZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5yZW5kZXIoY29uZmlnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbdXBkYXRlUGFyZW50VmRvbT1mYWxzZV0gdHJ1ZSB0byByZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBwYXJlbnQgdmRvbSA9PiByZWFsIGRvbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gdHJ1ZSB0byB1cGRhdGUgdGhlIHZkb20gc2lsZW50bHkgKHVzZWZ1bCBmb3IgZGVzdHJveWluZyBtdWx0aXBsZSBjaGlsZCBpdGVtcyBpbiBhIHJvdylcbiAgICAgKi9cbiAgICBkZXN0cm95KHVwZGF0ZVBhcmVudFZkb209ZmFsc2UsIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUudmRvbUVmZmVjdD8uZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIERlc3Ryb3kgYWxsIGNsYXNzaWMgY29tcG9uZW50cyBpbnN0YW50aWF0ZWQgYnkgdGhpcyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgICBtZS5jaGlsZENvbXBvbmVudHM/LmZvckVhY2goY2hpbGREYXRhID0+IHtcbiAgICAgICAgICAgIGNoaWxkRGF0YS5pbnN0YW5jZS5kZXN0cm95KGZhbHNlLCB0cnVlKSAvLyBQYXNzIHNpbGVudD10cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBtZS5jaGlsZENvbXBvbmVudHM/LmNsZWFyKCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFueSBwZW5kaW5nIERPTSBldmVudCBsaXN0ZW5lcnMgdGhhdCBtaWdodCBub3QgaGF2ZSBiZWVuIG1vdW50ZWRcbiAgICAgICAgbWVbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF0gPSBudWxsO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlY3Vyc2l2ZWx5IGNvbXBhcmVzIHRoZSBuZXcgVkRPTSBjb25maWcgd2l0aCB0aGUgbGFzdCBhcHBsaWVkIGNvbmZpZ1xuICAgICAqIGZvciBhIGdpdmVuIGNvbXBvbmVudCBpbnN0YW5jZSBhbmQgaXRzIHN1Yi1pbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIHtOZW8uY29yZS5CYXNlfSBpbnN0YW5jZSBUaGUgY29tcG9uZW50IGluc3RhbmNlIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3Q29uZmlnIFRoZSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSB0aGUgVkRPTS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGFzdENvbmZpZyBUaGUgbGFzdCBhcHBsaWVkIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGlmZkFuZFNldChpbnN0YW5jZSwgbmV3Q29uZmlnLCBsYXN0Q29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhQ29uZmlnID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3Q29uZmlnKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ld0NvbmZpZ1trZXldLFxuICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBsYXN0Q29uZmlnW2tleV07XG5cbiAgICAgICAgICAgIGlmICghTmVvLmlzRXF1YWwobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb25maWcgcHJvcGVydHkgaXMgYW4gb2JqZWN0IGFuZCBpdCBtYXBzIHRvIGEgc3ViLWNvbXBvbmVudCBpbnN0YW5jZSwgcmVjdXJzZS5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLnR5cGVPZihuZXdWYWx1ZSkgPT09ICdPYmplY3QnICYmIE5lby50eXBlT2YoaW5zdGFuY2Vba2V5XSkgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaWZmQW5kU2V0KGluc3RhbmNlW2tleV0sIG5ld1ZhbHVlLCBvbGRWYWx1ZSB8fCB7fSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGFkZCBpdCB0byB0aGUgZGVsdGEgdG8gYmUgc2V0IG9uIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICBkZWx0YUNvbmZpZ1trZXldID0gbmV3VmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGNhbGwgc2V0KCkgaWYgdGhlcmUgYXJlIGFjdHVhbCBjaGFuZ2VzIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlbHRhQ29uZmlnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXQoZGVsdGFDb25maWcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBpbml0QXN5bmMoKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRBc3luYygpO1xuXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUh0bWxUZW1wbGF0ZXMgJiYgTmVvLmNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgaWYgKCFOZW8ubnMoJ05lby5mdW5jdGlvbmFsLnV0aWwuSHRtbFRlbXBsYXRlUHJvY2Vzc29yJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4uL3V0aWwvSHRtbFRlbXBsYXRlUHJvY2Vzc29yLm1qcycpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHRtbFRlbXBsYXRlUHJvY2Vzc29yID0gbW9kdWxlLmRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaGFuZGxlciBydW5zIHdoZW4gdGhlIGVmZmVjdCdzIGBpc1J1bm5pbmdgIHN0YXRlIGNoYW5nZXMuXG4gICAgICogSXQgcnVucyBvdXRzaWRlIHRoZSBlZmZlY3QncyB0cmFja2luZyBzY29wZSwgcHJldmVudGluZyBmZWVkYmFjayBsb29wcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uRWZmZWN0UnVuU3RhdGVDaGFuZ2UodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGVmZmVjdCBoYXMganVzdCBmaW5pc2hlZCBydW5uaW5nLi4uXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgbmV3VmRvbSA9IG1lW3Zkb21Ub0FwcGx5U3ltYm9sXTtcblxuICAgICAgICAgICAgaWYgKG5ld1Zkb20pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIGFuIEh0bWxUZW1wbGF0ZSwgaGFuZCBpdCBvZmYgdG8gdGhlIHByb2Nlc3NvclxuICAgICAgICAgICAgICAgIGlmIChuZXdWZG9tW2lzSHRtbFRlbXBsYXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWUuaHRtbFRlbXBsYXRlUHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5odG1sVGVtcGxhdGVQcm9jZXNzb3IucHJvY2VzcyhuZXdWZG9tLCBtZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm1pc3NlZFJlYWR5U3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnkgY2FsbGluZyB0aGlzIHdpdGggYW4gZW1wdHkgb2JqZWN0LCB3ZSBlbnN1cmUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVycyBhIHBsYWNlaG9sZGVyIERPTSBub2RlIGZvciB0aGlzIGNvbXBvbmVudCwgd2hpY2ggd2UgY2FuIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvcHVsYXRlIGxhdGVyIG9uY2UgdGhlIHRlbXBsYXRlIHByb2Nlc3NvciBpcyByZWFkeS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmNvbnRpbnVlVXBkYXRlV2l0aFZkb20oe30pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8vIFN0b3AgZXhlY3V0aW9uLCB0aGUgcHJvY2Vzc29yIHdpbGwgY2FsbCBiYWNrXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgc3RhbmRhcmQgSlNPTi1iYXNlZCBWRE9NIHVwZGF0ZVxuICAgICAgICAgICAgICAgIG1lLmNvbnRpbnVlVXBkYXRlV2l0aFZkb20obmV3VmRvbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHByb2Nlc3NlcyBhIFZET00gbm9kZSB0byBpbnN0YW50aWF0ZSBjb21wb25lbnRzIGRlZmluZWQgd2l0aGluIGl0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZG9tVHJlZSBUaGUgVkRPTSBub2RlIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudElkIFRoZSBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudCAodGhlIGZ1bmN0aW9uYWwgY29tcG9uZW50IGhvc3RpbmcgaXQpLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyZW50SW5kZXhdIFRoZSBpbmRleCBvZiB0aGUgdmRvbU5vZGUgd2l0aGluIGl0cyBwYXJlbnQncyBjaGlsZHJlbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvY2Vzc2VkIFZET00gbm9kZSwgcG90ZW50aWFsbHkgcmVwbGFjZWQgd2l0aCBhIGNvbXBvbmVudCByZWZlcmVuY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm9jZXNzVmRvbUZvckNvbXBvbmVudHModmRvbVRyZWUsIHBhcmVudElkLCBwYXJlbnRJbmRleCkge1xuICAgICAgICBpZiAoIXZkb21UcmVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmRvbVRyZWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhIGNvbXBvbmVudCByZWZlcmVuY2UsIG5vIG5lZWQgdG8gcHJvY2VzcyBmdXJ0aGVyXG4gICAgICAgIGlmICh2ZG9tVHJlZS5jb21wb25lbnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZkb21UcmVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIGNvbXBvbmVudCBkZWZpbml0aW9uIChmdW5jdGlvbmFsIG9yIGNsYXNzaWMpXG4gICAgICAgIGlmICh2ZG9tVHJlZS5jbGFzc05hbWUgfHwgdmRvbVRyZWUubW9kdWxlIHx8IHZkb21UcmVlLm50eXBlKSB7XG4gICAgICAgICAgICAvLyBDb21wb25lbnRzIGFyZSByZWNvbmNpbGVkIGJhc2VkIG9uIHRoZWlyIGBpZGAgcHJvcGVydHkgaW4gdGhlIFZET00gZGVmaW5pdGlvbi5cbiAgICAgICAgICAgIC8vIElmIG5vIGBpZGAgaXMgcHJvdmlkZWQsIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZCBvbiBldmVyeSByZW5kZXIuXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRLZXkgPSB2ZG9tVHJlZS5pZDtcblxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnRLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb21wb25lbnQgZGVmaW5pdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudCBWRE9NIGlzIG1pc3NpbmcgYW4gXCJpZFwiLiBGb3Igc3RhYmxlIHJlY29uY2lsaWF0aW9uLCAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2VzcGVjaWFsbHkgaW4gZHluYW1pYyBsaXN0cywgcHJvdmlkZSBhIHVuaXF1ZSBcImlkXCIgcHJvcGVydHkuJ1xuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgICAgICAgICAgICAgICB2ZG9tVHJlZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNoaWxkRGF0YSA9IG1lLmNoaWxkQ29tcG9uZW50cz8uZ2V0KGNvbXBvbmVudEtleSksXG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnID0gey4uLnZkb21UcmVlfSwgLy8gU2hhbGxvdyBjb3B5XG4gICAgICAgICAgICAgICAgaW5zdGFuY2U7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBuZXdDb25maWcuY2xhc3NOYW1lO1xuICAgICAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5pZDtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdDb25maWcubW9kdWxlO1xuICAgICAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5udHlwZTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZERhdGEpIHtcbiAgICAgICAgICAgICAgICBtZS5jaGlsZENvbXBvbmVudHMgPz89IG5ldyBNYXAoKTtcblxuICAgICAgICAgICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IE5lb1sodmRvbVRyZWUuY2xhc3NOYW1lIHx8IHZkb21UcmVlLm1vZHVsZSkgPyAnY3JlYXRlJyA6ICdudHlwZSddKHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmRvbVRyZWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SWQ6IG1lLndpbmRvd0lkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gY2hpbGREYXRhLmluc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZGlmZiBhbmQgc2V0IGNvbmZpZ3NcbiAgICAgICAgICAgICAgICB0aGlzLmRpZmZBbmRTZXQoaW5zdGFuY2UsIG5ld0NvbmZpZywgY2hpbGREYXRhLmxhc3RDb25maWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIG5ldyBtYXAgZm9yIHRyYWNraW5nIGluIHRoaXMgcmVuZGVyIGN5Y2xlXG4gICAgICAgICAgICBtZS4jbmV4dENoaWxkQ29tcG9uZW50cy5zZXQoY29tcG9uZW50S2V5LCB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbGFzdENvbmZpZzogbmV3Q29uZmlnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgZGVmaW5pdGlvbiB3aXRoIGEgcmVmZXJlbmNlIHVzaW5nIHRoZSBjb21wb25lbnQncyBvd24gbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuY3JlYXRlVmRvbVJlZmVyZW5jZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcHJvY2VzcyBjaGlsZHJlblxuICAgICAgICBpZiAodmRvbVRyZWUuY24gJiYgQXJyYXkuaXNBcnJheSh2ZG9tVHJlZS5jbikpIHtcbiAgICAgICAgICAgIHZkb21UcmVlLmNuID0gdmRvbVRyZWUuY24ubWFwKChjaGlsZCwgaW5kZXgpID0+XG4gICAgICAgICAgICAgICAgbWUucHJvY2Vzc1Zkb21Gb3JDb21wb25lbnRzKGNoaWxkLCBwYXJlbnRJZCwgaW5kZXgpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbVRyZWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZ1bmN0aW9uYWxCYXNlKTtcbiIsImNvbnN0IGlzSHRtbFRlbXBsYXRlID0gU3ltYm9sLmZvcignbmVvLmlzSHRtbFRlbXBsYXRlJyk7XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIHRoZSByZXN1bHQgb2YgYW4gYGh0bWxgIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsLlxuICogSXQgaG9sZHMgdGhlIHN0YXRpYyBzdHJpbmdzIGFuZCB0aGUgZHluYW1pYyB2YWx1ZXMgb2YgdGhlIHRlbXBsYXRlLlxuICogQGNsYXNzIE5lby5mdW5jdGlvbmFsLnV0aWwuSHRtbFRlbXBsYXRlXG4gKi9cbmNsYXNzIEh0bWxUZW1wbGF0ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBzdHJpbmdzIFRoZSBzdGF0aWMgcGFydHMgb2YgdGhlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gdmFsdWVzIFRoZSBkeW5hbWljIHZhbHVlcyBvZiB0aGUgdGVtcGxhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy52YWx1ZXMgID0gdmFsdWVzO1xuICAgICAgICB0aGlzW2lzSHRtbFRlbXBsYXRlXSA9IHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWwgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIGBIdG1sVGVtcGxhdGVgIGluc3RhbmNlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGFueSBwYXJzaW5nIG9yIHN0cmluZyBjb25jYXRlbmF0aW9uIGl0c2VsZi5cbiAqIEl0IHNpbXBseSBjYXB0dXJlcyB0aGUgdGVtcGxhdGUncyBwYXJ0cyBmb3IgbGF0ZXIgcHJvY2Vzc2luZy5cbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gc3RyaW5nc1xuICogQHBhcmFtIHtBcnJheTwqPn0gdmFsdWVzXG4gKiBAcmV0dXJucyB7TmVvLmZ1bmN0aW9uYWwudXRpbC5IdG1sVGVtcGxhdGV9IEFuIGluc3RhbmNlIG9mIEh0bWxUZW1wbGF0ZVxuICovXG5jb25zdCBodG1sID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4ge1xuICAgIHJldHVybiBuZXcgSHRtbFRlbXBsYXRlKHN0cmluZ3MsIHZhbHVlcyk7XG59O1xuXG5leHBvcnQgeyBodG1sLCBpc0h0bWxUZW1wbGF0ZSwgSHRtbFRlbXBsYXRlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9