export const __webpack_esm_id__ = "vendors-src_functional_component_Base_mjs";
export const __webpack_esm_ids__ = ["vendors-src_functional_component_Base_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/core/Effect.mjs"
/*!*****************************!*\
  !*** ./src/core/Effect.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");




/**
 * Creates a reactive effect that automatically tracks its dependencies and re-runs when any of them change.
 * This is a lightweight, plain JavaScript class for performance.
 * It serves as a core reactive primitive, enabling automatic and dynamic dependency tracking.
 * @class Neo.core.Effect
 */
class Effect {
    /**
     * The optional component id this effect belongs to.
     * @member {String|null} componentId=null
     */
    componentId = null
    /**
     * A Map containing Config instances as keys and their cleanup functions as values.
     * @member {Map} dependencies=new Map()
     * @protected
     */
    dependencies = new Map()
    /**
     * The function to execute.
     * @member {Function|null} _fn=null
     */
    _fn = null
    /**
     * The unique identifier for this effect instance.
     * @member {String|null}
     */
    id = _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getId('effect')
    /**
     * @member {Boolean}
     * @protected
     */
    isDestroyed = false
    /**
     * @member {Neo.core.Config}
     * @protected
     */
    isRunning = null

    /**
     * @member fn
     */
    get fn() {
        return this._fn
    }
    set fn(value) {
        this._fn = value;
        // Assigning a new function to `fn` automatically triggers a re-run.
        // This ensures that the effect immediately re-evaluates its dependencies
        // based on the new function's logic, clearing old dependencies and establishing new ones.
        this.run()
    }

    /**
     * @param {Function|Object}  fn              - The function to execute, or a config object for the effect.
     * @param {Function}        [fn.fn]          - The function to execute for the effect (if the first argument is an object).
     * @param {String}          [fn.componentId] - The component id this effect belongs to.
     * @param {Boolean}         [fn.lazy=false]  - If true, the effect will not run immediately upon creation.
     * @param {Object|Object[]} [fn.subscriber]  - A single subscriber or an array of subscribers for the isRunning config.
     * @param {Object}          [options={}]     - Optional. Used if the first argument is a function, this object contains the options.
     * @example
     * // Signature 1: Function and Options
     * const myEffect = new Effect(() => console.log('Run'), {lazy: true});
     * @example
     * // Signature 2: Single Config Object
     * const myEffect = new Effect({fn: () => console.log('Run'), lazy: true});
     */
    constructor(fn, options={}) {
        const me = this;

        const {
              fn: effectFn,
              componentId,
              lazy = false,
              subscriber
        } = (typeof fn === 'function') ? { ...options, fn } : (fn || {});

        if (componentId) {
            me.componentId = componentId
        }

        me.isRunning = new _Config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](false);

        if (subscriber) {
            [].concat(subscriber).forEach(sub => me.isRunning.subscribe(sub))
        }

        if (lazy) {
            me._fn = effectFn
        } else {
            me.fn = effectFn
        }
    }

    /**
     * Cleans up all subscriptions and destroys the effect.
     */
    destroy() {
        const me = this;

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        me.isDestroyed = true
    }

    /**
     * Executes the effect function, re-evaluating its dependencies.
     * If the EffectManager is paused (e.g., inside a batch), it queues itself to be run later.
     * @protected
     */
    run() {
        const me = this;

        if (me.isDestroyed) {
            return
        }

        // Check if already running without creating a dependency on `isRunning`.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        const isRunning = me.isRunning.get();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        if (isRunning) {
            return
        }

        // If the manager is globally paused for batching, queue this effect and stop.
        if (_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isPaused()) {
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].queue(me);
            return
        }

        // Set `isRunning` to true without creating a dependency.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        me.isRunning.set(true);
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        // Clear old dependencies and set this as the active effect.
        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].push(me);

        try {
            // Execute the function, which will collect new dependencies.
            me.fn()
        } finally {
            // Clean up after the run.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pop();

            // Set `isRunning` to false without creating a dependency.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
            me.isRunning.set(false);
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking()
        }
    }

    /**
     * Adds a `Neo.core.Config` instance as a dependency for this effect.
     * @param {Neo.core.Config} config The config instance to subscribe to.
     * @protected
     */
    addDependency(config) {
        const me = this;

        if (!me.dependencies.has(config)) {
            const cleanup = config.subscribe({
                id: me.id,
                fn: me.run.bind(me)
            });

            me.dependencies.set(config, cleanup)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Effect, 'Neo.core.Effect', () => {
    /**
     * Factory shortcut to create a new Neo.core.Effect instance.
     * @function Neo.effect
     * @param {Function|Object} fn - The function to execute, or a config object for the effect.
     * @param {Object} [options] - Optional. Used if the first argument is a function.
     * @returns {Neo.core.Effect}
     */
    Neo.effect = (fn, options) => new Effect(fn, options)
}));


/***/ },

/***/ "./src/functional/component/Base.mjs"
/*!*******************************************!*\
  !*** ./src/functional/component/Base.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Abstract.mjs */ "./src/component/Abstract.mjs");
/* harmony import */ var _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/Effect.mjs */ "./src/core/Effect.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");
/* harmony import */ var _util_html_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/html.mjs */ "./src/functional/util/html.mjs");






const
    activeDomListenersSymbol = Symbol.for('activeDomListeners'),
    hookIndexSymbol          = Symbol.for('hookIndex'),
    hooksSymbol              = Symbol.for('hooks'),
    pendingDomEventsSymbol   = Symbol.for('pendingDomEvents'),
    vdomToApplySymbol        = Symbol('vdomToApply');

/**
 * @class Neo.functional.component.Base
 * @extends Neo.component.Abstract
 */
class FunctionalBase extends _component_Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.functional.component.Base'
         * @protected
         */
        className: 'Neo.functional.component.Base',
        /**
         * @member {Boolean} enableHtmlTemplates_=false
         * @reactive
         * Set this to true to enable using tagged template literals for VDOM creation
         * via the render() method. This will lazy load the html parser.
         */
        enableHtmlTemplates_: false,
        /**
         * @member {String} ntype='functional-component'
         * @protected
         */
        ntype: 'functional-component',
        /**
         * The vdom markup for this component.
         * @member {Object} vdom={}
         */
        vdom: {}
    }

    /**
     * Neo component instances, which got defined inside createVdom()
     * @member {Map|null} childComponents=null
     */
    childComponents = null
    /**
     * @member {Neo.functional.util.HtmlTemplateProcessor|null} htmlTemplateProcessor=null
     * @private
     */
    htmlTemplateProcessor = Neo.ns('Neo.functional.util.HtmlTemplateProcessor')
    /**
     * Internal Map to store the next set of components after the createVdom() Effect has run.
     * @member {Map|null} nextChildComponents=null
     * @private
     */
    #nextChildComponents = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me   = this,
            opts = {configurable: true, enumerable: false, writable: true};

        // The build process will replace `render()` with `createVdom()`.
        if (Neo.config.environment !== 'development') {
            me.enableHtmlTemplates = false
        }

        Object.defineProperties(me, {
            [activeDomListenersSymbol]: {...opts, value: []},
            [hookIndexSymbol]         : {...opts, value: 0},
            [hooksSymbol]             : {...opts, value: []},
            [pendingDomEventsSymbol]  : {...opts, value: []},
            [vdomToApplySymbol]       : {...opts, value: null}
        });

        // Creates a reactive effect that re-executes createVdom() when dependencies change.
        me.vdomEffect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]({
            fn: () => {
                me[hookIndexSymbol]        = 0;
                me[pendingDomEventsSymbol] = []; // Clear pending events for new render
                me[vdomToApplySymbol]      = me.createVdom(me)
            },
            componentId: me.id,
            subscriber : {
                id   : me.id,
                fn   : me.onEffectRunStateChange,
                scope: me
            }
        })
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        super.afterSetIsReady(value, oldValue);

        const me = this;

        if (value && me.missedReadyState) {
            me.vdomEffect.run();
            delete me.missedReadyState
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && oldValue !== undefined) {
            // Initial registration of DOM event listeners when component mounts
            this.applyPendingDomListeners()
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        this.childComponents?.forEach(childData => {
            childData.instance.windowId = value
        })
    }

    /**
     * Applies the pending DOM event listeners and updates the active list.
     * @private
     */
    applyPendingDomListeners() {
        const
            me            = this,
            activeEvents  = me[activeDomListenersSymbol],
            pendingEvents = me[pendingDomEventsSymbol];

        if (pendingEvents.length > 0) {
            if (!Neo.isEqual(activeEvents, pendingEvents)) {
                if (activeEvents?.length > 0) {
                    // Remove old dynamic listeners
                    me.removeDomListeners(me[activeDomListenersSymbol])
                }

                me.addDomListeners([...pendingEvents]);

                me[activeDomListenersSymbol] = [...pendingEvents]
            }

            // Clear pending events for next `createVdom()` Effect run
            me[pendingDomEventsSymbol] = []
        }
    }

    /**
     * A lifecycle hook that runs after a state change has been detected but before the
     * VDOM update is dispatched. It provides a dedicated place for logic that needs to
     * execute before rendering, such as calculating derived data or caching values.
     *
     * You can prevent the VDOM update by returning `false` from this method. This is
     * useful for advanced cases where you might want to manually trigger a different
     * update after modifying other component configs.
     *
     * **IMPORTANT**: Do not change the value of any config that is used as a dependency
     * within the `createVdom` method from inside this hook, as it will cause an
     * infinite update loop. This hook is for one-way data flow, not for triggering
     * cascading reactive changes.
     *
     * @returns {Boolean|undefined} Return `false` to cancel the upcoming VDOM update.
     * @example
     * beforeUpdate() {
     *     // Perform an expensive calculation and cache the result on the instance
     *     this.processedData = this.processRawData(this.rawData);
     *
     *     // Example of conditionally cancelling an update
     *     if (this.processedData.length === 0 && this.vdom.cn?.length === 0) {
     *         return false; // Don't re-render if there's nothing to show
     *     }
     * }
     */
    beforeUpdate() {
        // This method can be overridden by subclasses
    }

    /**
     * This method is called by the HtmlTemplateProcessor after the async parsing is complete.
     * It then continues the component update lifecycle.
     * @param {Object} parsedVdom The VDOM object received from the parser addon.
     * @protected
     */
    continueUpdateWithVdom(parsedVdom) {
        const me = this;

        // 1. Apply new VDOM to instance immediately so getVdomRoot() works on the new structure
        for (const key in me.vdom) delete me.vdom[key];
        Object.assign(me.vdom, parsedVdom);

        // 2. Identify Root and Apply ID (User's Requirement)
        const root = me.getVdomRoot();

        if (me.id) {
            root.id = me.id
        }

        // 3. Generate IDs (now using correct root ID as prefix)
        me.generateIds(root);

        // 4. Prepare Optimization Map
        const vnodeMap = new Map();

        if (me.vnode) {
            const populateMap = (node) => {
                if (node.id) vnodeMap.set(node.id, node);
                node.childNodes?.forEach(populateMap);
            };
            populateMap(me.vnode);
        }

        // 5. Process Components & Preserve State (modifies root in-place)
        // Create a new map for components instantiated in this render cycle
        me.#nextChildComponents = new Map();

        // Process the newVdom to instantiate components
        // The parentId for these components will be the functional component's id
        const processedVdom = me.processVdomForComponents(root, me.id, undefined, vnodeMap);

        if (processedVdom !== root) {
             for (const key in me.vdom) delete me.vdom[key];
             Object.assign(me.vdom, processedVdom)
        }


        // 6. Cleanup Child Components
        // Destroy components that are no longer present in the new VDOM
        if (me.childComponents?.size > 0) {
            [...me.childComponents].forEach(([key, childData]) => {
                if (!me.#nextChildComponents.has(key)) {
                    me.childComponents.delete(key);
                    childData.instance.destroy()
                }
            })
        }

        // 7. Update Child References
        // If this component created other classic or functional components,
        // include their full vdom into the next update cycle.
        const oldKeys = me.childComponents ? new Set(me.childComponents.keys()) : new Set();
        let hasNewChildren = false;

        for (const newKey of me.#nextChildComponents.keys()) {
            if (!oldKeys.has(newKey)) {
                hasNewChildren = true;
                break
            }
        }

        if (hasNewChildren) {
            // When new child components are created, we need to send their full VDOM
            // to the vdom-worker, so they can get rendered.
            // Subsequent updates will be granular via diffAndSet() => set() on the child.
            me.updateDepth = -1;
        }

        // Update the main map of instantiated components
        me.childComponents = me.#nextChildComponents;

        // 8. CLS Merging
        if (me.cls) {
            root.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].union(me.cls, root.cls)
        }

        // 9. Reset Symbol
        me[vdomToApplySymbol] = null;

        // 10. Update Call
        if (me.beforeUpdate() !== false) {
            me.updateVdom()
        }

        // 11. Listeners
        // Update DOM event listeners based on the new render
        if (me.mounted) {
            me.applyPendingDomListeners()
        }
    }

    /**
     * Override this method in your functional component to return its VDOM structure.
     * This method will be automatically re-executed when any of the component's configs change.
     * To access data from a state provider, use `config.data`.
     * @param {Neo.functional.component.Base} config - Mental model: while it contains the instance, it makes it clear to access configs
     * @returns {Object} The VDOM structure for the component.
     */
    createVdom(config) {
        const me = this;

        if (me.enableHtmlTemplates && typeof me.render === 'function') {
            return me.render(config)
        }

        return {}
    }

    /**
     * Destroys the functional component
     * @param {Boolean} [updateParentVdom=false] true to remove the component from the parent vdom => real dom
     * @param {Boolean} [silent=false] true to update the vdom silently (useful for destroying multiple child items in a row)
     */
    destroy(updateParentVdom=false, silent=false) {
        const me = this;

        me.vdomEffect?.destroy();

        // Destroy all classic components instantiated by this functional component
        me.childComponents?.forEach(childData => {
            childData.instance.destroy(false, true) // Pass silent=true
        });
        me.childComponents?.clear();

        // Remove any pending DOM event listeners that might not have been mounted
        me[pendingDomEventsSymbol] = null;

        super.destroy(updateParentVdom, silent)
    }

    /**
     * This method recursively compares the new VDOM config with the last applied config
     * for a given component instance and its sub-instances.
     * @param {Neo.core.Base} instance The component instance to update.
     * @param {Object} newConfig The new configuration object from the VDOM.
     * @param {Object} lastConfig The last applied configuration object.
     * @private
     */
    diffAndSet(instance, newConfig, lastConfig) {
        const deltaConfig = {};

        for (const key in newConfig) {
            const newValue = newConfig[key],
                  oldValue = lastConfig[key];

            if (!Neo.isEqual(newValue, oldValue)) {
                // If the config property is an object and it maps to a sub-component instance, recurse.
                if (Neo.typeOf(newValue) === 'Object' && Neo.typeOf(instance[key]) === 'NeoInstance') {
                    this.diffAndSet(instance[key], newValue, oldValue || {})
                } else {
                    // Otherwise, add it to the delta to be set on the current instance.
                    deltaConfig[key] = newValue
                }
            }
        }

        // Only call set() if there are actual changes for the current instance.
        if (Object.keys(deltaConfig).length > 0) {
            instance.set(deltaConfig)
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        if (this.enableHtmlTemplates && Neo.config.environment === 'development') {
            if (!Neo.ns('Neo.functional.util.HtmlTemplateProcessor')) {
                const module = await __webpack_require__.e(/*! import() */ "vendors-src_functional_util_HtmlTemplateProcessor_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../util/HtmlTemplateProcessor.mjs */ "./src/functional/util/HtmlTemplateProcessor.mjs"));
                this.htmlTemplateProcessor = module.default
            }
        }
    }

    /**
     * Traverses the VDOM tree and assigns deterministic IDs to nodes that lack them.
     * Uses a "Scoped" strategy:
     * - If a node has a custom ID, that ID becomes the new prefix for its descendants.
     * - If a node lacks an ID, it gets `prefix + '__' + index`.
     * - Indices reset for each new scope (prefix).
     *
     * This ensures that inserting/removing nodes only affects the indices within the immediate
     * parent scope, while sub-trees with custom IDs remain stable.
     *
     * @param {Object} vdom
     * @param {String} [prefix=this.id]
     * @param {Map} [scopeMap=new Map()] Tracks the counter for each prefix
     */
    generateIds(vdom, prefix=this.id, scopeMap=new Map()) {
        if (!vdom) return;

        // If the node has an ID, it becomes the new prefix for its children
        if (vdom.id) {
            prefix = vdom.id
        } else {
            // Otherwise, generate an ID based on the current prefix and its counter
            let count = scopeMap.get(prefix) || 0;
            vdom.id = prefix + '__' + count;
            scopeMap.set(prefix, count + 1)
        }

        vdom.cn?.forEach(child => this.generateIds(child, prefix, scopeMap))
    }

    /**
     * This handler runs when the effect's `isRunning` state changes.
     * It runs outside the effect's tracking scope, preventing feedback loops.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    onEffectRunStateChange(value, oldValue) {
        // When the effect has just finished running...
        if (value === false) {
            const me      = this,
                  newVdom = me[vdomToApplySymbol];

            if (newVdom) {
                // If the result is an HtmlTemplate, hand it off to the processor
                if (newVdom[_util_html_mjs__WEBPACK_IMPORTED_MODULE_4__.isHtmlTemplate]) {
                    if (me.htmlTemplateProcessor) {
                        me.htmlTemplateProcessor.process(newVdom, me)
                    } else {
                        me.missedReadyState = true;
                        // By calling this with an empty object, we ensure that the parent container
                        // renders a placeholder DOM node for this component, which we can then
                        // populate later once the template processor is ready.
                        me.continueUpdateWithVdom({})
                    }
                    return // Stop execution, the processor will call back
                }

                // Continue with the standard JSON-based VDOM update
                me.continueUpdateWithVdom(newVdom)
            }
        }
    }

    /**
     * Recursively processes a VDOM node to instantiate components defined within it.
     * @param {Object} vdomTree The VDOM node to process.
     * @param {String} parentId The ID of the parent component (the functional component hosting it).
     * @param {Number} [parentIndex] The index of the vdomNode within its parent's children.
     * @param {Map<String, Object>} [vnodeMap] Optimization map for O(1) VNode lookups.
     * @returns {Object} The processed VDOM node, potentially replaced with a component reference.
     * @private
     */
    processVdomForComponents(vdomTree, parentId, parentIndex, vnodeMap) {
        if (!vdomTree) {
            return vdomTree
        }

        // If it's already a component reference, no need to process further
        if (vdomTree.componentId) {
            return vdomTree
        }

        const me = this;

        // Check if it's a component definition (functional or classic)
        if (vdomTree.className || vdomTree.module || vdomTree.ntype) {
            // Components are reconciled based on their `id` property in the VDOM definition.
            // If no `id` is provided, a new instance will be created on every render.
            const componentKey = vdomTree.id;

            if (!componentKey) {
                console.error([
                        'Component definition in functional component VDOM is missing an "id". For stable reconciliation, ',
                        'especially in dynamic lists, provide a unique "id" property.'
                    ].join(''),
                    vdomTree
                )
            }

            let childData = me.childComponents?.get(componentKey),
                newConfig = {...vdomTree}, // Shallow copy
                instance;

            delete newConfig.className;
            delete newConfig.id;
            delete newConfig.module;
            delete newConfig.ntype;

            if (!childData) {
                me.childComponents ??= new Map();

                // Instantiate the component
                instance = Neo[(vdomTree.className || vdomTree.module) ? 'create' : 'ntype']({
                    ...vdomTree,
                    parentId,
                    parentIndex,
                    windowId: me.windowId
                });
            } else {
                instance = childData.instance;

                // Recursively diff and set configs
                this.diffAndSet(instance, newConfig, childData.lastConfig);
            }

            // Add to the new map for tracking in this render cycle
            me.#nextChildComponents.set(componentKey, {
                instance,
                lastConfig: newConfig
            });

            // Replace the definition with a reference using the component's own method
            return instance.createVdomReference();
        }

        // Recursively process children
        if (vdomTree.cn && Array.isArray(vdomTree.cn)) {
            vdomTree.cn = vdomTree.cn.map((child, index) =>
                me.processVdomForComponents(child, parentId, index, vnodeMap)
            )
        }

        // Preservation: if this node matches an existing node in the persistent VNODE by ID,
        // copy over the scroll state. The VNODE is the source of truth for scroll state
        // as it is updated directly by onScrollCapture (Main Thread -> App Worker).
        if (vdomTree.id && vnodeMap) {
            const vnode = vnodeMap.get(vdomTree.id);
            if (vnode) {
                if (Neo.isNumber(vnode.scrollTop)) {
                    vdomTree.scrollTop = vnode.scrollTop
                }
                if (Neo.isNumber(vnode.scrollLeft)) {
                    vdomTree.scrollLeft = vnode.scrollLeft
                }
            }
        }

        return vdomTree
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(FunctionalBase));


/***/ },

/***/ "./src/functional/util/html.mjs"
/*!**************************************!*\
  !*** ./src/functional/util/html.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HtmlTemplate: () => (/* binding */ HtmlTemplate),
/* harmony export */   html: () => (/* binding */ html),
/* harmony export */   isHtmlTemplate: () => (/* binding */ isHtmlTemplate)
/* harmony export */ });
const isHtmlTemplate = Symbol.for('neo.isHtmlTemplate');

/**
 * A container for the result of an `html` tagged template literal.
 * It holds the static strings and the dynamic values of the template.
 * @class Neo.functional.util.HtmlTemplate
 */
class HtmlTemplate {
    /**
     * @param {Array<String>} strings The static parts of the template
     * @param {Array<*>} values The dynamic values of the template
     */
    constructor(strings, values) {
        this.strings = strings;
        this.values  = values;
        this[isHtmlTemplate] = true;
    }
}

/**
 * A tagged template literal function that creates an `HtmlTemplate` instance.
 * This function does not perform any parsing or string concatenation itself.
 * It simply captures the template's parts for later processing.
 * @param {Array<String>} strings
 * @param {Array<*>} values
 * @returns {Neo.functional.util.HtmlTemplate} An instance of HtmlTemplate
 */
const html = (strings, ...values) => {
    return new HtmlTemplate(strings, values);
};




/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mdW5jdGlvbmFsX2NvbXBvbmVudF9CYXNlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNPO0FBQ0Y7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsU0FBUyx3REFBVztBQUNwQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQixXQUFXO0FBQzNDO0FBQ0E7QUFDQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUF5QztBQUM3RTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUMsaUJBQWlCLFdBQVc7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbURBQU07O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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QUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSw4QkFBOEIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyaUI5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUU4QyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29yZS9FZmZlY3QubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZnVuY3Rpb25hbC9jb21wb25lbnQvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9mdW5jdGlvbmFsL3V0aWwvaHRtbC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbmZpZyAgICAgICAgZnJvbSAnLi9Db25maWcubWpzJztcbmltcG9ydCBFZmZlY3RNYW5hZ2VyIGZyb20gJy4vRWZmZWN0TWFuYWdlci5tanMnO1xuaW1wb3J0IElkR2VuZXJhdG9yICAgZnJvbSAnLi9JZEdlbmVyYXRvci5tanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBhdXRvbWF0aWNhbGx5IHRyYWNrcyBpdHMgZGVwZW5kZW5jaWVzIGFuZCByZS1ydW5zIHdoZW4gYW55IG9mIHRoZW0gY2hhbmdlLlxuICogVGhpcyBpcyBhIGxpZ2h0d2VpZ2h0LCBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzIGZvciBwZXJmb3JtYW5jZS5cbiAqIEl0IHNlcnZlcyBhcyBhIGNvcmUgcmVhY3RpdmUgcHJpbWl0aXZlLCBlbmFibGluZyBhdXRvbWF0aWMgYW5kIGR5bmFtaWMgZGVwZW5kZW5jeSB0cmFja2luZy5cbiAqIEBjbGFzcyBOZW8uY29yZS5FZmZlY3RcbiAqL1xuY2xhc3MgRWZmZWN0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgY29tcG9uZW50IGlkIHRoaXMgZWZmZWN0IGJlbG9uZ3MgdG8uXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbXBvbmVudElkPW51bGxcbiAgICAgKi9cbiAgICBjb21wb25lbnRJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBBIE1hcCBjb250YWluaW5nIENvbmZpZyBpbnN0YW5jZXMgYXMga2V5cyBhbmQgdGhlaXIgY2xlYW51cCBmdW5jdGlvbnMgYXMgdmFsdWVzLlxuICAgICAqIEBtZW1iZXIge01hcH0gZGVwZW5kZW5jaWVzPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkZXBlbmRlbmNpZXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSBfZm49bnVsbFxuICAgICAqL1xuICAgIF9mbiA9IG51bGxcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZWZmZWN0IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGlkID0gSWRHZW5lcmF0b3IuZ2V0SWQoJ2VmZmVjdCcpXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNEZXN0cm95ZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5jb3JlLkNvbmZpZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNSdW5uaW5nID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciBmblxuICAgICAqL1xuICAgIGdldCBmbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZuXG4gICAgfVxuICAgIHNldCBmbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mbiA9IHZhbHVlO1xuICAgICAgICAvLyBBc3NpZ25pbmcgYSBuZXcgZnVuY3Rpb24gdG8gYGZuYCBhdXRvbWF0aWNhbGx5IHRyaWdnZXJzIGEgcmUtcnVuLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgZWZmZWN0IGltbWVkaWF0ZWx5IHJlLWV2YWx1YXRlcyBpdHMgZGVwZW5kZW5jaWVzXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBuZXcgZnVuY3Rpb24ncyBsb2dpYywgY2xlYXJpbmcgb2xkIGRlcGVuZGVuY2llcyBhbmQgZXN0YWJsaXNoaW5nIG5ldyBvbmVzLlxuICAgICAgICB0aGlzLnJ1bigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9ICBmbiAgICAgICAgICAgICAgLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSwgb3IgYSBjb25maWcgb2JqZWN0IGZvciB0aGUgZWZmZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICBbZm4uZm5dICAgICAgICAgIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIHRoZSBlZmZlY3QgKGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmplY3QpLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICBbZm4uY29tcG9uZW50SWRdIC0gVGhlIGNvbXBvbmVudCBpZCB0aGlzIGVmZmVjdCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICBbZm4ubGF6eT1mYWxzZV0gIC0gSWYgdHJ1ZSwgdGhlIGVmZmVjdCB3aWxsIG5vdCBydW4gaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gW2ZuLnN1YnNjcmliZXJdICAtIEEgc2luZ2xlIHN1YnNjcmliZXIgb3IgYW4gYXJyYXkgb2Ygc3Vic2NyaWJlcnMgZm9yIHRoZSBpc1J1bm5pbmcgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBbb3B0aW9ucz17fV0gICAgIC0gT3B0aW9uYWwuIFVzZWQgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIHRoaXMgb2JqZWN0IGNvbnRhaW5zIHRoZSBvcHRpb25zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2lnbmF0dXJlIDE6IEZ1bmN0aW9uIGFuZCBPcHRpb25zXG4gICAgICogY29uc3QgbXlFZmZlY3QgPSBuZXcgRWZmZWN0KCgpID0+IGNvbnNvbGUubG9nKCdSdW4nKSwge2xhenk6IHRydWV9KTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNpZ25hdHVyZSAyOiBTaW5nbGUgQ29uZmlnIE9iamVjdFxuICAgICAqIGNvbnN0IG15RWZmZWN0ID0gbmV3IEVmZmVjdCh7Zm46ICgpID0+IGNvbnNvbGUubG9nKCdSdW4nKSwgbGF6eTogdHJ1ZX0pO1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZuLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGZuOiBlZmZlY3RGbixcbiAgICAgICAgICAgICAgY29tcG9uZW50SWQsXG4gICAgICAgICAgICAgIGxhenkgPSBmYWxzZSxcbiAgICAgICAgICAgICAgc3Vic2NyaWJlclxuICAgICAgICB9ID0gKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgPyB7IC4uLm9wdGlvbnMsIGZuIH0gOiAoZm4gfHwge30pO1xuXG4gICAgICAgIGlmIChjb21wb25lbnRJZCkge1xuICAgICAgICAgICAgbWUuY29tcG9uZW50SWQgPSBjb21wb25lbnRJZFxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNSdW5uaW5nID0gbmV3IENvbmZpZyhmYWxzZSk7XG5cbiAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIFtdLmNvbmNhdChzdWJzY3JpYmVyKS5mb3JFYWNoKHN1YiA9PiBtZS5pc1J1bm5pbmcuc3Vic2NyaWJlKHN1YikpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF6eSkge1xuICAgICAgICAgICAgbWUuX2ZuID0gZWZmZWN0Rm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmZuID0gZWZmZWN0Rm5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgZGVzdHJveXMgdGhlIGVmZmVjdC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuICAgICAgICBtZS5kZXBlbmRlbmNpZXMuY2xlYXIoKTtcbiAgICAgICAgbWUuaXNEZXN0cm95ZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGVmZmVjdCBmdW5jdGlvbiwgcmUtZXZhbHVhdGluZyBpdHMgZGVwZW5kZW5jaWVzLlxuICAgICAqIElmIHRoZSBFZmZlY3RNYW5hZ2VyIGlzIHBhdXNlZCAoZS5nLiwgaW5zaWRlIGEgYmF0Y2gpLCBpdCBxdWV1ZXMgaXRzZWxmIHRvIGJlIHJ1biBsYXRlci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcnVuKCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcnVubmluZyB3aXRob3V0IGNyZWF0aW5nIGEgZGVwZW5kZW5jeSBvbiBgaXNSdW5uaW5nYC5cbiAgICAgICAgRWZmZWN0TWFuYWdlci5wYXVzZVRyYWNraW5nKCk7XG4gICAgICAgIGNvbnN0IGlzUnVubmluZyA9IG1lLmlzUnVubmluZy5nZXQoKTtcbiAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWVUcmFja2luZygpO1xuXG4gICAgICAgIGlmIChpc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIG1hbmFnZXIgaXMgZ2xvYmFsbHkgcGF1c2VkIGZvciBiYXRjaGluZywgcXVldWUgdGhpcyBlZmZlY3QgYW5kIHN0b3AuXG4gICAgICAgIGlmIChFZmZlY3RNYW5hZ2VyLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucXVldWUobWUpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgYGlzUnVubmluZ2AgdG8gdHJ1ZSB3aXRob3V0IGNyZWF0aW5nIGEgZGVwZW5kZW5jeS5cbiAgICAgICAgRWZmZWN0TWFuYWdlci5wYXVzZVRyYWNraW5nKCk7XG4gICAgICAgIG1lLmlzUnVubmluZy5zZXQodHJ1ZSk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lVHJhY2tpbmcoKTtcblxuICAgICAgICAvLyBDbGVhciBvbGQgZGVwZW5kZW5jaWVzIGFuZCBzZXQgdGhpcyBhcyB0aGUgYWN0aXZlIGVmZmVjdC5cbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuICAgICAgICBtZS5kZXBlbmRlbmNpZXMuY2xlYXIoKTtcbiAgICAgICAgRWZmZWN0TWFuYWdlci5wdXNoKG1lKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgZnVuY3Rpb24sIHdoaWNoIHdpbGwgY29sbGVjdCBuZXcgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgbWUuZm4oKVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYWZ0ZXIgdGhlIHJ1bi5cbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucG9wKCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBgaXNSdW5uaW5nYCB0byBmYWxzZSB3aXRob3V0IGNyZWF0aW5nIGEgZGVwZW5kZW5jeS5cbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2VUcmFja2luZygpO1xuICAgICAgICAgICAgbWUuaXNSdW5uaW5nLnNldChmYWxzZSk7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZVRyYWNraW5nKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBgTmVvLmNvcmUuQ29uZmlnYCBpbnN0YW5jZSBhcyBhIGRlcGVuZGVuY3kgZm9yIHRoaXMgZWZmZWN0LlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQ29uZmlnfSBjb25maWcgVGhlIGNvbmZpZyBpbnN0YW5jZSB0byBzdWJzY3JpYmUgdG8uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFkZERlcGVuZGVuY3koY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmRlcGVuZGVuY2llcy5oYXMoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9IGNvbmZpZy5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIGlkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBmbjogbWUucnVuLmJpbmQobWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuZGVwZW5kZW5jaWVzLnNldChjb25maWcsIGNsZWFudXApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5nYXRla2VlcChFZmZlY3QsICdOZW8uY29yZS5FZmZlY3QnLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBzaG9ydGN1dCB0byBjcmVhdGUgYSBuZXcgTmVvLmNvcmUuRWZmZWN0IGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBOZW8uZWZmZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIG9yIGEgY29uZmlnIG9iamVjdCBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwuIFVzZWQgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkVmZmVjdH1cbiAgICAgKi9cbiAgICBOZW8uZWZmZWN0ID0gKGZuLCBvcHRpb25zKSA9PiBuZXcgRWZmZWN0KGZuLCBvcHRpb25zKVxufSk7XG4iLCJpbXBvcnQgQWJzdHJhY3QgICAgICAgICBmcm9tICcuLi8uLi9jb21wb25lbnQvQWJzdHJhY3QubWpzJztcbmltcG9ydCBFZmZlY3QgICAgICAgICAgIGZyb20gJy4uLy4uL2NvcmUvRWZmZWN0Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0FycmF5Lm1qcyc7XG5pbXBvcnQgVkRvbVV0aWwgICAgICAgICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcbmltcG9ydCB7aXNIdG1sVGVtcGxhdGV9IGZyb20gJy4uL3V0aWwvaHRtbC5tanMnO1xuXG5jb25zdFxuICAgIGFjdGl2ZURvbUxpc3RlbmVyc1N5bWJvbCA9IFN5bWJvbC5mb3IoJ2FjdGl2ZURvbUxpc3RlbmVycycpLFxuICAgIGhvb2tJbmRleFN5bWJvbCAgICAgICAgICA9IFN5bWJvbC5mb3IoJ2hvb2tJbmRleCcpLFxuICAgIGhvb2tzU3ltYm9sICAgICAgICAgICAgICA9IFN5bWJvbC5mb3IoJ2hvb2tzJyksXG4gICAgcGVuZGluZ0RvbUV2ZW50c1N5bWJvbCAgID0gU3ltYm9sLmZvcigncGVuZGluZ0RvbUV2ZW50cycpLFxuICAgIHZkb21Ub0FwcGx5U3ltYm9sICAgICAgICA9IFN5bWJvbCgndmRvbVRvQXBwbHknKTtcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQWJzdHJhY3RcbiAqL1xuY2xhc3MgRnVuY3Rpb25hbEJhc2UgZXh0ZW5kcyBBYnN0cmFjdCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uZnVuY3Rpb25hbC5jb21wb25lbnQuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZW5hYmxlSHRtbFRlbXBsYXRlc189ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgdG8gZW5hYmxlIHVzaW5nIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFscyBmb3IgVkRPTSBjcmVhdGlvblxuICAgICAgICAgKiB2aWEgdGhlIHJlbmRlcigpIG1ldGhvZC4gVGhpcyB3aWxsIGxhenkgbG9hZCB0aGUgaHRtbCBwYXJzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGVIdG1sVGVtcGxhdGVzXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdmdW5jdGlvbmFsLWNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdmdW5jdGlvbmFsLWNvbXBvbmVudCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmRvbSBtYXJrdXAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IHZkb209e31cbiAgICAgICAgICovXG4gICAgICAgIHZkb206IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVvIGNvbXBvbmVudCBpbnN0YW5jZXMsIHdoaWNoIGdvdCBkZWZpbmVkIGluc2lkZSBjcmVhdGVWZG9tKClcbiAgICAgKiBAbWVtYmVyIHtNYXB8bnVsbH0gY2hpbGRDb21wb25lbnRzPW51bGxcbiAgICAgKi9cbiAgICBjaGlsZENvbXBvbmVudHMgPSBudWxsXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TmVvLmZ1bmN0aW9uYWwudXRpbC5IdG1sVGVtcGxhdGVQcm9jZXNzb3J8bnVsbH0gaHRtbFRlbXBsYXRlUHJvY2Vzc29yPW51bGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGh0bWxUZW1wbGF0ZVByb2Nlc3NvciA9IE5lby5ucygnTmVvLmZ1bmN0aW9uYWwudXRpbC5IdG1sVGVtcGxhdGVQcm9jZXNzb3InKVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIE1hcCB0byBzdG9yZSB0aGUgbmV4dCBzZXQgb2YgY29tcG9uZW50cyBhZnRlciB0aGUgY3JlYXRlVmRvbSgpIEVmZmVjdCBoYXMgcnVuLlxuICAgICAqIEBtZW1iZXIge01hcHxudWxsfSBuZXh0Q2hpbGRDb21wb25lbnRzPW51bGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNuZXh0Q2hpbGRDb21wb25lbnRzID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgb3B0cyA9IHtjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZX07XG5cbiAgICAgICAgLy8gVGhlIGJ1aWxkIHByb2Nlc3Mgd2lsbCByZXBsYWNlIGByZW5kZXIoKWAgd2l0aCBgY3JlYXRlVmRvbSgpYC5cbiAgICAgICAgaWYgKE5lby5jb25maWcuZW52aXJvbm1lbnQgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIG1lLmVuYWJsZUh0bWxUZW1wbGF0ZXMgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobWUsIHtcbiAgICAgICAgICAgIFthY3RpdmVEb21MaXN0ZW5lcnNTeW1ib2xdOiB7Li4ub3B0cywgdmFsdWU6IFtdfSxcbiAgICAgICAgICAgIFtob29rSW5kZXhTeW1ib2xdICAgICAgICAgOiB7Li4ub3B0cywgdmFsdWU6IDB9LFxuICAgICAgICAgICAgW2hvb2tzU3ltYm9sXSAgICAgICAgICAgICA6IHsuLi5vcHRzLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW3BlbmRpbmdEb21FdmVudHNTeW1ib2xdICA6IHsuLi5vcHRzLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW3Zkb21Ub0FwcGx5U3ltYm9sXSAgICAgICA6IHsuLi5vcHRzLCB2YWx1ZTogbnVsbH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBhIHJlYWN0aXZlIGVmZmVjdCB0aGF0IHJlLWV4ZWN1dGVzIGNyZWF0ZVZkb20oKSB3aGVuIGRlcGVuZGVuY2llcyBjaGFuZ2UuXG4gICAgICAgIG1lLnZkb21FZmZlY3QgPSBuZXcgRWZmZWN0KHtcbiAgICAgICAgICAgIGZuOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWVbaG9va0luZGV4U3ltYm9sXSAgICAgICAgPSAwO1xuICAgICAgICAgICAgICAgIG1lW3BlbmRpbmdEb21FdmVudHNTeW1ib2xdID0gW107IC8vIENsZWFyIHBlbmRpbmcgZXZlbnRzIGZvciBuZXcgcmVuZGVyXG4gICAgICAgICAgICAgICAgbWVbdmRvbVRvQXBwbHlTeW1ib2xdICAgICAgPSBtZS5jcmVhdGVWZG9tKG1lKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBvbmVudElkOiBtZS5pZCxcbiAgICAgICAgICAgIHN1YnNjcmliZXIgOiB7XG4gICAgICAgICAgICAgICAgaWQgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIGZuICAgOiBtZS5vbkVmZmVjdFJ1blN0YXRlQ2hhbmdlLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgaXNSZWFkeSBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldElzUmVhZHkodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0SXNSZWFkeSh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgbWUubWlzc2VkUmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgbWUudmRvbUVmZmVjdC5ydW4oKTtcbiAgICAgICAgICAgIGRlbGV0ZSBtZS5taXNzZWRSZWFkeVN0YXRlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbCByZWdpc3RyYXRpb24gb2YgRE9NIGV2ZW50IGxpc3RlbmVycyB3aGVuIGNvbXBvbmVudCBtb3VudHNcbiAgICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nRG9tTGlzdGVuZXJzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgd2luZG93SWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldFdpbmRvd0lkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdGhpcy5jaGlsZENvbXBvbmVudHM/LmZvckVhY2goY2hpbGREYXRhID0+IHtcbiAgICAgICAgICAgIGNoaWxkRGF0YS5pbnN0YW5jZS53aW5kb3dJZCA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgcGVuZGluZyBET00gZXZlbnQgbGlzdGVuZXJzIGFuZCB1cGRhdGVzIHRoZSBhY3RpdmUgbGlzdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFwcGx5UGVuZGluZ0RvbUxpc3RlbmVycygpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYWN0aXZlRXZlbnRzICA9IG1lW2FjdGl2ZURvbUxpc3RlbmVyc1N5bWJvbF0sXG4gICAgICAgICAgICBwZW5kaW5nRXZlbnRzID0gbWVbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF07XG5cbiAgICAgICAgaWYgKHBlbmRpbmdFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChhY3RpdmVFdmVudHMsIHBlbmRpbmdFdmVudHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV2ZW50cz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIGR5bmFtaWMgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgICAgIG1lLnJlbW92ZURvbUxpc3RlbmVycyhtZVthY3RpdmVEb21MaXN0ZW5lcnNTeW1ib2xdKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLmFkZERvbUxpc3RlbmVycyhbLi4ucGVuZGluZ0V2ZW50c10pO1xuXG4gICAgICAgICAgICAgICAgbWVbYWN0aXZlRG9tTGlzdGVuZXJzU3ltYm9sXSA9IFsuLi5wZW5kaW5nRXZlbnRzXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGVhciBwZW5kaW5nIGV2ZW50cyBmb3IgbmV4dCBgY3JlYXRlVmRvbSgpYCBFZmZlY3QgcnVuXG4gICAgICAgICAgICBtZVtwZW5kaW5nRG9tRXZlbnRzU3ltYm9sXSA9IFtdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGxpZmVjeWNsZSBob29rIHRoYXQgcnVucyBhZnRlciBhIHN0YXRlIGNoYW5nZSBoYXMgYmVlbiBkZXRlY3RlZCBidXQgYmVmb3JlIHRoZVxuICAgICAqIFZET00gdXBkYXRlIGlzIGRpc3BhdGNoZWQuIEl0IHByb3ZpZGVzIGEgZGVkaWNhdGVkIHBsYWNlIGZvciBsb2dpYyB0aGF0IG5lZWRzIHRvXG4gICAgICogZXhlY3V0ZSBiZWZvcmUgcmVuZGVyaW5nLCBzdWNoIGFzIGNhbGN1bGF0aW5nIGRlcml2ZWQgZGF0YSBvciBjYWNoaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gcHJldmVudCB0aGUgVkRPTSB1cGRhdGUgYnkgcmV0dXJuaW5nIGBmYWxzZWAgZnJvbSB0aGlzIG1ldGhvZC4gVGhpcyBpc1xuICAgICAqIHVzZWZ1bCBmb3IgYWR2YW5jZWQgY2FzZXMgd2hlcmUgeW91IG1pZ2h0IHdhbnQgdG8gbWFudWFsbHkgdHJpZ2dlciBhIGRpZmZlcmVudFxuICAgICAqIHVwZGF0ZSBhZnRlciBtb2RpZnlpbmcgb3RoZXIgY29tcG9uZW50IGNvbmZpZ3MuXG4gICAgICpcbiAgICAgKiAqKklNUE9SVEFOVCoqOiBEbyBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvZiBhbnkgY29uZmlnIHRoYXQgaXMgdXNlZCBhcyBhIGRlcGVuZGVuY3lcbiAgICAgKiB3aXRoaW4gdGhlIGBjcmVhdGVWZG9tYCBtZXRob2QgZnJvbSBpbnNpZGUgdGhpcyBob29rLCBhcyBpdCB3aWxsIGNhdXNlIGFuXG4gICAgICogaW5maW5pdGUgdXBkYXRlIGxvb3AuIFRoaXMgaG9vayBpcyBmb3Igb25lLXdheSBkYXRhIGZsb3csIG5vdCBmb3IgdHJpZ2dlcmluZ1xuICAgICAqIGNhc2NhZGluZyByZWFjdGl2ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58dW5kZWZpbmVkfSBSZXR1cm4gYGZhbHNlYCB0byBjYW5jZWwgdGhlIHVwY29taW5nIFZET00gdXBkYXRlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYmVmb3JlVXBkYXRlKCkge1xuICAgICAqICAgICAvLyBQZXJmb3JtIGFuIGV4cGVuc2l2ZSBjYWxjdWxhdGlvbiBhbmQgY2FjaGUgdGhlIHJlc3VsdCBvbiB0aGUgaW5zdGFuY2VcbiAgICAgKiAgICAgdGhpcy5wcm9jZXNzZWREYXRhID0gdGhpcy5wcm9jZXNzUmF3RGF0YSh0aGlzLnJhd0RhdGEpO1xuICAgICAqXG4gICAgICogICAgIC8vIEV4YW1wbGUgb2YgY29uZGl0aW9uYWxseSBjYW5jZWxsaW5nIGFuIHVwZGF0ZVxuICAgICAqICAgICBpZiAodGhpcy5wcm9jZXNzZWREYXRhLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnZkb20uY24/Lmxlbmd0aCA9PT0gMCkge1xuICAgICAqICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBEb24ndCByZS1yZW5kZXIgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3dcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKi9cbiAgICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIEh0bWxUZW1wbGF0ZVByb2Nlc3NvciBhZnRlciB0aGUgYXN5bmMgcGFyc2luZyBpcyBjb21wbGV0ZS5cbiAgICAgKiBJdCB0aGVuIGNvbnRpbnVlcyB0aGUgY29tcG9uZW50IHVwZGF0ZSBsaWZlY3ljbGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZFZkb20gVGhlIFZET00gb2JqZWN0IHJlY2VpdmVkIGZyb20gdGhlIHBhcnNlciBhZGRvbi5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY29udGludWVVcGRhdGVXaXRoVmRvbShwYXJzZWRWZG9tKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAvLyAxLiBBcHBseSBuZXcgVkRPTSB0byBpbnN0YW5jZSBpbW1lZGlhdGVseSBzbyBnZXRWZG9tUm9vdCgpIHdvcmtzIG9uIHRoZSBuZXcgc3RydWN0dXJlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1lLnZkb20pIGRlbGV0ZSBtZS52ZG9tW2tleV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUudmRvbSwgcGFyc2VkVmRvbSk7XG5cbiAgICAgICAgLy8gMi4gSWRlbnRpZnkgUm9vdCBhbmQgQXBwbHkgSUQgKFVzZXIncyBSZXF1aXJlbWVudClcbiAgICAgICAgY29uc3Qgcm9vdCA9IG1lLmdldFZkb21Sb290KCk7XG5cbiAgICAgICAgaWYgKG1lLmlkKSB7XG4gICAgICAgICAgICByb290LmlkID0gbWUuaWRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIEdlbmVyYXRlIElEcyAobm93IHVzaW5nIGNvcnJlY3Qgcm9vdCBJRCBhcyBwcmVmaXgpXG4gICAgICAgIG1lLmdlbmVyYXRlSWRzKHJvb3QpO1xuXG4gICAgICAgIC8vIDQuIFByZXBhcmUgT3B0aW1pemF0aW9uIE1hcFxuICAgICAgICBjb25zdCB2bm9kZU1hcCA9IG5ldyBNYXAoKTtcblxuICAgICAgICBpZiAobWUudm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcHVsYXRlTWFwID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCkgdm5vZGVNYXAuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGROb2Rlcz8uZm9yRWFjaChwb3B1bGF0ZU1hcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9wdWxhdGVNYXAobWUudm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4gUHJvY2VzcyBDb21wb25lbnRzICYgUHJlc2VydmUgU3RhdGUgKG1vZGlmaWVzIHJvb3QgaW4tcGxhY2UpXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtYXAgZm9yIGNvbXBvbmVudHMgaW5zdGFudGlhdGVkIGluIHRoaXMgcmVuZGVyIGN5Y2xlXG4gICAgICAgIG1lLiNuZXh0Q2hpbGRDb21wb25lbnRzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIG5ld1Zkb20gdG8gaW5zdGFudGlhdGUgY29tcG9uZW50c1xuICAgICAgICAvLyBUaGUgcGFyZW50SWQgZm9yIHRoZXNlIGNvbXBvbmVudHMgd2lsbCBiZSB0aGUgZnVuY3Rpb25hbCBjb21wb25lbnQncyBpZFxuICAgICAgICBjb25zdCBwcm9jZXNzZWRWZG9tID0gbWUucHJvY2Vzc1Zkb21Gb3JDb21wb25lbnRzKHJvb3QsIG1lLmlkLCB1bmRlZmluZWQsIHZub2RlTWFwKTtcblxuICAgICAgICBpZiAocHJvY2Vzc2VkVmRvbSAhPT0gcm9vdCkge1xuICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1lLnZkb20pIGRlbGV0ZSBtZS52ZG9tW2tleV07XG4gICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZS52ZG9tLCBwcm9jZXNzZWRWZG9tKVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyA2LiBDbGVhbnVwIENoaWxkIENvbXBvbmVudHNcbiAgICAgICAgLy8gRGVzdHJveSBjb21wb25lbnRzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50IGluIHRoZSBuZXcgVkRPTVxuICAgICAgICBpZiAobWUuY2hpbGRDb21wb25lbnRzPy5zaXplID4gMCkge1xuICAgICAgICAgICAgWy4uLm1lLmNoaWxkQ29tcG9uZW50c10uZm9yRWFjaCgoW2tleSwgY2hpbGREYXRhXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbWUuI25leHRDaGlsZENvbXBvbmVudHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUuY2hpbGRDb21wb25lbnRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZERhdGEuaW5zdGFuY2UuZGVzdHJveSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDcuIFVwZGF0ZSBDaGlsZCBSZWZlcmVuY2VzXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGNyZWF0ZWQgb3RoZXIgY2xhc3NpYyBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIGluY2x1ZGUgdGhlaXIgZnVsbCB2ZG9tIGludG8gdGhlIG5leHQgdXBkYXRlIGN5Y2xlLlxuICAgICAgICBjb25zdCBvbGRLZXlzID0gbWUuY2hpbGRDb21wb25lbnRzID8gbmV3IFNldChtZS5jaGlsZENvbXBvbmVudHMua2V5cygpKSA6IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGhhc05ld0NoaWxkcmVuID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChjb25zdCBuZXdLZXkgb2YgbWUuI25leHRDaGlsZENvbXBvbmVudHMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoIW9sZEtleXMuaGFzKG5ld0tleSkpIHtcbiAgICAgICAgICAgICAgICBoYXNOZXdDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNOZXdDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gV2hlbiBuZXcgY2hpbGQgY29tcG9uZW50cyBhcmUgY3JlYXRlZCwgd2UgbmVlZCB0byBzZW5kIHRoZWlyIGZ1bGwgVkRPTVxuICAgICAgICAgICAgLy8gdG8gdGhlIHZkb20td29ya2VyLCBzbyB0aGV5IGNhbiBnZXQgcmVuZGVyZWQuXG4gICAgICAgICAgICAvLyBTdWJzZXF1ZW50IHVwZGF0ZXMgd2lsbCBiZSBncmFudWxhciB2aWEgZGlmZkFuZFNldCgpID0+IHNldCgpIG9uIHRoZSBjaGlsZC5cbiAgICAgICAgICAgIG1lLnVwZGF0ZURlcHRoID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1haW4gbWFwIG9mIGluc3RhbnRpYXRlZCBjb21wb25lbnRzXG4gICAgICAgIG1lLmNoaWxkQ29tcG9uZW50cyA9IG1lLiNuZXh0Q2hpbGRDb21wb25lbnRzO1xuXG4gICAgICAgIC8vIDguIENMUyBNZXJnaW5nXG4gICAgICAgIGlmIChtZS5jbHMpIHtcbiAgICAgICAgICAgIHJvb3QuY2xzID0gTmVvQXJyYXkudW5pb24obWUuY2xzLCByb290LmNscylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDkuIFJlc2V0IFN5bWJvbFxuICAgICAgICBtZVt2ZG9tVG9BcHBseVN5bWJvbF0gPSBudWxsO1xuXG4gICAgICAgIC8vIDEwLiBVcGRhdGUgQ2FsbFxuICAgICAgICBpZiAobWUuYmVmb3JlVXBkYXRlKCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtZS51cGRhdGVWZG9tKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDExLiBMaXN0ZW5lcnNcbiAgICAgICAgLy8gVXBkYXRlIERPTSBldmVudCBsaXN0ZW5lcnMgYmFzZWQgb24gdGhlIG5ldyByZW5kZXJcbiAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLmFwcGx5UGVuZGluZ0RvbUxpc3RlbmVycygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbiB5b3VyIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRvIHJldHVybiBpdHMgVkRPTSBzdHJ1Y3R1cmUuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlLWV4ZWN1dGVkIHdoZW4gYW55IG9mIHRoZSBjb21wb25lbnQncyBjb25maWdzIGNoYW5nZS5cbiAgICAgKiBUbyBhY2Nlc3MgZGF0YSBmcm9tIGEgc3RhdGUgcHJvdmlkZXIsIHVzZSBgY29uZmlnLmRhdGFgLlxuICAgICAqIEBwYXJhbSB7TmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2V9IGNvbmZpZyAtIE1lbnRhbCBtb2RlbDogd2hpbGUgaXQgY29udGFpbnMgdGhlIGluc3RhbmNlLCBpdCBtYWtlcyBpdCBjbGVhciB0byBhY2Nlc3MgY29uZmlnc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBWRE9NIHN0cnVjdHVyZSBmb3IgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVWZG9tKGNvbmZpZykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmVuYWJsZUh0bWxUZW1wbGF0ZXMgJiYgdHlwZW9mIG1lLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnJlbmRlcihjb25maWcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt1cGRhdGVQYXJlbnRWZG9tPWZhbHNlXSB0cnVlIHRvIHJlbW92ZSB0aGUgY29tcG9uZW50IGZyb20gdGhlIHBhcmVudCB2ZG9tID0+IHJlYWwgZG9tXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXSB0cnVlIHRvIHVwZGF0ZSB0aGUgdmRvbSBzaWxlbnRseSAodXNlZnVsIGZvciBkZXN0cm95aW5nIG11bHRpcGxlIGNoaWxkIGl0ZW1zIGluIGEgcm93KVxuICAgICAqL1xuICAgIGRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbT1mYWxzZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBtZS52ZG9tRWZmZWN0Py5kZXN0cm95KCk7XG5cbiAgICAgICAgLy8gRGVzdHJveSBhbGwgY2xhc3NpYyBjb21wb25lbnRzIGluc3RhbnRpYXRlZCBieSB0aGlzIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICAgIG1lLmNoaWxkQ29tcG9uZW50cz8uZm9yRWFjaChjaGlsZERhdGEgPT4ge1xuICAgICAgICAgICAgY2hpbGREYXRhLmluc3RhbmNlLmRlc3Ryb3koZmFsc2UsIHRydWUpIC8vIFBhc3Mgc2lsZW50PXRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG1lLmNoaWxkQ29tcG9uZW50cz8uY2xlYXIoKTtcblxuICAgICAgICAvLyBSZW1vdmUgYW55IHBlbmRpbmcgRE9NIGV2ZW50IGxpc3RlbmVycyB0aGF0IG1pZ2h0IG5vdCBoYXZlIGJlZW4gbW91bnRlZFxuICAgICAgICBtZVtwZW5kaW5nRG9tRXZlbnRzU3ltYm9sXSA9IG51bGw7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSh1cGRhdGVQYXJlbnRWZG9tLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmVjdXJzaXZlbHkgY29tcGFyZXMgdGhlIG5ldyBWRE9NIGNvbmZpZyB3aXRoIHRoZSBsYXN0IGFwcGxpZWQgY29uZmlnXG4gICAgICogZm9yIGEgZ2l2ZW4gY29tcG9uZW50IGluc3RhbmNlIGFuZCBpdHMgc3ViLWluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkJhc2V9IGluc3RhbmNlIFRoZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdDb25maWcgVGhlIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHRoZSBWRE9NLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXN0Q29uZmlnIFRoZSBsYXN0IGFwcGxpZWQgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkaWZmQW5kU2V0KGluc3RhbmNlLCBuZXdDb25maWcsIGxhc3RDb25maWcpIHtcbiAgICAgICAgY29uc3QgZGVsdGFDb25maWcgPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdDb25maWcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3Q29uZmlnW2tleV0sXG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGxhc3RDb25maWdba2V5XTtcblxuICAgICAgICAgICAgaWYgKCFOZW8uaXNFcXVhbChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbmZpZyBwcm9wZXJ0eSBpcyBhbiBvYmplY3QgYW5kIGl0IG1hcHMgdG8gYSBzdWItY29tcG9uZW50IGluc3RhbmNlLCByZWN1cnNlLlxuICAgICAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKG5ld1ZhbHVlKSA9PT0gJ09iamVjdCcgJiYgTmVvLnR5cGVPZihpbnN0YW5jZVtrZXldKSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpZmZBbmRTZXQoaW5zdGFuY2Vba2V5XSwgbmV3VmFsdWUsIG9sZFZhbHVlIHx8IHt9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYWRkIGl0IHRvIHRoZSBkZWx0YSB0byBiZSBzZXQgb24gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhQ29uZmlnW2tleV0gPSBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgY2FsbCBzZXQoKSBpZiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVsdGFDb25maWcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldChkZWx0YUNvbmZpZylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGluaXRBc3luYygpIHtcbiAgICAgICAgYXdhaXQgc3VwZXIuaW5pdEFzeW5jKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlSHRtbFRlbXBsYXRlcyAmJiBOZW8uY29uZmlnLmVudmlyb25tZW50ID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBpZiAoIU5lby5ucygnTmVvLmZ1bmN0aW9uYWwudXRpbC5IdG1sVGVtcGxhdGVQcm9jZXNzb3InKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGF3YWl0IGltcG9ydCgnLi4vdXRpbC9IdG1sVGVtcGxhdGVQcm9jZXNzb3IubWpzJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5odG1sVGVtcGxhdGVQcm9jZXNzb3IgPSBtb2R1bGUuZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSBWRE9NIHRyZWUgYW5kIGFzc2lnbnMgZGV0ZXJtaW5pc3RpYyBJRHMgdG8gbm9kZXMgdGhhdCBsYWNrIHRoZW0uXG4gICAgICogVXNlcyBhIFwiU2NvcGVkXCIgc3RyYXRlZ3k6XG4gICAgICogLSBJZiBhIG5vZGUgaGFzIGEgY3VzdG9tIElELCB0aGF0IElEIGJlY29tZXMgdGhlIG5ldyBwcmVmaXggZm9yIGl0cyBkZXNjZW5kYW50cy5cbiAgICAgKiAtIElmIGEgbm9kZSBsYWNrcyBhbiBJRCwgaXQgZ2V0cyBgcHJlZml4ICsgJ19fJyArIGluZGV4YC5cbiAgICAgKiAtIEluZGljZXMgcmVzZXQgZm9yIGVhY2ggbmV3IHNjb3BlIChwcmVmaXgpLlxuICAgICAqXG4gICAgICogVGhpcyBlbnN1cmVzIHRoYXQgaW5zZXJ0aW5nL3JlbW92aW5nIG5vZGVzIG9ubHkgYWZmZWN0cyB0aGUgaW5kaWNlcyB3aXRoaW4gdGhlIGltbWVkaWF0ZVxuICAgICAqIHBhcmVudCBzY29wZSwgd2hpbGUgc3ViLXRyZWVzIHdpdGggY3VzdG9tIElEcyByZW1haW4gc3RhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeD10aGlzLmlkXVxuICAgICAqIEBwYXJhbSB7TWFwfSBbc2NvcGVNYXA9bmV3IE1hcCgpXSBUcmFja3MgdGhlIGNvdW50ZXIgZm9yIGVhY2ggcHJlZml4XG4gICAgICovXG4gICAgZ2VuZXJhdGVJZHModmRvbSwgcHJlZml4PXRoaXMuaWQsIHNjb3BlTWFwPW5ldyBNYXAoKSkge1xuICAgICAgICBpZiAoIXZkb20pIHJldHVybjtcblxuICAgICAgICAvLyBJZiB0aGUgbm9kZSBoYXMgYW4gSUQsIGl0IGJlY29tZXMgdGhlIG5ldyBwcmVmaXggZm9yIGl0cyBjaGlsZHJlblxuICAgICAgICBpZiAodmRvbS5pZCkge1xuICAgICAgICAgICAgcHJlZml4ID0gdmRvbS5pZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBnZW5lcmF0ZSBhbiBJRCBiYXNlZCBvbiB0aGUgY3VycmVudCBwcmVmaXggYW5kIGl0cyBjb3VudGVyXG4gICAgICAgICAgICBsZXQgY291bnQgPSBzY29wZU1hcC5nZXQocHJlZml4KSB8fCAwO1xuICAgICAgICAgICAgdmRvbS5pZCA9IHByZWZpeCArICdfXycgKyBjb3VudDtcbiAgICAgICAgICAgIHNjb3BlTWFwLnNldChwcmVmaXgsIGNvdW50ICsgMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZkb20uY24/LmZvckVhY2goY2hpbGQgPT4gdGhpcy5nZW5lcmF0ZUlkcyhjaGlsZCwgcHJlZml4LCBzY29wZU1hcCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYW5kbGVyIHJ1bnMgd2hlbiB0aGUgZWZmZWN0J3MgYGlzUnVubmluZ2Agc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBJdCBydW5zIG91dHNpZGUgdGhlIGVmZmVjdCdzIHRyYWNraW5nIHNjb3BlLCBwcmV2ZW50aW5nIGZlZWRiYWNrIGxvb3BzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICovXG4gICAgb25FZmZlY3RSdW5TdGF0ZUNoYW5nZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgZWZmZWN0IGhhcyBqdXN0IGZpbmlzaGVkIHJ1bm5pbmcuLi5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICBuZXdWZG9tID0gbWVbdmRvbVRvQXBwbHlTeW1ib2xdO1xuXG4gICAgICAgICAgICBpZiAobmV3VmRvbSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgYW4gSHRtbFRlbXBsYXRlLCBoYW5kIGl0IG9mZiB0byB0aGUgcHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgaWYgKG5ld1Zkb21baXNIdG1sVGVtcGxhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5odG1sVGVtcGxhdGVQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmh0bWxUZW1wbGF0ZVByb2Nlc3Nvci5wcm9jZXNzKG5ld1Zkb20sIG1lKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUubWlzc2VkUmVhZHlTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCeSBjYWxsaW5nIHRoaXMgd2l0aCBhbiBlbXB0eSBvYmplY3QsIHdlIGVuc3VyZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXJzIGEgcGxhY2Vob2xkZXIgRE9NIG5vZGUgZm9yIHRoaXMgY29tcG9uZW50LCB3aGljaCB3ZSBjYW4gdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9wdWxhdGUgbGF0ZXIgb25jZSB0aGUgdGVtcGxhdGUgcHJvY2Vzc29yIGlzIHJlYWR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuY29udGludWVVcGRhdGVXaXRoVmRvbSh7fSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLy8gU3RvcCBleGVjdXRpb24sIHRoZSBwcm9jZXNzb3Igd2lsbCBjYWxsIGJhY2tcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBzdGFuZGFyZCBKU09OLWJhc2VkIFZET00gdXBkYXRlXG4gICAgICAgICAgICAgICAgbWUuY29udGludWVVcGRhdGVXaXRoVmRvbShuZXdWZG9tKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgcHJvY2Vzc2VzIGEgVkRPTSBub2RlIHRvIGluc3RhbnRpYXRlIGNvbXBvbmVudHMgZGVmaW5lZCB3aXRoaW4gaXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZkb21UcmVlIFRoZSBWRE9NIG5vZGUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWQgVGhlIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50ICh0aGUgZnVuY3Rpb25hbCBjb21wb25lbnQgaG9zdGluZyBpdCkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJlbnRJbmRleF0gVGhlIGluZGV4IG9mIHRoZSB2ZG9tTm9kZSB3aXRoaW4gaXRzIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgICAqIEBwYXJhbSB7TWFwPFN0cmluZywgT2JqZWN0Pn0gW3Zub2RlTWFwXSBPcHRpbWl6YXRpb24gbWFwIGZvciBPKDEpIFZOb2RlIGxvb2t1cHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb2Nlc3NlZCBWRE9NIG5vZGUsIHBvdGVudGlhbGx5IHJlcGxhY2VkIHdpdGggYSBjb21wb25lbnQgcmVmZXJlbmNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvY2Vzc1Zkb21Gb3JDb21wb25lbnRzKHZkb21UcmVlLCBwYXJlbnRJZCwgcGFyZW50SW5kZXgsIHZub2RlTWFwKSB7XG4gICAgICAgIGlmICghdmRvbVRyZWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZG9tVHJlZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGEgY29tcG9uZW50IHJlZmVyZW5jZSwgbm8gbmVlZCB0byBwcm9jZXNzIGZ1cnRoZXJcbiAgICAgICAgaWYgKHZkb21UcmVlLmNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmRvbVRyZWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgY29tcG9uZW50IGRlZmluaXRpb24gKGZ1bmN0aW9uYWwgb3IgY2xhc3NpYylcbiAgICAgICAgaWYgKHZkb21UcmVlLmNsYXNzTmFtZSB8fCB2ZG9tVHJlZS5tb2R1bGUgfHwgdmRvbVRyZWUubnR5cGUpIHtcbiAgICAgICAgICAgIC8vIENvbXBvbmVudHMgYXJlIHJlY29uY2lsZWQgYmFzZWQgb24gdGhlaXIgYGlkYCBwcm9wZXJ0eSBpbiB0aGUgVkRPTSBkZWZpbml0aW9uLlxuICAgICAgICAgICAgLy8gSWYgbm8gYGlkYCBpcyBwcm92aWRlZCwgYSBuZXcgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkIG9uIGV2ZXJ5IHJlbmRlci5cbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudEtleSA9IHZkb21UcmVlLmlkO1xuXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudEtleSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbXBvbmVudCBkZWZpbml0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50IFZET00gaXMgbWlzc2luZyBhbiBcImlkXCIuIEZvciBzdGFibGUgcmVjb25jaWxpYXRpb24sICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXNwZWNpYWxseSBpbiBkeW5hbWljIGxpc3RzLCBwcm92aWRlIGEgdW5pcXVlIFwiaWRcIiBwcm9wZXJ0eS4nXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbignJyksXG4gICAgICAgICAgICAgICAgICAgIHZkb21UcmVlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY2hpbGREYXRhID0gbWUuY2hpbGRDb21wb25lbnRzPy5nZXQoY29tcG9uZW50S2V5KSxcbiAgICAgICAgICAgICAgICBuZXdDb25maWcgPSB7Li4udmRvbVRyZWV9LCAvLyBTaGFsbG93IGNvcHlcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTtcblxuICAgICAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5jbGFzc05hbWU7XG4gICAgICAgICAgICBkZWxldGUgbmV3Q29uZmlnLmlkO1xuICAgICAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5tb2R1bGU7XG4gICAgICAgICAgICBkZWxldGUgbmV3Q29uZmlnLm50eXBlO1xuXG4gICAgICAgICAgICBpZiAoIWNoaWxkRGF0YSkge1xuICAgICAgICAgICAgICAgIG1lLmNoaWxkQ29tcG9uZW50cyA/Pz0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gTmVvWyh2ZG9tVHJlZS5jbGFzc05hbWUgfHwgdmRvbVRyZWUubW9kdWxlKSA/ICdjcmVhdGUnIDogJ250eXBlJ10oe1xuICAgICAgICAgICAgICAgICAgICAuLi52ZG9tVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEluZGV4LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dJZDogbWUud2luZG93SWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBjaGlsZERhdGEuaW5zdGFuY2U7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBkaWZmIGFuZCBzZXQgY29uZmlnc1xuICAgICAgICAgICAgICAgIHRoaXMuZGlmZkFuZFNldChpbnN0YW5jZSwgbmV3Q29uZmlnLCBjaGlsZERhdGEubGFzdENvbmZpZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgbmV3IG1hcCBmb3IgdHJhY2tpbmcgaW4gdGhpcyByZW5kZXIgY3ljbGVcbiAgICAgICAgICAgIG1lLiNuZXh0Q2hpbGRDb21wb25lbnRzLnNldChjb21wb25lbnRLZXksIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBsYXN0Q29uZmlnOiBuZXdDb25maWdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBkZWZpbml0aW9uIHdpdGggYSByZWZlcmVuY2UgdXNpbmcgdGhlIGNvbXBvbmVudCdzIG93biBtZXRob2RcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5jcmVhdGVWZG9tUmVmZXJlbmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwcm9jZXNzIGNoaWxkcmVuXG4gICAgICAgIGlmICh2ZG9tVHJlZS5jbiAmJiBBcnJheS5pc0FycmF5KHZkb21UcmVlLmNuKSkge1xuICAgICAgICAgICAgdmRvbVRyZWUuY24gPSB2ZG9tVHJlZS5jbi5tYXAoKGNoaWxkLCBpbmRleCkgPT5cbiAgICAgICAgICAgICAgICBtZS5wcm9jZXNzVmRvbUZvckNvbXBvbmVudHMoY2hpbGQsIHBhcmVudElkLCBpbmRleCwgdm5vZGVNYXApXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVzZXJ2YXRpb246IGlmIHRoaXMgbm9kZSBtYXRjaGVzIGFuIGV4aXN0aW5nIG5vZGUgaW4gdGhlIHBlcnNpc3RlbnQgVk5PREUgYnkgSUQsXG4gICAgICAgIC8vIGNvcHkgb3ZlciB0aGUgc2Nyb2xsIHN0YXRlLiBUaGUgVk5PREUgaXMgdGhlIHNvdXJjZSBvZiB0cnV0aCBmb3Igc2Nyb2xsIHN0YXRlXG4gICAgICAgIC8vIGFzIGl0IGlzIHVwZGF0ZWQgZGlyZWN0bHkgYnkgb25TY3JvbGxDYXB0dXJlIChNYWluIFRocmVhZCAtPiBBcHAgV29ya2VyKS5cbiAgICAgICAgaWYgKHZkb21UcmVlLmlkICYmIHZub2RlTWFwKSB7XG4gICAgICAgICAgICBjb25zdCB2bm9kZSA9IHZub2RlTWFwLmdldCh2ZG9tVHJlZS5pZCk7XG4gICAgICAgICAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzTnVtYmVyKHZub2RlLnNjcm9sbFRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbVRyZWUuc2Nyb2xsVG9wID0gdm5vZGUuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNOdW1iZXIodm5vZGUuc2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmRvbVRyZWUuc2Nyb2xsTGVmdCA9IHZub2RlLnNjcm9sbExlZnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmRvbVRyZWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEZ1bmN0aW9uYWxCYXNlKTtcbiIsImNvbnN0IGlzSHRtbFRlbXBsYXRlID0gU3ltYm9sLmZvcignbmVvLmlzSHRtbFRlbXBsYXRlJyk7XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIHRoZSByZXN1bHQgb2YgYW4gYGh0bWxgIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsLlxuICogSXQgaG9sZHMgdGhlIHN0YXRpYyBzdHJpbmdzIGFuZCB0aGUgZHluYW1pYyB2YWx1ZXMgb2YgdGhlIHRlbXBsYXRlLlxuICogQGNsYXNzIE5lby5mdW5jdGlvbmFsLnV0aWwuSHRtbFRlbXBsYXRlXG4gKi9cbmNsYXNzIEh0bWxUZW1wbGF0ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBzdHJpbmdzIFRoZSBzdGF0aWMgcGFydHMgb2YgdGhlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtBcnJheTwqPn0gdmFsdWVzIFRoZSBkeW5hbWljIHZhbHVlcyBvZiB0aGUgdGVtcGxhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy52YWx1ZXMgID0gdmFsdWVzO1xuICAgICAgICB0aGlzW2lzSHRtbFRlbXBsYXRlXSA9IHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWwgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIGBIdG1sVGVtcGxhdGVgIGluc3RhbmNlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGFueSBwYXJzaW5nIG9yIHN0cmluZyBjb25jYXRlbmF0aW9uIGl0c2VsZi5cbiAqIEl0IHNpbXBseSBjYXB0dXJlcyB0aGUgdGVtcGxhdGUncyBwYXJ0cyBmb3IgbGF0ZXIgcHJvY2Vzc2luZy5cbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gc3RyaW5nc1xuICogQHBhcmFtIHtBcnJheTwqPn0gdmFsdWVzXG4gKiBAcmV0dXJucyB7TmVvLmZ1bmN0aW9uYWwudXRpbC5IdG1sVGVtcGxhdGV9IEFuIGluc3RhbmNlIG9mIEh0bWxUZW1wbGF0ZVxuICovXG5jb25zdCBodG1sID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4ge1xuICAgIHJldHVybiBuZXcgSHRtbFRlbXBsYXRlKHN0cmluZ3MsIHZhbHVlcyk7XG59O1xuXG5leHBvcnQgeyBodG1sLCBpc0h0bWxUZW1wbGF0ZSwgSHRtbFRlbXBsYXRlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9