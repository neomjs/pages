"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_functional_component_Base_mjs"],{

/***/ "./src/core/Effect.mjs":
/*!*****************************!*\
  !*** ./src/core/Effect.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");




/**
 * Creates a reactive effect that automatically tracks its dependencies and re-runs when any of them change.
 * This is a lightweight, plain JavaScript class for performance.
 * It serves as a core reactive primitive, enabling automatic and dynamic dependency tracking.
 * @class Neo.core.Effect
 */
class Effect {
    /**
     * The optional component id this effect belongs to.
     * @member {String|null} componentId=null
     */
    componentId = null
    /**
     * A Map containing Config instances as keys and their cleanup functions as values.
     * @member {Map} dependencies=new Map()
     * @protected
     */
    dependencies = new Map()
    /**
     * The function to execute.
     * @member {Function|null} _fn=null
     */
    _fn = null
    /**
     * The unique identifier for this effect instance.
     * @member {String|null}
     */
    id = _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getId('effect')
    /**
     * @member {Boolean}
     * @protected
     */
    isDestroyed = false
    /**
     * @member {Neo.core.Config}
     * @protected
     */
    isRunning = null

    /**
     * @member fn
     */
    get fn() {
        return this._fn
    }
    set fn(value) {
        this._fn = value;
        // Assigning a new function to `fn` automatically triggers a re-run.
        // This ensures that the effect immediately re-evaluates its dependencies
        // based on the new function's logic, clearing old dependencies and establishing new ones.
        this.run()
    }

    /**
     * @param {Function|Object}  fn              - The function to execute, or a config object for the effect.
     * @param {Function}        [fn.fn]          - The function to execute for the effect (if the first argument is an object).
     * @param {String}          [fn.componentId] - The component id this effect belongs to.
     * @param {Boolean}         [fn.lazy=false]  - If true, the effect will not run immediately upon creation.
     * @param {Object|Object[]} [fn.subscriber]  - A single subscriber or an array of subscribers for the isRunning config.
     * @param {Object}          [options={}]     - Optional. Used if the first argument is a function, this object contains the options.
     * @example
     * // Signature 1: Function and Options
     * const myEffect = new Effect(() => console.log('Run'), {lazy: true});
     * @example
     * // Signature 2: Single Config Object
     * const myEffect = new Effect({fn: () => console.log('Run'), lazy: true});
     */
    constructor(fn, options={}) {
        const me = this;

        const {
              fn: effectFn,
              componentId,
              lazy = false,
              subscriber
        } = (typeof fn === 'function') ? { ...options, fn } : (fn || {});

        if (componentId) {
            me.componentId = componentId
        }

        me.isRunning = new _Config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](false);

        if (subscriber) {
            [].concat(subscriber).forEach(sub => me.isRunning.subscribe(sub))
        }

        if (lazy) {
            me._fn = effectFn
        } else {
            me.fn = effectFn
        }
    }

    /**
     * Cleans up all subscriptions and destroys the effect.
     */
    destroy() {
        const me = this;

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        me.isDestroyed = true
    }

    /**
     * Executes the effect function, re-evaluating its dependencies.
     * If the EffectManager is paused (e.g., inside a batch), it queues itself to be run later.
     * @protected
     */
    run() {
        const me = this;

        if (me.isDestroyed) {
            return
        }

        // Check if already running without creating a dependency on `isRunning`.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        const isRunning = me.isRunning.get();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        if (isRunning) {
            return
        }

        // If the manager is globally paused for batching, queue this effect and stop.
        if (_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isPaused()) {
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].queue(me);
            return
        }

        // Set `isRunning` to true without creating a dependency.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        me.isRunning.set(true);
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        // Clear old dependencies and set this as the active effect.
        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].push(me);

        try {
            // Execute the function, which will collect new dependencies.
            me.fn()
        } finally {
            // Clean up after the run.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pop();

            // Set `isRunning` to false without creating a dependency.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
            me.isRunning.set(false);
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking()
        }
    }

    /**
     * Adds a `Neo.core.Config` instance as a dependency for this effect.
     * @param {Neo.core.Config} config The config instance to subscribe to.
     * @protected
     */
    addDependency(config) {
        const me = this;

        if (!me.dependencies.has(config)) {
            const cleanup = config.subscribe({
                id: me.id,
                fn: me.run.bind(me)
            });

            me.dependencies.set(config, cleanup)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Effect, 'Neo.core.Effect', () => {
    /**
     * Factory shortcut to create a new Neo.core.Effect instance.
     * @function Neo.effect
     * @param {Function|Object} fn - The function to execute, or a config object for the effect.
     * @param {Object} [options] - Optional. Used if the first argument is a function.
     * @returns {Neo.core.Effect}
     */
    Neo.effect = (fn, options) => new Effect(fn, options)
}));


/***/ }),

/***/ "./src/functional/component/Base.mjs":
/*!*******************************************!*\
  !*** ./src/functional/component/Base.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Abstract.mjs */ "./src/component/Abstract.mjs");
/* harmony import */ var _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/Effect.mjs */ "./src/core/Effect.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _util_html_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/html.mjs */ "./src/functional/util/html.mjs");





const
    activeDomListenersSymbol = Symbol.for('activeDomListeners'),
    hookIndexSymbol          = Symbol.for('hookIndex'),
    hooksSymbol              = Symbol.for('hooks'),
    pendingDomEventsSymbol   = Symbol.for('pendingDomEvents'),
    vdomToApplySymbol        = Symbol('vdomToApply');

/**
 * @class Neo.functional.component.Base
 * @extends Neo.component.Abstract
 */
class FunctionalBase extends _component_Abstract_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.functional.component.Base'
         * @protected
         */
        className: 'Neo.functional.component.Base',
        /**
         * @member {Boolean} enableHtmlTemplates_=false
         * @reactive
         * Set this to true to enable using tagged template literals for VDOM creation
         * via the render() method. This will lazy load the html parser.
         */
        enableHtmlTemplates_: false,
        /**
         * @member {String} ntype='functional-component'
         * @protected
         */
        ntype: 'functional-component',
        /**
         * The vdom markup for this component.
         * @member {Object} vdom={}
         */
        vdom: {}
    }

    /**
     * Neo component instances, which got defined inside createVdom()
     * @member {Map|null} childComponents=null
     */
    childComponents = null
    /**
     * @member {Neo.functional.util.HtmlTemplateProcessor|null} htmlTemplateProcessor=null
     * @private
     */
    htmlTemplateProcessor = Neo.ns('Neo.functional.util.HtmlTemplateProcessor')
    /**
     * Internal Map to store the next set of components after the createVdom() Effect has run.
     * @member {Map|null} nextChildComponents=null
     * @private
     */
    #nextChildComponents = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me   = this,
            opts = {configurable: true, enumerable: false, writable: true};

        // The build process will replace `render()` with `createVdom()`.
        if (Neo.config.environment !== 'development') {
            me.enableHtmlTemplates = false
        }

        Object.defineProperties(me, {
            [activeDomListenersSymbol]: {...opts, value: []},
            [hookIndexSymbol]         : {...opts, value: 0},
            [hooksSymbol]             : {...opts, value: []},
            [pendingDomEventsSymbol]  : {...opts, value: []},
            [vdomToApplySymbol]       : {...opts, value: null}
        });

        // Creates a reactive effect that re-executes createVdom() when dependencies change.
        me.vdomEffect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]({
            fn: () => {
                me[hookIndexSymbol]        = 0;
                me[pendingDomEventsSymbol] = []; // Clear pending events for new render
                me[vdomToApplySymbol]      = me.createVdom(me)
            },
            componentId: me.id,
            subscriber : {
                id   : me.id,
                fn   : me.onEffectRunStateChange,
                scope: me
            }
        })
    }

    /**
     * Triggered after the isReady config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetIsReady(value, oldValue) {
        const me = this;

        if (value && me.missedReadyState) {
            me.vdomEffect.run();
            delete me.missedReadyState
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        if (value && oldValue !== undefined) {
            // Initial registration of DOM event listeners when component mounts
            this.applyPendingDomListeners()
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        this.childComponents?.forEach(childData => {
            childData.instance.windowId = value
        })
    }

    /**
     * Applies the pending DOM event listeners and updates the active list.
     * @private
     */
    applyPendingDomListeners() {
        const
            me            = this,
            activeEvents  = me[activeDomListenersSymbol],
            pendingEvents = me[pendingDomEventsSymbol];

        if (pendingEvents.length > 0) {
            if (!Neo.isEqual(activeEvents, pendingEvents)) {
                if (activeEvents?.length > 0) {
                    // Remove old dynamic listeners
                    me.removeDomListeners(me[activeDomListenersSymbol])
                }

                me.addDomListeners([...pendingEvents]);

                me[activeDomListenersSymbol] = [...pendingEvents]
            }

            // Clear pending events for next `createVdom()` Effect run
            me[pendingDomEventsSymbol] = []
        }
    }

    /**
     * A lifecycle hook that runs after a state change has been detected but before the
     * VDOM update is dispatched. It provides a dedicated place for logic that needs to
     * execute before rendering, such as calculating derived data or caching values.
     *
     * You can prevent the VDOM update by returning `false` from this method. This is
     * useful for advanced cases where you might want to manually trigger a different
     * update after modifying other component configs.
     *
     * **IMPORTANT**: Do not change the value of any config that is used as a dependency
     * within the `createVdom` method from inside this hook, as it will cause an
     * infinite update loop. This hook is for one-way data flow, not for triggering
     * cascading reactive changes.
     *
     * @returns {Boolean|undefined} Return `false` to cancel the upcoming VDOM update.
     * @example
     * beforeUpdate() {
     *     // Perform an expensive calculation and cache the result on the instance
     *     this.processedData = this.processRawData(this.rawData);
     *
     *     // Example of conditionally cancelling an update
     *     if (this.processedData.length === 0 && this.vdom.cn?.length === 0) {
     *         return false; // Don't re-render if there's nothing to show
     *     }
     * }
     */
    beforeUpdate() {
        // This method can be overridden by subclasses
    }

    /**
     * This method is called by the HtmlTemplateProcessor after the async parsing is complete.
     * It then continues the component update lifecycle.
     * @param {Object} parsedVdom The VDOM object received from the parser addon.
     * @protected
     */
    continueUpdateWithVdom(parsedVdom) {
        const me = this;

        // Create a new map for components instantiated in this render cycle
        me.#nextChildComponents = new Map();

        // Process the newVdom to instantiate components
        // The parentId for these components will be the functional component's id
        const processedVdom = me.processVdomForComponents(parsedVdom, me.id);

        // Destroy components that are no longer present in the new VDOM
        if (me.childComponents?.size > 0) {
            [...me.childComponents].forEach(([key, childData]) => {
                if (!me.#nextChildComponents.has(key)) {
                    me.childComponents.delete(key);
                    childData.instance.destroy()
                }
            })
        }

        // If this component created other classic or functional components,
        // include their full vdom into the next update cycle.
        const oldKeys = me.childComponents ? new Set(me.childComponents.keys()) : new Set();
        let hasNewChildren = false;

        for (const newKey of me.#nextChildComponents.keys()) {
            if (!oldKeys.has(newKey)) {
                hasNewChildren = true;
                break
            }
        }

        if (hasNewChildren) {
            // When new child components are created, we need to send their full VDOM
            // to the vdom-worker, so they can get rendered.
            // Subsequent updates will be granular via diffAndSet() => set() on the child.
            me.updateDepth = -1;
        }

        // Update the main map of instantiated components
        me.childComponents = me.#nextChildComponents;

        // Clear the old vdom properties
        for (const key in me.vdom) {
            delete me.vdom[key]
        }

        // Assign the new properties
        Object.assign(me.vdom, processedVdom); // Use processedVdom here

        me[vdomToApplySymbol] = null;

        const root = me.getVdomRoot();

        if (me.cls) {
            root.cls = _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].union(me.cls, root.cls)
        }

        if (me.id) {
            root.id = me.id
        }

        // Re-hydrate the new vdom with stable IDs from the previous vnode tree.
        // This is crucial for functional components where the vdom is recreated on every render,
        // ensuring the diffing algorithm can track nodes correctly.
        me.syncVdomIds();

        if (me.beforeUpdate() !== false) {
            me.updateVdom()
        }

        // Update DOM event listeners based on the new render
        if (me.mounted) {
            me.applyPendingDomListeners()
        }
    }

    /**
     * Override this method in your functional component to return its VDOM structure.
     * This method will be automatically re-executed when any of the component's configs change.
     * To access data from a state provider, use `config.data`.
     * @param {Neo.functional.component.Base} config - Mental model: while it contains the instance, it makes it clear to access configs
     * @returns {Object} The VDOM structure for the component.
     */
    createVdom(config) {
        const me = this;

        if (me.enableHtmlTemplates && typeof me.render === 'function') {
            return me.render(config)
        }

        return {}
    }

    /**
     *
     */
    destroy() {
        const me = this;

        me.vdomEffect?.destroy();

        // Destroy all classic components instantiated by this functional component
        me.childComponents?.forEach(childData => {
            childData.instance.destroy()
        });
        me.childComponents?.clear();

        // Remove any pending DOM event listeners that might not have been mounted
        me[pendingDomEventsSymbol] = null;

        super.destroy()
    }

    /**
     * This method recursively compares the new VDOM config with the last applied config
     * for a given component instance and its sub-instances.
     * @param {Neo.core.Base} instance The component instance to update.
     * @param {Object} newConfig The new configuration object from the VDOM.
     * @param {Object} lastConfig The last applied configuration object.
     * @private
     */
    diffAndSet(instance, newConfig, lastConfig) {
        const deltaConfig = {};

        for (const key in newConfig) {
            const newValue = newConfig[key],
                  oldValue = lastConfig[key];

            if (!Neo.isEqual(newValue, oldValue)) {
                // If the config property is an object and it maps to a sub-component instance, recurse.
                if (Neo.typeOf(newValue) === 'Object' && Neo.typeOf(instance[key]) === 'NeoInstance') {
                    this.diffAndSet(instance[key], newValue, oldValue || {})
                } else {
                    // Otherwise, add it to the delta to be set on the current instance.
                    deltaConfig[key] = newValue
                }
            }
        }

        // Only call set() if there are actual changes for the current instance.
        if (Object.keys(deltaConfig).length > 0) {
            instance.set(deltaConfig)
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async initAsync() {
        await super.initAsync();

        if (this.enableHtmlTemplates && Neo.config.environment === 'development') {
            if (!Neo.ns('Neo.functional.util.HtmlTemplateProcessor')) {
                const module = await __webpack_require__.e(/*! import() */ "vendors-src_functional_util_HtmlTemplateProcessor_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ../util/HtmlTemplateProcessor.mjs */ "./src/functional/util/HtmlTemplateProcessor.mjs"));
                this.htmlTemplateProcessor = module.default
            }
        }
    }

    /**
     * This handler runs when the effect's `isRunning` state changes.
     * It runs outside the effect's tracking scope, preventing feedback loops.
     * @param {Boolean} value
     * @param {Boolean} oldValue
     */
    onEffectRunStateChange(value, oldValue) {
        // When the effect has just finished running...
        if (value === false) {
            const me      = this,
                  newVdom = me[vdomToApplySymbol];

            if (newVdom) {
                // If the result is an HtmlTemplate, hand it off to the processor
                if (newVdom[_util_html_mjs__WEBPACK_IMPORTED_MODULE_3__.isHtmlTemplate]) {
                    if (me.htmlTemplateProcessor) {
                        me.htmlTemplateProcessor.process(newVdom, me)
                    } else {
                        me.missedReadyState = true;
                        // By calling this with an empty object, we ensure that the parent container
                        // renders a placeholder DOM node for this component, which we can then
                        // populate later once the template processor is ready.
                        me.continueUpdateWithVdom({})
                    }
                    return // Stop execution, the processor will call back
                }

                // Continue with the standard JSON-based VDOM update
                me.continueUpdateWithVdom(newVdom)
            }
        }
    }

    /**
     * Recursively processes a VDOM node to instantiate components defined within it.
     * @param {Object} vdomTree The VDOM node to process.
     * @param {String} parentId The ID of the parent component (the functional component hosting it).
     * @param {Number} [parentIndex] The index of the vdomNode within its parent's children.
     * @returns {Object} The processed VDOM node, potentially replaced with a component reference.
     * @private
     */
    processVdomForComponents(vdomTree, parentId, parentIndex) {
        if (!vdomTree) {
            return vdomTree
        }

        // If it's already a component reference, no need to process further
        if (vdomTree.componentId) {
            return vdomTree
        }

        const me = this;

        // Check if it's a component definition (functional or classic)
        if (vdomTree.className || vdomTree.module || vdomTree.ntype) {
            // Components are reconciled based on their `id` property in the VDOM definition.
            // If no `id` is provided, a new instance will be created on every render.
            const componentKey = vdomTree.id;

            if (!componentKey) {
                console.error([
                        'Component definition in functional component VDOM is missing an "id". For stable reconciliation, ',
                        'especially in dynamic lists, provide a unique "id" property.'
                    ].join(''),
                    vdomTree
                )
            }

            let childData = me.childComponents?.get(componentKey),
                newConfig = {...vdomTree}, // Shallow copy
                instance;

            delete newConfig.className;
            delete newConfig.id;
            delete newConfig.module;
            delete newConfig.ntype;

            if (!childData) {
                me.childComponents ??= new Map();

                // Instantiate the component
                instance = Neo[(vdomTree.className || vdomTree.module) ? 'create' : 'ntype']({
                    ...vdomTree,
                    parentId,
                    parentIndex,
                    windowId: me.windowId
                });
            } else {
                instance = childData.instance;

                // Recursively diff and set configs
                this.diffAndSet(instance, newConfig, childData.lastConfig);
            }

            // Add to the new map for tracking in this render cycle
            me.#nextChildComponents.set(componentKey, {
                instance,
                lastConfig: newConfig
            });

            // Replace the definition with a reference using the component's own method
            return instance.createVdomReference();
        }

        // Recursively process children
        if (vdomTree.cn && Array.isArray(vdomTree.cn)) {
            vdomTree.cn = vdomTree.cn.map((child, index) =>
                me.processVdomForComponents(child, parentId, index)
            )
        }

        return vdomTree
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(FunctionalBase));


/***/ }),

/***/ "./src/functional/util/html.mjs":
/*!**************************************!*\
  !*** ./src/functional/util/html.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HtmlTemplate: () => (/* binding */ HtmlTemplate),
/* harmony export */   html: () => (/* binding */ html),
/* harmony export */   isHtmlTemplate: () => (/* binding */ isHtmlTemplate)
/* harmony export */ });
const isHtmlTemplate = Symbol.for('neo.isHtmlTemplate');

/**
 * A container for the result of an `html` tagged template literal.
 * It holds the static strings and the dynamic values of the template.
 * @class Neo.functional.util.HtmlTemplate
 */
class HtmlTemplate {
    /**
     * @param {Array<String>} strings The static parts of the template
     * @param {Array<*>} values The dynamic values of the template
     */
    constructor(strings, values) {
        this.strings = strings;
        this.values  = values;
        this[isHtmlTemplate] = true;
    }
}

/**
 * A tagged template literal function that creates an `HtmlTemplate` instance.
 * This function does not perform any parsing or string concatenation itself.
 * It simply captures the template's parts for later processing.
 * @param {Array<String>} strings
 * @param {Array<*>} values
 * @returns {Neo.functional.util.HtmlTemplate} An instance of HtmlTemplate
 */
const html = (strings, ...values) => {
    return new HtmlTemplate(strings, values);
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19mdW5jdGlvbmFsX2NvbXBvbmVudF9CYXNlX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ087QUFDRjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxTQUFTLHdEQUFXO0FBQ3BCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCLFdBQVc7QUFDM0M7QUFDQTtBQUNBLDhEQUE4RCxXQUFXO0FBQ3pFO0FBQ0E7QUFDQSxvQ0FBb0MseUNBQXlDO0FBQzdFO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQyxpQkFBaUIsV0FBVzs7QUFFdkU7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixtREFBTTs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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QUFDMUM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDhCQUE4QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9kOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsVUFBVTtBQUNyQixhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvRWZmZWN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Z1bmN0aW9uYWwvY29tcG9uZW50L0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvZnVuY3Rpb25hbC91dGlsL2h0bWwubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb25maWcgICAgICAgIGZyb20gJy4vQ29uZmlnLm1qcyc7XG5pbXBvcnQgRWZmZWN0TWFuYWdlciBmcm9tICcuL0VmZmVjdE1hbmFnZXIubWpzJztcbmltcG9ydCBJZEdlbmVyYXRvciAgIGZyb20gJy4vSWRHZW5lcmF0b3IubWpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgYXV0b21hdGljYWxseSB0cmFja3MgaXRzIGRlcGVuZGVuY2llcyBhbmQgcmUtcnVucyB3aGVuIGFueSBvZiB0aGVtIGNoYW5nZS5cbiAqIFRoaXMgaXMgYSBsaWdodHdlaWdodCwgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcyBmb3IgcGVyZm9ybWFuY2UuXG4gKiBJdCBzZXJ2ZXMgYXMgYSBjb3JlIHJlYWN0aXZlIHByaW1pdGl2ZSwgZW5hYmxpbmcgYXV0b21hdGljIGFuZCBkeW5hbWljIGRlcGVuZGVuY3kgdHJhY2tpbmcuXG4gKiBAY2xhc3MgTmVvLmNvcmUuRWZmZWN0XG4gKi9cbmNsYXNzIEVmZmVjdCB7XG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGNvbXBvbmVudCBpZCB0aGlzIGVmZmVjdCBiZWxvbmdzIHRvLlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb21wb25lbnRJZD1udWxsXG4gICAgICovXG4gICAgY29tcG9uZW50SWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQSBNYXAgY29udGFpbmluZyBDb25maWcgaW5zdGFuY2VzIGFzIGtleXMgYW5kIHRoZWlyIGNsZWFudXAgZnVuY3Rpb25zIGFzIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyIHtNYXB9IGRlcGVuZGVuY2llcz1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb258bnVsbH0gX2ZuPW51bGxcbiAgICAgKi9cbiAgICBfZm4gPSBudWxsXG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGVmZmVjdCBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBpZCA9IElkR2VuZXJhdG9yLmdldElkKCdlZmZlY3QnKVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzRGVzdHJveWVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5Db25maWd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzUnVubmluZyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgZm5cbiAgICAgKi9cbiAgICBnZXQgZm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mblxuICAgIH1cbiAgICBzZXQgZm4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZm4gPSB2YWx1ZTtcbiAgICAgICAgLy8gQXNzaWduaW5nIGEgbmV3IGZ1bmN0aW9uIHRvIGBmbmAgYXV0b21hdGljYWxseSB0cmlnZ2VycyBhIHJlLXJ1bi5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGVmZmVjdCBpbW1lZGlhdGVseSByZS1ldmFsdWF0ZXMgaXRzIGRlcGVuZGVuY2llc1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgbmV3IGZ1bmN0aW9uJ3MgbG9naWMsIGNsZWFyaW5nIG9sZCBkZXBlbmRlbmNpZXMgYW5kIGVzdGFibGlzaGluZyBuZXcgb25lcy5cbiAgICAgICAgdGhpcy5ydW4oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSAgZm4gICAgICAgICAgICAgIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIG9yIGEgY29uZmlnIG9iamVjdCBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgW2ZuLmZuXSAgICAgICAgICAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciB0aGUgZWZmZWN0IChpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0KS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgW2ZuLmNvbXBvbmVudElkXSAtIFRoZSBjb21wb25lbnQgaWQgdGhpcyBlZmZlY3QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW2ZuLmxhenk9ZmFsc2VdICAtIElmIHRydWUsIHRoZSBlZmZlY3Qgd2lsbCBub3QgcnVuIGltbWVkaWF0ZWx5IHVwb24gY3JlYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IFtmbi5zdWJzY3JpYmVyXSAgLSBBIHNpbmdsZSBzdWJzY3JpYmVyIG9yIGFuIGFycmF5IG9mIHN1YnNjcmliZXJzIGZvciB0aGUgaXNSdW5uaW5nIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnM9e31dICAgICAtIE9wdGlvbmFsLiBVc2VkIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCB0aGlzIG9iamVjdCBjb250YWlucyB0aGUgb3B0aW9ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNpZ25hdHVyZSAxOiBGdW5jdGlvbiBhbmQgT3B0aW9uc1xuICAgICAqIGNvbnN0IG15RWZmZWN0ID0gbmV3IEVmZmVjdCgoKSA9PiBjb25zb2xlLmxvZygnUnVuJyksIHtsYXp5OiB0cnVlfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaWduYXR1cmUgMjogU2luZ2xlIENvbmZpZyBPYmplY3RcbiAgICAgKiBjb25zdCBteUVmZmVjdCA9IG5ldyBFZmZlY3Qoe2ZuOiAoKSA9PiBjb25zb2xlLmxvZygnUnVuJyksIGxhenk6IHRydWV9KTtcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihmbiwgb3B0aW9ucz17fSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBmbjogZWZmZWN0Rm4sXG4gICAgICAgICAgICAgIGNvbXBvbmVudElkLFxuICAgICAgICAgICAgICBsYXp5ID0gZmFsc2UsXG4gICAgICAgICAgICAgIHN1YnNjcmliZXJcbiAgICAgICAgfSA9ICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpID8geyAuLi5vcHRpb25zLCBmbiB9IDogKGZuIHx8IHt9KTtcblxuICAgICAgICBpZiAoY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIG1lLmNvbXBvbmVudElkID0gY29tcG9uZW50SWRcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzUnVubmluZyA9IG5ldyBDb25maWcoZmFsc2UpO1xuXG4gICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBbXS5jb25jYXQoc3Vic2NyaWJlcikuZm9yRWFjaChzdWIgPT4gbWUuaXNSdW5uaW5nLnN1YnNjcmliZShzdWIpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhenkpIHtcbiAgICAgICAgICAgIG1lLl9mbiA9IGVmZmVjdEZuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5mbiA9IGVmZmVjdEZuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGRlc3Ryb3lzIHRoZSBlZmZlY3QuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIG1lLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBlZmZlY3QgZnVuY3Rpb24sIHJlLWV2YWx1YXRpbmcgaXRzIGRlcGVuZGVuY2llcy5cbiAgICAgKiBJZiB0aGUgRWZmZWN0TWFuYWdlciBpcyBwYXVzZWQgKGUuZy4sIGluc2lkZSBhIGJhdGNoKSwgaXQgcXVldWVzIGl0c2VsZiB0byBiZSBydW4gbGF0ZXIuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHJ1bm5pbmcgd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kgb24gYGlzUnVubmluZ2AuXG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2VUcmFja2luZygpO1xuICAgICAgICBjb25zdCBpc1J1bm5pbmcgPSBtZS5pc1J1bm5pbmcuZ2V0KCk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lVHJhY2tpbmcoKTtcblxuICAgICAgICBpZiAoaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBtYW5hZ2VyIGlzIGdsb2JhbGx5IHBhdXNlZCBmb3IgYmF0Y2hpbmcsIHF1ZXVlIHRoaXMgZWZmZWN0IGFuZCBzdG9wLlxuICAgICAgICBpZiAoRWZmZWN0TWFuYWdlci5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnF1ZXVlKG1lKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGBpc1J1bm5pbmdgIHRvIHRydWUgd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kuXG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2VUcmFja2luZygpO1xuICAgICAgICBtZS5pc1J1bm5pbmcuc2V0KHRydWUpO1xuICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZVRyYWNraW5nKCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgb2xkIGRlcGVuZGVuY2llcyBhbmQgc2V0IHRoaXMgYXMgdGhlIGFjdGl2ZSBlZmZlY3QuXG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucHVzaChtZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGNvbGxlY3QgbmV3IGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgIG1lLmZuKClcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFmdGVyIHRoZSBydW4uXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnBvcCgpO1xuXG4gICAgICAgICAgICAvLyBTZXQgYGlzUnVubmluZ2AgdG8gZmFsc2Ugd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kuXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICAgIG1lLmlzUnVubmluZy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWVUcmFja2luZygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYE5lby5jb3JlLkNvbmZpZ2AgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGlzIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkNvbmZpZ30gY29uZmlnIFRoZSBjb25maWcgaW5zdGFuY2UgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZGREZXBlbmRlbmN5KGNvbmZpZykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5kZXBlbmRlbmNpZXMuaGFzKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBjb25maWcuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBpZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgZm46IG1lLnJ1bi5iaW5kKG1lKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmRlcGVuZGVuY2llcy5zZXQoY29uZmlnLCBjbGVhbnVwKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uZ2F0ZWtlZXAoRWZmZWN0LCAnTmVvLmNvcmUuRWZmZWN0JywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEZhY3Rvcnkgc2hvcnRjdXQgdG8gY3JlYXRlIGEgbmV3IE5lby5jb3JlLkVmZmVjdCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gTmVvLmVmZmVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBmbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLCBvciBhIGNvbmZpZyBvYmplY3QgZm9yIHRoZSBlZmZlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsLiBVc2VkIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5FZmZlY3R9XG4gICAgICovXG4gICAgTmVvLmVmZmVjdCA9IChmbiwgb3B0aW9ucykgPT4gbmV3IEVmZmVjdChmbiwgb3B0aW9ucylcbn0pO1xuIiwiaW1wb3J0IEFic3RyYWN0ICAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Fic3RyYWN0Lm1qcyc7XG5pbXBvcnQgRWZmZWN0ICAgICAgICAgICBmcm9tICcuLi8uLi9jb3JlL0VmZmVjdC5tanMnO1xuaW1wb3J0IE5lb0FycmF5ICAgICAgICAgZnJvbSAnLi4vLi4vdXRpbC9BcnJheS5tanMnO1xuaW1wb3J0IHtpc0h0bWxUZW1wbGF0ZX0gZnJvbSAnLi4vdXRpbC9odG1sLm1qcyc7XG5cbmNvbnN0XG4gICAgYWN0aXZlRG9tTGlzdGVuZXJzU3ltYm9sID0gU3ltYm9sLmZvcignYWN0aXZlRG9tTGlzdGVuZXJzJyksXG4gICAgaG9va0luZGV4U3ltYm9sICAgICAgICAgID0gU3ltYm9sLmZvcignaG9va0luZGV4JyksXG4gICAgaG9va3NTeW1ib2wgICAgICAgICAgICAgID0gU3ltYm9sLmZvcignaG9va3MnKSxcbiAgICBwZW5kaW5nRG9tRXZlbnRzU3ltYm9sICAgPSBTeW1ib2wuZm9yKCdwZW5kaW5nRG9tRXZlbnRzJyksXG4gICAgdmRvbVRvQXBwbHlTeW1ib2wgICAgICAgID0gU3ltYm9sKCd2ZG9tVG9BcHBseScpO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZnVuY3Rpb25hbC5jb21wb25lbnQuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbXBvbmVudC5BYnN0cmFjdFxuICovXG5jbGFzcyBGdW5jdGlvbmFsQmFzZSBleHRlbmRzIEFic3RyYWN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5mdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZnVuY3Rpb25hbC5jb21wb25lbnQuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBlbmFibGVIdG1sVGVtcGxhdGVzXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSB0byBlbmFibGUgdXNpbmcgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxzIGZvciBWRE9NIGNyZWF0aW9uXG4gICAgICAgICAqIHZpYSB0aGUgcmVuZGVyKCkgbWV0aG9kLiBUaGlzIHdpbGwgbGF6eSBsb2FkIHRoZSBodG1sIHBhcnNlci5cbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZUh0bWxUZW1wbGF0ZXNfOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2Z1bmN0aW9uYWwtY29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2Z1bmN0aW9uYWwtY29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZG9tIG1hcmt1cCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gdmRvbT17fVxuICAgICAgICAgKi9cbiAgICAgICAgdmRvbToge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZW8gY29tcG9uZW50IGluc3RhbmNlcywgd2hpY2ggZ290IGRlZmluZWQgaW5zaWRlIGNyZWF0ZVZkb20oKVxuICAgICAqIEBtZW1iZXIge01hcHxudWxsfSBjaGlsZENvbXBvbmVudHM9bnVsbFxuICAgICAqL1xuICAgIGNoaWxkQ29tcG9uZW50cyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uZnVuY3Rpb25hbC51dGlsLkh0bWxUZW1wbGF0ZVByb2Nlc3NvcnxudWxsfSBodG1sVGVtcGxhdGVQcm9jZXNzb3I9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaHRtbFRlbXBsYXRlUHJvY2Vzc29yID0gTmVvLm5zKCdOZW8uZnVuY3Rpb25hbC51dGlsLkh0bWxUZW1wbGF0ZVByb2Nlc3NvcicpXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgTWFwIHRvIHN0b3JlIHRoZSBuZXh0IHNldCBvZiBjb21wb25lbnRzIGFmdGVyIHRoZSBjcmVhdGVWZG9tKCkgRWZmZWN0IGhhcyBydW4uXG4gICAgICogQG1lbWJlciB7TWFwfG51bGx9IG5leHRDaGlsZENvbXBvbmVudHM9bnVsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI25leHRDaGlsZENvbXBvbmVudHMgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICA9IHRoaXMsXG4gICAgICAgICAgICBvcHRzID0ge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlfTtcblxuICAgICAgICAvLyBUaGUgYnVpbGQgcHJvY2VzcyB3aWxsIHJlcGxhY2UgYHJlbmRlcigpYCB3aXRoIGBjcmVhdGVWZG9tKClgLlxuICAgICAgICBpZiAoTmVvLmNvbmZpZy5lbnZpcm9ubWVudCAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgbWUuZW5hYmxlSHRtbFRlbXBsYXRlcyA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZSwge1xuICAgICAgICAgICAgW2FjdGl2ZURvbUxpc3RlbmVyc1N5bWJvbF06IHsuLi5vcHRzLCB2YWx1ZTogW119LFxuICAgICAgICAgICAgW2hvb2tJbmRleFN5bWJvbF0gICAgICAgICA6IHsuLi5vcHRzLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICBbaG9va3NTeW1ib2xdICAgICAgICAgICAgIDogey4uLm9wdHMsIHZhbHVlOiBbXX0sXG4gICAgICAgICAgICBbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF0gIDogey4uLm9wdHMsIHZhbHVlOiBbXX0sXG4gICAgICAgICAgICBbdmRvbVRvQXBwbHlTeW1ib2xdICAgICAgIDogey4uLm9wdHMsIHZhbHVlOiBudWxsfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGVzIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgcmUtZXhlY3V0ZXMgY3JlYXRlVmRvbSgpIHdoZW4gZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgICAgICAgbWUudmRvbUVmZmVjdCA9IG5ldyBFZmZlY3Qoe1xuICAgICAgICAgICAgZm46ICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZVtob29rSW5kZXhTeW1ib2xdICAgICAgICA9IDA7XG4gICAgICAgICAgICAgICAgbWVbcGVuZGluZ0RvbUV2ZW50c1N5bWJvbF0gPSBbXTsgLy8gQ2xlYXIgcGVuZGluZyBldmVudHMgZm9yIG5ldyByZW5kZXJcbiAgICAgICAgICAgICAgICBtZVt2ZG9tVG9BcHBseVN5bWJvbF0gICAgICA9IG1lLmNyZWF0ZVZkb20obWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcG9uZW50SWQ6IG1lLmlkLFxuICAgICAgICAgICAgc3Vic2NyaWJlciA6IHtcbiAgICAgICAgICAgICAgICBpZCAgIDogbWUuaWQsXG4gICAgICAgICAgICAgICAgZm4gICA6IG1lLm9uRWZmZWN0UnVuU3RhdGVDaGFuZ2UsXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBpc1JlYWR5IGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0SXNSZWFkeSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5taXNzZWRSZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBtZS52ZG9tRWZmZWN0LnJ1bigpO1xuICAgICAgICAgICAgZGVsZXRlIG1lLm1pc3NlZFJlYWR5U3RhdGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsIHJlZ2lzdHJhdGlvbiBvZiBET00gZXZlbnQgbGlzdGVuZXJzIHdoZW4gY29tcG9uZW50IG1vdW50c1xuICAgICAgICAgICAgdGhpcy5hcHBseVBlbmRpbmdEb21MaXN0ZW5lcnMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICB0aGlzLmNoaWxkQ29tcG9uZW50cz8uZm9yRWFjaChjaGlsZERhdGEgPT4ge1xuICAgICAgICAgICAgY2hpbGREYXRhLmluc3RhbmNlLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBwZW5kaW5nIERPTSBldmVudCBsaXN0ZW5lcnMgYW5kIHVwZGF0ZXMgdGhlIGFjdGl2ZSBsaXN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXBwbHlQZW5kaW5nRG9tTGlzdGVuZXJzKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhY3RpdmVFdmVudHMgID0gbWVbYWN0aXZlRG9tTGlzdGVuZXJzU3ltYm9sXSxcbiAgICAgICAgICAgIHBlbmRpbmdFdmVudHMgPSBtZVtwZW5kaW5nRG9tRXZlbnRzU3ltYm9sXTtcblxuICAgICAgICBpZiAocGVuZGluZ0V2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKGFjdGl2ZUV2ZW50cywgcGVuZGluZ0V2ZW50cykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXZlbnRzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgZHluYW1pYyBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgbWUucmVtb3ZlRG9tTGlzdGVuZXJzKG1lW2FjdGl2ZURvbUxpc3RlbmVyc1N5bWJvbF0pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFsuLi5wZW5kaW5nRXZlbnRzXSk7XG5cbiAgICAgICAgICAgICAgICBtZVthY3RpdmVEb21MaXN0ZW5lcnNTeW1ib2xdID0gWy4uLnBlbmRpbmdFdmVudHNdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHBlbmRpbmcgZXZlbnRzIGZvciBuZXh0IGBjcmVhdGVWZG9tKClgIEVmZmVjdCBydW5cbiAgICAgICAgICAgIG1lW3BlbmRpbmdEb21FdmVudHNTeW1ib2xdID0gW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbGlmZWN5Y2xlIGhvb2sgdGhhdCBydW5zIGFmdGVyIGEgc3RhdGUgY2hhbmdlIGhhcyBiZWVuIGRldGVjdGVkIGJ1dCBiZWZvcmUgdGhlXG4gICAgICogVkRPTSB1cGRhdGUgaXMgZGlzcGF0Y2hlZC4gSXQgcHJvdmlkZXMgYSBkZWRpY2F0ZWQgcGxhY2UgZm9yIGxvZ2ljIHRoYXQgbmVlZHMgdG9cbiAgICAgKiBleGVjdXRlIGJlZm9yZSByZW5kZXJpbmcsIHN1Y2ggYXMgY2FsY3VsYXRpbmcgZGVyaXZlZCBkYXRhIG9yIGNhY2hpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogWW91IGNhbiBwcmV2ZW50IHRoZSBWRE9NIHVwZGF0ZSBieSByZXR1cm5pbmcgYGZhbHNlYCBmcm9tIHRoaXMgbWV0aG9kLiBUaGlzIGlzXG4gICAgICogdXNlZnVsIGZvciBhZHZhbmNlZCBjYXNlcyB3aGVyZSB5b3UgbWlnaHQgd2FudCB0byBtYW51YWxseSB0cmlnZ2VyIGEgZGlmZmVyZW50XG4gICAgICogdXBkYXRlIGFmdGVyIG1vZGlmeWluZyBvdGhlciBjb21wb25lbnQgY29uZmlncy5cbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UKio6IERvIG5vdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIGFueSBjb25maWcgdGhhdCBpcyB1c2VkIGFzIGEgZGVwZW5kZW5jeVxuICAgICAqIHdpdGhpbiB0aGUgYGNyZWF0ZVZkb21gIG1ldGhvZCBmcm9tIGluc2lkZSB0aGlzIGhvb2ssIGFzIGl0IHdpbGwgY2F1c2UgYW5cbiAgICAgKiBpbmZpbml0ZSB1cGRhdGUgbG9vcC4gVGhpcyBob29rIGlzIGZvciBvbmUtd2F5IGRhdGEgZmxvdywgbm90IGZvciB0cmlnZ2VyaW5nXG4gICAgICogY2FzY2FkaW5nIHJlYWN0aXZlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9IFJldHVybiBgZmFsc2VgIHRvIGNhbmNlbCB0aGUgdXBjb21pbmcgVkRPTSB1cGRhdGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBiZWZvcmVVcGRhdGUoKSB7XG4gICAgICogICAgIC8vIFBlcmZvcm0gYW4gZXhwZW5zaXZlIGNhbGN1bGF0aW9uIGFuZCBjYWNoZSB0aGUgcmVzdWx0IG9uIHRoZSBpbnN0YW5jZVxuICAgICAqICAgICB0aGlzLnByb2Nlc3NlZERhdGEgPSB0aGlzLnByb2Nlc3NSYXdEYXRhKHRoaXMucmF3RGF0YSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gRXhhbXBsZSBvZiBjb25kaXRpb25hbGx5IGNhbmNlbGxpbmcgYW4gdXBkYXRlXG4gICAgICogICAgIGlmICh0aGlzLnByb2Nlc3NlZERhdGEubGVuZ3RoID09PSAwICYmIHRoaXMudmRvbS5jbj8ubGVuZ3RoID09PSAwKSB7XG4gICAgICogICAgICAgICByZXR1cm4gZmFsc2U7IC8vIERvbid0IHJlLXJlbmRlciBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvd1xuICAgICAqICAgICB9XG4gICAgICogfVxuICAgICAqL1xuICAgIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgSHRtbFRlbXBsYXRlUHJvY2Vzc29yIGFmdGVyIHRoZSBhc3luYyBwYXJzaW5nIGlzIGNvbXBsZXRlLlxuICAgICAqIEl0IHRoZW4gY29udGludWVzIHRoZSBjb21wb25lbnQgdXBkYXRlIGxpZmVjeWNsZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkVmRvbSBUaGUgVkRPTSBvYmplY3QgcmVjZWl2ZWQgZnJvbSB0aGUgcGFyc2VyIGFkZG9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjb250aW51ZVVwZGF0ZVdpdGhWZG9tKHBhcnNlZFZkb20pIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtYXAgZm9yIGNvbXBvbmVudHMgaW5zdGFudGlhdGVkIGluIHRoaXMgcmVuZGVyIGN5Y2xlXG4gICAgICAgIG1lLiNuZXh0Q2hpbGRDb21wb25lbnRzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIG5ld1Zkb20gdG8gaW5zdGFudGlhdGUgY29tcG9uZW50c1xuICAgICAgICAvLyBUaGUgcGFyZW50SWQgZm9yIHRoZXNlIGNvbXBvbmVudHMgd2lsbCBiZSB0aGUgZnVuY3Rpb25hbCBjb21wb25lbnQncyBpZFxuICAgICAgICBjb25zdCBwcm9jZXNzZWRWZG9tID0gbWUucHJvY2Vzc1Zkb21Gb3JDb21wb25lbnRzKHBhcnNlZFZkb20sIG1lLmlkKTtcblxuICAgICAgICAvLyBEZXN0cm95IGNvbXBvbmVudHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQgaW4gdGhlIG5ldyBWRE9NXG4gICAgICAgIGlmIChtZS5jaGlsZENvbXBvbmVudHM/LnNpemUgPiAwKSB7XG4gICAgICAgICAgICBbLi4ubWUuY2hpbGRDb21wb25lbnRzXS5mb3JFYWNoKChba2V5LCBjaGlsZERhdGFdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZS4jbmV4dENoaWxkQ29tcG9uZW50cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5jaGlsZENvbXBvbmVudHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRGF0YS5pbnN0YW5jZS5kZXN0cm95KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgY3JlYXRlZCBvdGhlciBjbGFzc2ljIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cyxcbiAgICAgICAgLy8gaW5jbHVkZSB0aGVpciBmdWxsIHZkb20gaW50byB0aGUgbmV4dCB1cGRhdGUgY3ljbGUuXG4gICAgICAgIGNvbnN0IG9sZEtleXMgPSBtZS5jaGlsZENvbXBvbmVudHMgPyBuZXcgU2V0KG1lLmNoaWxkQ29tcG9uZW50cy5rZXlzKCkpIDogbmV3IFNldCgpO1xuICAgICAgICBsZXQgaGFzTmV3Q2hpbGRyZW4gPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5ld0tleSBvZiBtZS4jbmV4dENoaWxkQ29tcG9uZW50cy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmICghb2xkS2V5cy5oYXMobmV3S2V5KSkge1xuICAgICAgICAgICAgICAgIGhhc05ld0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc05ld0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAvLyBXaGVuIG5ldyBjaGlsZCBjb21wb25lbnRzIGFyZSBjcmVhdGVkLCB3ZSBuZWVkIHRvIHNlbmQgdGhlaXIgZnVsbCBWRE9NXG4gICAgICAgICAgICAvLyB0byB0aGUgdmRvbS13b3JrZXIsIHNvIHRoZXkgY2FuIGdldCByZW5kZXJlZC5cbiAgICAgICAgICAgIC8vIFN1YnNlcXVlbnQgdXBkYXRlcyB3aWxsIGJlIGdyYW51bGFyIHZpYSBkaWZmQW5kU2V0KCkgPT4gc2V0KCkgb24gdGhlIGNoaWxkLlxuICAgICAgICAgICAgbWUudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFpbiBtYXAgb2YgaW5zdGFudGlhdGVkIGNvbXBvbmVudHNcbiAgICAgICAgbWUuY2hpbGRDb21wb25lbnRzID0gbWUuI25leHRDaGlsZENvbXBvbmVudHM7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIG9sZCB2ZG9tIHByb3BlcnRpZXNcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWUudmRvbSkge1xuICAgICAgICAgICAgZGVsZXRlIG1lLnZkb21ba2V5XVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXNzaWduIHRoZSBuZXcgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuYXNzaWduKG1lLnZkb20sIHByb2Nlc3NlZFZkb20pOyAvLyBVc2UgcHJvY2Vzc2VkVmRvbSBoZXJlXG5cbiAgICAgICAgbWVbdmRvbVRvQXBwbHlTeW1ib2xdID0gbnVsbDtcblxuICAgICAgICBjb25zdCByb290ID0gbWUuZ2V0VmRvbVJvb3QoKTtcblxuICAgICAgICBpZiAobWUuY2xzKSB7XG4gICAgICAgICAgICByb290LmNscyA9IE5lb0FycmF5LnVuaW9uKG1lLmNscywgcm9vdC5jbHMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWUuaWQpIHtcbiAgICAgICAgICAgIHJvb3QuaWQgPSBtZS5pZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmUtaHlkcmF0ZSB0aGUgbmV3IHZkb20gd2l0aCBzdGFibGUgSURzIGZyb20gdGhlIHByZXZpb3VzIHZub2RlIHRyZWUuXG4gICAgICAgIC8vIFRoaXMgaXMgY3J1Y2lhbCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzIHdoZXJlIHRoZSB2ZG9tIGlzIHJlY3JlYXRlZCBvbiBldmVyeSByZW5kZXIsXG4gICAgICAgIC8vIGVuc3VyaW5nIHRoZSBkaWZmaW5nIGFsZ29yaXRobSBjYW4gdHJhY2sgbm9kZXMgY29ycmVjdGx5LlxuICAgICAgICBtZS5zeW5jVmRvbUlkcygpO1xuXG4gICAgICAgIGlmIChtZS5iZWZvcmVVcGRhdGUoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1lLnVwZGF0ZVZkb20oKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIERPTSBldmVudCBsaXN0ZW5lcnMgYmFzZWQgb24gdGhlIG5ldyByZW5kZXJcbiAgICAgICAgaWYgKG1lLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLmFwcGx5UGVuZGluZ0RvbUxpc3RlbmVycygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbiB5b3VyIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRvIHJldHVybiBpdHMgVkRPTSBzdHJ1Y3R1cmUuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlLWV4ZWN1dGVkIHdoZW4gYW55IG9mIHRoZSBjb21wb25lbnQncyBjb25maWdzIGNoYW5nZS5cbiAgICAgKiBUbyBhY2Nlc3MgZGF0YSBmcm9tIGEgc3RhdGUgcHJvdmlkZXIsIHVzZSBgY29uZmlnLmRhdGFgLlxuICAgICAqIEBwYXJhbSB7TmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2V9IGNvbmZpZyAtIE1lbnRhbCBtb2RlbDogd2hpbGUgaXQgY29udGFpbnMgdGhlIGluc3RhbmNlLCBpdCBtYWtlcyBpdCBjbGVhciB0byBhY2Nlc3MgY29uZmlnc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBWRE9NIHN0cnVjdHVyZSBmb3IgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVWZG9tKGNvbmZpZykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmVuYWJsZUh0bWxUZW1wbGF0ZXMgJiYgdHlwZW9mIG1lLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1lLnJlbmRlcihjb25maWcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBtZS52ZG9tRWZmZWN0Py5kZXN0cm95KCk7XG5cbiAgICAgICAgLy8gRGVzdHJveSBhbGwgY2xhc3NpYyBjb21wb25lbnRzIGluc3RhbnRpYXRlZCBieSB0aGlzIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICAgIG1lLmNoaWxkQ29tcG9uZW50cz8uZm9yRWFjaChjaGlsZERhdGEgPT4ge1xuICAgICAgICAgICAgY2hpbGREYXRhLmluc3RhbmNlLmRlc3Ryb3koKVxuICAgICAgICB9KTtcbiAgICAgICAgbWUuY2hpbGRDb21wb25lbnRzPy5jbGVhcigpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcGVuZGluZyBET00gZXZlbnQgbGlzdGVuZXJzIHRoYXQgbWlnaHQgbm90IGhhdmUgYmVlbiBtb3VudGVkXG4gICAgICAgIG1lW3BlbmRpbmdEb21FdmVudHNTeW1ib2xdID0gbnVsbDtcblxuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZWN1cnNpdmVseSBjb21wYXJlcyB0aGUgbmV3IFZET00gY29uZmlnIHdpdGggdGhlIGxhc3QgYXBwbGllZCBjb25maWdcbiAgICAgKiBmb3IgYSBnaXZlbiBjb21wb25lbnQgaW5zdGFuY2UgYW5kIGl0cyBzdWItaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQmFzZX0gaW5zdGFuY2UgVGhlIGNvbXBvbmVudCBpbnN0YW5jZSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0NvbmZpZyBUaGUgbmV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gdGhlIFZET00uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxhc3RDb25maWcgVGhlIGxhc3QgYXBwbGllZCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpZmZBbmRTZXQoaW5zdGFuY2UsIG5ld0NvbmZpZywgbGFzdENvbmZpZykge1xuICAgICAgICBjb25zdCBkZWx0YUNvbmZpZyA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld0NvbmZpZykge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBuZXdDb25maWdba2V5XSxcbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbGFzdENvbmZpZ1trZXldO1xuXG4gICAgICAgICAgICBpZiAoIU5lby5pc0VxdWFsKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29uZmlnIHByb3BlcnR5IGlzIGFuIG9iamVjdCBhbmQgaXQgbWFwcyB0byBhIHN1Yi1jb21wb25lbnQgaW5zdGFuY2UsIHJlY3Vyc2UuXG4gICAgICAgICAgICAgICAgaWYgKE5lby50eXBlT2YobmV3VmFsdWUpID09PSAnT2JqZWN0JyAmJiBOZW8udHlwZU9mKGluc3RhbmNlW2tleV0pID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlmZkFuZFNldChpbnN0YW5jZVtrZXldLCBuZXdWYWx1ZSwgb2xkVmFsdWUgfHwge30pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgaXQgdG8gdGhlIGRlbHRhIHRvIGJlIHNldCBvbiB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgZGVsdGFDb25maWdba2V5XSA9IG5ld1ZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBjYWxsIHNldCgpIGlmIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcyBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWx0YUNvbmZpZykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0KGRlbHRhQ29uZmlnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgaW5pdEFzeW5jKCkge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0QXN5bmMoKTtcblxuICAgICAgICBpZiAodGhpcy5lbmFibGVIdG1sVGVtcGxhdGVzICYmIE5lby5jb25maWcuZW52aXJvbm1lbnQgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmICghTmVvLm5zKCdOZW8uZnVuY3Rpb25hbC51dGlsLkh0bWxUZW1wbGF0ZVByb2Nlc3NvcicpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gYXdhaXQgaW1wb3J0KCcuLi91dGlsL0h0bWxUZW1wbGF0ZVByb2Nlc3Nvci5tanMnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmh0bWxUZW1wbGF0ZVByb2Nlc3NvciA9IG1vZHVsZS5kZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhhbmRsZXIgcnVucyB3aGVuIHRoZSBlZmZlY3QncyBgaXNSdW5uaW5nYCBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEl0IHJ1bnMgb3V0c2lkZSB0aGUgZWZmZWN0J3MgdHJhY2tpbmcgc2NvcGUsIHByZXZlbnRpbmcgZmVlZGJhY2sgbG9vcHMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkVmZmVjdFJ1blN0YXRlQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyBXaGVuIHRoZSBlZmZlY3QgaGFzIGp1c3QgZmluaXNoZWQgcnVubmluZy4uLlxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgIG5ld1Zkb20gPSBtZVt2ZG9tVG9BcHBseVN5bWJvbF07XG5cbiAgICAgICAgICAgIGlmIChuZXdWZG9tKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlc3VsdCBpcyBhbiBIdG1sVGVtcGxhdGUsIGhhbmQgaXQgb2ZmIHRvIHRoZSBwcm9jZXNzb3JcbiAgICAgICAgICAgICAgICBpZiAobmV3VmRvbVtpc0h0bWxUZW1wbGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmh0bWxUZW1wbGF0ZVByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuaHRtbFRlbXBsYXRlUHJvY2Vzc29yLnByb2Nlc3MobmV3VmRvbSwgbWUpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5taXNzZWRSZWFkeVN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ5IGNhbGxpbmcgdGhpcyB3aXRoIGFuIGVtcHR5IG9iamVjdCwgd2UgZW5zdXJlIHRoYXQgdGhlIHBhcmVudCBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlcnMgYSBwbGFjZWhvbGRlciBET00gbm9kZSBmb3IgdGhpcyBjb21wb25lbnQsIHdoaWNoIHdlIGNhbiB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3B1bGF0ZSBsYXRlciBvbmNlIHRoZSB0ZW1wbGF0ZSBwcm9jZXNzb3IgaXMgcmVhZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5jb250aW51ZVVwZGF0ZVdpdGhWZG9tKHt9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvLyBTdG9wIGV4ZWN1dGlvbiwgdGhlIHByb2Nlc3NvciB3aWxsIGNhbGwgYmFja1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIHN0YW5kYXJkIEpTT04tYmFzZWQgVkRPTSB1cGRhdGVcbiAgICAgICAgICAgICAgICBtZS5jb250aW51ZVVwZGF0ZVdpdGhWZG9tKG5ld1Zkb20pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBwcm9jZXNzZXMgYSBWRE9NIG5vZGUgdG8gaW5zdGFudGlhdGUgY29tcG9uZW50cyBkZWZpbmVkIHdpdGhpbiBpdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmRvbVRyZWUgVGhlIFZET00gbm9kZSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRJZCBUaGUgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQgKHRoZSBmdW5jdGlvbmFsIGNvbXBvbmVudCBob3N0aW5nIGl0KS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmVudEluZGV4XSBUaGUgaW5kZXggb2YgdGhlIHZkb21Ob2RlIHdpdGhpbiBpdHMgcGFyZW50J3MgY2hpbGRyZW4uXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb2Nlc3NlZCBWRE9NIG5vZGUsIHBvdGVudGlhbGx5IHJlcGxhY2VkIHdpdGggYSBjb21wb25lbnQgcmVmZXJlbmNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvY2Vzc1Zkb21Gb3JDb21wb25lbnRzKHZkb21UcmVlLCBwYXJlbnRJZCwgcGFyZW50SW5kZXgpIHtcbiAgICAgICAgaWYgKCF2ZG9tVHJlZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZkb21UcmVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgYSBjb21wb25lbnQgcmVmZXJlbmNlLCBubyBuZWVkIHRvIHByb2Nlc3MgZnVydGhlclxuICAgICAgICBpZiAodmRvbVRyZWUuY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZG9tVHJlZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBjb21wb25lbnQgZGVmaW5pdGlvbiAoZnVuY3Rpb25hbCBvciBjbGFzc2ljKVxuICAgICAgICBpZiAodmRvbVRyZWUuY2xhc3NOYW1lIHx8IHZkb21UcmVlLm1vZHVsZSB8fCB2ZG9tVHJlZS5udHlwZSkge1xuICAgICAgICAgICAgLy8gQ29tcG9uZW50cyBhcmUgcmVjb25jaWxlZCBiYXNlZCBvbiB0aGVpciBgaWRgIHByb3BlcnR5IGluIHRoZSBWRE9NIGRlZmluaXRpb24uXG4gICAgICAgICAgICAvLyBJZiBubyBgaWRgIGlzIHByb3ZpZGVkLCBhIG5ldyBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQgb24gZXZlcnkgcmVuZGVyLlxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50S2V5ID0gdmRvbVRyZWUuaWQ7XG5cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29tcG9uZW50IGRlZmluaXRpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnQgVkRPTSBpcyBtaXNzaW5nIGFuIFwiaWRcIi4gRm9yIHN0YWJsZSByZWNvbmNpbGlhdGlvbiwgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdlc3BlY2lhbGx5IGluIGR5bmFtaWMgbGlzdHMsIHByb3ZpZGUgYSB1bmlxdWUgXCJpZFwiIHByb3BlcnR5LidcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICAgICAgdmRvbVRyZWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjaGlsZERhdGEgPSBtZS5jaGlsZENvbXBvbmVudHM/LmdldChjb21wb25lbnRLZXkpLFxuICAgICAgICAgICAgICAgIG5ld0NvbmZpZyA9IHsuLi52ZG9tVHJlZX0sIC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgICAgICAgIGluc3RhbmNlO1xuXG4gICAgICAgICAgICBkZWxldGUgbmV3Q29uZmlnLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdDb25maWcuaWQ7XG4gICAgICAgICAgICBkZWxldGUgbmV3Q29uZmlnLm1vZHVsZTtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdDb25maWcubnR5cGU7XG5cbiAgICAgICAgICAgIGlmICghY2hpbGREYXRhKSB7XG4gICAgICAgICAgICAgICAgbWUuY2hpbGRDb21wb25lbnRzID8/PSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbnN0YW50aWF0ZSB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBOZW9bKHZkb21UcmVlLmNsYXNzTmFtZSB8fCB2ZG9tVHJlZS5tb2R1bGUpID8gJ2NyZWF0ZScgOiAnbnR5cGUnXSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnZkb21UcmVlLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lkOiBtZS53aW5kb3dJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGNoaWxkRGF0YS5pbnN0YW5jZTtcblxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGRpZmYgYW5kIHNldCBjb25maWdzXG4gICAgICAgICAgICAgICAgdGhpcy5kaWZmQW5kU2V0KGluc3RhbmNlLCBuZXdDb25maWcsIGNoaWxkRGF0YS5sYXN0Q29uZmlnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBuZXcgbWFwIGZvciB0cmFja2luZyBpbiB0aGlzIHJlbmRlciBjeWNsZVxuICAgICAgICAgICAgbWUuI25leHRDaGlsZENvbXBvbmVudHMuc2V0KGNvbXBvbmVudEtleSwge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGxhc3RDb25maWc6IG5ld0NvbmZpZ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGRlZmluaXRpb24gd2l0aCBhIHJlZmVyZW5jZSB1c2luZyB0aGUgY29tcG9uZW50J3Mgb3duIG1ldGhvZFxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLmNyZWF0ZVZkb21SZWZlcmVuY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgY2hpbGRyZW5cbiAgICAgICAgaWYgKHZkb21UcmVlLmNuICYmIEFycmF5LmlzQXJyYXkodmRvbVRyZWUuY24pKSB7XG4gICAgICAgICAgICB2ZG9tVHJlZS5jbiA9IHZkb21UcmVlLmNuLm1hcCgoY2hpbGQsIGluZGV4KSA9PlxuICAgICAgICAgICAgICAgIG1lLnByb2Nlc3NWZG9tRm9yQ29tcG9uZW50cyhjaGlsZCwgcGFyZW50SWQsIGluZGV4KVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZkb21UcmVlXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhGdW5jdGlvbmFsQmFzZSk7XG4iLCJjb25zdCBpc0h0bWxUZW1wbGF0ZSA9IFN5bWJvbC5mb3IoJ25lby5pc0h0bWxUZW1wbGF0ZScpO1xuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciB0aGUgcmVzdWx0IG9mIGFuIGBodG1sYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqIEl0IGhvbGRzIHRoZSBzdGF0aWMgc3RyaW5ncyBhbmQgdGhlIGR5bmFtaWMgdmFsdWVzIG9mIHRoZSB0ZW1wbGF0ZS5cbiAqIEBjbGFzcyBOZW8uZnVuY3Rpb25hbC51dGlsLkh0bWxUZW1wbGF0ZVxuICovXG5jbGFzcyBIdG1sVGVtcGxhdGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gc3RyaW5ncyBUaGUgc3RhdGljIHBhcnRzIG9mIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXk8Kj59IHZhbHVlcyBUaGUgZHluYW1pYyB2YWx1ZXMgb2YgdGhlIHRlbXBsYXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMudmFsdWVzICA9IHZhbHVlcztcbiAgICAgICAgdGhpc1tpc0h0bWxUZW1wbGF0ZV0gPSB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBgSHRtbFRlbXBsYXRlYCBpbnN0YW5jZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBhbnkgcGFyc2luZyBvciBzdHJpbmcgY29uY2F0ZW5hdGlvbiBpdHNlbGYuXG4gKiBJdCBzaW1wbHkgY2FwdHVyZXMgdGhlIHRlbXBsYXRlJ3MgcGFydHMgZm9yIGxhdGVyIHByb2Nlc3NpbmcuXG4gKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHN0cmluZ3NcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHZhbHVlc1xuICogQHJldHVybnMge05lby5mdW5jdGlvbmFsLnV0aWwuSHRtbFRlbXBsYXRlfSBBbiBpbnN0YW5jZSBvZiBIdG1sVGVtcGxhdGVcbiAqL1xuY29uc3QgaHRtbCA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IHtcbiAgICByZXR1cm4gbmV3IEh0bWxUZW1wbGF0ZShzdHJpbmdzLCB2YWx1ZXMpO1xufTtcblxuZXhwb3J0IHsgaHRtbCwgaXNIdG1sVGVtcGxhdGUsIEh0bWxUZW1wbGF0ZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9