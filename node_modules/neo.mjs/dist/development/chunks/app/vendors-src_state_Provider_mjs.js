"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_state_Provider_mjs"],{

/***/ "./src/core/Effect.mjs":
/*!*****************************!*\
  !*** ./src/core/Effect.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");




/**
 * Creates a reactive effect that automatically tracks its dependencies and re-runs when any of them change.
 * This is a lightweight, plain JavaScript class for performance.
 * It serves as a core reactive primitive, enabling automatic and dynamic dependency tracking.
 * @class Neo.core.Effect
 */
class Effect {
    /**
     * The optional component id this effect belongs to.
     * @member {String|null} componentId=null
     */
    componentId = null
    /**
     * A Map containing Config instances as keys and their cleanup functions as values.
     * @member {Map} dependencies=new Map()
     * @protected
     */
    dependencies = new Map()
    /**
     * The function to execute.
     * @member {Function|null} _fn=null
     */
    _fn = null
    /**
     * The unique identifier for this effect instance.
     * @member {String|null}
     */
    id = _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getId('effect')
    /**
     * @member {Boolean}
     * @protected
     */
    isDestroyed = false
    /**
     * @member {Neo.core.Config}
     * @protected
     */
    isRunning = null

    /**
     * @member fn
     */
    get fn() {
        return this._fn
    }
    set fn(value) {
        this._fn = value;
        // Assigning a new function to `fn` automatically triggers a re-run.
        // This ensures that the effect immediately re-evaluates its dependencies
        // based on the new function's logic, clearing old dependencies and establishing new ones.
        this.run()
    }

    /**
     * @param {Function|Object}  fn              - The function to execute, or a config object for the effect.
     * @param {Function}        [fn.fn]          - The function to execute for the effect (if the first argument is an object).
     * @param {String}          [fn.componentId] - The component id this effect belongs to.
     * @param {Boolean}         [fn.lazy=false]  - If true, the effect will not run immediately upon creation.
     * @param {Object|Object[]} [fn.subscriber]  - A single subscriber or an array of subscribers for the isRunning config.
     * @param {Object}          [options={}]     - Optional. Used if the first argument is a function, this object contains the options.
     * @example
     * // Signature 1: Function and Options
     * const myEffect = new Effect(() => console.log('Run'), {lazy: true});
     * @example
     * // Signature 2: Single Config Object
     * const myEffect = new Effect({fn: () => console.log('Run'), lazy: true});
     */
    constructor(fn, options={}) {
        const me = this;

        const {
              fn: effectFn,
              componentId,
              lazy = false,
              subscriber
        } = (typeof fn === 'function') ? { ...options, fn } : (fn || {});

        if (componentId) {
            me.componentId = componentId
        }

        me.isRunning = new _Config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](false);

        if (subscriber) {
            [].concat(subscriber).forEach(sub => me.isRunning.subscribe(sub))
        }

        if (lazy) {
            me._fn = effectFn
        } else {
            me.fn = effectFn
        }
    }

    /**
     * Cleans up all subscriptions and destroys the effect.
     */
    destroy() {
        const me = this;

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        me.isDestroyed = true
    }

    /**
     * Executes the effect function, re-evaluating its dependencies.
     * If the EffectManager is paused (e.g., inside a batch), it queues itself to be run later.
     * @protected
     */
    run() {
        const me = this;

        if (me.isDestroyed) {
            return
        }

        // Check if already running without creating a dependency on `isRunning`.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        const isRunning = me.isRunning.get();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        if (isRunning) {
            return
        }

        // If the manager is globally paused for batching, queue this effect and stop.
        if (_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isPaused()) {
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].queue(me);
            return
        }

        // Set `isRunning` to true without creating a dependency.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        me.isRunning.set(true);
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        // Clear old dependencies and set this as the active effect.
        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].push(me);

        try {
            // Execute the function, which will collect new dependencies.
            me.fn()
        } finally {
            // Clean up after the run.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pop();

            // Set `isRunning` to false without creating a dependency.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
            me.isRunning.set(false);
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking()
        }
    }

    /**
     * Adds a `Neo.core.Config` instance as a dependency for this effect.
     * @param {Neo.core.Config} config The config instance to subscribe to.
     * @protected
     */
    addDependency(config) {
        const me = this;

        if (!me.dependencies.has(config)) {
            const cleanup = config.subscribe({
                id: me.id,
                fn: me.run.bind(me)
            });

            me.dependencies.set(config, cleanup)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Effect, 'Neo.core.Effect', () => {
    /**
     * Factory shortcut to create a new Neo.core.Effect instance.
     * @function Neo.effect
     * @param {Function|Object} fn - The function to execute, or a config object for the effect.
     * @param {Object} [options] - Optional. Used if the first argument is a function.
     * @returns {Neo.core.Effect}
     */
    Neo.effect = (fn, options) => new Effect(fn, options)
}));


/***/ }),

/***/ "./src/state/Provider.mjs":
/*!********************************!*\
  !*** ./src/state/Provider.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Effect.mjs */ "./src/core/Effect.mjs");
/* harmony import */ var _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _createHierarchicalDataProxy_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createHierarchicalDataProxy.mjs */ "./src/state/createHierarchicalDataProxy.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");









const twoWayBindingSymbol = Symbol.for('twoWayBinding');

/**
 * An optional component state provider for adding bindings to configs
 * @class Neo.state.Provider
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Provider extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.state.Provider'
         * @protected
         */
        className: 'Neo.state.Provider',
        /**
         * @member {String} ntype='state-provider'
         * @protected
         */
        ntype: 'state-provider',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         /**
         * The core data object managed by this StateProvider.
         * This object holds the reactive state that can be accessed and modified
         * by components and formulas within the provider's hierarchy.
         * Changes to properties within this data object will trigger reactivity.
         * When new data is assigned, it will be deeply merged with existing data.
         * @member {Object|null} data_=null
         * @example
         *     data: {
         *         user: {
         *             firstName: 'John',
         *             lastName : 'Doe'
         *         },
         *         settings: {
         *             theme: 'dark'
         *         }
         *     }
         * @reactive
         */
        data_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_7__.isDescriptor]: true,
            merge         : 'deep',
            value         : {}
        },
        /**
         * Defines computed properties based on other data properties within the StateProvider hierarchy.
         * Each formula is a function that receives a `data` argument, which is a hierarchical proxy
         * allowing access to data from the current provider and all its parent providers.
         * Changes to dependencies (accessed via `data.propertyName`) will automatically re-run the formula.
         * @member {Object|null} formulas_=null
         * @example
         *     data: {
         *         a    : 1,
         *         b    : 2,
         *         total: 50
         *     }
         *     formulas: {
         *         aPlusB : (data) => data.a + data.b,
         *         aTimesB: (data) => data.a * data.b,
         *         // Accessing parent data (assuming a parent provider has a 'taxRate' property)
         *         totalWithTax: (data) => data.total * (1 + data.taxRate)
         *     }
         * @reactive
         */
        formulas_: null,
        /**
         * @member {Neo.state.Provider|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         /**
         * A collection of Neo.data.Store instances managed by this StateProvider.
         * Stores are defined as config objects with a `module` property pointing
         * to the store class, which will then be instantiated by the framework.
         * @member {Object|null} stores_=null
         * @example
         *     stores: {
         *         myUsers: {
         *             module: Neo.data.Store,
         *             model : 'MyApp.model.User',
         *             data  : [{id: 1, name: 'John'}, {id: 2, name: 'Doe'}]
         *         },
         *         myCustomStore1: MyCustomStoreClass,
         *         myCustomStore2: {
         *             module  : MyCustomStoreClass,
         *             autoLoad: true
         *         }
         *     }
         * @reactive
         */
        stores_: null
    }

    /**
     * @member {Map} #bindingEffects=new Map()
     * @private
     */
    #bindingEffects = new Map()
    /**
     * @member {Object} #dataConfigs={}
     * @private
     */
    #dataConfigs = {}
    /**
     * @member {Map} #formulaEffects=new Map()
     * @private
     */
    #formulaEffects = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        Neo.isUsingStateProviders = true;
        super.construct(config)
    }

    /**
     * Triggered after the data config got changed.
     * This method initializes the internal #dataConfigs map, converting each
     * plain data property into a reactive Neo.core.Config instance.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        value && this.processDataObject(value)
    }

    /**
     * Triggered after the formulas config got changed.
     * This method sets up reactive effects for each defined formula.
     * Each formula function receives the hierarchical data proxy, allowing implicit dependency tracking.
     * @param {Object|null} value The new formulas configuration.
     * @param {Object|null} oldValue The old formulas configuration.
     * @protected
     */
    afterSetFormulas(value, oldValue) {
        const me = this;

        // Destroy old formula effects to prevent memory leaks and stale calculations.
        me.#formulaEffects.forEach(effect => effect.destroy());
        me.#formulaEffects.clear();

        if (value) {
            Object.entries(value).forEach(([formulaKey, formulaFn]) => {
                // Create a new lazy Effect. It will not run until explicitly told to.
                const effect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]({
                    fn: () => {
                        const
                            hierarchicalData = me.getHierarchyData(),
                            result           = formulaFn(hierarchicalData);

                        me.setData(formulaKey, result);
                    },
                    lazy: true
                });

                me.#formulaEffects.set(formulaKey, effect)
            })
        }
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getHierarchyData()
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        if (value) {
            let me = this;

            Object.entries(value).forEach(([key, storeValue]) => {
                // support mapping string based listeners into the stateProvider instance
                Object.entries(storeValue.listeners || {}).forEach(([listenerKey, listener]) => {
                    me.bindCallback(listener, listenerKey, me, storeValue.listeners)
                })

                value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(storeValue)
            })
        }

        return value
    }

    /**
     * Creates a new binding for a component's config to a data property.
     * This now uses the Effect-based reactivity system.
     * @param {String} componentId
     * @param {String} configKey The component config to bind (e.g., 'text').
     * @param {String|Function} formatter The function that computes the value.
     */
    createBinding(componentId, configKey, formatter) {
        const
            me     = this,
            effect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](() => {
                const component = Neo.get(componentId);

                if (component && !component.isDestroyed) {
                    const
                        hierarchicalData = me.getHierarchyData(),
                        newValue         = Neo.isFunction(formatter) ? formatter.call(me, hierarchicalData) : hierarchicalData[formatter];

                    component._skipTwoWayPush = configKey;
                    component[configKey] = newValue;
                    delete component._skipTwoWayPush
                }
            });

        me.#bindingEffects.set(componentId, effect);

        // The effect observes the component's destruction to clean itself up.
        me.observeConfig(componentId, 'isDestroying', (value) => {
            if (value) {
                effect.destroy();
                me.#bindingEffects.delete(componentId)
            }
        });

        // The effect is returned to be managed by the component.
        return effect
    }

    /**
     * Processes a component's `bind` configuration to create reactive bindings.
     * It differentiates between store bindings and data bindings, and sets up two-way binding if specified.
     * @param {Neo.component.Base} component The component instance whose bindings are to be created.
     */
    createBindings(component) {
        let me               = this,
            hasTwoWayBinding = false;

        Object.entries(component.bind || {}).forEach(([configKey, value]) => {
            let key = value;

            // If the binding value is an object, it might contain `twoWay` or a specific `key`.
            if (Neo.isObject(value)) {
                if (value.twoWay) {
                    hasTwoWayBinding = true
                }
                key = value.key
            }

            // Determine if it's a store binding or a data binding.
            if (me.isStoreValue(key)) {
                // For store bindings, resolve the store and assign it to the component config.
                me.resolveStore(component, configKey, key.substring(7)) // remove the "stores." prefix
            } else {
                // For data bindings, create an Effect to keep the component config in sync with the data.
                me.createBinding(component.id, configKey, key, value.twoWay)
            }
        });

        // Mark the component if it has any two-way bindings, for internal tracking.
        if (hasTwoWayBinding) {
            component[twoWayBindingSymbol] = true
        }
    }

    /**
     * Destroys the state provider and cleans up all associated effects.
     */
    destroy() {
        const me = this;

        me.#formulaEffects.forEach(effect => effect.destroy());
        me.#formulaEffects.clear();

        me.#bindingEffects.forEach(effect => effect.destroy());
        me.#bindingEffects.clear();

        super.destroy()
    }

    /**
     * Convenience shortcut
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        return this.component.getController(ntype)
    }

    /**
     * Access the closest data property inside the parent chain.
     * @param {String} key
     * @returns {*} value
     */
    getData(key) {
        const ownerDetails = this.getOwnerOfDataProperty(key);

        if (ownerDetails) {
            return ownerDetails.owner.getDataConfig(ownerDetails.propertyName).get()
        }
    }

    /**
     * Retrieves the underlying core.Config instance for a given data property path.
     * @param {String} path The full path of the data property (e.g., 'user.firstname').
     * @returns {Neo.core.Config|null}
     */
    getDataConfig(path) {
        return this.#dataConfigs[path] || null
    }

    /**
     * Returns the merged, hierarchical data object as a reactive Proxy.
     * @returns {Proxy}
     */
    getHierarchyData() {
        return (0,_createHierarchicalDataProxy_mjs__WEBPACK_IMPORTED_MODULE_6__.createHierarchicalDataProxy)(this)
    }

    /**
     * Finds the state.Provider instance that owns a specific data property.
     * @param {String} path The full path of the data property.
     * @returns {{owner: Neo.state.Provider, propertyName: String}|null}
     */
    getOwnerOfDataProperty(path) {
        let me = this;

        if (me.#dataConfigs[path]) {
            return {owner: me, propertyName: path}
        }

        // Check for parent ownership
        const parent = me.getParent();
        if (parent) {
            return parent.getOwnerOfDataProperty(path)
        }

        return null
    }

    /**
     * Get the closest stateProvider inside the components parent tree
     * @returns {Neo.state.Provider|null}
     */
    getParent() {
        let me = this;

        // Access the internal value of the parent_ config directly.
        // This avoids recursive calls to the getter.
        if (me._parent) {
            return me._parent
        }

        // If no explicit parent is set, try to find it dynamically via the component.
        // Ensure this.component exists before trying to access its parent.
        if (me.component) {
            return me.component.parent?.getStateProvider() || null
        }

        // No explicit parent and no component to derive it from.
        return null
    }

    /**
     * Access the closest store inside the VM parent chain.
     * @param {String} key
     * @param {Neo.state.Provider} originStateProvider=this for internal usage only
     * @returns {Neo.data.Store}
     */
    getStore(key, originStateProvider=this) {
        let me       = this,
            {stores} = me,
            parentStateProvider;

        if (stores?.hasOwnProperty(key)) {
            return stores[key]
        }

        parentStateProvider = me.getParent();

        if (!parentStateProvider) {
            console.error(`store '${key}' not found inside this stateProvider or parents.`, originStateProvider)
        }

        return parentStateProvider.getStore(key, originStateProvider)
    }

    /**
     * Checks if any data property in the hierarchy starts with the given path.
     * This is used by the HierarchicalDataProxy to determine if it should return a nested proxy.
     * @param {String} path The path to check (e.g., 'user').
     * @returns {Boolean}
     */
    hasNestedDataStartingWith(path) {
        const pathWithDot = `${path}.`;

        if (Object.keys(this.#dataConfigs).some(key => key.startsWith(pathWithDot))) {
            return true
        }

        return this.getParent()?.hasNestedDataStartingWith(path) || false
    }

    /**
     * Returns the top-level data keys for a given path within this provider's data.
     * @param {String} path The path to get keys for (e.g., 'user.address').
     * @returns {String[]}
     */
    getTopLevelDataKeys(path) {
        const
            keys       = new Set(),
            pathPrefix = path ? `${path}.` : '';

        for (const fullPath in this.#dataConfigs) {
            if (fullPath.startsWith(pathPrefix)) {
                const
                    relativePath = fullPath.substring(pathPrefix.length),
                    topLevelKey  = relativePath.split('.')[0];

                if (topLevelKey) {
                    keys.add(topLevelKey)
                }
            }
        }

        return Array.from(keys)
    }

    /**
     * This is the core method for setting data, providing a single entry point for all data modifications.
     * It handles multiple scenarios:
     * 1.  **Object-based updates:** If `key` is an object, it recursively calls itself for each key-value pair.
     * 2.  **Data Records:** If `value` is a `Neo.data.Record`, it is treated as an atomic value and set directly.
     * 3.  **Bubbling Reactivity:** For a given key (e.g., 'user.name'), it sets the leaf value and then "bubbles up"
     *     the change, creating new parent objects (e.g., 'user') to ensure that effects depending on any part
     *     of the path are triggered.
     *
     * All updates are batched by the public `setData` methods to ensure effects run only once.
     * Use `setData()` or `setDataAtSameLevel()` instead of calling this method directly.
     *
     * @param {Object|String} key The property to set, or an object of key-value pairs.
     * @param {*} value The new value.
     * @param {Neo.state.Provider} [originStateProvider] The provider to start the search from for hierarchical updates.
     * @protected
     */
    internalSetData(key, value, originStateProvider) {
        const me = this;

        if (Neo.isObject(key)) {
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originStateProvider)
            });
            return
        }

        // Now 'key' is a string path.
        // If 'value' is a plain object, we need to drill down further.
        // If the value is a Neo.data.Record, treat it as an atomic value => it will not enter this block.
        if (Neo.typeOf(value) === 'Object') {
            Object.entries(value).forEach(([nestedKey, nestedValue]) => {
                const fullPath = `${key}.${nestedKey}`;
                me.internalSetData(fullPath, nestedValue, originStateProvider);
            });
            return // We've delegated the setting to deeper paths.
        }

        const
            ownerDetails   = me.getOwnerOfDataProperty(key),
            targetProvider = ownerDetails ? ownerDetails.owner : (originStateProvider || me);

        me.#setConfigValue(targetProvider, key, value, null);

        // This is the "reactivity bubbling" logic. When a leaf property like 'user.name' changes,
        // we must also trigger effects that depend on the parent object 'user'. We do this by
        // creating a new object reference for each parent in the path. The spread syntax
        // `{ ...oldParentValue, [leafKey]: latestValue }` is key, as it creates a new
        // object, which the reactivity system detects as a change.
        let path        = key,
            latestValue = value;

        while (path.includes('.')) {
            const leafKey = path.split('.').pop();
            path = path.substring(0, path.lastIndexOf('.'));

            const parentConfig = targetProvider.getDataConfig(path);

            if (parentConfig) {
                const oldParentValue = parentConfig.get();
                if (Neo.isObject(oldParentValue)) {
                    const newParentValue = { ...oldParentValue, [leafKey]: latestValue };
                    parentConfig.set(newParentValue);
                    latestValue = newParentValue;
                } else {
                    break // Stop if parent is not an object
                }
            } else {
                // If the parent config doesn't exist, we need to create it to support bubbling.
                // This is crucial for creating new nested data structures at runtime.
                const newParentValue = {[leafKey]: latestValue};
                me.#setConfigValue(targetProvider, path, newParentValue);
                latestValue = newParentValue
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return Neo.isString(value) && value.startsWith('stores.')
    }

    /**
     * Gets called after all constructors & configs are applied.
     * @protected
     */
    onConstructed() {
        super.onConstructed();

        // After the provider is fully constructed and initial data is set,
        // run the formula effects for the first time to compute their initial values.
        this.#formulaEffects.forEach(effect => effect.run())
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        // Can be overridden by subclasses
    }

    /**
     * Recursively processes a data object, creating or updating Neo.core.Config instances
     * for each property and storing them in the #dataConfigs map.
     * @param {Object} obj The data object to process.
     * @param {String} [path=''] The current path prefix for nested objects.
     * @protected
     */
    processDataObject(obj, path = '') {
        let me = this;

        Object.entries(obj).forEach(([key, value]) => {
            const fullPath = path ? `${path}.${key}` : key;

            // Ensure a Config instance exists for the current fullPath
            if (me.#dataConfigs[fullPath]) {
                me.#dataConfigs[fullPath].set(value)
            } else {
                me.#dataConfigs[fullPath] = new _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](value)
            }

            // If the value is a plain object, recursively process its properties
            if (Neo.typeOf(value) === 'Object') {
                me.processDataObject(value, fullPath)
            }
        });
    }

    /**
     * @param {Neo.component.Base} component
     * @param {String}             configName
     * @param {String}             storeName
     */
    resolveStore(component, configName, storeName) {
        let store = this.getStore(storeName);

        if (component[configName] !== store) {
            component[configName] = store
        }
    }

    /**
     * Helper function to set a config value and trigger reactivity.
     * This method creates a new Config instance if one doesn't exist for the given path,
     * or updates an existing one. It also triggers binding effects and calls onDataPropertyChange.
     * @param {Neo.state.Provider} provider The StateProvider instance owning the config.
     * @param {String}             path     The full path of the data property (e.g., 'user.firstname').
     * @param {*}                  newValue The new value to set.
     * @param {*}                 [oldVal]  The old value (optional, used for initial setup).
     * @private
     */
    #setConfigValue(provider, path, newValue, oldVal) {
        let currentConfig = provider.getDataConfig(path),
            hasChange     = true,
            oldValue      = oldVal;

        if (currentConfig) {
            oldValue  = currentConfig.get();
            hasChange = currentConfig.set(newValue)
        } else {
            currentConfig = new _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](newValue);
            provider.#dataConfigs[path] = currentConfig;
            // Trigger all binding effects to re-evaluate their dependencies
            provider.#bindingEffects.forEach(effect => effect.run())
        }

        if (hasChange) {
            // Notify subscribers of the data property change.
            provider.onDataPropertyChange(path, newValue, oldValue)
        }
    }

    /**
     * The method will assign all values to the closest stateProvider where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     *
     * All updates within a single call are batched to ensure that reactive effects (bindings and formulas)
     * are run only once.
     *
     * @param {Object|String} key
     * @param {*}             value
     */
    setData(key, value) {
        _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].pause();
        try {
            this.internalSetData(key, value, this)
        } finally {
            _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].resume()
        }
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent stateProviders.
     *
     * All updates within a single call are batched to ensure that reactive effects (bindings and formulas)
     * are run only once.
     *
     * @param {Object|String} key
     * @param {*}             value
     */
    setDataAtSameLevel(key, value) {
        _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].pause();
        try {
            this.internalSetData(key, value)
        } finally {
            _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].resume()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Provider));


/***/ }),

/***/ "./src/state/createHierarchicalDataProxy.mjs":
/*!***************************************************!*\
  !*** ./src/state/createHierarchicalDataProxy.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createHierarchicalDataProxy: () => (/* binding */ createHierarchicalDataProxy)
/* harmony export */ });
/* harmony import */ var _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EffectManager.mjs */ "./src/core/EffectManager.mjs");


/**
 * Creates a nested Proxy that represents a level in the hierarchical data structure.
 * @param {Neo.state.Provider} rootProvider The top-level provider to start searches from.
 * @param {String} path The current path of this proxy level (e.g., 'user' for data.user).
 * @returns {Proxy|null}
 * @private
 */
function createNestedProxy(rootProvider, path) {
    // The target object for the proxy can be empty because all lookups are dynamic.
    const target = {};

    return new Proxy(target, {
        /**
         * The get trap for the proxy. This is where the magic happens.
         * @param {Object} currentTarget The proxy's target object.
         * @param {String|Symbol} property The name of the property being accessed.
         * @returns {*} The value of the property or a new proxy for nested access.
         */
        get(currentTarget, property) {
            // Handle internal properties that might be set directly on the proxy's target
            // or are expected by the environment (like Siesta's __REFADR__).
            if (typeof property === 'symbol' || property === '__REFADR__' || property === 'inspect' || property === 'then') {
                return Reflect.get(currentTarget, property)
            }

            // Only allow string or number properties to proceed as data paths.
            if (typeof property !== 'string' && typeof property !== 'number') {
                return undefined; // For other non-string/non-number properties, return undefined.
            }

            // Special handling for the 'stores' property at the root level
            if (path === '' && property === 'stores') {
                return new Proxy({}, {
                    get(target, storeName) {
                        if (typeof storeName === 'symbol' || storeName === '__REFADR__') {
                            return Reflect.get(target, storeName)
                        }
                        // Delegate to the StateProvider's getStore method for hierarchical resolution
                        // Accessing store.count later will register the dependency via the Config system
                        return rootProvider.getStore(storeName)
                    }
                })
            }

            const fullPath = path ? `${path}.${property}` : property;

            // 1. Check if the full path corresponds to an actual data property.
            const ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);

            if (ownerDetails) {
                const
                    {owner, propertyName} = ownerDetails,
                    config                = owner.getDataConfig(propertyName);

                if (config) {
                    _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getActiveEffect()?.addDependency(config);

                    const value = config.get();
                    // If the value is an object, return a new proxy for it to ensure nested accesses are also proxied.
                    if (Neo.isObject(value)) {
                        return createNestedProxy(rootProvider, fullPath)
                    }

                    return value
                }
            }

            // 2. If not a direct match, it might be a parent object of a nested property
            //    (e.g., accessing `user` when a `user.firstname` binding exists).
            //    In this case, we return another proxy for the next level down.
            if (rootProvider.hasNestedDataStartingWith(fullPath)) {
                return createNestedProxy(rootProvider, fullPath)
            }

            // 3. If it's neither a data property nor a path to one, it doesn't exist.
            //    Returning undefined ensures that chained accesses (e.g., data.nonexistent.property) fail gracefully.
        },

        set(currentTarget, property, value) {
            // Allow internal properties (like Symbols or specific strings) to be set directly on the target.
            if (typeof property === 'symbol' || property === '__REFADR__') {
                return Reflect.set(currentTarget, property, value)
            }

            const
                fullPath     = path ? `${path}.${property}` : property,
                ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);
            let targetProvider;

            if (ownerDetails) {
                targetProvider = ownerDetails.owner
            } else {
                // If no owner is found, set it on the rootProvider (the one that created this proxy)
                targetProvider = rootProvider
            }

            targetProvider.setData(fullPath, value);
            return true // Indicate that the assignment was successful
        },

        ownKeys(currentTarget) {
            return rootProvider.getTopLevelDataKeys(path)
        },

        getOwnPropertyDescriptor(currentTarget, property) {
            const
                fullPath     = path ? `${path}.${property}` : property,
                ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);

            if (ownerDetails) {
                const config = ownerDetails.owner.getDataConfig(ownerDetails.propertyName);

                if (config) {
                    const value = config.get();
                    return {
                        value       : Neo.isObject(value) ? createNestedProxy(rootProvider, fullPath) : value,
                        writable    : true,
                        enumerable  : true,
                        configurable: true
                    }
                }
            }
        }
    })
}

/**
 * Creates a Proxy object that represents the merged, hierarchical data from a `state.Provider` chain.
 * When a property is accessed through this proxy while an Effect is running, it automatically
 * tracks the underlying core.Config instance as a dependency.
 * @param {Neo.state.Provider} provider The starting state.Provider.
 * @returns {Proxy}
 */
function createHierarchicalDataProxy(provider) {
    return createNestedProxy(provider, '')
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNPO0FBQ0Y7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsU0FBUyx3REFBVztBQUNwQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQixXQUFXO0FBQzNDO0FBQ0E7QUFDQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUF5QztBQUM3RTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUMsaUJBQWlCLFdBQVc7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbURBQU07O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFB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O0FBRVQ7QUFDQTtBQUNBLHlDQUF5QyxLQUFLLEdBQUcsU0FBUztBQUMxRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvRWZmZWN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3N0YXRlL1Byb3ZpZGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3N0YXRlL2NyZWF0ZUhpZXJhcmNoaWNhbERhdGFQcm94eS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbmZpZyAgICAgICAgZnJvbSAnLi9Db25maWcubWpzJztcbmltcG9ydCBFZmZlY3RNYW5hZ2VyIGZyb20gJy4vRWZmZWN0TWFuYWdlci5tanMnO1xuaW1wb3J0IElkR2VuZXJhdG9yICAgZnJvbSAnLi9JZEdlbmVyYXRvci5tanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBhdXRvbWF0aWNhbGx5IHRyYWNrcyBpdHMgZGVwZW5kZW5jaWVzIGFuZCByZS1ydW5zIHdoZW4gYW55IG9mIHRoZW0gY2hhbmdlLlxuICogVGhpcyBpcyBhIGxpZ2h0d2VpZ2h0LCBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzIGZvciBwZXJmb3JtYW5jZS5cbiAqIEl0IHNlcnZlcyBhcyBhIGNvcmUgcmVhY3RpdmUgcHJpbWl0aXZlLCBlbmFibGluZyBhdXRvbWF0aWMgYW5kIGR5bmFtaWMgZGVwZW5kZW5jeSB0cmFja2luZy5cbiAqIEBjbGFzcyBOZW8uY29yZS5FZmZlY3RcbiAqL1xuY2xhc3MgRWZmZWN0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9uYWwgY29tcG9uZW50IGlkIHRoaXMgZWZmZWN0IGJlbG9uZ3MgdG8uXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGNvbXBvbmVudElkPW51bGxcbiAgICAgKi9cbiAgICBjb21wb25lbnRJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBBIE1hcCBjb250YWluaW5nIENvbmZpZyBpbnN0YW5jZXMgYXMga2V5cyBhbmQgdGhlaXIgY2xlYW51cCBmdW5jdGlvbnMgYXMgdmFsdWVzLlxuICAgICAqIEBtZW1iZXIge01hcH0gZGVwZW5kZW5jaWVzPW5ldyBNYXAoKVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkZXBlbmRlbmNpZXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbnxudWxsfSBfZm49bnVsbFxuICAgICAqL1xuICAgIF9mbiA9IG51bGxcbiAgICAvKipcbiAgICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZWZmZWN0IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGlkID0gSWRHZW5lcmF0b3IuZ2V0SWQoJ2VmZmVjdCcpXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNEZXN0cm95ZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge05lby5jb3JlLkNvbmZpZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNSdW5uaW5nID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciBmblxuICAgICAqL1xuICAgIGdldCBmbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZuXG4gICAgfVxuICAgIHNldCBmbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mbiA9IHZhbHVlO1xuICAgICAgICAvLyBBc3NpZ25pbmcgYSBuZXcgZnVuY3Rpb24gdG8gYGZuYCBhdXRvbWF0aWNhbGx5IHRyaWdnZXJzIGEgcmUtcnVuLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgZWZmZWN0IGltbWVkaWF0ZWx5IHJlLWV2YWx1YXRlcyBpdHMgZGVwZW5kZW5jaWVzXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBuZXcgZnVuY3Rpb24ncyBsb2dpYywgY2xlYXJpbmcgb2xkIGRlcGVuZGVuY2llcyBhbmQgZXN0YWJsaXNoaW5nIG5ldyBvbmVzLlxuICAgICAgICB0aGlzLnJ1bigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9ICBmbiAgICAgICAgICAgICAgLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSwgb3IgYSBjb25maWcgb2JqZWN0IGZvciB0aGUgZWZmZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICBbZm4uZm5dICAgICAgICAgIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIHRoZSBlZmZlY3QgKGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmplY3QpLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICBbZm4uY29tcG9uZW50SWRdIC0gVGhlIGNvbXBvbmVudCBpZCB0aGlzIGVmZmVjdCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgICBbZm4ubGF6eT1mYWxzZV0gIC0gSWYgdHJ1ZSwgdGhlIGVmZmVjdCB3aWxsIG5vdCBydW4gaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxPYmplY3RbXX0gW2ZuLnN1YnNjcmliZXJdICAtIEEgc2luZ2xlIHN1YnNjcmliZXIgb3IgYW4gYXJyYXkgb2Ygc3Vic2NyaWJlcnMgZm9yIHRoZSBpc1J1bm5pbmcgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBbb3B0aW9ucz17fV0gICAgIC0gT3B0aW9uYWwuIFVzZWQgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIHRoaXMgb2JqZWN0IGNvbnRhaW5zIHRoZSBvcHRpb25zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2lnbmF0dXJlIDE6IEZ1bmN0aW9uIGFuZCBPcHRpb25zXG4gICAgICogY29uc3QgbXlFZmZlY3QgPSBuZXcgRWZmZWN0KCgpID0+IGNvbnNvbGUubG9nKCdSdW4nKSwge2xhenk6IHRydWV9KTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNpZ25hdHVyZSAyOiBTaW5nbGUgQ29uZmlnIE9iamVjdFxuICAgICAqIGNvbnN0IG15RWZmZWN0ID0gbmV3IEVmZmVjdCh7Zm46ICgpID0+IGNvbnNvbGUubG9nKCdSdW4nKSwgbGF6eTogdHJ1ZX0pO1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZuLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGZuOiBlZmZlY3RGbixcbiAgICAgICAgICAgICAgY29tcG9uZW50SWQsXG4gICAgICAgICAgICAgIGxhenkgPSBmYWxzZSxcbiAgICAgICAgICAgICAgc3Vic2NyaWJlclxuICAgICAgICB9ID0gKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgPyB7IC4uLm9wdGlvbnMsIGZuIH0gOiAoZm4gfHwge30pO1xuXG4gICAgICAgIGlmIChjb21wb25lbnRJZCkge1xuICAgICAgICAgICAgbWUuY29tcG9uZW50SWQgPSBjb21wb25lbnRJZFxuICAgICAgICB9XG5cbiAgICAgICAgbWUuaXNSdW5uaW5nID0gbmV3IENvbmZpZyhmYWxzZSk7XG5cbiAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIFtdLmNvbmNhdChzdWJzY3JpYmVyKS5mb3JFYWNoKHN1YiA9PiBtZS5pc1J1bm5pbmcuc3Vic2NyaWJlKHN1YikpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF6eSkge1xuICAgICAgICAgICAgbWUuX2ZuID0gZWZmZWN0Rm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmZuID0gZWZmZWN0Rm5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgZGVzdHJveXMgdGhlIGVmZmVjdC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuICAgICAgICBtZS5kZXBlbmRlbmNpZXMuY2xlYXIoKTtcbiAgICAgICAgbWUuaXNEZXN0cm95ZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGVmZmVjdCBmdW5jdGlvbiwgcmUtZXZhbHVhdGluZyBpdHMgZGVwZW5kZW5jaWVzLlxuICAgICAqIElmIHRoZSBFZmZlY3RNYW5hZ2VyIGlzIHBhdXNlZCAoZS5nLiwgaW5zaWRlIGEgYmF0Y2gpLCBpdCBxdWV1ZXMgaXRzZWxmIHRvIGJlIHJ1biBsYXRlci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcnVuKCkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcnVubmluZyB3aXRob3V0IGNyZWF0aW5nIGEgZGVwZW5kZW5jeSBvbiBgaXNSdW5uaW5nYC5cbiAgICAgICAgRWZmZWN0TWFuYWdlci5wYXVzZVRyYWNraW5nKCk7XG4gICAgICAgIGNvbnN0IGlzUnVubmluZyA9IG1lLmlzUnVubmluZy5nZXQoKTtcbiAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWVUcmFja2luZygpO1xuXG4gICAgICAgIGlmIChpc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIG1hbmFnZXIgaXMgZ2xvYmFsbHkgcGF1c2VkIGZvciBiYXRjaGluZywgcXVldWUgdGhpcyBlZmZlY3QgYW5kIHN0b3AuXG4gICAgICAgIGlmIChFZmZlY3RNYW5hZ2VyLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucXVldWUobWUpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgYGlzUnVubmluZ2AgdG8gdHJ1ZSB3aXRob3V0IGNyZWF0aW5nIGEgZGVwZW5kZW5jeS5cbiAgICAgICAgRWZmZWN0TWFuYWdlci5wYXVzZVRyYWNraW5nKCk7XG4gICAgICAgIG1lLmlzUnVubmluZy5zZXQodHJ1ZSk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lVHJhY2tpbmcoKTtcblxuICAgICAgICAvLyBDbGVhciBvbGQgZGVwZW5kZW5jaWVzIGFuZCBzZXQgdGhpcyBhcyB0aGUgYWN0aXZlIGVmZmVjdC5cbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuICAgICAgICBtZS5kZXBlbmRlbmNpZXMuY2xlYXIoKTtcbiAgICAgICAgRWZmZWN0TWFuYWdlci5wdXNoKG1lKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgZnVuY3Rpb24sIHdoaWNoIHdpbGwgY29sbGVjdCBuZXcgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgbWUuZm4oKVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYWZ0ZXIgdGhlIHJ1bi5cbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucG9wKCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBgaXNSdW5uaW5nYCB0byBmYWxzZSB3aXRob3V0IGNyZWF0aW5nIGEgZGVwZW5kZW5jeS5cbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2VUcmFja2luZygpO1xuICAgICAgICAgICAgbWUuaXNSdW5uaW5nLnNldChmYWxzZSk7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZVRyYWNraW5nKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBgTmVvLmNvcmUuQ29uZmlnYCBpbnN0YW5jZSBhcyBhIGRlcGVuZGVuY3kgZm9yIHRoaXMgZWZmZWN0LlxuICAgICAqIEBwYXJhbSB7TmVvLmNvcmUuQ29uZmlnfSBjb25maWcgVGhlIGNvbmZpZyBpbnN0YW5jZSB0byBzdWJzY3JpYmUgdG8uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFkZERlcGVuZGVuY3koY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoIW1lLmRlcGVuZGVuY2llcy5oYXMoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9IGNvbmZpZy5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIGlkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBmbjogbWUucnVuLmJpbmQobWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuZGVwZW5kZW5jaWVzLnNldChjb25maWcsIGNsZWFudXApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5nYXRla2VlcChFZmZlY3QsICdOZW8uY29yZS5FZmZlY3QnLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBzaG9ydGN1dCB0byBjcmVhdGUgYSBuZXcgTmVvLmNvcmUuRWZmZWN0IGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBOZW8uZWZmZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIG9yIGEgY29uZmlnIG9iamVjdCBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwuIFVzZWQgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkVmZmVjdH1cbiAgICAgKi9cbiAgICBOZW8uZWZmZWN0ID0gKGZuLCBvcHRpb25zKSA9PiBuZXcgRWZmZWN0KGZuLCBvcHRpb25zKVxufSk7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICAgICAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbmZpZyAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQ29uZmlnLm1qcyc7XG5pbXBvcnQgRWZmZWN0ICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9FZmZlY3QubWpzJztcbmltcG9ydCBFZmZlY3RNYW5hZ2VyICAgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0VmZmVjdE1hbmFnZXIubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCB7Y3JlYXRlSGllcmFyY2hpY2FsRGF0YVByb3h5fSBmcm9tICcuL2NyZWF0ZUhpZXJhcmNoaWNhbERhdGFQcm94eS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG5jb25zdCB0d29XYXlCaW5kaW5nU3ltYm9sID0gU3ltYm9sLmZvcigndHdvV2F5QmluZGluZycpO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIGNvbXBvbmVudCBzdGF0ZSBwcm92aWRlciBmb3IgYWRkaW5nIGJpbmRpbmdzIHRvIGNvbmZpZ3NcbiAqIEBjbGFzcyBOZW8uc3RhdGUuUHJvdmlkZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqIEBtaXhlcyBOZW8uY29yZS5PYnNlcnZhYmxlXG4gKi9cbmNsYXNzIFByb3ZpZGVyIGV4dGVuZHMgQmFzZSB7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZXMgdGhlIGNvcmUuT2JzZXJ2YWJsZSBtaXhpblxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG9ic2VydmFibGU9dHJ1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JzZXJ2YWJsZSA9IHRydWVcblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnN0YXRlLlByb3ZpZGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uc3RhdGUuUHJvdmlkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0nc3RhdGUtcHJvdmlkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnc3RhdGUtcHJvdmlkZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvcmUgZGF0YSBvYmplY3QgbWFuYWdlZCBieSB0aGlzIFN0YXRlUHJvdmlkZXIuXG4gICAgICAgICAqIFRoaXMgb2JqZWN0IGhvbGRzIHRoZSByZWFjdGl2ZSBzdGF0ZSB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBhbmQgbW9kaWZpZWRcbiAgICAgICAgICogYnkgY29tcG9uZW50cyBhbmQgZm9ybXVsYXMgd2l0aGluIHRoZSBwcm92aWRlcidzIGhpZXJhcmNoeS5cbiAgICAgICAgICogQ2hhbmdlcyB0byBwcm9wZXJ0aWVzIHdpdGhpbiB0aGlzIGRhdGEgb2JqZWN0IHdpbGwgdHJpZ2dlciByZWFjdGl2aXR5LlxuICAgICAgICAgKiBXaGVuIG5ldyBkYXRhIGlzIGFzc2lnbmVkLCBpdCB3aWxsIGJlIGRlZXBseSBtZXJnZWQgd2l0aCBleGlzdGluZyBkYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZGF0YV89bnVsbFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgZGF0YToge1xuICAgICAgICAgKiAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICogICAgICAgICAgICAgZmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgICAqICAgICAgICAgICAgIGxhc3ROYW1lIDogJ0RvZSdcbiAgICAgICAgICogICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAqICAgICAgICAgICAgIHRoZW1lOiAnZGFyaydcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YV86IHtcbiAgICAgICAgICAgIFtpc0Rlc2NyaXB0b3JdOiB0cnVlLFxuICAgICAgICAgICAgbWVyZ2UgICAgICAgICA6ICdkZWVwJyxcbiAgICAgICAgICAgIHZhbHVlICAgICAgICAgOiB7fVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBjb21wdXRlZCBwcm9wZXJ0aWVzIGJhc2VkIG9uIG90aGVyIGRhdGEgcHJvcGVydGllcyB3aXRoaW4gdGhlIFN0YXRlUHJvdmlkZXIgaGllcmFyY2h5LlxuICAgICAgICAgKiBFYWNoIGZvcm11bGEgaXMgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgYGRhdGFgIGFyZ3VtZW50LCB3aGljaCBpcyBhIGhpZXJhcmNoaWNhbCBwcm94eVxuICAgICAgICAgKiBhbGxvd2luZyBhY2Nlc3MgdG8gZGF0YSBmcm9tIHRoZSBjdXJyZW50IHByb3ZpZGVyIGFuZCBhbGwgaXRzIHBhcmVudCBwcm92aWRlcnMuXG4gICAgICAgICAqIENoYW5nZXMgdG8gZGVwZW5kZW5jaWVzIChhY2Nlc3NlZCB2aWEgYGRhdGEucHJvcGVydHlOYW1lYCkgd2lsbCBhdXRvbWF0aWNhbGx5IHJlLXJ1biB0aGUgZm9ybXVsYS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGZvcm11bGFzXz1udWxsXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAgICBkYXRhOiB7XG4gICAgICAgICAqICAgICAgICAgYSAgICA6IDEsXG4gICAgICAgICAqICAgICAgICAgYiAgICA6IDIsXG4gICAgICAgICAqICAgICAgICAgdG90YWw6IDUwXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqICAgICBmb3JtdWxhczoge1xuICAgICAgICAgKiAgICAgICAgIGFQbHVzQiA6IChkYXRhKSA9PiBkYXRhLmEgKyBkYXRhLmIsXG4gICAgICAgICAqICAgICAgICAgYVRpbWVzQjogKGRhdGEpID0+IGRhdGEuYSAqIGRhdGEuYixcbiAgICAgICAgICogICAgICAgICAvLyBBY2Nlc3NpbmcgcGFyZW50IGRhdGEgKGFzc3VtaW5nIGEgcGFyZW50IHByb3ZpZGVyIGhhcyBhICd0YXhSYXRlJyBwcm9wZXJ0eSlcbiAgICAgICAgICogICAgICAgICB0b3RhbFdpdGhUYXg6IChkYXRhKSA9PiBkYXRhLnRvdGFsICogKDEgKyBkYXRhLnRheFJhdGUpXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybXVsYXNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9IHBhcmVudF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29sbGVjdGlvbiBvZiBOZW8uZGF0YS5TdG9yZSBpbnN0YW5jZXMgbWFuYWdlZCBieSB0aGlzIFN0YXRlUHJvdmlkZXIuXG4gICAgICAgICAqIFN0b3JlcyBhcmUgZGVmaW5lZCBhcyBjb25maWcgb2JqZWN0cyB3aXRoIGEgYG1vZHVsZWAgcHJvcGVydHkgcG9pbnRpbmdcbiAgICAgICAgICogdG8gdGhlIHN0b3JlIGNsYXNzLCB3aGljaCB3aWxsIHRoZW4gYmUgaW5zdGFudGlhdGVkIGJ5IHRoZSBmcmFtZXdvcmsuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBzdG9yZXNfPW51bGxcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogICAgIHN0b3Jlczoge1xuICAgICAgICAgKiAgICAgICAgIG15VXNlcnM6IHtcbiAgICAgICAgICogICAgICAgICAgICAgbW9kdWxlOiBOZW8uZGF0YS5TdG9yZSxcbiAgICAgICAgICogICAgICAgICAgICAgbW9kZWwgOiAnTXlBcHAubW9kZWwuVXNlcicsXG4gICAgICAgICAqICAgICAgICAgICAgIGRhdGEgIDogW3tpZDogMSwgbmFtZTogJ0pvaG4nfSwge2lkOiAyLCBuYW1lOiAnRG9lJ31dXG4gICAgICAgICAqICAgICAgICAgfSxcbiAgICAgICAgICogICAgICAgICBteUN1c3RvbVN0b3JlMTogTXlDdXN0b21TdG9yZUNsYXNzLFxuICAgICAgICAgKiAgICAgICAgIG15Q3VzdG9tU3RvcmUyOiB7XG4gICAgICAgICAqICAgICAgICAgICAgIG1vZHVsZSAgOiBNeUN1c3RvbVN0b3JlQ2xhc3MsXG4gICAgICAgICAqICAgICAgICAgICAgIGF1dG9Mb2FkOiB0cnVlXG4gICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0b3Jlc186IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtNYXB9ICNiaW5kaW5nRWZmZWN0cz1uZXcgTWFwKClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNiaW5kaW5nRWZmZWN0cyA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge09iamVjdH0gI2RhdGFDb25maWdzPXt9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjZGF0YUNvbmZpZ3MgPSB7fVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge01hcH0gI2Zvcm11bGFFZmZlY3RzPW5ldyBNYXAoKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2Zvcm11bGFFZmZlY3RzID0gbmV3IE1hcCgpXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBOZW8uaXNVc2luZ1N0YXRlUHJvdmlkZXJzID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRhdGEgY29uZmlnIGdvdCBjaGFuZ2VkLlxuICAgICAqIFRoaXMgbWV0aG9kIGluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCAjZGF0YUNvbmZpZ3MgbWFwLCBjb252ZXJ0aW5nIGVhY2hcbiAgICAgKiBwbGFpbiBkYXRhIHByb3BlcnR5IGludG8gYSByZWFjdGl2ZSBOZW8uY29yZS5Db25maWcgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMucHJvY2Vzc0RhdGFPYmplY3QodmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBmb3JtdWxhcyBjb25maWcgZ290IGNoYW5nZWQuXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyB1cCByZWFjdGl2ZSBlZmZlY3RzIGZvciBlYWNoIGRlZmluZWQgZm9ybXVsYS5cbiAgICAgKiBFYWNoIGZvcm11bGEgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGhpZXJhcmNoaWNhbCBkYXRhIHByb3h5LCBhbGxvd2luZyBpbXBsaWNpdCBkZXBlbmRlbmN5IHRyYWNraW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlIFRoZSBuZXcgZm9ybXVsYXMgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZSBUaGUgb2xkIGZvcm11bGFzIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0Rm9ybXVsYXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBEZXN0cm95IG9sZCBmb3JtdWxhIGVmZmVjdHMgdG8gcHJldmVudCBtZW1vcnkgbGVha3MgYW5kIHN0YWxlIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgbWUuI2Zvcm11bGFFZmZlY3RzLmZvckVhY2goZWZmZWN0ID0+IGVmZmVjdC5kZXN0cm95KCkpO1xuICAgICAgICBtZS4jZm9ybXVsYUVmZmVjdHMuY2xlYXIoKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbZm9ybXVsYUtleSwgZm9ybXVsYUZuXSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXp5IEVmZmVjdC4gSXQgd2lsbCBub3QgcnVuIHVudGlsIGV4cGxpY2l0bHkgdG9sZCB0by5cbiAgICAgICAgICAgICAgICBjb25zdCBlZmZlY3QgPSBuZXcgRWZmZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgZm46ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGllcmFyY2hpY2FsRGF0YSA9IG1lLmdldEhpZXJhcmNoeURhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgICAgICAgICAgID0gZm9ybXVsYUZuKGhpZXJhcmNoaWNhbERhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXREYXRhKGZvcm11bGFLZXksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxhenk6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG1lLiNmb3JtdWxhRWZmZWN0cy5zZXQoZm9ybXVsYUtleSwgZWZmZWN0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZGF0YSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlR2V0RGF0YSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIaWVyYXJjaHlEYXRhKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBzdG9yZXMgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdHxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRTdG9yZXModmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHN0b3JlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBtYXBwaW5nIHN0cmluZyBiYXNlZCBsaXN0ZW5lcnMgaW50byB0aGUgc3RhdGVQcm92aWRlciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHN0b3JlVmFsdWUubGlzdGVuZXJzIHx8IHt9KS5mb3JFYWNoKChbbGlzdGVuZXJLZXksIGxpc3RlbmVyXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS5iaW5kQ2FsbGJhY2sobGlzdGVuZXIsIGxpc3RlbmVyS2V5LCBtZSwgc3RvcmVWYWx1ZS5saXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSBDbGFzc1N5c3RlbVV0aWwuYmVmb3JlU2V0SW5zdGFuY2Uoc3RvcmVWYWx1ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGJpbmRpbmcgZm9yIGEgY29tcG9uZW50J3MgY29uZmlnIHRvIGEgZGF0YSBwcm9wZXJ0eS5cbiAgICAgKiBUaGlzIG5vdyB1c2VzIHRoZSBFZmZlY3QtYmFzZWQgcmVhY3Rpdml0eSBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ0tleSBUaGUgY29tcG9uZW50IGNvbmZpZyB0byBiaW5kIChlLmcuLCAndGV4dCcpLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBmb3JtYXR0ZXIgVGhlIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmcoY29tcG9uZW50SWQsIGNvbmZpZ0tleSwgZm9ybWF0dGVyKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZWZmZWN0ID0gbmV3IEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gTmVvLmdldChjb21wb25lbnRJZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmICFjb21wb25lbnQuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoaWNhbERhdGEgPSBtZS5nZXRIaWVyYXJjaHlEYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSAgICAgICAgID0gTmVvLmlzRnVuY3Rpb24oZm9ybWF0dGVyKSA/IGZvcm1hdHRlci5jYWxsKG1lLCBoaWVyYXJjaGljYWxEYXRhKSA6IGhpZXJhcmNoaWNhbERhdGFbZm9ybWF0dGVyXTtcblxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuX3NraXBUd29XYXlQdXNoID0gY29uZmlnS2V5O1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRbY29uZmlnS2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29tcG9uZW50Ll9za2lwVHdvV2F5UHVzaFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG1lLiNiaW5kaW5nRWZmZWN0cy5zZXQoY29tcG9uZW50SWQsIGVmZmVjdCk7XG5cbiAgICAgICAgLy8gVGhlIGVmZmVjdCBvYnNlcnZlcyB0aGUgY29tcG9uZW50J3MgZGVzdHJ1Y3Rpb24gdG8gY2xlYW4gaXRzZWxmIHVwLlxuICAgICAgICBtZS5vYnNlcnZlQ29uZmlnKGNvbXBvbmVudElkLCAnaXNEZXN0cm95aW5nJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlZmZlY3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIG1lLiNiaW5kaW5nRWZmZWN0cy5kZWxldGUoY29tcG9uZW50SWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoZSBlZmZlY3QgaXMgcmV0dXJuZWQgdG8gYmUgbWFuYWdlZCBieSB0aGUgY29tcG9uZW50LlxuICAgICAgICByZXR1cm4gZWZmZWN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgY29tcG9uZW50J3MgYGJpbmRgIGNvbmZpZ3VyYXRpb24gdG8gY3JlYXRlIHJlYWN0aXZlIGJpbmRpbmdzLlxuICAgICAqIEl0IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gc3RvcmUgYmluZGluZ3MgYW5kIGRhdGEgYmluZGluZ3MsIGFuZCBzZXRzIHVwIHR3by13YXkgYmluZGluZyBpZiBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IGluc3RhbmNlIHdob3NlIGJpbmRpbmdzIGFyZSB0byBiZSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmdzKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBoYXNUd29XYXlCaW5kaW5nID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29tcG9uZW50LmJpbmQgfHwge30pLmZvckVhY2goKFtjb25maWdLZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgbGV0IGtleSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYmluZGluZyB2YWx1ZSBpcyBhbiBvYmplY3QsIGl0IG1pZ2h0IGNvbnRhaW4gYHR3b1dheWAgb3IgYSBzcGVjaWZpYyBga2V5YC5cbiAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR3b1dheSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNUd29XYXlCaW5kaW5nID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSB2YWx1ZS5rZXlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGl0J3MgYSBzdG9yZSBiaW5kaW5nIG9yIGEgZGF0YSBiaW5kaW5nLlxuICAgICAgICAgICAgaWYgKG1lLmlzU3RvcmVWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0b3JlIGJpbmRpbmdzLCByZXNvbHZlIHRoZSBzdG9yZSBhbmQgYXNzaWduIGl0IHRvIHRoZSBjb21wb25lbnQgY29uZmlnLlxuICAgICAgICAgICAgICAgIG1lLnJlc29sdmVTdG9yZShjb21wb25lbnQsIGNvbmZpZ0tleSwga2V5LnN1YnN0cmluZyg3KSkgLy8gcmVtb3ZlIHRoZSBcInN0b3Jlcy5cIiBwcmVmaXhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGRhdGEgYmluZGluZ3MsIGNyZWF0ZSBhbiBFZmZlY3QgdG8ga2VlcCB0aGUgY29tcG9uZW50IGNvbmZpZyBpbiBzeW5jIHdpdGggdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgbWUuY3JlYXRlQmluZGluZyhjb21wb25lbnQuaWQsIGNvbmZpZ0tleSwga2V5LCB2YWx1ZS50d29XYXkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1hcmsgdGhlIGNvbXBvbmVudCBpZiBpdCBoYXMgYW55IHR3by13YXkgYmluZGluZ3MsIGZvciBpbnRlcm5hbCB0cmFja2luZy5cbiAgICAgICAgaWYgKGhhc1R3b1dheUJpbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFt0d29XYXlCaW5kaW5nU3ltYm9sXSA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBzdGF0ZSBwcm92aWRlciBhbmQgY2xlYW5zIHVwIGFsbCBhc3NvY2lhdGVkIGVmZmVjdHMuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLiNmb3JtdWxhRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QuZGVzdHJveSgpKTtcbiAgICAgICAgbWUuI2Zvcm11bGFFZmZlY3RzLmNsZWFyKCk7XG5cbiAgICAgICAgbWUuI2JpbmRpbmdFZmZlY3RzLmZvckVhY2goZWZmZWN0ID0+IGVmZmVjdC5kZXN0cm95KCkpO1xuICAgICAgICBtZS4jYmluZGluZ0VmZmVjdHMuY2xlYXIoKTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldENvbnRyb2xsZXIobnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmdldENvbnRyb2xsZXIobnR5cGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjZXNzIHRoZSBjbG9zZXN0IGRhdGEgcHJvcGVydHkgaW5zaWRlIHRoZSBwYXJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldERhdGEoa2V5KSB7XG4gICAgICAgIGNvbnN0IG93bmVyRGV0YWlscyA9IHRoaXMuZ2V0T3duZXJPZkRhdGFQcm9wZXJ0eShrZXkpO1xuXG4gICAgICAgIGlmIChvd25lckRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBvd25lckRldGFpbHMub3duZXIuZ2V0RGF0YUNvbmZpZyhvd25lckRldGFpbHMucHJvcGVydHlOYW1lKS5nZXQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1bmRlcmx5aW5nIGNvcmUuQ29uZmlnIGluc3RhbmNlIGZvciBhIGdpdmVuIGRhdGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgZnVsbCBwYXRoIG9mIHRoZSBkYXRhIHByb3BlcnR5IChlLmcuLCAndXNlci5maXJzdG5hbWUnKS5cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvcmUuQ29uZmlnfG51bGx9XG4gICAgICovXG4gICAgZ2V0RGF0YUNvbmZpZyhwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkYXRhQ29uZmlnc1twYXRoXSB8fCBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVyZ2VkLCBoaWVyYXJjaGljYWwgZGF0YSBvYmplY3QgYXMgYSByZWFjdGl2ZSBQcm94eS5cbiAgICAgKiBAcmV0dXJucyB7UHJveHl9XG4gICAgICovXG4gICAgZ2V0SGllcmFyY2h5RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFQcm94eSh0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzdGF0ZS5Qcm92aWRlciBpbnN0YW5jZSB0aGF0IG93bnMgYSBzcGVjaWZpYyBkYXRhIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBmdWxsIHBhdGggb2YgdGhlIGRhdGEgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge3tvd25lcjogTmVvLnN0YXRlLlByb3ZpZGVyLCBwcm9wZXJ0eU5hbWU6IFN0cmluZ318bnVsbH1cbiAgICAgKi9cbiAgICBnZXRPd25lck9mRGF0YVByb3BlcnR5KHBhdGgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuI2RhdGFDb25maWdzW3BhdGhdKSB7XG4gICAgICAgICAgICByZXR1cm4ge293bmVyOiBtZSwgcHJvcGVydHlOYW1lOiBwYXRofVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHBhcmVudCBvd25lcnNoaXBcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbWUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuZ2V0T3duZXJPZkRhdGFQcm9wZXJ0eShwYXRoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsb3Nlc3Qgc3RhdGVQcm92aWRlciBpbnNpZGUgdGhlIGNvbXBvbmVudHMgcGFyZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIEFjY2VzcyB0aGUgaW50ZXJuYWwgdmFsdWUgb2YgdGhlIHBhcmVudF8gY29uZmlnIGRpcmVjdGx5LlxuICAgICAgICAvLyBUaGlzIGF2b2lkcyByZWN1cnNpdmUgY2FsbHMgdG8gdGhlIGdldHRlci5cbiAgICAgICAgaWYgKG1lLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZS5fcGFyZW50XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBleHBsaWNpdCBwYXJlbnQgaXMgc2V0LCB0cnkgdG8gZmluZCBpdCBkeW5hbWljYWxseSB2aWEgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgLy8gRW5zdXJlIHRoaXMuY29tcG9uZW50IGV4aXN0cyBiZWZvcmUgdHJ5aW5nIHRvIGFjY2VzcyBpdHMgcGFyZW50LlxuICAgICAgICBpZiAobWUuY29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuY29tcG9uZW50LnBhcmVudD8uZ2V0U3RhdGVQcm92aWRlcigpIHx8IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IHBhcmVudCBhbmQgbm8gY29tcG9uZW50IHRvIGRlcml2ZSBpdCBmcm9tLlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY2VzcyB0aGUgY2xvc2VzdCBzdG9yZSBpbnNpZGUgdGhlIFZNIHBhcmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IG9yaWdpblN0YXRlUHJvdmlkZXI9dGhpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKi9cbiAgICBnZXRTdG9yZShrZXksIG9yaWdpblN0YXRlUHJvdmlkZXI9dGhpcykge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3N0b3Jlc30gPSBtZSxcbiAgICAgICAgICAgIHBhcmVudFN0YXRlUHJvdmlkZXI7XG5cbiAgICAgICAgaWYgKHN0b3Jlcz8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3Jlc1trZXldXG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRTdGF0ZVByb3ZpZGVyID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKCFwYXJlbnRTdGF0ZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBzdG9yZSAnJHtrZXl9JyBub3QgZm91bmQgaW5zaWRlIHRoaXMgc3RhdGVQcm92aWRlciBvciBwYXJlbnRzLmAsIG9yaWdpblN0YXRlUHJvdmlkZXIpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50U3RhdGVQcm92aWRlci5nZXRTdG9yZShrZXksIG9yaWdpblN0YXRlUHJvdmlkZXIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFueSBkYXRhIHByb3BlcnR5IGluIHRoZSBoaWVyYXJjaHkgc3RhcnRzIHdpdGggdGhlIGdpdmVuIHBhdGguXG4gICAgICogVGhpcyBpcyB1c2VkIGJ5IHRoZSBIaWVyYXJjaGljYWxEYXRhUHJveHkgdG8gZGV0ZXJtaW5lIGlmIGl0IHNob3VsZCByZXR1cm4gYSBuZXN0ZWQgcHJveHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2sgKGUuZy4sICd1c2VyJykuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzTmVzdGVkRGF0YVN0YXJ0aW5nV2l0aChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHBhdGhXaXRoRG90ID0gYCR7cGF0aH0uYDtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy4jZGF0YUNvbmZpZ3MpLnNvbWUoa2V5ID0+IGtleS5zdGFydHNXaXRoKHBhdGhXaXRoRG90KSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnQoKT8uaGFzTmVzdGVkRGF0YVN0YXJ0aW5nV2l0aChwYXRoKSB8fCBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvcC1sZXZlbCBkYXRhIGtleXMgZm9yIGEgZ2l2ZW4gcGF0aCB3aXRoaW4gdGhpcyBwcm92aWRlcidzIGRhdGEuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gZ2V0IGtleXMgZm9yIChlLmcuLCAndXNlci5hZGRyZXNzJykuXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldFRvcExldmVsRGF0YUtleXMocGF0aCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAga2V5cyAgICAgICA9IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHBhdGhQcmVmaXggPSBwYXRoID8gYCR7cGF0aH0uYCA6ICcnO1xuXG4gICAgICAgIGZvciAoY29uc3QgZnVsbFBhdGggaW4gdGhpcy4jZGF0YUNvbmZpZ3MpIHtcbiAgICAgICAgICAgIGlmIChmdWxsUGF0aC5zdGFydHNXaXRoKHBhdGhQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gZnVsbFBhdGguc3Vic3RyaW5nKHBhdGhQcmVmaXgubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxLZXkgID0gcmVsYXRpdmVQYXRoLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAodG9wTGV2ZWxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5hZGQodG9wTGV2ZWxLZXkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oa2V5cylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIG1ldGhvZCBmb3Igc2V0dGluZyBkYXRhLCBwcm92aWRpbmcgYSBzaW5nbGUgZW50cnkgcG9pbnQgZm9yIGFsbCBkYXRhIG1vZGlmaWNhdGlvbnMuXG4gICAgICogSXQgaGFuZGxlcyBtdWx0aXBsZSBzY2VuYXJpb3M6XG4gICAgICogMS4gICoqT2JqZWN0LWJhc2VkIHVwZGF0ZXM6KiogSWYgYGtleWAgaXMgYW4gb2JqZWN0LCBpdCByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgZm9yIGVhY2gga2V5LXZhbHVlIHBhaXIuXG4gICAgICogMi4gICoqRGF0YSBSZWNvcmRzOioqIElmIGB2YWx1ZWAgaXMgYSBgTmVvLmRhdGEuUmVjb3JkYCwgaXQgaXMgdHJlYXRlZCBhcyBhbiBhdG9taWMgdmFsdWUgYW5kIHNldCBkaXJlY3RseS5cbiAgICAgKiAzLiAgKipCdWJibGluZyBSZWFjdGl2aXR5OioqIEZvciBhIGdpdmVuIGtleSAoZS5nLiwgJ3VzZXIubmFtZScpLCBpdCBzZXRzIHRoZSBsZWFmIHZhbHVlIGFuZCB0aGVuIFwiYnViYmxlcyB1cFwiXG4gICAgICogICAgIHRoZSBjaGFuZ2UsIGNyZWF0aW5nIG5ldyBwYXJlbnQgb2JqZWN0cyAoZS5nLiwgJ3VzZXInKSB0byBlbnN1cmUgdGhhdCBlZmZlY3RzIGRlcGVuZGluZyBvbiBhbnkgcGFydFxuICAgICAqICAgICBvZiB0aGUgcGF0aCBhcmUgdHJpZ2dlcmVkLlxuICAgICAqXG4gICAgICogQWxsIHVwZGF0ZXMgYXJlIGJhdGNoZWQgYnkgdGhlIHB1YmxpYyBgc2V0RGF0YWAgbWV0aG9kcyB0byBlbnN1cmUgZWZmZWN0cyBydW4gb25seSBvbmNlLlxuICAgICAqIFVzZSBgc2V0RGF0YSgpYCBvciBgc2V0RGF0YUF0U2FtZUxldmVsKClgIGluc3RlYWQgb2YgY2FsbGluZyB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSB0byBzZXQsIG9yIGFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TmVvLnN0YXRlLlByb3ZpZGVyfSBbb3JpZ2luU3RhdGVQcm92aWRlcl0gVGhlIHByb3ZpZGVyIHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbSBmb3IgaGllcmFyY2hpY2FsIHVwZGF0ZXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCBvcmlnaW5TdGF0ZVByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGtleSkuZm9yRWFjaCgoW2RhdGFLZXksIGRhdGFWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBtZS5pbnRlcm5hbFNldERhdGEoZGF0YUtleSwgZGF0YVZhbHVlLCBvcmlnaW5TdGF0ZVByb3ZpZGVyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyAna2V5JyBpcyBhIHN0cmluZyBwYXRoLlxuICAgICAgICAvLyBJZiAndmFsdWUnIGlzIGEgcGxhaW4gb2JqZWN0LCB3ZSBuZWVkIHRvIGRyaWxsIGRvd24gZnVydGhlci5cbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgTmVvLmRhdGEuUmVjb3JkLCB0cmVhdCBpdCBhcyBhbiBhdG9taWMgdmFsdWUgPT4gaXQgd2lsbCBub3QgZW50ZXIgdGhpcyBibG9jay5cbiAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtuZXN0ZWRLZXksIG5lc3RlZFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gYCR7a2V5fS4ke25lc3RlZEtleX1gO1xuICAgICAgICAgICAgICAgIG1lLmludGVybmFsU2V0RGF0YShmdWxsUGF0aCwgbmVzdGVkVmFsdWUsIG9yaWdpblN0YXRlUHJvdmlkZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gLy8gV2UndmUgZGVsZWdhdGVkIHRoZSBzZXR0aW5nIHRvIGRlZXBlciBwYXRocy5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBvd25lckRldGFpbHMgICA9IG1lLmdldE93bmVyT2ZEYXRhUHJvcGVydHkoa2V5KSxcbiAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyID0gb3duZXJEZXRhaWxzID8gb3duZXJEZXRhaWxzLm93bmVyIDogKG9yaWdpblN0YXRlUHJvdmlkZXIgfHwgbWUpO1xuXG4gICAgICAgIG1lLiNzZXRDb25maWdWYWx1ZSh0YXJnZXRQcm92aWRlciwga2V5LCB2YWx1ZSwgbnVsbCk7XG5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgXCJyZWFjdGl2aXR5IGJ1YmJsaW5nXCIgbG9naWMuIFdoZW4gYSBsZWFmIHByb3BlcnR5IGxpa2UgJ3VzZXIubmFtZScgY2hhbmdlcyxcbiAgICAgICAgLy8gd2UgbXVzdCBhbHNvIHRyaWdnZXIgZWZmZWN0cyB0aGF0IGRlcGVuZCBvbiB0aGUgcGFyZW50IG9iamVjdCAndXNlcicuIFdlIGRvIHRoaXMgYnlcbiAgICAgICAgLy8gY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHJlZmVyZW5jZSBmb3IgZWFjaCBwYXJlbnQgaW4gdGhlIHBhdGguIFRoZSBzcHJlYWQgc3ludGF4XG4gICAgICAgIC8vIGB7IC4uLm9sZFBhcmVudFZhbHVlLCBbbGVhZktleV06IGxhdGVzdFZhbHVlIH1gIGlzIGtleSwgYXMgaXQgY3JlYXRlcyBhIG5ld1xuICAgICAgICAvLyBvYmplY3QsIHdoaWNoIHRoZSByZWFjdGl2aXR5IHN5c3RlbSBkZXRlY3RzIGFzIGEgY2hhbmdlLlxuICAgICAgICBsZXQgcGF0aCAgICAgICAgPSBrZXksXG4gICAgICAgICAgICBsYXRlc3RWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlIChwYXRoLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWZLZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sYXN0SW5kZXhPZignLicpKTtcblxuICAgICAgICAgICAgY29uc3QgcGFyZW50Q29uZmlnID0gdGFyZ2V0UHJvdmlkZXIuZ2V0RGF0YUNvbmZpZyhwYXRoKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcmVudFZhbHVlID0gcGFyZW50Q29uZmlnLmdldCgpO1xuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3Qob2xkUGFyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcmVudFZhbHVlID0geyAuLi5vbGRQYXJlbnRWYWx1ZSwgW2xlYWZLZXldOiBsYXRlc3RWYWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcuc2V0KG5ld1BhcmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWUgPSBuZXdQYXJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhayAvLyBTdG9wIGlmIHBhcmVudCBpcyBub3QgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyZW50IGNvbmZpZyBkb2Vzbid0IGV4aXN0LCB3ZSBuZWVkIHRvIGNyZWF0ZSBpdCB0byBzdXBwb3J0IGJ1YmJsaW5nLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgY3J1Y2lhbCBmb3IgY3JlYXRpbmcgbmV3IG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgYXQgcnVudGltZS5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXJlbnRWYWx1ZSA9IHtbbGVhZktleV06IGxhdGVzdFZhbHVlfTtcbiAgICAgICAgICAgICAgICBtZS4jc2V0Q29uZmlnVmFsdWUodGFyZ2V0UHJvdmlkZXIsIHBhdGgsIG5ld1BhcmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZSA9IG5ld1BhcmVudFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb252ZW5pZW5jZSBtZXRob2QgdG8gY2hlY2sgaWYgYSBiaW5kaW5nIHZhbHVlIGlzIHN1cHBvc2VkIHRvIG1hdGNoIGEgc3RvcmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1N0b3JlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE5lby5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aCgnc3RvcmVzLicpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgYWxsIGNvbnN0cnVjdG9ycyAmIGNvbmZpZ3MgYXJlIGFwcGxpZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgcHJvdmlkZXIgaXMgZnVsbHkgY29uc3RydWN0ZWQgYW5kIGluaXRpYWwgZGF0YSBpcyBzZXQsXG4gICAgICAgIC8vIHJ1biB0aGUgZm9ybXVsYSBlZmZlY3RzIGZvciB0aGUgZmlyc3QgdGltZSB0byBjb21wdXRlIHRoZWlyIGluaXRpYWwgdmFsdWVzLlxuICAgICAgICB0aGlzLiNmb3JtdWxhRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QucnVuKCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgb25EYXRhUHJvcGVydHlDaGFuZ2Uoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHByb2Nlc3NlcyBhIGRhdGEgb2JqZWN0LCBjcmVhdGluZyBvciB1cGRhdGluZyBOZW8uY29yZS5Db25maWcgaW5zdGFuY2VzXG4gICAgICogZm9yIGVhY2ggcHJvcGVydHkgYW5kIHN0b3JpbmcgdGhlbSBpbiB0aGUgI2RhdGFDb25maWdzIG1hcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBkYXRhIG9iamVjdCB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aD0nJ10gVGhlIGN1cnJlbnQgcGF0aCBwcmVmaXggZm9yIG5lc3RlZCBvYmplY3RzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm9jZXNzRGF0YU9iamVjdChvYmosIHBhdGggPSAnJykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5O1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgYSBDb25maWcgaW5zdGFuY2UgZXhpc3RzIGZvciB0aGUgY3VycmVudCBmdWxsUGF0aFxuICAgICAgICAgICAgaWYgKG1lLiNkYXRhQ29uZmlnc1tmdWxsUGF0aF0pIHtcbiAgICAgICAgICAgICAgICBtZS4jZGF0YUNvbmZpZ3NbZnVsbFBhdGhdLnNldCh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuI2RhdGFDb25maWdzW2Z1bGxQYXRoXSA9IG5ldyBDb25maWcodmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgcmVjdXJzaXZlbHkgcHJvY2VzcyBpdHMgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKE5lby50eXBlT2YodmFsdWUpID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG1lLnByb2Nlc3NEYXRhT2JqZWN0KHZhbHVlLCBmdWxsUGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICBjb25maWdOYW1lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgIHN0b3JlTmFtZVxuICAgICAqL1xuICAgIHJlc29sdmVTdG9yZShjb21wb25lbnQsIGNvbmZpZ05hbWUsIHN0b3JlTmFtZSkge1xuICAgICAgICBsZXQgc3RvcmUgPSB0aGlzLmdldFN0b3JlKHN0b3JlTmFtZSk7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudFtjb25maWdOYW1lXSAhPT0gc3RvcmUpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFtjb25maWdOYW1lXSA9IHN0b3JlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IGEgY29uZmlnIHZhbHVlIGFuZCB0cmlnZ2VyIHJlYWN0aXZpdHkuXG4gICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBDb25maWcgaW5zdGFuY2UgaWYgb25lIGRvZXNuJ3QgZXhpc3QgZm9yIHRoZSBnaXZlbiBwYXRoLFxuICAgICAqIG9yIHVwZGF0ZXMgYW4gZXhpc3Rpbmcgb25lLiBJdCBhbHNvIHRyaWdnZXJzIGJpbmRpbmcgZWZmZWN0cyBhbmQgY2FsbHMgb25EYXRhUHJvcGVydHlDaGFuZ2UuXG4gICAgICogQHBhcmFtIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IHByb3ZpZGVyIFRoZSBTdGF0ZVByb3ZpZGVyIGluc3RhbmNlIG93bmluZyB0aGUgY29uZmlnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICBwYXRoICAgICBUaGUgZnVsbCBwYXRoIG9mIHRoZSBkYXRhIHByb3BlcnR5IChlLmcuLCAndXNlci5maXJzdG5hbWUnKS5cbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgICAgICAgICAgW29sZFZhbF0gIFRoZSBvbGQgdmFsdWUgKG9wdGlvbmFsLCB1c2VkIGZvciBpbml0aWFsIHNldHVwKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNzZXRDb25maWdWYWx1ZShwcm92aWRlciwgcGF0aCwgbmV3VmFsdWUsIG9sZFZhbCkge1xuICAgICAgICBsZXQgY3VycmVudENvbmZpZyA9IHByb3ZpZGVyLmdldERhdGFDb25maWcocGF0aCksXG4gICAgICAgICAgICBoYXNDaGFuZ2UgICAgID0gdHJ1ZSxcbiAgICAgICAgICAgIG9sZFZhbHVlICAgICAgPSBvbGRWYWw7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlICA9IGN1cnJlbnRDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICBoYXNDaGFuZ2UgPSBjdXJyZW50Q29uZmlnLnNldChuZXdWYWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRDb25maWcgPSBuZXcgQ29uZmlnKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLiNkYXRhQ29uZmlnc1twYXRoXSA9IGN1cnJlbnRDb25maWc7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGFsbCBiaW5kaW5nIGVmZmVjdHMgdG8gcmUtZXZhbHVhdGUgdGhlaXIgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICBwcm92aWRlci4jYmluZGluZ0VmZmVjdHMuZm9yRWFjaChlZmZlY3QgPT4gZWZmZWN0LnJ1bigpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0NoYW5nZSkge1xuICAgICAgICAgICAgLy8gTm90aWZ5IHN1YnNjcmliZXJzIG9mIHRoZSBkYXRhIHByb3BlcnR5IGNoYW5nZS5cbiAgICAgICAgICAgIHByb3ZpZGVyLm9uRGF0YVByb3BlcnR5Q2hhbmdlKHBhdGgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2Qgd2lsbCBhc3NpZ24gYWxsIHZhbHVlcyB0byB0aGUgY2xvc2VzdCBzdGF0ZVByb3ZpZGVyIHdoZXJlIGl0IGZpbmRzIGFuIGV4aXN0aW5nIGtleS5cbiAgICAgKiBJbiBjYXNlIG5vIG1hdGNoIGlzIGZvdW5kIGluc2lkZSB0aGUgcGFyZW50IGNoYWluLCBhIG5ldyBkYXRhIHByb3BlcnR5IHdpbGwgZ2V0IGdlbmVyYXRlZC5cbiAgICAgKlxuICAgICAqIEFsbCB1cGRhdGVzIHdpdGhpbiBhIHNpbmdsZSBjYWxsIGFyZSBiYXRjaGVkIHRvIGVuc3VyZSB0aGF0IHJlYWN0aXZlIGVmZmVjdHMgKGJpbmRpbmdzIGFuZCBmb3JtdWxhcylcbiAgICAgKiBhcmUgcnVuIG9ubHkgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgICAgICB2YWx1ZVxuICAgICAqL1xuICAgIHNldERhdGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICBFZmZlY3RNYW5hZ2VyLnBhdXNlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCB0aGlzKVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIGluc3RlYWQgb2Ygc2V0RGF0YSgpIGluIGNhc2UgeW91IHdhbnQgdG8gZW5mb3JjZVxuICAgICAqIHNldHRpbmcgYWxsIGtleXMgb24gdGhpcyBpbnN0YW5jZSBpbnN0ZWFkIG9mIGxvb2tpbmcgZm9yIG1hdGNoZXMgaW5zaWRlIHBhcmVudCBzdGF0ZVByb3ZpZGVycy5cbiAgICAgKlxuICAgICAqIEFsbCB1cGRhdGVzIHdpdGhpbiBhIHNpbmdsZSBjYWxsIGFyZSBiYXRjaGVkIHRvIGVuc3VyZSB0aGF0IHJlYWN0aXZlIGVmZmVjdHMgKGJpbmRpbmdzIGFuZCBmb3JtdWxhcylcbiAgICAgKiBhcmUgcnVuIG9ubHkgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgICAgICB2YWx1ZVxuICAgICAqL1xuICAgIHNldERhdGFBdFNhbWVMZXZlbChrZXksIHZhbHVlKSB7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2UoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTZXREYXRhKGtleSwgdmFsdWUpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFByb3ZpZGVyKTtcbiIsImltcG9ydCBFZmZlY3RNYW5hZ2VyIGZyb20gJy4uL2NvcmUvRWZmZWN0TWFuYWdlci5tanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXN0ZWQgUHJveHkgdGhhdCByZXByZXNlbnRzIGEgbGV2ZWwgaW4gdGhlIGhpZXJhcmNoaWNhbCBkYXRhIHN0cnVjdHVyZS5cbiAqIEBwYXJhbSB7TmVvLnN0YXRlLlByb3ZpZGVyfSByb290UHJvdmlkZXIgVGhlIHRvcC1sZXZlbCBwcm92aWRlciB0byBzdGFydCBzZWFyY2hlcyBmcm9tLlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIGN1cnJlbnQgcGF0aCBvZiB0aGlzIHByb3h5IGxldmVsIChlLmcuLCAndXNlcicgZm9yIGRhdGEudXNlcikuXG4gKiBAcmV0dXJucyB7UHJveHl8bnVsbH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5lc3RlZFByb3h5KHJvb3RQcm92aWRlciwgcGF0aCkge1xuICAgIC8vIFRoZSB0YXJnZXQgb2JqZWN0IGZvciB0aGUgcHJveHkgY2FuIGJlIGVtcHR5IGJlY2F1c2UgYWxsIGxvb2t1cHMgYXJlIGR5bmFtaWMuXG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG5cbiAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGdldCB0cmFwIGZvciB0aGUgcHJveHkuIFRoaXMgaXMgd2hlcmUgdGhlIG1hZ2ljIGhhcHBlbnMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50VGFyZ2V0IFRoZSBwcm94eSdzIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGJlaW5nIGFjY2Vzc2VkLlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBvciBhIG5ldyBwcm94eSBmb3IgbmVzdGVkIGFjY2Vzcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldChjdXJyZW50VGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludGVybmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSBzZXQgZGlyZWN0bHkgb24gdGhlIHByb3h5J3MgdGFyZ2V0XG4gICAgICAgICAgICAvLyBvciBhcmUgZXhwZWN0ZWQgYnkgdGhlIGVudmlyb25tZW50IChsaWtlIFNpZXN0YSdzIF9fUkVGQURSX18pLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N5bWJvbCcgfHwgcHJvcGVydHkgPT09ICdfX1JFRkFEUl9fJyB8fCBwcm9wZXJ0eSA9PT0gJ2luc3BlY3QnIHx8IHByb3BlcnR5ID09PSAndGhlbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoY3VycmVudFRhcmdldCwgcHJvcGVydHkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgYWxsb3cgc3RyaW5nIG9yIG51bWJlciBwcm9wZXJ0aWVzIHRvIHByb2NlZWQgYXMgZGF0YSBwYXRocy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBGb3Igb3RoZXIgbm9uLXN0cmluZy9ub24tbnVtYmVyIHByb3BlcnRpZXMsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoZSAnc3RvcmVzJyBwcm9wZXJ0eSBhdCB0aGUgcm9vdCBsZXZlbFxuICAgICAgICAgICAgaWYgKHBhdGggPT09ICcnICYmIHByb3BlcnR5ID09PSAnc3RvcmVzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlTmFtZSA9PT0gJ3N5bWJvbCcgfHwgc3RvcmVOYW1lID09PSAnX19SRUZBRFJfXycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBzdG9yZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgU3RhdGVQcm92aWRlcidzIGdldFN0b3JlIG1ldGhvZCBmb3IgaGllcmFyY2hpY2FsIHJlc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyBzdG9yZS5jb3VudCBsYXRlciB3aWxsIHJlZ2lzdGVyIHRoZSBkZXBlbmRlbmN5IHZpYSB0aGUgQ29uZmlnIHN5c3RlbVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RQcm92aWRlci5nZXRTdG9yZShzdG9yZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGggPyBgJHtwYXRofS4ke3Byb3BlcnR5fWAgOiBwcm9wZXJ0eTtcblxuICAgICAgICAgICAgLy8gMS4gQ2hlY2sgaWYgdGhlIGZ1bGwgcGF0aCBjb3JyZXNwb25kcyB0byBhbiBhY3R1YWwgZGF0YSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGNvbnN0IG93bmVyRGV0YWlscyA9IHJvb3RQcm92aWRlci5nZXRPd25lck9mRGF0YVByb3BlcnR5KGZ1bGxQYXRoKTtcblxuICAgICAgICAgICAgaWYgKG93bmVyRGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHtvd25lciwgcHJvcGVydHlOYW1lfSA9IG93bmVyRGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnICAgICAgICAgICAgICAgID0gb3duZXIuZ2V0RGF0YUNvbmZpZyhwcm9wZXJ0eU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLmdldEFjdGl2ZUVmZmVjdCgpPy5hZGREZXBlbmRlbmN5KGNvbmZpZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIHJldHVybiBhIG5ldyBwcm94eSBmb3IgaXQgdG8gZW5zdXJlIG5lc3RlZCBhY2Nlc3NlcyBhcmUgYWxzbyBwcm94aWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5lc3RlZFByb3h5KHJvb3RQcm92aWRlciwgZnVsbFBhdGgpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDIuIElmIG5vdCBhIGRpcmVjdCBtYXRjaCwgaXQgbWlnaHQgYmUgYSBwYXJlbnQgb2JqZWN0IG9mIGEgbmVzdGVkIHByb3BlcnR5XG4gICAgICAgICAgICAvLyAgICAoZS5nLiwgYWNjZXNzaW5nIGB1c2VyYCB3aGVuIGEgYHVzZXIuZmlyc3RuYW1lYCBiaW5kaW5nIGV4aXN0cykuXG4gICAgICAgICAgICAvLyAgICBJbiB0aGlzIGNhc2UsIHdlIHJldHVybiBhbm90aGVyIHByb3h5IGZvciB0aGUgbmV4dCBsZXZlbCBkb3duLlxuICAgICAgICAgICAgaWYgKHJvb3RQcm92aWRlci5oYXNOZXN0ZWREYXRhU3RhcnRpbmdXaXRoKGZ1bGxQYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXN0ZWRQcm94eShyb290UHJvdmlkZXIsIGZ1bGxQYXRoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAzLiBJZiBpdCdzIG5laXRoZXIgYSBkYXRhIHByb3BlcnR5IG5vciBhIHBhdGggdG8gb25lLCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgLy8gICAgUmV0dXJuaW5nIHVuZGVmaW5lZCBlbnN1cmVzIHRoYXQgY2hhaW5lZCBhY2Nlc3NlcyAoZS5nLiwgZGF0YS5ub25leGlzdGVudC5wcm9wZXJ0eSkgZmFpbCBncmFjZWZ1bGx5LlxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChjdXJyZW50VGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IGludGVybmFsIHByb3BlcnRpZXMgKGxpa2UgU3ltYm9scyBvciBzcGVjaWZpYyBzdHJpbmdzKSB0byBiZSBzZXQgZGlyZWN0bHkgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzeW1ib2wnIHx8IHByb3BlcnR5ID09PSAnX19SRUZBRFJfXycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQoY3VycmVudFRhcmdldCwgcHJvcGVydHksIHZhbHVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIGZ1bGxQYXRoICAgICA9IHBhdGggPyBgJHtwYXRofS4ke3Byb3BlcnR5fWAgOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBvd25lckRldGFpbHMgPSByb290UHJvdmlkZXIuZ2V0T3duZXJPZkRhdGFQcm9wZXJ0eShmdWxsUGF0aCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0UHJvdmlkZXI7XG5cbiAgICAgICAgICAgIGlmIChvd25lckRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRQcm92aWRlciA9IG93bmVyRGV0YWlscy5vd25lclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBvd25lciBpcyBmb3VuZCwgc2V0IGl0IG9uIHRoZSByb290UHJvdmlkZXIgKHRoZSBvbmUgdGhhdCBjcmVhdGVkIHRoaXMgcHJveHkpXG4gICAgICAgICAgICAgICAgdGFyZ2V0UHJvdmlkZXIgPSByb290UHJvdmlkZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0UHJvdmlkZXIuc2V0RGF0YShmdWxsUGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWUgLy8gSW5kaWNhdGUgdGhhdCB0aGUgYXNzaWdubWVudCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICB9LFxuXG4gICAgICAgIG93bktleXMoY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RQcm92aWRlci5nZXRUb3BMZXZlbERhdGFLZXlzKHBhdGgpXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN1cnJlbnRUYXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgIGZ1bGxQYXRoICAgICA9IHBhdGggPyBgJHtwYXRofS4ke3Byb3BlcnR5fWAgOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBvd25lckRldGFpbHMgPSByb290UHJvdmlkZXIuZ2V0T3duZXJPZkRhdGFQcm9wZXJ0eShmdWxsUGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChvd25lckRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBvd25lckRldGFpbHMub3duZXIuZ2V0RGF0YUNvbmZpZyhvd25lckRldGFpbHMucHJvcGVydHlOYW1lKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA6IE5lby5pc09iamVjdCh2YWx1ZSkgPyBjcmVhdGVOZXN0ZWRQcm94eShyb290UHJvdmlkZXIsIGZ1bGxQYXRoKSA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGUgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZSAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm94eSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBtZXJnZWQsIGhpZXJhcmNoaWNhbCBkYXRhIGZyb20gYSBgc3RhdGUuUHJvdmlkZXJgIGNoYWluLlxuICogV2hlbiBhIHByb3BlcnR5IGlzIGFjY2Vzc2VkIHRocm91Z2ggdGhpcyBwcm94eSB3aGlsZSBhbiBFZmZlY3QgaXMgcnVubmluZywgaXQgYXV0b21hdGljYWxseVxuICogdHJhY2tzIHRoZSB1bmRlcmx5aW5nIGNvcmUuQ29uZmlnIGluc3RhbmNlIGFzIGEgZGVwZW5kZW5jeS5cbiAqIEBwYXJhbSB7TmVvLnN0YXRlLlByb3ZpZGVyfSBwcm92aWRlciBUaGUgc3RhcnRpbmcgc3RhdGUuUHJvdmlkZXIuXG4gKiBAcmV0dXJucyB7UHJveHl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIaWVyYXJjaGljYWxEYXRhUHJveHkocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlTmVzdGVkUHJveHkocHJvdmlkZXIsICcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9