"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_state_Provider_mjs"],{

/***/ "./src/core/Effect.mjs":
/*!*****************************!*\
  !*** ./src/core/Effect.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _EffectBatchManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectBatchManager.mjs */ "./src/core/EffectBatchManager.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");




/**
 * Creates a reactive effect that automatically tracks its dependencies and re-runs when any of them change.
 * This is a lightweight, plain JavaScript class for performance.
 * It serves as a core reactive primitive, enabling automatic and dynamic dependency tracking.
 * @class Neo.core.Effect
 */
class Effect {
    /**
     * A Map containing Config instances as keys and their cleanup functions as values.
     * @member {Map} dependencies=new Map()
     * @protected
     */
    dependencies = new Map()
    /**
     * The function to execute.
     * @member {Function|null} _fn=null
     */
    _fn = null
    /**
     * The unique identifier for this effect instance.
     * @member {String|null}
     */
    id = _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getId('effect')
    /**
     * @member {Boolean}
     * @protected
     */
    isDestroyed = false
    /**
     * @member {Boolean}
     * @protected
     */
    isRunning = false

    /**
     * @member fn
     */
    get fn() {
        return this._fn
    }
    set fn(value) {
        this._fn = value;
        // Assigning a new function to `fn` automatically triggers a re-run.
        // This ensures that the effect immediately re-evaluates its dependencies
        // based on the new function's logic, clearing old dependencies and establishing new ones.
        this.run()
    }

    /**
     * @param {Object} config
     * @param {Function} config.fn The function to execute for the effect.
     */
    constructor({fn}) {
        this.fn = fn
    }

    /**
     * Cleans up all subscriptions and destroys the effect.
     */
    destroy() {
        const me = this;

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        me.isDestroyed = true
    }

    /**
     * Executes the effect function, tracking its dependencies.
     * This is called automatically on creation and whenever a dependency changes.
     * The dynamic re-tracking ensures the effect always reflects its current dependencies,
     * even if the logic within `fn` changes conditionally.
     * @protected
     */
    run() {
        const me = this;

        if (me.isDestroyed || me.isRunning) return;

        if (_EffectBatchManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBatchActive()) {
            _EffectBatchManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].queueEffect(me);
            return
        }

        me.isRunning = true;

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();

        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].push(me);

        try {
            me.fn()
        } finally {
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].pop();
            me.isRunning = false;
        }
    }

    /**
     * Adds a `Neo.core.Config` instance as a dependency for this effect.
     * @param {Neo.core.Config} config The config instance to subscribe to.
     * @protected
     */
    addDependency(config) {
        const me = this;

        // Only add if not already a dependency. Map uses strict equality (===) for object keys.
        if (!me.dependencies.has(config)) {
            const cleanup = config.subscribe({
                id: me.id,
                fn: me.run.bind(me)
            });

            me.dependencies.set(config, cleanup)
        }
    }
}

const ns = Neo.ns('Neo.core', true);
ns.Effect = Effect;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Effect);


/***/ }),

/***/ "./src/state/Provider.mjs":
/*!********************************!*\
  !*** ./src/state/Provider.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Effect.mjs */ "./src/core/Effect.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _createHierarchicalDataProxy_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createHierarchicalDataProxy.mjs */ "./src/state/createHierarchicalDataProxy.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");








const twoWayBindingSymbol = Symbol.for('twoWayBinding');

/**
 * An optional component state provider for adding bindings to configs
 * @class Neo.state.Provider
 * @extends Neo.core.Base
 */
class Provider extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.state.Provider'
         * @protected
         */
        className: 'Neo.state.Provider',
        /**
         * @member {String} ntype='state-provider'
         * @protected
         */
        ntype: 'state-provider',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         /**
         * The core data object managed by this StateProvider.
         * This object holds the reactive state that can be accessed and modified
         * by components and formulas within the provider's hierarchy.
         * Changes to properties within this data object will trigger reactivity.
         * When new data is assigned, it will be deeply merged with existing data.
         * @member {Object|null} data_=null
         * @example
         *     data: {
         *         user: {
         *             firstName: 'John',
         *             lastName : 'Doe'
         *         },
         *         settings: {
         *             theme: 'dark'
         *         }
         *     }
         */
        data_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_6__.isDescriptor]: true,
            merge         : 'deep',
            value         : {}
        },
        /**
         * Defines computed properties based on other data properties within the StateProvider hierarchy.
         * Each formula is a function that receives a `data` argument, which is a hierarchical proxy
         * allowing access to data from the current provider and all its parent providers.
         * Changes to dependencies (accessed via `data.propertyName`) will automatically re-run the formula.
         * @member {Object|null} formulas_=null
         * @example
         *     data: {
         *         a    : 1,
         *         b    : 2,
         *         total: 50
         *     }
         *     formulas: {
         *         aPlusB : (data) => data.a + data.b,
         *         aTimesB: (data) => data.a * data.b,
         *         // Accessing parent data (assuming a parent provider has a 'taxRate' property)
         *         totalWithTax: (data) => data.total * (1 + data.taxRate)
         *     }
         */
        formulas_: null,
        /**
         * @member {Neo.state.Provider|null} parent_=null
         */
        parent_: null,
        /**
         /**
         * A collection of Neo.data.Store instances managed by this StateProvider.
         * Stores are defined as config objects with a `module` property pointing
         * to the store class, which will then be instantiated by the framework.
         * @member {Object|null} stores_=null
         * @example
         *     stores: {
         *         myUsers: {
         *             module: Neo.data.Store,
         *             model : 'MyApp.model.User',
         *             data  : [{id: 1, name: 'John'}, {id: 2, name: 'Doe'}]
         *         },
         *         myCustomStore1: MyCustomStoreClass,
         *         myCustomStore2: {
         *             module  : MyCustomStoreClass,
         *             autoLoad: true
         *         }
         *     }
         */
        stores_: null
    }

    /**
     * @member {Map} #bindingEffects=new Map()
     * @private
     */
    #bindingEffects = new Map()
    /**
     * @member {Object} #dataConfigs={}
     * @private
     */
    #dataConfigs = {}
    /**
     * @member {Map} #formulaEffects=new Map()
     * @private
     */
    #formulaEffects = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        Neo.isUsingStateProviders = true;
        super.construct(config)
    }

    /**
     * Triggered after the data config got changed.
     * This method initializes the internal #dataConfigs map, converting each
     * plain data property into a reactive Neo.core.Config instance.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        value && this.processDataObject(value)
    }

    /**
     * Triggered after the formulas config got changed.
     * This method sets up reactive effects for each defined formula.
     * Each formula function receives the hierarchical data proxy, allowing implicit dependency tracking.
     * @param {Object|null} value The new formulas configuration.
     * @param {Object|null} oldValue The old formulas configuration.
     * @protected
     */
    afterSetFormulas(value, oldValue) {
        const me = this;

        // Destroy old formula effects to prevent memory leaks and stale calculations.
        me.#formulaEffects.forEach(effect => effect.destroy());
        me.#formulaEffects.clear();

        if (value) {
            Object.entries(value).forEach(([formulaKey, formulaFn]) => {
                // Create a new Effect for each formula. The Effect's fn will re-run whenever its dependencies change.
                const effect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]({
                    fn: () => {
                        const
                            hierarchicalData = me.getHierarchyData(), // Get the reactive data proxy
                            result           = formulaFn(hierarchicalData); // Execute the formula with the data

                        // Assign the result back to the state provider's data.
                        // This makes the formula's output available as a data property.
                        if (isNaN(result)) {
                            me.setData(formulaKey, null)
                        } else {
                            me.setData(formulaKey, result)
                        }
                    }
                });

                me.#formulaEffects.set(formulaKey, effect)
            })
        }
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getHierarchyData()
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        if (value) {
            let me = this;

            Object.entries(value).forEach(([key, storeValue]) => {
                // support mapping string based listeners into the stateProvider instance
                Object.entries(storeValue.listeners || {}).forEach(([listenerKey, listener]) => {
                    me.bindCallback(listener, listenerKey, me, storeValue.listeners)
                })

                value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(storeValue)
            })
        }

        return value
    }

    /**
     * Creates a new binding for a component's config to a data property.
     * This now uses the Effect-based reactivity system.
     * @param {String} componentId
     * @param {String} configKey The component config to bind (e.g., 'text').
     * @param {String|Function} formatter The function that computes the value.
     */
    createBinding(componentId, configKey, key, isTwoWay) {
        const
            me     = this,
            effect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]({
            fn: () => {
                const component = Neo.get(componentId);

                if (component && !component.isDestroyed) {
                    const
                        hierarchicalData = me.getHierarchyData(),
                        newValue         = Neo.isFunction(key) ? key.call(me, hierarchicalData) : hierarchicalData[key];

                    component._skipTwoWayPush = configKey;
                    component[configKey] = newValue;
                    delete component._skipTwoWayPush
                }
            }
        });

        me.#bindingEffects.set(componentId, effect);

        // The effect observes the component's destruction to clean itself up.
        me.observeConfig(componentId, 'isDestroying', (value) => {
            if (value) {
                effect.destroy();
                me.#bindingEffects.delete(componentId)
            }
        });

        // The effect is returned to be managed by the component.
        return effect
    }

    /**
     * Processes a component's `bind` configuration to create reactive bindings.
     * It differentiates between store bindings and data bindings, and sets up two-way binding if specified.
     * @param {Neo.component.Base} component The component instance whose bindings are to be created.
     */
    createBindings(component) {
        let hasTwoWayBinding = false;

        Object.entries(component.bind || {}).forEach(([configKey, value]) => {
            let key = value;

            // If the binding value is an object, it might contain `twoWay` or a specific `key`.
            if (Neo.isObject(value)) {
                if (value.twoWay) {
                    hasTwoWayBinding = true
                }
                key = value.key
            }

            // Determine if it's a store binding or a data binding.
            if (this.isStoreValue(key)) {
                // For store bindings, resolve the store and assign it to the component config.
                this.resolveStore(component, configKey, key.substring(7)) // remove the "stores." prefix
            } else {
                // For data bindings, create an Effect to keep the component config in sync with the data.
                this.createBinding(component.id, configKey, key, value.twoWay)
            }
        });

        // Mark the component if it has any two-way bindings, for internal tracking.
        if (hasTwoWayBinding) {
            component[twoWayBindingSymbol] = true
        }
    }

    /**
     * Destroys the state provider and cleans up all associated effects.
     */
    destroy() {
        const me = this;

        me.#formulaEffects.forEach(effect => effect.destroy());
        me.#formulaEffects.clear();

        me.#bindingEffects.forEach(effect => effect.destroy());
        me.#bindingEffects.clear();

        super.destroy()
    }

    /**
     * Convenience shortcut
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        return this.component.getController(ntype)
    }

    /**
     * Access the closest data property inside the parent chain.
     * @param {String} key
     * @returns {*} value
     */
    getData(key) {
        const ownerDetails = this.getOwnerOfDataProperty(key);

        if (ownerDetails) {
            return ownerDetails.owner.getDataConfig(ownerDetails.propertyName).get()
        }
    }

    /**
     * Retrieves the underlying core.Config instance for a given data property path.
     * @param {String} path The full path of the data property (e.g., 'user.firstname').
     * @returns {Neo.core.Config|null}
     */
    getDataConfig(path) {
        return this.#dataConfigs[path] || null
    }

    /**
     * Returns the merged, hierarchical data object as a reactive Proxy.
     * @returns {Proxy}
     */
    getHierarchyData() {
        return (0,_createHierarchicalDataProxy_mjs__WEBPACK_IMPORTED_MODULE_5__.createHierarchicalDataProxy)(this)
    }

    /**
     * Finds the state.Provider instance that owns a specific data property.
     * @param {String} path The full path of the data property.
     * @returns {{owner: Neo.state.Provider, propertyName: String}|null}
     */
    getOwnerOfDataProperty(path) {
        let me = this;

        if (me.#dataConfigs[path]) {
            return {owner: me, propertyName: path}
        }

        // Check for parent ownership
        const parent = me.getParent();
        if (parent) {
            return parent.getOwnerOfDataProperty(path)
        }

        return null
    }

    /**
     * Get the closest stateProvider inside the components parent tree
     * @returns {Neo.state.Provider|null}
     */
    getParent() {
        let me = this;

        // Access the internal value of the parent_ config directly.
        // This avoids recursive calls to the getter.
        if (me._parent) {
            return me._parent
        }

        // If no explicit parent is set, try to find it dynamically via the component.
        // Ensure this.component exists before trying to access its parent.
        if (me.component) {
            return me.component.parent?.getStateProvider() || null
        }

        // No explicit parent and no component to derive it from.
        return null
    }

    /**
     * Access the closest store inside the VM parent chain.
     * @param {String} key
     * @param {Neo.state.Provider} originStateProvider=this for internal usage only
     * @returns {Neo.data.Store}
     */
    getStore(key, originStateProvider=this) {
        let me       = this,
            {stores} = me,
            parentStateProvider;

        if (stores?.hasOwnProperty(key)) {
            return stores[key]
        }

        parentStateProvider = me.getParent();

        if (!parentStateProvider) {
            console.error(`store '${key}' not found inside this stateProvider or parents.`, originStateProvider)
        }

        return parentStateProvider.getStore(key, originStateProvider)
    }

    /**
     * Checks if any data property in the hierarchy starts with the given path.
     * This is used by the HierarchicalDataProxy to determine if it should return a nested proxy.
     * @param {String} path The path to check (e.g., 'user').
     * @returns {Boolean}
     */
    hasNestedDataStartingWith(path) {
        const pathWithDot = `${path}.`;

        if (Object.keys(this.#dataConfigs).some(key => key.startsWith(pathWithDot))) {
            return true
        }

        return this.getParent()?.hasNestedDataStartingWith(path) || false
    }

    /**
     * Returns the top-level data keys for a given path within this provider's data.
     * @param {String} path The path to get keys for (e.g., 'user.address').
     * @returns {String[]}
     */
    getTopLevelDataKeys(path) {
        const keys = new Set();
        const pathPrefix = path ? `${path}.` : '';

        for (const fullPath in this.#dataConfigs) {
            if (fullPath.startsWith(pathPrefix)) {
                const relativePath = fullPath.substring(pathPrefix.length);
                const topLevelKey = relativePath.split('.')[0];
                if (topLevelKey) {
                    keys.add(topLevelKey);
                }
            }
        }
        return Array.from(keys);
    }

    /**
     * Internal method to avoid code redundancy.
     * Use setData() or setDataAtSameLevel() instead.
     *
     * This method handles setting data properties, including nested paths and Neo.data.Record instances.
     * It determines the owning StateProvider in the hierarchy and delegates to #setConfigValue.
     *
     * Passing an originStateProvider param will try to set each key on the closest property match
     * inside the parent stateProvider chain => setData()
     * Not passing it will set all values on the stateProvider where the method gets called => setDataAtSameLevel()
     * @param {Object|String} key
     * @param {*} value
     * @param {Neo.state.Provider} [originStateProvider]
     * @protected
     */
    internalSetData(key, value, originStateProvider) {
        const me = this;

        // If the value is a Neo.data.Record, treat it as an atomic value
        // and set it directly without further recursive processing of its properties.
        if (Neo.isObject(value) && value.isRecord) {
            const
                ownerDetails   = me.getOwnerOfDataProperty(key),
                targetProvider = ownerDetails ? ownerDetails.owner : (originStateProvider || me);

            me.#setConfigValue(targetProvider, key, value, null);
            return
        }

        // If the key is an object, iterate over its entries and recursively call internalSetData.
        // This handles setting multiple properties at once (e.g., setData({prop1: val1, prop2: val2})).
        if (Neo.isObject(key)) {
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originStateProvider)
            });
            return
        }

        // Handle single key/value pairs, including nested paths (e.g., 'user.firstName').
        const
            ownerDetails   = me.getOwnerOfDataProperty(key),
            targetProvider = ownerDetails ? ownerDetails.owner : (originStateProvider || me),
            pathParts      = key.split('.');

        let currentPath     = '',
            currentConfig   = null,
            currentProvider = targetProvider;

        for (let i = 0; i < pathParts.length; i++) {
            const part = pathParts[i];
            currentPath = currentPath ? `${currentPath}.${part}` : part;
            currentConfig = currentProvider.getDataConfig(currentPath);

            if (i === pathParts.length - 1) { // Last part of the path
                // Set the value for the final property in the path.
                me.#setConfigValue(currentProvider, currentPath, value, null)
            } else { // Intermediate part of the path
                // Ensure intermediate paths exist as objects. If not, create them.
                // If an intermediate path exists but is not an object, overwrite it with an empty object.
                if (!currentConfig) {
                    currentConfig = new _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]({}); // Create an empty object config
                    currentProvider.#dataConfigs[currentPath] = currentConfig
                } else if (!Neo.isObject(currentConfig.get())) {
                    currentConfig.set({})
                }
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return Neo.isString(value) && value.startsWith('stores.')
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        // Can be overridden by subclasses
    }

    /**
     * Recursively processes a data object, creating or updating Neo.core.Config instances
     * for each property and storing them in the #dataConfigs map.
     * @param {Object} obj The data object to process.
     * @param {String} [path=''] The current path prefix for nested objects.
     * @protected
     */
    processDataObject(obj, path = '') {
        let me = this;

        Object.entries(obj).forEach(([key, value]) => {
            const fullPath = path ? `${path}.${key}` : key;

            // Ensure a Config instance exists for the current fullPath
            if (me.#dataConfigs[fullPath]) {
                me.#dataConfigs[fullPath].set(value);
            } else {
                me.#dataConfigs[fullPath] = new _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](value);
            }

            // If the value is a plain object, recursively process its properties
            if (Neo.typeOf(value) === 'Object') {
                me.processDataObject(value, fullPath);
            }
        });
    }

    /**
     * @param {Neo.component.Base} component
     * @param {String} configName
     * @param {String} storeName
     */
    resolveStore(component, configName, storeName) {
        let store = this.getStore(storeName);

        if (component[configName] !== store) {
            component[configName] = store
        }
    }

    /**
     * Helper function to set a config value and trigger reactivity.
     * This method creates a new Config instance if one doesn't exist for the given path,
     * or updates an existing one. It also triggers binding effects and calls onDataPropertyChange.
     * @param {Neo.state.Provider} provider The StateProvider instance owning the config.
     * @param {String} path The full path of the data property (e.g., 'user.firstname').
     * @param {*} newValue The new value to set.
     * @param {*} oldVal The old value (optional, used for initial setup).
     * @private
     */
    #setConfigValue(provider, path, newValue, oldVal) {
        let currentConfig = provider.getDataConfig(path),
            oldValue      = oldVal;

        if (currentConfig) {
            oldValue = currentConfig.get();
            currentConfig.set(newValue);
        } else {
            currentConfig = new _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](newValue);
            provider.#dataConfigs[path] = currentConfig;
            // Trigger all binding effects to re-evaluate their dependencies
            provider.#bindingEffects.forEach(effect => effect.run())
        }

        // Notify subscribers of the data property change.
        provider.onDataPropertyChange(path, newValue, oldValue)
    }

    /**
     * The method will assign all values to the closest stateProvider where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     * @param {Object|String} key
     * @param {*} value
     */
    setData(key, value) {
        this.internalSetData(key, value, this)
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent stateProviders.
     * @param {Object|String} key
     * @param {*} value
     */
    setDataAtSameLevel(key, value) {
        this.internalSetData(key, value)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Provider));


/***/ }),

/***/ "./src/state/createHierarchicalDataProxy.mjs":
/*!***************************************************!*\
  !*** ./src/state/createHierarchicalDataProxy.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createHierarchicalDataProxy: () => (/* binding */ createHierarchicalDataProxy)
/* harmony export */ });
/* harmony import */ var _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EffectManager.mjs */ "./src/core/EffectManager.mjs");


/**
 * Creates a nested Proxy that represents a level in the hierarchical data structure.
 * @param {Neo.state.Provider} rootProvider The top-level provider to start searches from.
 * @param {String} path The current path of this proxy level (e.g., 'user' for data.user).
 * @returns {Proxy|null}
 * @private
 */
function createNestedProxy(rootProvider, path) {
    // The target object for the proxy can be empty because all lookups are dynamic.
    const target = {};

    return new Proxy(target, {
        /**
         * The get trap for the proxy. This is where the magic happens.
         * @param {Object} currentTarget The proxy's target object.
         * @param {String|Symbol} property The name of the property being accessed.
         * @returns {*} The value of the property or a new proxy for nested access.
         */
        get(currentTarget, property) {
            // Handle internal properties that might be set directly on the proxy's target
            // or are expected by the environment (like Siesta's __REFADR__).
            if (typeof property === 'symbol' || property === '__REFADR__' || property === 'inspect' || property === 'then') {
                return Reflect.get(currentTarget, property);
            }

            // Only allow string or number properties to proceed as data paths.
            if (typeof property !== 'string' && typeof property !== 'number') {
                return undefined; // For other non-string/non-number properties, return undefined.
            }

            const fullPath = path ? `${path}.${property}` : property;

            // 1. Check if the full path corresponds to an actual data property.
            const ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);

            if (ownerDetails) {
                const
                    {owner, propertyName} = ownerDetails,
                    config                = owner.getDataConfig(propertyName);

                if (config) {
                    const activeEffect = _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getActiveEffect();
                    if (activeEffect) {
                        activeEffect.addDependency(config);
                    }

                    const value = config.get();
                    // If the value is an object, return a new proxy for it to ensure nested accesses are also proxied.
                    if (Neo.typeOf(value) === 'Object') {
                        return createNestedProxy(rootProvider, fullPath)
                    }
                    return value;
                }
            }

            // 2. If not a direct match, it might be a parent object of a nested property
            //    (e.g., accessing `user` when a `user.firstname` binding exists).
            //    In this case, we return another proxy for the next level down.
            if (rootProvider.hasNestedDataStartingWith(fullPath)) {
                return createNestedProxy(rootProvider, fullPath)
            }

            // 3. If it's neither a data property nor a path to one, it doesn't exist in the state.
            return null
        },

        set(currentTarget, property, value) {
            // Allow internal properties (like Symbols or specific strings) to be set directly on the target.
            if (typeof property === 'symbol' || property === '__REFADR__') {
                return Reflect.set(currentTarget, property, value);
            }

            const fullPath = path ? `${path}.${property}` : property;
            const ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);

            let targetProvider;
            if (ownerDetails) {
                targetProvider = ownerDetails.owner;
            } else {
                // If no owner is found, set it on the rootProvider (the one that created this proxy)
                targetProvider = rootProvider;
            }

            targetProvider.setData(fullPath, value);
            return true; // Indicate that the assignment was successful
        },

        ownKeys(currentTarget) {
            return rootProvider.getTopLevelDataKeys(path);
        },

        getOwnPropertyDescriptor(currentTarget, property) {
            const fullPath = path ? `${path}.${property}` : property;
            const ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);

            if (ownerDetails) {
                const config = ownerDetails.owner.getDataConfig(ownerDetails.propertyName);
                if (config) {
                    const value = config.get();
                    return {
                        value: Neo.isObject(value) ? createNestedProxy(rootProvider, fullPath) : value,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                    };
                }
            }
            return undefined; // Property not found
        }
    })
}

/**
 * Creates a Proxy object that represents the merged, hierarchical data from a `state.Provider` chain.
 * When a property is accessed through this proxy while an Effect is running, it automatically
 * tracks the underlying core.Config instance as a dependency.
 * @param {Neo.state.Provider} provider The starting state.Provider.
 * @returns {Proxy}
 */
function createHierarchicalDataProxy(provider) {
    return createNestedProxy(provider, '')
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNNO0FBQ1A7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVMsd0RBQVc7QUFDcEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBWSwrREFBa0I7QUFDOUIsWUFBWSwrREFBa0I7QUFDOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsMERBQWE7O0FBRXJCO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsWUFBWSwwREFBYTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsTUFBTSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUh1QztBQUNPO0FBQ0w7QUFDQTtBQUNJO0FB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QTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHVDQUF1QyxLQUFLLEdBQUcsU0FBUztBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvcmUvRWZmZWN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3N0YXRlL1Byb3ZpZGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3N0YXRlL2NyZWF0ZUhpZXJhcmNoaWNhbERhdGFQcm94eS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVmZmVjdE1hbmFnZXIgICAgIGZyb20gJy4vRWZmZWN0TWFuYWdlci5tanMnO1xuaW1wb3J0IEVmZmVjdEJhdGNoTWFuYWdlciBmcm9tICcuL0VmZmVjdEJhdGNoTWFuYWdlci5tanMnO1xuaW1wb3J0IElkR2VuZXJhdG9yICAgICAgICBmcm9tICcuL0lkR2VuZXJhdG9yLm1qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlYWN0aXZlIGVmZmVjdCB0aGF0IGF1dG9tYXRpY2FsbHkgdHJhY2tzIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHJlLXJ1bnMgd2hlbiBhbnkgb2YgdGhlbSBjaGFuZ2UuXG4gKiBUaGlzIGlzIGEgbGlnaHR3ZWlnaHQsIHBsYWluIEphdmFTY3JpcHQgY2xhc3MgZm9yIHBlcmZvcm1hbmNlLlxuICogSXQgc2VydmVzIGFzIGEgY29yZSByZWFjdGl2ZSBwcmltaXRpdmUsIGVuYWJsaW5nIGF1dG9tYXRpYyBhbmQgZHluYW1pYyBkZXBlbmRlbmN5IHRyYWNraW5nLlxuICogQGNsYXNzIE5lby5jb3JlLkVmZmVjdFxuICovXG5jbGFzcyBFZmZlY3Qge1xuICAgIC8qKlxuICAgICAqIEEgTWFwIGNvbnRhaW5pbmcgQ29uZmlnIGluc3RhbmNlcyBhcyBrZXlzIGFuZCB0aGVpciBjbGVhbnVwIGZ1bmN0aW9ucyBhcyB2YWx1ZXMuXG4gICAgICogQG1lbWJlciB7TWFwfSBkZXBlbmRlbmNpZXM9bmV3IE1hcCgpXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRlcGVuZGVuY2llcyA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufG51bGx9IF9mbj1udWxsXG4gICAgICovXG4gICAgX2ZuID0gbnVsbFxuICAgIC8qKlxuICAgICAqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBlZmZlY3QgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgaWQgPSBJZEdlbmVyYXRvci5nZXRJZCgnZWZmZWN0JylcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc0Rlc3Ryb3llZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNSdW5uaW5nID0gZmFsc2VcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgZm5cbiAgICAgKi9cbiAgICBnZXQgZm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mblxuICAgIH1cbiAgICBzZXQgZm4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZm4gPSB2YWx1ZTtcbiAgICAgICAgLy8gQXNzaWduaW5nIGEgbmV3IGZ1bmN0aW9uIHRvIGBmbmAgYXV0b21hdGljYWxseSB0cmlnZ2VycyBhIHJlLXJ1bi5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGVmZmVjdCBpbW1lZGlhdGVseSByZS1ldmFsdWF0ZXMgaXRzIGRlcGVuZGVuY2llc1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgbmV3IGZ1bmN0aW9uJ3MgbG9naWMsIGNsZWFyaW5nIG9sZCBkZXBlbmRlbmNpZXMgYW5kIGVzdGFibGlzaGluZyBuZXcgb25lcy5cbiAgICAgICAgdGhpcy5ydW4oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuZm4gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIHRoZSBlZmZlY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioe2ZufSkge1xuICAgICAgICB0aGlzLmZuID0gZm5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGRlc3Ryb3lzIHRoZSBlZmZlY3QuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIG1lLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBlZmZlY3QgZnVuY3Rpb24sIHRyYWNraW5nIGl0cyBkZXBlbmRlbmNpZXMuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBvbiBjcmVhdGlvbiBhbmQgd2hlbmV2ZXIgYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gICAgICogVGhlIGR5bmFtaWMgcmUtdHJhY2tpbmcgZW5zdXJlcyB0aGUgZWZmZWN0IGFsd2F5cyByZWZsZWN0cyBpdHMgY3VycmVudCBkZXBlbmRlbmNpZXMsXG4gICAgICogZXZlbiBpZiB0aGUgbG9naWMgd2l0aGluIGBmbmAgY2hhbmdlcyBjb25kaXRpb25hbGx5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBydW4oKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaXNEZXN0cm95ZWQgfHwgbWUuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICAgICAgaWYgKEVmZmVjdEJhdGNoTWFuYWdlci5pc0JhdGNoQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIEVmZmVjdEJhdGNoTWFuYWdlci5xdWV1ZUVmZmVjdChtZSk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzUnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuICAgICAgICBtZS5kZXBlbmRlbmNpZXMuY2xlYXIoKTtcblxuICAgICAgICBFZmZlY3RNYW5hZ2VyLnB1c2gobWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZS5mbigpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnBvcCgpO1xuICAgICAgICAgICAgbWUuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYE5lby5jb3JlLkNvbmZpZ2AgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGlzIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkNvbmZpZ30gY29uZmlnIFRoZSBjb25maWcgaW5zdGFuY2UgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZGREZXBlbmRlbmN5KGNvbmZpZykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gT25seSBhZGQgaWYgbm90IGFscmVhZHkgYSBkZXBlbmRlbmN5LiBNYXAgdXNlcyBzdHJpY3QgZXF1YWxpdHkgKD09PSkgZm9yIG9iamVjdCBrZXlzLlxuICAgICAgICBpZiAoIW1lLmRlcGVuZGVuY2llcy5oYXMoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9IGNvbmZpZy5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIGlkOiBtZS5pZCxcbiAgICAgICAgICAgICAgICBmbjogbWUucnVuLmJpbmQobWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuZGVwZW5kZW5jaWVzLnNldChjb25maWcsIGNsZWFudXApXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IG5zID0gTmVvLm5zKCdOZW8uY29yZScsIHRydWUpO1xubnMuRWZmZWN0ID0gRWZmZWN0O1xuXG5leHBvcnQgZGVmYXVsdCBFZmZlY3Q7XG4iLCJpbXBvcnQgQmFzZSAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgQ2xhc3NTeXN0ZW1VdGlsICAgICAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IENvbmZpZyAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQ29uZmlnLm1qcyc7XG5pbXBvcnQgRWZmZWN0ICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9FZmZlY3QubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL09ic2VydmFibGUubWpzJztcbmltcG9ydCB7Y3JlYXRlSGllcmFyY2hpY2FsRGF0YVByb3h5fSBmcm9tICcuL2NyZWF0ZUhpZXJhcmNoaWNhbERhdGFQcm94eS5tanMnO1xuaW1wb3J0IHtpc0Rlc2NyaXB0b3J9ICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQ29uZmlnU3ltYm9scy5tanMnO1xuXG5jb25zdCB0d29XYXlCaW5kaW5nU3ltYm9sID0gU3ltYm9sLmZvcigndHdvV2F5QmluZGluZycpO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIGNvbXBvbmVudCBzdGF0ZSBwcm92aWRlciBmb3IgYWRkaW5nIGJpbmRpbmdzIHRvIGNvbmZpZ3NcbiAqIEBjbGFzcyBOZW8uc3RhdGUuUHJvdmlkZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgUHJvdmlkZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc3RhdGUuUHJvdmlkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zdGF0ZS5Qcm92aWRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzdGF0ZS1wcm92aWRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzdGF0ZS1wcm92aWRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gY29tcG9uZW50PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29yZSBkYXRhIG9iamVjdCBtYW5hZ2VkIGJ5IHRoaXMgU3RhdGVQcm92aWRlci5cbiAgICAgICAgICogVGhpcyBvYmplY3QgaG9sZHMgdGhlIHJlYWN0aXZlIHN0YXRlIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIGFuZCBtb2RpZmllZFxuICAgICAgICAgKiBieSBjb21wb25lbnRzIGFuZCBmb3JtdWxhcyB3aXRoaW4gdGhlIHByb3ZpZGVyJ3MgaGllcmFyY2h5LlxuICAgICAgICAgKiBDaGFuZ2VzIHRvIHByb3BlcnRpZXMgd2l0aGluIHRoaXMgZGF0YSBvYmplY3Qgd2lsbCB0cmlnZ2VyIHJlYWN0aXZpdHkuXG4gICAgICAgICAqIFdoZW4gbmV3IGRhdGEgaXMgYXNzaWduZWQsIGl0IHdpbGwgYmUgZGVlcGx5IG1lcmdlZCB3aXRoIGV4aXN0aW5nIGRhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkYXRhXz1udWxsXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAgICBkYXRhOiB7XG4gICAgICAgICAqICAgICAgICAgdXNlcjoge1xuICAgICAgICAgKiAgICAgICAgICAgICBmaXJzdE5hbWU6ICdKb2huJyxcbiAgICAgICAgICogICAgICAgICAgICAgbGFzdE5hbWUgOiAnRG9lJ1xuICAgICAgICAgKiAgICAgICAgIH0sXG4gICAgICAgICAqICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICogICAgICAgICAgICAgdGhlbWU6ICdkYXJrJ1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnZGVlcCcsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDoge31cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgY29tcHV0ZWQgcHJvcGVydGllcyBiYXNlZCBvbiBvdGhlciBkYXRhIHByb3BlcnRpZXMgd2l0aGluIHRoZSBTdGF0ZVByb3ZpZGVyIGhpZXJhcmNoeS5cbiAgICAgICAgICogRWFjaCBmb3JtdWxhIGlzIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIGBkYXRhYCBhcmd1bWVudCwgd2hpY2ggaXMgYSBoaWVyYXJjaGljYWwgcHJveHlcbiAgICAgICAgICogYWxsb3dpbmcgYWNjZXNzIHRvIGRhdGEgZnJvbSB0aGUgY3VycmVudCBwcm92aWRlciBhbmQgYWxsIGl0cyBwYXJlbnQgcHJvdmlkZXJzLlxuICAgICAgICAgKiBDaGFuZ2VzIHRvIGRlcGVuZGVuY2llcyAoYWNjZXNzZWQgdmlhIGBkYXRhLnByb3BlcnR5TmFtZWApIHdpbGwgYXV0b21hdGljYWxseSByZS1ydW4gdGhlIGZvcm11bGEuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBmb3JtdWxhc189bnVsbFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgZGF0YToge1xuICAgICAgICAgKiAgICAgICAgIGEgICAgOiAxLFxuICAgICAgICAgKiAgICAgICAgIGIgICAgOiAyLFxuICAgICAgICAgKiAgICAgICAgIHRvdGFsOiA1MFxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiAgICAgZm9ybXVsYXM6IHtcbiAgICAgICAgICogICAgICAgICBhUGx1c0IgOiAoZGF0YSkgPT4gZGF0YS5hICsgZGF0YS5iLFxuICAgICAgICAgKiAgICAgICAgIGFUaW1lc0I6IChkYXRhKSA9PiBkYXRhLmEgKiBkYXRhLmIsXG4gICAgICAgICAqICAgICAgICAgLy8gQWNjZXNzaW5nIHBhcmVudCBkYXRhIChhc3N1bWluZyBhIHBhcmVudCBwcm92aWRlciBoYXMgYSAndGF4UmF0ZScgcHJvcGVydHkpXG4gICAgICAgICAqICAgICAgICAgdG90YWxXaXRoVGF4OiAoZGF0YSkgPT4gZGF0YS50b3RhbCAqICgxICsgZGF0YS50YXhSYXRlKVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybXVsYXNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9IHBhcmVudF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAvKipcbiAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIE5lby5kYXRhLlN0b3JlIGluc3RhbmNlcyBtYW5hZ2VkIGJ5IHRoaXMgU3RhdGVQcm92aWRlci5cbiAgICAgICAgICogU3RvcmVzIGFyZSBkZWZpbmVkIGFzIGNvbmZpZyBvYmplY3RzIHdpdGggYSBgbW9kdWxlYCBwcm9wZXJ0eSBwb2ludGluZ1xuICAgICAgICAgKiB0byB0aGUgc3RvcmUgY2xhc3MsIHdoaWNoIHdpbGwgdGhlbiBiZSBpbnN0YW50aWF0ZWQgYnkgdGhlIGZyYW1ld29yay5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IHN0b3Jlc189bnVsbFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgc3RvcmVzOiB7XG4gICAgICAgICAqICAgICAgICAgbXlVc2Vyczoge1xuICAgICAgICAgKiAgICAgICAgICAgICBtb2R1bGU6IE5lby5kYXRhLlN0b3JlLFxuICAgICAgICAgKiAgICAgICAgICAgICBtb2RlbCA6ICdNeUFwcC5tb2RlbC5Vc2VyJyxcbiAgICAgICAgICogICAgICAgICAgICAgZGF0YSAgOiBbe2lkOiAxLCBuYW1lOiAnSm9obid9LCB7aWQ6IDIsIG5hbWU6ICdEb2UnfV1cbiAgICAgICAgICogICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgIG15Q3VzdG9tU3RvcmUxOiBNeUN1c3RvbVN0b3JlQ2xhc3MsXG4gICAgICAgICAqICAgICAgICAgbXlDdXN0b21TdG9yZTI6IHtcbiAgICAgICAgICogICAgICAgICAgICAgbW9kdWxlICA6IE15Q3VzdG9tU3RvcmVDbGFzcyxcbiAgICAgICAgICogICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWVcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZXNfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TWFwfSAjYmluZGluZ0VmZmVjdHM9bmV3IE1hcCgpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjYmluZGluZ0VmZmVjdHMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9ICNkYXRhQ29uZmlncz17fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2RhdGFDb25maWdzID0ge31cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtNYXB9ICNmb3JtdWxhRWZmZWN0cz1uZXcgTWFwKClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNmb3JtdWxhRWZmZWN0cyA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgTmVvLmlzVXNpbmdTdGF0ZVByb3ZpZGVycyA9IHRydWU7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXRhIGNvbmZpZyBnb3QgY2hhbmdlZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBpbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgI2RhdGFDb25maWdzIG1hcCwgY29udmVydGluZyBlYWNoXG4gICAgICogcGxhaW4gZGF0YSBwcm9wZXJ0eSBpbnRvIGEgcmVhY3RpdmUgTmVvLmNvcmUuQ29uZmlnIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREYXRhKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnByb2Nlc3NEYXRhT2JqZWN0KHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZm9ybXVsYXMgY29uZmlnIGdvdCBjaGFuZ2VkLlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdXAgcmVhY3RpdmUgZWZmZWN0cyBmb3IgZWFjaCBkZWZpbmVkIGZvcm11bGEuXG4gICAgICogRWFjaCBmb3JtdWxhIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBoaWVyYXJjaGljYWwgZGF0YSBwcm94eSwgYWxsb3dpbmcgaW1wbGljaXQgZGVwZW5kZW5jeSB0cmFja2luZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZSBUaGUgbmV3IGZvcm11bGFzIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWUgVGhlIG9sZCBmb3JtdWxhcyBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZvcm11bGFzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gRGVzdHJveSBvbGQgZm9ybXVsYSBlZmZlY3RzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIGFuZCBzdGFsZSBjYWxjdWxhdGlvbnMuXG4gICAgICAgIG1lLiNmb3JtdWxhRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QuZGVzdHJveSgpKTtcbiAgICAgICAgbWUuI2Zvcm11bGFFZmZlY3RzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2Zvcm11bGFLZXksIGZvcm11bGFGbl0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgRWZmZWN0IGZvciBlYWNoIGZvcm11bGEuIFRoZSBFZmZlY3QncyBmbiB3aWxsIHJlLXJ1biB3aGVuZXZlciBpdHMgZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgICAgICAgICAgICAgICBjb25zdCBlZmZlY3QgPSBuZXcgRWZmZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgZm46ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGllcmFyY2hpY2FsRGF0YSA9IG1lLmdldEhpZXJhcmNoeURhdGEoKSwgLy8gR2V0IHRoZSByZWFjdGl2ZSBkYXRhIHByb3h5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICAgICAgICAgICA9IGZvcm11bGFGbihoaWVyYXJjaGljYWxEYXRhKTsgLy8gRXhlY3V0ZSB0aGUgZm9ybXVsYSB3aXRoIHRoZSBkYXRhXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IGJhY2sgdG8gdGhlIHN0YXRlIHByb3ZpZGVyJ3MgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgdGhlIGZvcm11bGEncyBvdXRwdXQgYXZhaWxhYmxlIGFzIGEgZGF0YSBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0RGF0YShmb3JtdWxhS2V5LCBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5zZXREYXRhKGZvcm11bGFLZXksIHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWUuI2Zvcm11bGFFZmZlY3RzLnNldChmb3JtdWxhS2V5LCBlZmZlY3QpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYWNjZXNzaW5nIHRoZSBkYXRhIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVHZXREYXRhKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhpZXJhcmNoeURhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIHN0b3JlcyBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFN0b3Jlcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgc3RvcmVWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IG1hcHBpbmcgc3RyaW5nIGJhc2VkIGxpc3RlbmVycyBpbnRvIHRoZSBzdGF0ZVByb3ZpZGVyIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoc3RvcmVWYWx1ZS5saXN0ZW5lcnMgfHwge30pLmZvckVhY2goKFtsaXN0ZW5lcktleSwgbGlzdGVuZXJdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmJpbmRDYWxsYmFjayhsaXN0ZW5lciwgbGlzdGVuZXJLZXksIG1lLCBzdG9yZVZhbHVlLmxpc3RlbmVycylcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IENsYXNzU3lzdGVtVXRpbC5iZWZvcmVTZXRJbnN0YW5jZShzdG9yZVZhbHVlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYmluZGluZyBmb3IgYSBjb21wb25lbnQncyBjb25maWcgdG8gYSBkYXRhIHByb3BlcnR5LlxuICAgICAqIFRoaXMgbm93IHVzZXMgdGhlIEVmZmVjdC1iYXNlZCByZWFjdGl2aXR5IHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnS2V5IFRoZSBjb21wb25lbnQgY29uZmlnIHRvIGJpbmQgKGUuZy4sICd0ZXh0JykuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGZvcm1hdHRlciBUaGUgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwgY29uZmlnS2V5LCBrZXksIGlzVHdvV2F5KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZWZmZWN0ID0gbmV3IEVmZmVjdCh7XG4gICAgICAgICAgICBmbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IE5lby5nZXQoY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiAhY29tcG9uZW50LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWVyYXJjaGljYWxEYXRhID0gbWUuZ2V0SGllcmFyY2h5RGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgICAgICAgICA9IE5lby5pc0Z1bmN0aW9uKGtleSkgPyBrZXkuY2FsbChtZSwgaGllcmFyY2hpY2FsRGF0YSkgOiBoaWVyYXJjaGljYWxEYXRhW2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Ll9za2lwVHdvV2F5UHVzaCA9IGNvbmZpZ0tleTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50W2NvbmZpZ0tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudC5fc2tpcFR3b1dheVB1c2hcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLiNiaW5kaW5nRWZmZWN0cy5zZXQoY29tcG9uZW50SWQsIGVmZmVjdCk7XG5cbiAgICAgICAgLy8gVGhlIGVmZmVjdCBvYnNlcnZlcyB0aGUgY29tcG9uZW50J3MgZGVzdHJ1Y3Rpb24gdG8gY2xlYW4gaXRzZWxmIHVwLlxuICAgICAgICBtZS5vYnNlcnZlQ29uZmlnKGNvbXBvbmVudElkLCAnaXNEZXN0cm95aW5nJywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlZmZlY3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIG1lLiNiaW5kaW5nRWZmZWN0cy5kZWxldGUoY29tcG9uZW50SWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoZSBlZmZlY3QgaXMgcmV0dXJuZWQgdG8gYmUgbWFuYWdlZCBieSB0aGUgY29tcG9uZW50LlxuICAgICAgICByZXR1cm4gZWZmZWN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgY29tcG9uZW50J3MgYGJpbmRgIGNvbmZpZ3VyYXRpb24gdG8gY3JlYXRlIHJlYWN0aXZlIGJpbmRpbmdzLlxuICAgICAqIEl0IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gc3RvcmUgYmluZGluZ3MgYW5kIGRhdGEgYmluZGluZ3MsIGFuZCBzZXRzIHVwIHR3by13YXkgYmluZGluZyBpZiBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IGluc3RhbmNlIHdob3NlIGJpbmRpbmdzIGFyZSB0byBiZSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmdzKGNvbXBvbmVudCkge1xuICAgICAgICBsZXQgaGFzVHdvV2F5QmluZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbXBvbmVudC5iaW5kIHx8IHt9KS5mb3JFYWNoKChbY29uZmlnS2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGxldCBrZXkgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGJpbmRpbmcgdmFsdWUgaXMgYW4gb2JqZWN0LCBpdCBtaWdodCBjb250YWluIGB0d29XYXlgIG9yIGEgc3BlY2lmaWMgYGtleWAuXG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50d29XYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVHdvV2F5QmluZGluZyA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gdmFsdWUua2V5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBpdCdzIGEgc3RvcmUgYmluZGluZyBvciBhIGRhdGEgYmluZGluZy5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RvcmVWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0b3JlIGJpbmRpbmdzLCByZXNvbHZlIHRoZSBzdG9yZSBhbmQgYXNzaWduIGl0IHRvIHRoZSBjb21wb25lbnQgY29uZmlnLlxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVN0b3JlKGNvbXBvbmVudCwgY29uZmlnS2V5LCBrZXkuc3Vic3RyaW5nKDcpKSAvLyByZW1vdmUgdGhlIFwic3RvcmVzLlwiIHByZWZpeFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZGF0YSBiaW5kaW5ncywgY3JlYXRlIGFuIEVmZmVjdCB0byBrZWVwIHRoZSBjb21wb25lbnQgY29uZmlnIGluIHN5bmMgd2l0aCB0aGUgZGF0YS5cbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJpbmRpbmcoY29tcG9uZW50LmlkLCBjb25maWdLZXksIGtleSwgdmFsdWUudHdvV2F5KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgaWYgaXQgaGFzIGFueSB0d28td2F5IGJpbmRpbmdzLCBmb3IgaW50ZXJuYWwgdHJhY2tpbmcuXG4gICAgICAgIGlmIChoYXNUd29XYXlCaW5kaW5nKSB7XG4gICAgICAgICAgICBjb21wb25lbnRbdHdvV2F5QmluZGluZ1N5bWJvbF0gPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgc3RhdGUgcHJvdmlkZXIgYW5kIGNsZWFucyB1cCBhbGwgYXNzb2NpYXRlZCBlZmZlY3RzLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBtZS4jZm9ybXVsYUVmZmVjdHMuZm9yRWFjaChlZmZlY3QgPT4gZWZmZWN0LmRlc3Ryb3koKSk7XG4gICAgICAgIG1lLiNmb3JtdWxhRWZmZWN0cy5jbGVhcigpO1xuXG4gICAgICAgIG1lLiNiaW5kaW5nRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QuZGVzdHJveSgpKTtcbiAgICAgICAgbWUuI2JpbmRpbmdFZmZlY3RzLmNsZWFyKCk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyKG50eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRDb250cm9sbGVyKG50eXBlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY2VzcyB0aGUgY2xvc2VzdCBkYXRhIHByb3BlcnR5IGluc2lkZSB0aGUgcGFyZW50IGNoYWluLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXREYXRhKGtleSkge1xuICAgICAgICBjb25zdCBvd25lckRldGFpbHMgPSB0aGlzLmdldE93bmVyT2ZEYXRhUHJvcGVydHkoa2V5KTtcblxuICAgICAgICBpZiAob3duZXJEZXRhaWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gb3duZXJEZXRhaWxzLm93bmVyLmdldERhdGFDb25maWcob3duZXJEZXRhaWxzLnByb3BlcnR5TmFtZSkuZ2V0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdW5kZXJseWluZyBjb3JlLkNvbmZpZyBpbnN0YW5jZSBmb3IgYSBnaXZlbiBkYXRhIHByb3BlcnR5IHBhdGguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIGZ1bGwgcGF0aCBvZiB0aGUgZGF0YSBwcm9wZXJ0eSAoZS5nLiwgJ3VzZXIuZmlyc3RuYW1lJykuXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkNvbmZpZ3xudWxsfVxuICAgICAqL1xuICAgIGdldERhdGFDb25maWcocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YUNvbmZpZ3NbcGF0aF0gfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lcmdlZCwgaGllcmFyY2hpY2FsIGRhdGEgb2JqZWN0IGFzIGEgcmVhY3RpdmUgUHJveHkuXG4gICAgICogQHJldHVybnMge1Byb3h5fVxuICAgICAqL1xuICAgIGdldEhpZXJhcmNoeURhdGEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIaWVyYXJjaGljYWxEYXRhUHJveHkodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc3RhdGUuUHJvdmlkZXIgaW5zdGFuY2UgdGhhdCBvd25zIGEgc3BlY2lmaWMgZGF0YSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgZnVsbCBwYXRoIG9mIHRoZSBkYXRhIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHt7b3duZXI6IE5lby5zdGF0ZS5Qcm92aWRlciwgcHJvcGVydHlOYW1lOiBTdHJpbmd9fG51bGx9XG4gICAgICovXG4gICAgZ2V0T3duZXJPZkRhdGFQcm9wZXJ0eShwYXRoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLiNkYXRhQ29uZmlnc1twYXRoXSkge1xuICAgICAgICAgICAgcmV0dXJuIHtvd25lcjogbWUsIHByb3BlcnR5TmFtZTogcGF0aH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBwYXJlbnQgb3duZXJzaGlwXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG1lLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmdldE93bmVyT2ZEYXRhUHJvcGVydHkocGF0aClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5zdGF0ZS5Qcm92aWRlcnxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBBY2Nlc3MgdGhlIGludGVybmFsIHZhbHVlIG9mIHRoZSBwYXJlbnRfIGNvbmZpZyBkaXJlY3RseS5cbiAgICAgICAgLy8gVGhpcyBhdm9pZHMgcmVjdXJzaXZlIGNhbGxzIHRvIHRoZSBnZXR0ZXIuXG4gICAgICAgIGlmIChtZS5fcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuX3BhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcGFyZW50IGlzIHNldCwgdHJ5IHRvIGZpbmQgaXQgZHluYW1pY2FsbHkgdmlhIHRoZSBjb21wb25lbnQuXG4gICAgICAgIC8vIEVuc3VyZSB0aGlzLmNvbXBvbmVudCBleGlzdHMgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgaXRzIHBhcmVudC5cbiAgICAgICAgaWYgKG1lLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmNvbXBvbmVudC5wYXJlbnQ/LmdldFN0YXRlUHJvdmlkZXIoKSB8fCBudWxsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBleHBsaWNpdCBwYXJlbnQgYW5kIG5vIGNvbXBvbmVudCB0byBkZXJpdmUgaXQgZnJvbS5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdGhlIGNsb3Nlc3Qgc3RvcmUgaW5zaWRlIHRoZSBWTSBwYXJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7TmVvLnN0YXRlLlByb3ZpZGVyfSBvcmlnaW5TdGF0ZVByb3ZpZGVyPXRoaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5LCBvcmlnaW5TdGF0ZVByb3ZpZGVyPXRoaXMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzdG9yZXN9ID0gbWUsXG4gICAgICAgICAgICBwYXJlbnRTdGF0ZVByb3ZpZGVyO1xuXG4gICAgICAgIGlmIChzdG9yZXM/Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZXNba2V5XVxuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50U3RhdGVQcm92aWRlciA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmICghcGFyZW50U3RhdGVQcm92aWRlcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgc3RvcmUgJyR7a2V5fScgbm90IGZvdW5kIGluc2lkZSB0aGlzIHN0YXRlUHJvdmlkZXIgb3IgcGFyZW50cy5gLCBvcmlnaW5TdGF0ZVByb3ZpZGVyKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudFN0YXRlUHJvdmlkZXIuZ2V0U3RvcmUoa2V5LCBvcmlnaW5TdGF0ZVByb3ZpZGVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbnkgZGF0YSBwcm9wZXJ0eSBpbiB0aGUgaGllcmFyY2h5IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSB0aGUgSGllcmFyY2hpY2FsRGF0YVByb3h5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGQgcmV0dXJuIGEgbmVzdGVkIHByb3h5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrIChlLmcuLCAndXNlcicpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc05lc3RlZERhdGFTdGFydGluZ1dpdGgocGF0aCkge1xuICAgICAgICBjb25zdCBwYXRoV2l0aERvdCA9IGAke3BhdGh9LmA7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuI2RhdGFDb25maWdzKS5zb21lKGtleSA9PiBrZXkuc3RhcnRzV2l0aChwYXRoV2l0aERvdCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KCk/Lmhhc05lc3RlZERhdGFTdGFydGluZ1dpdGgocGF0aCkgfHwgZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3AtbGV2ZWwgZGF0YSBrZXlzIGZvciBhIGdpdmVuIHBhdGggd2l0aGluIHRoaXMgcHJvdmlkZXIncyBkYXRhLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGdldCBrZXlzIGZvciAoZS5nLiwgJ3VzZXIuYWRkcmVzcycpLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRUb3BMZXZlbERhdGFLZXlzKHBhdGgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgcGF0aFByZWZpeCA9IHBhdGggPyBgJHtwYXRofS5gIDogJyc7XG5cbiAgICAgICAgZm9yIChjb25zdCBmdWxsUGF0aCBpbiB0aGlzLiNkYXRhQ29uZmlncykge1xuICAgICAgICAgICAgaWYgKGZ1bGxQYXRoLnN0YXJ0c1dpdGgocGF0aFByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBmdWxsUGF0aC5zdWJzdHJpbmcocGF0aFByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvcExldmVsS2V5ID0gcmVsYXRpdmVQYXRoLnNwbGl0KCcuJylbMF07XG4gICAgICAgICAgICAgICAgaWYgKHRvcExldmVsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMuYWRkKHRvcExldmVsS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oa2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGF2b2lkIGNvZGUgcmVkdW5kYW5jeS5cbiAgICAgKiBVc2Ugc2V0RGF0YSgpIG9yIHNldERhdGFBdFNhbWVMZXZlbCgpIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBoYW5kbGVzIHNldHRpbmcgZGF0YSBwcm9wZXJ0aWVzLCBpbmNsdWRpbmcgbmVzdGVkIHBhdGhzIGFuZCBOZW8uZGF0YS5SZWNvcmQgaW5zdGFuY2VzLlxuICAgICAqIEl0IGRldGVybWluZXMgdGhlIG93bmluZyBTdGF0ZVByb3ZpZGVyIGluIHRoZSBoaWVyYXJjaHkgYW5kIGRlbGVnYXRlcyB0byAjc2V0Q29uZmlnVmFsdWUuXG4gICAgICpcbiAgICAgKiBQYXNzaW5nIGFuIG9yaWdpblN0YXRlUHJvdmlkZXIgcGFyYW0gd2lsbCB0cnkgdG8gc2V0IGVhY2gga2V5IG9uIHRoZSBjbG9zZXN0IHByb3BlcnR5IG1hdGNoXG4gICAgICogaW5zaWRlIHRoZSBwYXJlbnQgc3RhdGVQcm92aWRlciBjaGFpbiA9PiBzZXREYXRhKClcbiAgICAgKiBOb3QgcGFzc2luZyBpdCB3aWxsIHNldCBhbGwgdmFsdWVzIG9uIHRoZSBzdGF0ZVByb3ZpZGVyIHdoZXJlIHRoZSBtZXRob2QgZ2V0cyBjYWxsZWQgPT4gc2V0RGF0YUF0U2FtZUxldmVsKClcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcn0gW29yaWdpblN0YXRlUHJvdmlkZXJdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCBvcmlnaW5TdGF0ZVByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBOZW8uZGF0YS5SZWNvcmQsIHRyZWF0IGl0IGFzIGFuIGF0b21pYyB2YWx1ZVxuICAgICAgICAvLyBhbmQgc2V0IGl0IGRpcmVjdGx5IHdpdGhvdXQgZnVydGhlciByZWN1cnNpdmUgcHJvY2Vzc2luZyBvZiBpdHMgcHJvcGVydGllcy5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUuaXNSZWNvcmQpIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgb3duZXJEZXRhaWxzICAgPSBtZS5nZXRPd25lck9mRGF0YVByb3BlcnR5KGtleSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0UHJvdmlkZXIgPSBvd25lckRldGFpbHMgPyBvd25lckRldGFpbHMub3duZXIgOiAob3JpZ2luU3RhdGVQcm92aWRlciB8fCBtZSk7XG5cbiAgICAgICAgICAgIG1lLiNzZXRDb25maWdWYWx1ZSh0YXJnZXRQcm92aWRlciwga2V5LCB2YWx1ZSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBrZXkgaXMgYW4gb2JqZWN0LCBpdGVyYXRlIG92ZXIgaXRzIGVudHJpZXMgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgaW50ZXJuYWxTZXREYXRhLlxuICAgICAgICAvLyBUaGlzIGhhbmRsZXMgc2V0dGluZyBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2UgKGUuZy4sIHNldERhdGEoe3Byb3AxOiB2YWwxLCBwcm9wMjogdmFsMn0pKS5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhrZXkpLmZvckVhY2goKFtkYXRhS2V5LCBkYXRhVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuaW50ZXJuYWxTZXREYXRhKGRhdGFLZXksIGRhdGFWYWx1ZSwgb3JpZ2luU3RhdGVQcm92aWRlcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgc2luZ2xlIGtleS92YWx1ZSBwYWlycywgaW5jbHVkaW5nIG5lc3RlZCBwYXRocyAoZS5nLiwgJ3VzZXIuZmlyc3ROYW1lJykuXG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBvd25lckRldGFpbHMgICA9IG1lLmdldE93bmVyT2ZEYXRhUHJvcGVydHkoa2V5KSxcbiAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyID0gb3duZXJEZXRhaWxzID8gb3duZXJEZXRhaWxzLm93bmVyIDogKG9yaWdpblN0YXRlUHJvdmlkZXIgfHwgbWUpLFxuICAgICAgICAgICAgcGF0aFBhcnRzICAgICAgPSBrZXkuc3BsaXQoJy4nKTtcblxuICAgICAgICBsZXQgY3VycmVudFBhdGggICAgID0gJycsXG4gICAgICAgICAgICBjdXJyZW50Q29uZmlnICAgPSBudWxsLFxuICAgICAgICAgICAgY3VycmVudFByb3ZpZGVyID0gdGFyZ2V0UHJvdmlkZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXRoUGFydHNbaV07XG4gICAgICAgICAgICBjdXJyZW50UGF0aCA9IGN1cnJlbnRQYXRoID8gYCR7Y3VycmVudFBhdGh9LiR7cGFydH1gIDogcGFydDtcbiAgICAgICAgICAgIGN1cnJlbnRDb25maWcgPSBjdXJyZW50UHJvdmlkZXIuZ2V0RGF0YUNvbmZpZyhjdXJyZW50UGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChpID09PSBwYXRoUGFydHMubGVuZ3RoIC0gMSkgeyAvLyBMYXN0IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIGZvciB0aGUgZmluYWwgcHJvcGVydHkgaW4gdGhlIHBhdGguXG4gICAgICAgICAgICAgICAgbWUuI3NldENvbmZpZ1ZhbHVlKGN1cnJlbnRQcm92aWRlciwgY3VycmVudFBhdGgsIHZhbHVlLCBudWxsKVxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gSW50ZXJtZWRpYXRlIHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgaW50ZXJtZWRpYXRlIHBhdGhzIGV4aXN0IGFzIG9iamVjdHMuIElmIG5vdCwgY3JlYXRlIHRoZW0uXG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gaW50ZXJtZWRpYXRlIHBhdGggZXhpc3RzIGJ1dCBpcyBub3QgYW4gb2JqZWN0LCBvdmVyd3JpdGUgaXQgd2l0aCBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcgPSBuZXcgQ29uZmlnKHt9KTsgLy8gQ3JlYXRlIGFuIGVtcHR5IG9iamVjdCBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3ZpZGVyLiNkYXRhQ29uZmlnc1tjdXJyZW50UGF0aF0gPSBjdXJyZW50Q29uZmlnXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghTmVvLmlzT2JqZWN0KGN1cnJlbnRDb25maWcuZ2V0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcuc2V0KHt9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNvbnZlbmllbmNlIG1ldGhvZCB0byBjaGVjayBpZiBhIGJpbmRpbmcgdmFsdWUgaXMgc3VwcG9zZWQgdG8gbWF0Y2ggYSBzdG9yZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzU3RvcmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdGFydHNXaXRoKCdzdG9yZXMuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgKi9cbiAgICBvbkRhdGFQcm9wZXJ0eUNoYW5nZShrZXksIHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgcHJvY2Vzc2VzIGEgZGF0YSBvYmplY3QsIGNyZWF0aW5nIG9yIHVwZGF0aW5nIE5lby5jb3JlLkNvbmZpZyBpbnN0YW5jZXNcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eSBhbmQgc3RvcmluZyB0aGVtIGluIHRoZSAjZGF0YUNvbmZpZ3MgbWFwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIGRhdGEgb2JqZWN0IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoPScnXSBUaGUgY3VycmVudCBwYXRoIHByZWZpeCBmb3IgbmVzdGVkIG9iamVjdHMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHByb2Nlc3NEYXRhT2JqZWN0KG9iaiwgcGF0aCA9ICcnKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMob2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBhIENvbmZpZyBpbnN0YW5jZSBleGlzdHMgZm9yIHRoZSBjdXJyZW50IGZ1bGxQYXRoXG4gICAgICAgICAgICBpZiAobWUuI2RhdGFDb25maWdzW2Z1bGxQYXRoXSkge1xuICAgICAgICAgICAgICAgIG1lLiNkYXRhQ29uZmlnc1tmdWxsUGF0aF0uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUuI2RhdGFDb25maWdzW2Z1bGxQYXRoXSA9IG5ldyBDb25maWcodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgaXRzIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChOZW8udHlwZU9mKHZhbHVlKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBtZS5wcm9jZXNzRGF0YU9iamVjdCh2YWx1ZSwgZnVsbFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RvcmVOYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZVN0b3JlKGNvbXBvbmVudCwgY29uZmlnTmFtZSwgc3RvcmVOYW1lKSB7XG4gICAgICAgIGxldCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmUoc3RvcmVOYW1lKTtcblxuICAgICAgICBpZiAoY29tcG9uZW50W2NvbmZpZ05hbWVdICE9PSBzdG9yZSkge1xuICAgICAgICAgICAgY29tcG9uZW50W2NvbmZpZ05hbWVdID0gc3RvcmVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgYSBjb25maWcgdmFsdWUgYW5kIHRyaWdnZXIgcmVhY3Rpdml0eS5cbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IENvbmZpZyBpbnN0YW5jZSBpZiBvbmUgZG9lc24ndCBleGlzdCBmb3IgdGhlIGdpdmVuIHBhdGgsXG4gICAgICogb3IgdXBkYXRlcyBhbiBleGlzdGluZyBvbmUuIEl0IGFsc28gdHJpZ2dlcnMgYmluZGluZyBlZmZlY3RzIGFuZCBjYWxscyBvbkRhdGFQcm9wZXJ0eUNoYW5nZS5cbiAgICAgKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcn0gcHJvdmlkZXIgVGhlIFN0YXRlUHJvdmlkZXIgaW5zdGFuY2Ugb3duaW5nIHRoZSBjb25maWcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIGZ1bGwgcGF0aCBvZiB0aGUgZGF0YSBwcm9wZXJ0eSAoZS5nLiwgJ3VzZXIuZmlyc3RuYW1lJykuXG4gICAgICogQHBhcmFtIHsqfSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbCBUaGUgb2xkIHZhbHVlIChvcHRpb25hbCwgdXNlZCBmb3IgaW5pdGlhbCBzZXR1cCkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjc2V0Q29uZmlnVmFsdWUocHJvdmlkZXIsIHBhdGgsIG5ld1ZhbHVlLCBvbGRWYWwpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRDb25maWcgPSBwcm92aWRlci5nZXREYXRhQ29uZmlnKHBhdGgpLFxuICAgICAgICAgICAgb2xkVmFsdWUgICAgICA9IG9sZFZhbDtcblxuICAgICAgICBpZiAoY3VycmVudENvbmZpZykge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSBjdXJyZW50Q29uZmlnLmdldCgpO1xuICAgICAgICAgICAgY3VycmVudENvbmZpZy5zZXQobmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudENvbmZpZyA9IG5ldyBDb25maWcobmV3VmFsdWUpO1xuICAgICAgICAgICAgcHJvdmlkZXIuI2RhdGFDb25maWdzW3BhdGhdID0gY3VycmVudENvbmZpZztcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYWxsIGJpbmRpbmcgZWZmZWN0cyB0byByZS1ldmFsdWF0ZSB0aGVpciBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIHByb3ZpZGVyLiNiaW5kaW5nRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QucnVuKCkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgb2YgdGhlIGRhdGEgcHJvcGVydHkgY2hhbmdlLlxuICAgICAgICBwcm92aWRlci5vbkRhdGFQcm9wZXJ0eUNoYW5nZShwYXRoLCBuZXdWYWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB3aWxsIGFzc2lnbiBhbGwgdmFsdWVzIHRvIHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgd2hlcmUgaXQgZmluZHMgYW4gZXhpc3Rpbmcga2V5LlxuICAgICAqIEluIGNhc2Ugbm8gbWF0Y2ggaXMgZm91bmQgaW5zaWRlIHRoZSBwYXJlbnQgY2hhaW4sIGEgbmV3IGRhdGEgcHJvcGVydHkgd2lsbCBnZXQgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldERhdGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCB0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIHNldERhdGEoKSBpbiBjYXNlIHlvdSB3YW50IHRvIGVuZm9yY2VcbiAgICAgKiBzZXR0aW5nIGFsbCBrZXlzIG9uIHRoaXMgaW5zdGFuY2UgaW5zdGVhZCBvZiBsb29raW5nIGZvciBtYXRjaGVzIGluc2lkZSBwYXJlbnQgc3RhdGVQcm92aWRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc2V0RGF0YUF0U2FtZUxldmVsKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFByb3ZpZGVyKTtcbiIsImltcG9ydCBFZmZlY3RNYW5hZ2VyIGZyb20gJy4uL2NvcmUvRWZmZWN0TWFuYWdlci5tanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXN0ZWQgUHJveHkgdGhhdCByZXByZXNlbnRzIGEgbGV2ZWwgaW4gdGhlIGhpZXJhcmNoaWNhbCBkYXRhIHN0cnVjdHVyZS5cbiAqIEBwYXJhbSB7TmVvLnN0YXRlLlByb3ZpZGVyfSByb290UHJvdmlkZXIgVGhlIHRvcC1sZXZlbCBwcm92aWRlciB0byBzdGFydCBzZWFyY2hlcyBmcm9tLlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIGN1cnJlbnQgcGF0aCBvZiB0aGlzIHByb3h5IGxldmVsIChlLmcuLCAndXNlcicgZm9yIGRhdGEudXNlcikuXG4gKiBAcmV0dXJucyB7UHJveHl8bnVsbH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5lc3RlZFByb3h5KHJvb3RQcm92aWRlciwgcGF0aCkge1xuICAgIC8vIFRoZSB0YXJnZXQgb2JqZWN0IGZvciB0aGUgcHJveHkgY2FuIGJlIGVtcHR5IGJlY2F1c2UgYWxsIGxvb2t1cHMgYXJlIGR5bmFtaWMuXG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG5cbiAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGdldCB0cmFwIGZvciB0aGUgcHJveHkuIFRoaXMgaXMgd2hlcmUgdGhlIG1hZ2ljIGhhcHBlbnMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50VGFyZ2V0IFRoZSBwcm94eSdzIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGJlaW5nIGFjY2Vzc2VkLlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBvciBhIG5ldyBwcm94eSBmb3IgbmVzdGVkIGFjY2Vzcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldChjdXJyZW50VGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludGVybmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSBzZXQgZGlyZWN0bHkgb24gdGhlIHByb3h5J3MgdGFyZ2V0XG4gICAgICAgICAgICAvLyBvciBhcmUgZXhwZWN0ZWQgYnkgdGhlIGVudmlyb25tZW50IChsaWtlIFNpZXN0YSdzIF9fUkVGQURSX18pLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N5bWJvbCcgfHwgcHJvcGVydHkgPT09ICdfX1JFRkFEUl9fJyB8fCBwcm9wZXJ0eSA9PT0gJ2luc3BlY3QnIHx8IHByb3BlcnR5ID09PSAndGhlbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoY3VycmVudFRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IGFsbG93IHN0cmluZyBvciBudW1iZXIgcHJvcGVydGllcyB0byBwcm9jZWVkIGFzIGRhdGEgcGF0aHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcGVydHkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gRm9yIG90aGVyIG5vbi1zdHJpbmcvbm9uLW51bWJlciBwcm9wZXJ0aWVzLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGggPyBgJHtwYXRofS4ke3Byb3BlcnR5fWAgOiBwcm9wZXJ0eTtcblxuICAgICAgICAgICAgLy8gMS4gQ2hlY2sgaWYgdGhlIGZ1bGwgcGF0aCBjb3JyZXNwb25kcyB0byBhbiBhY3R1YWwgZGF0YSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGNvbnN0IG93bmVyRGV0YWlscyA9IHJvb3RQcm92aWRlci5nZXRPd25lck9mRGF0YVByb3BlcnR5KGZ1bGxQYXRoKTtcblxuICAgICAgICAgICAgaWYgKG93bmVyRGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHtvd25lciwgcHJvcGVydHlOYW1lfSA9IG93bmVyRGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnICAgICAgICAgICAgICAgID0gb3duZXIuZ2V0RGF0YUNvbmZpZyhwcm9wZXJ0eU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVFZmZlY3QgPSBFZmZlY3RNYW5hZ2VyLmdldEFjdGl2ZUVmZmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3QuYWRkRGVwZW5kZW5jeShjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIHJldHVybiBhIG5ldyBwcm94eSBmb3IgaXQgdG8gZW5zdXJlIG5lc3RlZCBhY2Nlc3NlcyBhcmUgYWxzbyBwcm94aWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTmVzdGVkUHJveHkocm9vdFByb3ZpZGVyLCBmdWxsUGF0aClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAyLiBJZiBub3QgYSBkaXJlY3QgbWF0Y2gsIGl0IG1pZ2h0IGJlIGEgcGFyZW50IG9iamVjdCBvZiBhIG5lc3RlZCBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gICAgKGUuZy4sIGFjY2Vzc2luZyBgdXNlcmAgd2hlbiBhIGB1c2VyLmZpcnN0bmFtZWAgYmluZGluZyBleGlzdHMpLlxuICAgICAgICAgICAgLy8gICAgSW4gdGhpcyBjYXNlLCB3ZSByZXR1cm4gYW5vdGhlciBwcm94eSBmb3IgdGhlIG5leHQgbGV2ZWwgZG93bi5cbiAgICAgICAgICAgIGlmIChyb290UHJvdmlkZXIuaGFzTmVzdGVkRGF0YVN0YXJ0aW5nV2l0aChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTmVzdGVkUHJveHkocm9vdFByb3ZpZGVyLCBmdWxsUGF0aClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMy4gSWYgaXQncyBuZWl0aGVyIGEgZGF0YSBwcm9wZXJ0eSBub3IgYSBwYXRoIHRvIG9uZSwgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgc3RhdGUuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChjdXJyZW50VGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IGludGVybmFsIHByb3BlcnRpZXMgKGxpa2UgU3ltYm9scyBvciBzcGVjaWZpYyBzdHJpbmdzKSB0byBiZSBzZXQgZGlyZWN0bHkgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzeW1ib2wnIHx8IHByb3BlcnR5ID09PSAnX19SRUZBRFJfXycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQoY3VycmVudFRhcmdldCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoID8gYCR7cGF0aH0uJHtwcm9wZXJ0eX1gIDogcHJvcGVydHk7XG4gICAgICAgICAgICBjb25zdCBvd25lckRldGFpbHMgPSByb290UHJvdmlkZXIuZ2V0T3duZXJPZkRhdGFQcm9wZXJ0eShmdWxsUGF0aCk7XG5cbiAgICAgICAgICAgIGxldCB0YXJnZXRQcm92aWRlcjtcbiAgICAgICAgICAgIGlmIChvd25lckRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRQcm92aWRlciA9IG93bmVyRGV0YWlscy5vd25lcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gb3duZXIgaXMgZm91bmQsIHNldCBpdCBvbiB0aGUgcm9vdFByb3ZpZGVyICh0aGUgb25lIHRoYXQgY3JlYXRlZCB0aGlzIHByb3h5KVxuICAgICAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyID0gcm9vdFByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRQcm92aWRlci5zZXREYXRhKGZ1bGxQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gSW5kaWNhdGUgdGhhdCB0aGUgYXNzaWdubWVudCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICB9LFxuXG4gICAgICAgIG93bktleXMoY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RQcm92aWRlci5nZXRUb3BMZXZlbERhdGFLZXlzKHBhdGgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50VGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoID8gYCR7cGF0aH0uJHtwcm9wZXJ0eX1gIDogcHJvcGVydHk7XG4gICAgICAgICAgICBjb25zdCBvd25lckRldGFpbHMgPSByb290UHJvdmlkZXIuZ2V0T3duZXJPZkRhdGFQcm9wZXJ0eShmdWxsUGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChvd25lckRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBvd25lckRldGFpbHMub3duZXIuZ2V0RGF0YUNvbmZpZyhvd25lckRldGFpbHMucHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29uZmlnLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IE5lby5pc09iamVjdCh2YWx1ZSkgPyBjcmVhdGVOZXN0ZWRQcm94eShyb290UHJvdmlkZXIsIGZ1bGxQYXRoKSA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFByb3BlcnR5IG5vdCBmb3VuZFxuICAgICAgICB9XG4gICAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUHJveHkgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgbWVyZ2VkLCBoaWVyYXJjaGljYWwgZGF0YSBmcm9tIGEgYHN0YXRlLlByb3ZpZGVyYCBjaGFpbi5cbiAqIFdoZW4gYSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCB0aHJvdWdoIHRoaXMgcHJveHkgd2hpbGUgYW4gRWZmZWN0IGlzIHJ1bm5pbmcsIGl0IGF1dG9tYXRpY2FsbHlcbiAqIHRyYWNrcyB0aGUgdW5kZXJseWluZyBjb3JlLkNvbmZpZyBpbnN0YW5jZSBhcyBhIGRlcGVuZGVuY3kuXG4gKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcn0gcHJvdmlkZXIgVGhlIHN0YXJ0aW5nIHN0YXRlLlByb3ZpZGVyLlxuICogQHJldHVybnMge1Byb3h5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGllcmFyY2hpY2FsRGF0YVByb3h5KHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5lc3RlZFByb3h5KHByb3ZpZGVyLCAnJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==