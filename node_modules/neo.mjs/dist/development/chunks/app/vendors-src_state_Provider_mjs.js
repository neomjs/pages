"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_state_Provider_mjs"],{

/***/ "./src/state/Provider.mjs":
/*!********************************!*\
  !*** ./src/state/Provider.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");





const dataVariableRegex   = /data((?!(\.[a-z_]\w*\(\)))\.[a-z_]\w*)+/gi,
      twoWayBindingSymbol = Symbol.for('twoWayBinding'),
      variableNameRegex   = /^\w*/;

/**
 * An optional component state provider for adding bindings to configs
 * @class Neo.state.Provider
 * @extends Neo.core.Base
 */
class Provider extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.state.Provider'
         * @protected
         */
        className: 'Neo.state.Provider',
        /**
         * @member {String} ntype='state-provider'
         * @protected
         */
        ntype: 'state-provider',
        /**
         * @member {Object|null} bindings_=null
         * @protected
         */
        bindings_: null,
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Object|null} data_=null
         */
        data_: null,
        /**
         * @member {Object|null} formulas_=null
         *
         * @example
         *     data: {
         *         a: 1,
         *         b: 2
         *     }
         *     formulas: {
         *         aPlusB: {
         *             bind: {
         *                 foo: 'a',
         *                 bar: 'b'
         *             },
         *             get(data) {
         *                 return data.foo + data.bar
         *             }
         *         }
         *     }
         */
        formulas_: null,
        /**
         * @member {Neo.state.Provider|null} parent_=null
         */
        parent_: null,
        /**
         * @member {Object|null} stores_=null
         */
        stores_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        Neo.currentWorker.isUsingStateProviders = true;
        super.construct(config);
        this.bindings = {}
    }

    /**
     * Adds a given key/value combination on this stateProvider level.
     * The method is used by setData() & setDataAtSameLevel()
     * in case the  data property does not exist yet.
     * @param {String} key
     * @param {*} value
     * @private
     */
    addDataProperty(key, value) {
        let me = this,
            data, scope;

        Neo.ns(key, true, me.data);

        data = me.getDataScope(key);
        scope = data.scope;

        scope[data.key] = value;

        me.createDataProperties(me.data, 'data')
    }

    /**
     * Triggered after the data config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        value && this.createDataProperties(value, 'data')
    }

    /**
     * Triggered after the formulas config got changed
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetFormulas(value, oldValue) {
        value && this.resolveFormulas(null)
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return value || {}
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.state.Provider|null} value
     * @param {Neo.state.Provider|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value ? value : this.getParent()
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        if (value) {
            let me = this;

            Object.entries(value).forEach(([key, storeValue]) => {
                // support mapping string based listeners into the stateProvider instance
                Object.entries(storeValue.listeners || {}).forEach(([listenerKey, listener]) => {
                    me.bindCallback(listener, listenerKey, me, storeValue.listeners)
                })

                value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(storeValue)
            })
        }

        return value
    }

    /**
     * @param {Function} formatter
     * @param {Object} data=null optionally pass this.getHierarchyData() for performance reasons
     * @returns {String}
     */
    callFormatter(formatter, data=null) {
        if (!data) {
            data = this.getHierarchyData()
        }

        return formatter.call(this, data)
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise, it will use the closest stateProvider with a match.
     * @param {String} componentId
     * @param {String} key
     * @param {String} value
     * @param {String} formatter
     */
    createBinding(componentId, key, value, formatter) {
        let me      = this,
            data    = me.getDataScope(key),
            scope   = data.scope,
            keyLeaf = data.key,
            bindingScope, parentStateProvider;

        if (scope?.hasOwnProperty(keyLeaf)) {
            bindingScope = Neo.ns(`${key}.${componentId}`, true, me.bindings);
            bindingScope[value] = formatter
        } else {
            parentStateProvider = me.getParent();

            if (parentStateProvider) {
                parentStateProvider.createBinding(componentId, key, value, formatter)
            } else {
                console.error('No state.Provider found with the specified data property', componentId, keyLeaf, value)
            }
        }
    }

    /**
     * Registers a new binding in case a matching data property does exist.
     * Otherwise, it will use the closest stateProvider with a match.
     * @param {String} componentId
     * @param {String} formatter
     * @param {String} value
     * @returns {String[]}
     */
    createBindingByFormatter(componentId, formatter, value) {
        let me            = this,
            formatterVars = me.getFormatterVariables(formatter);

        formatterVars.forEach(key => {
            me.createBinding(componentId, key, value, formatter)
        });

        return formatterVars
    }

    /**
     * @param {Neo.component.Base} component
     */
    createBindings(component) {
        Object.entries(component.bind).forEach(([key, value]) => {
            let twoWayBinding = false,
                formatterVars;

            if (Neo.isObject(value)) {
                twoWayBinding = true;
                value         = value.value
            }

            if (!this.isStoreValue(value)) {
                formatterVars = this.createBindingByFormatter(component.id, value, key);

                if (twoWayBinding) {
                    component.bind[key].key = formatterVars[0];
                    component[twoWayBindingSymbol] = true;
                }
            }
        })
    }

    /**
     * @param {Object} config
     * @param {String} path
     */
    createDataProperties(config, path) {
        let me   = this,
            root = Neo.ns(path, false, me),
            descriptor, keyValue, newPath;

        Object.entries(config).forEach(([key, value]) => {
            if (!key.startsWith('_')) {
                descriptor = Object.getOwnPropertyDescriptor(root, key);
                newPath    = `${path}.${key}`

                if (!(typeof descriptor === 'object' && typeof descriptor.set === 'function')) {
                    keyValue = config[key];
                    me.createDataProperty(key, newPath, root);
                    root[key] = keyValue
                }

                if (Neo.isObject(value)) {
                    me.createDataProperties(config[key], newPath)
                }
            }
        })
    }

    /**
     * @param {String} key
     * @param {String} path
     * @param {Object} root=this.data
     */
    createDataProperty(key, path, root=this.data) {
        let me = this;

        if (path?.startsWith('data.')) {
            path = path.substring(5)
        }

        Object.defineProperty(root, key, {
            get() {
                let value = root['_' + key];

                if (Neo.typeOf(value) === 'Date') {
                    value = new Date(value.valueOf())
                }

                return value
            },

            set(value) {
                let _key     = `_${key}`,
                    oldValue = root[_key];

                if (!root[_key]) {
                    Object.defineProperty(root, _key, {
                        enumerable: false,
                        value,
                        writable  : true
                    })
                } else {
                    root[_key] = value
                }

                if (!Neo.isEqual(value, oldValue)) {
                    me.onDataPropertyChange(path ? path : key, value, oldValue)
                }
            }
        })
    }

    /**
     * Convenience shortcut
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        return this.component.getController(ntype)
    }

    /**
     * Access the closest data property inside the parent chain.
     * @param {String} key
     * @param {Neo.state.Provider} originStateProvider=this for internal usage only
     * @returns {*} value
     */
    getData(key, originStateProvider=this) {
        let me      = this,
            data    = me.getDataScope(key),
            {scope} = data,
            keyLeaf = data.key,
            parentStateProvider;

        if (scope?.hasOwnProperty(keyLeaf)) {
            return scope[keyLeaf]
        }

        parentStateProvider = me.getParent();

        if (!parentStateProvider) {
            console.error(`data property '${key}' does not exist.`, originStateProvider)
        }

        return parentStateProvider.getData(key, originStateProvider)
    }

    /**
     * Helper method to get the scope for a nested data property via Neo.ns() if needed.
     *
     * Example: passing the value 'foo.bar.baz' will return the bar object as the scope
     * and 'baz' as the key.
     * @param key
     * @returns {Object}
     */
    getDataScope(key) {
        let me      = this,
            keyLeaf = key,
            {data}  = me;

        if (key.includes('.')) {
            key     = key.split('.');
            keyLeaf = key.pop();
            data    = Neo.ns(key.join('.'), false, data)
        }

        return {
            key  : keyLeaf,
            scope: data
        }
    }

    /**
     * Extracts data variables from a given formatter string
     * @param {String} value
     */
    getFormatterVariables(value) {
        let {environment} = Neo.config;

        if (Neo.isFunction(value)) {
            value = value.toString()
        }

        if (environment === 'dist/esm' || environment === 'dist/production') {
            // See: https://github.com/neomjs/neo/issues/2371
            // Inside dist/esm & dist/prod the formatter:
            // data => DateUtil.convertToyyyymmdd(data.currentDate)
            // will get minified to:
            // e=>s.Z.convertToyyyymmdd(e.currentDate)
            // The new strategy: find the first variable name => "e"
            // Replace it with "data":
            // data=>s.Z.convertToyyyymmdd(data.currentDate)
            // From there we can use the dev mode regex again.

            let dataName       = value.match(variableNameRegex)[0],
                variableRegExp = new RegExp(`(^|[^\\w.])(${dataName})(?!\\w)`, 'g');

            value = value.replace(variableRegExp, '$1data')
        }

        let dataVars = value.match(dataVariableRegex) || [],
            result   = [];

        dataVars.forEach(variable => {
            // remove the "data." at the start
            variable = variable.substr(5);
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].add(result, variable)
        });

        result.sort();

        return result
    }

    /**
     * Returns the merged data
     * @param {Object} data=this.getPlainData()
     * @returns {Object} data
     */
    getHierarchyData(data=this.getPlainData()) {
        let me     = this,
            parent = me.getParent();

        if (parent) {
            return {
                ...parent.getHierarchyData(data),
                ...me.getPlainData()
            }
        }

        return me.getPlainData()
    }

    /**
     * Returns a plain version of this.data.
     * This excludes the property getters & setters.
     * @param {Object} data=this.data
     * @returns {Object}
     */
    getPlainData(data=this.data) {
        let plainData = {};

        Object.entries(data).forEach(([key, value]) => {
            if (Neo.typeOf(value) === 'Object') {
                plainData[key] = this.getPlainData(value)
            } else {
                plainData[key] = value
            }
        });

        return plainData
    }

    /**
     * Get the closest stateProvider inside the components parent tree
     * @returns {Neo.state.Provider|null}
     */
    getParent() {
        let {parent} = this;

        if (parent) {
            return parent
        }

        return this.component.parent?.getStateProvider() || null
    }

    /**
     * Access the closest store inside the VM parent chain.
     * @param {String} key
     * @param {Neo.state.Provider} originStateProvider=this for internal usage only
     * @returns {Neo.data.Store}
     */
    getStore(key, originStateProvider=this) {
        let me       = this,
            {stores} = me,
            parentStateProvider;

        if (stores?.hasOwnProperty(key)) {
            return stores[key]
        }

        parentStateProvider = me.getParent();

        if (!parentStateProvider) {
            console.error(`store '${key}' not found inside this stateProvider or parents.`, originStateProvider)
        }

        return parentStateProvider.getStore(key, originStateProvider)
    }

    /**
     * Internal method to avoid code redundancy.
     * Use setData() or setDataAtSameLevel() instead.
     *
     * Passing an originStateProvider param will try to set each key on the closest property match
     * inside the parent stateProvider chain => setData()
     * Not passing it will set all values on the stateProvider where the method gets called => setDataAtSameLevel()
     * @param {Object|String} key
     * @param {*} value
     * @param {Neo.state.Provider} [originStateProvider]
     * @protected
     */
    internalSetData(key, value, originStateProvider) {
        let me = this,
            data, keyLeaf, parentStateProvider, scope;

        if (Neo.isObject(value) && !value.isRecord) {
            Object.entries(value).forEach(([dataKey, dataValue]) => {
                me.internalSetData(`${key}.${dataKey}`, dataValue, originStateProvider)
            })
        } else if (Neo.isObject(key)) {
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originStateProvider)
            })
        } else {
            data    = me.getDataScope(key);
            keyLeaf = data.key;
            scope   = data.scope;

            if (scope?.hasOwnProperty(keyLeaf)) {
                scope[keyLeaf] = value
            } else {
                if (originStateProvider) {
                    parentStateProvider = me.getParent();

                    if (parentStateProvider) {
                        parentStateProvider.internalSetData(key, value, originStateProvider)
                    } else {
                        originStateProvider.addDataProperty(key, value)
                    }
                } else {
                    me.addDataProperty(key, value)
                }
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return Neo.isString(value) && value.startsWith('stores.')
    }

    /**
     * Override this method to change the order configs are applied to this instance.
     * @param {Object} config
     * @param {Boolean} [preventOriginalConfig] True prevents the instance from getting an originalConfig property
     * @returns {Object} config
     */
    mergeConfig(config, preventOriginalConfig) {
        if (config.data) {
            config.data = Neo.merge(Neo.clone(this.constructor.config.data, true) || {}, config.data)
        }

        return super.mergeConfig(config, preventOriginalConfig)
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        let me      = this,
            binding = me.bindings && Neo.ns(key, false, me.bindings),
            component, config, hierarchyData, stateProvider;

        if (binding) {
            hierarchyData = {};

            Object.entries(binding).forEach(([componentId, configObject]) => {
                component     = Neo.getComponent(componentId) || Neo.get(componentId); // timing issue: the cmp might not be registered inside manager.Component yet
                config        = {};
                stateProvider = component.getStateProvider() || me;

                if (!hierarchyData[stateProvider.id]) {
                    hierarchyData[stateProvider.id] = stateProvider.getHierarchyData()
                }

                Object.entries(configObject).forEach(([configField, formatter]) => {
                    // we can not call me.callFormatter(), since a data property inside a parent stateProvider
                    // could have changed which is relying on data properties inside a closer stateProvider
                    config[configField] = stateProvider.callFormatter(formatter, hierarchyData[stateProvider.id])
                });

                component?.set(config)
            })
        }

        me.formulas && me.resolveFormulas({key, id: me.id, oldValue, value});

        me.fire('dataPropertyChange', {key, id: me.id, oldValue, value})
    }

    /**
     * This method will assign binding values at the earliest possible point inside the component lifecycle.
     * It can not store bindings though, since child component ids most likely do not exist yet.
     * @param {Neo.component.Base} component=this.component
     */
    parseConfig(component=this.component) {
        let me     = this,
            config = {};

        if (component.bind) {
            me.createBindings(component);

            Object.entries(component.bind).forEach(([key, value]) => {
                if (Neo.isObject(value)) {
                    value.key = me.getFormatterVariables(value.value)[0];
                    value = value.value
                }

                if (me.isStoreValue(value)) {
                    me.resolveStore(component, key, value.substring(7)) // remove the "stores." at the start
                } else {
                    config[key] = me.callFormatter(value)
                }
            });

            component.set(config)
        }
    }

    /**
     * Removes all bindings for a given component id inside this stateProvider as well as inside all parent stateProviders.
     * @param {String} componentId
     */
    removeBindings(componentId) {
        let me = this;

        Object.entries(me.bindings).forEach(([dataProperty, binding]) => {
            delete binding[componentId]
        });

        me.getParent()?.removeBindings(componentId)
    }

    /**
     * Resolve the formulas initially and update, when data change
     * @param {Object} data data from event or null on initial call
     */
    resolveFormulas(data) {
        let me         = this,
            {formulas} = me,
            initialRun = !data,
            affectFormula, bindObject, fn, key, result, value;

        if (formulas) {
            if (!initialRun && (!data.key || !data.value)) {
                console.warn('[StateProvider:formulas] missing key or value', data.key, data.value)
            }

            for ([key, value] of Object.entries(formulas)) {
                affectFormula = true;

                // Check if the change affects a formula
                if (!initialRun) {
                    affectFormula = Object.values(value.bind).includes(data.key)
                }

                if (affectFormula) {
                    // Create Bind-Object and fill with new values
                    bindObject = Neo.clone(value.bind);
                    fn         = value.get;

                    Object.keys(bindObject).forEach((key, index) => {
                        bindObject[key] = me.getData(bindObject[key])
                    });

                    // Calc the formula
                    result = fn(bindObject);

                    // Assign if no error or null
                    if (isNaN(result)) {
                        me.setData(key, null)
                    } else {
                        me.setData(key, result)
                    }
                }
            }
        }
    }

    /**
     * @param {Neo.component.Base} component
     * @param {String} configName
     * @param {String} storeName
     */
    resolveStore(component, configName, storeName) {
        let store = this.getStore(storeName);

        if (component[configName] !== store) {
            component[configName] = store
        }
    }

    /**
     * The method will assign all values to the closest stateProvider where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     * @param {Object|String} key
     * @param {*} value
     */
    setData(key, value) {
        this.internalSetData(key, value, this)
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent stateProviders.
     * @param {Object|String} key
     * @param {*} value
     */
    setDataAtSameLevel(key, value) {
        this.internalSetData(key, value)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Provider));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDTztBQUNOO0FBQ0s7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFJO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsd0JBQXdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3N0YXRlL1Byb3ZpZGVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCBmcm9tICcuLi91dGlsL0NsYXNzU3lzdGVtLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBPYnNlcnZhYmxlICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5cbmNvbnN0IGRhdGFWYXJpYWJsZVJlZ2V4ICAgPSAvZGF0YSgoPyEoXFwuW2Etel9dXFx3KlxcKFxcKSkpXFwuW2Etel9dXFx3KikrL2dpLFxuICAgICAgdHdvV2F5QmluZGluZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ3R3b1dheUJpbmRpbmcnKSxcbiAgICAgIHZhcmlhYmxlTmFtZVJlZ2V4ICAgPSAvXlxcdyovO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIGNvbXBvbmVudCBzdGF0ZSBwcm92aWRlciBmb3IgYWRkaW5nIGJpbmRpbmdzIHRvIGNvbmZpZ3NcbiAqIEBjbGFzcyBOZW8uc3RhdGUuUHJvdmlkZXJcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgUHJvdmlkZXIgZXh0ZW5kcyBCYXNlIHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS5PYnNlcnZhYmxlIG1peGluXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gb2JzZXJ2YWJsZT10cnVlXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBvYnNlcnZhYmxlID0gdHJ1ZVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uc3RhdGUuUHJvdmlkZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5zdGF0ZS5Qcm92aWRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdzdGF0ZS1wcm92aWRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdzdGF0ZS1wcm92aWRlcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gYmluZGluZ3NfPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZGluZ3NfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfG51bGx9IGNvbXBvbmVudD1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkYXRhXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXRhXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBmb3JtdWxhc189bnVsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgZGF0YToge1xuICAgICAgICAgKiAgICAgICAgIGE6IDEsXG4gICAgICAgICAqICAgICAgICAgYjogMlxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiAgICAgZm9ybXVsYXM6IHtcbiAgICAgICAgICogICAgICAgICBhUGx1c0I6IHtcbiAgICAgICAgICogICAgICAgICAgICAgYmluZDoge1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgZm9vOiAnYScsXG4gICAgICAgICAqICAgICAgICAgICAgICAgICBiYXI6ICdiJ1xuICAgICAgICAgKiAgICAgICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgICAgICBnZXQoZGF0YSkge1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZm9vICsgZGF0YS5iYXJcbiAgICAgICAgICogICAgICAgICAgICAgfVxuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICovXG4gICAgICAgIGZvcm11bGFzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5zdGF0ZS5Qcm92aWRlcnxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudF86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc3RvcmVzXz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZXNfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIuaXNVc2luZ1N0YXRlUHJvdmlkZXJzID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBnaXZlbiBrZXkvdmFsdWUgY29tYmluYXRpb24gb24gdGhpcyBzdGF0ZVByb3ZpZGVyIGxldmVsLlxuICAgICAqIFRoZSBtZXRob2QgaXMgdXNlZCBieSBzZXREYXRhKCkgJiBzZXREYXRhQXRTYW1lTGV2ZWwoKVxuICAgICAqIGluIGNhc2UgdGhlICBkYXRhIHByb3BlcnR5IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkRGF0YVByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEsIHNjb3BlO1xuXG4gICAgICAgIE5lby5ucyhrZXksIHRydWUsIG1lLmRhdGEpO1xuXG4gICAgICAgIGRhdGEgPSBtZS5nZXREYXRhU2NvcGUoa2V5KTtcbiAgICAgICAgc2NvcGUgPSBkYXRhLnNjb3BlO1xuXG4gICAgICAgIHNjb3BlW2RhdGEua2V5XSA9IHZhbHVlO1xuXG4gICAgICAgIG1lLmNyZWF0ZURhdGFQcm9wZXJ0aWVzKG1lLmRhdGEsICdkYXRhJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRhdGEgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldERhdGEodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIHRoaXMuY3JlYXRlRGF0YVByb3BlcnRpZXModmFsdWUsICdkYXRhJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGZvcm11bGFzIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRGb3JtdWxhcyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgdGhpcy5yZXNvbHZlRm9ybXVsYXMobnVsbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGRhdGEgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldERhdGEodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLnN0YXRlLlByb3ZpZGVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFBhcmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUgOiB0aGlzLmdldFBhcmVudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmVzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmVzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCBzdG9yZVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgbWFwcGluZyBzdHJpbmcgYmFzZWQgbGlzdGVuZXJzIGludG8gdGhlIHN0YXRlUHJvdmlkZXIgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhzdG9yZVZhbHVlLmxpc3RlbmVycyB8fCB7fSkuZm9yRWFjaCgoW2xpc3RlbmVyS2V5LCBsaXN0ZW5lcl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYmluZENhbGxiYWNrKGxpc3RlbmVyLCBsaXN0ZW5lcktleSwgbWUsIHN0b3JlVmFsdWUubGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHN0b3JlVmFsdWUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9ybWF0dGVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGE9bnVsbCBvcHRpb25hbGx5IHBhc3MgdGhpcy5nZXRIaWVyYXJjaHlEYXRhKCkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNhbGxGb3JtYXR0ZXIoZm9ybWF0dGVyLCBkYXRhPW51bGwpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5nZXRIaWVyYXJjaHlEYXRhKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuY2FsbCh0aGlzLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBiaW5kaW5nIGluIGNhc2UgYSBtYXRjaGluZyBkYXRhIHByb3BlcnR5IGRvZXMgZXhpc3QuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgY2xvc2VzdCBzdGF0ZVByb3ZpZGVyIHdpdGggYSBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50SWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdHRlclxuICAgICAqL1xuICAgIGNyZWF0ZUJpbmRpbmcoY29tcG9uZW50SWQsIGtleSwgdmFsdWUsIGZvcm1hdHRlcikge1xuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhICAgID0gbWUuZ2V0RGF0YVNjb3BlKGtleSksXG4gICAgICAgICAgICBzY29wZSAgID0gZGF0YS5zY29wZSxcbiAgICAgICAgICAgIGtleUxlYWYgPSBkYXRhLmtleSxcbiAgICAgICAgICAgIGJpbmRpbmdTY29wZSwgcGFyZW50U3RhdGVQcm92aWRlcjtcblxuICAgICAgICBpZiAoc2NvcGU/Lmhhc093blByb3BlcnR5KGtleUxlYWYpKSB7XG4gICAgICAgICAgICBiaW5kaW5nU2NvcGUgPSBOZW8ubnMoYCR7a2V5fS4ke2NvbXBvbmVudElkfWAsIHRydWUsIG1lLmJpbmRpbmdzKTtcbiAgICAgICAgICAgIGJpbmRpbmdTY29wZVt2YWx1ZV0gPSBmb3JtYXR0ZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudFN0YXRlUHJvdmlkZXIgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZVByb3ZpZGVyLmNyZWF0ZUJpbmRpbmcoY29tcG9uZW50SWQsIGtleSwgdmFsdWUsIGZvcm1hdHRlcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gc3RhdGUuUHJvdmlkZXIgZm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgcHJvcGVydHknLCBjb21wb25lbnRJZCwga2V5TGVhZiwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYmluZGluZyBpbiBjYXNlIGEgbWF0Y2hpbmcgZGF0YSBwcm9wZXJ0eSBkb2VzIGV4aXN0LlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGNsb3Nlc3Qgc3RhdGVQcm92aWRlciB3aXRoIGEgbWF0Y2guXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudElkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdHRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5nQnlGb3JtYXR0ZXIoY29tcG9uZW50SWQsIGZvcm1hdHRlciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgZm9ybWF0dGVyVmFycyA9IG1lLmdldEZvcm1hdHRlclZhcmlhYmxlcyhmb3JtYXR0ZXIpO1xuXG4gICAgICAgIGZvcm1hdHRlclZhcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbWUuY3JlYXRlQmluZGluZyhjb21wb25lbnRJZCwga2V5LCB2YWx1ZSwgZm9ybWF0dGVyKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyVmFyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5ncyhjb21wb25lbnQpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29tcG9uZW50LmJpbmQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgbGV0IHR3b1dheUJpbmRpbmcgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXJWYXJzO1xuXG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHR3b1dheUJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgPSB2YWx1ZS52YWx1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTdG9yZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlclZhcnMgPSB0aGlzLmNyZWF0ZUJpbmRpbmdCeUZvcm1hdHRlcihjb21wb25lbnQuaWQsIHZhbHVlLCBrZXkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR3b1dheUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmJpbmRba2V5XS5rZXkgPSBmb3JtYXR0ZXJWYXJzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRbdHdvV2F5QmluZGluZ1N5bWJvbF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhUHJvcGVydGllcyhjb25maWcsIHBhdGgpIHtcbiAgICAgICAgbGV0IG1lICAgPSB0aGlzLFxuICAgICAgICAgICAgcm9vdCA9IE5lby5ucyhwYXRoLCBmYWxzZSwgbWUpLFxuICAgICAgICAgICAgZGVzY3JpcHRvciwga2V5VmFsdWUsIG5ld1BhdGg7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29uZmlnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ18nKSkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJvb3QsIGtleSk7XG4gICAgICAgICAgICAgICAgbmV3UGF0aCAgICA9IGAke3BhdGh9LiR7a2V5fWBcblxuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVzY3JpcHRvci5zZXQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleVZhbHVlID0gY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZURhdGFQcm9wZXJ0eShrZXksIG5ld1BhdGgsIHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICByb290W2tleV0gPSBrZXlWYWx1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNyZWF0ZURhdGFQcm9wZXJ0aWVzKGNvbmZpZ1trZXldLCBuZXdQYXRoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcm9vdD10aGlzLmRhdGFcbiAgICAgKi9cbiAgICBjcmVhdGVEYXRhUHJvcGVydHkoa2V5LCBwYXRoLCByb290PXRoaXMuZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChwYXRoPy5zdGFydHNXaXRoKCdkYXRhLicpKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoNSlcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb290LCBrZXksIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSByb290WydfJyArIGtleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBfa2V5ICAgICA9IGBfJHtrZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByb290W19rZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyb290W19rZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb290LCBfa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGUgIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RbX2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghTmVvLmlzRXF1YWwodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZS5vbkRhdGFQcm9wZXJ0eUNoYW5nZShwYXRoID8gcGF0aCA6IGtleSwgdmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbnR5cGVdXG4gICAgICogQHJldHVybnMge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfVxuICAgICAqL1xuICAgIGdldENvbnRyb2xsZXIobnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmdldENvbnRyb2xsZXIobnR5cGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWNjZXNzIHRoZSBjbG9zZXN0IGRhdGEgcHJvcGVydHkgaW5zaWRlIHRoZSBwYXJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7TmVvLnN0YXRlLlByb3ZpZGVyfSBvcmlnaW5TdGF0ZVByb3ZpZGVyPXRoaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXREYXRhKGtleSwgb3JpZ2luU3RhdGVQcm92aWRlcj10aGlzKSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGRhdGEgICAgPSBtZS5nZXREYXRhU2NvcGUoa2V5KSxcbiAgICAgICAgICAgIHtzY29wZX0gPSBkYXRhLFxuICAgICAgICAgICAga2V5TGVhZiA9IGRhdGEua2V5LFxuICAgICAgICAgICAgcGFyZW50U3RhdGVQcm92aWRlcjtcblxuICAgICAgICBpZiAoc2NvcGU/Lmhhc093blByb3BlcnR5KGtleUxlYWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVba2V5TGVhZl1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudFN0YXRlUHJvdmlkZXIgPSBtZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAoIXBhcmVudFN0YXRlUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGRhdGEgcHJvcGVydHkgJyR7a2V5fScgZG9lcyBub3QgZXhpc3QuYCwgb3JpZ2luU3RhdGVQcm92aWRlcilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRTdGF0ZVByb3ZpZGVyLmdldERhdGEoa2V5LCBvcmlnaW5TdGF0ZVByb3ZpZGVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZ2V0IHRoZSBzY29wZSBmb3IgYSBuZXN0ZWQgZGF0YSBwcm9wZXJ0eSB2aWEgTmVvLm5zKCkgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTogcGFzc2luZyB0aGUgdmFsdWUgJ2Zvby5iYXIuYmF6JyB3aWxsIHJldHVybiB0aGUgYmFyIG9iamVjdCBhcyB0aGUgc2NvcGVcbiAgICAgKiBhbmQgJ2JheicgYXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXREYXRhU2NvcGUoa2V5KSB7XG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGtleUxlYWYgPSBrZXksXG4gICAgICAgICAgICB7ZGF0YX0gID0gbWU7XG5cbiAgICAgICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBrZXkgICAgID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBrZXlMZWFmID0ga2V5LnBvcCgpO1xuICAgICAgICAgICAgZGF0YSAgICA9IE5lby5ucyhrZXkuam9pbignLicpLCBmYWxzZSwgZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXkgIDoga2V5TGVhZixcbiAgICAgICAgICAgIHNjb3BlOiBkYXRhXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBkYXRhIHZhcmlhYmxlcyBmcm9tIGEgZ2l2ZW4gZm9ybWF0dGVyIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZvcm1hdHRlclZhcmlhYmxlcyh2YWx1ZSkge1xuICAgICAgICBsZXQge2Vudmlyb25tZW50fSA9IE5lby5jb25maWc7XG5cbiAgICAgICAgaWYgKE5lby5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW52aXJvbm1lbnQgPT09ICdkaXN0L2VzbScgfHwgZW52aXJvbm1lbnQgPT09ICdkaXN0L3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9uZW9tanMvbmVvL2lzc3Vlcy8yMzcxXG4gICAgICAgICAgICAvLyBJbnNpZGUgZGlzdC9lc20gJiBkaXN0L3Byb2QgdGhlIGZvcm1hdHRlcjpcbiAgICAgICAgICAgIC8vIGRhdGEgPT4gRGF0ZVV0aWwuY29udmVydFRveXl5eW1tZGQoZGF0YS5jdXJyZW50RGF0ZSlcbiAgICAgICAgICAgIC8vIHdpbGwgZ2V0IG1pbmlmaWVkIHRvOlxuICAgICAgICAgICAgLy8gZT0+cy5aLmNvbnZlcnRUb3l5eXltbWRkKGUuY3VycmVudERhdGUpXG4gICAgICAgICAgICAvLyBUaGUgbmV3IHN0cmF0ZWd5OiBmaW5kIHRoZSBmaXJzdCB2YXJpYWJsZSBuYW1lID0+IFwiZVwiXG4gICAgICAgICAgICAvLyBSZXBsYWNlIGl0IHdpdGggXCJkYXRhXCI6XG4gICAgICAgICAgICAvLyBkYXRhPT5zLlouY29udmVydFRveXl5eW1tZGQoZGF0YS5jdXJyZW50RGF0ZSlcbiAgICAgICAgICAgIC8vIEZyb20gdGhlcmUgd2UgY2FuIHVzZSB0aGUgZGV2IG1vZGUgcmVnZXggYWdhaW4uXG5cbiAgICAgICAgICAgIGxldCBkYXRhTmFtZSAgICAgICA9IHZhbHVlLm1hdGNoKHZhcmlhYmxlTmFtZVJlZ2V4KVswXSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVJlZ0V4cCA9IG5ldyBSZWdFeHAoYChefFteXFxcXHcuXSkoJHtkYXRhTmFtZX0pKD8hXFxcXHcpYCwgJ2cnKTtcblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHZhcmlhYmxlUmVnRXhwLCAnJDFkYXRhJylcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhVmFycyA9IHZhbHVlLm1hdGNoKGRhdGFWYXJpYWJsZVJlZ2V4KSB8fCBbXSxcbiAgICAgICAgICAgIHJlc3VsdCAgID0gW107XG5cbiAgICAgICAgZGF0YVZhcnMuZm9yRWFjaCh2YXJpYWJsZSA9PiB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIFwiZGF0YS5cIiBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUuc3Vic3RyKDUpO1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKHJlc3VsdCwgdmFyaWFibGUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC5zb3J0KCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lcmdlZCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGE9dGhpcy5nZXRQbGFpbkRhdGEoKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBnZXRIaWVyYXJjaHlEYXRhKGRhdGE9dGhpcy5nZXRQbGFpbkRhdGEoKSkge1xuICAgICAgICBsZXQgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudCA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucGFyZW50LmdldEhpZXJhcmNoeURhdGEoZGF0YSksXG4gICAgICAgICAgICAgICAgLi4ubWUuZ2V0UGxhaW5EYXRhKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZS5nZXRQbGFpbkRhdGEoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwbGFpbiB2ZXJzaW9uIG9mIHRoaXMuZGF0YS5cbiAgICAgKiBUaGlzIGV4Y2x1ZGVzIHRoZSBwcm9wZXJ0eSBnZXR0ZXJzICYgc2V0dGVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YT10aGlzLmRhdGFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFBsYWluRGF0YShkYXRhPXRoaXMuZGF0YSkge1xuICAgICAgICBsZXQgcGxhaW5EYXRhID0ge307XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcGxhaW5EYXRhW2tleV0gPSB0aGlzLmdldFBsYWluRGF0YSh2YWx1ZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhaW5EYXRhW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGxhaW5EYXRhXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5zdGF0ZS5Qcm92aWRlcnxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IHtwYXJlbnR9ID0gdGhpcztcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQucGFyZW50Py5nZXRTdGF0ZVByb3ZpZGVyKCkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY2VzcyB0aGUgY2xvc2VzdCBzdG9yZSBpbnNpZGUgdGhlIFZNIHBhcmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IG9yaWdpblN0YXRlUHJvdmlkZXI9dGhpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAqIEByZXR1cm5zIHtOZW8uZGF0YS5TdG9yZX1cbiAgICAgKi9cbiAgICBnZXRTdG9yZShrZXksIG9yaWdpblN0YXRlUHJvdmlkZXI9dGhpcykge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3N0b3Jlc30gPSBtZSxcbiAgICAgICAgICAgIHBhcmVudFN0YXRlUHJvdmlkZXI7XG5cbiAgICAgICAgaWYgKHN0b3Jlcz8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3Jlc1trZXldXG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRTdGF0ZVByb3ZpZGVyID0gbWUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKCFwYXJlbnRTdGF0ZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBzdG9yZSAnJHtrZXl9JyBub3QgZm91bmQgaW5zaWRlIHRoaXMgc3RhdGVQcm92aWRlciBvciBwYXJlbnRzLmAsIG9yaWdpblN0YXRlUHJvdmlkZXIpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50U3RhdGVQcm92aWRlci5nZXRTdG9yZShrZXksIG9yaWdpblN0YXRlUHJvdmlkZXIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGF2b2lkIGNvZGUgcmVkdW5kYW5jeS5cbiAgICAgKiBVc2Ugc2V0RGF0YSgpIG9yIHNldERhdGFBdFNhbWVMZXZlbCgpIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBQYXNzaW5nIGFuIG9yaWdpblN0YXRlUHJvdmlkZXIgcGFyYW0gd2lsbCB0cnkgdG8gc2V0IGVhY2gga2V5IG9uIHRoZSBjbG9zZXN0IHByb3BlcnR5IG1hdGNoXG4gICAgICogaW5zaWRlIHRoZSBwYXJlbnQgc3RhdGVQcm92aWRlciBjaGFpbiA9PiBzZXREYXRhKClcbiAgICAgKiBOb3QgcGFzc2luZyBpdCB3aWxsIHNldCBhbGwgdmFsdWVzIG9uIHRoZSBzdGF0ZVByb3ZpZGVyIHdoZXJlIHRoZSBtZXRob2QgZ2V0cyBjYWxsZWQgPT4gc2V0RGF0YUF0U2FtZUxldmVsKClcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcn0gW29yaWdpblN0YXRlUHJvdmlkZXJdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCBvcmlnaW5TdGF0ZVByb3ZpZGVyKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBkYXRhLCBrZXlMZWFmLCBwYXJlbnRTdGF0ZVByb3ZpZGVyLCBzY29wZTtcblxuICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSAmJiAhdmFsdWUuaXNSZWNvcmQpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbZGF0YUtleSwgZGF0YVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLmludGVybmFsU2V0RGF0YShgJHtrZXl9LiR7ZGF0YUtleX1gLCBkYXRhVmFsdWUsIG9yaWdpblN0YXRlUHJvdmlkZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKE5lby5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhrZXkpLmZvckVhY2goKFtkYXRhS2V5LCBkYXRhVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuaW50ZXJuYWxTZXREYXRhKGRhdGFLZXksIGRhdGFWYWx1ZSwgb3JpZ2luU3RhdGVQcm92aWRlcilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhICAgID0gbWUuZ2V0RGF0YVNjb3BlKGtleSk7XG4gICAgICAgICAgICBrZXlMZWFmID0gZGF0YS5rZXk7XG4gICAgICAgICAgICBzY29wZSAgID0gZGF0YS5zY29wZTtcblxuICAgICAgICAgICAgaWYgKHNjb3BlPy5oYXNPd25Qcm9wZXJ0eShrZXlMZWFmKSkge1xuICAgICAgICAgICAgICAgIHNjb3BlW2tleUxlYWZdID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpblN0YXRlUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50U3RhdGVQcm92aWRlciA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZVByb3ZpZGVyLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCBvcmlnaW5TdGF0ZVByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luU3RhdGVQcm92aWRlci5hZGREYXRhUHJvcGVydHkoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmFkZERhdGFQcm9wZXJ0eShrZXksIHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNvbnZlbmllbmNlIG1ldGhvZCB0byBjaGVjayBpZiBhIGJpbmRpbmcgdmFsdWUgaXMgc3VwcG9zZWQgdG8gbWF0Y2ggYSBzdG9yZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzU3RvcmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdGFydHNXaXRoKCdzdG9yZXMuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIG9yZGVyIGNvbmZpZ3MgYXJlIGFwcGxpZWQgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudE9yaWdpbmFsQ29uZmlnXSBUcnVlIHByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGdldHRpbmcgYW4gb3JpZ2luYWxDb25maWcgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZyhjb25maWcsIHByZXZlbnRPcmlnaW5hbENvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gTmVvLm1lcmdlKE5lby5jbG9uZSh0aGlzLmNvbnN0cnVjdG9yLmNvbmZpZy5kYXRhLCB0cnVlKSB8fCB7fSwgY29uZmlnLmRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIubWVyZ2VDb25maWcoY29uZmlnLCBwcmV2ZW50T3JpZ2luYWxDb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICovXG4gICAgb25EYXRhUHJvcGVydHlDaGFuZ2Uoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgYmluZGluZyA9IG1lLmJpbmRpbmdzICYmIE5lby5ucyhrZXksIGZhbHNlLCBtZS5iaW5kaW5ncyksXG4gICAgICAgICAgICBjb21wb25lbnQsIGNvbmZpZywgaGllcmFyY2h5RGF0YSwgc3RhdGVQcm92aWRlcjtcblxuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgaGllcmFyY2h5RGF0YSA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhiaW5kaW5nKS5mb3JFYWNoKChbY29tcG9uZW50SWQsIGNvbmZpZ09iamVjdF0pID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgICAgID0gTmVvLmdldENvbXBvbmVudChjb21wb25lbnRJZCkgfHwgTmVvLmdldChjb21wb25lbnRJZCk7IC8vIHRpbWluZyBpc3N1ZTogdGhlIGNtcCBtaWdodCBub3QgYmUgcmVnaXN0ZXJlZCBpbnNpZGUgbWFuYWdlci5Db21wb25lbnQgeWV0XG4gICAgICAgICAgICAgICAgY29uZmlnICAgICAgICA9IHt9O1xuICAgICAgICAgICAgICAgIHN0YXRlUHJvdmlkZXIgPSBjb21wb25lbnQuZ2V0U3RhdGVQcm92aWRlcigpIHx8IG1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFoaWVyYXJjaHlEYXRhW3N0YXRlUHJvdmlkZXIuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoeURhdGFbc3RhdGVQcm92aWRlci5pZF0gPSBzdGF0ZVByb3ZpZGVyLmdldEhpZXJhcmNoeURhdGEoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZ09iamVjdCkuZm9yRWFjaCgoW2NvbmZpZ0ZpZWxkLCBmb3JtYXR0ZXJdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBub3QgY2FsbCBtZS5jYWxsRm9ybWF0dGVyKCksIHNpbmNlIGEgZGF0YSBwcm9wZXJ0eSBpbnNpZGUgYSBwYXJlbnQgc3RhdGVQcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBoYXZlIGNoYW5nZWQgd2hpY2ggaXMgcmVseWluZyBvbiBkYXRhIHByb3BlcnRpZXMgaW5zaWRlIGEgY2xvc2VyIHN0YXRlUHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2NvbmZpZ0ZpZWxkXSA9IHN0YXRlUHJvdmlkZXIuY2FsbEZvcm1hdHRlcihmb3JtYXR0ZXIsIGhpZXJhcmNoeURhdGFbc3RhdGVQcm92aWRlci5pZF0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb21wb25lbnQ/LnNldChjb25maWcpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUuZm9ybXVsYXMgJiYgbWUucmVzb2x2ZUZvcm11bGFzKHtrZXksIGlkOiBtZS5pZCwgb2xkVmFsdWUsIHZhbHVlfSk7XG5cbiAgICAgICAgbWUuZmlyZSgnZGF0YVByb3BlcnR5Q2hhbmdlJywge2tleSwgaWQ6IG1lLmlkLCBvbGRWYWx1ZSwgdmFsdWV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYXNzaWduIGJpbmRpbmcgdmFsdWVzIGF0IHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBwb2ludCBpbnNpZGUgdGhlIGNvbXBvbmVudCBsaWZlY3ljbGUuXG4gICAgICogSXQgY2FuIG5vdCBzdG9yZSBiaW5kaW5ncyB0aG91Z2gsIHNpbmNlIGNoaWxkIGNvbXBvbmVudCBpZHMgbW9zdCBsaWtlbHkgZG8gbm90IGV4aXN0IHlldC5cbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50PXRoaXMuY29tcG9uZW50XG4gICAgICovXG4gICAgcGFyc2VDb25maWcoY29tcG9uZW50PXRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgY29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5iaW5kKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVCaW5kaW5ncyhjb21wb25lbnQpO1xuXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb21wb25lbnQuYmluZCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE5lby5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUua2V5ID0gbWUuZ2V0Rm9ybWF0dGVyVmFyaWFibGVzKHZhbHVlLnZhbHVlKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtZS5pc1N0b3JlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlc29sdmVTdG9yZShjb21wb25lbnQsIGtleSwgdmFsdWUuc3Vic3RyaW5nKDcpKSAvLyByZW1vdmUgdGhlIFwic3RvcmVzLlwiIGF0IHRoZSBzdGFydFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1trZXldID0gbWUuY2FsbEZvcm1hdHRlcih2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29tcG9uZW50LnNldChjb25maWcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBiaW5kaW5ncyBmb3IgYSBnaXZlbiBjb21wb25lbnQgaWQgaW5zaWRlIHRoaXMgc3RhdGVQcm92aWRlciBhcyB3ZWxsIGFzIGluc2lkZSBhbGwgcGFyZW50IHN0YXRlUHJvdmlkZXJzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqL1xuICAgIHJlbW92ZUJpbmRpbmdzKGNvbXBvbmVudElkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWUuYmluZGluZ3MpLmZvckVhY2goKFtkYXRhUHJvcGVydHksIGJpbmRpbmddKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgYmluZGluZ1tjb21wb25lbnRJZF1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZ2V0UGFyZW50KCk/LnJlbW92ZUJpbmRpbmdzKGNvbXBvbmVudElkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgdGhlIGZvcm11bGFzIGluaXRpYWxseSBhbmQgdXBkYXRlLCB3aGVuIGRhdGEgY2hhbmdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgZGF0YSBmcm9tIGV2ZW50IG9yIG51bGwgb24gaW5pdGlhbCBjYWxsXG4gICAgICovXG4gICAgcmVzb2x2ZUZvcm11bGFzKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Zvcm11bGFzfSA9IG1lLFxuICAgICAgICAgICAgaW5pdGlhbFJ1biA9ICFkYXRhLFxuICAgICAgICAgICAgYWZmZWN0Rm9ybXVsYSwgYmluZE9iamVjdCwgZm4sIGtleSwgcmVzdWx0LCB2YWx1ZTtcblxuICAgICAgICBpZiAoZm9ybXVsYXMpIHtcbiAgICAgICAgICAgIGlmICghaW5pdGlhbFJ1biAmJiAoIWRhdGEua2V5IHx8ICFkYXRhLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW1N0YXRlUHJvdmlkZXI6Zm9ybXVsYXNdIG1pc3Npbmcga2V5IG9yIHZhbHVlJywgZGF0YS5rZXksIGRhdGEudmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZvcm11bGFzKSkge1xuICAgICAgICAgICAgICAgIGFmZmVjdEZvcm11bGEgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNoYW5nZSBhZmZlY3RzIGEgZm9ybXVsYVxuICAgICAgICAgICAgICAgIGlmICghaW5pdGlhbFJ1bikge1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RGb3JtdWxhID0gT2JqZWN0LnZhbHVlcyh2YWx1ZS5iaW5kKS5pbmNsdWRlcyhkYXRhLmtleSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWZmZWN0Rm9ybXVsYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgQmluZC1PYmplY3QgYW5kIGZpbGwgd2l0aCBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGJpbmRPYmplY3QgPSBOZW8uY2xvbmUodmFsdWUuYmluZCk7XG4gICAgICAgICAgICAgICAgICAgIGZuICAgICAgICAgPSB2YWx1ZS5nZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYmluZE9iamVjdCkuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZE9iamVjdFtrZXldID0gbWUuZ2V0RGF0YShiaW5kT2JqZWN0W2tleV0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGMgdGhlIGZvcm11bGFcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4oYmluZE9iamVjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIGlmIG5vIGVycm9yIG9yIG51bGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNldERhdGEoa2V5LCBudWxsKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0RGF0YShrZXksIHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnTmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZU5hbWVcbiAgICAgKi9cbiAgICByZXNvbHZlU3RvcmUoY29tcG9uZW50LCBjb25maWdOYW1lLCBzdG9yZU5hbWUpIHtcbiAgICAgICAgbGV0IHN0b3JlID0gdGhpcy5nZXRTdG9yZShzdG9yZU5hbWUpO1xuXG4gICAgICAgIGlmIChjb21wb25lbnRbY29uZmlnTmFtZV0gIT09IHN0b3JlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRbY29uZmlnTmFtZV0gPSBzdG9yZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB3aWxsIGFzc2lnbiBhbGwgdmFsdWVzIHRvIHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgd2hlcmUgaXQgZmluZHMgYW4gZXhpc3Rpbmcga2V5LlxuICAgICAqIEluIGNhc2Ugbm8gbWF0Y2ggaXMgZm91bmQgaW5zaWRlIHRoZSBwYXJlbnQgY2hhaW4sIGEgbmV3IGRhdGEgcHJvcGVydHkgd2lsbCBnZXQgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldERhdGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmludGVybmFsU2V0RGF0YShrZXksIHZhbHVlLCB0aGlzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIHNldERhdGEoKSBpbiBjYXNlIHlvdSB3YW50IHRvIGVuZm9yY2VcbiAgICAgKiBzZXR0aW5nIGFsbCBrZXlzIG9uIHRoaXMgaW5zdGFuY2UgaW5zdGVhZCBvZiBsb29raW5nIGZvciBtYXRjaGVzIGluc2lkZSBwYXJlbnQgc3RhdGVQcm92aWRlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc2V0RGF0YUF0U2FtZUxldmVsKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFByb3ZpZGVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==