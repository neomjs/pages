"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_state_Provider_mjs"],{

/***/ "./src/core/Effect.mjs"
/*!*****************************!*\
  !*** ./src/core/Effect.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IdGenerator.mjs */ "./src/core/IdGenerator.mjs");




/**
 * Creates a reactive effect that automatically tracks its dependencies and re-runs when any of them change.
 * This is a lightweight, plain JavaScript class for performance.
 * It serves as a core reactive primitive, enabling automatic and dynamic dependency tracking.
 * @class Neo.core.Effect
 */
class Effect {
    /**
     * The optional component id this effect belongs to.
     * @member {String|null} componentId=null
     */
    componentId = null
    /**
     * A Map containing Config instances as keys and their cleanup functions as values.
     * @member {Map} dependencies=new Map()
     * @protected
     */
    dependencies = new Map()
    /**
     * The function to execute.
     * @member {Function|null} _fn=null
     */
    _fn = null
    /**
     * The unique identifier for this effect instance.
     * @member {String|null}
     */
    id = _IdGenerator_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getId('effect')
    /**
     * @member {Boolean}
     * @protected
     */
    isDestroyed = false
    /**
     * @member {Neo.core.Config}
     * @protected
     */
    isRunning = null

    /**
     * @member fn
     */
    get fn() {
        return this._fn
    }
    set fn(value) {
        this._fn = value;
        // Assigning a new function to `fn` automatically triggers a re-run.
        // This ensures that the effect immediately re-evaluates its dependencies
        // based on the new function's logic, clearing old dependencies and establishing new ones.
        this.run()
    }

    /**
     * @param {Function|Object}  fn              - The function to execute, or a config object for the effect.
     * @param {Function}        [fn.fn]          - The function to execute for the effect (if the first argument is an object).
     * @param {String}          [fn.componentId] - The component id this effect belongs to.
     * @param {Boolean}         [fn.lazy=false]  - If true, the effect will not run immediately upon creation.
     * @param {Object|Object[]} [fn.subscriber]  - A single subscriber or an array of subscribers for the isRunning config.
     * @param {Object}          [options={}]     - Optional. Used if the first argument is a function, this object contains the options.
     * @example
     * // Signature 1: Function and Options
     * const myEffect = new Effect(() => console.log('Run'), {lazy: true});
     * @example
     * // Signature 2: Single Config Object
     * const myEffect = new Effect({fn: () => console.log('Run'), lazy: true});
     */
    constructor(fn, options={}) {
        const me = this;

        const {
              fn: effectFn,
              componentId,
              lazy = false,
              subscriber
        } = (typeof fn === 'function') ? { ...options, fn } : (fn || {});

        if (componentId) {
            me.componentId = componentId
        }

        me.isRunning = new _Config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](false);

        if (subscriber) {
            [].concat(subscriber).forEach(sub => me.isRunning.subscribe(sub))
        }

        if (lazy) {
            me._fn = effectFn
        } else {
            me.fn = effectFn
        }
    }

    /**
     * Cleans up all subscriptions and destroys the effect.
     */
    destroy() {
        const me = this;

        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        me.isDestroyed = true
    }

    /**
     * Executes the effect function, re-evaluating its dependencies.
     * If the EffectManager is paused (e.g., inside a batch), it queues itself to be run later.
     * @protected
     */
    run() {
        const me = this;

        if (me.isDestroyed) {
            return
        }

        // Check if already running without creating a dependency on `isRunning`.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        const isRunning = me.isRunning.get();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        if (isRunning) {
            return
        }

        // If the manager is globally paused for batching, queue this effect and stop.
        if (_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isPaused()) {
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].queue(me);
            return
        }

        // Set `isRunning` to true without creating a dependency.
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
        me.isRunning.set(true);
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking();

        // Clear old dependencies and set this as the active effect.
        me.dependencies.forEach(cleanup => cleanup());
        me.dependencies.clear();
        _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].push(me);

        try {
            // Execute the function, which will collect new dependencies.
            me.fn()
        } finally {
            // Clean up after the run.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pop();

            // Set `isRunning` to false without creating a dependency.
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].pauseTracking();
            me.isRunning.set(false);
            _EffectManager_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resumeTracking()
        }
    }

    /**
     * Adds a `Neo.core.Config` instance as a dependency for this effect.
     * @param {Neo.core.Config} config The config instance to subscribe to.
     * @protected
     */
    addDependency(config) {
        const me = this;

        if (!me.dependencies.has(config)) {
            const cleanup = config.subscribe({
                id: me.id,
                fn: me.run.bind(me)
            });

            me.dependencies.set(config, cleanup)
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.gatekeep(Effect, 'Neo.core.Effect', () => {
    /**
     * Factory shortcut to create a new Neo.core.Effect instance.
     * @function Neo.effect
     * @param {Function|Object} fn - The function to execute, or a config object for the effect.
     * @param {Object} [options] - Optional. Used if the first argument is a function.
     * @returns {Neo.core.Effect}
     */
    Neo.effect = (fn, options) => new Effect(fn, options)
}));


/***/ },

/***/ "./src/state/Provider.mjs"
/*!********************************!*\
  !*** ./src/state/Provider.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Config.mjs */ "./src/core/Config.mjs");
/* harmony import */ var _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Effect.mjs */ "./src/core/Effect.mjs");
/* harmony import */ var _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/EffectManager.mjs */ "./src/core/EffectManager.mjs");
/* harmony import */ var _core_Observable_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Observable.mjs */ "./src/core/Observable.mjs");
/* harmony import */ var _createHierarchicalDataProxy_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createHierarchicalDataProxy.mjs */ "./src/state/createHierarchicalDataProxy.mjs");
/* harmony import */ var _core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/ConfigSymbols.mjs */ "./src/core/ConfigSymbols.mjs");









const twoWayBindingSymbol = Symbol.for('twoWayBinding');

/**
 * An optional component state provider for adding bindings to configs
 * @class Neo.state.Provider
 * @extends Neo.core.Base
 * @mixes Neo.core.Observable
 */
class Provider extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * True automatically applies the core.Observable mixin
     * @member {Boolean} observable=true
     * @static
     */
    static observable = true

    static config = {
        /**
         * @member {String} className='Neo.state.Provider'
         * @protected
         */
        className: 'Neo.state.Provider',
        /**
         * @member {String} ntype='state-provider'
         * @protected
         */
        ntype: 'state-provider',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         /**
         * The core data object managed by this StateProvider.
         * This object holds the reactive state that can be accessed and modified
         * by components and formulas within the provider's hierarchy.
         * Changes to properties within this data object will trigger reactivity.
         * When new data is assigned, it will be deeply merged with existing data.
         * @member {Object|null} data_=null
         * @example
         *     data: {
         *         user: {
         *             firstName: 'John',
         *             lastName : 'Doe'
         *         },
         *         settings: {
         *             theme: 'dark'
         *         }
         *     }
         * @reactive
         */
        data_: {
            [_core_ConfigSymbols_mjs__WEBPACK_IMPORTED_MODULE_7__.isDescriptor]: true,
            merge         : 'deep',
            value         : {}
        },
        /**
         * Defines computed properties based on other data properties within the StateProvider hierarchy.
         * Each formula is a function that receives a `data` argument, which is a hierarchical proxy
         * allowing access to data from the current provider and all its parent providers.
         * Changes to dependencies (accessed via `data.propertyName`) will automatically re-run the formula.
         * @member {Object|null} formulas_=null
         * @example
         *     data: {
         *         a    : 1,
         *         b    : 2,
         *         total: 50
         *     }
         *     formulas: {
         *         aPlusB : (data) => data.a + data.b,
         *         aTimesB: (data) => data.a * data.b,
         *         // Accessing parent data (assuming a parent provider has a 'taxRate' property)
         *         totalWithTax: (data) => data.total * (1 + data.taxRate)
         *     }
         * @reactive
         */
        formulas_: null,
        /**
         * @member {Neo.state.Provider|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         /**
         * A collection of Neo.data.Store instances managed by this StateProvider.
         * Stores are defined as config objects with a `module` property pointing
         * to the store class, which will then be instantiated by the framework.
         * @member {Object|null} stores_=null
         * @example
         *     stores: {
         *         myUsers: {
         *             module: Neo.data.Store,
         *             model : 'MyApp.model.User',
         *             data  : [{id: 1, name: 'John'}, {id: 2, name: 'Doe'}]
         *         },
         *         myCustomStore1: MyCustomStoreClass,
         *         myCustomStore2: {
         *             module  : MyCustomStoreClass,
         *             autoLoad: true
         *         }
         *     }
         * @reactive
         */
        stores_: null,
        /**
         * @member {String|null} windowId=null
         */
        windowId: null
    }

    /**
     * @member {Map} #bindingEffects=new Map()
     * @private
     */
    #bindingEffects = new Map()
    /**
     * @member {Object} #dataConfigs={}
     * @private
     */
    #dataConfigs = {}
    /**
     * @member {Map} #formulaEffects=new Map()
     * @private
     */
    #formulaEffects = new Map()

    /**
     * @param {Object} config
     */
    construct(config) {
        Neo.isUsingStateProviders = true;
        super.construct(config)
    }

    /**
     * @param {*} value
     * @returns {*}
     * @protected
     */
    adjustValue(value) {
        if (value instanceof Date) {
            return new Date(value.valueOf())
        }

        return value
    }

    /**
     * Triggered after the data config got changed.
     * This method initializes the internal #dataConfigs map, converting each
     * plain data property into a reactive Neo.core.Config instance.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @protected
     */
    afterSetData(value, oldValue) {
        value && this.processDataObject(value)
    }

    /**
     * Triggered after the formulas config got changed.
     * This method sets up reactive effects for each defined formula.
     * Each formula function receives the hierarchical data proxy, allowing implicit dependency tracking.
     * @param {Object|null} value The new formulas configuration.
     * @param {Object|null} oldValue The old formulas configuration.
     * @protected
     */
    afterSetFormulas(value, oldValue) {
        const me = this;

        // Destroy old formula effects to prevent memory leaks and stale calculations.
        me.#formulaEffects.forEach(effect => effect.destroy());
        me.#formulaEffects.clear();

        if (value) {
            Object.entries(value).forEach(([formulaKey, formulaFn]) => {
                // Create a new lazy Effect. It will not run until explicitly told to.
                const effect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"]({
                    fn: () => {
                        const
                            hierarchicalData = me.getHierarchyData(),
                            result           = formulaFn(hierarchicalData);

                        me.setData(formulaKey, result);
                    },
                    lazy: true
                });

                me.#formulaEffects.set(formulaKey, effect)
            })
        }
    }

    /**
     * Triggered when accessing the data config
     * @param {Object} value
     * @protected
     */
    beforeGetData(value) {
        return this.getHierarchyData()
    }

    /**
     * Triggered before the stores config gets changed.
     * @param {Object|null} value
     * @param {Object|null} oldValue
     * @returns {Object|null}
     * @protected
     */
    beforeSetStores(value, oldValue) {
        if (value) {
            let me = this;

            Object.entries(value).forEach(([key, storeValue]) => {
                // support mapping string based listeners into the stateProvider instance
                Object.entries(storeValue.listeners || {}).forEach(([listenerKey, listener]) => {
                    me.bindCallback(listener, listenerKey, me, storeValue.listeners)
                })

                value[key] = _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(storeValue)
            })
        }

        return value
    }

    /**
     * Creates a new binding for a component's config to a data property.
     * This now uses the Effect-based reactivity system.
     * @param {String} componentId
     * @param {String} configKey The component config to bind (e.g., 'text').
     * @param {String|Function} formatter The function that computes the value.
     */
    createBinding(componentId, configKey, formatter) {
        const
            me     = this,
            effect = new _core_Effect_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](() => {
                const component = Neo.get(componentId);

                if (component && !component.isDestroyed) {
                    const
                        hierarchicalData = me.getHierarchyData(),
                        newValue         = Neo.isFunction(formatter) ? formatter.call(me, hierarchicalData) : hierarchicalData[formatter];

                    component._skipTwoWayPush = configKey;
                    component[configKey] = newValue;
                    delete component._skipTwoWayPush
                }
            });

        me.#bindingEffects.set(componentId, effect);

        // The effect observes the component's destruction to clean itself up.
        me.observeConfig(componentId, 'isDestroying', (value) => {
            if (value) {
                effect.destroy();
                me.#bindingEffects.delete(componentId)
            }
        });

        // The effect is returned to be managed by the component.
        return effect
    }

    /**
     * Processes a component's `bind` configuration to create reactive bindings.
     * It differentiates between store bindings and data bindings, and sets up two-way binding if specified.
     * @param {Neo.component.Base} component The component instance whose bindings are to be created.
     */
    createBindings(component) {
        let me               = this,
            hasTwoWayBinding = false;

        Object.entries(component.bind || {}).forEach(([configKey, value]) => {
            let key = value;

            // If the binding value is an object, it might contain `twoWay` or a specific `key`.
            if (Neo.isObject(value)) {
                if (value.twoWay) {
                    hasTwoWayBinding = true
                }
                key = value.key
            }

            // Determine if it's a store binding or a data binding.
            if (me.isStoreValue(key)) {
                // For store bindings, resolve the store and assign it to the component config.
                me.resolveStore(component, configKey, key.substring(7)) // remove the "stores." prefix
            } else {
                // For data bindings, create an Effect to keep the component config in sync with the data.
                me.createBinding(component.id, configKey, key, value.twoWay)
            }
        });

        // Mark the component if it has any two-way bindings, for internal tracking.
        if (hasTwoWayBinding) {
            component[twoWayBindingSymbol] = true
        }
    }

    /**
     * Destroys the state provider and cleans up all associated effects.
     */
    destroy() {
        const me = this;

        me.#formulaEffects.forEach(effect => effect.destroy());
        me.#formulaEffects.clear();

        me.#bindingEffects.forEach(effect => effect.destroy());
        me.#bindingEffects.clear();

        super.destroy()
    }

    /**
     * Convenience shortcut
     * @param {String} [ntype]
     * @returns {Neo.controller.Component|null}
     */
    getController(ntype) {
        return this.component.getController(ntype)
    }

    /**
     * Access the closest data property inside the parent chain.
     * @param {String} key
     * @returns {*} value
     */
    getData(key) {
        const ownerDetails = this.getOwnerOfDataProperty(key);

        if (ownerDetails) {
            return ownerDetails.owner.getDataConfig(ownerDetails.propertyName).get()
        }
    }

    /**
     * Retrieves the underlying core.Config instance for a given data property path.
     * @param {String} path The full path of the data property (e.g., 'user.firstname').
     * @returns {Neo.core.Config|null}
     */
    getDataConfig(path) {
        return this.#dataConfigs[path] || null
    }

    /**
     * Returns the merged, hierarchical data object as a reactive Proxy.
     * @returns {Proxy}
     */
    getHierarchyData() {
        return (0,_createHierarchicalDataProxy_mjs__WEBPACK_IMPORTED_MODULE_6__.createHierarchicalDataProxy)(this)
    }

    /**
     * Finds the state.Provider instance that owns a specific data property.
     * @param {String} path The full path of the data property.
     * @returns {{owner: Neo.state.Provider, propertyName: String}|null}
     */
    getOwnerOfDataProperty(path) {
        let me = this;

        if (me.#dataConfigs[path]) {
            return {owner: me, propertyName: path}
        }

        // Check for parent ownership
        const parent = me.getParent();
        if (parent) {
            return parent.getOwnerOfDataProperty(path)
        }

        return null
    }

    /**
     * Get the closest stateProvider inside the components parent tree
     * @returns {Neo.state.Provider|null}
     */
    getParent() {
        let me = this;

        // Access the internal value of the parent_ config directly.
        // This avoids recursive calls to the getter.
        if (me._parent) {
            return me._parent
        }

        // If no explicit parent is set, try to find it dynamically via the component.
        // Ensure this.component exists before trying to access its parent.
        if (me.component) {
            return me.component.parent?.getStateProvider() || null
        }

        // No explicit parent and no component to derive it from.
        return null
    }

    /**
     * Access the closest store inside the VM parent chain.
     * @param {String} key
     * @param {Neo.state.Provider} originStateProvider=this for internal usage only
     * @returns {Neo.data.Store}
     */
    getStore(key, originStateProvider=this) {
        let me       = this,
            {stores} = me,
            parentStateProvider;

        if (stores?.hasOwnProperty(key)) {
            return stores[key]
        }

        parentStateProvider = me.getParent();

        if (!parentStateProvider) {
            console.error(`store '${key}' not found inside this stateProvider or parents.`, originStateProvider)
        }

        return parentStateProvider.getStore(key, originStateProvider)
    }

    /**
     * Checks if any data property in the hierarchy starts with the given path.
     * This is used by the HierarchicalDataProxy to determine if it should return a nested proxy.
     * @param {String} path The path to check (e.g., 'user').
     * @returns {Boolean}
     */
    hasNestedDataStartingWith(path) {
        const pathWithDot = `${path}.`;

        if (Object.keys(this.#dataConfigs).some(key => key.startsWith(pathWithDot))) {
            return true
        }

        return this.getParent()?.hasNestedDataStartingWith(path) || false
    }

    /**
     * Returns the top-level data keys for a given path within this provider's data.
     * @param {String} path The path to get keys for (e.g., 'user.address').
     * @returns {String[]}
     */
    getTopLevelDataKeys(path) {
        const
            keys       = new Set(),
            pathPrefix = path ? `${path}.` : '';

        for (const fullPath in this.#dataConfigs) {
            if (fullPath.startsWith(pathPrefix)) {
                const
                    relativePath = fullPath.substring(pathPrefix.length),
                    topLevelKey  = relativePath.split('.')[0];

                if (topLevelKey) {
                    keys.add(topLevelKey)
                }
            }
        }

        return Array.from(keys)
    }

    /**
     * This is the core method for setting data, providing a single entry point for all data modifications.
     * It handles multiple scenarios:
     * 1.  **Object-based updates:** If `key` is an object, it recursively calls itself for each key-value pair.
     * 2.  **Data Records:** If `value` is a `Neo.data.Record`, it is treated as an atomic value and set directly.
     * 3.  **Bubbling Reactivity:** For a given key (e.g., 'user.name'), it sets the leaf value and then "bubbles up"
     *     the change, creating new parent objects (e.g., 'user') to ensure that effects depending on any part
     *     of the path are triggered.
     *
     * All updates are batched by the public `setData` methods to ensure effects run only once.
     * Use `setData()` or `setDataAtSameLevel()` instead of calling this method directly.
     *
     * @param {Object|String} key The property to set, or an object of key-value pairs.
     * @param {*} value The new value.
     * @param {Neo.state.Provider} [originStateProvider] The provider to start the search from for hierarchical updates.
     * @protected
     */
    internalSetData(key, value, originStateProvider) {
        const me = this;

        if (Neo.isObject(key)) {
            Object.entries(key).forEach(([dataKey, dataValue]) => {
                me.internalSetData(dataKey, dataValue, originStateProvider)
            });
            return
        }

        // Now 'key' is a string path.
        // If 'value' is a plain object, we need to drill down further.
        // If the value is a Neo.data.Record, treat it as an atomic value => it will not enter this block.
        if (Neo.typeOf(value) === 'Object') {
            Object.entries(value).forEach(([nestedKey, nestedValue]) => {
                const fullPath = `${key}.${nestedKey}`;
                me.internalSetData(fullPath, nestedValue, originStateProvider);
            });
            return // We've delegated the setting to deeper paths.
        }

        const
            ownerDetails   = me.getOwnerOfDataProperty(key),
            targetProvider = ownerDetails ? ownerDetails.owner : (originStateProvider || me);

        me.#setConfigValue(targetProvider, key, value, null);

        // This is the "reactivity bubbling" logic. When a leaf property like 'user.name' changes,
        // we must also trigger effects that depend on the parent object 'user'. We do this by
        // creating a new object reference for each parent in the path. The spread syntax
        // `{ ...oldParentValue, [leafKey]: latestValue }` is key, as it creates a new
        // object, which the reactivity system detects as a change.
        let path        = key,
            latestValue = value;

        while (path.includes('.')) {
            const leafKey = path.split('.').pop();
            path = path.substring(0, path.lastIndexOf('.'));

            const parentConfig = targetProvider.getDataConfig(path);

            if (parentConfig) {
                const oldParentValue = parentConfig.get();
                if (Neo.isObject(oldParentValue)) {
                    const newParentValue = { ...oldParentValue, [leafKey]: latestValue };
                    parentConfig.set(newParentValue);
                    latestValue = newParentValue;
                } else {
                    break // Stop if parent is not an object
                }
            } else {
                // If the parent config doesn't exist, we need to create it to support bubbling.
                // This is crucial for creating new nested data structures at runtime.
                const newParentValue = {[leafKey]: latestValue};
                me.#setConfigValue(targetProvider, path, newParentValue);
                latestValue = newParentValue
            }
        }
    }

    /**
     * Internal convenience method to check if a binding value is supposed to match a store
     * @param {String} value
     * @returns {Boolean}
     */
    isStoreValue(value) {
        return Neo.isString(value) && value.startsWith('stores.')
    }

    /**
     * Gets called after all constructors & configs are applied.
     * @protected
     */
    onConstructed() {
        super.onConstructed();

        // After the provider is fully constructed and initial data is set,
        // run the formula effects for the first time to compute their initial values.
        this.#formulaEffects.forEach(effect => effect.run())
    }

    /**
     * @param {String} key
     * @param {*} value
     * @param {*} oldValue
     */
    onDataPropertyChange(key, value, oldValue) {
        // Can be overridden by subclasses
    }

    /**
     * Recursively processes a data object, creating or updating Neo.core.Config instances
     * for each property and storing them in the #dataConfigs map.
     * @param {Object} obj The data object to process.
     * @param {String} [path=''] The current path prefix for nested objects.
     * @protected
     */
    processDataObject(obj, path = '') {
        let me = this;

        Object.entries(obj).forEach(([key, value]) => {
            const fullPath = path ? `${path}.${key}` : key;

            value = me.adjustValue(value);

            // Ensure a Config instance exists for the current fullPath
            if (me.#dataConfigs[fullPath]) {
                me.#dataConfigs[fullPath].set(value)
            } else {
                me.#dataConfigs[fullPath] = new _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](value)
            }

            // If the value is a plain object, recursively process its properties
            if (Neo.typeOf(value) === 'Object') {
                me.processDataObject(value, fullPath)
            }
        });
    }

    /**
     * @param {Neo.component.Base} component
     * @param {String}             configName
     * @param {String}             storeName
     */
    resolveStore(component, configName, storeName) {
        let store = this.getStore(storeName);

        if (component[configName] !== store) {
            component[configName] = store
        }
    }

    /**
     * Helper function to set a config value and trigger reactivity.
     * This method creates a new Config instance if one doesn't exist for the given path,
     * or updates an existing one. It also triggers binding effects and calls onDataPropertyChange.
     * @param {Neo.state.Provider} provider The StateProvider instance owning the config.
     * @param {String}             path     The full path of the data property (e.g., 'user.firstname').
     * @param {*}                  newValue The new value to set.
     * @param {*}                 [oldVal]  The old value (optional, used for initial setup).
     * @private
     */
    #setConfigValue(provider, path, newValue, oldVal) {
        newValue = provider.adjustValue(newValue);

        let currentConfig = provider.getDataConfig(path),
            hasChange     = true,
            oldValue      = oldVal;

        if (currentConfig) {
            oldValue  = currentConfig.get();
            hasChange = currentConfig.set(newValue)
        } else {
            currentConfig = new _core_Config_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](newValue);
            provider.#dataConfigs[path] = currentConfig;
            // Trigger all binding effects to re-evaluate their dependencies
            provider.#bindingEffects.forEach(effect => effect.run())
        }

        if (hasChange) {
            // Notify subscribers of the data property change.
            provider.onDataPropertyChange(path, newValue, oldValue)
        }
    }

    /**
     * The method will assign all values to the closest stateProvider where it finds an existing key.
     * In case no match is found inside the parent chain, a new data property will get generated.
     *
     * All updates within a single call are batched to ensure that reactive effects (bindings and formulas)
     * are run only once.
     *
     * @param {Object|String} key
     * @param {*}             value
     */
    setData(key, value) {
        _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].pause();
        try {
            this.internalSetData(key, value, this)
        } finally {
            _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].resume()
        }
    }

    /**
     * Use this method instead of setData() in case you want to enforce
     * setting all keys on this instance instead of looking for matches inside parent stateProviders.
     *
     * All updates within a single call are batched to ensure that reactive effects (bindings and formulas)
     * are run only once.
     *
     * @param {Object|String} key
     * @param {*}             value
     */
    setDataAtSameLevel(key, value) {
        _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].pause();
        try {
            this.internalSetData(key, value)
        } finally {
            _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].resume()
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Provider));


/***/ },

/***/ "./src/state/createHierarchicalDataProxy.mjs"
/*!***************************************************!*\
  !*** ./src/state/createHierarchicalDataProxy.mjs ***!
  \***************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createHierarchicalDataProxy: () => (/* binding */ createHierarchicalDataProxy)
/* harmony export */ });
/* harmony import */ var _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EffectManager.mjs */ "./src/core/EffectManager.mjs");


/**
 * Creates a nested Proxy that represents a level in the hierarchical data structure.
 * @param {Neo.state.Provider} rootProvider The top-level provider to start searches from.
 * @param {String} path The current path of this proxy level (e.g., 'user' for data.user).
 * @returns {Proxy|null}
 * @private
 */
function createNestedProxy(rootProvider, path) {
    // The target object for the proxy can be empty because all lookups are dynamic.
    const target = {};

    return new Proxy(target, {
        /**
         * The get trap for the proxy. This is where the magic happens.
         * @param {Object} currentTarget The proxy's target object.
         * @param {String|Symbol} property The name of the property being accessed.
         * @returns {*} The value of the property or a new proxy for nested access.
         */
        get(currentTarget, property) {
            // Handle internal properties that might be set directly on the proxy's target
            // or are expected by the environment (like Siesta's __REFADR__).
            if (typeof property === 'symbol' || property === '__REFADR__' || property === 'inspect' || property === 'then') {
                return Reflect.get(currentTarget, property)
            }

            // Only allow string or number properties to proceed as data paths.
            if (typeof property !== 'string' && typeof property !== 'number') {
                return undefined; // For other non-string/non-number properties, return undefined.
            }

            // Special handling for the 'stores' property at the root level
            if (path === '' && property === 'stores') {
                return new Proxy({}, {
                    get(target, storeName) {
                        if (typeof storeName === 'symbol' || storeName === '__REFADR__') {
                            return Reflect.get(target, storeName)
                        }
                        // Delegate to the StateProvider's getStore method for hierarchical resolution
                        // Accessing store.count later will register the dependency via the Config system
                        return rootProvider.getStore(storeName)
                    }
                })
            }

            const fullPath = path ? `${path}.${property}` : property;

            // 1. Check if the full path corresponds to an actual data property.
            const ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);

            if (ownerDetails) {
                const
                    {owner, propertyName} = ownerDetails,
                    config                = owner.getDataConfig(propertyName);

                if (config) {
                    _core_EffectManager_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getActiveEffect()?.addDependency(config);

                    const value = config.get();
                    // If the value is an object, return a new proxy for it to ensure nested accesses are also proxied.
                    if (Neo.isObject(value)) {
                        return createNestedProxy(rootProvider, fullPath)
                    }

                    return value
                }
            }

            // 2. If not a direct match, it might be a parent object of a nested property
            //    (e.g., accessing `user` when a `user.firstname` binding exists).
            //    In this case, we return another proxy for the next level down.
            if (rootProvider.hasNestedDataStartingWith(fullPath)) {
                return createNestedProxy(rootProvider, fullPath)
            }

            // 3. If it's neither a data property nor a path to one, it doesn't exist.
            //    Returning undefined ensures that chained accesses (e.g., data.nonexistent.property) fail gracefully.
        },

        set(currentTarget, property, value) {
            // Allow internal properties (like Symbols or specific strings) to be set directly on the target.
            if (typeof property === 'symbol' || property === '__REFADR__') {
                return Reflect.set(currentTarget, property, value)
            }

            const
                fullPath     = path ? `${path}.${property}` : property,
                ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);
            let targetProvider;

            if (ownerDetails) {
                targetProvider = ownerDetails.owner
            } else {
                // If no owner is found, set it on the rootProvider (the one that created this proxy)
                targetProvider = rootProvider
            }

            targetProvider.setData(fullPath, value);
            return true // Indicate that the assignment was successful
        },

        ownKeys(currentTarget) {
            return rootProvider.getTopLevelDataKeys(path)
        },

        getOwnPropertyDescriptor(currentTarget, property) {
            const
                fullPath     = path ? `${path}.${property}` : property,
                ownerDetails = rootProvider.getOwnerOfDataProperty(fullPath);

            if (ownerDetails) {
                const config = ownerDetails.owner.getDataConfig(ownerDetails.propertyName);

                if (config) {
                    const value = config.get();
                    return {
                        value       : Neo.isObject(value) ? createNestedProxy(rootProvider, fullPath) : value,
                        writable    : true,
                        enumerable  : true,
                        configurable: true
                    }
                }
            }
        }
    })
}

/**
 * Creates a Proxy object that represents the merged, hierarchical data from a `state.Provider` chain.
 * When a property is accessed through this proxy while an Effect is running, it automatically
 * tracks the underlying core.Config instance as a dependency.
 * @param {Neo.state.Provider} provider The starting state.Provider.
 * @returns {Proxy}
 */
function createHierarchicalDataProxy(provider) {
    return createNestedProxy(provider, '')
}


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY19zdGF0ZV9Qcm92aWRlcl9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNPO0FBQ0Y7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsU0FBUyx3REFBVztBQUNwQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQixXQUFXO0FBQzNDO0FBQ0E7QUFDQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUF5QztBQUM3RTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUMsaUJBQWlCLFdBQVc7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbURBQU07O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFB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QUFFQTtBQUNBLHlDQUF5QyxLQUFLLEdBQUcsU0FBUztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSyxHQUFHLFNBQVM7QUFDMUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb3JlL0VmZmVjdC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zdGF0ZS9Qcm92aWRlci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9zdGF0ZS9jcmVhdGVIaWVyYXJjaGljYWxEYXRhUHJveHkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb25maWcgICAgICAgIGZyb20gJy4vQ29uZmlnLm1qcyc7XG5pbXBvcnQgRWZmZWN0TWFuYWdlciBmcm9tICcuL0VmZmVjdE1hbmFnZXIubWpzJztcbmltcG9ydCBJZEdlbmVyYXRvciAgIGZyb20gJy4vSWRHZW5lcmF0b3IubWpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgYXV0b21hdGljYWxseSB0cmFja3MgaXRzIGRlcGVuZGVuY2llcyBhbmQgcmUtcnVucyB3aGVuIGFueSBvZiB0aGVtIGNoYW5nZS5cbiAqIFRoaXMgaXMgYSBsaWdodHdlaWdodCwgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcyBmb3IgcGVyZm9ybWFuY2UuXG4gKiBJdCBzZXJ2ZXMgYXMgYSBjb3JlIHJlYWN0aXZlIHByaW1pdGl2ZSwgZW5hYmxpbmcgYXV0b21hdGljIGFuZCBkeW5hbWljIGRlcGVuZGVuY3kgdHJhY2tpbmcuXG4gKiBAY2xhc3MgTmVvLmNvcmUuRWZmZWN0XG4gKi9cbmNsYXNzIEVmZmVjdCB7XG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbmFsIGNvbXBvbmVudCBpZCB0aGlzIGVmZmVjdCBiZWxvbmdzIHRvLlxuICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBjb21wb25lbnRJZD1udWxsXG4gICAgICovXG4gICAgY29tcG9uZW50SWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQSBNYXAgY29udGFpbmluZyBDb25maWcgaW5zdGFuY2VzIGFzIGtleXMgYW5kIHRoZWlyIGNsZWFudXAgZnVuY3Rpb25zIGFzIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyIHtNYXB9IGRlcGVuZGVuY2llcz1uZXcgTWFwKClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb258bnVsbH0gX2ZuPW51bGxcbiAgICAgKi9cbiAgICBfZm4gPSBudWxsXG4gICAgLyoqXG4gICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGVmZmVjdCBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBpZCA9IElkR2VuZXJhdG9yLmdldElkKCdlZmZlY3QnKVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzRGVzdHJveWVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtOZW8uY29yZS5Db25maWd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzUnVubmluZyA9IG51bGxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIgZm5cbiAgICAgKi9cbiAgICBnZXQgZm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mblxuICAgIH1cbiAgICBzZXQgZm4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZm4gPSB2YWx1ZTtcbiAgICAgICAgLy8gQXNzaWduaW5nIGEgbmV3IGZ1bmN0aW9uIHRvIGBmbmAgYXV0b21hdGljYWxseSB0cmlnZ2VycyBhIHJlLXJ1bi5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGVmZmVjdCBpbW1lZGlhdGVseSByZS1ldmFsdWF0ZXMgaXRzIGRlcGVuZGVuY2llc1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgbmV3IGZ1bmN0aW9uJ3MgbG9naWMsIGNsZWFyaW5nIG9sZCBkZXBlbmRlbmNpZXMgYW5kIGVzdGFibGlzaGluZyBuZXcgb25lcy5cbiAgICAgICAgdGhpcy5ydW4oKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSAgZm4gICAgICAgICAgICAgIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIG9yIGEgY29uZmlnIG9iamVjdCBmb3IgdGhlIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgICAgW2ZuLmZuXSAgICAgICAgICAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciB0aGUgZWZmZWN0IChpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0KS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgW2ZuLmNvbXBvbmVudElkXSAtIFRoZSBjb21wb25lbnQgaWQgdGhpcyBlZmZlY3QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW2ZuLmxhenk9ZmFsc2VdICAtIElmIHRydWUsIHRoZSBlZmZlY3Qgd2lsbCBub3QgcnVuIGltbWVkaWF0ZWx5IHVwb24gY3JlYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R8T2JqZWN0W119IFtmbi5zdWJzY3JpYmVyXSAgLSBBIHNpbmdsZSBzdWJzY3JpYmVyIG9yIGFuIGFycmF5IG9mIHN1YnNjcmliZXJzIGZvciB0aGUgaXNSdW5uaW5nIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnM9e31dICAgICAtIE9wdGlvbmFsLiBVc2VkIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCB0aGlzIG9iamVjdCBjb250YWlucyB0aGUgb3B0aW9ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNpZ25hdHVyZSAxOiBGdW5jdGlvbiBhbmQgT3B0aW9uc1xuICAgICAqIGNvbnN0IG15RWZmZWN0ID0gbmV3IEVmZmVjdCgoKSA9PiBjb25zb2xlLmxvZygnUnVuJyksIHtsYXp5OiB0cnVlfSk7XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTaWduYXR1cmUgMjogU2luZ2xlIENvbmZpZyBPYmplY3RcbiAgICAgKiBjb25zdCBteUVmZmVjdCA9IG5ldyBFZmZlY3Qoe2ZuOiAoKSA9PiBjb25zb2xlLmxvZygnUnVuJyksIGxhenk6IHRydWV9KTtcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihmbiwgb3B0aW9ucz17fSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBmbjogZWZmZWN0Rm4sXG4gICAgICAgICAgICAgIGNvbXBvbmVudElkLFxuICAgICAgICAgICAgICBsYXp5ID0gZmFsc2UsXG4gICAgICAgICAgICAgIHN1YnNjcmliZXJcbiAgICAgICAgfSA9ICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpID8geyAuLi5vcHRpb25zLCBmbiB9IDogKGZuIHx8IHt9KTtcblxuICAgICAgICBpZiAoY29tcG9uZW50SWQpIHtcbiAgICAgICAgICAgIG1lLmNvbXBvbmVudElkID0gY29tcG9uZW50SWRcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmlzUnVubmluZyA9IG5ldyBDb25maWcoZmFsc2UpO1xuXG4gICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBbXS5jb25jYXQoc3Vic2NyaWJlcikuZm9yRWFjaChzdWIgPT4gbWUuaXNSdW5uaW5nLnN1YnNjcmliZShzdWIpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhenkpIHtcbiAgICAgICAgICAgIG1lLl9mbiA9IGVmZmVjdEZuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5mbiA9IGVmZmVjdEZuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGRlc3Ryb3lzIHRoZSBlZmZlY3QuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIG1lLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBlZmZlY3QgZnVuY3Rpb24sIHJlLWV2YWx1YXRpbmcgaXRzIGRlcGVuZGVuY2llcy5cbiAgICAgKiBJZiB0aGUgRWZmZWN0TWFuYWdlciBpcyBwYXVzZWQgKGUuZy4sIGluc2lkZSBhIGJhdGNoKSwgaXQgcXVldWVzIGl0c2VsZiB0byBiZSBydW4gbGF0ZXIuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHJ1bm5pbmcgd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kgb24gYGlzUnVubmluZ2AuXG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2VUcmFja2luZygpO1xuICAgICAgICBjb25zdCBpc1J1bm5pbmcgPSBtZS5pc1J1bm5pbmcuZ2V0KCk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lVHJhY2tpbmcoKTtcblxuICAgICAgICBpZiAoaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBtYW5hZ2VyIGlzIGdsb2JhbGx5IHBhdXNlZCBmb3IgYmF0Y2hpbmcsIHF1ZXVlIHRoaXMgZWZmZWN0IGFuZCBzdG9wLlxuICAgICAgICBpZiAoRWZmZWN0TWFuYWdlci5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnF1ZXVlKG1lKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGBpc1J1bm5pbmdgIHRvIHRydWUgd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kuXG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2VUcmFja2luZygpO1xuICAgICAgICBtZS5pc1J1bm5pbmcuc2V0KHRydWUpO1xuICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZVRyYWNraW5nKCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgb2xkIGRlcGVuZGVuY2llcyBhbmQgc2V0IHRoaXMgYXMgdGhlIGFjdGl2ZSBlZmZlY3QuXG4gICAgICAgIG1lLmRlcGVuZGVuY2llcy5mb3JFYWNoKGNsZWFudXAgPT4gY2xlYW51cCgpKTtcbiAgICAgICAgbWUuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucHVzaChtZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGNvbGxlY3QgbmV3IGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgIG1lLmZuKClcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFmdGVyIHRoZSBydW4uXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnBvcCgpO1xuXG4gICAgICAgICAgICAvLyBTZXQgYGlzUnVubmluZ2AgdG8gZmFsc2Ugd2l0aG91dCBjcmVhdGluZyBhIGRlcGVuZGVuY3kuXG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICAgIG1lLmlzUnVubmluZy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgRWZmZWN0TWFuYWdlci5yZXN1bWVUcmFja2luZygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYE5lby5jb3JlLkNvbmZpZ2AgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5IGZvciB0aGlzIGVmZmVjdC5cbiAgICAgKiBAcGFyYW0ge05lby5jb3JlLkNvbmZpZ30gY29uZmlnIFRoZSBjb25maWcgaW5zdGFuY2UgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZGREZXBlbmRlbmN5KGNvbmZpZykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFtZS5kZXBlbmRlbmNpZXMuaGFzKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBjb25maWcuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBpZDogbWUuaWQsXG4gICAgICAgICAgICAgICAgZm46IG1lLnJ1bi5iaW5kKG1lKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmRlcGVuZGVuY2llcy5zZXQoY29uZmlnLCBjbGVhbnVwKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uZ2F0ZWtlZXAoRWZmZWN0LCAnTmVvLmNvcmUuRWZmZWN0JywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEZhY3Rvcnkgc2hvcnRjdXQgdG8gY3JlYXRlIGEgbmV3IE5lby5jb3JlLkVmZmVjdCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gTmVvLmVmZmVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBmbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlLCBvciBhIGNvbmZpZyBvYmplY3QgZm9yIHRoZSBlZmZlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsLiBVc2VkIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtOZW8uY29yZS5FZmZlY3R9XG4gICAgICovXG4gICAgTmVvLmVmZmVjdCA9IChmbiwgb3B0aW9ucykgPT4gbmV3IEVmZmVjdChmbiwgb3B0aW9ucylcbn0pO1xuIiwiaW1wb3J0IEJhc2UgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuaW1wb3J0IENsYXNzU3lzdGVtVXRpbCAgICAgICAgICAgICAgIGZyb20gJy4uL3V0aWwvQ2xhc3NTeXN0ZW0ubWpzJztcbmltcG9ydCBDb25maWcgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0NvbmZpZy5tanMnO1xuaW1wb3J0IEVmZmVjdCAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4uL2NvcmUvRWZmZWN0Lm1qcyc7XG5pbXBvcnQgRWZmZWN0TWFuYWdlciAgICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9FZmZlY3RNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9PYnNlcnZhYmxlLm1qcyc7XG5pbXBvcnQge2NyZWF0ZUhpZXJhcmNoaWNhbERhdGFQcm94eX0gZnJvbSAnLi9jcmVhdGVIaWVyYXJjaGljYWxEYXRhUHJveHkubWpzJztcbmltcG9ydCB7aXNEZXNjcmlwdG9yfSAgICAgICAgICAgICAgICBmcm9tICcuLi9jb3JlL0NvbmZpZ1N5bWJvbHMubWpzJztcblxuY29uc3QgdHdvV2F5QmluZGluZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ3R3b1dheUJpbmRpbmcnKTtcblxuLyoqXG4gKiBBbiBvcHRpb25hbCBjb21wb25lbnQgc3RhdGUgcHJvdmlkZXIgZm9yIGFkZGluZyBiaW5kaW5ncyB0byBjb25maWdzXG4gKiBAY2xhc3MgTmVvLnN0YXRlLlByb3ZpZGVyXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKiBAbWl4ZXMgTmVvLmNvcmUuT2JzZXJ2YWJsZVxuICovXG5jbGFzcyBQcm92aWRlciBleHRlbmRzIEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRydWUgYXV0b21hdGljYWxseSBhcHBsaWVzIHRoZSBjb3JlLk9ic2VydmFibGUgbWl4aW5cbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIG9ic2VydmFibGUgPSB0cnVlXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5zdGF0ZS5Qcm92aWRlcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnN0YXRlLlByb3ZpZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3N0YXRlLXByb3ZpZGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3N0YXRlLXByb3ZpZGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb3JlIGRhdGEgb2JqZWN0IG1hbmFnZWQgYnkgdGhpcyBTdGF0ZVByb3ZpZGVyLlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBob2xkcyB0aGUgcmVhY3RpdmUgc3RhdGUgdGhhdCBjYW4gYmUgYWNjZXNzZWQgYW5kIG1vZGlmaWVkXG4gICAgICAgICAqIGJ5IGNvbXBvbmVudHMgYW5kIGZvcm11bGFzIHdpdGhpbiB0aGUgcHJvdmlkZXIncyBoaWVyYXJjaHkuXG4gICAgICAgICAqIENoYW5nZXMgdG8gcHJvcGVydGllcyB3aXRoaW4gdGhpcyBkYXRhIG9iamVjdCB3aWxsIHRyaWdnZXIgcmVhY3Rpdml0eS5cbiAgICAgICAgICogV2hlbiBuZXcgZGF0YSBpcyBhc3NpZ25lZCwgaXQgd2lsbCBiZSBkZWVwbHkgbWVyZ2VkIHdpdGggZXhpc3RpbmcgZGF0YS5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRhdGFfPW51bGxcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogICAgIGRhdGE6IHtcbiAgICAgICAgICogICAgICAgICB1c2VyOiB7XG4gICAgICAgICAqICAgICAgICAgICAgIGZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICAgKiAgICAgICAgICAgICBsYXN0TmFtZSA6ICdEb2UnXG4gICAgICAgICAqICAgICAgICAgfSxcbiAgICAgICAgICogICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgKiAgICAgICAgICAgICB0aGVtZTogJ2RhcmsnXG4gICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRhdGFfOiB7XG4gICAgICAgICAgICBbaXNEZXNjcmlwdG9yXTogdHJ1ZSxcbiAgICAgICAgICAgIG1lcmdlICAgICAgICAgOiAnZGVlcCcsXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgIDoge31cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgY29tcHV0ZWQgcHJvcGVydGllcyBiYXNlZCBvbiBvdGhlciBkYXRhIHByb3BlcnRpZXMgd2l0aGluIHRoZSBTdGF0ZVByb3ZpZGVyIGhpZXJhcmNoeS5cbiAgICAgICAgICogRWFjaCBmb3JtdWxhIGlzIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIGBkYXRhYCBhcmd1bWVudCwgd2hpY2ggaXMgYSBoaWVyYXJjaGljYWwgcHJveHlcbiAgICAgICAgICogYWxsb3dpbmcgYWNjZXNzIHRvIGRhdGEgZnJvbSB0aGUgY3VycmVudCBwcm92aWRlciBhbmQgYWxsIGl0cyBwYXJlbnQgcHJvdmlkZXJzLlxuICAgICAgICAgKiBDaGFuZ2VzIHRvIGRlcGVuZGVuY2llcyAoYWNjZXNzZWQgdmlhIGBkYXRhLnByb3BlcnR5TmFtZWApIHdpbGwgYXV0b21hdGljYWxseSByZS1ydW4gdGhlIGZvcm11bGEuXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBmb3JtdWxhc189bnVsbFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgZGF0YToge1xuICAgICAgICAgKiAgICAgICAgIGEgICAgOiAxLFxuICAgICAgICAgKiAgICAgICAgIGIgICAgOiAyLFxuICAgICAgICAgKiAgICAgICAgIHRvdGFsOiA1MFxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiAgICAgZm9ybXVsYXM6IHtcbiAgICAgICAgICogICAgICAgICBhUGx1c0IgOiAoZGF0YSkgPT4gZGF0YS5hICsgZGF0YS5iLFxuICAgICAgICAgKiAgICAgICAgIGFUaW1lc0I6IChkYXRhKSA9PiBkYXRhLmEgKiBkYXRhLmIsXG4gICAgICAgICAqICAgICAgICAgLy8gQWNjZXNzaW5nIHBhcmVudCBkYXRhIChhc3N1bWluZyBhIHBhcmVudCBwcm92aWRlciBoYXMgYSAndGF4UmF0ZScgcHJvcGVydHkpXG4gICAgICAgICAqICAgICAgICAgdG90YWxXaXRoVGF4OiAoZGF0YSkgPT4gZGF0YS50b3RhbCAqICgxICsgZGF0YS50YXhSYXRlKVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGZvcm11bGFzXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5zdGF0ZS5Qcm92aWRlcnxudWxsfSBwYXJlbnRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbGxlY3Rpb24gb2YgTmVvLmRhdGEuU3RvcmUgaW5zdGFuY2VzIG1hbmFnZWQgYnkgdGhpcyBTdGF0ZVByb3ZpZGVyLlxuICAgICAgICAgKiBTdG9yZXMgYXJlIGRlZmluZWQgYXMgY29uZmlnIG9iamVjdHMgd2l0aCBhIGBtb2R1bGVgIHByb3BlcnR5IHBvaW50aW5nXG4gICAgICAgICAqIHRvIHRoZSBzdG9yZSBjbGFzcywgd2hpY2ggd2lsbCB0aGVuIGJlIGluc3RhbnRpYXRlZCBieSB0aGUgZnJhbWV3b3JrLlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc3RvcmVzXz1udWxsXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAgICBzdG9yZXM6IHtcbiAgICAgICAgICogICAgICAgICBteVVzZXJzOiB7XG4gICAgICAgICAqICAgICAgICAgICAgIG1vZHVsZTogTmVvLmRhdGEuU3RvcmUsXG4gICAgICAgICAqICAgICAgICAgICAgIG1vZGVsIDogJ015QXBwLm1vZGVsLlVzZXInLFxuICAgICAgICAgKiAgICAgICAgICAgICBkYXRhICA6IFt7aWQ6IDEsIG5hbWU6ICdKb2huJ30sIHtpZDogMiwgbmFtZTogJ0RvZSd9XVxuICAgICAgICAgKiAgICAgICAgIH0sXG4gICAgICAgICAqICAgICAgICAgbXlDdXN0b21TdG9yZTE6IE15Q3VzdG9tU3RvcmVDbGFzcyxcbiAgICAgICAgICogICAgICAgICBteUN1c3RvbVN0b3JlMjoge1xuICAgICAgICAgKiAgICAgICAgICAgICBtb2R1bGUgIDogTXlDdXN0b21TdG9yZUNsYXNzLFxuICAgICAgICAgKiAgICAgICAgICAgICBhdXRvTG9hZDogdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9yZXNfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IHdpbmRvd0lkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7TWFwfSAjYmluZGluZ0VmZmVjdHM9bmV3IE1hcCgpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAjYmluZGluZ0VmZmVjdHMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9ICNkYXRhQ29uZmlncz17fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI2RhdGFDb25maWdzID0ge31cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtNYXB9ICNmb3JtdWxhRWZmZWN0cz1uZXcgTWFwKClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICNmb3JtdWxhRWZmZWN0cyA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgTmVvLmlzVXNpbmdTdGF0ZVByb3ZpZGVycyA9IHRydWU7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZGp1c3RWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBkYXRhIGNvbmZpZyBnb3QgY2hhbmdlZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBpbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgI2RhdGFDb25maWdzIG1hcCwgY29udmVydGluZyBlYWNoXG4gICAgICogcGxhaW4gZGF0YSBwcm9wZXJ0eSBpbnRvIGEgcmVhY3RpdmUgTmVvLmNvcmUuQ29uZmlnIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREYXRhKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLnByb2Nlc3NEYXRhT2JqZWN0KHZhbHVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZm9ybXVsYXMgY29uZmlnIGdvdCBjaGFuZ2VkLlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdXAgcmVhY3RpdmUgZWZmZWN0cyBmb3IgZWFjaCBkZWZpbmVkIGZvcm11bGEuXG4gICAgICogRWFjaCBmb3JtdWxhIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBoaWVyYXJjaGljYWwgZGF0YSBwcm94eSwgYWxsb3dpbmcgaW1wbGljaXQgZGVwZW5kZW5jeSB0cmFja2luZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB2YWx1ZSBUaGUgbmV3IGZvcm11bGFzIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb2xkVmFsdWUgVGhlIG9sZCBmb3JtdWxhcyBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldEZvcm11bGFzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgLy8gRGVzdHJveSBvbGQgZm9ybXVsYSBlZmZlY3RzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIGFuZCBzdGFsZSBjYWxjdWxhdGlvbnMuXG4gICAgICAgIG1lLiNmb3JtdWxhRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QuZGVzdHJveSgpKTtcbiAgICAgICAgbWUuI2Zvcm11bGFFZmZlY3RzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2Zvcm11bGFLZXksIGZvcm11bGFGbl0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGF6eSBFZmZlY3QuIEl0IHdpbGwgbm90IHJ1biB1bnRpbCBleHBsaWNpdGx5IHRvbGQgdG8uXG4gICAgICAgICAgICAgICAgY29uc3QgZWZmZWN0ID0gbmV3IEVmZmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGZuOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoaWNhbERhdGEgPSBtZS5nZXRIaWVyYXJjaHlEYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICAgICAgICAgICA9IGZvcm11bGFGbihoaWVyYXJjaGljYWxEYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2V0RGF0YShmb3JtdWxhS2V5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYXp5OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtZS4jZm9ybXVsYUVmZmVjdHMuc2V0KGZvcm11bGFLZXksIGVmZmVjdClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhY2Nlc3NpbmcgdGhlIGRhdGEgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldERhdGEodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGllcmFyY2h5RGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgc3RvcmVzIGNvbmZpZyBnZXRzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0U3RvcmVzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCBzdG9yZVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgbWFwcGluZyBzdHJpbmcgYmFzZWQgbGlzdGVuZXJzIGludG8gdGhlIHN0YXRlUHJvdmlkZXIgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhzdG9yZVZhbHVlLmxpc3RlbmVycyB8fCB7fSkuZm9yRWFjaCgoW2xpc3RlbmVyS2V5LCBsaXN0ZW5lcl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWUuYmluZENhbGxiYWNrKGxpc3RlbmVyLCBsaXN0ZW5lcktleSwgbWUsIHN0b3JlVmFsdWUubGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHN0b3JlVmFsdWUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBiaW5kaW5nIGZvciBhIGNvbXBvbmVudCdzIGNvbmZpZyB0byBhIGRhdGEgcHJvcGVydHkuXG4gICAgICogVGhpcyBub3cgdXNlcyB0aGUgRWZmZWN0LWJhc2VkIHJlYWN0aXZpdHkgc3lzdGVtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRJZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWdLZXkgVGhlIGNvbXBvbmVudCBjb25maWcgdG8gYmluZCAoZS5nLiwgJ3RleHQnKS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gZm9ybWF0dGVyIFRoZSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5nKGNvbXBvbmVudElkLCBjb25maWdLZXksIGZvcm1hdHRlcikge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGVmZmVjdCA9IG5ldyBFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IE5lby5nZXQoY29tcG9uZW50SWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiAhY29tcG9uZW50LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWVyYXJjaGljYWxEYXRhID0gbWUuZ2V0SGllcmFyY2h5RGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgICAgICAgICA9IE5lby5pc0Z1bmN0aW9uKGZvcm1hdHRlcikgPyBmb3JtYXR0ZXIuY2FsbChtZSwgaGllcmFyY2hpY2FsRGF0YSkgOiBoaWVyYXJjaGljYWxEYXRhW2Zvcm1hdHRlcl07XG5cbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Ll9za2lwVHdvV2F5UHVzaCA9IGNvbmZpZ0tleTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50W2NvbmZpZ0tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudC5fc2tpcFR3b1dheVB1c2hcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBtZS4jYmluZGluZ0VmZmVjdHMuc2V0KGNvbXBvbmVudElkLCBlZmZlY3QpO1xuXG4gICAgICAgIC8vIFRoZSBlZmZlY3Qgb2JzZXJ2ZXMgdGhlIGNvbXBvbmVudCdzIGRlc3RydWN0aW9uIHRvIGNsZWFuIGl0c2VsZiB1cC5cbiAgICAgICAgbWUub2JzZXJ2ZUNvbmZpZyhjb21wb25lbnRJZCwgJ2lzRGVzdHJveWluZycsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBtZS4jYmluZGluZ0VmZmVjdHMuZGVsZXRlKGNvbXBvbmVudElkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGUgZWZmZWN0IGlzIHJldHVybmVkIHRvIGJlIG1hbmFnZWQgYnkgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgcmV0dXJuIGVmZmVjdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIGNvbXBvbmVudCdzIGBiaW5kYCBjb25maWd1cmF0aW9uIHRvIGNyZWF0ZSByZWFjdGl2ZSBiaW5kaW5ncy5cbiAgICAgKiBJdCBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIHN0b3JlIGJpbmRpbmdzIGFuZCBkYXRhIGJpbmRpbmdzLCBhbmQgc2V0cyB1cCB0d28td2F5IGJpbmRpbmcgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7TmVvLmNvbXBvbmVudC5CYXNlfSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCBpbnN0YW5jZSB3aG9zZSBiaW5kaW5ncyBhcmUgdG8gYmUgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBjcmVhdGVCaW5kaW5ncyhjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaGFzVHdvV2F5QmluZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbXBvbmVudC5iaW5kIHx8IHt9KS5mb3JFYWNoKChbY29uZmlnS2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGxldCBrZXkgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGJpbmRpbmcgdmFsdWUgaXMgYW4gb2JqZWN0LCBpdCBtaWdodCBjb250YWluIGB0d29XYXlgIG9yIGEgc3BlY2lmaWMgYGtleWAuXG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50d29XYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVHdvV2F5QmluZGluZyA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gdmFsdWUua2V5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBpdCdzIGEgc3RvcmUgYmluZGluZyBvciBhIGRhdGEgYmluZGluZy5cbiAgICAgICAgICAgIGlmIChtZS5pc1N0b3JlVmFsdWUoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBzdG9yZSBiaW5kaW5ncywgcmVzb2x2ZSB0aGUgc3RvcmUgYW5kIGFzc2lnbiBpdCB0byB0aGUgY29tcG9uZW50IGNvbmZpZy5cbiAgICAgICAgICAgICAgICBtZS5yZXNvbHZlU3RvcmUoY29tcG9uZW50LCBjb25maWdLZXksIGtleS5zdWJzdHJpbmcoNykpIC8vIHJlbW92ZSB0aGUgXCJzdG9yZXMuXCIgcHJlZml4XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBkYXRhIGJpbmRpbmdzLCBjcmVhdGUgYW4gRWZmZWN0IHRvIGtlZXAgdGhlIGNvbXBvbmVudCBjb25maWcgaW4gc3luYyB3aXRoIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgIG1lLmNyZWF0ZUJpbmRpbmcoY29tcG9uZW50LmlkLCBjb25maWdLZXksIGtleSwgdmFsdWUudHdvV2F5KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgaWYgaXQgaGFzIGFueSB0d28td2F5IGJpbmRpbmdzLCBmb3IgaW50ZXJuYWwgdHJhY2tpbmcuXG4gICAgICAgIGlmIChoYXNUd29XYXlCaW5kaW5nKSB7XG4gICAgICAgICAgICBjb21wb25lbnRbdHdvV2F5QmluZGluZ1N5bWJvbF0gPSB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgc3RhdGUgcHJvdmlkZXIgYW5kIGNsZWFucyB1cCBhbGwgYXNzb2NpYXRlZCBlZmZlY3RzLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcblxuICAgICAgICBtZS4jZm9ybXVsYUVmZmVjdHMuZm9yRWFjaChlZmZlY3QgPT4gZWZmZWN0LmRlc3Ryb3koKSk7XG4gICAgICAgIG1lLiNmb3JtdWxhRWZmZWN0cy5jbGVhcigpO1xuXG4gICAgICAgIG1lLiNiaW5kaW5nRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QuZGVzdHJveSgpKTtcbiAgICAgICAgbWUuI2JpbmRpbmdFZmZlY3RzLmNsZWFyKCk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2Ugc2hvcnRjdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW250eXBlXVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyKG50eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRDb250cm9sbGVyKG50eXBlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY2VzcyB0aGUgY2xvc2VzdCBkYXRhIHByb3BlcnR5IGluc2lkZSB0aGUgcGFyZW50IGNoYWluLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXREYXRhKGtleSkge1xuICAgICAgICBjb25zdCBvd25lckRldGFpbHMgPSB0aGlzLmdldE93bmVyT2ZEYXRhUHJvcGVydHkoa2V5KTtcblxuICAgICAgICBpZiAob3duZXJEZXRhaWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gb3duZXJEZXRhaWxzLm93bmVyLmdldERhdGFDb25maWcob3duZXJEZXRhaWxzLnByb3BlcnR5TmFtZSkuZ2V0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdW5kZXJseWluZyBjb3JlLkNvbmZpZyBpbnN0YW5jZSBmb3IgYSBnaXZlbiBkYXRhIHByb3BlcnR5IHBhdGguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIGZ1bGwgcGF0aCBvZiB0aGUgZGF0YSBwcm9wZXJ0eSAoZS5nLiwgJ3VzZXIuZmlyc3RuYW1lJykuXG4gICAgICogQHJldHVybnMge05lby5jb3JlLkNvbmZpZ3xudWxsfVxuICAgICAqL1xuICAgIGdldERhdGFDb25maWcocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YUNvbmZpZ3NbcGF0aF0gfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lcmdlZCwgaGllcmFyY2hpY2FsIGRhdGEgb2JqZWN0IGFzIGEgcmVhY3RpdmUgUHJveHkuXG4gICAgICogQHJldHVybnMge1Byb3h5fVxuICAgICAqL1xuICAgIGdldEhpZXJhcmNoeURhdGEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIaWVyYXJjaGljYWxEYXRhUHJveHkodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc3RhdGUuUHJvdmlkZXIgaW5zdGFuY2UgdGhhdCBvd25zIGEgc3BlY2lmaWMgZGF0YSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgZnVsbCBwYXRoIG9mIHRoZSBkYXRhIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHt7b3duZXI6IE5lby5zdGF0ZS5Qcm92aWRlciwgcHJvcGVydHlOYW1lOiBTdHJpbmd9fG51bGx9XG4gICAgICovXG4gICAgZ2V0T3duZXJPZkRhdGFQcm9wZXJ0eShwYXRoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG1lLiNkYXRhQ29uZmlnc1twYXRoXSkge1xuICAgICAgICAgICAgcmV0dXJuIHtvd25lcjogbWUsIHByb3BlcnR5TmFtZTogcGF0aH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBwYXJlbnQgb3duZXJzaGlwXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG1lLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmdldE93bmVyT2ZEYXRhUHJvcGVydHkocGF0aClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgaW5zaWRlIHRoZSBjb21wb25lbnRzIHBhcmVudCB0cmVlXG4gICAgICogQHJldHVybnMge05lby5zdGF0ZS5Qcm92aWRlcnxudWxsfVxuICAgICAqL1xuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyBBY2Nlc3MgdGhlIGludGVybmFsIHZhbHVlIG9mIHRoZSBwYXJlbnRfIGNvbmZpZyBkaXJlY3RseS5cbiAgICAgICAgLy8gVGhpcyBhdm9pZHMgcmVjdXJzaXZlIGNhbGxzIHRvIHRoZSBnZXR0ZXIuXG4gICAgICAgIGlmIChtZS5fcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWUuX3BhcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcGFyZW50IGlzIHNldCwgdHJ5IHRvIGZpbmQgaXQgZHluYW1pY2FsbHkgdmlhIHRoZSBjb21wb25lbnQuXG4gICAgICAgIC8vIEVuc3VyZSB0aGlzLmNvbXBvbmVudCBleGlzdHMgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgaXRzIHBhcmVudC5cbiAgICAgICAgaWYgKG1lLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lLmNvbXBvbmVudC5wYXJlbnQ/LmdldFN0YXRlUHJvdmlkZXIoKSB8fCBudWxsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBleHBsaWNpdCBwYXJlbnQgYW5kIG5vIGNvbXBvbmVudCB0byBkZXJpdmUgaXQgZnJvbS5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdGhlIGNsb3Nlc3Qgc3RvcmUgaW5zaWRlIHRoZSBWTSBwYXJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7TmVvLnN0YXRlLlByb3ZpZGVyfSBvcmlnaW5TdGF0ZVByb3ZpZGVyPXRoaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgKiBAcmV0dXJucyB7TmVvLmRhdGEuU3RvcmV9XG4gICAgICovXG4gICAgZ2V0U3RvcmUoa2V5LCBvcmlnaW5TdGF0ZVByb3ZpZGVyPXRoaXMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtzdG9yZXN9ID0gbWUsXG4gICAgICAgICAgICBwYXJlbnRTdGF0ZVByb3ZpZGVyO1xuXG4gICAgICAgIGlmIChzdG9yZXM/Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZXNba2V5XVxuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50U3RhdGVQcm92aWRlciA9IG1lLmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmICghcGFyZW50U3RhdGVQcm92aWRlcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgc3RvcmUgJyR7a2V5fScgbm90IGZvdW5kIGluc2lkZSB0aGlzIHN0YXRlUHJvdmlkZXIgb3IgcGFyZW50cy5gLCBvcmlnaW5TdGF0ZVByb3ZpZGVyKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudFN0YXRlUHJvdmlkZXIuZ2V0U3RvcmUoa2V5LCBvcmlnaW5TdGF0ZVByb3ZpZGVyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbnkgZGF0YSBwcm9wZXJ0eSBpbiB0aGUgaGllcmFyY2h5IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSB0aGUgSGllcmFyY2hpY2FsRGF0YVByb3h5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGQgcmV0dXJuIGEgbmVzdGVkIHByb3h5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrIChlLmcuLCAndXNlcicpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc05lc3RlZERhdGFTdGFydGluZ1dpdGgocGF0aCkge1xuICAgICAgICBjb25zdCBwYXRoV2l0aERvdCA9IGAke3BhdGh9LmA7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuI2RhdGFDb25maWdzKS5zb21lKGtleSA9PiBrZXkuc3RhcnRzV2l0aChwYXRoV2l0aERvdCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KCk/Lmhhc05lc3RlZERhdGFTdGFydGluZ1dpdGgocGF0aCkgfHwgZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3AtbGV2ZWwgZGF0YSBrZXlzIGZvciBhIGdpdmVuIHBhdGggd2l0aGluIHRoaXMgcHJvdmlkZXIncyBkYXRhLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGdldCBrZXlzIGZvciAoZS5nLiwgJ3VzZXIuYWRkcmVzcycpLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRUb3BMZXZlbERhdGFLZXlzKHBhdGgpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIGtleXMgICAgICAgPSBuZXcgU2V0KCksXG4gICAgICAgICAgICBwYXRoUHJlZml4ID0gcGF0aCA/IGAke3BhdGh9LmAgOiAnJztcblxuICAgICAgICBmb3IgKGNvbnN0IGZ1bGxQYXRoIGluIHRoaXMuI2RhdGFDb25maWdzKSB7XG4gICAgICAgICAgICBpZiAoZnVsbFBhdGguc3RhcnRzV2l0aChwYXRoUHJlZml4KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IGZ1bGxQYXRoLnN1YnN0cmluZyhwYXRoUHJlZml4Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHRvcExldmVsS2V5ICA9IHJlbGF0aXZlUGF0aC5zcGxpdCgnLicpWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvcExldmVsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMuYWRkKHRvcExldmVsS2V5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGtleXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY29yZSBtZXRob2QgZm9yIHNldHRpbmcgZGF0YSwgcHJvdmlkaW5nIGEgc2luZ2xlIGVudHJ5IHBvaW50IGZvciBhbGwgZGF0YSBtb2RpZmljYXRpb25zLlxuICAgICAqIEl0IGhhbmRsZXMgbXVsdGlwbGUgc2NlbmFyaW9zOlxuICAgICAqIDEuICAqKk9iamVjdC1iYXNlZCB1cGRhdGVzOioqIElmIGBrZXlgIGlzIGFuIG9iamVjdCwgaXQgcmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyLlxuICAgICAqIDIuICAqKkRhdGEgUmVjb3JkczoqKiBJZiBgdmFsdWVgIGlzIGEgYE5lby5kYXRhLlJlY29yZGAsIGl0IGlzIHRyZWF0ZWQgYXMgYW4gYXRvbWljIHZhbHVlIGFuZCBzZXQgZGlyZWN0bHkuXG4gICAgICogMy4gICoqQnViYmxpbmcgUmVhY3Rpdml0eToqKiBGb3IgYSBnaXZlbiBrZXkgKGUuZy4sICd1c2VyLm5hbWUnKSwgaXQgc2V0cyB0aGUgbGVhZiB2YWx1ZSBhbmQgdGhlbiBcImJ1YmJsZXMgdXBcIlxuICAgICAqICAgICB0aGUgY2hhbmdlLCBjcmVhdGluZyBuZXcgcGFyZW50IG9iamVjdHMgKGUuZy4sICd1c2VyJykgdG8gZW5zdXJlIHRoYXQgZWZmZWN0cyBkZXBlbmRpbmcgb24gYW55IHBhcnRcbiAgICAgKiAgICAgb2YgdGhlIHBhdGggYXJlIHRyaWdnZXJlZC5cbiAgICAgKlxuICAgICAqIEFsbCB1cGRhdGVzIGFyZSBiYXRjaGVkIGJ5IHRoZSBwdWJsaWMgYHNldERhdGFgIG1ldGhvZHMgdG8gZW5zdXJlIGVmZmVjdHMgcnVuIG9ubHkgb25jZS5cbiAgICAgKiBVc2UgYHNldERhdGEoKWAgb3IgYHNldERhdGFBdFNhbWVMZXZlbCgpYCBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBtZXRob2QgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtleSBUaGUgcHJvcGVydHkgdG8gc2V0LCBvciBhbiBvYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcn0gW29yaWdpblN0YXRlUHJvdmlkZXJdIFRoZSBwcm92aWRlciB0byBzdGFydCB0aGUgc2VhcmNoIGZyb20gZm9yIGhpZXJhcmNoaWNhbCB1cGRhdGVzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSwgb3JpZ2luU3RhdGVQcm92aWRlcikge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKE5lby5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhrZXkpLmZvckVhY2goKFtkYXRhS2V5LCBkYXRhVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUuaW50ZXJuYWxTZXREYXRhKGRhdGFLZXksIGRhdGFWYWx1ZSwgb3JpZ2luU3RhdGVQcm92aWRlcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgJ2tleScgaXMgYSBzdHJpbmcgcGF0aC5cbiAgICAgICAgLy8gSWYgJ3ZhbHVlJyBpcyBhIHBsYWluIG9iamVjdCwgd2UgbmVlZCB0byBkcmlsbCBkb3duIGZ1cnRoZXIuXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIE5lby5kYXRhLlJlY29yZCwgdHJlYXQgaXQgYXMgYW4gYXRvbWljIHZhbHVlID0+IGl0IHdpbGwgbm90IGVudGVyIHRoaXMgYmxvY2suXG4gICAgICAgIGlmIChOZW8udHlwZU9mKHZhbHVlKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChbbmVzdGVkS2V5LCBuZXN0ZWRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IGAke2tleX0uJHtuZXN0ZWRLZXl9YDtcbiAgICAgICAgICAgICAgICBtZS5pbnRlcm5hbFNldERhdGEoZnVsbFBhdGgsIG5lc3RlZFZhbHVlLCBvcmlnaW5TdGF0ZVByb3ZpZGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIC8vIFdlJ3ZlIGRlbGVnYXRlZCB0aGUgc2V0dGluZyB0byBkZWVwZXIgcGF0aHMuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdFxuICAgICAgICAgICAgb3duZXJEZXRhaWxzICAgPSBtZS5nZXRPd25lck9mRGF0YVByb3BlcnR5KGtleSksXG4gICAgICAgICAgICB0YXJnZXRQcm92aWRlciA9IG93bmVyRGV0YWlscyA/IG93bmVyRGV0YWlscy5vd25lciA6IChvcmlnaW5TdGF0ZVByb3ZpZGVyIHx8IG1lKTtcblxuICAgICAgICBtZS4jc2V0Q29uZmlnVmFsdWUodGFyZ2V0UHJvdmlkZXIsIGtleSwgdmFsdWUsIG51bGwpO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIFwicmVhY3Rpdml0eSBidWJibGluZ1wiIGxvZ2ljLiBXaGVuIGEgbGVhZiBwcm9wZXJ0eSBsaWtlICd1c2VyLm5hbWUnIGNoYW5nZXMsXG4gICAgICAgIC8vIHdlIG11c3QgYWxzbyB0cmlnZ2VyIGVmZmVjdHMgdGhhdCBkZXBlbmQgb24gdGhlIHBhcmVudCBvYmplY3QgJ3VzZXInLiBXZSBkbyB0aGlzIGJ5XG4gICAgICAgIC8vIGNyZWF0aW5nIGEgbmV3IG9iamVjdCByZWZlcmVuY2UgZm9yIGVhY2ggcGFyZW50IGluIHRoZSBwYXRoLiBUaGUgc3ByZWFkIHN5bnRheFxuICAgICAgICAvLyBgeyAuLi5vbGRQYXJlbnRWYWx1ZSwgW2xlYWZLZXldOiBsYXRlc3RWYWx1ZSB9YCBpcyBrZXksIGFzIGl0IGNyZWF0ZXMgYSBuZXdcbiAgICAgICAgLy8gb2JqZWN0LCB3aGljaCB0aGUgcmVhY3Rpdml0eSBzeXN0ZW0gZGV0ZWN0cyBhcyBhIGNoYW5nZS5cbiAgICAgICAgbGV0IHBhdGggICAgICAgID0ga2V5LFxuICAgICAgICAgICAgbGF0ZXN0VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAocGF0aC5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICBjb25zdCBsZWFmS2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGFzdEluZGV4T2YoJy4nKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudENvbmZpZyA9IHRhcmdldFByb3ZpZGVyLmdldERhdGFDb25maWcocGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRQYXJlbnRWYWx1ZSA9IHBhcmVudENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KG9sZFBhcmVudFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXJlbnRWYWx1ZSA9IHsgLi4ub2xkUGFyZW50VmFsdWUsIFtsZWFmS2V5XTogbGF0ZXN0VmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnLnNldChuZXdQYXJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlID0gbmV3UGFyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgLy8gU3RvcCBpZiBwYXJlbnQgaXMgbm90IGFuIG9iamVjdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBjb25maWcgZG9lc24ndCBleGlzdCwgd2UgbmVlZCB0byBjcmVhdGUgaXQgdG8gc3VwcG9ydCBidWJibGluZy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGNydWNpYWwgZm9yIGNyZWF0aW5nIG5ldyBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzIGF0IHJ1bnRpbWUuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UGFyZW50VmFsdWUgPSB7W2xlYWZLZXldOiBsYXRlc3RWYWx1ZX07XG4gICAgICAgICAgICAgICAgbWUuI3NldENvbmZpZ1ZhbHVlKHRhcmdldFByb3ZpZGVyLCBwYXRoLCBuZXdQYXJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWUgPSBuZXdQYXJlbnRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY29udmVuaWVuY2UgbWV0aG9kIHRvIGNoZWNrIGlmIGEgYmluZGluZyB2YWx1ZSBpcyBzdXBwb3NlZCB0byBtYXRjaCBhIHN0b3JlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdG9yZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOZW8uaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLnN0YXJ0c1dpdGgoJ3N0b3Jlcy4nKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIGFmdGVyIGFsbCBjb25zdHJ1Y3RvcnMgJiBjb25maWdzIGFyZSBhcHBsaWVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkNvbnN0cnVjdGVkKCkge1xuICAgICAgICBzdXBlci5vbkNvbnN0cnVjdGVkKCk7XG5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIHByb3ZpZGVyIGlzIGZ1bGx5IGNvbnN0cnVjdGVkIGFuZCBpbml0aWFsIGRhdGEgaXMgc2V0LFxuICAgICAgICAvLyBydW4gdGhlIGZvcm11bGEgZWZmZWN0cyBmb3IgdGhlIGZpcnN0IHRpbWUgdG8gY29tcHV0ZSB0aGVpciBpbml0aWFsIHZhbHVlcy5cbiAgICAgICAgdGhpcy4jZm9ybXVsYUVmZmVjdHMuZm9yRWFjaChlZmZlY3QgPT4gZWZmZWN0LnJ1bigpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAqL1xuICAgIG9uRGF0YVByb3BlcnR5Q2hhbmdlKGtleSwgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIC8vIENhbiBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBwcm9jZXNzZXMgYSBkYXRhIG9iamVjdCwgY3JlYXRpbmcgb3IgdXBkYXRpbmcgTmVvLmNvcmUuQ29uZmlnIGluc3RhbmNlc1xuICAgICAqIGZvciBlYWNoIHByb3BlcnR5IGFuZCBzdG9yaW5nIHRoZW0gaW4gdGhlICNkYXRhQ29uZmlncyBtYXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgZGF0YSBvYmplY3QgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGg9JyddIFRoZSBjdXJyZW50IHBhdGggcHJlZml4IGZvciBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvY2Vzc0RhdGFPYmplY3Qob2JqLCBwYXRoID0gJycpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBPYmplY3QuZW50cmllcyhvYmopLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoID8gYCR7cGF0aH0uJHtrZXl9YCA6IGtleTtcblxuICAgICAgICAgICAgdmFsdWUgPSBtZS5hZGp1c3RWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBhIENvbmZpZyBpbnN0YW5jZSBleGlzdHMgZm9yIHRoZSBjdXJyZW50IGZ1bGxQYXRoXG4gICAgICAgICAgICBpZiAobWUuI2RhdGFDb25maWdzW2Z1bGxQYXRoXSkge1xuICAgICAgICAgICAgICAgIG1lLiNkYXRhQ29uZmlnc1tmdWxsUGF0aF0uc2V0KHZhbHVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS4jZGF0YUNvbmZpZ3NbZnVsbFBhdGhdID0gbmV3IENvbmZpZyh2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCByZWN1cnNpdmVseSBwcm9jZXNzIGl0cyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoTmVvLnR5cGVPZih2YWx1ZSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbWUucHJvY2Vzc0RhdGFPYmplY3QodmFsdWUsIGZ1bGxQYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZX0gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgIGNvbmZpZ05hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAgc3RvcmVOYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZVN0b3JlKGNvbXBvbmVudCwgY29uZmlnTmFtZSwgc3RvcmVOYW1lKSB7XG4gICAgICAgIGxldCBzdG9yZSA9IHRoaXMuZ2V0U3RvcmUoc3RvcmVOYW1lKTtcblxuICAgICAgICBpZiAoY29tcG9uZW50W2NvbmZpZ05hbWVdICE9PSBzdG9yZSkge1xuICAgICAgICAgICAgY29tcG9uZW50W2NvbmZpZ05hbWVdID0gc3RvcmVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgYSBjb25maWcgdmFsdWUgYW5kIHRyaWdnZXIgcmVhY3Rpdml0eS5cbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IENvbmZpZyBpbnN0YW5jZSBpZiBvbmUgZG9lc24ndCBleGlzdCBmb3IgdGhlIGdpdmVuIHBhdGgsXG4gICAgICogb3IgdXBkYXRlcyBhbiBleGlzdGluZyBvbmUuIEl0IGFsc28gdHJpZ2dlcnMgYmluZGluZyBlZmZlY3RzIGFuZCBjYWxscyBvbkRhdGFQcm9wZXJ0eUNoYW5nZS5cbiAgICAgKiBAcGFyYW0ge05lby5zdGF0ZS5Qcm92aWRlcn0gcHJvdmlkZXIgVGhlIFN0YXRlUHJvdmlkZXIgaW5zdGFuY2Ugb3duaW5nIHRoZSBjb25maWcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgIHBhdGggICAgIFRoZSBmdWxsIHBhdGggb2YgdGhlIGRhdGEgcHJvcGVydHkgKGUuZy4sICd1c2VyLmZpcnN0bmFtZScpLlxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgICAgICAgICAgICBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgICAgICBbb2xkVmFsXSAgVGhlIG9sZCB2YWx1ZSAob3B0aW9uYWwsIHVzZWQgZm9yIGluaXRpYWwgc2V0dXApLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgI3NldENvbmZpZ1ZhbHVlKHByb3ZpZGVyLCBwYXRoLCBuZXdWYWx1ZSwgb2xkVmFsKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gcHJvdmlkZXIuYWRqdXN0VmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICAgIGxldCBjdXJyZW50Q29uZmlnID0gcHJvdmlkZXIuZ2V0RGF0YUNvbmZpZyhwYXRoKSxcbiAgICAgICAgICAgIGhhc0NoYW5nZSAgICAgPSB0cnVlLFxuICAgICAgICAgICAgb2xkVmFsdWUgICAgICA9IG9sZFZhbDtcblxuICAgICAgICBpZiAoY3VycmVudENvbmZpZykge1xuICAgICAgICAgICAgb2xkVmFsdWUgID0gY3VycmVudENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgIGhhc0NoYW5nZSA9IGN1cnJlbnRDb25maWcuc2V0KG5ld1ZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudENvbmZpZyA9IG5ldyBDb25maWcobmV3VmFsdWUpO1xuICAgICAgICAgICAgcHJvdmlkZXIuI2RhdGFDb25maWdzW3BhdGhdID0gY3VycmVudENvbmZpZztcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYWxsIGJpbmRpbmcgZWZmZWN0cyB0byByZS1ldmFsdWF0ZSB0aGVpciBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIHByb3ZpZGVyLiNiaW5kaW5nRWZmZWN0cy5mb3JFYWNoKGVmZmVjdCA9PiBlZmZlY3QucnVuKCkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzQ2hhbmdlKSB7XG4gICAgICAgICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgb2YgdGhlIGRhdGEgcHJvcGVydHkgY2hhbmdlLlxuICAgICAgICAgICAgcHJvdmlkZXIub25EYXRhUHJvcGVydHlDaGFuZ2UocGF0aCwgbmV3VmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB3aWxsIGFzc2lnbiBhbGwgdmFsdWVzIHRvIHRoZSBjbG9zZXN0IHN0YXRlUHJvdmlkZXIgd2hlcmUgaXQgZmluZHMgYW4gZXhpc3Rpbmcga2V5LlxuICAgICAqIEluIGNhc2Ugbm8gbWF0Y2ggaXMgZm91bmQgaW5zaWRlIHRoZSBwYXJlbnQgY2hhaW4sIGEgbmV3IGRhdGEgcHJvcGVydHkgd2lsbCBnZXQgZ2VuZXJhdGVkLlxuICAgICAqXG4gICAgICogQWxsIHVwZGF0ZXMgd2l0aGluIGEgc2luZ2xlIGNhbGwgYXJlIGJhdGNoZWQgdG8gZW5zdXJlIHRoYXQgcmVhY3RpdmUgZWZmZWN0cyAoYmluZGluZ3MgYW5kIGZvcm11bGFzKVxuICAgICAqIGFyZSBydW4gb25seSBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgIHZhbHVlXG4gICAgICovXG4gICAgc2V0RGF0YShrZXksIHZhbHVlKSB7XG4gICAgICAgIEVmZmVjdE1hbmFnZXIucGF1c2UoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTZXREYXRhKGtleSwgdmFsdWUsIHRoaXMpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBFZmZlY3RNYW5hZ2VyLnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiBzZXREYXRhKCkgaW4gY2FzZSB5b3Ugd2FudCB0byBlbmZvcmNlXG4gICAgICogc2V0dGluZyBhbGwga2V5cyBvbiB0aGlzIGluc3RhbmNlIGluc3RlYWQgb2YgbG9va2luZyBmb3IgbWF0Y2hlcyBpbnNpZGUgcGFyZW50IHN0YXRlUHJvdmlkZXJzLlxuICAgICAqXG4gICAgICogQWxsIHVwZGF0ZXMgd2l0aGluIGEgc2luZ2xlIGNhbGwgYXJlIGJhdGNoZWQgdG8gZW5zdXJlIHRoYXQgcmVhY3RpdmUgZWZmZWN0cyAoYmluZGluZ3MgYW5kIGZvcm11bGFzKVxuICAgICAqIGFyZSBydW4gb25seSBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICAgICAgIHZhbHVlXG4gICAgICovXG4gICAgc2V0RGF0YUF0U2FtZUxldmVsKGtleSwgdmFsdWUpIHtcbiAgICAgICAgRWZmZWN0TWFuYWdlci5wYXVzZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFNldERhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIucmVzdW1lKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUHJvdmlkZXIpO1xuIiwiaW1wb3J0IEVmZmVjdE1hbmFnZXIgZnJvbSAnLi4vY29yZS9FZmZlY3RNYW5hZ2VyLm1qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5lc3RlZCBQcm94eSB0aGF0IHJlcHJlc2VudHMgYSBsZXZlbCBpbiB0aGUgaGllcmFyY2hpY2FsIGRhdGEgc3RydWN0dXJlLlxuICogQHBhcmFtIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IHJvb3RQcm92aWRlciBUaGUgdG9wLWxldmVsIHByb3ZpZGVyIHRvIHN0YXJ0IHNlYXJjaGVzIGZyb20uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgY3VycmVudCBwYXRoIG9mIHRoaXMgcHJveHkgbGV2ZWwgKGUuZy4sICd1c2VyJyBmb3IgZGF0YS51c2VyKS5cbiAqIEByZXR1cm5zIHtQcm94eXxudWxsfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTmVzdGVkUHJveHkocm9vdFByb3ZpZGVyLCBwYXRoKSB7XG4gICAgLy8gVGhlIHRhcmdldCBvYmplY3QgZm9yIHRoZSBwcm94eSBjYW4gYmUgZW1wdHkgYmVjYXVzZSBhbGwgbG9va3VwcyBhcmUgZHluYW1pYy5cbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcblxuICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZ2V0IHRyYXAgZm9yIHRoZSBwcm94eS4gVGhpcyBpcyB3aGVyZSB0aGUgbWFnaWMgaGFwcGVucy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRUYXJnZXQgVGhlIHByb3h5J3MgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgYWNjZXNzZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IG9yIGEgbmV3IHByb3h5IGZvciBuZXN0ZWQgYWNjZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0KGN1cnJlbnRUYXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW50ZXJuYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHNldCBkaXJlY3RseSBvbiB0aGUgcHJveHkncyB0YXJnZXRcbiAgICAgICAgICAgIC8vIG9yIGFyZSBleHBlY3RlZCBieSB0aGUgZW52aXJvbm1lbnQgKGxpa2UgU2llc3RhJ3MgX19SRUZBRFJfXykuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3ltYm9sJyB8fCBwcm9wZXJ0eSA9PT0gJ19fUkVGQURSX18nIHx8IHByb3BlcnR5ID09PSAnaW5zcGVjdCcgfHwgcHJvcGVydHkgPT09ICd0aGVuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChjdXJyZW50VGFyZ2V0LCBwcm9wZXJ0eSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBhbGxvdyBzdHJpbmcgb3IgbnVtYmVyIHByb3BlcnRpZXMgdG8gcHJvY2VlZCBhcyBkYXRhIHBhdGhzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIEZvciBvdGhlciBub24tc3RyaW5nL25vbi1udW1iZXIgcHJvcGVydGllcywgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlICdzdG9yZXMnIHByb3BlcnR5IGF0IHRoZSByb290IGxldmVsXG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gJycgJiYgcHJvcGVydHkgPT09ICdzdG9yZXMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVOYW1lID09PSAnc3ltYm9sJyB8fCBzdG9yZU5hbWUgPT09ICdfX1JFRkFEUl9fJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHN0b3JlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGVnYXRlIHRvIHRoZSBTdGF0ZVByb3ZpZGVyJ3MgZ2V0U3RvcmUgbWV0aG9kIGZvciBoaWVyYXJjaGljYWwgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXNzaW5nIHN0b3JlLmNvdW50IGxhdGVyIHdpbGwgcmVnaXN0ZXIgdGhlIGRlcGVuZGVuY3kgdmlhIHRoZSBDb25maWcgc3lzdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFByb3ZpZGVyLmdldFN0b3JlKHN0b3JlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aCA/IGAke3BhdGh9LiR7cHJvcGVydHl9YCA6IHByb3BlcnR5O1xuXG4gICAgICAgICAgICAvLyAxLiBDaGVjayBpZiB0aGUgZnVsbCBwYXRoIGNvcnJlc3BvbmRzIHRvIGFuIGFjdHVhbCBkYXRhIHByb3BlcnR5LlxuICAgICAgICAgICAgY29uc3Qgb3duZXJEZXRhaWxzID0gcm9vdFByb3ZpZGVyLmdldE93bmVyT2ZEYXRhUHJvcGVydHkoZnVsbFBhdGgpO1xuXG4gICAgICAgICAgICBpZiAob3duZXJEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICAgICAge293bmVyLCBwcm9wZXJ0eU5hbWV9ID0gb3duZXJEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICBjb25maWcgICAgICAgICAgICAgICAgPSBvd25lci5nZXREYXRhQ29uZmlnKHByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIEVmZmVjdE1hbmFnZXIuZ2V0QWN0aXZlRWZmZWN0KCk/LmFkZERlcGVuZGVuY3koY29uZmlnKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgcmV0dXJuIGEgbmV3IHByb3h5IGZvciBpdCB0byBlbnN1cmUgbmVzdGVkIGFjY2Vzc2VzIGFyZSBhbHNvIHByb3hpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTmVzdGVkUHJveHkocm9vdFByb3ZpZGVyLCBmdWxsUGF0aClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMi4gSWYgbm90IGEgZGlyZWN0IG1hdGNoLCBpdCBtaWdodCBiZSBhIHBhcmVudCBvYmplY3Qgb2YgYSBuZXN0ZWQgcHJvcGVydHlcbiAgICAgICAgICAgIC8vICAgIChlLmcuLCBhY2Nlc3NpbmcgYHVzZXJgIHdoZW4gYSBgdXNlci5maXJzdG5hbWVgIGJpbmRpbmcgZXhpc3RzKS5cbiAgICAgICAgICAgIC8vICAgIEluIHRoaXMgY2FzZSwgd2UgcmV0dXJuIGFub3RoZXIgcHJveHkgZm9yIHRoZSBuZXh0IGxldmVsIGRvd24uXG4gICAgICAgICAgICBpZiAocm9vdFByb3ZpZGVyLmhhc05lc3RlZERhdGFTdGFydGluZ1dpdGgoZnVsbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5lc3RlZFByb3h5KHJvb3RQcm92aWRlciwgZnVsbFBhdGgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDMuIElmIGl0J3MgbmVpdGhlciBhIGRhdGEgcHJvcGVydHkgbm9yIGEgcGF0aCB0byBvbmUsIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgICAvLyAgICBSZXR1cm5pbmcgdW5kZWZpbmVkIGVuc3VyZXMgdGhhdCBjaGFpbmVkIGFjY2Vzc2VzIChlLmcuLCBkYXRhLm5vbmV4aXN0ZW50LnByb3BlcnR5KSBmYWlsIGdyYWNlZnVsbHkuXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0KGN1cnJlbnRUYXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQWxsb3cgaW50ZXJuYWwgcHJvcGVydGllcyAobGlrZSBTeW1ib2xzIG9yIHNwZWNpZmljIHN0cmluZ3MpIHRvIGJlIHNldCBkaXJlY3RseSBvbiB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N5bWJvbCcgfHwgcHJvcGVydHkgPT09ICdfX1JFRkFEUl9fJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldChjdXJyZW50VGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgZnVsbFBhdGggICAgID0gcGF0aCA/IGAke3BhdGh9LiR7cHJvcGVydHl9YCA6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIG93bmVyRGV0YWlscyA9IHJvb3RQcm92aWRlci5nZXRPd25lck9mRGF0YVByb3BlcnR5KGZ1bGxQYXRoKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRQcm92aWRlcjtcblxuICAgICAgICAgICAgaWYgKG93bmVyRGV0YWlscykge1xuICAgICAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyID0gb3duZXJEZXRhaWxzLm93bmVyXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIG93bmVyIGlzIGZvdW5kLCBzZXQgaXQgb24gdGhlIHJvb3RQcm92aWRlciAodGhlIG9uZSB0aGF0IGNyZWF0ZWQgdGhpcyBwcm94eSlcbiAgICAgICAgICAgICAgICB0YXJnZXRQcm92aWRlciA9IHJvb3RQcm92aWRlclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRQcm92aWRlci5zZXREYXRhKGZ1bGxQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZSAvLyBJbmRpY2F0ZSB0aGF0IHRoZSBhc3NpZ25tZW50IHdhcyBzdWNjZXNzZnVsXG4gICAgICAgIH0sXG5cbiAgICAgICAgb3duS2V5cyhjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdFByb3ZpZGVyLmdldFRvcExldmVsRGF0YUtleXMocGF0aClcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3VycmVudFRhcmdldCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgZnVsbFBhdGggICAgID0gcGF0aCA/IGAke3BhdGh9LiR7cHJvcGVydHl9YCA6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIG93bmVyRGV0YWlscyA9IHJvb3RQcm92aWRlci5nZXRPd25lck9mRGF0YVByb3BlcnR5KGZ1bGxQYXRoKTtcblxuICAgICAgICAgICAgaWYgKG93bmVyRGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IG93bmVyRGV0YWlscy5vd25lci5nZXREYXRhQ29uZmlnKG93bmVyRGV0YWlscy5wcm9wZXJ0eU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgICAgIDogTmVvLmlzT2JqZWN0KHZhbHVlKSA/IGNyZWF0ZU5lc3RlZFByb3h5KHJvb3RQcm92aWRlciwgZnVsbFBhdGgpIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZSAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3h5IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIG1lcmdlZCwgaGllcmFyY2hpY2FsIGRhdGEgZnJvbSBhIGBzdGF0ZS5Qcm92aWRlcmAgY2hhaW4uXG4gKiBXaGVuIGEgcHJvcGVydHkgaXMgYWNjZXNzZWQgdGhyb3VnaCB0aGlzIHByb3h5IHdoaWxlIGFuIEVmZmVjdCBpcyBydW5uaW5nLCBpdCBhdXRvbWF0aWNhbGx5XG4gKiB0cmFja3MgdGhlIHVuZGVybHlpbmcgY29yZS5Db25maWcgaW5zdGFuY2UgYXMgYSBkZXBlbmRlbmN5LlxuICogQHBhcmFtIHtOZW8uc3RhdGUuUHJvdmlkZXJ9IHByb3ZpZGVyIFRoZSBzdGFydGluZyBzdGF0ZS5Qcm92aWRlci5cbiAqIEByZXR1cm5zIHtQcm94eX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFQcm94eShwcm92aWRlcikge1xuICAgIHJldHVybiBjcmVhdGVOZXN0ZWRQcm94eShwcm92aWRlciwgJycpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9