export const __webpack_esm_id__ = "vendors-examples_component_wrapper_googleMaps_app_mjs-src_container_Panel_mjs";
export const __webpack_esm_ids__ = ["vendors-examples_component_wrapper_googleMaps_app_mjs-src_container_Panel_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./examples/component/wrapper/googleMaps/MainContainer.mjs"
/*!*****************************************************************!*\
  !*** ./examples/component/wrapper/googleMaps/MainContainer.mjs ***!
  \*****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../src/form/field/Number.mjs */ "./src/form/field/Number.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");
/* harmony import */ var _MapComponent_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MapComponent.mjs */ "./examples/component/wrapper/googleMaps/MapComponent.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./examples/component/wrapper/googleMaps/MainContainerController.mjs");







/**
 * @class Neo.examples.component.wrapper.googleMaps.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
    static config = {
        className : 'Neo.examples.component.wrapper.googleMaps.MainContainer',
        autoMount : true,
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
        layout    : {ntype: 'vbox', align: 'stretch'},

        items: [{
            module   : _MapComponent_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
            flex     : 1,
            listeners: {zoomChange: 'onMapZoomChange'},
            reference: 'google-maps-component'
        }, {
            module: _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            flex  : 'none',
            style : {margin: '20px'},
            items : [{
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'onFlyToButtonClick',
                height : 27,
                iconCls: 'fa-solid fa-plane',
                text   : 'Fly to San Fran'
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'onFlyToIcelandButtonClick',
                height : 27,
                iconCls: 'fa-solid fa-plane',
                style  : {marginLeft: '10px'},
                text   : 'Fly to Iceland'
            }, {
                module              : _src_form_field_Number_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                clearToOriginalValue: true,
                labelPosition       : 'inline',
                labelText           : 'zoom',
                listeners           : {change: 'onZoomFieldChange'},
                minValue            : 0,
                maxValue            : 10,
                reference           : 'zoom-field',
                style               : {marginLeft: '10px'},
                value               : 6,
                width               : 100
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'onRemoveMarkerButtonClick',
                height : 27,
                iconCls: 'fa-solid fa-trash',
                mode   : 'hide',
                style  : {marginLeft: '10px'},
                text   : 'Hide marker'
            }]
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./examples/component/wrapper/googleMaps/MainContainerController.mjs"
/*!***************************************************************************!*\
  !*** ./examples/component/wrapper/googleMaps/MainContainerController.mjs ***!
  \***************************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Neo.examples.component.wrapper.googleMaps.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.examples.component.wrapper.googleMaps.MainContainerController'
         * @protected
         */
        className: 'Neo.examples.component.wrapper.googleMaps.MainContainerController'
    }

    /**
     * @param {Object} data
     */
    onFlyToButtonClick(data) {
        this.getReference('google-maps-component').panTo({lat: 37.655, lng: -122.4175})
    }

    /**
     * @param {Object} data
     */
    onFlyToIcelandButtonClick(data) {
        this.getReference('google-maps-component').panTo({ lat: 64.963051,lng: -19.020835})
    }

    /**
     * @param {Object} data
     */
    onMapZoomChange(data) {
        this.getReference('zoom-field').value = data.value
    }

    /**
     * @param {Object} data
     */
    onRemoveMarkerButtonClick(data) {
        let button = data.component,
            map    = this.getReference('google-maps-component');

        if (button.mode === 'hide') {
            button.set({
                iconCls: 'fa fa-location-dot',
                mode   : 'show',
                text   : 'Show marker'
            });

            map.hideMarker('-13')
        } else {
            button.set({
                iconCls: 'fa-solid fa-trash',
                mode   : 'hide',
                text   : 'Hide marker'
            });

            map.showMarker('-13')
        }
    }

    /**
     * @param {Object} data
     */
    onZoomFieldChange(data) {
        this.getReference('google-maps-component').zoom = data.value
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ },

/***/ "./examples/component/wrapper/googleMaps/MapComponent.mjs"
/*!****************************************************************!*\
  !*** ./examples/component/wrapper/googleMaps/MapComponent.mjs ***!
  \****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_component_wrapper_GoogleMaps_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/component/wrapper/GoogleMaps.mjs */ "./src/component/wrapper/GoogleMaps.mjs");
/* harmony import */ var _MarkerDialog_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MarkerDialog.mjs */ "./examples/component/wrapper/googleMaps/MarkerDialog.mjs");



/**
 * @class Neo.examples.component.wrapper.googleMaps.MapComponent
 * @extends Neo.component.wrapper.GoogleMaps
 */
class MapComponent extends _src_component_wrapper_GoogleMaps_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.examples.component.wrapper.googleMaps.MapComponent'
         * @protected
         */
        className: 'Neo.examples.component.wrapper.googleMaps.MapComponent',
        /**
         * Center the map initially to Island
         * @member {Object} center={lat: 64.963051,lng: -19.020835}
         * @reactive
         */
        center: {
            lat: 64.963051,
            lng: -19.020835
        },
        /**
         * Adding a record field
         * @member {Object} markerStore
         * @protected
         */
        markerStore: {
            model: {
                fields: [{
                    name: 'anchorPoint',
                    type: 'Object'
                }, {
                    name: 'icon',
                    type: 'Object'
                }, {
                    name: 'id'
                }, {
                    name: 'label',
                    type: 'String'
                }, {
                    name: 'position',
                    type: 'Object'
                }, {
                    name: 'record',
                    type: 'Object'
                }, {
                    name: 'title',
                    type: 'String'
                }]
            }
        },
        /**
         * Ensure only Island is visible
         * @member {Number} zoom=6
         * @reactive
         */
        zoom: 6
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        this.fetchData()
    }

    /**
     * Ajax request to get the Marker Data
     */
    fetchData() {
        fetch('../../../../examples/component/wrapper/googleMaps/earthquakes.json')
            .then(response => response.json())
            .catch(err => console.log("Can't access  + url, err"))
            .then(data => this.createMarkersAndAddToMarkerStore(data))
    }

    /**
     * Create Marker records from the Server result and add all Markers to the MarkerStore
     * @param {Object} data from earthquake.json
     */
    createMarkersAndAddToMarkerStore(data) {
        let date, icon;

        const markers = data.results.map(record => {
            date = new Date(record.timestamp).toLocaleDateString('default', {
                day   : 'numeric',
                hour  : 'numeric',
                hour12: true,
                minute: 'numeric',
                month : 'short',
                year  : 'numeric'
            });

            icon = this.getIcon(undefined, undefined, record.size);

            // Create a single Marker
            return {
                icon,
                position: {lat: record.latitude, lng: record.longitude},
                record,
                title   : `${date}, ${record.humanReadableLocation}`
            }
        });

        this.markerStore.add(markers)
    }

    /**
     * google.maps.SymbolPaths are not available in the worker.
     * Therefore, we are solving it here
     * @param {String} symbol
     * @returns {Number}
     */
    getType(symbol) {
        return {
            'CIRCLE'               : 0,
            'FORWARD_CLOSED_ARROW' : 1,
            'FORWARD_OPEN_ARROW'   : 2,
            'BACKWARD_CLOSED_ARROW': 3,
            'BACKWARD_OPEN_ARROW'  : 4
        }[symbol]
    }

    /**
     * Create an icon based on color, symbol and size
     * @param {String} color=red
     * @param {'CIRCLE' | 'FORWARD_CLOSED_ARROW' | 'FORWARD_OPEN_ARROW' | 'BACKWARD_CLOSED_ARROW' | 'BACKWARD_OPEN_ARROW'} [symbol=CIRCLE]
     * @param {Number} scaleMultiplier=1
     * @returns {{fillColor: string, path: Number, fillOpacity: number, strokeWeight: number, scale: number, strokeColor: string}}
     */
    getIcon(color='red', symbol='CIRCLE', scaleMultiplier=1) {
        return {
            fillColor   : color,
            fillOpacity : 1.0,
            path        : this.getType(symbol),
            scale       : 10 * scaleMultiplier,
            strokeColor : `dark${color}`,
            strokeWeight: 2
        }
    }

    /**
     * @param {Object} data
     */
    onMarkerClick(data) {
        let me     = this,
            record = data.record.record;

        me.disabled = true;

        me.dialog = Neo.create(_MarkerDialog_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], {
            appName             : me.appName,
            boundaryContainerId : me.id,
            domEvent            : data.domEvent,
            record,

            listeners: {
                close: () => me.disabled = false
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MapComponent));


/***/ },

/***/ "./examples/component/wrapper/googleMaps/MarkerDialog.mjs"
/*!****************************************************************!*\
  !*** ./examples/component/wrapper/googleMaps/MarkerDialog.mjs ***!
  \****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_dialog_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/dialog/Base.mjs */ "./src/dialog/Base.mjs");


/**
 * @class Neo.examples.component.wrapper.googleMaps.MarkerDialog
 * @extends Neo.dialog.Base
 */
class MarkerDialog extends _src_dialog_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        className: 'Neo.examples.component.wrapper.googleMaps.MarkerDialog',

        // turn off dragging and resizing
        draggable           : false,
        resizable           : false,

        // custom property
        record_: null,

        containerConfig: {style: {padding: '10px'}},
        headerConfig: {actions: ['close']},
        // custom config used to align the popup
        offsetConfig: {x: -15,y: -15},

        items: [{
            ntype: 'component',
            cls  : ['detail-container'],
            vdom : {/* here goes the itemTpl */}
        }],

        itemTpl: data => [
            {cls: ['detail-depth'],   html: `Depth: ${data.depth}`},
            {cls: ['detail-date'],    html: `${data.visualDate}`},
            {cls: ['detail-quality'], html: `Quality: ${data.quality}`},
            {cls: ['detail-quality'], html: `Size: ${data.size}`}
        ]
    }

    /**
     * Update the view based on the data
     * @param value
     * @param oldValue
     *
     * @example
     *      depth: 11.9
     *      humanReadableLocation: "19,9 km N af Sigöldustöð"
     *      latitude: 64.35
     *      longitude : -19.173
     *      quality: 53.79
     *      size: 0.9
     *      timestamp: "2017-10-11T18:34:56.000Z"
     */
    afterSetRecord(value, oldValue) {
        let me              = this,
            outputContainer = me.items[0],
            vdom            = outputContainer.vdom;

        value.visualDate = me.calcVisualDate(value.timestamp);

        me.title = `${value.humanReadableLocation} | ${value.size}`;
        vdom.cn  = me.itemTpl(value)
    }

    calcVisualDate(dateString) {
        const
            date   = new Date(dateString),
            day    = date.toLocaleDateString('en-US', {day: 'numeric'}),
            month  = date.toLocaleDateString('en-US', {month: 'short'}),
            year   = date.toLocaleDateString('en-US', {year: 'numeric'}),
            hour   = date.toLocaleTimeString('en-US', {hour: 'numeric', hour12: false}),
            minute = date.toLocaleTimeString('en-US', {minute: 'numeric'});

        return `${day}. ${month} <b>${year}</b> ${hour}:${minute}`
    }

    async onInitVnode(data, automount) {
        super.onInitVnode(data, automount)

        let me = this;

        /**
         * Add to click position
         */
        me.wrapperStyle = {
            top   : me.domEvent.clientY + me.offsetConfig.y + 'px',
            left  : me.domEvent.clientX + me.offsetConfig.x + 'px',
            height: me.height,
            width : me.width
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MarkerDialog));


/***/ },

/***/ "./examples/component/wrapper/googleMaps/app.mjs"
/*!*******************************************************!*\
  !*** ./examples/component/wrapper/googleMaps/app.mjs ***!
  \*******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/component/wrapper/googleMaps/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.component.wrapper.googleMaps'
});



/***/ },

/***/ "./src/component/Label.mjs"
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ },

/***/ "./src/component/wrapper/GoogleMaps.mjs"
/*!**********************************************!*\
  !*** ./src/component/wrapper/GoogleMaps.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/ClassSystem.mjs */ "./src/util/ClassSystem.mjs");
/* harmony import */ var _data_Store_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/Store.mjs */ "./src/data/Store.mjs");




/**
 * @class Neo.component.wrapper.GoogleMaps
 * @extends Neo.component.Base
 */
class GoogleMaps extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.wrapper.GoogleMaps'
         * @protected
         */
        className: 'Neo.component.wrapper.GoogleMaps',
        /**
         * @member {String} ntype='googlemaps'
         * @protected
         */
        ntype: 'googlemaps',
        /**
         * Specify lat & lng for the current focus position
         * @member {Object} center_={lat: -34.397, lng: 150.644}
         * @reactive
         */
        center_: {lat: -34.397, lng: 150.644},
        /**
         * Prefer to use markerStoreConfig instead.
         * @member {Neo.data.Store|Object} markerStore_
         * @protected
         * @reactive
         */
        markerStore_: {
            model: {
                fields: [{
                    name: 'anchorPoint',
                    type: 'Object'
                }, {
                    name: 'icon',
                    type: 'Object'
                }, {
                    name: 'id'
                }, {
                    name: 'label',
                    type: 'String'
                }, {
                    name: 'position',
                    type: 'Object'
                }, {
                    name: 'title',
                    type: 'String'
                }]
            }
        },
        /**
         * @member {Number} zoom_=8
         * @reactive
         */
        zoom_: 8
    }

    /**
     * false hides the default fullscreen control
     * @member {Boolean} fullscreenControl=true
     */
    fullscreenControl = true
    /**
     * Internal flag. Gets set to true once Neo.main.addon.GoogleMaps.create() is finished.
     * @member {Boolean} mapCreated=false
     */
    mapCreated = false
    /**
     * Pass any options to the map instance which are not explicitly defined here
     * @member {Object} mapOptions={}
     */
    mapOptions = {}
    /**
     * @member {Object} markerStoreConfig=null
     */
    markerStoreConfig = null
    /**
     * null => the maximum zoom from the current map type is used instead
     * @member {Number|null} maxZoom=null
     */
    maxZoom = null
    /**
     null => the minimum zoom from the current map type is used instead
     * @member {Number|null} minZoom=null
     */
    minZoom = null
    /**
     * false hides the default zoom control
     * @member {Boolean} zoomControl=true
     */
    zoomControl = true

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.addDomListeners({
            googleMapZoomChange: me.onMapZoomChange,
            googleMarkerClick  : me.parseMarkerClick,
            local              : false,
            scope              : me
        })
    }

    /**
     * @param {Object} data
     * @param {Object} [data.anchorPoint] x & y
     * @param {String} [data.icon]
     * @param {String} data.id
     * @param {String} [data.label]
     * @param {String} data.mapId
     * @param {Object} data.position
     * @param {String} [data.title]
     */
    addMarker(data) {
        let {appName, windowId} = this;

        Neo.main.addon.GoogleMaps.addMarker({
            appName,
            windowId,
            ...data
        })
    }

    /**
     * Triggered after the center config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetCenter(value, oldValue) {
        let {appName, id, windowId} = this;

        if (this.mapCreated) {
            Neo.main.addon.GoogleMaps.setCenter({
                appName,
                id,
                value,
                windowId
            })
        }
    }

    /**
     * Triggered after the markerStore config got changed
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    afterSetMarkerStore(value, oldValue) {
        let me = this;

        value.on({
            load : me.onMarkerStoreLoad,
            scope: me
        });

        if (value.items.length > 0) {
            me.onMarkerStoreLoad()
        }
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        let me = this;

        if (value === false && oldValue !== undefined) {
            me.removeMap()
        }

        super.afterSetMounted(value, oldValue);

        if (value) {
            let opts = {
                appName          : me.appName,
                center           : me.center,
                fullscreenControl: me.fullscreenControl,
                id               : me.id,
                mapOptions       : me.mapOptions,
                maxZoom          : me.maxZoom,
                minZoom          : me.minZoom,
                zoom             : me.zoom,
                zoomControl      : me.zoomControl
            };

            me.timeout(50).then(() => {
                Neo.main.addon.GoogleMaps.create(opts).then(() => {
                    me.mapCreated = true;
                    me.onComponentMounted()
                })
            })
        }
    }

    /**
     * Triggered after the zoom config got changed
     * @param {Number} value
     * @param {Number} oldValue
     * @protected
     */
    afterSetZoom(value, oldValue) {
        let me                      = this,
            {appName, id, windowId} = me;

        if (me.mapCreated) {
            Neo.main.addon.GoogleMaps.setZoom({
                appName,
                id,
                value,
                windowId
            });

            me.fire('zoomChange', {id, value})
        }
    }

    /**
     * Triggered before the markerStore config gets changed.
     * @param {Object} value
     * @param {Object} oldValue
     * @protected
     */
    beforeSetMarkerStore(value, oldValue) {
        oldValue?.destroy();

        return _util_ClassSystem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].beforeSetInstance(value, _data_Store_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], this.markerStoreConfig)
    }

    /**
     * @param {Boolean} updateParentVdom=false
     * @param {Boolean} silent=false
     */
    destroy(updateParentVdom=false, silent=false) {
        this.removeMap();
        super.destroy(updateParentVdom, silent)
    }

    /**
     * @param {String} id
     */
    hideMarker(id) {
        let {appName, windowId} = this;

        Neo.main.addon.GoogleMaps.hideMarker({
            appName,
            id,
            mapId: this.id,
            windowId
        })
    }

    /**
     * Hook to use once the map instance got rendered
     */
    onComponentMounted() {
    }

    /**
     * @param {Object} data
     */
    onMapZoomChange(data) {
        this.zoom = data.value
    }

    /**
     *
     */
    onMarkerStoreLoad() {
        let {appName, id, windowId} = this;

        Neo.main.addon.GoogleMaps.destroyMarkers({
            appName,
            id,
            windowId
        });

        this.markerStore.forEach(item => {
            Neo.main.addon.GoogleMaps.addMarker({
                appName,
                mapId: id,
                windowId,
                ...item
            })
        })
    }

    /**
     * @param {Object} position
     * @param {Number} position.lat
     * @param {Number} position.lng
     */
    panTo(position) {
        let {appName, id, windowId} = this;

        Neo.main.addon.GoogleMaps.panTo({
            appName,
            mapId: id,
            position,
            windowId
        })
    }

    /**
     * Internal function. Use onMarkerClick() or the markerClick event instead
     * @param {Object} data
     * @protected
     */
    parseMarkerClick(data) {
        let me = this;

        data.record = me.markerStore.get(data.id);

        me.onMarkerClick?.(data);

        me.fire('markerClick', {id: me.id, data})
    }

    /**
     *
     */
    removeMap() {
        let {appName, id, windowId} = this;

        Neo.main.addon.GoogleMaps.removeMap({
            appName,
            mapId: id,
            windowId
        })
    }

    /**
     * @param {String} id
     */
    removeMarker(id) {
        let {appName, windowId} = this;

        Neo.main.addon.GoogleMaps.removeMarker({
            appName,
            id,
            mapId: this.id,
            windowId
        })
    }

    /**
     * @param {String} id
     */
    showMarker(id) {
        let {appName, windowId} = this;

        Neo.main.addon.GoogleMaps.showMarker({
            appName,
            id,
            mapId: this.id,
            windowId
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(GoogleMaps));


/***/ },

/***/ "./src/container/Panel.mjs"
/*!*********************************!*\
  !*** ./src/container/Panel.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");



/**
 * An extended Container supporting multiple docked header toolbars
 * @class Neo.container.Panel
 * @extends Neo.container.Base
 */
class Panel extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Panel'
         * @protected
         */
        className: 'Neo.container.Panel',
        /**
         * @member {String} ntype='panel'
         * @protected
         */
        ntype: 'panel',
        /**
         * @member {String[]} baseCls=['neo-panel','neo-container']
         */
        baseCls: ['neo-panel', 'neo-container'],
        /**
         * @member {Object} containerConfig=null
         */
        containerConfig: null,
        /**
         * @member {Object} headerDefaults=null
         */
        headerDefaults: null,
        /**
         * @member {Array} headers=null
         */
        headers: null,
        /**
         * @member {Object} items={ntype: 'vbox', align: 'stretch'}
         * @reactive
         */
        _layout: {
            ntype: 'vbox',
            align: 'stretch'
        },
        /**
         * @member {Boolean} verticalHeadersFirst=false
         */
        verticalHeadersFirst: false
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        if (me.hasHeaders() && me.verticalHeadersFirst === true) {
            me.layout = {
                ntype: 'hbox',
                align: 'stretch'
            };
        }
    }

    /**
     * @param {Object} header the header config
     * @returns {Object}
     */
    static createHeaderConfig(header) {
        if (Neo.typeOf(header) === 'NeoInstance') {
            return header;
        }

        let config = {
            flex: '0 1 auto'
        };

        if (!header.module && !header.ntype) {
            config.cls   = ['neo-panel-header-toolbar', 'neo-toolbar'];
            config.ntype = 'toolbar';
        }

        if (header.text) {
            config.items = [{
                ntype: 'label',
                cls  : ['neo-panel-header-text', 'neo-label'],
                text : header.text
            }];

            delete header.text;
        }

        // assuming all labels inside a Panel Header are meant to be titles -> look the same way
        if (Array.isArray(header.items)) {
            header.items.forEach(item => {
                if (item.ntype === 'label') {
                    item.cls = ['neo-panel-header-text', 'neo-label'];
                }
            });
        }

        return {...config, ...header}
    }

    /**
     *
     */
    createItems() {
        let me              = this,
            containerConfig = me.containerConfig;

        if (!me.hasHeaders()) {
            containerConfig && me.set(containerConfig);
            super.createItems();
        } else {
            let hf                   = me.verticalHeadersFirst === false,
                headers              = me.headers || [],
                bottomHeaders        = headers.filter(header => {return header.dock === (hf ?'bottom': 'right')}),
                leftHeaders          = headers.filter(header => {return header.dock === (hf ?'left'  : 'top')}),
                rightHeaders         = headers.filter(header => {return header.dock === (hf ?'right' : 'bottom')}),
                topHeaders           = headers.filter(header => {return header.dock === (hf ?'top'   : 'left')}),
                hasHorizontalHeaders = bottomHeaders.length > 0 || topHeaders  .length > 0,
                hasVerticalHeaders   = leftHeaders  .length > 0 || rightHeaders.length > 0,
                {items}              = me,
                horizontalItems      = [],
                verticalItems        = [],
                config;

            topHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            if (hasVerticalHeaders && (hf && hasHorizontalHeaders || !hf && hasHorizontalHeaders)) {
                leftHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    ...containerConfig
                };

                horizontalItems.push({...me.headerDefaults, ...config});

                rightHeaders.forEach(header => {
                    horizontalItems.push(Panel.createHeaderConfig(header))
                });

                verticalItems.push({
                    ntype    : 'container',
                    items    : horizontalItems,
                    layout   : {ntype: (hf ? 'hbox' : 'vbox'), align: 'stretch'},
                    reference: 'bodyContainer'
                });
            } else {
                config = {
                    ntype       : 'container',
                    flex        : 1,
                    items,
                    itemDefaults: me.itemDefaults,
                    reference   : 'bodyContainer',
                    ...containerConfig
                };

                verticalItems.push({...me.headerDefaults, ...config})
            }

            bottomHeaders.forEach(header => {
                verticalItems.push(Panel.createHeaderConfig(header))
            });

            me.items = verticalItems;

            me.itemDefaults = null;

            super.createItems()
        }
    }

    /**
     * @returns {Boolean}
     */
    hasHeaders() {
        return Array.isArray(this.headers) && this.headers.length > 0
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Panel));


/***/ },

/***/ "./src/container/Viewport.mjs"
/*!************************************!*\
  !*** ./src/container/Viewport.mjs ***!
  \************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/container/Base.mjs");


/**
 * @class Neo.container.Viewport
 * @extends Neo.container.Base
 */
class Viewport extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.container.Viewport'
         * @protected
         */
        className: 'Neo.container.Viewport',
        /**
         * @member {String} ntype='viewport'
         * @protected
         */
        ntype: 'viewport',
        /**
         * true applies 'neo-body-viewport' to the document.body
         * @member {Boolean} applyBodyCls=true
         */
        applyBodyCls: true,
        /**
         * Assuming that a Viewport is the top level view of your app, and you want to mount it right away.
         * Could be without any items. Use false otherwise.
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {String[]} baseCls=['neo-viewport']
         */
        baseCls: ['neo-viewport'],
        /**
         * true applies a main.addon.ResizeObserver and fires a custom resize event
         * which other instances can subscribe to.
         * @member {Boolean} monitorSize_=false
         * @reactive
         */
        monitorSize_: false
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        let me = this;

        if (value && me.monitorSize) {
            me.addDomListeners([{resize: me.onDomResize, scope: me}])
        }
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let {windowId} = this;

        this.applyBodyCls && Neo.main.DomAccess.applyBodyCls({
            cls: ['neo-body-viewport'],
            windowId
        })
    }

    /**
     * @param {Object} data
     */
    onDomResize(data) {
        this.fire('resize', data)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Viewport));


/***/ },

/***/ "./src/controller/Component.mjs"
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {String|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/toolbar/Base.mjs"
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }

    /**
     * @returns {Object}
     */
    toJSON() {
        return {
            ...super.toJSON(),
            dock: this.dock
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NvbXBvbmVudF93cmFwcGVyX2dvb2dsZU1hcHNfYXBwX21qcy1zcmNfY29udGFpbmVyX1BhbmVsX21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRTtBQUNNO0FBQ0w7QUFDTTtBQUNwQjtBQUNXOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQXVCO0FBQzNDLHFCQUFxQixnQ0FBZ0M7O0FBRXJEO0FBQ0EsdUJBQXVCLHlEQUFZO0FBQ25DO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBLFNBQVM7QUFDVCxvQkFBb0IsNkRBQU87QUFDM0I7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBLHlCQUF5Qiw0REFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5QkFBeUIsNERBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBLGFBQWE7QUFDYixzQ0FBc0Msa0VBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRCQUE0QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpRUFBZSw2QkFBNkIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pFOEI7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFFQUFtQjtBQUN6RDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDBEQUEwRCw0QkFBNEI7QUFDdEY7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdDQUFnQyxRQUFRLDJEQUFTLFdBQVc7QUFDNUQ7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9nb29nbGVNYXBzL01haW5Db250YWluZXIubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9nb29nbGVNYXBzL01haW5Db250YWluZXJDb250cm9sbGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY29tcG9uZW50L3dyYXBwZXIvZ29vZ2xlTWFwcy9NYXBDb21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9nb29nbGVNYXBzL01hcmtlckRpYWxvZy5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NvbXBvbmVudC93cmFwcGVyL2dvb2dsZU1hcHMvYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbXBvbmVudC9MYWJlbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb21wb25lbnQvd3JhcHBlci9Hb29nbGVNYXBzLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRhaW5lci9QYW5lbC5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdG9vbGJhci9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQnV0dG9uICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgTnVtYmVyRmllbGQgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2Zvcm0vZmllbGQvTnVtYmVyLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vLi4vc3JjL3Rvb2xiYXIvQmFzZS5tanMnO1xuaW1wb3J0IFZpZXdwb3J0ICAgICAgICAgICAgICAgIGZyb20gJy4uLy4uLy4uLy4uL3NyYy9jb250YWluZXIvVmlld3BvcnQubWpzJztcbmltcG9ydCBNYXBDb21wb25lbnQgICAgICAgICAgICBmcm9tIFwiLi9NYXBDb21wb25lbnQubWpzXCI7XG5pbXBvcnQgTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIgZnJvbSAnLi9NYWluQ29udGFpbmVyQ29udHJvbGxlci5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY29tcG9uZW50LndyYXBwZXIuZ29vZ2xlTWFwcy5NYWluQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLlZpZXdwb3J0XG4gKi9cbmNsYXNzIE1haW5Db250YWluZXIgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgY2xhc3NOYW1lIDogJ05lby5leGFtcGxlcy5jb21wb25lbnQud3JhcHBlci5nb29nbGVNYXBzLk1haW5Db250YWluZXInLFxuICAgICAgICBhdXRvTW91bnQgOiB0cnVlLFxuICAgICAgICBjb250cm9sbGVyOiBNYWluQ29udGFpbmVyQ29udHJvbGxlcixcbiAgICAgICAgbGF5b3V0ICAgIDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbW9kdWxlICAgOiBNYXBDb21wb25lbnQsXG4gICAgICAgICAgICBmbGV4ICAgICA6IDEsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHt6b29tQ2hhbmdlOiAnb25NYXBab29tQ2hhbmdlJ30sXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdnb29nbGUtbWFwcy1jb21wb25lbnQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZTogVG9vbGJhcixcbiAgICAgICAgICAgIGZsZXggIDogJ25vbmUnLFxuICAgICAgICAgICAgc3R5bGUgOiB7bWFyZ2luOiAnMjBweCd9LFxuICAgICAgICAgICAgaXRlbXMgOiBbe1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiAnb25GbHlUb0J1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiAyNyxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEtc29saWQgZmEtcGxhbmUnLFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdGbHkgdG8gU2FuIEZyYW4nXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6ICdvbkZseVRvSWNlbGFuZEJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiAyNyxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEtc29saWQgZmEtcGxhbmUnLFxuICAgICAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5MZWZ0OiAnMTBweCd9LFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdGbHkgdG8gSWNlbGFuZCdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgIDogTnVtYmVyRmllbGQsXG4gICAgICAgICAgICAgICAgY2xlYXJUb09yaWdpbmFsVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgICAgICA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgICAgICAgOiAnem9vbScsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzICAgICAgICAgICA6IHtjaGFuZ2U6ICdvblpvb21GaWVsZENoYW5nZSd9LFxuICAgICAgICAgICAgICAgIG1pblZhbHVlICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlICAgICAgICAgICAgOiAxMCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2UgICAgICAgICAgIDogJ3pvb20tZmllbGQnLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgICAgICAgICAgICAgOiB7bWFyZ2luTGVmdDogJzEwcHgnfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgICAgICAgIDogNixcbiAgICAgICAgICAgICAgICB3aWR0aCAgICAgICAgICAgICAgIDogMTAwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6ICdvblJlbW92ZU1hcmtlckJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiAyNyxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEtc29saWQgZmEtdHJhc2gnLFxuICAgICAgICAgICAgICAgIG1vZGUgICA6ICdoaWRlJyxcbiAgICAgICAgICAgICAgICBzdHlsZSAgOiB7bWFyZ2luTGVmdDogJzEwcHgnfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnSGlkZSBtYXJrZXInXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFpbkNvbnRhaW5lcik7XG4iLCJpbXBvcnQgQ29tcG9uZW50Q29udHJvbGxlciBmcm9tICcuLi8uLi8uLi8uLi9zcmMvY29udHJvbGxlci9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmV4YW1wbGVzLmNvbXBvbmVudC53cmFwcGVyLmdvb2dsZU1hcHMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyQ29udHJvbGxlciBleHRlbmRzIENvbXBvbmVudENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmV4YW1wbGVzLmNvbXBvbmVudC53cmFwcGVyLmdvb2dsZU1hcHMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5leGFtcGxlcy5jb21wb25lbnQud3JhcHBlci5nb29nbGVNYXBzLk1haW5Db250YWluZXJDb250cm9sbGVyJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25GbHlUb0J1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5nZXRSZWZlcmVuY2UoJ2dvb2dsZS1tYXBzLWNvbXBvbmVudCcpLnBhblRvKHtsYXQ6IDM3LjY1NSwgbG5nOiAtMTIyLjQxNzV9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25GbHlUb0ljZWxhbmRCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIHRoaXMuZ2V0UmVmZXJlbmNlKCdnb29nbGUtbWFwcy1jb21wb25lbnQnKS5wYW5Ubyh7IGxhdDogNjQuOTYzMDUxLGxuZzogLTE5LjAyMDgzNX0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1hcFpvb21DaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgnem9vbS1maWVsZCcpLnZhbHVlID0gZGF0YS52YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25SZW1vdmVNYXJrZXJCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBidXR0b24gPSBkYXRhLmNvbXBvbmVudCxcbiAgICAgICAgICAgIG1hcCAgICA9IHRoaXMuZ2V0UmVmZXJlbmNlKCdnb29nbGUtbWFwcy1jb21wb25lbnQnKTtcblxuICAgICAgICBpZiAoYnV0dG9uLm1vZGUgPT09ICdoaWRlJykge1xuICAgICAgICAgICAgYnV0dG9uLnNldCh7XG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLWxvY2F0aW9uLWRvdCcsXG4gICAgICAgICAgICAgICAgbW9kZSAgIDogJ3Nob3cnLFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdTaG93IG1hcmtlcidcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXAuaGlkZU1hcmtlcignLTEzJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1dHRvbi5zZXQoe1xuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYS1zb2xpZCBmYS10cmFzaCcsXG4gICAgICAgICAgICAgICAgbW9kZSAgIDogJ2hpZGUnLFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdIaWRlIG1hcmtlcidcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXAuc2hvd01hcmtlcignLTEzJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25ab29tRmllbGRDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLmdldFJlZmVyZW5jZSgnZ29vZ2xlLW1hcHMtY29tcG9uZW50Jykuem9vbSA9IGRhdGEudmFsdWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXJDb250cm9sbGVyKTtcbiIsImltcG9ydCBHb29nbGVNYXBzQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnQvd3JhcHBlci9Hb29nbGVNYXBzLm1qcyc7XG5pbXBvcnQgTWFya2VyRGlhbG9nICAgICAgICBmcm9tICcuL01hcmtlckRpYWxvZy5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY29tcG9uZW50LndyYXBwZXIuZ29vZ2xlTWFwcy5NYXBDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQud3JhcHBlci5Hb29nbGVNYXBzXG4gKi9cbmNsYXNzIE1hcENvbXBvbmVudCBleHRlbmRzIEdvb2dsZU1hcHNDb21wb25lbnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmV4YW1wbGVzLmNvbXBvbmVudC53cmFwcGVyLmdvb2dsZU1hcHMuTWFwQ29tcG9uZW50J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZXhhbXBsZXMuY29tcG9uZW50LndyYXBwZXIuZ29vZ2xlTWFwcy5NYXBDb21wb25lbnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2VudGVyIHRoZSBtYXAgaW5pdGlhbGx5IHRvIElzbGFuZFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGNlbnRlcj17bGF0OiA2NC45NjMwNTEsbG5nOiAtMTkuMDIwODM1fVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgbGF0OiA2NC45NjMwNTEsXG4gICAgICAgICAgICBsbmc6IC0xOS4wMjA4MzVcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGluZyBhIHJlY29yZCBmaWVsZFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IG1hcmtlclN0b3JlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1hcmtlclN0b3JlOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FuY2hvclBvaW50JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdCdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpY29uJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdCdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpZCdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnT2JqZWN0J1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JlY29yZCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPYmplY3QnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU3RyaW5nJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnN1cmUgb25seSBJc2xhbmQgaXMgdmlzaWJsZVxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHpvb209NlxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHpvb206IDZcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICB0aGlzLmZldGNoRGF0YSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWpheCByZXF1ZXN0IHRvIGdldCB0aGUgTWFya2VyIERhdGFcbiAgICAgKi9cbiAgICBmZXRjaERhdGEoKSB7XG4gICAgICAgIGZldGNoKCcuLi8uLi8uLi8uLi9leGFtcGxlcy9jb21wb25lbnQvd3JhcHBlci9nb29nbGVNYXBzL2VhcnRocXVha2VzLmpzb24nKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZyhcIkNhbid0IGFjY2VzcyAgKyB1cmwsIGVyclwiKSlcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4gdGhpcy5jcmVhdGVNYXJrZXJzQW5kQWRkVG9NYXJrZXJTdG9yZShkYXRhKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgTWFya2VyIHJlY29yZHMgZnJvbSB0aGUgU2VydmVyIHJlc3VsdCBhbmQgYWRkIGFsbCBNYXJrZXJzIHRvIHRoZSBNYXJrZXJTdG9yZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIGZyb20gZWFydGhxdWFrZS5qc29uXG4gICAgICovXG4gICAgY3JlYXRlTWFya2Vyc0FuZEFkZFRvTWFya2VyU3RvcmUoZGF0YSkge1xuICAgICAgICBsZXQgZGF0ZSwgaWNvbjtcblxuICAgICAgICBjb25zdCBtYXJrZXJzID0gZGF0YS5yZXN1bHRzLm1hcChyZWNvcmQgPT4ge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHJlY29yZC50aW1lc3RhbXApLnRvTG9jYWxlRGF0ZVN0cmluZygnZGVmYXVsdCcsIHtcbiAgICAgICAgICAgICAgICBkYXkgICA6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBob3VyICA6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBob3VyMTI6IHRydWUsXG4gICAgICAgICAgICAgICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgbW9udGggOiAnc2hvcnQnLFxuICAgICAgICAgICAgICAgIHllYXIgIDogJ251bWVyaWMnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWNvbiA9IHRoaXMuZ2V0SWNvbih1bmRlZmluZWQsIHVuZGVmaW5lZCwgcmVjb3JkLnNpemUpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzaW5nbGUgTWFya2VyXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtsYXQ6IHJlY29yZC5sYXRpdHVkZSwgbG5nOiByZWNvcmQubG9uZ2l0dWRlfSxcbiAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgdGl0bGUgICA6IGAke2RhdGV9LCAke3JlY29yZC5odW1hblJlYWRhYmxlTG9jYXRpb259YFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1hcmtlclN0b3JlLmFkZChtYXJrZXJzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdvb2dsZS5tYXBzLlN5bWJvbFBhdGhzIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSB3b3JrZXIuXG4gICAgICogVGhlcmVmb3JlLCB3ZSBhcmUgc29sdmluZyBpdCBoZXJlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0VHlwZShzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdDSVJDTEUnICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgJ0ZPUldBUkRfQ0xPU0VEX0FSUk9XJyA6IDEsXG4gICAgICAgICAgICAnRk9SV0FSRF9PUEVOX0FSUk9XJyAgIDogMixcbiAgICAgICAgICAgICdCQUNLV0FSRF9DTE9TRURfQVJST1cnOiAzLFxuICAgICAgICAgICAgJ0JBQ0tXQVJEX09QRU5fQVJST1cnICA6IDRcbiAgICAgICAgfVtzeW1ib2xdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGljb24gYmFzZWQgb24gY29sb3IsIHN5bWJvbCBhbmQgc2l6ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvcj1yZWRcbiAgICAgKiBAcGFyYW0geydDSVJDTEUnIHwgJ0ZPUldBUkRfQ0xPU0VEX0FSUk9XJyB8ICdGT1JXQVJEX09QRU5fQVJST1cnIHwgJ0JBQ0tXQVJEX0NMT1NFRF9BUlJPVycgfCAnQkFDS1dBUkRfT1BFTl9BUlJPVyd9IFtzeW1ib2w9Q0lSQ0xFXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZU11bHRpcGxpZXI9MVxuICAgICAqIEByZXR1cm5zIHt7ZmlsbENvbG9yOiBzdHJpbmcsIHBhdGg6IE51bWJlciwgZmlsbE9wYWNpdHk6IG51bWJlciwgc3Ryb2tlV2VpZ2h0OiBudW1iZXIsIHNjYWxlOiBudW1iZXIsIHN0cm9rZUNvbG9yOiBzdHJpbmd9fVxuICAgICAqL1xuICAgIGdldEljb24oY29sb3I9J3JlZCcsIHN5bWJvbD0nQ0lSQ0xFJywgc2NhbGVNdWx0aXBsaWVyPTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGxDb2xvciAgIDogY29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eSA6IDEuMCxcbiAgICAgICAgICAgIHBhdGggICAgICAgIDogdGhpcy5nZXRUeXBlKHN5bWJvbCksXG4gICAgICAgICAgICBzY2FsZSAgICAgICA6IDEwICogc2NhbGVNdWx0aXBsaWVyLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3IgOiBgZGFyayR7Y29sb3J9YCxcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbk1hcmtlckNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmQgPSBkYXRhLnJlY29yZC5yZWNvcmQ7XG5cbiAgICAgICAgbWUuZGlzYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIG1lLmRpYWxvZyA9IE5lby5jcmVhdGUoTWFya2VyRGlhbG9nLCB7XG4gICAgICAgICAgICBhcHBOYW1lICAgICAgICAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQgOiBtZS5pZCxcbiAgICAgICAgICAgIGRvbUV2ZW50ICAgICAgICAgICAgOiBkYXRhLmRvbUV2ZW50LFxuICAgICAgICAgICAgcmVjb3JkLFxuXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgICAgICBjbG9zZTogKCkgPT4gbWUuZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFwQ29tcG9uZW50KTtcbiIsImltcG9ydCBEaWFsb2dCYXNlIGZyb20gJy4uLy4uLy4uLy4uL3NyYy9kaWFsb2cvQmFzZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY29tcG9uZW50LndyYXBwZXIuZ29vZ2xlTWFwcy5NYXJrZXJEaWFsb2dcbiAqIEBleHRlbmRzIE5lby5kaWFsb2cuQmFzZVxuICovXG5jbGFzcyBNYXJrZXJEaWFsb2cgZXh0ZW5kcyBEaWFsb2dCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZXhhbXBsZXMuY29tcG9uZW50LndyYXBwZXIuZ29vZ2xlTWFwcy5NYXJrZXJEaWFsb2cnLFxuXG4gICAgICAgIC8vIHR1cm4gb2ZmIGRyYWdnaW5nIGFuZCByZXNpemluZ1xuICAgICAgICBkcmFnZ2FibGUgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHJlc2l6YWJsZSAgICAgICAgICAgOiBmYWxzZSxcblxuICAgICAgICAvLyBjdXN0b20gcHJvcGVydHlcbiAgICAgICAgcmVjb3JkXzogbnVsbCxcblxuICAgICAgICBjb250YWluZXJDb25maWc6IHtzdHlsZToge3BhZGRpbmc6ICcxMHB4J319LFxuICAgICAgICBoZWFkZXJDb25maWc6IHthY3Rpb25zOiBbJ2Nsb3NlJ119LFxuICAgICAgICAvLyBjdXN0b20gY29uZmlnIHVzZWQgdG8gYWxpZ24gdGhlIHBvcHVwXG4gICAgICAgIG9mZnNldENvbmZpZzoge3g6IC0xNSx5OiAtMTV9LFxuXG4gICAgICAgIGl0ZW1zOiBbe1xuICAgICAgICAgICAgbnR5cGU6ICdjb21wb25lbnQnLFxuICAgICAgICAgICAgY2xzICA6IFsnZGV0YWlsLWNvbnRhaW5lciddLFxuICAgICAgICAgICAgdmRvbSA6IHsvKiBoZXJlIGdvZXMgdGhlIGl0ZW1UcGwgKi99XG4gICAgICAgIH1dLFxuXG4gICAgICAgIGl0ZW1UcGw6IGRhdGEgPT4gW1xuICAgICAgICAgICAge2NsczogWydkZXRhaWwtZGVwdGgnXSwgICBodG1sOiBgRGVwdGg6ICR7ZGF0YS5kZXB0aH1gfSxcbiAgICAgICAgICAgIHtjbHM6IFsnZGV0YWlsLWRhdGUnXSwgICAgaHRtbDogYCR7ZGF0YS52aXN1YWxEYXRlfWB9LFxuICAgICAgICAgICAge2NsczogWydkZXRhaWwtcXVhbGl0eSddLCBodG1sOiBgUXVhbGl0eTogJHtkYXRhLnF1YWxpdHl9YH0sXG4gICAgICAgICAgICB7Y2xzOiBbJ2RldGFpbC1xdWFsaXR5J10sIGh0bWw6IGBTaXplOiAke2RhdGEuc2l6ZX1gfVxuICAgICAgICBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB2aWV3IGJhc2VkIG9uIHRoZSBkYXRhXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIG9sZFZhbHVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAgZGVwdGg6IDExLjlcbiAgICAgKiAgICAgIGh1bWFuUmVhZGFibGVMb2NhdGlvbjogXCIxOSw5IGttIE4gYWYgU2lnw7ZsZHVzdMO2w7BcIlxuICAgICAqICAgICAgbGF0aXR1ZGU6IDY0LjM1XG4gICAgICogICAgICBsb25naXR1ZGUgOiAtMTkuMTczXG4gICAgICogICAgICBxdWFsaXR5OiA1My43OVxuICAgICAqICAgICAgc2l6ZTogMC45XG4gICAgICogICAgICB0aW1lc3RhbXA6IFwiMjAxNy0xMC0xMVQxODozNDo1Ni4wMDBaXCJcbiAgICAgKi9cbiAgICBhZnRlclNldFJlY29yZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBvdXRwdXRDb250YWluZXIgPSBtZS5pdGVtc1swXSxcbiAgICAgICAgICAgIHZkb20gICAgICAgICAgICA9IG91dHB1dENvbnRhaW5lci52ZG9tO1xuXG4gICAgICAgIHZhbHVlLnZpc3VhbERhdGUgPSBtZS5jYWxjVmlzdWFsRGF0ZSh2YWx1ZS50aW1lc3RhbXApO1xuXG4gICAgICAgIG1lLnRpdGxlID0gYCR7dmFsdWUuaHVtYW5SZWFkYWJsZUxvY2F0aW9ufSB8ICR7dmFsdWUuc2l6ZX1gO1xuICAgICAgICB2ZG9tLmNuICA9IG1lLml0ZW1UcGwodmFsdWUpXG4gICAgfVxuXG4gICAgY2FsY1Zpc3VhbERhdGUoZGF0ZVN0cmluZykge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgZGF0ZSAgID0gbmV3IERhdGUoZGF0ZVN0cmluZyksXG4gICAgICAgICAgICBkYXkgICAgPSBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7ZGF5OiAnbnVtZXJpYyd9KSxcbiAgICAgICAgICAgIG1vbnRoICA9IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHttb250aDogJ3Nob3J0J30pLFxuICAgICAgICAgICAgeWVhciAgID0gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywge3llYXI6ICdudW1lcmljJ30pLFxuICAgICAgICAgICAgaG91ciAgID0gZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywge2hvdXI6ICdudW1lcmljJywgaG91cjEyOiBmYWxzZX0pLFxuICAgICAgICAgICAgbWludXRlID0gZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywge21pbnV0ZTogJ251bWVyaWMnfSk7XG5cbiAgICAgICAgcmV0dXJuIGAke2RheX0uICR7bW9udGh9IDxiPiR7eWVhcn08L2I+ICR7aG91cn06JHttaW51dGV9YFxuICAgIH1cblxuICAgIGFzeW5jIG9uSW5pdFZub2RlKGRhdGEsIGF1dG9tb3VudCkge1xuICAgICAgICBzdXBlci5vbkluaXRWbm9kZShkYXRhLCBhdXRvbW91bnQpXG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIHRvIGNsaWNrIHBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBtZS53cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgICAgICB0b3AgICA6IG1lLmRvbUV2ZW50LmNsaWVudFkgKyBtZS5vZmZzZXRDb25maWcueSArICdweCcsXG4gICAgICAgICAgICBsZWZ0ICA6IG1lLmRvbUV2ZW50LmNsaWVudFggKyBtZS5vZmZzZXRDb25maWcueCArICdweCcsXG4gICAgICAgICAgICBoZWlnaHQ6IG1lLmhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoIDogbWUud2lkdGhcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTWFya2VyRGlhbG9nKTtcbiIsImltcG9ydCBNYWluQ29udGFpbmVyIGZyb20gJy4vTWFpbkNvbnRhaW5lci5tanMnO1xuXG5leHBvcnQgY29uc3Qgb25TdGFydCA9ICgpID0+IE5lby5hcHAoe1xuICAgIG1haW5WaWV3OiBNYWluQ29udGFpbmVyLFxuICAgIG5hbWUgICAgOiAnTmVvLmV4YW1wbGVzLmNvbXBvbmVudC53cmFwcGVyLmdvb2dsZU1hcHMnXG59KTtcblxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjbGFzcyB0byByZW5kZXIgYSBsYWJlbCB3aXRoIGEgdGV4dFxuICogQGNsYXNzIE5lby5jb21wb25lbnQuTGFiZWxcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBMYWJlbCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkxhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkxhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWxhYmVsJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWxhYmVsJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRhZz0nbGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0YWc6ICdsYWJlbCdcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExhYmVsKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgZnJvbSAnLi4vLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDbGFzc1N5c3RlbVV0aWwgZnJvbSAnLi4vLi4vdXRpbC9DbGFzc1N5c3RlbS5tanMnO1xuaW1wb3J0IFN0b3JlICAgICAgICAgICBmcm9tICcuLi8uLi9kYXRhL1N0b3JlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb21wb25lbnQud3JhcHBlci5Hb29nbGVNYXBzXG4gKiBAZXh0ZW5kcyBOZW8uY29tcG9uZW50LkJhc2VcbiAqL1xuY2xhc3MgR29vZ2xlTWFwcyBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbXBvbmVudC53cmFwcGVyLkdvb2dsZU1hcHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb21wb25lbnQud3JhcHBlci5Hb29nbGVNYXBzJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2dvb2dsZW1hcHMnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnZ29vZ2xlbWFwcycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGxhdCAmIGxuZyBmb3IgdGhlIGN1cnJlbnQgZm9jdXMgcG9zaXRpb25cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjZW50ZXJfPXtsYXQ6IC0zNC4zOTcsIGxuZzogMTUwLjY0NH1cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjZW50ZXJfOiB7bGF0OiAtMzQuMzk3LCBsbmc6IDE1MC42NDR9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJlZmVyIHRvIHVzZSBtYXJrZXJTdG9yZUNvbmZpZyBpbnN0ZWFkLlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uZGF0YS5TdG9yZXxPYmplY3R9IG1hcmtlclN0b3JlX1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbWFya2VyU3RvcmVfOiB7XG4gICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgIGZpZWxkczogW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2FuY2hvclBvaW50JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdCdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpY29uJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdCdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpZCdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTdHJpbmcnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnT2JqZWN0J1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1N0cmluZydcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSB6b29tXz04XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgem9vbV86IDhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmYWxzZSBoaWRlcyB0aGUgZGVmYXVsdCBmdWxsc2NyZWVuIGNvbnRyb2xcbiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBmdWxsc2NyZWVuQ29udHJvbD10cnVlXG4gICAgICovXG4gICAgZnVsbHNjcmVlbkNvbnRyb2wgPSB0cnVlXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZmxhZy4gR2V0cyBzZXQgdG8gdHJ1ZSBvbmNlIE5lby5tYWluLmFkZG9uLkdvb2dsZU1hcHMuY3JlYXRlKCkgaXMgZmluaXNoZWQuXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbWFwQ3JlYXRlZD1mYWxzZVxuICAgICAqL1xuICAgIG1hcENyZWF0ZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFBhc3MgYW55IG9wdGlvbnMgdG8gdGhlIG1hcCBpbnN0YW5jZSB3aGljaCBhcmUgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBoZXJlXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtYXBPcHRpb25zPXt9XG4gICAgICovXG4gICAgbWFwT3B0aW9ucyA9IHt9XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBtYXJrZXJTdG9yZUNvbmZpZz1udWxsXG4gICAgICovXG4gICAgbWFya2VyU3RvcmVDb25maWcgPSBudWxsXG4gICAgLyoqXG4gICAgICogbnVsbCA9PiB0aGUgbWF4aW11bSB6b29tIGZyb20gdGhlIGN1cnJlbnQgbWFwIHR5cGUgaXMgdXNlZCBpbnN0ZWFkXG4gICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IG1heFpvb209bnVsbFxuICAgICAqL1xuICAgIG1heFpvb20gPSBudWxsXG4gICAgLyoqXG4gICAgIG51bGwgPT4gdGhlIG1pbmltdW0gem9vbSBmcm9tIHRoZSBjdXJyZW50IG1hcCB0eXBlIGlzIHVzZWQgaW5zdGVhZFxuICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSBtaW5ab29tPW51bGxcbiAgICAgKi9cbiAgICBtaW5ab29tID0gbnVsbFxuICAgIC8qKlxuICAgICAqIGZhbHNlIGhpZGVzIHRoZSBkZWZhdWx0IHpvb20gY29udHJvbFxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHpvb21Db250cm9sPXRydWVcbiAgICAgKi9cbiAgICB6b29tQ29udHJvbCA9IHRydWVcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIGdvb2dsZU1hcFpvb21DaGFuZ2U6IG1lLm9uTWFwWm9vbUNoYW5nZSxcbiAgICAgICAgICAgIGdvb2dsZU1hcmtlckNsaWNrICA6IG1lLnBhcnNlTWFya2VyQ2xpY2ssXG4gICAgICAgICAgICBsb2NhbCAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgICAgICA6IG1lXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGEuYW5jaG9yUG9pbnRdIHggJiB5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkYXRhLmljb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RhdGEubGFiZWxdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubWFwSWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YS5wb3NpdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YS50aXRsZV1cbiAgICAgKi9cbiAgICBhZGRNYXJrZXIoZGF0YSkge1xuICAgICAgICBsZXQge2FwcE5hbWUsIHdpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uR29vZ2xlTWFwcy5hZGRNYXJrZXIoe1xuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICAgICAgLi4uZGF0YVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgY2VudGVyIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldENlbnRlcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHthcHBOYW1lLCBpZCwgd2luZG93SWR9ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5tYXBDcmVhdGVkKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5Hb29nbGVNYXBzLnNldENlbnRlcih7XG4gICAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWFya2VyU3RvcmUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TWFya2VyU3RvcmUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgdmFsdWUub24oe1xuICAgICAgICAgICAgbG9hZCA6IG1lLm9uTWFya2VyU3RvcmVMb2FkLFxuICAgICAgICAgICAgc2NvcGU6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh2YWx1ZS5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZS5vbk1hcmtlclN0b3JlTG9hZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgJiYgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWUucmVtb3ZlTWFwKClcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgICAgICA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY2VudGVyICAgICAgICAgICA6IG1lLmNlbnRlcixcbiAgICAgICAgICAgICAgICBmdWxsc2NyZWVuQ29udHJvbDogbWUuZnVsbHNjcmVlbkNvbnRyb2wsXG4gICAgICAgICAgICAgICAgaWQgICAgICAgICAgICAgICA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIG1hcE9wdGlvbnMgICAgICAgOiBtZS5tYXBPcHRpb25zLFxuICAgICAgICAgICAgICAgIG1heFpvb20gICAgICAgICAgOiBtZS5tYXhab29tLFxuICAgICAgICAgICAgICAgIG1pblpvb20gICAgICAgICAgOiBtZS5taW5ab29tLFxuICAgICAgICAgICAgICAgIHpvb20gICAgICAgICAgICAgOiBtZS56b29tLFxuICAgICAgICAgICAgICAgIHpvb21Db250cm9sICAgICAgOiBtZS56b29tQ29udHJvbFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbWUudGltZW91dCg1MCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uR29vZ2xlTWFwcy5jcmVhdGUob3B0cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm1hcENyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5vbkNvbXBvbmVudE1vdW50ZWQoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB6b29tIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFpvb20odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZSwgaWQsIHdpbmRvd0lkfSA9IG1lO1xuXG4gICAgICAgIGlmIChtZS5tYXBDcmVhdGVkKSB7XG4gICAgICAgICAgICBOZW8ubWFpbi5hZGRvbi5Hb29nbGVNYXBzLnNldFpvb20oe1xuICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5maXJlKCd6b29tQ2hhbmdlJywge2lkLCB2YWx1ZX0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYmVmb3JlIHRoZSBtYXJrZXJTdG9yZSBjb25maWcgZ2V0cyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXRNYXJrZXJTdG9yZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWU/LmRlc3Ryb3koKTtcblxuICAgICAgICByZXR1cm4gQ2xhc3NTeXN0ZW1VdGlsLmJlZm9yZVNldEluc3RhbmNlKHZhbHVlLCBTdG9yZSwgdGhpcy5tYXJrZXJTdG9yZUNvbmZpZylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZVBhcmVudFZkb209ZmFsc2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNpbGVudD1mYWxzZVxuICAgICAqL1xuICAgIGRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbT1mYWxzZSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTWFwKCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kodXBkYXRlUGFyZW50VmRvbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqL1xuICAgIGhpZGVNYXJrZXIoaWQpIHtcbiAgICAgICAgbGV0IHthcHBOYW1lLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkdvb2dsZU1hcHMuaGlkZU1hcmtlcih7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBtYXBJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayB0byB1c2Ugb25jZSB0aGUgbWFwIGluc3RhbmNlIGdvdCByZW5kZXJlZFxuICAgICAqL1xuICAgIG9uQ29tcG9uZW50TW91bnRlZCgpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTWFwWm9vbUNoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuem9vbSA9IGRhdGEudmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uTWFya2VyU3RvcmVMb2FkKCkge1xuICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkdvb2dsZU1hcHMuZGVzdHJveU1hcmtlcnMoe1xuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYXJrZXJTdG9yZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgTmVvLm1haW4uYWRkb24uR29vZ2xlTWFwcy5hZGRNYXJrZXIoe1xuICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgbWFwSWQ6IGlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkLFxuICAgICAgICAgICAgICAgIC4uLml0ZW1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uLmxhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbi5sbmdcbiAgICAgKi9cbiAgICBwYW5Ubyhwb3NpdGlvbikge1xuICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkdvb2dsZU1hcHMucGFuVG8oe1xuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIG1hcElkOiBpZCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbi4gVXNlIG9uTWFya2VyQ2xpY2soKSBvciB0aGUgbWFya2VyQ2xpY2sgZXZlbnQgaW5zdGVhZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHBhcnNlTWFya2VyQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGRhdGEucmVjb3JkID0gbWUubWFya2VyU3RvcmUuZ2V0KGRhdGEuaWQpO1xuXG4gICAgICAgIG1lLm9uTWFya2VyQ2xpY2s/LihkYXRhKTtcblxuICAgICAgICBtZS5maXJlKCdtYXJrZXJDbGljaycsIHtpZDogbWUuaWQsIGRhdGF9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlTWFwKCkge1xuICAgICAgICBsZXQge2FwcE5hbWUsIGlkLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkdvb2dsZU1hcHMucmVtb3ZlTWFwKHtcbiAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICBtYXBJZDogaWQsXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqL1xuICAgIHJlbW92ZU1hcmtlcihpZCkge1xuICAgICAgICBsZXQge2FwcE5hbWUsIHdpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgTmVvLm1haW4uYWRkb24uR29vZ2xlTWFwcy5yZW1vdmVNYXJrZXIoe1xuICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbWFwSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB3aW5kb3dJZFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqL1xuICAgIHNob3dNYXJrZXIoaWQpIHtcbiAgICAgICAgbGV0IHthcHBOYW1lLCB3aW5kb3dJZH0gPSB0aGlzO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkdvb2dsZU1hcHMuc2hvd01hcmtlcih7XG4gICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBtYXBJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhHb29nbGVNYXBzKTtcbiIsImltcG9ydCBDb250YWluZXIgZnJvbSAnLi9CYXNlLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgIGZyb20gJy4uL3Rvb2xiYXIvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFuIGV4dGVuZGVkIENvbnRhaW5lciBzdXBwb3J0aW5nIG11bHRpcGxlIGRvY2tlZCBoZWFkZXIgdG9vbGJhcnNcbiAqIEBjbGFzcyBOZW8uY29udGFpbmVyLlBhbmVsXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgUGFuZWwgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmNvbnRhaW5lci5QYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRhaW5lci5QYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwYW5lbCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwYW5lbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1wYW5lbCcsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tcGFuZWwnLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBjb250YWluZXJDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbmVyQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBoZWFkZXJEZWZhdWx0cz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJEZWZhdWx0czogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5fSBoZWFkZXJzPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1zPXtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIF9sYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlOiAndmJveCcsXG4gICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB2ZXJ0aWNhbEhlYWRlcnNGaXJzdD1mYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdmVydGljYWxIZWFkZXJzRmlyc3Q6IGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUuaGFzSGVhZGVycygpICYmIG1lLnZlcnRpY2FsSGVhZGVyc0ZpcnN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZS5sYXlvdXQgPSB7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdoYm94JyxcbiAgICAgICAgICAgICAgICBhbGlnbjogJ3N0cmV0Y2gnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlciB0aGUgaGVhZGVyIGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpIHtcbiAgICAgICAgaWYgKE5lby50eXBlT2YoaGVhZGVyKSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgICAgICBmbGV4OiAnMCAxIGF1dG8nXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFoZWFkZXIubW9kdWxlICYmICFoZWFkZXIubnR5cGUpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jbHMgICA9IFsnbmVvLXBhbmVsLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ107XG4gICAgICAgICAgICBjb25maWcubnR5cGUgPSAndG9vbGJhcic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhZGVyLnRleHQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5pdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgbnR5cGU6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLXBhbmVsLWhlYWRlci10ZXh0JywgJ25lby1sYWJlbCddLFxuICAgICAgICAgICAgICAgIHRleHQgOiBoZWFkZXIudGV4dFxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXIudGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc3VtaW5nIGFsbCBsYWJlbHMgaW5zaWRlIGEgUGFuZWwgSGVhZGVyIGFyZSBtZWFudCB0byBiZSB0aXRsZXMgLT4gbG9vayB0aGUgc2FtZSB3YXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyLml0ZW1zKSkge1xuICAgICAgICAgICAgaGVhZGVyLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ubnR5cGUgPT09ICdsYWJlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbHMgPSBbJ25lby1wYW5lbC1oZWFkZXItdGV4dCcsICduZW8tbGFiZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7Li4uY29uZmlnLCAuLi5oZWFkZXJ9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb250YWluZXJDb25maWcgPSBtZS5jb250YWluZXJDb25maWc7XG5cbiAgICAgICAgaWYgKCFtZS5oYXNIZWFkZXJzKCkpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNvbmZpZyAmJiBtZS5zZXQoY29udGFpbmVyQ29uZmlnKTtcbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaGYgICAgICAgICAgICAgICAgICAgPSBtZS52ZXJ0aWNhbEhlYWRlcnNGaXJzdCA9PT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVycyAgICAgICAgICAgICAgPSBtZS5oZWFkZXJzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGJvdHRvbUhlYWRlcnMgICAgICAgID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtyZXR1cm4gaGVhZGVyLmRvY2sgPT09IChoZiA/J2JvdHRvbSc6ICdyaWdodCcpfSksXG4gICAgICAgICAgICAgICAgbGVmdEhlYWRlcnMgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8nbGVmdCcgIDogJ3RvcCcpfSksXG4gICAgICAgICAgICAgICAgcmlnaHRIZWFkZXJzICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ncmlnaHQnIDogJ2JvdHRvbScpfSksXG4gICAgICAgICAgICAgICAgdG9wSGVhZGVycyAgICAgICAgICAgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge3JldHVybiBoZWFkZXIuZG9jayA9PT0gKGhmID8ndG9wJyAgIDogJ2xlZnQnKX0pLFxuICAgICAgICAgICAgICAgIGhhc0hvcml6b250YWxIZWFkZXJzID0gYm90dG9tSGVhZGVycy5sZW5ndGggPiAwIHx8IHRvcEhlYWRlcnMgIC5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIGhhc1ZlcnRpY2FsSGVhZGVycyAgID0gbGVmdEhlYWRlcnMgIC5sZW5ndGggPiAwIHx8IHJpZ2h0SGVhZGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgIHtpdGVtc30gICAgICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEl0ZW1zICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEl0ZW1zICAgICAgICA9IFtdLFxuICAgICAgICAgICAgICAgIGNvbmZpZztcblxuICAgICAgICAgICAgdG9wSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNWZXJ0aWNhbEhlYWRlcnMgJiYgKGhmICYmIGhhc0hvcml6b250YWxIZWFkZXJzIHx8ICFoZiAmJiBoYXNIb3Jpem9udGFsSGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0SGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBudHlwZSAgICAgICA6ICdjb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICBmbGV4ICAgICAgICA6IDEsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRGVmYXVsdHM6IG1lLml0ZW1EZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29udGFpbmVyQ29uZmlnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJdGVtcy5wdXNoKHsuLi5tZS5oZWFkZXJEZWZhdWx0cywgLi4uY29uZmlnfSk7XG5cbiAgICAgICAgICAgICAgICByaWdodEhlYWRlcnMuZm9yRWFjaChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsSXRlbXMucHVzaChQYW5lbC5jcmVhdGVIZWFkZXJDb25maWcoaGVhZGVyKSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG50eXBlICAgIDogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zICAgIDogaG9yaXpvbnRhbEl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQgICA6IHtudHlwZTogKGhmID8gJ2hib3gnIDogJ3Zib3gnKSwgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogJ2JvZHlDb250YWluZXInXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgICAgOiAnY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZmxleCAgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbURlZmF1bHRzOiBtZS5pdGVtRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZSAgIDogJ2JvZHlDb250YWluZXInLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250YWluZXJDb25maWdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKHsuLi5tZS5oZWFkZXJEZWZhdWx0cywgLi4uY29uZmlnfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm90dG9tSGVhZGVycy5mb3JFYWNoKGhlYWRlciA9PiB7XG4gICAgICAgICAgICAgICAgdmVydGljYWxJdGVtcy5wdXNoKFBhbmVsLmNyZWF0ZUhlYWRlckNvbmZpZyhoZWFkZXIpKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zID0gdmVydGljYWxJdGVtcztcblxuICAgICAgICAgICAgbWUuaXRlbURlZmF1bHRzID0gbnVsbDtcblxuICAgICAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzSGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5oZWFkZXJzKSAmJiB0aGlzLmhlYWRlcnMubGVuZ3RoID4gMFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUGFuZWwpO1xuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250YWluZXIuVmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb250YWluZXIuVmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndmlld3BvcnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAndmlld3BvcnQnLFxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBhcHBsaWVzICduZW8tYm9keS12aWV3cG9ydCcgdG8gdGhlIGRvY3VtZW50LmJvZHlcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXBwbHlCb2R5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5Qm9keUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc3VtaW5nIHRoYXQgYSBWaWV3cG9ydCBpcyB0aGUgdG9wIGxldmVsIHZpZXcgb2YgeW91ciBhcHAsIGFuZCB5b3Ugd2FudCB0byBtb3VudCBpdCByaWdodCBhd2F5LlxuICAgICAgICAgKiBDb3VsZCBiZSB3aXRob3V0IGFueSBpdGVtcy4gVXNlIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXZpZXdwb3J0J11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLXZpZXdwb3J0J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGFwcGxpZXMgYSBtYWluLmFkZG9uLlJlc2l6ZU9ic2VydmVyIGFuZCBmaXJlcyBhIGN1c3RvbSByZXNpemUgZXZlbnRcbiAgICAgICAgICogd2hpY2ggb3RoZXIgaW5zdGFuY2VzIGNhbiBzdWJzY3JpYmUgdG8uXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vbml0b3JTaXplXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIG1vbml0b3JTaXplXzogZmFsc2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1vdW50ZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBtZS5tb25pdG9yU2l6ZSkge1xuICAgICAgICAgICAgbWUuYWRkRG9tTGlzdGVuZXJzKFt7cmVzaXplOiBtZS5vbkRvbVJlc2l6ZSwgc2NvcGU6IG1lfV0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIHN1cGVyLm9uQ29uc3RydWN0ZWQoKTtcblxuICAgICAgICBsZXQge3dpbmRvd0lkfSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5hcHBseUJvZHlDbHMgJiYgTmVvLm1haW4uRG9tQWNjZXNzLmFwcGx5Qm9keUNscyh7XG4gICAgICAgICAgICBjbHM6IFsnbmVvLWJvZHktdmlld3BvcnQnXSxcbiAgICAgICAgICAgIHdpbmRvd0lkXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRvbVJlc2l6ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgncmVzaXplJywgZGF0YSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFZpZXdwb3J0KTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1jb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1jb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVmZXJlbmNlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlZmVyZW5jZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gd2luZG93SWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWQ6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbXBvbmVudH0gPSBtZTtcblxuICAgICAgICBtZS5yZWZlcmVuY2VzID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFBhcmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlck5hbWVcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBbY29tcG9uZW50XVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8Qm9vbGVhbnxudWxsfVxuICAgICAqL1xuICAgIGdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lLFxuICAgICAgICAgICAgaGFuZGxlckNiO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIHRocyBmdW5jdGlvbiAqbmFtZSogZmlyc3QgaW4gdGhlIENvbXBvbmVudCBpdHNlbGYuXG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGl0LCByZXR1cm4gdHJ1ZSBzbyBjYWxsaW5nIGNvZGUga25vd3Mgbm90IHRvIGNvbnRpbnVlIHRvIHNlYXJjaC5cbiAgICAgICAgICAgIGhhbmRsZXJDYiA9IHJlc29sdmVDYWxsYmFjayhoYW5kbGVyTmFtZSwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBmbiBpcyByZXNvbHZlZCBpbiB0aGUgQ29tcG9uZW50IG9yIGl0cyBvd24gcGFyZW50IGNoYWluLlxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3RhdHVzIGluZGljYXRpbmcgdGhhdCB3ZSBkbyBub3QgbmVlZCBhbiBlYXJseSBiaW5kaW5nXG4gICAgICAgICAgICBpZiAoaGFuZGxlckNiLmZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZW8uaXNGdW5jdGlvbihtZVtoYW5kbGVyTmFtZV0pID9cbiAgICAgICAgICAgIG1lIDogcGFyZW50Py5nZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsb3Nlc3QgY29udHJvbGxlciBpbnNpZGUgdGhlIGNvbXBvbmVudHMgcGFyZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudH0gPSBtZTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuY29tcG9uZW50LnBhcmVudD8uZ2V0Q29udHJvbGxlcigpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiB1cGRhdGUgY2hhbmdlZCByZWZlcmVuY2VzIChlLmcuIGNvbnRhaW5lci5yZW1vdmUoKSB0aGVuIGNvbnRhaW5lci5hZGQoKSB1c2luZyB0aGUgc2FtZSBrZXkpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSZWZlcmVuY2UobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLnJlZmVyZW5jZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLmNvbXBvbmVudC5kb3duKHtyZWZlcmVuY2U6IG5hbWV9KTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIG1lLnJlZmVyZW5jZXNbbmFtZV0gPSBjb21wb25lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb25lbnQgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2FtZUxldmVsT25seT1mYWxzZSB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBzdGF0ZVByb3ZpZGVyIGluc2lkZSB0aGUgY29tcG9uZW50IHBhcmVudCB0cmVlLFxuICAgICAqIGluIGNhc2UgdGhlcmUgaXMgbm9uZSBvbiB0aGUgc2FtZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW1lTGV2ZWxPbmx5PWZhbHNlXVxuICAgICAqL1xuICAgIGdldFN0YXRlUHJvdmlkZXIoc2FtZUxldmVsT25seT1mYWxzZSkge1xuICAgICAgICBsZXQge2NvbXBvbmVudH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2FtZUxldmVsT25seSA/IGNvbXBvbmVudC5zdGF0ZVByb3ZpZGVyIDogY29tcG9uZW50LmdldFN0YXRlUHJvdmlkZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBhY2Nlc3Npbmcgc3RhdGUuUHJvdmlkZXIgYmFzZWQgZGF0YS5TdG9yZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge05lby5kYXRhLlN0b3JlfVxuICAgICAqL1xuICAgIGdldFN0b3JlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluc2lkZSB5b3VyIHZpZXcgY29udHJvbGxlcnMgYXMgYSBzdGFydGluZyBwb2ludCBpbiBjYXNlIHlvdSBuZWVkIHJlZmVyZW5jZXNcbiAgICAgKiAoaW5zdGVhZCBvZiB1c2luZyBvbkNvbnN0cnVjdGVkKCkgaW5zaWRlIHlvdXIgY29udHJvbGxlcilcbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudENvbnN0cnVjdGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFdpbGwgZ2V0IGNhbGxlZCBieSBjb21wb25lbnQuQmFzZTogZGVzdHJveSgpIGluIGNhc2UgdGhlIGNvbXBvbmVudCBoYXMgYSByZWZlcmVuY2UgY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVmZXJlbmNlc30gPSBtZSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSByZWZlcmVuY2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVmZXJlbmNlc1trZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRQYXJlbnQoKT8ucmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgc2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5zZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IEJ1dHRvbiAgICBmcm9tICcuLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnQvQmFzZS5tanMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IExhYmVsICAgICBmcm9tICcuLi9jb21wb25lbnQvTGFiZWwubWpzJztcbmltcG9ydCBOZW9BcnJheSAgZnJvbSAnLi4vdXRpbC9BcnJheS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udG9vbGJhci5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgVG9vbGJhciBleHRlbmRzIENvbnRhaW5lciB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgdmFsdWVzIGZvciBkb2NrXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IGRvY2tQb3NpdGlvbnM9Wyd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnLCBudWxsXVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZG9ja1Bvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgbnVsbF1cblxuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRvb2xiYXIuQmFzZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRvb2xiYXIuQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSd0b29sYmFyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3Rvb2xiYXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tdG9vbGJhciddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby10b29sYmFyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gZG9ja189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRvY2tfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBpdGVtRGVmYXVsdHM9e250eXBlOididXR0b24nfVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1EZWZhdWx0czoge1xuICAgICAgICAgICAgbnR5cGU6ICdidXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J2ZsZXhib3gnLGFsaWduOidjZW50ZXInLGRpcmVjdGlvbjogJ3JvdycsIHBhY2s6J3N0YXJ0J31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIG50eXBlICAgIDogJ2ZsZXhib3gnLFxuICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZG9jayBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlICYmICFvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y2xzfSAgICAgICAgID0gbWUsXG4gICAgICAgICAgICBkb2NrUG9zaXRpb25zID0gbWUuZ2V0U3RhdGljQ29uZmlnKCdkb2NrUG9zaXRpb25zJyksXG4gICAgICAgICAgICBsYXlvdXRDb25maWcgID0gbWUuZ2V0TGF5b3V0Q29uZmlnKCk7XG5cbiAgICAgICAgZG9ja1Bvc2l0aW9ucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBrZXkgIT09IG51bGwgJiYgTmVvQXJyYXkudG9nZ2xlKGNscywgJ25lby1kb2NrLScgKyBrZXksIGtleSA9PT0gdmFsdWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghbWUubGF5b3V0KSB7XG4gICAgICAgICAgICBsYXlvdXRDb25maWcubnR5cGUgPSAnZmxleGJveCc7XG4gICAgICAgICAgICBtZS5zZXQoe2NscywgbGF5b3V0OiBsYXlvdXRDb25maWd9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUubGF5b3V0LnNldChsYXlvdXRDb25maWcpO1xuICAgICAgICAgICAgbWUuY2xzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBuZXcgZG9jayBwb3NpdGlvbiBtYXRjaGVzIGEgdmFsdWUgb2YgdGhlIHN0YXRpYyBkb2NrUG9zaXRpb25zIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldERvY2sodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVNldEVudW1WYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsICdkb2NrJywgJ2RvY2tQb3NpdGlvbnMnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY3JlYXRlSXRlbXMoKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlSXRlbXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXlvdXQgY29uZmlnIGRlcGVuZGluZyBvbiB0aGlzLmRvY2tcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBsYXlvdXRDb25maWdcbiAgICAgKi9cbiAgICBnZXRMYXlvdXRDb25maWcoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBsYXlvdXRDb25maWc7XG5cbiAgICAgICAgaWYgKG1lLmRvY2spIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWUuZG9jaykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2sgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ24gICAgOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXlvdXRDb25maWcgfHwgbWUubGF5b3V0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zIGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gaXRlbVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbXBvbmVudC5CYXNlfE5lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgaXRlbSwgc2lsZW50PWZhbHNlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5tYXAoaXRlbSA9PiB0aGlzLnJlcGxhY2VTcGFjZXIoaXRlbSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VwZXIuaW5zZXJ0KGluZGV4LCBpdGVtLCBzaWxlbnQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBpdGVtXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH1cbiAgICAgKi9cbiAgICByZXBsYWNlU3BhY2VyKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09ICctPicgPyB7bW9kdWxlOiBDb21wb25lbnQsIGZsZXg6IDF9IDogaXRlbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBkb2NrOiB0aGlzLmRvY2tcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoVG9vbGJhcik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9