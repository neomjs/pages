export const __webpack_esm_id__ = "src_plugin_Responsive_mjs";
export const __webpack_esm_ids__ = ["src_plugin_Responsive_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/plugin/Base.mjs"
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ },

/***/ "./src/plugin/Responsive.mjs"
/*!***********************************!*\
  !*** ./src/plugin/Responsive.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/plugin/Base.mjs");


/**
 * @class Neo.plugin.Responsive
 * @extends Neo.plugin.Base
 */
class Responsive extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Responsive'
         * @protected
         */
        className: 'Neo.plugin.Responsive',
        /**
         * @member {String} ntype='plugin-responsive'
         * @protected
         */
        ntype: 'plugin-responsive',
        /**
         * @member {Map} responsiveConfig: new Map()
         */
        responsiveConfig: new Map(),
        /**
         * @member {Object} defaultResponsiveConfig
         */
        defaultResponsiveConfig: {
            landscape(data) {
                return data.width > data.height
            },
            portrait(data) {
                return data.width < data.height
            }
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        owner.addCls('neo-responsive');

        Neo.first('viewport').addDomListeners([
            {resize: me.onResize, scope: me}
        ])

        Neo.Responsive = Neo.Responsive || {
            responsiveConfig: new Map(),
            apps            : {}
        };

        me.addToResponsiveMap(me.defaultResponsiveConfig, me);
        me.addToResponsiveMap(owner.responsiveConfig || {}, owner);
        me.handleBodyCls()
    }

    /**
     * @param responsiveObj
     * @param scope
     */
    addToResponsiveMap(responsiveObj, scope) {
        for (const [key, value] of Object.entries(responsiveObj)) {
            let fn;

            if (Neo.isObject(value)) {
                fn = function (rect) {
                    let returnBool = true;

                    for (const [subKey, subValue] of Object.entries(value)) {
                        const isMin      = subKey.startsWith('min'),
                              testConfig = subKey.substring(3).toLowerCase();

                        if (isMin) {
                            returnBool = rect[testConfig] >= subValue
                        } else {
                            returnBool = rect[testConfig] <= subValue
                        }

                        if (!returnBool) {
                            break
                        }
                    }

                    return returnBool
                }
            } else {
                fn = value
            }

            fn = fn.bind(scope);

            Neo.Responsive.responsiveConfig.set(key, fn)
        }
    }

    /**
     *
     */
    handleBodyCls() {
        const
            me         = this,
            {windowId} = me.owner,
            apps       = Neo.Responsive;

        if (!apps[windowId]?.activeBodyUpdate) {
            const viewport = Neo.first('viewport'); // todo

            apps[windowId] = {
                appId           : viewport.id,
                activeBodyUpdate: true
            };

            viewport.addDomListeners([
                {resize: me.onResizeBody, scope: me}
            ])
        }
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        const
            me           = this,
            config       = {},
            configTester = Neo.Responsive.responsiveConfig,
            {owner}      = me,
            {responsive} = owner;

        for (const [key, value] of Object.entries(responsive)) {
            const hasKey = configTester.get(key)?.(data.rect);

            if (hasKey) {
                for (const [configKey, configValue] of Object.entries(value)) {
                    if (false) // removed by dead control flow
{} else {
                        config[configKey] = configValue
                    }
                }
            }
        }

        Object.keys(config).length > 0 && owner.set(config)
    }

    /**
     * Add either neo-landscape or neo-portrait to the parent viewport component
     */
    onResizeBody(data) {
        const
            me          = this,
            newRect     = data.contentRect,
            isLandscape = newRect.width >= newRect.height,
            addCls      = isLandscape ? 'neo-landscape' : 'neo-portrait',
            removeCls   = isLandscape ? 'neo-portrait' : 'neo-landscape';

        Neo.applyDeltas(me.appName, {
            id : 'document.body',
            cls: {
                add   : [addCls],
                remove: [removeCls]
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Responsive));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfcGx1Z2luX1Jlc3BvbnNpdmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUk7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Rk47O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFNO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixLQUF1RCxFQUFFO0FBQUEsRUFHNUQsQ0FBQztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsMEJBQTBCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9SZXNwb25zaXZlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwbHVnaW4gaW1wbGVtZW50YXRpb25zLlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFBsdWdpbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHBsdWdpbiBudHlwZXMgbmVlZCB0byBzdGFydCB3aXRoICdwbHVnaW4tJyB0byBlbnN1cmUgdGhhdCBjb21wb25lbnQuQmFzZTogZ2V0UGx1Z2luKCkgY2FuIGZpbmQgdGhlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZTtcblxuICAgICAgICBpZiAob3duZXIuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUub25Pd25lckNvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyLm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5vbk93bmVyQ29uc3RydWN0ZWQoKVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvd25lci5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyTW91bnRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIub24oJ21vdW50ZWQnLCBtZS5vbk93bmVyTW91bnRlZCwgbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMuX19wcm90b19fKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG93bmVyIENvbXBvbmVudCB3aGVuIGl0IGlzIGNvbnN0cnVjdGVkXG4gICAgICovXG4gICAgb25Pd25lckNvbnN0cnVjdGVkKCkge1xuICAgICAgICBsZXQge293bmVyfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG93bmVyLndpbmRvd0lkKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd0lkID0gb3duZXIud2luZG93SWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG93bmVyIENvbXBvbmVudCB3aGVuIGl0IGRvZXMgZ2V0IG1vdW50ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyTW91bnRlZCgpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUGx1Z2luKTtcbiIsImltcG9ydCBQbHVnaW4gZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5wbHVnaW4uUmVzcG9uc2l2ZVxuICogQGV4dGVuZHMgTmVvLnBsdWdpbi5CYXNlXG4gKi9cbmNsYXNzIFJlc3BvbnNpdmUgZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5SZXNwb25zaXZlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLlJlc3BvbnNpdmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ncGx1Z2luLXJlc3BvbnNpdmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luLXJlc3BvbnNpdmUnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TWFwfSByZXNwb25zaXZlQ29uZmlnOiBuZXcgTWFwKClcbiAgICAgICAgICovXG4gICAgICAgIHJlc3BvbnNpdmVDb25maWc6IG5ldyBNYXAoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gZGVmYXVsdFJlc3BvbnNpdmVDb25maWdcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRSZXNwb25zaXZlQ29uZmlnOiB7XG4gICAgICAgICAgICBsYW5kc2NhcGUoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLndpZHRoID4gZGF0YS5oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3J0cmFpdChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEud2lkdGggPCBkYXRhLmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lO1xuXG4gICAgICAgIG93bmVyLmFkZENscygnbmVvLXJlc3BvbnNpdmUnKTtcblxuICAgICAgICBOZW8uZmlyc3QoJ3ZpZXdwb3J0JykuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgIHtyZXNpemU6IG1lLm9uUmVzaXplLCBzY29wZTogbWV9XG4gICAgICAgIF0pXG5cbiAgICAgICAgTmVvLlJlc3BvbnNpdmUgPSBOZW8uUmVzcG9uc2l2ZSB8fCB7XG4gICAgICAgICAgICByZXNwb25zaXZlQ29uZmlnOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBhcHBzICAgICAgICAgICAgOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIG1lLmFkZFRvUmVzcG9uc2l2ZU1hcChtZS5kZWZhdWx0UmVzcG9uc2l2ZUNvbmZpZywgbWUpO1xuICAgICAgICBtZS5hZGRUb1Jlc3BvbnNpdmVNYXAob3duZXIucmVzcG9uc2l2ZUNvbmZpZyB8fCB7fSwgb3duZXIpO1xuICAgICAgICBtZS5oYW5kbGVCb2R5Q2xzKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2l2ZU9ialxuICAgICAqIEBwYXJhbSBzY29wZVxuICAgICAqL1xuICAgIGFkZFRvUmVzcG9uc2l2ZU1hcChyZXNwb25zaXZlT2JqLCBzY29wZSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXNwb25zaXZlT2JqKSkge1xuICAgICAgICAgICAgbGV0IGZuO1xuXG4gICAgICAgICAgICBpZiAoTmVvLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybkJvb2wgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3N1YktleSwgc3ViVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNNaW4gICAgICA9IHN1YktleS5zdGFydHNXaXRoKCdtaW4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RDb25maWcgPSBzdWJLZXkuc3Vic3RyaW5nKDMpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkJvb2wgPSByZWN0W3Rlc3RDb25maWddID49IHN1YlZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkJvb2wgPSByZWN0W3Rlc3RDb25maWddIDw9IHN1YlZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmV0dXJuQm9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuQm9vbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm4gPSB2YWx1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbiA9IGZuLmJpbmQoc2NvcGUpO1xuXG4gICAgICAgICAgICBOZW8uUmVzcG9uc2l2ZS5yZXNwb25zaXZlQ29uZmlnLnNldChrZXksIGZuKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBoYW5kbGVCb2R5Q2xzKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7d2luZG93SWR9ID0gbWUub3duZXIsXG4gICAgICAgICAgICBhcHBzICAgICAgID0gTmVvLlJlc3BvbnNpdmU7XG5cbiAgICAgICAgaWYgKCFhcHBzW3dpbmRvd0lkXT8uYWN0aXZlQm9keVVwZGF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBOZW8uZmlyc3QoJ3ZpZXdwb3J0Jyk7IC8vIHRvZG9cblxuICAgICAgICAgICAgYXBwc1t3aW5kb3dJZF0gPSB7XG4gICAgICAgICAgICAgICAgYXBwSWQgICAgICAgICAgIDogdmlld3BvcnQuaWQsXG4gICAgICAgICAgICAgICAgYWN0aXZlQm9keVVwZGF0ZTogdHJ1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmlld3BvcnQuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgICAgICB7cmVzaXplOiBtZS5vblJlc2l6ZUJvZHksIHNjb3BlOiBtZX1cbiAgICAgICAgICAgIF0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUmVzaXplKGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgICAgICAgPSB7fSxcbiAgICAgICAgICAgIGNvbmZpZ1Rlc3RlciA9IE5lby5SZXNwb25zaXZlLnJlc3BvbnNpdmVDb25maWcsXG4gICAgICAgICAgICB7b3duZXJ9ICAgICAgPSBtZSxcbiAgICAgICAgICAgIHtyZXNwb25zaXZlfSA9IG93bmVyO1xuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3BvbnNpdmUpKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNLZXkgPSBjb25maWdUZXN0ZXIuZ2V0KGtleSk/LihkYXRhLnJlY3QpO1xuXG4gICAgICAgICAgICBpZiAoaGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbY29uZmlnS2V5LCBjb25maWdWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSAmJiBOZW8udHlwZU9mKG93bmVyW2NvbmZpZ0tleV0pID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiBudHlwZSwgbW9kdWxlIG9yIGNsYXNzTmFtZSBtdXN0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lcltjb25maWdLZXldLnNldCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tjb25maWdLZXldID0gY29uZmlnVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZykubGVuZ3RoID4gMCAmJiBvd25lci5zZXQoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBlaXRoZXIgbmVvLWxhbmRzY2FwZSBvciBuZW8tcG9ydHJhaXQgdG8gdGhlIHBhcmVudCB2aWV3cG9ydCBjb21wb25lbnRcbiAgICAgKi9cbiAgICBvblJlc2l6ZUJvZHkoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbmV3UmVjdCAgICAgPSBkYXRhLmNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgaXNMYW5kc2NhcGUgPSBuZXdSZWN0LndpZHRoID49IG5ld1JlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgYWRkQ2xzICAgICAgPSBpc0xhbmRzY2FwZSA/ICduZW8tbGFuZHNjYXBlJyA6ICduZW8tcG9ydHJhaXQnLFxuICAgICAgICAgICAgcmVtb3ZlQ2xzICAgPSBpc0xhbmRzY2FwZSA/ICduZW8tcG9ydHJhaXQnIDogJ25lby1sYW5kc2NhcGUnO1xuXG4gICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCB7XG4gICAgICAgICAgICBpZCA6ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgICAgIGNsczoge1xuICAgICAgICAgICAgICAgIGFkZCAgIDogW2FkZENsc10sXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBbcmVtb3ZlQ2xzXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUmVzcG9uc2l2ZSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9