"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_plugin_Responsive_mjs"],{

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ }),

/***/ "./src/plugin/Responsive.mjs":
/*!***********************************!*\
  !*** ./src/plugin/Responsive.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/plugin/Base.mjs");


/**
 * @class Neo.plugin.Responsive
 * @extends Neo.plugin.Base
 */
class Responsive extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Responsive'
         * @protected
         */
        className: 'Neo.plugin.Responsive',
        /**
         * @member {String} ntype='plugin-responsive'
         * @protected
         */
        ntype: 'plugin-responsive',
        /**
         * @member {Map} responsiveConfig: new Map()
         */
        responsiveConfig: new Map(),
        /**
         * @member {Object} defaultResponsiveConfig
         */
        defaultResponsiveConfig: {
            landscape(data) {
                return data.width > data.height
            },
            portrait(data) {
                return data.width < data.height
            }
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        owner.addCls('neo-responsive');

        Neo.first('viewport').addDomListeners([
            {resize: me.onResize, scope: me}
        ])

        Neo.Responsive = Neo.Responsive || {
            responsiveConfig: new Map(),
            apps            : {}
        };

        me.addToResponsiveMap(me.defaultResponsiveConfig, me);
        me.addToResponsiveMap(owner.responsiveConfig || {}, owner);
        me.handleBodyCls()
    }

    /**
     * @param responsiveObj
     * @param scope
     */
    addToResponsiveMap(responsiveObj, scope) {
        for (const [key, value] of Object.entries(responsiveObj)) {
            let fn;

            if (Neo.isObject(value)) {
                fn = function (rect) {
                    let returnBool = true;

                    for (const [subKey, subValue] of Object.entries(value)) {
                        const isMin      = subKey.startsWith('min'),
                              testConfig = subKey.substring(3).toLowerCase();

                        if (isMin) {
                            returnBool = rect[testConfig] >= subValue
                        } else {
                            returnBool = rect[testConfig] <= subValue
                        }

                        if (!returnBool) {
                            break
                        }
                    }

                    return returnBool
                }
            } else {
                fn = value
            }

            fn = fn.bind(scope);

            Neo.Responsive.responsiveConfig.set(key, fn)
        }
    }

    /**
     *
     */
    handleBodyCls() {
        const
            me        = this,
            {appName} = me.owner,
            apps      = Neo.Responsive;

        if (!apps[appName]?.activeBodyUpdate) {
            const viewport = Neo.first('viewport'); // todo

            apps[appName] = {
                appId           : viewport.id,
                activeBodyUpdate: true
            };

            viewport.addDomListeners([
                {resize: me.onResizeBody, scope: me}
            ])
        }
    }

    /**
     * @param {Object} data
     */
    onResize(data) {
        const
            me           = this,
            config       = {},
            configTester = Neo.Responsive.responsiveConfig,
            {owner}      = me,
            {responsive} = owner;

        for (const [key, value] of Object.entries(responsive)) {
            const hasKey = configTester.get(key)?.(data.rect);

            if (hasKey) {
                for (const [configKey, configValue] of Object.entries(value)) {
                    if (false) // removed by dead control flow
{} else {
                        config[configKey] = configValue
                    }
                }
            }
        }

        Object.keys(config).length > 0 && owner.set(config)
    }

    /**
     * Add either neo-landscape or neo-portrait to the parent viewport component
     */
    onResizeBody(data) {
        const
            me          = this,
            newRect     = data.contentRect,
            isLandscape = newRect.width >= newRect.height,
            addCls      = isLandscape ? 'neo-landscape' : 'neo-portrait',
            removeCls   = isLandscape ? 'neo-portrait' : 'neo-landscape';

        Neo.applyDeltas(me.appName, {
            id : 'document.body',
            cls: {
                add   : [addCls],
                remove: [removeCls]
            }
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Responsive));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfcGx1Z2luX1Jlc3BvbnNpdmVfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Rk47O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFNO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7O0FBRXpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixLQUF1RCxFQUFFO0FBQUEsRUFHNUQsQ0FBQztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsMEJBQTBCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9CYXNlLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL3BsdWdpbi9SZXNwb25zaXZlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwbHVnaW4gaW1wbGVtZW50YXRpb25zLlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFBsdWdpbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHBsdWdpbiBudHlwZXMgbmVlZCB0byBzdGFydCB3aXRoICdwbHVnaW4tJyB0byBlbnN1cmUgdGhhdCBjb21wb25lbnQuQmFzZTogZ2V0UGx1Z2luKCkgY2FuIGZpbmQgdGhlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lO1xuXG4gICAgICAgIGlmIChvd25lci5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyQ29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uT3duZXJDb25zdHJ1Y3RlZCgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG93bmVyLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJNb3VudGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5vbignbW91bnRlZCcsIG1lLm9uT3duZXJNb3VudGVkLCBtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgdGhpcy5fX3Byb3RvX18pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgaXMgY29uc3RydWN0ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCB7b3duZXJ9ID0gdGhpcztcblxuICAgICAgICBpZiAob3duZXIud2luZG93SWQpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93SWQgPSBvd25lci53aW5kb3dJZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgZG9lcyBnZXQgbW91bnRlZFxuICAgICAqL1xuICAgIG9uT3duZXJNb3VudGVkKCkge1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhQbHVnaW4pO1xuIiwiaW1wb3J0IFBsdWdpbiBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5SZXNwb25zaXZlXG4gKiBAZXh0ZW5kcyBOZW8ucGx1Z2luLkJhc2VcbiAqL1xuY2xhc3MgUmVzcG9uc2l2ZSBleHRlbmRzIFBsdWdpbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLlJlc3BvbnNpdmUnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uUmVzcG9uc2l2ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4tcmVzcG9uc2l2ZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4tcmVzcG9uc2l2ZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtNYXB9IHJlc3BvbnNpdmVDb25maWc6IG5ldyBNYXAoKVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzcG9uc2l2ZUNvbmZpZzogbmV3IE1hcCgpLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBkZWZhdWx0UmVzcG9uc2l2ZUNvbmZpZ1xuICAgICAgICAgKi9cbiAgICAgICAgZGVmYXVsdFJlc3BvbnNpdmVDb25maWc6IHtcbiAgICAgICAgICAgIGxhbmRzY2FwZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEud2lkdGggPiBkYXRhLmhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvcnRyYWl0KGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS53aWR0aCA8IGRhdGEuaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ID0gbWU7XG5cbiAgICAgICAgb3duZXIuYWRkQ2xzKCduZW8tcmVzcG9uc2l2ZScpO1xuXG4gICAgICAgIE5lby5maXJzdCgndmlld3BvcnQnKS5hZGREb21MaXN0ZW5lcnMoW1xuICAgICAgICAgICAge3Jlc2l6ZTogbWUub25SZXNpemUsIHNjb3BlOiBtZX1cbiAgICAgICAgXSlcblxuICAgICAgICBOZW8uUmVzcG9uc2l2ZSA9IE5lby5SZXNwb25zaXZlIHx8IHtcbiAgICAgICAgICAgIHJlc3BvbnNpdmVDb25maWc6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGFwcHMgICAgICAgICAgICA6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgbWUuYWRkVG9SZXNwb25zaXZlTWFwKG1lLmRlZmF1bHRSZXNwb25zaXZlQ29uZmlnLCBtZSk7XG4gICAgICAgIG1lLmFkZFRvUmVzcG9uc2l2ZU1hcChvd25lci5yZXNwb25zaXZlQ29uZmlnIHx8IHt9LCBvd25lcik7XG4gICAgICAgIG1lLmhhbmRsZUJvZHlDbHMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSByZXNwb25zaXZlT2JqXG4gICAgICogQHBhcmFtIHNjb3BlXG4gICAgICovXG4gICAgYWRkVG9SZXNwb25zaXZlTWFwKHJlc3BvbnNpdmVPYmosIHNjb3BlKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3BvbnNpdmVPYmopKSB7XG4gICAgICAgICAgICBsZXQgZm47XG5cbiAgICAgICAgICAgIGlmIChOZW8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0dXJuQm9vbCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc3ViS2V5LCBzdWJWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc01pbiAgICAgID0gc3ViS2V5LnN0YXJ0c1dpdGgoJ21pbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdENvbmZpZyA9IHN1YktleS5zdWJzdHJpbmcoMykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuQm9vbCA9IHJlY3RbdGVzdENvbmZpZ10gPj0gc3ViVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuQm9vbCA9IHJlY3RbdGVzdENvbmZpZ10gPD0gc3ViVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5Cb29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5Cb29sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbiA9IHZhbHVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuID0gZm4uYmluZChzY29wZSk7XG5cbiAgICAgICAgICAgIE5lby5SZXNwb25zaXZlLnJlc3BvbnNpdmVDb25maWcuc2V0KGtleSwgZm4pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGhhbmRsZUJvZHlDbHMoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBtZSAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWV9ID0gbWUub3duZXIsXG4gICAgICAgICAgICBhcHBzICAgICAgPSBOZW8uUmVzcG9uc2l2ZTtcblxuICAgICAgICBpZiAoIWFwcHNbYXBwTmFtZV0/LmFjdGl2ZUJvZHlVcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gTmVvLmZpcnN0KCd2aWV3cG9ydCcpOyAvLyB0b2RvXG5cbiAgICAgICAgICAgIGFwcHNbYXBwTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgYXBwSWQgICAgICAgICAgIDogdmlld3BvcnQuaWQsXG4gICAgICAgICAgICAgICAgYWN0aXZlQm9keVVwZGF0ZTogdHJ1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmlld3BvcnQuYWRkRG9tTGlzdGVuZXJzKFtcbiAgICAgICAgICAgICAgICB7cmVzaXplOiBtZS5vblJlc2l6ZUJvZHksIHNjb3BlOiBtZX1cbiAgICAgICAgICAgIF0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uUmVzaXplKGRhdGEpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb25maWcgICAgICAgPSB7fSxcbiAgICAgICAgICAgIGNvbmZpZ1Rlc3RlciA9IE5lby5SZXNwb25zaXZlLnJlc3BvbnNpdmVDb25maWcsXG4gICAgICAgICAgICB7b3duZXJ9ICAgICAgPSBtZSxcbiAgICAgICAgICAgIHtyZXNwb25zaXZlfSA9IG93bmVyO1xuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3BvbnNpdmUpKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNLZXkgPSBjb25maWdUZXN0ZXIuZ2V0KGtleSk/LihkYXRhLnJlY3QpO1xuXG4gICAgICAgICAgICBpZiAoaGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbY29uZmlnS2V5LCBjb25maWdWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSAmJiBOZW8udHlwZU9mKG93bmVyW2NvbmZpZ0tleV0pID09PSAnTmVvSW5zdGFuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiBudHlwZSwgbW9kdWxlIG9yIGNsYXNzTmFtZSBtdXN0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lcltjb25maWdLZXldLnNldCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tjb25maWdLZXldID0gY29uZmlnVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZykubGVuZ3RoID4gMCAmJiBvd25lci5zZXQoY29uZmlnKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBlaXRoZXIgbmVvLWxhbmRzY2FwZSBvciBuZW8tcG9ydHJhaXQgdG8gdGhlIHBhcmVudCB2aWV3cG9ydCBjb21wb25lbnRcbiAgICAgKi9cbiAgICBvblJlc2l6ZUJvZHkoZGF0YSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbmV3UmVjdCAgICAgPSBkYXRhLmNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgaXNMYW5kc2NhcGUgPSBuZXdSZWN0LndpZHRoID49IG5ld1JlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgYWRkQ2xzICAgICAgPSBpc0xhbmRzY2FwZSA/ICduZW8tbGFuZHNjYXBlJyA6ICduZW8tcG9ydHJhaXQnLFxuICAgICAgICAgICAgcmVtb3ZlQ2xzICAgPSBpc0xhbmRzY2FwZSA/ICduZW8tcG9ydHJhaXQnIDogJ25lby1sYW5kc2NhcGUnO1xuXG4gICAgICAgIE5lby5hcHBseURlbHRhcyhtZS5hcHBOYW1lLCB7XG4gICAgICAgICAgICBpZCA6ICdkb2N1bWVudC5ib2R5JyxcbiAgICAgICAgICAgIGNsczoge1xuICAgICAgICAgICAgICAgIGFkZCAgIDogW2FkZENsc10sXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBbcmVtb3ZlQ2xzXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUmVzcG9uc2l2ZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=