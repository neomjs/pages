"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["src_code_executor_Neo_mjs"],{

/***/ "./src/code/executor/Neo.mjs"
/*!***********************************!*\
  !*** ./src/code/executor/Neo.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


const
    classNameRegex = /className\s*:\s*['"]([^'"]+)['"]/g,
    exportRegex    = /export\s+(?:default\s+)?(?:const|let|var|class|function|async\s+function|generator\s+function|async\s+generator\s+function|(\{[\s\S]*?\}))/g,
    importRegex    = /import\s+(?:([\w-]+)|\{([^}]+)\})\s+from\s+['"]([^'"]+)['"]/;

/**
 * @summary Executor implementation for Neo.mjs source code.
 *
 * This executor is responsible for taking raw Neo.mjs component code (as a string), resolving its dependencies,
 * and executing it within a container. It handles:
 * - **Dynamic Imports**: Parsing `import` statements and resolving them at runtime using `Promise.all` and `import()`.
 * - **Environment Handling**: Adjusting import paths based on the running environment (`development`, `dist/development`, `dist/production`) to ensure correct file resolution.
 * - **Code Execution**: Wrapping the code in a `new Function` context to execute it safely and inject the result into the target container.
 * - **Namespace Management**: Cleaning up previous class definitions to allow for iterative development and re-execution.
 *
 * @class Neo.code.executor.Neo
 * @extends Neo.core.Base
 */
class NeoExecutor extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.code.executor.Neo'
         * @protected
         */
        className: 'Neo.code.executor.Neo'
    }

    /**
     * @param {String} sourceCode
     * @returns {String[]}
     */
    findClassNames(sourceCode) {
        let classNames = [],
            match;

        while ((match = classNameRegex.exec(sourceCode)) !== null) {
            classNames.push(match[1])
        }

        return classNames
    }

    /**
     * @param {String} sourceCode
     * @returns {String|null}
     */
    findMainClassName(sourceCode) {
        let classNames = this.findClassNames(sourceCode),
            mainName   = null,
            prioNames  = ['MainContainer', 'MainComponent', 'MainView', 'Main'];

        if (classNames.length > 0) {
            for (const name of prioNames) {
                mainName = classNames.find(className => className.endsWith(name));
                if (mainName) {
                    break
                }
            }

            if (!mainName) {
                mainName = classNames[classNames.length - 1]
            }
        }

        return mainName
    }

    /**
     * Executes the provided Neo.mjs source code within the given container.
     *
     * This method performs a complex transformation to emulate a native module environment within the browser:
     * 1.  **Import Rewriting**: It parses the source for `import` statements and maps them to dynamic `import()` calls.
     *     Crucially, it adjusts relative paths based on the `environment` (dev vs. dist) to ensure the browser can resolve the files.
     * 2.  **Promise Resolution**: It wraps all imports in a `Promise.all` to ensure dependencies are ready before code execution.
     * 3.  **Sandbox Execution**: It constructs a function body string and executes it using `new Function`. This allows the code
     *     to run in the global scope but with injected variables (`container`, `module`).
     * 4.  **Namespace Cleaning**: It actively deletes the target class from the `Neo` namespace before execution. This is critical
     *     for **Hot Module Replacement (HMR)** workflows, ensuring that re-running the code actually updates the class definition
     *     instead of using a cached version.
     * @param {Object} data
     * @param {String} data.code
     * @param {Neo.container.Base} data.container
     * @returns {Promise<Object>}
     */
    async execute({code, container}) {
        let me                = this,
            {environment}     = Neo.config,
            source            = code,
            className         = me.findMainClassName(source),
            cleanLines        = [],
            moduleNameAndPath = [],
            params            = [],
            vars              = [],
            codeString, module, promises;

        source.split('\n').forEach(line => {
            let importMatch = line.match(importRegex);

            if (importMatch) {
                let defaultImport = importMatch[1],
                    namedImports  = importMatch[2]?.split(',').map(name => name.trim()),
                    path          = importMatch[3],
                    index;

                if (environment === 'development') {
                    if (path.startsWith('.')) {
                        path = '../' + path
                    }
                }
                // We want the non-minified version for code which can not get bundled.
                else if (environment === 'dist/development') {
                    index = path.lastIndexOf('../');

                    if (index === 0) {
                        path = '../../../../src/' + path.slice(index + 3)
                    } else {
                        path = path.slice(0, index) + '../../../' + path.slice(index + 3)
                    }
                }

                // We want the minified version of the code which can not get bundled.
                else if (environment === 'dist/production') {
                    index = path.lastIndexOf('../');

                    if (index === 0) {
                        path = '../../../esm/src/' + path.slice(index + 3)
                    } else {
                        path = path.slice(0, index) + '../../esm/' + path.slice(index + 3)
                    }
                }

                moduleNameAndPath.push({defaultImport, namedImports, path})
            } else if (line.match(exportRegex)) {
                // Skip export statements
            } else {
                cleanLines.push(`    ${line}`)
            }
        });

        promises = moduleNameAndPath.map((item, i) => {
            let moduleAlias = `Module${i}`;
            params.push(moduleAlias);
            if (item.defaultImport) {
                vars.push(`    const ${item.defaultImport} = ${moduleAlias}.default;`);
            }
            if (item.namedImports) {
                vars.push(`    const {${item.namedImports.join(', ')}} = ${moduleAlias};`);
            }
            return `import('${item.path}')`
        });

        codeString = [
            'Promise.all([',
            `    ${promises.join(',\n')}`,
            `]).then(([${params.join(', ')}]) => {`,
            `${vars.join('\n')}`,
            `    ${cleanLines.join('\n')}`,
            '',
            `    module = Neo.ns('${className}');`,
            '',
            `    if (module && (`,
            `        Neo.component.Base.isPrototypeOf(module) ||`,
            `        Neo.functional.component.Base.isPrototypeOf(module)`,
            `    )) {`,
            `        container.add({module})`,
            '    }',
            '})',
            '.catch(error => {',
            '    console.warn("LivePreview Error:", error);',
            '    container.add({ntype:\'component\', html:error.message});',
            '})'
        ].join('\n');

        // destroy, silent => merge changes into one update cycle
        container.removeAll(true, true);

        // We must ensure that classes inside the editor won't get cached, since this disables run-time changes
        // See: https://github.com/neomjs/neo/issues/5863
        me.findClassNames(codeString).forEach(item => {
            let nsArray   = item.split('.'),
                className = nsArray.pop(),
                ns        = Neo.ns(nsArray);

            if (ns) {
                delete ns[className]
            }
        });

        try {
            new Function('container', 'module', codeString)(container, module);
        } catch (error) {
            container.add({
                ntype: 'component',
                html : error.message
            })
        }

        return {}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(NeoExecutor));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfY29kZV9leGVjdXRvcl9OZW9fbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXVDOztBQUV2QztBQUNBO0FBQ0Esb0pBQW9KLFVBQVU7QUFDOUosNkNBQTZDLElBQUksS0FBSzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQUk7QUFDOUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0Msa0NBQWtDO0FBQzFFLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCx1Q0FBdUMsS0FBSztBQUM1QztBQUNBLFNBQVM7O0FBRVQ7QUFDQSx1Q0FBdUMsRUFBRTtBQUN6QztBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQixJQUFJLFlBQVksU0FBUztBQUNwRjtBQUNBO0FBQ0Esc0NBQXNDLEVBQUUsK0JBQStCLElBQUksYUFBYTtBQUN4RjtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEMseUJBQXlCLGtCQUFrQixPQUFPO0FBQ2xELGVBQWUsZ0JBQWdCO0FBQy9CLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQSxvQ0FBb0MsVUFBVSxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9DQUFvQyxPQUFPO0FBQzNDLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsOEJBQThCO0FBQzlCLDJEQUEyRDtBQUMzRCxnQ0FBZ0Msd0NBQXdDLEVBQUU7QUFDMUUsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDJCQUEyQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jb2RlL2V4ZWN1dG9yL05lby5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vLi4vY29yZS9CYXNlLm1qcyc7XG5cbmNvbnN0XG4gICAgY2xhc3NOYW1lUmVnZXggPSAvY2xhc3NOYW1lXFxzKjpcXHMqWydcIl0oW14nXCJdKylbJ1wiXS9nLFxuICAgIGV4cG9ydFJlZ2V4ICAgID0gL2V4cG9ydFxccysoPzpkZWZhdWx0XFxzKyk/KD86Y29uc3R8bGV0fHZhcnxjbGFzc3xmdW5jdGlvbnxhc3luY1xccytmdW5jdGlvbnxnZW5lcmF0b3JcXHMrZnVuY3Rpb258YXN5bmNcXHMrZ2VuZXJhdG9yXFxzK2Z1bmN0aW9ufChcXHtbXFxzXFxTXSo/XFx9KSkvZyxcbiAgICBpbXBvcnRSZWdleCAgICA9IC9pbXBvcnRcXHMrKD86KFtcXHctXSspfFxceyhbXn1dKylcXH0pXFxzK2Zyb21cXHMrWydcIl0oW14nXCJdKylbJ1wiXS87XG5cbi8qKlxuICogQHN1bW1hcnkgRXhlY3V0b3IgaW1wbGVtZW50YXRpb24gZm9yIE5lby5tanMgc291cmNlIGNvZGUuXG4gKlxuICogVGhpcyBleGVjdXRvciBpcyByZXNwb25zaWJsZSBmb3IgdGFraW5nIHJhdyBOZW8ubWpzIGNvbXBvbmVudCBjb2RlIChhcyBhIHN0cmluZyksIHJlc29sdmluZyBpdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGV4ZWN1dGluZyBpdCB3aXRoaW4gYSBjb250YWluZXIuIEl0IGhhbmRsZXM6XG4gKiAtICoqRHluYW1pYyBJbXBvcnRzKio6IFBhcnNpbmcgYGltcG9ydGAgc3RhdGVtZW50cyBhbmQgcmVzb2x2aW5nIHRoZW0gYXQgcnVudGltZSB1c2luZyBgUHJvbWlzZS5hbGxgIGFuZCBgaW1wb3J0KClgLlxuICogLSAqKkVudmlyb25tZW50IEhhbmRsaW5nKio6IEFkanVzdGluZyBpbXBvcnQgcGF0aHMgYmFzZWQgb24gdGhlIHJ1bm5pbmcgZW52aXJvbm1lbnQgKGBkZXZlbG9wbWVudGAsIGBkaXN0L2RldmVsb3BtZW50YCwgYGRpc3QvcHJvZHVjdGlvbmApIHRvIGVuc3VyZSBjb3JyZWN0IGZpbGUgcmVzb2x1dGlvbi5cbiAqIC0gKipDb2RlIEV4ZWN1dGlvbioqOiBXcmFwcGluZyB0aGUgY29kZSBpbiBhIGBuZXcgRnVuY3Rpb25gIGNvbnRleHQgdG8gZXhlY3V0ZSBpdCBzYWZlbHkgYW5kIGluamVjdCB0aGUgcmVzdWx0IGludG8gdGhlIHRhcmdldCBjb250YWluZXIuXG4gKiAtICoqTmFtZXNwYWNlIE1hbmFnZW1lbnQqKjogQ2xlYW5pbmcgdXAgcHJldmlvdXMgY2xhc3MgZGVmaW5pdGlvbnMgdG8gYWxsb3cgZm9yIGl0ZXJhdGl2ZSBkZXZlbG9wbWVudCBhbmQgcmUtZXhlY3V0aW9uLlxuICpcbiAqIEBjbGFzcyBOZW8uY29kZS5leGVjdXRvci5OZW9cbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgTmVvRXhlY3V0b3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb2RlLmV4ZWN1dG9yLk5lbydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvZGUuZXhlY3V0b3IuTmVvJ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2VDb2RlXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIGZpbmRDbGFzc05hbWVzKHNvdXJjZUNvZGUpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXSxcbiAgICAgICAgICAgIG1hdGNoO1xuXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBjbGFzc05hbWVSZWdleC5leGVjKHNvdXJjZUNvZGUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKG1hdGNoWzFdKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlQ29kZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kTWFpbkNsYXNzTmFtZShzb3VyY2VDb2RlKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gdGhpcy5maW5kQ2xhc3NOYW1lcyhzb3VyY2VDb2RlKSxcbiAgICAgICAgICAgIG1haW5OYW1lICAgPSBudWxsLFxuICAgICAgICAgICAgcHJpb05hbWVzICA9IFsnTWFpbkNvbnRhaW5lcicsICdNYWluQ29tcG9uZW50JywgJ01haW5WaWV3JywgJ01haW4nXTtcblxuICAgICAgICBpZiAoY2xhc3NOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcHJpb05hbWVzKSB7XG4gICAgICAgICAgICAgICAgbWFpbk5hbWUgPSBjbGFzc05hbWVzLmZpbmQoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5lbmRzV2l0aChuYW1lKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1haW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1haW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgbWFpbk5hbWUgPSBjbGFzc05hbWVzW2NsYXNzTmFtZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYWluTmFtZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBOZW8ubWpzIHNvdXJjZSBjb2RlIHdpdGhpbiB0aGUgZ2l2ZW4gY29udGFpbmVyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgYSBjb21wbGV4IHRyYW5zZm9ybWF0aW9uIHRvIGVtdWxhdGUgYSBuYXRpdmUgbW9kdWxlIGVudmlyb25tZW50IHdpdGhpbiB0aGUgYnJvd3NlcjpcbiAgICAgKiAxLiAgKipJbXBvcnQgUmV3cml0aW5nKio6IEl0IHBhcnNlcyB0aGUgc291cmNlIGZvciBgaW1wb3J0YCBzdGF0ZW1lbnRzIGFuZCBtYXBzIHRoZW0gdG8gZHluYW1pYyBgaW1wb3J0KClgIGNhbGxzLlxuICAgICAqICAgICBDcnVjaWFsbHksIGl0IGFkanVzdHMgcmVsYXRpdmUgcGF0aHMgYmFzZWQgb24gdGhlIGBlbnZpcm9ubWVudGAgKGRldiB2cy4gZGlzdCkgdG8gZW5zdXJlIHRoZSBicm93c2VyIGNhbiByZXNvbHZlIHRoZSBmaWxlcy5cbiAgICAgKiAyLiAgKipQcm9taXNlIFJlc29sdXRpb24qKjogSXQgd3JhcHMgYWxsIGltcG9ydHMgaW4gYSBgUHJvbWlzZS5hbGxgIHRvIGVuc3VyZSBkZXBlbmRlbmNpZXMgYXJlIHJlYWR5IGJlZm9yZSBjb2RlIGV4ZWN1dGlvbi5cbiAgICAgKiAzLiAgKipTYW5kYm94IEV4ZWN1dGlvbioqOiBJdCBjb25zdHJ1Y3RzIGEgZnVuY3Rpb24gYm9keSBzdHJpbmcgYW5kIGV4ZWN1dGVzIGl0IHVzaW5nIGBuZXcgRnVuY3Rpb25gLiBUaGlzIGFsbG93cyB0aGUgY29kZVxuICAgICAqICAgICB0byBydW4gaW4gdGhlIGdsb2JhbCBzY29wZSBidXQgd2l0aCBpbmplY3RlZCB2YXJpYWJsZXMgKGBjb250YWluZXJgLCBgbW9kdWxlYCkuXG4gICAgICogNC4gICoqTmFtZXNwYWNlIENsZWFuaW5nKio6IEl0IGFjdGl2ZWx5IGRlbGV0ZXMgdGhlIHRhcmdldCBjbGFzcyBmcm9tIHRoZSBgTmVvYCBuYW1lc3BhY2UgYmVmb3JlIGV4ZWN1dGlvbi4gVGhpcyBpcyBjcml0aWNhbFxuICAgICAqICAgICBmb3IgKipIb3QgTW9kdWxlIFJlcGxhY2VtZW50IChITVIpKiogd29ya2Zsb3dzLCBlbnN1cmluZyB0aGF0IHJlLXJ1bm5pbmcgdGhlIGNvZGUgYWN0dWFsbHkgdXBkYXRlcyB0aGUgY2xhc3MgZGVmaW5pdGlvblxuICAgICAqICAgICBpbnN0ZWFkIG9mIHVzaW5nIGEgY2FjaGVkIHZlcnNpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5jb2RlXG4gICAgICogQHBhcmFtIHtOZW8uY29udGFpbmVyLkJhc2V9IGRhdGEuY29udGFpbmVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlKHtjb2RlLCBjb250YWluZXJ9KSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7ZW52aXJvbm1lbnR9ICAgICA9IE5lby5jb25maWcsXG4gICAgICAgICAgICBzb3VyY2UgICAgICAgICAgICA9IGNvZGUsXG4gICAgICAgICAgICBjbGFzc05hbWUgICAgICAgICA9IG1lLmZpbmRNYWluQ2xhc3NOYW1lKHNvdXJjZSksXG4gICAgICAgICAgICBjbGVhbkxpbmVzICAgICAgICA9IFtdLFxuICAgICAgICAgICAgbW9kdWxlTmFtZUFuZFBhdGggPSBbXSxcbiAgICAgICAgICAgIHBhcmFtcyAgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICB2YXJzICAgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgY29kZVN0cmluZywgbW9kdWxlLCBwcm9taXNlcztcblxuICAgICAgICBzb3VyY2Uuc3BsaXQoJ1xcbicpLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICBsZXQgaW1wb3J0TWF0Y2ggPSBsaW5lLm1hdGNoKGltcG9ydFJlZ2V4KTtcblxuICAgICAgICAgICAgaWYgKGltcG9ydE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZmF1bHRJbXBvcnQgPSBpbXBvcnRNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZWRJbXBvcnRzICA9IGltcG9ydE1hdGNoWzJdPy5zcGxpdCgnLCcpLm1hcChuYW1lID0+IG5hbWUudHJpbSgpKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCAgICAgICAgICA9IGltcG9ydE1hdGNoWzNdLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChlbnZpcm9ubWVudCA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSAnLi4vJyArIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRoZSBub24tbWluaWZpZWQgdmVyc2lvbiBmb3IgY29kZSB3aGljaCBjYW4gbm90IGdldCBidW5kbGVkLlxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVudmlyb25tZW50ID09PSAnZGlzdC9kZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcuLi8nKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSAnLi4vLi4vLi4vLi4vc3JjLycgKyBwYXRoLnNsaWNlKGluZGV4ICsgMylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGluZGV4KSArICcuLi8uLi8uLi8nICsgcGF0aC5zbGljZShpbmRleCArIDMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRoZSBtaW5pZmllZCB2ZXJzaW9uIG9mIHRoZSBjb2RlIHdoaWNoIGNhbiBub3QgZ2V0IGJ1bmRsZWQuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZW52aXJvbm1lbnQgPT09ICdkaXN0L3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLi4vJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gJy4uLy4uLy4uL2VzbS9zcmMvJyArIHBhdGguc2xpY2UoaW5kZXggKyAzKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaW5kZXgpICsgJy4uLy4uL2VzbS8nICsgcGF0aC5zbGljZShpbmRleCArIDMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lQW5kUGF0aC5wdXNoKHtkZWZhdWx0SW1wb3J0LCBuYW1lZEltcG9ydHMsIHBhdGh9KVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKGV4cG9ydFJlZ2V4KSkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgZXhwb3J0IHN0YXRlbWVudHNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW5MaW5lcy5wdXNoKGAgICAgJHtsaW5lfWApXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb21pc2VzID0gbW9kdWxlTmFtZUFuZFBhdGgubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbW9kdWxlQWxpYXMgPSBgTW9kdWxlJHtpfWA7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChtb2R1bGVBbGlhcyk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kZWZhdWx0SW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgdmFycy5wdXNoKGAgICAgY29uc3QgJHtpdGVtLmRlZmF1bHRJbXBvcnR9ID0gJHttb2R1bGVBbGlhc30uZGVmYXVsdDtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLm5hbWVkSW1wb3J0cykge1xuICAgICAgICAgICAgICAgIHZhcnMucHVzaChgICAgIGNvbnN0IHske2l0ZW0ubmFtZWRJbXBvcnRzLmpvaW4oJywgJyl9fSA9ICR7bW9kdWxlQWxpYXN9O2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGBpbXBvcnQoJyR7aXRlbS5wYXRofScpYFxuICAgICAgICB9KTtcblxuICAgICAgICBjb2RlU3RyaW5nID0gW1xuICAgICAgICAgICAgJ1Byb21pc2UuYWxsKFsnLFxuICAgICAgICAgICAgYCAgICAke3Byb21pc2VzLmpvaW4oJyxcXG4nKX1gLFxuICAgICAgICAgICAgYF0pLnRoZW4oKFske3BhcmFtcy5qb2luKCcsICcpfV0pID0+IHtgLFxuICAgICAgICAgICAgYCR7dmFycy5qb2luKCdcXG4nKX1gLFxuICAgICAgICAgICAgYCAgICAke2NsZWFuTGluZXMuam9pbignXFxuJyl9YCxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgYCAgICBtb2R1bGUgPSBOZW8ubnMoJyR7Y2xhc3NOYW1lfScpO2AsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIGAgICAgaWYgKG1vZHVsZSAmJiAoYCxcbiAgICAgICAgICAgIGAgICAgICAgIE5lby5jb21wb25lbnQuQmFzZS5pc1Byb3RvdHlwZU9mKG1vZHVsZSkgfHxgLFxuICAgICAgICAgICAgYCAgICAgICAgTmVvLmZ1bmN0aW9uYWwuY29tcG9uZW50LkJhc2UuaXNQcm90b3R5cGVPZihtb2R1bGUpYCxcbiAgICAgICAgICAgIGAgICAgKSkge2AsXG4gICAgICAgICAgICBgICAgICAgICBjb250YWluZXIuYWRkKHttb2R1bGV9KWAsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJ30pJyxcbiAgICAgICAgICAgICcuY2F0Y2goZXJyb3IgPT4geycsXG4gICAgICAgICAgICAnICAgIGNvbnNvbGUud2FybihcIkxpdmVQcmV2aWV3IEVycm9yOlwiLCBlcnJvcik7JyxcbiAgICAgICAgICAgICcgICAgY29udGFpbmVyLmFkZCh7bnR5cGU6XFwnY29tcG9uZW50XFwnLCBodG1sOmVycm9yLm1lc3NhZ2V9KTsnLFxuICAgICAgICAgICAgJ30pJ1xuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgIC8vIGRlc3Ryb3ksIHNpbGVudCA9PiBtZXJnZSBjaGFuZ2VzIGludG8gb25lIHVwZGF0ZSBjeWNsZVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQWxsKHRydWUsIHRydWUpO1xuXG4gICAgICAgIC8vIFdlIG11c3QgZW5zdXJlIHRoYXQgY2xhc3NlcyBpbnNpZGUgdGhlIGVkaXRvciB3b24ndCBnZXQgY2FjaGVkLCBzaW5jZSB0aGlzIGRpc2FibGVzIHJ1bi10aW1lIGNoYW5nZXNcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvNTg2M1xuICAgICAgICBtZS5maW5kQ2xhc3NOYW1lcyhjb2RlU3RyaW5nKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbGV0IG5zQXJyYXkgICA9IGl0ZW0uc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBuc0FycmF5LnBvcCgpLFxuICAgICAgICAgICAgICAgIG5zICAgICAgICA9IE5lby5ucyhuc0FycmF5KTtcblxuICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5zW2NsYXNzTmFtZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbignY29udGFpbmVyJywgJ21vZHVsZScsIGNvZGVTdHJpbmcpKGNvbnRhaW5lciwgbW9kdWxlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGQoe1xuICAgICAgICAgICAgICAgIG50eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICBodG1sIDogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoTmVvRXhlY3V0b3IpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==