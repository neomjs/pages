export const __webpack_esm_id__ = "src_code_executor_Neo_mjs";
export const __webpack_esm_ids__ = ["src_code_executor_Neo_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/code/executor/Neo.mjs"
/*!***********************************!*\
  !*** ./src/code/executor/Neo.mjs ***!
  \***********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base.mjs */ "./src/core/Base.mjs");


const
    classNameRegex = /className\s*:\s*['"]([^'"]+)['"]/g,
    exportRegex    = /export\s+(?:default\s+)?(?:const|let|var|class|function|async\s+function|generator\s+function|async\s+generator\s+function|(\{[\s\S]*?\}))/g,
    importRegex    = /import\s+(?:([\w-]+)|\{([^}]+)\})\s+from\s+['"]([^'"]+)['"]/;

/**
 * @summary Executor implementation for Neo.mjs source code.
 *
 * This executor is responsible for taking raw Neo.mjs component code (as a string), resolving its dependencies,
 * and executing it within a container. It handles:
 * - **Dynamic Imports**: Parsing `import` statements and resolving them at runtime using `Promise.all` and `import()`.
 * - **Environment Handling**: Adjusting import paths based on the running environment (`development`, `dist/development`, `dist/production`) to ensure correct file resolution.
 * - **Code Execution**: Wrapping the code in a `new Function` context to execute it safely and inject the result into the target container.
 * - **Namespace Management**: Cleaning up previous class definitions to allow for iterative development and re-execution.
 *
 * @class Neo.code.executor.Neo
 * @extends Neo.core.Base
 */
class NeoExecutor extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.code.executor.Neo'
         * @protected
         */
        className: 'Neo.code.executor.Neo'
    }

    /**
     * @param {String} sourceCode
     * @returns {String[]}
     */
    findClassNames(sourceCode) {
        let classNames = [],
            match;

        while ((match = classNameRegex.exec(sourceCode)) !== null) {
            classNames.push(match[1])
        }

        return classNames
    }

    /**
     * @param {String} sourceCode
     * @returns {String|null}
     */
    findMainClassName(sourceCode) {
        let classNames = this.findClassNames(sourceCode),
            mainName   = null,
            prioNames  = ['MainContainer', 'MainComponent', 'MainView', 'Main'];

        if (classNames.length > 0) {
            for (const name of prioNames) {
                mainName = classNames.find(className => className.endsWith(name));
                if (mainName) {
                    break
                }
            }

            if (!mainName) {
                mainName = classNames[classNames.length - 1]
            }
        }

        return mainName
    }

    /**
     * Executes the provided Neo.mjs source code within the given container.
     *
     * This method performs a complex transformation to emulate a native module environment within the browser:
     * 1.  **Import Rewriting**: It parses the source for `import` statements and maps them to dynamic `import()` calls.
     *     Crucially, it adjusts relative paths based on the `environment` (dev vs. dist) to ensure the browser can resolve the files.
     * 2.  **Promise Resolution**: It wraps all imports in a `Promise.all` to ensure dependencies are ready before code execution.
     * 3.  **Sandbox Execution**: It constructs a function body string and executes it using `new Function`. This allows the code
     *     to run in the global scope but with injected variables (`container`, `module`).
     * 4.  **Namespace Cleaning**: It actively deletes the target class from the `Neo` namespace before execution. This is critical
     *     for **Hot Module Replacement (HMR)** workflows, ensuring that re-running the code actually updates the class definition
     *     instead of using a cached version.
     * @param {Object} data
     * @param {String} data.code
     * @param {Neo.container.Base} data.container
     * @returns {Promise<Object>}
     */
    async execute({code, container}) {
        let me                = this,
            {environment}     = Neo.config,
            source            = code,
            className         = me.findMainClassName(source),
            cleanLines        = [],
            moduleNameAndPath = [],
            params            = [],
            vars              = [],
            codeString, module, promises;

        source.split('\n').forEach(line => {
            let importMatch = line.match(importRegex);

            if (importMatch) {
                let defaultImport = importMatch[1],
                    namedImports  = importMatch[2]?.split(',').map(name => name.trim()),
                    path          = importMatch[3],
                    index;

                if (environment === 'development') {
                    if (path.startsWith('.')) {
                        path = '../' + path
                    }
                }
                // We want the non-minified version for code which can not get bundled.
                else if (environment === 'dist/development') {
                    index = path.lastIndexOf('../');

                    if (index === 0) {
                        path = '../../../../src/' + path.slice(index + 3)
                    } else {
                        path = path.slice(0, index) + '../../../' + path.slice(index + 3)
                    }
                }

                // We want the minified version of the code which can not get bundled.
                else if (environment === 'dist/production') {
                    index = path.lastIndexOf('../');

                    if (index === 0) {
                        path = '../../../esm/src/' + path.slice(index + 3)
                    } else {
                        path = path.slice(0, index) + '../../esm/' + path.slice(index + 3)
                    }
                }

                moduleNameAndPath.push({defaultImport, namedImports, path})
            } else if (line.match(exportRegex)) {
                // Skip export statements
            } else {
                cleanLines.push(`    ${line}`)
            }
        });

        promises = moduleNameAndPath.map((item, i) => {
            let moduleAlias = `Module${i}`;
            params.push(moduleAlias);
            if (item.defaultImport) {
                vars.push(`    const ${item.defaultImport} = ${moduleAlias}.default;`);
            }
            if (item.namedImports) {
                vars.push(`    const {${item.namedImports.join(', ')}} = ${moduleAlias};`);
            }
            return `import('${item.path}')`
        });

        codeString = [
            'Promise.all([',
            `    ${promises.join(',\n')}`,
            `]).then(([${params.join(', ')}]) => {`,
            `${vars.join('\n')}`,
            `    ${cleanLines.join('\n')}`,
            '',
            `    module = Neo.ns('${className}');`,
            '',
            `    if (module && (`,
            `        Neo.component.Base.isPrototypeOf(module) ||`,
            `        Neo.functional.component.Base.isPrototypeOf(module)`,
            `    )) {`,
            `        container.add({module})`,
            '    }',
            '})',
            '.catch(error => {',
            '    console.warn("LivePreview Error:", error);',
            '    container.add({ntype:\'component\', html:error.message});',
            '})'
        ].join('\n');

        // destroy, silent => merge changes into one update cycle
        container.removeAll(true, true);

        // We must ensure that classes inside the editor won't get cached, since this disables run-time changes
        // See: https://github.com/neomjs/neo/issues/5863
        me.findClassNames(codeString).forEach(item => {
            let nsArray   = item.split('.'),
                className = nsArray.pop(),
                ns        = Neo.ns(nsArray);

            if (ns) {
                delete ns[className]
            }
        });

        try {
            new Function('container', 'module', codeString)(container, module);
        } catch (error) {
            container.add({
                ntype: 'component',
                html : error.message
            })
        }

        return {}
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(NeoExecutor));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC9zcmNfY29kZV9leGVjdXRvcl9OZW9fbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF1Qzs7QUFFdkM7QUFDQTtBQUNBLG9KQUFvSixVQUFVO0FBQzlKLDZDQUE2QyxJQUFJLEtBQUs7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFJO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsb0JBQW9CO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGtDQUFrQztBQUMxRSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2QsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQSxTQUFTOztBQUVUO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0IsSUFBSSxZQUFZLFNBQVM7QUFDcEY7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLCtCQUErQixJQUFJLGFBQWE7QUFDeEY7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QyxTQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDLHlCQUF5QixrQkFBa0IsT0FBTztBQUNsRCxlQUFlLGdCQUFnQjtBQUMvQixtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0Esb0NBQW9DLFVBQVUsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQ0FBb0MsT0FBTztBQUMzQyxrQkFBa0I7QUFDbEIsY0FBYztBQUNkLDhCQUE4QjtBQUM5QiwyREFBMkQ7QUFDM0QsZ0NBQWdDLHdDQUF3QyxFQUFFO0FBQzFFLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvY29kZS9leGVjdXRvci9OZW8ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlIGZyb20gJy4uLy4uL2NvcmUvQmFzZS5tanMnO1xuXG5jb25zdFxuICAgIGNsYXNzTmFtZVJlZ2V4ID0gL2NsYXNzTmFtZVxccyo6XFxzKlsnXCJdKFteJ1wiXSspWydcIl0vZyxcbiAgICBleHBvcnRSZWdleCAgICA9IC9leHBvcnRcXHMrKD86ZGVmYXVsdFxccyspPyg/OmNvbnN0fGxldHx2YXJ8Y2xhc3N8ZnVuY3Rpb258YXN5bmNcXHMrZnVuY3Rpb258Z2VuZXJhdG9yXFxzK2Z1bmN0aW9ufGFzeW5jXFxzK2dlbmVyYXRvclxccytmdW5jdGlvbnwoXFx7W1xcc1xcU10qP1xcfSkpL2csXG4gICAgaW1wb3J0UmVnZXggICAgPSAvaW1wb3J0XFxzKyg/OihbXFx3LV0rKXxcXHsoW159XSspXFx9KVxccytmcm9tXFxzK1snXCJdKFteJ1wiXSspWydcIl0vO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEV4ZWN1dG9yIGltcGxlbWVudGF0aW9uIGZvciBOZW8ubWpzIHNvdXJjZSBjb2RlLlxuICpcbiAqIFRoaXMgZXhlY3V0b3IgaXMgcmVzcG9uc2libGUgZm9yIHRha2luZyByYXcgTmVvLm1qcyBjb21wb25lbnQgY29kZSAoYXMgYSBzdHJpbmcpLCByZXNvbHZpbmcgaXRzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBleGVjdXRpbmcgaXQgd2l0aGluIGEgY29udGFpbmVyLiBJdCBoYW5kbGVzOlxuICogLSAqKkR5bmFtaWMgSW1wb3J0cyoqOiBQYXJzaW5nIGBpbXBvcnRgIHN0YXRlbWVudHMgYW5kIHJlc29sdmluZyB0aGVtIGF0IHJ1bnRpbWUgdXNpbmcgYFByb21pc2UuYWxsYCBhbmQgYGltcG9ydCgpYC5cbiAqIC0gKipFbnZpcm9ubWVudCBIYW5kbGluZyoqOiBBZGp1c3RpbmcgaW1wb3J0IHBhdGhzIGJhc2VkIG9uIHRoZSBydW5uaW5nIGVudmlyb25tZW50IChgZGV2ZWxvcG1lbnRgLCBgZGlzdC9kZXZlbG9wbWVudGAsIGBkaXN0L3Byb2R1Y3Rpb25gKSB0byBlbnN1cmUgY29ycmVjdCBmaWxlIHJlc29sdXRpb24uXG4gKiAtICoqQ29kZSBFeGVjdXRpb24qKjogV3JhcHBpbmcgdGhlIGNvZGUgaW4gYSBgbmV3IEZ1bmN0aW9uYCBjb250ZXh0IHRvIGV4ZWN1dGUgaXQgc2FmZWx5IGFuZCBpbmplY3QgdGhlIHJlc3VsdCBpbnRvIHRoZSB0YXJnZXQgY29udGFpbmVyLlxuICogLSAqKk5hbWVzcGFjZSBNYW5hZ2VtZW50Kio6IENsZWFuaW5nIHVwIHByZXZpb3VzIGNsYXNzIGRlZmluaXRpb25zIHRvIGFsbG93IGZvciBpdGVyYXRpdmUgZGV2ZWxvcG1lbnQgYW5kIHJlLWV4ZWN1dGlvbi5cbiAqXG4gKiBAY2xhc3MgTmVvLmNvZGUuZXhlY3V0b3IuTmVvXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIE5lb0V4ZWN1dG9yIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29kZS5leGVjdXRvci5OZW8nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5jb2RlLmV4ZWN1dG9yLk5lbydcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlQ29kZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBmaW5kQ2xhc3NOYW1lcyhzb3VyY2VDb2RlKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW10sXG4gICAgICAgICAgICBtYXRjaDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gY2xhc3NOYW1lUmVnZXguZXhlYyhzb3VyY2VDb2RlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaChtYXRjaFsxXSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZUNvZGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZmluZE1haW5DbGFzc05hbWUoc291cmNlQ29kZSkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IHRoaXMuZmluZENsYXNzTmFtZXMoc291cmNlQ29kZSksXG4gICAgICAgICAgICBtYWluTmFtZSAgID0gbnVsbCxcbiAgICAgICAgICAgIHByaW9OYW1lcyAgPSBbJ01haW5Db250YWluZXInLCAnTWFpbkNvbXBvbmVudCcsICdNYWluVmlldycsICdNYWluJ107XG5cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHByaW9OYW1lcykge1xuICAgICAgICAgICAgICAgIG1haW5OYW1lID0gY2xhc3NOYW1lcy5maW5kKGNsYXNzTmFtZSA9PiBjbGFzc05hbWUuZW5kc1dpdGgobmFtZSkpO1xuICAgICAgICAgICAgICAgIGlmIChtYWluTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtYWluTmFtZSkge1xuICAgICAgICAgICAgICAgIG1haW5OYW1lID0gY2xhc3NOYW1lc1tjbGFzc05hbWVzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFpbk5hbWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgTmVvLm1qcyBzb3VyY2UgY29kZSB3aXRoaW4gdGhlIGdpdmVuIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGEgY29tcGxleCB0cmFuc2Zvcm1hdGlvbiB0byBlbXVsYXRlIGEgbmF0aXZlIG1vZHVsZSBlbnZpcm9ubWVudCB3aXRoaW4gdGhlIGJyb3dzZXI6XG4gICAgICogMS4gICoqSW1wb3J0IFJld3JpdGluZyoqOiBJdCBwYXJzZXMgdGhlIHNvdXJjZSBmb3IgYGltcG9ydGAgc3RhdGVtZW50cyBhbmQgbWFwcyB0aGVtIHRvIGR5bmFtaWMgYGltcG9ydCgpYCBjYWxscy5cbiAgICAgKiAgICAgQ3J1Y2lhbGx5LCBpdCBhZGp1c3RzIHJlbGF0aXZlIHBhdGhzIGJhc2VkIG9uIHRoZSBgZW52aXJvbm1lbnRgIChkZXYgdnMuIGRpc3QpIHRvIGVuc3VyZSB0aGUgYnJvd3NlciBjYW4gcmVzb2x2ZSB0aGUgZmlsZXMuXG4gICAgICogMi4gICoqUHJvbWlzZSBSZXNvbHV0aW9uKio6IEl0IHdyYXBzIGFsbCBpbXBvcnRzIGluIGEgYFByb21pc2UuYWxsYCB0byBlbnN1cmUgZGVwZW5kZW5jaWVzIGFyZSByZWFkeSBiZWZvcmUgY29kZSBleGVjdXRpb24uXG4gICAgICogMy4gICoqU2FuZGJveCBFeGVjdXRpb24qKjogSXQgY29uc3RydWN0cyBhIGZ1bmN0aW9uIGJvZHkgc3RyaW5nIGFuZCBleGVjdXRlcyBpdCB1c2luZyBgbmV3IEZ1bmN0aW9uYC4gVGhpcyBhbGxvd3MgdGhlIGNvZGVcbiAgICAgKiAgICAgdG8gcnVuIGluIHRoZSBnbG9iYWwgc2NvcGUgYnV0IHdpdGggaW5qZWN0ZWQgdmFyaWFibGVzIChgY29udGFpbmVyYCwgYG1vZHVsZWApLlxuICAgICAqIDQuICAqKk5hbWVzcGFjZSBDbGVhbmluZyoqOiBJdCBhY3RpdmVseSBkZWxldGVzIHRoZSB0YXJnZXQgY2xhc3MgZnJvbSB0aGUgYE5lb2AgbmFtZXNwYWNlIGJlZm9yZSBleGVjdXRpb24uIFRoaXMgaXMgY3JpdGljYWxcbiAgICAgKiAgICAgZm9yICoqSG90IE1vZHVsZSBSZXBsYWNlbWVudCAoSE1SKSoqIHdvcmtmbG93cywgZW5zdXJpbmcgdGhhdCByZS1ydW5uaW5nIHRoZSBjb2RlIGFjdHVhbGx5IHVwZGF0ZXMgdGhlIGNsYXNzIGRlZmluaXRpb25cbiAgICAgKiAgICAgaW5zdGVhZCBvZiB1c2luZyBhIGNhY2hlZCB2ZXJzaW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuY29kZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRhaW5lci5CYXNlfSBkYXRhLmNvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZSh7Y29kZSwgY29udGFpbmVyfSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Vudmlyb25tZW50fSAgICAgPSBOZW8uY29uZmlnLFxuICAgICAgICAgICAgc291cmNlICAgICAgICAgICAgPSBjb2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lICAgICAgICAgPSBtZS5maW5kTWFpbkNsYXNzTmFtZShzb3VyY2UpLFxuICAgICAgICAgICAgY2xlYW5MaW5lcyAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIG1vZHVsZU5hbWVBbmRQYXRoID0gW10sXG4gICAgICAgICAgICBwYXJhbXMgICAgICAgICAgICA9IFtdLFxuICAgICAgICAgICAgdmFycyAgICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGNvZGVTdHJpbmcsIG1vZHVsZSwgcHJvbWlzZXM7XG5cbiAgICAgICAgc291cmNlLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgbGV0IGltcG9ydE1hdGNoID0gbGluZS5tYXRjaChpbXBvcnRSZWdleCk7XG5cbiAgICAgICAgICAgIGlmIChpbXBvcnRNYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0SW1wb3J0ID0gaW1wb3J0TWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgIG5hbWVkSW1wb3J0cyAgPSBpbXBvcnRNYXRjaFsyXT8uc3BsaXQoJywnKS5tYXAobmFtZSA9PiBuYW1lLnRyaW0oKSksXG4gICAgICAgICAgICAgICAgICAgIHBhdGggICAgICAgICAgPSBpbXBvcnRNYXRjaFszXSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW52aXJvbm1lbnQgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gJy4uLycgKyBwYXRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0aGUgbm9uLW1pbmlmaWVkIHZlcnNpb24gZm9yIGNvZGUgd2hpY2ggY2FuIG5vdCBnZXQgYnVuZGxlZC5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnZpcm9ubWVudCA9PT0gJ2Rpc3QvZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLi4vJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gJy4uLy4uLy4uLy4uL3NyYy8nICsgcGF0aC5zbGljZShpbmRleCArIDMpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBpbmRleCkgKyAnLi4vLi4vLi4vJyArIHBhdGguc2xpY2UoaW5kZXggKyAzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0aGUgbWluaWZpZWQgdmVyc2lvbiBvZiB0aGUgY29kZSB3aGljaCBjYW4gbm90IGdldCBidW5kbGVkLlxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVudmlyb25tZW50ID09PSAnZGlzdC9wcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy4uLycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9ICcuLi8uLi8uLi9lc20vc3JjLycgKyBwYXRoLnNsaWNlKGluZGV4ICsgMylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGluZGV4KSArICcuLi8uLi9lc20vJyArIHBhdGguc2xpY2UoaW5kZXggKyAzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZUFuZFBhdGgucHVzaCh7ZGVmYXVsdEltcG9ydCwgbmFtZWRJbXBvcnRzLCBwYXRofSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5tYXRjaChleHBvcnRSZWdleCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGV4cG9ydCBzdGF0ZW1lbnRzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFuTGluZXMucHVzaChgICAgICR7bGluZX1gKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9taXNlcyA9IG1vZHVsZU5hbWVBbmRQYXRoLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG1vZHVsZUFsaWFzID0gYE1vZHVsZSR7aX1gO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gobW9kdWxlQWxpYXMpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uZGVmYXVsdEltcG9ydCkge1xuICAgICAgICAgICAgICAgIHZhcnMucHVzaChgICAgIGNvbnN0ICR7aXRlbS5kZWZhdWx0SW1wb3J0fSA9ICR7bW9kdWxlQWxpYXN9LmRlZmF1bHQ7YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5uYW1lZEltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICB2YXJzLnB1c2goYCAgICBjb25zdCB7JHtpdGVtLm5hbWVkSW1wb3J0cy5qb2luKCcsICcpfX0gPSAke21vZHVsZUFsaWFzfTtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgaW1wb3J0KCcke2l0ZW0ucGF0aH0nKWBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29kZVN0cmluZyA9IFtcbiAgICAgICAgICAgICdQcm9taXNlLmFsbChbJyxcbiAgICAgICAgICAgIGAgICAgJHtwcm9taXNlcy5qb2luKCcsXFxuJyl9YCxcbiAgICAgICAgICAgIGBdKS50aGVuKChbJHtwYXJhbXMuam9pbignLCAnKX1dKSA9PiB7YCxcbiAgICAgICAgICAgIGAke3ZhcnMuam9pbignXFxuJyl9YCxcbiAgICAgICAgICAgIGAgICAgJHtjbGVhbkxpbmVzLmpvaW4oJ1xcbicpfWAsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIGAgICAgbW9kdWxlID0gTmVvLm5zKCcke2NsYXNzTmFtZX0nKTtgLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBgICAgIGlmIChtb2R1bGUgJiYgKGAsXG4gICAgICAgICAgICBgICAgICAgICBOZW8uY29tcG9uZW50LkJhc2UuaXNQcm90b3R5cGVPZihtb2R1bGUpIHx8YCxcbiAgICAgICAgICAgIGAgICAgICAgIE5lby5mdW5jdGlvbmFsLmNvbXBvbmVudC5CYXNlLmlzUHJvdG90eXBlT2YobW9kdWxlKWAsXG4gICAgICAgICAgICBgICAgICkpIHtgLFxuICAgICAgICAgICAgYCAgICAgICAgY29udGFpbmVyLmFkZCh7bW9kdWxlfSlgLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICd9KScsXG4gICAgICAgICAgICAnLmNhdGNoKGVycm9yID0+IHsnLFxuICAgICAgICAgICAgJyAgICBjb25zb2xlLndhcm4oXCJMaXZlUHJldmlldyBFcnJvcjpcIiwgZXJyb3IpOycsXG4gICAgICAgICAgICAnICAgIGNvbnRhaW5lci5hZGQoe250eXBlOlxcJ2NvbXBvbmVudFxcJywgaHRtbDplcnJvci5tZXNzYWdlfSk7JyxcbiAgICAgICAgICAgICd9KSdcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcblxuICAgICAgICAvLyBkZXN0cm95LCBzaWxlbnQgPT4gbWVyZ2UgY2hhbmdlcyBpbnRvIG9uZSB1cGRhdGUgY3ljbGVcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUFsbCh0cnVlLCB0cnVlKTtcblxuICAgICAgICAvLyBXZSBtdXN0IGVuc3VyZSB0aGF0IGNsYXNzZXMgaW5zaWRlIHRoZSBlZGl0b3Igd29uJ3QgZ2V0IGNhY2hlZCwgc2luY2UgdGhpcyBkaXNhYmxlcyBydW4tdGltZSBjaGFuZ2VzXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzU4NjNcbiAgICAgICAgbWUuZmluZENsYXNzTmFtZXMoY29kZVN0cmluZykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBuc0FycmF5ICAgPSBpdGVtLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gbnNBcnJheS5wb3AoKSxcbiAgICAgICAgICAgICAgICBucyAgICAgICAgPSBOZW8ubnMobnNBcnJheSk7XG5cbiAgICAgICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuc1tjbGFzc05hbWVdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgRnVuY3Rpb24oJ2NvbnRhaW5lcicsICdtb2R1bGUnLCBjb2RlU3RyaW5nKShjb250YWluZXIsIG1vZHVsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkKHtcbiAgICAgICAgICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgaHRtbCA6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge31cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE5lb0V4ZWN1dG9yKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==