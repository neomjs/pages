export const __webpack_esm_id__ = "vendors-src_table_plugin_CellEditing_mjs";
export const __webpack_esm_ids__ = ["vendors-src_table_plugin_CellEditing_mjs"];
export const __webpack_esm_modules__ = {

/***/ "./src/plugin/Base.mjs"
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ },

/***/ "./src/table/plugin/CellEditing.mjs"
/*!******************************************!*\
  !*** ./src/table/plugin/CellEditing.mjs ***!
  \******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.table.plugin.CellEditing
 * @extends Neo.plugin.Base
 */
class CellEditing extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.table.plugin.CellEditing'
         * @protected
         */
        className: 'Neo.table.plugin.CellEditing',
        /**
         * @member {String} ntype='plugin-table-cell-editing'
         * @protected
         */
        ntype: 'plugin-table-cell-editing',
        /**
         * @member {String} cellCls='neo-table-cell'
         */
        cellCls: 'neo-table-cell',
        /**
         * @member {Boolean} disabled_=false
         * @reactive
         */
        disabled_: false,
        /**
         * @member {String[]} editorCls=['neo-table-editor']
         */
        editorCls: ['neo-table-editor'],
        /**
         * @member {Boolean} focusCells=true
         */
        focusCells: true
    }

    /**
     * Storing editor instances per column
     * @member {Object} editors={}
     */
    editors = {}
    /**
     * Storing the currently mounted editor
     * @member {Neo.form.field.Base|null} mountedEditor=null
     */
    mountedEditor = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me               = this,
            {owner}          = me,
            {selectionModel} = owner;

        owner.on({
            cellDoubleClick     : me.onCellDoubleClick,
            focusLeave          : me.onFocusLeave,
            selectionModelChange: me.onSelectionModelChange,
            scope               : me
        });

        // Connect an already registered selectionModel instance
        if (Neo.typeOf(selectionModel) === 'NeoInstance') {
            me.onSelectionModelChange({value: selectionModel})
        }

        owner.body.keys.add({
            Enter: 'onTableKeyDown',
            Space: 'onTableKeyDown',
            scope: me
        })
    }

    /**
     * Triggered after the disabled config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisabled(value, oldValue) {
        oldValue && this.unmountEditor()
    }

    /**
     * @param {args} args
     */
    destroy(...args) {
        Object.values(this.editors).forEach(editor => {
            editor.destroy(false, true)
        });

        super.destroy(...args)
    }

    /**
     * @param {Object} record
     * @param {String} dataField
     * @returns {Promise<void>}
     */
    async mountEditor(record, dataField) {
        if (this.disabled) {
            return
        }

        let me                  = this,
            {appName, windowId} = me,
            {body}              = me.owner,
            cellId              = body.getCellId(record, dataField),
            cellNode            = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(body.vdom, cellId).vdom,
            column              = me.owner.headerToolbar.getColumn(dataField),
            editor              = me.editors[dataField],
            value               = record[dataField],
            keys;

        if (me.mountedEditor) {
            await me.unmountEditor();
            await me.timeout(10)
        }

        if (!column.editable) {
            return
        }

        if (!editor) {
            me.editors[dataField] = editor = Neo.create({
                module   : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                appName,
                cls      : me.editorCls,
                dataField,
                hideLabel: true,
                parentId : body.id,
                record,
                value,
                windowId,

                ...column.editor
            });

            keys = {
                Enter : 'onEditorKeyEnter',
                Escape: 'onEditorKeyEscape',
                Tab   : 'onEditorKeyTab',
                scope : me
            };

            if (editor.keys) {
                editor.keys.add(keys)
            } else {
                editor.keys = keys
            }
        } else {
            editor.originalConfig.value = value;
            editor.setSilent({record, value})
        }

        me.mountedEditor = editor;

        cellNode.cn = [editor.createVdomReference()];
        delete cellNode.html;

        body.updateDepth = -1;

        await body.promiseUpdate();

        await me.timeout(30);

        editor.focus()
    }

    /**
     *
     * @param {Object} data
     * @param {Neo.table.Body} data.body
     * @param {Object}         data.data
     * @param {String}         data.dataField
     * @param {Object}         data.record
     * @returns {Promise<void>}
     */
    async onCellDoubleClick({body, data, dataField, record}) {
        await this.mountEditor(record, dataField)
    }

    /**
     * @param {Object} data
     * @param {Neo.form.field.Base} field
     * @returns {Promise<void>}
     */
    async onEditorKeyEnter(data, field) {
        let me = this;

        await me.submitEditor();
        await me.timeout(20);
        me.selectCell(data)
    }

    /**
     * @param {Object} data
     * @param {Neo.form.field.Base} field
     * @returns {Promise<void>}
     */
    async onEditorKeyEscape(data, field) {
        let me = this;

        await me.unmountEditor();
        await me.timeout(20);
        me.selectCell(data)
    }

    /**
     * @param {Object} event
     * @param {Neo.form.field.Base} field
     * @returns {Promise<void>}
     */
    async onEditorKeyTab(event, field) {
        let me           = this,
            {store}      = me.owner,
            oldIndex     = store.indexOf(field.record),
            countRecords = store.getCount(),
            index        = (oldIndex + (event.altKey ? -1 : 1) + countRecords) % countRecords,
            record       = store.getAt(index);

        await me.submitEditor();
        await me.mountEditor(record, field.dataField)
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onFocusLeave(data) {
        await this.unmountEditor()
    }

    /**
     * @param {Object} data
     */
    onSelectionChange(data) {
        // todo: Once we separate cell selections & focus, we can use this event to mount editors
        // console.log('onSelectionChange', data);
    }

    /**
     * @param {Object} data
     */
    onSelectionModelChange(data) {
        let selectionModel = data.value;

        if (selectionModel.ntype.includes('cell')) {
            selectionModel.on('selectionChange', this.onSelectionChange, this)
        }
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onTableKeyDown(data) {
        let me       = this,
            {target} = data,
            {body}   = me.owner,
            dataField, record;

        if (!me.mountedEditor && target.cls?.includes('neo-selected')) {
            dataField = body.getCellDataField(target.id);
            record    = body.getRecord(target.id);

            await me.mountEditor(record, dataField)
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.path
     */
    selectCell({path}) {
        let me               = this,
            {selectionModel} = me.owner,
            i                = 0,
            len              = path.length,
            cellId;

        for (; i < len; i++) {
            if (path[i].cls?.includes(me.cellCls)) {
                cellId = path[i].id;
                break
            }
        }

        if (cellId) {
            selectionModel?.deselect(cellId, true); // the cell might still count as selected => silent deselect first
            selectionModel?.select(cellId);
            me.focusCells && me.owner.focus(cellId)
        }
    }

    /**
     * If the field is valid:
     * Updates the record field, in case the value of the editor changed,
     * otherwise unmounts the editor
     * @returns {Promise<void>}
     */
    async submitEditor() {
        let me    = this,
            field = me.mountedEditor;

        if (field?.isValid()) {
            if (field.isDirty) {
                me.mountedEditor = null;
                field.record[field.dataField] = field.getSubmitValue()
            } else {
                await me.unmountEditor()
            }
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async unmountEditor() {
        if (!this.mountedEditor) {
            return
        }

        let me       = this,
            record   = me.mountedEditor.record,
            {body}   = me.owner,
            rowIndex = body.store.indexOf(record);

        me.mountedEditor = null;

        body.getVdomRoot().cn[rowIndex] = body.createRow({record, rowIndex});
        await body.promiseUpdate()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CellEditing));


/***/ }

};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190YWJsZV9wbHVnaW5fQ2VsbEVkaXRpbmdfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUk7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEsT0FBTyxXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsc0JBQXNCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZGUTtBQUNJO0FBQ047O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFNO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTs7QUFFQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSwyQkFBMkIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25lby5tanMvLi9zcmMvcGx1Z2luL0Jhc2UubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdGFibGUvcGx1Z2luL0NlbGxFZGl0aW5nLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZSBmcm9tICcuLi9jb3JlL0Jhc2UubWpzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBwbHVnaW4gaW1wbGVtZW50YXRpb25zLlxuICogUGx1Z2lucyBhcmUgaW50ZW5kZWQgdG8gZ2V0IHB1dCBpbnRvIHRoZSBwbHVnaW5zIGNvbmZpZyBvZiBjb21wb25lbnQuQmFzZVxuICogdG8gZW5oYW5jZSB0aGVtIG9yIGFkZCBhZGRpdGlvbmFsIGZlYXR1cmVzXG4gKiBAY2xhc3MgTmVvLnBsdWdpbi5CYXNlXG4gKiBAZXh0ZW5kcyBOZW8uY29yZS5CYXNlXG4gKi9cbmNsYXNzIFBsdWdpbiBleHRlbmRzIEJhc2Uge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnBsdWdpbi5CYXNlJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8ucGx1Z2luLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHBsdWdpbiBudHlwZXMgbmVlZCB0byBzdGFydCB3aXRoICdwbHVnaW4tJyB0byBlbnN1cmUgdGhhdCBjb21wb25lbnQuQmFzZTogZ2V0UGx1Z2luKCkgY2FuIGZpbmQgdGhlbVxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4nXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZX0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB3aW5kb3dJZF89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvd0lkXzogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtvd25lcn0gPSBtZTtcblxuICAgICAgICBpZiAob3duZXIuaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgbWUub25Pd25lckNvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG93bmVyLm9uKCdjb25zdHJ1Y3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5vbk93bmVyQ29uc3RydWN0ZWQoKVxuICAgICAgICAgICAgfSwgbWUsIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvd25lci5tb3VudGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyTW91bnRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIub24oJ21vdW50ZWQnLCBtZS5vbk93bmVyTW91bnRlZCwgbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSB3aW5kb3dJZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0V2luZG93SWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhbHVlICYmIE5lby5jdXJyZW50V29ya2VyLmluc2VydFRoZW1lRmlsZXModmFsdWUsIHRoaXMuX19wcm90b19fKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG93bmVyIENvbXBvbmVudCB3aGVuIGl0IGlzIGNvbnN0cnVjdGVkXG4gICAgICovXG4gICAgb25Pd25lckNvbnN0cnVjdGVkKCkge1xuICAgICAgICBsZXQge293bmVyfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKG93bmVyLndpbmRvd0lkKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd0lkID0gb3duZXIud2luZG93SWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFwcGx5IGNoYW5nZXMgdG8gdGhlIG93bmVyIENvbXBvbmVudCB3aGVuIGl0IGRvZXMgZ2V0IG1vdW50ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyTW91bnRlZCgpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoUGx1Z2luKTtcbiIsImltcG9ydCBQbHVnaW4gICAgZnJvbSAnLi4vLi4vcGx1Z2luL0Jhc2UubWpzJztcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnLi4vLi4vZm9ybS9maWVsZC9UZXh0Lm1qcyc7XG5pbXBvcnQgVmRvbVV0aWwgIGZyb20gJy4uLy4uL3V0aWwvVkRvbS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8udGFibGUucGx1Z2luLkNlbGxFZGl0aW5nXG4gKiBAZXh0ZW5kcyBOZW8ucGx1Z2luLkJhc2VcbiAqL1xuY2xhc3MgQ2VsbEVkaXRpbmcgZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLnRhYmxlLnBsdWdpbi5DZWxsRWRpdGluZydcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLnRhYmxlLnBsdWdpbi5DZWxsRWRpdGluZycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdwbHVnaW4tdGFibGUtY2VsbC1lZGl0aW5nJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ3BsdWdpbi10YWJsZS1jZWxsLWVkaXRpbmcnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjZWxsQ2xzPSduZW8tdGFibGUtY2VsbCdcbiAgICAgICAgICovXG4gICAgICAgIGNlbGxDbHM6ICduZW8tdGFibGUtY2VsbCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBkaXNhYmxlZF89ZmFsc2VcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGVkaXRvckNscz1bJ25lby10YWJsZS1lZGl0b3InXVxuICAgICAgICAgKi9cbiAgICAgICAgZWRpdG9yQ2xzOiBbJ25lby10YWJsZS1lZGl0b3InXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGZvY3VzQ2VsbHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9jdXNDZWxsczogdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgZWRpdG9yIGluc3RhbmNlcyBwZXIgY29sdW1uXG4gICAgICogQG1lbWJlciB7T2JqZWN0fSBlZGl0b3JzPXt9XG4gICAgICovXG4gICAgZWRpdG9ycyA9IHt9XG4gICAgLyoqXG4gICAgICogU3RvcmluZyB0aGUgY3VycmVudGx5IG1vdW50ZWQgZWRpdG9yXG4gICAgICogQG1lbWJlciB7TmVvLmZvcm0uZmllbGQuQmFzZXxudWxsfSBtb3VudGVkRWRpdG9yPW51bGxcbiAgICAgKi9cbiAgICBtb3VudGVkRWRpdG9yID0gbnVsbFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSAgICAgICAgICA9IG1lLFxuICAgICAgICAgICAge3NlbGVjdGlvbk1vZGVsfSA9IG93bmVyO1xuXG4gICAgICAgIG93bmVyLm9uKHtcbiAgICAgICAgICAgIGNlbGxEb3VibGVDbGljayAgICAgOiBtZS5vbkNlbGxEb3VibGVDbGljayxcbiAgICAgICAgICAgIGZvY3VzTGVhdmUgICAgICAgICAgOiBtZS5vbkZvY3VzTGVhdmUsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbENoYW5nZTogbWUub25TZWxlY3Rpb25Nb2RlbENoYW5nZSxcbiAgICAgICAgICAgIHNjb3BlICAgICAgICAgICAgICAgOiBtZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb25uZWN0IGFuIGFscmVhZHkgcmVnaXN0ZXJlZCBzZWxlY3Rpb25Nb2RlbCBpbnN0YW5jZVxuICAgICAgICBpZiAoTmVvLnR5cGVPZihzZWxlY3Rpb25Nb2RlbCkgPT09ICdOZW9JbnN0YW5jZScpIHtcbiAgICAgICAgICAgIG1lLm9uU2VsZWN0aW9uTW9kZWxDaGFuZ2Uoe3ZhbHVlOiBzZWxlY3Rpb25Nb2RlbH0pXG4gICAgICAgIH1cblxuICAgICAgICBvd25lci5ib2R5LmtleXMuYWRkKHtcbiAgICAgICAgICAgIEVudGVyOiAnb25UYWJsZUtleURvd24nLFxuICAgICAgICAgICAgU3BhY2U6ICdvblRhYmxlS2V5RG93bicsXG4gICAgICAgICAgICBzY29wZTogbWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRpc2FibGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RGlzYWJsZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIG9sZFZhbHVlICYmIHRoaXMudW5tb3VudEVkaXRvcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcmdzfSBhcmdzXG4gICAgICovXG4gICAgZGVzdHJveSguLi5hcmdzKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5lZGl0b3JzKS5mb3JFYWNoKGVkaXRvciA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuZGVzdHJveShmYWxzZSwgdHJ1ZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSguLi5hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpZWxkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgbW91bnRFZGl0b3IocmVjb3JkLCBkYXRhRmllbGQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2FwcE5hbWUsIHdpbmRvd0lkfSA9IG1lLFxuICAgICAgICAgICAge2JvZHl9ICAgICAgICAgICAgICA9IG1lLm93bmVyLFxuICAgICAgICAgICAgY2VsbElkICAgICAgICAgICAgICA9IGJvZHkuZ2V0Q2VsbElkKHJlY29yZCwgZGF0YUZpZWxkKSxcbiAgICAgICAgICAgIGNlbGxOb2RlICAgICAgICAgICAgPSBWZG9tVXRpbC5maW5kKGJvZHkudmRvbSwgY2VsbElkKS52ZG9tLFxuICAgICAgICAgICAgY29sdW1uICAgICAgICAgICAgICA9IG1lLm93bmVyLmhlYWRlclRvb2xiYXIuZ2V0Q29sdW1uKGRhdGFGaWVsZCksXG4gICAgICAgICAgICBlZGl0b3IgICAgICAgICAgICAgID0gbWUuZWRpdG9yc1tkYXRhRmllbGRdLFxuICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA9IHJlY29yZFtkYXRhRmllbGRdLFxuICAgICAgICAgICAga2V5cztcblxuICAgICAgICBpZiAobWUubW91bnRlZEVkaXRvcikge1xuICAgICAgICAgICAgYXdhaXQgbWUudW5tb3VudEVkaXRvcigpO1xuICAgICAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29sdW1uLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgICAgICBtZS5lZGl0b3JzW2RhdGFGaWVsZF0gPSBlZGl0b3IgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgICAgICBhcHBOYW1lLFxuICAgICAgICAgICAgICAgIGNscyAgICAgIDogbWUuZWRpdG9yQ2xzLFxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZCxcbiAgICAgICAgICAgICAgICBoaWRlTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgOiBib2R5LmlkLFxuICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCxcblxuICAgICAgICAgICAgICAgIC4uLmNvbHVtbi5lZGl0b3JcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBrZXlzID0ge1xuICAgICAgICAgICAgICAgIEVudGVyIDogJ29uRWRpdG9yS2V5RW50ZXInLFxuICAgICAgICAgICAgICAgIEVzY2FwZTogJ29uRWRpdG9yS2V5RXNjYXBlJyxcbiAgICAgICAgICAgICAgICBUYWIgICA6ICdvbkVkaXRvcktleVRhYicsXG4gICAgICAgICAgICAgICAgc2NvcGUgOiBtZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGVkaXRvci5rZXlzKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmtleXMuYWRkKGtleXMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkaXRvci5rZXlzID0ga2V5c1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRpdG9yLm9yaWdpbmFsQ29uZmlnLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0U2lsZW50KHtyZWNvcmQsIHZhbHVlfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLm1vdW50ZWRFZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgICAgY2VsbE5vZGUuY24gPSBbZWRpdG9yLmNyZWF0ZVZkb21SZWZlcmVuY2UoKV07XG4gICAgICAgIGRlbGV0ZSBjZWxsTm9kZS5odG1sO1xuXG4gICAgICAgIGJvZHkudXBkYXRlRGVwdGggPSAtMTtcblxuICAgICAgICBhd2FpdCBib2R5LnByb21pc2VVcGRhdGUoKTtcblxuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDMwKTtcblxuICAgICAgICBlZGl0b3IuZm9jdXMoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby50YWJsZS5Cb2R5fSBkYXRhLmJvZHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICBkYXRhLmRhdGFcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICBkYXRhLmRhdGFGaWVsZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGEucmVjb3JkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgb25DZWxsRG91YmxlQ2xpY2soe2JvZHksIGRhdGEsIGRhdGFGaWVsZCwgcmVjb3JkfSkge1xuICAgICAgICBhd2FpdCB0aGlzLm1vdW50RWRpdG9yKHJlY29yZCwgZGF0YUZpZWxkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uZm9ybS5maWVsZC5CYXNlfSBmaWVsZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG9uRWRpdG9yS2V5RW50ZXIoZGF0YSwgZmllbGQpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBhd2FpdCBtZS5zdWJtaXRFZGl0b3IoKTtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMCk7XG4gICAgICAgIG1lLnNlbGVjdENlbGwoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLmZvcm0uZmllbGQuQmFzZX0gZmllbGRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvbkVkaXRvcktleUVzY2FwZShkYXRhLCBmaWVsZCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGF3YWl0IG1lLnVubW91bnRFZGl0b3IoKTtcbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgyMCk7XG4gICAgICAgIG1lLnNlbGVjdENlbGwoZGF0YSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge05lby5mb3JtLmZpZWxkLkJhc2V9IGZpZWxkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgb25FZGl0b3JLZXlUYWIoZXZlbnQsIGZpZWxkKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3N0b3JlfSAgICAgID0gbWUub3duZXIsXG4gICAgICAgICAgICBvbGRJbmRleCAgICAgPSBzdG9yZS5pbmRleE9mKGZpZWxkLnJlY29yZCksXG4gICAgICAgICAgICBjb3VudFJlY29yZHMgPSBzdG9yZS5nZXRDb3VudCgpLFxuICAgICAgICAgICAgaW5kZXggICAgICAgID0gKG9sZEluZGV4ICsgKGV2ZW50LmFsdEtleSA/IC0xIDogMSkgKyBjb3VudFJlY29yZHMpICUgY291bnRSZWNvcmRzLFxuICAgICAgICAgICAgcmVjb3JkICAgICAgID0gc3RvcmUuZ2V0QXQoaW5kZXgpO1xuXG4gICAgICAgIGF3YWl0IG1lLnN1Ym1pdEVkaXRvcigpO1xuICAgICAgICBhd2FpdCBtZS5tb3VudEVkaXRvcihyZWNvcmQsIGZpZWxkLmRhdGFGaWVsZClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG9uRm9jdXNMZWF2ZShkYXRhKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudW5tb3VudEVkaXRvcigpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblNlbGVjdGlvbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIC8vIHRvZG86IE9uY2Ugd2Ugc2VwYXJhdGUgY2VsbCBzZWxlY3Rpb25zICYgZm9jdXMsIHdlIGNhbiB1c2UgdGhpcyBldmVudCB0byBtb3VudCBlZGl0b3JzXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvblNlbGVjdGlvbkNoYW5nZScsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25TZWxlY3Rpb25Nb2RlbENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBzZWxlY3Rpb25Nb2RlbCA9IGRhdGEudmFsdWU7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGVsLm50eXBlLmluY2x1ZGVzKCdjZWxsJykpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsLm9uKCdzZWxlY3Rpb25DaGFuZ2UnLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLCB0aGlzKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvblRhYmxlS2V5RG93bihkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7dGFyZ2V0fSA9IGRhdGEsXG4gICAgICAgICAgICB7Ym9keX0gICA9IG1lLm93bmVyLFxuICAgICAgICAgICAgZGF0YUZpZWxkLCByZWNvcmQ7XG5cbiAgICAgICAgaWYgKCFtZS5tb3VudGVkRWRpdG9yICYmIHRhcmdldC5jbHM/LmluY2x1ZGVzKCduZW8tc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgZGF0YUZpZWxkID0gYm9keS5nZXRDZWxsRGF0YUZpZWxkKHRhcmdldC5pZCk7XG4gICAgICAgICAgICByZWNvcmQgICAgPSBib2R5LmdldFJlY29yZCh0YXJnZXQuaWQpO1xuXG4gICAgICAgICAgICBhd2FpdCBtZS5tb3VudEVkaXRvcihyZWNvcmQsIGRhdGFGaWVsZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5wYXRoXG4gICAgICovXG4gICAgc2VsZWN0Q2VsbCh7cGF0aH0pIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3NlbGVjdGlvbk1vZGVsfSA9IG1lLm93bmVyLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgICBsZW4gICAgICAgICAgICAgID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBjZWxsSWQ7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2xzPy5pbmNsdWRlcyhtZS5jZWxsQ2xzKSkge1xuICAgICAgICAgICAgICAgIGNlbGxJZCA9IHBhdGhbaV0uaWQ7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjZWxsSWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdChjZWxsSWQsIHRydWUpOyAvLyB0aGUgY2VsbCBtaWdodCBzdGlsbCBjb3VudCBhcyBzZWxlY3RlZCA9PiBzaWxlbnQgZGVzZWxlY3QgZmlyc3RcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5zZWxlY3QoY2VsbElkKTtcbiAgICAgICAgICAgIG1lLmZvY3VzQ2VsbHMgJiYgbWUub3duZXIuZm9jdXMoY2VsbElkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGZpZWxkIGlzIHZhbGlkOlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlY29yZCBmaWVsZCwgaW4gY2FzZSB0aGUgdmFsdWUgb2YgdGhlIGVkaXRvciBjaGFuZ2VkLFxuICAgICAqIG90aGVyd2lzZSB1bm1vdW50cyB0aGUgZWRpdG9yXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0RWRpdG9yKCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgZmllbGQgPSBtZS5tb3VudGVkRWRpdG9yO1xuXG4gICAgICAgIGlmIChmaWVsZD8uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIG1lLm1vdW50ZWRFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZpZWxkLnJlY29yZFtmaWVsZC5kYXRhRmllbGRdID0gZmllbGQuZ2V0U3VibWl0VmFsdWUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBtZS51bm1vdW50RWRpdG9yKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHVubW91bnRFZGl0b3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VudGVkRWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICByZWNvcmQgICA9IG1lLm1vdW50ZWRFZGl0b3IucmVjb3JkLFxuICAgICAgICAgICAge2JvZHl9ICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIHJvd0luZGV4ID0gYm9keS5zdG9yZS5pbmRleE9mKHJlY29yZCk7XG5cbiAgICAgICAgbWUubW91bnRlZEVkaXRvciA9IG51bGw7XG5cbiAgICAgICAgYm9keS5nZXRWZG9tUm9vdCgpLmNuW3Jvd0luZGV4XSA9IGJvZHkuY3JlYXRlUm93KHtyZWNvcmQsIHJvd0luZGV4fSk7XG4gICAgICAgIGF3YWl0IGJvZHkucHJvbWlzZVVwZGF0ZSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDZWxsRWRpdGluZyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=