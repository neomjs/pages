"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-src_table_plugin_CellEditing_mjs"],{

/***/ "./src/plugin/Base.mjs":
/*!*****************************!*\
  !*** ./src/plugin/Base.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./src/core/Base.mjs");


/**
 * Abstract base class for plugin implementations.
 * Plugins are intended to get put into the plugins config of component.Base
 * to enhance them or add additional features
 * @class Neo.plugin.Base
 * @extends Neo.core.Base
 */
class Plugin extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.plugin.Base'
         * @protected
         */
        className: 'Neo.plugin.Base',
        /**
         * All plugin ntypes need to start with 'plugin-' to ensure that component.Base: getPlugin() can find them
         * @member {String} ntype='plugin'
         * @protected
         */
        ntype: 'plugin',
        /**
         * @member {Neo.component.Base} owner=null
         * @protected
         */
        owner: null,
        /**
         * @member {Number|null} windowId_=null
         * @reactive
         */
        windowId_: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me      = this,
            {owner} = me;

        if (owner.isConstructed) {
            me.onOwnerConstructed()
        } else {
            owner.on('constructed', () => {
                me.onOwnerConstructed()
            }, me, {once: true})
        }

        if (owner.mounted) {
            me.onOwnerMounted();
        } else {
            owner.on('mounted', me.onOwnerMounted, me);
        }
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        value && Neo.currentWorker.insertThemeFiles(value, this.__proto__)
    }

    /**
     * Override this method to apply changes to the owner Component when it is constructed
     */
    onOwnerConstructed() {
        let {owner} = this;

        if (owner.windowId) {
            this.windowId = owner.windowId
        }
    }

    /**
     * Override this method to apply changes to the owner Component when it does get mounted
     */
    onOwnerMounted() {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Plugin));


/***/ }),

/***/ "./src/table/plugin/CellEditing.mjs":
/*!******************************************!*\
  !*** ./src/table/plugin/CellEditing.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../plugin/Base.mjs */ "./src/plugin/Base.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.table.plugin.CellEditing
 * @extends Neo.plugin.Base
 */
class CellEditing extends _plugin_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.table.plugin.CellEditing'
         * @protected
         */
        className: 'Neo.table.plugin.CellEditing',
        /**
         * @member {String} ntype='plugin-table-cell-editing'
         * @protected
         */
        ntype: 'plugin-table-cell-editing',
        /**
         * @member {String} cellCls='neo-table-cell'
         */
        cellCls: 'neo-table-cell',
        /**
         * @member {Boolean} disabled_=false
         * @reactive
         */
        disabled_: false,
        /**
         * @member {String[]} editorCls=['neo-table-editor']
         */
        editorCls: ['neo-table-editor'],
        /**
         * @member {Boolean} focusCells=true
         */
        focusCells: true
    }

    /**
     * Storing editor instances per column
     * @member {Object} editors={}
     */
    editors = {}
    /**
     * Storing the currently mounted editor
     * @member {Neo.form.field.Base|null} mountedEditor=null
     */
    mountedEditor = null

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me               = this,
            {owner}          = me,
            {selectionModel} = owner;

        owner.on({
            cellDoubleClick     : me.onCellDoubleClick,
            focusLeave          : me.onFocusLeave,
            selectionModelChange: me.onSelectionModelChange,
            scope               : me
        });

        // Connect an already registered selectionModel instance
        if (Neo.typeOf(selectionModel) === 'NeoInstance') {
            me.onSelectionModelChange({value: selectionModel})
        }

        owner.body.keys.add({
            Enter: 'onTableKeyDown',
            Space: 'onTableKeyDown',
            scope: me
        })
    }

    /**
     * Triggered after the disabled config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetDisabled(value, oldValue) {
        oldValue && this.unmountEditor()
    }

    /**
     * @param {args} args
     */
    destroy(...args) {
        Object.values(this.editors).forEach(editor => {
            editor.destroy(false, true)
        });

        super.destroy(...args)
    }

    /**
     * @param {Object} record
     * @param {String} dataField
     * @returns {Promise<void>}
     */
    async mountEditor(record, dataField) {
        if (this.disabled) {
            return
        }

        let me                  = this,
            {appName, windowId} = me,
            {body}              = me.owner,
            cellId              = body.getCellId(record, dataField),
            cellNode            = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(body.vdom, cellId).vdom,
            column              = me.owner.headerToolbar.getColumn(dataField),
            editor              = me.editors[dataField],
            value               = record[dataField],
            keys;

        if (me.mountedEditor) {
            await me.unmountEditor();
            await me.timeout(10)
        }

        if (!column.editable) {
            return
        }

        if (!editor) {
            me.editors[dataField] = editor = Neo.create({
                module   : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                appName,
                cls      : me.editorCls,
                dataField,
                hideLabel: true,
                parentId : body.id,
                record,
                value,
                windowId,

                ...column.editor
            });

            keys = {
                Enter : 'onEditorKeyEnter',
                Escape: 'onEditorKeyEscape',
                Tab   : 'onEditorKeyTab',
                scope : me
            };

            if (editor.keys) {
                editor.keys.add(keys)
            } else {
                editor.keys = keys
            }
        } else {
            editor.originalConfig.value = value;
            editor.setSilent({record, value})
        }

        me.mountedEditor = editor;

        cellNode.cn = [editor.createVdomReference()];
        delete cellNode.html;

        body.updateDepth = -1;

        await body.promiseUpdate();

        await me.timeout(30);

        editor.focus()
    }

    /**
     *
     * @param {Object} data
     * @param {Neo.table.Body} data.body
     * @param {Object}         data.data
     * @param {String}         data.dataField
     * @param {Object}         data.record
     * @returns {Promise<void>}
     */
    async onCellDoubleClick({body, data, dataField, record}) {
        await this.mountEditor(record, dataField)
    }

    /**
     * @param {Object} data
     * @param {Neo.form.field.Base} field
     * @returns {Promise<void>}
     */
    async onEditorKeyEnter(data, field) {
        let me = this;

        await me.submitEditor();
        await me.timeout(20);
        me.selectCell(data)
    }

    /**
     * @param {Object} data
     * @param {Neo.form.field.Base} field
     * @returns {Promise<void>}
     */
    async onEditorKeyEscape(data, field) {
        let me = this;

        await me.unmountEditor();
        await me.timeout(20);
        me.selectCell(data)
    }

    /**
     * @param {Object} event
     * @param {Neo.form.field.Base} field
     * @returns {Promise<void>}
     */
    async onEditorKeyTab(event, field) {
        let me           = this,
            {store}      = me.owner,
            oldIndex     = store.indexOf(field.record),
            countRecords = store.getCount(),
            index        = (oldIndex + (event.altKey ? -1 : 1) + countRecords) % countRecords,
            record       = store.getAt(index);

        await me.submitEditor();
        await me.mountEditor(record, field.dataField)
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onFocusLeave(data) {
        await this.unmountEditor()
    }

    /**
     * @param {Object} data
     */
    onSelectionChange(data) {
        // todo: Once we separate cell selections & focus, we can use this event to mount editors
        // console.log('onSelectionChange', data);
    }

    /**
     * @param {Object} data
     */
    onSelectionModelChange(data) {
        let selectionModel = data.value;

        if (selectionModel.ntype.includes('cell')) {
            selectionModel.on('selectionChange', this.onSelectionChange, this)
        }
    }

    /**
     * @param {Object} data
     * @returns {Promise<void>}
     */
    async onTableKeyDown(data) {
        let me       = this,
            {target} = data,
            {body}   = me.owner,
            dataField, record;

        if (!me.mountedEditor && target.cls?.includes('neo-selected')) {
            dataField = body.getCellDataField(target.id);
            record    = body.getRecord(target.id);

            await me.mountEditor(record, dataField)
        }
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.path
     */
    selectCell({path}) {
        let me               = this,
            {selectionModel} = me.owner,
            i                = 0,
            len              = path.length,
            cellId;

        for (; i < len; i++) {
            if (path[i].cls?.includes(me.cellCls)) {
                cellId = path[i].id;
                break
            }
        }

        if (cellId) {
            selectionModel?.deselect(cellId, true); // the cell might still count as selected => silent deselect first
            selectionModel?.select(cellId);
            me.focusCells && me.owner.focus(cellId)
        }
    }

    /**
     * If the field is valid:
     * Updates the record field, in case the value of the editor changed,
     * otherwise unmounts the editor
     * @returns {Promise<void>}
     */
    async submitEditor() {
        let me    = this,
            field = me.mountedEditor;

        if (field?.isValid()) {
            if (field.isDirty) {
                me.mountedEditor = null;
                field.record[field.dataField] = field.getSubmitValue()
            } else {
                await me.unmountEditor()
            }
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async unmountEditor() {
        if (!this.mountedEditor) {
            return
        }

        let me       = this,
            record   = me.mountedEditor.record,
            {body}   = me.owner,
            rowIndex = body.store.indexOf(record);

        me.mountedEditor = null;

        body.getVdomRoot().cn[rowIndex] = body.createRow({record, rowIndex});
        await body.promiseUpdate()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(CellEditing));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLXNyY190YWJsZV9wbHVnaW5fQ2VsbEVkaXRpbmdfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBSTtBQUN6QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYSxPQUFPLFdBQVc7QUFDL0I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkZRO0FBQ0k7QUFDTjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQU07QUFDaEM7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxnQkFBZ0I7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQSxrQ0FBa0Msc0RBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDhCQUE4QixjQUFjO0FBQzVDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUscUJBQXFCO0FBQ3BDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxxQkFBcUI7QUFDcEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBOztBQUVBLDBEQUEwRCxpQkFBaUI7QUFDM0U7QUFDQTtBQUNBOztBQUVBLGlFQUFlLDJCQUEyQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9wbHVnaW4vQmFzZS5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy90YWJsZS9wbHVnaW4vQ2VsbEVkaXRpbmcubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlIGZyb20gJy4uL2NvcmUvQmFzZS5tanMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHBsdWdpbiBpbXBsZW1lbnRhdGlvbnMuXG4gKiBQbHVnaW5zIGFyZSBpbnRlbmRlZCB0byBnZXQgcHV0IGludG8gdGhlIHBsdWdpbnMgY29uZmlnIG9mIGNvbXBvbmVudC5CYXNlXG4gKiB0byBlbmhhbmNlIHRoZW0gb3IgYWRkIGFkZGl0aW9uYWwgZmVhdHVyZXNcbiAqIEBjbGFzcyBOZW8ucGx1Z2luLkJhc2VcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgUGx1Z2luIGV4dGVuZHMgQmFzZSB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8ucGx1Z2luLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5wbHVnaW4uQmFzZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgcGx1Z2luIG50eXBlcyBuZWVkIHRvIHN0YXJ0IHdpdGggJ3BsdWdpbi0nIHRvIGVuc3VyZSB0aGF0IGNvbXBvbmVudC5CYXNlOiBnZXRQbHVnaW4oKSBjYW4gZmluZCB0aGVtXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdwbHVnaW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5CYXNlfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IHdpbmRvd0lkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWRfOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge293bmVyfSA9IG1lO1xuXG4gICAgICAgIGlmIChvd25lci5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbk93bmVyQ29uc3RydWN0ZWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3duZXIub24oJ2NvbnN0cnVjdGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lLm9uT3duZXJDb25zdHJ1Y3RlZCgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG93bmVyLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1lLm9uT3duZXJNb3VudGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvd25lci5vbignbW91bnRlZCcsIG1lLm9uT3duZXJNb3VudGVkLCBtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgJiYgTmVvLmN1cnJlbnRXb3JrZXIuaW5zZXJ0VGhlbWVGaWxlcyh2YWx1ZSwgdGhpcy5fX3Byb3RvX18pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgaXMgY29uc3RydWN0ZWRcbiAgICAgKi9cbiAgICBvbk93bmVyQ29uc3RydWN0ZWQoKSB7XG4gICAgICAgIGxldCB7b3duZXJ9ID0gdGhpcztcblxuICAgICAgICBpZiAob3duZXIud2luZG93SWQpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93SWQgPSBvd25lci53aW5kb3dJZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYXBwbHkgY2hhbmdlcyB0byB0aGUgb3duZXIgQ29tcG9uZW50IHdoZW4gaXQgZG9lcyBnZXQgbW91bnRlZFxuICAgICAqL1xuICAgIG9uT3duZXJNb3VudGVkKCkge1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhQbHVnaW4pO1xuIiwiaW1wb3J0IFBsdWdpbiAgICBmcm9tICcuLi8uLi9wbHVnaW4vQmFzZS5tanMnO1xuaW1wb3J0IFRleHRGaWVsZCBmcm9tICcuLi8uLi9mb3JtL2ZpZWxkL1RleHQubWpzJztcbmltcG9ydCBWZG9tVXRpbCAgZnJvbSAnLi4vLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby50YWJsZS5wbHVnaW4uQ2VsbEVkaXRpbmdcbiAqIEBleHRlbmRzIE5lby5wbHVnaW4uQmFzZVxuICovXG5jbGFzcyBDZWxsRWRpdGluZyBleHRlbmRzIFBsdWdpbiB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8udGFibGUucGx1Z2luLkNlbGxFZGl0aW5nJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8udGFibGUucGx1Z2luLkNlbGxFZGl0aW5nJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J3BsdWdpbi10YWJsZS1jZWxsLWVkaXRpbmcnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAncGx1Z2luLXRhYmxlLWNlbGwtZWRpdGluZycsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNlbGxDbHM9J25lby10YWJsZS1jZWxsJ1xuICAgICAgICAgKi9cbiAgICAgICAgY2VsbENsczogJ25lby10YWJsZS1jZWxsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGRpc2FibGVkXz1mYWxzZVxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVkXzogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gZWRpdG9yQ2xzPVsnbmVvLXRhYmxlLWVkaXRvciddXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0b3JDbHM6IFsnbmVvLXRhYmxlLWVkaXRvciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gZm9jdXNDZWxscz10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBmb2N1c0NlbGxzOiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcmluZyBlZGl0b3IgaW5zdGFuY2VzIHBlciBjb2x1bW5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGVkaXRvcnM9e31cbiAgICAgKi9cbiAgICBlZGl0b3JzID0ge31cbiAgICAvKipcbiAgICAgKiBTdG9yaW5nIHRoZSBjdXJyZW50bHkgbW91bnRlZCBlZGl0b3JcbiAgICAgKiBAbWVtYmVyIHtOZW8uZm9ybS5maWVsZC5CYXNlfG51bGx9IG1vdW50ZWRFZGl0b3I9bnVsbFxuICAgICAqL1xuICAgIG1vdW50ZWRFZGl0b3IgPSBudWxsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7b3duZXJ9ICAgICAgICAgID0gbWUsXG4gICAgICAgICAgICB7c2VsZWN0aW9uTW9kZWx9ID0gb3duZXI7XG5cbiAgICAgICAgb3duZXIub24oe1xuICAgICAgICAgICAgY2VsbERvdWJsZUNsaWNrICAgICA6IG1lLm9uQ2VsbERvdWJsZUNsaWNrLFxuICAgICAgICAgICAgZm9jdXNMZWF2ZSAgICAgICAgICA6IG1lLm9uRm9jdXNMZWF2ZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsQ2hhbmdlOiBtZS5vblNlbGVjdGlvbk1vZGVsQ2hhbmdlLFxuICAgICAgICAgICAgc2NvcGUgICAgICAgICAgICAgICA6IG1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbm5lY3QgYW4gYWxyZWFkeSByZWdpc3RlcmVkIHNlbGVjdGlvbk1vZGVsIGluc3RhbmNlXG4gICAgICAgIGlmIChOZW8udHlwZU9mKHNlbGVjdGlvbk1vZGVsKSA9PT0gJ05lb0luc3RhbmNlJykge1xuICAgICAgICAgICAgbWUub25TZWxlY3Rpb25Nb2RlbENoYW5nZSh7dmFsdWU6IHNlbGVjdGlvbk1vZGVsfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG93bmVyLmJvZHkua2V5cy5hZGQoe1xuICAgICAgICAgICAgRW50ZXI6ICdvblRhYmxlS2V5RG93bicsXG4gICAgICAgICAgICBTcGFjZTogJ29uVGFibGVLZXlEb3duJyxcbiAgICAgICAgICAgIHNjb3BlOiBtZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZGlzYWJsZWQgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXREaXNhYmxlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgb2xkVmFsdWUgJiYgdGhpcy51bm1vdW50RWRpdG9yKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FyZ3N9IGFyZ3NcbiAgICAgKi9cbiAgICBkZXN0cm95KC4uLmFyZ3MpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmVkaXRvcnMpLmZvckVhY2goZWRpdG9yID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5kZXN0cm95KGZhbHNlLCB0cnVlKVxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmllbGRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBtb3VudEVkaXRvcihyZWNvcmQsIGRhdGFGaWVsZCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7YXBwTmFtZSwgd2luZG93SWR9ID0gbWUsXG4gICAgICAgICAgICB7Ym9keX0gICAgICAgICAgICAgID0gbWUub3duZXIsXG4gICAgICAgICAgICBjZWxsSWQgICAgICAgICAgICAgID0gYm9keS5nZXRDZWxsSWQocmVjb3JkLCBkYXRhRmllbGQpLFxuICAgICAgICAgICAgY2VsbE5vZGUgICAgICAgICAgICA9IFZkb21VdGlsLmZpbmQoYm9keS52ZG9tLCBjZWxsSWQpLnZkb20sXG4gICAgICAgICAgICBjb2x1bW4gICAgICAgICAgICAgID0gbWUub3duZXIuaGVhZGVyVG9vbGJhci5nZXRDb2x1bW4oZGF0YUZpZWxkKSxcbiAgICAgICAgICAgIGVkaXRvciAgICAgICAgICAgICAgPSBtZS5lZGl0b3JzW2RhdGFGaWVsZF0sXG4gICAgICAgICAgICB2YWx1ZSAgICAgICAgICAgICAgID0gcmVjb3JkW2RhdGFGaWVsZF0sXG4gICAgICAgICAgICBrZXlzO1xuXG4gICAgICAgIGlmIChtZS5tb3VudGVkRWRpdG9yKSB7XG4gICAgICAgICAgICBhd2FpdCBtZS51bm1vdW50RWRpdG9yKCk7XG4gICAgICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDEwKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb2x1bW4uZWRpdGFibGUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICAgIG1lLmVkaXRvcnNbZGF0YUZpZWxkXSA9IGVkaXRvciA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgY2xzICAgICAgOiBtZS5lZGl0b3JDbHMsXG4gICAgICAgICAgICAgICAgZGF0YUZpZWxkLFxuICAgICAgICAgICAgICAgIGhpZGVMYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCA6IGJvZHkuaWQsXG4gICAgICAgICAgICAgICAgcmVjb3JkLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkLFxuXG4gICAgICAgICAgICAgICAgLi4uY29sdW1uLmVkaXRvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGtleXMgPSB7XG4gICAgICAgICAgICAgICAgRW50ZXIgOiAnb25FZGl0b3JLZXlFbnRlcicsXG4gICAgICAgICAgICAgICAgRXNjYXBlOiAnb25FZGl0b3JLZXlFc2NhcGUnLFxuICAgICAgICAgICAgICAgIFRhYiAgIDogJ29uRWRpdG9yS2V5VGFiJyxcbiAgICAgICAgICAgICAgICBzY29wZSA6IG1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZWRpdG9yLmtleXMpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iua2V5cy5hZGQoa2V5cylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmtleXMgPSBrZXlzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3Iub3JpZ2luYWxDb25maWcudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGVkaXRvci5zZXRTaWxlbnQoe3JlY29yZCwgdmFsdWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgbWUubW91bnRlZEVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICBjZWxsTm9kZS5jbiA9IFtlZGl0b3IuY3JlYXRlVmRvbVJlZmVyZW5jZSgpXTtcbiAgICAgICAgZGVsZXRlIGNlbGxOb2RlLmh0bWw7XG5cbiAgICAgICAgYm9keS51cGRhdGVEZXB0aCA9IC0xO1xuXG4gICAgICAgIGF3YWl0IGJvZHkucHJvbWlzZVVwZGF0ZSgpO1xuXG4gICAgICAgIGF3YWl0IG1lLnRpbWVvdXQoMzApO1xuXG4gICAgICAgIGVkaXRvci5mb2N1cygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7TmVvLnRhYmxlLkJvZHl9IGRhdGEuYm9keVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgIGRhdGEuZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgIGRhdGEuZGF0YUZpZWxkXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgZGF0YS5yZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvbkNlbGxEb3VibGVDbGljayh7Ym9keSwgZGF0YSwgZGF0YUZpZWxkLCByZWNvcmR9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubW91bnRFZGl0b3IocmVjb3JkLCBkYXRhRmllbGQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge05lby5mb3JtLmZpZWxkLkJhc2V9IGZpZWxkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgb25FZGl0b3JLZXlFbnRlcihkYXRhLCBmaWVsZCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGF3YWl0IG1lLnN1Ym1pdEVkaXRvcigpO1xuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwKTtcbiAgICAgICAgbWUuc2VsZWN0Q2VsbChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtOZW8uZm9ybS5maWVsZC5CYXNlfSBmaWVsZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG9uRWRpdG9yS2V5RXNjYXBlKGRhdGEsIGZpZWxkKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgYXdhaXQgbWUudW5tb3VudEVkaXRvcigpO1xuICAgICAgICBhd2FpdCBtZS50aW1lb3V0KDIwKTtcbiAgICAgICAgbWUuc2VsZWN0Q2VsbChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqIEBwYXJhbSB7TmVvLmZvcm0uZmllbGQuQmFzZX0gZmllbGRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBvbkVkaXRvcktleVRhYihldmVudCwgZmllbGQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c3RvcmV9ICAgICAgPSBtZS5vd25lcixcbiAgICAgICAgICAgIG9sZEluZGV4ICAgICA9IHN0b3JlLmluZGV4T2YoZmllbGQucmVjb3JkKSxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkcyA9IHN0b3JlLmdldENvdW50KCksXG4gICAgICAgICAgICBpbmRleCAgICAgICAgPSAob2xkSW5kZXggKyAoZXZlbnQuYWx0S2V5ID8gLTEgOiAxKSArIGNvdW50UmVjb3JkcykgJSBjb3VudFJlY29yZHMsXG4gICAgICAgICAgICByZWNvcmQgICAgICAgPSBzdG9yZS5nZXRBdChpbmRleCk7XG5cbiAgICAgICAgYXdhaXQgbWUuc3VibWl0RWRpdG9yKCk7XG4gICAgICAgIGF3YWl0IG1lLm1vdW50RWRpdG9yKHJlY29yZCwgZmllbGQuZGF0YUZpZWxkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgYXdhaXQgdGhpcy51bm1vdW50RWRpdG9yKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgLy8gdG9kbzogT25jZSB3ZSBzZXBhcmF0ZSBjZWxsIHNlbGVjdGlvbnMgJiBmb2N1cywgd2UgY2FuIHVzZSB0aGlzIGV2ZW50IHRvIG1vdW50IGVkaXRvcnNcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29uU2VsZWN0aW9uQ2hhbmdlJywgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblNlbGVjdGlvbk1vZGVsQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbk1vZGVsID0gZGF0YS52YWx1ZTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZWwubnR5cGUuaW5jbHVkZXMoJ2NlbGwnKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwub24oJ3NlbGVjdGlvbkNoYW5nZScsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UsIHRoaXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIG9uVGFibGVLZXlEb3duKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt0YXJnZXR9ID0gZGF0YSxcbiAgICAgICAgICAgIHtib2R5fSAgID0gbWUub3duZXIsXG4gICAgICAgICAgICBkYXRhRmllbGQsIHJlY29yZDtcblxuICAgICAgICBpZiAoIW1lLm1vdW50ZWRFZGl0b3IgJiYgdGFyZ2V0LmNscz8uaW5jbHVkZXMoJ25lby1zZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICBkYXRhRmllbGQgPSBib2R5LmdldENlbGxEYXRhRmllbGQodGFyZ2V0LmlkKTtcbiAgICAgICAgICAgIHJlY29yZCAgICA9IGJvZHkuZ2V0UmVjb3JkKHRhcmdldC5pZCk7XG5cbiAgICAgICAgICAgIGF3YWl0IG1lLm1vdW50RWRpdG9yKHJlY29yZCwgZGF0YUZpZWxkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhLnBhdGhcbiAgICAgKi9cbiAgICBzZWxlY3RDZWxsKHtwYXRofSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7c2VsZWN0aW9uTW9kZWx9ID0gbWUub3duZXIsXG4gICAgICAgICAgICBpICAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgICAgIGxlbiAgICAgICAgICAgICAgPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIGNlbGxJZDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jbHM/LmluY2x1ZGVzKG1lLmNlbGxDbHMpKSB7XG4gICAgICAgICAgICAgICAgY2VsbElkID0gcGF0aFtpXS5pZDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNlbGxJZCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LmRlc2VsZWN0KGNlbGxJZCwgdHJ1ZSk7IC8vIHRoZSBjZWxsIG1pZ2h0IHN0aWxsIGNvdW50IGFzIHNlbGVjdGVkID0+IHNpbGVudCBkZXNlbGVjdCBmaXJzdFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LnNlbGVjdChjZWxsSWQpO1xuICAgICAgICAgICAgbWUuZm9jdXNDZWxscyAmJiBtZS5vd25lci5mb2N1cyhjZWxsSWQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZmllbGQgaXMgdmFsaWQ6XG4gICAgICogVXBkYXRlcyB0aGUgcmVjb3JkIGZpZWxkLCBpbiBjYXNlIHRoZSB2YWx1ZSBvZiB0aGUgZWRpdG9yIGNoYW5nZWQsXG4gICAgICogb3RoZXJ3aXNlIHVubW91bnRzIHRoZSBlZGl0b3JcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBzdWJtaXRFZGl0b3IoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBmaWVsZCA9IG1lLm1vdW50ZWRFZGl0b3I7XG5cbiAgICAgICAgaWYgKGZpZWxkPy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgbWUubW91bnRlZEVkaXRvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgZmllbGQucmVjb3JkW2ZpZWxkLmRhdGFGaWVsZF0gPSBmaWVsZC5nZXRTdWJtaXRWYWx1ZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IG1lLnVubW91bnRFZGl0b3IoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgdW5tb3VudEVkaXRvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdW50ZWRFZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZCAgID0gbWUubW91bnRlZEVkaXRvci5yZWNvcmQsXG4gICAgICAgICAgICB7Ym9keX0gICA9IG1lLm93bmVyLFxuICAgICAgICAgICAgcm93SW5kZXggPSBib2R5LnN0b3JlLmluZGV4T2YocmVjb3JkKTtcblxuICAgICAgICBtZS5tb3VudGVkRWRpdG9yID0gbnVsbDtcblxuICAgICAgICBib2R5LmdldFZkb21Sb290KCkuY25bcm93SW5kZXhdID0gYm9keS5jcmVhdGVSb3coe3JlY29yZCwgcm93SW5kZXh9KTtcbiAgICAgICAgYXdhaXQgYm9keS5wcm9taXNlVXBkYXRlKClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENlbGxFZGl0aW5nKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==