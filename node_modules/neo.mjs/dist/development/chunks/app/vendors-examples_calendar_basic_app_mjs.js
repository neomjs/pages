"use strict";
(self["webpackChunkneo_mjs"] = self["webpackChunkneo_mjs"] || []).push([["vendors-examples_calendar_basic_app_mjs"],{

/***/ "./examples/calendar/basic/MainContainer.mjs"
/*!***************************************************!*\
  !*** ./examples/calendar/basic/MainContainer.mjs ***!
  \***************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _src_calendar_view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/calendar/view/MainContainer.mjs */ "./src/calendar/view/MainContainer.mjs");
/* harmony import */ var _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MainContainerController.mjs */ "./examples/calendar/basic/MainContainerController.mjs");
/* harmony import */ var _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/toolbar/Base.mjs */ "./src/toolbar/Base.mjs");
/* harmony import */ var _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/container/Viewport.mjs */ "./src/container/Viewport.mjs");






/**
 * @class Neo.examples.calendar.basic.MainContainer
 * @extends Neo.container.Viewport
 */
class MainContainer extends _src_container_Viewport_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        className : 'Neo.examples.calendar.basic.MainContainer',
        autoMount : true,
        cls       : ['neo-examples-calendar-maincontainer', 'neo-viewport'],
        controller: _MainContainerController_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
        layout    : {ntype: 'vbox', align: 'stretch'},

        items: [{
            module : _src_toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
            flex   : 'none',
            padding: 20,
            reference: 'headerToolbar',

            style: {
                backgroundColor: '#f2f2f2',
                padding        : '10px 5px 10px 10px'
            },

            items: [{
                ntype: 'component',
                cls  : ['neo-header'],
                html : '<i class="fa fa-calendar"></i>neo.mjs Calendar'
            }, '->', {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                handler: 'onSwitchThemeButtonClick',
                height : 27,
                iconCls: 'fa fa-moon',
                text   : 'Theme Dark'
            }, {
                module : _src_button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                height : 27,
                iconCls: 'fab fa-github',
                style  : {marginLeft: '5px'},
                text   : 'GitHub',
                url    : 'https://github.com/neomjs/neo/tree/dev/src/calendar'
            }]
        }, {
            module   : _src_calendar_view_MainContainer_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex     : 1,
            reference: 'calendar',

            calendarStoreConfig: {
                autoLoad: true,
                url     : '../../examples/calendar/basic/data/calendars.json'
            },

            eventStoreConfig: {
                autoLoad: true,
                url     : '../../examples/calendar/basic/data/events.json'
            },

            modelData: {
                currentDate: new Date('2024-07-21')
            }
        }]
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./examples/calendar/basic/MainContainerController.mjs"
/*!*************************************************************!*\
  !*** ./examples/calendar/basic/MainContainerController.mjs ***!
  \*************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/controller/Component.mjs */ "./src/controller/Component.mjs");


/**
 * @class Neo.examples.calendar.basic.MainContainerController
 * @extends Neo.controller.Component
 */
class MainContainerController extends _src_controller_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.examples.calendar.basic.MainContainerController'
         * @protected
         */
        className: 'Neo.examples.calendar.basic.MainContainerController'
    }

    /**
     * @param {Object} data
     */
    onSwitchThemeButtonClick(data) {
        let me            = this,
            button        = data.component,
            component     = me.component,
            headerToolbar = me.getReference('headerToolbar'),
            buttonText, headerColor, iconCls, style, theme;

        if (button.text === 'Theme Light') {
            buttonText  = 'Theme Dark';
            headerColor = '#f2f2f2';
            iconCls     = 'fa fa-moon';
            theme       = 'neo-theme-light'
        } else {
            buttonText  = 'Theme Light';
            headerColor = '#33343d';
            iconCls     = 'fa fa-sun';
            theme       = 'neo-theme-dark'
        }

        component.theme = theme;

        button.set({
            iconCls,
            text: buttonText
        });

        style = headerToolbar.style || {};
        style.backgroundColor = headerColor;
        headerToolbar.style = style
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainerController));


/***/ },

/***/ "./examples/calendar/basic/app.mjs"
/*!*****************************************!*\
  !*** ./examples/calendar/basic/app.mjs ***!
  \*****************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   onStart: () => (/* binding */ onStart)
/* harmony export */ });
/* harmony import */ var _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MainContainer.mjs */ "./examples/calendar/basic/MainContainer.mjs");


const onStart = () => Neo.app({
    mainView: _MainContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    name    : 'Neo.examples.calendar.basic'
});


/***/ },

/***/ "./src/calendar/view/EditEventContainer.mjs"
/*!**************************************************!*\
  !*** ./src/calendar/view/EditEventContainer.mjs ***!
  \**************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _store_Calendars_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store/Calendars.mjs */ "./src/calendar/store/Calendars.mjs");
/* harmony import */ var _form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../form/field/Color.mjs */ "./src/form/field/Color.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _form_Container_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../form/field/Text.mjs */ "./src/form/field/Text.mjs");
/* harmony import */ var _form_field_Time_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../form/field/Time.mjs */ "./src/form/field/Time.mjs");








/**
 * @class Neo.calendar.view.EditEventContainer
 * @extends Neo.form.Container
 */
class EditEventContainer extends _form_Container_mjs__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.EditEventContainer'
         * @protected
         */
        className: 'Neo.calendar.view.EditEventContainer',
        /**
         * @member {String[]} baseCls=['neo-calendar-edit-event-container']
         */
        baseCls: ['neo-calendar-edit-event-container'],
        /**
         * @member {Object} bind
         */
        bind: {
            endTime             : data => data.endTime,
            intlFormat_time     : data => data.timeFormatter,
            minimumEventDuration: data => data.minimumEventDuration,
            startTime           : data => data.startTime
        },
        /**
         * @member {Object|null} calendarFieldConfig=null
         */
        calendarFieldConfig: null,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} endTime_='24:00'
         * @reactive
         */
        endTime_: '24:00',
        /**
         * @member {Object|null} endTimeFieldConfig=null
         */
        endTimeFieldConfig: null,
        /**
         * Bound to the state provider.
         * @member {Intl.DateTimeFormat|null} intlFormat_time=null
         * @protected
         */
        intlFormat_time: null,
        /**
         * @member {Neo.calendar.view.week.Component|null} owner=null
         */
        owner: null,
        /**
         * @member {Neo.calendar.model.Event|null} record_=null
         * @reactive
         */
        record_: null,
        /**
         * Only full hours are valid for now
         * format: 'hh:mm'
         * @member {String} startTime_='00:00'
         * @reactive
         */
        startTime_: '00:00',
        /**
         * @member {Object|null} startTimeFieldConfig=null
         */
        startTimeFieldConfig: null,
        /**
         * @member {Object|null} titleFieldConfig=null
         */
        titleFieldConfig: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        // focus trap, see: https://github.com/neomjs/neo/issues/2306
        this.vdom.tabIndex = -1
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);
        value && this.getField('title').then(field => field.focus())
    }

    /**
     * Triggered after the record config got changed
     * @param {Neo.calendar.model.Event} value
     * @param {Neo.calendar.model.Event} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        if (value && oldValue) {
            let me                  = this,
                timeFormat          = me.intlFormat_time,
                {calendarId, title} = value;

            me.getField('endTime')  .then(field => field.minValue = me.getEndTimeMinValue(value));
            me.getField('startTime').then(field => field.maxValue = me.getStartTimeMaxValue(value));

            me.reset({
                calendarId,
                endTime  : timeFormat.format(value.endDate),
                startTime: timeFormat.format(value.startDate),
                title
            })
        } else if (value) {
            this.createItems()
        }
    }

    /**
     *
     */
    createItems() {
        let me         = this,
            {record}   = me,
            timeFormat = me.intlFormat_time,
            timeFieldDefaults = {
                module              : _form_field_Time_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                listeners           : {change: me.onTimeFieldChange, scope: me},
                stepSize            : 15 * 60,
                width               : '9em'
            };

        if (record) {
            me.items = [{
                module              : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                labelText           : 'Title',
                listeners           : {change: me.onTitleFieldChange, scope: me},
                name                : 'title',
                required            : true,
                value               : record.title,
                ...me.titleFieldConfig
            }, {
                module              : _form_field_Color_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
                clearToOriginalValue: true,
                colorField          : 'color',
                displayField        : 'name',
                flex                : 'none',
                forceSelection      : true,
                labelPosition       : 'inline',
                labelText           : 'Calendar',
                listeners           : {change: me.onCalendarFieldChange, scope: me},
                name                : 'calendarId',
                required            : true,
                triggerAction       : 'all',
                value               : record.calendarId,

                colorFormatter: (scope,data) => {
                    let value = data[scope.colorField];

                    if (value === 'yellow') {
                        return 'var(--event-yellow-border-color)';
                    }

                    return `var(--event-${value}-color)`
                },

                store: {
                    module  : _store_Calendars_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                    sourceId: me.stateProvider.getStore('calendars').id
                },

                ...me.calendarFieldConfig
            }, {
                labelText: 'Start Time',
                maxValue : me.getStartTimeMaxValue(record),
                minValue : me.startTime,
                name     : 'startTime',
                value    : timeFormat.format(record.startDate),
                ...timeFieldDefaults,
                ...me.startTimeFieldConfig
            }, {
                labelText: 'End Time',
                maxValue : me.endTime,
                minValue : me.getEndTimeMinValue(record),
                name     : 'endTime',
                value    : timeFormat.format(record.endDate),
                ...timeFieldDefaults,
                ...me.endTimeFieldConfig
            }, {
                module : _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                cls    : ['neo-button', 'neo-red'],
                handler: me.onDeleteButtonClick.bind(me),
                iconCls: 'fas fa-trash-alt',
                style  : {marginTop: '3em'},
                text   : 'Delete'
            }];

            super.createItems()
        }
    }

    /**
     * @param {Neo.calendar.model.Event} record
     * @returns {String}
     */
    getEndTimeMinValue(record) {
        let date = new Date(record.startDate.valueOf());

        date.setMinutes(date.getMinutes() + this.minimumEventDuration);

        return this.intlFormat_time.format(date);
    }

    /**
     * @param {Neo.calendar.model.Event} record
     * @returns {String}
     */
    getStartTimeMaxValue(record) {
        let date = new Date(record.endDate.valueOf());

        date.setMinutes(date.getMinutes() - this.minimumEventDuration);

        return this.intlFormat_time.format(date)
    }

    /**
     * @param {Object} data
     */
    onCalendarFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.calendarId = data.value[data.component.store.keyProperty]
        }
    }

    /**
     * todo: we could add a confirm dialog
     * @param {Object} data
     */
    onDeleteButtonClick(data) {
        let me = this;

        me.getStateProvider().getStore('events').remove(me.record);
        me.unmount()
    }

    /**
     * @param {Object} data
     */
    async onFocusLeave(data) {
        let me = this;

        // we need a short delay, since a TimeField picker could be open
        await me.timeout(100);

        me.mounted && me.unmount()
    }

    /**
     * @param {Object} data
     */
    onTimeFieldChange(data) {
        let me     = this,
            name   = data.component.name,
            field  = name === 'endTime' ? 'endDate' : 'startDate',
            record = me.record,
            date   = _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].clone(me.record[field]),
            value  = data.value.split(':').map(e => Number(e));

        date.setHours(value[0]);
        date.setMinutes(value[1]);

        record[field] = date;

        if (name === 'endTime') {
            me.getField('startTime').then(field => field.maxValue = me.getStartTimeMaxValue(record))
        } else {
            me.getField('endTime')  .then(field => field.minValue = me.getEndTimeMinValue(record))
        }
    }

    /**
     * @param {Object} data
     */
    onTitleFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.title = data.value
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(EditEventContainer));


/***/ },

/***/ "./src/calendar/view/MainContainer.mjs"
/*!*********************************************!*\
  !*** ./src/calendar/view/MainContainer.mjs ***!
  \*********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _calendars_Container_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calendars/Container.mjs */ "./src/calendar/view/calendars/Container.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_DateSelector_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../component/DateSelector.mjs */ "./src/component/DateSelector.mjs");
/* harmony import */ var _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Date.mjs */ "./src/util/Date.mjs");
/* harmony import */ var _calendars_EditContainer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calendars/EditContainer.mjs */ "./src/calendar/view/calendars/EditContainer.mjs");
/* harmony import */ var _EditEventContainer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EditEventContainer.mjs */ "./src/calendar/view/EditEventContainer.mjs");
/* harmony import */ var _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MainContainerStateProvider.mjs */ "./src/calendar/view/MainContainerStateProvider.mjs");
/* harmony import */ var _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../toolbar/Base.mjs */ "./src/toolbar/Base.mjs");









const todayDate = new Date();

/**
 * @class Neo.calendar.view.MainContainer
 * @extends Neo.container.Base
 */
class MainContainer extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Valid entries for the views config
     * @member {String[]} validViews=['day','week','month','year']
     * @static
     */
    static validViews = ['day', 'week', 'month', 'year']

    static config = {
        /**
         * @member {String} className='Neo.calendar.view.MainContainer'
         * @protected
         */
        className: 'Neo.calendar.view.MainContainer',
        /**
         * @member {String} ntype='calendar-maincontainer'
         * @protected
         */
        ntype: 'calendar-maincontainer',
        /**
         * The currently active view. Must be a value included inside the views config.
         * valid values: 'day', 'week', 'month', 'year'
         * @member {String} activeView_='week'
         * @reactive
         */
        activeView_: 'week',
        /**
         * @member {String[]} baseCls=['neo-calendar-maincontainer','neo-container']
         */
        baseCls: ['neo-calendar-maincontainer', 'neo-container'],
        /**
         * Scale the calendar with using s different base font-size
         * @member {Number|null} baseFontSize_=null
         * @reactive
         */
        baseFontSize_: null,
        /**
         * @member {Neo.calendar.view.Container|null} calendarsContainer=null
         */
        calendarsContainer: null,
        /**
         * @member {Object|null} calendarStoreConfig_=null
         * @reactive
         */
        calendarStoreConfig_: null,
        /**
         * @member {Object|null} colorStoreConfig_=null
         * @reactive
         */
        colorStoreConfig_: null,
        /**
         * @member {Neo.component.DateSelector|null} dateSelector=null
         */
        dateSelector: null,
        /**
         * @member {Object|null} dateSelectorConfig=null
         */
        dateSelectorConfig: null,
        /**
         * @member {Neo.calendar.view.DayComponent|null} dayComponent=null
         */
        dayComponent: null,
        /**
         * @member {Object|null} dayComponentConfig=null
         */
        dayComponentConfig: null,
        /**
         * Read only
         * @member {Neo.calendar.view.calendars.EditContainer|null} editCalendarContainer_=null
         * @reactive
         */
        editCalendarContainer_: null,
        /**
         * @member {Object|null} editCalendarContainerConfig=null
         */
        editCalendarContainerConfig: null,
        /**
         * Read only
         * @member {Neo.calendar.view.EditEventContainer|null} editEventContainer_=null
         * @reactive
         */
        editEventContainer_: null,
        /**
         * @member {Object|null} editEventContainerConfig=null
         */
        editEventContainerConfig: null,
        /**
         * @member {Object|null} eventStoreConfig_=null
         * @reactive
         */
        eventStoreConfig_: null,
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @protected
         * @reactive
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Neo.calendar.view.Component|null} monthComponent=null
         */
        monthComponent: null,
        /**
         * @member {Object|null} monthComponentConfig=null
         */
        monthComponentConfig: null,
        /**
         * True to only keep the active view inside the DOM
         * @member {Boolean} removeInactiveCards=true
         */
        removeInactiveCards: true,
        /**
         * @member {Object|null} settingsContainerConfig=null
         */
        settingsContainerConfig: null,
        /**
         * @member {Number} settingsContainerWidth=300
         */
        settingsContainerWidth: 310,
        /**
         * @member {Boolean} settingsExpanded_=false
         * @reactive
         */
        settingsExpanded_: false,
        /**
         * @member {Boolean} sideBarExpanded_=true
         * @reactive
         */
        sideBarExpanded_: true,
        /**
         * @member {Number} sideBarWidth=220
         */
        sideBarWidth: 220,
        /**
         * @member {Neo.calendar.view.MainContainerStateProvider} stateProvider=MainContainerStateProvider
         * @reactive
         */
        stateProvider: _MainContainerStateProvider_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
        /**
         * @member {Boolean} useSettingsContainer_=true
         * @reactive
         */
        useSettingsContainer_: true,
        /**
         * Any combination and order of 'day', 'week', 'month', 'year'
         * @member {String[]} views_=['day','week','month','year']
         * @reactive
         */
        views_: ['day', 'week', 'month', 'year'],
        /**
         * @member {Neo.calendar.view.Component|null} weekComponent=null
         */
        weekComponent: null,
        /**
         * @member {Object|null} weekComponentConfig=null
         */
        weekComponentConfig: null,
        /**
         * @member {Neo.calendar.view.YearComponent|null} yearComponent=null
         */
        yearComponent: null,
        /**
         * @member {Object|null} yearComponentConfig=null
         */
        yearComponentConfig: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me = this;

        me.createItemsContent();
        !me.sideBarExpanded && me.afterSetSideBarExpanded(false, true)
    }

    /**
     * Triggered after the activeView config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetActiveView(value, oldValue) {
        if (oldValue !== undefined) {
            let me = this;

            me.items[1].items[1].layout.activeIndex = me.views.indexOf(value);

            me.items[0].items[1].items.forEach(item => {
                if (item.toggleGroup === 'mainViews') {
                    item.pressed = item.value === value
                }
            });
        }
    }

    /**
     * Triggered after the baseFontSize config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetBaseFontSize(value, oldValue) {
        if (oldValue !== undefined) {
            let style = this.style || {};

            if (!value) {
                delete style.fontSize
            } else {
                style.fontSize = `${value}px`
            }

            this.style = style
        }
    }

    /**
     * Triggered after the settingsExpanded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSettingsExpanded(value, oldValue) {
        if (Neo.isBoolean(oldValue)) {
            let me                = this,
                settingsContainer = me.items[1].items[2];

            if (value) {
                if (settingsContainer) {
                    settingsContainer.expand()
                } else {
                    me.createSettingsContainer(true).then(() => {
                        // short delay to ensure the vnode already exists
                        me.timeout(50).then(() => {
                            me.items[1].items[2].expand()
                        })
                    })
                }
            } else {
                settingsContainer.collapse(me.settingsContainerWidth)
            }
        }
    }

    /**
     * Triggered after the sideBarExpanded config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetSideBarExpanded(value, oldValue) {
        if (oldValue !== undefined) {
            let me      = this,
                sideBar = me.items[1].items[0],
                style   = sideBar.style || {};

            if (value) {
                me.updateDepth = -1;

                // todo: updates colliding with parent updates need to pass the update depth for the next parent update cycle
                delete sideBar.vdom.removeDom;

                me.promiseUpdate().then(() => {
                    sideBar.mounted = true;

                    me.timeout(50).then(() => {
                        style.marginLeft = '0px';
                        sideBar.style = style
                    })
                })
            } else {
                style.marginLeft    = `-${me.sideBarWidth}px`;
                sideBar._style      = style; // silent update
                sideBar._vdom.style = style; // silent update

                sideBar.promiseUpdate().then(() => {
                    me.timeout(400).then(() => {
                        sideBar.vdom.removeDom = true;
                        sideBar.update();

                        sideBar.mounted = false
                    })
                })
            }
        }
    }

    /**
     * Triggered after the theme config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetTheme(value, oldValue) {
        super.afterSetTheme(value, oldValue);

        let me = this;

        if (me._editCalendarContainer) {
            me._editCalendarContainer.theme = value
        }

        if (me._editEventContainer) {
            me._editEventContainer.theme = value
        }
    }

    /**
     * Triggered after the useSettingsContainer config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetUseSettingsContainer(value, oldValue) {
        let me = this;

        if (value) {
            me.settingsExpanded && me.createSettingsContainer(false);

            // we need a short delay to ensure the items already got created
            me.timeout(10).then(() => {
                me.items[0].items[1].add({
                    handler: me.toggleSettings.bind(me),
                    iconCls: 'fa fa-cog',
                    style  : {marginLeft: '10px'}
                })
            })
        } else if (!value && oldValue) {
            // we only need this logic in case we dynamically change the config from true to false
            me.items[1]         .removeLast();
            me.items[0].items[1].removeLast()
        }
    }

    /**
     * Gets triggered before getting the value of the editCalendarContainer config
     * @param {Neo.calendar.view.calendars.EditContainer|null} value
     * @returns {Neo.calendar.view.calendars.EditContainer}
     */
    beforeGetEditCalendarContainer(value) {
        if (!value) {
            let me = this;

            me._editCalendarContainer = value = Neo.create({
                module       : _calendars_EditContainer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
                appName      : me.appName,
                owner        : me,
                stateProvider: {parent: me.getStateProvider()},
                theme        : me.theme,
                width        : 250,
                windowId     : me.windowId,
                ...me.editCalendarContainerConfig
            })
        }

        return value
    }

    /**
     * Gets triggered before getting the value of the editEventContainer config
     * @param {Neo.calendar.view.EditEventContainer|null} value
     * @returns {Neo.calendar.view.EditEventContainer}
     */
    beforeGetEditEventContainer(value) {
        if (!value) {
            let me = this;

            me._editEventContainer = value = Neo.create({
                module       : _EditEventContainer_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
                appName      : me.appName,
                owner        : me,
                stateProvider: {parent: me.getStateProvider()},
                theme        : me.theme,
                width        : 250,
                windowId     : me.windowId,
                ...me.editEventContainerConfig
            })
        }

        return value
    }

    /**
     * Triggered before the activeView config gets changed.
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    beforeSetActiveView(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'activeView', 'validViews')
    }

    /**
     * Triggered before the views config gets changed.
     * @param {String[]} value
     * @param {String[]} oldValue
     * @protected
     */
    beforeSetViews(value, oldValue) {
        let validViews = this.getStaticConfig('validViews');

        value.forEach(view => {
            if (!validViews.includes(view)) {
                console.error(view, 'is not a valid entry for views. Stick to:', validViews);
                return oldValue
            }
        });

        return value
    }

    /**
     * @param {String} view
     * @protected
     */
    changeActiveView(view) {
        this.activeView = view
    }

    /**
     * @returns {Object[]}
     */
    createHeaderItems() {
        let me = this;

        return [{
            module: _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            cls   : ['neo-calendar-header-toolbar', 'neo-left', 'neo-toolbar'],
            width : me.sideBarWidth,
            items : [{
                handler: me.toggleSidebar.bind(me),
                iconCls: 'fa fa-bars'
            }, '->', {
                handler: me.onPreviousIntervalButtonClick.bind(me),
                iconCls: 'fa fa-chevron-left',
            }, {
                handler: me.onTodayButtonClick.bind(me),
                height : 24,
                text   : 'Today'
            }, {
                handler: me.onNextIntervalButtonClick.bind(me),
                iconCls: 'fa fa-chevron-right'
            }]
        }, {
            module: _toolbar_Base_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
            cls   : ['neo-calendar-header-toolbar', 'neo-toolbar'],
            items : ['->', ...me.createViewHeaderButtons()]
        }]
    }

    /**
     * @protected
     */
    createItemsContent() {
        let me = this;

        me.calendarsContainer = Neo.create({
            module  : _calendars_Container_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex    : 1,
            parentId: me.id, // we need the parentId to access the model inside the ctor
            owner   : me
        });

        me.dateSelector = Neo.create({
            module   : _component_DateSelector_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
            appName  : me.appName,
            flex     : 'none',
            height   : me.sideBarWidth,
            listeners: {dateChange: me.onDateSelectorChange, scope: me},
            parentId : me.id, // we need the parentId to access the model inside the ctor
            value    : null,

            bind: {
                locale              : data => data.locale,
                scrollNewYearFromTop: data => data.scrollNewYearFromTop,
                showWeekends        : data => data.showWeekends,
                value               : data => _util_Date_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].convertToyyyymmdd(data.currentDate),
                weekStartDay        : data => data.weekStartDay
            },

            ...me.dateSelectorConfig
        });

        me.items = [{
            module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex  : 'none',
            layout: {ntype: 'hbox', align: 'stretch'},
            items : me.createHeaderItems()
        }, {
            module: _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            flex  : 1,
            layout: {ntype: 'hbox', align: 'stretch'},
            items : [{
                module  : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                cls     : ['neo-calendar-sidebar', 'neo-container'],
                layout  : {ntype: 'vbox', align: 'stretch'},
                minWidth: me.sideBarWidth,
                width   : me.sideBarWidth,
                items   : [me.dateSelector, me.calendarsContainer]
            }, {
                module   : _container_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                flex     : 1,
                items    : me.createViews(),
                listeners: {cardLoaded: me.onCardLoaded, scope: me},
                layout   : {
                    ntype              : 'card',
                    activeIndex        : me.views.indexOf(me.activeView),
                    removeInactiveCards: me.removeInactiveCards
                }
            }]
        }]
    }

    /**
     * @param {Boolean} collapsed
     * @returns {Promise<*>}
     */
    createSettingsContainer(collapsed) {
        let me = this;

        return Promise.all(/*! import() */[__webpack_require__.e("vendors-src_tab_Container_mjs"), __webpack_require__.e("src_calendar_view_SettingsContainer_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./SettingsContainer.mjs */ "./src/calendar/view/SettingsContainer.mjs")).then(module => {
            me.items[1].add({
                module             : module.default,
                collapsed,
                minWidth           : me.settingsContainerWidth,
                removeInactiveCards: me.removeInactiveCards,
                style              : {marginRight: !collapsed ? '0' : `-${me.settingsContainerWidth}px`},
                width              : me.settingsContainerWidth,
                ...me.settingsContainerConfig
            })
        })
    }

    /**
     * @returns {Object[]}
     */
    createViewHeaderButtons() {
        let me          = this,
            activeIndex = me.views.indexOf(me.activeView),
            buttons     = [];

        me.views.forEach((view, index) => {
            buttons.push({
                handler    : me.changeActiveView.bind(me, view),
                height     : 24,
                pressed    : activeIndex === index,
                text       : Neo.capitalize(view),
                toggleGroup: 'mainViews',
                value      : view
            })
        });

        return buttons
    }

    /**
     * @returns {Neo.component.Base[]}
     */
    createViews() {
        let me    = this,
            cards = [],
            cmp,

        defaultConfig = {
            appName : me.appName,
            owner   : me,
            parentId: me.id
        },

        map = {
            day: {
                module: () => Promise.all(/*! import() */[__webpack_require__.e("vendors-src_calendar_view_week_Component_mjs"), __webpack_require__.e("src_calendar_view_DayComponent_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ./DayComponent.mjs */ "./src/calendar/view/DayComponent.mjs")),
                flag  : 'day',
                ...defaultConfig,
                ...me.dayComponentConfig
            },
            month: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_month_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./month/Component.mjs */ "./src/calendar/view/month/Component.mjs")),
                flag  : 'month',
                ...defaultConfig,
                ...me.monthComponentConfig
            },
            week: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_week_Component_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./week/Component.mjs */ "./src/calendar/view/week/Component.mjs")),
                flag  : 'week',
                ...defaultConfig,
                ...me.weekComponentConfig
            },
            year: {
                module: () => __webpack_require__.e(/*! import() */ "vendors-src_calendar_view_YearComponent_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./YearComponent.mjs */ "./src/calendar/view/YearComponent.mjs")),
                flag  : 'year',
                ...defaultConfig,
                ...me.yearComponentConfig
            }
        };

        me.views.forEach(view => {
            me[`${view}Component`] = cmp = map[view];
            cards.push(cmp);
        });

        return cards
    }

    /**
     * @param data
     */
    onCardLoaded(data) {
        this[`${data.item.flag}Component`] = data.item;

        // fire the event on this instance as well => setting views can subscribe to it more easily
        this.fire('cardLoaded', {item: data.item})
    }

    /**
     * @param {Object} data
     * @param {String} data.oldValue
     * @param {String} data.value
     */
    onDateSelectorChange({value}) {
        this.setState('currentDate', value)
    }

    /**
     * @param data
     */
    onNextIntervalButtonClick(data) {
        this.switchInterval(1)
    }

    /**
     * @param data
     */
    onPreviousIntervalButtonClick(data) {
        this.switchInterval(-1)
    }

    /**
     * @param data
     */
    onTodayButtonClick(data) {
        this.stateProvider.setData({
            currentDate: todayDate
        })
    }

    /**
     * @protected
     */
    toggleSettings() {
        this.settingsExpanded = !this.settingsExpanded
    }

    /**
     * @protected
     */
    toggleSidebar() {
        this.sideBarExpanded = !this.sideBarExpanded
    }

    /**
     * @param {Number} multiplier
     */
    switchInterval(multiplier) {
        let me            = this,
            {currentDate} = me.data,

        map = {
            day  : () => {currentDate.setDate(    currentDate.getDate()     + multiplier)},
            month: () => {currentDate.setMonth(   currentDate.getMonth()    + multiplier)},
            week : () => {currentDate.setDate(    currentDate.getDate() + 7 * multiplier)},
            year : () => {currentDate.setFullYear(currentDate.getFullYear() + multiplier)}
        };

        map[me.activeView]();

        me.stateProvider.setData({currentDate})
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(MainContainer));


/***/ },

/***/ "./src/calendar/view/calendars/ColorsList.mjs"
/*!****************************************************!*\
  !*** ./src/calendar/view/calendars/ColorsList.mjs ***!
  \****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../list/Base.mjs */ "./src/list/Base.mjs");


/**
 * @class Neo.calendar.view.calendars.ColorsList
 * @extends Neo.list.Base
 */
class ColorsList extends _list_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.ColorsList'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.ColorsList',
        /**
         * @member {String[]} baseCls=['neo-calendars-colors-list','neo-list']
         */
        baseCls: ['neo-calendars-colors-list', 'neo-list'],
        /**
         * @member {Object} bind
         */
        bind: {
            store: 'stores.colors'
        },
        /**
         * Set this to true in case a keyboard navigation should immediately select the focussed item
         * @member {Boolean} selectOnFocus=true
         */
        selectOnFocus: true,
        /**
         * @member {Boolean} useWrapperNode=false
         * @reactive
         */
        useWrapperNode: false,
        /**
         * The list gets used as a form field, so we are adjusting the selection based on this config
         * @member {String} value_=null
         * @reactive
         */
        value_: null,
        /**
         * Added a tabIndex to enable tabbing through the form
         * @member {Object} _vdom={tag:'ul',cn:[],tabIndex:'0'}
         */
        _vdom:
        {tag: 'ul', cn: [], tabIndex: '0'}
    }

    /**
     * Triggered after the value config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetValue(value, oldValue) {
        let me = this,
            record;

        if (value && oldValue !== undefined && !me.disableSelection) {
            record = me.store.find('name', value)[0];
            me.selectionModel?.select(me.getItemId(record[me.getKeyProperty()]))
        }
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a string.
     */
    createItemContent(record, index) {
        return {style: {
            backgroundColor: `var(--event-${record.name}-color)`,
            color          : `var(--event-${record.name}-color)` // needed for the box-shadow (CSS currentColor)
        }}
    }

    /**
     * @returns {Object}
     */
    getVdomRoot() {
        return this.vdom
    }

    /**
     * @returns {Object}
     */
    getVnodeRoot() {
        return this.vnode
    }

    /**
     *
     */
    onConstructed() {
        super.onConstructed();

        let me      = this,
            {value} = me;

        value && me.afterSetValue(value, null)
    }

    /**
     * Gets triggered from selection.Model: select()
     * @param {String[]} items
     */
    onSelect(items) {
        let me       = this,
            recordId = me.getItemRecordId(items[0]);

        me.fire('change', {
            record: me.store.get(recordId)
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(ColorsList));


/***/ },

/***/ "./src/calendar/view/calendars/Container.mjs"
/*!***************************************************!*\
  !*** ./src/calendar/view/calendars/Container.mjs ***!
  \***************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _List_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./List.mjs */ "./src/calendar/view/calendars/List.mjs");



/**
 * @class Neo.calendar.view.calendars.Container
 * @extends Neo.container.Base
 */
class Container extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.Container'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.Container',
        /**
         * @member {String[]} baseCls=['neo-calendar-calendarscontainer','neo-container']
         */
        baseCls: ['neo-calendar-calendarscontainer', 'neo-container'],
        /**
         * @member {Object} bind
         */
        bind: {
            calendarStore: 'stores.calendars'
        },
        /**
         * @member {Neo.calendar.store.Calendars|null} calendarStore_=null
         * @reactive
         */
        calendarStore: null,
        /**
         * @member {Object[]} items
         */
        items: [{
            module: _List_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
            owner : '@config:owner' // passing the owner config downwards
        }, {
            ntype       : 'button',
            cls         : ['neo-add-calendar-button'],
            flex        : 'none',
            handler     : 'onAddCalendarButtonClick',
            handlerScope: 'this',
            style       : {marginTop: 'auto'},
            text        : 'Add Calendar'
        }],
        /**
         * @member {Object} layout={ntype:'vbox',align:'stretch'}
         * @protected
         * @reactive
         */
        layout: {ntype: 'vbox', align: 'stretch'},
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * @param {Object} data
     */
    onAddCalendarButtonClick(data) {
        this.calendarStore.add({
            active: true,
            color : 'red',
            name  : 'New Calendar'
        })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Container));


/***/ },

/***/ "./src/calendar/view/calendars/EditContainer.mjs"
/*!*******************************************************!*\
  !*** ./src/calendar/view/calendars/EditContainer.mjs ***!
  \*******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _ColorsList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorsList.mjs */ "./src/calendar/view/calendars/ColorsList.mjs");
/* harmony import */ var _form_Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../form/Container.mjs */ "./src/form/Container.mjs");
/* harmony import */ var _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../form/field/Text.mjs */ "./src/form/field/Text.mjs");





/**
 * @class Neo.calendar.view.calendars.EditContainer
 * @extends Neo.form.Container
 */
class EditContainer extends _form_Container_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.EditContainer'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.EditContainer',
        /**
         * @member {String[]} baseCls=['neo-calendar-edit-container']
         */
        baseCls: ['neo-calendar-edit-container'],
        /**
         * @member {Neo.calendar.view.calendars.ColorsList|null} colorsList=null
         */
        colorsList: null,
        /**
         * @member {Object|null} colorsListConfig=null
         */
        colorsListConfig: null,
        /**
         * @member {Object|null} nameFieldConfig=null
         */
        nameFieldConfig: null,
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         */
        owner: null,
        /**
         * @member {Neo.calendar.model.Calendar|null} record_=null
         * @reactive
         */
        record_: null,
        /**
         * @member {Number|null} unMountTimeoutId=null
         * @protected
         */
        unMountTimeoutId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        // focus trap, see: https://github.com/neomjs/neo/issues/2306
        this.vdom.tabIndex = -1;
    }

    /**
     * Triggered after the mounted config got changed
     * @param {Boolean} value
     * @param {Boolean} oldValue
     * @protected
     */
    afterSetMounted(value, oldValue) {
        super.afterSetMounted(value, oldValue);

        value && this.getField('name').then(field => {
            field.focus()
        })
    }

    /**
     * Triggered after the record config got changed
     * @param {Neo.calendar.model.Calendar} value
     * @param {Neo.calendar.model.Calendar} oldValue
     * @protected
     */
    afterSetRecord(value, oldValue) {
        let me = this;

        if (value && oldValue) {
            me.reset({
                name: value.name
            });

            me.colorsList.value = value.color;
        } else if (value) {
            me.createItems();
        }
    }

    /**
     * Triggered before the record config gets changed
     * We need the before method to also get clicks on the same edit icon,
     * since it does trigger for not changed values.
     * @param {Neo.calendar.model.Calendar} value
     * @param {Neo.calendar.model.Calendar} oldValue
     * @protected
     */
    beforeSetRecord(value, oldValue) {
        let me = this;

        if (me.unMountTimeoutId) {
            clearTimeout(me.unMountTimeoutId);
            me.unMountTimeoutId = null;
        }

        return value;
    }

    /**
     *
     */
    createItems() {
        let me       = this,
            {record} = me;

        if (record) {
            me.colorsList = Neo.create({
                module      : _ColorsList_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
                listeners   : {change: me.onColorChange, scope: me},
                parentId    : me.parentId,
                value       : record.color,
                wrapperStyle: {marginTop: '0.2em'},
                ...me.colorsListConfig
            });

            me.items = [{
                module              : _form_field_Text_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
                clearToOriginalValue: true,
                flex                : 'none',
                labelPosition       : 'inline',
                labelText           : 'Calendar Name',
                listeners           : {change: me.onNameFieldChange, scope: me},
                name                : 'name',
                required            : true,
                value               : record.name,
                ...me.nameFieldConfig
            },
            me.colorsList, {
                module : _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
                cls    : ['neo-red'],
                handler: me.onDeleteButtonClick.bind(me),
                iconCls: 'fas fa-trash-alt',
                style  : {marginTop: '3em'},
                text   : 'Delete'
            }];

            super.createItems();
        }
    }

    /**
     * @param {Object} data
     * @param {Object} data.record
     */
    onColorChange(data) {
        this.record.color = data.record.name;
    }

    /**
     * @param {Object} data
     */
    onDeleteButtonClick(data) {
        let me = this;

        // todo: we could add a confirm dialog

        me.getStateProvider().getStore('calendars').remove(me.record);
        me.unmount();
    }

    /**
     * @param {Object} [data]
     */
    onFocusLeave(data) {
        let me = this;

        // we need a short delay to get record-changes (clicking on another edit icon)
        me.unMountTimeoutId = setTimeout(() => {
            me.unMountTimeoutId = null;
            me.mounted && me.unmount();
        }, 200);
    }

    /**
     * @param {Object} data
     */
    onNameFieldChange(data) {
        if (!Neo.isEmpty(data.value)) {
            this.record.name = data.value;
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(EditContainer));


/***/ },

/***/ "./src/calendar/view/calendars/List.mjs"
/*!**********************************************!*\
  !*** ./src/calendar/view/calendars/List.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../form/field/CheckBox.mjs */ "./src/form/field/CheckBox.mjs");
/* harmony import */ var _list_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../list/Component.mjs */ "./src/list/Component.mjs");



/**
 * @class Neo.calendar.view.calendars.List
 * @extends Neo.list.Component
 */
class List extends _list_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.calendar.view.calendars.List'
         * @protected
         */
        className: 'Neo.calendar.view.calendars.List',
        /**
         * @member {String[]} baseCls=['neo-calendars-list','neo-list']
         */
        baseCls: ['neo-calendars-list', 'neo-list'],
        /**
         * @member {Object} bind
         */
        bind: {
            store: 'stores.calendars'
        },
        /**
         * @member {Object} itemDefaults
         */
        itemDefaults: {
            module        : _form_field_CheckBox_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            flex          : 'none',
            hideLabel     : true,
            iconCls       : ['fas', 'fa-square'],
            iconClsChecked: ['fas', 'fa-check-square']
        },
        /**
         * @member {Neo.calendar.view.MainContainer|null} owner=null
         * @protected
         */
        owner: null
    }

    /**
     * Override this method for custom renderers
     * @param {Object} record
     * @param {Number} index
     * @returns {Object|Object[]|String} Either a config object to assign to the item, a vdom cn array or a string.
     */
    createItemContent(record, index) {
        let me       = this,
            id       = record[me.getKeyProperty()],
            items    = me.items || [],
            checkBox = items[index],

        config = {
            checked   : record.active,
            cls       : [`neo-color-${record.color}`],
            fieldValue: id,
            id        : me.getComponentId(index),
            valueLabel: record.name
        };

        if (checkBox) {
            checkBox.setSilent(config)
        } else {
            items[index] = checkBox = Neo.create({
                appName  : me.appName,
                listeners: {change: me.onCheckboxChange, scope: me},
                parentId : me.id,
                windowId : me.windowId,
                ...me.itemDefaults,
                ...config
            })
        }

        me.items       = items;
        me.updateDepth = 2;

        return [
            checkBox.createVdomReference(),
            {tag: 'i', cls: ['neo-edit-icon', 'fas', 'fa-edit'], id: me.getEditIconId(index)}
        ]
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getEditIconId(index) {
        return `${this.id}__${index}__edit-icon`
    }

    /**
     * @param {Object} data
     */
    onCheckboxChange(data) {
        this.store.get(data.component.fieldValue).active = data.value
    }

    /**
     * @param {Object} data
     */
    onClick(data) {
        // The click even arrives before the CheckBox onInputValueChange() gets triggered.
        // We need a short delay to ensure the vdom of the list item contains the new checked state
        this.timeout(20).then(() => {
            super.onClick(data)
        });

        if (data.path[0].cls.includes('neo-edit-icon')) {
            let me                    = this,
                listItemRect          = data.path[1].rect,
                mainContainer         = me.owner,
                editCalendarContainer = mainContainer.editCalendarContainer,
                {mounted, style}      = editCalendarContainer,
                record                = me.store.get(me.getItemRecordId(data.path[1].id));

            Object.assign(style, {
                left: `${listItemRect.right + 13}px`,
                top : `${listItemRect.top   - 10}px`
            });

            editCalendarContainer[mounted ? 'set' : 'setSilent']({
                parentId: mainContainer.id,
                record,
                style
            });

            if (!mounted) {
                editCalendarContainer.initVnode(true)
            } else {
                editCalendarContainer.afterSetMounted(true, false)
            }
        }
    }

    /**
     * @param {String} itemId
     */
    onKeyDownEnter(itemId) {
        let me       = this,
            recordId = me.getItemRecordId(itemId),
            checkBox = me.items[me.store.indexOf(recordId)];

        checkBox.checked = !checkBox.checked
    }

    /**
     * @param {String[]} items
     */
    onSelect(items) {
        this.setState('activeCalendarId', this.getItemRecordId(items[0]))
    }

    /**
     * Disabling the super class logic for now, since the collection.Base mutation event already covers the sorting
     * @param {Object} data
     */
    sortItems(data) {

    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(List));


/***/ },

/***/ "./src/component/Label.mjs"
/*!*********************************!*\
  !*** ./src/component/Label.mjs ***!
  \*********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/component/Base.mjs");


/**
 * Convenience class to render a label with a text
 * @class Neo.component.Label
 * @extends Neo.component.Base
 */
class Label extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.component.Label'
         * @protected
         */
        className: 'Neo.component.Label',
        /**
         * @member {String} ntype='label'
         * @protected
         */
        ntype: 'label',
        /**
         * @member {String[]} baseCls=['neo-label']
         */
        baseCls: ['neo-label'],
        /**
         * @member {String} tag='label'
         * @protected
         * @reactive
         */
        tag: 'label'
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Label));


/***/ },

/***/ "./src/controller/Component.mjs"
/*!**************************************!*\
  !*** ./src/controller/Component.mjs ***!
  \**************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/controller/Base.mjs");
/* harmony import */ var _util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Function.mjs */ "./src/util/Function.mjs");



/**
 * @class Neo.controller.Component
 * @extends Neo.controller.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.controller.Component'
         * @protected
         */
        className: 'Neo.controller.Component',
        /**
         * @member {String} ntype='component-controller'
         * @protected
         */
        ntype: 'component-controller',
        /**
         * @member {Neo.component.Base|null} component=null
         * @protected
         */
        component: null,
        /**
         * @member {Neo.controller.Component|null} parent_=null
         * @reactive
         */
        parent_: null,
        /**
         * @member {Object} references=null
         * @protected
         */
        references: null,
        /**
         * @member {String|null} windowId=null
         */
        windowId: null
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me          = this,
            {component} = me;

        me.references = {};

        if (component.isConstructed) {
            me.onComponentConstructed()
        } else {
            component.on('constructed', () => {
                me.onComponentConstructed()
            }, me, {once: true})
        }
    }

    /**
     * Triggered before the parent config gets changed
     * @param {Neo.controller.Component|null} value
     * @param {Neo.controller.Component|null} oldValue
     * @protected
     */
    beforeSetParent(value, oldValue) {
        return value || this.getParent()
    }

    /**
     * @param {String} handlerName
     * @param {Neo.component.Base|null} [component]
     * @returns {Neo.controller.Component|Boolean|null}
     */
    getHandlerScope(handlerName, component) {
        let me       = this,
            {parent} = me,
            handlerCb;

        if (component) {
            // Look for ths function *name* first in the Component itself.
            // If we find it, return true so calling code knows not to continue to search.
            handlerCb = (0,_util_Function_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveCallback)(handlerName, component);

            // Handler fn is resolved in the Component or its own parent chain.
            // Return a status indicating that we do not need an early binding
            if (handlerCb.fn) {
                return true
            }
        }

        return Neo.isFunction(me[handlerName]) ?
            me : parent?.getHandlerScope(handlerName) || null
    }

    /**
     * Get the closest controller inside the components parent tree
     * @returns {Neo.controller.Component|null}
     */
    getParent() {
        let me       = this,
            {parent} = me;

        if (parent) {
            return parent
        }

        return me.component.parent?.getController() || null
    }

    /**
     * todo: update changed references (e.g. container.remove() then container.add() using the same key)
     * @param {String} name
     * @returns {*}
     */
    getReference(name) {
        let me        = this,
            component = me.references[name];

        if (!component) {
            component = me.component.down({reference: name});

            if (component) {
                me.references[name] = component
            }
        }

        return component || null
    }

    /**
     * Convenience shortcut
     * @param args
     * @returns {*}
     */
    getState(...args) {
        return this.getStateProvider().getData(...args)
    }

    /**
     * sameLevelOnly=false will return the closest stateProvider inside the component parent tree,
     * in case there is none on the same level.
     * @param {Boolean} [sameLevelOnly=false]
     */
    getStateProvider(sameLevelOnly=false) {
        let {component} = this;
        return sameLevelOnly ? component.stateProvider : component.getStateProvider()
    }

    /**
     * Convenience shortcut for accessing state.Provider based data.Stores
     * @param {String} key
     * @returns {Neo.data.Store}
     */
    getStore(key) {
        return this.getStateProvider().getStore(key)
    }

    /**
     * Override this method inside your view controllers as a starting point in case you need references
     * (instead of using onConstructed() inside your controller)
     */
    onComponentConstructed() {}

    /**
     * Will get called by component.Base: destroy() in case the component has a reference config
     * @param {Neo.component.Base} component
     */
    removeReference(component) {
        let me           = this,
            {references} = me,
            key;

        for (key in references) {
            if (component === references[key]) {
                delete references[key];
                break
            }
        }

        me.getParent()?.removeReference(component)
    }

    /**
     * Convenience shortcut
     * @param args
     */
    setState(...args) {
        this.getStateProvider().setData(...args)
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/form/field/Color.mjs"
/*!**********************************!*\
  !*** ./src/form/field/Color.mjs ***!
  \**********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../list/Color.mjs */ "./src/list/Color.mjs");
/* harmony import */ var _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComboBox.mjs */ "./src/form/field/ComboBox.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/VDom.mjs */ "./src/util/VDom.mjs");




/**
 * @class Neo.form.field.Color
 * @extends Neo.form.field.ComboBox
 */
class Color extends _ComboBox_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.form.field.Color'
         * @protected
         */
        className: 'Neo.form.field.Color',
        /**
         * @member {String} ntype='colorfield'
         * @protected
         */
        ntype: 'colorfield',
        /**
         * @member {String[]} baseCls=['neo-colorfield','neo-combobox','neo-pickerfield','neo-textfield']
         */
        baseCls: ['neo-colorfield', 'neo-combobox', 'neo-pickerfield', 'neo-textfield'],
        /**
         * The data.Model field which contains the color value
         * @member {String} colorField='name'
         */
        colorField: 'name',
        /**
         * Override the formatter to apply a custom background-color styling.
         * E.g. using CSS vars for different themes
         * @member {Function} colorField=(scope,data)=>data[scope.colorField]
         */
        colorFormatter: (scope,data) => data[scope.colorField],
        /**
         * @member {Object|null} listConfig
         */
        listConfig: {
            module            : _list_Color_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
            colorField        : '@config:colorField',
            colorFormatter    : '@config:colorFormatter',
            silentSelectUpdate: true
        }
    }

    /**
     * @param {Object} config
     */
    construct(config) {
        super.construct(config);

        let me           = this,
            inputWrapper = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.vdom, me.getInputWrapperId());

        inputWrapper.vdom.cn.unshift({
            cls  : 'neo-color',
            id   : me.getColorIndicatorId(),
            style: {
                backgroundColor: me.getColor()
            }
        });

        me.update()
    }

    /**
     * Triggered after the value config got changed
     * @param {Number|String|null} value
     * @param {Number|String|null} oldValue
     * @param {Boolean} [preventFilter=false]
     * @protected
     */
    afterSetValue(value, oldValue, preventFilter=false) {
        let me             = this,
            colorIndicator = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].find(me.vdom, me.getColorIndicatorId())?.vdom,
            {list, record} = me,
            selectionModel = me.list?.selectionModel;

        if (colorIndicator) {
            colorIndicator.style.backgroundColor = me.getColor()
        }

        if (record) {
            selectionModel?.select(list.getItemId(record[me.store.keyProperty]))
        } else {
            selectionModel?.deselectAll(true)
        }

        // the super call will trigger the vdom update
        super.afterSetValue(value, oldValue, preventFilter)
    }

    /**
     * @returns {String}
     */
    getColor() {
        let me                  = this,
            {inputValue, value} = me;

        return value ? me.colorFormatter(me, value) : me.forceSelection ? null : inputValue
    }

    /**
     * @returns {String}
     */
    getColorIndicatorId() {
        return `${this.id}__color-indicator`
    }

    /**
     * @protected
     */
    onSelectPostLastItem() {
        let {list} = this,
            index  = list.store.getCount() - 1;

        list.vdom.cn[index] = list.createItem(list.store.getAt(index), index);

        super.onSelectPostLastItem()
    }

    /**
     * @protected
     */
    onSelectPreFirstItem() {
        let {list} = this;

        list.vdom.cn[0] = list.createItem(list.store.getAt(0), 0);

        super.onSelectPreFirstItem()
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Color));


/***/ },

/***/ "./src/list/Component.mjs"
/*!********************************!*\
  !*** ./src/list/Component.mjs ***!
  \********************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./src/list/Base.mjs");


/**
 * A base class for lists which will use component based list items
 * @class Neo.list.Component
 * @extends Neo.list.Base
 */
class Component extends _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static config = {
        /**
         * @member {String} className='Neo.list.Component'
         * @protected
         */
        className: 'Neo.list.Component',
        /**
         * @member {String} ntype='component-list'
         * @protected
         */
        ntype: 'component-list',
        /**
         * @member {Neo.component.Base[]|null} items=null
         */
        items: null
    }

    /**
     * Triggered after the appName config got changed
     * @param {String|null} value
     * @param {String|null} oldValue
     * @protected
     */
    afterSetAppName(value, oldValue) {
        super.afterSetAppName(value, oldValue);

        value && this.items?.forEach(item => {
            item.appName = value
        })
    }

    /**
     * Triggered after the windowId config got changed
     * @param {Number|null} value
     * @param {Number|null} oldValue
     * @protected
     */
    afterSetWindowId(value, oldValue) {
        super.afterSetWindowId(value, oldValue);

        value && this.items?.forEach(item => {
            item.windowId = value
        })
    }

    /**
     *
     */
    destroy(...args) {
        let items = this.items || [];

        items.forEach(item => {
            item.destroy()
        });

        super.destroy(...args)
    }

    /**
     * @param {Number} index
     * @returns {String}
     */
    getComponentId(index) {
        return `${this.id}__${index}__component`
    }

    /**
     * @param {Number|String} recordId
     * @returns {String}
     */
    getItemId(recordId) {
        return `${this.id}__${this.store.indexOf(recordId)}`
    }

    /**
     * @param {String} vnodeId
     * @returns {String|Number} itemId
     */
    getItemRecordId(vnodeId) {
        let itemId = vnodeId.split('__')[1];
        return this.store.getAt(parseInt(itemId))[this.getKeyProperty()]
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    onStoreSort(data) {
        this.sortItems(data);
        super.onStoreSort(data)
    }

    /**
     * @param {Object} data
     * @param {Object[]} data.items
     * @param {Object[]} data.previousItems
     * @param {Neo.data.Store} data.scope
     */
    sortItems(data) {
        let me       = this,
            newItems = [],
            fromIndex, key, previousKeys;

        if (me.items) {
            me.items.forEach(item => {
                item.setSilent({id: null})
            });

            key          = me.getKeyProperty();
            previousKeys = data.previousItems.map(e => e[key]);

            data.items.forEach(item => {
                fromIndex = previousKeys.indexOf(item[key]);
                newItems.push(me.items[fromIndex])
            });

            me.updateDepth = -1;
            me.items = newItems
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Component));


/***/ },

/***/ "./src/toolbar/Base.mjs"
/*!******************************!*\
  !*** ./src/toolbar/Base.mjs ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _button_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../button/Base.mjs */ "./src/button/Base.mjs");
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../component/Base.mjs */ "./src/component/Base.mjs");
/* harmony import */ var _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../container/Base.mjs */ "./src/container/Base.mjs");
/* harmony import */ var _component_Label_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../component/Label.mjs */ "./src/component/Label.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array.mjs */ "./src/util/Array.mjs");






/**
 * @class Neo.toolbar.Base
 * @extends Neo.container.Base
 */
class Toolbar extends _container_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Valid values for dock
     * @member {String[]} dockPositions=['top','right','bottom','left', null]
     * @static
     */
    static dockPositions = ['top', 'right', 'bottom', 'left', null]

    static config = {
        /**
         * @member {String} className='Neo.toolbar.Base'
         * @protected
         */
        className: 'Neo.toolbar.Base',
        /**
         * @member {String} ntype='toolbar'
         * @protected
         */
        ntype: 'toolbar',
        /**
         * @member {String[]} baseCls=['neo-toolbar']
         */
        baseCls: ['neo-toolbar'],
        /**
         * @member {String|null} dock_=null
         * @reactive
         */
        dock_: null,
        /**
         * @member {Object} itemDefaults={ntype:'button'}
         * @reactive
         */
        itemDefaults: {
            ntype: 'button'
        },
        /**
         * @member {Object} layout={ntype:'flexbox',align:'center',direction: 'row', pack:'start'}
         * @reactive
         */
        layout: {
            ntype    : 'flexbox',
            align    : 'center',
            direction: 'row',
            pack     : 'start'
        }
    }

    /**
     * Triggered after the dock config got changed
     * @param {String} value
     * @param {String} oldValue
     * @protected
     */
    afterSetDock(value, oldValue) {
        if (!value && !oldValue) {
            return
        }

        let me            = this,
            {cls}         = me,
            dockPositions = me.getStaticConfig('dockPositions'),
            layoutConfig  = me.getLayoutConfig();

        dockPositions.forEach(key => {
            key !== null && _util_Array_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].toggle(cls, 'neo-dock-' + key, key === value)
        });

        if (!me.layout) {
            layoutConfig.ntype = 'flexbox';
            me.set({cls, layout: layoutConfig})
        } else {
            me.layout.set(layoutConfig);
            me.cls = cls;
        }
    }

    /**
     * Checks if the new dock position matches a value of the static dockPositions config
     * @param {String} value
     * @param {String} oldValue
     * @returns {String} value
     * @protected
     */
    beforeSetDock(value, oldValue) {
        return this.beforeSetEnumValue(value, oldValue, 'dock', 'dockPositions')
    }

    /**
     *
     */
    createItems() {
        let items = this._items;

        if (Array.isArray(items)) {
            this._items = items.map(item => this.replaceSpacer(item))
        }

        return super.createItems()
    }

    /**
     * Creates a layout config depending on this.dock
     * @returns {Object} layoutConfig
     */
    getLayoutConfig() {
        let me = this,
            layoutConfig;

        if (me.dock) {
            switch (me.dock) {
                case 'bottom':
                case 'top':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'row',
                        pack     : 'start'
                    };
                    break
                case 'left':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column-reverse',
                        pack     : 'start'
                    };
                    break
                case 'right':
                    layoutConfig = {
                        align    : 'center',
                        direction: 'column',
                        pack     : 'start'
                    };
                    break
            }
        }

        return layoutConfig || me.layout
    }

    /**
     * Inserts an item or array of items at a specific index
     * @param {Number} index
     * @param {Array|Object} item
     * @param {Boolean} [silent=false]
     * @returns {Neo.component.Base|Neo.component.Base[]}
     */
    insert(index, item, silent=false) {
        if (Array.isArray(item)) {
            item = item.map(item => this.replaceSpacer(item))
        } else {
            item = this.replaceSpacer(item)
        }

        return super.insert(index, item, silent)
    }

    /**
     * @param {Array|Object|String} item
     * @returns {Array|Object}
     */
    replaceSpacer(item) {
        return item === '->' ? {module: _component_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], flex: 1} : item
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Neo.setupClass(Toolbar));


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtzL2FwcC92ZW5kb3JzLWV4YW1wbGVzX2NhbGVuZGFyX2Jhc2ljX2FwcF9tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1FO0FBQ2dCO0FBQ2Y7QUFDQTtBQUNNOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBdUI7QUFDM0MscUJBQXFCLGdDQUFnQzs7QUFFckQ7QUFDQSxxQkFBcUIsNkRBQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCLDREQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlCQUF5Qiw0REFBTTtBQUMvQjtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCx1QkFBdUIsNEVBQVE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsNkJBQTZCLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyRTJCOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxRUFBbUI7QUFDekQ7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUs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Z0MsUUFBUSwyREFBUyxXQUFXO0FBQzVEO0FBQ0E7O0FBRUEsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY2FsZW5kYXIvYmFzaWMvTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL2V4YW1wbGVzL2NhbGVuZGFyL2Jhc2ljL01haW5Db250YWluZXJDb250cm9sbGVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vZXhhbXBsZXMvY2FsZW5kYXIvYmFzaWMvYXBwLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvRWRpdEV2ZW50Q29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvTWFpbkNvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L2NhbGVuZGFycy9Db2xvcnNMaXN0Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvY2FsZW5kYXJzL0NvbnRhaW5lci5tanMiLCJ3ZWJwYWNrOi8vbmVvLm1qcy8uL3NyYy9jYWxlbmRhci92aWV3L2NhbGVuZGFycy9FZGl0Q29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NhbGVuZGFyL3ZpZXcvY2FsZW5kYXJzL0xpc3QubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvY29tcG9uZW50L0xhYmVsLm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2NvbnRyb2xsZXIvQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9uZW8ubWpzLy4vc3JjL2Zvcm0vZmllbGQvQ29sb3IubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvbGlzdC9Db21wb25lbnQubWpzIiwid2VicGFjazovL25lby5tanMvLi9zcmMvdG9vbGJhci9CYXNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQnV0dG9uICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ2FsZW5kYXIgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NhbGVuZGFyL3ZpZXcvTWFpbkNvbnRhaW5lci5tanMnO1xuaW1wb3J0IE1haW5Db250YWluZXJDb250cm9sbGVyIGZyb20gJy4vTWFpbkNvbnRhaW5lckNvbnRyb2xsZXIubWpzJztcbmltcG9ydCBUb29sYmFyICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi8uLi9zcmMvdG9vbGJhci9CYXNlLm1qcyc7XG5pbXBvcnQgVmlld3BvcnQgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vLi4vc3JjL2NvbnRhaW5lci9WaWV3cG9ydC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMuTWFpbkNvbnRhaW5lclxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5WaWV3cG9ydFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgVmlld3BvcnQge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIGNsYXNzTmFtZSA6ICdOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMuTWFpbkNvbnRhaW5lcicsXG4gICAgICAgIGF1dG9Nb3VudCA6IHRydWUsXG4gICAgICAgIGNscyAgICAgICA6IFsnbmVvLWV4YW1wbGVzLWNhbGVuZGFyLW1haW5jb250YWluZXInLCAnbmVvLXZpZXdwb3J0J10sXG4gICAgICAgIGNvbnRyb2xsZXI6IE1haW5Db250YWluZXJDb250cm9sbGVyLFxuICAgICAgICBsYXlvdXQgICAgOiB7bnR5cGU6ICd2Ym94JywgYWxpZ246ICdzdHJldGNoJ30sXG5cbiAgICAgICAgaXRlbXM6IFt7XG4gICAgICAgICAgICBtb2R1bGUgOiBUb29sYmFyLFxuICAgICAgICAgICAgZmxleCAgIDogJ25vbmUnLFxuICAgICAgICAgICAgcGFkZGluZzogMjAsXG4gICAgICAgICAgICByZWZlcmVuY2U6ICdoZWFkZXJUb29sYmFyJyxcblxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjJmMmYyJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nICAgICAgICA6ICcxMHB4IDVweCAxMHB4IDEwcHgnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICBudHlwZTogJ2NvbXBvbmVudCcsXG4gICAgICAgICAgICAgICAgY2xzICA6IFsnbmVvLWhlYWRlciddLFxuICAgICAgICAgICAgICAgIGh0bWwgOiAnPGkgY2xhc3M9XCJmYSBmYS1jYWxlbmRhclwiPjwvaT5uZW8ubWpzIENhbGVuZGFyJ1xuICAgICAgICAgICAgfSwgJy0+Jywge1xuICAgICAgICAgICAgICAgIG1vZHVsZSA6IEJ1dHRvbixcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiAnb25Td2l0Y2hUaGVtZUJ1dHRvbkNsaWNrJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiAyNyxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtbW9vbicsXG4gICAgICAgICAgICAgICAgdGV4dCAgIDogJ1RoZW1lIERhcmsnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGhlaWdodCA6IDI3LFxuICAgICAgICAgICAgICAgIGljb25DbHM6ICdmYWIgZmEtZ2l0aHViJyxcbiAgICAgICAgICAgICAgICBzdHlsZSAgOiB7bWFyZ2luTGVmdDogJzVweCd9LFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdHaXRIdWInLFxuICAgICAgICAgICAgICAgIHVybCAgICA6ICdodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby90cmVlL2Rldi9zcmMvY2FsZW5kYXInXG4gICAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGUgICA6IENhbGVuZGFyLFxuICAgICAgICAgICAgZmxleCAgICAgOiAxLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiAnY2FsZW5kYXInLFxuXG4gICAgICAgICAgICBjYWxlbmRhclN0b3JlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgYXV0b0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdXJsICAgICA6ICcuLi8uLi9leGFtcGxlcy9jYWxlbmRhci9iYXNpYy9kYXRhL2NhbGVuZGFycy5qc29uJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZXZlbnRTdG9yZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGF1dG9Mb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVybCAgICAgOiAnLi4vLi4vZXhhbXBsZXMvY2FsZW5kYXIvYmFzaWMvZGF0YS9ldmVudHMuanNvbidcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1vZGVsRGF0YToge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlOiBuZXcgRGF0ZSgnMjAyNC0wNy0yMScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhNYWluQ29udGFpbmVyKTtcbiIsImltcG9ydCBDb21wb25lbnRDb250cm9sbGVyIGZyb20gJy4uLy4uLy4uL3NyYy9jb250cm9sbGVyL0NvbXBvbmVudC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXJcbiAqIEBleHRlbmRzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyQ29udHJvbGxlciBleHRlbmRzIENvbXBvbmVudENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmV4YW1wbGVzLmNhbGVuZGFyLmJhc2ljLk1haW5Db250YWluZXJDb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uZXhhbXBsZXMuY2FsZW5kYXIuYmFzaWMuTWFpbkNvbnRhaW5lckNvbnRyb2xsZXInXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblN3aXRjaFRoZW1lQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBidXR0b24gICAgICAgID0gZGF0YS5jb21wb25lbnQsXG4gICAgICAgICAgICBjb21wb25lbnQgICAgID0gbWUuY29tcG9uZW50LFxuICAgICAgICAgICAgaGVhZGVyVG9vbGJhciA9IG1lLmdldFJlZmVyZW5jZSgnaGVhZGVyVG9vbGJhcicpLFxuICAgICAgICAgICAgYnV0dG9uVGV4dCwgaGVhZGVyQ29sb3IsIGljb25DbHMsIHN0eWxlLCB0aGVtZTtcblxuICAgICAgICBpZiAoYnV0dG9uLnRleHQgPT09ICdUaGVtZSBMaWdodCcpIHtcbiAgICAgICAgICAgIGJ1dHRvblRleHQgID0gJ1RoZW1lIERhcmsnO1xuICAgICAgICAgICAgaGVhZGVyQ29sb3IgPSAnI2YyZjJmMic7XG4gICAgICAgICAgICBpY29uQ2xzICAgICA9ICdmYSBmYS1tb29uJztcbiAgICAgICAgICAgIHRoZW1lICAgICAgID0gJ25lby10aGVtZS1saWdodCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1dHRvblRleHQgID0gJ1RoZW1lIExpZ2h0JztcbiAgICAgICAgICAgIGhlYWRlckNvbG9yID0gJyMzMzM0M2QnO1xuICAgICAgICAgICAgaWNvbkNscyAgICAgPSAnZmEgZmEtc3VuJztcbiAgICAgICAgICAgIHRoZW1lICAgICAgID0gJ25lby10aGVtZS1kYXJrJ1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50LnRoZW1lID0gdGhlbWU7XG5cbiAgICAgICAgYnV0dG9uLnNldCh7XG4gICAgICAgICAgICBpY29uQ2xzLFxuICAgICAgICAgICAgdGV4dDogYnV0dG9uVGV4dFxuICAgICAgICB9KTtcblxuICAgICAgICBzdHlsZSA9IGhlYWRlclRvb2xiYXIuc3R5bGUgfHwge307XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IGhlYWRlckNvbG9yO1xuICAgICAgICBoZWFkZXJUb29sYmFyLnN0eWxlID0gc3R5bGVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXJDb250cm9sbGVyKTtcbiIsImltcG9ydCBNYWluQ29udGFpbmVyIGZyb20gJy4vTWFpbkNvbnRhaW5lci5tanMnO1xuXG5leHBvcnQgY29uc3Qgb25TdGFydCA9ICgpID0+IE5lby5hcHAoe1xuICAgIG1haW5WaWV3OiBNYWluQ29udGFpbmVyLFxuICAgIG5hbWUgICAgOiAnTmVvLmV4YW1wbGVzLmNhbGVuZGFyLmJhc2ljJ1xufSk7XG4iLCJpbXBvcnQgQnV0dG9uICAgICAgICBmcm9tICcuLi8uLi9idXR0b24vQmFzZS5tanMnO1xuaW1wb3J0IENhbGVuZGFyU3RvcmUgZnJvbSAnLi4vc3RvcmUvQ2FsZW5kYXJzLm1qcyc7XG5pbXBvcnQgQ29sb3JGaWVsZCAgICBmcm9tICcuLi8uLi9mb3JtL2ZpZWxkL0NvbG9yLm1qcyc7XG5pbXBvcnQgRGF0ZVV0aWwgICAgICBmcm9tICcuLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBGb3JtQ29udGFpbmVyIGZyb20gJy4uLy4uL2Zvcm0vQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgVGV4dEZpZWxkICAgICBmcm9tICcuLi8uLi9mb3JtL2ZpZWxkL1RleHQubWpzJztcbmltcG9ydCBUaW1lRmllbGQgICAgIGZyb20gJy4uLy4uL2Zvcm0vZmllbGQvVGltZS5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5FZGl0RXZlbnRDb250YWluZXJcbiAqIEBleHRlbmRzIE5lby5mb3JtLkNvbnRhaW5lclxuICovXG5jbGFzcyBFZGl0RXZlbnRDb250YWluZXIgZXh0ZW5kcyBGb3JtQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LkVkaXRFdmVudENvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcuRWRpdEV2ZW50Q29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLWVkaXQtZXZlbnQtY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFyLWVkaXQtZXZlbnQtY29udGFpbmVyJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGJpbmRcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IHtcbiAgICAgICAgICAgIGVuZFRpbWUgICAgICAgICAgICAgOiBkYXRhID0+IGRhdGEuZW5kVGltZSxcbiAgICAgICAgICAgIGludGxGb3JtYXRfdGltZSAgICAgOiBkYXRhID0+IGRhdGEudGltZUZvcm1hdHRlcixcbiAgICAgICAgICAgIG1pbmltdW1FdmVudER1cmF0aW9uOiBkYXRhID0+IGRhdGEubWluaW11bUV2ZW50RHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydFRpbWUgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLnN0YXJ0VGltZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGNhbGVuZGFyRmllbGRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY2FsZW5kYXJGaWVsZENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZnVsbCBob3VycyBhcmUgdmFsaWQgZm9yIG5vd1xuICAgICAgICAgKiBmb3JtYXQ6ICdoaDptbSdcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBlbmRUaW1lXz0nMjQ6MDAnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5kVGltZV86ICcyNDowMCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZW5kVGltZUZpZWxkQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGVuZFRpbWVGaWVsZENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRvIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAgICAgICAgICogQG1lbWJlciB7SW50bC5EYXRlVGltZUZvcm1hdHxudWxsfSBpbnRsRm9ybWF0X3RpbWU9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBpbnRsRm9ybWF0X3RpbWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy53ZWVrLkNvbXBvbmVudHxudWxsfSBvd25lcj1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci5tb2RlbC5FdmVudHxudWxsfSByZWNvcmRfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICByZWNvcmRfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBmdWxsIGhvdXJzIGFyZSB2YWxpZCBmb3Igbm93XG4gICAgICAgICAqIGZvcm1hdDogJ2hoOm1tJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHN0YXJ0VGltZV89JzAwOjAwJ1xuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0VGltZV86ICcwMDowMCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gc3RhcnRUaW1lRmllbGRDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnRUaW1lRmllbGRDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gdGl0bGVGaWVsZENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aXRsZUZpZWxkQ29uZmlnOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgLy8gZm9jdXMgdHJhcCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbmVvbWpzL25lby9pc3N1ZXMvMjMwNlxuICAgICAgICB0aGlzLnZkb20udGFiSW5kZXggPSAtMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbW91bnRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldE1vdW50ZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSAmJiB0aGlzLmdldEZpZWxkKCd0aXRsZScpLnRoZW4oZmllbGQgPT4gZmllbGQuZm9jdXMoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlY29yZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5FdmVudH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci5tb2RlbC5FdmVudH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRSZWNvcmQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgICAgICAgICAgPSBtZS5pbnRsRm9ybWF0X3RpbWUsXG4gICAgICAgICAgICAgICAge2NhbGVuZGFySWQsIHRpdGxlfSA9IHZhbHVlO1xuXG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnZW5kVGltZScpICAudGhlbihmaWVsZCA9PiBmaWVsZC5taW5WYWx1ZSA9IG1lLmdldEVuZFRpbWVNaW5WYWx1ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgbWUuZ2V0RmllbGQoJ3N0YXJ0VGltZScpLnRoZW4oZmllbGQgPT4gZmllbGQubWF4VmFsdWUgPSBtZS5nZXRTdGFydFRpbWVNYXhWYWx1ZSh2YWx1ZSkpO1xuXG4gICAgICAgICAgICBtZS5yZXNldCh7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJJZCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lICA6IHRpbWVGb3JtYXQuZm9ybWF0KHZhbHVlLmVuZERhdGUpLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogdGltZUZvcm1hdC5mb3JtYXQodmFsdWUuc3RhcnREYXRlKSxcbiAgICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVJdGVtcygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVjb3JkfSAgID0gbWUsXG4gICAgICAgICAgICB0aW1lRm9ybWF0ID0gbWUuaW50bEZvcm1hdF90aW1lLFxuICAgICAgICAgICAgdGltZUZpZWxkRGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgICA6IFRpbWVGaWVsZCxcbiAgICAgICAgICAgICAgICBjbGVhclRvT3JpZ2luYWxWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICAgICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gICAgICAgOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICAgICAgICAgIDoge2NoYW5nZTogbWUub25UaW1lRmllbGRDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgc3RlcFNpemUgICAgICAgICAgICA6IDE1ICogNjAsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgICA6ICc5ZW0nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgIG1lLml0ZW1zID0gW3tcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgIDogVGV4dEZpZWxkLFxuICAgICAgICAgICAgICAgIGNsZWFyVG9PcmlnaW5hbFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZsZXggICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbiAgICAgICA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dCAgICAgICAgICAgOiAnVGl0bGUnLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vblRpdGxlRmllbGRDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgICAgICAgICAgICA6ICd0aXRsZScsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA6IHJlY29yZC50aXRsZSxcbiAgICAgICAgICAgICAgICAuLi5tZS50aXRsZUZpZWxkQ29uZmlnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgICA6IENvbG9yRmllbGQsXG4gICAgICAgICAgICAgICAgY2xlYXJUb09yaWdpbmFsVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29sb3JGaWVsZCAgICAgICAgICA6ICdjb2xvcicsXG4gICAgICAgICAgICAgICAgZGlzcGxheUZpZWxkICAgICAgICA6ICduYW1lJyxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICAgICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGZvcmNlU2VsZWN0aW9uICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gICAgICAgOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQgICAgICAgICAgIDogJ0NhbGVuZGFyJyxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICAgICAgICAgIDoge2NoYW5nZTogbWUub25DYWxlbmRhckZpZWxkQ2hhbmdlLCBzY29wZTogbWV9LFxuICAgICAgICAgICAgICAgIG5hbWUgICAgICAgICAgICAgICAgOiAnY2FsZW5kYXJJZCcsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdHJpZ2dlckFjdGlvbiAgICAgICA6ICdhbGwnLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgICAgICAgOiByZWNvcmQuY2FsZW5kYXJJZCxcblxuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0dGVyOiAoc2NvcGUsZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW3Njb3BlLmNvbG9yRmllbGRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3llbGxvdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndmFyKC0tZXZlbnQteWVsbG93LWJvcmRlci1jb2xvciknO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB2YXIoLS1ldmVudC0ke3ZhbHVlfS1jb2xvcilgXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHN0b3JlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZSAgOiBDYWxlbmRhclN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZDogbWUuc3RhdGVQcm92aWRlci5nZXRTdG9yZSgnY2FsZW5kYXJzJykuaWRcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLi4ubWUuY2FsZW5kYXJGaWVsZENvbmZpZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJ1N0YXJ0IFRpbWUnLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlIDogbWUuZ2V0U3RhcnRUaW1lTWF4VmFsdWUocmVjb3JkKSxcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA6IG1lLnN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBuYW1lICAgICA6ICdzdGFydFRpbWUnLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgIDogdGltZUZvcm1hdC5mb3JtYXQocmVjb3JkLnN0YXJ0RGF0ZSksXG4gICAgICAgICAgICAgICAgLi4udGltZUZpZWxkRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4ubWUuc3RhcnRUaW1lRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQ6ICdFbmQgVGltZScsXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgOiBtZS5lbmRUaW1lLFxuICAgICAgICAgICAgICAgIG1pblZhbHVlIDogbWUuZ2V0RW5kVGltZU1pblZhbHVlKHJlY29yZCksXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgOiAnZW5kVGltZScsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgOiB0aW1lRm9ybWF0LmZvcm1hdChyZWNvcmQuZW5kRGF0ZSksXG4gICAgICAgICAgICAgICAgLi4udGltZUZpZWxkRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4ubWUuZW5kVGltZUZpZWxkQ29uZmlnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGNscyAgICA6IFsnbmVvLWJ1dHRvbicsICduZW8tcmVkJ10sXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUub25EZWxldGVCdXR0b25DbGljay5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmFzIGZhLXRyYXNoLWFsdCcsXG4gICAgICAgICAgICAgICAgc3R5bGUgIDoge21hcmdpblRvcDogJzNlbSd9LFxuICAgICAgICAgICAgICAgIHRleHQgICA6ICdEZWxldGUnXG4gICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgc3VwZXIuY3JlYXRlSXRlbXMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuRXZlbnR9IHJlY29yZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0RW5kVGltZU1pblZhbHVlKHJlY29yZCkge1xuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHJlY29yZC5zdGFydERhdGUudmFsdWVPZigpKTtcblxuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyB0aGlzLm1pbmltdW1FdmVudER1cmF0aW9uKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbnRsRm9ybWF0X3RpbWUuZm9ybWF0KGRhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLm1vZGVsLkV2ZW50fSByZWNvcmRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN0YXJ0VGltZU1heFZhbHVlKHJlY29yZCkge1xuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHJlY29yZC5lbmREYXRlLnZhbHVlT2YoKSk7XG5cbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpIC0gdGhpcy5taW5pbXVtRXZlbnREdXJhdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50bEZvcm1hdF90aW1lLmZvcm1hdChkYXRlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DYWxlbmRhckZpZWxkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNFbXB0eShkYXRhLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmQuY2FsZW5kYXJJZCA9IGRhdGEudmFsdWVbZGF0YS5jb21wb25lbnQuc3RvcmUua2V5UHJvcGVydHldXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiB3ZSBjb3VsZCBhZGQgYSBjb25maXJtIGRpYWxvZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25EZWxldGVCdXR0b25DbGljayhkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuZ2V0U3RhdGVQcm92aWRlcigpLmdldFN0b3JlKCdldmVudHMnKS5yZW1vdmUobWUucmVjb3JkKTtcbiAgICAgICAgbWUudW5tb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBhc3luYyBvbkZvY3VzTGVhdmUoZGF0YSkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgYSBzaG9ydCBkZWxheSwgc2luY2UgYSBUaW1lRmllbGQgcGlja2VyIGNvdWxkIGJlIG9wZW5cbiAgICAgICAgYXdhaXQgbWUudGltZW91dCgxMDApO1xuXG4gICAgICAgIG1lLm1vdW50ZWQgJiYgbWUudW5tb3VudCgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRpbWVGaWVsZENoYW5nZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbmFtZSAgID0gZGF0YS5jb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgIGZpZWxkICA9IG5hbWUgPT09ICdlbmRUaW1lJyA/ICdlbmREYXRlJyA6ICdzdGFydERhdGUnLFxuICAgICAgICAgICAgcmVjb3JkID0gbWUucmVjb3JkLFxuICAgICAgICAgICAgZGF0ZSAgID0gRGF0ZVV0aWwuY2xvbmUobWUucmVjb3JkW2ZpZWxkXSksXG4gICAgICAgICAgICB2YWx1ZSAgPSBkYXRhLnZhbHVlLnNwbGl0KCc6JykubWFwKGUgPT4gTnVtYmVyKGUpKTtcblxuICAgICAgICBkYXRlLnNldEhvdXJzKHZhbHVlWzBdKTtcbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKHZhbHVlWzFdKTtcblxuICAgICAgICByZWNvcmRbZmllbGRdID0gZGF0ZTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2VuZFRpbWUnKSB7XG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnc3RhcnRUaW1lJykudGhlbihmaWVsZCA9PiBmaWVsZC5tYXhWYWx1ZSA9IG1lLmdldFN0YXJ0VGltZU1heFZhbHVlKHJlY29yZCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZS5nZXRGaWVsZCgnZW5kVGltZScpICAudGhlbihmaWVsZCA9PiBmaWVsZC5taW5WYWx1ZSA9IG1lLmdldEVuZFRpbWVNaW5WYWx1ZShyZWNvcmQpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvblRpdGxlRmllbGRDaGFuZ2UoZGF0YSkge1xuICAgICAgICBpZiAoIU5lby5pc0VtcHR5KGRhdGEudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZC50aXRsZSA9IGRhdGEudmFsdWVcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoRWRpdEV2ZW50Q29udGFpbmVyKTtcbiIsImltcG9ydCBDYWxlbmRhcnNDb250YWluZXIgICAgICAgICBmcm9tICcuL2NhbGVuZGFycy9Db250YWluZXIubWpzJztcbmltcG9ydCBDb250YWluZXIgICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi9jb250YWluZXIvQmFzZS5tanMnO1xuaW1wb3J0IERhdGVTZWxlY3RvciAgICAgICAgICAgICAgIGZyb20gJy4uLy4uL2NvbXBvbmVudC9EYXRlU2VsZWN0b3IubWpzJztcbmltcG9ydCBEYXRlVXRpbCAgICAgICAgICAgICAgICAgICBmcm9tICcuLi8uLi91dGlsL0RhdGUubWpzJztcbmltcG9ydCBFZGl0Q2FsZW5kYXJDb250YWluZXIgICAgICBmcm9tICcuL2NhbGVuZGFycy9FZGl0Q29udGFpbmVyLm1qcyc7XG5pbXBvcnQgRWRpdEV2ZW50Q29udGFpbmVyICAgICAgICAgZnJvbSAnLi9FZGl0RXZlbnRDb250YWluZXIubWpzJztcbmltcG9ydCBNYWluQ29udGFpbmVyU3RhdGVQcm92aWRlciBmcm9tICcuL01haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyLm1qcyc7XG5pbXBvcnQgVG9vbGJhciAgICAgICAgICAgICAgICAgICAgZnJvbSAnLi4vLi4vdG9vbGJhci9CYXNlLm1qcyc7XG5cbmNvbnN0IHRvZGF5RGF0ZSA9IG5ldyBEYXRlKCk7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXJcbiAqIEBleHRlbmRzIE5lby5jb250YWluZXIuQmFzZVxuICovXG5jbGFzcyBNYWluQ29udGFpbmVyIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCBlbnRyaWVzIGZvciB0aGUgdmlld3MgY29uZmlnXG4gICAgICogQG1lbWJlciB7U3RyaW5nW119IHZhbGlkVmlld3M9WydkYXknLCd3ZWVrJywnbW9udGgnLCd5ZWFyJ11cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkVmlld3MgPSBbJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXVxuXG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NhbGVuZGFyLW1haW5jb250YWluZXInXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY2FsZW5kYXItbWFpbmNvbnRhaW5lcicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSB2aWV3LiBNdXN0IGJlIGEgdmFsdWUgaW5jbHVkZWQgaW5zaWRlIHRoZSB2aWV3cyBjb25maWcuXG4gICAgICAgICAqIHZhbGlkIHZhbHVlczogJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gYWN0aXZlVmlld189J3dlZWsnXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlVmlld186ICd3ZWVrJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLW1haW5jb250YWluZXInLCduZW8tY29udGFpbmVyJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWNhbGVuZGFyLW1haW5jb250YWluZXInLCAnbmVvLWNvbnRhaW5lciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGUgdGhlIGNhbGVuZGFyIHdpdGggdXNpbmcgcyBkaWZmZXJlbnQgYmFzZSBmb250LXNpemVcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfG51bGx9IGJhc2VGb250U2l6ZV89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGJhc2VGb250U2l6ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5Db250YWluZXJ8bnVsbH0gY2FsZW5kYXJzQ29udGFpbmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNhbGVuZGFyc0NvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjYWxlbmRhclN0b3JlQ29uZmlnXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsZW5kYXJTdG9yZUNvbmZpZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gY29sb3JTdG9yZUNvbmZpZ189bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yU3RvcmVDb25maWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNvbXBvbmVudC5EYXRlU2VsZWN0b3J8bnVsbH0gZGF0ZVNlbGVjdG9yPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGVTZWxlY3RvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkYXRlU2VsZWN0b3JDb25maWc9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0ZVNlbGVjdG9yQ29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuRGF5Q29tcG9uZW50fG51bGx9IGRheUNvbXBvbmVudD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkYXlDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZGF5Q29tcG9uZW50Q29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRheUNvbXBvbmVudENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWQgb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuRWRpdENvbnRhaW5lcnxudWxsfSBlZGl0Q2FsZW5kYXJDb250YWluZXJfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGVkaXRDYWxlbmRhckNvbnRhaW5lckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXJDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuRWRpdEV2ZW50Q29udGFpbmVyfG51bGx9IGVkaXRFdmVudENvbnRhaW5lcl89bnVsbFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGVkaXRFdmVudENvbnRhaW5lcl86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZWRpdEV2ZW50Q29udGFpbmVyQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGVkaXRFdmVudENvbnRhaW5lckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBldmVudFN0b3JlQ29uZmlnXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnRTdG9yZUNvbmZpZ186IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGxheW91dD17bnR5cGU6J3Zib3gnLGFsaWduOidzdHJldGNoJ31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGxheW91dDoge250eXBlOiAndmJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuQ29tcG9uZW50fG51bGx9IG1vbnRoQ29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1vbnRoQ29tcG9uZW50OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IG1vbnRoQ29tcG9uZW50Q29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG1vbnRoQ29tcG9uZW50Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSB0byBvbmx5IGtlZXAgdGhlIGFjdGl2ZSB2aWV3IGluc2lkZSB0aGUgRE9NXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHJlbW92ZUluYWN0aXZlQ2FyZHM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSW5hY3RpdmVDYXJkczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBzZXR0aW5nc0NvbnRhaW5lckNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBzZXR0aW5nc0NvbnRhaW5lckNvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2V0dGluZ3NDb250YWluZXJXaWR0aD0zMDBcbiAgICAgICAgICovXG4gICAgICAgIHNldHRpbmdzQ29udGFpbmVyV2lkdGg6IDMxMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNldHRpbmdzRXhwYW5kZWRfPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0dGluZ3NFeHBhbmRlZF86IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gc2lkZUJhckV4cGFuZGVkXz10cnVlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lkZUJhckV4cGFuZGVkXzogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2lkZUJhcldpZHRoPTIyMFxuICAgICAgICAgKi9cbiAgICAgICAgc2lkZUJhcldpZHRoOiAyMjAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIudmlldy5NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlcn0gc3RhdGVQcm92aWRlcj1NYWluQ29udGFpbmVyU3RhdGVQcm92aWRlclxuICAgICAgICAgKiBAcmVhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlUHJvdmlkZXI6IE1haW5Db250YWluZXJTdGF0ZVByb3ZpZGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gdXNlU2V0dGluZ3NDb250YWluZXJfPXRydWVcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VTZXR0aW5nc0NvbnRhaW5lcl86IHRydWUsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnkgY29tYmluYXRpb24gYW5kIG9yZGVyIG9mICdkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJ1xuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gdmlld3NfPVsnZGF5Jywnd2VlaycsJ21vbnRoJywneWVhciddXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmlld3NfOiBbJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LkNvbXBvbmVudHxudWxsfSB3ZWVrQ29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHdlZWtDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gd2Vla0NvbXBvbmVudENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB3ZWVrQ29tcG9uZW50Q29uZmlnOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuWWVhckNvbXBvbmVudHxudWxsfSB5ZWFyQ29tcG9uZW50PW51bGxcbiAgICAgICAgICovXG4gICAgICAgIHllYXJDb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0geWVhckNvbXBvbmVudENvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICB5ZWFyQ29tcG9uZW50Q29uZmlnOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIuY29uc3RydWN0KGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5jcmVhdGVJdGVtc0NvbnRlbnQoKTtcbiAgICAgICAgIW1lLnNpZGVCYXJFeHBhbmRlZCAmJiBtZS5hZnRlclNldFNpZGVCYXJFeHBhbmRlZChmYWxzZSwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGFjdGl2ZVZpZXcgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QWN0aXZlVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLml0ZW1zWzFdLml0ZW1zWzFdLmxheW91dC5hY3RpdmVJbmRleCA9IG1lLnZpZXdzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgICAgICAgICBtZS5pdGVtc1swXS5pdGVtc1sxXS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRvZ2dsZUdyb3VwID09PSAnbWFpblZpZXdzJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXNzZWQgPSBpdGVtLnZhbHVlID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBiYXNlRm9udFNpemUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0QmFzZUZvbnRTaXplKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5zdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZS5mb250U2l6ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5mb250U2l6ZSA9IGAke3ZhbHVlfXB4YFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2V0dGluZ3NFeHBhbmRlZCBjb25maWcgZ290IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFNldHRpbmdzRXhwYW5kZWQodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChOZW8uaXNCb29sZWFuKG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0NvbnRhaW5lciA9IG1lLml0ZW1zWzFdLml0ZW1zWzJdO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDb250YWluZXIuZXhwYW5kKClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZS5jcmVhdGVTZXR0aW5nc0NvbnRhaW5lcih0cnVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3J0IGRlbGF5IHRvIGVuc3VyZSB0aGUgdm5vZGUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRpbWVvdXQoNTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLml0ZW1zWzFdLml0ZW1zWzJdLmV4cGFuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDb250YWluZXIuY29sbGFwc2UobWUuc2V0dGluZ3NDb250YWluZXJXaWR0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgc2lkZUJhckV4cGFuZGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0U2lkZUJhckV4cGFuZGVkKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHNpZGVCYXIgPSBtZS5pdGVtc1sxXS5pdGVtc1swXSxcbiAgICAgICAgICAgICAgICBzdHlsZSAgID0gc2lkZUJhci5zdHlsZSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWUudXBkYXRlRGVwdGggPSAtMTtcblxuICAgICAgICAgICAgICAgIC8vIHRvZG86IHVwZGF0ZXMgY29sbGlkaW5nIHdpdGggcGFyZW50IHVwZGF0ZXMgbmVlZCB0byBwYXNzIHRoZSB1cGRhdGUgZGVwdGggZm9yIHRoZSBuZXh0IHBhcmVudCB1cGRhdGUgY3ljbGVcbiAgICAgICAgICAgICAgICBkZWxldGUgc2lkZUJhci52ZG9tLnJlbW92ZURvbTtcblxuICAgICAgICAgICAgICAgIG1lLnByb21pc2VVcGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZUJhci5tb3VudGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDUwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLm1hcmdpbkxlZnQgPSAnMHB4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVCYXIuc3R5bGUgPSBzdHlsZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLm1hcmdpbkxlZnQgICAgPSBgLSR7bWUuc2lkZUJhcldpZHRofXB4YDtcbiAgICAgICAgICAgICAgICBzaWRlQmFyLl9zdHlsZSAgICAgID0gc3R5bGU7IC8vIHNpbGVudCB1cGRhdGVcbiAgICAgICAgICAgICAgICBzaWRlQmFyLl92ZG9tLnN0eWxlID0gc3R5bGU7IC8vIHNpbGVudCB1cGRhdGVcblxuICAgICAgICAgICAgICAgIHNpZGVCYXIucHJvbWlzZVVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBtZS50aW1lb3V0KDQwMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlQmFyLnZkb20ucmVtb3ZlRG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVCYXIudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVCYXIubW91bnRlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdGhlbWUgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmFmdGVyU2V0VGhlbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIGlmIChtZS5fZWRpdENhbGVuZGFyQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBtZS5fZWRpdENhbGVuZGFyQ29udGFpbmVyLnRoZW1lID0gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5fZWRpdEV2ZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBtZS5fZWRpdEV2ZW50Q29udGFpbmVyLnRoZW1lID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgdXNlU2V0dGluZ3NDb250YWluZXIgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRVc2VTZXR0aW5nc0NvbnRhaW5lcih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnNldHRpbmdzRXhwYW5kZWQgJiYgbWUuY3JlYXRlU2V0dGluZ3NDb250YWluZXIoZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGEgc2hvcnQgZGVsYXkgdG8gZW5zdXJlIHRoZSBpdGVtcyBhbHJlYWR5IGdvdCBjcmVhdGVkXG4gICAgICAgICAgICBtZS50aW1lb3V0KDEwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtZS5pdGVtc1swXS5pdGVtc1sxXS5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS50b2dnbGVTZXR0aW5ncy5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLWNvZycsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5MZWZ0OiAnMTBweCd9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdGhpcyBsb2dpYyBpbiBjYXNlIHdlIGR5bmFtaWNhbGx5IGNoYW5nZSB0aGUgY29uZmlnIGZyb20gdHJ1ZSB0byBmYWxzZVxuICAgICAgICAgICAgbWUuaXRlbXNbMV0gICAgICAgICAucmVtb3ZlTGFzdCgpO1xuICAgICAgICAgICAgbWUuaXRlbXNbMF0uaXRlbXNbMV0ucmVtb3ZlTGFzdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGVkaXRDYWxlbmRhckNvbnRhaW5lciBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyfG51bGx9IHZhbHVlXG4gICAgICogQHJldHVybnMge05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5FZGl0Q29udGFpbmVyfVxuICAgICAqL1xuICAgIGJlZm9yZUdldEVkaXRDYWxlbmRhckNvbnRhaW5lcih2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICBtZS5fZWRpdENhbGVuZGFyQ29udGFpbmVyID0gdmFsdWUgPSBOZW8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgOiBFZGl0Q2FsZW5kYXJDb250YWluZXIsXG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgICAgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICBvd25lciAgICAgICAgOiBtZSxcbiAgICAgICAgICAgICAgICBzdGF0ZVByb3ZpZGVyOiB7cGFyZW50OiBtZS5nZXRTdGF0ZVByb3ZpZGVyKCl9LFxuICAgICAgICAgICAgICAgIHRoZW1lICAgICAgICA6IG1lLnRoZW1lLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgICAgICA6IDI1MCxcbiAgICAgICAgICAgICAgICB3aW5kb3dJZCAgICAgOiBtZS53aW5kb3dJZCxcbiAgICAgICAgICAgICAgICAuLi5tZS5lZGl0Q2FsZW5kYXJDb250YWluZXJDb25maWdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBiZWZvcmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGVkaXRFdmVudENvbnRhaW5lciBjb25maWdcbiAgICAgKiBAcGFyYW0ge05lby5jYWxlbmRhci52aWV3LkVkaXRFdmVudENvbnRhaW5lcnxudWxsfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtOZW8uY2FsZW5kYXIudmlldy5FZGl0RXZlbnRDb250YWluZXJ9XG4gICAgICovXG4gICAgYmVmb3JlR2V0RWRpdEV2ZW50Q29udGFpbmVyKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIG1lLl9lZGl0RXZlbnRDb250YWluZXIgPSB2YWx1ZSA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgICA6IEVkaXRFdmVudENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBhcHBOYW1lICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIG93bmVyICAgICAgICA6IG1lLFxuICAgICAgICAgICAgICAgIHN0YXRlUHJvdmlkZXI6IHtwYXJlbnQ6IG1lLmdldFN0YXRlUHJvdmlkZXIoKX0sXG4gICAgICAgICAgICAgICAgdGhlbWUgICAgICAgIDogbWUudGhlbWUsXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgIDogMjUwLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkICAgICA6IG1lLndpbmRvd0lkLFxuICAgICAgICAgICAgICAgIC4uLm1lLmVkaXRFdmVudENvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBiZWZvcmUgdGhlIGFjdGl2ZVZpZXcgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYmVmb3JlU2V0QWN0aXZlVmlldyh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU2V0RW51bVZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgJ2FjdGl2ZVZpZXcnLCAndmFsaWRWaWV3cycpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgdmlld3MgY29uZmlnIGdldHMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFZpZXdzKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBsZXQgdmFsaWRWaWV3cyA9IHRoaXMuZ2V0U3RhdGljQ29uZmlnKCd2YWxpZFZpZXdzJyk7XG5cbiAgICAgICAgdmFsdWUuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgIGlmICghdmFsaWRWaWV3cy5pbmNsdWRlcyh2aWV3KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodmlldywgJ2lzIG5vdCBhIHZhbGlkIGVudHJ5IGZvciB2aWV3cy4gU3RpY2sgdG86JywgdmFsaWRWaWV3cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2aWV3XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNoYW5nZUFjdGl2ZVZpZXcodmlldykge1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXcgPSB2aWV3XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgICAqL1xuICAgIGNyZWF0ZUhlYWRlckl0ZW1zKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbW9kdWxlOiBUb29sYmFyLFxuICAgICAgICAgICAgY2xzICAgOiBbJ25lby1jYWxlbmRhci1oZWFkZXItdG9vbGJhcicsICduZW8tbGVmdCcsICduZW8tdG9vbGJhciddLFxuICAgICAgICAgICAgd2lkdGggOiBtZS5zaWRlQmFyV2lkdGgsXG4gICAgICAgICAgICBpdGVtcyA6IFt7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogbWUudG9nZ2xlU2lkZWJhci5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtYmFycydcbiAgICAgICAgICAgIH0sICctPicsIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS5vblByZXZpb3VzSW50ZXJ2YWxCdXR0b25DbGljay5iaW5kKG1lKSxcbiAgICAgICAgICAgICAgICBpY29uQ2xzOiAnZmEgZmEtY2hldnJvbi1sZWZ0JyxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBtZS5vblRvZGF5QnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0IDogMjQsXG4gICAgICAgICAgICAgICAgdGV4dCAgIDogJ1RvZGF5J1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uTmV4dEludGVydmFsQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhIGZhLWNoZXZyb24tcmlnaHQnXG4gICAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtb2R1bGU6IFRvb2xiYXIsXG4gICAgICAgICAgICBjbHMgICA6IFsnbmVvLWNhbGVuZGFyLWhlYWRlci10b29sYmFyJywgJ25lby10b29sYmFyJ10sXG4gICAgICAgICAgICBpdGVtcyA6IFsnLT4nLCAuLi5tZS5jcmVhdGVWaWV3SGVhZGVyQnV0dG9ucygpXVxuICAgICAgICB9XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtc0NvbnRlbnQoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgbWUuY2FsZW5kYXJzQ29udGFpbmVyID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtb2R1bGUgIDogQ2FsZW5kYXJzQ29udGFpbmVyLFxuICAgICAgICAgICAgZmxleCAgICA6IDEsXG4gICAgICAgICAgICBwYXJlbnRJZDogbWUuaWQsIC8vIHdlIG5lZWQgdGhlIHBhcmVudElkIHRvIGFjY2VzcyB0aGUgbW9kZWwgaW5zaWRlIHRoZSBjdG9yXG4gICAgICAgICAgICBvd25lciAgIDogbWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuZGF0ZVNlbGVjdG9yID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICBtb2R1bGUgICA6IERhdGVTZWxlY3RvcixcbiAgICAgICAgICAgIGFwcE5hbWUgIDogbWUuYXBwTmFtZSxcbiAgICAgICAgICAgIGZsZXggICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgaGVpZ2h0ICAgOiBtZS5zaWRlQmFyV2lkdGgsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHtkYXRlQ2hhbmdlOiBtZS5vbkRhdGVTZWxlY3RvckNoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgIHBhcmVudElkIDogbWUuaWQsIC8vIHdlIG5lZWQgdGhlIHBhcmVudElkIHRvIGFjY2VzcyB0aGUgbW9kZWwgaW5zaWRlIHRoZSBjdG9yXG4gICAgICAgICAgICB2YWx1ZSAgICA6IG51bGwsXG5cbiAgICAgICAgICAgIGJpbmQ6IHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgICAgICAgICAgICAgIDogZGF0YSA9PiBkYXRhLmxvY2FsZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxOZXdZZWFyRnJvbVRvcDogZGF0YSA9PiBkYXRhLnNjcm9sbE5ld1llYXJGcm9tVG9wLFxuICAgICAgICAgICAgICAgIHNob3dXZWVrZW5kcyAgICAgICAgOiBkYXRhID0+IGRhdGEuc2hvd1dlZWtlbmRzLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgICAgICAgOiBkYXRhID0+IERhdGVVdGlsLmNvbnZlcnRUb3l5eXltbWRkKGRhdGEuY3VycmVudERhdGUpLFxuICAgICAgICAgICAgICAgIHdlZWtTdGFydERheSAgICAgICAgOiBkYXRhID0+IGRhdGEud2Vla1N0YXJ0RGF5XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAuLi5tZS5kYXRlU2VsZWN0b3JDb25maWdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUuaXRlbXMgPSBbe1xuICAgICAgICAgICAgbW9kdWxlOiBDb250YWluZXIsXG4gICAgICAgICAgICBmbGV4ICA6ICdub25lJyxcbiAgICAgICAgICAgIGxheW91dDoge250eXBlOiAnaGJveCcsIGFsaWduOiAnc3RyZXRjaCd9LFxuICAgICAgICAgICAgaXRlbXMgOiBtZS5jcmVhdGVIZWFkZXJJdGVtcygpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1vZHVsZTogQ29udGFpbmVyLFxuICAgICAgICAgICAgZmxleCAgOiAxLFxuICAgICAgICAgICAgbGF5b3V0OiB7bnR5cGU6ICdoYm94JywgYWxpZ246ICdzdHJldGNoJ30sXG4gICAgICAgICAgICBpdGVtcyA6IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlICA6IENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBjbHMgICAgIDogWyduZW8tY2FsZW5kYXItc2lkZWJhcicsICduZW8tY29udGFpbmVyJ10sXG4gICAgICAgICAgICAgICAgbGF5b3V0ICA6IHtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogbWUuc2lkZUJhcldpZHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoICAgOiBtZS5zaWRlQmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgaXRlbXMgICA6IFttZS5kYXRlU2VsZWN0b3IsIG1lLmNhbGVuZGFyc0NvbnRhaW5lcl1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICA6IENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBmbGV4ICAgICA6IDEsXG4gICAgICAgICAgICAgICAgaXRlbXMgICAgOiBtZS5jcmVhdGVWaWV3cygpLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge2NhcmRMb2FkZWQ6IG1lLm9uQ2FyZExvYWRlZCwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBsYXlvdXQgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgbnR5cGUgICAgICAgICAgICAgIDogJ2NhcmQnLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVJbmRleCAgICAgICAgOiBtZS52aWV3cy5pbmRleE9mKG1lLmFjdGl2ZVZpZXcpLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiBtZS5yZW1vdmVJbmFjdGl2ZUNhcmRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbGxhcHNlZFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPCo+fVxuICAgICAqL1xuICAgIGNyZWF0ZVNldHRpbmdzQ29udGFpbmVyKGNvbGxhcHNlZCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBpbXBvcnQoJy4vU2V0dGluZ3NDb250YWluZXIubWpzJykudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgbWUuaXRlbXNbMV0uYWRkKHtcbiAgICAgICAgICAgICAgICBtb2R1bGUgICAgICAgICAgICAgOiBtb2R1bGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWQsXG4gICAgICAgICAgICAgICAgbWluV2lkdGggICAgICAgICAgIDogbWUuc2V0dGluZ3NDb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgICAgICByZW1vdmVJbmFjdGl2ZUNhcmRzOiBtZS5yZW1vdmVJbmFjdGl2ZUNhcmRzLFxuICAgICAgICAgICAgICAgIHN0eWxlICAgICAgICAgICAgICA6IHttYXJnaW5SaWdodDogIWNvbGxhcHNlZCA/ICcwJyA6IGAtJHttZS5zZXR0aW5nc0NvbnRhaW5lcldpZHRofXB4YH0sXG4gICAgICAgICAgICAgICAgd2lkdGggICAgICAgICAgICAgIDogbWUuc2V0dGluZ3NDb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAuLi5tZS5zZXR0aW5nc0NvbnRhaW5lckNvbmZpZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAgICovXG4gICAgY3JlYXRlVmlld0hlYWRlckJ1dHRvbnMoKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBhY3RpdmVJbmRleCA9IG1lLnZpZXdzLmluZGV4T2YobWUuYWN0aXZlVmlldyksXG4gICAgICAgICAgICBidXR0b25zICAgICA9IFtdO1xuXG4gICAgICAgIG1lLnZpZXdzLmZvckVhY2goKHZpZXcsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBidXR0b25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgICAgOiBtZS5jaGFuZ2VBY3RpdmVWaWV3LmJpbmQobWUsIHZpZXcpLFxuICAgICAgICAgICAgICAgIGhlaWdodCAgICAgOiAyNCxcbiAgICAgICAgICAgICAgICBwcmVzc2VkICAgIDogYWN0aXZlSW5kZXggPT09IGluZGV4LFxuICAgICAgICAgICAgICAgIHRleHQgICAgICAgOiBOZW8uY2FwaXRhbGl6ZSh2aWV3KSxcbiAgICAgICAgICAgICAgICB0b2dnbGVHcm91cDogJ21haW5WaWV3cycsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICA6IHZpZXdcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBidXR0b25zXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZVtdfVxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXdzKCkge1xuICAgICAgICBsZXQgbWUgICAgPSB0aGlzLFxuICAgICAgICAgICAgY2FyZHMgPSBbXSxcbiAgICAgICAgICAgIGNtcCxcblxuICAgICAgICBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgYXBwTmFtZSA6IG1lLmFwcE5hbWUsXG4gICAgICAgICAgICBvd25lciAgIDogbWUsXG4gICAgICAgICAgICBwYXJlbnRJZDogbWUuaWRcbiAgICAgICAgfSxcblxuICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICBkYXk6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6ICgpID0+IGltcG9ydCgnLi9EYXlDb21wb25lbnQubWpzJyksXG4gICAgICAgICAgICAgICAgZmxhZyAgOiAnZGF5JyxcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAgICAgICAgIC4uLm1lLmRheUNvbXBvbmVudENvbmZpZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vbnRoOiB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiAoKSA9PiBpbXBvcnQoJy4vbW9udGgvQ29tcG9uZW50Lm1qcycpLFxuICAgICAgICAgICAgICAgIGZsYWcgIDogJ21vbnRoJyxcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgICAgICAgICAgIC4uLm1lLm1vbnRoQ29tcG9uZW50Q29uZmlnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2Vlazoge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogKCkgPT4gaW1wb3J0KCcuL3dlZWsvQ29tcG9uZW50Lm1qcycpLFxuICAgICAgICAgICAgICAgIGZsYWcgIDogJ3dlZWsnLFxuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgICAgICAgICAgICAgLi4ubWUud2Vla0NvbXBvbmVudENvbmZpZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHllYXI6IHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6ICgpID0+IGltcG9ydCgnLi9ZZWFyQ29tcG9uZW50Lm1qcycpLFxuICAgICAgICAgICAgICAgIGZsYWcgIDogJ3llYXInLFxuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgICAgICAgICAgICAgLi4ubWUueWVhckNvbXBvbmVudENvbmZpZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG1lLnZpZXdzLmZvckVhY2godmlldyA9PiB7XG4gICAgICAgICAgICBtZVtgJHt2aWV3fUNvbXBvbmVudGBdID0gY21wID0gbWFwW3ZpZXddO1xuICAgICAgICAgICAgY2FyZHMucHVzaChjbXApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2FyZHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2FyZExvYWRlZChkYXRhKSB7XG4gICAgICAgIHRoaXNbYCR7ZGF0YS5pdGVtLmZsYWd9Q29tcG9uZW50YF0gPSBkYXRhLml0ZW07XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgZXZlbnQgb24gdGhpcyBpbnN0YW5jZSBhcyB3ZWxsID0+IHNldHRpbmcgdmlld3MgY2FuIHN1YnNjcmliZSB0byBpdCBtb3JlIGVhc2lseVxuICAgICAgICB0aGlzLmZpcmUoJ2NhcmRMb2FkZWQnLCB7aXRlbTogZGF0YS5pdGVtfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudmFsdWVcbiAgICAgKi9cbiAgICBvbkRhdGVTZWxlY3RvckNoYW5nZSh7dmFsdWV9KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoJ2N1cnJlbnREYXRlJywgdmFsdWUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBvbk5leHRJbnRlcnZhbEJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hJbnRlcnZhbCgxKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25QcmV2aW91c0ludGVydmFsQnV0dG9uQ2xpY2soZGF0YSkge1xuICAgICAgICB0aGlzLnN3aXRjaEludGVydmFsKC0xKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgb25Ub2RheUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZVByb3ZpZGVyLnNldERhdGEoe1xuICAgICAgICAgICAgY3VycmVudERhdGU6IHRvZGF5RGF0ZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0b2dnbGVTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0V4cGFuZGVkID0gIXRoaXMuc2V0dGluZ3NFeHBhbmRlZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0b2dnbGVTaWRlYmFyKCkge1xuICAgICAgICB0aGlzLnNpZGVCYXJFeHBhbmRlZCA9ICF0aGlzLnNpZGVCYXJFeHBhbmRlZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAgICovXG4gICAgc3dpdGNoSW50ZXJ2YWwobXVsdGlwbGllcikge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7Y3VycmVudERhdGV9ID0gbWUuZGF0YSxcblxuICAgICAgICBtYXAgPSB7XG4gICAgICAgICAgICBkYXkgIDogKCkgPT4ge2N1cnJlbnREYXRlLnNldERhdGUoICAgIGN1cnJlbnREYXRlLmdldERhdGUoKSAgICAgKyBtdWx0aXBsaWVyKX0sXG4gICAgICAgICAgICBtb250aDogKCkgPT4ge2N1cnJlbnREYXRlLnNldE1vbnRoKCAgIGN1cnJlbnREYXRlLmdldE1vbnRoKCkgICAgKyBtdWx0aXBsaWVyKX0sXG4gICAgICAgICAgICB3ZWVrIDogKCkgPT4ge2N1cnJlbnREYXRlLnNldERhdGUoICAgIGN1cnJlbnREYXRlLmdldERhdGUoKSArIDcgKiBtdWx0aXBsaWVyKX0sXG4gICAgICAgICAgICB5ZWFyIDogKCkgPT4ge2N1cnJlbnREYXRlLnNldEZ1bGxZZWFyKGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCkgKyBtdWx0aXBsaWVyKX1cbiAgICAgICAgfTtcblxuICAgICAgICBtYXBbbWUuYWN0aXZlVmlld10oKTtcblxuICAgICAgICBtZS5zdGF0ZVByb3ZpZGVyLnNldERhdGEoe2N1cnJlbnREYXRlfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKE1haW5Db250YWluZXIpO1xuIiwiaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vLi4vbGlzdC9CYXNlLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db2xvcnNMaXN0XG4gKiBAZXh0ZW5kcyBOZW8ubGlzdC5CYXNlXG4gKi9cbmNsYXNzIENvbG9yc0xpc3QgZXh0ZW5kcyBMaXN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db2xvcnNMaXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29sb3JzTGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jYWxlbmRhcnMtY29sb3JzLWxpc3QnLCduZW8tbGlzdCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhcnMtY29sb3JzLWxpc3QnLCAnbmVvLWxpc3QnXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgc3RvcmU6ICdzdG9yZXMuY29sb3JzJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpbiBjYXNlIGEga2V5Ym9hcmQgbmF2aWdhdGlvbiBzaG91bGQgaW1tZWRpYXRlbHkgc2VsZWN0IHRoZSBmb2N1c3NlZCBpdGVtXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHNlbGVjdE9uRm9jdXM9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0T25Gb2N1czogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IHVzZVdyYXBwZXJOb2RlPWZhbHNlXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlV3JhcHBlck5vZGU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3QgZ2V0cyB1c2VkIGFzIGEgZm9ybSBmaWVsZCwgc28gd2UgYXJlIGFkanVzdGluZyB0aGUgc2VsZWN0aW9uIGJhc2VkIG9uIHRoaXMgY29uZmlnXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gdmFsdWVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZV86IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRlZCBhIHRhYkluZGV4IHRvIGVuYWJsZSB0YWJiaW5nIHRocm91Z2ggdGhlIGZvcm1cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBfdmRvbT17dGFnOid1bCcsY246W10sdGFiSW5kZXg6JzAnfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Zkb206XG4gICAgICAgIHt0YWc6ICd1bCcsIGNuOiBbXSwgdGFiSW5kZXg6ICcwJ31cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZDtcblxuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhbWUuZGlzYWJsZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmVjb3JkID0gbWUuc3RvcmUuZmluZCgnbmFtZScsIHZhbHVlKVswXTtcbiAgICAgICAgICAgIG1lLnNlbGVjdGlvbk1vZGVsPy5zZWxlY3QobWUuZ2V0SXRlbUlkKHJlY29yZFttZS5nZXRLZXlQcm9wZXJ0eSgpXSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIHJlbmRlcmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fE9iamVjdFtdfFN0cmluZ30gRWl0aGVyIGEgY29uZmlnIG9iamVjdCB0byBhc3NpZ24gdG8gdGhlIGl0ZW0sIGEgdmRvbSBjbiBhcnJheSBvciBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtQ29udGVudChyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB7c3R5bGU6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYHZhcigtLWV2ZW50LSR7cmVjb3JkLm5hbWV9LWNvbG9yKWAsXG4gICAgICAgICAgICBjb2xvciAgICAgICAgICA6IGB2YXIoLS1ldmVudC0ke3JlY29yZC5uYW1lfS1jb2xvcilgIC8vIG5lZWRlZCBmb3IgdGhlIGJveC1zaGFkb3cgKENTUyBjdXJyZW50Q29sb3IpXG4gICAgICAgIH19XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRWZG9tUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmRvbVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Vm5vZGVSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52bm9kZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgb25Db25zdHJ1Y3RlZCgpIHtcbiAgICAgICAgc3VwZXIub25Db25zdHJ1Y3RlZCgpO1xuXG4gICAgICAgIGxldCBtZSAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHt2YWx1ZX0gPSBtZTtcblxuICAgICAgICB2YWx1ZSAmJiBtZS5hZnRlclNldFZhbHVlKHZhbHVlLCBudWxsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIGZyb20gc2VsZWN0aW9uLk1vZGVsOiBzZWxlY3QoKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGl0ZW1zXG4gICAgICovXG4gICAgb25TZWxlY3QoaXRlbXMpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHJlY29yZElkID0gbWUuZ2V0SXRlbVJlY29yZElkKGl0ZW1zWzBdKTtcblxuICAgICAgICBtZS5maXJlKCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICByZWNvcmQ6IG1lLnN0b3JlLmdldChyZWNvcmRJZClcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKENvbG9yc0xpc3QpO1xuIiwiaW1wb3J0IEJhc2VDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMaXN0ICAgICAgICAgIGZyb20gJy4vTGlzdC5tanMnO1xuXG4vKipcbiAqIEBjbGFzcyBOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyXG4gKiBAZXh0ZW5kcyBOZW8uY29udGFpbmVyLkJhc2VcbiAqL1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuQ29udGFpbmVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWNhbGVuZGFyLWNhbGVuZGFyc2NvbnRhaW5lcicsJ25lby1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItY2FsZW5kYXJzY29udGFpbmVyJywgJ25lby1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gYmluZFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDoge1xuICAgICAgICAgICAgY2FsZW5kYXJTdG9yZTogJ3N0b3Jlcy5jYWxlbmRhcnMnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIuc3RvcmUuQ2FsZW5kYXJzfG51bGx9IGNhbGVuZGFyU3RvcmVfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBjYWxlbmRhclN0b3JlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119IGl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgIG1vZHVsZTogTGlzdCxcbiAgICAgICAgICAgIG93bmVyIDogJ0Bjb25maWc6b3duZXInIC8vIHBhc3NpbmcgdGhlIG93bmVyIGNvbmZpZyBkb3dud2FyZHNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbnR5cGUgICAgICAgOiAnYnV0dG9uJyxcbiAgICAgICAgICAgIGNscyAgICAgICAgIDogWyduZW8tYWRkLWNhbGVuZGFyLWJ1dHRvbiddLFxuICAgICAgICAgICAgZmxleCAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBoYW5kbGVyICAgICA6ICdvbkFkZENhbGVuZGFyQnV0dG9uQ2xpY2snLFxuICAgICAgICAgICAgaGFuZGxlclNjb3BlOiAndGhpcycsXG4gICAgICAgICAgICBzdHlsZSAgICAgICA6IHttYXJnaW5Ub3A6ICdhdXRvJ30sXG4gICAgICAgICAgICB0ZXh0ICAgICAgICA6ICdBZGQgQ2FsZW5kYXInXG4gICAgICAgIH1dLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOid2Ym94JyxhbGlnbjonc3RyZXRjaCd9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBsYXlvdXQ6IHtudHlwZTogJ3Zib3gnLCBhbGlnbjogJ3N0cmV0Y2gnfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXJ8bnVsbH0gb3duZXI9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvd25lcjogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25BZGRDYWxlbmRhckJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhclN0b3JlLmFkZCh7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBjb2xvciA6ICdyZWQnLFxuICAgICAgICAgICAgbmFtZSAgOiAnTmV3IENhbGVuZGFyJ1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29udGFpbmVyKTtcbiIsImltcG9ydCBCdXR0b24gICAgICAgIGZyb20gJy4uLy4uLy4uL2J1dHRvbi9CYXNlLm1qcyc7XG5pbXBvcnQgQ29sb3JzTGlzdCAgICBmcm9tICcuL0NvbG9yc0xpc3QubWpzJztcbmltcG9ydCBGb3JtQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uL2Zvcm0vQ29udGFpbmVyLm1qcyc7XG5pbXBvcnQgVGV4dEZpZWxkICAgICBmcm9tICcuLi8uLi8uLi9mb3JtL2ZpZWxkL1RleHQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXJcbiAqIEBleHRlbmRzIE5lby5mb3JtLkNvbnRhaW5lclxuICovXG5jbGFzcyBFZGl0Q29udGFpbmVyIGV4dGVuZHMgRm9ybUNvbnRhaW5lciB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuRWRpdENvbnRhaW5lcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkVkaXRDb250YWluZXInLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2FsZW5kYXItZWRpdC1jb250YWluZXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tY2FsZW5kYXItZWRpdC1jb250YWluZXInXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3LmNhbGVuZGFycy5Db2xvcnNMaXN0fG51bGx9IGNvbG9yc0xpc3Q9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JzTGlzdDogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBjb2xvcnNMaXN0Q29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yc0xpc3RDb25maWc6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gbmFtZUZpZWxkQ29uZmlnPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG5hbWVGaWVsZENvbmZpZzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jYWxlbmRhci52aWV3Lk1haW5Db250YWluZXJ8bnVsbH0gb3duZXI9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ8bnVsbH0gcmVjb3JkXz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjb3JkXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcnxudWxsfSB1bk1vdW50VGltZW91dElkPW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdW5Nb3VudFRpbWVvdXRJZDogbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3QoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyLmNvbnN0cnVjdChjb25maWcpO1xuXG4gICAgICAgIC8vIGZvY3VzIHRyYXAsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25lb21qcy9uZW8vaXNzdWVzLzIzMDZcbiAgICAgICAgdGhpcy52ZG9tLnRhYkluZGV4ID0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtb3VudGVkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0TW91bnRlZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRNb3VudGVkKHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgJiYgdGhpcy5nZXRGaWVsZCgnbmFtZScpLnRoZW4oZmllbGQgPT4ge1xuICAgICAgICAgICAgZmllbGQuZm9jdXMoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgcmVjb3JkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLm1vZGVsLkNhbGVuZGFyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNhbGVuZGFyLm1vZGVsLkNhbGVuZGFyfSBvbGRWYWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhZnRlclNldFJlY29yZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgJiYgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG1lLnJlc2V0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUuY29sb3JzTGlzdC52YWx1ZSA9IHZhbHVlLmNvbG9yO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBtZS5jcmVhdGVJdGVtcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcmVjb3JkIGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBXZSBuZWVkIHRoZSBiZWZvcmUgbWV0aG9kIHRvIGFsc28gZ2V0IGNsaWNrcyBvbiB0aGUgc2FtZSBlZGl0IGljb24sXG4gICAgICogc2luY2UgaXQgZG9lcyB0cmlnZ2VyIGZvciBub3QgY2hhbmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOZW8uY2FsZW5kYXIubW9kZWwuQ2FsZW5kYXJ9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFJlY29yZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBpZiAobWUudW5Nb3VudFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1lLnVuTW91bnRUaW1lb3V0SWQpO1xuICAgICAgICAgICAgbWUudW5Nb3VudFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjcmVhdGVJdGVtcygpIHtcbiAgICAgICAgbGV0IG1lICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIHtyZWNvcmR9ID0gbWU7XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgbWUuY29sb3JzTGlzdCA9IE5lby5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG1vZHVsZSAgICAgIDogQ29sb3JzTGlzdCxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgICA6IHtjaGFuZ2U6IG1lLm9uQ29sb3JDaGFuZ2UsIHNjb3BlOiBtZX0sXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgICAgOiBtZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA6IHJlY29yZC5jb2xvcixcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGU6IHttYXJnaW5Ub3A6ICcwLjJlbSd9LFxuICAgICAgICAgICAgICAgIC4uLm1lLmNvbG9yc0xpc3RDb25maWdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtZS5pdGVtcyA9IFt7XG4gICAgICAgICAgICAgICAgbW9kdWxlICAgICAgICAgICAgICA6IFRleHRGaWVsZCxcbiAgICAgICAgICAgICAgICBjbGVhclRvT3JpZ2luYWxWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmbGV4ICAgICAgICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24gICAgICAgOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQgICAgICAgICAgIDogJ0NhbGVuZGFyIE5hbWUnLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyAgICAgICAgICAgOiB7Y2hhbmdlOiBtZS5vbk5hbWVGaWVsZENoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBuYW1lICAgICAgICAgICAgICAgIDogJ25hbWUnLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgICAgICAgICAgICAgOiByZWNvcmQubmFtZSxcbiAgICAgICAgICAgICAgICAuLi5tZS5uYW1lRmllbGRDb25maWdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZS5jb2xvcnNMaXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlIDogQnV0dG9uLFxuICAgICAgICAgICAgICAgIGNscyAgICA6IFsnbmVvLXJlZCddLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IG1lLm9uRGVsZXRlQnV0dG9uQ2xpY2suYmluZChtZSksXG4gICAgICAgICAgICAgICAgaWNvbkNsczogJ2ZhcyBmYS10cmFzaC1hbHQnLFxuICAgICAgICAgICAgICAgIHN0eWxlICA6IHttYXJnaW5Ub3A6ICczZW0nfSxcbiAgICAgICAgICAgICAgICB0ZXh0ICAgOiAnRGVsZXRlJ1xuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIHN1cGVyLmNyZWF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhLnJlY29yZFxuICAgICAqL1xuICAgIG9uQ29sb3JDaGFuZ2UoZGF0YSkge1xuICAgICAgICB0aGlzLnJlY29yZC5jb2xvciA9IGRhdGEucmVjb3JkLm5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBvbkRlbGV0ZUJ1dHRvbkNsaWNrKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB0b2RvOiB3ZSBjb3VsZCBhZGQgYSBjb25maXJtIGRpYWxvZ1xuXG4gICAgICAgIG1lLmdldFN0YXRlUHJvdmlkZXIoKS5nZXRTdG9yZSgnY2FsZW5kYXJzJykucmVtb3ZlKG1lLnJlY29yZCk7XG4gICAgICAgIG1lLnVubW91bnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG4gICAgICovXG4gICAgb25Gb2N1c0xlYXZlKGRhdGEpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICAvLyB3ZSBuZWVkIGEgc2hvcnQgZGVsYXkgdG8gZ2V0IHJlY29yZC1jaGFuZ2VzIChjbGlja2luZyBvbiBhbm90aGVyIGVkaXQgaWNvbilcbiAgICAgICAgbWUudW5Nb3VudFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbWUudW5Nb3VudFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICBtZS5tb3VudGVkICYmIG1lLnVubW91bnQoKTtcbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uTmFtZUZpZWxkQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgaWYgKCFOZW8uaXNFbXB0eShkYXRhLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmQubmFtZSA9IGRhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKEVkaXRDb250YWluZXIpO1xuIiwiaW1wb3J0IENoZWNrQm94RmllbGQgZnJvbSAnLi4vLi4vLi4vZm9ybS9maWVsZC9DaGVja0JveC5tanMnO1xuaW1wb3J0IENvbXBvbmVudExpc3QgZnJvbSAnLi4vLi4vLi4vbGlzdC9Db21wb25lbnQubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkxpc3RcbiAqIEBleHRlbmRzIE5lby5saXN0LkNvbXBvbmVudFxuICovXG5jbGFzcyBMaXN0IGV4dGVuZHMgQ29tcG9uZW50TGlzdCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY2FsZW5kYXIudmlldy5jYWxlbmRhcnMuTGlzdCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNhbGVuZGFyLnZpZXcuY2FsZW5kYXJzLkxpc3QnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nW119IGJhc2VDbHM9WyduZW8tY2FsZW5kYXJzLWxpc3QnLCduZW8tbGlzdCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jYWxlbmRhcnMtbGlzdCcsICduZW8tbGlzdCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBiaW5kXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiB7XG4gICAgICAgICAgICBzdG9yZTogJ3N0b3Jlcy5jYWxlbmRhcnMnXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9IGl0ZW1EZWZhdWx0c1xuICAgICAgICAgKi9cbiAgICAgICAgaXRlbURlZmF1bHRzOiB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogQ2hlY2tCb3hGaWVsZCxcbiAgICAgICAgICAgIGZsZXggICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICBoaWRlTGFiZWwgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGljb25DbHMgICAgICAgOiBbJ2ZhcycsICdmYS1zcXVhcmUnXSxcbiAgICAgICAgICAgIGljb25DbHNDaGVja2VkOiBbJ2ZhcycsICdmYS1jaGVjay1zcXVhcmUnXVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TmVvLmNhbGVuZGFyLnZpZXcuTWFpbkNvbnRhaW5lcnxudWxsfSBvd25lcj1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgZm9yIGN1c3RvbSByZW5kZXJlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge09iamVjdHxPYmplY3RbXXxTdHJpbmd9IEVpdGhlciBhIGNvbmZpZyBvYmplY3QgdG8gYXNzaWduIHRvIHRoZSBpdGVtLCBhIHZkb20gY24gYXJyYXkgb3IgYSBzdHJpbmcuXG4gICAgICovXG4gICAgY3JlYXRlSXRlbUNvbnRlbnQocmVjb3JkLCBpbmRleCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgaWQgICAgICAgPSByZWNvcmRbbWUuZ2V0S2V5UHJvcGVydHkoKV0sXG4gICAgICAgICAgICBpdGVtcyAgICA9IG1lLml0ZW1zIHx8IFtdLFxuICAgICAgICAgICAgY2hlY2tCb3ggPSBpdGVtc1tpbmRleF0sXG5cbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgY2hlY2tlZCAgIDogcmVjb3JkLmFjdGl2ZSxcbiAgICAgICAgICAgIGNscyAgICAgICA6IFtgbmVvLWNvbG9yLSR7cmVjb3JkLmNvbG9yfWBdLFxuICAgICAgICAgICAgZmllbGRWYWx1ZTogaWQsXG4gICAgICAgICAgICBpZCAgICAgICAgOiBtZS5nZXRDb21wb25lbnRJZChpbmRleCksXG4gICAgICAgICAgICB2YWx1ZUxhYmVsOiByZWNvcmQubmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjaGVja0JveCkge1xuICAgICAgICAgICAgY2hlY2tCb3guc2V0U2lsZW50KGNvbmZpZylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1zW2luZGV4XSA9IGNoZWNrQm94ID0gTmVvLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYXBwTmFtZSAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge2NoYW5nZTogbWUub25DaGVja2JveENoYW5nZSwgc2NvcGU6IG1lfSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCA6IG1lLmlkLFxuICAgICAgICAgICAgICAgIHdpbmRvd0lkIDogbWUud2luZG93SWQsXG4gICAgICAgICAgICAgICAgLi4ubWUuaXRlbURlZmF1bHRzLFxuICAgICAgICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLml0ZW1zICAgICAgID0gaXRlbXM7XG4gICAgICAgIG1lLnVwZGF0ZURlcHRoID0gMjtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY2hlY2tCb3guY3JlYXRlVmRvbVJlZmVyZW5jZSgpLFxuICAgICAgICAgICAge3RhZzogJ2knLCBjbHM6IFsnbmVvLWVkaXQtaWNvbicsICdmYXMnLCAnZmEtZWRpdCddLCBpZDogbWUuZ2V0RWRpdEljb25JZChpbmRleCl9XG4gICAgICAgIF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEVkaXRJY29uSWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWR9X18ke2luZGV4fV9fZWRpdC1pY29uYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25DaGVja2JveENoYW5nZShkYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuZ2V0KGRhdGEuY29tcG9uZW50LmZpZWxkVmFsdWUpLmFjdGl2ZSA9IGRhdGEudmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uQ2xpY2soZGF0YSkge1xuICAgICAgICAvLyBUaGUgY2xpY2sgZXZlbiBhcnJpdmVzIGJlZm9yZSB0aGUgQ2hlY2tCb3ggb25JbnB1dFZhbHVlQ2hhbmdlKCkgZ2V0cyB0cmlnZ2VyZWQuXG4gICAgICAgIC8vIFdlIG5lZWQgYSBzaG9ydCBkZWxheSB0byBlbnN1cmUgdGhlIHZkb20gb2YgdGhlIGxpc3QgaXRlbSBjb250YWlucyB0aGUgbmV3IGNoZWNrZWQgc3RhdGVcbiAgICAgICAgdGhpcy50aW1lb3V0KDIwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHN1cGVyLm9uQ2xpY2soZGF0YSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRhdGEucGF0aFswXS5jbHMuaW5jbHVkZXMoJ25lby1lZGl0LWljb24nKSkge1xuICAgICAgICAgICAgbGV0IG1lICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbGlzdEl0ZW1SZWN0ICAgICAgICAgID0gZGF0YS5wYXRoWzFdLnJlY3QsXG4gICAgICAgICAgICAgICAgbWFpbkNvbnRhaW5lciAgICAgICAgID0gbWUub3duZXIsXG4gICAgICAgICAgICAgICAgZWRpdENhbGVuZGFyQ29udGFpbmVyID0gbWFpbkNvbnRhaW5lci5lZGl0Q2FsZW5kYXJDb250YWluZXIsXG4gICAgICAgICAgICAgICAge21vdW50ZWQsIHN0eWxlfSAgICAgID0gZWRpdENhbGVuZGFyQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHJlY29yZCAgICAgICAgICAgICAgICA9IG1lLnN0b3JlLmdldChtZS5nZXRJdGVtUmVjb3JkSWQoZGF0YS5wYXRoWzFdLmlkKSk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHtsaXN0SXRlbVJlY3QucmlnaHQgKyAxM31weGAsXG4gICAgICAgICAgICAgICAgdG9wIDogYCR7bGlzdEl0ZW1SZWN0LnRvcCAgIC0gMTB9cHhgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZWRpdENhbGVuZGFyQ29udGFpbmVyW21vdW50ZWQgPyAnc2V0JyA6ICdzZXRTaWxlbnQnXSh7XG4gICAgICAgICAgICAgICAgcGFyZW50SWQ6IG1haW5Db250YWluZXIuaWQsXG4gICAgICAgICAgICAgICAgcmVjb3JkLFxuICAgICAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgZWRpdENhbGVuZGFyQ29udGFpbmVyLmluaXRWbm9kZSh0cnVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0Q2FsZW5kYXJDb250YWluZXIuYWZ0ZXJTZXRNb3VudGVkKHRydWUsIGZhbHNlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1JZFxuICAgICAqL1xuICAgIG9uS2V5RG93bkVudGVyKGl0ZW1JZCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgcmVjb3JkSWQgPSBtZS5nZXRJdGVtUmVjb3JkSWQoaXRlbUlkKSxcbiAgICAgICAgICAgIGNoZWNrQm94ID0gbWUuaXRlbXNbbWUuc3RvcmUuaW5kZXhPZihyZWNvcmRJZCldO1xuXG4gICAgICAgIGNoZWNrQm94LmNoZWNrZWQgPSAhY2hlY2tCb3guY2hlY2tlZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGl0ZW1zXG4gICAgICovXG4gICAgb25TZWxlY3QoaXRlbXMpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgnYWN0aXZlQ2FsZW5kYXJJZCcsIHRoaXMuZ2V0SXRlbVJlY29yZElkKGl0ZW1zWzBdKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxpbmcgdGhlIHN1cGVyIGNsYXNzIGxvZ2ljIGZvciBub3csIHNpbmNlIHRoZSBjb2xsZWN0aW9uLkJhc2UgbXV0YXRpb24gZXZlbnQgYWxyZWFkeSBjb3ZlcnMgdGhlIHNvcnRpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIHNvcnRJdGVtcyhkYXRhKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExpc3QpO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0Jhc2UubWpzJztcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjbGFzcyB0byByZW5kZXIgYSBsYWJlbCB3aXRoIGEgdGV4dFxuICogQGNsYXNzIE5lby5jb21wb25lbnQuTGFiZWxcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBMYWJlbCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY2xhc3NOYW1lPSdOZW8uY29tcG9uZW50LkxhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjbGFzc05hbWU6ICdOZW8uY29tcG9uZW50LkxhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2xhYmVsJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2xhYmVsJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLWxhYmVsJ11cbiAgICAgICAgICovXG4gICAgICAgIGJhc2VDbHM6IFsnbmVvLWxhYmVsJ10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IHRhZz0nbGFiZWwnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0YWc6ICdsYWJlbCdcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKExhYmVsKTtcbiIsImltcG9ydCBCYXNlICAgICAgICAgICAgICBmcm9tICcuL0Jhc2UubWpzJztcbmltcG9ydCB7cmVzb2x2ZUNhbGxiYWNrfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5jb250cm9sbGVyLkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmNvbnRyb2xsZXIuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5jb250cm9sbGVyLkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1jb250cm9sbGVyJ1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1jb250cm9sbGVyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBjb21wb25lbnQ9bnVsbFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8bnVsbH0gcGFyZW50Xz1udWxsXG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50XzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gcmVmZXJlbmNlcz1udWxsXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHJlZmVyZW5jZXM6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gd2luZG93SWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93SWQ6IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2NvbXBvbmVudH0gPSBtZTtcblxuICAgICAgICBtZS5yZWZlcmVuY2VzID0ge307XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBtZS5vbkNvbXBvbmVudENvbnN0cnVjdGVkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5vbignY29uc3RydWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWUub25Db21wb25lbnRDb25zdHJ1Y3RlZCgpXG4gICAgICAgICAgICB9LCBtZSwge29uY2U6IHRydWV9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJlZm9yZSB0aGUgcGFyZW50IGNvbmZpZyBnZXRzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge05lby5jb250cm9sbGVyLkNvbXBvbmVudHxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZVNldFBhcmVudCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHRoaXMuZ2V0UGFyZW50KClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlck5hbWVcbiAgICAgKiBAcGFyYW0ge05lby5jb21wb25lbnQuQmFzZXxudWxsfSBbY29tcG9uZW50XVxuICAgICAqIEByZXR1cm5zIHtOZW8uY29udHJvbGxlci5Db21wb25lbnR8Qm9vbGVhbnxudWxsfVxuICAgICAqL1xuICAgIGdldEhhbmRsZXJTY29wZShoYW5kbGVyTmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGxldCBtZSAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cGFyZW50fSA9IG1lLFxuICAgICAgICAgICAgaGFuZGxlckNiO1xuXG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIHRocyBmdW5jdGlvbiAqbmFtZSogZmlyc3QgaW4gdGhlIENvbXBvbmVudCBpdHNlbGYuXG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGl0LCByZXR1cm4gdHJ1ZSBzbyBjYWxsaW5nIGNvZGUga25vd3Mgbm90IHRvIGNvbnRpbnVlIHRvIHNlYXJjaC5cbiAgICAgICAgICAgIGhhbmRsZXJDYiA9IHJlc29sdmVDYWxsYmFjayhoYW5kbGVyTmFtZSwgY29tcG9uZW50KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBmbiBpcyByZXNvbHZlZCBpbiB0aGUgQ29tcG9uZW50IG9yIGl0cyBvd24gcGFyZW50IGNoYWluLlxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3RhdHVzIGluZGljYXRpbmcgdGhhdCB3ZSBkbyBub3QgbmVlZCBhbiBlYXJseSBiaW5kaW5nXG4gICAgICAgICAgICBpZiAoaGFuZGxlckNiLmZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBOZW8uaXNGdW5jdGlvbihtZVtoYW5kbGVyTmFtZV0pID9cbiAgICAgICAgICAgIG1lIDogcGFyZW50Py5nZXRIYW5kbGVyU2NvcGUoaGFuZGxlck5hbWUpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsb3Nlc3QgY29udHJvbGxlciBpbnNpZGUgdGhlIGNvbXBvbmVudHMgcGFyZW50IHRyZWVcbiAgICAgKiBAcmV0dXJucyB7TmVvLmNvbnRyb2xsZXIuQ29tcG9uZW50fG51bGx9XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge3BhcmVudH0gPSBtZTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWUuY29tcG9uZW50LnBhcmVudD8uZ2V0Q29udHJvbGxlcigpIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiB1cGRhdGUgY2hhbmdlZCByZWZlcmVuY2VzIChlLmcuIGNvbnRhaW5lci5yZW1vdmUoKSB0aGVuIGNvbnRhaW5lci5hZGQoKSB1c2luZyB0aGUgc2FtZSBrZXkpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSZWZlcmVuY2UobmFtZSkge1xuICAgICAgICBsZXQgbWUgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLnJlZmVyZW5jZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG1lLmNvbXBvbmVudC5kb3duKHtyZWZlcmVuY2U6IG5hbWV9KTtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIG1lLnJlZmVyZW5jZXNbbmFtZV0gPSBjb21wb25lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb25lbnQgfHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTdGF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5nZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2FtZUxldmVsT25seT1mYWxzZSB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBzdGF0ZVByb3ZpZGVyIGluc2lkZSB0aGUgY29tcG9uZW50IHBhcmVudCB0cmVlLFxuICAgICAqIGluIGNhc2UgdGhlcmUgaXMgbm9uZSBvbiB0aGUgc2FtZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW1lTGV2ZWxPbmx5PWZhbHNlXVxuICAgICAqL1xuICAgIGdldFN0YXRlUHJvdmlkZXIoc2FtZUxldmVsT25seT1mYWxzZSkge1xuICAgICAgICBsZXQge2NvbXBvbmVudH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2FtZUxldmVsT25seSA/IGNvbXBvbmVudC5zdGF0ZVByb3ZpZGVyIDogY29tcG9uZW50LmdldFN0YXRlUHJvdmlkZXIoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHNob3J0Y3V0IGZvciBhY2Nlc3Npbmcgc3RhdGUuUHJvdmlkZXIgYmFzZWQgZGF0YS5TdG9yZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge05lby5kYXRhLlN0b3JlfVxuICAgICAqL1xuICAgIGdldFN0b3JlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZVByb3ZpZGVyKCkuZ2V0U3RvcmUoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluc2lkZSB5b3VyIHZpZXcgY29udHJvbGxlcnMgYXMgYSBzdGFydGluZyBwb2ludCBpbiBjYXNlIHlvdSBuZWVkIHJlZmVyZW5jZXNcbiAgICAgKiAoaW5zdGVhZCBvZiB1c2luZyBvbkNvbnN0cnVjdGVkKCkgaW5zaWRlIHlvdXIgY29udHJvbGxlcilcbiAgICAgKi9cbiAgICBvbkNvbXBvbmVudENvbnN0cnVjdGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFdpbGwgZ2V0IGNhbGxlZCBieSBjb21wb25lbnQuQmFzZTogZGVzdHJveSgpIGluIGNhc2UgdGhlIGNvbXBvbmVudCBoYXMgYSByZWZlcmVuY2UgY29uZmlnXG4gICAgICogQHBhcmFtIHtOZW8uY29tcG9uZW50LkJhc2V9IGNvbXBvbmVudFxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShjb21wb25lbnQpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7cmVmZXJlbmNlc30gPSBtZSxcbiAgICAgICAgICAgIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSByZWZlcmVuY2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVmZXJlbmNlc1trZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZS5nZXRQYXJlbnQoKT8ucmVtb3ZlUmVmZXJlbmNlKGNvbXBvbmVudClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBzaG9ydGN1dFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgc2V0U3RhdGUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmdldFN0YXRlUHJvdmlkZXIoKS5zZXREYXRhKC4uLmFyZ3MpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOZW8uc2V0dXBDbGFzcyhDb21wb25lbnQpO1xuIiwiaW1wb3J0IENvbG9yTGlzdCBmcm9tICcuLi8uLi9saXN0L0NvbG9yLm1qcydcbmltcG9ydCBDb21ib0JveCAgZnJvbSAnLi9Db21ib0JveC5tanMnO1xuaW1wb3J0IFZEb21VdGlsICBmcm9tICcuLi8uLi91dGlsL1ZEb20ubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmZvcm0uZmllbGQuQ29sb3JcbiAqIEBleHRlbmRzIE5lby5mb3JtLmZpZWxkLkNvbWJvQm94XG4gKi9cbmNsYXNzIENvbG9yIGV4dGVuZHMgQ29tYm9Cb3gge1xuICAgIHN0YXRpYyBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmZvcm0uZmllbGQuQ29sb3InXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5mb3JtLmZpZWxkLkNvbG9yJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbG9yZmllbGQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG50eXBlOiAnY29sb3JmaWVsZCcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gYmFzZUNscz1bJ25lby1jb2xvcmZpZWxkJywnbmVvLWNvbWJvYm94JywnbmVvLXBpY2tlcmZpZWxkJywnbmVvLXRleHRmaWVsZCddXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlQ2xzOiBbJ25lby1jb2xvcmZpZWxkJywgJ25lby1jb21ib2JveCcsICduZW8tcGlja2VyZmllbGQnLCAnbmVvLXRleHRmaWVsZCddLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEuTW9kZWwgZmllbGQgd2hpY2ggY29udGFpbnMgdGhlIGNvbG9yIHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gY29sb3JGaWVsZD0nbmFtZSdcbiAgICAgICAgICovXG4gICAgICAgIGNvbG9yRmllbGQ6ICduYW1lJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJyaWRlIHRoZSBmb3JtYXR0ZXIgdG8gYXBwbHkgYSBjdXN0b20gYmFja2dyb3VuZC1jb2xvciBzdHlsaW5nLlxuICAgICAgICAgKiBFLmcuIHVzaW5nIENTUyB2YXJzIGZvciBkaWZmZXJlbnQgdGhlbWVzXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBjb2xvckZpZWxkPShzY29wZSxkYXRhKT0+ZGF0YVtzY29wZS5jb2xvckZpZWxkXVxuICAgICAgICAgKi9cbiAgICAgICAgY29sb3JGb3JtYXR0ZXI6IChzY29wZSxkYXRhKSA9PiBkYXRhW3Njb3BlLmNvbG9yRmllbGRdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGxpc3RDb25maWdcbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb25maWc6IHtcbiAgICAgICAgICAgIG1vZHVsZSAgICAgICAgICAgIDogQ29sb3JMaXN0LFxuICAgICAgICAgICAgY29sb3JGaWVsZCAgICAgICAgOiAnQGNvbmZpZzpjb2xvckZpZWxkJyxcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0dGVyICAgIDogJ0Bjb25maWc6Y29sb3JGb3JtYXR0ZXInLFxuICAgICAgICAgICAgc2lsZW50U2VsZWN0VXBkYXRlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0KGNvbmZpZykge1xuICAgICAgICBzdXBlci5jb25zdHJ1Y3QoY29uZmlnKTtcblxuICAgICAgICBsZXQgbWUgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGlucHV0V3JhcHBlciA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbWUuZ2V0SW5wdXRXcmFwcGVySWQoKSk7XG5cbiAgICAgICAgaW5wdXRXcmFwcGVyLnZkb20uY24udW5zaGlmdCh7XG4gICAgICAgICAgICBjbHMgIDogJ25lby1jb2xvcicsXG4gICAgICAgICAgICBpZCAgIDogbWUuZ2V0Q29sb3JJbmRpY2F0b3JJZCgpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG1lLmdldENvbG9yKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWUudXBkYXRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHZhbHVlIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xudWxsfSBvbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRGaWx0ZXI9ZmFsc2VdXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBwcmV2ZW50RmlsdGVyPWZhbHNlKSB7XG4gICAgICAgIGxldCBtZSAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb2xvckluZGljYXRvciA9IFZEb21VdGlsLmZpbmQobWUudmRvbSwgbWUuZ2V0Q29sb3JJbmRpY2F0b3JJZCgpKT8udmRvbSxcbiAgICAgICAgICAgIHtsaXN0LCByZWNvcmR9ID0gbWUsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbCA9IG1lLmxpc3Q/LnNlbGVjdGlvbk1vZGVsO1xuXG4gICAgICAgIGlmIChjb2xvckluZGljYXRvcikge1xuICAgICAgICAgICAgY29sb3JJbmRpY2F0b3Iuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbWUuZ2V0Q29sb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWw/LnNlbGVjdChsaXN0LmdldEl0ZW1JZChyZWNvcmRbbWUuc3RvcmUua2V5UHJvcGVydHldKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGVsPy5kZXNlbGVjdEFsbCh0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHN1cGVyIGNhbGwgd2lsbCB0cmlnZ2VyIHRoZSB2ZG9tIHVwZGF0ZVxuICAgICAgICBzdXBlci5hZnRlclNldFZhbHVlKHZhbHVlLCBvbGRWYWx1ZSwgcHJldmVudEZpbHRlcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbG9yKCkge1xuICAgICAgICBsZXQgbWUgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICB7aW5wdXRWYWx1ZSwgdmFsdWV9ID0gbWU7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gbWUuY29sb3JGb3JtYXR0ZXIobWUsIHZhbHVlKSA6IG1lLmZvcmNlU2VsZWN0aW9uID8gbnVsbCA6IGlucHV0VmFsdWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbG9ySW5kaWNhdG9ySWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fY29sb3ItaW5kaWNhdG9yYFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblNlbGVjdFBvc3RMYXN0SXRlbSgpIHtcbiAgICAgICAgbGV0IHtsaXN0fSA9IHRoaXMsXG4gICAgICAgICAgICBpbmRleCAgPSBsaXN0LnN0b3JlLmdldENvdW50KCkgLSAxO1xuXG4gICAgICAgIGxpc3QudmRvbS5jbltpbmRleF0gPSBsaXN0LmNyZWF0ZUl0ZW0obGlzdC5zdG9yZS5nZXRBdChpbmRleCksIGluZGV4KTtcblxuICAgICAgICBzdXBlci5vblNlbGVjdFBvc3RMYXN0SXRlbSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uU2VsZWN0UHJlRmlyc3RJdGVtKCkge1xuICAgICAgICBsZXQge2xpc3R9ID0gdGhpcztcblxuICAgICAgICBsaXN0LnZkb20uY25bMF0gPSBsaXN0LmNyZWF0ZUl0ZW0obGlzdC5zdG9yZS5nZXRBdCgwKSwgMCk7XG5cbiAgICAgICAgc3VwZXIub25TZWxlY3RQcmVGaXJzdEl0ZW0oKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29sb3IpO1xuIiwiaW1wb3J0IExpc3QgZnJvbSAnLi9CYXNlLm1qcyc7XG5cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBsaXN0cyB3aGljaCB3aWxsIHVzZSBjb21wb25lbnQgYmFzZWQgbGlzdCBpdGVtc1xuICogQGNsYXNzIE5lby5saXN0LkNvbXBvbmVudFxuICogQGV4dGVuZHMgTmVvLmxpc3QuQmFzZVxuICovXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBMaXN0IHtcbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby5saXN0LkNvbXBvbmVudCdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmxpc3QuQ29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2NvbXBvbmVudC1saXN0J1xuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBudHlwZTogJ2NvbXBvbmVudC1saXN0JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge05lby5jb21wb25lbnQuQmFzZVtdfG51bGx9IGl0ZW1zPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiBudWxsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBhcHBOYW1lIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRBcHBOYW1lKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBzdXBlci5hZnRlclNldEFwcE5hbWUodmFsdWUsIG9sZFZhbHVlKTtcblxuICAgICAgICB2YWx1ZSAmJiB0aGlzLml0ZW1zPy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5hcHBOYW1lID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIHdpbmRvd0lkIGNvbmZpZyBnb3QgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8bnVsbH0gb2xkVmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWZ0ZXJTZXRXaW5kb3dJZCh2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgIHZhbHVlICYmIHRoaXMuaXRlbXM/LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLndpbmRvd0lkID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koLi4uYXJncykge1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zIHx8IFtdO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmRlc3Ryb3koKVxuICAgICAgICB9KTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb21wb25lbnRJZChpbmRleCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH1fXyR7aW5kZXh9X19jb21wb25lbnRgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSByZWNvcmRJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0SXRlbUlkKHJlY29yZElkKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkfV9fJHt0aGlzLnN0b3JlLmluZGV4T2YocmVjb3JkSWQpfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdm5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfSBpdGVtSWRcbiAgICAgKi9cbiAgICBnZXRJdGVtUmVjb3JkSWQodm5vZGVJZCkge1xuICAgICAgICBsZXQgaXRlbUlkID0gdm5vZGVJZC5zcGxpdCgnX18nKVsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0QXQocGFyc2VJbnQoaXRlbUlkKSlbdGhpcy5nZXRLZXlQcm9wZXJ0eSgpXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5pdGVtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucHJldmlvdXNJdGVtc1xuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IGRhdGEuc2NvcGVcbiAgICAgKi9cbiAgICBvblN0b3JlU29ydChkYXRhKSB7XG4gICAgICAgIHRoaXMuc29ydEl0ZW1zKGRhdGEpO1xuICAgICAgICBzdXBlci5vblN0b3JlU29ydChkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YS5pdGVtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGRhdGEucHJldmlvdXNJdGVtc1xuICAgICAqIEBwYXJhbSB7TmVvLmRhdGEuU3RvcmV9IGRhdGEuc2NvcGVcbiAgICAgKi9cbiAgICBzb3J0SXRlbXMoZGF0YSkge1xuICAgICAgICBsZXQgbWUgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgbmV3SXRlbXMgPSBbXSxcbiAgICAgICAgICAgIGZyb21JbmRleCwga2V5LCBwcmV2aW91c0tleXM7XG5cbiAgICAgICAgaWYgKG1lLml0ZW1zKSB7XG4gICAgICAgICAgICBtZS5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2lsZW50KHtpZDogbnVsbH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAga2V5ICAgICAgICAgID0gbWUuZ2V0S2V5UHJvcGVydHkoKTtcbiAgICAgICAgICAgIHByZXZpb3VzS2V5cyA9IGRhdGEucHJldmlvdXNJdGVtcy5tYXAoZSA9PiBlW2tleV0pO1xuXG4gICAgICAgICAgICBkYXRhLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgZnJvbUluZGV4ID0gcHJldmlvdXNLZXlzLmluZGV4T2YoaXRlbVtrZXldKTtcbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKG1lLml0ZW1zW2Zyb21JbmRleF0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWUudXBkYXRlRGVwdGggPSAtMTtcbiAgICAgICAgICAgIG1lLml0ZW1zID0gbmV3SXRlbXNcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmVvLnNldHVwQ2xhc3MoQ29tcG9uZW50KTtcbiIsImltcG9ydCBCdXR0b24gICAgZnJvbSAnLi4vYnV0dG9uL0Jhc2UubWpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vY29udGFpbmVyL0Jhc2UubWpzJztcbmltcG9ydCBMYWJlbCAgICAgZnJvbSAnLi4vY29tcG9uZW50L0xhYmVsLm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLnRvb2xiYXIuQmFzZVxuICogQGV4dGVuZHMgTmVvLmNvbnRhaW5lci5CYXNlXG4gKi9cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHZhbHVlcyBmb3IgZG9ja1xuICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBkb2NrUG9zaXRpb25zPVsndG9wJywncmlnaHQnLCdib3R0b20nLCdsZWZ0JywgbnVsbF1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGRvY2tQb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsIG51bGxdXG5cbiAgICBzdGF0aWMgY29uZmlnID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBjbGFzc05hbWU9J05lby50b29sYmFyLkJhc2UnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby50b29sYmFyLkJhc2UnLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBudHlwZT0ndG9vbGJhcidcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICd0b29sYmFyJyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBiYXNlQ2xzPVsnbmVvLXRvb2xiYXInXVxuICAgICAgICAgKi9cbiAgICAgICAgYmFzZUNsczogWyduZW8tdG9vbGJhciddLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGRvY2tfPW51bGxcbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBkb2NrXzogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH0gaXRlbURlZmF1bHRzPXtudHlwZTonYnV0dG9uJ31cbiAgICAgICAgICogQHJlYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtRGVmYXVsdHM6IHtcbiAgICAgICAgICAgIG50eXBlOiAnYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fSBsYXlvdXQ9e250eXBlOidmbGV4Ym94JyxhbGlnbjonY2VudGVyJyxkaXJlY3Rpb246ICdyb3cnLCBwYWNrOidzdGFydCd9XG4gICAgICAgICAqIEByZWFjdGl2ZVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICBudHlwZSAgICA6ICdmbGV4Ym94JyxcbiAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGRvY2sgY29uZmlnIGdvdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFmdGVyU2V0RG9jayh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiAhb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAge2Nsc30gICAgICAgICA9IG1lLFxuICAgICAgICAgICAgZG9ja1Bvc2l0aW9ucyA9IG1lLmdldFN0YXRpY0NvbmZpZygnZG9ja1Bvc2l0aW9ucycpLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnICA9IG1lLmdldExheW91dENvbmZpZygpO1xuXG4gICAgICAgIGRvY2tQb3NpdGlvbnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAga2V5ICE9PSBudWxsICYmIE5lb0FycmF5LnRvZ2dsZShjbHMsICduZW8tZG9jay0nICsga2V5LCBrZXkgPT09IHZhbHVlKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW1lLmxheW91dCkge1xuICAgICAgICAgICAgbGF5b3V0Q29uZmlnLm50eXBlID0gJ2ZsZXhib3gnO1xuICAgICAgICAgICAgbWUuc2V0KHtjbHMsIGxheW91dDogbGF5b3V0Q29uZmlnfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmxheW91dC5zZXQobGF5b3V0Q29uZmlnKTtcbiAgICAgICAgICAgIG1lLmNscyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgbmV3IGRvY2sgcG9zaXRpb24gbWF0Y2hlcyBhIHZhbHVlIG9mIHRoZSBzdGF0aWMgZG9ja1Bvc2l0aW9ucyBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBiZWZvcmVTZXREb2NrKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZXRFbnVtVmFsdWUodmFsdWUsIG9sZFZhbHVlLCAnZG9jaycsICdkb2NrUG9zaXRpb25zJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNyZWF0ZUl0ZW1zKCkge1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLl9pdGVtcztcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUl0ZW1zKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF5b3V0IGNvbmZpZyBkZXBlbmRpbmcgb24gdGhpcy5kb2NrXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5b3V0Q29uZmlnXG4gICAgICovXG4gICAgZ2V0TGF5b3V0Q29uZmlnKCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLFxuICAgICAgICAgICAgbGF5b3V0Q29uZmlnO1xuXG4gICAgICAgIGlmIChtZS5kb2NrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1lLmRvY2spIHtcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdjb2x1bW4tcmV2ZXJzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGxheW91dENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduICAgIDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFjayAgICAgOiAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5b3V0Q29uZmlnIHx8IG1lLmxheW91dFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gaXRlbSBvciBhcnJheSBvZiBpdGVtcyBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge05lby5jb21wb25lbnQuQmFzZXxOZW8uY29tcG9uZW50LkJhc2VbXX1cbiAgICAgKi9cbiAgICBpbnNlcnQoaW5kZXgsIGl0ZW0sIHNpbGVudD1mYWxzZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ubWFwKGl0ZW0gPT4gdGhpcy5yZXBsYWNlU3BhY2VyKGl0ZW0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMucmVwbGFjZVNwYWNlcihpdGVtKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydChpbmRleCwgaXRlbSwgc2lsZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gaXRlbVxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9XG4gICAgICovXG4gICAgcmVwbGFjZVNwYWNlcihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtID09PSAnLT4nID8ge21vZHVsZTogQ29tcG9uZW50LCBmbGV4OiAxfSA6IGl0ZW1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5lby5zZXR1cENsYXNzKFRvb2xiYXIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==